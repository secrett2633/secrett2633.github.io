---
title: "[Superseded] PEP 367 - New Super"
excerpt: "Python Enhancement Proposal 367: 'New Super'에 대한 한국어 번역입니다."
categories:
  - Python
  - PEP
tags:
  - Python
  - PEP
  - Translation
permalink: /python/pep/367/
toc: true
toc_sticky: true
date: 2025-09-26 20:50:02+0900
last_modified_at: 2025-09-26 20:50:02+0900
published: true
---
> **원문 링크:** [PEP 367 - New Super](https://peps.python.org/pep-0367/)
>
> **상태:** Superseded | **유형:** Standards Track | **작성일:** 28-Apr-2007

PEP 367 – New Super

## 개요
이 문서는 Python Enhancement Proposal (PEP) 367에 대한 번역 및 정리입니다. 이 PEP는 `super()` 타입의 새로운 구문 설탕(syntactic sugar) 사용법을 제안합니다. 이는 메서드가 정의된 클래스와 현재 메서드를 호출하는 인스턴스(또는 클래스 메서드의 경우 클래스 객체)에 자동으로 바인딩되는 `super` 인스턴스를 생성하는 것을 목표로 합니다.

**참고:** 이 PEP는 PEP 3135로 번호가 변경되었습니다. 아래 내용은 이전 번호로 제출된 최종 버전입니다.

### 핵심 제안
기존의 `super(Foo, self).foo(1, 2)` 형태 대신 `super.foo(1, 2)`와 같은 간결한 사용법을 제안합니다.

또한, 현재의 `__builtin__.super`는 `__builtin__.__super__`로 별칭이 부여되고(Python 3.0에서는 제거 예정), `super`에 값을 할당하는 것은 `SyntaxError`를 발생시키도록 제안됩니다.

## 도입 배경 (Rationale)
`super()`의 현재 사용법은 클래스와 인스턴스를 명시적으로 전달해야 하므로, DRY (Don't Repeat Yourself) 원칙에 위배됩니다. 이는 클래스 이름 변경을 어렵게 만들고, 많은 개발자에게 불편한 점으로 여겨집니다.

## 상세 명세 (Specification)

### 용어 설명
*   **super type**: `super`라는 내장 타입을 의미합니다.
*   **super instance**: `super` 타입의 인스턴스로, 클래스 및 해당 클래스의 인스턴스와 연관됩니다.

### 새로운 `super`의 동작
새로운 `super`의 의미 체계는 Python 2.5와의 하위 호환성을 보장하지 않으므로, `from __future__ import new_super`를 통해 활성화해야 합니다.

`__builtin__.super`는 `__builtin__.__super__`로 별칭이 부여되며, 이는 새로운 `super` 의미 체계가 활성화되었는지 여부와 관계없이 적용됩니다. Python 3.0에서는 `__builtin__.super` 이름이 제거될 예정입니다.

새로운 `super` 사용법에서는 `super` 인스턴스를 명시적으로 생성하지 않고도 MRO (Method Resolution Order) 상 다음 클래스의 메서드를 호출할 수 있습니다 (기존 방식은 `__super__`를 통해 여전히 지원됩니다). 모든 함수는 `super`라는 암시적 로컬 변수를 가지게 됩니다. 이 변수는 일반 로컬 변수와 동일하게 작동하지만 다음 예외가 있습니다.

*   `super` 이름에 값을 할당하면 컴파일 시 `SyntaxError`가 발생합니다.
*   `super` 이름을 사용하는 `static method` 또는 일반 함수를 호출하면 런타임 시 `TypeError`가 발생합니다.

`super` 이름을 사용하거나 `super` 이름을 사용하는 내부 함수를 가진 모든 함수는 다음과 같은 프리앰블(preamble)을 포함합니다.

```python
super = __builtin__.__super__(<class>, <instance>)
```
여기서 `<class>`는 메서드가 정의된 클래스이며, `<instance>`는 메서드의 첫 번째 매개변수입니다 (일반적으로 인스턴스 메서드의 경우 `self`, 클래스 메서드의 경우 `cls`). `static method` 및 일반 함수의 경우 `<class>`는 `None`이 되어 프리앰블 중에 `TypeError`가 발생합니다.

**참고:** `super`와 `__super__`의 관계는 `import`와 `__import__`의 관계와 유사합니다.

## 미해결 문제 (Open Issues)

### 사용할 클래스 객체 결정
메서드를 정의하는 클래스와 연결하는 정확한 메커니즘은 이 PEP에 명시되어 있지 않으며, 최대 성능을 위해 선택되어야 합니다. CPython의 경우, 클래스 인스턴스는 함수 객체의 C 레벨 변수에 `NULL`(클래스의 일부 아님), `Py_None`(static method) 또는 클래스 객체(인스턴스 또는 class method) 중 하나로 바인딩되는 방식으로 유지될 것을 제안합니다.

### `super`가 실제로 키워드가 되어야 하는가?
이 제안에 따라 `super`는 `None`이 키워드인 것과 동일한 수준으로 키워드가 됩니다. `super` 이름에 대한 추가적인 제한은 구현을 단순화할 수 있지만, 일부는 `super`의 실제 키워드화를 반대합니다. 가장 간단한 해결책이 종종 올바른 해결책이며, 필요하지 않은 경우 언어에 추가적인 키워드를 추가하지 않는 것이 가장 간단한 해결책일 수 있습니다. 그러나 다른 미해결 문제를 해결할 수도 있습니다.

## 해결된 문제 (Closed Issues)

### `__call__` 속성과 함께 사용되는 `super`
기존 방식으로 `super` 인스턴스를 인스턴스화할 때 `__call__` 속성을 찾아 MRO에서 다음 클래스로의 자동 `super` 조회를 시도할 수 있다는 문제가 제기되었습니다. 그러나 이는 객체를 호출할 때 객체 타입에서 직접 `__call__` 메서드를 찾기 때문에 사실이 아닌 것으로 밝혀졌습니다. `__builtin__.super`가 `__builtin__.__super__`로 이름이 변경되면서 이 문제는 완전히 사라집니다.

## 참조 구현 (Reference Implementation)
위 명세는 Python만으로는 완전히 구현할 수 없습니다. 참조 구현은 다음 차이점을 가집니다.

*   새로운 `super` 의미 체계는 바이트코드 해킹(bytecode hacking)을 사용하여 구현됩니다.
*   `super`에 대한 할당이 `SyntaxError`를 발생시키지 않습니다.
*   클래스는 `autosuper_meta` 메타클래스를 사용하거나 `autosuper` 기본 클래스에서 상속받아야 새로운 `super` 의미 체계를 얻을 수 있습니다.
*   `super`는 암시적인 로컬 변수가 아닙니다. 특히 내부 함수가 `super` 인스턴스를 사용하려면 메서드 내에 `super = super` 형태의 할당이 있어야 합니다.

참조 구현은 Python 2.5 이상에서 실행된다고 가정합니다.

## 대안 제안 (Alternative Proposals)

### 변경 없음 (No Changes)
기존 방식을 유지하는 것이 항상 매력적이지만, `super` 사용법에 대한 변경 요구는 오랫동안 있어왔으며, 다음과 같은 정당한 이유가 있습니다.

*   클래스 이름과의 결합 해제 (더 이상 올바른 클래스에 바인딩되지 않을 수도 있음)
*   더 간결하고 깔끔한 `super` 호출

### `super` 타입에 동적 속성 추가 (Dynamic attribute on super type)
`super` 타입에 동적 속성 조회를 추가하여 적절한 클래스 및 인스턴스 매개변수를 자동으로 결정합니다. 이 제안은 프로토타입 구현 외에는 적합하지 않은 `sys._getframe()`에 의존합니다.

### `super(__this_class__, self)`
이 제안은 `__this_class__` PEP의 수용에 의존합니다. `__this_class__`는 항상 사용되는 클래스에 바인딩되는 특별한 이름을 제안하며, 이것이 수용되면 클래스 이름 대신 `__this_class__`를 사용하여 이름 바인딩 문제를 해결할 수 있습니다.

### `self.__super__.foo(*args)`
`__super__` 속성은 이 PEP의 여러 곳에서 언급되며, 완전한 해결책의 후보가 될 수 있습니다. 그러나 이중 밑줄 이름은 일반적으로 내부 구현 세부 사항이며 일상적인 코드에서 멀리하려는 경향이 있습니다.

### `super(self, *args)` 또는 `__super__(self, *args)`
이 해결책은 타입 표시 문제만 해결하며, 이름이 다른 `super` 메서드를 처리하지 않고 인스턴스 이름을 명시해야 합니다. 다른 메서드 이름에 적용할 수 없어 유연성이 떨어집니다.

### `super.foo(self, *args)`
이 변형은 적절한 인스턴스를 찾는 문제를 해결하며, 만약 어떤 대안이 각광받는다면 이것이 되기를 바라는 제안입니다.

### `super` 또는 `super()`
이 제안은 다른 이름, 시그니처, 또는 다른 클래스나 인스턴스에 적용할 여지를 남기지 않습니다.

### `super(*p, **kw)`
`super(*p, **kw)`를 직접 호출하는 것이 현재 실행 중인 메서드와 동일한 이름을 가진 `super` 객체의 메서드를 호출하는 것과 동일하다는 제안이 있었습니다. 그러나 구현 및 스타일 문제로 인해 Guido는 KISS (Keep It Simple Stupid) 원칙에 따라 이 PEP에서 제외해야 한다고 제안했습니다.

## 변경 이력 (History)
*   **2007년 4월 29일**: 제목이 "Super As A Keyword"에서 "New Super"로 변경되었습니다. 언어가 업데이트되고 혼란스러운 부분에 대한 명확화를 위해 용어 섹션이 추가되었습니다. 참조 구현 및 기록 섹션이 추가되었습니다.
*   **2007년 5월 6일**: Tim Delaney가 python-3000 및 python-dev 메일링 리스트에서의 논의를 반영하여 업데이트했습니다.

## 참고 자료 (References)
*   Fixing super anyone?
*   PEP 3130: Access to Module/Class/Function Currently Being Defined (this)

## 저작권 (Copyright)
이 문서는 공개 도메인에 있습니다.

> ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.