---
title: "[Final] PEP 3102 - Keyword-Only Arguments"
excerpt: "Python Enhancement Proposal 3102: 'Keyword-Only Arguments'에 대한 한국어 번역입니다."
categories:
  - Python
  - PEP
tags:
  - Python
  - PEP
  - Translation
permalink: /python/pep/3102/
toc: true
toc_sticky: true
date: 2025-09-27 14:16:28+0900
last_modified_at: 2025-09-27 14:16:28+0900
published: true
---
> **원문 링크:** [PEP 3102 - Keyword-Only Arguments](https://peps.python.org/pep-3102/)
>
> **상태:** Final | **유형:** Standards Track | **작성일:** 22-Apr-2006

## PEP 3102 – 키워드 전용 인자 (Keyword-Only Arguments)

### 초록 (Abstract)
이 PEP는 함수 인자가 명명된 매개변수 슬롯에 할당되는 방식에 대한 변경을 제안합니다. 특히 "키워드 전용 인자(keyword-only arguments)"의 선언을 가능하게 하는데, 이는 반드시 키워드를 통해서만 제공될 수 있으며 위치 인자(positional argument)에 의해 자동으로 채워지지 않는 인자들을 의미합니다.

### 배경 (Rationale)
현재 Python의 함수 호출 패러다임은 인자를 위치(position) 또는 키워드(keyword)로 지정할 수 있도록 합니다. 인자는 명시적으로 이름으로 채워지거나, 암시적으로 위치에 의해 채워질 수 있습니다.

함수가 가변적인 수의 인자를 받는 것이 바람직한 경우가 많습니다. Python 언어는 `varargs` 문법(`*name`)을 사용하여 이를 지원하며, 이는 '남은' 인자들을 튜플(tuple) 형태로 `varargs` 매개변수로 전달하도록 지정합니다.

이러한 방식의 한계점은 현재 모든 일반 인자(regular argument) 슬롯이 `vararg` 슬롯보다 먼저 채워져야 한다는 것입니다.

이것이 항상 바람직한 것은 아닙니다. 가변적인 수의 인자를 받으면서도 키워드 인자 형태의 하나 이상의 '옵션'을 받는 함수를 쉽게 상상할 수 있습니다. 현재 이를 수행하는 유일한 방법은 `varargs` 인자와 '키워드 딕셔너리' 인자(`**kwargs`)를 모두 정의한 다음, 딕셔너리에서 원하는 키워드를 수동으로 추출하는 것입니다.

### 명세 (Specification)

문법적으로 제안된 변경 사항은 상당히 간단합니다.

첫 번째 변경 사항은 `varargs` 인자 뒤에 일반 인자가 나타날 수 있도록 허용하는 것입니다:

```python
def sortwords(*wordlist, case_sensitive=False):
    ...
```
이 함수는 여러 개의 위치 인자를 받을 수 있으며, `case_sensitive`라는 키워드 옵션도 받습니다. 이 옵션은 위치 인자에 의해 채워지지 않고, 반드시 이름으로 명시적으로 지정되어야 합니다.

키워드 전용 인자는 기본값(default value)을 가질 필요는 없습니다. Python은 모든 인자가 값에 바인딩되어야 하며, 키워드 전용 인자에 값을 바인딩하는 유일한 방법은 키워드를 통한 것이기 때문에, 이러한 인자들은 '필수 키워드(required keyword)' 인자가 됩니다. 이러한 인자들은 호출자에 의해 제공되어야 하며, 키워드를 통해 제공되어야 합니다.

두 번째 문법적 변경 사항은 `varargs` 인자의 이름 생략을 허용하는 것입니다. 이는 `varargs` 인자를 받지 않는 함수에 대해 키워드 전용 인자를 허용하는 것을 의미합니다:

```python
def compare(a, b, *, key=None):
    ...
```
이 변경 사항의 배경은 다음과 같습니다. 여러 위치 인자와 키워드 인자를 받는 함수를 가정해 봅시다:

```python
def compare(a, b, key=None):
    ...
```
이제 `key`를 키워드 전용 인자로 만들고 싶다고 가정해 봅시다. 위 문법에서, 키워드 인자 바로 앞에 `varargs` 인자를 추가하여 이를 달성할 수 있습니다:

```python
def compare(a, b, *ignore, key=None):
    ...
```
불행히도, `ignore` 인자는 호출자가 제공했을 수 있는 모든 잘못된 위치 인자도 흡수하게 됩니다. 원치 않는 인자들이 오류를 발생시키도록 하는 것이 더 바람직하므로, 다음과 같이 할 수 있습니다:

```python
def compare(a, b, *ignore, key=None):
    if ignore: # If ignore is not empty
        raise TypeError
```
편리한 단축키로, 단순히 `ignore` 이름을 생략하여 '이 지점 이후로 어떠한 위치 인자도 허용하지 않는다'는 의미를 나타낼 수 있습니다.

(참고: 대체 문법 제안에 대한 많은 논의 끝에, BDFL (Benevolent Dictator For Life)은 위치 매개변수의 끝을 나타내는 이 '단일 별표' 문법에 찬성했습니다.)

### 함수 호출 동작 (Function Calling Behavior)

함수가 호출될 때, 입력 인자는 다음과 같이 형식 매개변수(formal parameters)에 할당됩니다:

각 형식 매개변수에는 해당 매개변수에 할당된 인자의 값을 담는 데 사용될 슬롯(slot)이 있습니다. 값이 할당된 슬롯은 '채워짐(filled)'으로 표시됩니다. 아직 값이 할당되지 않은 슬롯은 '비어 있음(empty)'으로 간주됩니다. 초기에는 모든 슬롯이 비어 있는 것으로 표시됩니다.

위치 인자가 먼저 할당되고, 이어서 키워드 인자가 할당됩니다.

**각 위치 인자에 대해:**
*   첫 번째로 비어 있는 매개변수 슬롯에 인자를 바인딩하려고 시도합니다.
*   슬롯이 `vararg` 슬롯이 아니면, 해당 슬롯을 '채워짐'으로 표시합니다.
*   다음으로 비어 있는 슬롯이 `vararg` 슬롯이고 이름이 없으면 오류입니다.
*   그렇지 않고 다음으로 비어 있는 슬롯이 `vararg` 슬롯이면, 남아 있는 모든 비(非)키워드 인자는 `vararg` 슬롯에 배치됩니다.

**각 키워드 인자에 대해:**
*   키워드와 동일한 이름을 가진 매개변수가 있으면, 인자 값이 해당 매개변수 슬롯에 할당됩니다. 그러나 매개변수 슬롯이 이미 채워져 있으면 오류입니다.
*   그렇지 않고 '키워드 딕셔너리' 인자(`**kwargs`)가 있으면, 해당 인자는 키워드 이름을 딕셔너리 키로 사용하여 딕셔너리에 추가됩니다. 단, 해당 키로 이미 항목이 있는 경우에는 오류입니다.
*   그렇지 않고 키워드 딕셔너리가 없고 일치하는 이름의 매개변수도 없으면 오류입니다.

**마지막으로:**
*   `vararg` 슬롯이 아직 채워지지 않았다면, 빈 튜플을 그 값으로 할당합니다.
*   남아 있는 각 빈 슬롯에 대해: 해당 슬롯에 기본값이 있으면 기본값으로 슬롯을 채웁니다. 기본값이 없으면 오류입니다.

현재 Python 구현에 따라, 발생하는 모든 오류는 `TypeError`를 발생시켜 알립니다.

### 하위 호환성 (Backwards Compatibility)

이 PEP에서 지정된 함수 호출 동작은 기존 동작의 상위 집합입니다. 즉, 기존 프로그램은 계속 작동할 것으로 예상됩니다.

### 저작권 (Copyright)

이 문서는 퍼블릭 도메인에 공개되었습니다.

> ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.