<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js"/><script src="/secrett2633.github.io/_next/static/chunks/fd9d1056-62aaf4b921c84028.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/23-ca4408d024135d8d.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/main-app-fa660020ba1e0b6e.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/231-c4b666723e6aae68.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/layout-8808afda01b7a1b7.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="next-size-adjust"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/secrett2633.github.io/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_9012cf layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/secrett2633.github.io">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Deferred] PEP 316 - Programming by Contract for Python</h1><div class="page__meta"><time dateTime="2025-09-26 18:27:40+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0316/">PEP 316 - Programming by Contract for Python</a></p>
<p><strong>상태:</strong> Deferred | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 02-May-2003</p>
</blockquote>
<h2>PEP 316 – Python을 위한 계약 기반 프로그래밍 (Programming by Contract for Python)</h2>
<h3>개요</h3>
<p>이 문서는 Python에서 "계약 기반 프로그래밍(Programming by Contract, DBC)"을 구현하는 방법을 설명하는 제안입니다. Eiffel의 Design By Contract™가 가장 널리 알려진 계약 기반 프로그래밍의 예시입니다.</p>
<p>계약 기반 프로그래밍은 클래스 및 모듈에 대한 불변식(invariant), 그리고 함수와 메서드에 대한 사전 조건(pre-condition) 및 사후 조건(post-condition) 표현식을 포함하도록 언어를 확장합니다. 이 표현식들(계약)은 <code>assert</code>와 유사하게, 거짓일 경우 프로그램 실행이 중단되며, 런타임 검사는 일반적으로 디버깅 중에만 활성화됩니다. 계약은 단순히 <code>assert</code>를 사용하는 것보다 높은 수준이며, 일반적으로 문서화에 포함됩니다.</p>
<p><strong>상태:</strong> 연기됨 (Deferred)
<strong>작성자:</strong> Terence Way
<strong>생성일:</strong> 2003년 5월 2일</p>
<h3>동기 (Motivation)</h3>
<p>Python에는 이미 <code>assert</code> 문이 있는데, 왜 계약과 같은 것을 지원하기 위해 언어에 추가적인 기능을 도입해야 할까요? 가장 큰 두 가지 이유는 다음과 같습니다.</p>
<ol>
<li><strong>더 나은, 더 정확한 문서화:</strong> 복잡한 모듈이나 클래스는 종종 제대로 문서화되지 않는 경우가 많습니다. 제공된 문서는 특정 모듈이나 클래스를 사용하도록 설득하기에는 충분할 수 있지만, 실제 디버깅이 시작되면 프로그래머는 거의 항상 소스 코드를 읽어야 합니다. 계약은 <code>doctest</code> 모듈이 제공하는 훌륭한 예시를 확장합니다. 문서는 프로그래머가 읽을 수 있으며, 실행 가능한 테스트가 포함되어 있습니다.</li>
<li><strong>더 쉬운 테스팅:</strong> 계약을 통한 코드 테스트도 더 쉬워집니다. 포괄적으로 작성된 계약은 곧 유닛 테스트(unit tests)와 동일합니다. 테스트는 사전 조건의 모든 범위를 실행하며, 사후 조건이 위반되면 실패합니다. 이론적으로 올바르게 명시된 함수는 완전히 무작위로 테스트될 수 있습니다.</li>
</ol>
<p>왜 이것을 언어에 추가해야 할까요? 여러 구현을 두거나 프로그래머가 자체적인 <code>assert</code>를 구현하도록 두지 않는 이유는 무엇일까요? 그 답은 <strong>상속(inheritance)</strong> 시 계약의 동작 때문입니다.</p>
<p>만약 Alice와 Bob이 서로 다른 <code>assert</code> 패키지를 사용한다고 가정해 봅시다. Alice가 <code>assert</code>로 보호되는 클래스 라이브러리를 만들었다면, Bob은 Alice의 라이브러리에서 클래스를 파생하여도 사후 조건 및 불변식의 올바른 검사를 기대할 수 없습니다. 만약 둘 다 동일한 <code>assert</code> 패키지를 사용한다면, Bob은 Alice의 메서드를 오버라이드(override)하더라도 Alice의 계약 <code>assert</code>에 대해 테스트할 수 있습니다. 이러한 <code>assert</code> 시스템이 존재하기에 가장 자연스러운 곳은 언어의 런타임 라이브러리입니다.</p>
<h3>명세 (Specification)</h3>
<p>모든 모듈 또는 클래스의 docstring은 <code>inv:</code> 키워드로 시작하는 줄로 표시된 불변식 계약을 포함할 수 있습니다. 콜론(:) 앞뒤의 공백은 무시됩니다. 콜론 뒤에는 같은 줄에 단일 표현식이 바로 오거나, <code>inv</code> 키워드보다 들여쓰기된 여러 줄의 표현식이 올 수 있습니다. 일반적인 Python의 암묵적/명시적 줄 연속 규칙이 적용됩니다. 하나의 docstring에 여러 개의 불변식 계약이 있을 수 있습니다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-python"># 상태 열거
START, CONNECTING, CONNECTED, CLOSING, CLOSED = range(5)

class conn:
    """A network connection
    inv: self.state in [START, CLOSED,  # 닫힌 상태
                        CONNECTING, CLOSING,  # 전환 상태
                        CONNECTED]
    inv: 0 &#x3C;= self.seqno &#x3C; 256
    """

class circbuf:
    """A circular buffer.
    inv: # 버퍼에 0에서 최대 항목까지 있을 수 있음
        0 &#x3C;= self.len &#x3C;= len(self.buf)
    inv: # g는 buf의 유효한 인덱스임
        0 &#x3C;= self.g &#x3C; len(self.buf)
    inv: # p도 buf의 유효한 인덱스임
        0 &#x3C;= self.p &#x3C; len(self.buf)
    inv: # get과 put 사이에 len개의 항목이 있음
        (self.p - self.g) % len(self.buf) == \
        self.len % len(self.buf)
    """
</code></pre>
<p>모듈 불변식은 모듈이 로드된 후, 그리고 모듈 내의 모든 <code>public</code> 함수의 진입 및 종료 시점에 <code>True</code>여야 합니다.
클래스 불변식은 <code>__init__</code> 함수가 반환된 후, <code>__del__</code> 함수의 진입 시점에, 그리고 클래스의 모든 <code>public</code> 메서드의 진입 및 종료 시점에 <code>True</code>여야 합니다. 클래스 불변식은 <code>self</code> 변수를 사용하여 인스턴스 변수에 접근해야 합니다.
메서드 또는 함수는 이름이 밑줄(<code>_</code>)로 시작하지 않거나, <code>__</code> (두 개의 밑줄)로 시작하고 끝나지 않는 경우 <code>public</code>으로 간주됩니다.</p>
<p>모든 함수나 메서드의 docstring은 위와 동일한 규칙에 따라 <code>pre</code> 키워드로 문서화된 사전 조건을 가질 수 있습니다. 사후 조건은 <code>post</code> 키워드 뒤에 선택적으로 변수 목록을 사용하여 문서화됩니다. 이 변수들은 함수 또는 메서드의 본문과 동일한 스코프(scope)에 있습니다. 이 목록은 함수/메서드가 수정할 수 있는 변수를 선언합니다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-python">class circbuf:
    def __init__(self, leng):
        """Construct an empty circular buffer.
        pre: leng > 0
        post[self]: self.is_empty()
            len(self.buf) == leng
        """
</code></pre>
<p><code>reStructuredText</code>를 사용하여 작성된 docstring을 지원하기 위해 단일 콜론(:) 대신 이중 콜론(::)을 사용할 수 있습니다. 예를 들어, 다음 두 docstring은 동일한 계약을 설명합니다.</p>
<pre><code>"""pre: leng > 0"""
"""pre:: leng > 0"""
</code></pre>
<p>사전 및 사후 조건의 표현식은 모듈 네임스페이스(namespace)에 정의됩니다. 즉, 클로저(closure) 변수를 제외하고 함수가 접근할 수 있는 거의 모든 변수에 접근할 수 있습니다.</p>
<p>사후 조건의 계약 표현식은 두 개의 추가 변수에 접근할 수 있습니다.</p>
<ul>
<li><code>__old__</code>: <code>post</code> 키워드 바로 뒤에 오는 변수 목록에서 선언된 값들의 얕은 복사본(shallow copies)으로 채워집니다.</li>
<li><code>__return__</code>: 함수 또는 메서드의 반환 값에 바인딩(bind)됩니다.</li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-python">class circbuf:
    def get(self):
        """Pull an entry from a non-empty circular buffer.
        pre: not self.is_empty()
        post[self.g, self.len]: __return__ == self.buf[__old__.self.g]
            self.len == __old__.self.len - 1
        """
</code></pre>
<p>모든 계약 표현식은 몇 가지 추가 편의 함수에 접근할 수 있습니다. 시퀀스의 진리 여부를 더 쉽게 평가하기 위해 <code>forall</code>과 <code>exists</code> 두 함수가 다음과 같이 정의됩니다.</p>
<pre><code class="language-python">def forall(a, fn = bool):
    """Return True only if all elements in a are true.
    >>> forall([])
    1
    >>> even = lambda x: x % 2 == 0
    >>> forall([2, 4, 6, 8], even)
    1
    >>> forall('this is a test'.split(), lambda x: len(x) == 4)
    0
    """
def exists(a, fn = bool):
    """Returns True if there is at least one true value in a.
    >>> exists([])
    0
    >>> exists('this is a test'.split(), lambda x: len(x) == 4)
    1
    """
</code></pre>
<p><strong>예시:</strong></p>
<pre><code class="language-python">def sort(a):
    """Sort a list.
    pre: isinstance(a, type(list))
    post[a]: # 배열 크기는 변경되지 않음
        len(a) == len(__old__.a)
        # 배열은 정렬되어 있음
        forall([a[i] >= a[i-1] for i in range(1, len(a))])
        # 모든 이전 요소가 여전히 배열에 있음
        forall(__old__.a, lambda e: __old__.a.count(e) == a.count(e))
    """
</code></pre>
<p>조건 평가를 더 쉽게 하기 위해 <code>implies</code> 함수가 정의됩니다. 두 인수를 사용하면 논리적 함의(<code>=></code>) 연산자와 유사합니다. 세 인수를 사용하면 C 언어의 조건부 표현식(<code>x?a:b</code>)과 유사합니다. 다음과 같이 정의됩니다.</p>
<ul>
<li><code>implies(False, a)</code> => <code>True</code></li>
<li><code>implies(True, a)</code> => <code>a</code></li>
<li><code>implies(False, a, b)</code> => <code>b</code></li>
<li><code>implies(True, a, b)</code> => <code>a</code></li>
</ul>
<p>함수 진입 시, 함수의 사전 조건이 검사됩니다. 사전 조건 중 하나라도 거짓이면 <code>AssertionError</code>가 발생합니다. 함수가 <code>public</code>인 경우, 클래스 또는 모듈의 불변식도 검사됩니다. <code>post</code>에 선언된 변수들의 복사본이 저장되고, 함수가 호출되며, 함수가 예외를 발생시키지 않고 종료되면 사후 조건이 검사됩니다.</p>
<h3>예외 (Exceptions)</h3>
<p>함수나 메서드가 예외를 발생시켜 종료하더라도 클래스/모듈 불변식은 검사됩니다 (사후 조건은 검사되지 않습니다).</p>
<p>실패한 모든 계약은 <code>ContractViolationError</code> 예외의 서브클래스(subclass)인 예외를 발생시키며, <code>ContractViolationError</code>는 <code>AssertionError</code> 예외의 서브클래스입니다. 실패한 사전 조건은 <code>PreconditionViolationError</code> 예외를 발생시키고, 실패한 사후 조건은 <code>PostconditionViolationError</code> 예외를, 실패한 불변식은 <code>InvariantViolationError</code> 예외를 발생시킵니다.</p>
<p><strong>클래스 계층 구조:</strong></p>
<pre><code>AssertionError
    ContractViolationError
        PreconditionViolationError
        PostconditionViolationError
        InvariantViolationError
        InvalidPreconditionError
</code></pre>
<p><code>InvalidPreconditionError</code>는 사전 조건이 불법적으로 강화될 때 발생합니다. 이는 상속 섹션에서 자세히 설명합니다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-python">try:
    some_func()
except contract.PreconditionViolationError:
    # 사전 조건 실패, 정상 처리
    pass
</code></pre>
<h3>상속 (Inheritance)</h3>
<p>클래스의 불변식은 모든 슈퍼클래스(super-classes)의 불변식을 포함합니다 (클래스 불변식은 슈퍼클래스 불변식과 AND 연산됩니다). 이 불변식들은 메서드 결정 순서(method-resolution order)로 검사됩니다.</p>
<p>메서드의 사후 조건 또한 오버라이드(override)된 모든 사후 조건을 포함합니다 (메서드 사후 조건은 오버라이드된 모든 메서드 사후 조건과 AND 연산됩니다).</p>
<p>오버라이딩하는 메서드의 사전 조건이 충족되면, 오버라이드된 메서드의 사전 조건은 무시될 수 있습니다. 그러나 오버라이딩하는 메서드의 사전 조건이 실패하면, 오버라이드된 모든 메서드의 사전 조건도 실패해야 합니다. 그렇지 않으면 <code>InvalidPreconditionError</code>라는 별도의 예외가 발생합니다. 이는 사전 조건을 약화시키는 것을 지원합니다.</p>
<p><strong>다소 억지스러운 예시:</strong></p>
<pre><code class="language-python">class SimpleMailClient:
    def send(self, msg, dest):
        """메시지를 목적지로 보냅니다.
        pre: self.is_open() # 열린 연결이 있어야 함
        """
    def recv(self):
        """읽지 않은 다음 메일 메시지를 가져옵니다. 메시지가 없으면 None을 반환합니다.
        pre: self.is_open() # 열린 연결이 있어야 함
        post: __return__ is None or isinstance(__return__, Message)
        """

class ComplexMailClient(SimpleMailClient):
    def send(self, msg, dest):
        """메시지를 목적지로 보냅니다. 현재 연결되어 있으면 메시지가 즉시 전송됩니다.
        그렇지 않으면 연결이 될 때까지 메시지가 로컬에 대기열에 추가됩니다.
        pre: True # SimpleMailClient의 사전 조건을 약화시킴
        """
    def recv(self):
        """읽지 않은 다음 메일 메시지를 가져옵니다. 메시지가 있을 때까지 기다립니다.
        pre: True # 항상 호출될 수 있음
        post: isinstance(__return__, Message)
        """
</code></pre>
<p>사전 조건은 약화될 수만 있기 때문에, <code>ComplexMailClient</code>는 기존 코드를 손상시킬 염려 없이 <code>SimpleMailClient</code>를 대체할 수 있습니다.</p>
<h3>이론적 근거 (Rationale)</h3>
<p>다음과 같은 차이점을 제외하고, Python의 계약 기반 프로그래밍은 Eiffel DBC 명세를 따릅니다.</p>
<ul>
<li><strong>docstring에 계약 포함:</strong> <code>doctest</code> 모듈을 본떠 계약을 docstring에 포함합니다. 이는 추가적인 구문(syntax)의 필요성을 없애고, 계약이 있는 프로그램이 하위 호환성(backwards-compatible)을 가지도록 보장하며, 계약을 문서에 포함하기 위한 추가 작업이 필요하지 않습니다.</li>
<li><strong>키워드 선택:</strong> <code>Eiffel</code> 스타일의 <code>REQUIRE</code>, <code>ENSURE</code>, <code>INVARIANT</code> 대신 <code>pre</code>, <code>post</code>, <code>inv</code> 키워드가 선택되었습니다. 이는 더 짧고, 수학적 표기법과 더 일치하며, 미묘한 이유가 있습니다: 'require'는 호출자의 책임을, 'ensure'는 제공자의 보장을 의미합니다. 그러나 다중 상속을 사용할 때 호출자의 잘못 없이 사전 조건이 실패할 수 있고, 다중 스레드를 사용할 때 함수의 잘못 없이 사후 조건이 실패할 수 있습니다.</li>
<li><strong>반복문 불변식(Loop invariants) 미지원:</strong> <code>Eiffel</code>에서 사용되는 반복문 불변식은 지원되지 않습니다. 이는 구현하기 어렵고, 어차피 문서화의 일부가 아닙니다.</li>
<li><strong>변수명 <code>__old__</code> 및 <code>__return__</code>:</strong> <code>return</code> 키워드와의 충돌을 피하고 Python의 명명 규칙과 일치하도록 <code>__old__</code> 및 <code>__return__</code> 변수명이 선택되었습니다. 이들은 <code>public</code>이며 Python 구현에서 제공됩니다.</li>
<li><strong><code>post</code> 키워드 뒤 변수 선언:</strong> <code>post</code> 키워드 뒤에 변수를 선언하는 것은 함수 또는 메서드가 수정할 수 있는 것을 정확히 설명합니다. 이는 <code>Eiffel</code>의 <code>NoChange</code> 구문이 필요 없게 하고, <code>__old__</code>의 구현을 훨씬 쉽게 만듭니다. 또한, 변경할 내용을 선언한 다음 변경을 제한하는 두 부분으로 나뉘는 Z 스키마와도 더 일치합니다.</li>
<li><strong><code>__old__</code> 값에 대한 얕은 복사본(Shallow copies):</strong> <code>__old__</code> 값에 대한 변수들의 얕은 복사본은 계약 프로그래밍 구현이 시스템 속도를 너무 많이 저하시키는 것을 방지합니다. 함수가 얕은 복사본으로는 감지되지 않을 값을 변경하는 경우, 다음과 같이 변경 사항을 선언할 수 있습니다.
<pre><code class="language-python">post[self, self.obj, self.obj.p]
</code></pre>
</li>
<li><strong><code>forall</code>, <code>exists</code>, <code>implies</code> 함수:</strong> 기존 함수를 계약으로 문서화하는 데 시간을 보낸 후 이 함수들이 추가되었습니다. 이 함수들은 일반적인 명세 관용구의 대부분을 포착합니다. <code>implies</code>를 함수로 정의하는 것이 작동하지 않을 수도 있다고 생각할 수 있지만 (다른 부울 연산자와 달리 인수가 필요 여부에 관계없이 평가됨), 계약에서는 계약의 어떤 표현식에도 부작용(side-effects)이 없어야 하므로 작동합니다.</li>
</ul>
<h3>참조 구현 (Reference Implementation)</h3>
<p>참조 구현이 제공됩니다. 이 구현은 클래스 또는 모듈의 네임스페이스를 직접 변경하여 계약 검사를 수행하는 새로운 함수로 기존 함수를 대체합니다.</p>
<p><code>__getattr__</code>을 해킹하거나 <code>__metaclass__</code>를 사용하는 다른 구현도 존재합니다.</p>
<h3>참고 자료 (References)</h3>
<ul>
<li>이 문서에 설명된 구현: <a href="http://www.wayforward.net/pycontract/">http://www.wayforward.net/pycontract/</a></li>
<li>Design By Contract는 Eiffel Software Inc.의 등록 상표입니다: <a href="http://archive.eiffel.com/doc/manuals/technology/contract/">http://archive.eiffel.com/doc/manuals/technology/contract/</a></li>
<li>Object-oriented Software Construction, Bertrand Meyer, ISBN 0-13-629031-0</li>
<li>doctest – Test docstrings represent reality: <a href="http://docs.python.org/library/doctest.html">http://docs.python.org/library/doctest.html</a></li>
<li>Design by Contract for Python, R. Plosch IEEE Proceedings of the Joint Asia Pacific Software Engineering Conference (APSEC97/ICSC97), Hong Kong, December 2-5, 1997: <a href="http://www.swe.uni-linz.ac.at/publications/abstract/TR-SE-97.24.html">http://www.swe.uni-linz.ac.at/publications/abstract/TR-SE-97.24.html</a></li>
<li>PyDBC – Design by Contract for Python 2.2+, Daniel Arbuckle: <a href="http://www.nongnu.org/pydbc/">http://www.nongnu.org/pydbc/</a></li>
<li>ReStructuredText: <a href="http://docutils.sourceforge.net/rst.html">http://docutils.sourceforge.net/rst.html</a></li>
<li>Extreme Programming Explained, Kent Beck, ISBN 0-201-61641-6</li>
<li>The Z Notation, Second Edition, J.M. Spivey ISBN 0-13-978529-9</li>
</ul>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.
최종 수정일: 2025-02-01 08:59:27 GMT</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy mb-4"><h4 class="text-sm font-medium text-gray-900 mb-2">카테고리</h4><span class="page__taxonomy-item">Python</span><span class="page__taxonomy-item">PEP</span></div><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[4281,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"185\",\"static/chunks/app/layout-8808afda01b7a1b7.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/316\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"iV6XySbMHIJ3imQdvgy3I\",\"assetPrefix\":\"/secrett2633.github.io\",\"initialCanonicalUrl\":\"/python/pep/316/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/316\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"316\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/316\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"32x32\",\"href\":\"/favicon-32x32.png\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"16x16\",\"href\":\"/favicon-16x16.png\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_9012cf layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T4b3f,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0316/\"\u003ePEP 316 - Programming by Contract for Python\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Deferred | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 02-May-2003\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 316 – Python을 위한 계약 기반 프로그래밍 (Programming by Contract for Python)\u003c/h2\u003e\n\u003ch3\u003e개요\u003c/h3\u003e\n\u003cp\u003e이 문서는 Python에서 \"계약 기반 프로그래밍(Programming by Contract, DBC)\"을 구현하는 방법을 설명하는 제안입니다. Eiffel의 Design By Contract™가 가장 널리 알려진 계약 기반 프로그래밍의 예시입니다.\u003c/p\u003e\n\u003cp\u003e계약 기반 프로그래밍은 클래스 및 모듈에 대한 불변식(invariant), 그리고 함수와 메서드에 대한 사전 조건(pre-condition) 및 사후 조건(post-condition) 표현식을 포함하도록 언어를 확장합니다. 이 표현식들(계약)은 \u003ccode\u003eassert\u003c/code\u003e와 유사하게, 거짓일 경우 프로그램 실행이 중단되며, 런타임 검사는 일반적으로 디버깅 중에만 활성화됩니다. 계약은 단순히 \u003ccode\u003eassert\u003c/code\u003e를 사용하는 것보다 높은 수준이며, 일반적으로 문서화에 포함됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 연기됨 (Deferred)\n\u003cstrong\u003e작성자:\u003c/strong\u003e Terence Way\n\u003cstrong\u003e생성일:\u003c/strong\u003e 2003년 5월 2일\u003c/p\u003e\n\u003ch3\u003e동기 (Motivation)\u003c/h3\u003e\n\u003cp\u003ePython에는 이미 \u003ccode\u003eassert\u003c/code\u003e 문이 있는데, 왜 계약과 같은 것을 지원하기 위해 언어에 추가적인 기능을 도입해야 할까요? 가장 큰 두 가지 이유는 다음과 같습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e더 나은, 더 정확한 문서화:\u003c/strong\u003e 복잡한 모듈이나 클래스는 종종 제대로 문서화되지 않는 경우가 많습니다. 제공된 문서는 특정 모듈이나 클래스를 사용하도록 설득하기에는 충분할 수 있지만, 실제 디버깅이 시작되면 프로그래머는 거의 항상 소스 코드를 읽어야 합니다. 계약은 \u003ccode\u003edoctest\u003c/code\u003e 모듈이 제공하는 훌륭한 예시를 확장합니다. 문서는 프로그래머가 읽을 수 있으며, 실행 가능한 테스트가 포함되어 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e더 쉬운 테스팅:\u003c/strong\u003e 계약을 통한 코드 테스트도 더 쉬워집니다. 포괄적으로 작성된 계약은 곧 유닛 테스트(unit tests)와 동일합니다. 테스트는 사전 조건의 모든 범위를 실행하며, 사후 조건이 위반되면 실패합니다. 이론적으로 올바르게 명시된 함수는 완전히 무작위로 테스트될 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e왜 이것을 언어에 추가해야 할까요? 여러 구현을 두거나 프로그래머가 자체적인 \u003ccode\u003eassert\u003c/code\u003e를 구현하도록 두지 않는 이유는 무엇일까요? 그 답은 \u003cstrong\u003e상속(inheritance)\u003c/strong\u003e 시 계약의 동작 때문입니다.\u003c/p\u003e\n\u003cp\u003e만약 Alice와 Bob이 서로 다른 \u003ccode\u003eassert\u003c/code\u003e 패키지를 사용한다고 가정해 봅시다. Alice가 \u003ccode\u003eassert\u003c/code\u003e로 보호되는 클래스 라이브러리를 만들었다면, Bob은 Alice의 라이브러리에서 클래스를 파생하여도 사후 조건 및 불변식의 올바른 검사를 기대할 수 없습니다. 만약 둘 다 동일한 \u003ccode\u003eassert\u003c/code\u003e 패키지를 사용한다면, Bob은 Alice의 메서드를 오버라이드(override)하더라도 Alice의 계약 \u003ccode\u003eassert\u003c/code\u003e에 대해 테스트할 수 있습니다. 이러한 \u003ccode\u003eassert\u003c/code\u003e 시스템이 존재하기에 가장 자연스러운 곳은 언어의 런타임 라이브러리입니다.\u003c/p\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003cp\u003e모든 모듈 또는 클래스의 docstring은 \u003ccode\u003einv:\u003c/code\u003e 키워드로 시작하는 줄로 표시된 불변식 계약을 포함할 수 있습니다. 콜론(:) 앞뒤의 공백은 무시됩니다. 콜론 뒤에는 같은 줄에 단일 표현식이 바로 오거나, \u003ccode\u003einv\u003c/code\u003e 키워드보다 들여쓰기된 여러 줄의 표현식이 올 수 있습니다. 일반적인 Python의 암묵적/명시적 줄 연속 규칙이 적용됩니다. 하나의 docstring에 여러 개의 불변식 계약이 있을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 상태 열거\nSTART, CONNECTING, CONNECTED, CLOSING, CLOSED = range(5)\n\nclass conn:\n    \"\"\"A network connection\n    inv: self.state in [START, CLOSED,  # 닫힌 상태\n                        CONNECTING, CLOSING,  # 전환 상태\n                        CONNECTED]\n    inv: 0 \u0026#x3C;= self.seqno \u0026#x3C; 256\n    \"\"\"\n\nclass circbuf:\n    \"\"\"A circular buffer.\n    inv: # 버퍼에 0에서 최대 항목까지 있을 수 있음\n        0 \u0026#x3C;= self.len \u0026#x3C;= len(self.buf)\n    inv: # g는 buf의 유효한 인덱스임\n        0 \u0026#x3C;= self.g \u0026#x3C; len(self.buf)\n    inv: # p도 buf의 유효한 인덱스임\n        0 \u0026#x3C;= self.p \u0026#x3C; len(self.buf)\n    inv: # get과 put 사이에 len개의 항목이 있음\n        (self.p - self.g) % len(self.buf) == \\\n        self.len % len(self.buf)\n    \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모듈 불변식은 모듈이 로드된 후, 그리고 모듈 내의 모든 \u003ccode\u003epublic\u003c/code\u003e 함수의 진입 및 종료 시점에 \u003ccode\u003eTrue\u003c/code\u003e여야 합니다.\n클래스 불변식은 \u003ccode\u003e__init__\u003c/code\u003e 함수가 반환된 후, \u003ccode\u003e__del__\u003c/code\u003e 함수의 진입 시점에, 그리고 클래스의 모든 \u003ccode\u003epublic\u003c/code\u003e 메서드의 진입 및 종료 시점에 \u003ccode\u003eTrue\u003c/code\u003e여야 합니다. 클래스 불변식은 \u003ccode\u003eself\u003c/code\u003e 변수를 사용하여 인스턴스 변수에 접근해야 합니다.\n메서드 또는 함수는 이름이 밑줄(\u003ccode\u003e_\u003c/code\u003e)로 시작하지 않거나, \u003ccode\u003e__\u003c/code\u003e (두 개의 밑줄)로 시작하고 끝나지 않는 경우 \u003ccode\u003epublic\u003c/code\u003e으로 간주됩니다.\u003c/p\u003e\n\u003cp\u003e모든 함수나 메서드의 docstring은 위와 동일한 규칙에 따라 \u003ccode\u003epre\u003c/code\u003e 키워드로 문서화된 사전 조건을 가질 수 있습니다. 사후 조건은 \u003ccode\u003epost\u003c/code\u003e 키워드 뒤에 선택적으로 변수 목록을 사용하여 문서화됩니다. 이 변수들은 함수 또는 메서드의 본문과 동일한 스코프(scope)에 있습니다. 이 목록은 함수/메서드가 수정할 수 있는 변수를 선언합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass circbuf:\n    def __init__(self, leng):\n        \"\"\"Construct an empty circular buffer.\n        pre: leng \u003e 0\n        post[self]: self.is_empty()\n            len(self.buf) == leng\n        \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e를 사용하여 작성된 docstring을 지원하기 위해 단일 콜론(:) 대신 이중 콜론(::)을 사용할 수 있습니다. 예를 들어, 다음 두 docstring은 동일한 계약을 설명합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\"\"\"pre: leng \u003e 0\"\"\"\n\"\"\"pre:: leng \u003e 0\"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사전 및 사후 조건의 표현식은 모듈 네임스페이스(namespace)에 정의됩니다. 즉, 클로저(closure) 변수를 제외하고 함수가 접근할 수 있는 거의 모든 변수에 접근할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e사후 조건의 계약 표현식은 두 개의 추가 변수에 접근할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__old__\u003c/code\u003e: \u003ccode\u003epost\u003c/code\u003e 키워드 바로 뒤에 오는 변수 목록에서 선언된 값들의 얕은 복사본(shallow copies)으로 채워집니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__return__\u003c/code\u003e: 함수 또는 메서드의 반환 값에 바인딩(bind)됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass circbuf:\n    def get(self):\n        \"\"\"Pull an entry from a non-empty circular buffer.\n        pre: not self.is_empty()\n        post[self.g, self.len]: __return__ == self.buf[__old__.self.g]\n            self.len == __old__.self.len - 1\n        \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 계약 표현식은 몇 가지 추가 편의 함수에 접근할 수 있습니다. 시퀀스의 진리 여부를 더 쉽게 평가하기 위해 \u003ccode\u003eforall\u003c/code\u003e과 \u003ccode\u003eexists\u003c/code\u003e 두 함수가 다음과 같이 정의됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef forall(a, fn = bool):\n    \"\"\"Return True only if all elements in a are true.\n    \u003e\u003e\u003e forall([])\n    1\n    \u003e\u003e\u003e even = lambda x: x % 2 == 0\n    \u003e\u003e\u003e forall([2, 4, 6, 8], even)\n    1\n    \u003e\u003e\u003e forall('this is a test'.split(), lambda x: len(x) == 4)\n    0\n    \"\"\"\ndef exists(a, fn = bool):\n    \"\"\"Returns True if there is at least one true value in a.\n    \u003e\u003e\u003e exists([])\n    0\n    \u003e\u003e\u003e exists('this is a test'.split(), lambda x: len(x) == 4)\n    1\n    \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef sort(a):\n    \"\"\"Sort a list.\n    pre: isinstance(a, type(list))\n    post[a]: # 배열 크기는 변경되지 않음\n        len(a) == len(__old__.a)\n        # 배열은 정렬되어 있음\n        forall([a[i] \u003e= a[i-1] for i in range(1, len(a))])\n        # 모든 이전 요소가 여전히 배열에 있음\n        forall(__old__.a, lambda e: __old__.a.count(e) == a.count(e))\n    \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e조건 평가를 더 쉽게 하기 위해 \u003ccode\u003eimplies\u003c/code\u003e 함수가 정의됩니다. 두 인수를 사용하면 논리적 함의(\u003ccode\u003e=\u003e\u003c/code\u003e) 연산자와 유사합니다. 세 인수를 사용하면 C 언어의 조건부 표현식(\u003ccode\u003ex?a:b\u003c/code\u003e)과 유사합니다. 다음과 같이 정의됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eimplies(False, a)\u003c/code\u003e =\u003e \u003ccode\u003eTrue\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eimplies(True, a)\u003c/code\u003e =\u003e \u003ccode\u003ea\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eimplies(False, a, b)\u003c/code\u003e =\u003e \u003ccode\u003eb\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eimplies(True, a, b)\u003c/code\u003e =\u003e \u003ccode\u003ea\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e함수 진입 시, 함수의 사전 조건이 검사됩니다. 사전 조건 중 하나라도 거짓이면 \u003ccode\u003eAssertionError\u003c/code\u003e가 발생합니다. 함수가 \u003ccode\u003epublic\u003c/code\u003e인 경우, 클래스 또는 모듈의 불변식도 검사됩니다. \u003ccode\u003epost\u003c/code\u003e에 선언된 변수들의 복사본이 저장되고, 함수가 호출되며, 함수가 예외를 발생시키지 않고 종료되면 사후 조건이 검사됩니다.\u003c/p\u003e\n\u003ch3\u003e예외 (Exceptions)\u003c/h3\u003e\n\u003cp\u003e함수나 메서드가 예외를 발생시켜 종료하더라도 클래스/모듈 불변식은 검사됩니다 (사후 조건은 검사되지 않습니다).\u003c/p\u003e\n\u003cp\u003e실패한 모든 계약은 \u003ccode\u003eContractViolationError\u003c/code\u003e 예외의 서브클래스(subclass)인 예외를 발생시키며, \u003ccode\u003eContractViolationError\u003c/code\u003e는 \u003ccode\u003eAssertionError\u003c/code\u003e 예외의 서브클래스입니다. 실패한 사전 조건은 \u003ccode\u003ePreconditionViolationError\u003c/code\u003e 예외를 발생시키고, 실패한 사후 조건은 \u003ccode\u003ePostconditionViolationError\u003c/code\u003e 예외를, 실패한 불변식은 \u003ccode\u003eInvariantViolationError\u003c/code\u003e 예외를 발생시킵니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e클래스 계층 구조:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAssertionError\n    ContractViolationError\n        PreconditionViolationError\n        PostconditionViolationError\n        InvariantViolationError\n        InvalidPreconditionError\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eInvalidPreconditionError\u003c/code\u003e는 사전 조건이 불법적으로 강화될 때 발생합니다. 이는 상속 섹션에서 자세히 설명합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\n    some_func()\nexcept contract.PreconditionViolationError:\n    # 사전 조건 실패, 정상 처리\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e상속 (Inheritance)\u003c/h3\u003e\n\u003cp\u003e클래스의 불변식은 모든 슈퍼클래스(super-classes)의 불변식을 포함합니다 (클래스 불변식은 슈퍼클래스 불변식과 AND 연산됩니다). 이 불변식들은 메서드 결정 순서(method-resolution order)로 검사됩니다.\u003c/p\u003e\n\u003cp\u003e메서드의 사후 조건 또한 오버라이드(override)된 모든 사후 조건을 포함합니다 (메서드 사후 조건은 오버라이드된 모든 메서드 사후 조건과 AND 연산됩니다).\u003c/p\u003e\n\u003cp\u003e오버라이딩하는 메서드의 사전 조건이 충족되면, 오버라이드된 메서드의 사전 조건은 무시될 수 있습니다. 그러나 오버라이딩하는 메서드의 사전 조건이 실패하면, 오버라이드된 모든 메서드의 사전 조건도 실패해야 합니다. 그렇지 않으면 \u003ccode\u003eInvalidPreconditionError\u003c/code\u003e라는 별도의 예외가 발생합니다. 이는 사전 조건을 약화시키는 것을 지원합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e다소 억지스러운 예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass SimpleMailClient:\n    def send(self, msg, dest):\n        \"\"\"메시지를 목적지로 보냅니다.\n        pre: self.is_open() # 열린 연결이 있어야 함\n        \"\"\"\n    def recv(self):\n        \"\"\"읽지 않은 다음 메일 메시지를 가져옵니다. 메시지가 없으면 None을 반환합니다.\n        pre: self.is_open() # 열린 연결이 있어야 함\n        post: __return__ is None or isinstance(__return__, Message)\n        \"\"\"\n\nclass ComplexMailClient(SimpleMailClient):\n    def send(self, msg, dest):\n        \"\"\"메시지를 목적지로 보냅니다. 현재 연결되어 있으면 메시지가 즉시 전송됩니다.\n        그렇지 않으면 연결이 될 때까지 메시지가 로컬에 대기열에 추가됩니다.\n        pre: True # SimpleMailClient의 사전 조건을 약화시킴\n        \"\"\"\n    def recv(self):\n        \"\"\"읽지 않은 다음 메일 메시지를 가져옵니다. 메시지가 있을 때까지 기다립니다.\n        pre: True # 항상 호출될 수 있음\n        post: isinstance(__return__, Message)\n        \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사전 조건은 약화될 수만 있기 때문에, \u003ccode\u003eComplexMailClient\u003c/code\u003e는 기존 코드를 손상시킬 염려 없이 \u003ccode\u003eSimpleMailClient\u003c/code\u003e를 대체할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e이론적 근거 (Rationale)\u003c/h3\u003e\n\u003cp\u003e다음과 같은 차이점을 제외하고, Python의 계약 기반 프로그래밍은 Eiffel DBC 명세를 따릅니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003edocstring에 계약 포함:\u003c/strong\u003e \u003ccode\u003edoctest\u003c/code\u003e 모듈을 본떠 계약을 docstring에 포함합니다. 이는 추가적인 구문(syntax)의 필요성을 없애고, 계약이 있는 프로그램이 하위 호환성(backwards-compatible)을 가지도록 보장하며, 계약을 문서에 포함하기 위한 추가 작업이 필요하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e키워드 선택:\u003c/strong\u003e \u003ccode\u003eEiffel\u003c/code\u003e 스타일의 \u003ccode\u003eREQUIRE\u003c/code\u003e, \u003ccode\u003eENSURE\u003c/code\u003e, \u003ccode\u003eINVARIANT\u003c/code\u003e 대신 \u003ccode\u003epre\u003c/code\u003e, \u003ccode\u003epost\u003c/code\u003e, \u003ccode\u003einv\u003c/code\u003e 키워드가 선택되었습니다. 이는 더 짧고, 수학적 표기법과 더 일치하며, 미묘한 이유가 있습니다: 'require'는 호출자의 책임을, 'ensure'는 제공자의 보장을 의미합니다. 그러나 다중 상속을 사용할 때 호출자의 잘못 없이 사전 조건이 실패할 수 있고, 다중 스레드를 사용할 때 함수의 잘못 없이 사후 조건이 실패할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e반복문 불변식(Loop invariants) 미지원:\u003c/strong\u003e \u003ccode\u003eEiffel\u003c/code\u003e에서 사용되는 반복문 불변식은 지원되지 않습니다. 이는 구현하기 어렵고, 어차피 문서화의 일부가 아닙니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e변수명 \u003ccode\u003e__old__\u003c/code\u003e 및 \u003ccode\u003e__return__\u003c/code\u003e:\u003c/strong\u003e \u003ccode\u003ereturn\u003c/code\u003e 키워드와의 충돌을 피하고 Python의 명명 규칙과 일치하도록 \u003ccode\u003e__old__\u003c/code\u003e 및 \u003ccode\u003e__return__\u003c/code\u003e 변수명이 선택되었습니다. 이들은 \u003ccode\u003epublic\u003c/code\u003e이며 Python 구현에서 제공됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003epost\u003c/code\u003e 키워드 뒤 변수 선언:\u003c/strong\u003e \u003ccode\u003epost\u003c/code\u003e 키워드 뒤에 변수를 선언하는 것은 함수 또는 메서드가 수정할 수 있는 것을 정확히 설명합니다. 이는 \u003ccode\u003eEiffel\u003c/code\u003e의 \u003ccode\u003eNoChange\u003c/code\u003e 구문이 필요 없게 하고, \u003ccode\u003e__old__\u003c/code\u003e의 구현을 훨씬 쉽게 만듭니다. 또한, 변경할 내용을 선언한 다음 변경을 제한하는 두 부분으로 나뉘는 Z 스키마와도 더 일치합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e__old__\u003c/code\u003e 값에 대한 얕은 복사본(Shallow copies):\u003c/strong\u003e \u003ccode\u003e__old__\u003c/code\u003e 값에 대한 변수들의 얕은 복사본은 계약 프로그래밍 구현이 시스템 속도를 너무 많이 저하시키는 것을 방지합니다. 함수가 얕은 복사본으로는 감지되지 않을 값을 변경하는 경우, 다음과 같이 변경 사항을 선언할 수 있습니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003epost[self, self.obj, self.obj.p]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eforall\u003c/code\u003e, \u003ccode\u003eexists\u003c/code\u003e, \u003ccode\u003eimplies\u003c/code\u003e 함수:\u003c/strong\u003e 기존 함수를 계약으로 문서화하는 데 시간을 보낸 후 이 함수들이 추가되었습니다. 이 함수들은 일반적인 명세 관용구의 대부분을 포착합니다. \u003ccode\u003eimplies\u003c/code\u003e를 함수로 정의하는 것이 작동하지 않을 수도 있다고 생각할 수 있지만 (다른 부울 연산자와 달리 인수가 필요 여부에 관계없이 평가됨), 계약에서는 계약의 어떤 표현식에도 부작용(side-effects)이 없어야 하므로 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e참조 구현 (Reference Implementation)\u003c/h3\u003e\n\u003cp\u003e참조 구현이 제공됩니다. 이 구현은 클래스 또는 모듈의 네임스페이스를 직접 변경하여 계약 검사를 수행하는 새로운 함수로 기존 함수를 대체합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__getattr__\u003c/code\u003e을 해킹하거나 \u003ccode\u003e__metaclass__\u003c/code\u003e를 사용하는 다른 구현도 존재합니다.\u003c/p\u003e\n\u003ch3\u003e참고 자료 (References)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e이 문서에 설명된 구현: \u003ca href=\"http://www.wayforward.net/pycontract/\"\u003ehttp://www.wayforward.net/pycontract/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDesign By Contract는 Eiffel Software Inc.의 등록 상표입니다: \u003ca href=\"http://archive.eiffel.com/doc/manuals/technology/contract/\"\u003ehttp://archive.eiffel.com/doc/manuals/technology/contract/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eObject-oriented Software Construction, Bertrand Meyer, ISBN 0-13-629031-0\u003c/li\u003e\n\u003cli\u003edoctest – Test docstrings represent reality: \u003ca href=\"http://docs.python.org/library/doctest.html\"\u003ehttp://docs.python.org/library/doctest.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDesign by Contract for Python, R. Plosch IEEE Proceedings of the Joint Asia Pacific Software Engineering Conference (APSEC97/ICSC97), Hong Kong, December 2-5, 1997: \u003ca href=\"http://www.swe.uni-linz.ac.at/publications/abstract/TR-SE-97.24.html\"\u003ehttp://www.swe.uni-linz.ac.at/publications/abstract/TR-SE-97.24.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePyDBC – Design by Contract for Python 2.2+, Daniel Arbuckle: \u003ca href=\"http://www.nongnu.org/pydbc/\"\u003ehttp://www.nongnu.org/pydbc/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eReStructuredText: \u003ca href=\"http://docutils.sourceforge.net/rst.html\"\u003ehttp://docutils.sourceforge.net/rst.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eExtreme Programming Explained, Kent Beck, ISBN 0-201-61641-6\u003c/li\u003e\n\u003cli\u003eThe Z Notation, Second Edition, J.M. Spivey ISBN 0-13-978529-9\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.\n최종 수정일: 2025-02-01 08:59:27 GMT\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Deferred] PEP 316 - Programming by Contract for Python\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 18:27:40+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"page__taxonomy mb-4\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"카테고리\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":\"Python\"}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":\"PEP\"}]]]}],[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]]}]]}]}]}]\nb:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"conten"])</script><script>self.__next_f.push([1,"t\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"21\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>