<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js"/><script src="/secrett2633.github.io/_next/static/chunks/fd9d1056-62aaf4b921c84028.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/23-ca4408d024135d8d.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/main-app-fa660020ba1e0b6e.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/231-c4b666723e6aae68.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/layout-8808afda01b7a1b7.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="next-size-adjust"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/secrett2633.github.io/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_9012cf layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/secrett2633.github.io">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Withdrawn] PEP 339 - Design of the CPython Compiler</h1><div class="page__meta"><time dateTime="2025-09-26 18:46:48+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0339/">PEP 339 - Design of the CPython Compiler</a></p>
<p><strong>상태:</strong> Withdrawn | <strong>유형:</strong> Informational | <strong>작성일:</strong> 02-Feb-2005</p>
</blockquote>
<p><strong>참고:</strong> 이 PEP는 철회되었으며 Python 개발자 가이드로 이동되었습니다.</p>
<h2>개요 (Abstract)</h2>
<p>과거(Python 2.4까지)에는 소스 코드(source code)를 바이트코드(bytecode)로 컴파일하는 과정이 두 단계로 이루어졌습니다:</p>
<ol>
<li>소스 코드를 파스 트리(parse tree)로 파싱합니다 (<code>Parser/pgen.c</code>).</li>
<li>파스 트리를 기반으로 바이트코드를 생성합니다 (<code>Python/compile.c</code>).</li>
</ol>
<p>이는 일반적인 컴파일러의 작동 방식과는 다릅니다. 컴파일의 일반적인 단계는 다음과 같습니다:</p>
<ol>
<li>소스 코드를 파스 트리로 파싱합니다 (<code>Parser/pgen.c</code>).</li>
<li>파스 트리를 추상 구문 트리(Abstract Syntax Tree, AST)로 변환합니다 (<code>Python/ast.c</code>).</li>
<li>AST를 제어 흐름 그래프(Control Flow Graph, CFG)로 변환합니다 (<code>Python/compile.c</code>).</li>
<li>제어 흐름 그래프를 기반으로 바이트코드를 생성합니다 (<code>Python/compile.c</code>).</li>
</ol>
<p>Python 2.5부터는 위에서 설명한 네 가지 단계가 사용됩니다. 이러한 변경은 컴파일 과정을 세 단계로 나누어 단순화하기 위해 이루어졌습니다. 이 문서는 프로세스의 마지막 세 단계가 어떻게 작동하는지 설명하는 것을 목표로 합니다.</p>
<p>이 문서는 컴파일에 필요한 설명을 넘어 파싱(parsing)이 작동하는 방식에 대해서는 다루지 않습니다. 또한, 전체 시스템이 작동하는 방식을 전부 다루지는 않습니다. 모든 세부 사항을 정확히 이해하려면 일부 소스 코드를 직접 읽어야 할 수도 있습니다.</p>
<h2>파스 트리 (Parse Trees)</h2>
<p>Python의 파서(parser)는 주로 "Dragon Book" [Aho86]에 설명된 구현을 기반으로 하는 LL(1) 파서입니다.</p>
<p>Python의 문법 파일은 <code>Grammar/Grammar</code>에서 찾을 수 있으며, 문법 규칙의 숫자 값은 <code>Include/graminit.h</code>에 저장됩니다. 토큰(token) 유형(예: <code>:</code>, 숫자 등 리터럴 토큰)의 숫자 값은 <code>Include/token.h</code>에 보관됩니다. 파스 트리는 <code>Include/node.h</code>에 정의된 <code>node *</code> 구조체들로 구성됩니다.</p>
<p><code>node</code> 구조체에서 데이터를 조회하는 데는 다음 매크로(모두 <code>Include/token.h</code>에 정의됨)를 사용할 수 있습니다:</p>
<ul>
<li><code>CHILD(node *, int)</code>: 0-오프셋 인덱싱을 사용하여 노드의 n번째 자식(child)을 반환합니다.</li>
<li><code>RCHILD(node *, int)</code>: 노드의 오른쪽에서 n번째 자식을 반환합니다. 음수를 사용합니다!</li>
<li><code>NCH(node *)</code>: 노드가 가진 자식의 수를 반환합니다.</li>
<li><code>STR(node *)</code>: 노드의 문자열 표현을 반환합니다. 예를 들어, <code>COLON</code> 토큰에 대해 <code>:</code>를 반환합니다.</li>
<li><code>TYPE(node *)</code>: <code>Include/graminit.h</code>에 지정된 노드의 유형을 반환합니다.</li>
<li><code>REQ(node *, TYPE)</code>: 노드가 예상된 유형인지 단언(assert)합니다.</li>
<li><code>LINENO(node *)</code>: 파스 규칙 생성으로 이어진 소스 코드의 줄 번호를 검색합니다. <code>Python/ast.c</code>에 정의되어 있습니다.</li>
</ul>
<p>이 모든 것을 예시로 들기 위해 <code>'while'</code> 규칙을 고려해 봅시다:</p>
<pre><code>while_stmt: 'while' test ':' suite ['else' ':' suite]
</code></pre>
<p>이것을 나타내는 노드는 <code>TYPE(node) == while_stmt</code>가 되고, <code>else</code> 문(statement)의 유무에 따라 자식의 수는 4개 또는 7개가 될 수 있습니다. 첫 번째 <code>:</code>에 접근하고 이것이 실제 <code>:</code> 토큰인지 확인하려면 <code>(REQ(CHILD(node, 2), COLON))</code>과 같이 사용합니다.</p>
<h2>추상 구문 트리 (Abstract Syntax Trees, AST)</h2>
<p>추상 구문 트리(AST)는 소스 코드를 포함할 필요 없이 프로그램 구조를 고수준으로 표현한 것입니다. 소스 코드의 추상적인 표현으로 생각할 수 있습니다. AST 노드의 사양은 Zephyr Abstract Syntax Definition Language (ASDL) [Wang97]을 사용하여 지정됩니다.</p>
<p>Python용 AST 노드의 정의는 파일 <code>Parser/Python.asdl</code>에서 찾을 수 있습니다.</p>
<p>각 AST 노드(문, 표현식, 리스트 컴프리헨션(list comprehensions) 및 예외 핸들러(exception handlers)와 같은 여러 특수 유형을 나타냄)는 ASDL에 의해 정의됩니다. AST의 대부분의 정의는 <code>'if'</code> 문이나 속성 조회(attribute lookup)와 같은 특정 소스 구성 요소에 해당합니다. 이 정의는 특정 프로그래밍 언어에서의 구현과는 독립적입니다.</p>
<p>다음 Python ASDL 구성 요소의 일부는 접근 방식과 구문을 보여줍니다:</p>
<pre><code>module Python {
    stmt = FunctionDef(identifier name, arguments args, stmt* body, expr* decorators)
         | Return(expr? value)
         | Yield(expr value)
         attributes (int lineno)
}
</code></pre>
<p>위의 예시는 세 가지 종류의 문(statements)을 설명합니다. 함수 정의(<code>FunctionDef</code>), 반환 문(<code>Return</code>), 그리고 yield 문(<code>Yield</code>)입니다. 세 가지 종류 모두 <code>|</code>로 구분되어 <code>stmt</code> 유형으로 간주됩니다. 이들은 모두 다양한 종류와 수의 인자(arguments)를 취합니다.</p>
<p>인자 유형의 수정자(modifier)는 필요한 값의 수를 지정합니다.
<code>?</code>는 선택 사항(optional)임을 의미하고, <code>*</code>는 0개 이상을 의미하며, 수정자가 없으면 인자에 대해 하나의 값만 필요하며 필수임을 의미합니다. 예를 들어, <code>FunctionDef</code>는 <code>name</code>에 대해 <code>identifier</code>, <code>args</code>에 대해 <code>arguments</code>, <code>body</code>에 대해 0개 이상의 <code>stmt</code> 인자, <code>decorators</code>에 대해 0개 이상의 <code>expr</code> 인자를 취합니다.</p>
<p><code>arguments</code>와 같이 노드 유형인 것이 단일 AST 노드로 표현되며, 예상할 수 있는 <code>stmt</code>와 같은 노드 시퀀스가 아님을 주목하십시오.</p>
<p>세 가지 종류 모두 <code>attributes</code> 인자를 가지고 있습니다. 이는 <code>attributes</code> 앞에 <code>|</code>가 없다는 사실로 알 수 있습니다.</p>
<p>위의 문 정의는 다음 C 구조체 유형을 생성합니다:</p>
<pre><code class="language-c">typedef struct _stmt *stmt_ty;
struct _stmt {
    enum { FunctionDef_kind=1, Return_kind=2, Yield_kind=3 } kind;
    union {
        struct {
            identifier name;
            arguments_ty args;
            asdl_seq *body;
        } FunctionDef;
        struct {
            expr_ty value;
        } Return;
        struct {
            expr_ty value;
        } Yield;
    } v;
    int lineno;
}
</code></pre>
<p>또한, 적절한 초기화를 통해 <code>stmt_ty</code> 구조체를 할당하는 일련의 생성자 함수(constructor functions)가 생성됩니다. <code>kind</code> 필드는 유니온(union)의 어떤 구성 요소가 초기화되는지를 지정합니다. <code>FunctionDef()</code> 생성자 함수는 <code>kind</code>를 <code>FunctionDef_kind</code>로 설정하고 <code>name</code>, <code>args</code>, <code>body</code>, <code>attributes</code> 필드를 초기화합니다.</p>
<h2>메모리 관리 (Memory Management)</h2>
<p>컴파일러의 실제 구현을 논의하기 전에 메모리 처리 방식에 대한 논의가 필요합니다. 메모리 관리를 단순화하기 위해 아레나(arena)가 사용됩니다. 이는 메모리가 할당 및 제거를 쉽게 하기 위해 단일 위치에 풀링(pooling)된다는 것을 의미합니다. 이를 통해 명시적인 메모리 할당 해제(deallocation)가 필요 없어집니다. 컴파일러에서 필요한 모든 메모리 할당이 해당 메모리를 아레나에 등록하기 때문에, 아레나를 해제하는 단일 호출만으로 컴파일러가 사용한 모든 메모리를 완전히 해제할 수 있습니다.</p>
<p>일반적으로 컴파일러의 핵심 부분에서 작업하지 않는 한 메모리 관리는 완전히 무시할 수 있습니다. 그러나 컴파일러의 아주 초기 또는 마지막 부분에서 작업하는 경우 아레나가 작동하는 방식에 신경 써야 합니다. 아레나와 관련된 모든 코드는 <code>Include/pyarena.h</code> 또는 <code>Python/pyarena.c</code>에 있습니다.</p>
<p><code>PyArena_New()</code>는 새 아레나를 생성합니다. 반환된 <code>PyArena</code> 구조체는 주어진 모든 메모리에 대한 포인터를 저장합니다. 이는 컴파일러가 사용한 메모리를 마쳤을 때 어떤 메모리를 해제해야 하는지 장부 관리(bookkeeping)를 합니다. 이 해제는 <code>PyArena_Free()</code>를 통해 수행됩니다. 이는 컴파일러가 종료되는 전략적인 영역에서만 호출되어야 합니다.</p>
<p>위에 명시된 바와 같이, 일반적으로 컴파일러 작업 시 메모리 관리에 대해 걱정할 필요가 없습니다. 대부분의 경우 기술적인 세부 사항은 숨겨지도록 설계되었습니다.</p>
<p>유일한 예외는 <code>PyObject</code>를 관리할 때 발생합니다. Python의 나머지 부분이 참조 카운팅(reference counting)을 사용하기 때문에, 할당된 각 <code>PyObject</code>를 정리하기 위한 추가 지원이 아레나에 추가됩니다. 이러한 경우는 매우 드뭅니다. 그러나 <code>PyObject</code>를 할당했다면 <code>PyArena_AddPyObject()</code>를 호출하여 아레나에 알려야 합니다.</p>
<h2>파스 트리에서 AST로 (Parse Tree to AST)</h2>
<p>AST는 <code>PyAST_FromNode()</code> 함수를 사용하여 파스 트리에서 생성됩니다 ( <code>Python/ast.c</code> 참조).</p>
<p>이 함수는 파스 트리의 트리 워크(tree walk)를 시작하여 진행하면서 다양한 AST 노드를 생성합니다. 이를 위해 필요한 모든 새 노드를 할당하고, 필요한 지원 함수에 대해 적절한 AST 노드 생성 함수를 호출하며, 필요에 따라 노드를 연결합니다.</p>
<p>문법 사양과 파스 트리의 노드 사이에 자동화되거나 상징적인 연결이 없다는 점을 인지해야 합니다. <code>yacc</code>에서와 같이 파스 트리에 의해 직접적인 도움은 제공되지 않습니다.</p>
<p>예를 들어, 작업 중인 파스 트리에서 어떤 노드를 다루고 있는지 계속 추적해야 합니다 (예: <code>'if'</code> 문을 다루고 있다면 조건문의 끝을 찾기 위해 <code>:</code> 토큰을 주시해야 합니다).</p>
<p>파스 트리에서 AST 노드를 생성하기 위해 호출되는 함수들은 모두 <code>ast_for_xx</code>라는 이름을 가지며, 여기서 <code>xx</code>는 함수가 처리하는 문법 규칙입니다 (<code>alias_for_import_name</code>은 예외입니다). 이 함수들은 차례로 ASDL 문법에 의해 정의되고 <code>Python/Python-ast.c</code>에 포함된 생성자 함수( <code>Parser/asdl_c.py</code>에 의해 생성됨)를 호출하여 AST의 노드를 생성합니다. 이 모든 과정은 <code>asdl_seq</code> 구조체에 저장된 AST 노드 시퀀스로 이어집니다.</p>
<p><code>Python/asdl.c</code> 및 <code>Include/asdl.h</code>에서 찾을 수 있는 <code>asdl_seq *</code> 유형을 생성하고 사용하는 함수 및 매크로:</p>
<ul>
<li><code>asdl_seq_new()</code>: 지정된 길이에 대한 <code>asdl_seq</code>에 메모리를 할당합니다.</li>
<li><code>asdl_seq_GET()</code>: <code>asdl_seq</code>의 특정 위치에 있는 항목을 가져옵니다.</li>
<li><code>asdl_seq_SET()</code>: <code>asdl_seq</code>의 특정 인덱스를 지정된 값으로 설정합니다.</li>
<li><code>asdl_seq_LEN(asdl_seq *)</code>: <code>asdl_seq</code>의 길이를 반환합니다.</li>
</ul>
<p>문을 다루는 경우, 문을 생성한 줄 번호를 추적하는 것에 대해서도 신경 써야 합니다. 현재 줄 번호는 각 <code>stmt_ty</code> 함수의 마지막 매개변수로 전달됩니다.</p>
<h2>제어 흐름 그래프 (Control Flow Graphs)</h2>
<p>제어 흐름 그래프(Control Flow Graph, 약어 CFG로 자주 참조됨)는 블록 내에 중간 표현(Intermediate Representation, 약어 IR; 여기서는 Python 바이트코드)을 포함하는 기본 블록(basic blocks)을 사용하여 프로그램의 흐름을 모델링하는 방향 그래프(directed graph)입니다. 기본 블록 자체는 단일 진입점(entry point)을 가지지만 여러 개의 종료점(exit points)을 가질 수 있는 IR 블록입니다. 단일 진입점은 기본 블록의 핵심입니다. 이는 모두 점프(jumps)와 관련이 있습니다. 진입점은 제어 흐름을 변경하는 것(함수 호출이나 점프와 같은)의 대상인 반면, 종료점은 프로그램의 흐름을 변경하는 명령(점프나 <code>'return'</code> 문과 같은)입니다. 이는 기본 블록이 진입점에서 시작하여 종료점 또는 블록의 끝까지 실행되는 코드 조각임을 의미합니다.</p>
<p>예를 들어, <code>else</code> 블록이 있는 <code>'if'</code> 문을 생각해 봅시다. <code>'if'</code> 문의 가드(guard)는 <code>'if'</code> 문으로 이어지는 코드를 포함하는 기본 블록이 가리키는 기본 블록입니다. <code>'if'</code> 문 블록은 <code>'if'</code>의 참(true) 본문과 <code>'else'</code> 본문(NULL일 수 있음)으로의 점프(종료점)를 포함하며, 각각은 자체 기본 블록입니다. 이 두 블록은 차례로 전체 <code>'if'</code> 문 다음에 오는 코드를 나타내는 기본 블록을 가리킵니다.</p>
<p>CFG는 일반적으로 최종 코드 출력의 한 단계 전입니다. 코드는 CFG에서 에지를 따라 후위 깊이 우선 탐색(post-order depth-first search)을 수행하여 기본 블록에서 직접 생성됩니다 (점프 대상은 출력 순서에 따라 조정됨).</p>
<h2>AST에서 CFG로, CFG에서 바이트코드로 (AST to CFG to Bytecode)</h2>
<p>AST가 생성되면 다음 단계는 CFG를 생성하는 것입니다. 첫 번째 단계는 점프 대상을 특정 오프셋으로 해결하지 않고 AST를 Python 바이트코드로 변환하는 것입니다 (이는 CFG가 최종 바이트코드로 변환될 때 계산됩니다). 본질적으로 이것은 AST를 제어 흐름이 CFG의 에지로 표현되는 Python 바이트코드로 변환합니다.</p>
<p>변환은 두 번의 패스(pass)로 수행됩니다. 첫 번째 패스는 네임스페이스(namespace)를 생성합니다 (변수는 클로저(closures)의 경우 로컬(local), 자유/셀(free/cell) 또는 전역(global)으로 분류될 수 있습니다). 이것이 완료되면 두 번째 패스는 본질적으로 CFG를 리스트로 평탄화(flatten)하고 바이트코드의 최종 출력을 위한 점프 오프셋(jump offsets)을 계산합니다.</p>
<p>변환 프로세스는 <code>Python/compile.c</code>의 <code>PyAST_Compile()</code> 함수 호출에 의해 시작됩니다. 이 함수는 AST를 CFG로 변환하고 CFG에서 최종 바이트코드를 출력하는 두 가지 작업을 모두 수행합니다. AST를 CFG로 변환하는 단계는 <code>PyAST_Compile()</code>에 의해 호출되는 두 함수 <code>PySymtable_Build()</code>와 <code>compiler_mod()</code>에 의해 주로 처리됩니다. 전자는 <code>Python/symtable.c</code>에 있고 후자는 <code>Python/compile.c</code>에 있습니다.</p>
<p><code>PySymtable_Build()</code>는 AST의 시작 코드 블록(전달된)으로 들어가서 적절한 <code>symtable_visit_xx</code> 함수(여기서 <code>xx</code>는 AST 노드 유형)를 호출하는 것으로 시작합니다. 다음으로, AST 트리는 <code>symtable_enter_block()</code> 및 <code>symtable_exit_block()</code>을 각각 사용하여 블록에 들어가고 나올 때 로컬 변수의 범위(reach)를 나타내는 다양한 코드 블록으로 탐색됩니다.</p>
<p>심볼 테이블(symbol table)이 생성되면 <code>Python/compile.c</code>에 코드가 있는 CFG 생성 시간입니다. 이는 다양한 AST 노드 유형별로 작업을 세분화하는 여러 함수에 의해 처리됩니다. 함수는 모두 <code>compiler_visit_xx</code>라는 이름을 가지며, 여기서 <code>xx</code>는 노드 유형의 이름입니다 (예: <code>stmt</code>, <code>expr</code> 등). 각 함수는 <code>struct compiler *</code>와 <code>xx_ty</code>를 받는데, 여기서 <code>xx</code>는 AST 노드 유형입니다. 일반적으로 이러한 함수는 전달된 노드 유형에 따라 분기되는 큰 <code>switch</code> 문으로 구성됩니다. 간단한 것들은 <code>switch</code> 문에서 인라인(inline)으로 처리되며, 더 복잡한 변환은 <code>compiler_xx</code>라는 다른 함수로 위임됩니다 (여기서 <code>xx</code>는 처리되는 내용을 설명하는 이름).</p>
<p>임의의 AST 노드를 변환할 때는 <code>VISIT()</code> 매크로를 사용합니다. <code>&#x3C;node type></code>에 전달된 값에 따라 적절한 <code>compiler_visit_xx</code> 함수가 호출됩니다 (따라서 <code>VISIT(c, expr, node)</code>는 <code>compiler_visit_expr(c, node)</code>를 호출합니다). <code>VISIT_SEQ</code> 매크로는 매우 유사하지만, AST 노드 시퀀스( <code>*</code> 수정자를 사용한 노드의 인자로 생성된 값들)에 대해 호출됩니다. 슬라이스(slices) 처리를 위한 <code>VISIT_SLICE()</code>도 있습니다.</p>
<p>바이트코드 생성은 다음 매크로에 의해 처리됩니다:</p>
<ul>
<li><code>ADDOP()</code>: 지정된 opcode를 추가합니다.</li>
<li><code>ADDOP_I()</code>: 인자를 취하는 opcode를 추가합니다.</li>
<li><code>ADDOP_O(struct compiler *c, int op, PyObject *type, PyObject *obj)</code>: <code>PyObject</code> 시퀀스 객체에서 지정된 <code>PyObject</code>의 위치에 따라 적절한 인자와 함께 opcode를 추가하지만, 이름 맹글링(name mangling) 처리는 하지 않습니다. 이름 맹글링이 불가능하고 이름의 범위가 알려진 전역 변수(globals), 상수(consts) 또는 매개변수(parameters)와 같은 객체의 이름 기반 조회가 필요한 경우에 사용됩니다.</li>
<li><code>ADDOP_NAME()</code>: <code>ADDOP_O</code>와 유사하지만, 이름 맹글링도 처리됩니다. 이름 기반 속성 로딩(attribute loading) 또는 임포팅(importing)에 사용됩니다.</li>
<li><code>ADDOP_JABS()</code>: 기본 블록으로의 절대 점프(absolute jump)를 생성합니다.</li>
<li><code>ADDOP_JREL()</code>: 기본 블록으로의 상대 점프(relative jump)를 생성합니다.</li>
</ul>
<p>바이트코드를 생성하는 여러 헬퍼 함수들은 <code>compiler_xx()</code>로 명명되며, 여기서 <code>xx</code>는 함수가 돕는 내용입니다 (예: <code>list</code>, <code>boolop</code> 등). 특히 유용한 것 중 하나는 <code>compiler_nameop()</code>입니다. 이 함수는 변수의 범위를 조회하고 표현식 컨텍스트(expression context)에 따라 변수를 로드(load), 저장(store) 또는 삭제(delete)하는 적절한 opcode를 생성합니다.</p>
<p>문이 정의된 줄 번호를 처리하는 것은 <code>compiler_visit_stmt()</code>에 의해 처리되므로 걱정할 필요가 없습니다.</p>
<p>AST 노드를 기반으로 바이트코드를 생성하는 것 외에도 기본 블록 생성도 처리해야 합니다. 기본 블록을 관리하는 데 사용되는 매크로 및 함수는 다음과 같습니다:</p>
<ul>
<li><code>NEW_BLOCK()</code>: 블록을 생성하고 현재 블록으로 설정합니다.</li>
<li><code>NEXT_BLOCK()</code>: 기본적으로 <code>NEW_BLOCK()</code>에 현재 블록에서의 점프 기능이 추가됩니다.</li>
<li><code>compiler_new_block()</code>: 블록을 생성하지만 사용하지는 않습니다 (점프 생성에 사용됨).</li>
</ul>
<p>CFG가 생성되면 평탄화(flatten)되어야 하며, 그 후에 최종 바이트코드 생성이 이루어집니다. 평탄화는 후위 깊이 우선 탐색(post-order depth-first search)을 사용하여 처리됩니다. 평탄화되면 평탄화에 따라 점프 오프셋이 백패치(backpatched)되고 <code>PyCodeObject</code> 파일이 생성됩니다. 이 모든 것은 <code>assemble()</code> 호출에 의해 처리됩니다.</p>
<h2>새 바이트코드 도입 (Introducing New Bytecode)</h2>
<p>때로는 새로운 기능에 새로운 opcode가 필요할 수 있습니다. 그러나 새로운 바이트코드를 추가하는 것은 컴파일러의 AST -> 바이트코드 단계에서 단순히 새로운 바이트코드를 갑자기 도입하는 것만큼 간단하지 않습니다. Python 전반의 여러 코드 조각은 어떤 바이트코드가 존재하는지에 대한 정확한 정보에 의존합니다.</p>
<p>첫째, 이름과 고유 식별 번호를 선택해야 합니다. opcode의 공식 목록은 <code>Include/opcode.h</code>에서 찾을 수 있습니다. opcode가 인자를 취해야 하는 경우, <code>HAVE_ARGUMENT</code> ( <code>Include/opcode.h</code>에 있음)에 할당된 숫자보다 큰 고유 번호를 부여해야 합니다.</p>
<p>이름/번호 쌍이 선택되고 <code>Include/opcode.h</code>에 입력되면 <code>Lib/opcode.py</code>와 <code>Doc/library/dis.rst</code>에도 입력해야 합니다.</p>
<p>새로운 바이트코드를 사용하려면 <code>.pyc</code> 파일의 매직 넘버(magic number)도 변경해야 합니다. <code>Python/import.c</code>의 <code>MAGIC</code> 변수에 이 숫자가 포함되어 있습니다. 이 숫자를 변경하면 이전 <code>MAGIC</code>을 가진 모든 <code>.pyc</code> 파일이 임포트(import) 시 인터프리터(interpreter)에 의해 다시 컴파일됩니다.</p>
<p>마지막으로, 새로운 바이트코드의 사용을 도입해야 합니다. <code>Python/compile.c</code>와 <code>Python/ceval.c</code>를 변경하는 것이 주된 변경 장소가 될 것입니다. 그러나 <code>'compiler'</code> 패키지도 변경해야 합니다. 이를 위한 주요 파일은 <code>Lib/compiler/pyassem.py</code>와 <code>Lib/compiler/pycodegen.py</code>입니다.</p>
<p>기존 바이트코드의 출력에 영향을 미칠 수 있는 변경을 하고 매직 넘버를 계속 변경하지 않는 경우, 이전 <code>.py(c|o)</code> 파일을 삭제해야 합니다! 바이트코드를 변경하면 결국 매직 넘버를 변경하게 되겠지만, 디버깅 중에는 매직 넘버를 계속 올리지 않고 바이트코드 출력을 변경할 것입니다. 이는 만료된(stale) <code>.pyc</code> 파일이 다시 생성되지 않을 수 있음을 의미합니다. <code>find . -name '*.py[co]' -exec rm -f {} ';'</code>를 실행하면 가지고 있는 모든 <code>.pyc</code> 파일이 삭제되어 새 파일이 생성되도록 강제하고 새 바이트코드를 제대로 테스트할 수 있습니다.</p>
<h2>코드 객체 (Code Objects)</h2>
<p><code>PyAST_Compile()</code>의 결과는 <code>Include/code.h</code>에 정의된 <code>PyCodeObject</code>입니다. 이제 실행 가능한 Python 바이트코드를 갖게 된 것입니다!</p>
<p>코드 객체(바이트코드)는 <code>Python/ceval.c</code>에서 실행됩니다. 이 파일은 <code>PyEval_EvalFrameEx()</code>의 큰 <code>switch</code> 문에 새 opcode에 대한 새 <code>case</code> 문이 필요합니다.</p>
<h2>주요 파일 (Important Files)</h2>
<ul>
<li>
<p><strong><code>Parser/</code></strong></p>
<ul>
<li><code>Python.asdl</code>: ASDL 구문 파일.</li>
<li><code>asdl.py</code>: "Zephyr Abstract Syntax Definition Language의 구현." ASDL 파일을 파싱하기 위해 SPARK를 사용합니다.</li>
<li><code>asdl_c.py</code>: "ASDL 설명에서 C 코드를 생성합니다." <code>Python/Python-ast.c</code>와 <code>Include/Python-ast.h</code>를 생성합니다.</li>
<li><code>spark.py</code>: SPARK 파서 생성기.</li>
</ul>
</li>
<li>
<p><strong><code>Python/</code></strong></p>
<ul>
<li><code>Python-ast.c</code>: ASDL 유형에 해당하는 C 구조체를 생성합니다. 또한 AST 노드를 마샬링(marshaling)하는 코드도 포함합니다 (핵심 ASDL 유형은 <code>asdl.c</code>에 마샬링 코드가 있습니다). "Parser/asdl_c.py에 의해 자동으로 생성된 파일". 이 파일은 문법 변경이 커밋될 때마다 <code>__version__</code> 값이 최신 문법 변경 개정 번호로 설정되므로 별도로 커밋되어야 합니다.</li>
<li><code>asdl.c</code>: ASDL 시퀀스 유형을 처리하는 코드를 포함합니다. 또한 숫자 및 식별자(identifier)와 같은 핵심 ASDL 유형을 마샬링하는 코드도 있습니다. AST 노드를 마샬링하기 위해 <code>Python-ast.c</code>에서 사용됩니다.</li>
<li><code>ast.c</code>: Python의 파스 트리를 추상 구문 트리로 변환합니다.</li>
<li><code>ceval.c</code>: 바이트코드를 실행합니다 (eval loop).</li>
<li><code>compile.c</code>: AST를 기반으로 바이트코드를 생성합니다.</li>
<li><code>symtable.c</code>: AST에서 심볼 테이블을 생성합니다.</li>
<li><code>pyarena.c</code>: 아레나 메모리 관리자의 구현.</li>
<li><code>import.c</code>: 바이트코드 버전 관리를 위한 매직 넘버 (<code>MAGIC</code>)의 본거지.</li>
</ul>
</li>
<li>
<p><strong><code>Include/</code></strong></p>
<ul>
<li><code>Python-ast.h</code>: <code>Python/Python-ast.c</code>에 의해 생성된 C 구조체의 실제 정의를 포함합니다. "Parser/asdl_c.py에 의해 자동으로 생성됨".</li>
<li><code>asdl.h</code>: 해당 <code>Python/ast.c</code>의 헤더.</li>
<li><code>ast.h</code>: <code>PyAST_FromNode()</code>를 외부( <code>Python/ast.c</code>에서)로 선언합니다.</li>
<li><code>code.h</code>: <code>Objects/codeobject.c</code>의 헤더 파일; <code>PyCodeObject</code>의 정의를 포함합니다.</li>
<li><code>symtable.h</code>: <code>Python/symtable.c</code>의 헤더. <code>struct symtable</code>과 <code>PySTEntryObject</code>가 여기에 정의됩니다.</li>
<li><code>pyarena.h</code>: 해당 <code>Python/pyarena.c</code>의 헤더 파일.</li>
<li><code>opcode.h</code>: 바이트코드의 마스터 리스트; 이 파일이 수정되면 다른 여러 파일도 그에 따라 수정해야 합니다 ("새 바이트코드 도입" 참조).</li>
</ul>
</li>
<li>
<p><strong><code>Objects/</code></strong></p>
<ul>
<li><code>codeobject.c</code>: <code>PyCodeObject</code> 관련 코드를 포함합니다 (원래 <code>Python/compile.c</code>에 있었음).</li>
</ul>
</li>
<li>
<p><strong><code>Lib/</code></strong></p>
<ul>
<li><code>opcode.py</code>: <code>Include/opcode.h</code>가 수정되면 수정해야 하는 파일 중 하나.</li>
<li><strong><code>compiler/</code></strong>
<ul>
<li><code>pyassem.py</code>: <code>Include/opcode.h</code>가 변경되면 수정해야 하는 파일 중 하나.</li>
<li><code>pycodegen.py</code>: <code>Include/opcode.h</code>가 변경되면 수정해야 하는 파일 중 하나.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>알려진 컴파일러 관련 실험 (Known Compiler-related Experiments)</h2>
<p>이 섹션에서는 컴파일러(바이트코드 포함)와 관련된 알려진 실험을 나열합니다.</p>
<ul>
<li>Skip Montanaro는 Python 워크숍에서 Peephole Optimizer에 대한 논문을 발표했습니다.</li>
<li>Michael Hudson은 바이트코드를 직접 다루는 기능을 제공하는 <code>Bytecodehacks</code>라는 비활성 SourceForge 프로젝트를 가지고 있습니다.</li>
<li><code>LOAD_ATTR</code>/<code>CALL_FUNCTION</code>의 기능을 결합하는 <code>CALL_ATTR</code>이라는 opcode가 생성되었습니다. 현재는 클래식 클래스(classic classes)에서만 작동하며, 신식 클래스(new-style classes)의 경우 클래식 클래스와 신식 클래스를 모두 지원해야 하는 문제로 인해 실제 속도 저하가 발생한다는 벤치마킹 결과가 있었습니다.</li>
</ul>
<h2>참고 자료 (References)</h2>
<ul>
<li>[Aho86] Alfred V. Aho, Ravi Sethi, Jeffrey D. Ullman. <em>Compilers: Principles, Techniques, and Tools</em>, <a href="http://www.amazon.com/exec/obidos/tg/detail/-/0201100886/104-0162389-6419108">http://www.amazon.com/exec/obidos/tg/detail/-/0201100886/104-0162389-6419108</a></li>
<li>[Wang97] Daniel C. Wang, Andrew W. Appel, Jeff L. Korn, and Chris S. Serra. The Zephyr Abstract Syntax Description Language. In <em>Proceedings of the Conference on Domain-Specific Languages</em>, pp. 213–227, 1997.</li>
<li>Skip Montanaro's Peephole Optimizer Paper (<a href="https://legacy.python.org/workshops/1998-11/proceedings/papers/montanaro/montanaro.html">https://legacy.python.org/workshops/1998-11/proceedings/papers/montanaro/montanaro.html</a>)</li>
<li>Bytecodehacks Project (<a href="http://bytecodehacks.sourceforge.net/bch-docs/bch/index.html">http://bytecodehacks.sourceforge.net/bch-docs/bch/index.html</a>)</li>
<li>CALL_ATTR opcode (<a href="https://bugs.python.org/issue709744">https://bugs.python.org/issue709744</a>)</li>
</ul>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy mb-4"><h4 class="text-sm font-medium text-gray-900 mb-2">카테고리</h4><span class="page__taxonomy-item">Python</span><span class="page__taxonomy-item">PEP</span></div><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[4281,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"185\",\"static/chunks/app/layout-8808afda01b7a1b7.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/339\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"iV6XySbMHIJ3imQdvgy3I\",\"assetPrefix\":\"/secrett2633.github.io\",\"initialCanonicalUrl\":\"/python/pep/339/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/339\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"339\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/339\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"32x32\",\"href\":\"/favicon-32x32.png\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"16x16\",\"href\":\"/favicon-16x16.png\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_9012cf layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T759e,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0339/\"\u003ePEP 339 - Design of the CPython Compiler\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Withdrawn | \u003cstrong\u003e유형:\u003c/strong\u003e Informational | \u003cstrong\u003e작성일:\u003c/strong\u003e 02-Feb-2005\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 이 PEP는 철회되었으며 Python 개발자 가이드로 이동되었습니다.\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e과거(Python 2.4까지)에는 소스 코드(source code)를 바이트코드(bytecode)로 컴파일하는 과정이 두 단계로 이루어졌습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e소스 코드를 파스 트리(parse tree)로 파싱합니다 (\u003ccode\u003eParser/pgen.c\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e파스 트리를 기반으로 바이트코드를 생성합니다 (\u003ccode\u003ePython/compile.c\u003c/code\u003e).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이는 일반적인 컴파일러의 작동 방식과는 다릅니다. 컴파일의 일반적인 단계는 다음과 같습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e소스 코드를 파스 트리로 파싱합니다 (\u003ccode\u003eParser/pgen.c\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e파스 트리를 추상 구문 트리(Abstract Syntax Tree, AST)로 변환합니다 (\u003ccode\u003ePython/ast.c\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003eAST를 제어 흐름 그래프(Control Flow Graph, CFG)로 변환합니다 (\u003ccode\u003ePython/compile.c\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e제어 흐름 그래프를 기반으로 바이트코드를 생성합니다 (\u003ccode\u003ePython/compile.c\u003c/code\u003e).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003ePython 2.5부터는 위에서 설명한 네 가지 단계가 사용됩니다. 이러한 변경은 컴파일 과정을 세 단계로 나누어 단순화하기 위해 이루어졌습니다. 이 문서는 프로세스의 마지막 세 단계가 어떻게 작동하는지 설명하는 것을 목표로 합니다.\u003c/p\u003e\n\u003cp\u003e이 문서는 컴파일에 필요한 설명을 넘어 파싱(parsing)이 작동하는 방식에 대해서는 다루지 않습니다. 또한, 전체 시스템이 작동하는 방식을 전부 다루지는 않습니다. 모든 세부 사항을 정확히 이해하려면 일부 소스 코드를 직접 읽어야 할 수도 있습니다.\u003c/p\u003e\n\u003ch2\u003e파스 트리 (Parse Trees)\u003c/h2\u003e\n\u003cp\u003ePython의 파서(parser)는 주로 \"Dragon Book\" [Aho86]에 설명된 구현을 기반으로 하는 LL(1) 파서입니다.\u003c/p\u003e\n\u003cp\u003ePython의 문법 파일은 \u003ccode\u003eGrammar/Grammar\u003c/code\u003e에서 찾을 수 있으며, 문법 규칙의 숫자 값은 \u003ccode\u003eInclude/graminit.h\u003c/code\u003e에 저장됩니다. 토큰(token) 유형(예: \u003ccode\u003e:\u003c/code\u003e, 숫자 등 리터럴 토큰)의 숫자 값은 \u003ccode\u003eInclude/token.h\u003c/code\u003e에 보관됩니다. 파스 트리는 \u003ccode\u003eInclude/node.h\u003c/code\u003e에 정의된 \u003ccode\u003enode *\u003c/code\u003e 구조체들로 구성됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enode\u003c/code\u003e 구조체에서 데이터를 조회하는 데는 다음 매크로(모두 \u003ccode\u003eInclude/token.h\u003c/code\u003e에 정의됨)를 사용할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCHILD(node *, int)\u003c/code\u003e: 0-오프셋 인덱싱을 사용하여 노드의 n번째 자식(child)을 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRCHILD(node *, int)\u003c/code\u003e: 노드의 오른쪽에서 n번째 자식을 반환합니다. 음수를 사용합니다!\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNCH(node *)\u003c/code\u003e: 노드가 가진 자식의 수를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSTR(node *)\u003c/code\u003e: 노드의 문자열 표현을 반환합니다. 예를 들어, \u003ccode\u003eCOLON\u003c/code\u003e 토큰에 대해 \u003ccode\u003e:\u003c/code\u003e를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTYPE(node *)\u003c/code\u003e: \u003ccode\u003eInclude/graminit.h\u003c/code\u003e에 지정된 노드의 유형을 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eREQ(node *, TYPE)\u003c/code\u003e: 노드가 예상된 유형인지 단언(assert)합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLINENO(node *)\u003c/code\u003e: 파스 규칙 생성으로 이어진 소스 코드의 줄 번호를 검색합니다. \u003ccode\u003ePython/ast.c\u003c/code\u003e에 정의되어 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 모든 것을 예시로 들기 위해 \u003ccode\u003e'while'\u003c/code\u003e 규칙을 고려해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewhile_stmt: 'while' test ':' suite ['else' ':' suite]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것을 나타내는 노드는 \u003ccode\u003eTYPE(node) == while_stmt\u003c/code\u003e가 되고, \u003ccode\u003eelse\u003c/code\u003e 문(statement)의 유무에 따라 자식의 수는 4개 또는 7개가 될 수 있습니다. 첫 번째 \u003ccode\u003e:\u003c/code\u003e에 접근하고 이것이 실제 \u003ccode\u003e:\u003c/code\u003e 토큰인지 확인하려면 \u003ccode\u003e(REQ(CHILD(node, 2), COLON))\u003c/code\u003e과 같이 사용합니다.\u003c/p\u003e\n\u003ch2\u003e추상 구문 트리 (Abstract Syntax Trees, AST)\u003c/h2\u003e\n\u003cp\u003e추상 구문 트리(AST)는 소스 코드를 포함할 필요 없이 프로그램 구조를 고수준으로 표현한 것입니다. 소스 코드의 추상적인 표현으로 생각할 수 있습니다. AST 노드의 사양은 Zephyr Abstract Syntax Definition Language (ASDL) [Wang97]을 사용하여 지정됩니다.\u003c/p\u003e\n\u003cp\u003ePython용 AST 노드의 정의는 파일 \u003ccode\u003eParser/Python.asdl\u003c/code\u003e에서 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e각 AST 노드(문, 표현식, 리스트 컴프리헨션(list comprehensions) 및 예외 핸들러(exception handlers)와 같은 여러 특수 유형을 나타냄)는 ASDL에 의해 정의됩니다. AST의 대부분의 정의는 \u003ccode\u003e'if'\u003c/code\u003e 문이나 속성 조회(attribute lookup)와 같은 특정 소스 구성 요소에 해당합니다. 이 정의는 특정 프로그래밍 언어에서의 구현과는 독립적입니다.\u003c/p\u003e\n\u003cp\u003e다음 Python ASDL 구성 요소의 일부는 접근 방식과 구문을 보여줍니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emodule Python {\n    stmt = FunctionDef(identifier name, arguments args, stmt* body, expr* decorators)\n         | Return(expr? value)\n         | Yield(expr value)\n         attributes (int lineno)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 예시는 세 가지 종류의 문(statements)을 설명합니다. 함수 정의(\u003ccode\u003eFunctionDef\u003c/code\u003e), 반환 문(\u003ccode\u003eReturn\u003c/code\u003e), 그리고 yield 문(\u003ccode\u003eYield\u003c/code\u003e)입니다. 세 가지 종류 모두 \u003ccode\u003e|\u003c/code\u003e로 구분되어 \u003ccode\u003estmt\u003c/code\u003e 유형으로 간주됩니다. 이들은 모두 다양한 종류와 수의 인자(arguments)를 취합니다.\u003c/p\u003e\n\u003cp\u003e인자 유형의 수정자(modifier)는 필요한 값의 수를 지정합니다.\n\u003ccode\u003e?\u003c/code\u003e는 선택 사항(optional)임을 의미하고, \u003ccode\u003e*\u003c/code\u003e는 0개 이상을 의미하며, 수정자가 없으면 인자에 대해 하나의 값만 필요하며 필수임을 의미합니다. 예를 들어, \u003ccode\u003eFunctionDef\u003c/code\u003e는 \u003ccode\u003ename\u003c/code\u003e에 대해 \u003ccode\u003eidentifier\u003c/code\u003e, \u003ccode\u003eargs\u003c/code\u003e에 대해 \u003ccode\u003earguments\u003c/code\u003e, \u003ccode\u003ebody\u003c/code\u003e에 대해 0개 이상의 \u003ccode\u003estmt\u003c/code\u003e 인자, \u003ccode\u003edecorators\u003c/code\u003e에 대해 0개 이상의 \u003ccode\u003eexpr\u003c/code\u003e 인자를 취합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003earguments\u003c/code\u003e와 같이 노드 유형인 것이 단일 AST 노드로 표현되며, 예상할 수 있는 \u003ccode\u003estmt\u003c/code\u003e와 같은 노드 시퀀스가 아님을 주목하십시오.\u003c/p\u003e\n\u003cp\u003e세 가지 종류 모두 \u003ccode\u003eattributes\u003c/code\u003e 인자를 가지고 있습니다. 이는 \u003ccode\u003eattributes\u003c/code\u003e 앞에 \u003ccode\u003e|\u003c/code\u003e가 없다는 사실로 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e위의 문 정의는 다음 C 구조체 유형을 생성합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct _stmt *stmt_ty;\nstruct _stmt {\n    enum { FunctionDef_kind=1, Return_kind=2, Yield_kind=3 } kind;\n    union {\n        struct {\n            identifier name;\n            arguments_ty args;\n            asdl_seq *body;\n        } FunctionDef;\n        struct {\n            expr_ty value;\n        } Return;\n        struct {\n            expr_ty value;\n        } Yield;\n    } v;\n    int lineno;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한, 적절한 초기화를 통해 \u003ccode\u003estmt_ty\u003c/code\u003e 구조체를 할당하는 일련의 생성자 함수(constructor functions)가 생성됩니다. \u003ccode\u003ekind\u003c/code\u003e 필드는 유니온(union)의 어떤 구성 요소가 초기화되는지를 지정합니다. \u003ccode\u003eFunctionDef()\u003c/code\u003e 생성자 함수는 \u003ccode\u003ekind\u003c/code\u003e를 \u003ccode\u003eFunctionDef_kind\u003c/code\u003e로 설정하고 \u003ccode\u003ename\u003c/code\u003e, \u003ccode\u003eargs\u003c/code\u003e, \u003ccode\u003ebody\u003c/code\u003e, \u003ccode\u003eattributes\u003c/code\u003e 필드를 초기화합니다.\u003c/p\u003e\n\u003ch2\u003e메모리 관리 (Memory Management)\u003c/h2\u003e\n\u003cp\u003e컴파일러의 실제 구현을 논의하기 전에 메모리 처리 방식에 대한 논의가 필요합니다. 메모리 관리를 단순화하기 위해 아레나(arena)가 사용됩니다. 이는 메모리가 할당 및 제거를 쉽게 하기 위해 단일 위치에 풀링(pooling)된다는 것을 의미합니다. 이를 통해 명시적인 메모리 할당 해제(deallocation)가 필요 없어집니다. 컴파일러에서 필요한 모든 메모리 할당이 해당 메모리를 아레나에 등록하기 때문에, 아레나를 해제하는 단일 호출만으로 컴파일러가 사용한 모든 메모리를 완전히 해제할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e일반적으로 컴파일러의 핵심 부분에서 작업하지 않는 한 메모리 관리는 완전히 무시할 수 있습니다. 그러나 컴파일러의 아주 초기 또는 마지막 부분에서 작업하는 경우 아레나가 작동하는 방식에 신경 써야 합니다. 아레나와 관련된 모든 코드는 \u003ccode\u003eInclude/pyarena.h\u003c/code\u003e 또는 \u003ccode\u003ePython/pyarena.c\u003c/code\u003e에 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyArena_New()\u003c/code\u003e는 새 아레나를 생성합니다. 반환된 \u003ccode\u003ePyArena\u003c/code\u003e 구조체는 주어진 모든 메모리에 대한 포인터를 저장합니다. 이는 컴파일러가 사용한 메모리를 마쳤을 때 어떤 메모리를 해제해야 하는지 장부 관리(bookkeeping)를 합니다. 이 해제는 \u003ccode\u003ePyArena_Free()\u003c/code\u003e를 통해 수행됩니다. 이는 컴파일러가 종료되는 전략적인 영역에서만 호출되어야 합니다.\u003c/p\u003e\n\u003cp\u003e위에 명시된 바와 같이, 일반적으로 컴파일러 작업 시 메모리 관리에 대해 걱정할 필요가 없습니다. 대부분의 경우 기술적인 세부 사항은 숨겨지도록 설계되었습니다.\u003c/p\u003e\n\u003cp\u003e유일한 예외는 \u003ccode\u003ePyObject\u003c/code\u003e를 관리할 때 발생합니다. Python의 나머지 부분이 참조 카운팅(reference counting)을 사용하기 때문에, 할당된 각 \u003ccode\u003ePyObject\u003c/code\u003e를 정리하기 위한 추가 지원이 아레나에 추가됩니다. 이러한 경우는 매우 드뭅니다. 그러나 \u003ccode\u003ePyObject\u003c/code\u003e를 할당했다면 \u003ccode\u003ePyArena_AddPyObject()\u003c/code\u003e를 호출하여 아레나에 알려야 합니다.\u003c/p\u003e\n\u003ch2\u003e파스 트리에서 AST로 (Parse Tree to AST)\u003c/h2\u003e\n\u003cp\u003eAST는 \u003ccode\u003ePyAST_FromNode()\u003c/code\u003e 함수를 사용하여 파스 트리에서 생성됩니다 ( \u003ccode\u003ePython/ast.c\u003c/code\u003e 참조).\u003c/p\u003e\n\u003cp\u003e이 함수는 파스 트리의 트리 워크(tree walk)를 시작하여 진행하면서 다양한 AST 노드를 생성합니다. 이를 위해 필요한 모든 새 노드를 할당하고, 필요한 지원 함수에 대해 적절한 AST 노드 생성 함수를 호출하며, 필요에 따라 노드를 연결합니다.\u003c/p\u003e\n\u003cp\u003e문법 사양과 파스 트리의 노드 사이에 자동화되거나 상징적인 연결이 없다는 점을 인지해야 합니다. \u003ccode\u003eyacc\u003c/code\u003e에서와 같이 파스 트리에 의해 직접적인 도움은 제공되지 않습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 작업 중인 파스 트리에서 어떤 노드를 다루고 있는지 계속 추적해야 합니다 (예: \u003ccode\u003e'if'\u003c/code\u003e 문을 다루고 있다면 조건문의 끝을 찾기 위해 \u003ccode\u003e:\u003c/code\u003e 토큰을 주시해야 합니다).\u003c/p\u003e\n\u003cp\u003e파스 트리에서 AST 노드를 생성하기 위해 호출되는 함수들은 모두 \u003ccode\u003east_for_xx\u003c/code\u003e라는 이름을 가지며, 여기서 \u003ccode\u003exx\u003c/code\u003e는 함수가 처리하는 문법 규칙입니다 (\u003ccode\u003ealias_for_import_name\u003c/code\u003e은 예외입니다). 이 함수들은 차례로 ASDL 문법에 의해 정의되고 \u003ccode\u003ePython/Python-ast.c\u003c/code\u003e에 포함된 생성자 함수( \u003ccode\u003eParser/asdl_c.py\u003c/code\u003e에 의해 생성됨)를 호출하여 AST의 노드를 생성합니다. 이 모든 과정은 \u003ccode\u003easdl_seq\u003c/code\u003e 구조체에 저장된 AST 노드 시퀀스로 이어집니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePython/asdl.c\u003c/code\u003e 및 \u003ccode\u003eInclude/asdl.h\u003c/code\u003e에서 찾을 수 있는 \u003ccode\u003easdl_seq *\u003c/code\u003e 유형을 생성하고 사용하는 함수 및 매크로:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003easdl_seq_new()\u003c/code\u003e: 지정된 길이에 대한 \u003ccode\u003easdl_seq\u003c/code\u003e에 메모리를 할당합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easdl_seq_GET()\u003c/code\u003e: \u003ccode\u003easdl_seq\u003c/code\u003e의 특정 위치에 있는 항목을 가져옵니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easdl_seq_SET()\u003c/code\u003e: \u003ccode\u003easdl_seq\u003c/code\u003e의 특정 인덱스를 지정된 값으로 설정합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easdl_seq_LEN(asdl_seq *)\u003c/code\u003e: \u003ccode\u003easdl_seq\u003c/code\u003e의 길이를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e문을 다루는 경우, 문을 생성한 줄 번호를 추적하는 것에 대해서도 신경 써야 합니다. 현재 줄 번호는 각 \u003ccode\u003estmt_ty\u003c/code\u003e 함수의 마지막 매개변수로 전달됩니다.\u003c/p\u003e\n\u003ch2\u003e제어 흐름 그래프 (Control Flow Graphs)\u003c/h2\u003e\n\u003cp\u003e제어 흐름 그래프(Control Flow Graph, 약어 CFG로 자주 참조됨)는 블록 내에 중간 표현(Intermediate Representation, 약어 IR; 여기서는 Python 바이트코드)을 포함하는 기본 블록(basic blocks)을 사용하여 프로그램의 흐름을 모델링하는 방향 그래프(directed graph)입니다. 기본 블록 자체는 단일 진입점(entry point)을 가지지만 여러 개의 종료점(exit points)을 가질 수 있는 IR 블록입니다. 단일 진입점은 기본 블록의 핵심입니다. 이는 모두 점프(jumps)와 관련이 있습니다. 진입점은 제어 흐름을 변경하는 것(함수 호출이나 점프와 같은)의 대상인 반면, 종료점은 프로그램의 흐름을 변경하는 명령(점프나 \u003ccode\u003e'return'\u003c/code\u003e 문과 같은)입니다. 이는 기본 블록이 진입점에서 시작하여 종료점 또는 블록의 끝까지 실행되는 코드 조각임을 의미합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003eelse\u003c/code\u003e 블록이 있는 \u003ccode\u003e'if'\u003c/code\u003e 문을 생각해 봅시다. \u003ccode\u003e'if'\u003c/code\u003e 문의 가드(guard)는 \u003ccode\u003e'if'\u003c/code\u003e 문으로 이어지는 코드를 포함하는 기본 블록이 가리키는 기본 블록입니다. \u003ccode\u003e'if'\u003c/code\u003e 문 블록은 \u003ccode\u003e'if'\u003c/code\u003e의 참(true) 본문과 \u003ccode\u003e'else'\u003c/code\u003e 본문(NULL일 수 있음)으로의 점프(종료점)를 포함하며, 각각은 자체 기본 블록입니다. 이 두 블록은 차례로 전체 \u003ccode\u003e'if'\u003c/code\u003e 문 다음에 오는 코드를 나타내는 기본 블록을 가리킵니다.\u003c/p\u003e\n\u003cp\u003eCFG는 일반적으로 최종 코드 출력의 한 단계 전입니다. 코드는 CFG에서 에지를 따라 후위 깊이 우선 탐색(post-order depth-first search)을 수행하여 기본 블록에서 직접 생성됩니다 (점프 대상은 출력 순서에 따라 조정됨).\u003c/p\u003e\n\u003ch2\u003eAST에서 CFG로, CFG에서 바이트코드로 (AST to CFG to Bytecode)\u003c/h2\u003e\n\u003cp\u003eAST가 생성되면 다음 단계는 CFG를 생성하는 것입니다. 첫 번째 단계는 점프 대상을 특정 오프셋으로 해결하지 않고 AST를 Python 바이트코드로 변환하는 것입니다 (이는 CFG가 최종 바이트코드로 변환될 때 계산됩니다). 본질적으로 이것은 AST를 제어 흐름이 CFG의 에지로 표현되는 Python 바이트코드로 변환합니다.\u003c/p\u003e\n\u003cp\u003e변환은 두 번의 패스(pass)로 수행됩니다. 첫 번째 패스는 네임스페이스(namespace)를 생성합니다 (변수는 클로저(closures)의 경우 로컬(local), 자유/셀(free/cell) 또는 전역(global)으로 분류될 수 있습니다). 이것이 완료되면 두 번째 패스는 본질적으로 CFG를 리스트로 평탄화(flatten)하고 바이트코드의 최종 출력을 위한 점프 오프셋(jump offsets)을 계산합니다.\u003c/p\u003e\n\u003cp\u003e변환 프로세스는 \u003ccode\u003ePython/compile.c\u003c/code\u003e의 \u003ccode\u003ePyAST_Compile()\u003c/code\u003e 함수 호출에 의해 시작됩니다. 이 함수는 AST를 CFG로 변환하고 CFG에서 최종 바이트코드를 출력하는 두 가지 작업을 모두 수행합니다. AST를 CFG로 변환하는 단계는 \u003ccode\u003ePyAST_Compile()\u003c/code\u003e에 의해 호출되는 두 함수 \u003ccode\u003ePySymtable_Build()\u003c/code\u003e와 \u003ccode\u003ecompiler_mod()\u003c/code\u003e에 의해 주로 처리됩니다. 전자는 \u003ccode\u003ePython/symtable.c\u003c/code\u003e에 있고 후자는 \u003ccode\u003ePython/compile.c\u003c/code\u003e에 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePySymtable_Build()\u003c/code\u003e는 AST의 시작 코드 블록(전달된)으로 들어가서 적절한 \u003ccode\u003esymtable_visit_xx\u003c/code\u003e 함수(여기서 \u003ccode\u003exx\u003c/code\u003e는 AST 노드 유형)를 호출하는 것으로 시작합니다. 다음으로, AST 트리는 \u003ccode\u003esymtable_enter_block()\u003c/code\u003e 및 \u003ccode\u003esymtable_exit_block()\u003c/code\u003e을 각각 사용하여 블록에 들어가고 나올 때 로컬 변수의 범위(reach)를 나타내는 다양한 코드 블록으로 탐색됩니다.\u003c/p\u003e\n\u003cp\u003e심볼 테이블(symbol table)이 생성되면 \u003ccode\u003ePython/compile.c\u003c/code\u003e에 코드가 있는 CFG 생성 시간입니다. 이는 다양한 AST 노드 유형별로 작업을 세분화하는 여러 함수에 의해 처리됩니다. 함수는 모두 \u003ccode\u003ecompiler_visit_xx\u003c/code\u003e라는 이름을 가지며, 여기서 \u003ccode\u003exx\u003c/code\u003e는 노드 유형의 이름입니다 (예: \u003ccode\u003estmt\u003c/code\u003e, \u003ccode\u003eexpr\u003c/code\u003e 등). 각 함수는 \u003ccode\u003estruct compiler *\u003c/code\u003e와 \u003ccode\u003exx_ty\u003c/code\u003e를 받는데, 여기서 \u003ccode\u003exx\u003c/code\u003e는 AST 노드 유형입니다. 일반적으로 이러한 함수는 전달된 노드 유형에 따라 분기되는 큰 \u003ccode\u003eswitch\u003c/code\u003e 문으로 구성됩니다. 간단한 것들은 \u003ccode\u003eswitch\u003c/code\u003e 문에서 인라인(inline)으로 처리되며, 더 복잡한 변환은 \u003ccode\u003ecompiler_xx\u003c/code\u003e라는 다른 함수로 위임됩니다 (여기서 \u003ccode\u003exx\u003c/code\u003e는 처리되는 내용을 설명하는 이름).\u003c/p\u003e\n\u003cp\u003e임의의 AST 노드를 변환할 때는 \u003ccode\u003eVISIT()\u003c/code\u003e 매크로를 사용합니다. \u003ccode\u003e\u0026#x3C;node type\u003e\u003c/code\u003e에 전달된 값에 따라 적절한 \u003ccode\u003ecompiler_visit_xx\u003c/code\u003e 함수가 호출됩니다 (따라서 \u003ccode\u003eVISIT(c, expr, node)\u003c/code\u003e는 \u003ccode\u003ecompiler_visit_expr(c, node)\u003c/code\u003e를 호출합니다). \u003ccode\u003eVISIT_SEQ\u003c/code\u003e 매크로는 매우 유사하지만, AST 노드 시퀀스( \u003ccode\u003e*\u003c/code\u003e 수정자를 사용한 노드의 인자로 생성된 값들)에 대해 호출됩니다. 슬라이스(slices) 처리를 위한 \u003ccode\u003eVISIT_SLICE()\u003c/code\u003e도 있습니다.\u003c/p\u003e\n\u003cp\u003e바이트코드 생성은 다음 매크로에 의해 처리됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eADDOP()\u003c/code\u003e: 지정된 opcode를 추가합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eADDOP_I()\u003c/code\u003e: 인자를 취하는 opcode를 추가합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eADDOP_O(struct compiler *c, int op, PyObject *type, PyObject *obj)\u003c/code\u003e: \u003ccode\u003ePyObject\u003c/code\u003e 시퀀스 객체에서 지정된 \u003ccode\u003ePyObject\u003c/code\u003e의 위치에 따라 적절한 인자와 함께 opcode를 추가하지만, 이름 맹글링(name mangling) 처리는 하지 않습니다. 이름 맹글링이 불가능하고 이름의 범위가 알려진 전역 변수(globals), 상수(consts) 또는 매개변수(parameters)와 같은 객체의 이름 기반 조회가 필요한 경우에 사용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eADDOP_NAME()\u003c/code\u003e: \u003ccode\u003eADDOP_O\u003c/code\u003e와 유사하지만, 이름 맹글링도 처리됩니다. 이름 기반 속성 로딩(attribute loading) 또는 임포팅(importing)에 사용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eADDOP_JABS()\u003c/code\u003e: 기본 블록으로의 절대 점프(absolute jump)를 생성합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eADDOP_JREL()\u003c/code\u003e: 기본 블록으로의 상대 점프(relative jump)를 생성합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e바이트코드를 생성하는 여러 헬퍼 함수들은 \u003ccode\u003ecompiler_xx()\u003c/code\u003e로 명명되며, 여기서 \u003ccode\u003exx\u003c/code\u003e는 함수가 돕는 내용입니다 (예: \u003ccode\u003elist\u003c/code\u003e, \u003ccode\u003eboolop\u003c/code\u003e 등). 특히 유용한 것 중 하나는 \u003ccode\u003ecompiler_nameop()\u003c/code\u003e입니다. 이 함수는 변수의 범위를 조회하고 표현식 컨텍스트(expression context)에 따라 변수를 로드(load), 저장(store) 또는 삭제(delete)하는 적절한 opcode를 생성합니다.\u003c/p\u003e\n\u003cp\u003e문이 정의된 줄 번호를 처리하는 것은 \u003ccode\u003ecompiler_visit_stmt()\u003c/code\u003e에 의해 처리되므로 걱정할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003eAST 노드를 기반으로 바이트코드를 생성하는 것 외에도 기본 블록 생성도 처리해야 합니다. 기본 블록을 관리하는 데 사용되는 매크로 및 함수는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eNEW_BLOCK()\u003c/code\u003e: 블록을 생성하고 현재 블록으로 설정합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNEXT_BLOCK()\u003c/code\u003e: 기본적으로 \u003ccode\u003eNEW_BLOCK()\u003c/code\u003e에 현재 블록에서의 점프 기능이 추가됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecompiler_new_block()\u003c/code\u003e: 블록을 생성하지만 사용하지는 않습니다 (점프 생성에 사용됨).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCFG가 생성되면 평탄화(flatten)되어야 하며, 그 후에 최종 바이트코드 생성이 이루어집니다. 평탄화는 후위 깊이 우선 탐색(post-order depth-first search)을 사용하여 처리됩니다. 평탄화되면 평탄화에 따라 점프 오프셋이 백패치(backpatched)되고 \u003ccode\u003ePyCodeObject\u003c/code\u003e 파일이 생성됩니다. 이 모든 것은 \u003ccode\u003eassemble()\u003c/code\u003e 호출에 의해 처리됩니다.\u003c/p\u003e\n\u003ch2\u003e새 바이트코드 도입 (Introducing New Bytecode)\u003c/h2\u003e\n\u003cp\u003e때로는 새로운 기능에 새로운 opcode가 필요할 수 있습니다. 그러나 새로운 바이트코드를 추가하는 것은 컴파일러의 AST -\u003e 바이트코드 단계에서 단순히 새로운 바이트코드를 갑자기 도입하는 것만큼 간단하지 않습니다. Python 전반의 여러 코드 조각은 어떤 바이트코드가 존재하는지에 대한 정확한 정보에 의존합니다.\u003c/p\u003e\n\u003cp\u003e첫째, 이름과 고유 식별 번호를 선택해야 합니다. opcode의 공식 목록은 \u003ccode\u003eInclude/opcode.h\u003c/code\u003e에서 찾을 수 있습니다. opcode가 인자를 취해야 하는 경우, \u003ccode\u003eHAVE_ARGUMENT\u003c/code\u003e ( \u003ccode\u003eInclude/opcode.h\u003c/code\u003e에 있음)에 할당된 숫자보다 큰 고유 번호를 부여해야 합니다.\u003c/p\u003e\n\u003cp\u003e이름/번호 쌍이 선택되고 \u003ccode\u003eInclude/opcode.h\u003c/code\u003e에 입력되면 \u003ccode\u003eLib/opcode.py\u003c/code\u003e와 \u003ccode\u003eDoc/library/dis.rst\u003c/code\u003e에도 입력해야 합니다.\u003c/p\u003e\n\u003cp\u003e새로운 바이트코드를 사용하려면 \u003ccode\u003e.pyc\u003c/code\u003e 파일의 매직 넘버(magic number)도 변경해야 합니다. \u003ccode\u003ePython/import.c\u003c/code\u003e의 \u003ccode\u003eMAGIC\u003c/code\u003e 변수에 이 숫자가 포함되어 있습니다. 이 숫자를 변경하면 이전 \u003ccode\u003eMAGIC\u003c/code\u003e을 가진 모든 \u003ccode\u003e.pyc\u003c/code\u003e 파일이 임포트(import) 시 인터프리터(interpreter)에 의해 다시 컴파일됩니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 새로운 바이트코드의 사용을 도입해야 합니다. \u003ccode\u003ePython/compile.c\u003c/code\u003e와 \u003ccode\u003ePython/ceval.c\u003c/code\u003e를 변경하는 것이 주된 변경 장소가 될 것입니다. 그러나 \u003ccode\u003e'compiler'\u003c/code\u003e 패키지도 변경해야 합니다. 이를 위한 주요 파일은 \u003ccode\u003eLib/compiler/pyassem.py\u003c/code\u003e와 \u003ccode\u003eLib/compiler/pycodegen.py\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e기존 바이트코드의 출력에 영향을 미칠 수 있는 변경을 하고 매직 넘버를 계속 변경하지 않는 경우, 이전 \u003ccode\u003e.py(c|o)\u003c/code\u003e 파일을 삭제해야 합니다! 바이트코드를 변경하면 결국 매직 넘버를 변경하게 되겠지만, 디버깅 중에는 매직 넘버를 계속 올리지 않고 바이트코드 출력을 변경할 것입니다. 이는 만료된(stale) \u003ccode\u003e.pyc\u003c/code\u003e 파일이 다시 생성되지 않을 수 있음을 의미합니다. \u003ccode\u003efind . -name '*.py[co]' -exec rm -f {} ';'\u003c/code\u003e를 실행하면 가지고 있는 모든 \u003ccode\u003e.pyc\u003c/code\u003e 파일이 삭제되어 새 파일이 생성되도록 강제하고 새 바이트코드를 제대로 테스트할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e코드 객체 (Code Objects)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ePyAST_Compile()\u003c/code\u003e의 결과는 \u003ccode\u003eInclude/code.h\u003c/code\u003e에 정의된 \u003ccode\u003ePyCodeObject\u003c/code\u003e입니다. 이제 실행 가능한 Python 바이트코드를 갖게 된 것입니다!\u003c/p\u003e\n\u003cp\u003e코드 객체(바이트코드)는 \u003ccode\u003ePython/ceval.c\u003c/code\u003e에서 실행됩니다. 이 파일은 \u003ccode\u003ePyEval_EvalFrameEx()\u003c/code\u003e의 큰 \u003ccode\u003eswitch\u003c/code\u003e 문에 새 opcode에 대한 새 \u003ccode\u003ecase\u003c/code\u003e 문이 필요합니다.\u003c/p\u003e\n\u003ch2\u003e주요 파일 (Important Files)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eParser/\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePython.asdl\u003c/code\u003e: ASDL 구문 파일.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easdl.py\u003c/code\u003e: \"Zephyr Abstract Syntax Definition Language의 구현.\" ASDL 파일을 파싱하기 위해 SPARK를 사용합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easdl_c.py\u003c/code\u003e: \"ASDL 설명에서 C 코드를 생성합니다.\" \u003ccode\u003ePython/Python-ast.c\u003c/code\u003e와 \u003ccode\u003eInclude/Python-ast.h\u003c/code\u003e를 생성합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003espark.py\u003c/code\u003e: SPARK 파서 생성기.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ePython/\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePython-ast.c\u003c/code\u003e: ASDL 유형에 해당하는 C 구조체를 생성합니다. 또한 AST 노드를 마샬링(marshaling)하는 코드도 포함합니다 (핵심 ASDL 유형은 \u003ccode\u003easdl.c\u003c/code\u003e에 마샬링 코드가 있습니다). \"Parser/asdl_c.py에 의해 자동으로 생성된 파일\". 이 파일은 문법 변경이 커밋될 때마다 \u003ccode\u003e__version__\u003c/code\u003e 값이 최신 문법 변경 개정 번호로 설정되므로 별도로 커밋되어야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easdl.c\u003c/code\u003e: ASDL 시퀀스 유형을 처리하는 코드를 포함합니다. 또한 숫자 및 식별자(identifier)와 같은 핵심 ASDL 유형을 마샬링하는 코드도 있습니다. AST 노드를 마샬링하기 위해 \u003ccode\u003ePython-ast.c\u003c/code\u003e에서 사용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003east.c\u003c/code\u003e: Python의 파스 트리를 추상 구문 트리로 변환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eceval.c\u003c/code\u003e: 바이트코드를 실행합니다 (eval loop).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecompile.c\u003c/code\u003e: AST를 기반으로 바이트코드를 생성합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esymtable.c\u003c/code\u003e: AST에서 심볼 테이블을 생성합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epyarena.c\u003c/code\u003e: 아레나 메모리 관리자의 구현.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eimport.c\u003c/code\u003e: 바이트코드 버전 관리를 위한 매직 넘버 (\u003ccode\u003eMAGIC\u003c/code\u003e)의 본거지.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eInclude/\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePython-ast.h\u003c/code\u003e: \u003ccode\u003ePython/Python-ast.c\u003c/code\u003e에 의해 생성된 C 구조체의 실제 정의를 포함합니다. \"Parser/asdl_c.py에 의해 자동으로 생성됨\".\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easdl.h\u003c/code\u003e: 해당 \u003ccode\u003ePython/ast.c\u003c/code\u003e의 헤더.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003east.h\u003c/code\u003e: \u003ccode\u003ePyAST_FromNode()\u003c/code\u003e를 외부( \u003ccode\u003ePython/ast.c\u003c/code\u003e에서)로 선언합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecode.h\u003c/code\u003e: \u003ccode\u003eObjects/codeobject.c\u003c/code\u003e의 헤더 파일; \u003ccode\u003ePyCodeObject\u003c/code\u003e의 정의를 포함합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esymtable.h\u003c/code\u003e: \u003ccode\u003ePython/symtable.c\u003c/code\u003e의 헤더. \u003ccode\u003estruct symtable\u003c/code\u003e과 \u003ccode\u003ePySTEntryObject\u003c/code\u003e가 여기에 정의됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epyarena.h\u003c/code\u003e: 해당 \u003ccode\u003ePython/pyarena.c\u003c/code\u003e의 헤더 파일.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eopcode.h\u003c/code\u003e: 바이트코드의 마스터 리스트; 이 파일이 수정되면 다른 여러 파일도 그에 따라 수정해야 합니다 (\"새 바이트코드 도입\" 참조).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eObjects/\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecodeobject.c\u003c/code\u003e: \u003ccode\u003ePyCodeObject\u003c/code\u003e 관련 코드를 포함합니다 (원래 \u003ccode\u003ePython/compile.c\u003c/code\u003e에 있었음).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eLib/\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eopcode.py\u003c/code\u003e: \u003ccode\u003eInclude/opcode.h\u003c/code\u003e가 수정되면 수정해야 하는 파일 중 하나.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ecompiler/\u003c/code\u003e\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epyassem.py\u003c/code\u003e: \u003ccode\u003eInclude/opcode.h\u003c/code\u003e가 변경되면 수정해야 하는 파일 중 하나.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epycodegen.py\u003c/code\u003e: \u003ccode\u003eInclude/opcode.h\u003c/code\u003e가 변경되면 수정해야 하는 파일 중 하나.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e알려진 컴파일러 관련 실험 (Known Compiler-related Experiments)\u003c/h2\u003e\n\u003cp\u003e이 섹션에서는 컴파일러(바이트코드 포함)와 관련된 알려진 실험을 나열합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSkip Montanaro는 Python 워크숍에서 Peephole Optimizer에 대한 논문을 발표했습니다.\u003c/li\u003e\n\u003cli\u003eMichael Hudson은 바이트코드를 직접 다루는 기능을 제공하는 \u003ccode\u003eBytecodehacks\u003c/code\u003e라는 비활성 SourceForge 프로젝트를 가지고 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLOAD_ATTR\u003c/code\u003e/\u003ccode\u003eCALL_FUNCTION\u003c/code\u003e의 기능을 결합하는 \u003ccode\u003eCALL_ATTR\u003c/code\u003e이라는 opcode가 생성되었습니다. 현재는 클래식 클래스(classic classes)에서만 작동하며, 신식 클래스(new-style classes)의 경우 클래식 클래스와 신식 클래스를 모두 지원해야 하는 문제로 인해 실제 속도 저하가 발생한다는 벤치마킹 결과가 있었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e참고 자료 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e[Aho86] Alfred V. Aho, Ravi Sethi, Jeffrey D. Ullman. \u003cem\u003eCompilers: Principles, Techniques, and Tools\u003c/em\u003e, \u003ca href=\"http://www.amazon.com/exec/obidos/tg/detail/-/0201100886/104-0162389-6419108\"\u003ehttp://www.amazon.com/exec/obidos/tg/detail/-/0201100886/104-0162389-6419108\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[Wang97] Daniel C. Wang, Andrew W. Appel, Jeff L. Korn, and Chris S. Serra. The Zephyr Abstract Syntax Description Language. In \u003cem\u003eProceedings of the Conference on Domain-Specific Languages\u003c/em\u003e, pp. 213–227, 1997.\u003c/li\u003e\n\u003cli\u003eSkip Montanaro's Peephole Optimizer Paper (\u003ca href=\"https://legacy.python.org/workshops/1998-11/proceedings/papers/montanaro/montanaro.html\"\u003ehttps://legacy.python.org/workshops/1998-11/proceedings/papers/montanaro/montanaro.html\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003eBytecodehacks Project (\u003ca href=\"http://bytecodehacks.sourceforge.net/bch-docs/bch/index.html\"\u003ehttp://bytecodehacks.sourceforge.net/bch-docs/bch/index.html\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003eCALL_ATTR opcode (\u003ca href=\"https://bugs.python.org/issue709744\"\u003ehttps://bugs.python.org/issue709744\u003c/a\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Withdrawn] PEP 339 - Design of the CPython Compiler\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 18:46:48+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"page__taxonomy mb-4\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"카테고리\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":\"Python\"}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":\"PEP\"}]]]}],[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]]}]]}]}]}]\nb:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":"])</script><script>self.__next_f.push([1,"\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"21\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>