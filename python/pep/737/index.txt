3:I[9275,[],""]
5:I[1343,[],""]
6:I[4281,["231","static/chunks/231-c4b666723e6aae68.js","185","static/chunks/app/layout-8808afda01b7a1b7.js"],"default"]
7:I[231,["231","static/chunks/231-c4b666723e6aae68.js","877","static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js"],""]
4:["slug","python/pep/737","c"]
0:["iV6XySbMHIJ3imQdvgy3I",[[["",{"children":[["slug","python/pep/737","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"737\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/737","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","link",null,{"rel":"icon","type":"image/png","sizes":"32x32","href":"/favicon-32x32.png"}],["$","link",null,{"rel":"icon","type":"image/png","sizes":"16x16","href":"/favicon-16x16.png"}],["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_9012cf layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T62cf,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0737/">PEP 737 - C API to format a type fully qualified name</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 29-Nov-2023</p>
</blockquote>
<h1>PEP 737 – 타입의 Fully Qualified Name 포맷을 위한 C API</h1>
<h2>개요</h2>
<p>이 문서는 PEP 737, "C API to format a type fully qualified name"의 내용을 한국어 사용자가 이해하기 쉽게 번역하고 설명합니다. Python 개발자들이 이 PEP의 제안 내용, 도입 배경, 그리고 실제 Python 사용에 미치는 영향을 명확하게 이해할 수 있도록 돕는 것이 목표입니다.</p>
<hr>
<p><strong>PEP 737 – C API to format a type fully qualified name</strong></p>
<ul>
<li><strong>작성자:</strong> Victor Stinner </li>
<li><strong>토론:</strong> <a href="https://discuss.python.org/t/pep-737-c-api-to-format-a-type-fully-qualified-name/34988">Discourse thread</a></li>
<li><strong>상태:</strong> Final (최종)</li>
<li><strong>유형:</strong> Standards Track (표준 트랙)</li>
<li><strong>생성일:</strong> 2023년 11월 29일</li>
<li><strong>Python 버전:</strong> 3.13</li>
<li><strong>게시 이력:</strong> 2023년 11월 29일</li>
<li><strong>결정:</strong> <a href="https://discuss.python.org/t/pep-737-unify-type-name-formatting/35048/17">Discourse message</a></li>
</ul>
<h2>Abstract (요약)</h2>
<p>이 PEP는 타입의 Fully Qualified Name (완전한 정규화된 이름)을 포맷하기 위한 새로운 C API를 추가할 것을 제안합니다. 이는 타입이 어떻게 구현되었는지에 따라 다르게 포맷되는 문제를 해결하여, 타입 이름 포맷팅 방식을 통일하는 것을 목표로 합니다.</p>
<p>새로운 C 코드에서 에러 메시지나 <code>__repr__()</code> 메서드에 타입의 Fully Qualified Name을 사용하는 것을 권장하며, 타입 이름을 잘라내지(truncate) 않도록 권고합니다.</p>
<p><code>PyUnicode_FromFormat()</code> 함수에 <code> %T</code>, <code> %#T</code>, <code> %N</code>, <code> %#N</code>과 같은 새로운 포맷을 추가하여 객체 타입과 일반 타입의 Fully Qualified Name을 포맷할 수 있도록 합니다. 또한, C 코드에서 <code>borrowed reference</code> (빌린 참조)로 인한 잠재적인 충돌을 방지하여 코드를 더욱 안전하게 만듭니다. 이 새로운 C API는 Limited C API와도 호환됩니다.</p>
<h2>Rationale (도입 배경)</h2>
<p>Python 표준 라이브러리에서는 에러 메시지를 포맷하거나 <code>__repr__()</code> 메서드를 구현할 때 타입 이름이나 객체의 타입 이름을 포맷하는 것이 흔한 작업입니다. 그러나 이러한 타입 이름을 포맷하는 방식에 따라 다른 결과가 나올 수 있습니다.</p>
<p><code>datetime.timedelta</code> 타입을 예로 들면:</p>
<ul>
<li>타입의 짧은 이름 (<code>type.__name__</code>)과 Qualified Name (<code>type.__qualname__</code>)은 <code>'timedelta'</code>입니다.</li>
<li>타입의 모듈 (<code>type.__module__</code>)은 <code>'datetime'</code>입니다.</li>
<li>타입의 Fully Qualified Name은 <code>'datetime.timedelta'</code>입니다.</li>
<li>타입의 표현 (<code>repr(type)</code>)은 Fully Qualified Name을 포함합니다: <code>&#x3C;class 'datetime.timedelta'></code>.</li>
</ul>
<h3>Python 코드</h3>
<p>Python에서는 <code>type.__name__</code>을 사용하여 타입의 짧은 이름을 얻고, <code>f"{type.__module__}.{type.__qualname__}"</code>과 같이 포맷하여 타입의 "Fully Qualified Name"을 얻습니다. <code>type(obj)</code> 또는 <code>obj.__class__</code>는 객체 <code>obj</code>의 타입을 얻는 데 사용됩니다.</p>
<p>예시:</p>
<pre><code class="language-python">raise TypeError("str expected, not %s" % type(value).__name__)
raise TypeError("can't serialize %s" % self.__class__.__name__)
name = "%s.%s" % (obj.__module__, obj.__qualname__)
</code></pre>
<p>Qualified Name은 PEP 3155 "Qualified name for classes and functions"에 따라 Python 3.3에서 타입에 추가되었습니다.</p>
<h3>C 코드</h3>
<p>C 코드에서 타입 이름을 포맷하는 가장 일반적인 방법은 타입의 <code>PyTypeObject.tp_name</code> 멤버를 가져오는 것입니다.</p>
<p>예시:</p>
<pre><code class="language-c">PyErr_Format(PyExc_TypeError, "globals must be a dict, not %.100s", Py_TYPE(globals)->tp_name);
</code></pre>
<p>타입의 "Fully Qualified Name"은 <code>PyErr_Display()</code>, <code>type.__repr__()</code> 구현, <code>sys.unraisablehook</code> 구현 등 일부 경우에 사용됩니다.</p>
<p><code>Py_TYPE(obj)->tp_name</code>을 사용하는 것이 <code>PyType_GetQualName()</code>을 호출하는 것보다 편리하므로 선호되지만, <code>PyType_GetQualName()</code>은 Python 3.11에서야 추가되었습니다.</p>
<p>일부 함수는 타입 이름을 포맷하기 위해 <code>%R</code> (<code>repr(type)</code>)을 사용하며, 이 경우 출력에 타입의 Fully Qualified Name이 포함됩니다.</p>
<p>예시:</p>
<pre><code class="language-c">PyErr_Format(PyExc_TypeError, "calling %R should have returned an instance "
                               "of BaseException, not %R", type, Py_TYPE(value));
</code></pre>
<h3><code>PyTypeObject.tp_name</code> 사용의 Python과의 불일치</h3>
<p><code>PyTypeObject.tp_name</code> 멤버는 타입 구현 방식에 따라 다릅니다.</p>
<ul>
<li>C의 정적 타입(Static types) 및 힙 타입(heap types): <code>tp_name</code>은 타입의 Fully Qualified Name입니다.</li>
<li>Python 클래스: <code>tp_name</code>은 타입의 짧은 이름 (<code>type.__name__</code>)입니다.</li>
</ul>
<p>따라서 <code>Py_TYPE(obj)->tp_name</code>을 사용하여 객체 타입 이름을 포맷하면, 타입이 C로 구현되었는지 Python으로 구현되었는지에 따라 다른 출력을 제공합니다. 이는 Python으로 작성된 코드와 C로 작성된 코드가 동일하게 동작해야 한다는 PEP 399 "Pure Python/C Accelerator Module Compatibility Requirements" 원칙에 위배됩니다.</p>
<p>예시:</p>
<pre><code class="language-python">$ python3.12
>>> import _datetime; c_obj = _datetime.date(1970, 1, 1)
>>> import _pydatetime; py_obj = _pydatetime.date(1970, 1, 1)
>>> my_list = list(range(3))
>>> my_list[c_obj] # C type
TypeError: list indices must be integers or slices, not datetime.date
>>> my_list[py_obj] # Python type
TypeError: list indices must be integers or slices, not date
</code></pre>
<p>위 예시에서 C로 구현된 타입은 Fully Qualified Name (<code>datetime.date</code>)을, Python으로 구현된 타입은 짧은 이름 (<code>date</code>)을 에러 메시지에 사용합니다.</p>
<h3>Limited C API</h3>
<p><code>Py_TYPE(obj)->tp_name</code> 코드는 <code>PyTypeObject</code> 멤버가 Limited C API에서 제외되므로 Limited C API와 함께 사용할 수 없습니다. 대신 <code>PyType_GetName()</code>, <code>PyType_GetQualName()</code>, <code>PyType_GetModule()</code> 함수를 사용하여 타입 이름을 읽어야 하지만, 이들은 사용하기에 덜 편리합니다.</p>
<h3>C에서 타입 이름 잘라내기 (Truncating type names)</h3>
<p>1998년 <code>PyErr_Format()</code> 함수가 추가되었을 때, 이 구현은 500바이트의 고정 버퍼를 사용했습니다. 당시 함수에는 <code>/* Caller is responsible for limiting the format */</code>이라는 주석이 있었습니다.</p>
<p>2001년에 이 함수는 힙에 동적 버퍼를 할당하도록 수정되었지만, <code>%.100s</code>와 같이 타입 이름을 잘라내는 관행은 이미 습관화되었고 개발자들은 타입 이름이 왜 잘려야 하는지 잊어버렸습니다. Python에서는 타입 이름이 잘리지 않습니다.</p>
<p>C에서는 타입 이름을 잘라내고 Python에서는 그렇지 않은 것은 PEP 399 "Pure Python/C Accelerator Module Compatibility Requirements" 원칙에 위배됩니다.</p>
<p>관련 이슈: <a href="https://github.com/python/cpython/issues/52178">Replace %.100s by %s in PyErr_Format(): the arbitrary limit of 500 bytes is outdated (2011)</a>.</p>
<h2>Specification (세부 사항)</h2>
<p>이 PEP는 다음을 제안합니다:</p>
<ul>
<li><code>PyType_GetFullyQualifiedName()</code> 함수 추가.</li>
<li><code>PyType_GetModuleName()</code> 함수 추가.</li>
<li><code>PyUnicode_FromFormat()</code>에 새로운 포맷 추가.</li>
<li>새로운 C 코드에서 에러 메시지 및 <code>__repr__()</code> 메서드에 타입의 Fully Qualified Name을 사용하는 것을 권장.</li>
<li>새로운 C 코드에서 타입 이름을 잘라내지 않도록 권장.</li>
</ul>
<h3><code>PyType_GetFullyQualifiedName()</code> 함수 추가</h3>
<p>타입의 Fully Qualified Name을 얻기 위한 <code>PyType_GetFullyQualifiedName()</code> 함수를 추가합니다. 이는 <code>f"{type.__module__}.{type.__qualname__}"</code>과 유사하며, <code>type.__module__</code>이 문자열이 아니거나 <code>"builtins"</code> 또는 <code>"__main__"</code>과 같으면 <code>type.__qualname__</code>을 반환합니다.</p>
<p>API:</p>
<pre><code class="language-c">PyObject* PyType_GetFullyQualifiedName(PyTypeObject *type)
</code></pre>
<p>성공 시, 문자열에 대한 새로운 참조를 반환합니다. 에러 발생 시, 예외를 발생시키고 <code>NULL</code>을 반환합니다.</p>
<h3><code>PyType_GetModuleName()</code> 함수 추가</h3>
<p>타입의 모듈 이름 (<code>type.__module__</code> 문자열)을 얻기 위한 <code>PyType_GetModuleName()</code> 함수를 추가합니다.</p>
<p>API:</p>
<pre><code class="language-c">PyObject* PyType_GetModuleName(PyTypeObject *type)
</code></pre>
<p>성공 시, 문자열에 대한 새로운 참조를 반환합니다. 에러 발생 시, 예외를 발생시키고 <code>NULL</code>을 반환합니다.</p>
<h3><code>PyUnicode_FromFormat()</code>에 포맷 추가</h3>
<p><code>PyUnicode_FromFormat()</code>에 다음 포맷을 추가합니다:</p>
<ul>
<li><code>%N</code>: 타입의 Fully Qualified Name을 포맷하며, <code>PyType_GetFullyQualifiedName(type)</code>과 유사합니다. 'N'은 'type Name'을 의미합니다.</li>
<li><code>%T</code>: 객체 타입의 Fully Qualified Name을 포맷하며, <code>PyType_GetFullyQualifiedName(Py_TYPE(obj))</code>과 유사합니다. 'T'는 'object Type'을 의미합니다.</li>
<li><code>%#N</code> 및 <code>%#T</code>: 대체 형식은 모듈 이름과 Qualified Name 사이에 점 (<code>.</code>) 대신 콜론 (<code>:</code>) 구분자를 사용합니다.</li>
</ul>
<p>예를 들어, 기존에 <code>tp_name</code>을 사용하던 다음 코드는:</p>
<pre><code class="language-c">PyErr_Format(PyExc_TypeError, "__format__ must return a str, not %.200s", Py_TYPE(result)->tp_name);
</code></pre>
<p><code>%T</code> 포맷으로 대체될 수 있습니다:</p>
<pre><code class="language-c">PyErr_Format(PyExc_TypeError, "__format__ must return a str, not %T", result);
</code></pre>
<p>업데이트된 코드의 장점:</p>
<ul>
<li><strong>더 안전한 C 코드:</strong> <code>borrowed reference</code>를 반환하는 <code>Py_TYPE()</code>를 피합니다.</li>
<li><strong>Limited C API 호환성:</strong> <code>PyTypeObject.tp_name</code> 멤버를 명시적으로 읽지 않아 Limited C API와 호환됩니다.</li>
<li><strong>일관된 포맷팅:</strong> 포맷된 타입 이름이 더 이상 타입 구현에 의존하지 않습니다.</li>
<li><strong>잘림 방지:</strong> 타입 이름이 더 이상 잘리지 않습니다.</li>
</ul>
<p>참고: <code>%T</code> 포맷은 <code>time.strftime()</code>에서 사용되지만, <code>printf()</code>에서는 사용되지 않습니다.</p>
<h3>Formats Summary (포맷 요약)</h3>
<p>| C object | C type | Format |
| :------- | :----- | :----- |
| <code>%T</code>     | <code>%N</code>   | 타입의 Fully Qualified Name. |
| <code>%#T</code>    | <code>%#N</code>  | 타입의 Fully Qualified Name, 콜론 구분자. |</p>
<h3>타입의 Fully Qualified Name 사용 권장</h3>
<p>새로운 C 코드에서 에러 메시지 및 <code>__repr__()</code> 메서드에 타입의 Fully Qualified Name을 사용하는 것이 권장됩니다.</p>
<p>복잡한 애플리케이션에서는 일반적인 이름으로 인해 동일한 짧은 이름을 가진 두 개의 타입이 다른 모듈에 정의될 가능성이 있습니다. Fully Qualified Name을 사용하면 타입을 명확하게 식별하는 데 도움이 됩니다.</p>
<h3>타입 이름 잘라내지 않도록 권장</h3>
<p>새로운 C 코드에서 타입 이름은 잘라내서는 안 됩니다. 예를 들어, <code>%.100s</code> 포맷은 피하고 <code> %s</code> 포맷(또는 C에서는 <code>%T</code> 포맷)을 대신 사용해야 합니다.</p>
<h2>Implementation (구현)</h2>
<ul>
<li><a href="https://github.com/python/cpython/pull/112615">Pull request: Add type.<strong>fully_qualified_name</strong> attribute</a></li>
<li><a href="https://github.com/python/cpython/pull/112616">Pull request: Add %T format to PyUnicode_FromFormat()</a></li>
</ul>
<h2>Backwards Compatibility (하위 호환성)</h2>
<p>이 PEP에서 제안된 변경 사항은 하위 호환됩니다.</p>
<ul>
<li>새로운 C API 추가는 하위 호환성에 영향을 미치지 않습니다.</li>
<li>기존 C API는 변경되지 않습니다.</li>
<li>Python API는 변경되지 않습니다.</li>
</ul>
<p>타입의 짧은 이름을 Fully Qualified Name으로 대체하는 것은 새로운 C 코드에서만 권장됩니다. 타입 이름을 잘라내지 않는 것도 새로운 C 코드에서만 권장됩니다. 기존 코드는 변경되지 않고 하위 호환성을 유지합니다. Python 코드에 대한 권장 사항은 없습니다.</p>
<h2>Rejected Ideas (거부된 아이디어)</h2>
<h3><code>type.__fully_qualified_name__</code> 속성 추가</h3>
<p><code>type.__fully_qualified_name__</code> 읽기 전용 속성을 추가하여, 타입의 Fully Qualified Name을 제공하는 아이디어가 있었습니다. 이는 <code>f"{type.__module__}.{type.__qualname__}"</code>과 유사하며, <code>type.__module__</code>이 문자열이 아니거나 <code>"builtins"</code> 또는 <code>"__main__"</code>과 같으면 <code>type.__qualname__</code>을 반환합니다.</p>
<p>그러나 이 변경 사항은 Steering Council에 의해 거부되었습니다:</p>
<blockquote>
<p>"우리는 이 PEP에서 제안된 C API 변경의 유용성을 이해하며 그대로 수용할 가능성이 높습니다. 그러나 Python 수준의 변경에 대해서는 정당성이 부족하다고 봅니다. 특히 <code>__fully_qualified_name__</code>의 필요성에 의문을 제기합니다."</p>
</blockquote>
<p>Thomas Wouters는 다음과 같이 덧붙였습니다:</p>
<blockquote>
<p>"C API와 정확히 동일한 방식으로 타입을 포맷해야 할 필요성이 정말 있다면, 개인적으로 <code>type.__format__</code>보다는 유틸리티 함수가 더 합리적이라고 생각하지만, 구체적인 사용 사례가 있다면 SC도 설득될 수 있을 것입니다."</p>
</blockquote>
<h3><code>type.__format__()</code> 메서드 추가</h3>
<p><code>type.__format__()</code> 메서드에 다음 포맷을 추가하는 아이디어가 있었습니다:</p>
<ul>
<li><code>N</code>: 타입의 Fully Qualified Name을 포맷합니다 (<code>type.__fully_qualified_name__</code>). 'N'은 'Name'을 의미합니다.</li>
<li><code>#N</code> (대체 형식): 모듈 이름과 Qualified Name 사이에 점 (<code>.</code>) 대신 콜론 (<code>:</code>) 구분자를 사용하여 타입의 Fully Qualified Name을 포맷합니다.</li>
</ul>
<p>f-string을 사용한 예시:</p>
<pre><code class="language-python">>>> import datetime
>>> f"{datetime.timedelta:N}" # fully qualified name
'datetime.timedelta'
>>> f"{datetime.timedelta:#N}" # fully qualified name, colon separator
'datetime:timedelta'
</code></pre>
<p><code>#N</code> 포맷에 사용된 콜론 (<code>:</code>) 구분자는 이름을 임포트하려는 경우 추측을 제거하는 데 도움이 됩니다. (<code>pkgutil.resolve_name()</code>, <code>python -m inspect</code> 명령줄 인터페이스, setuptools entry points 참조).</p>
<p>이 변경 사항 또한 Steering Council에 의해 거부되었습니다.</p>
<h3><code>str(type)</code> 변경</h3>
<p><code>type.__str__()</code> 메서드를 수정하여 타입 이름을 다르게 포맷하는 아이디어가 있었습니다. 예를 들어, 타입의 Fully Qualified Name을 반환할 수 있습니다.</p>
<p>문제는 이것이 하위 호환되지 않는 변경이라는 점입니다. 예를 들어, 표준 라이브러리의 <code>enum</code>, <code>functools</code>, <code>optparse</code>, <code>pdb</code>, <code>xmlrpc.server</code> 모듈을 업데이트해야 합니다. <code>test_dataclasses</code>, <code>test_descrtut</code>, <code>test_cmd_line_script</code> 테스트도 업데이트해야 합니다.</p>
<p>관련 풀 리퀘스트: <a href="https://github.com/python/cpython/pull/34336">type(str) returns the fully qualified name</a>.</p>
<h3><code>!t</code> 포매터로 객체 타입 얻기</h3>
<p><code>f"{obj!t:T}"</code>를 사용하여 <code>type(obj).__fully_qualified_name__</code>을 포맷하는 아이디어는 <code>f"{type(obj):T}"</code>와 유사합니다.</p>
<p><code>!t</code> 포매터가 2018년에 제안되었을 때, f-string PEP 498 "Literal String Interpolation"의 저자인 Eric Smith는 이에 강력히 반대했습니다.</p>
<h3><code>str % args</code>에 포맷 추가</h3>
<p><code>str % arg</code>에서 타입 이름을 포맷하기 위한 포맷을 추가하는 아이디어가 있었습니다. 예를 들어, 타입의 Fully Qualified Name을 포맷하기 위해 <code>%T</code> 포맷을 추가하는 것입니다.</p>
<p>요즘에는 새로운 코드에 f-string이 선호됩니다.</p>
<h3>C에서 타입 이름을 포맷하는 다른 방법들</h3>
<p><code>printf()</code> 함수는 여러 크기 지정자(hh, h, l, ll, z, t, j)를 지원하며, <code>PyUnicode_FromFormat()</code> 함수는 대부분을 지원합니다.</p>
<p><code>h</code> 및 <code>hh</code> 길이 지정자를 사용한 제안된 포맷:</p>
<ul>
<li><code>%hhT</code>는 <code>type.__name__</code>을 포맷합니다.</li>
<li><code>%hT</code>는 <code>type.__qualname__</code>을 포맷합니다.</li>
<li><code>%T</code>는 <code>type.__fully_qualified_name__</code>을 포맷합니다.</li>
</ul>
<p>길이 지정자는 인수의 C 타입을 지정하는 데 사용되며, 인수가 포맷되는 방식을 변경하는 데 사용되지 않습니다. 대체 형식 (<code>#</code>)은 인수가 포맷되는 방식을 변경합니다. 여기서 인수의 C 타입은 항상 <code>PyObject*</code>입니다.</p>
<p>다른 제안된 포맷:</p>
<ul>
<li><code>%Q</code>, <code>%t</code></li>
<li><code>%lT</code>는 <code>type.__fully_qualified_name__</code>을 포맷합니다.</li>
<li><code>%Tn</code>은 <code>type.__name__</code>을 포맷합니다.</li>
<li><code>%Tq</code>는 <code>type.__qualname__</code>을 포맷합니다.</li>
<li><code>%Tf</code>는 <code>type.__fully_qualified_name__</code>을 포맷합니다.</li>
</ul>
<p>타입 이름을 포맷하는 옵션이 너무 많으면 다른 모듈 간에 불일치가 발생하고 API가 오류 발생 가능성이 높아질 수 있습니다. <code>%t</code> 포맷의 경우, <code>printf()</code>는 이제 <code>ptrdiff_t</code> 인수에 대한 길이 지정자로 <code>t</code>를 사용합니다.</p>
<p>타입을 포맷하는 데 사용될 API는 다음과 같습니다:</p>
<p>| C API                | Python API     | Format            |
| :------------------- | :------------- | :---------------- |
| <code>PyType_GetName()</code>   | <code>type.__name__</code> | 타입 짧은 이름. |
| <code>PyType_GetQualName()</code> | <code>type.__qualname__</code> | 타입 Qualified Name. |
| <code>PyType_GetModuleName()</code> | <code>type.__module__</code> | 타입 모듈 이름. |</p>
<h3><code>Py_TYPE()</code>와 함께 <code>%T</code> 포맷 사용: 타입 전달</h3>
<p><code>Py_TYPE(obj)</code>와 같이 <code>%T</code> 포맷에 타입을 전달하는 아이디어가 있었습니다.</p>
<pre><code class="language-c">PyErr_Format(PyExc_ValueError, "Unexpected value %R of type %T", obj, Py_TYPE(obj));
</code></pre>
<p><code>Py_TYPE()</code> 함수는 <code>borrowed reference</code>를 반환합니다. 에러를 포맷하기 위해 <code>borrowed reference</code>를 사용하는 것은 안전해 보일 수 있지만, 실제로는 충돌로 이어질 수 있습니다. 예를 들어, <code>repr(obj)</code>가 <code>%R</code> 포맷에 의해 호출될 때 <code>ClassB</code>에 대한 마지막 참조가 제거되고 클래스가 할당 해제될 수 있습니다. 이때 <code>%T</code> 포맷이 처리되면 <code>Py_TYPE(obj)</code>는 이미 <code>dangling pointer</code>가 되어 Python이 충돌할 수 있습니다.</p>
<h3>타입의 Fully Qualified Name을 얻기 위한 다른 API 제안</h3>
<ul>
<li><code>type.__fullyqualname__</code> 속성 추가: 단어 사이에 밑줄이 없는 이름.</li>
<li><code>type.__fqn__</code> 속성 추가: FQN은 Fully Qualified Name의 약자.</li>
<li><code>type.fully_qualified_name()</code> 메서드 추가: 타입에 추가된 메서드는 모든 타입에 상속되므로 기존 코드에 영향을 미칠 수 있습니다.</li>
<li><code>inspect</code> 모듈에 함수 추가: 사용하려면 <code>inspect</code> 모듈을 임포트해야 합니다.</li>
</ul>
<h3>Fully Qualified Name에 <code>__main__</code> 모듈 포함</h3>
<p><code>type.__fully_qualified_name__</code>을 <code>f"{type.__module__}.{type.__qualname__}"</code>으로 포맷하거나, <code>type.__module__</code>이 문자열이 아니거나 <code>"builtins"</code>와 같으면 <code>type.__qualname__</code>으로 포맷하는 아이디어가 있었습니다. <code>__main__</code> 모듈을 다르게 처리하지 않고 이름에 포함시키는 것입니다.</p>
<p><code>type.__repr__()</code>, <code>collections.abc</code>, <code>unittest</code> 모듈과 같은 기존 코드는 <code>f'{obj.__module__}.{obj.__qualname__}'</code>으로 타입 이름을 포맷하고, 모듈이 <code>builtins</code>와 같을 경우에만 모듈 부분을 생략합니다.</p>
<p><code>traceback</code> 및 <code>pdb</code> 모듈만이 모듈이 <code>"builtins"</code> 또는 <code>"__main__"</code>과 같을 경우 모듈을 생략합니다.</p>
<p><code>type.__fully_qualified_name__</code> 속성은 스크립트가 <code>python script.py</code>로 실행될 때 정의되는 타입과 같이 일반적인 경우에 더 짧은 이름을 생성하기 위해 <code>__main__</code> 모듈을 생략합니다. 디버깅을 위해 타입에 <code>repr()</code> 함수를 사용할 수 있으며, 이는 타입 이름에 <code>__main__</code> 모듈을 포함합니다. 또는 <code>"builtins"</code> 모듈의 경우에도 항상 모듈 이름을 포함하려면 <code>f"{type.__module__}.{type.__qualname__}"</code> 포맷을 사용하세요.</p>
<p>스크립트 예시:</p>
<pre><code class="language-python">class MyType: pass
print(f"name: {MyType.__fully_qualified_name__}")
print(f"repr: {repr(MyType)}")
</code></pre>
<p>출력:</p>
<pre><code>name: MyType
repr: &#x3C;class '__main__.MyType'>
</code></pre>
<h2>Discussions (토론)</h2>
<ul>
<li><a href="https://discuss.python.org/t/pep-737-unify-type-name-formatting/35048">Discourse: PEP 737 – Unify type name formatting (2023)</a></li>
<li><a href="https://discuss.python.org/t/enhance-type-name-formatting-when-raising-an-exception-add-t-format-in-c-and-add-type-fullyqualname/34988">Discourse: Enhance type name formatting when raising an exception: add %T format in C, and add type.<strong>fullyqualname</strong> (2023)</a></li>
<li><a href="https://github.com/python/cpython/issues/112616">Issue: PyUnicode_FromFormat(): Add %T format to format the type name of an object (2023)</a></li>
<li><a href="https://github.com/python/cpython/issues/112521">Issue: C API: Investigate how the PyTypeObject members can be removed from the public C API (2023)</a></li>
<li><a href="https://mail.python.org/archives/list/python-dev@python.org/thread/S5G3C4G6Q5Q7M7M8N8J7K2L4R5N8N5P6/">python-dev thread: bpo-34595: How to format a type name? (2018)</a></li>
<li><a href="https://github.com/python/cpython/issues/84370">Issue: PyUnicode_FromFormat(): add %T format for an object type name (2018)</a></li>
<li><a href="https://github.com/python/cpython/issues/52178">Issue: Replace %.100s by %s in PyErr_Format(): the arbitrary limit of 500 bytes is outdated (2011)</a></li>
</ul>
<h2>Copyright (저작권)</h2>
<p>이 문서는 Public Domain에 있거나 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스 하에 배포됩니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 737 - C API to format a type fully qualified name"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-27 13:28:04+0900","children":"2025년 9월 27일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 27일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":[["$","div",null,{"className":"page__taxonomy mb-4","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"카테고리"}],[["$","span","Python",{"className":"page__taxonomy-item","children":"Python"}],["$","span","PEP",{"className":"page__taxonomy-item","children":"PEP"}]]]}],["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]]}]]}]}]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","21",{"name":"next-size-adjust"}]]
1:null
