<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js"/><script src="/secrett2633.github.io/_next/static/chunks/fd9d1056-62aaf4b921c84028.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/23-ca4408d024135d8d.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/main-app-fa660020ba1e0b6e.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/231-c4b666723e6aae68.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/layout-8808afda01b7a1b7.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="next-size-adjust"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/secrett2633.github.io/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_9012cf layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/secrett2633.github.io">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 483 - The Theory of Type Hints</h1><div class="page__meta"><time dateTime="2025-09-26 22:28:39+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0483/">PEP 483 - The Theory of Type Hints</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Informational | <strong>작성일:</strong> 19-Dec-2014</p>
</blockquote>
<h2>PEP 483 – 타입 힌트의 이론 (The Theory of Type Hints)</h2>
<h3>개요 (Abstract)</h3>
<p>이 PEP는 PEP 484에서 참조되는 타입 이론을 설명합니다.</p>
<h3>서론 (Introduction)</h3>
<p>이 문서는 Python 3.5를 위한 새로운 타입 힌트 제안의 이론적 배경을 제시합니다. 아직 많은 세부 사항이 확정되어야 하므로 완전한 제안이나 명세는 아니지만, 더 자세한 명세를 논의하기 어렵게 만드는 이론적 기반을 제공합니다. 타입 이론의 기본 개념을 상기하는 것으로 시작하여, 점진적 타이핑(gradual typing)을 설명하고, 일반적인 규칙을 제시하며, 어노테이션(annotations)에 사용될 수 있는 새로운 특별한 타입(예: <code>Union</code>)을 정의합니다. 마지막으로 제네릭 타입(generic types)에 대한 접근 방식과 타입 힌트의 실용적인 측면을 정의합니다.</p>
<h3>표기 규칙 (Notational conventions)</h3>
<ul>
<li><code>t1</code>, <code>t2</code> 등과 <code>u1</code>, <code>u2</code> 등은 타입을 나타냅니다.</li>
<li><code>T</code>, <code>U</code> 등은 <code>TypeVar()</code>로 정의되는 타입 변수(type variables)입니다.</li>
<li>PEP 8 규칙에 따라 객체, <code>class</code> 문으로 정의된 클래스 및 인스턴스가 표기됩니다.</li>
<li>이 PEP의 맥락에서 타입에 적용되는 <code>==</code> 기호는 두 표현식이 동일한 타입을 나타냄을 의미합니다.</li>
<li>PEP 484는 타입(타입 체커를 위한 개념)과 클래스(런타임 개념)를 구분하지만, 이 PEP는 타입 체커 구현의 유연성을 위해 불필요하게 엄격한 구분을 피합니다.</li>
</ul>
<h3>배경 (Background)</h3>
<p>문헌에는 타입 개념에 대한 다양한 정의가 있습니다. 여기서는 타입을 값들의 집합과 이 값들에 적용할 수 있는 함수들의 집합으로 가정합니다.</p>
<p>특정 타입을 정의하는 방법은 여러 가지가 있습니다.</p>
<ul>
<li><strong>모든 값을 명시적으로 나열하여 정의:</strong> 예: <code>True</code>와 <code>False</code>는 <code>bool</code> 타입을 형성합니다.</li>
<li><strong>타입 변수와 함께 사용할 수 있는 함수를 지정하여 정의:</strong> 예: <code>__len__</code> 메서드를 가진 모든 객체는 <code>Sized</code> 타입을 형성합니다. <code>[1, 2, 3]</code>과 <code>'abc'</code> 모두 <code>len</code> 함수를 호출할 수 있으므로 이 타입에 속합니다.</li>
<li><strong>간단한 클래스 정의:</strong> 예: <code>class UserID(int): pass</code> 와 같이 클래스를 정의하면, 이 클래스의 모든 인스턴스 또한 하나의 타입을 형성합니다.</li>
</ul>
<p>사용자가 타입 체커가 이해할 수 있는 형태로 타입을 정의할 수 있는 것이 중요합니다. 이 PEP의 목표는 PEP 3107 구문을 사용하여 변수 및 함수의 타입 어노테이션을 위한 체계적인 타입 정의 방식을 제안하는 것입니다. 이러한 어노테이션은 다양한 종류의 버그를 방지하고, 문서화 목적으로, 또는 프로그램 실행 속도를 높이는 데 사용될 수 있습니다. 여기서는 정적 타입 체커(static type checker)를 사용하여 버그를 방지하는 데 중점을 둡니다.</p>
<h3>서브타입 관계 (Subtype relationships)</h3>
<p>정적 타입 체커에 있어 중요한 개념은 서브타입(subtype) 관계입니다. 이는 <code>first_var</code>가 <code>first_type</code>이고 <code>second_var</code>가 <code>second_type</code>일 때, <code>first_var = second_var</code> 할당이 안전한지 여부에서 발생합니다.</p>
<p>안전하다고 볼 수 있는 강력한 기준은 다음과 같습니다.</p>
<ol>
<li><code>second_type</code>의 모든 값이 <code>first_type</code>의 값 집합에도 포함됩니다.</li>
<li><code>first_type</code>의 모든 함수가 <code>second_type</code>의 함수 집합에도 포함됩니다.</li>
</ol>
<p>이 정의에 따르면:</p>
<ul>
<li>모든 타입은 자기 자신의 서브타입입니다.</li>
<li>서브타이핑 과정에서 값 집합은 작아지고, 함수 집합은 커집니다.</li>
</ul>
<p><strong>직관적인 예시:</strong> 모든 <code>Dog</code>는 <code>Animal</code>이며, <code>Dog</code>는 <code>bark</code>와 같은 더 많은 함수를 가집니다. 따라서 <code>Dog</code>는 <code>Animal</code>의 서브타입입니다. 반대로 <code>Animal</code>은 <code>Dog</code>의 서브타입이 아닙니다.</p>
<p><strong>더 형식적인 예시:</strong> <code>int</code>는 <code>float</code>의 서브타입입니다. 모든 정수는 실수이며, 정수는 비트 시프트 <code>&#x3C;&#x3C;</code>, <code>>></code>와 같은 더 많은 연산을 지원합니다.</p>
<p><strong>까다로운 예시:</strong> <code>List[int]</code> (정수만 포함하는 리스트 타입)는 <code>List[float]</code> (실수만 포함하는 리스트 타입)의 서브타입이 아닙니다. 첫 번째 서브타이핑 조건은 만족하지만, 실수를 추가하는 작업은 <code>List[float]</code>에서만 가능하므로 두 번째 조건이 실패합니다.</p>
<p>타입 체커에 서브타입 정보를 선언하는 두 가지 일반적인 접근 방식이 있습니다.</p>
<ul>
<li><strong>명목적 서브타이핑 (Nominal subtyping):</strong> 타입 트리가 클래스 트리를 기반으로 합니다. 즉, <code>UserID</code>는 <code>int</code>의 서브타입으로 간주됩니다. 파이썬에서는 호환되지 않는 방식으로 속성을 오버라이드할 수 있으므로, 이 접근 방식은 타입 체커의 제어 하에 사용되어야 합니다.
<pre><code class="language-python">class Base:
    answer = '42' # type: str
class Derived(Base):
    answer = 5 # should be marked as error by type checker
</code></pre>
</li>
<li><strong>구조적 서브타이핑 (Structural subtyping):</strong> 서브타입 관계가 선언된 메서드로부터 추론됩니다. 즉, <code>UserID</code>와 <code>int</code>는 동일한 타입으로 간주될 수 있습니다. 이 방식이 더 유연하다고 여겨집니다.</li>
</ul>
<h3>점진적 타이핑 요약 (Summary of gradual typing)</h3>
<p>점진적 타이핑(Gradual typing)은 프로그램의 일부에만 어노테이션을 달아 동적 타이핑과 정적 타이핑의 장점을 모두 활용할 수 있도록 합니다.</p>
<p>새로운 관계인 <code>is-consistent-with</code>를 정의하는데, 이는 <code>is-subtype-of</code>와 유사하지만, 새로운 타입 <code>Any</code>가 포함될 때 전이적(transitive)이지 않습니다. <code>a_value</code>의 타입이 <code>a_variable</code>의 타입과 일치(consistent)하면 <code>a_value</code>를 <code>a_variable</code>에 할당하는 것은 허용됩니다. (<code>is-consistent-with</code> 관계는 대칭적이지 않습니다.) <code>is-consistent-with</code> 관계는 세 가지 규칙으로 정의됩니다.</p>
<ol>
<li>타입 <code>t1</code>이 타입 <code>t2</code>의 서브타입이면, <code>t1</code>은 <code>t2</code>와 일치합니다.</li>
<li><code>Any</code>는 모든 타입과 일치합니다. (하지만 <code>Any</code>가 모든 타입의 서브타입인 것은 아닙니다.)</li>
<li>모든 타입은 <code>Any</code>와 일치합니다. (하지만 모든 타입이 <code>Any</code>의 서브타입인 것은 아닙니다.)</li>
</ol>
<p><code>Any</code>는 모든 값과 모든 메서드를 가진 타입으로 간주될 수 있습니다. 이는 타입 계층 구조의 상단(모든 값을 가짐)과 하단(모든 메서드를 가짐)에 부분적으로 <code>Any</code>를 위치시킵니다. <code>object</code>와 대조적으로, <code>object</code>는 대부분의 타입과 일치하지 않습니다. 즉, 인자를 어노테이션할 때 <code>Any</code>와 <code>object</code> 모두 "어떤 타입이든 허용됨"을 의미하지만, <code>Any</code>만 어떤 타입이 예상되든 전달될 수 있습니다 (본질적으로 <code>Any</code>는 동적 타이핑으로의 폴백(fallback)을 선언하고 정적 체커의 불평을 침묵시킵니다).</p>
<p><strong>예시:</strong>
<code>Employee</code> 클래스와 그 서브클래스 <code>Manager</code>가 있다고 가정합니다.</p>
<pre><code class="language-python">class Employee: ...
class Manager(Employee): ...

worker: Employee = Employee() # worker 변수는 Employee 타입으로 선언
worker = Manager() # OK (규칙 1: Manager는 Employee의 서브타입)

boss: Manager = Manager()
# boss = Employee() # 정적 검사 실패 (Employee는 Manager의 서브타입이 아님)

something: Any = some_func() # something 변수는 Any 타입으로 선언
worker = something # OK (규칙 2: Any는 모든 타입과 일치)

something = worker # OK (규칙 3: 모든 타입은 Any와 일치)
</code></pre>
<h3>타입과 클래스 (Types vs. Classes)</h3>
<p>파이썬에서 클래스는 <code>class</code> 문으로 정의되고 <code>type(obj)</code> 내장 함수에 의해 반환되는 객체 팩토리입니다. 클래스는 동적이고 런타임 개념입니다.
타입 개념은 위에서 설명되었으며, 변수 및 함수의 타입 어노테이션에 나타나고, 아래 설명된 구성 요소를 사용하여 구성될 수 있으며, 정적 타입 체커에서 사용됩니다.</p>
<p>모든 클래스는 타입입니다. 그러나 주어진 타입의 의미를 정확하게 나타내는 클래스를 구현하는 것은 까다롭고 오류 발생 가능성이 높으며, PEP 484의 목표가 아닙니다. PEP 484에 설명된 정적 타입은 런타임 클래스와 혼동되어서는 안 됩니다.
<strong>예시:</strong></p>
<ul>
<li><code>int</code>는 클래스이자 타입입니다.</li>
<li><code>UserID</code>는 클래스이자 타입입니다.</li>
<li><code>Union[str, int]</code>는 타입이지만, 적절한 클래스는 아닙니다.
<pre><code class="language-python">class MyUnion(Union[str, int]): ... # TypeError 발생
Union[str, int]() # TypeError 발생
</code></pre>
</li>
</ul>
<p><code>typing</code> 인터페이스는 클래스로 구현됩니다. 즉, 런타임에 <code>Generic[T].__bases__</code> 등을 평가할 수 있습니다. 그러나 클래스와 타입 간의 구분을 강조하기 위해 다음 일반 규칙이 적용됩니다.</p>
<ul>
<li>아래에 정의된 타입(예: <code>Any</code>, <code>Union</code> 등)은 인스턴스화할 수 없으며, 시도하면 <code>TypeError</code>가 발생합니다. (단, <code>Generic</code>의 비추상 서브클래스는 가능합니다.)</li>
<li><code>Generic</code> 및 그로부터 파생된 클래스를 제외하고는 아래에 정의된 타입을 서브클래싱할 수 없습니다.</li>
<li><code>isinstance</code> 또는 <code>issubclass</code>에 나타나면 <code>TypeError</code>가 발생합니다 (매개변수화되지 않은 제네릭 제외).</li>
</ul>
<h3>기본 구성 요소 (Fundamental building blocks)</h3>
<ul>
<li><strong><code>Any</code></strong>: 모든 타입은 <code>Any</code>와 일치하며, <code>Any</code> 또한 모든 타입과 일치합니다.</li>
<li><strong><code>Union[t1, t2, …]</code></strong>: <code>t1</code> 등의 최소한 하나 이상의 서브타입인 타입들이 이 <code>Union</code>의 서브타입이 됩니다.
<ul>
<li>인수의 순서는 중요하지 않습니다.</li>
<li>중첩된 <code>Union</code>은 평탄화됩니다.</li>
<li><code>ti</code>와 <code>tj</code>가 서브타입 관계에 있다면, 덜 구체적인(less specific) 타입이 남습니다.</li>
<li><code>Union[t1]</code>은 <code>t1</code>을 반환합니다.</li>
<li><code>Union[]</code>은 허용되지 않습니다.</li>
<li><code>Union[..., object, ...]</code>은 <code>object</code>를 반환합니다.</li>
</ul>
</li>
<li><strong><code>Optional[t1]</code></strong>: <code>Union[t1, None]</code>의 별칭입니다.</li>
<li><strong><code>Tuple[t1, t2, …, tn]</code></strong>: 항목들이 <code>t1</code> 등의 인스턴스인 튜플입니다.
<ul>
<li>길이가 같고 각 <code>ui</code>가 <code>ti</code>의 서브타입이면 <code>Tuple[u1, ..., um]</code>은 <code>Tuple[t1, ..., tn]</code>의 서브타입입니다.</li>
<li>빈 튜플은 <code>Tuple[()]</code>로 표기합니다.</li>
<li>가변 길이의 동종 튜플 타입은 <code>Tuple[t1, ...]</code>으로 작성할 수 있습니다.</li>
</ul>
</li>
<li><strong><code>Callable[[t1, t2, …, tn], tr]</code></strong>: 위치 인자 타입이 <code>t1</code> 등이고 반환 타입이 <code>tr</code>인 함수입니다.
<ul>
<li>인자 목록은 비어 있을 수 있습니다 (<code>n==0</code>).</li>
<li>선택적(optional) 인자나 키워드 인자를 나타낼 방법은 없지만, <code>Callable[..., tr]</code> (리터럴 생략 부호)를 사용하여 인자 목록이 완전히 검사되지 않음을 나타낼 수 있습니다.</li>
</ul>
</li>
<li><strong><code>Intersection[t1, t2, …]</code> (제안 예정):</strong> <code>t1</code> 등의 각 타입의 서브타입인 타입들이 이 <code>Intersection</code>의 서브타입이 됩니다.</li>
</ul>
<h3>제네릭 타입 (Generic types)</h3>
<p>위에서 정의된 기본 구성 요소들은 제네릭 방식으로 새로운 타입을 구성할 수 있게 합니다. 제네릭 타입 생성자(generic type constructor)는 타입을 인자로 받아 타입을 "반환"하는 것과 유사한 의미를 가집니다.</p>
<p><strong>컨테이너 클래스:</strong> <code>list</code> 또는 <code>dict</code>와 같은 컨테이너 클래스는 일반적으로 특정 타입의 값만 포함합니다. 따라서 다음과 같이 타입 어노테이션을 달 수 있습니다.</p>
<pre><code class="language-python">users: list[UserID] = []
users.append(UserID(42)) # OK
# users.append('Some guy') # 타입 체커에 의해 거부되어야 함
</code></pre>
<p>이러한 상황에서 타입 어노테이션을 허용하기 위해, 내장 컨테이너 및 컨테이너 추상 베이스 클래스는 타입 매개변수(type parameters)로 확장되어 제네릭 타입 생성자처럼 동작합니다. 제네릭 타입 생성자처럼 동작하는 클래스를 제네릭 타입(generic types)이라고 합니다.</p>
<pre><code class="language-python">from typing import Iterable
class Task: ...
def work(todo_list: Iterable[Task]) -> None: ...
</code></pre>
<p>여기서 <code>Iterable</code>은 <code>Task</code>라는 구체적인 타입을 받아 <code>Iterable[Task]</code>라는 구체적인 타입을 반환하는 제네릭 타입입니다.</p>
<p><strong>제네릭 함수:</strong> 타입 변수(type variables)를 사용하여 제네릭 함수의 타입 어노테이션을 허용합니다.</p>
<pre><code class="language-python">def take_first(seq: Sequence[T]) -> T: # 제네릭 함수
    return seq[0]

accumulator: int = 0
accumulator += take_first([1, 2, 3]) # 안전함, T는 int로 추론됨
# accumulator += take_first((2.7, 3.5)) # 안전하지 않음
</code></pre>
<h3>타입 변수 (Type variables)</h3>
<p>타입 변수는 타입 어노테이션에서 광범위하게 사용됩니다. 타입 체커의 타입 추론(type inference) 내부 메커니즘도 일반적으로 타입 변수를 기반으로 합니다.</p>
<ul>
<li>
<p><code>X = TypeVar('X')</code>: 고유한 타입 변수를 선언합니다. 이름은 변수 이름과 일치해야 합니다. 기본적으로 타입 변수는 모든 가능한 타입을 범위로 가집니다.</p>
<pre><code class="language-python">T = TypeVar('T')
def do_nothing(one_arg: T, other_arg: T) -> None: pass
do_nothing(1, 2) # OK, T는 int
do_nothing('abc', UserID(42)) # OK, T는 object
</code></pre>
</li>
<li>
<p><code>Y = TypeVar('Y', t1, t2, ...)</code>: <code>t1</code> 등으로 제한된 타입 변수입니다. <code>Union[t1, t2, ...]</code>와 유사하게 동작합니다. 제약이 있는 타입 변수는 <code>t1</code> 등 제약 내에서만 범위를 가지며, 제약의 서브클래스는 <code>t1</code> 등 중에서 가장 파생된 베이스 클래스로 대체됩니다.</p>
<pre><code class="language-python">AnyStr = TypeVar('AnyStr', str, bytes)
def longest(first: AnyStr, second: AnyStr) -> AnyStr:
    return first if len(first) >= len(second) else second

result = longest('a', 'abc') # result의 추론된 타입은 str
# result = longest('a', b'abc') # 정적 타입 검사 실패
</code></pre>
<p>이 예시에서 <code>longest()</code>의 두 인수는 모두 동일한 타입(<code>str</code> 또는 <code>bytes</code>)이어야 하며, 공통 <code>str</code> 서브클래스의 인스턴스라 할지라도 반환 타입은 여전히 <code>str</code>입니다.</p>
</li>
</ul>
<h3>제네릭 타입 정의 및 사용 (Defining and using generic types)</h3>
<p>사용자는 <code>Generic</code>이라는 특별한 구성 요소를 사용하여 자신의 클래스를 제네릭 타입으로 선언할 수 있습니다. <code>class MyGeneric(Generic[X, Y, ...]): ...</code> 정의는 타입 변수 <code>X</code>, <code>Y</code> 등을 통해 <code>MyGeneric</code>이라는 제네릭 타입을 정의합니다. <code>MyGeneric</code> 자체는 매개변수화(parameterizable)될 수 있습니다.</p>
<pre><code class="language-python">class CustomQueue(Generic[T]):
    def put(self, task: T) -> None: ...
    def get(self) -> T: ...

def communicate(queue: CustomQueue[str]) -> Optional[str]: ...
</code></pre>
<p>제네릭 타입에서 파생된 클래스는 제네릭이 됩니다. 클래스는 여러 제네릭 타입을 서브클래싱할 수 있습니다. 그러나 제네릭에 의해 반환된 특정 타입에서 파생된 클래스는 제네릭이 아닙니다.</p>
<p>타입 변수가 생략된 상태로 타입 어노테이션에 제네릭 타입이 나타나면 <code>Any</code>로 가정됩니다. 이러한 형태는 동적 타이핑으로의 폴백으로 사용될 수 있으며 <code>issubclass</code> 및 <code>isinstance</code>와 함께 사용이 허용됩니다. 모든 인스턴스의 타입 정보는 런타임에 지워집니다.</p>
<h3>공변성 (Covariance) 및 반변성 (Contravariance)</h3>
<p><code>t2</code>가 <code>t1</code>의 서브타입일 때, 제네릭 타입 생성자 <code>GenType</code>은 다음과 같이 불립니다.</p>
<ul>
<li><strong>공변 (Covariant):</strong> 모든 <code>t1</code>, <code>t2</code>에 대해 <code>GenType[t2]</code>가 <code>GenType[t1]</code>의 서브타입인 경우.</li>
<li><strong>반변 (Contravariant):</strong> 모든 <code>t1</code>, <code>t2</code>에 대해 <code>GenType[t1]</code>이 <code>GenType[t2]</code>의 서브타입인 경우.</li>
<li><strong>불변 (Invariant):</strong> 위 두 가지 모두 해당하지 않는 경우.</li>
</ul>
<p><strong>실제 예시:</strong></p>
<ul>
<li>**<code>Union</code>**은 모든 인자에서 공변적으로 동작합니다.</li>
<li>**<code>FrozenSet[T]</code>**는 공변입니다. <code>int</code>는 <code>float</code>의 서브타입이고, <code>FrozenSet[int]</code>의 값 집합은 <code>FrozenSet[float]</code>의 값 집합의 명확한 부분집합이기 때문에 <code>FrozenSet[int]</code>는 <code>FrozenSet[float]</code>의 서브타입입니다.</li>
<li>**<code>List[T]</code>**는 불변입니다. <code>List[int]</code>의 값 집합이 <code>List[float]</code>의 값 집합의 부분집합이더라도, <code>List[int]</code>에는 <code>int</code>만 추가할 수 있기 때문에 <code>List[int]</code>는 <code>List[float]</code>의 서브타입이 아닙니다. 이는 가변(mutable) 타입에서 전형적인 상황입니다.</li>
<li><strong><code>Callable</code></strong> 타입은 반환 타입에는 공변이지만, 인자에는 반변입니다.
<ul>
<li><code>Callable[[], int]</code>는 <code>Callable[[], float]</code>의 서브타입입니다.</li>
<li><code>Callable[[float], None]</code>는 <code>Callable[[int], None]</code>의 서브타입입니다.
즉, <code>Manager</code>에 대한 급여를 계산할 수 있는 함수가 예상되는 상황에서 <code>Employee</code>에 대한 급여를 계산할 수 있는 <code>Callable[[Employee], Decimal]</code>도 허용됩니다.</li>
</ul>
</li>
</ul>
<p>사용자 정의 제네릭 타입에 대한 공변성/반변성은 매개변수로 사용되는 타입 변수의 정의에서 <code>covariant=True</code> 또는 <code>contravariant=True</code> 특수 키워드를 사용하여 선언할 수 있습니다. 타입은 기본적으로 불변입니다.</p>
<pre><code class="language-python">T_co = TypeVar('T_co', covariant=True)
class Box(Generic[T_co]): # 이 타입은 공변으로 선언됨
    def __init__(self, content: T_co) -> None:
        self._content = content
    def get_content(self) -> T_co:
        return self._content

T_contra = TypeVar('T_contra', contravariant=True)
class Sink(Generic[T_contra]): # 이 타입은 반변으로 선언됨
    def send_to_nowhere(self, data: T_contra) -> None:
        # ...
</code></pre>
<p>분산은 타입 변수의 속성이 아니라 제네릭 타입의 속성입니다.</p>
<h3>실용적인 측면 (Pragmatics)</h3>
<p>몇 가지 사항은 이론과 무관하지만 실제 사용을 더 편리하게 만듭니다.</p>
<ul>
<li>타입이 예상되는 곳에 <code>None</code> 대신 <code>type(None)</code>을 사용할 수 있습니다. 예: <code>Union[t1, None] == Union[t1, type(None)]</code>.</li>
<li><strong>타입 별칭 (Type aliases):</strong>
<pre><code class="language-python">Point = Tuple[float, float]
def distance(point: Point) -> float: ...
</code></pre>
</li>
<li><strong>문자열을 통한 전방 참조 (Forward references):</strong>
<pre><code class="language-python">class MyComparable:
    def compare(self, other: 'MyComparable') -> int: ...
</code></pre>
</li>
<li><strong>제약되지 않은(unconstrained), 제약된(constrained), 또는 바운드된(bounded) <code>TypeVar</code> 선언:</strong> <code>TypeVar('T', bound=complex)</code>와 같이 사용할 수 있습니다.</li>
<li><strong>주석 내 타입 선언 (Type declaration in comments):</strong>
<pre><code class="language-python">lst = [] # type: Sequence[int]
</code></pre>
</li>
<li><strong><code>cast(T, obj)</code> 사용:</strong> <code>zork = cast(Any, frobozz())</code>와 같이 사용할 수 있습니다.</li>
<li>오버로딩(overloading) 및 스텁 모듈(stub modules)과 같은 다른 사항은 PEP 484를 참조하십시오.</li>
</ul>
<h3><code>typing.py</code>에 미리 정의된 제네릭 타입 및 프로토콜 (Predefined generic types and Protocols in typing.py)</h3>
<p><code>typing.py</code> 모듈에서 제공되는 타입들은 다음과 같습니다.</p>
<ul>
<li><code>collections.abc</code>의 모든 것 (단, <code>Set</code>은 <code>AbstractSet</code>으로 이름 변경).</li>
<li><code>Dict</code>, <code>List</code>, <code>Set</code>, <code>FrozenSet</code> 등.</li>
<li><code>re.Pattern[AnyStr]</code>, <code>re.Match[AnyStr]</code>.</li>
<li><code>io.IO[AnyStr]</code>, <code>io.TextIO ~ io.IO[str]</code>, <code>io.BinaryIO ~ io.IO[bytes]</code>.</li>
</ul>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy mb-4"><h4 class="text-sm font-medium text-gray-900 mb-2">카테고리</h4><span class="page__taxonomy-item">Python</span><span class="page__taxonomy-item">PEP</span></div><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[4281,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"185\",\"static/chunks/app/layout-8808afda01b7a1b7.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/483\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"iV6XySbMHIJ3imQdvgy3I\",\"assetPrefix\":\"/secrett2633.github.io\",\"initialCanonicalUrl\":\"/python/pep/483/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/483\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"483\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/483\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"32x32\",\"href\":\"/favicon-32x32.png\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"16x16\",\"href\":\"/favicon-16x16.png\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_9012cf layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T5cba,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0483/\"\u003ePEP 483 - The Theory of Type Hints\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Informational | \u003cstrong\u003e작성일:\u003c/strong\u003e 19-Dec-2014\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 483 – 타입 힌트의 이론 (The Theory of Type Hints)\u003c/h2\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 PEP 484에서 참조되는 타입 이론을 설명합니다.\u003c/p\u003e\n\u003ch3\u003e서론 (Introduction)\u003c/h3\u003e\n\u003cp\u003e이 문서는 Python 3.5를 위한 새로운 타입 힌트 제안의 이론적 배경을 제시합니다. 아직 많은 세부 사항이 확정되어야 하므로 완전한 제안이나 명세는 아니지만, 더 자세한 명세를 논의하기 어렵게 만드는 이론적 기반을 제공합니다. 타입 이론의 기본 개념을 상기하는 것으로 시작하여, 점진적 타이핑(gradual typing)을 설명하고, 일반적인 규칙을 제시하며, 어노테이션(annotations)에 사용될 수 있는 새로운 특별한 타입(예: \u003ccode\u003eUnion\u003c/code\u003e)을 정의합니다. 마지막으로 제네릭 타입(generic types)에 대한 접근 방식과 타입 힌트의 실용적인 측면을 정의합니다.\u003c/p\u003e\n\u003ch3\u003e표기 규칙 (Notational conventions)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003et1\u003c/code\u003e, \u003ccode\u003et2\u003c/code\u003e 등과 \u003ccode\u003eu1\u003c/code\u003e, \u003ccode\u003eu2\u003c/code\u003e 등은 타입을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eT\u003c/code\u003e, \u003ccode\u003eU\u003c/code\u003e 등은 \u003ccode\u003eTypeVar()\u003c/code\u003e로 정의되는 타입 변수(type variables)입니다.\u003c/li\u003e\n\u003cli\u003ePEP 8 규칙에 따라 객체, \u003ccode\u003eclass\u003c/code\u003e 문으로 정의된 클래스 및 인스턴스가 표기됩니다.\u003c/li\u003e\n\u003cli\u003e이 PEP의 맥락에서 타입에 적용되는 \u003ccode\u003e==\u003c/code\u003e 기호는 두 표현식이 동일한 타입을 나타냄을 의미합니다.\u003c/li\u003e\n\u003cli\u003ePEP 484는 타입(타입 체커를 위한 개념)과 클래스(런타임 개념)를 구분하지만, 이 PEP는 타입 체커 구현의 유연성을 위해 불필요하게 엄격한 구분을 피합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e배경 (Background)\u003c/h3\u003e\n\u003cp\u003e문헌에는 타입 개념에 대한 다양한 정의가 있습니다. 여기서는 타입을 값들의 집합과 이 값들에 적용할 수 있는 함수들의 집합으로 가정합니다.\u003c/p\u003e\n\u003cp\u003e특정 타입을 정의하는 방법은 여러 가지가 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e모든 값을 명시적으로 나열하여 정의:\u003c/strong\u003e 예: \u003ccode\u003eTrue\u003c/code\u003e와 \u003ccode\u003eFalse\u003c/code\u003e는 \u003ccode\u003ebool\u003c/code\u003e 타입을 형성합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e타입 변수와 함께 사용할 수 있는 함수를 지정하여 정의:\u003c/strong\u003e 예: \u003ccode\u003e__len__\u003c/code\u003e 메서드를 가진 모든 객체는 \u003ccode\u003eSized\u003c/code\u003e 타입을 형성합니다. \u003ccode\u003e[1, 2, 3]\u003c/code\u003e과 \u003ccode\u003e'abc'\u003c/code\u003e 모두 \u003ccode\u003elen\u003c/code\u003e 함수를 호출할 수 있으므로 이 타입에 속합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e간단한 클래스 정의:\u003c/strong\u003e 예: \u003ccode\u003eclass UserID(int): pass\u003c/code\u003e 와 같이 클래스를 정의하면, 이 클래스의 모든 인스턴스 또한 하나의 타입을 형성합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e사용자가 타입 체커가 이해할 수 있는 형태로 타입을 정의할 수 있는 것이 중요합니다. 이 PEP의 목표는 PEP 3107 구문을 사용하여 변수 및 함수의 타입 어노테이션을 위한 체계적인 타입 정의 방식을 제안하는 것입니다. 이러한 어노테이션은 다양한 종류의 버그를 방지하고, 문서화 목적으로, 또는 프로그램 실행 속도를 높이는 데 사용될 수 있습니다. 여기서는 정적 타입 체커(static type checker)를 사용하여 버그를 방지하는 데 중점을 둡니다.\u003c/p\u003e\n\u003ch3\u003e서브타입 관계 (Subtype relationships)\u003c/h3\u003e\n\u003cp\u003e정적 타입 체커에 있어 중요한 개념은 서브타입(subtype) 관계입니다. 이는 \u003ccode\u003efirst_var\u003c/code\u003e가 \u003ccode\u003efirst_type\u003c/code\u003e이고 \u003ccode\u003esecond_var\u003c/code\u003e가 \u003ccode\u003esecond_type\u003c/code\u003e일 때, \u003ccode\u003efirst_var = second_var\u003c/code\u003e 할당이 안전한지 여부에서 발생합니다.\u003c/p\u003e\n\u003cp\u003e안전하다고 볼 수 있는 강력한 기준은 다음과 같습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003esecond_type\u003c/code\u003e의 모든 값이 \u003ccode\u003efirst_type\u003c/code\u003e의 값 집합에도 포함됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efirst_type\u003c/code\u003e의 모든 함수가 \u003ccode\u003esecond_type\u003c/code\u003e의 함수 집합에도 포함됩니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 정의에 따르면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모든 타입은 자기 자신의 서브타입입니다.\u003c/li\u003e\n\u003cli\u003e서브타이핑 과정에서 값 집합은 작아지고, 함수 집합은 커집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e직관적인 예시:\u003c/strong\u003e 모든 \u003ccode\u003eDog\u003c/code\u003e는 \u003ccode\u003eAnimal\u003c/code\u003e이며, \u003ccode\u003eDog\u003c/code\u003e는 \u003ccode\u003ebark\u003c/code\u003e와 같은 더 많은 함수를 가집니다. 따라서 \u003ccode\u003eDog\u003c/code\u003e는 \u003ccode\u003eAnimal\u003c/code\u003e의 서브타입입니다. 반대로 \u003ccode\u003eAnimal\u003c/code\u003e은 \u003ccode\u003eDog\u003c/code\u003e의 서브타입이 아닙니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e더 형식적인 예시:\u003c/strong\u003e \u003ccode\u003eint\u003c/code\u003e는 \u003ccode\u003efloat\u003c/code\u003e의 서브타입입니다. 모든 정수는 실수이며, 정수는 비트 시프트 \u003ccode\u003e\u0026#x3C;\u0026#x3C;\u003c/code\u003e, \u003ccode\u003e\u003e\u003e\u003c/code\u003e와 같은 더 많은 연산을 지원합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e까다로운 예시:\u003c/strong\u003e \u003ccode\u003eList[int]\u003c/code\u003e (정수만 포함하는 리스트 타입)는 \u003ccode\u003eList[float]\u003c/code\u003e (실수만 포함하는 리스트 타입)의 서브타입이 아닙니다. 첫 번째 서브타이핑 조건은 만족하지만, 실수를 추가하는 작업은 \u003ccode\u003eList[float]\u003c/code\u003e에서만 가능하므로 두 번째 조건이 실패합니다.\u003c/p\u003e\n\u003cp\u003e타입 체커에 서브타입 정보를 선언하는 두 가지 일반적인 접근 방식이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e명목적 서브타이핑 (Nominal subtyping):\u003c/strong\u003e 타입 트리가 클래스 트리를 기반으로 합니다. 즉, \u003ccode\u003eUserID\u003c/code\u003e는 \u003ccode\u003eint\u003c/code\u003e의 서브타입으로 간주됩니다. 파이썬에서는 호환되지 않는 방식으로 속성을 오버라이드할 수 있으므로, 이 접근 방식은 타입 체커의 제어 하에 사용되어야 합니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Base:\n    answer = '42' # type: str\nclass Derived(Base):\n    answer = 5 # should be marked as error by type checker\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e구조적 서브타이핑 (Structural subtyping):\u003c/strong\u003e 서브타입 관계가 선언된 메서드로부터 추론됩니다. 즉, \u003ccode\u003eUserID\u003c/code\u003e와 \u003ccode\u003eint\u003c/code\u003e는 동일한 타입으로 간주될 수 있습니다. 이 방식이 더 유연하다고 여겨집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e점진적 타이핑 요약 (Summary of gradual typing)\u003c/h3\u003e\n\u003cp\u003e점진적 타이핑(Gradual typing)은 프로그램의 일부에만 어노테이션을 달아 동적 타이핑과 정적 타이핑의 장점을 모두 활용할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e새로운 관계인 \u003ccode\u003eis-consistent-with\u003c/code\u003e를 정의하는데, 이는 \u003ccode\u003eis-subtype-of\u003c/code\u003e와 유사하지만, 새로운 타입 \u003ccode\u003eAny\u003c/code\u003e가 포함될 때 전이적(transitive)이지 않습니다. \u003ccode\u003ea_value\u003c/code\u003e의 타입이 \u003ccode\u003ea_variable\u003c/code\u003e의 타입과 일치(consistent)하면 \u003ccode\u003ea_value\u003c/code\u003e를 \u003ccode\u003ea_variable\u003c/code\u003e에 할당하는 것은 허용됩니다. (\u003ccode\u003eis-consistent-with\u003c/code\u003e 관계는 대칭적이지 않습니다.) \u003ccode\u003eis-consistent-with\u003c/code\u003e 관계는 세 가지 규칙으로 정의됩니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e타입 \u003ccode\u003et1\u003c/code\u003e이 타입 \u003ccode\u003et2\u003c/code\u003e의 서브타입이면, \u003ccode\u003et1\u003c/code\u003e은 \u003ccode\u003et2\u003c/code\u003e와 일치합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAny\u003c/code\u003e는 모든 타입과 일치합니다. (하지만 \u003ccode\u003eAny\u003c/code\u003e가 모든 타입의 서브타입인 것은 아닙니다.)\u003c/li\u003e\n\u003cli\u003e모든 타입은 \u003ccode\u003eAny\u003c/code\u003e와 일치합니다. (하지만 모든 타입이 \u003ccode\u003eAny\u003c/code\u003e의 서브타입인 것은 아닙니다.)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ccode\u003eAny\u003c/code\u003e는 모든 값과 모든 메서드를 가진 타입으로 간주될 수 있습니다. 이는 타입 계층 구조의 상단(모든 값을 가짐)과 하단(모든 메서드를 가짐)에 부분적으로 \u003ccode\u003eAny\u003c/code\u003e를 위치시킵니다. \u003ccode\u003eobject\u003c/code\u003e와 대조적으로, \u003ccode\u003eobject\u003c/code\u003e는 대부분의 타입과 일치하지 않습니다. 즉, 인자를 어노테이션할 때 \u003ccode\u003eAny\u003c/code\u003e와 \u003ccode\u003eobject\u003c/code\u003e 모두 \"어떤 타입이든 허용됨\"을 의미하지만, \u003ccode\u003eAny\u003c/code\u003e만 어떤 타입이 예상되든 전달될 수 있습니다 (본질적으로 \u003ccode\u003eAny\u003c/code\u003e는 동적 타이핑으로의 폴백(fallback)을 선언하고 정적 체커의 불평을 침묵시킵니다).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e예시:\u003c/strong\u003e\n\u003ccode\u003eEmployee\u003c/code\u003e 클래스와 그 서브클래스 \u003ccode\u003eManager\u003c/code\u003e가 있다고 가정합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Employee: ...\nclass Manager(Employee): ...\n\nworker: Employee = Employee() # worker 변수는 Employee 타입으로 선언\nworker = Manager() # OK (규칙 1: Manager는 Employee의 서브타입)\n\nboss: Manager = Manager()\n# boss = Employee() # 정적 검사 실패 (Employee는 Manager의 서브타입이 아님)\n\nsomething: Any = some_func() # something 변수는 Any 타입으로 선언\nworker = something # OK (규칙 2: Any는 모든 타입과 일치)\n\nsomething = worker # OK (규칙 3: 모든 타입은 Any와 일치)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e타입과 클래스 (Types vs. Classes)\u003c/h3\u003e\n\u003cp\u003e파이썬에서 클래스는 \u003ccode\u003eclass\u003c/code\u003e 문으로 정의되고 \u003ccode\u003etype(obj)\u003c/code\u003e 내장 함수에 의해 반환되는 객체 팩토리입니다. 클래스는 동적이고 런타임 개념입니다.\n타입 개념은 위에서 설명되었으며, 변수 및 함수의 타입 어노테이션에 나타나고, 아래 설명된 구성 요소를 사용하여 구성될 수 있으며, 정적 타입 체커에서 사용됩니다.\u003c/p\u003e\n\u003cp\u003e모든 클래스는 타입입니다. 그러나 주어진 타입의 의미를 정확하게 나타내는 클래스를 구현하는 것은 까다롭고 오류 발생 가능성이 높으며, PEP 484의 목표가 아닙니다. PEP 484에 설명된 정적 타입은 런타임 클래스와 혼동되어서는 안 됩니다.\n\u003cstrong\u003e예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eint\u003c/code\u003e는 클래스이자 타입입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUserID\u003c/code\u003e는 클래스이자 타입입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUnion[str, int]\u003c/code\u003e는 타입이지만, 적절한 클래스는 아닙니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass MyUnion(Union[str, int]): ... # TypeError 발생\nUnion[str, int]() # TypeError 발생\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003etyping\u003c/code\u003e 인터페이스는 클래스로 구현됩니다. 즉, 런타임에 \u003ccode\u003eGeneric[T].__bases__\u003c/code\u003e 등을 평가할 수 있습니다. 그러나 클래스와 타입 간의 구분을 강조하기 위해 다음 일반 규칙이 적용됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e아래에 정의된 타입(예: \u003ccode\u003eAny\u003c/code\u003e, \u003ccode\u003eUnion\u003c/code\u003e 등)은 인스턴스화할 수 없으며, 시도하면 \u003ccode\u003eTypeError\u003c/code\u003e가 발생합니다. (단, \u003ccode\u003eGeneric\u003c/code\u003e의 비추상 서브클래스는 가능합니다.)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGeneric\u003c/code\u003e 및 그로부터 파생된 클래스를 제외하고는 아래에 정의된 타입을 서브클래싱할 수 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eisinstance\u003c/code\u003e 또는 \u003ccode\u003eissubclass\u003c/code\u003e에 나타나면 \u003ccode\u003eTypeError\u003c/code\u003e가 발생합니다 (매개변수화되지 않은 제네릭 제외).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e기본 구성 요소 (Fundamental building blocks)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eAny\u003c/code\u003e\u003c/strong\u003e: 모든 타입은 \u003ccode\u003eAny\u003c/code\u003e와 일치하며, \u003ccode\u003eAny\u003c/code\u003e 또한 모든 타입과 일치합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eUnion[t1, t2, …]\u003c/code\u003e\u003c/strong\u003e: \u003ccode\u003et1\u003c/code\u003e 등의 최소한 하나 이상의 서브타입인 타입들이 이 \u003ccode\u003eUnion\u003c/code\u003e의 서브타입이 됩니다.\n\u003cul\u003e\n\u003cli\u003e인수의 순서는 중요하지 않습니다.\u003c/li\u003e\n\u003cli\u003e중첩된 \u003ccode\u003eUnion\u003c/code\u003e은 평탄화됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eti\u003c/code\u003e와 \u003ccode\u003etj\u003c/code\u003e가 서브타입 관계에 있다면, 덜 구체적인(less specific) 타입이 남습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUnion[t1]\u003c/code\u003e은 \u003ccode\u003et1\u003c/code\u003e을 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUnion[]\u003c/code\u003e은 허용되지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUnion[..., object, ...]\u003c/code\u003e은 \u003ccode\u003eobject\u003c/code\u003e를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eOptional[t1]\u003c/code\u003e\u003c/strong\u003e: \u003ccode\u003eUnion[t1, None]\u003c/code\u003e의 별칭입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eTuple[t1, t2, …, tn]\u003c/code\u003e\u003c/strong\u003e: 항목들이 \u003ccode\u003et1\u003c/code\u003e 등의 인스턴스인 튜플입니다.\n\u003cul\u003e\n\u003cli\u003e길이가 같고 각 \u003ccode\u003eui\u003c/code\u003e가 \u003ccode\u003eti\u003c/code\u003e의 서브타입이면 \u003ccode\u003eTuple[u1, ..., um]\u003c/code\u003e은 \u003ccode\u003eTuple[t1, ..., tn]\u003c/code\u003e의 서브타입입니다.\u003c/li\u003e\n\u003cli\u003e빈 튜플은 \u003ccode\u003eTuple[()]\u003c/code\u003e로 표기합니다.\u003c/li\u003e\n\u003cli\u003e가변 길이의 동종 튜플 타입은 \u003ccode\u003eTuple[t1, ...]\u003c/code\u003e으로 작성할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eCallable[[t1, t2, …, tn], tr]\u003c/code\u003e\u003c/strong\u003e: 위치 인자 타입이 \u003ccode\u003et1\u003c/code\u003e 등이고 반환 타입이 \u003ccode\u003etr\u003c/code\u003e인 함수입니다.\n\u003cul\u003e\n\u003cli\u003e인자 목록은 비어 있을 수 있습니다 (\u003ccode\u003en==0\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e선택적(optional) 인자나 키워드 인자를 나타낼 방법은 없지만, \u003ccode\u003eCallable[..., tr]\u003c/code\u003e (리터럴 생략 부호)를 사용하여 인자 목록이 완전히 검사되지 않음을 나타낼 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eIntersection[t1, t2, …]\u003c/code\u003e (제안 예정):\u003c/strong\u003e \u003ccode\u003et1\u003c/code\u003e 등의 각 타입의 서브타입인 타입들이 이 \u003ccode\u003eIntersection\u003c/code\u003e의 서브타입이 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e제네릭 타입 (Generic types)\u003c/h3\u003e\n\u003cp\u003e위에서 정의된 기본 구성 요소들은 제네릭 방식으로 새로운 타입을 구성할 수 있게 합니다. 제네릭 타입 생성자(generic type constructor)는 타입을 인자로 받아 타입을 \"반환\"하는 것과 유사한 의미를 가집니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e컨테이너 클래스:\u003c/strong\u003e \u003ccode\u003elist\u003c/code\u003e 또는 \u003ccode\u003edict\u003c/code\u003e와 같은 컨테이너 클래스는 일반적으로 특정 타입의 값만 포함합니다. 따라서 다음과 같이 타입 어노테이션을 달 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eusers: list[UserID] = []\nusers.append(UserID(42)) # OK\n# users.append('Some guy') # 타입 체커에 의해 거부되어야 함\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 상황에서 타입 어노테이션을 허용하기 위해, 내장 컨테이너 및 컨테이너 추상 베이스 클래스는 타입 매개변수(type parameters)로 확장되어 제네릭 타입 생성자처럼 동작합니다. 제네릭 타입 생성자처럼 동작하는 클래스를 제네릭 타입(generic types)이라고 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Iterable\nclass Task: ...\ndef work(todo_list: Iterable[Task]) -\u003e None: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003eIterable\u003c/code\u003e은 \u003ccode\u003eTask\u003c/code\u003e라는 구체적인 타입을 받아 \u003ccode\u003eIterable[Task]\u003c/code\u003e라는 구체적인 타입을 반환하는 제네릭 타입입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e제네릭 함수:\u003c/strong\u003e 타입 변수(type variables)를 사용하여 제네릭 함수의 타입 어노테이션을 허용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef take_first(seq: Sequence[T]) -\u003e T: # 제네릭 함수\n    return seq[0]\n\naccumulator: int = 0\naccumulator += take_first([1, 2, 3]) # 안전함, T는 int로 추론됨\n# accumulator += take_first((2.7, 3.5)) # 안전하지 않음\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e타입 변수 (Type variables)\u003c/h3\u003e\n\u003cp\u003e타입 변수는 타입 어노테이션에서 광범위하게 사용됩니다. 타입 체커의 타입 추론(type inference) 내부 메커니즘도 일반적으로 타입 변수를 기반으로 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eX = TypeVar('X')\u003c/code\u003e: 고유한 타입 변수를 선언합니다. 이름은 변수 이름과 일치해야 합니다. 기본적으로 타입 변수는 모든 가능한 타입을 범위로 가집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eT = TypeVar('T')\ndef do_nothing(one_arg: T, other_arg: T) -\u003e None: pass\ndo_nothing(1, 2) # OK, T는 int\ndo_nothing('abc', UserID(42)) # OK, T는 object\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eY = TypeVar('Y', t1, t2, ...)\u003c/code\u003e: \u003ccode\u003et1\u003c/code\u003e 등으로 제한된 타입 변수입니다. \u003ccode\u003eUnion[t1, t2, ...]\u003c/code\u003e와 유사하게 동작합니다. 제약이 있는 타입 변수는 \u003ccode\u003et1\u003c/code\u003e 등 제약 내에서만 범위를 가지며, 제약의 서브클래스는 \u003ccode\u003et1\u003c/code\u003e 등 중에서 가장 파생된 베이스 클래스로 대체됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eAnyStr = TypeVar('AnyStr', str, bytes)\ndef longest(first: AnyStr, second: AnyStr) -\u003e AnyStr:\n    return first if len(first) \u003e= len(second) else second\n\nresult = longest('a', 'abc') # result의 추론된 타입은 str\n# result = longest('a', b'abc') # 정적 타입 검사 실패\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서 \u003ccode\u003elongest()\u003c/code\u003e의 두 인수는 모두 동일한 타입(\u003ccode\u003estr\u003c/code\u003e 또는 \u003ccode\u003ebytes\u003c/code\u003e)이어야 하며, 공통 \u003ccode\u003estr\u003c/code\u003e 서브클래스의 인스턴스라 할지라도 반환 타입은 여전히 \u003ccode\u003estr\u003c/code\u003e입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e제네릭 타입 정의 및 사용 (Defining and using generic types)\u003c/h3\u003e\n\u003cp\u003e사용자는 \u003ccode\u003eGeneric\u003c/code\u003e이라는 특별한 구성 요소를 사용하여 자신의 클래스를 제네릭 타입으로 선언할 수 있습니다. \u003ccode\u003eclass MyGeneric(Generic[X, Y, ...]): ...\u003c/code\u003e 정의는 타입 변수 \u003ccode\u003eX\u003c/code\u003e, \u003ccode\u003eY\u003c/code\u003e 등을 통해 \u003ccode\u003eMyGeneric\u003c/code\u003e이라는 제네릭 타입을 정의합니다. \u003ccode\u003eMyGeneric\u003c/code\u003e 자체는 매개변수화(parameterizable)될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass CustomQueue(Generic[T]):\n    def put(self, task: T) -\u003e None: ...\n    def get(self) -\u003e T: ...\n\ndef communicate(queue: CustomQueue[str]) -\u003e Optional[str]: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제네릭 타입에서 파생된 클래스는 제네릭이 됩니다. 클래스는 여러 제네릭 타입을 서브클래싱할 수 있습니다. 그러나 제네릭에 의해 반환된 특정 타입에서 파생된 클래스는 제네릭이 아닙니다.\u003c/p\u003e\n\u003cp\u003e타입 변수가 생략된 상태로 타입 어노테이션에 제네릭 타입이 나타나면 \u003ccode\u003eAny\u003c/code\u003e로 가정됩니다. 이러한 형태는 동적 타이핑으로의 폴백으로 사용될 수 있으며 \u003ccode\u003eissubclass\u003c/code\u003e 및 \u003ccode\u003eisinstance\u003c/code\u003e와 함께 사용이 허용됩니다. 모든 인스턴스의 타입 정보는 런타임에 지워집니다.\u003c/p\u003e\n\u003ch3\u003e공변성 (Covariance) 및 반변성 (Contravariance)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003et2\u003c/code\u003e가 \u003ccode\u003et1\u003c/code\u003e의 서브타입일 때, 제네릭 타입 생성자 \u003ccode\u003eGenType\u003c/code\u003e은 다음과 같이 불립니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e공변 (Covariant):\u003c/strong\u003e 모든 \u003ccode\u003et1\u003c/code\u003e, \u003ccode\u003et2\u003c/code\u003e에 대해 \u003ccode\u003eGenType[t2]\u003c/code\u003e가 \u003ccode\u003eGenType[t1]\u003c/code\u003e의 서브타입인 경우.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e반변 (Contravariant):\u003c/strong\u003e 모든 \u003ccode\u003et1\u003c/code\u003e, \u003ccode\u003et2\u003c/code\u003e에 대해 \u003ccode\u003eGenType[t1]\u003c/code\u003e이 \u003ccode\u003eGenType[t2]\u003c/code\u003e의 서브타입인 경우.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e불변 (Invariant):\u003c/strong\u003e 위 두 가지 모두 해당하지 않는 경우.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e실제 예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e**\u003ccode\u003eUnion\u003c/code\u003e**은 모든 인자에서 공변적으로 동작합니다.\u003c/li\u003e\n\u003cli\u003e**\u003ccode\u003eFrozenSet[T]\u003c/code\u003e**는 공변입니다. \u003ccode\u003eint\u003c/code\u003e는 \u003ccode\u003efloat\u003c/code\u003e의 서브타입이고, \u003ccode\u003eFrozenSet[int]\u003c/code\u003e의 값 집합은 \u003ccode\u003eFrozenSet[float]\u003c/code\u003e의 값 집합의 명확한 부분집합이기 때문에 \u003ccode\u003eFrozenSet[int]\u003c/code\u003e는 \u003ccode\u003eFrozenSet[float]\u003c/code\u003e의 서브타입입니다.\u003c/li\u003e\n\u003cli\u003e**\u003ccode\u003eList[T]\u003c/code\u003e**는 불변입니다. \u003ccode\u003eList[int]\u003c/code\u003e의 값 집합이 \u003ccode\u003eList[float]\u003c/code\u003e의 값 집합의 부분집합이더라도, \u003ccode\u003eList[int]\u003c/code\u003e에는 \u003ccode\u003eint\u003c/code\u003e만 추가할 수 있기 때문에 \u003ccode\u003eList[int]\u003c/code\u003e는 \u003ccode\u003eList[float]\u003c/code\u003e의 서브타입이 아닙니다. 이는 가변(mutable) 타입에서 전형적인 상황입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eCallable\u003c/code\u003e\u003c/strong\u003e 타입은 반환 타입에는 공변이지만, 인자에는 반변입니다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCallable[[], int]\u003c/code\u003e는 \u003ccode\u003eCallable[[], float]\u003c/code\u003e의 서브타입입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCallable[[float], None]\u003c/code\u003e는 \u003ccode\u003eCallable[[int], None]\u003c/code\u003e의 서브타입입니다.\n즉, \u003ccode\u003eManager\u003c/code\u003e에 대한 급여를 계산할 수 있는 함수가 예상되는 상황에서 \u003ccode\u003eEmployee\u003c/code\u003e에 대한 급여를 계산할 수 있는 \u003ccode\u003eCallable[[Employee], Decimal]\u003c/code\u003e도 허용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e사용자 정의 제네릭 타입에 대한 공변성/반변성은 매개변수로 사용되는 타입 변수의 정의에서 \u003ccode\u003ecovariant=True\u003c/code\u003e 또는 \u003ccode\u003econtravariant=True\u003c/code\u003e 특수 키워드를 사용하여 선언할 수 있습니다. 타입은 기본적으로 불변입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eT_co = TypeVar('T_co', covariant=True)\nclass Box(Generic[T_co]): # 이 타입은 공변으로 선언됨\n    def __init__(self, content: T_co) -\u003e None:\n        self._content = content\n    def get_content(self) -\u003e T_co:\n        return self._content\n\nT_contra = TypeVar('T_contra', contravariant=True)\nclass Sink(Generic[T_contra]): # 이 타입은 반변으로 선언됨\n    def send_to_nowhere(self, data: T_contra) -\u003e None:\n        # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e분산은 타입 변수의 속성이 아니라 제네릭 타입의 속성입니다.\u003c/p\u003e\n\u003ch3\u003e실용적인 측면 (Pragmatics)\u003c/h3\u003e\n\u003cp\u003e몇 가지 사항은 이론과 무관하지만 실제 사용을 더 편리하게 만듭니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e타입이 예상되는 곳에 \u003ccode\u003eNone\u003c/code\u003e 대신 \u003ccode\u003etype(None)\u003c/code\u003e을 사용할 수 있습니다. 예: \u003ccode\u003eUnion[t1, None] == Union[t1, type(None)]\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e타입 별칭 (Type aliases):\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ePoint = Tuple[float, float]\ndef distance(point: Point) -\u003e float: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e문자열을 통한 전방 참조 (Forward references):\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass MyComparable:\n    def compare(self, other: 'MyComparable') -\u003e int: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e제약되지 않은(unconstrained), 제약된(constrained), 또는 바운드된(bounded) \u003ccode\u003eTypeVar\u003c/code\u003e 선언:\u003c/strong\u003e \u003ccode\u003eTypeVar('T', bound=complex)\u003c/code\u003e와 같이 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e주석 내 타입 선언 (Type declaration in comments):\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elst = [] # type: Sequence[int]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ecast(T, obj)\u003c/code\u003e 사용:\u003c/strong\u003e \u003ccode\u003ezork = cast(Any, frobozz())\u003c/code\u003e와 같이 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e오버로딩(overloading) 및 스텁 모듈(stub modules)과 같은 다른 사항은 PEP 484를 참조하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003etyping.py\u003c/code\u003e에 미리 정의된 제네릭 타입 및 프로토콜 (Predefined generic types and Protocols in typing.py)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003etyping.py\u003c/code\u003e 모듈에서 제공되는 타입들은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecollections.abc\u003c/code\u003e의 모든 것 (단, \u003ccode\u003eSet\u003c/code\u003e은 \u003ccode\u003eAbstractSet\u003c/code\u003e으로 이름 변경).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDict\u003c/code\u003e, \u003ccode\u003eList\u003c/code\u003e, \u003ccode\u003eSet\u003c/code\u003e, \u003ccode\u003eFrozenSet\u003c/code\u003e 등.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ere.Pattern[AnyStr]\u003c/code\u003e, \u003ccode\u003ere.Match[AnyStr]\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eio.IO[AnyStr]\u003c/code\u003e, \u003ccode\u003eio.TextIO ~ io.IO[str]\u003c/code\u003e, \u003ccode\u003eio.BinaryIO ~ io.IO[bytes]\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 483 - The Theory of Type Hints\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:28:39+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"page__taxonomy mb-4\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"카테고리\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":\"Python\"}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":\"PEP\"}]]]}],[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]]}]]}]}]}]\nb:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett26"])</script><script>self.__next_f.push([1,"33\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"21\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>