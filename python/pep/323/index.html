<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js"/><script src="/secrett2633.github.io/_next/static/chunks/fd9d1056-62aaf4b921c84028.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/23-ca4408d024135d8d.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/main-app-fa660020ba1e0b6e.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/231-c4b666723e6aae68.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/layout-8808afda01b7a1b7.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="next-size-adjust"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/secrett2633.github.io/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_9012cf layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/secrett2633.github.io">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Deferred] PEP 323 - Copyable Iterators</h1><div class="page__meta"><time dateTime="2025-09-26 18:31:01+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0323/">PEP 323 - Copyable Iterators</a></p>
<p><strong>상태:</strong> Deferred | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 25-Oct-2003</p>
</blockquote>
<p>PEP 323 – 복사 가능한 이터레이터 (Copyable Iterators)</p>
<hr>
<h2>개요</h2>
<p>이 PEP (Python Enhancement Proposal)는 일부 이터레이터 (iterator) 유형이 <code>__copy__</code> 메서드를 통해 인스턴스의 얕은 복사 (shallow copy)를 지원해야 한다고 제안합니다. 이 제안은 <code>__copy__</code> 메서드를 사용하는 코드가 어떻게 이러한 기능을 활용할 수 있는지 보여줍니다.</p>
<p><strong>상태:</strong> 연기됨 (Deferred)
<strong>작성자:</strong> Alex Martelli
<strong>생성일:</strong> 2003년 10월 25일
<strong>Python 버전:</strong> 2.5</p>
<h2>연기 (Deferral)</h2>
<p>이 PEP는 연기되었습니다. 복사 가능한 이터레이터는 좋은 아이디어였지만, 4년이 지난 후에도 구현되거나 광범위한 관심을 받지 못했습니다.</p>
<h2>추상 (Abstract)</h2>
<p>이 PEP는 특정 요구 사항을 충족하는 <code>__copy__</code> 메서드를 노출함으로써 일부 이터레이터 타입이 인스턴스의 얕은 복사를 지원해야 한다고 제안하며, 이터레이터를 사용하는 코드가 <code>__copy__</code> 메서드를 활용하는 방법을 제시합니다.</p>
<h2>업데이트 및 코멘트 (Update and Comments)</h2>
<p><code>__copy__</code> 지원은 Python 2.4의 <code>itertools.tee()</code>에 포함되었습니다. 기존 이터레이터에 <code>__copy__</code> 메서드를 추가하면 <code>tee()</code>의 동작이 변경될 수 있습니다. 현재 복사된 이터레이터는 원래 이터레이터에 묶여 있으며, 원본이 진행되면 모든 복사본도 진행됩니다. 좋은 관행은 <code>a, b = tee(a)</code>처럼 원본을 덮어쓰는 것입니다. 이 관행을 따르지 않는 코드는 <code>__copy__</code> 메서드가 이터레이터에 추가될 경우 의미적 변화를 관찰할 수 있습니다.</p>
<h2>동기 (Motivation)</h2>
<p>Python 2.3까지 대부분의 내장 이터레이터 유형은 인스턴스를 복사할 수 없었습니다. 사용자가 작성한 이터레이터는 <code>copy.copy</code>를 호출할 수 있지만, 복사 결과로 원본과 독립적으로 이터레이션할 수 있는 별도의 이터레이터 객체를 반환할 수도 있고 그렇지 않을 수도 있습니다.</p>
<p>현재 사용자 정의 이터레이터 타입에서 <code>copy.copy</code> 지원은 거의 항상 "우발적"입니다. 즉, Python 표준 라이브러리의 <code>copy</code> 모듈에 있는 <code>copy</code> 메서드의 표준 메커니즘은 복사본을 만들고 반환하지만, 복사본이 원본과 독립적으로 이터레이션 가능하려면 해당 클래스의 <code>.next()</code> 호출이 인스턴스 상태를 기존 값 변경이 아닌 새 값으로 속성을 재할당함으로써만 변경해야 합니다.</p>
<p>예를 들어, "인덱스" 상태가 정수 속성으로 유지되는 이터레이터는 유용한 복사본을 제공할 수 있습니다. 반면에 "인덱스" 상태가 리스트 속성으로 유지되는 이터레이터는 <code>.next()</code> 실행 시 동일한 리스트 객체를 변경할 것이므로, 이러한 이터레이터의 복사본은 원본과 독립적으로 이터레이션할 수 없습니다.</p>
<p>이러한 상황 때문에 <code>copy.copy(it)</code>는 유용하지 않으며 널리 사용되지 않습니다. 그러나 이터레이터의 "스냅샷"을 "북마크"처럼 얻어 시퀀스를 계속 이터레이션하다가 나중에 북마크 지점부터 다시 이터레이션할 수 있는 많은 경우가 있습니다. 이러한 "북마킹"을 지원하기 위해 <code>itertools</code> 모듈은 Python 2.4에서 <code>tee</code> 함수를 추가했습니다:</p>
<pre><code class="language-python">it, bookmark = itertools.tee(it)
</code></pre>
<p>이 호출 후에 <code>it</code>와 <code>bookmark</code>는 원래 <code>it</code>와 동일한 기본 시퀀스에 대해 독립적으로 이터레이션할 수 있는 이터레이터가 되어 "이터레이터 복사"에 대한 애플리케이션 요구 사항을 충족합니다. <code>it</code>의 이전 값은 다시 사용해서는 안 됩니다.</p>
<p>그러나 <code>itertools.tee</code>는 인수로 전달된 이터레이터의 특성에 대해 가정을 할 수 없을 때, 두 "티된" 이터레이터 중 하나만 진행했지만 둘 다 아직 진행하지 않은 모든 항목을 메모리에 저장해야 합니다. 이는 두 이터레이터가 진행에서 서로 크게 멀어질 경우 메모리 비용이 상당히 커질 수 있습니다.</p>
<p>이 PEP는 중요한 경우 <code>itertools.tee</code>가 메모리 비용을 최소화하면서 작동하도록 하는 또 다른 아이디어를 제안합니다. 이는 사용자 코드도 이터레이터를 복사할지, 리스트로 만들지, 보조 디스크 파일을 사용할지 결정하는 데 활용할 수 있습니다.</p>
<p>핵심 고려 사항은 시퀀스 위에 내장 함수 <code>iter</code>가 만드는 이터레이터와 같은 일부 중요한 이터레이터는 본질적으로 복사하기 쉽다는 것입니다. 단순히 동일한 시퀀스에 대한 다른 참조와 정수 인덱스의 복사본을 얻으면 됩니다. 그러나 Python 2.3에서는 이러한 이터레이터가 상태를 노출하지 않으며 <code>copy.copy</code>를 지원하지 않습니다.</p>
<p>따라서 이 PEP의 목적은 이러한 이터레이터 유형이 적절한 <code>__copy__</code> 메서드를 노출하도록 하는 것입니다. 마찬가지로, 독립적인 이터레이션에 적합하고 시간 및 공간 비용이 제한적인 인스턴스 복사본을 제공할 수 있는 사용자 정의 이터레이터 유형도 적절한 <code>__copy__</code> 메서드를 노출해야 합니다. <code>copy.copy</code>는 타입이 인스턴스 복사 방식을 제어하는 다른 방법도 지원하지만, 단순화를 위해 복사를 지원하는 이터레이터 타입은 항상 <code>__copy__</code> 메서드를 노출하는 방식으로만 이를 수행하도록 제안됩니다.</p>
<p>이터레이터가 가능한 경우 적절한 <code>__copy__</code>를 노출하면 <code>itertools.tee</code> 및 유사한 사용자 코드의 쉬운 최적화를 가능하게 합니다:</p>
<pre><code class="language-python">def tee(it):
    it = iter(it)
    try:
        copier = it.__copy__
    except AttributeError:
        # 복사 불가능한 이터레이터, 필요한 모든 어려운 작업 수행
        # [생략!]
    else:
        return it, copier()
</code></pre>
<p>이 함수는 <code>copy.copy(it)</code>를 호출하지 않습니다. 이는 이 PEP가 구현된 후에도 일부 사용자 정의 클래스로 구현된 이터레이터 유형에 대해 "단순히 성공할 수도" 있지만, 실제로 적절한 "독립적으로 이터레이션 가능한" 복사 객체를 결과로 제공하지 않을 수 있기 때문입니다.</p>
<h2>명세 (Specification)</h2>
<p>모든 이터레이터 타입 <code>X</code>는 <code>X</code>의 어떤 인스턴스 <code>x</code>에 대해서도 인자 없이 호출할 수 있는 <code>__copy__</code> 메서드를 노출할 수 있습니다. 이 메서드는 이터레이터 타입이 합리적으로 적은 계산 및 메모리 노력으로 복사 가능성을 제공할 수 있는 경우에만 노출되어야 합니다. 또한, <code>__copy__</code> 메서드가 반환하는 새 객체 <code>y</code>는 <code>x</code>와 독립적이고 별도로 이터레이션되며, 동일한 "기본 시퀀스" 항목을 따라 진행하는 <code>X</code>의 새 인스턴스여야 합니다.</p>
<p>예를 들어, <code>Iter</code> 클래스가 시퀀스에 대한 내장 <code>iter</code>의 기능을 본질적으로 복제한다고 가정합니다:</p>
<pre><code class="language-python">class Iter(object):
    def __init__(self, sequence):
        self.sequence = sequence
        self.index = 0
    def __iter__(self):
        return self
    def next(self):
        try:
            result = self.sequence[self.index]
        except IndexError:
            raise StopIteration
        self.index += 1
        return result
</code></pre>
<p>이 <code>Iter</code> 클래스를 이 PEP에 부합하도록 만들려면, <code>Iter</code> 클래스 본문에 다음 추가가면 충분합니다:</p>
<pre><code class="language-python">    def __copy__(self):
        result = self.__class__(self.sequence)
        result.index = self.index
        return result
</code></pre>
<p>이 경우 <code>__copy__</code>는 시퀀스를 복사하려고 시도하지 않습니다. 원본 또는 복사된 이터레이터 중 하나 또는 둘 다 시퀀스를 진행하는 동안 시퀀스가 변경되면 이터레이션 동작이 잘못될 가능성이 높습니다. 이는 변경 가능한 시퀀스를 이터레이션하는 이터레이터의 일반적인 Python 동작을 변경하는 것은 <code>__copy__</code>의 책임이 아닙니다 (이는 이터레이터의 <code>__deepcopy__</code> 메서드에 대한 명세일 수 있지만, 이 PEP는 이를 다루지 않습니다).</p>
<p>또한, 주어진 인수로 호출된 임의 인스턴스의 특정 메서드로부터 무한한 결과 시퀀스를 제공하는 "랜덤 이터레이터"를 고려해 보십시오:</p>
<pre><code class="language-python">class RandomIterator(object):
    def __init__(self, bound_method, *args):
        self.call = bound_method
        self.args = args
    def __iter__(self):
        return self
    def next(self):
        return self.call(*self.args)
    def __copy__(self):
        import copy, new
        im_self = copy.copy(self.call.im_self)
        method = new.instancemethod(self.call.im_func, im_self)
        return self.__class__(method, *self.args)
</code></pre>
<p>이 이터레이터 유형은 이름이 의미하는 것보다 약간 더 일반적입니다. <code>im_self</code>를 복사하기 위해 <code>copy.copy</code>를 사용해야 합니다. <code>random.Random</code> 인스턴스는 <code>__getstate__</code> 및 <code>__setstate__</code>를 통해 복사를 지원하며, <code>__copy__</code>를 통하지 않습니다. <code>copy.copy</code>를 사용하는 것이 객체의 얕은 복사본을 얻는 일반적인 방법입니다.</p>
<h2>세부 사항 (Details)</h2>
<p>사용자 정의 이터레이터 타입이 <code>__copy__</code> 메서드를 지원하도록 권장하는 것 외에도 (메모리 및 런타임 비용이 적고 독립적으로 이터레이션 가능한 이터레이터 객체의 복사본을 생성할 수 있는 경우에만), 이 PEP의 구현은 특히 내장 <code>iter</code>가 반환하는 시퀀스 이터레이터와 내장 <code>dict</code> 타입의 <code>__iter__</code>, <code>iterkeys</code>, <code>itervalues</code>, <code>iteritems</code> 메서드가 반환하는 딕셔너리 이터레이터에 복사 가능성을 추가하는 것을 포함할 것입니다.</p>
<p>제너레이터 함수에 의해 생성된 이터레이터는 복사할 수 없습니다. 그러나 Python 2.4의 새 "제너레이터 표현식" (PEP 289)에 의해 생성된 이터레이터는 기본 이터레이터가 복사 가능한 경우 복사 가능해야 합니다. 제너레이터 표현식에 가능한 엄격한 제한은 제너레이터의 훨씬 더 넓은 일반성에 비해 이를 실현 가능하게 만들어야 합니다. 마찬가지로 내장 함수 <code>enumerate</code> 및 <code>itertools</code> 모듈에서 제공하는 특정 함수에 의해 생성된 이터레이터는 기본 이터레이터가 복사 가능한 경우 복사 가능해야 합니다.</p>
<p>이 PEP의 구현은 또한 동기 섹션에서 언급된 새로운 <code>itertools.tee</code> 함수의 최적화를 포함할 것입니다.</p>
<h2>이론적 근거 (Rationale)</h2>
<p>이터레이터의 (얕은) 복사에 대한 주요 사용 사례는 <code>itertools.tee</code> (2.4에 새로 추가됨) 함수와 동일합니다. 사용자 코드는 이터레이터를 직접 복사하려고 시도하지 않을 것입니다. 왜냐하면 복사 불가능한 경우를 별도로 처리해야 하기 때문입니다. <code>itertools.tee</code>를 호출하면 적절한 경우 내부적으로 복사를 수행하고, 복사 불가능한 이터레이터에 대해서는 암시적으로 최대한 효율적인 비복사 전략으로 대체됩니다. (때때로 사용자 코드는 다른 전략, 예를 들어 리스트를 만들거나 시퀀스를 디스크에 저장하는 것과 같은 방식으로 복사 불가능한 이터레이터를 처리하기 위해 더 직접적인 제어를 원할 수도 있습니다).</p>
<p>"tee"된 이터레이터는 "참조 지점" 역할을 하여 시퀀스 처리가 알려진 지점에서 계속되거나 재개될 수 있도록 하는 동시에, 다른 독립적인 이터레이터는 필요에 따라 시퀀스의 더 먼 부분을 "탐색"하기 위해 자유롭게 진행될 수 있습니다. 간단한 예: 숫자의 이터레이터 (양수라고 가정)를 받아서, 입력 이터레이터의 각 항목에 해당하는 총합의 분수 값을 반환하는 제너레이터 함수입니다. 호출자는 총합을 미리 알고 있다면 값으로 전달할 수 있습니다. 그렇지 않으면 이 제너레이터 함수를 호출하여 반환된 이터레이터는 먼저 총합을 계산합니다.</p>
<pre><code class="language-python">def fractions(numbers, total=None):
    if total is None:
        numbers, aux = itertools.tee(numbers)
        total = sum(aux)
    total = float(total)
    for item in numbers:
        yield item / total
</code></pre>
<p><code>numbers</code> 이터레이터를 "tee"할 수 있는 기능은, <code>numbers</code> 이터레이터가 복사 가능한 경우, 필요한 경우 총합을 미리 계산하는 데 <code>O(N)</code> 보조 메모리를 반드시 요구하지 않으면서 이 제너레이터가 작동하도록 합니다.</p>
<p>"이터레이터 북마킹"의 또 다른 예로, 가끔 "후위 연산자" 역할을 하는 문자열이 포함된 숫자 스트림을 생각해 봅시다. 가장 흔한 연산자는 <code>'+'</code>이며, 이 경우 이전의 모든 숫자 (이전 연산자가 있었다면 그 이후, 아니면 처음부터)를 합산하여 결과를 yield 해야 합니다. 때때로 <code>'*'</code>를 발견할 수도 있는데, 이는 이전 숫자를 합산하는 대신 곱해야 한다는 점만 다릅니다.</p>
<pre><code class="language-python">def filter_weird_stream(stream):
    it = iter(stream)
    while True:
        it, bookmark = itertools.tee(it)
        total = 0
        for item in it:
            if item == '+':
                yield total
                break
            elif item == '*':
                product = 1
                for item in bookmark:
                    if item == '*':
                        yield product
                        break
                    else:
                        product *= item
                else: # bookmark loop did not break
                    yield product # yield final product if no more '*'
                break # break from outer loop after '*' is handled
            else:
                total += item
        else: # it loop did not break
            # Reached end of stream, yield final total if no operator
            # This part needs careful handling based on exact requirements.
            # For simplicity, let's assume stream always ends with an operator or is empty.
            if total != 0: # If there were numbers before EOF and no operator
                yield total
            raise StopIteration
</code></pre>
<p><strong>참고:</strong> 위의 <code>filter_weird_stream</code> 예제는 원본 PEP의 코드와 약간 다르게 해석될 수 있습니다. 특히 <code>else</code> 블록의 처리는 상황에 따라 다르게 구현될 수 있습니다. PEP의 예제는 <code>'*'</code> 연산자 후 <code>it</code>가 소비되는 것을 보여주며, <code>bookmark</code>는 그 지점부터 다시 시작합니다. 원본 코드를 그대로 옮기기보다는 핵심 개념을 설명하는 데 집중했습니다.</p>
<p><code>itertools.tee</code>의 유사한 사용 사례는 이터레이터로 표현된 명령 스트림에 대한 "실행 취소", 토큰 스트림 파싱에 대한 "백트래킹" 등과 같은 작업을 지원할 수 있습니다. (물론, 각 경우에 작업의 세부 사항에 따라 단일 이터레이터로 시퀀스를 진행하는 동안 시퀀스의 관련 부분을 리스트에 저장하는 것과 같은 더 간단한 가능성도 고려해야 합니다).</p>
<p>다음은 기본 이터레이터가 <code>__copy__</code>를 지원하는 경우 내장 <code>enumerate</code>가 <code>__copy__</code>를 지원하도록 확장될 수 있는 방법에 대한 순수 Python 예제입니다:</p>
<pre><code class="language-python">class enumerate(object):
    def __init__(self, it):
        self.it = iter(it)
        self.i = -1
    def __iter__(self):
        return self
    def next(self):
        self.i += 1
        return self.i, self.it.next()
    def __copy__(self):
        result = self.__class__.__new__(self.__class__) # Use __new__ with class argument
        result.it = self.it.__copy__()
        result.i = self.i
        return result
</code></pre>
<p><strong>참고:</strong> <code>__new__</code> 호출 방식은 Python 2.x와 3.x에서 약간 다를 수 있습니다. 위 코드는 Python 2.x 스타일을 따릅니다.</p>
<p>다음은 이터레이터의 "우발적인 복사 가능성"으로 인해 발생하는 "취약성"의 한 예입니다. 즉, <code>copy.copy</code>가 성공하더라도 결과로 원본과 독립적으로 이터레이션할 수 있는 이터레이터를 받을 것이라고 기대해서는 안 됩니다. 다음은 간단한 중첩 리스트인 "트리"를 (선위 순서로) 이터레이션하는 이터레이터 클래스입니다. 리스트인 항목은 하위 트리로, 다른 항목은 리프로 처리됩니다.</p>
<pre><code class="language-python">class ListreeIter(object):
    def __init__(self, tree):
        self.tree = [tree]
        self.indx = [-1]
    def __iter__(self):
        return self
    def next(self):
        if not self.indx:
            raise StopIteration
        self.indx[-1] += 1
        try:
            result = self.tree[-1][self.indx[-1]]
        except IndexError:
            self.tree.pop()
            self.indx.pop()
            return self.next()
        if type(result) is not list:
            return result
        self.tree.append(result)
        self.indx.append(-1)
        return self.next()
</code></pre>
<p>다음 코드는 의도한 대로 작동하지 않습니다. <code>copy.copy</code>가 수행하는 우발적인 복사가 "인덱스" 리스트인 변경 가능한 속성 <code>it.indx</code>를 복제하는 대신 공유하기 때문에, <code>cop</code> 이터레이터는 원본 <code>it</code> 이터레이터가 진행됨에 따라 단계별로 소모되고 고갈됩니다. 따라서 이 이터레이터의 "클라이언트 코드"는 시퀀스의 일부를 이터레이터를 <code>copy.copy</code>하여 두 번 이터레이션하려고 시도하지만, 이는 올바르지 않습니다.</p>
<p>올바른 해결책 중 하나는 <code>itertools.tee</code>를 사용하는 것입니다. 즉, 첫 번째 <code>for</code> 루프를 다음과 같이 변경합니다:</p>
<pre><code class="language-python">for i in it:
    print i,
    if i == 6:
        it, cop = itertools.tee(it)
        break
for i in it:
    print i,
</code></pre>
<p>(이 루프를 두 부분으로 나누어야 합니다. 그렇지 않으면 <code>tee()</code> 호출 후 더 이상 사용해서는 안 되는 <code>it</code>의 원래 값에서 계속 루프를 돌게 됩니다!) 또는 리스트를 만듭니다:</p>
<pre><code class="language-python">for i in it:
    print i,
    if i == 6:
        cop = lit = list(it)
        break
for i in lit:
    print i,
</code></pre>
<p>(다시, <code>list(it)</code> 호출에 의해 이터레이터 <code>it</code>가 소진되므로 루프를 두 부분으로 나누어야 합니다).</p>
<p>마지막으로, 이 PEP가 권장하는 대로 <code>ListreeIter</code>가 적절한 <code>__copy__</code> 메서드를 제공한다면 이 모든 해결책이 작동할 것입니다:</p>
<pre><code class="language-python">    def __copy__(self):
        result = self.__class__.__new__(self.__class__) # Use __new__ with class argument
        result.tree = copy.copy(self.tree)
        result.indx = copy.copy(self.indx)
        return result
</code></pre>
<p>복사본을 "더 깊이" 만들 필요는 없지만, 두 개의 변경 가능한 "인덱스 상태" 속성은 "적절한" (독립적으로 이터레이션 가능한) 이터레이터 복사본을 얻기 위해 실제로 복사되어야 합니다.</p>
<p>권장되는 해결책은 <code>ListreeIter</code> 클래스가 이 <code>__copy__</code> 메서드를 제공하고 클라이언트 코드가 <code>itertools.tee</code>를 사용하는 것입니다 (위에서 보여준 두 부분으로 나뉜 루프와 함께). 이렇게 하면 클라이언트 코드가 사용할 수 있는 다양한 이터레이터 유형에 대해 최대한 관용적이며, 동시에 이 특정 이터레이터 유형의 "tee"ing에 대해 좋은 성능을 달성할 수 있습니다.</p>
<h2>참조 (References)</h2>
<ul>
<li>python-dev 토론 시작 게시물: <a href="https://mail.python.org/pipermail/python-dev/2003-October/038969.html">https://mail.python.org/pipermail/python-dev/2003-October/038969.html</a></li>
<li>표준 라이브러리의 <code>copy</code> 모듈 온라인 문서: <a href="https://docs.python.org/release/2.6/library/copy.html">https://docs.python.org/release/2.6/library/copy.html</a></li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 공개 도메인에 배치되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy mb-4"><h4 class="text-sm font-medium text-gray-900 mb-2">카테고리</h4><span class="page__taxonomy-item">Python</span><span class="page__taxonomy-item">PEP</span></div><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[4281,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"185\",\"static/chunks/app/layout-8808afda01b7a1b7.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/323\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"iV6XySbMHIJ3imQdvgy3I\",\"assetPrefix\":\"/secrett2633.github.io\",\"initialCanonicalUrl\":\"/python/pep/323/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/323\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"323\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/323\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"32x32\",\"href\":\"/favicon-32x32.png\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"16x16\",\"href\":\"/favicon-16x16.png\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_9012cf layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T5832,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0323/\"\u003ePEP 323 - Copyable Iterators\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Deferred | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 25-Oct-2003\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 323 – 복사 가능한 이터레이터 (Copyable Iterators)\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e개요\u003c/h2\u003e\n\u003cp\u003e이 PEP (Python Enhancement Proposal)는 일부 이터레이터 (iterator) 유형이 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 통해 인스턴스의 얕은 복사 (shallow copy)를 지원해야 한다고 제안합니다. 이 제안은 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 사용하는 코드가 어떻게 이러한 기능을 활용할 수 있는지 보여줍니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 연기됨 (Deferred)\n\u003cstrong\u003e작성자:\u003c/strong\u003e Alex Martelli\n\u003cstrong\u003e생성일:\u003c/strong\u003e 2003년 10월 25일\n\u003cstrong\u003ePython 버전:\u003c/strong\u003e 2.5\u003c/p\u003e\n\u003ch2\u003e연기 (Deferral)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 연기되었습니다. 복사 가능한 이터레이터는 좋은 아이디어였지만, 4년이 지난 후에도 구현되거나 광범위한 관심을 받지 못했습니다.\u003c/p\u003e\n\u003ch2\u003e추상 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 특정 요구 사항을 충족하는 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 노출함으로써 일부 이터레이터 타입이 인스턴스의 얕은 복사를 지원해야 한다고 제안하며, 이터레이터를 사용하는 코드가 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 활용하는 방법을 제시합니다.\u003c/p\u003e\n\u003ch2\u003e업데이트 및 코멘트 (Update and Comments)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e__copy__\u003c/code\u003e 지원은 Python 2.4의 \u003ccode\u003eitertools.tee()\u003c/code\u003e에 포함되었습니다. 기존 이터레이터에 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 추가하면 \u003ccode\u003etee()\u003c/code\u003e의 동작이 변경될 수 있습니다. 현재 복사된 이터레이터는 원래 이터레이터에 묶여 있으며, 원본이 진행되면 모든 복사본도 진행됩니다. 좋은 관행은 \u003ccode\u003ea, b = tee(a)\u003c/code\u003e처럼 원본을 덮어쓰는 것입니다. 이 관행을 따르지 않는 코드는 \u003ccode\u003e__copy__\u003c/code\u003e 메서드가 이터레이터에 추가될 경우 의미적 변화를 관찰할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePython 2.3까지 대부분의 내장 이터레이터 유형은 인스턴스를 복사할 수 없었습니다. 사용자가 작성한 이터레이터는 \u003ccode\u003ecopy.copy\u003c/code\u003e를 호출할 수 있지만, 복사 결과로 원본과 독립적으로 이터레이션할 수 있는 별도의 이터레이터 객체를 반환할 수도 있고 그렇지 않을 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e현재 사용자 정의 이터레이터 타입에서 \u003ccode\u003ecopy.copy\u003c/code\u003e 지원은 거의 항상 \"우발적\"입니다. 즉, Python 표준 라이브러리의 \u003ccode\u003ecopy\u003c/code\u003e 모듈에 있는 \u003ccode\u003ecopy\u003c/code\u003e 메서드의 표준 메커니즘은 복사본을 만들고 반환하지만, 복사본이 원본과 독립적으로 이터레이션 가능하려면 해당 클래스의 \u003ccode\u003e.next()\u003c/code\u003e 호출이 인스턴스 상태를 기존 값 변경이 아닌 새 값으로 속성을 재할당함으로써만 변경해야 합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \"인덱스\" 상태가 정수 속성으로 유지되는 이터레이터는 유용한 복사본을 제공할 수 있습니다. 반면에 \"인덱스\" 상태가 리스트 속성으로 유지되는 이터레이터는 \u003ccode\u003e.next()\u003c/code\u003e 실행 시 동일한 리스트 객체를 변경할 것이므로, 이러한 이터레이터의 복사본은 원본과 독립적으로 이터레이션할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e이러한 상황 때문에 \u003ccode\u003ecopy.copy(it)\u003c/code\u003e는 유용하지 않으며 널리 사용되지 않습니다. 그러나 이터레이터의 \"스냅샷\"을 \"북마크\"처럼 얻어 시퀀스를 계속 이터레이션하다가 나중에 북마크 지점부터 다시 이터레이션할 수 있는 많은 경우가 있습니다. 이러한 \"북마킹\"을 지원하기 위해 \u003ccode\u003eitertools\u003c/code\u003e 모듈은 Python 2.4에서 \u003ccode\u003etee\u003c/code\u003e 함수를 추가했습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eit, bookmark = itertools.tee(it)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 호출 후에 \u003ccode\u003eit\u003c/code\u003e와 \u003ccode\u003ebookmark\u003c/code\u003e는 원래 \u003ccode\u003eit\u003c/code\u003e와 동일한 기본 시퀀스에 대해 독립적으로 이터레이션할 수 있는 이터레이터가 되어 \"이터레이터 복사\"에 대한 애플리케이션 요구 사항을 충족합니다. \u003ccode\u003eit\u003c/code\u003e의 이전 값은 다시 사용해서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e그러나 \u003ccode\u003eitertools.tee\u003c/code\u003e는 인수로 전달된 이터레이터의 특성에 대해 가정을 할 수 없을 때, 두 \"티된\" 이터레이터 중 하나만 진행했지만 둘 다 아직 진행하지 않은 모든 항목을 메모리에 저장해야 합니다. 이는 두 이터레이터가 진행에서 서로 크게 멀어질 경우 메모리 비용이 상당히 커질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 중요한 경우 \u003ccode\u003eitertools.tee\u003c/code\u003e가 메모리 비용을 최소화하면서 작동하도록 하는 또 다른 아이디어를 제안합니다. 이는 사용자 코드도 이터레이터를 복사할지, 리스트로 만들지, 보조 디스크 파일을 사용할지 결정하는 데 활용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e핵심 고려 사항은 시퀀스 위에 내장 함수 \u003ccode\u003eiter\u003c/code\u003e가 만드는 이터레이터와 같은 일부 중요한 이터레이터는 본질적으로 복사하기 쉽다는 것입니다. 단순히 동일한 시퀀스에 대한 다른 참조와 정수 인덱스의 복사본을 얻으면 됩니다. 그러나 Python 2.3에서는 이러한 이터레이터가 상태를 노출하지 않으며 \u003ccode\u003ecopy.copy\u003c/code\u003e를 지원하지 않습니다.\u003c/p\u003e\n\u003cp\u003e따라서 이 PEP의 목적은 이러한 이터레이터 유형이 적절한 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 노출하도록 하는 것입니다. 마찬가지로, 독립적인 이터레이션에 적합하고 시간 및 공간 비용이 제한적인 인스턴스 복사본을 제공할 수 있는 사용자 정의 이터레이터 유형도 적절한 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 노출해야 합니다. \u003ccode\u003ecopy.copy\u003c/code\u003e는 타입이 인스턴스 복사 방식을 제어하는 다른 방법도 지원하지만, 단순화를 위해 복사를 지원하는 이터레이터 타입은 항상 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 노출하는 방식으로만 이를 수행하도록 제안됩니다.\u003c/p\u003e\n\u003cp\u003e이터레이터가 가능한 경우 적절한 \u003ccode\u003e__copy__\u003c/code\u003e를 노출하면 \u003ccode\u003eitertools.tee\u003c/code\u003e 및 유사한 사용자 코드의 쉬운 최적화를 가능하게 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef tee(it):\n    it = iter(it)\n    try:\n        copier = it.__copy__\n    except AttributeError:\n        # 복사 불가능한 이터레이터, 필요한 모든 어려운 작업 수행\n        # [생략!]\n    else:\n        return it, copier()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 \u003ccode\u003ecopy.copy(it)\u003c/code\u003e를 호출하지 않습니다. 이는 이 PEP가 구현된 후에도 일부 사용자 정의 클래스로 구현된 이터레이터 유형에 대해 \"단순히 성공할 수도\" 있지만, 실제로 적절한 \"독립적으로 이터레이션 가능한\" 복사 객체를 결과로 제공하지 않을 수 있기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003cp\u003e모든 이터레이터 타입 \u003ccode\u003eX\u003c/code\u003e는 \u003ccode\u003eX\u003c/code\u003e의 어떤 인스턴스 \u003ccode\u003ex\u003c/code\u003e에 대해서도 인자 없이 호출할 수 있는 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 노출할 수 있습니다. 이 메서드는 이터레이터 타입이 합리적으로 적은 계산 및 메모리 노력으로 복사 가능성을 제공할 수 있는 경우에만 노출되어야 합니다. 또한, \u003ccode\u003e__copy__\u003c/code\u003e 메서드가 반환하는 새 객체 \u003ccode\u003ey\u003c/code\u003e는 \u003ccode\u003ex\u003c/code\u003e와 독립적이고 별도로 이터레이션되며, 동일한 \"기본 시퀀스\" 항목을 따라 진행하는 \u003ccode\u003eX\u003c/code\u003e의 새 인스턴스여야 합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003eIter\u003c/code\u003e 클래스가 시퀀스에 대한 내장 \u003ccode\u003eiter\u003c/code\u003e의 기능을 본질적으로 복제한다고 가정합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Iter(object):\n    def __init__(self, sequence):\n        self.sequence = sequence\n        self.index = 0\n    def __iter__(self):\n        return self\n    def next(self):\n        try:\n            result = self.sequence[self.index]\n        except IndexError:\n            raise StopIteration\n        self.index += 1\n        return result\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 \u003ccode\u003eIter\u003c/code\u003e 클래스를 이 PEP에 부합하도록 만들려면, \u003ccode\u003eIter\u003c/code\u003e 클래스 본문에 다음 추가가면 충분합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e    def __copy__(self):\n        result = self.__class__(self.sequence)\n        result.index = self.index\n        return result\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 경우 \u003ccode\u003e__copy__\u003c/code\u003e는 시퀀스를 복사하려고 시도하지 않습니다. 원본 또는 복사된 이터레이터 중 하나 또는 둘 다 시퀀스를 진행하는 동안 시퀀스가 변경되면 이터레이션 동작이 잘못될 가능성이 높습니다. 이는 변경 가능한 시퀀스를 이터레이션하는 이터레이터의 일반적인 Python 동작을 변경하는 것은 \u003ccode\u003e__copy__\u003c/code\u003e의 책임이 아닙니다 (이는 이터레이터의 \u003ccode\u003e__deepcopy__\u003c/code\u003e 메서드에 대한 명세일 수 있지만, 이 PEP는 이를 다루지 않습니다).\u003c/p\u003e\n\u003cp\u003e또한, 주어진 인수로 호출된 임의 인스턴스의 특정 메서드로부터 무한한 결과 시퀀스를 제공하는 \"랜덤 이터레이터\"를 고려해 보십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass RandomIterator(object):\n    def __init__(self, bound_method, *args):\n        self.call = bound_method\n        self.args = args\n    def __iter__(self):\n        return self\n    def next(self):\n        return self.call(*self.args)\n    def __copy__(self):\n        import copy, new\n        im_self = copy.copy(self.call.im_self)\n        method = new.instancemethod(self.call.im_func, im_self)\n        return self.__class__(method, *self.args)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 이터레이터 유형은 이름이 의미하는 것보다 약간 더 일반적입니다. \u003ccode\u003eim_self\u003c/code\u003e를 복사하기 위해 \u003ccode\u003ecopy.copy\u003c/code\u003e를 사용해야 합니다. \u003ccode\u003erandom.Random\u003c/code\u003e 인스턴스는 \u003ccode\u003e__getstate__\u003c/code\u003e 및 \u003ccode\u003e__setstate__\u003c/code\u003e를 통해 복사를 지원하며, \u003ccode\u003e__copy__\u003c/code\u003e를 통하지 않습니다. \u003ccode\u003ecopy.copy\u003c/code\u003e를 사용하는 것이 객체의 얕은 복사본을 얻는 일반적인 방법입니다.\u003c/p\u003e\n\u003ch2\u003e세부 사항 (Details)\u003c/h2\u003e\n\u003cp\u003e사용자 정의 이터레이터 타입이 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 지원하도록 권장하는 것 외에도 (메모리 및 런타임 비용이 적고 독립적으로 이터레이션 가능한 이터레이터 객체의 복사본을 생성할 수 있는 경우에만), 이 PEP의 구현은 특히 내장 \u003ccode\u003eiter\u003c/code\u003e가 반환하는 시퀀스 이터레이터와 내장 \u003ccode\u003edict\u003c/code\u003e 타입의 \u003ccode\u003e__iter__\u003c/code\u003e, \u003ccode\u003eiterkeys\u003c/code\u003e, \u003ccode\u003eitervalues\u003c/code\u003e, \u003ccode\u003eiteritems\u003c/code\u003e 메서드가 반환하는 딕셔너리 이터레이터에 복사 가능성을 추가하는 것을 포함할 것입니다.\u003c/p\u003e\n\u003cp\u003e제너레이터 함수에 의해 생성된 이터레이터는 복사할 수 없습니다. 그러나 Python 2.4의 새 \"제너레이터 표현식\" (PEP 289)에 의해 생성된 이터레이터는 기본 이터레이터가 복사 가능한 경우 복사 가능해야 합니다. 제너레이터 표현식에 가능한 엄격한 제한은 제너레이터의 훨씬 더 넓은 일반성에 비해 이를 실현 가능하게 만들어야 합니다. 마찬가지로 내장 함수 \u003ccode\u003eenumerate\u003c/code\u003e 및 \u003ccode\u003eitertools\u003c/code\u003e 모듈에서 제공하는 특정 함수에 의해 생성된 이터레이터는 기본 이터레이터가 복사 가능한 경우 복사 가능해야 합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP의 구현은 또한 동기 섹션에서 언급된 새로운 \u003ccode\u003eitertools.tee\u003c/code\u003e 함수의 최적화를 포함할 것입니다.\u003c/p\u003e\n\u003ch2\u003e이론적 근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e이터레이터의 (얕은) 복사에 대한 주요 사용 사례는 \u003ccode\u003eitertools.tee\u003c/code\u003e (2.4에 새로 추가됨) 함수와 동일합니다. 사용자 코드는 이터레이터를 직접 복사하려고 시도하지 않을 것입니다. 왜냐하면 복사 불가능한 경우를 별도로 처리해야 하기 때문입니다. \u003ccode\u003eitertools.tee\u003c/code\u003e를 호출하면 적절한 경우 내부적으로 복사를 수행하고, 복사 불가능한 이터레이터에 대해서는 암시적으로 최대한 효율적인 비복사 전략으로 대체됩니다. (때때로 사용자 코드는 다른 전략, 예를 들어 리스트를 만들거나 시퀀스를 디스크에 저장하는 것과 같은 방식으로 복사 불가능한 이터레이터를 처리하기 위해 더 직접적인 제어를 원할 수도 있습니다).\u003c/p\u003e\n\u003cp\u003e\"tee\"된 이터레이터는 \"참조 지점\" 역할을 하여 시퀀스 처리가 알려진 지점에서 계속되거나 재개될 수 있도록 하는 동시에, 다른 독립적인 이터레이터는 필요에 따라 시퀀스의 더 먼 부분을 \"탐색\"하기 위해 자유롭게 진행될 수 있습니다. 간단한 예: 숫자의 이터레이터 (양수라고 가정)를 받아서, 입력 이터레이터의 각 항목에 해당하는 총합의 분수 값을 반환하는 제너레이터 함수입니다. 호출자는 총합을 미리 알고 있다면 값으로 전달할 수 있습니다. 그렇지 않으면 이 제너레이터 함수를 호출하여 반환된 이터레이터는 먼저 총합을 계산합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef fractions(numbers, total=None):\n    if total is None:\n        numbers, aux = itertools.tee(numbers)\n        total = sum(aux)\n    total = float(total)\n    for item in numbers:\n        yield item / total\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003enumbers\u003c/code\u003e 이터레이터를 \"tee\"할 수 있는 기능은, \u003ccode\u003enumbers\u003c/code\u003e 이터레이터가 복사 가능한 경우, 필요한 경우 총합을 미리 계산하는 데 \u003ccode\u003eO(N)\u003c/code\u003e 보조 메모리를 반드시 요구하지 않으면서 이 제너레이터가 작동하도록 합니다.\u003c/p\u003e\n\u003cp\u003e\"이터레이터 북마킹\"의 또 다른 예로, 가끔 \"후위 연산자\" 역할을 하는 문자열이 포함된 숫자 스트림을 생각해 봅시다. 가장 흔한 연산자는 \u003ccode\u003e'+'\u003c/code\u003e이며, 이 경우 이전의 모든 숫자 (이전 연산자가 있었다면 그 이후, 아니면 처음부터)를 합산하여 결과를 yield 해야 합니다. 때때로 \u003ccode\u003e'*'\u003c/code\u003e를 발견할 수도 있는데, 이는 이전 숫자를 합산하는 대신 곱해야 한다는 점만 다릅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef filter_weird_stream(stream):\n    it = iter(stream)\n    while True:\n        it, bookmark = itertools.tee(it)\n        total = 0\n        for item in it:\n            if item == '+':\n                yield total\n                break\n            elif item == '*':\n                product = 1\n                for item in bookmark:\n                    if item == '*':\n                        yield product\n                        break\n                    else:\n                        product *= item\n                else: # bookmark loop did not break\n                    yield product # yield final product if no more '*'\n                break # break from outer loop after '*' is handled\n            else:\n                total += item\n        else: # it loop did not break\n            # Reached end of stream, yield final total if no operator\n            # This part needs careful handling based on exact requirements.\n            # For simplicity, let's assume stream always ends with an operator or is empty.\n            if total != 0: # If there were numbers before EOF and no operator\n                yield total\n            raise StopIteration\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 위의 \u003ccode\u003efilter_weird_stream\u003c/code\u003e 예제는 원본 PEP의 코드와 약간 다르게 해석될 수 있습니다. 특히 \u003ccode\u003eelse\u003c/code\u003e 블록의 처리는 상황에 따라 다르게 구현될 수 있습니다. PEP의 예제는 \u003ccode\u003e'*'\u003c/code\u003e 연산자 후 \u003ccode\u003eit\u003c/code\u003e가 소비되는 것을 보여주며, \u003ccode\u003ebookmark\u003c/code\u003e는 그 지점부터 다시 시작합니다. 원본 코드를 그대로 옮기기보다는 핵심 개념을 설명하는 데 집중했습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eitertools.tee\u003c/code\u003e의 유사한 사용 사례는 이터레이터로 표현된 명령 스트림에 대한 \"실행 취소\", 토큰 스트림 파싱에 대한 \"백트래킹\" 등과 같은 작업을 지원할 수 있습니다. (물론, 각 경우에 작업의 세부 사항에 따라 단일 이터레이터로 시퀀스를 진행하는 동안 시퀀스의 관련 부분을 리스트에 저장하는 것과 같은 더 간단한 가능성도 고려해야 합니다).\u003c/p\u003e\n\u003cp\u003e다음은 기본 이터레이터가 \u003ccode\u003e__copy__\u003c/code\u003e를 지원하는 경우 내장 \u003ccode\u003eenumerate\u003c/code\u003e가 \u003ccode\u003e__copy__\u003c/code\u003e를 지원하도록 확장될 수 있는 방법에 대한 순수 Python 예제입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass enumerate(object):\n    def __init__(self, it):\n        self.it = iter(it)\n        self.i = -1\n    def __iter__(self):\n        return self\n    def next(self):\n        self.i += 1\n        return self.i, self.it.next()\n    def __copy__(self):\n        result = self.__class__.__new__(self.__class__) # Use __new__ with class argument\n        result.it = self.it.__copy__()\n        result.i = self.i\n        return result\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e \u003ccode\u003e__new__\u003c/code\u003e 호출 방식은 Python 2.x와 3.x에서 약간 다를 수 있습니다. 위 코드는 Python 2.x 스타일을 따릅니다.\u003c/p\u003e\n\u003cp\u003e다음은 이터레이터의 \"우발적인 복사 가능성\"으로 인해 발생하는 \"취약성\"의 한 예입니다. 즉, \u003ccode\u003ecopy.copy\u003c/code\u003e가 성공하더라도 결과로 원본과 독립적으로 이터레이션할 수 있는 이터레이터를 받을 것이라고 기대해서는 안 됩니다. 다음은 간단한 중첩 리스트인 \"트리\"를 (선위 순서로) 이터레이션하는 이터레이터 클래스입니다. 리스트인 항목은 하위 트리로, 다른 항목은 리프로 처리됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass ListreeIter(object):\n    def __init__(self, tree):\n        self.tree = [tree]\n        self.indx = [-1]\n    def __iter__(self):\n        return self\n    def next(self):\n        if not self.indx:\n            raise StopIteration\n        self.indx[-1] += 1\n        try:\n            result = self.tree[-1][self.indx[-1]]\n        except IndexError:\n            self.tree.pop()\n            self.indx.pop()\n            return self.next()\n        if type(result) is not list:\n            return result\n        self.tree.append(result)\n        self.indx.append(-1)\n        return self.next()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 코드는 의도한 대로 작동하지 않습니다. \u003ccode\u003ecopy.copy\u003c/code\u003e가 수행하는 우발적인 복사가 \"인덱스\" 리스트인 변경 가능한 속성 \u003ccode\u003eit.indx\u003c/code\u003e를 복제하는 대신 공유하기 때문에, \u003ccode\u003ecop\u003c/code\u003e 이터레이터는 원본 \u003ccode\u003eit\u003c/code\u003e 이터레이터가 진행됨에 따라 단계별로 소모되고 고갈됩니다. 따라서 이 이터레이터의 \"클라이언트 코드\"는 시퀀스의 일부를 이터레이터를 \u003ccode\u003ecopy.copy\u003c/code\u003e하여 두 번 이터레이션하려고 시도하지만, 이는 올바르지 않습니다.\u003c/p\u003e\n\u003cp\u003e올바른 해결책 중 하나는 \u003ccode\u003eitertools.tee\u003c/code\u003e를 사용하는 것입니다. 즉, 첫 번째 \u003ccode\u003efor\u003c/code\u003e 루프를 다음과 같이 변경합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor i in it:\n    print i,\n    if i == 6:\n        it, cop = itertools.tee(it)\n        break\nfor i in it:\n    print i,\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(이 루프를 두 부분으로 나누어야 합니다. 그렇지 않으면 \u003ccode\u003etee()\u003c/code\u003e 호출 후 더 이상 사용해서는 안 되는 \u003ccode\u003eit\u003c/code\u003e의 원래 값에서 계속 루프를 돌게 됩니다!) 또는 리스트를 만듭니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor i in it:\n    print i,\n    if i == 6:\n        cop = lit = list(it)\n        break\nfor i in lit:\n    print i,\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(다시, \u003ccode\u003elist(it)\u003c/code\u003e 호출에 의해 이터레이터 \u003ccode\u003eit\u003c/code\u003e가 소진되므로 루프를 두 부분으로 나누어야 합니다).\u003c/p\u003e\n\u003cp\u003e마지막으로, 이 PEP가 권장하는 대로 \u003ccode\u003eListreeIter\u003c/code\u003e가 적절한 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 제공한다면 이 모든 해결책이 작동할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e    def __copy__(self):\n        result = self.__class__.__new__(self.__class__) # Use __new__ with class argument\n        result.tree = copy.copy(self.tree)\n        result.indx = copy.copy(self.indx)\n        return result\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e복사본을 \"더 깊이\" 만들 필요는 없지만, 두 개의 변경 가능한 \"인덱스 상태\" 속성은 \"적절한\" (독립적으로 이터레이션 가능한) 이터레이터 복사본을 얻기 위해 실제로 복사되어야 합니다.\u003c/p\u003e\n\u003cp\u003e권장되는 해결책은 \u003ccode\u003eListreeIter\u003c/code\u003e 클래스가 이 \u003ccode\u003e__copy__\u003c/code\u003e 메서드를 제공하고 클라이언트 코드가 \u003ccode\u003eitertools.tee\u003c/code\u003e를 사용하는 것입니다 (위에서 보여준 두 부분으로 나뉜 루프와 함께). 이렇게 하면 클라이언트 코드가 사용할 수 있는 다양한 이터레이터 유형에 대해 최대한 관용적이며, 동시에 이 특정 이터레이터 유형의 \"tee\"ing에 대해 좋은 성능을 달성할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e참조 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003epython-dev 토론 시작 게시물: \u003ca href=\"https://mail.python.org/pipermail/python-dev/2003-October/038969.html\"\u003ehttps://mail.python.org/pipermail/python-dev/2003-October/038969.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e표준 라이브러리의 \u003ccode\u003ecopy\u003c/code\u003e 모듈 온라인 문서: \u003ca href=\"https://docs.python.org/release/2.6/library/copy.html\"\u003ehttps://docs.python.org/release/2.6/library/copy.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 공개 도메인에 배치되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Deferred] PEP 323 - Copyable Iterators\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 18:31:01+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"page__taxonomy mb-4\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"카테고리\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":\"Python\"}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":\"PEP\"}]]]}],[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]]}]]}]}]}]\nb:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\""])</script><script>self.__next_f.push([1,"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"21\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>