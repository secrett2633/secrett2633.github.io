<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js"/><script src="/secrett2633.github.io/_next/static/chunks/fd9d1056-62aaf4b921c84028.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/23-ca4408d024135d8d.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/main-app-fa660020ba1e0b6e.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/231-c4b666723e6aae68.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/layout-8808afda01b7a1b7.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="next-size-adjust"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/secrett2633.github.io/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_9012cf layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/secrett2633.github.io">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 302 - New Import Hooks</h1><div class="page__meta"><time dateTime="2025-09-26 18:08:12+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0302/">PEP 302 - New Import Hooks</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 19-Dec-2002</p>
</blockquote>
<h1>PEP 302 – 새로운 임포트 훅 (New Import Hooks)</h1>
<ul>
<li><strong>작성자</strong>: Just van Rossum, Paul Moore</li>
<li><strong>상태</strong>: Final (최종)</li>
<li><strong>유형</strong>: Standards Track (표준 트랙)</li>
<li><strong>작성일</strong>: 2002년 12월 19일</li>
<li><strong>Python 버전</strong>: 2.3</li>
</ul>
<p><strong>경고</strong>: 임포트에 대한 언어 참조 및 <code>importlib</code> 문서가 현재 이 PEP를 대체합니다. 이 문서는 더 이상 업데이트되지 않으며 역사적 목적으로만 제공됩니다.</p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 Python 임포트 메커니즘을 더 잘 사용자 정의할 수 있는 새로운 임포트 훅 세트를 추가할 것을 제안합니다. 기존의 <code>__import__</code> 훅과 달리, 새로운 방식의 훅은 기존 스키마에 주입(inject)될 수 있어 모듈이 발견되고 로드되는 방식에 대해 더 세밀한 제어가 가능합니다.</p>
<h2>동기 (Motivation)</h2>
<p>현재 임포트 메커니즘을 사용자 정의하는 유일한 방법은 내장 함수인 <code>__import__</code>를 오버라이드(override)하는 것입니다. 하지만 <code>__import__</code>를 오버라이드하는 것은 다음과 같은 여러 가지 문제를 가지고 있습니다.</p>
<ul>
<li><code>__import__</code>를 대체하는 코드는 전체 임포트 메커니즘을 완전히 재구현하거나, 사용자 정의 코드 전후에 원래 <code>__import__</code>를 호출해야 합니다. 이는 매우 복잡한 의미와 책임을 가집니다.</li>
<li><code>__import__</code>는 <code>sys.modules</code>에 이미 있는 모듈에 대해서도 호출되는데, 이는 모니터링 도구를 작성하는 경우가 아니라면 거의 원하지 않는 동작입니다.</li>
<li>C 언어에서 임포트 메커니즘을 확장해야 할 경우, 현재는 Python의 <code>import.c</code>를 직접 수정하거나 <code>import.c</code>의 많은 부분을 처음부터 재구현하는 것 외에는 불가능합니다.</li>
</ul>
<p>과거에는 <code>__import__</code> 훅을 기반으로 임포트 메커니즘을 확장하는 다양한 Python 도구들이 있었습니다 (<code>ihooks.py</code>, <code>imputil.py</code>, <code>iu.py</code> 등). 하지만 이러한 도구들은 Python으로 작성되었기 때문에 부트스트랩(bootstrapping) 문제 등 유용성에 한계가 있었습니다. 예를 들어, 전체 표준 라이브러리를 임포트 훅에서 로드하려면 훅 자체가 C로 작성되어야 했습니다.</p>
<h2>사용 사례 (Use cases)</h2>
<p>이 섹션에서는 임포트 훅에 의존하는 몇 가지 기존 애플리케이션을 나열합니다. 당시 더 유연한 임포트 훅이 있었다면 절약할 수 있었을 많은 중복 작업이 수행되었습니다. 이 PEP는 미래의 유사한 프로젝트들을 훨씬 더 쉽게 만들 것입니다.</p>
<p>임포트 메커니즘의 확장은 모듈이 비표준적인 방식으로 저장되어 있을 때 필요합니다. 예를 들어, 다음과 같은 경우입니다.</p>
<ul>
<li>아카이브(archive) 안에 함께 묶인 모듈들</li>
<li><code>.pyc</code> 형식 파일에 저장되지 않은 바이트코드(byte code)</li>
<li>네트워크를 통해 데이터베이스에서 로드되는 모듈</li>
</ul>
<p>이 PEP에 대한 작업은 부분적으로 Zip 아카이브에서 임포트하는 기능을 Python에 내장 기능으로 추가하는 PEP 273의 구현에 의해 촉발되었습니다. PEP 273 구현은 <code>import.c</code>에 많은 코드를 추가해야 했는데, 이는 기존 <code>import.c</code>의 한계 때문이었습니다.</p>
<p>최종 사용자를 위한 애플리케이션 패키징(packaging)은 임포트 훅의 전형적인 사용 사례입니다. 많은 소스 파일이나 <code>.pyc</code> 파일을 배포하는 것이 항상 적절하지 않으므로 (별도의 Python 설치는 말할 것도 없고), 필요한 모든 모듈을 단일 파일로 묶으려는 요구가 자주 있었습니다. 이러한 요구로 인해 <code>Freeze</code>, <code>Squeeze</code>, <code>Installer</code>, <code>py2exe</code>, <code>BuildApplication</code>과 같은 여러 솔루션이 구현되었습니다. 이 PEP에서 제안하는 훅은 <code>import.c</code>에 하드코딩된 훅을 제거하고, <code>__import__</code> 기반 도구들이 <code>import.c</code> 에뮬레이션(emulation) 코드를 대부분 없앨 수 있도록 할 것입니다.</p>
<h2>근거 (Rationale)</h2>
<p>내장 Zip 임포트를 구현하기 위한 대안적인 아이디어를 실험하던 중, <code>import.c</code>에 비교적 적은 변경만으로도 이것이 가능하다는 것이 발견되었습니다. 이로 인해 Zip 관련 특정 기능을 새로운 소스 파일로 분리하는 동시에, 일반적인 새로운 임포트 훅 스키마(현재 이 PEP에서 설명하는 방식)를 만들 수 있게 되었습니다.</p>
<p>초기 디자인에서는 <code>sys.path</code>에 문자열이 아닌 객체를 허용했습니다. 이러한 객체는 임포트를 처리하는 데 필요한 메서드를 가질 수 있었습니다. 하지만 이 방식은 두 가지 단점이 있었습니다.</p>
<ol>
<li><code>sys.path</code>의 모든 항목이 문자열이라고 가정하는 코드를 깨뜨립니다.</li>
<li><code>PYTHONPATH</code> 환경 변수와 호환되지 않습니다.</li>
</ol>
<p>이후 Jython에서 아이디어를 얻어 <code>sys.path</code>에 문자열 서브클래스를 허용하는 타협안이 제시되었으나, "보기 흉한 해킹"으로 인식되었습니다.</p>
<p>결과적으로, 각 <code>sys.path</code> 항목을 처리할 수 있는지 <code>sys.path_hooks</code>의 후보 목록을 순회하며 묻는 방식(McMillan의 <code>iu.py</code>에서 대부분 복사)이 채택되었습니다. 이 후보 목록은 <code>sys</code> 모듈의 새로운 객체인 <code>sys.path_hooks</code>입니다.</p>
<p>각 새로운 임포트 시 <code>sys.path_hooks</code>를 순회하는 것은 비용이 많이 들 수 있으므로, 그 결과는 <code>sys.path_importer_cache</code>라는 또 다른 <code>sys</code> 모듈의 새로운 객체에 캐시됩니다. 이것은 <code>sys.path</code> 항목을 임포터(importer) 객체에 매핑합니다.</p>
<p><code>import.c</code>에 미치는 영향을 최소화하고 추가 오버헤드를 피하기 위해, 기존 파일 시스템 임포트 로직에 대한 명시적인 훅이나 임포터 객체를 추가하지 않고, <code>sys.path_hooks</code>의 어떤 훅도 경로 항목을 처리할 수 없을 경우 단순히 내장 로직으로 폴백(fall back)하도록 선택되었습니다. 이 경우 <code>None</code> 값이 <code>sys.path_importer_cache</code>에 저장되어 반복적인 조회를 피합니다.</p>
<p><code>sys.path</code> 항목이 필요 없는 임포터(예: 내장 및 프로즌 모듈)에 대한 질문이 제기되었고, Gordon McMillan의 <code>iu.py</code>에 있는 "메타패스(metapath)" 개념이 도입되었습니다. 이 PEP의 구현에서는 <code>sys.path</code>가 순회되기 전에 순회되는 임포터 객체 목록이며, <code>sys.meta_path</code>라는 새로운 <code>sys</code> 모듈 객체입니다.</p>
<h2>사양 1부: 임포터 프로토콜 (Specification part 1: The Importer Protocol)</h2>
<p>이 PEP는 "임포터 프로토콜"이라는 새로운 프로토콜을 소개합니다. 프로토콜이 작동하는 컨텍스트를 이해하는 것이 중요하므로, 임포트 메커니즘의 외부 흐름을 간략하게 설명합니다.</p>
<p><code>import</code> 문이 나타나면 인터프리터는 내장 이름 공간에서 <code>__import__</code> 함수를 찾습니다. <code>__import__</code>는 모듈 이름과 현재 전역 이름 공간에 대한 참조를 포함한 네 가지 인수로 호출됩니다. 내장 <code>__import__</code> 함수는 모듈이 패키지 또는 패키지의 서브모듈인지 확인하고, 해당될 경우 패키지에 상대적으로 임포트를 시도합니다. 실패하면 절대 임포트(absolute import)로 진행됩니다.</p>
<p>임포터 프로토콜은 개별 임포트 수준에서 작동합니다. <code>spam.ham</code> 임포트 요청이 임포터에게 전달될 때, <code>spam</code> 모듈은 이미 임포트되어 있습니다.</p>
<p>프로토콜은 <code>finder</code>와 <code>loader</code>, 두 가지 객체를 포함합니다.</p>
<h3>Finder (파인더)</h3>
<p><code>finder</code> 객체는 단일 메서드를 가집니다.</p>
<ul>
<li><code>finder.find_module(fullname, path=None)</code>
<ul>
<li>이 메서드는 모듈의 완전한 이름(fully qualified name)으로 호출됩니다.</li>
<li><code>finder</code>가 <code>sys.meta_path</code>에 설치된 경우, 두 번째 인수로 최상위 모듈에 대해서는 <code>None</code>을, 서브모듈 또는 서브패키지에 대해서는 <code>package.__path__</code>를 받습니다.</li>
<li>모듈을 찾으면 <code>loader</code> 객체를 반환하고, 찾지 못하면 <code>None</code>을 반환해야 합니다.</li>
<li><code>find_module()</code>이 예외를 발생시키면 호출자에게 전파되어 임포트가 중단됩니다.</li>
</ul>
</li>
</ul>
<h3>Loader (로더)</h3>
<p><code>loader</code> 객체도 하나의 메서드를 가집니다.</p>
<ul>
<li><code>loader.load_module(fullname)</code>
<ul>
<li>이 메서드는 로드된 모듈을 반환하거나 예외를 발생시킵니다 (기존 예외가 전파되지 않는 경우 <code>ImportError</code>가 바람직합니다).</li>
<li>로드할 수 없는 모듈을 로드하도록 요청받으면 <code>ImportError</code>를 발생시켜야 합니다.</li>
</ul>
</li>
</ul>
<p>많은 경우 <code>finder</code>와 <code>loader</code>는 동일한 객체일 수 있습니다. <code>finder.find_module()</code>은 단순히 <code>self</code>를 반환할 수 있습니다.</p>
<p>두 메서드의 <code>fullname</code> 인수는 "spam.eggs.ham"과 같은 완전한 모듈 이름입니다. <code>find_module()</code> 메서드는 실제 임포트 중에 항상 호출되는 것은 아니므로, <code>finder</code>는 <code>sys.modules</code>에 부모 패키지가 존재한다고 의존해서는 안 됩니다.</p>
<p><code>load_module()</code> 메서드는 코드를 실행하기 전에 몇 가지 책임을 이행해야 합니다.</p>
<ul>
<li><code>sys.modules</code>에 <code>fullname</code>이라는 이름의 기존 모듈 객체가 있으면 로더는 해당 객체를 사용해야 합니다.</li>
<li><code>sys.modules</code>에 <code>fullname</code>이라는 이름의 모듈이 없으면 로더는 새 모듈 객체를 생성하고 <code>sys.modules</code>에 추가해야 합니다. 이 작업은 로더가 모듈 코드를 실행하기 전에 이루어져야 합니다.</li>
<li>로드에 실패하면 로더는 <code>sys.modules</code>에 삽입했을 수 있는 모듈을 제거해야 합니다.</li>
<li><code>__file__</code> 속성이 설정되어야 합니다. 이는 문자열이어야 하며, " <code>&#x3C;frozen></code> "과 같은 더미 값일 수 있습니다. <code>__file__</code> 속성이 전혀 없는 특권은 내장 모듈에만 주어집니다.</li>
<li><code>__name__</code> 속성이 설정되어야 합니다. <code>imp.new_module()</code>을 사용하면 자동으로 설정됩니다.</li>
<li>패키지인 경우 <code>__path__</code> 변수가 설정되어야 합니다. 이는 리스트여야 하며, 임포터에게 <code>__path__</code>가 더 이상 의미가 없다면 비어있을 수 있습니다.</li>
<li><code>__loader__</code> 속성은 로더 객체로 설정되어야 합니다. 이는 주로 인트로스펙션(introspection) 및 재로드(reloading)를 위한 것입니다.</li>
<li><code>__package__</code> 속성이 설정되어야 합니다 (PEP 366).</li>
<li>모듈이 Python 모듈인 경우 (내장 모듈이나 동적으로 로드된 확장 모듈과 반대), 모듈의 전역 이름 공간( <code>module.__dict__</code> )에서 모듈 코드를 실행해야 합니다.</li>
</ul>
<p><code>load_module()</code> 메서드를 위한 최소한의 패턴은 다음과 같습니다.</p>
<pre><code class="language-python"># 대부분의 세부 사항을 처리하기 위해 importlib.util.module_for_loader()를 사용하는 것을 고려하세요.
def load_module(self, fullname):
    code = self.get_code(fullname)
    ispkg = self.is_package(fullname)
    mod = sys.modules.setdefault(fullname, imp.new_module(fullname))
    mod.__file__ = "&#x3C;%s>" % self.__class__.__name__
    mod.__loader__ = self
    if ispkg:
        mod.__path__ = []
        mod.__package__ = fullname
    else:
        mod.__package__ = fullname.rpartition('.')[0]
    exec(code, mod.__dict__)
    return mod
</code></pre>
<h2>사양 2부: 훅 등록 (Specification part 2: Registering Hooks)</h2>
<p>두 가지 유형의 임포트 훅이 있습니다: **메타 훅(Meta hooks)**과 <strong>경로 훅(Path hooks)</strong>.</p>
<h3>메타 훅 (Meta hooks)</h3>
<ul>
<li>임포트 처리 시작 시, 다른 임포트 처리보다 먼저 호출됩니다 (따라서 메타 훅은 <code>sys.path</code> 처리, 프로즌 모듈, 심지어 내장 모듈까지 재정의할 수 있습니다).</li>
<li>메타 훅을 등록하려면 <code>finder</code> 객체를 <code>sys.meta_path</code> (등록된 메타 훅 목록)에 추가하기만 하면 됩니다.</li>
<li>현재 기본적으로 비어 있습니다.</li>
</ul>
<h3>경로 훅 (Path hooks)</h3>
<ul>
<li><code>sys.path</code> (또는 <code>package.__path__</code>) 처리의 일부로, 관련 경로 항목이 발견되는 시점에 호출됩니다.</li>
<li>경로 훅은 <code>sys.path_hooks</code>에 임포터 팩토리(importer factory)를 추가하여 등록됩니다.</li>
<li><code>sys.path_hooks</code>는 콜러블(callable) 목록이며, 주어진 경로 항목을 처리할 수 있는지 순서대로 확인됩니다.</li>
<li>콜러블은 경로 항목을 처리할 수 없으면 <code>ImportError</code>를 발생시키고, 처리할 수 있으면 임포터 객체를 반환해야 합니다.</li>
<li>경로 훅 검사 결과는 <code>sys.path_importer_cache</code>에 캐시됩니다. 이 캐시는 <code>sys.path_hooks</code>를 스캔하기 전에 확인됩니다.</li>
</ul>
<p>새로운 <code>sys</code> 변수들은 <code>sys.path</code>와 마찬가지로 특정 유형을 가져야 합니다.</p>
<ul>
<li><code>sys.meta_path</code>와 <code>sys.path_hooks</code>는 Python 리스트여야 합니다.</li>
<li><code>sys.path_importer_cache</code>는 Python 딕셔너리여야 합니다.</li>
</ul>
<p>이러한 변수를 인플레이스(in-place)로 수정하거나 새 객체로 교체하는 것은 허용됩니다.</p>
<h2>패키지와 <code>__path__</code>의 역할 (Packages and the role of <strong>path</strong>)</h2>
<p>모듈이 <code>__path__</code> 속성을 가지고 있으면 임포트 메커니즘은 이를 패키지로 취급합니다. 패키지의 서브모듈을 임포트할 때 <code>sys.path</code> 대신 <code>__path__</code> 변수가 사용됩니다. 따라서 <code>sys.path</code>에 대한 규칙은 <code>pkg.__path__</code>에도 적용됩니다. 즉, <code>pkg.__path__</code>가 순회될 때 <code>sys.path_hooks</code>도 참조됩니다.</p>
<p>메타 임포터는 작업을 수행하기 위해 <code>sys.path</code>를 전혀 사용하지 않을 수 있으므로 <code>pkg.__path__</code> 값을 무시할 수 있습니다. 이 경우에도 비어 있을 수 있는 리스트로 설정하는 것이 좋습니다.</p>
<h2>임포터 프로토콜의 선택적 확장 (Optional Extensions to the Importer Protocol)</h2>
<p>임포터 프로토콜은 세 가지 선택적 확장을 정의합니다.</p>
<ol>
<li>데이터 파일 검색</li>
<li>모듈 패키징 도구 및/또는 모듈 의존성 분석 도구(예: Freeze) 지원</li>
<li>모듈을 스크립트로 실행하는 지원</li>
</ol>
<p>이 세 가지 확장 모두 일반적인 임포터에 강력히 권장되지만, 해당 기능이 필요하지 않으면 안전하게 생략할 수 있습니다.</p>
<h3>데이터 파일 검색 (<code>get_data</code>)</h3>
<p>기저 저장소 백엔드에서 임의의 "파일"에 대한 데이터를 검색하기 위해 로더 객체는 <code>get_data()</code>라는 메서드를 제공할 수 있습니다.</p>
<ul>
<li><code>loader.get_data(path)</code>: 이 메서드는 데이터를 문자열로 반환하거나 "파일"을 찾지 못하면 <code>IOError</code>를 발생시킵니다. 데이터는 항상 "이진(binary)" 모드가 사용된 것처럼 반환됩니다. 이는 파일 시스템과 유사한 속성을 가진 임포터를 위한 것입니다.</li>
</ul>
<p>예시:</p>
<pre><code class="language-python">d = os.path.dirname(__file__)
data = __loader__.get_data(os.path.join(d, "logo.gif"))
</code></pre>
<h3>패키징/분석 도구 지원 (<code>is_package</code>, <code>get_code</code>, <code>get_source</code>)</h3>
<p>Freeze와 같은 도구에 대한 지원이 필요한 경우 다음 메서드 세트를 구현할 수 있습니다. 호출자가 쉽게 사용할 수 있도록 세 가지 메서드 모두 구현하거나, 아예 구현하지 않아야 합니다.</p>
<ul>
<li><code>loader.is_package(fullname)</code>: <code>fullname</code>으로 지정된 모듈이 패키지이면 <code>True</code>, 아니면 <code>False</code>를 반환해야 합니다.</li>
<li><code>loader.get_code(fullname)</code>: 모듈과 관련된 코드 객체를 반환하거나, 내장 또는 확장 모듈인 경우 <code>None</code>을 반환해야 합니다. 소스 코드는 있지만 코드 객체가 없으면 컴파일된 소스 코드를 반환해야 합니다.</li>
<li><code>loader.get_source(fullname)</code>: 모듈의 소스 코드를 문자열로 반환하거나, 소스를 사용할 수 없으면 <code>None</code>을 반환해야 합니다.</li>
</ul>
<p>이 세 메서드 모두 모듈을 찾을 수 없으면 <code>ImportError</code>를 발생시켜야 합니다.</p>
<h3>스크립트 실행 지원 (<code>get_filename</code>)</h3>
<p>모듈을 스크립트로 실행하는 것(PEP 338)을 지원하려면 위 세 가지 메서드가 구현되어야 합니다. 또한, <code>runpy</code> 모듈이 <code>__file__</code> 속성을 올바르게 설정할 수 있도록 다음 메서드를 제공할 수 있습니다.</p>
<ul>
<li><code>loader.get_filename(fullname)</code>: 이 메서드는 명명된 모듈이 로드될 경우 <code>__file__</code>이 설정될 값을 반환해야 합니다. 모듈을 찾을 수 없으면 <code>ImportError</code>를 발생시켜야 합니다.</li>
</ul>
<h2><code>imp</code> 모듈과의 통합 (Integration with the 'imp' module)</h2>
<p>새로운 임포트 훅은 기존 <code>imp.find_module()</code> 및 <code>imp.load_module()</code> 호출에 쉽게 통합되지 않습니다. 기존 코드에 영향을 주지 않고 통합하는 것은 의문이며, <code>imp</code> 모듈에 새 함수를 추가하는 것이 더 좋습니다.</p>
<p>기존 <code>imp.find_module()</code> 및 <code>imp.load_module()</code> 호출의 의미는 "내장 임포트 메커니즘을 노출"에서 "기본적으로 훅이 없는 내장 임포트 메커니즘을 노출"로 변경됩니다. 이들은 어떤 임포트 훅도 호출하지 않습니다.</p>
<p>새로운 <code>imp</code> 모듈 함수(<code>get_loader()</code>)가 제안되었으며, 다음과 같은 패턴으로 사용됩니다.</p>
<pre><code class="language-python">loader = imp.get_loader(fullname, path)
if loader is not None:
    loader.load_module(fullname)
</code></pre>
<p>"기본" 임포트의 경우, <code>loader</code> 객체는 <code>imp.find_module()</code>의 현재 출력에 대한 래퍼(wrapper)이며, <code>loader.load_module()</code>은 해당 출력을 사용하여 <code>imp.load_module()</code>을 호출합니다.</p>
<h2>향후 호환성 (Forward Compatibility)</h2>
<p>기존 <code>__import__</code> 훅은 폴백(fallback)으로 원래 <code>__import__</code> 함수를 호출하지 않는 한, 새로운 방식의 훅을 자동으로 호출하지 않습니다. 예를 들어, <code>ihooks.py</code>, <code>iu.py</code>, <code>imputil.py</code>는 이 PEP와 호환되지 않습니다.</p>
<h2>미해결 문제 (Open Issues)</h2>
<ul>
<li><strong>데이터 파일 위치</strong>: 모듈, 특히 복잡한 패키지나 전체 애플리케이션의 경우 지원 데이터 파일이 필요합니다. 현재는 일반적으로 <code>sys.path</code> (또는 <code>package.__path__</code> 속성)를 통해 이러한 파일을 찾습니다. 이 접근 방식은 임포트 훅을 통해 로드되는 모듈에는 일반적으로 작동하지 않습니다.
<ul>
<li>해결책으로 "그렇게 하지 마세요", <code>sys.prefix</code> 기반의 표준 위치에서 찾기, 임포트 훅이 모듈 파일에 상대적인 데이터 파일에 접근하는 표준적인 방법을 제공하는 것 등이 논의되었습니다. <code>zipimport</code> 객체는 <code>__loader__</code> 속성과 <code>get_data(name)</code> 메서드를 제공하여 이러한 문제를 해결합니다.</li>
</ul>
</li>
<li><strong>사용 가능한 모듈 및 데이터 파일 목록</strong>: 임포터로부터 사용 가능한 모듈 목록이나 <code>get_data()</code> 메서드와 함께 사용할 데이터 파일 목록을 받는 것이 유용할 수 있다는 제안이 있었습니다. <code>list_modules()</code> 및 <code>list_files()</code>와 같은 확장이 고려될 수 있습니다.</li>
<li><strong>대안적인 파일 형식 또는 컴파일러</strong>: 이 PEP는 대안적인 위치에서 모듈을 로드하는 데 중점을 둡니다. 대안적인 파일 형식이나 컴파일러로 모듈을 로드하기 위한 전용 솔루션을 제공하지 않습니다.</li>
<li><strong>훅 스태킹(Stacking) 지원 부족</strong>: 이 PEP 내에서는 훅 스태킹에 대한 특별한 지원이 없습니다. 예를 들어, <code>.tar</code> 및 <code>.gz</code> 파일에서 모듈을 로드하는 별도의 훅을 결합하여 <code>tar.gz</code> 파일에서 모듈을 로드하는 훅을 작성하는 방법은 명확하지 않습니다.</li>
<li><strong><code>sys.path</code> 처리 후 훅 추가</strong>: <code>sys.meta_path</code>를 통해 <code>sys.path</code>가 처리되기 전에 실행되는 훅을 추가할 수 있지만, <code>sys.path</code>가 처리된 후에 실행되는 훅을 추가하는 동등한 방법은 없습니다.</li>
</ul>
<h2>구현 (Implementation)</h2>
<p>PEP 302 구현은 Python 2.3a1부터 Python에 통합되었습니다.
PEP 273은 PEP 302의 임포트 훅을 사용하여 구현되었습니다.</p>
<h2>참고 및 각주 (References and Footnotes)</h2>
<ul>
<li>imputil module: <code>http://docs.python.org/library/imputil.html</code></li>
<li>The Freeze tool. See also the <code>Tools/freeze/</code> directory in a Python source distribution</li>
<li>py2exe by Thomas Heller: <code>http://www.py2exe.org/</code></li>
<li><code>imp.set_frozenmodules()</code> patch: <code>http://bugs.python.org/issue642578</code></li>
<li>The path argument to <code>finder.find_module()</code> is there because the <code>pkg.__path__</code> variable may be needed at this point. It may either come from the actual parent module or be supplied by <code>imp.find_module()</code> or the proposed <code>imp.get_loader()</code> function.</li>
<li>Quixote, a framework for developing Web applications: <code>http://www.mems-exchange.org/software/quixote/</code></li>
<li>New import hooks + Import from Zip files: <code>http://bugs.python.org/issue652586</code></li>
<li>Language reference for imports: <code>http://docs.python.org/3/reference/import.html</code></li>
<li>importlib documentation: <code>http://docs.python.org/3/library/importlib.html#module-importlib</code></li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)에 배포되었습니다.</p>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy mb-4"><h4 class="text-sm font-medium text-gray-900 mb-2">카테고리</h4><span class="page__taxonomy-item">Python</span><span class="page__taxonomy-item">PEP</span></div><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[4281,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"185\",\"static/chunks/app/layout-8808afda01b7a1b7.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/302\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"iV6XySbMHIJ3imQdvgy3I\",\"assetPrefix\":\"/secrett2633.github.io\",\"initialCanonicalUrl\":\"/python/pep/302/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/302\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"302\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/302\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"32x32\",\"href\":\"/favicon-32x32.png\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"16x16\",\"href\":\"/favicon-16x16.png\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_9012cf layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T6045,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0302/\"\u003ePEP 302 - New Import Hooks\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 19-Dec-2002\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 302 – 새로운 임포트 훅 (New Import Hooks)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자\u003c/strong\u003e: Just van Rossum, Paul Moore\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태\u003c/strong\u003e: Final (최종)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형\u003c/strong\u003e: Standards Track (표준 트랙)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e작성일\u003c/strong\u003e: 2002년 12월 19일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전\u003c/strong\u003e: 2.3\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e경고\u003c/strong\u003e: 임포트에 대한 언어 참조 및 \u003ccode\u003eimportlib\u003c/code\u003e 문서가 현재 이 PEP를 대체합니다. 이 문서는 더 이상 업데이트되지 않으며 역사적 목적으로만 제공됩니다.\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 Python 임포트 메커니즘을 더 잘 사용자 정의할 수 있는 새로운 임포트 훅 세트를 추가할 것을 제안합니다. 기존의 \u003ccode\u003e__import__\u003c/code\u003e 훅과 달리, 새로운 방식의 훅은 기존 스키마에 주입(inject)될 수 있어 모듈이 발견되고 로드되는 방식에 대해 더 세밀한 제어가 가능합니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e현재 임포트 메커니즘을 사용자 정의하는 유일한 방법은 내장 함수인 \u003ccode\u003e__import__\u003c/code\u003e를 오버라이드(override)하는 것입니다. 하지만 \u003ccode\u003e__import__\u003c/code\u003e를 오버라이드하는 것은 다음과 같은 여러 가지 문제를 가지고 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__import__\u003c/code\u003e를 대체하는 코드는 전체 임포트 메커니즘을 완전히 재구현하거나, 사용자 정의 코드 전후에 원래 \u003ccode\u003e__import__\u003c/code\u003e를 호출해야 합니다. 이는 매우 복잡한 의미와 책임을 가집니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__import__\u003c/code\u003e는 \u003ccode\u003esys.modules\u003c/code\u003e에 이미 있는 모듈에 대해서도 호출되는데, 이는 모니터링 도구를 작성하는 경우가 아니라면 거의 원하지 않는 동작입니다.\u003c/li\u003e\n\u003cli\u003eC 언어에서 임포트 메커니즘을 확장해야 할 경우, 현재는 Python의 \u003ccode\u003eimport.c\u003c/code\u003e를 직접 수정하거나 \u003ccode\u003eimport.c\u003c/code\u003e의 많은 부분을 처음부터 재구현하는 것 외에는 불가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e과거에는 \u003ccode\u003e__import__\u003c/code\u003e 훅을 기반으로 임포트 메커니즘을 확장하는 다양한 Python 도구들이 있었습니다 (\u003ccode\u003eihooks.py\u003c/code\u003e, \u003ccode\u003eimputil.py\u003c/code\u003e, \u003ccode\u003eiu.py\u003c/code\u003e 등). 하지만 이러한 도구들은 Python으로 작성되었기 때문에 부트스트랩(bootstrapping) 문제 등 유용성에 한계가 있었습니다. 예를 들어, 전체 표준 라이브러리를 임포트 훅에서 로드하려면 훅 자체가 C로 작성되어야 했습니다.\u003c/p\u003e\n\u003ch2\u003e사용 사례 (Use cases)\u003c/h2\u003e\n\u003cp\u003e이 섹션에서는 임포트 훅에 의존하는 몇 가지 기존 애플리케이션을 나열합니다. 당시 더 유연한 임포트 훅이 있었다면 절약할 수 있었을 많은 중복 작업이 수행되었습니다. 이 PEP는 미래의 유사한 프로젝트들을 훨씬 더 쉽게 만들 것입니다.\u003c/p\u003e\n\u003cp\u003e임포트 메커니즘의 확장은 모듈이 비표준적인 방식으로 저장되어 있을 때 필요합니다. 예를 들어, 다음과 같은 경우입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e아카이브(archive) 안에 함께 묶인 모듈들\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.pyc\u003c/code\u003e 형식 파일에 저장되지 않은 바이트코드(byte code)\u003c/li\u003e\n\u003cli\u003e네트워크를 통해 데이터베이스에서 로드되는 모듈\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 PEP에 대한 작업은 부분적으로 Zip 아카이브에서 임포트하는 기능을 Python에 내장 기능으로 추가하는 PEP 273의 구현에 의해 촉발되었습니다. PEP 273 구현은 \u003ccode\u003eimport.c\u003c/code\u003e에 많은 코드를 추가해야 했는데, 이는 기존 \u003ccode\u003eimport.c\u003c/code\u003e의 한계 때문이었습니다.\u003c/p\u003e\n\u003cp\u003e최종 사용자를 위한 애플리케이션 패키징(packaging)은 임포트 훅의 전형적인 사용 사례입니다. 많은 소스 파일이나 \u003ccode\u003e.pyc\u003c/code\u003e 파일을 배포하는 것이 항상 적절하지 않으므로 (별도의 Python 설치는 말할 것도 없고), 필요한 모든 모듈을 단일 파일로 묶으려는 요구가 자주 있었습니다. 이러한 요구로 인해 \u003ccode\u003eFreeze\u003c/code\u003e, \u003ccode\u003eSqueeze\u003c/code\u003e, \u003ccode\u003eInstaller\u003c/code\u003e, \u003ccode\u003epy2exe\u003c/code\u003e, \u003ccode\u003eBuildApplication\u003c/code\u003e과 같은 여러 솔루션이 구현되었습니다. 이 PEP에서 제안하는 훅은 \u003ccode\u003eimport.c\u003c/code\u003e에 하드코딩된 훅을 제거하고, \u003ccode\u003e__import__\u003c/code\u003e 기반 도구들이 \u003ccode\u003eimport.c\u003c/code\u003e 에뮬레이션(emulation) 코드를 대부분 없앨 수 있도록 할 것입니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e내장 Zip 임포트를 구현하기 위한 대안적인 아이디어를 실험하던 중, \u003ccode\u003eimport.c\u003c/code\u003e에 비교적 적은 변경만으로도 이것이 가능하다는 것이 발견되었습니다. 이로 인해 Zip 관련 특정 기능을 새로운 소스 파일로 분리하는 동시에, 일반적인 새로운 임포트 훅 스키마(현재 이 PEP에서 설명하는 방식)를 만들 수 있게 되었습니다.\u003c/p\u003e\n\u003cp\u003e초기 디자인에서는 \u003ccode\u003esys.path\u003c/code\u003e에 문자열이 아닌 객체를 허용했습니다. 이러한 객체는 임포트를 처리하는 데 필요한 메서드를 가질 수 있었습니다. 하지만 이 방식은 두 가지 단점이 있었습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003esys.path\u003c/code\u003e의 모든 항목이 문자열이라고 가정하는 코드를 깨뜨립니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePYTHONPATH\u003c/code\u003e 환경 변수와 호환되지 않습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이후 Jython에서 아이디어를 얻어 \u003ccode\u003esys.path\u003c/code\u003e에 문자열 서브클래스를 허용하는 타협안이 제시되었으나, \"보기 흉한 해킹\"으로 인식되었습니다.\u003c/p\u003e\n\u003cp\u003e결과적으로, 각 \u003ccode\u003esys.path\u003c/code\u003e 항목을 처리할 수 있는지 \u003ccode\u003esys.path_hooks\u003c/code\u003e의 후보 목록을 순회하며 묻는 방식(McMillan의 \u003ccode\u003eiu.py\u003c/code\u003e에서 대부분 복사)이 채택되었습니다. 이 후보 목록은 \u003ccode\u003esys\u003c/code\u003e 모듈의 새로운 객체인 \u003ccode\u003esys.path_hooks\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e각 새로운 임포트 시 \u003ccode\u003esys.path_hooks\u003c/code\u003e를 순회하는 것은 비용이 많이 들 수 있으므로, 그 결과는 \u003ccode\u003esys.path_importer_cache\u003c/code\u003e라는 또 다른 \u003ccode\u003esys\u003c/code\u003e 모듈의 새로운 객체에 캐시됩니다. 이것은 \u003ccode\u003esys.path\u003c/code\u003e 항목을 임포터(importer) 객체에 매핑합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimport.c\u003c/code\u003e에 미치는 영향을 최소화하고 추가 오버헤드를 피하기 위해, 기존 파일 시스템 임포트 로직에 대한 명시적인 훅이나 임포터 객체를 추가하지 않고, \u003ccode\u003esys.path_hooks\u003c/code\u003e의 어떤 훅도 경로 항목을 처리할 수 없을 경우 단순히 내장 로직으로 폴백(fall back)하도록 선택되었습니다. 이 경우 \u003ccode\u003eNone\u003c/code\u003e 값이 \u003ccode\u003esys.path_importer_cache\u003c/code\u003e에 저장되어 반복적인 조회를 피합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esys.path\u003c/code\u003e 항목이 필요 없는 임포터(예: 내장 및 프로즌 모듈)에 대한 질문이 제기되었고, Gordon McMillan의 \u003ccode\u003eiu.py\u003c/code\u003e에 있는 \"메타패스(metapath)\" 개념이 도입되었습니다. 이 PEP의 구현에서는 \u003ccode\u003esys.path\u003c/code\u003e가 순회되기 전에 순회되는 임포터 객체 목록이며, \u003ccode\u003esys.meta_path\u003c/code\u003e라는 새로운 \u003ccode\u003esys\u003c/code\u003e 모듈 객체입니다.\u003c/p\u003e\n\u003ch2\u003e사양 1부: 임포터 프로토콜 (Specification part 1: The Importer Protocol)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \"임포터 프로토콜\"이라는 새로운 프로토콜을 소개합니다. 프로토콜이 작동하는 컨텍스트를 이해하는 것이 중요하므로, 임포트 메커니즘의 외부 흐름을 간략하게 설명합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimport\u003c/code\u003e 문이 나타나면 인터프리터는 내장 이름 공간에서 \u003ccode\u003e__import__\u003c/code\u003e 함수를 찾습니다. \u003ccode\u003e__import__\u003c/code\u003e는 모듈 이름과 현재 전역 이름 공간에 대한 참조를 포함한 네 가지 인수로 호출됩니다. 내장 \u003ccode\u003e__import__\u003c/code\u003e 함수는 모듈이 패키지 또는 패키지의 서브모듈인지 확인하고, 해당될 경우 패키지에 상대적으로 임포트를 시도합니다. 실패하면 절대 임포트(absolute import)로 진행됩니다.\u003c/p\u003e\n\u003cp\u003e임포터 프로토콜은 개별 임포트 수준에서 작동합니다. \u003ccode\u003espam.ham\u003c/code\u003e 임포트 요청이 임포터에게 전달될 때, \u003ccode\u003espam\u003c/code\u003e 모듈은 이미 임포트되어 있습니다.\u003c/p\u003e\n\u003cp\u003e프로토콜은 \u003ccode\u003efinder\u003c/code\u003e와 \u003ccode\u003eloader\u003c/code\u003e, 두 가지 객체를 포함합니다.\u003c/p\u003e\n\u003ch3\u003eFinder (파인더)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003efinder\u003c/code\u003e 객체는 단일 메서드를 가집니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efinder.find_module(fullname, path=None)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e이 메서드는 모듈의 완전한 이름(fully qualified name)으로 호출됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efinder\u003c/code\u003e가 \u003ccode\u003esys.meta_path\u003c/code\u003e에 설치된 경우, 두 번째 인수로 최상위 모듈에 대해서는 \u003ccode\u003eNone\u003c/code\u003e을, 서브모듈 또는 서브패키지에 대해서는 \u003ccode\u003epackage.__path__\u003c/code\u003e를 받습니다.\u003c/li\u003e\n\u003cli\u003e모듈을 찾으면 \u003ccode\u003eloader\u003c/code\u003e 객체를 반환하고, 찾지 못하면 \u003ccode\u003eNone\u003c/code\u003e을 반환해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efind_module()\u003c/code\u003e이 예외를 발생시키면 호출자에게 전파되어 임포트가 중단됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eLoader (로더)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eloader\u003c/code\u003e 객체도 하나의 메서드를 가집니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eloader.load_module(fullname)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e이 메서드는 로드된 모듈을 반환하거나 예외를 발생시킵니다 (기존 예외가 전파되지 않는 경우 \u003ccode\u003eImportError\u003c/code\u003e가 바람직합니다).\u003c/li\u003e\n\u003cli\u003e로드할 수 없는 모듈을 로드하도록 요청받으면 \u003ccode\u003eImportError\u003c/code\u003e를 발생시켜야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e많은 경우 \u003ccode\u003efinder\u003c/code\u003e와 \u003ccode\u003eloader\u003c/code\u003e는 동일한 객체일 수 있습니다. \u003ccode\u003efinder.find_module()\u003c/code\u003e은 단순히 \u003ccode\u003eself\u003c/code\u003e를 반환할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e두 메서드의 \u003ccode\u003efullname\u003c/code\u003e 인수는 \"spam.eggs.ham\"과 같은 완전한 모듈 이름입니다. \u003ccode\u003efind_module()\u003c/code\u003e 메서드는 실제 임포트 중에 항상 호출되는 것은 아니므로, \u003ccode\u003efinder\u003c/code\u003e는 \u003ccode\u003esys.modules\u003c/code\u003e에 부모 패키지가 존재한다고 의존해서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eload_module()\u003c/code\u003e 메서드는 코드를 실행하기 전에 몇 가지 책임을 이행해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esys.modules\u003c/code\u003e에 \u003ccode\u003efullname\u003c/code\u003e이라는 이름의 기존 모듈 객체가 있으면 로더는 해당 객체를 사용해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.modules\u003c/code\u003e에 \u003ccode\u003efullname\u003c/code\u003e이라는 이름의 모듈이 없으면 로더는 새 모듈 객체를 생성하고 \u003ccode\u003esys.modules\u003c/code\u003e에 추가해야 합니다. 이 작업은 로더가 모듈 코드를 실행하기 전에 이루어져야 합니다.\u003c/li\u003e\n\u003cli\u003e로드에 실패하면 로더는 \u003ccode\u003esys.modules\u003c/code\u003e에 삽입했을 수 있는 모듈을 제거해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__file__\u003c/code\u003e 속성이 설정되어야 합니다. 이는 문자열이어야 하며, \" \u003ccode\u003e\u0026#x3C;frozen\u003e\u003c/code\u003e \"과 같은 더미 값일 수 있습니다. \u003ccode\u003e__file__\u003c/code\u003e 속성이 전혀 없는 특권은 내장 모듈에만 주어집니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__name__\u003c/code\u003e 속성이 설정되어야 합니다. \u003ccode\u003eimp.new_module()\u003c/code\u003e을 사용하면 자동으로 설정됩니다.\u003c/li\u003e\n\u003cli\u003e패키지인 경우 \u003ccode\u003e__path__\u003c/code\u003e 변수가 설정되어야 합니다. 이는 리스트여야 하며, 임포터에게 \u003ccode\u003e__path__\u003c/code\u003e가 더 이상 의미가 없다면 비어있을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__loader__\u003c/code\u003e 속성은 로더 객체로 설정되어야 합니다. 이는 주로 인트로스펙션(introspection) 및 재로드(reloading)를 위한 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__package__\u003c/code\u003e 속성이 설정되어야 합니다 (PEP 366).\u003c/li\u003e\n\u003cli\u003e모듈이 Python 모듈인 경우 (내장 모듈이나 동적으로 로드된 확장 모듈과 반대), 모듈의 전역 이름 공간( \u003ccode\u003emodule.__dict__\u003c/code\u003e )에서 모듈 코드를 실행해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eload_module()\u003c/code\u003e 메서드를 위한 최소한의 패턴은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 대부분의 세부 사항을 처리하기 위해 importlib.util.module_for_loader()를 사용하는 것을 고려하세요.\ndef load_module(self, fullname):\n    code = self.get_code(fullname)\n    ispkg = self.is_package(fullname)\n    mod = sys.modules.setdefault(fullname, imp.new_module(fullname))\n    mod.__file__ = \"\u0026#x3C;%s\u003e\" % self.__class__.__name__\n    mod.__loader__ = self\n    if ispkg:\n        mod.__path__ = []\n        mod.__package__ = fullname\n    else:\n        mod.__package__ = fullname.rpartition('.')[0]\n    exec(code, mod.__dict__)\n    return mod\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e사양 2부: 훅 등록 (Specification part 2: Registering Hooks)\u003c/h2\u003e\n\u003cp\u003e두 가지 유형의 임포트 훅이 있습니다: **메타 훅(Meta hooks)**과 \u003cstrong\u003e경로 훅(Path hooks)\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3\u003e메타 훅 (Meta hooks)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e임포트 처리 시작 시, 다른 임포트 처리보다 먼저 호출됩니다 (따라서 메타 훅은 \u003ccode\u003esys.path\u003c/code\u003e 처리, 프로즌 모듈, 심지어 내장 모듈까지 재정의할 수 있습니다).\u003c/li\u003e\n\u003cli\u003e메타 훅을 등록하려면 \u003ccode\u003efinder\u003c/code\u003e 객체를 \u003ccode\u003esys.meta_path\u003c/code\u003e (등록된 메타 훅 목록)에 추가하기만 하면 됩니다.\u003c/li\u003e\n\u003cli\u003e현재 기본적으로 비어 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e경로 훅 (Path hooks)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esys.path\u003c/code\u003e (또는 \u003ccode\u003epackage.__path__\u003c/code\u003e) 처리의 일부로, 관련 경로 항목이 발견되는 시점에 호출됩니다.\u003c/li\u003e\n\u003cli\u003e경로 훅은 \u003ccode\u003esys.path_hooks\u003c/code\u003e에 임포터 팩토리(importer factory)를 추가하여 등록됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.path_hooks\u003c/code\u003e는 콜러블(callable) 목록이며, 주어진 경로 항목을 처리할 수 있는지 순서대로 확인됩니다.\u003c/li\u003e\n\u003cli\u003e콜러블은 경로 항목을 처리할 수 없으면 \u003ccode\u003eImportError\u003c/code\u003e를 발생시키고, 처리할 수 있으면 임포터 객체를 반환해야 합니다.\u003c/li\u003e\n\u003cli\u003e경로 훅 검사 결과는 \u003ccode\u003esys.path_importer_cache\u003c/code\u003e에 캐시됩니다. 이 캐시는 \u003ccode\u003esys.path_hooks\u003c/code\u003e를 스캔하기 전에 확인됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e새로운 \u003ccode\u003esys\u003c/code\u003e 변수들은 \u003ccode\u003esys.path\u003c/code\u003e와 마찬가지로 특정 유형을 가져야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esys.meta_path\u003c/code\u003e와 \u003ccode\u003esys.path_hooks\u003c/code\u003e는 Python 리스트여야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.path_importer_cache\u003c/code\u003e는 Python 딕셔너리여야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 변수를 인플레이스(in-place)로 수정하거나 새 객체로 교체하는 것은 허용됩니다.\u003c/p\u003e\n\u003ch2\u003e패키지와 \u003ccode\u003e__path__\u003c/code\u003e의 역할 (Packages and the role of \u003cstrong\u003epath\u003c/strong\u003e)\u003c/h2\u003e\n\u003cp\u003e모듈이 \u003ccode\u003e__path__\u003c/code\u003e 속성을 가지고 있으면 임포트 메커니즘은 이를 패키지로 취급합니다. 패키지의 서브모듈을 임포트할 때 \u003ccode\u003esys.path\u003c/code\u003e 대신 \u003ccode\u003e__path__\u003c/code\u003e 변수가 사용됩니다. 따라서 \u003ccode\u003esys.path\u003c/code\u003e에 대한 규칙은 \u003ccode\u003epkg.__path__\u003c/code\u003e에도 적용됩니다. 즉, \u003ccode\u003epkg.__path__\u003c/code\u003e가 순회될 때 \u003ccode\u003esys.path_hooks\u003c/code\u003e도 참조됩니다.\u003c/p\u003e\n\u003cp\u003e메타 임포터는 작업을 수행하기 위해 \u003ccode\u003esys.path\u003c/code\u003e를 전혀 사용하지 않을 수 있으므로 \u003ccode\u003epkg.__path__\u003c/code\u003e 값을 무시할 수 있습니다. 이 경우에도 비어 있을 수 있는 리스트로 설정하는 것이 좋습니다.\u003c/p\u003e\n\u003ch2\u003e임포터 프로토콜의 선택적 확장 (Optional Extensions to the Importer Protocol)\u003c/h2\u003e\n\u003cp\u003e임포터 프로토콜은 세 가지 선택적 확장을 정의합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e데이터 파일 검색\u003c/li\u003e\n\u003cli\u003e모듈 패키징 도구 및/또는 모듈 의존성 분석 도구(예: Freeze) 지원\u003c/li\u003e\n\u003cli\u003e모듈을 스크립트로 실행하는 지원\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 세 가지 확장 모두 일반적인 임포터에 강력히 권장되지만, 해당 기능이 필요하지 않으면 안전하게 생략할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e데이터 파일 검색 (\u003ccode\u003eget_data\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003e기저 저장소 백엔드에서 임의의 \"파일\"에 대한 데이터를 검색하기 위해 로더 객체는 \u003ccode\u003eget_data()\u003c/code\u003e라는 메서드를 제공할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eloader.get_data(path)\u003c/code\u003e: 이 메서드는 데이터를 문자열로 반환하거나 \"파일\"을 찾지 못하면 \u003ccode\u003eIOError\u003c/code\u003e를 발생시킵니다. 데이터는 항상 \"이진(binary)\" 모드가 사용된 것처럼 반환됩니다. 이는 파일 시스템과 유사한 속성을 가진 임포터를 위한 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ed = os.path.dirname(__file__)\ndata = __loader__.get_data(os.path.join(d, \"logo.gif\"))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e패키징/분석 도구 지원 (\u003ccode\u003eis_package\u003c/code\u003e, \u003ccode\u003eget_code\u003c/code\u003e, \u003ccode\u003eget_source\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003eFreeze와 같은 도구에 대한 지원이 필요한 경우 다음 메서드 세트를 구현할 수 있습니다. 호출자가 쉽게 사용할 수 있도록 세 가지 메서드 모두 구현하거나, 아예 구현하지 않아야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eloader.is_package(fullname)\u003c/code\u003e: \u003ccode\u003efullname\u003c/code\u003e으로 지정된 모듈이 패키지이면 \u003ccode\u003eTrue\u003c/code\u003e, 아니면 \u003ccode\u003eFalse\u003c/code\u003e를 반환해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eloader.get_code(fullname)\u003c/code\u003e: 모듈과 관련된 코드 객체를 반환하거나, 내장 또는 확장 모듈인 경우 \u003ccode\u003eNone\u003c/code\u003e을 반환해야 합니다. 소스 코드는 있지만 코드 객체가 없으면 컴파일된 소스 코드를 반환해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eloader.get_source(fullname)\u003c/code\u003e: 모듈의 소스 코드를 문자열로 반환하거나, 소스를 사용할 수 없으면 \u003ccode\u003eNone\u003c/code\u003e을 반환해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 세 메서드 모두 모듈을 찾을 수 없으면 \u003ccode\u003eImportError\u003c/code\u003e를 발생시켜야 합니다.\u003c/p\u003e\n\u003ch3\u003e스크립트 실행 지원 (\u003ccode\u003eget_filename\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003e모듈을 스크립트로 실행하는 것(PEP 338)을 지원하려면 위 세 가지 메서드가 구현되어야 합니다. 또한, \u003ccode\u003erunpy\u003c/code\u003e 모듈이 \u003ccode\u003e__file__\u003c/code\u003e 속성을 올바르게 설정할 수 있도록 다음 메서드를 제공할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eloader.get_filename(fullname)\u003c/code\u003e: 이 메서드는 명명된 모듈이 로드될 경우 \u003ccode\u003e__file__\u003c/code\u003e이 설정될 값을 반환해야 합니다. 모듈을 찾을 수 없으면 \u003ccode\u003eImportError\u003c/code\u003e를 발생시켜야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e\u003ccode\u003eimp\u003c/code\u003e 모듈과의 통합 (Integration with the 'imp' module)\u003c/h2\u003e\n\u003cp\u003e새로운 임포트 훅은 기존 \u003ccode\u003eimp.find_module()\u003c/code\u003e 및 \u003ccode\u003eimp.load_module()\u003c/code\u003e 호출에 쉽게 통합되지 않습니다. 기존 코드에 영향을 주지 않고 통합하는 것은 의문이며, \u003ccode\u003eimp\u003c/code\u003e 모듈에 새 함수를 추가하는 것이 더 좋습니다.\u003c/p\u003e\n\u003cp\u003e기존 \u003ccode\u003eimp.find_module()\u003c/code\u003e 및 \u003ccode\u003eimp.load_module()\u003c/code\u003e 호출의 의미는 \"내장 임포트 메커니즘을 노출\"에서 \"기본적으로 훅이 없는 내장 임포트 메커니즘을 노출\"로 변경됩니다. 이들은 어떤 임포트 훅도 호출하지 않습니다.\u003c/p\u003e\n\u003cp\u003e새로운 \u003ccode\u003eimp\u003c/code\u003e 모듈 함수(\u003ccode\u003eget_loader()\u003c/code\u003e)가 제안되었으며, 다음과 같은 패턴으로 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eloader = imp.get_loader(fullname, path)\nif loader is not None:\n    loader.load_module(fullname)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\"기본\" 임포트의 경우, \u003ccode\u003eloader\u003c/code\u003e 객체는 \u003ccode\u003eimp.find_module()\u003c/code\u003e의 현재 출력에 대한 래퍼(wrapper)이며, \u003ccode\u003eloader.load_module()\u003c/code\u003e은 해당 출력을 사용하여 \u003ccode\u003eimp.load_module()\u003c/code\u003e을 호출합니다.\u003c/p\u003e\n\u003ch2\u003e향후 호환성 (Forward Compatibility)\u003c/h2\u003e\n\u003cp\u003e기존 \u003ccode\u003e__import__\u003c/code\u003e 훅은 폴백(fallback)으로 원래 \u003ccode\u003e__import__\u003c/code\u003e 함수를 호출하지 않는 한, 새로운 방식의 훅을 자동으로 호출하지 않습니다. 예를 들어, \u003ccode\u003eihooks.py\u003c/code\u003e, \u003ccode\u003eiu.py\u003c/code\u003e, \u003ccode\u003eimputil.py\u003c/code\u003e는 이 PEP와 호환되지 않습니다.\u003c/p\u003e\n\u003ch2\u003e미해결 문제 (Open Issues)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e데이터 파일 위치\u003c/strong\u003e: 모듈, 특히 복잡한 패키지나 전체 애플리케이션의 경우 지원 데이터 파일이 필요합니다. 현재는 일반적으로 \u003ccode\u003esys.path\u003c/code\u003e (또는 \u003ccode\u003epackage.__path__\u003c/code\u003e 속성)를 통해 이러한 파일을 찾습니다. 이 접근 방식은 임포트 훅을 통해 로드되는 모듈에는 일반적으로 작동하지 않습니다.\n\u003cul\u003e\n\u003cli\u003e해결책으로 \"그렇게 하지 마세요\", \u003ccode\u003esys.prefix\u003c/code\u003e 기반의 표준 위치에서 찾기, 임포트 훅이 모듈 파일에 상대적인 데이터 파일에 접근하는 표준적인 방법을 제공하는 것 등이 논의되었습니다. \u003ccode\u003ezipimport\u003c/code\u003e 객체는 \u003ccode\u003e__loader__\u003c/code\u003e 속성과 \u003ccode\u003eget_data(name)\u003c/code\u003e 메서드를 제공하여 이러한 문제를 해결합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e사용 가능한 모듈 및 데이터 파일 목록\u003c/strong\u003e: 임포터로부터 사용 가능한 모듈 목록이나 \u003ccode\u003eget_data()\u003c/code\u003e 메서드와 함께 사용할 데이터 파일 목록을 받는 것이 유용할 수 있다는 제안이 있었습니다. \u003ccode\u003elist_modules()\u003c/code\u003e 및 \u003ccode\u003elist_files()\u003c/code\u003e와 같은 확장이 고려될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e대안적인 파일 형식 또는 컴파일러\u003c/strong\u003e: 이 PEP는 대안적인 위치에서 모듈을 로드하는 데 중점을 둡니다. 대안적인 파일 형식이나 컴파일러로 모듈을 로드하기 위한 전용 솔루션을 제공하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e훅 스태킹(Stacking) 지원 부족\u003c/strong\u003e: 이 PEP 내에서는 훅 스태킹에 대한 특별한 지원이 없습니다. 예를 들어, \u003ccode\u003e.tar\u003c/code\u003e 및 \u003ccode\u003e.gz\u003c/code\u003e 파일에서 모듈을 로드하는 별도의 훅을 결합하여 \u003ccode\u003etar.gz\u003c/code\u003e 파일에서 모듈을 로드하는 훅을 작성하는 방법은 명확하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003esys.path\u003c/code\u003e 처리 후 훅 추가\u003c/strong\u003e: \u003ccode\u003esys.meta_path\u003c/code\u003e를 통해 \u003ccode\u003esys.path\u003c/code\u003e가 처리되기 전에 실행되는 훅을 추가할 수 있지만, \u003ccode\u003esys.path\u003c/code\u003e가 처리된 후에 실행되는 훅을 추가하는 동등한 방법은 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003ePEP 302 구현은 Python 2.3a1부터 Python에 통합되었습니다.\nPEP 273은 PEP 302의 임포트 훅을 사용하여 구현되었습니다.\u003c/p\u003e\n\u003ch2\u003e참고 및 각주 (References and Footnotes)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eimputil module: \u003ccode\u003ehttp://docs.python.org/library/imputil.html\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThe Freeze tool. See also the \u003ccode\u003eTools/freeze/\u003c/code\u003e directory in a Python source distribution\u003c/li\u003e\n\u003cli\u003epy2exe by Thomas Heller: \u003ccode\u003ehttp://www.py2exe.org/\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eimp.set_frozenmodules()\u003c/code\u003e patch: \u003ccode\u003ehttp://bugs.python.org/issue642578\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThe path argument to \u003ccode\u003efinder.find_module()\u003c/code\u003e is there because the \u003ccode\u003epkg.__path__\u003c/code\u003e variable may be needed at this point. It may either come from the actual parent module or be supplied by \u003ccode\u003eimp.find_module()\u003c/code\u003e or the proposed \u003ccode\u003eimp.get_loader()\u003c/code\u003e function.\u003c/li\u003e\n\u003cli\u003eQuixote, a framework for developing Web applications: \u003ccode\u003ehttp://www.mems-exchange.org/software/quixote/\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eNew import hooks + Import from Zip files: \u003ccode\u003ehttp://bugs.python.org/issue652586\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eLanguage reference for imports: \u003ccode\u003ehttp://docs.python.org/3/reference/import.html\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eimportlib documentation: \u003ccode\u003ehttp://docs.python.org/3/library/importlib.html#module-importlib\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 배포되었습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 302 - New Import Hooks\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 18:08:12+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"page__taxonomy mb-4\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"카테고리\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":\"Python\"}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":\"PEP\"}]]]}],[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]]}]]}]}]}]\nb:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\""])</script><script>self.__next_f.push([1,"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"21\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>