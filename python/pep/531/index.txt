3:I[9275,[],""]
5:I[1343,[],""]
6:I[4281,["231","static/chunks/231-c4b666723e6aae68.js","185","static/chunks/app/layout-8808afda01b7a1b7.js"],"default"]
7:I[231,["231","static/chunks/231-c4b666723e6aae68.js","877","static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js"],""]
4:["slug","python/pep/531","c"]
0:["iV6XySbMHIJ3imQdvgy3I",[[["",{"children":[["slug","python/pep/531","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"531\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/531","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","link",null,{"rel":"icon","type":"image/png","sizes":"32x32","href":"/favicon-32x32.png"}],["$","link",null,{"rel":"icon","type":"image/png","sizes":"16x16","href":"/favicon-16x16.png"}],["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_9012cf layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T83ef,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0531/">PEP 531 - Existence checking operators</a></p>
<p><strong>상태:</strong> Withdrawn | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 25-Oct-2016</p>
</blockquote>
<p>PEP 531 – 존재 확인 연산자 (Existence Checking Operators)</p>
<p><strong>상태:</strong> 철회됨 (Withdrawn)</p>
<h2>초록 (Abstract)</h2>
<p>PEP 505와 관련 논의에서 영감을 받은 이 PEP는 Python에 두 가지 새로운 제어 흐름 연산자를 추가할 것을 제안했습니다:</p>
<ul>
<li><strong>존재 확인 전제 조건("exists-then"):</strong> <code>expr1 ?then expr2</code></li>
<li><strong>존재 확인 대체 ("exists-else"):</strong> <code>expr1 ?else expr2</code></li>
</ul>
<p>또한, 일반적인 존재 확인 표현식 및 문장을 위한 다음과 같은 약어를 제안했습니다:</p>
<ul>
<li><strong>존재 확인 속성 접근:</strong> <code>obj?.attr</code> ( <code>obj ?then obj.attr</code> 와 동일)</li>
<li><strong>존재 확인 인덱싱 (Subscripting):</strong> <code>obj?[expr]</code> ( <code>obj ?then obj[expr]</code> 와 동일)</li>
<li><strong>존재 확인 할당:</strong> <code>value ?= expr</code> ( <code>value = value ?else expr</code> 와 동일)</li>
</ul>
<p>이 새로운 연산자 정의에 사용된 공통 기호 <code>?</code>는 <code>if</code> 문, <code>while</code> 루프, <code>comprehension</code>, <code>generator expression</code>, 조건부 표현식, 논리적 <code>and</code>, 논리적 <code>or</code>에서 사용되는 기존의 <code>truth-checking</code> 프로토콜 대신 새로운 "existence checking" 프로토콜을 사용한다는 것을 나타냅니다.</p>
<p>이 새로운 프로토콜은 <code>operator.exists</code>로 제공될 예정이었으며, 다음과 같은 특징을 가집니다:</p>
<ul>
<li>타입은 기본 동작을 재정의하기 위해 새로운 <code>__exists__</code> 매직 메서드 (Python) 또는 <code>tp_exists</code> 슬롯 (C)을 정의할 수 있습니다. 이 선택적 메서드는 <code>__bool__</code>과 동일한 시그니처와 가능한 반환 값을 가집니다.</li>
<li><code>operator.exists(None)</code>은 <code>False</code>를 반환합니다.</li>
<li><code>operator.exists(NotImplemented)</code>는 <code>False</code>를 반환합니다.</li>
<li><code>operator.exists(Ellipsis)</code>는 <code>False</code>를 반환합니다.</li>
<li><code>float</code>, <code>complex</code>, <code>decimal.Decimal</code>은 <code>NaN</code> 값이 <code>False</code>를 반환하고 다른 값 (0 값 포함)은 <code>True</code>를 반환하도록 존재 확인을 재정의합니다.</li>
<li>다른 모든 타입의 경우, <code>operator.exists(obj)</code>는 기본적으로 <code>True</code>를 반환합니다.</li>
<li>가장 중요한 점은 <code>truth-checking</code> 컨텍스트에서 <code>False</code>로 평가되는 값 (0, 빈 컨테이너)도 <code>existence-checking</code> 컨텍스트에서는 <code>True</code>로 평가된다는 것입니다.</li>
</ul>
<h2>PEP 철회 (PEP Withdrawal)</h2>
<p>이 PEP는 <code>python-ideas</code>에 토론을 위해 게시되었을 때, 특정 구문 제안의 세부 사항을 고려하기 전에 세 가지 상위 수준의 디자인 질문을 검토하도록 요청했습니다:</p>
<ol>
<li>"존재 확인(existence checking)"이 소프트웨어 개발에 존재하는 유용한 일반적인 개념이며 "진리 확인(truth checking)" 개념과 구별되는가?</li>
<li>Python 생태계가 언어 정의, 표준 라이브러리 및 사용자 정의 코드에 정의된 "데이터 누락(data missing)" 지표 전반에 걸쳐 알고리즘(특히 단축 평가(short-circuiting) 알고리즘)의 일반화를 허용하는 존재 확인 프로토콜로부터 이점을 얻을 것인가?</li>
<li><code>truth-checking</code>의 <code>and</code> 및 <code>or</code> 제어 흐름 연산자에 해당하는 존재 확인 연산자가 제공된다면 그러한 프로토콜을 효과적으로 사용하기 더 쉬울 것인가?</li>
</ol>
<p>첫 번째 질문에 대한 답변은 대체로 긍정적이었지만, 두 번째 질문에 대한 답변은 "아니오"라는 것이 빠르게 명확해졌습니다.</p>
<p>Steven D'Aprano는에서 반대 의견을 잘 설명했지만, 일반적인 아이디어는 "누락된 데이터(missing data)" 센티넬(sentinel)을 확인할 때, 특정 센티넬 값을 찾는 경우가 거의 항상이며, 어떤 센티넬 값이라도 찾는 것이 아니라는 것입니다.</p>
<p>예를 들어, <code>NotImplemented</code>는 <code>None</code>이 오버로드된 산술 연산자의 잠재적으로 유효한 결과일 수 있고, 예외 처리가 피연산자 강제 변환에 유용하기에는 너무 많은 런타임 오버헤드를 부과하기 때문에 존재합니다.</p>
<p>마찬가지로, <code>Ellipsis</code>는 다차원 슬라이싱 지원을 위해 존재합니다. 이는 <code>None</code>이 슬라이싱 컨텍스트에서 이미 다른 의미(기본 시작 또는 중지 인덱스 또는 기본 스텝 크기 사용을 나타냄)를 가지고 있기 때문입니다.</p>
<p>수학에서 <code>NaN</code> 값의 유용성은 프로그램적으로 해당 타입의 일반 값처럼 동작하면서(예: 모든 일반 속성 및 메서드 노출), 산술적으로는 <code>NaN</code> 값을 처리하는 수학적 규칙에 따라 동작한다는 것입니다.</p>
<p>이 핵심 디자인 개념이 무효화됨에 따라, 제안 전체는 의미가 없으므로 철회되었습니다.</p>
<p>그러나 제안에 대한 논의는 새로운 구문 도입 없이 기존 <code>and</code>, <code>or</code>, <code>if-else</code> 연산자를 더 유연하게 만들 수 있는 잠재적인 프로토콜 기반 접근 방식에 대한 고려를 촉발시켰으므로, 이는 PEP 505에 대한 또 다른 가능한 대안으로 작성될 예정입니다.</p>
<h2>다른 PEP와의 관계 (Relationship with other PEPs)</h2>
<p>이 PEP는 Mark Haase의 PEP 505 작업을 기반으로 하고 영감을 받았지만, 제안된 기능의 구문 및 의미론적 세부 사항의 상당한 차이로 인해 궁극적으로 해당 PEP와 경쟁했습니다.</p>
<p>또한, 애플리케이션 및 서비스 개발 활동의 전형적인 요구 사항이 실제로 변화함에 따라 기존 Python 사용자에게 미치는 이점에 초점을 맞춰 변경의 근거에 대한 다른 관점을 제시합니다. 유사한 기능이 여러 프로그래밍 언어에 나타나는 것은 우연이 아니며, 다른 언어 설계자들이 이 문제를 어떻게 다루고 있는지 배우는 것이 좋지만, 다른 곳에서 설정된 선례는 이 문제를 어떻게 해결할 것인지에 더 관련이 있으며, 이 문제를 애초에 다루어야 한다고 생각하는지에 대한 여부와는 관련이 없습니다.</p>
<h2>근거 (Rationale)</h2>
<h3>존재 확인 표현식 (Existence checking expressions)</h3>
<p>현대 소프트웨어 개발에서 점점 더 흔해지는 요구 사항은 "반정형 데이터(semi-structured data)" 작업입니다. 이는 데이터의 구조는 미리 알려져 있지만, 런타임에 데이터의 일부가 누락될 수 있으며, 해당 데이터를 조작하는 소프트웨어는 완전히 실패하기보다는 점진적으로 기능 저하(예: 누락된 데이터에 의존하는 결과 생략)하도록 예상되는 경우입니다.</p>
<p>이 문제가 발생하는 특히 일반적인 경우는 다음과 같습니다:</p>
<ul>
<li>선택적 애플리케이션 구성 설정 및 함수 매개변수 처리</li>
<li>분산 시스템에서 외부 서비스 실패 처리</li>
<li>부분 레코드를 포함하는 데이터 세트 처리</li>
</ul>
<p>이 중 후자 두 가지 경우가 이 PEP의 주요 동기입니다. 선택적 구성 설정 및 매개변수를 처리해야 하는 요구 사항은 Python 자체만큼 오래된 디자인 요구 사항이지만, 퍼블릭 클라우드 인프라의 부상, 분산 서비스의 협업 네트워크로서의 소프트웨어 시스템 개발, 분석을 위한 대규모 공개 및 비공개 데이터 세트의 가용성은 부분 서비스 실패 또는 부분 데이터 가용성 상황에서 작업을 점진적으로 저하시킬 수 있는 능력이 현대 프로그래밍 환경의 필수 기능이 되고 있음을 의미합니다.</p>
<p>현재 Python에서 이러한 소프트웨어를 작성하는 것은 코드가 다음과 같은 표현식으로 가득 차게 되므로 정말로 어색할 수 있습니다:</p>
<pre><code class="language-python">value1 = expr1.field.of.interest if expr1 is not None else None
value2 = expr2["field"]["of"]["interest"] if expr2 is not None else None
value3 = expr3 if expr3 is not None else expr4 if expr4 is not None else expr5
</code></pre>
<p>이러한 경우가 가끔 발생한다면, 전체 문장 형태로 확장하면 가독성을 향상시킬 수 있지만, 데이터 변환 파이프라인에서 4~5개가 연속으로 있는 경우(이는 상당히 흔한 상황입니다), 이를 16~20줄의 조건부 로직으로 대체하는 것은 문제를 전혀 해결하는 데 도움이 되지 않습니다.</p>
<p>위 세 가지 예시를 다음과 같이 확장하면 이를 이해하는 데 도움이 될 것입니다:</p>
<pre><code class="language-python">if expr1 is not None:
    value1 = expr1.field.of.interest
else:
    value1 = None

if expr2 is not None:
    value2 = expr2["field"]["of"]["interest"]
else:
    value2 = None

if expr3 is not None:
    value3 = expr3
else:
    if expr4 is not None:
        value3 = expr4
    else:
        value3 = expr5
</code></pre>
<p>이 PEP의 제안들이 결합된 영향은 위 샘플 표현식들을 다음과 같이 작성할 수 있도록 하는 것입니다:</p>
<pre><code class="language-python">value1 = expr1?.field.of.interest
value2 = expr2?["field"]["of"]["interest"]
value3 = expr3 ?else expr4 ?else expr5
</code></pre>
<p>이러한 형태에서는 독자에게 제시되는 거의 모든 정보가 "이 코드는 무엇을 하는가?"라는 질문과 즉시 관련되며, 누락된 데이터를 출력으로 전달하거나 대체 입력으로 폴백(fallback)하여 처리하는 상용구(boilerplate) 코드는 <code>?</code> 기호 두 번과 <code>?else</code> 키워드 두 번 사용으로 줄어들었습니다.</p>
<p>처음 두 예시에서, 31자 길이의 상용구 절 <code>if exprN is not None else None</code> (단일 문자 변수명에서는 최소 27자)이 단일 <code>?</code> 문자로 대체되어, 코드 라인의 신호 대 패턴 노이즈 비율(signal-to-pattern-noise ratio)이 상당히 향상되었습니다 (특히 더 의미 있는 변수 및 필드 이름을 사용하도록 권장하여 표현의 간결성을 위해 짧게 만드는 것보다).</p>
<p>마지막 예시에서, 21자 길이의 상용구 <code>if exprN is not None</code> (최소 17자)의 두 인스턴스가 단일 문자로 대체되어 다시 신호 대 패턴 노이즈 비율이 상당히 향상되었습니다.</p>
<p>더 나아가, 5개의 "잠재적 관심 하위 표현식" 각각은 정확히 한 번만 포함되며, 이들이 존재하는지 먼저 확인하기 위해 4개를 복제하거나 명명된 변수로 추출할 필요가 없습니다.</p>
<p>존재 확인 전제 조건 연산자는 주로 존재 확인 속성 접근 및 인덱싱 연산자를 위한 명확한 개념적 기반을 제공하기 위해 정의됩니다:</p>
<ul>
<li><code>obj?.attr</code>는 대략 <code>obj ?then obj.attr</code>와 동일합니다.</li>
<li><code>obj?[expr]</code>는 대략 <code>obj ?then obj[expr]</code>와 동일합니다.</li>
</ul>
<p>단축 형태와 확장된 형태 사이의 주요 의미론적 차이는 존재 확인 연산자 왼쪽에 있는 공통 하위 표현식이 단축 형태에서는 한 번만 평가된다는 것입니다 (증가 할당문(augmented assignment statements)이 제공하는 이점과 유사합니다).</p>
<h3>존재 확인 할당 (Existence checking assignment)</h3>
<p>존재 확인 할당은 이 PEP의 개념을 확장하여 일반적인 구성 처리 관용구(idiom)를 다루도록 제안되었습니다:</p>
<pre><code class="language-python">value = value if value is not None else expensive_default()
</code></pre>
<p>이것을 다음과 같이 축약할 수 있습니다:</p>
<pre><code class="language-python">value ?= expensive_default()
</code></pre>
<p>이는 주로 대상이 인덱싱(subscript) 작업 또는 하위 속성일 때 유용합니다. 왜냐하면 이 특정 변경이 없더라도 PEP는 여전히 이 관용구를 다음과 같이 업데이트하는 것을 허용할 것이기 때문입니다:</p>
<pre><code class="language-python">value = value ?else expensive_default()
</code></pre>
<p>이 형태를 추가하는 것에 대한 주요 반대 의견은 이것이 모호할 수 있으며 다음 중 하나를 의미할 수 있다는 것입니다:</p>
<ul>
<li><code>value = value ?else expensive_default()</code></li>
<li><code>value = value ?then value.subfield.of.interest</code></li>
</ul>
<p>두 번째 형태는 전혀 유용하지 않지만, 이 우려가 증가 할당 기능을 유지하면서 해결할 만큼 충분히 중요하다고 판단된다면, 전체 키워드를 구문에 포함시킬 수 있습니다:</p>
<pre><code class="language-python">value ?else= expensive_default()
</code></pre>
<p>대안으로, 증가 할당은 현재 제안에서 완전히 제외되고 나중에 다시 고려될 수도 있습니다.</p>
<h3>존재 확인 프로토콜 (Existence checking protocol)</h3>
<p>존재 확인 프로토콜은 프록시 객체(예: 원격 리소스의 로컬 표현) 및 테스트에 사용되는 목(mock) 객체가 프록시 또는 목 객체 자체가 <code>None</code>이 아니더라도 대상 리소스의 비존재를 올바르게 나타낼 수 있도록 하기 위해 주로 이 제안에 포함되었습니다.</p>
<p>그러나 해당 프로토콜이 정의되면, 숫자 타입의 <code>NaN</code> 값을 확인하는 타입 독립적인 방법을 제공하도록 확장하는 것이 자연스러워 보입니다. 현재는 작업 중인 정확한 데이터 타입(예: 내장 <code>float</code>, 내장 <code>complex</code>, <code>decimal</code> 모듈)을 알고 적절한 연산(예: <code>math.isnan</code>, <code>cmath.isnan</code>, <code>decimal.getcontext().is_nan()</code> 등)을 사용해야 합니다.</p>
<p>마찬가지로, 다른 내장 플레이스홀더 싱글톤(singleton)인 <code>Ellipsis</code>와 <code>NotImplemented</code>도 데이터 자체를 나타내기보다는 데이터의 부재를 나타내는 객체로 간주하는 것이 합리적입니다.</p>
<h3>제안된 기호 표기법 (Proposed symbolic notation)</h3>
<p>Python은 역사적으로 <code>bool()</code> 내장 함수를 통해 직접 호출할 수 있는 <code>truth checking</code>이라는 한 가지 종류의 암시적 불리언(boolean) 컨텍스트만 가졌습니다. 이 PEP는 <code>truth checking</code> 대신 <code>existence checking</code>에 기반한 새로운 종류의 제어 흐름 연산을 제안하므로, <code>truth checking</code> 대신 <code>existence checking</code>이 사용될 때 코드에 직접 알림을 갖는 것이 가치 있다고 간주됩니다.</p>
<p>존재 주장을 위한 수학적 기호는 U+2203 'THERE EXISTS': <code>∃</code> 입니다.</p>
<p>따라서 이 PEP에서 제안된 구문 추가에 대한 한 가지 가능한 접근 방식은 이미 정의된 수학적 표기법을 사용하는 것입니다:</p>
<pre><code class="language-python">expr1 ∃then expr2
expr1 ∃else expr2
obj∃.attr
obj∃[expr]
target ∃= expr
</code></pre>
<p>그러나 이 접근 방식에는 두 가지 주요 문제점이 있습니다. 하나는 실용적인 문제이고, 다른 하나는 교육학적인 문제입니다.</p>
<p>실용적인 문제는 대부분의 키보드가 기본적인 산술에 사용되는 기호 외에는 수학적 기호를 쉽게 입력할 수 있는 방법을 제공하지 않는다는 일반적인 문제입니다 (이 PEP에 나타나는 기호조차도 직접 입력하기보다는에서 복사하여 붙여넣은 것입니다).</p>
<p>교육학적인 문제는 존재 주장(<code>∃</code>)과 보편 주장(<code>∀</code>)의 기호가 기본적인 산술 연산자만큼 대부분의 사람들에게 익숙하지 않을 것이므로, <code>∃</code>를 채택함으로써 제안된 구문을 실제로 이해하기 쉽게 만들지는 못할 것이라는 점입니다.</p>
<p>이와 대조적으로, <code>?</code>는 Python 구문에서 몇 안 되는 남은 미사용 ASCII 구두점 문자 중 하나이므로, "이 제어 흐름 연산은 <code>truth check</code>가 아닌 <code>existence check</code>에 기반한다"는 구문 마커의 후보로 사용할 수 있습니다.</p>
<p>이 경로를 따르면 Python의 구문을 유사한 기능을 제공하는 다른 언어의 해당 구문과 일치시키는 장점도 있습니다.</p>
<p>PEP 505의 기존 요약과 "안전 탐색 연산자(safe navigation operator)" 및 "널 병합 연산자(null coalescing operator)"에 대한 Wikipedia 기사에서 발췌하면 다음과 같습니다:</p>
<p><code>?.</code> 존재 확인 속성 접근 구문은 다음을 정확하게 따릅니다:</p>
<ul>
<li>C#의 "safe navigation" 속성 접근 연산자 (<code>?.</code>)</li>
<li>Swift의 "optional chaining" 연산자 (<code>?.</code>)</li>
<li>Groovy의 "safe navigation" 속성 접근 연산자 (<code>?.</code>)</li>
<li>Dart의 "conditional member access" 연산자 (<code>?.</code>)</li>
</ul>
<p><code>?[]</code> 존재 확인 속성 접근 구문은 다음을 정확하게 따릅니다:</p>
<ul>
<li>C#의 "safe navigation" 인덱싱 연산자 (<code>?[]</code>)</li>
<li>Swift의 "optional subscript" 연산자 (<code>?[].</code>)</li>
</ul>
<p><code>?else</code> 존재 확인 대체 구문은 의미론적으로 다음을 따릅니다:</p>
<ul>
<li>C#의 "null-coalescing" 연산자 (<code>??</code>)</li>
<li>PHP의 "null-coalescing" 연산자 (<code>??</code>)</li>
<li>Swift의 "nil-coalescing" 연산자 (<code>??</code>)</li>
</ul>
<p>명확히 하자면, 이것들이 다른 언어에서 사용되는 유일한 연산자 표기법은 아니지만, 가장 일반적인 표기법이며 <code>?</code> 기호가 가장 흔한 구문 마커입니다 (아마도 C 스타일 조건부 표현식에서 <code>then</code> 절을 도입하는 데 <code>?</code>를 사용하는 것에 의해 촉발되었을 것입니다. 이러한 언어 중 다수가 이 또한 제공합니다).</p>
<h3>제안된 키워드 (Proposed keywords)</h3>
<p>기호 마커 <code>?</code>가 주어졌을 때, 존재 확인 전제 조건 및 대체 연산을 <code>truth checking</code>과 동일한 키워드를 사용하여 표현하는 것은 구문적으로 모호하지 않을 것입니다:</p>
<ul>
<li><code>expr1 ?and expr2</code> (<code>expr1 ?then expr2</code> 대신)</li>
<li><code>expr1 ?or expr2</code> (<code>expr1 ?else expr2</code> 대신)</li>
</ul>
<p>그러나, 구문적으로 작성되었을 때는 모호하지 않지만, 이 접근 방식은 코드를 발음하기 매우 어렵게 만들고 ("?"의 발음은 무엇인가?) 설명하기도 어렵게 만듭니다 (키워드가 재사용되므로 "존재 확인 전제 조건(?and)"과 "존재 확인 대체(?or)"를 "논리적 논리곱(and)" 및 "논리적 논리합(or)"과 구별하는 명확한 약어 용어가 없습니다).</p>
<p>사람들에게 <code>?</code> 기호를 "exists"라고 발음하도록 권장하여 약어 이름을 "exists-and expression" 및 "exists-or expression"으로 만들 수도 있지만, 코드에서 이를 보고 순수하게 그 이름을 추측할 방법은 없을 것입니다.</p>
<p>대신, 이 PEP는 제안된 기호 구문을 활용하여 새로운 키워드 (<code>?then</code>)를 도입하고 기존 키워드 (<code>?else</code>)를 차용하여 사람들이 모호함 없이 "<code>then</code> 표현식" 및 "<code>else</code> 표현식"을 언급할 수 있도록 합니다.</p>
<p>이러한 키워드는 제안된 표현식과 의미론적으로 동등한 조건부 표현식과도 잘 일치합니다.</p>
<p><code>?else</code> 표현식의 경우, <code>expr1 ?else expr2</code>는 다음와 동일합니다:</p>
<pre><code class="language-python">_lhs_result = expr1
_lhs_result if operator.exists(_lhs_result) else expr2
</code></pre>
<p>여기서 병렬 관계는 분명합니다. <code>else expr2</code>가 축약형과 확장형 모두의 끝에 나타나기 때문입니다.</p>
<p><code>?then</code> 표현식의 경우, <code>expr1 ?then expr2</code>는 다음와 동일합니다:</p>
<pre><code class="language-python">_lhs_result = expr1
expr2 if operator.exists(_lhs_result) else _lhs_result
</code></pre>
<p>여기서 병렬 관계는 Python의 전통적으로 익명인 "<code>then</code>" 절( <code>if</code> 문에서는 <code>:</code>으로, 조건부 표현식에서는 <code>if</code>로 접미사) 때문에 즉시 명확하지는 않지만, 조건부 제어 흐름의 "if-then-else" 설명에 이미 익숙하다면 여전히 합리적으로 명확합니다.</p>
<h2>위험 및 우려 사항 (Risks and concerns)</h2>
<h3>가독성 (Readability)</h3>
<p>새로운 구문을 효과적으로 읽고 쓰는 것을 배우는 것은 주로 두 가지 개념을 내면화하는 것을 필요로 합니다:</p>
<ul>
<li><code>?</code>를 포함하는 표현식은 존재 확인을 포함하며, <code>None</code> 또는 다른 "존재하지 않는" 값이 예상 입력이고 올바른 처리가 이를 결과로 전파하는 것이라면 단축 평가(short-circuit)될 수 있습니다. 이 경우 존재 확인 연산자가 원하는 것일 가능성이 높습니다.</li>
</ul>
<p>현재 이러한 개념은 언어 수준에서 명시적으로 표현되지 않으므로, 조건부 표현식 및 문장을 기반으로 하는 다양한 관용적인 패턴을 인식하고 사용하는 것을 배워야 합니다.</p>
<h3>마법 같은 구문 (Magic syntax)</h3>
<p><code>?</code>가 구문 요소로서 본질적으로 <code>is not None</code> 또는 <code>operator.exists</code>를 제안하는 것은 없습니다. Python 코드에서 <code>?</code>의 주요 현재 사용은 IPython 환경에서 이전 표현식의 결과에 대한 도움말 정보를 요청하기 위한 후행 접미사입니다.</p>
<p>그러나 존재 확인이라는 개념은 <code>truth checking</code>과 구별되는 광범위한 시각적 마커로부터 진정으로 이점을 얻으며, 이를 수행하려면 단일 문자 기호 구문이 필요합니다.</p>
<h3>개념적 복잡성 (Conceptual complexity)</h3>
<p>이 제안은 현재 임시적이고 비공식적인 "존재 확인" 개념을 명확하게 정의된 연산자 프로토콜을 가진 구문적 언어 기능의 지위로 격상시킵니다.</p>
<p>여러 면에서 이는 실제로 언어의 전반적인 개념적 복잡성을 줄여야 합니다. <code>bool(expr)</code>을 사용한 <code>truth checking</code>과 <code>operator.exists(expr)</code>을 사용한 <code>existence checking</code> 간에 현재 <code>truth checking</code>과 <code>expr is not None</code> (또는 피연산자 강제 변환 컨텍스트의 <code>expr is not NotImplemented</code>, 또는 수학 라이브러리의 다양한 <code>NaN</code> 확인 연산) 간에 매핑되는 것보다 훨씬 더 많은 기대가 올바르게 매핑될 것이기 때문입니다.</p>
<p>이 PEP에 의해 도입된 새로운 병렬 관계의 간단한 예시로 다음을 비교하십시오:</p>
<pre><code class="language-python">all_are_true = all(map(bool, iterable))
at_least_one_is_true = any(map(bool, iterable))
all_exist = all(map(operator.exists, iterable))
at_least_one_exists = any(map(operator.exists, iterable))
</code></pre>
<h2>디자인 논의 (Design Discussion)</h2>
<h3>존재 확인 표현식 체인의 미묘한 차이 (Subtleties in chaining existence checking expressions)</h3>
<p>논리 연산자 체인에서 이미 존재하는 것과 유사하게, 존재 확인 표현식 체인에서도 미묘한 차이가 발생합니다. 체인 내의 표현식 중 하나의 오른쪽이 존재하지 않는 값을 반환하면 동작이 놀라울 수 있습니다.</p>
<p>결과적으로, <code>value = arg1 ?then f(arg1) ?else default()</code>는 <code>value = cond and expr1 or expr2</code>가 의심스러운 것과 본질적으로 동일한 이유로 의심스럽습니다. 전자는 <code>f(arg1)</code>이 <code>None</code>을 반환하면 <code>default()</code>를 평가하고, 후자는 <code>expr1</code>이 불리언 컨텍스트에서 <code>False</code>로 평가되면 <code>expr2</code>를 평가합니다.</p>
<h3>조건부 표현식과의 모호한 상호 작용 (Ambiguous interaction with conditional expressions)</h3>
<p>현재 작성된 제안에서 다음은 구문 오류입니다:</p>
<pre><code class="language-python">value = f(arg) if arg ?else default
</code></pre>
<p>다음은 첫 번째 조건이 거짓이 아니라 존재하지 않는 경우 두 번째 조건을 확인하는 유효한 연산입니다:</p>
<pre><code class="language-python">value = expr1 if cond1 ?else cond2 else expr2
</code></pre>
<p>위에 설명된 표현식 체인 문제는 첫 번째 연산이 다음와 동일해야 한다는 주장을 뒷받침합니다:</p>
<pre><code class="language-python">value = f(arg) if operator.exists(arg) else default
</code></pre>
<p>이것은 두 번째 연산을 다음과 같이 더 명확하게 작성하도록 요구합니다:</p>
<pre><code class="language-python">value = expr1 if (cond1 ?else cond2) else expr2
</code></pre>
<p>대안으로, 첫 번째 형태는 구문 오류로 남아 있을 수 있으며, 존재 확인 기호는 <code>if</code> 키워드에 붙여서 <code>truth check</code> 대신 <code>existence check</code>를 사용한다는 것을 나타낼 수 있습니다:</p>
<pre><code class="language-python">value = expr1 if? cond else expr2
</code></pre>
<h3>다른 진리 확인 컨텍스트에서의 존재 확인 (Existence checking in other truth-checking contexts)</h3>
<p><code>truth-checking</code> 프로토콜은 현재 다음과 같은 구문 구조에서 사용됩니다:</p>
<ul>
<li>논리적 논리곱 (<code>and</code>-표현식)</li>
<li>논리적 논리합 (<code>or</code>-표현식)</li>
<li>조건부 표현식 (<code>if-else</code> 표현식)</li>
<li><code>if</code> 문</li>
<li><code>while</code> 루프</li>
<li><code>comprehension</code> 및 <code>generator expression</code>의 <code>filter</code> 절</li>
</ul>
<p>현재 PEP에서는 <code>and</code>와 <code>or</code>를 사용한 <code>truth-checking</code>에서 <code>existence-checking</code>으로 전환하는 것은 적절한 위치에 새로운 키워드인 <code>?then</code>과 <code>?else</code>를 대체하는 문제입니다.</p>
<p>다른 <code>truth-checking</code> 컨텍스트의 경우, <code>operator.exists</code> API를 가져와 사용하거나, <code>expr is not None</code> (또는 컨텍스트에 적합한 동등물)을 특별히 확인하는 현재 관용구를 계속 사용하는 것을 제안합니다.</p>
<p>이와 관련하여 가장 간단한 개선 사항은 제안된 <code>exists()</code> API를 <code>operator</code> 모듈 함수에서 새로운 내장 함수로 격상시키는 것입니다.</p>
<p>대안으로, <code>?</code> 존재 확인 기호는 <code>if</code> 및 <code>while</code> 키워드에 대한 수정자로 지원되어 <code>truth check</code> 대신 <code>existence check</code> 사용을 나타낼 수 있습니다.</p>
<p>그러나, 이러한 제안 중 어느 것이든 얻게 될 잠재적인 일관성 이점이 추가적인 혼란을 정당화할지는 전혀 명확하지 않으므로, 현재 제안에서 생략되었습니다.</p>
<h3><code>__bool__</code>과 <code>__exists__</code> 간의 예상 불변 관계 정의 (Defining expected invariant relations between <strong>bool</strong> and <strong>exists</strong>)</h3>
<p>PEP는 현재 모든 기존 타입의 <code>__bool__</code> 정의를 수정하지 않고 두므로, 전체 제안이 역호환성을 유지하도록 보장하지만, 다음과 같은 경우 <code>bool(obj)</code>는 <code>True</code>를 반환하지만 제안된 <code>operator.exists(obj)</code>는 <code>False</code>를 반환합니다:</p>
<ul>
<li><code>float</code>, <code>complex</code>, <code>decimal.Decimal</code>의 <code>NaN</code> 값</li>
<li><code>Ellipsis</code></li>
<li><code>NotImplemented</code></li>
</ul>
<p>이러한 것들을 잠재적으로 변경해야 한다는 주요 주장은, 존재 확인 컨텍스트에서 존재하지 않는다고 나타내는 값이 <code>truth checking</code> 컨텍스트에서도 <code>False</code>로 보고되어야 한다는 권장되는 불변 요소가 있다면 잠재적인 코드 동작을 추론하기가 더 쉬워진다는 것입니다.</p>
<p>이러한 불변 요소를 정의하지 못하면 <code>float("NaN") ?else 0.0</code>이 <code>0.0</code>을 반환하는 반면 <code>float("NaN") or 0.0</code>은 <code>NaN</code>을 반환하는 것과 같이 다소 이상한 결과가 발생할 수 있습니다.</p>
<h2>제약 사항 (Limitations)</h2>
<h3>임의의 센티넬 객체 (Arbitrary sentinel objects)</h3>
<p>이 제안은 <code>None</code>이 허용된 명시적 값인 "센티넬 객체(sentinel object)" 관용구에 대한 구문 지원을 제공하려 하지 않습니다. 이 경우 누락된 값을 나타내기 위해 별도의 센티넬 객체가 정의됩니다:</p>
<pre><code class="language-python">_SENTINEL = object()
def f(obj=_SENTINEL):
    return obj if obj is not _SENTINEL else default_value()
</code></pre>
<p>이는 존재 프로토콜 정의를 정의하고 사용하는 데 있어 훨씬 더 복잡하게 만드는 대가로 잠재적으로 지원될 수 있습니다:</p>
<ul>
<li>Python 계층에서는 <code>operator.exists</code> 및 <code>__exists__</code> 구현이 비존재를 나타내기 위해 빈 튜플을 반환하고, 그렇지 않으면 존재 확인의 결과로 사용될 객체에 대한 참조를 포함하는 단일 요소 튜플을 반환할 것입니다.</li>
<li>C 계층에서는 <code>tp_exists</code> 구현이 비존재를 나타내기 위해 <code>NULL</code>을 반환하고, 그렇지 않으면 존재 확인의 결과로 <code>PyObject *</code> 포인터를 반환할 것입니다.</li>
</ul>
<p>이러한 변경을 통해 센티넬 객체 관용구는 다음과 같이 다시 작성될 수 있습니다:</p>
<pre><code class="language-python">class Maybe:
    SENTINEL = object()
    def __init__(self, value):
        self._result = (value,) if value is not self.SENTINEL else ()
    def __exists__(self):
        return self._result
    def f(obj=Maybe.SENTINEL):
        return Maybe(obj) ?else default_value()
</code></pre>
<p>그러나, 제안된 3가지 표준 센티넬 값(즉, <code>None</code>, <code>Ellipsis</code>, <code>NotImplemented</code>)을 사용할 수 없는 경우가 추가 프로토콜 복잡성과 <code>__bool__</code>과 <code>__exists__</code> 간의 대칭 손실을 감수할 만큼 충분히 흔하지는 않을 것이라고 생각합니다.</p>
<h2>명세 (Specification)</h2>
<p>초록(Abstract)은 이미 제안의 요점을 제공하고, 근거(Rationale)는 몇 가지 특정 예시를 제공합니다. 기본 아이디어에 충분한 관심이 있다면, 전체 명세는 제안된 구문 설탕과 참조 구현 생성을 안내하기에 충분한 기본 조건부 표현식 간의 정확한 대응 관계를 제공해야 할 것입니다.</p>
<p>…TBD…</p>
<h2>구현 (Implementation)</h2>
<p>PEP 505와 마찬가지로, 실제 구현은 이러한 연산자를 추가하는 아이디어에 대한 원칙적인 관심이 있을 때까지 연기되었습니다. 구현은 이러한 제안의 어려운 부분이 아니며, 어려운 부분은 신규 및 기존 Python 사용자에게 장기적인 이점이 광범위한 생태계(다른 구현 개발자, 언어 교육 과정 개발자, 기타 Python 관련 교육 자료 저자 포함)가 변경에 적응하는 데 드는 단기적인 비용보다 더 큰 변경인지 여부를 결정하는 것입니다.</p>
<p>…TBD…</p>
<h2>참고 자료 (References)</h2>
<ul>
<li>Wikipedia: Safe navigation operator (https://en.wikipedia.org/wiki/Safe_navigation_operator)</li>
<li>Wikipedia: Null coalescing operator (https://en.wikipedia.org/wiki/Null_coalescing_operator)</li>
<li>FileFormat.info: Unicode Character 'THERE EXISTS' (U+2203) (http://www.fileformat.info/info/unicode/char/2203/index.htm)</li>
<li>python-ideas discussion thread (https://mail.python.org/pipermail/python-ideas/2016-October/043415.html)</li>
<li>Steven D'Aprano's critique of the proposal (https://mail.python.org/pipermail/python-ideas/2016-October/043453.html)</li>
<li>Considering a link to the idea of overloadable Boolean operators (https://mail.python.org/pipermail/python-ideas/2016-October/043447.html)</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 CC0 1.0 라이선스 조건에 따라 공개 도메인에 게시되었습니다: https://creativecommons.org/publicdomain/zero/1.0/</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Withdrawn] PEP 531 - Existence checking operators"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 23:22:20+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":[["$","div",null,{"className":"page__taxonomy mb-4","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"카테고리"}],[["$","span","Python",{"className":"page__taxonomy-item","children":"Python"}],["$","span","PEP",{"className":"page__taxonomy-item","children":"PEP"}]]]}],["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]]}]]}]}]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","21",{"name":"next-size-adjust"}]]
1:null
