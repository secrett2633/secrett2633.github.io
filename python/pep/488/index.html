<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js"/><script src="/secrett2633.github.io/_next/static/chunks/fd9d1056-62aaf4b921c84028.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/23-ca4408d024135d8d.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/main-app-fa660020ba1e0b6e.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/231-c4b666723e6aae68.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/layout-8808afda01b7a1b7.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="next-size-adjust"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/secrett2633.github.io/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_9012cf layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/secrett2633.github.io">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 488 - Elimination of PYO files</h1><div class="page__meta"><time dateTime="2025-09-26 22:34:01+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0488/">PEP 488 - Elimination of PYO files</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 20-Feb-2015</p>
</blockquote>
<h2>PEP 488 – PYO 파일 제거</h2>
<h3>초록 (Abstract)</h3>
<p>이 PEP는 Python에서 PYO 파일 개념을 제거할 것을 제안합니다. 바이트코드 파일이 최적화 수준에 따라 분리되어 저장되는 방식을 계속 지원하기 위해, 최적화가 적용된 경우 바이트코드 저장소 디렉터리 내의 PYC 파일 이름에 최적화 수준을 포함하도록 확장할 것을 제안합니다.</p>
<h3>배경 (Rationale)</h3>
<p>현재 Python의 바이트코드 파일은 <code>PYC</code>와 <code>PYO</code> 두 가지 형태로 존재합니다. 인터프리터 시작 시 최적화 수준이 지정되지 않으면(<code>-O</code> 옵션 미지정) <code>PYC</code> 파일이 생성되고 읽힙니다. 반면, <code>-O</code> 또는 <code>-OO</code>와 같은 최적화 수준이 지정되면 <code>PYO</code> 파일이 읽고 쓰입니다.</p>
<p>문제는 <code>PYC</code> 파일이 Peepholer 최적화 외에 다른 최적화가 없음을 명확히 하는 반면, <code>PYO</code> 파일은 최적화 수준 1(<code>-O</code>)과 최적화 수준 2(<code>-OO</code>) 모두 <code>.pyo</code> 확장자를 재사용하여 어떤 최적화 수준이 적용되었는지 알 수 없다는 점입니다.</p>
<p>이러한 모호성은 다음과 같은 문제를 야기합니다.</p>
<ul>
<li><strong>코드 실행의 불일치:</strong> 사용자가 모든 <code>PYO</code> 파일이 동일한 최적화 수준으로 생성되었는지 확인하지 않으면, 인터프리터가 다른 최적화 수준으로 컴파일된 코드를 혼합하여 사용할 수 있습니다.</li>
<li><strong>불필요한 파일 변경 (File Churn):</strong> 최적화 수준을 변경하거나 이전에 생성된 <code>PYO</code> 파일의 최적화 수준을 확신할 수 없을 때마다 모든 <code>PYO</code> 파일을 삭제해야 하는 번거로움이 있습니다. 이는 불필요한 파일 쓰기 작업을 유발합니다.</li>
<li><strong>사전 컴파일의 어려움:</strong> <code>.pyo</code> 확장자가 여러 최적화 수준에 재사용되면서 모든 최적화 수준에 대한 바이트코드 파일을 미리 컴파일하는 것이 불가능합니다.</li>
<li><strong>배포 효율성 저하:</strong> 바이트코드 전용 모듈을 배포할 때 코드 난독화나 파일 크기 축소를 위해 <code>.pyc</code>와 <code>.pyo</code> 파일을 모두 배포하는 것은 비효율적입니다. 이 PEP에서는 비최적화 <code>.pyc</code> 파일 이름으로만 로드하도록 합니다.</li>
</ul>
<h3>제안 (Proposal)</h3>
<p><code>PYO</code> 파일의 모호성을 제거하기 위해, 이 PEP는 <code>PYO</code> 파일과 <code>.pyo</code> 확장자 개념을 없앨 것을 제안합니다. 최적화 수준을 명확히 하고 <code>__pycache__</code> 디렉터리에서 최적화된 바이트코드 파일을 불필요하게 다시 생성하는 것을 방지하기 위해, 바이트코드 파일 이름에 최적화 수준을 포함시킬 것입니다.</p>
<p>최적화 수준이 지정되지 않은 경우, 기존의 <code>.pyc</code> 파일 이름 형식이 그대로 사용됩니다.</p>
<p>예를 들어, Python 3.5에서 <code>foo.py</code>라는 소스 파일은 인터프리터의 최적화 수준(없음, <code>-O</code>, <code>-OO</code>)에 따라 다음과 같은 바이트코드 파일을 가질 수 있습니다.</p>
<ul>
<li><strong>0 (최적화 없음):</strong> <code>foo.cpython-35.pyc</code> (기존과 동일)</li>
<li><strong>1 (<code>-O</code>):</strong> <code>foo.cpython-35.opt-1.pyc</code></li>
<li><strong>2 (<code>-OO</code>):</strong> <code>foo.cpython-35.opt-2.pyc</code></li>
</ul>
<p>현재 바이트코드 파일 이름은 <code>importlib.util.cache_from_source()</code> 함수에 의해 PEP 3147에서 정의된 형식인 <code>'{name}.{cache_tag}.pyc'</code>를 사용하여 생성됩니다.</p>
<p>이 PEP는 최적화 수준이 지정된 경우 파일 이름 형식을 다음과 같이 변경할 것을 제안합니다.</p>
<p><code>'{name}.{cache_tag}.opt-{optimization}.pyc'</code></p>
<p>여기서 <code>opt-</code> 접두사는 캐시 태그와 시각적으로 구분되며, 최적화 수준은 캐시 태그 뒤에 배치되어 모듈 이름과 캐시 태그를 기준으로 한 사전식 정렬 순서를 유지합니다. <code>opt-</code>는 자체 설명적이며, 숫자 <code>0</code>과의 혼동을 피하기 위해 선택되었습니다. 구분자로 하이픈 대신 마침표를 사용하여 최적화 수준이 인터프리터 버전의 일부가 아님을 명확히 합니다.</p>
<p>이 변경 사항은 <code>import</code> 성능에 영향을 미치지 않습니다. <code>__pycache__</code> 디렉터리에 잠재적으로 더 많은 바이트코드 파일이 생길 수 있지만, import 시스템은 이미 인터프리터의 최적화 수준에 따라 단일 바이트코드 파일을 찾으므로 <code>stat</code> 호출 횟수에는 변화가 없습니다.</p>
<p>이 PEP의 잠재적인 단점은 <code>.pyc</code> 파일 수의 증가와 그에 따른 저장 공간 사용량 증가입니다. 그러나 이러한 문제가 되는 플랫폼의 경우 <code>sys.dont_write_bytecode</code>를 사용하여 바이트코드 생성을 비활성화하고 오프라인으로 제어할 수 있습니다.</p>
<h3>구현 (Implementation)</h3>
<h4><code>importlib</code></h4>
<p><code>importlib.util.cache_from_source()</code>는 바이트코드 파일 경로를 노출하고 <code>importlib</code>에 의해 직접 사용되므로 가장 중요한 변경이 필요합니다. Python 3.4의 함수 시그니처는 다음과 같습니다.</p>
<p><code>importlib.util.cache_from_source(path, debug_override=None)</code></p>
<p>이 PEP는 Python 3.5에서 시그니처를 다음과 같이 변경할 것을 제안합니다.</p>
<p><code>importlib.util.cache_from_source(path, debug_override=None, *, optimization=None)</code></p>
<p>새로 도입된 키워드 전용 매개변수 <code>optimization</code>은 파일 이름에 지정될 최적화 수준을 제어합니다. 인수가 <code>None</code>이면 인터프리터의 현재 최적화 수준이 가정됩니다. <code>optimization</code>에 전달되는 인수는 <code>str()</code>로 변환되며 <code>str.isalnum()</code>이 <code>True</code>여야 합니다. 빈 문자열이 전달되면 최적화 수준 추가가 억제되어 이 PEP 이전의 파일 이름 형식으로 돌아갑니다.</p>
<p><code>debug_override</code> 매개변수는 더 이상 사용되지 않을 것입니다. <code>False</code> 값은 <code>optimization=1</code>과 동등하며, <code>True</code> 값은 <code>optimization=''</code>를 나타냅니다. <code>debug_override</code>에 <code>None</code>이 아닌 값이 주어지면 Deprecation Warning이 발생합니다.</p>
<p><code>importlib.machinery</code>의 바이트코드 파일 접미사와 관련된 다양한 모듈 속성도 업데이트될 것입니다. <code>DEBUG_BYTECODE_SUFFIXES</code>와 <code>OPTIMIZED_BYTECODE_SUFFIXES</code>는 모두 더 이상 사용되지 않음으로 문서화되고 <code>BYTECODE_SUFFIXES</code>와 동일한 값으로 설정됩니다.</p>
<h4>표준 라이브러리의 나머지 부분</h4>
<p><code>py_compile</code> 및 <code>compileall</code> 모듈에 의해 노출되는 다양한 함수들은 새로운 바이트코드 파일 이름 의미론을 따르도록 업데이트될 것입니다. <code>compileall</code> 모듈의 CLI는 직접적인 영향을 받지 않습니다.</p>
<h3>호환성 고려 사항 (Compatibility Considerations)</h3>
<p>Python 3.2부터 바이트코드 파일을 직접 조작하는 모든 코드는 이 변경 사항이 코드에 미치는 영향을 고려해야 합니다. <code>importlib.util.cache_from_source()</code>의 <code>debug_override</code> 인수를 설정하던 코드는 최적화 수준 2의 바이트코드 파일 경로를 원할 경우 주의가 필요합니다.</p>
<p>바이트코드 전용 모듈을 배포하는 사람들은 <code>.pyc</code> 파일과 함께 <code>.pyo</code> 파일을 배포하는 것이 더 이상 유용하지 않으므로, 사용할 최적화 수준을 선택해야 합니다. 코드 난독화나 배포 크기 축소를 위해 단일 <code>.pyc</code>만 배포하는 것이 이러한 사용 사례에 유리할 것입니다. Python 3.5에서 바이트코드 파일의 매직 넘버가 변경되었기 때문에 기존 <code>.pyo</code> 파일을 지원할 필요가 없습니다.</p>
<h3>기각된 아이디어 (Rejected Ideas)</h3>
<h4>CPython에서 최적화 수준을 완전히 제거하는 것</h4>
<p>일부에서는 CPython의 다양한 최적화 수준을 수용하는 대신 완전히 제거해야 한다고 제안했습니다. 이 주장은 JIT와 같은 런타임 최적화를 통해 상당한 성능 향상을 얻을 수 있으며, 사전 실행 바이트코드 최적화를 통해서는 얻을 수 없다는 것입니다.</p>
<p>이 아이디어는 기존 CPython의 최적화 수준이 유용하다고 생각하는 사람들이 존재한다는 사실을 무시하기 때문에 이 PEP에서 기각되었습니다.</p>
<h4>파일 이름에서 최적화 수준의 대체 형식</h4>
<p><code>opt-</code> 접두사를 사용하고 최적화 수준을 캐시 태그와 파일 확장자 사이에 배치하는 것이 중요하지 않다는 의견도 있었습니다. 다양한 다른 형식들이 고려되었지만, 파일 정렬 순서 변경, 캐시 태그와의 모호성, 또는 자체 설명 부족 등의 이유로 기각되었습니다. 비공식 설문조사 결과, PEP가 제안한 형식을 선호하는 경향이 분명했습니다.</p>
<h4>바이트코드 메타데이터에 최적화 수준 포함</h4>
<p>바이트코드의 최적화 수준을 파일 이름이 아닌 파일의 메타데이터에 포함해야 한다는 제안도 있었습니다. 이는 모든 인터프리터가 한 번에 하나의 바이트코드 사본만 가질 수 있음을 의미합니다. 최적화 수준을 변경하려면 바이트코드를 다시 작성해야 하지만, 관리해야 할 파일은 하나만 있을 것입니다.</p>
<p>이 제안은 Python이 종종 루트 수준 애플리케이션으로 설치되며, 이 경우 표준 라이브러리 모듈의 바이트코드 파일을 수정하는 것이 항상 가능하다는 사실 때문에 기각되었습니다. 이러한 상황에서 통합자(integrators)는 사용자에게 적합한 최적화 수준을 추측해야 할 것입니다. 여러 최적화 수준이 동시에 존재할 수 있도록 함으로써 통합자들이 추측할 필요 없이 사용자가 원하는 최적화 수준을 활용할 수 있게 됩니다.</p>
<h3>저작권 (Copyright)</h3>
<h2>이 문서는 공개 도메인에 배치되었습니다.</h2>
<p><strong>PEP 488 요약:</strong></p>
<p>PEP 488은 Python에서 <code>.pyo</code> 파일 개념을 제거하고 모든 최적화된 바이트코드 파일을 <code>.pyc</code> 확장자로 통합하는 것을 제안합니다. 기존에는 최적화 수준에 따라 <code>.pyc</code>와 <code>.pyo</code>로 나뉘었지만, <code>.pyo</code> 파일은 최적화 수준 1(-O)과 2(-OO)를 구분하지 못해 모호성을 야기하고 불필요한 파일 관리를 초래했습니다. 이 PEP는 이러한 문제를 해결하기 위해 최적화 수준을 바이트코드 파일 이름(예: <code>foo.cpython-35.opt-1.pyc</code>)에 명시적으로 포함하도록 변경합니다. 이는 <code>importlib</code> 모듈과 표준 라이브러리의 관련 함수들을 업데이트하며, <code>debug_override</code> 매개변수를 비활성화합니다. 이로 인해 파일 수가 증가할 수 있지만, 호환성 및 명확성 측면에서 이점을 제공합니다.## PEP 488 – PYO 파일 제거</p>
<h3>초록 (Abstract)</h3>
<p>이 PEP는 Python에서 PYO 파일 개념을 제거하고, 최적화 수준을 바이트코드 저장소 디렉터리 내의 PYC 파일 이름에 포함시켜 바이트코드 파일의 최적화 수준별 분리 지원을 유지할 것을 제안합니다.</p>
<h3>배경 (Rationale)</h3>
<p>현재 Python의 바이트코드 파일은 <code>.pyc</code>와 <code>.pyo</code> 두 가지 형태로 존재합니다. 인터프리터 시작 시 최적화 수준이 지정되지 않으면(<code>.O</code> 옵션 미지정) <code>.pyc</code> 파일이 생성되고 읽히며, <code>-O</code> 또는 <code>-OO</code>와 같은 최적화 수준이 지정되면 <code>.pyo</code> 파일이 읽고 쓰입니다.</p>
<p>문제는 <code>.pyo</code> 파일이 최적화 수준 1(<code>-O</code>)과 최적화 수준 2(<code>-OO</code>) 모두에 동일하게 사용되어, 해당 파일이 어떤 최적화 수준으로 생성되었는지 명확히 알 수 없다는 점입니다. 이러한 모호성은 다음과 같은 문제를 야기합니다.</p>
<ul>
<li><strong>최적화 수준 혼동:</strong> 사용자가 주의하지 않으면 인터프리터가 다른 최적화 수준으로 컴파일된 코드를 혼합하여 사용할 수 있습니다.</li>
<li><strong>불필요한 파일 재생성:</strong> 최적화 수준을 변경하거나 기존 <code>.pyo</code> 파일의 최적화 수준을 확신할 수 없을 때마다 모든 <code>.pyo</code> 파일을 삭제해야 하는 번거로움이 있습니다.</li>
<li><strong>사전 컴파일 제약:</strong> <code>.pyo</code> 확장자가 여러 최적화 수준에 재사용되면서 모든 최적화 수준에 대한 바이트코드 파일을 미리 컴파일하는 것이 불가능합니다.</li>
<li><strong>배포 비효율성:</strong> 바이트코드 전용 모듈을 배포할 때 <code>.pyc</code>와 <code>.pyo</code> 파일을 모두 배포하는 것은 비효율적입니다. 이 PEP에서는 비최적화 <code>.pyc</code> 파일 이름으로만 로드하도록 합니다.</li>
</ul>
<h3>제안 (Proposal)</h3>
<p>이 PEP는 <code>PYO</code> 파일의 모호성을 제거하기 위해 <code>.pyo</code> 파일과 확장자 개념을 없앨 것을 제안합니다. 대신, 최적화 수준을 바이트코드 파일 이름에 포함시켜 명확성을 확보하고 <code>__pycache__</code> 디렉터리에서 불필요한 파일 재생성을 피합니다.</p>
<p>최적화 수준이 지정되지 않은 경우, 기존의 <code>.pyc</code> 파일 이름 형식이 그대로 사용됩니다.</p>
<p><strong>변경될 바이트코드 파일 이름 예시 (Python 3.5, <code>foo.py</code> 기준):</strong></p>
<ul>
<li><strong>0 (최적화 없음):</strong> <code>foo.cpython-35.pyc</code> (변경 없음)</li>
<li><strong>1 (<code>-O</code>):</strong> <code>foo.cpython-35.opt-1.pyc</code></li>
<li><strong>2 (<code>-OO</code>):</strong> <code>foo.cpython-35.opt-2.pyc</code></li>
</ul>
<p>현재 바이트코드 파일 이름은 <code>importlib.util.cache_from_source()</code> 함수에 의해 <code>'{name}.{cache_tag}.pyc'</code> 형식으로 생성되는데, 이 PEP는 최적화 수준이 지정된 경우 다음 형식으로 변경할 것을 제안합니다.</p>
<p><code>'{name}.{cache_tag}.opt-{optimization}.pyc'</code></p>
<p><code>opt-</code> 접두사는 캐시 태그와 시각적으로 구분되며, 최적화 수준은 캐시 태그 뒤에 배치되어 모듈 이름과 캐시 태그를 기준으로 한 사전식 정렬 순서를 유지합니다. 이 변경 사항은 <code>import</code> 성능에 영향을 미치지 않으며, <code>__pycache__</code> 디렉터리 내 파일 수 증가로 인한 저장 공간 사용량 증가는 <code>sys.dont_write_bytecode</code>를 통해 제어할 수 있습니다.</p>
<h3>구현 (Implementation)</h3>
<h4><code>importlib</code></h4>
<p><code>importlib.util.cache_from_source()</code> 함수의 시그니처가 Python 3.5에서 다음과 같이 변경됩니다.</p>
<p><code>importlib.util.cache_from_source(path, debug_override=None, *, optimization=None)</code></p>
<p>새로운 키워드 전용 매개변수 <code>optimization</code>은 파일 이름에 포함될 최적화 수준을 제어합니다. <code>debug_override</code> 매개변수는 더 이상 사용되지 않으며 Deprecation Warning이 발생할 것입니다. <code>importlib.machinery</code>의 <code>DEBUG_BYTECODE_SUFFIXES</code>와 <code>OPTIMIZED_BYTECODE_SUFFIXES</code>도 <code>BYTECODE_SUFFIXES</code>와 동일하게 설정되며 더 이상 사용되지 않음으로 문서화됩니다.</p>
<h4>표준 라이브러리의 나머지 부분</h4>
<p><code>py_compile</code> 및 <code>compileall</code> 모듈의 함수들은 새로운 바이트코드 파일 이름 의미론을 따르도록 업데이트될 것입니다.</p>
<h3>호환성 고려 사항 (Compatibility Considerations)</h3>
<p>Python 3.2부터 바이트코드 파일을 직접 조작하는 모든 코드는 이 변경 사항의 영향을 고려해야 합니다. 특히 <code>importlib.util.cache_from_source()</code>의 <code>debug_override</code> 인수를 설정하던 코드는 최적화 수준 2의 바이트코드 파일 경로를 다룰 때 주의가 필요합니다.</p>
<p>바이트코드 전용 모듈을 배포하는 경우, <code>.pyc</code> 파일과 함께 <code>.pyo</code> 파일을 배포하는 것이 더 이상 유용하지 않으므로, 사용할 최적화 수준을 선택하여 단일 <code>.pyc</code> 파일만 배포해야 합니다.</p>
<h3>기각된 아이디어 (Rejected Ideas)</h3>
<h4>CPython에서 최적화 수준을 완전히 제거하는 것</h4>
<p>런타임 최적화가 더 효율적이라는 이유로 CPython의 최적화 수준을 완전히 제거하자는 제안이 있었으나, 기존 최적화 수준이 유용하다고 생각하는 사용자들이 존재하며 다른 Python 인터프리터에서도 이 PEP의 제안이 유용할 수 있다는 점을 들어 기각되었습니다.</p>
<h4>파일 이름에서 최적화 수준의 대체 형식</h4>
<p><code>opt-</code> 접두사 및 최적화 수준 배치에 대한 다양한 대체 형식들이 고려되었으나, 파일 정렬 순서 변경, 캐시 태그와의 모호성, 자체 설명 부족 등의 이유로 현재 PEP가 제안하는 형식이 채택되었습니다.</p>
<h4>바이트코드 메타데이터에 최적화 수준 포함</h4>
<p>바이트코드의 최적화 수준을 파일 이름이 아닌 파일의 메타데이터에 포함하자는 제안도 있었으나, Python이 루트 수준 애플리케이션으로 설치되는 경우가 많아 표준 라이브러리 모듈의 바이트코드 파일을 수정할 때 통합자들이 적절한 최적화 수준을 추측해야 하는 문제가 발생할 수 있어 기각되었습니다. 여러 최적화 수준이 동시에 존재할 수 있도록 하여 사용자가 원하는 최적화 수준을 자유롭게 활용할 수 있도록 하는 것이 더 바람직하다고 판단되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy mb-4"><h4 class="text-sm font-medium text-gray-900 mb-2">카테고리</h4><span class="page__taxonomy-item">Python</span><span class="page__taxonomy-item">PEP</span></div><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[4281,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"185\",\"static/chunks/app/layout-8808afda01b7a1b7.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/488\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"iV6XySbMHIJ3imQdvgy3I\",\"assetPrefix\":\"/secrett2633.github.io\",\"initialCanonicalUrl\":\"/python/pep/488/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/488\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"488\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/488\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"32x32\",\"href\":\"/favicon-32x32.png\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"16x16\",\"href\":\"/favicon-16x16.png\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_9012cf layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T4bc0,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0488/\"\u003ePEP 488 - Elimination of PYO files\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 20-Feb-2015\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 488 – PYO 파일 제거\u003c/h2\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 Python에서 PYO 파일 개념을 제거할 것을 제안합니다. 바이트코드 파일이 최적화 수준에 따라 분리되어 저장되는 방식을 계속 지원하기 위해, 최적화가 적용된 경우 바이트코드 저장소 디렉터리 내의 PYC 파일 이름에 최적화 수준을 포함하도록 확장할 것을 제안합니다.\u003c/p\u003e\n\u003ch3\u003e배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003e현재 Python의 바이트코드 파일은 \u003ccode\u003ePYC\u003c/code\u003e와 \u003ccode\u003ePYO\u003c/code\u003e 두 가지 형태로 존재합니다. 인터프리터 시작 시 최적화 수준이 지정되지 않으면(\u003ccode\u003e-O\u003c/code\u003e 옵션 미지정) \u003ccode\u003ePYC\u003c/code\u003e 파일이 생성되고 읽힙니다. 반면, \u003ccode\u003e-O\u003c/code\u003e 또는 \u003ccode\u003e-OO\u003c/code\u003e와 같은 최적화 수준이 지정되면 \u003ccode\u003ePYO\u003c/code\u003e 파일이 읽고 쓰입니다.\u003c/p\u003e\n\u003cp\u003e문제는 \u003ccode\u003ePYC\u003c/code\u003e 파일이 Peepholer 최적화 외에 다른 최적화가 없음을 명확히 하는 반면, \u003ccode\u003ePYO\u003c/code\u003e 파일은 최적화 수준 1(\u003ccode\u003e-O\u003c/code\u003e)과 최적화 수준 2(\u003ccode\u003e-OO\u003c/code\u003e) 모두 \u003ccode\u003e.pyo\u003c/code\u003e 확장자를 재사용하여 어떤 최적화 수준이 적용되었는지 알 수 없다는 점입니다.\u003c/p\u003e\n\u003cp\u003e이러한 모호성은 다음과 같은 문제를 야기합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e코드 실행의 불일치:\u003c/strong\u003e 사용자가 모든 \u003ccode\u003ePYO\u003c/code\u003e 파일이 동일한 최적화 수준으로 생성되었는지 확인하지 않으면, 인터프리터가 다른 최적화 수준으로 컴파일된 코드를 혼합하여 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e불필요한 파일 변경 (File Churn):\u003c/strong\u003e 최적화 수준을 변경하거나 이전에 생성된 \u003ccode\u003ePYO\u003c/code\u003e 파일의 최적화 수준을 확신할 수 없을 때마다 모든 \u003ccode\u003ePYO\u003c/code\u003e 파일을 삭제해야 하는 번거로움이 있습니다. 이는 불필요한 파일 쓰기 작업을 유발합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e사전 컴파일의 어려움:\u003c/strong\u003e \u003ccode\u003e.pyo\u003c/code\u003e 확장자가 여러 최적화 수준에 재사용되면서 모든 최적화 수준에 대한 바이트코드 파일을 미리 컴파일하는 것이 불가능합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e배포 효율성 저하:\u003c/strong\u003e 바이트코드 전용 모듈을 배포할 때 코드 난독화나 파일 크기 축소를 위해 \u003ccode\u003e.pyc\u003c/code\u003e와 \u003ccode\u003e.pyo\u003c/code\u003e 파일을 모두 배포하는 것은 비효율적입니다. 이 PEP에서는 비최적화 \u003ccode\u003e.pyc\u003c/code\u003e 파일 이름으로만 로드하도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e제안 (Proposal)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ePYO\u003c/code\u003e 파일의 모호성을 제거하기 위해, 이 PEP는 \u003ccode\u003ePYO\u003c/code\u003e 파일과 \u003ccode\u003e.pyo\u003c/code\u003e 확장자 개념을 없앨 것을 제안합니다. 최적화 수준을 명확히 하고 \u003ccode\u003e__pycache__\u003c/code\u003e 디렉터리에서 최적화된 바이트코드 파일을 불필요하게 다시 생성하는 것을 방지하기 위해, 바이트코드 파일 이름에 최적화 수준을 포함시킬 것입니다.\u003c/p\u003e\n\u003cp\u003e최적화 수준이 지정되지 않은 경우, 기존의 \u003ccode\u003e.pyc\u003c/code\u003e 파일 이름 형식이 그대로 사용됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, Python 3.5에서 \u003ccode\u003efoo.py\u003c/code\u003e라는 소스 파일은 인터프리터의 최적화 수준(없음, \u003ccode\u003e-O\u003c/code\u003e, \u003ccode\u003e-OO\u003c/code\u003e)에 따라 다음과 같은 바이트코드 파일을 가질 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e0 (최적화 없음):\u003c/strong\u003e \u003ccode\u003efoo.cpython-35.pyc\u003c/code\u003e (기존과 동일)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e1 (\u003ccode\u003e-O\u003c/code\u003e):\u003c/strong\u003e \u003ccode\u003efoo.cpython-35.opt-1.pyc\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2 (\u003ccode\u003e-OO\u003c/code\u003e):\u003c/strong\u003e \u003ccode\u003efoo.cpython-35.opt-2.pyc\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e현재 바이트코드 파일 이름은 \u003ccode\u003eimportlib.util.cache_from_source()\u003c/code\u003e 함수에 의해 PEP 3147에서 정의된 형식인 \u003ccode\u003e'{name}.{cache_tag}.pyc'\u003c/code\u003e를 사용하여 생성됩니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 최적화 수준이 지정된 경우 파일 이름 형식을 다음과 같이 변경할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e'{name}.{cache_tag}.opt-{optimization}.pyc'\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e여기서 \u003ccode\u003eopt-\u003c/code\u003e 접두사는 캐시 태그와 시각적으로 구분되며, 최적화 수준은 캐시 태그 뒤에 배치되어 모듈 이름과 캐시 태그를 기준으로 한 사전식 정렬 순서를 유지합니다. \u003ccode\u003eopt-\u003c/code\u003e는 자체 설명적이며, 숫자 \u003ccode\u003e0\u003c/code\u003e과의 혼동을 피하기 위해 선택되었습니다. 구분자로 하이픈 대신 마침표를 사용하여 최적화 수준이 인터프리터 버전의 일부가 아님을 명확히 합니다.\u003c/p\u003e\n\u003cp\u003e이 변경 사항은 \u003ccode\u003eimport\u003c/code\u003e 성능에 영향을 미치지 않습니다. \u003ccode\u003e__pycache__\u003c/code\u003e 디렉터리에 잠재적으로 더 많은 바이트코드 파일이 생길 수 있지만, import 시스템은 이미 인터프리터의 최적화 수준에 따라 단일 바이트코드 파일을 찾으므로 \u003ccode\u003estat\u003c/code\u003e 호출 횟수에는 변화가 없습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP의 잠재적인 단점은 \u003ccode\u003e.pyc\u003c/code\u003e 파일 수의 증가와 그에 따른 저장 공간 사용량 증가입니다. 그러나 이러한 문제가 되는 플랫폼의 경우 \u003ccode\u003esys.dont_write_bytecode\u003c/code\u003e를 사용하여 바이트코드 생성을 비활성화하고 오프라인으로 제어할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e구현 (Implementation)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003eimportlib\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eimportlib.util.cache_from_source()\u003c/code\u003e는 바이트코드 파일 경로를 노출하고 \u003ccode\u003eimportlib\u003c/code\u003e에 의해 직접 사용되므로 가장 중요한 변경이 필요합니다. Python 3.4의 함수 시그니처는 다음과 같습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimportlib.util.cache_from_source(path, debug_override=None)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e이 PEP는 Python 3.5에서 시그니처를 다음과 같이 변경할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimportlib.util.cache_from_source(path, debug_override=None, *, optimization=None)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e새로 도입된 키워드 전용 매개변수 \u003ccode\u003eoptimization\u003c/code\u003e은 파일 이름에 지정될 최적화 수준을 제어합니다. 인수가 \u003ccode\u003eNone\u003c/code\u003e이면 인터프리터의 현재 최적화 수준이 가정됩니다. \u003ccode\u003eoptimization\u003c/code\u003e에 전달되는 인수는 \u003ccode\u003estr()\u003c/code\u003e로 변환되며 \u003ccode\u003estr.isalnum()\u003c/code\u003e이 \u003ccode\u003eTrue\u003c/code\u003e여야 합니다. 빈 문자열이 전달되면 최적화 수준 추가가 억제되어 이 PEP 이전의 파일 이름 형식으로 돌아갑니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edebug_override\u003c/code\u003e 매개변수는 더 이상 사용되지 않을 것입니다. \u003ccode\u003eFalse\u003c/code\u003e 값은 \u003ccode\u003eoptimization=1\u003c/code\u003e과 동등하며, \u003ccode\u003eTrue\u003c/code\u003e 값은 \u003ccode\u003eoptimization=''\u003c/code\u003e를 나타냅니다. \u003ccode\u003edebug_override\u003c/code\u003e에 \u003ccode\u003eNone\u003c/code\u003e이 아닌 값이 주어지면 Deprecation Warning이 발생합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimportlib.machinery\u003c/code\u003e의 바이트코드 파일 접미사와 관련된 다양한 모듈 속성도 업데이트될 것입니다. \u003ccode\u003eDEBUG_BYTECODE_SUFFIXES\u003c/code\u003e와 \u003ccode\u003eOPTIMIZED_BYTECODE_SUFFIXES\u003c/code\u003e는 모두 더 이상 사용되지 않음으로 문서화되고 \u003ccode\u003eBYTECODE_SUFFIXES\u003c/code\u003e와 동일한 값으로 설정됩니다.\u003c/p\u003e\n\u003ch4\u003e표준 라이브러리의 나머지 부분\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003epy_compile\u003c/code\u003e 및 \u003ccode\u003ecompileall\u003c/code\u003e 모듈에 의해 노출되는 다양한 함수들은 새로운 바이트코드 파일 이름 의미론을 따르도록 업데이트될 것입니다. \u003ccode\u003ecompileall\u003c/code\u003e 모듈의 CLI는 직접적인 영향을 받지 않습니다.\u003c/p\u003e\n\u003ch3\u003e호환성 고려 사항 (Compatibility Considerations)\u003c/h3\u003e\n\u003cp\u003ePython 3.2부터 바이트코드 파일을 직접 조작하는 모든 코드는 이 변경 사항이 코드에 미치는 영향을 고려해야 합니다. \u003ccode\u003eimportlib.util.cache_from_source()\u003c/code\u003e의 \u003ccode\u003edebug_override\u003c/code\u003e 인수를 설정하던 코드는 최적화 수준 2의 바이트코드 파일 경로를 원할 경우 주의가 필요합니다.\u003c/p\u003e\n\u003cp\u003e바이트코드 전용 모듈을 배포하는 사람들은 \u003ccode\u003e.pyc\u003c/code\u003e 파일과 함께 \u003ccode\u003e.pyo\u003c/code\u003e 파일을 배포하는 것이 더 이상 유용하지 않으므로, 사용할 최적화 수준을 선택해야 합니다. 코드 난독화나 배포 크기 축소를 위해 단일 \u003ccode\u003e.pyc\u003c/code\u003e만 배포하는 것이 이러한 사용 사례에 유리할 것입니다. Python 3.5에서 바이트코드 파일의 매직 넘버가 변경되었기 때문에 기존 \u003ccode\u003e.pyo\u003c/code\u003e 파일을 지원할 필요가 없습니다.\u003c/p\u003e\n\u003ch3\u003e기각된 아이디어 (Rejected Ideas)\u003c/h3\u003e\n\u003ch4\u003eCPython에서 최적화 수준을 완전히 제거하는 것\u003c/h4\u003e\n\u003cp\u003e일부에서는 CPython의 다양한 최적화 수준을 수용하는 대신 완전히 제거해야 한다고 제안했습니다. 이 주장은 JIT와 같은 런타임 최적화를 통해 상당한 성능 향상을 얻을 수 있으며, 사전 실행 바이트코드 최적화를 통해서는 얻을 수 없다는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 아이디어는 기존 CPython의 최적화 수준이 유용하다고 생각하는 사람들이 존재한다는 사실을 무시하기 때문에 이 PEP에서 기각되었습니다.\u003c/p\u003e\n\u003ch4\u003e파일 이름에서 최적화 수준의 대체 형식\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eopt-\u003c/code\u003e 접두사를 사용하고 최적화 수준을 캐시 태그와 파일 확장자 사이에 배치하는 것이 중요하지 않다는 의견도 있었습니다. 다양한 다른 형식들이 고려되었지만, 파일 정렬 순서 변경, 캐시 태그와의 모호성, 또는 자체 설명 부족 등의 이유로 기각되었습니다. 비공식 설문조사 결과, PEP가 제안한 형식을 선호하는 경향이 분명했습니다.\u003c/p\u003e\n\u003ch4\u003e바이트코드 메타데이터에 최적화 수준 포함\u003c/h4\u003e\n\u003cp\u003e바이트코드의 최적화 수준을 파일 이름이 아닌 파일의 메타데이터에 포함해야 한다는 제안도 있었습니다. 이는 모든 인터프리터가 한 번에 하나의 바이트코드 사본만 가질 수 있음을 의미합니다. 최적화 수준을 변경하려면 바이트코드를 다시 작성해야 하지만, 관리해야 할 파일은 하나만 있을 것입니다.\u003c/p\u003e\n\u003cp\u003e이 제안은 Python이 종종 루트 수준 애플리케이션으로 설치되며, 이 경우 표준 라이브러리 모듈의 바이트코드 파일을 수정하는 것이 항상 가능하다는 사실 때문에 기각되었습니다. 이러한 상황에서 통합자(integrators)는 사용자에게 적합한 최적화 수준을 추측해야 할 것입니다. 여러 최적화 수준이 동시에 존재할 수 있도록 함으로써 통합자들이 추측할 필요 없이 사용자가 원하는 최적화 수준을 활용할 수 있게 됩니다.\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003ch2\u003e이 문서는 공개 도메인에 배치되었습니다.\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003ePEP 488 요약:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ePEP 488은 Python에서 \u003ccode\u003e.pyo\u003c/code\u003e 파일 개념을 제거하고 모든 최적화된 바이트코드 파일을 \u003ccode\u003e.pyc\u003c/code\u003e 확장자로 통합하는 것을 제안합니다. 기존에는 최적화 수준에 따라 \u003ccode\u003e.pyc\u003c/code\u003e와 \u003ccode\u003e.pyo\u003c/code\u003e로 나뉘었지만, \u003ccode\u003e.pyo\u003c/code\u003e 파일은 최적화 수준 1(-O)과 2(-OO)를 구분하지 못해 모호성을 야기하고 불필요한 파일 관리를 초래했습니다. 이 PEP는 이러한 문제를 해결하기 위해 최적화 수준을 바이트코드 파일 이름(예: \u003ccode\u003efoo.cpython-35.opt-1.pyc\u003c/code\u003e)에 명시적으로 포함하도록 변경합니다. 이는 \u003ccode\u003eimportlib\u003c/code\u003e 모듈과 표준 라이브러리의 관련 함수들을 업데이트하며, \u003ccode\u003edebug_override\u003c/code\u003e 매개변수를 비활성화합니다. 이로 인해 파일 수가 증가할 수 있지만, 호환성 및 명확성 측면에서 이점을 제공합니다.## PEP 488 – PYO 파일 제거\u003c/p\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 Python에서 PYO 파일 개념을 제거하고, 최적화 수준을 바이트코드 저장소 디렉터리 내의 PYC 파일 이름에 포함시켜 바이트코드 파일의 최적화 수준별 분리 지원을 유지할 것을 제안합니다.\u003c/p\u003e\n\u003ch3\u003e배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003e현재 Python의 바이트코드 파일은 \u003ccode\u003e.pyc\u003c/code\u003e와 \u003ccode\u003e.pyo\u003c/code\u003e 두 가지 형태로 존재합니다. 인터프리터 시작 시 최적화 수준이 지정되지 않으면(\u003ccode\u003e.O\u003c/code\u003e 옵션 미지정) \u003ccode\u003e.pyc\u003c/code\u003e 파일이 생성되고 읽히며, \u003ccode\u003e-O\u003c/code\u003e 또는 \u003ccode\u003e-OO\u003c/code\u003e와 같은 최적화 수준이 지정되면 \u003ccode\u003e.pyo\u003c/code\u003e 파일이 읽고 쓰입니다.\u003c/p\u003e\n\u003cp\u003e문제는 \u003ccode\u003e.pyo\u003c/code\u003e 파일이 최적화 수준 1(\u003ccode\u003e-O\u003c/code\u003e)과 최적화 수준 2(\u003ccode\u003e-OO\u003c/code\u003e) 모두에 동일하게 사용되어, 해당 파일이 어떤 최적화 수준으로 생성되었는지 명확히 알 수 없다는 점입니다. 이러한 모호성은 다음과 같은 문제를 야기합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e최적화 수준 혼동:\u003c/strong\u003e 사용자가 주의하지 않으면 인터프리터가 다른 최적화 수준으로 컴파일된 코드를 혼합하여 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e불필요한 파일 재생성:\u003c/strong\u003e 최적화 수준을 변경하거나 기존 \u003ccode\u003e.pyo\u003c/code\u003e 파일의 최적화 수준을 확신할 수 없을 때마다 모든 \u003ccode\u003e.pyo\u003c/code\u003e 파일을 삭제해야 하는 번거로움이 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e사전 컴파일 제약:\u003c/strong\u003e \u003ccode\u003e.pyo\u003c/code\u003e 확장자가 여러 최적화 수준에 재사용되면서 모든 최적화 수준에 대한 바이트코드 파일을 미리 컴파일하는 것이 불가능합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e배포 비효율성:\u003c/strong\u003e 바이트코드 전용 모듈을 배포할 때 \u003ccode\u003e.pyc\u003c/code\u003e와 \u003ccode\u003e.pyo\u003c/code\u003e 파일을 모두 배포하는 것은 비효율적입니다. 이 PEP에서는 비최적화 \u003ccode\u003e.pyc\u003c/code\u003e 파일 이름으로만 로드하도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e제안 (Proposal)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003ePYO\u003c/code\u003e 파일의 모호성을 제거하기 위해 \u003ccode\u003e.pyo\u003c/code\u003e 파일과 확장자 개념을 없앨 것을 제안합니다. 대신, 최적화 수준을 바이트코드 파일 이름에 포함시켜 명확성을 확보하고 \u003ccode\u003e__pycache__\u003c/code\u003e 디렉터리에서 불필요한 파일 재생성을 피합니다.\u003c/p\u003e\n\u003cp\u003e최적화 수준이 지정되지 않은 경우, 기존의 \u003ccode\u003e.pyc\u003c/code\u003e 파일 이름 형식이 그대로 사용됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e변경될 바이트코드 파일 이름 예시 (Python 3.5, \u003ccode\u003efoo.py\u003c/code\u003e 기준):\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e0 (최적화 없음):\u003c/strong\u003e \u003ccode\u003efoo.cpython-35.pyc\u003c/code\u003e (변경 없음)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e1 (\u003ccode\u003e-O\u003c/code\u003e):\u003c/strong\u003e \u003ccode\u003efoo.cpython-35.opt-1.pyc\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2 (\u003ccode\u003e-OO\u003c/code\u003e):\u003c/strong\u003e \u003ccode\u003efoo.cpython-35.opt-2.pyc\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e현재 바이트코드 파일 이름은 \u003ccode\u003eimportlib.util.cache_from_source()\u003c/code\u003e 함수에 의해 \u003ccode\u003e'{name}.{cache_tag}.pyc'\u003c/code\u003e 형식으로 생성되는데, 이 PEP는 최적화 수준이 지정된 경우 다음 형식으로 변경할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e'{name}.{cache_tag}.opt-{optimization}.pyc'\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eopt-\u003c/code\u003e 접두사는 캐시 태그와 시각적으로 구분되며, 최적화 수준은 캐시 태그 뒤에 배치되어 모듈 이름과 캐시 태그를 기준으로 한 사전식 정렬 순서를 유지합니다. 이 변경 사항은 \u003ccode\u003eimport\u003c/code\u003e 성능에 영향을 미치지 않으며, \u003ccode\u003e__pycache__\u003c/code\u003e 디렉터리 내 파일 수 증가로 인한 저장 공간 사용량 증가는 \u003ccode\u003esys.dont_write_bytecode\u003c/code\u003e를 통해 제어할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e구현 (Implementation)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003eimportlib\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eimportlib.util.cache_from_source()\u003c/code\u003e 함수의 시그니처가 Python 3.5에서 다음과 같이 변경됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimportlib.util.cache_from_source(path, debug_override=None, *, optimization=None)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e새로운 키워드 전용 매개변수 \u003ccode\u003eoptimization\u003c/code\u003e은 파일 이름에 포함될 최적화 수준을 제어합니다. \u003ccode\u003edebug_override\u003c/code\u003e 매개변수는 더 이상 사용되지 않으며 Deprecation Warning이 발생할 것입니다. \u003ccode\u003eimportlib.machinery\u003c/code\u003e의 \u003ccode\u003eDEBUG_BYTECODE_SUFFIXES\u003c/code\u003e와 \u003ccode\u003eOPTIMIZED_BYTECODE_SUFFIXES\u003c/code\u003e도 \u003ccode\u003eBYTECODE_SUFFIXES\u003c/code\u003e와 동일하게 설정되며 더 이상 사용되지 않음으로 문서화됩니다.\u003c/p\u003e\n\u003ch4\u003e표준 라이브러리의 나머지 부분\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003epy_compile\u003c/code\u003e 및 \u003ccode\u003ecompileall\u003c/code\u003e 모듈의 함수들은 새로운 바이트코드 파일 이름 의미론을 따르도록 업데이트될 것입니다.\u003c/p\u003e\n\u003ch3\u003e호환성 고려 사항 (Compatibility Considerations)\u003c/h3\u003e\n\u003cp\u003ePython 3.2부터 바이트코드 파일을 직접 조작하는 모든 코드는 이 변경 사항의 영향을 고려해야 합니다. 특히 \u003ccode\u003eimportlib.util.cache_from_source()\u003c/code\u003e의 \u003ccode\u003edebug_override\u003c/code\u003e 인수를 설정하던 코드는 최적화 수준 2의 바이트코드 파일 경로를 다룰 때 주의가 필요합니다.\u003c/p\u003e\n\u003cp\u003e바이트코드 전용 모듈을 배포하는 경우, \u003ccode\u003e.pyc\u003c/code\u003e 파일과 함께 \u003ccode\u003e.pyo\u003c/code\u003e 파일을 배포하는 것이 더 이상 유용하지 않으므로, 사용할 최적화 수준을 선택하여 단일 \u003ccode\u003e.pyc\u003c/code\u003e 파일만 배포해야 합니다.\u003c/p\u003e\n\u003ch3\u003e기각된 아이디어 (Rejected Ideas)\u003c/h3\u003e\n\u003ch4\u003eCPython에서 최적화 수준을 완전히 제거하는 것\u003c/h4\u003e\n\u003cp\u003e런타임 최적화가 더 효율적이라는 이유로 CPython의 최적화 수준을 완전히 제거하자는 제안이 있었으나, 기존 최적화 수준이 유용하다고 생각하는 사용자들이 존재하며 다른 Python 인터프리터에서도 이 PEP의 제안이 유용할 수 있다는 점을 들어 기각되었습니다.\u003c/p\u003e\n\u003ch4\u003e파일 이름에서 최적화 수준의 대체 형식\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eopt-\u003c/code\u003e 접두사 및 최적화 수준 배치에 대한 다양한 대체 형식들이 고려되었으나, 파일 정렬 순서 변경, 캐시 태그와의 모호성, 자체 설명 부족 등의 이유로 현재 PEP가 제안하는 형식이 채택되었습니다.\u003c/p\u003e\n\u003ch4\u003e바이트코드 메타데이터에 최적화 수준 포함\u003c/h4\u003e\n\u003cp\u003e바이트코드의 최적화 수준을 파일 이름이 아닌 파일의 메타데이터에 포함하자는 제안도 있었으나, Python이 루트 수준 애플리케이션으로 설치되는 경우가 많아 표준 라이브러리 모듈의 바이트코드 파일을 수정할 때 통합자들이 적절한 최적화 수준을 추측해야 하는 문제가 발생할 수 있어 기각되었습니다. 여러 최적화 수준이 동시에 존재할 수 있도록 하여 사용자가 원하는 최적화 수준을 자유롭게 활용할 수 있도록 하는 것이 더 바람직하다고 판단되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 488 - Elimination of PYO files\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:34:01+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"page__taxonomy mb-4\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"카테고리\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":\"Python\"}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":\"PEP\"}]]]}],[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]]}]]}]}]}]\nb:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett26"])</script><script>self.__next_f.push([1,"33\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"21\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>