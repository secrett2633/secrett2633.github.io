<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js"/><script src="/secrett2633.github.io/_next/static/chunks/fd9d1056-62aaf4b921c84028.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/23-ca4408d024135d8d.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/main-app-fa660020ba1e0b6e.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/231-c4b666723e6aae68.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/layout-8808afda01b7a1b7.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="next-size-adjust"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/secrett2633.github.io/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_9012cf layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/secrett2633.github.io">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 506 - Adding A Secrets Module To The Standard Library</h1><div class="page__meta"><time dateTime="2025-09-26 22:53:00+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0506/">PEP 506 - Adding A Secrets Module To The Standard Library</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 19-Sep-2015</p>
</blockquote>
<h2>PEP 506 – 표준 라이브러리에 <code>secrets</code> 모듈 추가</h2>
<h3>개요 (Abstract)</h3>
<p>이 PEP(Python Enhancement Proposal)는 토큰 생성과 같은 일반적인 보안 관련 기능을 위한 모듈을 Python 표준 라이브러리에 추가할 것을 제안합니다.</p>
<h3>정의 (Definitions)</h3>
<p>이 제안서에서 사용되는 몇 가지 일반적인 약어는 다음과 같습니다:</p>
<ul>
<li><strong>PRNG (Pseudo Random Number Generator):</strong> 특정 바람직한 통계적 속성을 가진 무작위처럼 보이는 숫자를 생성하는 데 사용되는 결정론적 알고리즘입니다.</li>
<li><strong>CSPRNG (Cryptographically Strong Pseudo Random Number Generator):</strong> 예측에 강한 무작위처럼 보이는 숫자를 생성하는 데 사용되는 알고리즘입니다.</li>
<li><strong>MT (Mersenne Twister):</strong> 현재 <code>random</code> 모듈에서 기본값으로 사용되는, 광범위하게 연구된 PRNG입니다.</li>
</ul>
<h3>도입 배경 (Rationale)</h3>
<p>이 제안은 Python의 표준 라이브러리가 개발자들이 부주의하게 심각한 보안 오류를 범하기 너무 쉽게 만든다는 우려 때문에 시작되었습니다. OpenBSD의 창립자인 Theo de Raadt는 Guido van Rossum에게 비밀번호, 보안 토큰, 세션 키 등과 같은 민감한 정보를 생성하는 데 MT를 사용하는 것에 대한 우려를 표명했습니다.</p>
<p><code>random</code> 모듈의 문서에는 기본값이 보안 목적에 적합하지 않다고 명시되어 있지만, 많은 Python 개발자들이 이 경고를 놓치거나, 무시하거나, 오해할 수 있다고 강하게 믿어집니다. 특히 다음과 같은 경우들이 있습니다:</p>
<ul>
<li>개발자들이 문서를 읽지 않아 경고를 보지 못했을 수 있습니다.</li>
<li>자신이 사용하는 모듈의 특정 용도가 보안상 문제를 일으킬 수 있다는 것을 인지하지 못할 수 있습니다.</li>
<li>문제의 존재를 인지하지 못하고, 올바른 관행을 제공하지 않는 웹사이트에서 코드를 복사(또는 기술을 학습)했을 수 있습니다.</li>
</ul>
<p>Google에서 "python how to generate passwords"를 검색했을 때 첫 번째 결과는 <code>random</code> 모듈의 기본 함수를 사용하는 튜토리얼입니다. 웹 애플리케이션 사용을 의도한 것은 아니지만, 비슷한 기술이 해당 상황에서 사용될 가능성이 높습니다. 두 번째 결과는 비밀번호 생성에 대한 StackOverflow 질문입니다. 채택된 답변을 포함하여 제공된 대부분의 답변은 기본 함수를 사용합니다. 한 사용자가 기본값이 쉽게 손상될 수 있다고 경고했을 때, "너무 걱정하는 것 같다"는 답변을 받기도 했습니다.</p>
<p>이는 기존 <code>random</code> 모듈이 (예를 들어) 비밀번호나 보안 토큰을 생성할 때 "매력적인 위험 (attractive nuisance)"이 될 수 있음을 강력히 시사합니다.</p>
<h3>제안 (Proposal)</h3>
<p>다른 제안들은 <code>random</code> 모듈의 기본 PRNG를 변경하여, 개발자가 보안에 대해 생각할 필요 없이 구축할 수 있는 "기본적으로 안전한 (secure by default)" 암호학적으로 강력한 프리미티브를 제공하는 데 초점을 맞췄습니다. (아래 "대안" 섹션 참고) 이 PEP는 다른 접근 방식을 제안합니다:</p>
<p>표준 라이브러리는 이미 암호학적으로 강력한 프리미티브를 제공하지만, 많은 사용자는 그것이 존재하는지, 언제 사용해야 하는지 모릅니다. 암호화에 익숙하지 않은 사용자에게 보안 코드를 작성하도록 요구하는 대신, 표준 라이브러리는 보안 토큰 생성과 같은 가장 일반적인 요구 사항에 대한 "배터리 포함 (batteries-included)" 솔루션을 포함해야 합니다. 이 코드는 직접적으로 필요를 충족시키고("비밀번호 재설정 토큰을 어떻게 생성하나요?"), 개발자가 학습할 수 있는 허용 가능한 관행의 예시 역할을 할 것입니다.</p>
<p>이를 위해 이 PEP는 <code>secrets</code>라는 이름의 새 모듈을 표준 라이브러리에 추가할 것을 제안합니다. 이 모듈은 보안과 관련된 일반적인 활동을 위한 즉시 사용 가능한 함수 세트와 일부 하위 수준 프리미티브를 포함할 것입니다.</p>
<p><code>secrets</code>는 비밀로 유지되어야 하는 모든 것(비밀번호, 토큰 등)을 다루는 데 주력하는 모듈이 되고, <code>random</code> 모듈은 하위 호환성을 유지할 것을 제안합니다.</p>
<h3>API 및 구현 (API and Implementation)</h3>
<p>이 PEP는 <code>secrets</code> 모듈에 다음과 같은 함수들을 제안합니다:</p>
<ul>
<li><strong>토큰 생성 함수:</strong> 비밀번호 복구, 세션 키 등에 적합한 토큰을 다음 형식으로 생성하는 함수입니다.
<ul>
<li><code>bytes</code> 형식: <code>secrets.token_bytes</code></li>
<li>16진수 문자열 형식: <code>secrets.token_hex</code></li>
<li>URL-safe Base-64 인코딩 문자열 형식: <code>secrets.token_urlsafe</code></li>
</ul>
</li>
<li><strong>시스템 CSPRNG에 대한 제한된 인터페이스:</strong> <code>os.urandom</code> 또는 <code>random.SystemRandom</code>을 직접 사용하여 시스템 CSPRNG에 접근합니다. <code>random</code> 모듈과 달리, 이는 시딩, 상태 가져오기/설정 또는 비균일 분포를 위한 메서드를 제공할 필요가 없습니다. 다음을 제공해야 합니다.
<ul>
<li>시퀀스에서 항목을 선택하는 함수: <code>secrets.choice</code></li>
<li>주어진 수의 무작위 비트 및/또는 바이트를 정수 형태로 생성하는 함수: <code>secrets.randbits</code></li>
<li>0부터 주어진 상한 미만의 범위에서 무작위 정수를 반환하는 함수: <code>secrets.randbelow</code></li>
</ul>
</li>
<li><strong>타이밍 공격에 강한 비교 함수:</strong> 텍스트 또는 바이트 다이제스트의 동등성을 비교하는 함수: <code>secrets.compare_digest</code></li>
</ul>
<p>합의된 의견은 이러한 용도를 지원하기 위해 <code>random</code> 모듈에 새로운 CSPRNG를 추가할 필요가 없으며, <code>SystemRandom</code>이면 충분하다는 것입니다.</p>
<p>Alyssa (Nick) Coghlan과 Tim Peters는 몇 가지 예시 구현과 최소한의 API를 제안했습니다. "cryptography" 모듈의 이슈 트래커에서도 이 아이디어가 논의되었습니다. 다음 의사 코드(pseudo-code)는 실제 구현의 시작점으로 간주될 수 있습니다:</p>
<pre><code class="language-python">from random import SystemRandom
from hmac import compare_digest
import os
import binascii
import base64

_sysrand = SystemRandom()
randbits = _sysrand.getrandbits
choice = _sysrand.choice

def randbelow(exclusive_upper_bound):
    return _sysrand._randbelow(exclusive_upper_bound)

DEFAULT_ENTROPY = 32 # bytes

def token_bytes(nbytes=None):
    if nbytes is None:
        nbytes = DEFAULT_ENTROPY
    return os.urandom(nbytes)

def token_hex(nbytes=None):
    return binascii.hexlify(token_bytes(nbytes)).decode('ascii')

def token_urlsafe(nbytes=None):
    tok = token_bytes(nbytes)
    return base64.urlsafe_b64encode(tok).rstrip(b'=').decode('ascii')
</code></pre>
<p><code>secrets</code> 모듈 자체는 순수 Python으로 구현될 것이며, 다른 Python 구현체들도 변경 없이 쉽게 사용하거나 필요에 따라 조정할 수 있습니다.</p>
<h4>기본 인자 (Default arguments)</h4>
<p>"내 토큰은 몇 바이트여야 하는가?"는 어려운 질문입니다. <code>token_*</code> 함수에 기본 엔트로피(entropy) 양을 제공함으로써 이 질문에 도움을 줄 수 있습니다. <code>nbytes</code> 인자가 <code>None</code>이거나 주어지지 않으면 기본 엔트로피가 사용됩니다. 이 기본값은 중간 수준의 보안 사용에 충분히 안전할 것으로 예상되는 크기여야 하지만, 향후 유지보수 릴리스에서도 변경될 수 있습니다.</p>
<h4>명명 규칙 (Naming conventions)</h4>
<p>모듈에서 사용되는 명명 규칙, 즉 "randrange"와 같은 C 스타일 명명 규칙을 사용할지 "random_range"와 같은 Pythonic한 이름을 사용할지에 대한 질문이 있었습니다.</p>
<p>비공개 <code>SystemRandom</code> 인스턴스의 단순히 바인딩된 메서드(예: <code>randrange</code>)이거나 그에 대한 얇은 래퍼(wrapper)인 함수는 익숙한 이름을 유지해야 합니다. <code>token_*</code> 함수와 같이 새로운 기능은 더 Pythonic한 이름을 사용할 것입니다.</p>
<h3>대안 (Alternatives)</h3>
<p>한 가지 대안은 <code>random</code> 모듈에서 제공하는 기본 PRNG를 변경하는 것이었습니다. 이 제안은 상당한 회의론과 전면적인 반대에 부딪혔습니다:</p>
<ul>
<li>CSPRNG가 현재 PRNG(MT의 경우 이미 상당히 느림)보다 느릴 수 있다는 우려가 있습니다.</li>
<li>일부 애플리케이션(과학 시뮬레이션, 게임 플레이 재현 등)은 PRNG를 알려진 상태로 시딩(seeding)할 수 있는 능력을 필요로 하지만, CSPRNG는 설계상 이러한 기능을 제공하지 않습니다.</li>
<li><code>random</code> 모듈의 또 다른 주요 용도는 초보자가 작성하는 간단한 "숫자 맞추기" 게임이며, 많은 사람들이 <code>random</code> 모듈을 변경하여 이를 더 어렵게 만드는 것을 꺼립니다.</li>
<li><code>random</code> 모듈에서 MT를 제거하려는 제안은 없었지만, 비-CSPRNG를 선택하거나 하위 호환되지 않는 변경 사항에 대한 상당한 반대가 있었습니다.</li>
<li>MT에 대한 입증된 공격은 일반적으로 PHP 애플리케이션을 대상으로 합니다. PHP 버전의 MT는 열악한 시딩 기술로 인해 Python 버전보다 훨씬 쉬운 공격 대상이라고 여겨집니다. 따라서 Python 애플리케이션에 대한 입증된 공격 없이는 많은 사람들이 하위 호환되지 않는 변경에 반대합니다.</li>
</ul>
<p>Alyssa Coghlan은 이전에 기본적으로 시스템 CSPRNG를 사용하는 전역적으로 구성 가능한 PRNG에 대한 제안을 했지만, 이 제안을 선호하여 철회했습니다.</p>
<h3>다른 언어와의 비교 (Comparison To Other Languages)</h3>
<ul>
<li><strong>PHP:</strong> PHP는 기본적으로 현재 마이크로초 시간을 기반으로 13자 문자열을 반환하는 <code>uniqid</code> 함수를 포함합니다. PHP 문서는 이 함수가 보안 목적에 적합하지 않다고 경고합니다. 하지만 여러 성숙하고 잘 알려진 PHP 애플리케이션들이 이 기능을 보안 목적으로 사용합니다. PHP 5.3 이상은 <code>openssl_random_pseudo_bytes</code> 함수도 포함합니다. 이 함수는 주어진 길이의 의사 무작위 바이트 문자열과 해당 문자열이 암호학적으로 강력한지 여부를 나타내는 부울 플래그를 반환합니다.</li>
<li><strong>JavaScript:</strong> <code>Math.random</code>은 암호학적 목적에 부적합한 심각한 약점에도 불구하고 자주 사용됩니다. 최근 몇 년 동안 대부분의 브라우저는 <code>window.crypto.getRandomValues</code>를 지원하게 되었습니다. Node.js는 <code>crypto</code> 모듈을 제공하며, <code>crypto.randomBytes</code>와 같은 무작위 바이트 생성 함수를 포함합니다.</li>
<li><strong>Ruby:</strong> Ruby 표준 라이브러리는 <code>SecureRandom</code> 모듈을 포함하며 <code>base64</code>, <code>hex</code>, <code>random_bytes</code>, <code>random_number</code>, <code>urlsafe_base64</code>, <code>uuid</code>와 같은 메서드를 제공합니다.</li>
</ul>
<h3>모듈 이름은 무엇이 되어야 하는가? (What Should Be The Name Of The Module?)</h3>
<p>"Namespaces are one honking great idea"라는 Python의 Zen을 인용하며 "random.safe" 서브모듈을 추가하자는 제안이 있었습니다. 그러나 Zen의 저자인 Tim Peters는 이 아이디어에 반대하며 최상위 모듈을 권장했습니다. python-ideas 메일링 리스트의 논의에서 "secrets"라는 이름은 일부 승인을 받았고, 강력한 반대는 없었습니다. 현재 동일한 이름의 서드파티 모듈이 존재하지만, 사용되지 않고 버려진 것으로 보입니다.</p>
<h3>자주 묻는 질문 (Frequently Asked Questions)</h3>
<ul>
<li><strong>Q: 이것이 실제로 문제인가요? MT는 출력을 아무도 예측할 수 없을 만큼 충분히 무작위 아닌가요?</strong>
<ul>
<li><strong>A:</strong> 보안 전문가들 사이에서 MT는 보안 컨텍스트에서 안전하지 않다는 것이 합의된 의견입니다. MT의 내부 상태를 재구성하는 것은 어렵지 않으며, 따라서 과거와 미래의 모든 값을 예측할 수 있습니다. MT를 무작위성에 사용하는 시스템에 대한 여러 알려진 실제 공격들이 있습니다.</li>
</ul>
</li>
<li><strong>Q: PHP에 대한 공격은 그렇다 쳐도, Python 소프트웨어에 대한 알려진 공격이 있나요?</strong>
<ul>
<li><strong>A:</strong> 네, Zope와 Plone에서 최소한 취약점이 있었습니다. Hanno Schlichting은 다음과 같이 언급했습니다:
"Plone과 Zope 컨텍스트에서 실제 공격이 시연되었지만, 더 이상 제대로 된 링크를 찾을 수 없습니다. 제가 기억하기로는 Plone이 무작위 숫자를 생성하고 '죄송합니다, 오류가 발생했습니다. 문제가 &#x3C;무작위 숫자>로 기록되었습니다. 문의 시 이 번호를 포함해주세요.' 와 같은 오류 페이지에 이를 노출했습니다. 이는 누구나 이 페이지에 대량의 요청을 하여 MT 상태를 재구성하기에 충분한 무작위 값을 얻을 수 있게 했습니다. 여러 보안 관련 모듈이 <code>system random</code> 대신 <code>random</code>을 사용했기 때문에(쿠키 세션 ID, 비밀번호 재설정 링크, 인증 토큰 등), 공격자는 이 모든 것을 뚫을 수 있었습니다."
Christian Heimes는 2012년에 이 문제를 Zope 보안 팀에 보고했으며, 최소한 두 가지 관련 CVE 취약점과 Django에서 이 문제에 대한 최소한 한 가지 해결책이 있습니다.</li>
</ul>
</li>
<li><strong>Q: 이것이 SSL과 같은 전문 암호화 소프트웨어의 대안인가요?</strong>
<ul>
<li><strong>A:</strong> 아닙니다. 이것은 "배터리 포함" 솔루션이지, 완전한 기능을 갖춘 "원자력 발전소"가 아닙니다. 이는 일부 기본적인 보안 오류를 완화하기 위한 것이며, 모든 보안 관련 문제에 대한 해결책은 아닙니다. Alyssa Coghlan이 그녀의 이전 제안을 언급하며 말했듯이:
"...사람들은 보안에 민감한 소프트웨어에 <code>cryptography.io</code>와 같은 것을 사용하는 법을 배우는 것이 훨씬 낫습니다. 따라서 이 변경은 수백만 명의 현재 및 미래의 Python 개발자 중 상당수가 그렇게 하지 않을 것이라는 불가피한 현실을 고려할 때, 단순히 피해 완화에 관한 것입니다."</li>
</ul>
</li>
<li><strong>Q: 비밀번호 생성기는 어떤가요?</strong>
<ul>
<li><strong>A:</strong> 비밀번호 생성기의 요구 사항이 너무 다양하여 표준 라이브러리에 적합하지 않다는 것이 합의된 의견입니다. 모듈의 초기 릴리스에는 비밀번호 생성기가 포함되지 않을 것이며, 대신 문서에 레시피(예: <code>itertools</code> 모듈의 레시피) 형태로 제공될 것입니다.</li>
</ul>
</li>
<li><strong>Q: <code>secrets</code>는 Linux에서 <code>/dev/random</code> (블록킹)을 사용할까요, 아니면 <code>/dev/urandom</code> (논블록킹)을 사용할까요? 다른 플랫폼은 어떤가요?</strong>
<ul>
<li><strong>A:</strong> <code>secrets</code>는 <code>os.urandom</code> 및 <code>random.SystemRandom</code>을 기반으로 합니다. 이들은 운영 체제의 가장 좋은 암호학적 무작위성 소스에 대한 인터페이스입니다. Linux에서는 <code>/dev/urandom</code>일 수 있고, Windows에서는 <code>CryptGenRandom()</code>일 수 있습니다. 자세한 구현 내용은 문서 및/또는 소스 코드를 참조하세요.</li>
</ul>
</li>
</ul>
<h3>참고 자료 (References)</h3>
<p>https://mail.python.org/pipermail/python-ideas/2015-September/035820.html
https://docs.python.org/3/library/random.html
작성일 기준. Google 검색어는 사용자 모르게 자동 맞춤화될 수 있으므로 일부 독자는 다른 결과를 볼 수 있습니다.
http://interactivepython.org/runestone/static/everyday/2013/01/3_password.html
http://stackoverflow.com/questions/3854692/generate-password-in-python
http://stackoverflow.com/questions/3854692/generate-password-in-python/3854766#3854766
https://mail.python.org/pipermail/python-ideas/2015-September/036238.html
최소한 소스 코드와 문서를 읽으려는 동기가 있는 사람들.
많은 논의 끝에 Guido는 모듈이 <code>randbelow</code>만 제공하고 <code>randrange</code> 또는 <code>randint</code>와 같은 유사한 함수는 제공할 필요가 없다고 결정했습니다. http://code.activestate.com/lists/python-dev/138375/
https://mail.python.org/pipermail/python-ideas/2015-September/036271.html
https://mail.python.org/pipermail/python-ideas/2015-September/036350.html
https://github.com/pyca/cryptography/issues/2347
https://bitbucket.org/sdaprano/secrets
https://mail.python.org/pipermail/python-ideas/2015-September/036517.html, https://mail.python.org/pipermail/python-ideas/2015-September/036515.html
https://mail.python.org/pipermail/python-ideas/2015-September/036474.html
링크 필요.
기본적으로 PHP는 시간을 사용하여 MT PRNG를 시딩하는데(인용 필요), 이는 공격자가 악용할 수 있습니다. 반면 Python은 시스템 CSPRNG의 출력을 사용하여 PRNG를 시딩하며, 이는 악용하기 훨씬 더 어렵다고 여겨집니다.
http://php.net/manual/en/function.uniqid.php
http://php.net/manual/en/function.openssl-random-pseudo-bytes.php
자원 봉사자와 패치 환영.
http://ifsec.blogspot.fr/2012/05/cross-domain-mathrandom-prediction.html
https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues
https://nodejs.org/api/crypto.html
http://ruby-doc.org/stdlib-2.1.2/libdoc/securerandom/rdoc/SecureRandom.html
https://mail.python.org/pipermail/python-ideas/2015-September/036254.html
https://pypi.python.org/pypi/secrets
https://jazzy.id.au/2010/09/22/cracking_random_number_generators_part_3.html
https://mail.python.org/pipermail/python-ideas/2015-September/036077.html
https://media.blackhat.com/bh-us-12/Briefings/Argyros/BH_US_12_Argyros_PRNG_WP.pdf
개인 통신, 2016-08-24.
https://bugs.launchpad.net/zope2/+bug/1071067
http://www.cvedetails.com/cve/CVE-2012-5508/, http://www.cvedetails.com/cve/CVE-2012-6661/
https://github.com/django/django/commit/1525874238fd705ec17a066291935a9316bd3044
https://mail.python.org/pipermail/python-ideas/2015-September/036157.html
https://mail.python.org/pipermail/python-ideas/2015-September/036476.html, https://mail.python.org/pipermail/python-ideas/2015-September/036478.html
https://mail.python.org/pipermail/python-ideas/2015-September/036488.html
http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/, http://www.2uo.de/myths-about-urandom/</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy mb-4"><h4 class="text-sm font-medium text-gray-900 mb-2">카테고리</h4><span class="page__taxonomy-item">Python</span><span class="page__taxonomy-item">PEP</span></div><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[4281,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"185\",\"static/chunks/app/layout-8808afda01b7a1b7.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/506\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"iV6XySbMHIJ3imQdvgy3I\",\"assetPrefix\":\"/secrett2633.github.io\",\"initialCanonicalUrl\":\"/python/pep/506/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/506\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"506\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/506\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"32x32\",\"href\":\"/favicon-32x32.png\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"16x16\",\"href\":\"/favicon-16x16.png\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_9012cf layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T4f05,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0506/\"\u003ePEP 506 - Adding A Secrets Module To The Standard Library\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 19-Sep-2015\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 506 – 표준 라이브러리에 \u003ccode\u003esecrets\u003c/code\u003e 모듈 추가\u003c/h2\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP(Python Enhancement Proposal)는 토큰 생성과 같은 일반적인 보안 관련 기능을 위한 모듈을 Python 표준 라이브러리에 추가할 것을 제안합니다.\u003c/p\u003e\n\u003ch3\u003e정의 (Definitions)\u003c/h3\u003e\n\u003cp\u003e이 제안서에서 사용되는 몇 가지 일반적인 약어는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePRNG (Pseudo Random Number Generator):\u003c/strong\u003e 특정 바람직한 통계적 속성을 가진 무작위처럼 보이는 숫자를 생성하는 데 사용되는 결정론적 알고리즘입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCSPRNG (Cryptographically Strong Pseudo Random Number Generator):\u003c/strong\u003e 예측에 강한 무작위처럼 보이는 숫자를 생성하는 데 사용되는 알고리즘입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMT (Mersenne Twister):\u003c/strong\u003e 현재 \u003ccode\u003erandom\u003c/code\u003e 모듈에서 기본값으로 사용되는, 광범위하게 연구된 PRNG입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e도입 배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003e이 제안은 Python의 표준 라이브러리가 개발자들이 부주의하게 심각한 보안 오류를 범하기 너무 쉽게 만든다는 우려 때문에 시작되었습니다. OpenBSD의 창립자인 Theo de Raadt는 Guido van Rossum에게 비밀번호, 보안 토큰, 세션 키 등과 같은 민감한 정보를 생성하는 데 MT를 사용하는 것에 대한 우려를 표명했습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003erandom\u003c/code\u003e 모듈의 문서에는 기본값이 보안 목적에 적합하지 않다고 명시되어 있지만, 많은 Python 개발자들이 이 경고를 놓치거나, 무시하거나, 오해할 수 있다고 강하게 믿어집니다. 특히 다음과 같은 경우들이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e개발자들이 문서를 읽지 않아 경고를 보지 못했을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e자신이 사용하는 모듈의 특정 용도가 보안상 문제를 일으킬 수 있다는 것을 인지하지 못할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e문제의 존재를 인지하지 못하고, 올바른 관행을 제공하지 않는 웹사이트에서 코드를 복사(또는 기술을 학습)했을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eGoogle에서 \"python how to generate passwords\"를 검색했을 때 첫 번째 결과는 \u003ccode\u003erandom\u003c/code\u003e 모듈의 기본 함수를 사용하는 튜토리얼입니다. 웹 애플리케이션 사용을 의도한 것은 아니지만, 비슷한 기술이 해당 상황에서 사용될 가능성이 높습니다. 두 번째 결과는 비밀번호 생성에 대한 StackOverflow 질문입니다. 채택된 답변을 포함하여 제공된 대부분의 답변은 기본 함수를 사용합니다. 한 사용자가 기본값이 쉽게 손상될 수 있다고 경고했을 때, \"너무 걱정하는 것 같다\"는 답변을 받기도 했습니다.\u003c/p\u003e\n\u003cp\u003e이는 기존 \u003ccode\u003erandom\u003c/code\u003e 모듈이 (예를 들어) 비밀번호나 보안 토큰을 생성할 때 \"매력적인 위험 (attractive nuisance)\"이 될 수 있음을 강력히 시사합니다.\u003c/p\u003e\n\u003ch3\u003e제안 (Proposal)\u003c/h3\u003e\n\u003cp\u003e다른 제안들은 \u003ccode\u003erandom\u003c/code\u003e 모듈의 기본 PRNG를 변경하여, 개발자가 보안에 대해 생각할 필요 없이 구축할 수 있는 \"기본적으로 안전한 (secure by default)\" 암호학적으로 강력한 프리미티브를 제공하는 데 초점을 맞췄습니다. (아래 \"대안\" 섹션 참고) 이 PEP는 다른 접근 방식을 제안합니다:\u003c/p\u003e\n\u003cp\u003e표준 라이브러리는 이미 암호학적으로 강력한 프리미티브를 제공하지만, 많은 사용자는 그것이 존재하는지, 언제 사용해야 하는지 모릅니다. 암호화에 익숙하지 않은 사용자에게 보안 코드를 작성하도록 요구하는 대신, 표준 라이브러리는 보안 토큰 생성과 같은 가장 일반적인 요구 사항에 대한 \"배터리 포함 (batteries-included)\" 솔루션을 포함해야 합니다. 이 코드는 직접적으로 필요를 충족시키고(\"비밀번호 재설정 토큰을 어떻게 생성하나요?\"), 개발자가 학습할 수 있는 허용 가능한 관행의 예시 역할을 할 것입니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 이 PEP는 \u003ccode\u003esecrets\u003c/code\u003e라는 이름의 새 모듈을 표준 라이브러리에 추가할 것을 제안합니다. 이 모듈은 보안과 관련된 일반적인 활동을 위한 즉시 사용 가능한 함수 세트와 일부 하위 수준 프리미티브를 포함할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esecrets\u003c/code\u003e는 비밀로 유지되어야 하는 모든 것(비밀번호, 토큰 등)을 다루는 데 주력하는 모듈이 되고, \u003ccode\u003erandom\u003c/code\u003e 모듈은 하위 호환성을 유지할 것을 제안합니다.\u003c/p\u003e\n\u003ch3\u003eAPI 및 구현 (API and Implementation)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003esecrets\u003c/code\u003e 모듈에 다음과 같은 함수들을 제안합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e토큰 생성 함수:\u003c/strong\u003e 비밀번호 복구, 세션 키 등에 적합한 토큰을 다음 형식으로 생성하는 함수입니다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebytes\u003c/code\u003e 형식: \u003ccode\u003esecrets.token_bytes\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e16진수 문자열 형식: \u003ccode\u003esecrets.token_hex\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eURL-safe Base-64 인코딩 문자열 형식: \u003ccode\u003esecrets.token_urlsafe\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e시스템 CSPRNG에 대한 제한된 인터페이스:\u003c/strong\u003e \u003ccode\u003eos.urandom\u003c/code\u003e 또는 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e을 직접 사용하여 시스템 CSPRNG에 접근합니다. \u003ccode\u003erandom\u003c/code\u003e 모듈과 달리, 이는 시딩, 상태 가져오기/설정 또는 비균일 분포를 위한 메서드를 제공할 필요가 없습니다. 다음을 제공해야 합니다.\n\u003cul\u003e\n\u003cli\u003e시퀀스에서 항목을 선택하는 함수: \u003ccode\u003esecrets.choice\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e주어진 수의 무작위 비트 및/또는 바이트를 정수 형태로 생성하는 함수: \u003ccode\u003esecrets.randbits\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e0부터 주어진 상한 미만의 범위에서 무작위 정수를 반환하는 함수: \u003ccode\u003esecrets.randbelow\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e타이밍 공격에 강한 비교 함수:\u003c/strong\u003e 텍스트 또는 바이트 다이제스트의 동등성을 비교하는 함수: \u003ccode\u003esecrets.compare_digest\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e합의된 의견은 이러한 용도를 지원하기 위해 \u003ccode\u003erandom\u003c/code\u003e 모듈에 새로운 CSPRNG를 추가할 필요가 없으며, \u003ccode\u003eSystemRandom\u003c/code\u003e이면 충분하다는 것입니다.\u003c/p\u003e\n\u003cp\u003eAlyssa (Nick) Coghlan과 Tim Peters는 몇 가지 예시 구현과 최소한의 API를 제안했습니다. \"cryptography\" 모듈의 이슈 트래커에서도 이 아이디어가 논의되었습니다. 다음 의사 코드(pseudo-code)는 실제 구현의 시작점으로 간주될 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom random import SystemRandom\nfrom hmac import compare_digest\nimport os\nimport binascii\nimport base64\n\n_sysrand = SystemRandom()\nrandbits = _sysrand.getrandbits\nchoice = _sysrand.choice\n\ndef randbelow(exclusive_upper_bound):\n    return _sysrand._randbelow(exclusive_upper_bound)\n\nDEFAULT_ENTROPY = 32 # bytes\n\ndef token_bytes(nbytes=None):\n    if nbytes is None:\n        nbytes = DEFAULT_ENTROPY\n    return os.urandom(nbytes)\n\ndef token_hex(nbytes=None):\n    return binascii.hexlify(token_bytes(nbytes)).decode('ascii')\n\ndef token_urlsafe(nbytes=None):\n    tok = token_bytes(nbytes)\n    return base64.urlsafe_b64encode(tok).rstrip(b'=').decode('ascii')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esecrets\u003c/code\u003e 모듈 자체는 순수 Python으로 구현될 것이며, 다른 Python 구현체들도 변경 없이 쉽게 사용하거나 필요에 따라 조정할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e기본 인자 (Default arguments)\u003c/h4\u003e\n\u003cp\u003e\"내 토큰은 몇 바이트여야 하는가?\"는 어려운 질문입니다. \u003ccode\u003etoken_*\u003c/code\u003e 함수에 기본 엔트로피(entropy) 양을 제공함으로써 이 질문에 도움을 줄 수 있습니다. \u003ccode\u003enbytes\u003c/code\u003e 인자가 \u003ccode\u003eNone\u003c/code\u003e이거나 주어지지 않으면 기본 엔트로피가 사용됩니다. 이 기본값은 중간 수준의 보안 사용에 충분히 안전할 것으로 예상되는 크기여야 하지만, 향후 유지보수 릴리스에서도 변경될 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e명명 규칙 (Naming conventions)\u003c/h4\u003e\n\u003cp\u003e모듈에서 사용되는 명명 규칙, 즉 \"randrange\"와 같은 C 스타일 명명 규칙을 사용할지 \"random_range\"와 같은 Pythonic한 이름을 사용할지에 대한 질문이 있었습니다.\u003c/p\u003e\n\u003cp\u003e비공개 \u003ccode\u003eSystemRandom\u003c/code\u003e 인스턴스의 단순히 바인딩된 메서드(예: \u003ccode\u003erandrange\u003c/code\u003e)이거나 그에 대한 얇은 래퍼(wrapper)인 함수는 익숙한 이름을 유지해야 합니다. \u003ccode\u003etoken_*\u003c/code\u003e 함수와 같이 새로운 기능은 더 Pythonic한 이름을 사용할 것입니다.\u003c/p\u003e\n\u003ch3\u003e대안 (Alternatives)\u003c/h3\u003e\n\u003cp\u003e한 가지 대안은 \u003ccode\u003erandom\u003c/code\u003e 모듈에서 제공하는 기본 PRNG를 변경하는 것이었습니다. 이 제안은 상당한 회의론과 전면적인 반대에 부딪혔습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCSPRNG가 현재 PRNG(MT의 경우 이미 상당히 느림)보다 느릴 수 있다는 우려가 있습니다.\u003c/li\u003e\n\u003cli\u003e일부 애플리케이션(과학 시뮬레이션, 게임 플레이 재현 등)은 PRNG를 알려진 상태로 시딩(seeding)할 수 있는 능력을 필요로 하지만, CSPRNG는 설계상 이러한 기능을 제공하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erandom\u003c/code\u003e 모듈의 또 다른 주요 용도는 초보자가 작성하는 간단한 \"숫자 맞추기\" 게임이며, 많은 사람들이 \u003ccode\u003erandom\u003c/code\u003e 모듈을 변경하여 이를 더 어렵게 만드는 것을 꺼립니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erandom\u003c/code\u003e 모듈에서 MT를 제거하려는 제안은 없었지만, 비-CSPRNG를 선택하거나 하위 호환되지 않는 변경 사항에 대한 상당한 반대가 있었습니다.\u003c/li\u003e\n\u003cli\u003eMT에 대한 입증된 공격은 일반적으로 PHP 애플리케이션을 대상으로 합니다. PHP 버전의 MT는 열악한 시딩 기술로 인해 Python 버전보다 훨씬 쉬운 공격 대상이라고 여겨집니다. 따라서 Python 애플리케이션에 대한 입증된 공격 없이는 많은 사람들이 하위 호환되지 않는 변경에 반대합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAlyssa Coghlan은 이전에 기본적으로 시스템 CSPRNG를 사용하는 전역적으로 구성 가능한 PRNG에 대한 제안을 했지만, 이 제안을 선호하여 철회했습니다.\u003c/p\u003e\n\u003ch3\u003e다른 언어와의 비교 (Comparison To Other Languages)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePHP:\u003c/strong\u003e PHP는 기본적으로 현재 마이크로초 시간을 기반으로 13자 문자열을 반환하는 \u003ccode\u003euniqid\u003c/code\u003e 함수를 포함합니다. PHP 문서는 이 함수가 보안 목적에 적합하지 않다고 경고합니다. 하지만 여러 성숙하고 잘 알려진 PHP 애플리케이션들이 이 기능을 보안 목적으로 사용합니다. PHP 5.3 이상은 \u003ccode\u003eopenssl_random_pseudo_bytes\u003c/code\u003e 함수도 포함합니다. 이 함수는 주어진 길이의 의사 무작위 바이트 문자열과 해당 문자열이 암호학적으로 강력한지 여부를 나타내는 부울 플래그를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eJavaScript:\u003c/strong\u003e \u003ccode\u003eMath.random\u003c/code\u003e은 암호학적 목적에 부적합한 심각한 약점에도 불구하고 자주 사용됩니다. 최근 몇 년 동안 대부분의 브라우저는 \u003ccode\u003ewindow.crypto.getRandomValues\u003c/code\u003e를 지원하게 되었습니다. Node.js는 \u003ccode\u003ecrypto\u003c/code\u003e 모듈을 제공하며, \u003ccode\u003ecrypto.randomBytes\u003c/code\u003e와 같은 무작위 바이트 생성 함수를 포함합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRuby:\u003c/strong\u003e Ruby 표준 라이브러리는 \u003ccode\u003eSecureRandom\u003c/code\u003e 모듈을 포함하며 \u003ccode\u003ebase64\u003c/code\u003e, \u003ccode\u003ehex\u003c/code\u003e, \u003ccode\u003erandom_bytes\u003c/code\u003e, \u003ccode\u003erandom_number\u003c/code\u003e, \u003ccode\u003eurlsafe_base64\u003c/code\u003e, \u003ccode\u003euuid\u003c/code\u003e와 같은 메서드를 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e모듈 이름은 무엇이 되어야 하는가? (What Should Be The Name Of The Module?)\u003c/h3\u003e\n\u003cp\u003e\"Namespaces are one honking great idea\"라는 Python의 Zen을 인용하며 \"random.safe\" 서브모듈을 추가하자는 제안이 있었습니다. 그러나 Zen의 저자인 Tim Peters는 이 아이디어에 반대하며 최상위 모듈을 권장했습니다. python-ideas 메일링 리스트의 논의에서 \"secrets\"라는 이름은 일부 승인을 받았고, 강력한 반대는 없었습니다. 현재 동일한 이름의 서드파티 모듈이 존재하지만, 사용되지 않고 버려진 것으로 보입니다.\u003c/p\u003e\n\u003ch3\u003e자주 묻는 질문 (Frequently Asked Questions)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eQ: 이것이 실제로 문제인가요? MT는 출력을 아무도 예측할 수 없을 만큼 충분히 무작위 아닌가요?\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eA:\u003c/strong\u003e 보안 전문가들 사이에서 MT는 보안 컨텍스트에서 안전하지 않다는 것이 합의된 의견입니다. MT의 내부 상태를 재구성하는 것은 어렵지 않으며, 따라서 과거와 미래의 모든 값을 예측할 수 있습니다. MT를 무작위성에 사용하는 시스템에 대한 여러 알려진 실제 공격들이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eQ: PHP에 대한 공격은 그렇다 쳐도, Python 소프트웨어에 대한 알려진 공격이 있나요?\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eA:\u003c/strong\u003e 네, Zope와 Plone에서 최소한 취약점이 있었습니다. Hanno Schlichting은 다음과 같이 언급했습니다:\n\"Plone과 Zope 컨텍스트에서 실제 공격이 시연되었지만, 더 이상 제대로 된 링크를 찾을 수 없습니다. 제가 기억하기로는 Plone이 무작위 숫자를 생성하고 '죄송합니다, 오류가 발생했습니다. 문제가 \u0026#x3C;무작위 숫자\u003e로 기록되었습니다. 문의 시 이 번호를 포함해주세요.' 와 같은 오류 페이지에 이를 노출했습니다. 이는 누구나 이 페이지에 대량의 요청을 하여 MT 상태를 재구성하기에 충분한 무작위 값을 얻을 수 있게 했습니다. 여러 보안 관련 모듈이 \u003ccode\u003esystem random\u003c/code\u003e 대신 \u003ccode\u003erandom\u003c/code\u003e을 사용했기 때문에(쿠키 세션 ID, 비밀번호 재설정 링크, 인증 토큰 등), 공격자는 이 모든 것을 뚫을 수 있었습니다.\"\nChristian Heimes는 2012년에 이 문제를 Zope 보안 팀에 보고했으며, 최소한 두 가지 관련 CVE 취약점과 Django에서 이 문제에 대한 최소한 한 가지 해결책이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eQ: 이것이 SSL과 같은 전문 암호화 소프트웨어의 대안인가요?\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eA:\u003c/strong\u003e 아닙니다. 이것은 \"배터리 포함\" 솔루션이지, 완전한 기능을 갖춘 \"원자력 발전소\"가 아닙니다. 이는 일부 기본적인 보안 오류를 완화하기 위한 것이며, 모든 보안 관련 문제에 대한 해결책은 아닙니다. Alyssa Coghlan이 그녀의 이전 제안을 언급하며 말했듯이:\n\"...사람들은 보안에 민감한 소프트웨어에 \u003ccode\u003ecryptography.io\u003c/code\u003e와 같은 것을 사용하는 법을 배우는 것이 훨씬 낫습니다. 따라서 이 변경은 수백만 명의 현재 및 미래의 Python 개발자 중 상당수가 그렇게 하지 않을 것이라는 불가피한 현실을 고려할 때, 단순히 피해 완화에 관한 것입니다.\"\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eQ: 비밀번호 생성기는 어떤가요?\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eA:\u003c/strong\u003e 비밀번호 생성기의 요구 사항이 너무 다양하여 표준 라이브러리에 적합하지 않다는 것이 합의된 의견입니다. 모듈의 초기 릴리스에는 비밀번호 생성기가 포함되지 않을 것이며, 대신 문서에 레시피(예: \u003ccode\u003eitertools\u003c/code\u003e 모듈의 레시피) 형태로 제공될 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eQ: \u003ccode\u003esecrets\u003c/code\u003e는 Linux에서 \u003ccode\u003e/dev/random\u003c/code\u003e (블록킹)을 사용할까요, 아니면 \u003ccode\u003e/dev/urandom\u003c/code\u003e (논블록킹)을 사용할까요? 다른 플랫폼은 어떤가요?\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eA:\u003c/strong\u003e \u003ccode\u003esecrets\u003c/code\u003e는 \u003ccode\u003eos.urandom\u003c/code\u003e 및 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e을 기반으로 합니다. 이들은 운영 체제의 가장 좋은 암호학적 무작위성 소스에 대한 인터페이스입니다. Linux에서는 \u003ccode\u003e/dev/urandom\u003c/code\u003e일 수 있고, Windows에서는 \u003ccode\u003eCryptGenRandom()\u003c/code\u003e일 수 있습니다. 자세한 구현 내용은 문서 및/또는 소스 코드를 참조하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e참고 자료 (References)\u003c/h3\u003e\n\u003cp\u003ehttps://mail.python.org/pipermail/python-ideas/2015-September/035820.html\nhttps://docs.python.org/3/library/random.html\n작성일 기준. Google 검색어는 사용자 모르게 자동 맞춤화될 수 있으므로 일부 독자는 다른 결과를 볼 수 있습니다.\nhttp://interactivepython.org/runestone/static/everyday/2013/01/3_password.html\nhttp://stackoverflow.com/questions/3854692/generate-password-in-python\nhttp://stackoverflow.com/questions/3854692/generate-password-in-python/3854766#3854766\nhttps://mail.python.org/pipermail/python-ideas/2015-September/036238.html\n최소한 소스 코드와 문서를 읽으려는 동기가 있는 사람들.\n많은 논의 끝에 Guido는 모듈이 \u003ccode\u003erandbelow\u003c/code\u003e만 제공하고 \u003ccode\u003erandrange\u003c/code\u003e 또는 \u003ccode\u003erandint\u003c/code\u003e와 같은 유사한 함수는 제공할 필요가 없다고 결정했습니다. http://code.activestate.com/lists/python-dev/138375/\nhttps://mail.python.org/pipermail/python-ideas/2015-September/036271.html\nhttps://mail.python.org/pipermail/python-ideas/2015-September/036350.html\nhttps://github.com/pyca/cryptography/issues/2347\nhttps://bitbucket.org/sdaprano/secrets\nhttps://mail.python.org/pipermail/python-ideas/2015-September/036517.html, https://mail.python.org/pipermail/python-ideas/2015-September/036515.html\nhttps://mail.python.org/pipermail/python-ideas/2015-September/036474.html\n링크 필요.\n기본적으로 PHP는 시간을 사용하여 MT PRNG를 시딩하는데(인용 필요), 이는 공격자가 악용할 수 있습니다. 반면 Python은 시스템 CSPRNG의 출력을 사용하여 PRNG를 시딩하며, 이는 악용하기 훨씬 더 어렵다고 여겨집니다.\nhttp://php.net/manual/en/function.uniqid.php\nhttp://php.net/manual/en/function.openssl-random-pseudo-bytes.php\n자원 봉사자와 패치 환영.\nhttp://ifsec.blogspot.fr/2012/05/cross-domain-mathrandom-prediction.html\nhttps://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues\nhttps://nodejs.org/api/crypto.html\nhttp://ruby-doc.org/stdlib-2.1.2/libdoc/securerandom/rdoc/SecureRandom.html\nhttps://mail.python.org/pipermail/python-ideas/2015-September/036254.html\nhttps://pypi.python.org/pypi/secrets\nhttps://jazzy.id.au/2010/09/22/cracking_random_number_generators_part_3.html\nhttps://mail.python.org/pipermail/python-ideas/2015-September/036077.html\nhttps://media.blackhat.com/bh-us-12/Briefings/Argyros/BH_US_12_Argyros_PRNG_WP.pdf\n개인 통신, 2016-08-24.\nhttps://bugs.launchpad.net/zope2/+bug/1071067\nhttp://www.cvedetails.com/cve/CVE-2012-5508/, http://www.cvedetails.com/cve/CVE-2012-6661/\nhttps://github.com/django/django/commit/1525874238fd705ec17a066291935a9316bd3044\nhttps://mail.python.org/pipermail/python-ideas/2015-September/036157.html\nhttps://mail.python.org/pipermail/python-ideas/2015-September/036476.html, https://mail.python.org/pipermail/python-ideas/2015-September/036478.html\nhttps://mail.python.org/pipermail/python-ideas/2015-September/036488.html\nhttp://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/, http://www.2uo.de/myths-about-urandom/\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 506 - Adding A Secrets Module To The Standard Library\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:53:00+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"page__taxonomy mb-4\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"카테고리\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":\"Python\"}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":\"PEP\"}]]]}],[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]]}]]}]}]}]\nb:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publishe"])</script><script>self.__next_f.push([1,"r\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"21\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>