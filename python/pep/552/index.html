<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js"/><script src="/secrett2633.github.io/_next/static/chunks/fd9d1056-62aaf4b921c84028.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/23-ca4408d024135d8d.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/main-app-fa660020ba1e0b6e.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/231-c4b666723e6aae68.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/layout-8808afda01b7a1b7.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="next-size-adjust"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/secrett2633.github.io/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_9012cf layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/secrett2633.github.io">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 552 - Deterministic pycs</h1><div class="page__meta"><time dateTime="2025-09-26 23:38:24+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0552/">PEP 552 - Deterministic pycs</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 04-Sep-2017</p>
</blockquote>
<h1>PEP 552 – 결정론적 <code>.pyc</code> 파일</h1>
<h2>개요</h2>
<p>이 PEP는 <code>.pyc</code> 파일 형식을 확장하여, 파일의 결정론적(deterministic) 특성을 강화할 것을 제안합니다.</p>
<h2>도입 배경 (Rationale)</h2>
<p><strong>재현 가능한 빌드(Reproducible Build)의 중요성</strong>
재현 가능한 빌드란 동일한 소스 코드를 빌드할 때, 빌드 환경이 다르더라도 항상 바이트 단위로 동일한 결과물이 생성되는 것을 의미합니다. 이는 보안에 매우 중요하며, Bazel과 같은 콘텐츠 기반 빌드 시스템에서 핵심적인 개념입니다. 이러한 시스템은 출력 파일의 내용이 입력 파일의 내용에 대한 결정론적 함수일 때 가장 효율적입니다.</p>
<p><strong>기존 <code>.pyc</code> 형식의 문제점</strong>
현재 Python의 <code>.pyc</code> 파일 형식은 모듈의 마샬링(marshaled)된 코드 객체에 매직 넘버(magic number), 소스 타임스탬프(source timestamp), 그리고 소스 파일 크기를 접두사로 붙인 형태입니다. 여기서 '소스 타임스탬프'의 존재는 <code>.pyc</code> 파일이 입력 파일 내용만의 결정론적 함수가 아니라는 것을 의미합니다. 이는 소스 파일의 <code>mtime</code>(수정 시간)과 같은 변동성 있는 메타데이터에 의존하기 때문에, <code>.pyc</code> 파일이 적절한 재현성을 저해하는 요소가 됩니다.</p>
<p><strong>기존 배포자들의 어려움</strong>
Python 코드 배포자들은 현재 다음과 같은 선택지들로 인해 어려움을 겪고 있습니다.</p>
<ul>
<li><code>.pyc</code> 파일을 배포하지 않고 캐싱(caching) 이점을 포기하는 방법.</li>
<li><code>.pyc</code> 파일을 배포하지만 재현성을 잃는 방법.</li>
<li>모든 Python 소스 파일에 결정론적인 타임스탬프를 부여하는 복잡한 방법 (예: <code>cpython</code> 풀 리퀘스트 #296).</li>
<li>설치 시점에 <code>.pyc</code> 파일을 생성하는 것과 같이 위 방법들을 복합적으로 사용하는 방법.</li>
</ul>
<p>이러한 선택지들은 모두 만족스럽지 못합니다.</p>
<p><strong>PEP 552의 제안</strong>
이 PEP는 타임스탬프를 결정론적인 해시(hash) 값으로 대체하는 것을 제안합니다. 다만, 현재의 타임스탬프 기반 무효화(invalidation) 방법은 여전히 기본값으로 유지될 것입니다. 타임스탬프 기반 무효화는 비결정론적임에도 불구하고 많은 워크플로우와 사용 사례에서 잘 작동하기 때문입니다. 해시 기반 <code>.pyc</code> 형식은 모든 소스 파일을 읽고 해싱하는 비용을 발생시킬 수 있으며, 이는 단순히 타임스탬프를 확인하는 것보다 비쌉니다. 따라서, 현재로서는 주로 배포자나 고급 사용 사례에서 활용될 것으로 예상됩니다.</p>
<p>(참고: <code>.pyc</code> 파일을 비결정론적으로 만드는 다른 문제들도 있지만, 이 PEP에서는 다루지 않습니다.)</p>
<h2>사양 (Specification)</h2>
<p><strong><code>.pyc</code> 헤더 확장</strong>
<code>.pyc</code> 헤더는 현재 3개의 32비트 워드(word)로 구성되어 있습니다. 이 PEP에서는 이를 4개로 확장할 것을 제안합니다.</p>
<ul>
<li><strong>첫 번째 워드:</strong> 이전과 같이 바이트코드 및 <code>.pyc</code> 형식 버전을 나타내는 매직 넘버(magic number)입니다.</li>
<li><strong>두 번째 워드:</strong> 새로운 개념의 워드로, 비트 필드(bit field)가 됩니다. 이 비트 필드의 내용에 따라 나머지 헤더의 해석 및 <code>.pyc</code>의 무효화 동작이 달라집니다.</li>
</ul>
<p><strong><code>.pyc</code> 형식 종류</strong></p>
<ol>
<li>
<p><strong>기존 타임스탬프 기반 <code>.pyc</code>:</strong></p>
<ul>
<li>비트 필드가 <code>0</code>인 경우, 이 <code>.pyc</code>는 전통적인 타임스탬프 기반 <code>.pyc</code>입니다.</li>
<li>세 번째와 네 번째 워드는 각각 타임스탬프와 파일 크기가 됩니다.</li>
<li>소스 파일의 메타데이터와 헤더의 메타데이터를 비교하여 무효화를 수행합니다.</li>
</ul>
</li>
<li>
<p><strong>해시 기반 <code>.pyc</code>:</strong></p>
<ul>
<li>비트 필드의 최하위 비트가 설정된 경우, 이 <code>.pyc</code>는 해시 기반 <code>.pyc</code>입니다.</li>
<li>최하위 비트 다음의 비트는 <code>check_source</code> 플래그입니다.</li>
<li>비트 필드 뒤에는 64비트의 소스 파일 해시가 따라옵니다.</li>
<li>소스 파일 내용의 하드코딩된 키(hardcoded key)를 사용하는 SipHash를 사용합니다. (PEP 456을 통해 Python에 이미 SipHash 구현이 내장되어 있습니다.)</li>
<li>해시의 보안은 주요 고려 사항이 아니지만, MD5와 같이 완전히 손상된 해시는 제어된 환경에서 Python 감사를 용이하게 하기 위해 피합니다.</li>
</ul>
</li>
</ol>
<p><strong>해시 기반 <code>.pyc</code>의 동작</strong></p>
<ul>
<li>
<p><strong><code>check_source</code> 플래그가 설정된 경우:</strong></p>
<ul>
<li>Python은 소스 파일을 해싱하고, 그 결과를 <code>.pyc</code>에 저장된 예상 해시와 비교하여 <code>.pyc</code>의 유효성을 판단합니다.</li>
<li>만약 <code>.pyc</code>를 재생성해야 한다면, <code>check_source</code> 플래그가 설정된 해시 기반 <code>.pyc</code>로 다시 생성됩니다.</li>
</ul>
</li>
<li>
<p><strong><code>check_source</code> 플래그가 설정되지 않은 경우 (unset):</strong></p>
<ul>
<li>Python은 소스 파일의 해시를 확인하지 않고 <code>.pyc</code>를 로드합니다.</li>
<li>이 경우, 외부 시스템(예: 로컬 Linux 배포판의 패키지 관리자)이 <code>.pyc</code> 파일의 최신 상태를 유지할 책임이 있다고 가정합니다.</li>
<li>유효성 검사가 비활성화되어 있더라도, 해시 필드는 올바르게 설정되어 있어야 합니다. 이를 통해 대역 외(out-of-band) 일관성 검사기가 <code>.pyc</code>의 최신 상태를 확인할 수 있습니다.</li>
<li>PEP 3147에서 규정한 대로, 해당 소스 파일이 없는 <code>.pyc</code>는 로드되지 않는 규칙은 해시 기반 <code>.pyc</code>에도 계속 적용됩니다.</li>
</ul>
</li>
</ul>
<p><strong>프로그래밍 API 지원</strong></p>
<ul>
<li><code>py_compile</code> 및 <code>compileall</code> 모듈의 프로그래밍 API는 해시 기반 <code>.pyc</code> 생성을 지원합니다.</li>
<li><code>py_compile</code>은 새로운 <code>PycInvalidationMode</code> 열거형을 정의합니다.
<pre><code class="language-python">class PycInvalidationMode(Enum):
    TIMESTAMP
    CHECKED_HASH
    UNCHECKED_HASH
</code></pre>
</li>
<li><code>py_compile.compile</code>, <code>compileall.compile_dir</code>, <code>compileall.compile_file</code> 함수에 <code>invalidation_mode</code> 매개변수가 추가되며, <code>PycInvalidationMode</code> 열거형 값을 받습니다.</li>
</ul>
<p><strong><code>compileall</code> 도구 확장</strong></p>
<ul>
<li><code>compileall</code> 도구는 <code>--invalidation-mode</code>라는 새로운 명령줄 옵션으로 확장됩니다.</li>
<li><code>--invalidation-mode</code>는 <code>timestamp</code> (기본값), <code>checked-hash</code>, <code>unchecked-hash</code> 세 가지 값을 가질 수 있으며, 이는 <code>PycInvalidationMode</code> 열거형의 값에 해당합니다.</li>
</ul>
<p><strong><code>importlib.util</code> 확장</strong></p>
<ul>
<li><code>importlib.util</code> 모듈은 바이트스트링 소스에 대해 <code>.pyc</code> 작성 코드가 사용하는 해시를 계산하는 <code>source_hash(source)</code> 함수로 확장됩니다.</li>
</ul>
<p><strong>런타임 설정</strong></p>
<ul>
<li>해시 기반 <code>.pyc</code> 무효화의 런타임 설정은 <code>--check-hash-based-pycs</code>라는 새로운 인터프리터 옵션으로 제공됩니다.</li>
<li>이 옵션은 <code>default</code>, <code>always</code>, <code>never</code> 세 가지 값을 가질 수 있는 삼중 상태(tristate) 옵션입니다.
<ul>
<li><code>default</code>: 해시 기반 <code>.pyc</code>의 <code>check_source</code> 플래그에 따라 무효화가 결정됩니다.</li>
<li><code>always</code>: <code>check_source</code> 비트 값에 관계없이 인터프리터가 무효화를 위해 항상 소스 파일을 해싱합니다.</li>
<li><code>never</code>: 인터프리터가 해시 기반 <code>.pyc</code>를 항상 유효하다고 가정합니다. 이 경우, <code>unchecked</code> 해시 기반 <code>.pyc</code>는 다시 <code>unchecked</code> 해시 기반 <code>.pyc</code>로 재생성됩니다.</li>
</ul>
</li>
<li>타임스탬프 기반 <code>.pyc</code>는 <code>--check-hash-based-pycs</code> 옵션의 영향을 받지 않습니다.</li>
</ul>
<h2>참고 자료 (References)</h2>
<ul>
<li>Python Determinism: <a href="http://benno.id.au/blog/2013/01/15/python-determinism">http://benno.id.au/blog/2013/01/15/python-determinism</a></li>
<li>Bugzilla openSUSE: <a href="http://bugzilla.opensuse.org/show_bug.cgi?id=1049186">http://bugzilla.opensuse.org/show_bug.cgi?id=1049186</a></li>
</ul>
<h2>기여자 (Credits)</h2>
<p>저자는 이 PEP 주제에 대한 유익한 대화를 나눠준 Gregory P. Smith, Christian Heimes, Steve Dower에게 감사를 표합니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy mb-4"><h4 class="text-sm font-medium text-gray-900 mb-2">카테고리</h4><span class="page__taxonomy-item">Python</span><span class="page__taxonomy-item">PEP</span></div><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[4281,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"185\",\"static/chunks/app/layout-8808afda01b7a1b7.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/552\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"iV6XySbMHIJ3imQdvgy3I\",\"assetPrefix\":\"/secrett2633.github.io\",\"initialCanonicalUrl\":\"/python/pep/552/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/552\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"552\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/552\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"32x32\",\"href\":\"/favicon-32x32.png\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"16x16\",\"href\":\"/favicon-16x16.png\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_9012cf layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T2797,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0552/\"\u003ePEP 552 - Deterministic pycs\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 04-Sep-2017\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 552 – 결정론적 \u003ccode\u003e.pyc\u003c/code\u003e 파일\u003c/h1\u003e\n\u003ch2\u003e개요\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003e.pyc\u003c/code\u003e 파일 형식을 확장하여, 파일의 결정론적(deterministic) 특성을 강화할 것을 제안합니다.\u003c/p\u003e\n\u003ch2\u003e도입 배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e재현 가능한 빌드(Reproducible Build)의 중요성\u003c/strong\u003e\n재현 가능한 빌드란 동일한 소스 코드를 빌드할 때, 빌드 환경이 다르더라도 항상 바이트 단위로 동일한 결과물이 생성되는 것을 의미합니다. 이는 보안에 매우 중요하며, Bazel과 같은 콘텐츠 기반 빌드 시스템에서 핵심적인 개념입니다. 이러한 시스템은 출력 파일의 내용이 입력 파일의 내용에 대한 결정론적 함수일 때 가장 효율적입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e기존 \u003ccode\u003e.pyc\u003c/code\u003e 형식의 문제점\u003c/strong\u003e\n현재 Python의 \u003ccode\u003e.pyc\u003c/code\u003e 파일 형식은 모듈의 마샬링(marshaled)된 코드 객체에 매직 넘버(magic number), 소스 타임스탬프(source timestamp), 그리고 소스 파일 크기를 접두사로 붙인 형태입니다. 여기서 '소스 타임스탬프'의 존재는 \u003ccode\u003e.pyc\u003c/code\u003e 파일이 입력 파일 내용만의 결정론적 함수가 아니라는 것을 의미합니다. 이는 소스 파일의 \u003ccode\u003emtime\u003c/code\u003e(수정 시간)과 같은 변동성 있는 메타데이터에 의존하기 때문에, \u003ccode\u003e.pyc\u003c/code\u003e 파일이 적절한 재현성을 저해하는 요소가 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e기존 배포자들의 어려움\u003c/strong\u003e\nPython 코드 배포자들은 현재 다음과 같은 선택지들로 인해 어려움을 겪고 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e.pyc\u003c/code\u003e 파일을 배포하지 않고 캐싱(caching) 이점을 포기하는 방법.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.pyc\u003c/code\u003e 파일을 배포하지만 재현성을 잃는 방법.\u003c/li\u003e\n\u003cli\u003e모든 Python 소스 파일에 결정론적인 타임스탬프를 부여하는 복잡한 방법 (예: \u003ccode\u003ecpython\u003c/code\u003e 풀 리퀘스트 #296).\u003c/li\u003e\n\u003cli\u003e설치 시점에 \u003ccode\u003e.pyc\u003c/code\u003e 파일을 생성하는 것과 같이 위 방법들을 복합적으로 사용하는 방법.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 선택지들은 모두 만족스럽지 못합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePEP 552의 제안\u003c/strong\u003e\n이 PEP는 타임스탬프를 결정론적인 해시(hash) 값으로 대체하는 것을 제안합니다. 다만, 현재의 타임스탬프 기반 무효화(invalidation) 방법은 여전히 기본값으로 유지될 것입니다. 타임스탬프 기반 무효화는 비결정론적임에도 불구하고 많은 워크플로우와 사용 사례에서 잘 작동하기 때문입니다. 해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e 형식은 모든 소스 파일을 읽고 해싱하는 비용을 발생시킬 수 있으며, 이는 단순히 타임스탬프를 확인하는 것보다 비쌉니다. 따라서, 현재로서는 주로 배포자나 고급 사용 사례에서 활용될 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e(참고: \u003ccode\u003e.pyc\u003c/code\u003e 파일을 비결정론적으로 만드는 다른 문제들도 있지만, 이 PEP에서는 다루지 않습니다.)\u003c/p\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e.pyc\u003c/code\u003e 헤더 확장\u003c/strong\u003e\n\u003ccode\u003e.pyc\u003c/code\u003e 헤더는 현재 3개의 32비트 워드(word)로 구성되어 있습니다. 이 PEP에서는 이를 4개로 확장할 것을 제안합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e첫 번째 워드:\u003c/strong\u003e 이전과 같이 바이트코드 및 \u003ccode\u003e.pyc\u003c/code\u003e 형식 버전을 나타내는 매직 넘버(magic number)입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e두 번째 워드:\u003c/strong\u003e 새로운 개념의 워드로, 비트 필드(bit field)가 됩니다. 이 비트 필드의 내용에 따라 나머지 헤더의 해석 및 \u003ccode\u003e.pyc\u003c/code\u003e의 무효화 동작이 달라집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e.pyc\u003c/code\u003e 형식 종류\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e기존 타임스탬프 기반 \u003ccode\u003e.pyc\u003c/code\u003e:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e비트 필드가 \u003ccode\u003e0\u003c/code\u003e인 경우, 이 \u003ccode\u003e.pyc\u003c/code\u003e는 전통적인 타임스탬프 기반 \u003ccode\u003e.pyc\u003c/code\u003e입니다.\u003c/li\u003e\n\u003cli\u003e세 번째와 네 번째 워드는 각각 타임스탬프와 파일 크기가 됩니다.\u003c/li\u003e\n\u003cli\u003e소스 파일의 메타데이터와 헤더의 메타데이터를 비교하여 무효화를 수행합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e비트 필드의 최하위 비트가 설정된 경우, 이 \u003ccode\u003e.pyc\u003c/code\u003e는 해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e입니다.\u003c/li\u003e\n\u003cli\u003e최하위 비트 다음의 비트는 \u003ccode\u003echeck_source\u003c/code\u003e 플래그입니다.\u003c/li\u003e\n\u003cli\u003e비트 필드 뒤에는 64비트의 소스 파일 해시가 따라옵니다.\u003c/li\u003e\n\u003cli\u003e소스 파일 내용의 하드코딩된 키(hardcoded key)를 사용하는 SipHash를 사용합니다. (PEP 456을 통해 Python에 이미 SipHash 구현이 내장되어 있습니다.)\u003c/li\u003e\n\u003cli\u003e해시의 보안은 주요 고려 사항이 아니지만, MD5와 같이 완전히 손상된 해시는 제어된 환경에서 Python 감사를 용이하게 하기 위해 피합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e의 동작\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003echeck_source\u003c/code\u003e 플래그가 설정된 경우:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePython은 소스 파일을 해싱하고, 그 결과를 \u003ccode\u003e.pyc\u003c/code\u003e에 저장된 예상 해시와 비교하여 \u003ccode\u003e.pyc\u003c/code\u003e의 유효성을 판단합니다.\u003c/li\u003e\n\u003cli\u003e만약 \u003ccode\u003e.pyc\u003c/code\u003e를 재생성해야 한다면, \u003ccode\u003echeck_source\u003c/code\u003e 플래그가 설정된 해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e로 다시 생성됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003echeck_source\u003c/code\u003e 플래그가 설정되지 않은 경우 (unset):\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePython은 소스 파일의 해시를 확인하지 않고 \u003ccode\u003e.pyc\u003c/code\u003e를 로드합니다.\u003c/li\u003e\n\u003cli\u003e이 경우, 외부 시스템(예: 로컬 Linux 배포판의 패키지 관리자)이 \u003ccode\u003e.pyc\u003c/code\u003e 파일의 최신 상태를 유지할 책임이 있다고 가정합니다.\u003c/li\u003e\n\u003cli\u003e유효성 검사가 비활성화되어 있더라도, 해시 필드는 올바르게 설정되어 있어야 합니다. 이를 통해 대역 외(out-of-band) 일관성 검사기가 \u003ccode\u003e.pyc\u003c/code\u003e의 최신 상태를 확인할 수 있습니다.\u003c/li\u003e\n\u003cli\u003ePEP 3147에서 규정한 대로, 해당 소스 파일이 없는 \u003ccode\u003e.pyc\u003c/code\u003e는 로드되지 않는 규칙은 해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e에도 계속 적용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e프로그래밍 API 지원\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epy_compile\u003c/code\u003e 및 \u003ccode\u003ecompileall\u003c/code\u003e 모듈의 프로그래밍 API는 해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e 생성을 지원합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epy_compile\u003c/code\u003e은 새로운 \u003ccode\u003ePycInvalidationMode\u003c/code\u003e 열거형을 정의합니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass PycInvalidationMode(Enum):\n    TIMESTAMP\n    CHECKED_HASH\n    UNCHECKED_HASH\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epy_compile.compile\u003c/code\u003e, \u003ccode\u003ecompileall.compile_dir\u003c/code\u003e, \u003ccode\u003ecompileall.compile_file\u003c/code\u003e 함수에 \u003ccode\u003einvalidation_mode\u003c/code\u003e 매개변수가 추가되며, \u003ccode\u003ePycInvalidationMode\u003c/code\u003e 열거형 값을 받습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ecompileall\u003c/code\u003e 도구 확장\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecompileall\u003c/code\u003e 도구는 \u003ccode\u003e--invalidation-mode\u003c/code\u003e라는 새로운 명령줄 옵션으로 확장됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e--invalidation-mode\u003c/code\u003e는 \u003ccode\u003etimestamp\u003c/code\u003e (기본값), \u003ccode\u003echecked-hash\u003c/code\u003e, \u003ccode\u003eunchecked-hash\u003c/code\u003e 세 가지 값을 가질 수 있으며, 이는 \u003ccode\u003ePycInvalidationMode\u003c/code\u003e 열거형의 값에 해당합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eimportlib.util\u003c/code\u003e 확장\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eimportlib.util\u003c/code\u003e 모듈은 바이트스트링 소스에 대해 \u003ccode\u003e.pyc\u003c/code\u003e 작성 코드가 사용하는 해시를 계산하는 \u003ccode\u003esource_hash(source)\u003c/code\u003e 함수로 확장됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e런타임 설정\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e 무효화의 런타임 설정은 \u003ccode\u003e--check-hash-based-pycs\u003c/code\u003e라는 새로운 인터프리터 옵션으로 제공됩니다.\u003c/li\u003e\n\u003cli\u003e이 옵션은 \u003ccode\u003edefault\u003c/code\u003e, \u003ccode\u003ealways\u003c/code\u003e, \u003ccode\u003enever\u003c/code\u003e 세 가지 값을 가질 수 있는 삼중 상태(tristate) 옵션입니다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edefault\u003c/code\u003e: 해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e의 \u003ccode\u003echeck_source\u003c/code\u003e 플래그에 따라 무효화가 결정됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ealways\u003c/code\u003e: \u003ccode\u003echeck_source\u003c/code\u003e 비트 값에 관계없이 인터프리터가 무효화를 위해 항상 소스 파일을 해싱합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enever\u003c/code\u003e: 인터프리터가 해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e를 항상 유효하다고 가정합니다. 이 경우, \u003ccode\u003eunchecked\u003c/code\u003e 해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e는 다시 \u003ccode\u003eunchecked\u003c/code\u003e 해시 기반 \u003ccode\u003e.pyc\u003c/code\u003e로 재생성됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e타임스탬프 기반 \u003ccode\u003e.pyc\u003c/code\u003e는 \u003ccode\u003e--check-hash-based-pycs\u003c/code\u003e 옵션의 영향을 받지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e참고 자료 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ePython Determinism: \u003ca href=\"http://benno.id.au/blog/2013/01/15/python-determinism\"\u003ehttp://benno.id.au/blog/2013/01/15/python-determinism\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eBugzilla openSUSE: \u003ca href=\"http://bugzilla.opensuse.org/show_bug.cgi?id=1049186\"\u003ehttp://bugzilla.opensuse.org/show_bug.cgi?id=1049186\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e기여자 (Credits)\u003c/h2\u003e\n\u003cp\u003e저자는 이 PEP 주제에 대한 유익한 대화를 나눠준 Gregory P. Smith, Christian Heimes, Steve Dower에게 감사를 표합니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 552 - Deterministic pycs\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:38:24+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"page__taxonomy mb-4\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"카테고리\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":\"Python\"}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":\"PEP\"}]]]}],[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]]}]]}]}]}]\nb:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],"])</script><script>self.__next_f.push([1,"[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"21\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>