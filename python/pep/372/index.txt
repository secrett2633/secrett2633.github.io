3:I[9275,[],""]
5:I[1343,[],""]
6:I[4281,["231","static/chunks/231-c4b666723e6aae68.js","185","static/chunks/app/layout-8808afda01b7a1b7.js"],"default"]
7:I[231,["231","static/chunks/231-c4b666723e6aae68.js","877","static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js"],""]
4:["slug","python/pep/372","c"]
0:["iV6XySbMHIJ3imQdvgy3I",[[["",{"children":[["slug","python/pep/372","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"372\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/372","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","link",null,{"rel":"icon","type":"image/png","sizes":"32x32","href":"/favicon-32x32.png"}],["$","link",null,{"rel":"icon","type":"image/png","sizes":"16x16","href":"/favicon-16x16.png"}],["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_9012cf layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T38cc,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0372/">PEP 372 - Adding an ordered dictionary to collections</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 15-Jun-2008</p>
</blockquote>
<p>PEP 372 – <code>collections</code> 모듈에 순서가 있는 딕셔너리 추가</p>
<h2>개요</h2>
<p>이 PEP는 <code>collections</code> 모듈에 "OrderedDict"라는 이름의 순서가 있는 딕셔너리(ordered dictionary)를 새로운 데이터 구조로 추가할 것을 제안합니다. 제안된 API는 다양한 실제 애플리케이션 및 다른 프로그래밍 언어에서 유사한 구현을 사용하며 얻은 경험을 통합합니다.</p>
<h2>도입 배경</h2>
<p>현재 Python 버전에서 널리 사용되는 내장 <code>dict</code> 타입은 저장된 키/값 쌍에 대한 순서를 지정하지 않습니다. 이로 인해 특정 사용 사례에서는 딕셔너리를 데이터 저장소로 사용하기 어렵습니다. PHP 및 Ruby 1.9와 같은 일부 동적 프로그래밍 언어는 이터레이션(iteration) 시 특정 순서를 보장합니다. 이러한 언어와 기존 Python의 순서 있는 딕셔너리(ordered-dict) 구현에서는 항목의 순서가 키가 삽입된 시간에 따라 정의됩니다. 새로운 키는 마지막에 추가되지만, 덮어쓰기되는 키는 마지막으로 이동하지 않습니다.</p>
<p>다음 예시는 간단한 할당에 대한 동작을 보여줍니다:</p>
<pre><code class="language-python">>>> d = OrderedDict()
>>> d['parrot'] = 'dead'
>>> d['penguin'] = 'exploded'
>>> d.items()
[('parrot', 'dead'), ('penguin', 'exploded')]
</code></pre>
<p>순서가 유지된다는 점은 <code>OrderedDict</code>를 몇 가지 상황에서 유용하게 만듭니다:</p>
<ul>
<li>XML/HTML 처리 라이브러리는 현재 속성(attribute)의 순서를 잃거나, 필터링이 번거로운 <code>dict</code> 대신 <code>list</code>를 사용하거나, 자체적인 순서 있는 딕셔너리를 구현하고 있습니다. 이는 <code>ElementTree</code>, <code>html5lib</code>, <code>Genshi</code> 및 더 많은 라이브러리에 영향을 미칩니다.</li>
<li>다양한 라이브러리 및 애플리케이션에 많은 순서 있는 딕셔너리 구현이 존재하며, 대부분 서로 미묘하게 호환되지 않습니다. 더욱이, <code>dict</code>를 서브클래싱(subclassing)하는 것은 간단한 작업이 아니며, 많은 구현이 모든 메서드를 제대로 오버라이드(override)하지 않아 예기치 않은 결과를 초래할 수 있습니다.</li>
<li>또한, 많은 순서 있는 딕셔너리는 비효율적인 방식으로 구현되어 있어 많은 연산이 필요 이상으로 복잡해집니다.</li>
<li>PEP 3115는 메타클래스(metaclass)가 클래스 본문에 사용되는 매핑 객체를 변경할 수 있도록 허용합니다. 순서 있는 딕셔너리는 C 구조체(struct)와 유사하게 순서 있는 멤버 선언을 만드는 데 사용될 수 있습니다. 이는 예를 들어, 미래의 <code>ctypes</code> 릴리스뿐만 아니라 Django 프레임워크가 제공하는 것과 같이 데이터베이스 테이블을 클래스로 정의하는 ORM에 유용할 수 있습니다. Django는 현재 데이터베이스 모델에서 멤버의 순서를 복원하기 위해 "ugly hack"을 사용하고 있습니다.</li>
<li><code>RawConfigParser</code> 클래스는 애플리케이션이 내부적으로 사용되는 딕셔너리 타입을 설정할 수 있도록 <code>dict_type</code> 인수를 받습니다. 이 추가의 동기는 사용자가 순서 있는 딕셔너리를 제공할 수 있도록 명시적으로 허용하는 것이었습니다.</li>
<li>PHP와 같은 다른 프로그래밍 언어에서 포팅된 코드는 종종 순서 있는 딕셔너리에 의존합니다. 표준 라이브러리에 순서 유지 딕셔너리 구현이 있으면 전환을 용이하게 하고 다른 라이브러리 간의 호환성을 향상시킬 수 있습니다.</li>
</ul>
<h2>OrderedDict API</h2>
<p><code>OrderedDict</code> API는 대부분 <code>dict</code> 및 기존의 순서 있는 딕셔너리와 호환됩니다. 이 PEP는 <code>collections.Mapping</code> 추상 베이스 클래스에 설명된 2.7 및 3.0 딕셔너리 API를 참조합니다.</p>
<p>생성자(<code>constructor</code>) 및 <code>update()</code> 메서드는 <code>dict</code>와 마찬가지로 튜플의 이터러블(iterable)뿐만 아니라 매핑(mapping)도 허용합니다. 일반 딕셔너리와 달리 삽입 순서가 보존됩니다.</p>
<pre><code class="language-python">>>> d = OrderedDict([('a', 'b'), ('c', 'd')])
>>> d.update({'foo': 'bar'})
>>> d
collections.OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
</code></pre>
<p><code>OrderedDict</code>가 일반 <code>dict</code>로부터 업데이트될 경우, 새 키의 순서는 정의되지 않습니다.</p>
<p><code>keys()</code>, <code>values()</code>, <code>items()</code>와 같은 모든 이터레이션(iteration) 메서드는 키가 처음 삽입된 시간에 따라 정렬된 값을 반환합니다.</p>
<pre><code class="language-python">>>> d['spam'] = 'eggs'
>>> d.keys()
['a', 'c', 'foo', 'spam']
>>> d.values()
['b', 'd', 'bar', 'eggs']
>>> d.items()
[('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', 'eggs')]
</code></pre>
<p><code>dict</code>에는 없는 새로운 메서드:</p>
<ul>
<li><code>OrderedDict.__reversed__()</code>: 키에 의한 역방향 이터레이션(reverse iteration)을 지원합니다.</li>
</ul>
<h3>질문과 답변</h3>
<p><strong>기존 키가 재할당되면 어떻게 되나요?</strong>
키는 이동하지 않고 제자리에서 새 값이 할당됩니다. 이는 기존 구현과 일치합니다.</p>
<p><strong>생성자에 전달된 리스트에 키가 여러 번 나타나면 어떻게 되나요?</strong>
일반 <code>dict</code>와 동일하게, 나중에 오는 항목이 이전 항목을 덮어씁니다. 이는 실제로는 값만 덮어쓰여지기 때문에 첫 번째 키의 위치가 사용되는 부작용이 있습니다.</p>
<pre><code class="language-python">>>> OrderedDict([('a', 1), ('b', 2), ('a', 3)])
collections.OrderedDict([('a', 3), ('b', 2)])
</code></pre>
<p>이 동작은 Python의 기존 구현, PHP 배열 및 Ruby 1.9의 해시맵(hashmap)과 일치합니다.</p>
<p><strong>Ordered Dict는 <code>dict</code> 서브클래스인가요? 왜 그런가요?</strong>
네. <code>defaultdict</code>와 마찬가지로 <code>OrderedDict</code>는 <code>dict</code>를 서브클래스합니다. <code>dict</code>의 서브클래스이기 때문에 일부 메서드(<code>__getitem__</code>, <code>__len__</code> 등)를 더 빠르게 만듭니다. 더 중요한 것은, <code>dict</code>의 서브클래스라는 점이 <code>json</code>과 같이 <code>isinstance(d, dict)</code> 테스트를 통해 <code>dict</code> 입력을 요구하는 도구와 함께 <code>OrderedDict</code>를 사용할 수 있게 합니다.</p>
<p><strong><code>dict</code>를 서브클래싱함으로써 발생하는 제한 사항이 있나요?</strong>
네. <code>dict</code>의 API가 Py2.x와 Py3.x에서 다르기 때문에 <code>OrderedDict</code> API도 달라야 합니다. 따라서 Py2.7 버전은 <code>iterkeys</code>, <code>itervalues</code>, <code>iteritems</code>를 오버라이드해야 합니다.</p>
<p><strong><code>OrderedDict.popitem()</code>은 특정 키/값 쌍을 반환하나요?</strong>
네. 가장 최근에 삽입된 새 키와 해당 값을 꺼냅니다. 이는 전통적인 푸시/팝 쌍이 보이는 일반적인 LIFO(Last-In, First-Out) 동작에 해당합니다. 이는 의미론적으로 <code>k=list(od)[-1]; v=od[k]; del od[k]; return (k,v)</code>와 동일합니다. 실제 구현은 더 효율적이며 정렬된 키 목록에서 직접 꺼냅니다.</p>
<p><strong>OrderedDict는 인덱싱, 슬라이싱 등을 지원하나요?</strong>
<code>OrderedDict</code>는 <code>Sequence</code> 인터페이스를 구현하지 않습니다. 오히려 키 삽입 순서를 기억하는 <code>MutableMapping</code>입니다. 유일한 시퀀스(sequence)와 유사한 추가 기능은 <code>reversed</code> 지원입니다.
인덱싱을 허용하지 않는 또 다른 장점은 연결 리스트(linked list)를 사용하는 빠른 C 구현 가능성을 열어둔다는 것입니다.</p>
<p><strong>OrderedDict는 알파벳순과 같은 다른 정렬 순서를 지원하나요?</strong>
아니요. 다른 정렬 순서를 원하는 경우 다른 기술을 사용해야 합니다. <code>OrderedDict</code>는 삽입 순서를 기록하는 것에 관한 것입니다. 다른 순서에 관심이 있다면 다른 구조(예: 인메모리(in-memory) <code>dbm</code>)가 더 적합할 것입니다.</p>
<p><strong>OrderedDict는 <code>json</code> 모듈, PyYAML, <code>ConfigParser</code>와 얼마나 잘 작동하나요?</strong></p>
<ul>
<li>
<p><code>json</code>의 경우, <code>json</code>의 인코더(encoder)가 <code>OrderedDict</code>의 이터레이션 순서를 존중한다는 점이 좋습니다.</p>
<pre><code class="language-python">>>> items = [('one', 1), ('two', 2), ('three',3), ('four',4), ('five',5)]
>>> json.dumps(OrderedDict(items))
'{"one": 1, "two": 2, "three": 3, "four": 4, "five": 5}'
</code></pre>
<p>Py2.6에서는 <code>json</code> 디코더(decoder)의 <code>object_hook</code>이 이미 빌드된 딕셔너리를 전달하므로 객체 훅이 보기 전에 순서가 손실됩니다. 이 문제는 순서를 보존하는 새로운 훅을 추가하여 Python 2.7/3.1에서 수정되고 있습니다. 새로운 훅을 사용하면 순서를 보존할 수 있습니다.</p>
<pre><code class="language-python">>>> jtext = '{"one": 1, "two": 2, "three": 3, "four": 4, "five": 5}'
>>> json.loads(jtext, object_pairs_hook=OrderedDict)
OrderedDict({'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5})
</code></pre>
</li>
<li>
<p>PyYAML의 경우, 완전한 왕복(round-trip)은 문제 없습니다.</p>
<pre><code class="language-python">>>> ytext = yaml.dump(OrderedDict(items))
>>> print ytext
!!python/object/apply:collections.OrderedDict
- - [one, 1]
  - [two, 2]
  - [three, 3]
  - [four, 4]
  - [five, 5]
>>> yaml.load(ytext)
OrderedDict({'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5})
</code></pre>
</li>
<li>
<p><code>ConfigParser</code> 모듈의 경우, 왕복 또한 문제 없습니다. 사용자 정의 딕셔너리는 Py2.6에서 순서 있는 딕셔너리를 특별히 지원하기 위해 추가되었습니다.</p>
<pre><code class="language-python">>>> config = ConfigParser(dict_type=OrderedDict)
>>> config.read('myconfig.ini')
>>> config.remove_option('Log', 'error')
>>> config.write(open('myconfig.ini', 'w'))
</code></pre>
</li>
</ul>
<p><strong>OrderedDict는 동등성 테스트(equality testing)를 어떻게 처리하나요?</strong>
두 <code>OrderedDict</code>를 비교하는 것은 테스트가 순서에 민감하다는 것을 의미하므로 <code>list(od1.items()) == list(od2.items())</code>와 같이 동작합니다.
<code>OrderedDict</code>가 다른 <code>Mapping</code>과 비교될 때는 순서에 민감하지 않은 비교가 사용됩니다. 이를 통해 <code>OrderedDict</code>는 일반 딕셔너리가 사용되는 모든 곳에서 대체될 수 있습니다.</p>
<p><strong><code>__repr__</code> 형식은 <code>repr</code>/<code>eval</code> 왕복 동안 순서를 어떻게 유지하나요?</strong>
<code>OrderedDict([('a', 1), ('b', 2)])</code>와 같이 표현되어 순서를 유지합니다.</p>
<p><strong>가능한 기본 데이터 구조의 장단점은 무엇인가요?</strong></p>
<ul>
<li><strong>정렬된 키 목록 유지:</strong> <code>__delitem__()</code>을 제외한 모든 연산에서 빠릅니다. <code>__delitem__()</code>은 O(n) 연산이 됩니다. 이 데이터 구조는 매우 간단한 코드와 적은 공간 낭비를 가져옵니다.</li>
<li><strong>삽입 순서 번호를 기록하기 위한 별도의 딕셔너리 유지:</strong> 코드가 약간 더 복잡해집니다. 모든 기본 연산은 O(1)이지만 <code>__setitem__()</code> 및 <code>__delitem__()</code>의 상수 인자(constant factor)가 증가하여 모든 사용 사례가 이 속도 향상에 대한 비용을 지불해야 합니다. 또한, 첫 번째 순회는 한 번의 O(n log n) 정렬 비용을 발생시킵니다. 저장 비용은 정렬된 키 목록 접근 방식의 두 배입니다.</li>
<li><strong>C로 작성된 버전(연결 리스트 사용):</strong> 코드는 다른 두 접근 방식보다 더 복잡하지만, 공간을 절약하고 일반 딕셔너리와 동일한 O 표기법 성능을 유지합니다. 가장 빠르고 공간 효율적입니다.</li>
</ul>
<h2>참조 구현 (Reference Implementation)</h2>
<p>테스트 및 문서가 포함된 구현은 OrderedDict patch에서 확인할 수 있습니다.</p>
<p>제안된 버전은 다음과 같은 몇 가지 장점이 있습니다:</p>
<ul>
<li><code>MutableMapping</code> API와의 엄격한 준수 및 새로운 메서드가 없어 학습 곡선이 거의 0입니다. 단순히 삽입 순서를 기억하는 딕셔너리입니다.</li>
<li>일반적으로 좋은 성능을 보입니다. 키 삭제가 O(n)인 것을 제외하고는 <code>dict</code>와 동일한 O 표기법 시간 복잡도를 가집니다.</li>
</ul>
<p>여기서 제안된 API에 영감을 준 다른 Python 프로젝트 또는 독립형 라이브러리의 <code>OrderedDict</code> 구현은 다음과 같습니다:</p>
<ul>
<li>Python의 <code>odict</code></li>
<li>Babel의 <code>odict</code></li>
<li>Django의 <code>OrderedDict</code></li>
<li><code>odict</code> 모듈</li>
<li><code>ordereddict</code> (<code>odict</code> 모듈의 C 구현)</li>
<li><code>StableDict</code></li>
<li>Armin Rigo의 <code>OrderedDict</code></li>
</ul>
<h2>향후 방향 (Future Directions)</h2>
<p>표준 라이브러리에 <code>OrderedDict</code>가 도입됨에 따라 다른 라이브러리들도 이를 활용할 수 있습니다. 예를 들어, <code>ElementTree</code>는 향후 소스 파일의 속성 순서를 유지하는 <code>OrderedDict</code>를 반환할 수 있습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 372 - Adding an ordered dictionary to collections"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 20:56:08+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":[["$","div",null,{"className":"page__taxonomy mb-4","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"카테고리"}],[["$","span","Python",{"className":"page__taxonomy-item","children":"Python"}],["$","span","PEP",{"className":"page__taxonomy-item","children":"PEP"}]]]}],["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]]}]]}]}]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","21",{"name":"next-size-adjust"}]]
1:null
