<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js"/><script src="/secrett2633.github.io/_next/static/chunks/fd9d1056-62aaf4b921c84028.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/23-ca4408d024135d8d.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/main-app-fa660020ba1e0b6e.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/231-c4b666723e6aae68.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/layout-8808afda01b7a1b7.js" async=""></script><script src="/secrett2633.github.io/_next/static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="next-size-adjust"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/secrett2633.github.io/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_9012cf layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/secrett2633.github.io">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Draft] PEP 789 - Preventing task-cancellation bugs by limiting yield in async generators</h1><div class="page__meta"><time dateTime="2025-09-27 14:04:23+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0789/">PEP 789 - Preventing task-cancellation bugs by limiting yield in async generators</a></p>
<p><strong>상태:</strong> Draft | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 14-May-2024</p>
</blockquote>
<p>PEP 789은 <code>async</code> 제너레이터에서 <code>yield</code> 사용을 제한하여 태스크 취소 관련 버그를 방지하는 것을 제안합니다. 이 PEP의 목표는 구조적 동시성(Structured Concurrency) 모델과 <code>yield</code>의 근본적인 비호환성으로 인해 발생하는 문제를 해결하는 것입니다.</p>
<h2>초록 (Abstract)</h2>
<p>Python에서 <code>asyncio.TaskGroup</code> 및 <code>asyncio.timeout</code>과 같은 구조적 동시성 인터페이스는 동시 태스크의 생명주기를 명확하게 관리하는 데 도움이 됩니다. 그러나 이러한 컨텍스트 내에서 <code>yield</code>를 사용하여 프레임을 일시 중단하면 잘못된 태스크가 취소되거나, 타임아웃이 무시되거나, 예외 처리가 잘못되는 문제가 발생합니다. 근본적으로 <code>TaskGroup</code> 내에서 프레임을 일시 중단하는 것은 자식 태스크가 부모 프레임 내에 캡슐화되어야 한다는 구조적 동시성 설계 원칙을 위반합니다.</p>
<p>이러한 문제를 해결하기 위해 PEP는 새로운 컨텍스트 매니저인 <code>sys.prevent_yields()</code>를 제안합니다. 이 컨텍스트 내에서 <code>yield</code>를 시도하면 <code>RuntimeError</code>가 발생하여 태스크가 <code>yield</code>할 수 없도록 합니다. 또한 <code>@contextmanager</code>와 같은 데코레이터가 데코레이트된 함수 내에서 <code>yield</code>를 허용할 수 있는 메커니즘도 제공될 예정입니다. <code>sys.prevent_yields()</code>는 <code>asyncio</code> 및 하위 라이브러리에서 태스크 그룹, 타임아웃, 취소 기능을 구현하는 데 사용될 것이며, <code>contextlib</code> 등에서는 제너레이터를 안전한 <code>yield</code>를 허용하는 컨텍스트 매니저로 변환하는 데 사용될 관련 메커니즘이 적용될 것입니다.</p>
<h2>배경 (Background)</h2>
<p>최신 <code>asyncio</code> 인터페이스와 Trio, anyio와 같은 서드파티 라이브러리의 형태로 Python에서 구조적 동시성이 점점 인기를 얻고 있습니다. 이러한 인터페이스는 사용자가 취소 범위(cancel scope) 내에서 프레임을 일시 중단하는 <code>yield</code>를 작성하지 않는 한, 구성적 추론(compositional reasoning)을 지원합니다.</p>
<p>취소 범위는 해당 컨텍스트 내에서 발생하는 작업을 취소할 수 있는 컨텍스트 매니저입니다. <code>asyncio</code>에서는 <code>with asyncio.timeout():</code> 또는 <code>async with asyncio.TaskGroup() as tg:</code>의 설계에 암시되어 있으며, 각각 지정된 기간 후에 포함된 작업을 취소하거나 자식 태스크 중 하나가 예외를 발생시켰을 때 형제 태스크를 취소합니다. 이 구조적 접근 방식은 취소 범위 내에서 <code>yield</code>를 통해 중첩 구조를 깨뜨릴 때까지는 잘 작동합니다. 이는 몇 개의 함수 간 <code>goto</code>를 추가하는 것과 유사하게 구조적 제어 흐름에 심각한 영향을 미칩니다:</p>
<ul>
<li>타임아웃, 형제 태스크의 오류, 또는 다른 태스크를 취소하려는 명시적 요청으로 인해 <strong>잘못된 태스크가 취소될 수 있습니다.</strong></li>
<li><code>CancelledError</code>를 포함한 <strong>예외가 잘못된 태스크로 전달될 수 있습니다.</strong></li>
<li>예외가 완전히 사라져 <code>ExceptionGroup</code>에 추가되지 않고 <strong>누락될 수 있습니다.</strong></li>
</ul>
<h2>문제 진술 (Problem statement)</h2>
<p>근본적인 문제는 <code>yield</code>가 호출 프레임을 일시 중단한다는 것입니다. <code>yield</code>는 리프 프레임(leaf frame)에서만 의미가 있습니다. 즉, 호출 스택이 A -> B -> C 순서일 때 C를 일시 중단할 수는 있지만, C가 실행 중인 상태에서 B를 일시 중단할 수는 없습니다.</p>
<p>하지만 <code>TaskGroup</code>은 단일 프레임이 여러 자식 프레임을 동시에 실행할 수 있는 "동시 호출(concurrent call)"의 한 종류입니다. 이는 <code>yield</code>와 <code>TaskGroup</code>을 혼합하여 사용하면 B가 일시 중단되었지만 C가 활발히 실행되는 상황이 발생할 수 있음을 의미합니다. 이는 말이 되지 않으며 심각한 실제 문제를 야기합니다 (예: C가 예외를 발생시켰는데 A가 이미 반환된 경우, 이를 전파할 방법이 없습니다).</p>
<p>이는 제너레이터 제어 흐름과 구조적 동시성 제어 흐름 간의 근본적인 비호환성이며, API를 조정해서는 해결할 수 없습니다. 유일한 해결책은 <code>TaskGroup</code> 내에서 <code>yield</code>를 금지하는 것으로 보입니다.</p>
<p>타임아웃은 자식 태스크를 남겨두지는 않지만, 이와 유사한 문제로 인해 <code>yield</code>는 <code>TaskGroup</code>뿐만 아니라 모든 취소 범위 내에서 금지되어야 한다고 결론 내립니다.</p>
<h2>동기 부여 예시 (Motivating examples)</h2>
<h3>타임아웃이 외부 범위로 누출되는 경우 (Leaking a timeout to the outer scope)</h3>
<p>각 요소에 대해 최대 <code>max_time</code>초 동안 대기하면서 비동기 이터레이터를 반복하고 싶다고 가정해 봅시다. 이 로직을 비동기 제너레이터로 캡슐화하여 호출 사이트가 일반적인 <code>async for</code> 루프를 계속 사용할 수 있도록 할 수 있습니다.</p>
<pre><code class="language-python">async def iter_with_timeout(ait, max_time):
    try:
        while True:
            with timeout(max_time):
                yield await anext(ait)
    except StopAsyncIteration:
        return

async def fn():
    async for elem in iter_with_timeout(ait, max_time=1.0):
        await do_something_with(elem)
</code></pre>
<p>이 코드에는 버그가 있습니다. 제너레이터가 <code>yield</code>한 후 다시 재개되기 전에 타임아웃이 만료될 수 있습니다. 이 경우, 외부 태스크에서 <code>CancelledError</code>가 발생하며, 이는 <code>with timeout(max_time):</code> 문에 의해 잡히지 않습니다.</p>
<p>해결책은 간단합니다. 타임아웃 컨텍스트 내에서 다음 요소를 얻은 다음, 해당 컨텍스트 밖에서 <code>yield</code>하는 것입니다.</p>
<pre><code class="language-python">async def correct_iter_with_timeout(ait, max_time):
    try:
        while True:
            with timeout(max_time):
                tmp = await anext(ait)
            yield tmp # yield는 타임아웃 컨텍스트 밖에서 이루어진다.
    except StopAsyncIteration:
        return
</code></pre>
<h3>백그라운드 태스크 누출 (취소 및 예외 처리 위반) (Leaking background tasks (breaks cancellation and exception handling))</h3>
<p>타임아웃만이 취소 범위를 감싸는 유일한 인터페이스는 아닙니다. 백그라운드 워커 태스크가 필요한 경우 <code>yield</code>하기 전에 <code>TaskGroup</code>을 단순히 닫을 수 없습니다.</p>
<p>여러 "센서"의 피드를 병합하는 팬인(fan-in) 제너레이터의 예를 들어봅시다.</p>
<pre><code class="language-python">import asyncio, itertools

async def mock_sensor(name):
    for n in itertools.count():
        await asyncio.sleep(0.1)
        if n == 1 and name == "b":
            yield "PRESENT"
        elif n == 3 and name == "a":
            print("oops, raising RuntimeError")
            raise RuntimeError
        else:
            yield f"{name}-{n}"

async def move_elements_to_queue(ait, queue):
    async for obj in ait:
        await queue.put(obj)

async def combined_iterators(*aits):
    """여러 이터레이터에서 공유 큐로 요소를 이동하는 N개의 태스크를 시작하여 비동기 이터레이터를 결합합니다."""
    q = asyncio.Queue(maxsize=2)
    async with asyncio.TaskGroup() as tg:
        for ait in aits:
            tg.create_task(move_elements_to_queue(ait, q))
        while True:
            yield await q.get() # TaskGroup 내에서 yield 발생!

async def turn_on_lights_when_someone_gets_home():
    combined = combined_iterators(mock_sensor("a"), mock_sensor("b"))
    async for event in combined:
        print(event)
        if event == "PRESENT":
            break
    print("main task sleeping for a bit")
    await asyncio.sleep(1) # 다른 작업 수행

asyncio.run(turn_on_lights_when_someone_gets_home())
</code></pre>
<p>이 코드를 실행하면 <code>RuntimeError</code>가 발생했지만, 이 예외를 관찰하지 못하고 <code>CancelledError</code>가 외부 태스크에 주입됩니다. 이는 <code>TaskGroup</code> 내에서 <code>yield</code>했기 때문입니다.</p>
<p>이 문제를 해결하려면 비동기 제너레이터를 비동기 컨텍스트 매니저로 변환해야 합니다. 이 컨텍스트 매니저는 비동기 이터러블(여기서는 큐를 래핑하는 제너레이터)을 <code>yield</code>합니다.</p>
<pre><code class="language-python">async def queue_as_aiterable(queue):
    # 취소 범위 내에서 `yield`하지 않는 비동기 제너레이터는 괜찮습니다!
    while True:
        try:
            yield await queue.get()
        except asyncio.QueueShutDown:
            return

@asynccontextmanager # 컨텍스트 매니저에서는 취소 범위 내에서 yield가 허용됩니다.
async def combined_iterators(*aits):
    q = asyncio.Queue(maxsize=2)
    async with asyncio.TaskGroup() as tg:
        for ait in aits:
            tg.create_task(move_elements_to_queue(ait, q))
        yield queue_as_aiterable(q) # yield는 컨텍스트 매니저의 일부로 허용됨

async def turn_on_lights_when_someone_gets_home():
    # ...
    async with combined_iterators(...) as ait:
        async for event in ait:
            # ...
</code></pre>
<h3>사용자 정의 컨텍스트 매니저에서 (In a user-defined context manager)</h3>
<p>취소 범위 내에서 <code>yield</code>하는 것은 제너레이터를 사용하여 컨텍스트 매니저를 구현하는 경우에만 안전합니다. 이 경우 전파되는 모든 예외는 예상된 태스크로 리디렉션됩니다. <code>flake8-async</code>의 <code>ASYNC101</code> 린터 규칙은 알려진 취소 범위 내에서 <code>yield</code>하는 것에 대해 경고합니다. 그러나 사용자 정의 컨텍스트 매니저도 취소 범위를 래핑할 수 있으며, 모든 경우를 인식하거나 린트하는 것은 불가능합니다.</p>
<h2>사양 (Specification)</h2>
<p>이러한 문제를 방지하기 위해 다음과 같이 제안합니다:</p>
<ol>
<li>새로운 컨텍스트 매니저인 <code>with sys.prevent_yields(reason): ...</code>를 도입하여, 이 컨텍스트 내에서 <code>yield</code>를 시도하면 <code>RuntimeError</code>를 발생시킵니다. <code>asyncio</code> 및 하위 코드의 취소 범위와 유사한 컨텍스트 매니저는 이를 래핑하여 <code>with</code> 블록 내에서 <code>yield</code>를 방지할 수 있습니다.</li>
<li>제너레이터를 컨텍스트 매니저로 변환하는 데코레이터가 한 번의 호출에 걸쳐 <code>yield</code>를 허용할 수 있는 메커니즘을 제공합니다. 이는 <code>fn.__code__.co_allow_yields = True</code>와 같은 코드 객체 속성이나 <code>fn.__invoke_with_yields__</code>와 같은 호출 플래그가 될 수 있습니다.</li>
</ol>
<h2>구현 - 프레임 추적 (Implementation - tracking frames)</h2>
<p>새로운 <code>sys.prevent_yields</code> 컨텍스트 매니저는 인터프리터 지원이 필요합니다. 각 프레임에 대해 이 컨텍스트 매니저의 진입 및 종료를 추적합니다.</p>
<p><code>yield</code> 시 다음과 같이 동작합니다:</p>
<ul>
<li><code>entries != []</code>이고 <code>frame.allow_yield_flag</code>가 <code>False</code>인 경우, <code>yield</code> 대신 <code>RuntimeError</code>를 발생시킵니다 (이 PEP가 제안하는 새로운 동작).</li>
<li>그렇지 않으면 반환 시와 마찬가지로 스택을 부모 프레임에 병합합니다.</li>
</ul>
<p>이는 태스크 내에서 프레임을 <code>yield</code>하는 것에 관한 것이므로, <code>syntactic yield</code> 및 <code>yield from</code>이 영향을 받지만 <code>await</code> 표현식은 영향을 받지 않습니다.</p>
<h2>작동 예시 (Worked examples)</h2>
<h3><code>yield</code> 없는 예시 (No-yield example)</h3>
<p><code>sys.prevent_yields</code>에서 사용자 정의 <code>ContextManager</code>를 거쳐 원래 <code>Frame</code>으로 되감는 과정에서 스택 병합이 여러 번 발생합니다. <code>yield</code>가 없으면 오류가 발생하지 않으며, 진입 및 종료 횟수가 균형을 이루므로 프레임은 추가 추적 없이 평소와 같이 반환됩니다.</p>
<h3><code>yield</code> 시도 예시 (Attempts-to-yield example)</h3>
<p>이 예시에서는 <code>Frame</code>이 <code>sys.prevent_yields</code> 컨텍스트 내에서 <code>yield</code>를 시도합니다. 이는 인터프리터에 의해 감지되어 프레임을 일시 중단하는 대신 <code>RuntimeError</code>를 발생시킵니다.</p>
<h3><code>yield</code> 허용 예시 (Allowed-to-yield example)</h3>
<p>이 예시에서는 데코레이터가 <code>Frame</code>이 <code>yield</code>를 허용하도록 표시했습니다. 이는 <code>@contextlib.contextmanager</code> 또는 관련 데코레이터일 수 있습니다. <code>Frame</code>이 <code>yield</code>를 허용할 때, 진입/종료 스택은 일시 중단되기 전에 부모 프레임의 스택에 병합됩니다. <code>Frame</code>이 재개될 때 스택은 비어 있습니다. 마지막으로 <code>Frame</code>이 종료되면 종료가 부모 프레임의 스택에 병합되어 균형을 재조정합니다. 이는 부모 프레임이 남아있는 <code>sys.prevent_yields</code> 상태를 올바르게 상속하도록 보장하며, <code>Frame</code>이 안전하게 일시 중단 및 재개될 수 있도록 합니다.</p>
<h2><code>sys.prevent_yields</code>의 오용 시 동작 (Behavior if sys.prevent_yields is misused)</h2>
<p><code>sys.prevent_yields.__enter__</code> 및 <code>.__exit__</code>를 유효한 중첩과 일치하지 않는 순서로 호출하거나 다른 방식으로 유효하지 않은 프레임 상태를 얻을 수 있습니다. <code>sys.prevent_yields.__exit__</code>가 유효하지 않은 상태를 감지할 수 있는 두 가지 방법이 있습니다. 첫째, <code>yield</code>가 방지되지 않은 경우, 상태를 변경하지 않고 예외를 발생시킬 수 있습니다. 둘째, 예상치 못한 진입이 스택의 맨 위에 있는 경우, 해당 진입을 팝하고 예외를 발생시킬 것을 제안합니다. 이는 순서가 뒤바뀐 호출도 스택을 비우면서도 문제가 있음을 명확히 합니다.</p>
<h2>예상되는 용도 (Anticipated uses)</h2>
<p>표준 라이브러리에서는 <code>asyncio.TaskGroup</code>, <code>asyncio.timeout</code>, <code>asyncio.timeout_at</code>에서 <code>sys.prevent_yields</code>를 사용할 수 있습니다. 하위 라이브러리에서는 <code>trio.CancelScope</code>, 비동기 픽스처(pytest-trio, anyio 등) 및 기타 여러 곳에서 사용될 것으로 예상됩니다.</p>
<p>제너레이터를 컨텍스트 매니저로 지원하는 기능은 <code>@contextlib.(async)contextmanager</code>에서 사용될 것이며, 필요한 경우 <code>(Async)ExitStack</code>에서도 사용될 것입니다.</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p><code>sys.prevent_yields</code> 컨텍스트 매니저의 추가, <code>@contextlib.(async)contextmanager</code>의 변경, 그리고 해당 인터프리터 지원은 모두 완벽하게 하위 호환됩니다.</p>
<p><code>asyncio.TaskGroup</code>, <code>asyncio.timeout</code>, <code>asyncio.timeout_at</code> 내에서 <code>yield</code>를 방지하는 것은 현재 사용 중인 일부 코드에 대한 **호환성 파괴 변경(breaking change)**이 될 수 있습니다. 이러한 코드는 안전하지 않더라도 실제 환경에서 작동하는 경우가 많을 수 있기 때문입니다.</p>
<p>표준 라이브러리 코드에 대한 적절한 비권장(deprecation) 경로에 대해 커뮤니티 피드백을 구할 것이며, 여기에는 비권장 기간의 길이도 포함됩니다. 초기 제안으로, 3.14 버전의 <code>asyncio</code> 디버그 모드에서만 표준 라이브러리 컨텍스트 내에서 일시 중단할 때 <code>DeprecationWarning</code>을 발생시키고, 3.15 버전에서는 기본적으로 경고를 발생시키고 디버그 모드에서 오류를 발생시키며, 마지막으로 3.16 버전에서는 하드 에러로 만들 수 있습니다.</p>
<p>표준 라이브러리 사용 여부와 관계없이 하위 프레임워크는 이 기능을 즉시 채택할 것입니다.</p>
<h3>이 버그는 얼마나 널리 퍼져 있습니까? (How widespread is this bug?)</h3>
<p>명확한 수치는 없지만, 많은 프로젝트가 영향을 받는 것으로 추정됩니다.</p>
<h2>교육 방법 (How to Teach This)</h2>
<p>대부분의 중급 및 고급 Python 프로그래머는 <code>TaskGroup</code>, <code>timeout</code>, <code>@contextmanager</code>의 사용자로서 이 PEP와 상호작용할 것입니다. 이 그룹에게는 명확한 예외 메시지와 문서로 충분할 것으로 예상됩니다.</p>
<p><code>asyncio</code> 개발 페이지에 새 섹션이 추가되어, <code>async</code> 제너레이터는 "취소 범위" 컨텍스트(예: <code>TaskGroup</code> 또는 <code>timeout</code> 컨텍스트 매니저) 내에서 <code>yield</code>할 수 없다고 간략하게 명시할 것입니다.</p>
<p>각 취소 범위 컨텍스트 매니저(따라서 이제 <code>sys.prevent_yields</code>를 래핑하는) 문서에는 "[이 컨텍스트 매니저 내에서 <code>yield</code>하는 것은 오류입니다.]"와 같은 표준 문장이 포함될 것이며, 위의 설명으로 하이퍼링크될 것입니다.</p>
<h2>거부된 대안 (Rejected alternatives)</h2>
<h3>PEP 533, 이터레이터를 위한 결정론적 정리 (PEP 533, deterministic cleanup for iterators)</h3>
<p>PEP 533은 이터레이터 프로토콜에 <code>__[a]iterclose__</code>를 추가하여 각 <code>(async) for</code> 루프를 <code>with [a]closing(ait)</code>으로 래핑하는 것을 제안합니다. 이는 이터레이터가 보유한 리소스의 시기적절하고 결정론적인 정리를 보장하는 데 유용하지만, 이 PEP가 해결하려는 모든 문제를 완전히 해결하지는 못합니다. PEP 533이 있더라도 잘못된 취소는 여전히 잘못된 태스크로 전달될 수 있으며, 이터레이터가 닫히기 전에 문제를 일으킬 수 있습니다. 또한, <code>TaskGroup</code>과의 근본적인 구조적 동시성 문제를 해결하지 못합니다.</p>
<h3>비동기 제너레이터 전체를 비권장 (Deprecate async generators entirely)</h3>
<p>2024년 언어 서밋에서 일부 참석자들은 대신 비동기 제너레이터를 완전히 비권장할 것을 제안했습니다. 하지만 Trio 코드에서는 표준 제너레이터로도 동일한 문제가 발생할 수 있습니다. 또한, <code>decimal.localcontext</code>와 같이 취소 범위가 아닌 일부 동기 컨텍스트 매니저도 관련 문제를 나타냅니다. 비동기 제너레이터를 언어에서 제거하기보다는 문제를 해결하는 것이 바람직하다는 의견이 있었습니다.</p>
<h3>예외를 올바른 위치로 전달할 수 없습니까? (Can't we just deliver exceptions to the right place?)</h3>
<p>PEP 568(컨텍스트 변수에 대한 제너레이터 민감성; PEP 550 참조)을 구현하면 타임아웃으로 인한 예외를 처리할 수 있을 것입니다. 그러나 이는 <code>TaskGroup</code>과의 또 다른 문제를 해결하지 못합니다. 제너레이터 모델은 스택 프레임을 일시 중단된 상태로 만들고 이를 저장, 이동, 또는 임의의 위치에서 폐기하거나 되살릴 수 있는 비활성 값으로 취급하는 것입니다. 구조적 동시성 모델은 스택이 트리(tree)가 되며, 자식 태스크가 부모 프레임 내에 캡슐화되는 것입니다. 이 두 모델은 기본 구조적 프로그래밍 모델을 다른, 그리고 불행히도 호환되지 않는 방향으로 확장하고 있습니다. 모든 자식 태스크를 함께 일시 중단하는 것을 가정해도, 다른 태스크에서 제너레이터를 재개할 수 있어 구조적 동시성의 "상향식" 불변성을 위반할 수 있습니다. TaskGroup 문제를 해결하지 못하면서 취소 범위를 처리하기 위해 많은 메커니즘을 추가하는 것은 가치가 없다고 생각됩니다.</p>
<h3>대체 구현 - 바이트코드 검사 (Alternative implementation - inspecting bytecode)</h3>
<p><code>sys.prevent_yields</code>가 호출자의 바이트코드를 검사하여 호출 명령 포인터와 다음 컨텍스트 종료 사이에 <code>yield</code>가 없는지 확인하는 대안이 제안되었습니다. 그러나 사용자 정의 컨텍스트 매니저가 <code>sys.prevent_yields</code>를 래핑할 때 어떻게 작동할지 불분명하며, <code>__enter__()</code> 및 <code>__exit__()</code>에 대한 명시적 호출을 무시하여 <code>with</code> 문 사용 여부에 따라 컨텍스트 관리 프로토콜이 달라질 수 있습니다. "사용하는 경우에만 비용을 지불하는" 성능 비용은 매력적이지만, 프레임 객체 검사는 핵심 제어 흐름 구성 요소에 대해 지나치게 비싸고 전체 프로그램 속도 저하를 야기합니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy mb-4"><h4 class="text-sm font-medium text-gray-900 mb-2">카테고리</h4><span class="page__taxonomy-item">Python</span><span class="page__taxonomy-item">PEP</span></div><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/secrett2633.github.io/_next/static/chunks/webpack-a04af954a21fa650.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/secrett2633.github.io/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[4281,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"185\",\"static/chunks/app/layout-8808afda01b7a1b7.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c4b666723e6aae68.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-01b66e77b48ed573.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/789\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/secrett2633.github.io/_next/static/css/b9d6ec750ad82add.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"iV6XySbMHIJ3imQdvgy3I\",\"assetPrefix\":\"/secrett2633.github.io\",\"initialCanonicalUrl\":\"/python/pep/789/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/789\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"789\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/789\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"32x32\",\"href\":\"/favicon-32x32.png\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"type\":\"image/png\",\"sizes\":\"16x16\",\"href\":\"/favicon-16x16.png\"}],[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_9012cf layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T57c1,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0789/\"\u003ePEP 789 - Preventing task-cancellation bugs by limiting yield in async generators\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Draft | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 14-May-2024\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 789은 \u003ccode\u003easync\u003c/code\u003e 제너레이터에서 \u003ccode\u003eyield\u003c/code\u003e 사용을 제한하여 태스크 취소 관련 버그를 방지하는 것을 제안합니다. 이 PEP의 목표는 구조적 동시성(Structured Concurrency) 모델과 \u003ccode\u003eyield\u003c/code\u003e의 근본적인 비호환성으로 인해 발생하는 문제를 해결하는 것입니다.\u003c/p\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003ePython에서 \u003ccode\u003easyncio.TaskGroup\u003c/code\u003e 및 \u003ccode\u003easyncio.timeout\u003c/code\u003e과 같은 구조적 동시성 인터페이스는 동시 태스크의 생명주기를 명확하게 관리하는 데 도움이 됩니다. 그러나 이러한 컨텍스트 내에서 \u003ccode\u003eyield\u003c/code\u003e를 사용하여 프레임을 일시 중단하면 잘못된 태스크가 취소되거나, 타임아웃이 무시되거나, 예외 처리가 잘못되는 문제가 발생합니다. 근본적으로 \u003ccode\u003eTaskGroup\u003c/code\u003e 내에서 프레임을 일시 중단하는 것은 자식 태스크가 부모 프레임 내에 캡슐화되어야 한다는 구조적 동시성 설계 원칙을 위반합니다.\u003c/p\u003e\n\u003cp\u003e이러한 문제를 해결하기 위해 PEP는 새로운 컨텍스트 매니저인 \u003ccode\u003esys.prevent_yields()\u003c/code\u003e를 제안합니다. 이 컨텍스트 내에서 \u003ccode\u003eyield\u003c/code\u003e를 시도하면 \u003ccode\u003eRuntimeError\u003c/code\u003e가 발생하여 태스크가 \u003ccode\u003eyield\u003c/code\u003e할 수 없도록 합니다. 또한 \u003ccode\u003e@contextmanager\u003c/code\u003e와 같은 데코레이터가 데코레이트된 함수 내에서 \u003ccode\u003eyield\u003c/code\u003e를 허용할 수 있는 메커니즘도 제공될 예정입니다. \u003ccode\u003esys.prevent_yields()\u003c/code\u003e는 \u003ccode\u003easyncio\u003c/code\u003e 및 하위 라이브러리에서 태스크 그룹, 타임아웃, 취소 기능을 구현하는 데 사용될 것이며, \u003ccode\u003econtextlib\u003c/code\u003e 등에서는 제너레이터를 안전한 \u003ccode\u003eyield\u003c/code\u003e를 허용하는 컨텍스트 매니저로 변환하는 데 사용될 관련 메커니즘이 적용될 것입니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Background)\u003c/h2\u003e\n\u003cp\u003e최신 \u003ccode\u003easyncio\u003c/code\u003e 인터페이스와 Trio, anyio와 같은 서드파티 라이브러리의 형태로 Python에서 구조적 동시성이 점점 인기를 얻고 있습니다. 이러한 인터페이스는 사용자가 취소 범위(cancel scope) 내에서 프레임을 일시 중단하는 \u003ccode\u003eyield\u003c/code\u003e를 작성하지 않는 한, 구성적 추론(compositional reasoning)을 지원합니다.\u003c/p\u003e\n\u003cp\u003e취소 범위는 해당 컨텍스트 내에서 발생하는 작업을 취소할 수 있는 컨텍스트 매니저입니다. \u003ccode\u003easyncio\u003c/code\u003e에서는 \u003ccode\u003ewith asyncio.timeout():\u003c/code\u003e 또는 \u003ccode\u003easync with asyncio.TaskGroup() as tg:\u003c/code\u003e의 설계에 암시되어 있으며, 각각 지정된 기간 후에 포함된 작업을 취소하거나 자식 태스크 중 하나가 예외를 발생시켰을 때 형제 태스크를 취소합니다. 이 구조적 접근 방식은 취소 범위 내에서 \u003ccode\u003eyield\u003c/code\u003e를 통해 중첩 구조를 깨뜨릴 때까지는 잘 작동합니다. 이는 몇 개의 함수 간 \u003ccode\u003egoto\u003c/code\u003e를 추가하는 것과 유사하게 구조적 제어 흐름에 심각한 영향을 미칩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e타임아웃, 형제 태스크의 오류, 또는 다른 태스크를 취소하려는 명시적 요청으로 인해 \u003cstrong\u003e잘못된 태스크가 취소될 수 있습니다.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCancelledError\u003c/code\u003e를 포함한 \u003cstrong\u003e예외가 잘못된 태스크로 전달될 수 있습니다.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e예외가 완전히 사라져 \u003ccode\u003eExceptionGroup\u003c/code\u003e에 추가되지 않고 \u003cstrong\u003e누락될 수 있습니다.\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e문제 진술 (Problem statement)\u003c/h2\u003e\n\u003cp\u003e근본적인 문제는 \u003ccode\u003eyield\u003c/code\u003e가 호출 프레임을 일시 중단한다는 것입니다. \u003ccode\u003eyield\u003c/code\u003e는 리프 프레임(leaf frame)에서만 의미가 있습니다. 즉, 호출 스택이 A -\u003e B -\u003e C 순서일 때 C를 일시 중단할 수는 있지만, C가 실행 중인 상태에서 B를 일시 중단할 수는 없습니다.\u003c/p\u003e\n\u003cp\u003e하지만 \u003ccode\u003eTaskGroup\u003c/code\u003e은 단일 프레임이 여러 자식 프레임을 동시에 실행할 수 있는 \"동시 호출(concurrent call)\"의 한 종류입니다. 이는 \u003ccode\u003eyield\u003c/code\u003e와 \u003ccode\u003eTaskGroup\u003c/code\u003e을 혼합하여 사용하면 B가 일시 중단되었지만 C가 활발히 실행되는 상황이 발생할 수 있음을 의미합니다. 이는 말이 되지 않으며 심각한 실제 문제를 야기합니다 (예: C가 예외를 발생시켰는데 A가 이미 반환된 경우, 이를 전파할 방법이 없습니다).\u003c/p\u003e\n\u003cp\u003e이는 제너레이터 제어 흐름과 구조적 동시성 제어 흐름 간의 근본적인 비호환성이며, API를 조정해서는 해결할 수 없습니다. 유일한 해결책은 \u003ccode\u003eTaskGroup\u003c/code\u003e 내에서 \u003ccode\u003eyield\u003c/code\u003e를 금지하는 것으로 보입니다.\u003c/p\u003e\n\u003cp\u003e타임아웃은 자식 태스크를 남겨두지는 않지만, 이와 유사한 문제로 인해 \u003ccode\u003eyield\u003c/code\u003e는 \u003ccode\u003eTaskGroup\u003c/code\u003e뿐만 아니라 모든 취소 범위 내에서 금지되어야 한다고 결론 내립니다.\u003c/p\u003e\n\u003ch2\u003e동기 부여 예시 (Motivating examples)\u003c/h2\u003e\n\u003ch3\u003e타임아웃이 외부 범위로 누출되는 경우 (Leaking a timeout to the outer scope)\u003c/h3\u003e\n\u003cp\u003e각 요소에 대해 최대 \u003ccode\u003emax_time\u003c/code\u003e초 동안 대기하면서 비동기 이터레이터를 반복하고 싶다고 가정해 봅시다. 이 로직을 비동기 제너레이터로 캡슐화하여 호출 사이트가 일반적인 \u003ccode\u003easync for\u003c/code\u003e 루프를 계속 사용할 수 있도록 할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def iter_with_timeout(ait, max_time):\n    try:\n        while True:\n            with timeout(max_time):\n                yield await anext(ait)\n    except StopAsyncIteration:\n        return\n\nasync def fn():\n    async for elem in iter_with_timeout(ait, max_time=1.0):\n        await do_something_with(elem)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드에는 버그가 있습니다. 제너레이터가 \u003ccode\u003eyield\u003c/code\u003e한 후 다시 재개되기 전에 타임아웃이 만료될 수 있습니다. 이 경우, 외부 태스크에서 \u003ccode\u003eCancelledError\u003c/code\u003e가 발생하며, 이는 \u003ccode\u003ewith timeout(max_time):\u003c/code\u003e 문에 의해 잡히지 않습니다.\u003c/p\u003e\n\u003cp\u003e해결책은 간단합니다. 타임아웃 컨텍스트 내에서 다음 요소를 얻은 다음, 해당 컨텍스트 밖에서 \u003ccode\u003eyield\u003c/code\u003e하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def correct_iter_with_timeout(ait, max_time):\n    try:\n        while True:\n            with timeout(max_time):\n                tmp = await anext(ait)\n            yield tmp # yield는 타임아웃 컨텍스트 밖에서 이루어진다.\n    except StopAsyncIteration:\n        return\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e백그라운드 태스크 누출 (취소 및 예외 처리 위반) (Leaking background tasks (breaks cancellation and exception handling))\u003c/h3\u003e\n\u003cp\u003e타임아웃만이 취소 범위를 감싸는 유일한 인터페이스는 아닙니다. 백그라운드 워커 태스크가 필요한 경우 \u003ccode\u003eyield\u003c/code\u003e하기 전에 \u003ccode\u003eTaskGroup\u003c/code\u003e을 단순히 닫을 수 없습니다.\u003c/p\u003e\n\u003cp\u003e여러 \"센서\"의 피드를 병합하는 팬인(fan-in) 제너레이터의 예를 들어봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport asyncio, itertools\n\nasync def mock_sensor(name):\n    for n in itertools.count():\n        await asyncio.sleep(0.1)\n        if n == 1 and name == \"b\":\n            yield \"PRESENT\"\n        elif n == 3 and name == \"a\":\n            print(\"oops, raising RuntimeError\")\n            raise RuntimeError\n        else:\n            yield f\"{name}-{n}\"\n\nasync def move_elements_to_queue(ait, queue):\n    async for obj in ait:\n        await queue.put(obj)\n\nasync def combined_iterators(*aits):\n    \"\"\"여러 이터레이터에서 공유 큐로 요소를 이동하는 N개의 태스크를 시작하여 비동기 이터레이터를 결합합니다.\"\"\"\n    q = asyncio.Queue(maxsize=2)\n    async with asyncio.TaskGroup() as tg:\n        for ait in aits:\n            tg.create_task(move_elements_to_queue(ait, q))\n        while True:\n            yield await q.get() # TaskGroup 내에서 yield 발생!\n\nasync def turn_on_lights_when_someone_gets_home():\n    combined = combined_iterators(mock_sensor(\"a\"), mock_sensor(\"b\"))\n    async for event in combined:\n        print(event)\n        if event == \"PRESENT\":\n            break\n    print(\"main task sleeping for a bit\")\n    await asyncio.sleep(1) # 다른 작업 수행\n\nasyncio.run(turn_on_lights_when_someone_gets_home())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드를 실행하면 \u003ccode\u003eRuntimeError\u003c/code\u003e가 발생했지만, 이 예외를 관찰하지 못하고 \u003ccode\u003eCancelledError\u003c/code\u003e가 외부 태스크에 주입됩니다. 이는 \u003ccode\u003eTaskGroup\u003c/code\u003e 내에서 \u003ccode\u003eyield\u003c/code\u003e했기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이 문제를 해결하려면 비동기 제너레이터를 비동기 컨텍스트 매니저로 변환해야 합니다. 이 컨텍스트 매니저는 비동기 이터러블(여기서는 큐를 래핑하는 제너레이터)을 \u003ccode\u003eyield\u003c/code\u003e합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def queue_as_aiterable(queue):\n    # 취소 범위 내에서 `yield`하지 않는 비동기 제너레이터는 괜찮습니다!\n    while True:\n        try:\n            yield await queue.get()\n        except asyncio.QueueShutDown:\n            return\n\n@asynccontextmanager # 컨텍스트 매니저에서는 취소 범위 내에서 yield가 허용됩니다.\nasync def combined_iterators(*aits):\n    q = asyncio.Queue(maxsize=2)\n    async with asyncio.TaskGroup() as tg:\n        for ait in aits:\n            tg.create_task(move_elements_to_queue(ait, q))\n        yield queue_as_aiterable(q) # yield는 컨텍스트 매니저의 일부로 허용됨\n\nasync def turn_on_lights_when_someone_gets_home():\n    # ...\n    async with combined_iterators(...) as ait:\n        async for event in ait:\n            # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e사용자 정의 컨텍스트 매니저에서 (In a user-defined context manager)\u003c/h3\u003e\n\u003cp\u003e취소 범위 내에서 \u003ccode\u003eyield\u003c/code\u003e하는 것은 제너레이터를 사용하여 컨텍스트 매니저를 구현하는 경우에만 안전합니다. 이 경우 전파되는 모든 예외는 예상된 태스크로 리디렉션됩니다. \u003ccode\u003eflake8-async\u003c/code\u003e의 \u003ccode\u003eASYNC101\u003c/code\u003e 린터 규칙은 알려진 취소 범위 내에서 \u003ccode\u003eyield\u003c/code\u003e하는 것에 대해 경고합니다. 그러나 사용자 정의 컨텍스트 매니저도 취소 범위를 래핑할 수 있으며, 모든 경우를 인식하거나 린트하는 것은 불가능합니다.\u003c/p\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003cp\u003e이러한 문제를 방지하기 위해 다음과 같이 제안합니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e새로운 컨텍스트 매니저인 \u003ccode\u003ewith sys.prevent_yields(reason): ...\u003c/code\u003e를 도입하여, 이 컨텍스트 내에서 \u003ccode\u003eyield\u003c/code\u003e를 시도하면 \u003ccode\u003eRuntimeError\u003c/code\u003e를 발생시킵니다. \u003ccode\u003easyncio\u003c/code\u003e 및 하위 코드의 취소 범위와 유사한 컨텍스트 매니저는 이를 래핑하여 \u003ccode\u003ewith\u003c/code\u003e 블록 내에서 \u003ccode\u003eyield\u003c/code\u003e를 방지할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e제너레이터를 컨텍스트 매니저로 변환하는 데코레이터가 한 번의 호출에 걸쳐 \u003ccode\u003eyield\u003c/code\u003e를 허용할 수 있는 메커니즘을 제공합니다. 이는 \u003ccode\u003efn.__code__.co_allow_yields = True\u003c/code\u003e와 같은 코드 객체 속성이나 \u003ccode\u003efn.__invoke_with_yields__\u003c/code\u003e와 같은 호출 플래그가 될 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e구현 - 프레임 추적 (Implementation - tracking frames)\u003c/h2\u003e\n\u003cp\u003e새로운 \u003ccode\u003esys.prevent_yields\u003c/code\u003e 컨텍스트 매니저는 인터프리터 지원이 필요합니다. 각 프레임에 대해 이 컨텍스트 매니저의 진입 및 종료를 추적합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eyield\u003c/code\u003e 시 다음과 같이 동작합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eentries != []\u003c/code\u003e이고 \u003ccode\u003eframe.allow_yield_flag\u003c/code\u003e가 \u003ccode\u003eFalse\u003c/code\u003e인 경우, \u003ccode\u003eyield\u003c/code\u003e 대신 \u003ccode\u003eRuntimeError\u003c/code\u003e를 발생시킵니다 (이 PEP가 제안하는 새로운 동작).\u003c/li\u003e\n\u003cli\u003e그렇지 않으면 반환 시와 마찬가지로 스택을 부모 프레임에 병합합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 태스크 내에서 프레임을 \u003ccode\u003eyield\u003c/code\u003e하는 것에 관한 것이므로, \u003ccode\u003esyntactic yield\u003c/code\u003e 및 \u003ccode\u003eyield from\u003c/code\u003e이 영향을 받지만 \u003ccode\u003eawait\u003c/code\u003e 표현식은 영향을 받지 않습니다.\u003c/p\u003e\n\u003ch2\u003e작동 예시 (Worked examples)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003eyield\u003c/code\u003e 없는 예시 (No-yield example)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esys.prevent_yields\u003c/code\u003e에서 사용자 정의 \u003ccode\u003eContextManager\u003c/code\u003e를 거쳐 원래 \u003ccode\u003eFrame\u003c/code\u003e으로 되감는 과정에서 스택 병합이 여러 번 발생합니다. \u003ccode\u003eyield\u003c/code\u003e가 없으면 오류가 발생하지 않으며, 진입 및 종료 횟수가 균형을 이루므로 프레임은 추가 추적 없이 평소와 같이 반환됩니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eyield\u003c/code\u003e 시도 예시 (Attempts-to-yield example)\u003c/h3\u003e\n\u003cp\u003e이 예시에서는 \u003ccode\u003eFrame\u003c/code\u003e이 \u003ccode\u003esys.prevent_yields\u003c/code\u003e 컨텍스트 내에서 \u003ccode\u003eyield\u003c/code\u003e를 시도합니다. 이는 인터프리터에 의해 감지되어 프레임을 일시 중단하는 대신 \u003ccode\u003eRuntimeError\u003c/code\u003e를 발생시킵니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eyield\u003c/code\u003e 허용 예시 (Allowed-to-yield example)\u003c/h3\u003e\n\u003cp\u003e이 예시에서는 데코레이터가 \u003ccode\u003eFrame\u003c/code\u003e이 \u003ccode\u003eyield\u003c/code\u003e를 허용하도록 표시했습니다. 이는 \u003ccode\u003e@contextlib.contextmanager\u003c/code\u003e 또는 관련 데코레이터일 수 있습니다. \u003ccode\u003eFrame\u003c/code\u003e이 \u003ccode\u003eyield\u003c/code\u003e를 허용할 때, 진입/종료 스택은 일시 중단되기 전에 부모 프레임의 스택에 병합됩니다. \u003ccode\u003eFrame\u003c/code\u003e이 재개될 때 스택은 비어 있습니다. 마지막으로 \u003ccode\u003eFrame\u003c/code\u003e이 종료되면 종료가 부모 프레임의 스택에 병합되어 균형을 재조정합니다. 이는 부모 프레임이 남아있는 \u003ccode\u003esys.prevent_yields\u003c/code\u003e 상태를 올바르게 상속하도록 보장하며, \u003ccode\u003eFrame\u003c/code\u003e이 안전하게 일시 중단 및 재개될 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003e\u003ccode\u003esys.prevent_yields\u003c/code\u003e의 오용 시 동작 (Behavior if sys.prevent_yields is misused)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esys.prevent_yields.__enter__\u003c/code\u003e 및 \u003ccode\u003e.__exit__\u003c/code\u003e를 유효한 중첩과 일치하지 않는 순서로 호출하거나 다른 방식으로 유효하지 않은 프레임 상태를 얻을 수 있습니다. \u003ccode\u003esys.prevent_yields.__exit__\u003c/code\u003e가 유효하지 않은 상태를 감지할 수 있는 두 가지 방법이 있습니다. 첫째, \u003ccode\u003eyield\u003c/code\u003e가 방지되지 않은 경우, 상태를 변경하지 않고 예외를 발생시킬 수 있습니다. 둘째, 예상치 못한 진입이 스택의 맨 위에 있는 경우, 해당 진입을 팝하고 예외를 발생시킬 것을 제안합니다. 이는 순서가 뒤바뀐 호출도 스택을 비우면서도 문제가 있음을 명확히 합니다.\u003c/p\u003e\n\u003ch2\u003e예상되는 용도 (Anticipated uses)\u003c/h2\u003e\n\u003cp\u003e표준 라이브러리에서는 \u003ccode\u003easyncio.TaskGroup\u003c/code\u003e, \u003ccode\u003easyncio.timeout\u003c/code\u003e, \u003ccode\u003easyncio.timeout_at\u003c/code\u003e에서 \u003ccode\u003esys.prevent_yields\u003c/code\u003e를 사용할 수 있습니다. 하위 라이브러리에서는 \u003ccode\u003etrio.CancelScope\u003c/code\u003e, 비동기 픽스처(pytest-trio, anyio 등) 및 기타 여러 곳에서 사용될 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e제너레이터를 컨텍스트 매니저로 지원하는 기능은 \u003ccode\u003e@contextlib.(async)contextmanager\u003c/code\u003e에서 사용될 것이며, 필요한 경우 \u003ccode\u003e(Async)ExitStack\u003c/code\u003e에서도 사용될 것입니다.\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esys.prevent_yields\u003c/code\u003e 컨텍스트 매니저의 추가, \u003ccode\u003e@contextlib.(async)contextmanager\u003c/code\u003e의 변경, 그리고 해당 인터프리터 지원은 모두 완벽하게 하위 호환됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003easyncio.TaskGroup\u003c/code\u003e, \u003ccode\u003easyncio.timeout\u003c/code\u003e, \u003ccode\u003easyncio.timeout_at\u003c/code\u003e 내에서 \u003ccode\u003eyield\u003c/code\u003e를 방지하는 것은 현재 사용 중인 일부 코드에 대한 **호환성 파괴 변경(breaking change)**이 될 수 있습니다. 이러한 코드는 안전하지 않더라도 실제 환경에서 작동하는 경우가 많을 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e표준 라이브러리 코드에 대한 적절한 비권장(deprecation) 경로에 대해 커뮤니티 피드백을 구할 것이며, 여기에는 비권장 기간의 길이도 포함됩니다. 초기 제안으로, 3.14 버전의 \u003ccode\u003easyncio\u003c/code\u003e 디버그 모드에서만 표준 라이브러리 컨텍스트 내에서 일시 중단할 때 \u003ccode\u003eDeprecationWarning\u003c/code\u003e을 발생시키고, 3.15 버전에서는 기본적으로 경고를 발생시키고 디버그 모드에서 오류를 발생시키며, 마지막으로 3.16 버전에서는 하드 에러로 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e표준 라이브러리 사용 여부와 관계없이 하위 프레임워크는 이 기능을 즉시 채택할 것입니다.\u003c/p\u003e\n\u003ch3\u003e이 버그는 얼마나 널리 퍼져 있습니까? (How widespread is this bug?)\u003c/h3\u003e\n\u003cp\u003e명확한 수치는 없지만, 많은 프로젝트가 영향을 받는 것으로 추정됩니다.\u003c/p\u003e\n\u003ch2\u003e교육 방법 (How to Teach This)\u003c/h2\u003e\n\u003cp\u003e대부분의 중급 및 고급 Python 프로그래머는 \u003ccode\u003eTaskGroup\u003c/code\u003e, \u003ccode\u003etimeout\u003c/code\u003e, \u003ccode\u003e@contextmanager\u003c/code\u003e의 사용자로서 이 PEP와 상호작용할 것입니다. 이 그룹에게는 명확한 예외 메시지와 문서로 충분할 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003easyncio\u003c/code\u003e 개발 페이지에 새 섹션이 추가되어, \u003ccode\u003easync\u003c/code\u003e 제너레이터는 \"취소 범위\" 컨텍스트(예: \u003ccode\u003eTaskGroup\u003c/code\u003e 또는 \u003ccode\u003etimeout\u003c/code\u003e 컨텍스트 매니저) 내에서 \u003ccode\u003eyield\u003c/code\u003e할 수 없다고 간략하게 명시할 것입니다.\u003c/p\u003e\n\u003cp\u003e각 취소 범위 컨텍스트 매니저(따라서 이제 \u003ccode\u003esys.prevent_yields\u003c/code\u003e를 래핑하는) 문서에는 \"[이 컨텍스트 매니저 내에서 \u003ccode\u003eyield\u003c/code\u003e하는 것은 오류입니다.]\"와 같은 표준 문장이 포함될 것이며, 위의 설명으로 하이퍼링크될 것입니다.\u003c/p\u003e\n\u003ch2\u003e거부된 대안 (Rejected alternatives)\u003c/h2\u003e\n\u003ch3\u003ePEP 533, 이터레이터를 위한 결정론적 정리 (PEP 533, deterministic cleanup for iterators)\u003c/h3\u003e\n\u003cp\u003ePEP 533은 이터레이터 프로토콜에 \u003ccode\u003e__[a]iterclose__\u003c/code\u003e를 추가하여 각 \u003ccode\u003e(async) for\u003c/code\u003e 루프를 \u003ccode\u003ewith [a]closing(ait)\u003c/code\u003e으로 래핑하는 것을 제안합니다. 이는 이터레이터가 보유한 리소스의 시기적절하고 결정론적인 정리를 보장하는 데 유용하지만, 이 PEP가 해결하려는 모든 문제를 완전히 해결하지는 못합니다. PEP 533이 있더라도 잘못된 취소는 여전히 잘못된 태스크로 전달될 수 있으며, 이터레이터가 닫히기 전에 문제를 일으킬 수 있습니다. 또한, \u003ccode\u003eTaskGroup\u003c/code\u003e과의 근본적인 구조적 동시성 문제를 해결하지 못합니다.\u003c/p\u003e\n\u003ch3\u003e비동기 제너레이터 전체를 비권장 (Deprecate async generators entirely)\u003c/h3\u003e\n\u003cp\u003e2024년 언어 서밋에서 일부 참석자들은 대신 비동기 제너레이터를 완전히 비권장할 것을 제안했습니다. 하지만 Trio 코드에서는 표준 제너레이터로도 동일한 문제가 발생할 수 있습니다. 또한, \u003ccode\u003edecimal.localcontext\u003c/code\u003e와 같이 취소 범위가 아닌 일부 동기 컨텍스트 매니저도 관련 문제를 나타냅니다. 비동기 제너레이터를 언어에서 제거하기보다는 문제를 해결하는 것이 바람직하다는 의견이 있었습니다.\u003c/p\u003e\n\u003ch3\u003e예외를 올바른 위치로 전달할 수 없습니까? (Can't we just deliver exceptions to the right place?)\u003c/h3\u003e\n\u003cp\u003ePEP 568(컨텍스트 변수에 대한 제너레이터 민감성; PEP 550 참조)을 구현하면 타임아웃으로 인한 예외를 처리할 수 있을 것입니다. 그러나 이는 \u003ccode\u003eTaskGroup\u003c/code\u003e과의 또 다른 문제를 해결하지 못합니다. 제너레이터 모델은 스택 프레임을 일시 중단된 상태로 만들고 이를 저장, 이동, 또는 임의의 위치에서 폐기하거나 되살릴 수 있는 비활성 값으로 취급하는 것입니다. 구조적 동시성 모델은 스택이 트리(tree)가 되며, 자식 태스크가 부모 프레임 내에 캡슐화되는 것입니다. 이 두 모델은 기본 구조적 프로그래밍 모델을 다른, 그리고 불행히도 호환되지 않는 방향으로 확장하고 있습니다. 모든 자식 태스크를 함께 일시 중단하는 것을 가정해도, 다른 태스크에서 제너레이터를 재개할 수 있어 구조적 동시성의 \"상향식\" 불변성을 위반할 수 있습니다. TaskGroup 문제를 해결하지 못하면서 취소 범위를 처리하기 위해 많은 메커니즘을 추가하는 것은 가치가 없다고 생각됩니다.\u003c/p\u003e\n\u003ch3\u003e대체 구현 - 바이트코드 검사 (Alternative implementation - inspecting bytecode)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esys.prevent_yields\u003c/code\u003e가 호출자의 바이트코드를 검사하여 호출 명령 포인터와 다음 컨텍스트 종료 사이에 \u003ccode\u003eyield\u003c/code\u003e가 없는지 확인하는 대안이 제안되었습니다. 그러나 사용자 정의 컨텍스트 매니저가 \u003ccode\u003esys.prevent_yields\u003c/code\u003e를 래핑할 때 어떻게 작동할지 불분명하며, \u003ccode\u003e__enter__()\u003c/code\u003e 및 \u003ccode\u003e__exit__()\u003c/code\u003e에 대한 명시적 호출을 무시하여 \u003ccode\u003ewith\u003c/code\u003e 문 사용 여부에 따라 컨텍스트 관리 프로토콜이 달라질 수 있습니다. \"사용하는 경우에만 비용을 지불하는\" 성능 비용은 매력적이지만, 프레임 객체 검사는 핵심 제어 흐름 구성 요소에 대해 지나치게 비싸고 전체 프로그램 속도 저하를 야기합니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Draft] PEP 789 - Preventing task-cancellation bugs by limiting yield in async generators\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 14:04:23+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"page__taxonomy mb-4\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"카테고리\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":\"Python\"}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":\"PEP\"}]]]}],[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]]}]]}]}]}]\nb:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"met"])</script><script>self.__next_f.push([1,"a\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"21\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>