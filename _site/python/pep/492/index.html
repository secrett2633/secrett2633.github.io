<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <style> 
      ::-webkit-scrollbar{ 
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-track {
        width: 0px;
        background-color: #626262;
        /* border-radius: 5px; */
      }

      ::-webkit-scrollbar-thumb {
        width: 0px;
        background-color: #E2E2E2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-thumb:hover {
        width: 10px;
        height: 20px;
        /* background-color: rgba(190, 190, 190, 0.2); */
        background-color: #A2A2A2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-track:hover {
        width: 10px;
        /* background-color: rgba(150, 150, 150, 0.1); */
        background-color: #626262;
        border-radius: 5px;
        /* background: transparent; */
        /* border-radius: 10px; */
      }

      ::-webkit-scrollbar-button:start:decrement,::-webkit-scrollbar-button:end:increment {
          width:0px;
          height: 0px;
          /* background-color: rgb(14, 221, 24); */
          /* border-radius: 50%; */
      }
    </style>
    
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[Final] PEP 492 - Coroutines with async and await syntax | secrett2633</title>
<meta name="description" content="Python Enhancement Proposal 492: ‘Coroutines with async and await syntax’에 대한 한국어 번역입니다.">


  <meta name="author" content="secrett2633">
  
  <meta property="article:author" content="secrett2633">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="secrett2633's blog">
<meta property="og:title" content="[Final] PEP 492 - Coroutines with async and await syntax">
<meta property="og:url" content="http://localhost:4000/python/pep/492/">


  <meta property="og:description" content="Python Enhancement Proposal 492: ‘Coroutines with async and await syntax’에 대한 한국어 번역입니다.">







  <meta property="article:published_time" content="2025-09-26T22:37:54+09:00">



  <meta property="article:modified_time" content="2025-09-26T22:37:54+09:00">



  

  


<link rel="canonical" href="http://localhost:4000/python/pep/492/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "secrett2633",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="secrett2633's blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->


    <link rel="icon" type="image/png" sizes="32x32" href="https://secrett2633.github.io/assets/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://secrett2633.github.io/assets/images/favicon/favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          secrett2633's blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://github.com/secrett2633">GitHub</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <!-- 2022.02.17 author content hidden -->
  <!-- <div class="author__content">
    
      <h3 class="author__name" itemprop="name">secrett2633</h3>
    
    
  </div> -->

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
      
    
    
      <nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    <!-- Backend -->
    <li>
      <span class="nav__sub-title">Backend</span>
      <hr>
      <ul>
        <li><a href="/backend/django/">Django</a></li>
        <li><a href="/backend/logging/">Logging</a></li>
      </ul>
    </li>

    <!-- Python -->
    <li>
      <span class="nav__sub-title">Python</span>
      <hr>
      <ul>
        <li><a href="/python/pep/">PEP</a></li>
      </ul>
    </li>

    <!-- AI/ML -->
    <li>
      <span class="nav__sub-title">AI/ML</span>
      <hr>
      <ul>
        <li><a href="/ai/llm/">LLM</a></li>
        <li><a href="/ai/review/">Review</a></li>
      </ul>
    </li>

    <!-- DevOps -->
    <li>
      <span class="nav__sub-title">DevOps</span>
      <hr>
      <ul>
        <li><a href="/devops/nginx/">Nginx</a></li>
        <li><a href="/devops/docker/">Docker</a></li>
        <li><a href="/devops/safeline/">SafeLine</a></li>
        <li><a href="/devops/jenkins/">Jenkins</a></li>
        <li><a href="/devops/github-actions/">GitHub Actions</a></li>
        <li><a href="/devops/aws/">AWS</a></li>
      </ul>
    </li>

    <!-- etc -->
    <li>
      <span class="nav__sub-title">etc</span>
      <hr>
      <ul>
        <li><a href="/etc/me/">Me</a></li>
        <li><a href="/etc/chrome-extension/">Chrome Extension</a></li>
      </ul>
    </li>
  </ul>
</nav>
    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[Final] PEP 492 - Coroutines with async and await syntax">
    <meta itemprop="description" content="Python Enhancement Proposal 492: ‘Coroutines with async and await syntax’에 대한 한국어 번역입니다.">
    <meta itemprop="datePublished" content="2025-09-26T22:37:54+09:00">
    <meta itemprop="dateModified" content="2025-09-26T22:37:54+09:00">

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">[Final] PEP 492 - Coroutines with async and await syntax
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2025-09-26T22:37:54+09:00">September 26, 2025</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#pep-492--async-및-await-구문을-사용한-코루틴">PEP 492 – async 및 await 구문을 사용한 코루틴</a><ul><li><a href="#초록-abstract">초록 (Abstract)</a></li><li><a href="#api-설계-및-구현-수정-api-design-and-implementation-revisions">API 설계 및 구현 수정 (API Design and Implementation Revisions)</a></li><li><a href="#근거-및-목표-rationale-and-goals">근거 및 목표 (Rationale and Goals)</a></li><li><a href="#명세-specification">명세 (Specification)</a><ul><li><a href="#새로운-코루틴-선언-구문-new-coroutine-declaration-syntax">새로운 코루틴 선언 구문 (New Coroutine Declaration Syntax)</a></li><li><a href="#typescoroutine">types.coroutine()</a></li><li><a href="#await-표현식-await-expression">await 표현식 (Await Expression)</a></li><li><a href="#비동기-컨텍스트-관리자-및-async-with-asynchronous-context-managers-and-async-with">비동기 컨텍스트 관리자 및 async with (Asynchronous Context Managers and “async with”)</a></li><li><a href="#비동기-이터레이터-및-async-for-asynchronous-iterators-and-async-for">비동기 이터레이터 및 async for (Asynchronous Iterators and “async for”)</a></li><li><a href="#코루틴-객체-coroutine-objects">코루틴 객체 (Coroutine objects)</a></li><li><a href="#디버깅-기능-debugging-features">디버깅 기능 (Debugging Features)</a></li><li><a href="#새로운-표준-라이브러리-함수-new-standard-library-functions">새로운 표준 라이브러리 함수 (New Standard Library Functions)</a></li><li><a href="#새로운-추상-기본-클래스-new-abstract-base-classes">새로운 추상 기본 클래스 (New Abstract Base Classes)</a></li><li><a href="#용어-설명-glossary">용어 설명 (Glossary)</a></li><li><a href="#전환-계획-transition-plan">전환 계획 (Transition Plan)</a></li><li><a href="#하위-호환성-backwards-compatibility">하위 호환성 (Backwards Compatibility)</a></li><li><a href="#문법-업데이트-grammar-updates">문법 업데이트 (Grammar Updates)</a></li><li><a href="#폐지-계획-deprecation-plans">폐지 계획 (Deprecation Plans)</a></li><li><a href="#설계-고려-사항-design-considerations">설계 고려 사항 (Design Considerations)</a></li></ul></li><li><a href="#성능-performance">성능 (Performance)</a></li><li><a href="#구현-implementation">구현 (Implementation)</a></li></ul></li></ul>

            </nav>
          </aside>
        
        <blockquote>
  <p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0492/">PEP 492 - Coroutines with async and await syntax</a></p>

  <table>
    <tbody>
      <tr>
        <td><strong>상태:</strong> Final</td>
        <td><strong>유형:</strong> Standards Track</td>
        <td><strong>작성일:</strong> 09-Apr-2015</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h2 id="pep-492--async-및-await-구문을-사용한-코루틴">PEP 492 – <code class="language-plaintext highlighter-rouge">async</code> 및 <code class="language-plaintext highlighter-rouge">await</code> 구문을 사용한 코루틴</h2>

<p><strong>저자:</strong> Yury Selivanov
<strong>상태:</strong> Final
<strong>유형:</strong> Standards Track
<strong>생성일:</strong> 2015년 4월 9일
<strong>Python 버전:</strong> 3.5</p>

<h3 id="초록-abstract">초록 (Abstract)</h3>

<p>인터넷의 성장과 전반적인 연결성 증가는 반응성(responsive)과 확장성(scalable) 있는 코드에 대한 필요성을 비례적으로 증가시켰습니다. 이 제안은 명시적인 비동기(asynchronous), 동시성(concurrent) Python 코드를 더 쉽게 작성하고 Pythonic하게 만들어서 이러한 요구에 부응하는 것을 목표로 합니다.</p>

<p>이 PEP는 코루틴(coroutines)을 Python의 적절한 독립 개념으로 만들고 새로운 지원 구문을 도입할 것을 제안합니다. 궁극적인 목표는 Python에서 비동기 프로그래밍에 대한 공통적이고 쉽게 접근할 수 있는 사고 모델을 확립하고 이를 동기 프로그래밍에 최대한 가깝게 만드는 것입니다.</p>

<p>이 PEP는 비동기 작업이 <code class="language-plaintext highlighter-rouge">stdlib</code> 모듈 <code class="language-plaintext highlighter-rouge">asyncio.events.AbstractEventLoop</code>와 유사한 이벤트 루프(Event Loop)에 의해 스케줄링되고 조정된다고 가정합니다. 이 PEP는 특정 이벤트 루프 구현에 얽매이지 않지만, <code class="language-plaintext highlighter-rouge">yield</code>를 스케줄러에 대한 신호(signal)로 사용하여 이벤트(예: I/O)가 완료될 때까지 코루틴이 대기할 것임을 나타내는 종류의 코루틴에만 관련됩니다.</p>

<p>이 제안의 변경 사항은 빠르게 성장하는 비동기 프로그래밍 분야에서 Python이 관련성을 유지하고 경쟁력을 갖추는 데 도움이 될 것으로 예상됩니다. 많은 다른 언어들도 유사한 기능을 채택했거나 채택할 계획이기 때문입니다.</p>

<h3 id="api-설계-및-구현-수정-api-design-and-implementation-revisions">API 설계 및 구현 수정 (API Design and Implementation Revisions)</h3>

<p>Python 3.5 초기 베타 릴리스에 대한 피드백 결과, 이 PEP를 지원하는 객체 모델이 재설계되어 네이티브 코루틴(native coroutines)을 제너레이터(generators)와 더 명확하게 분리했습니다. 이제 네이티브 코루틴은 새로운 종류의 제너레이터가 아닌, 완전히 별개의 고유한 타입입니다. 이 변경은 주로 Tornado 웹 서버에 네이티브 코루틴 지원을 통합하려는 시도에서 발생한 문제들 때문에 구현되었습니다.</p>

<p>CPython 3.5.2에서는 <code class="language-plaintext highlighter-rouge">__aiter__</code> 프로토콜이 업데이트되었습니다. 3.5.2 이전에는 <code class="language-plaintext highlighter-rouge">__aiter__</code>가 비동기 이터레이터(asynchronous iterator)로 확인되는 awaitable을 반환해야 했습니다. 3.5.2부터 <code class="language-plaintext highlighter-rouge">__aiter__</code>는 비동기 이터레이터를 직접 반환해야 합니다. 3.5.2에서 이전 프로토콜을 사용하면 <code class="language-plaintext highlighter-rouge">PendingDeprecationWarning</code>이 발생합니다. CPython 3.6에서는 이전 <code class="language-plaintext highlighter-rouge">__aiter__</code> 프로토콜이 <code class="language-plaintext highlighter-rouge">DeprecationWarning</code>과 함께 계속 지원됩니다. CPython 3.7에서는 이전 <code class="language-plaintext highlighter-rouge">__aiter__</code> 프로토콜이 더 이상 지원되지 않으며, <code class="language-plaintext highlighter-rouge">__aiter__</code>가 비동기 이터레이터 이외의 것을 반환하면 <code class="language-plaintext highlighter-rouge">RuntimeError</code>가 발생합니다.</p>

<h3 id="근거-및-목표-rationale-and-goals">근거 및 목표 (Rationale and Goals)</h3>

<p>현재 Python은 PEP 342를 통해 제너레이터(generators)를 이용한 코루틴 구현을 지원하며, PEP 380에 도입된 <code class="language-plaintext highlighter-rouge">yield from</code> 구문을 통해 더욱 강화되었습니다. 하지만 이 접근 방식에는 몇 가지 단점이 있습니다:</p>

<ul>
  <li>코루틴과 일반 제너레이터가 동일한 구문을 공유하기 때문에 혼동하기 쉽습니다. 특히 새로운 개발자에게는 더욱 그렇습니다.</li>
  <li>함수가 코루틴인지 여부는 본문에 <code class="language-plaintext highlighter-rouge">yield</code> 또는 <code class="language-plaintext highlighter-rouge">yield from</code> 문이 있는지 여부로 결정되는데, 이는 리팩토링(refactoring) 중에 이러한 문이 함수 본문에 나타나거나 사라질 때 명확하지 않은 오류로 이어질 수 있습니다.</li>
  <li>비동기 호출 지원은 <code class="language-plaintext highlighter-rouge">yield</code>가 문법적으로 허용되는 표현식으로 제한되어 <code class="language-plaintext highlighter-rouge">with</code> 및 <code class="language-plaintext highlighter-rouge">for</code> 문과 같은 구문 기능의 유용성을 제한합니다.</li>
</ul>

<p>이 제안은 코루틴을 Python 언어의 네이티브(native) 기능으로 만들고, 제너레이터와 명확하게 분리합니다. 이는 제너레이터/코루틴의 모호성을 제거하고, 특정 라이브러리에 의존하지 않고 코루틴을 안정적으로 정의할 수 있게 합니다. 또한 린터(linters)와 IDE가 정적 코드 분석 및 리팩토링을 개선할 수 있도록 합니다.</p>

<p>네이티브 코루틴과 관련 새 구문 기능을 통해 컨텍스트 관리자(context manager) 및 이터레이션(iteration) 프로토콜을 비동기적으로 정의할 수 있습니다. 이 제안에서 나중에 보여주듯이, 새로운 <code class="language-plaintext highlighter-rouge">async with</code> 문을 사용하면 Python 프로그램이 런타임 컨텍스트(runtime context)에 진입하고 종료할 때 비동기 호출을 수행할 수 있으며, 새로운 <code class="language-plaintext highlighter-rouge">async for</code> 문을 사용하면 이터레이터(iterators)에서 비동기 호출을 수행할 수 있습니다.</p>

<h3 id="명세-specification">명세 (Specification)</h3>

<p>이 제안은 Python의 코루틴 지원을 강화하기 위한 새로운 구문과 의미론을 소개합니다.</p>

<p>이 명세는 Python의 코루틴 구현(PEP 342 및 PEP 380)에 대한 지식을 전제로 합니다. 여기서 제안된 구문 변경에 대한 동기는 <code class="language-plaintext highlighter-rouge">asyncio</code> 프레임워크(PEP 3156)와 “Cofunctions” 제안(PEP 3152, 현재 이 명세에 찬성하여 거부됨)에서 비롯됩니다.</p>

<p>이 문서의 이 시점부터 우리는 새로운 구문을 사용하여 선언된 함수를 지칭하기 위해 <strong>네이티브 코루틴(native coroutine)</strong>이라는 단어를 사용합니다. 제너레이터 구문에 기반한 코루틴을 지칭할 필요가 있을 때는 <strong>제너레이터 기반 코루틴(generator-based coroutine)</strong>이 사용됩니다. 두 정의 모두 적용 가능한 맥락에서는 <strong>코루틴(coroutine)</strong>이 사용됩니다.</p>

<h4 id="새로운-코루틴-선언-구문-new-coroutine-declaration-syntax">새로운 코루틴 선언 구문 (New Coroutine Declaration Syntax)</h4>

<p>네이티브 코루틴을 선언하는 데 다음의 새로운 구문이 사용됩니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>코루틴의 주요 특징은 다음과 같습니다:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">async def</code> 함수는 <code class="language-plaintext highlighter-rouge">await</code> 표현식을 포함하지 않더라도 항상 코루틴입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">async</code> 함수 내에 <code class="language-plaintext highlighter-rouge">yield</code> 또는 <code class="language-plaintext highlighter-rouge">yield from</code> 표현식이 있는 것은 <code class="language-plaintext highlighter-rouge">SyntaxError</code>입니다.</li>
  <li>내부적으로 두 개의 새로운 코드 객체 플래그가 도입되었습니다:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CO_COROUTINE</code>은 네이티브 코루틴(새 구문으로 정의됨)을 표시하는 데 사용됩니다.</li>
      <li><code class="language-plaintext highlighter-rouge">CO_ITERABLE_COROUTINE</code>은 제너레이터 기반 코루틴을 네이티브 코루틴과 호환되게 만드는 데 사용됩니다(<code class="language-plaintext highlighter-rouge">types.coroutine()</code> 함수에 의해 설정됨).</li>
    </ul>
  </li>
  <li>일반 제너레이터는 호출될 때 제너레이터 객체를 반환하는 것과 유사하게, 코루틴은 코루틴 객체를 반환합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">StopIteration</code> 예외는 코루틴 밖으로 전파되지 않으며, <code class="language-plaintext highlighter-rouge">RuntimeError</code>로 대체됩니다. 일반 제너레이터의 경우 이러한 동작은 <code class="language-plaintext highlighter-rouge">__future__</code> import를 필요로 합니다 (PEP 479 참조).</li>
  <li>네이티브 코루틴이 가비지 컬렉션될 때, 한 번도 <code class="language-plaintext highlighter-rouge">await</code>되지 않았다면 <code class="language-plaintext highlighter-rouge">RuntimeWarning</code>이 발생합니다 (디버깅 기능 참조).</li>
</ul>

<h4 id="typescoroutine"><code class="language-plaintext highlighter-rouge">types.coroutine()</code></h4>

<p><code class="language-plaintext highlighter-rouge">types</code> 모듈에 새로운 함수 <code class="language-plaintext highlighter-rouge">coroutine(fn)</code>이 추가됩니다. 이 함수는 <code class="language-plaintext highlighter-rouge">asyncio</code>의 기존 제너레이터 기반 코루틴과 이 PEP에 의해 도입된 네이티브 코루틴 간의 상호 운용성을 허용합니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@types.coroutine</span>
<span class="k">def</span> <span class="nf">process_data</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="nf">read_data</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
    <span class="c1"># ...
</span></code></pre></div></div>

<p>이 함수는 제너레이터 함수의 코드 객체에 <code class="language-plaintext highlighter-rouge">CO_ITERABLE_COROUTINE</code> 플래그를 적용하여 코루틴 객체를 반환하도록 만듭니다. <code class="language-plaintext highlighter-rouge">fn</code>이 제너레이터 함수가 아닌 경우, 래핑됩니다. 제너레이터를 반환하는 경우, awaitable 프록시 객체로 래핑됩니다 (awaitable 객체 정의 참조). <code class="language-plaintext highlighter-rouge">CO_COROUTINE</code> 플래그는 <code class="language-plaintext highlighter-rouge">types.coroutine()</code>에 의해 적용되지 않아 새로운 구문으로 정의된 네이티브 코루틴과 제너레이터 기반 코루틴을 분리할 수 있도록 합니다.</p>

<h4 id="await-표현식-await-expression"><code class="language-plaintext highlighter-rouge">await</code> 표현식 (Await Expression)</h4>

<p>코루틴 실행 결과를 얻기 위해 다음의 새로운 <code class="language-plaintext highlighter-rouge">await</code> 표현식이 사용됩니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">db</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="sh">'</span><span class="s">SELECT ...</span><span class="sh">'</span><span class="p">)</span>
    <span class="c1"># ...
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">await</code>는 <code class="language-plaintext highlighter-rouge">yield from</code>과 유사하게 <code class="language-plaintext highlighter-rouge">db.fetch</code> awaitable이 완료되고 결과 <code class="language-plaintext highlighter-rouge">data</code>를 반환할 때까지 <code class="language-plaintext highlighter-rouge">read_data</code> 코루틴의 실행을 일시 중단합니다. 이는 인수의 유효성을 검사하는 추가 단계와 함께 <code class="language-plaintext highlighter-rouge">yield from</code> 구현을 사용합니다. <code class="language-plaintext highlighter-rouge">await</code>는 다음 중 하나인 awaitable만 허용합니다:</p>

<ul>
  <li>네이티브 코루틴 함수에서 반환된 네이티브 코루틴 객체.</li>
  <li><code class="language-plaintext highlighter-rouge">types.coroutine()</code>으로 데코레이트된 함수에서 반환된 제너레이터 기반 코루틴 객체.</li>
  <li>이터레이터(iterator)를 반환하는 <code class="language-plaintext highlighter-rouge">__await__</code> 메서드를 가진 객체.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">yield from</code> 호출 체인은 항상 <code class="language-plaintext highlighter-rouge">yield</code>로 끝납니다. 이는 Futures가 구현되는 근본적인 메커니즘입니다. 내부적으로 코루틴은 특별한 종류의 제너레이터이므로, 모든 <code class="language-plaintext highlighter-rouge">await</code>는 <code class="language-plaintext highlighter-rouge">await</code> 호출 체인의 어딘가에서 <code class="language-plaintext highlighter-rouge">yield</code>에 의해 일시 중단됩니다 (자세한 설명은 PEP 3156 참조).</p>

<p>코루틴에 이 동작을 활성화하기 위해 <code class="language-plaintext highlighter-rouge">__await__</code>라는 새로운 매직 메서드가 추가됩니다. 예를 들어 <code class="language-plaintext highlighter-rouge">asyncio</code>에서 <code class="language-plaintext highlighter-rouge">Future</code> 객체를 <code class="language-plaintext highlighter-rouge">await</code> 문에서 사용할 수 있도록 하려면 <code class="language-plaintext highlighter-rouge">asyncio.Future</code> 클래스에 <code class="language-plaintext highlighter-rouge">__await__ = __iter__</code> 줄을 추가하는 것만으로 충분합니다. 이 PEP의 나머지 부분에서 <code class="language-plaintext highlighter-rouge">__await__</code> 메서드를 가진 객체를 <code class="language-plaintext highlighter-rouge">Future-like objects</code>라고 부릅니다.</p>

<p><code class="language-plaintext highlighter-rouge">__await__</code>가 이터레이터가 아닌 다른 것을 반환하면 <code class="language-plaintext highlighter-rouge">TypeError</code>가 발생합니다. CPython C API로 정의된 객체는 <code class="language-plaintext highlighter-rouge">__await__</code> 메서드와 유사하게 이터레이터를 반환하는 <code class="language-plaintext highlighter-rouge">tp_as_async.am_await</code> 함수를 가질 수 있습니다. <code class="language-plaintext highlighter-rouge">async def</code> 함수 외부에서 <code class="language-plaintext highlighter-rouge">await</code>를 사용하는 것은 <code class="language-plaintext highlighter-rouge">SyntaxError</code>입니다 ( <code class="language-plaintext highlighter-rouge">def</code> 함수 외부에서 <code class="language-plaintext highlighter-rouge">yield</code>를 사용하는 것이 <code class="language-plaintext highlighter-rouge">SyntaxError</code>인 것과 같습니다). awaitable 객체가 아닌 다른 것을 <code class="language-plaintext highlighter-rouge">await</code> 표현식에 전달하는 것은 <code class="language-plaintext highlighter-rouge">TypeError</code>입니다.</p>

<p><strong>업데이트된 연산자 우선순위 표 (Updated operator precedence table)</strong></p>

<p><code class="language-plaintext highlighter-rouge">await</code> 키워드는 다음과 같이 정의됩니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>power ::= await ["**" u_expr]
await ::= ["await"] primary
</code></pre></div></div>

<p>여기서 “primary”는 언어의 가장 강력하게 바인딩된 연산을 나타냅니다. <code class="language-plaintext highlighter-rouge">await</code> 연산자의 우선순위는 <code class="language-plaintext highlighter-rouge">[]</code>, <code class="language-plaintext highlighter-rouge">()</code>, <code class="language-plaintext highlighter-rouge">.</code>보다 낮지만 <code class="language-plaintext highlighter-rouge">**</code> 연산자보다 높도록 결정되었습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">await</code> 표현식의 예시 (Examples of “await” expressions)</strong></p>

<p>유효한 구문 예시:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">await</span> <span class="n">fut</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">pair</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fut</span><span class="p">,</span> <span class="sh">'</span><span class="s">spam</span><span class="sh">'</span>
<span class="k">with</span> <span class="k">await</span> <span class="n">fut</span><span class="p">,</span> <span class="nf">open</span><span class="p">():</span> <span class="k">pass</span>
<span class="k">await</span> <span class="nf">foo</span><span class="p">()[</span><span class="sh">'</span><span class="s">spam</span><span class="sh">'</span><span class="p">].</span><span class="nf">baz</span><span class="p">()()</span>
<span class="k">return</span> <span class="k">await</span> <span class="nf">coro</span><span class="p">()</span>
<span class="n">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">coro</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>
<span class="nf">func</span><span class="p">(</span><span class="n">a1</span><span class="o">=</span><span class="k">await</span> <span class="nf">coro</span><span class="p">(),</span> <span class="n">a2</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="k">await</span> <span class="nf">foo</span><span class="p">()</span> <span class="o">+</span> <span class="k">await</span> <span class="nf">bar</span><span class="p">()</span>
<span class="o">-</span><span class="k">await</span> <span class="nf">foo</span><span class="p">()</span>
</code></pre></div></div>

<p>유효하지 않은 구문 예시 (수정 제안과 함께):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Expression           Should be written as
# await await coro()   await (await coro())
# await -coro()        await (-coro())
</span></code></pre></div></div>

<h4 id="비동기-컨텍스트-관리자-및-async-with-asynchronous-context-managers-and-async-with">비동기 컨텍스트 관리자 및 <code class="language-plaintext highlighter-rouge">async with</code> (Asynchronous Context Managers and “async with”)</h4>

<p>비동기 컨텍스트 관리자는 <code class="language-plaintext highlighter-rouge">enter</code> 및 <code class="language-plaintext highlighter-rouge">exit</code> 메서드에서 실행을 일시 중단할 수 있는 컨텍스트 관리자입니다. 이를 가능하게 하기 위해 비동기 컨텍스트 관리자를 위한 새로운 프로토콜이 제안됩니다. <code class="language-plaintext highlighter-rouge">__aenter__</code> 및 <code class="language-plaintext highlighter-rouge">__aexit__</code>라는 두 가지 새로운 매직 메서드가 추가됩니다. 둘 다 awaitable을 반환해야 합니다.</p>

<p>비동기 컨텍스트 관리자의 예시:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">__aenter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="nf">log</span><span class="p">(</span><span class="sh">'</span><span class="s">entering context</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">__aexit__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="nf">log</span><span class="p">(</span><span class="sh">'</span><span class="s">exiting context</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>새 구문 (New Syntax)</strong></p>

<p>비동기 컨텍스트 관리자를 위한 새로운 문장이 제안됩니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">with</span> <span class="n">EXPR</span> <span class="k">as</span> <span class="n">VAR</span><span class="p">:</span>
    <span class="n">BLOCK</span>
</code></pre></div></div>

<p>이는 의미론적으로 다음과 동일합니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mgr</span> <span class="o">=</span> <span class="p">(</span><span class="n">EXPR</span><span class="p">)</span>
<span class="n">aexit</span> <span class="o">=</span> <span class="nf">type</span><span class="p">(</span><span class="n">mgr</span><span class="p">).</span><span class="n">__aexit__</span>
<span class="n">aenter</span> <span class="o">=</span> <span class="nf">type</span><span class="p">(</span><span class="n">mgr</span><span class="p">).</span><span class="n">__aenter__</span>
<span class="n">VAR</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">aenter</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">BLOCK</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="k">await</span> <span class="nf">aexit</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="o">*</span><span class="n">sys</span><span class="p">.</span><span class="nf">exc_info</span><span class="p">()):</span>
        <span class="k">raise</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">await</span> <span class="nf">aexit</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</code></pre></div></div>

<p>일반 <code class="language-plaintext highlighter-rouge">with</code> 문과 마찬가지로, 단일 <code class="language-plaintext highlighter-rouge">async with</code> 문에서 여러 컨텍스트 관리자를 지정할 수 있습니다. <code class="language-plaintext highlighter-rouge">__aenter__</code> 및 <code class="language-plaintext highlighter-rouge">__aexit__</code> 메서드가 없는 일반 컨텍스트 관리자를 <code class="language-plaintext highlighter-rouge">async with</code>에 전달하는 것은 오류입니다. <code class="language-plaintext highlighter-rouge">async def</code> 함수 외부에서 <code class="language-plaintext highlighter-rouge">async with</code>를 사용하는 것은 <code class="language-plaintext highlighter-rouge">SyntaxError</code>입니다.</p>

<h4 id="비동기-이터레이터-및-async-for-asynchronous-iterators-and-async-for">비동기 이터레이터 및 <code class="language-plaintext highlighter-rouge">async for</code> (Asynchronous Iterators and “async for”)</h4>

<p>비동기 이터러블(asynchronous iterable)은 <code class="language-plaintext highlighter-rouge">iter</code> 구현에서 비동기 코드를 호출할 수 있으며, 비동기 이터레이터는 <code class="language-plaintext highlighter-rouge">next</code> 메서드에서 비동기 코드를 호출할 수 있습니다. 비동기 이터레이션을 지원하려면:</p>

<ul>
  <li>객체는 비동기 이터레이터 객체를 반환하는 <code class="language-plaintext highlighter-rouge">__aiter__</code> 메서드를 구현해야 합니다 (또는 CPython C API로 정의된 경우 <code class="language-plaintext highlighter-rouge">tp_as_async.am_aiter</code> 슬롯).</li>
  <li>비동기 이터레이터 객체는 awaitable을 반환하는 <code class="language-plaintext highlighter-rouge">__anext__</code> 메서드를 구현해야 합니다 (또는 CPython C API로 정의된 경우 <code class="language-plaintext highlighter-rouge">tp_as_async.am_anext</code> 슬롯).</li>
  <li>이터레이션을 중지하려면 <code class="language-plaintext highlighter-rouge">__anext__</code>는 <code class="language-plaintext highlighter-rouge">StopAsyncIteration</code> 예외를 발생시켜야 합니다.</li>
</ul>

<p>비동기 이터러블의 예시:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AsyncIterable</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__aiter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">__anext__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">self</span><span class="p">.</span><span class="nf">fetch_data</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">StopAsyncIteration</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">fetch_data</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="c1"># ...
</span></code></pre></div></div>

<p><strong>새 구문 (New Syntax)</strong></p>

<p>비동기 이터레이터를 통해 반복하기 위한 새로운 문장이 제안됩니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="k">for</span> <span class="n">TARGET</span> <span class="ow">in</span> <span class="n">ITER</span><span class="p">:</span>
    <span class="n">BLOCK</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">BLOCK2</span>
</code></pre></div></div>

<p>이는 의미론적으로 다음과 동일합니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">ITER</span><span class="p">)</span>
<span class="nb">iter</span> <span class="o">=</span> <span class="nf">type</span><span class="p">(</span><span class="nb">iter</span><span class="p">).</span><span class="nf">__aiter__</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
<span class="n">running</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">while</span> <span class="n">running</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">TARGET</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">type</span><span class="p">(</span><span class="nb">iter</span><span class="p">).</span><span class="nf">__anext__</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">StopAsyncIteration</span><span class="p">:</span>
        <span class="n">running</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">BLOCK</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">BLOCK2</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">__aiter__</code> 메서드가 없는 일반 이터러블을 <code class="language-plaintext highlighter-rouge">async for</code>에 전달하는 것은 <code class="language-plaintext highlighter-rouge">TypeError</code>입니다. <code class="language-plaintext highlighter-rouge">async def</code> 함수 외부에서 <code class="language-plaintext highlighter-rouge">async for</code>를 사용하는 것은 <code class="language-plaintext highlighter-rouge">SyntaxError</code>입니다. 일반 <code class="language-plaintext highlighter-rouge">for</code> 문과 마찬가지로 <code class="language-plaintext highlighter-rouge">async for</code>는 선택적 <code class="language-plaintext highlighter-rouge">else</code> 절을 가집니다.</p>

<p><strong>왜 <code class="language-plaintext highlighter-rouge">StopAsyncIteration</code>인가? (Why StopAsyncIteration?)</strong></p>

<p>코루틴은 내부적으로 여전히 제너레이터에 기반합니다. PEP 479 이전에는 <code class="language-plaintext highlighter-rouge">def g1(): yield from fut; return 'spam'</code>과 <code class="language-plaintext highlighter-rouge">def g2(): yield from fut; raise StopIteration('spam')</code> 사이에 근본적인 차이가 없었습니다. PEP 479가 승인되어 코루틴에 기본적으로 활성화되었기 때문에, <code class="language-plaintext highlighter-rouge">async def a1(): await fut; raise StopIteration('spam')</code>과 같은 예시에서는 <code class="language-plaintext highlighter-rouge">StopIteration</code>이 <code class="language-plaintext highlighter-rouge">RuntimeError</code>로 래핑됩니다.</p>

<p>외부 코드에 이터레이션이 종료되었음을 알리는 유일한 방법은 <code class="language-plaintext highlighter-rouge">StopIteration</code> 이외의 다른 예외를 발생시키는 것입니다. 따라서 새로운 내장 예외 클래스 <code class="language-plaintext highlighter-rouge">StopAsyncIteration</code>이 추가되었습니다. 더욱이, PEP 479의 의미론에 따라 코루틴에서 발생한 모든 <code class="language-plaintext highlighter-rouge">StopIteration</code> 예외는 <code class="language-plaintext highlighter-rouge">RuntimeError</code>로 래핑됩니다.</p>

<h4 id="코루틴-객체-coroutine-objects">코루틴 객체 (Coroutine objects)</h4>

<p>이 섹션은 <code class="language-plaintext highlighter-rouge">CO_COROUTINE</code> 플래그가 있는 네이티브 코루틴, 즉 새로운 <code class="language-plaintext highlighter-rouge">async def</code> 구문으로 정의된 코루틴에만 적용됩니다. <code class="language-plaintext highlighter-rouge">asyncio</code>의 기존 <strong>제너레이터 기반 코루틴</strong>의 동작은 변경되지 않습니다. 코루틴과 제너레이터가 별개의 개념으로 다루어지도록 많은 노력이 기울여졌습니다:</p>

<ul>
  <li>네이티브 코루틴 객체는 <code class="language-plaintext highlighter-rouge">__iter__</code> 및 <code class="language-plaintext highlighter-rouge">__next__</code> 메서드를 구현하지 않습니다. 따라서 <code class="language-plaintext highlighter-rouge">iter()</code>, <code class="language-plaintext highlighter-rouge">list()</code>, <code class="language-plaintext highlighter-rouge">tuple()</code> 및 다른 내장 함수를 통해 반복하거나 전달할 수 없습니다. 또한 <code class="language-plaintext highlighter-rouge">for..in</code> 루프에서 사용할 수 없습니다.</li>
  <li>네이티브 코루틴 객체에 <code class="language-plaintext highlighter-rouge">__iter__</code> 또는 <code class="language-plaintext highlighter-rouge">__next__</code>를 사용하려고 시도하면 <code class="language-plaintext highlighter-rouge">TypeError</code>가 발생합니다.</li>
  <li>일반 제너레이터는 네이티브 코루틴에서 <code class="language-plaintext highlighter-rouge">yield from</code>을 사용할 수 없습니다. 그렇게 하면 <code class="language-plaintext highlighter-rouge">TypeError</code>가 발생합니다.</li>
  <li>제너레이터 기반 코루틴(<code class="language-plaintext highlighter-rouge">asyncio</code> 코드는 <code class="language-plaintext highlighter-rouge">@asyncio.coroutine</code>으로 데코레이트되어야 함)은 네이티브 코루틴 객체에서 <code class="language-plaintext highlighter-rouge">yield from</code>을 사용할 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">inspect.isgenerator()</code> 및 <code class="language-plaintext highlighter-rouge">inspect.isgeneratorfunction()</code>은 네이티브 코루틴 객체 및 네이티브 코루틴 함수에 대해 <code class="language-plaintext highlighter-rouge">False</code>를 반환합니다.</li>
</ul>

<p><strong>코루틴 객체 메서드 (Coroutine object methods)</strong></p>

<p>코루틴은 내부적으로 제너레이터에 기반하므로 구현을 공유합니다. 제너레이터 객체와 마찬가지로 코루틴은 <code class="language-plaintext highlighter-rouge">throw()</code>, <code class="language-plaintext highlighter-rouge">send()</code>, <code class="language-plaintext highlighter-rouge">close()</code> 메서드를 가집니다. <code class="language-plaintext highlighter-rouge">StopIteration</code> 및 <code class="language-plaintext highlighter-rouge">GeneratorExit</code>는 코루틴에 대해 동일한 역할을 수행합니다 (비록 PEP 479가 코루틴에 기본적으로 활성화되어 있지만). <code class="language-plaintext highlighter-rouge">throw()</code>, <code class="language-plaintext highlighter-rouge">send()</code> 메서드는 <code class="language-plaintext highlighter-rouge">Future-like objects</code>에 값을 푸시하고 오류를 발생시키는 데 사용됩니다.</p>

<h4 id="디버깅-기능-debugging-features">디버깅 기능 (Debugging Features)</h4>

<p>초보적인 실수는 코루틴에서 <code class="language-plaintext highlighter-rouge">yield from</code>을 사용하는 것을 잊는 것입니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@asyncio.coroutine</span>
<span class="k">def</span> <span class="nf">useful</span><span class="p">():</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 'yield from' 없이는 아무것도 하지 않습니다.
</span></code></pre></div></div>

<p>이러한 종류의 실수를 디버깅하기 위해 <code class="language-plaintext highlighter-rouge">asyncio</code>에는 특별한 디버그 모드가 있습니다. 이 모드에서 <code class="language-plaintext highlighter-rouge">@coroutine</code> 데코레이터는 모든 함수를 소멸자(destructor)로 경고를 기록하는 특수 객체로 래핑합니다. 래핑된 제너레이터가 가비지 컬렉션될 때마다, 데코레이터 함수가 정확히 어디에 정의되었는지, 컬렉션된 위치의 스택 트레이스(stack trace) 등에 대한 정보를 담은 자세한 로깅 메시지가 생성됩니다. 래퍼(wrapper) 객체는 또한 제너레이터에 대한 자세한 정보와 함께 편리한 <code class="language-plaintext highlighter-rouge">__repr__</code> 함수를 제공합니다.</p>

<p>이러한 디버그 기능을 활성화하는 방법이 문제입니다. 디버그 기능은 프로덕션 모드에서는 아무런 작동을 하지 않아야 하므로, <code class="language-plaintext highlighter-rouge">@coroutine</code> 데코레이터는 OS 환경 변수 <code class="language-plaintext highlighter-rouge">PYTHONASYNCIODEBUG</code>를 기반으로 래핑 여부를 결정합니다. 이 방식으로 <code class="language-plaintext highlighter-rouge">asyncio</code> 자체 함수가 계측된 <code class="language-plaintext highlighter-rouge">asyncio</code> 프로그램을 실행할 수 있습니다. <code class="language-plaintext highlighter-rouge">EventLoop.set_debug</code>는 다른 디버그 기능이며, <code class="language-plaintext highlighter-rouge">@coroutine</code> 데코레이터의 동작에는 영향을 미치지 않습니다.</p>

<p>이 제안을 통해 코루틴은 제너레이터와 구별되는 네이티브 개념이 됩니다. 한 번도 <code class="language-plaintext highlighter-rouge">await</code>되지 않은 코루틴에 대해 <code class="language-plaintext highlighter-rouge">RuntimeWarning</code>이 발생하는 것 외에도, <code class="language-plaintext highlighter-rouge">sys</code> 모듈에 두 개의 새로운 함수를 추가할 것이 제안됩니다: <code class="language-plaintext highlighter-rouge">set_coroutine_wrapper</code> 및 <code class="language-plaintext highlighter-rouge">get_coroutine_wrapper</code>. 이는 <code class="language-plaintext highlighter-rouge">asyncio</code> 및 다른 프레임워크(예: 코루틴이 정확히 어디에서 생성되었는지 표시하거나, 가비지 컬렉션된 위치의 더 자세한 스택 트레이스 표시)에서 고급 디버깅 기능을 활성화하기 위함입니다.</p>

<h4 id="새로운-표준-라이브러리-함수-new-standard-library-functions">새로운 표준 라이브러리 함수 (New Standard Library Functions)</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">types.coroutine(gen)</code>: 자세한 내용은 <code class="language-plaintext highlighter-rouge">types.coroutine()</code> 섹션 참조.</li>
  <li><code class="language-plaintext highlighter-rouge">inspect.iscoroutine(obj)</code>: <code class="language-plaintext highlighter-rouge">obj</code>가 네이티브 코루틴 객체이면 <code class="language-plaintext highlighter-rouge">True</code>를 반환.</li>
  <li><code class="language-plaintext highlighter-rouge">inspect.iscoroutinefunction(obj)</code>: <code class="language-plaintext highlighter-rouge">obj</code>가 네이티브 코루틴 함수이면 <code class="language-plaintext highlighter-rouge">True</code>를 반환.</li>
  <li><code class="language-plaintext highlighter-rouge">inspect.isawaitable(obj)</code>: <code class="language-plaintext highlighter-rouge">obj</code>가 awaitable이면 <code class="language-plaintext highlighter-rouge">True</code>를 반환.</li>
  <li><code class="language-plaintext highlighter-rouge">inspect.getcoroutinestate(coro)</code>: 네이티브 코루틴 객체의 현재 상태를 반환 (<code class="language-plaintext highlighter-rouge">inspect.getfgeneratorstate(gen)</code>를 미러링).</li>
  <li><code class="language-plaintext highlighter-rouge">inspect.getcoroutinelocals(coro)</code>: 네이티브 코루틴 객체의 로컬 변수와 해당 값의 매핑을 반환 (<code class="language-plaintext highlighter-rouge">inspect.getgeneratorlocals(gen)</code>를 미러링).</li>
  <li><code class="language-plaintext highlighter-rouge">sys.set_coroutine_wrapper(wrapper)</code>: 네이티브 코루틴 객체 생성을 가로챌 수 있도록 합니다. <code class="language-plaintext highlighter-rouge">wrapper</code>는 하나의 인자(코루틴 객체)를 받는 호출 가능 객체이거나 <code class="language-plaintext highlighter-rouge">None</code>이어야 합니다. <code class="language-plaintext highlighter-rouge">None</code>은 래퍼를 재설정합니다. 두 번 호출되면 새 래퍼가 이전 래퍼를 대체합니다. 이 함수는 스레드별(thread-specific)입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sys.get_coroutine_wrapper()</code>: 현재 래퍼 객체를 반환합니다. 래퍼가 설정되지 않은 경우 <code class="language-plaintext highlighter-rouge">None</code>을 반환합니다. 이 함수는 스레드별입니다.</li>
</ul>

<h4 id="새로운-추상-기본-클래스-new-abstract-base-classes">새로운 추상 기본 클래스 (New Abstract Base Classes)</h4>

<p>기존 프레임워크(예: Tornado) 및 컴파일러(예: Cython)와의 더 나은 통합을 허용하기 위해 두 개의 새로운 추상 기본 클래스(ABC)가 추가됩니다:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">collections.abc.Awaitable</code>: <code class="language-plaintext highlighter-rouge">__await__</code> 메서드를 구현하는 <code class="language-plaintext highlighter-rouge">Future-like classes</code>를 위한 ABC.</li>
  <li><code class="language-plaintext highlighter-rouge">collections.abc.Coroutine</code>: <code class="language-plaintext highlighter-rouge">send(value)</code>, <code class="language-plaintext highlighter-rouge">throw(type, exc, tb)</code>, <code class="language-plaintext highlighter-rouge">close()</code>, <code class="language-plaintext highlighter-rouge">__await__()</code> 메서드를 구현하는 코루틴 객체를 위한 ABC.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">CO_ITERABLE_COROUTINE</code> 플래그가 있는 제너레이터 기반 코루틴은 <code class="language-plaintext highlighter-rouge">__await__</code> 메서드를 구현하지 않으므로, <code class="language-plaintext highlighter-rouge">collections.abc.Coroutine</code> 및 <code class="language-plaintext highlighter-rouge">collections.abc.Awaitable</code> ABC의 인스턴스가 아닙니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@types.coroutine</span>
<span class="k">def</span> <span class="nf">gencoro</span><span class="p">():</span>
    <span class="k">yield</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="nf">isinstance</span><span class="p">(</span><span class="nf">gencoro</span><span class="p">(),</span> <span class="n">collections</span><span class="p">.</span><span class="n">abc</span><span class="p">.</span><span class="n">Coroutine</span><span class="p">)</span>
<span class="c1"># 하지만:
</span><span class="k">assert</span> <span class="n">inspect</span><span class="p">.</span><span class="nf">isawaitable</span><span class="p">(</span><span class="nf">gencoro</span><span class="p">())</span>
</code></pre></div></div>

<p>객체가 비동기 이터레이션을 지원하는지 쉽게 테스트할 수 있도록 두 개의 ABC가 더 추가됩니다:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">collections.abc.AsyncIterable</code>: <code class="language-plaintext highlighter-rouge">__aiter__</code> 메서드를 테스트합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">collections.abc.AsyncIterator</code>: <code class="language-plaintext highlighter-rouge">__aiter__</code> 및 <code class="language-plaintext highlighter-rouge">__anext__</code> 메서드를 테스트합니다.</li>
</ul>

<h4 id="용어-설명-glossary">용어 설명 (Glossary)</h4>

<ul>
  <li><strong>Native coroutine function (네이티브 코루틴 함수):</strong> <code class="language-plaintext highlighter-rouge">async def</code>로 선언된 코루틴 함수. <code class="language-plaintext highlighter-rouge">await</code> 및 <code class="language-plaintext highlighter-rouge">return value</code>를 사용합니다.</li>
  <li><strong>Native coroutine (네이티브 코루틴):</strong> 네이티브 코루틴 함수에서 반환됩니다.</li>
  <li><strong>Generator-based coroutine function (제너레이터 기반 코루틴 함수):</strong> 제너레이터 구문에 기반한 코루틴. <code class="language-plaintext highlighter-rouge">@asyncio.coroutine</code>으로 데코레이트된 함수가 가장 일반적인 예시입니다.</li>
  <li><strong>Generator-based coroutine (제너레이터 기반 코루틴):</strong> 제너레이터 기반 코루틴 함수에서 반환됩니다.</li>
  <li><strong>Coroutine (코루틴):</strong> 네이티브 코루틴 또는 제너레이터 기반 코루틴.</li>
  <li><strong>Coroutine object (코루틴 객체):</strong> 네이티브 코루틴 객체 또는 제너레이터 기반 코루틴 객체.</li>
  <li><strong>Future-like object (퓨처 유사 객체):</strong> <code class="language-plaintext highlighter-rouge">__await__</code> 메서드를 가진 객체, 또는 <code class="language-plaintext highlighter-rouge">tp_as_async-&gt;am_await</code> 함수를 가진 C 객체로 이터레이터를 반환합니다. 코루틴의 <code class="language-plaintext highlighter-rouge">await</code> 표현식에 의해 소비될 수 있습니다. 퓨처 유사 객체를 기다리는 코루틴은 퓨처 유사 객체의 <code class="language-plaintext highlighter-rouge">__await__</code>가 완료되고 결과를 반환할 때까지 일시 중단됩니다.</li>
  <li><strong>Awaitable (어웨이터블):</strong> 퓨처 유사 객체 또는 코루틴 객체.</li>
  <li><strong>Asynchronous context manager (비동기 컨텍스트 관리자):</strong> <code class="language-plaintext highlighter-rouge">__aenter__</code> 및 <code class="language-plaintext highlighter-rouge">__aexit__</code> 메서드를 가지며 <code class="language-plaintext highlighter-rouge">async with</code>와 함께 사용할 수 있습니다.</li>
  <li><strong>Asynchronous iterable (비동기 이터러블):</strong> 비동기 이터레이터 객체를 반환해야 하는 <code class="language-plaintext highlighter-rouge">__aiter__</code> 메서드를 가진 객체. <code class="language-plaintext highlighter-rouge">async for</code>와 함께 사용할 수 있습니다.</li>
  <li><strong>Asynchronous iterator (비동기 이터레이터):</strong> <code class="language-plaintext highlighter-rouge">__anext__</code> 메서드를 가집니다.</li>
</ul>

<h4 id="전환-계획-transition-plan">전환 계획 (Transition Plan)</h4>

<p><code class="language-plaintext highlighter-rouge">async</code> 및 <code class="language-plaintext highlighter-rouge">await</code> 키워드와의 하위 호환성 문제를 피하기 위해 <code class="language-plaintext highlighter-rouge">tokenizer.c</code>를 다음과 같이 수정하기로 결정했습니다:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">async def NAME</code> 토큰 조합을 인식합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">async def</code> 블록을 토큰화하는 동안, <code class="language-plaintext highlighter-rouge">'async'</code> <code class="language-plaintext highlighter-rouge">NAME</code> 토큰을 <code class="language-plaintext highlighter-rouge">ASYNC</code>로, <code class="language-plaintext highlighter-rouge">'await'</code> <code class="language-plaintext highlighter-rouge">NAME</code> 토큰을 <code class="language-plaintext highlighter-rouge">AWAIT</code>로 대체합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">def</code> 블록을 토큰화하는 동안, <code class="language-plaintext highlighter-rouge">'async'</code> 및 <code class="language-plaintext highlighter-rouge">'await'</code> <code class="language-plaintext highlighter-rouge">NAME</code> 토큰을 그대로 반환합니다.</li>
</ul>

<p>이 접근 방식은 새로운 구문 기능(모두 <code class="language-plaintext highlighter-rouge">async</code> 함수에서만 사용 가능)과 기존 코드의 원활한 조합을 허용합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Spam</span><span class="p">:</span>
    <span class="k">async</span> <span class="o">=</span> <span class="mi">42</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">ham</span><span class="p">():</span>
        <span class="nf">print</span><span class="p">(</span><span class="nf">getattr</span><span class="p">(</span><span class="n">Spam</span><span class="p">,</span> <span class="sh">'</span><span class="s">async</span><span class="sh">'</span><span class="p">))</span> <span class="c1"># 코루틴이 실행되어 '42'를 출력합니다.
</span></code></pre></div></div>

<h4 id="하위-호환성-backwards-compatibility">하위 호환성 (Backwards Compatibility)</h4>

<p>이 제안은 100% 하위 호환성을 유지합니다.</p>

<p><strong>asyncio</strong></p>

<p><code class="language-plaintext highlighter-rouge">asyncio</code> 모듈은 코루틴 및 새로운 문과 함께 작동하도록 조정되고 테스트되었습니다. 하위 호환성은 100% 유지됩니다. 즉, 모든 기존 코드는 그대로 작동합니다.</p>

<p>필요한 변경 사항은 주로 다음과 같습니다:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@asyncio.coroutine</code> 데코레이터를 새로운 <code class="language-plaintext highlighter-rouge">types.coroutine()</code> 함수를 사용하도록 수정합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">asyncio.Future</code> 클래스에 <code class="language-plaintext highlighter-rouge">__await__ = __iter__</code> 줄을 추가합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">async()</code> 함수의 별칭으로 <code class="language-plaintext highlighter-rouge">ensure_future()</code>를 추가합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">async()</code> 함수를 Deprecate합니다.</li>
</ul>

<p><strong>asyncio 마이그레이션 전략 (asyncio migration strategy)</strong></p>

<p>일반 제너레이터는 네이티브 코루틴 객체에서 <code class="language-plaintext highlighter-rouge">yield from</code>을 사용할 수 없으므로(자세한 내용은 제너레이터와의 차이점 섹션 참조), 새로운 구문을 사용하기 전에 모든 제너레이터 기반 코루틴이 <code class="language-plaintext highlighter-rouge">@asyncio.coroutine</code>으로 데코레이트되었는지 확인하는 것이 좋습니다.</p>

<h4 id="문법-업데이트-grammar-updates">문법 업데이트 (Grammar Updates)</h4>

<p>문법 변경은 상당히 미미합니다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>decorated: decorators (classdef | funcdef | async_funcdef)
async_funcdef: ASYNC funcdef
compound_stmt: (if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt)
async_stmt: ASYNC (funcdef | with_stmt | for_stmt)
power: atom_expr ['**' factor]
atom_expr: [AWAIT] atom trailer*
</code></pre></div></div>

<h4 id="폐지-계획-deprecation-plans">폐지 계획 (Deprecation Plans)</h4>

<p><code class="language-plaintext highlighter-rouge">async</code> 및 <code class="language-plaintext highlighter-rouge">await</code> 이름은 CPython 3.5 및 3.6에서 소프트하게 폐지됩니다. 3.7에서는 이들을 적절한 키워드로 전환할 것입니다. 3.7 이전에 <code class="language-plaintext highlighter-rouge">async</code> 및 <code class="language-plaintext highlighter-rouge">await</code>를 적절한 키워드로 만들면 사람들이 코드를 Python 3으로 포팅하기 더 어려워질 수 있습니다.</p>

<h4 id="설계-고려-사항-design-considerations">설계 고려 사항 (Design Considerations)</h4>

<p><strong>왜 <code class="language-plaintext highlighter-rouge">async</code>와 <code class="language-plaintext highlighter-rouge">await</code> 키워드인가 (Why “async” and “await” keywords)</strong></p>

<p><code class="language-plaintext highlighter-rouge">async/await</code>는 프로그래밍 언어에서 새로운 개념이 아닙니다.</p>

<ul>
  <li>C#은 오래 전부터 이 기능을 가지고 있습니다.</li>
  <li>ECMAScript 7에 <code class="language-plaintext highlighter-rouge">async/await</code>를 추가하려는 제안이 있습니다.</li>
  <li>Facebook의 Hack/HHVM.</li>
  <li>Google의 Dart 언어.</li>
  <li>Scala.</li>
  <li>C++에 <code class="language-plaintext highlighter-rouge">async/await</code>를 추가하려는 제안이 있습니다.</li>
  <li>그리고 다른 많은 덜 인기 있는 언어들에도 존재합니다.</li>
</ul>

<p>이는 일부 사용자들이 이미 <code class="language-plaintext highlighter-rouge">async/await</code> 경험이 있고, 한 프로젝트에서 여러 언어(예: Python과 ECMAScript 7)를 함께 사용하는 것을 더 쉽게 만들기 때문에 큰 이점입니다.</p>

<p><strong>왜 <code class="language-plaintext highlighter-rouge">async</code> 키워드가 중요한가 (Importance of “async” keyword)</strong></p>

<p><code class="language-plaintext highlighter-rouge">await</code> 표현식만 구현하고 최소한 하나의 <code class="language-plaintext highlighter-rouge">await</code>를 가진 모든 함수를 코루틴으로 처리하는 것도 가능하지만, 이 접근 방식은 API 설계, 코드 리팩토링 및 장기적인 지원을 더 어렵게 만듭니다.</p>

<p>Python에 <code class="language-plaintext highlighter-rouge">await</code> 키워드만 있다고 가정해 봅시다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">useful</span><span class="p">():</span>
    <span class="c1"># ...
</span>    <span class="k">await</span> <span class="nf">log</span><span class="p">(...)</span>
    <span class="c1"># ...
</span>
<span class="k">def</span> <span class="nf">important</span><span class="p">():</span>
    <span class="k">await</span> <span class="nf">useful</span><span class="p">()</span>
</code></pre></div></div>

<p>만약 <code class="language-plaintext highlighter-rouge">useful()</code> 함수가 리팩토링되어 누군가 그 안의 모든 <code class="language-plaintext highlighter-rouge">await</code> 표현식을 제거한다면, 그것은 일반 Python 함수가 될 것이고, <code class="language-plaintext highlighter-rouge">important()</code>를 포함하여 그 함수에 의존하는 모든 코드가 망가질 것입니다. 이 문제를 완화하려면 <code class="language-plaintext highlighter-rouge">@asyncio.coroutine</code>과 유사한 데코레이터를 도입해야 합니다.</p>

<p><strong>왜 <code class="language-plaintext highlighter-rouge">async def</code>인가 (Why “async def”)</strong></p>

<p>일부 사람들에게는 <code class="language-plaintext highlighter-rouge">async name(): pass</code>와 같은 간단한 구문이 <code class="language-plaintext highlighter-rouge">async def name(): pass</code>보다 더 매력적으로 보일 수 있습니다. 분명히 타이핑하기 더 쉽습니다. 그러나 다른 한편으로는 <code class="language-plaintext highlighter-rouge">async def</code>, <code class="language-plaintext highlighter-rouge">async with</code>, <code class="language-plaintext highlighter-rouge">async for</code> 사이의 대칭을 깨뜨립니다. 여기서 <code class="language-plaintext highlighter-rouge">async</code>는 문장이 비동기임을 나타내는 수식어(modifier)입니다. 또한 기존 문법과 더 일관성이 있습니다.</p>

<p><strong>왜 매직 메서드는 “a”로 시작하는가 (Why magic methods start with “a”)</strong></p>

<p>새로운 비동기 매직 메서드 <code class="language-plaintext highlighter-rouge">__aiter__</code>, <code class="language-plaintext highlighter-rouge">__anext__</code>, <code class="language-plaintext highlighter-rouge">__aenter__</code>, <code class="language-plaintext highlighter-rouge">__aexit__</code>는 모두 동일한 접두사 “a”로 시작합니다. 대안 제안은 “async” 접두사를 사용하여 <code class="language-plaintext highlighter-rouge">__anext__</code>를 <code class="language-plaintext highlighter-rouge">__async_next__</code>로 만드는 것이었습니다. 그러나 새로운 매직 메서드를 <code class="language-plaintext highlighter-rouge">__radd__</code> 및 <code class="language-plaintext highlighter-rouge">__iadd__</code>와 같은 기존 메서드와 일치시키기 위해 더 짧은 버전을 사용하기로 결정했습니다.</p>

<p><strong>왜 기존 매직 이름을 재사용하지 않는가 (Why not reuse existing magic names)</strong></p>

<p>새로운 비동기 이터레이터 및 컨텍스트 관리자에 대한 대안 아이디어는 선언에 <code class="language-plaintext highlighter-rouge">async</code> 키워드를 추가하여 기존 매직 메서드를 재사용하는 것이었습니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CM</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span> <span class="c1"># __aenter__ 대신
</span>        <span class="c1"># ...
</span></code></pre></div></div>

<p>이 접근 방식에는 다음과 같은 단점이 있습니다:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">with</code> 및 <code class="language-plaintext highlighter-rouge">async with</code> 문 모두에서 작동하는 객체를 생성할 수 없습니다.</li>
  <li>Python &lt;= 3.4에서는 <code class="language-plaintext highlighter-rouge">__enter__</code> 및/또는 <code class="language-plaintext highlighter-rouge">__exit__</code>에서 <code class="language-plaintext highlighter-rouge">Future-like objects</code>를 반환하는 것을 금지하지 않으므로 하위 호환성을 깨뜨릴 수 있습니다.</li>
  <li>이 제안의 주요 목적 중 하나는 네이티브 코루틴을 가능한 한 간단하고 오류 방지(foolproof)로 만드는 것이므로, 프로토콜을 명확하게 분리하는 것이 중요합니다.</li>
</ul>

<p><strong>왜 기존 <code class="language-plaintext highlighter-rouge">for</code> 및 <code class="language-plaintext highlighter-rouge">with</code> 문을 재사용하지 않는가 (Why not reuse existing “for” and “with” statements)</strong></p>

<p>기존 제너레이터 기반 코루틴과 이 제안의 비전은 사용자가 코드가 언제 일시 중단될 수 있는지 쉽게 파악할 수 있도록 하는 것입니다. 기존 <code class="language-plaintext highlighter-rouge">for</code> 및 <code class="language-plaintext highlighter-rouge">with</code> 문이 비동기 이터레이터 및 컨텍스트 관리자를 인식하도록 만들면 필연적으로 암시적인 일시 중단 지점(suspend points)이 생성되어 코드를 추론하기 더 어려워질 것입니다.</p>

<h3 id="성능-performance">성능 (Performance)</h3>

<p><strong>전반적인 영향 (Overall Impact)</strong></p>

<p>이 제안은 관찰 가능한 성능 영향을 도입하지 않습니다.</p>

<h3 id="구현-implementation">구현 (Implementation)</h3>

<p>PEP 492는 2015년 5월 5일 Guido에 의해 승인되었습니다. 구현은 이슈 24017에서 추적되었으며, 2015년 5월 11일에 커밋되었습니다.</p>

<p><strong>주요 변경 사항 및 새로운 프로토콜 목록 (List of high-level changes and new protocols)</strong></p>

<ul>
  <li>코루틴 정의를 위한 새 구문: <code class="language-plaintext highlighter-rouge">async def</code> 및 새 키워드 <code class="language-plaintext highlighter-rouge">await</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Future-like objects</code>를 위한 새 <code class="language-plaintext highlighter-rouge">__await__</code> 메서드, <code class="language-plaintext highlighter-rouge">PyTypeObject</code>의 새 <code class="language-plaintext highlighter-rouge">tp_as_async.am_await</code> 슬롯.</li>
  <li>비동기 컨텍스트 관리자를 위한 새 구문: <code class="language-plaintext highlighter-rouge">async with</code> 및 <code class="language-plaintext highlighter-rouge">__aenter__</code>, <code class="language-plaintext highlighter-rouge">__aexit__</code> 메서드와 관련된 프로토콜.</li>
  <li>비동기 이터레이션을 위한 새 구문: <code class="language-plaintext highlighter-rouge">async for</code> 및 <code class="language-plaintext highlighter-rouge">__aiter__</code>, <code class="language-plaintext highlighter-rouge">__anext__</code> 메서드, 새 내장 예외 <code class="language-plaintext highlighter-rouge">StopAsyncIteration</code>과 관련된 프로토콜.</li>
  <li><code class="language-plaintext highlighter-rouge">PyTypeObject</code>의 새 <code class="language-plaintext highlighter-rouge">tp_as_async.am_aiter</code> 및 <code class="language-plaintext highlighter-rouge">tp_as_async.am_anext</code> 슬롯.</li>
  <li>새로운 AST 노드: <code class="language-plaintext highlighter-rouge">AsyncFunctionDef</code>, <code class="language-plaintext highlighter-rouge">AsyncFor</code>, <code class="language-plaintext highlighter-rouge">AsyncWith</code>, <code class="language-plaintext highlighter-rouge">Await</code>.</li>
  <li>새로운 함수: <code class="language-plaintext highlighter-rouge">sys.set_coroutine_wrapper(callback)</code>, <code class="language-plaintext highlighter-rouge">sys.get_coroutine_wrapper()</code>, <code class="language-plaintext highlighter-rouge">types.coroutine(gen)</code>, <code class="language-plaintext highlighter-rouge">inspect.iscoroutinefunction(func)</code>, <code class="language-plaintext highlighter-rouge">inspect.iscoroutine(obj)</code>, <code class="language-plaintext highlighter-rouge">inspect.isawaitable(obj)</code>, <code class="language-plaintext highlighter-rouge">inspect.getcoroutinestate(coro)</code>, <code class="language-plaintext highlighter-rouge">inspect.getcoroutinelocals(coro)</code>.</li>
  <li>코드 객체를 위한 새 <code class="language-plaintext highlighter-rouge">CO_COROUTINE</code> 및 <code class="language-plaintext highlighter-rouge">CO_ITERABLE_COROUTINE</code> 비트 플래그.</li>
  <li>새로운 ABC: <code class="language-plaintext highlighter-rouge">collections.abc.Awaitable</code>, <code class="language-plaintext highlighter-rouge">collections.abc.Coroutine</code>, <code class="language-plaintext highlighter-rouge">collections.abc.AsyncIterable</code>, <code class="language-plaintext highlighter-rouge">collections.abc.AsyncIterator</code>.</li>
  <li>C API 변경: 새 <code class="language-plaintext highlighter-rouge">PyCoro_Type</code> (Python에 <code class="language-plaintext highlighter-rouge">types.CoroutineType</code>으로 노출) 및 <code class="language-plaintext highlighter-rouge">PyCoroObject</code>. <code class="language-plaintext highlighter-rouge">PyCoro_CheckExact(*o)</code>로 <code class="language-plaintext highlighter-rouge">o</code>가 네이티브 코루틴인지 테스트.</li>
</ul>

<p>이 변경 사항 및 새로운 요소 목록이 짧지는 않지만, 대부분의 사용자가 이러한 기능을 직접 사용하지 않을 것이라는 점을 이해하는 것이 중요합니다. 이는 프레임워크와 라이브러리에서 사용되어 <code class="language-plaintext highlighter-rouge">async def</code>, <code class="language-plaintext highlighter-rouge">await</code>, <code class="language-plaintext highlighter-rouge">async for</code>, <code class="language-plaintext highlighter-rouge">async with</code> 구문을 통해 사용자에게 편리하고 모호하지 않은 API를 제공하기 위한 것입니다.</p>

<p><strong>작동 예시 (Working example)</strong></p>

<p>이 PEP에서 제안된 모든 개념은 구현되었으며 테스트할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">echo_server</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Serving on localhost:8000</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">start_server</span><span class="p">(</span><span class="n">handle_connection</span><span class="p">,</span> <span class="sh">'</span><span class="s">localhost</span><span class="sh">'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">New connection...</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">reader</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">8192</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Sending {:.10}... back</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">repr</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
        <span class="n">writer</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="p">.</span><span class="nf">run_until_complete</span><span class="p">(</span><span class="nf">echo_server</span><span class="p">())</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="p">.</span><span class="nf">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
</code></pre></div></div>

<blockquote>
  <p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/tags/#python" class="page__taxonomy-item" rel="tag">Python</a><span class="sep">, </span>
    
      <a href="/tags/#translation" class="page__taxonomy-item" rel="tag">Translation</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/categories/#python" class="page__taxonomy-item" rel="tag">Python</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2025-09-26">September 26, 2025</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/python/pep/491/" class="pagination--pager" title="[Deferred] PEP 491 - The Wheel Binary Package Format 1.9
">Previous</a>
    
    
      <a href="/python/pep/493/" class="pagination--pager" title="[Final] PEP 493 - HTTPS verification migration tools for Python 2.7
">Next</a>
    
  </nav>


    </div>

    
  </article>

</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 secrett2633. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'secrett2633/secrett2633.github.io');
    script.setAttribute('issue-term', 'pathname');
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





  </body>
</html>
