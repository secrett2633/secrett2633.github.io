<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <style> 
      ::-webkit-scrollbar{ 
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-track {
        width: 0px;
        background-color: #626262;
        /* border-radius: 5px; */
      }

      ::-webkit-scrollbar-thumb {
        width: 0px;
        background-color: #E2E2E2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-thumb:hover {
        width: 10px;
        height: 20px;
        /* background-color: rgba(190, 190, 190, 0.2); */
        background-color: #A2A2A2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-track:hover {
        width: 10px;
        /* background-color: rgba(150, 150, 150, 0.1); */
        background-color: #626262;
        border-radius: 5px;
        /* background: transparent; */
        /* border-radius: 10px; */
      }

      ::-webkit-scrollbar-button:start:decrement,::-webkit-scrollbar-button:end:increment {
          width:0px;
          height: 0px;
          /* background-color: rgb(14, 221, 24); */
          /* border-radius: 50%; */
      }
    </style>
    
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[Final] PEP 750 - Template Strings | secrett2633</title>
<meta name="description" content="Python Enhancement Proposal 750: ‘Template Strings’에 대한 한국어 번역입니다.">


  <meta name="author" content="secrett2633">
  
  <meta property="article:author" content="secrett2633">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="secrett2633's blog">
<meta property="og:title" content="[Final] PEP 750 - Template Strings">
<meta property="og:url" content="http://localhost:4000/python/pep/750/">


  <meta property="og:description" content="Python Enhancement Proposal 750: ‘Template Strings’에 대한 한국어 번역입니다.">







  <meta property="article:published_time" content="2025-09-27T13:38:50+09:00">



  <meta property="article:modified_time" content="2025-09-27T13:38:50+09:00">



  

  


<link rel="canonical" href="http://localhost:4000/python/pep/750/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "secrett2633",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="secrett2633's blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->


    <link rel="icon" type="image/png" sizes="32x32" href="https://secrett2633.github.io/assets/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://secrett2633.github.io/assets/images/favicon/favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          secrett2633's blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://github.com/secrett2633">GitHub</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <!-- 2022.02.17 author content hidden -->
  <!-- <div class="author__content">
    
      <h3 class="author__name" itemprop="name">secrett2633</h3>
    
    
  </div> -->

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
      
    
    
      <nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    <!-- Backend -->
    <li>
      <span class="nav__sub-title">Backend</span>
      <hr>
      <ul>
        <li><a href="/backend/django/">Django</a></li>
        <li><a href="/backend/logging/">Logging</a></li>
      </ul>
    </li>

    <!-- Python -->
    <li>
      <span class="nav__sub-title">Python</span>
      <hr>
      <ul>
        <li><a href="/python/pep/">PEP</a></li>
      </ul>
    </li>

    <!-- AI/ML -->
    <li>
      <span class="nav__sub-title">AI/ML</span>
      <hr>
      <ul>
        <li><a href="/ai/llm/">LLM</a></li>
        <li><a href="/ai/review/">Review</a></li>
      </ul>
    </li>

    <!-- DevOps -->
    <li>
      <span class="nav__sub-title">DevOps</span>
      <hr>
      <ul>
        <li><a href="/devops/nginx/">Nginx</a></li>
        <li><a href="/devops/docker/">Docker</a></li>
        <li><a href="/devops/safeline/">SafeLine</a></li>
        <li><a href="/devops/jenkins/">Jenkins</a></li>
        <li><a href="/devops/github-actions/">GitHub Actions</a></li>
        <li><a href="/devops/aws/">AWS</a></li>
      </ul>
    </li>

    <!-- etc -->
    <li>
      <span class="nav__sub-title">etc</span>
      <hr>
      <ul>
        <li><a href="/etc/me/">Me</a></li>
        <li><a href="/etc/chrome-extension/">Chrome Extension</a></li>
      </ul>
    </li>
  </ul>
</nav>
    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[Final] PEP 750 - Template Strings">
    <meta itemprop="description" content="Python Enhancement Proposal 750: ‘Template Strings’에 대한 한국어 번역입니다.">
    <meta itemprop="datePublished" content="2025-09-27T13:38:50+09:00">
    <meta itemprop="dateModified" content="2025-09-27T13:38:50+09:00">

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">[Final] PEP 750 - Template Strings
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2025-09-27T13:38:50+09:00">September 27, 2025</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#pep-750--template-strings">PEP 750 – Template Strings</a><ul><li><a href="#개요-abstract">개요 (Abstract)</a></li><li><a href="#다른-peps와의-관계-relationship-with-other-peps">다른 PEPs와의 관계 (Relationship With Other PEPs)</a></li><li><a href="#동기-motivation">동기 (Motivation)</a></li><li><a href="#사양-specification">사양 (Specification)</a><ul><li><a href="#템플릿-문자열-리터럴-template-string-literals">템플릿 문자열 리터럴 (Template String Literals)</a></li><li><a href="#template-타입-the-template-type">Template 타입 (The Template Type)</a></li><li><a href="#interpolation-타입-the-interpolation-type">Interpolation 타입 (The Interpolation Type)</a></li><li><a href="#templatevalues-속성-the-templatevalues-property">Template.values 속성 (The Template.values Property)</a></li><li><a href="#템플릿-내용-반복-iterating-template-contents">템플릿 내용 반복 (Iterating Template Contents)</a></li><li><a href="#템플릿-문자열-처리-processing-template-strings">템플릿 문자열 처리 (Processing Template Strings)</a></li><li><a href="#템플릿-문자열-연결-template-string-concatenation">템플릿 문자열 연결 (Template String Concatenation)</a></li><li><a href="#template-및-interpolation-동등성-template-and-interpolation-equality">Template 및 Interpolation 동등성 (Template and Interpolation Equality)</a></li><li><a href="#순서-지정-미지원-no-support-for-ordering">순서 지정 미지원 (No Support for Ordering)</a></li><li><a href="#디버그-지정자-지원--support-for-the-debug-specifier---">디버그 지정자 지원 (=) (Support for the debug specifier ( = ))</a></li><li><a href="#raw-template-strings-원시-템플릿-문자열">Raw Template Strings (원시 템플릿 문자열)</a></li><li><a href="#보간-표현식-평가-interpolation-expression-evaluation">보간 표현식 평가 (Interpolation Expression Evaluation)</a></li><li><a href="#예외-exceptions">예외 (Exceptions)</a></li><li><a href="#template__str__-구현-없음-no-templatestr-implementation">Template.__str__() 구현 없음 (No Template.str() Implementation)</a></li><li><a href="#stringtemplatelib-모듈-the-stringtemplatelib-module">string.templatelib 모듈 (The string.templatelib Module)</a></li></ul></li><li><a href="#예제-examples">예제 (Examples)</a><ul><li><a href="#예제-t-strings로-f-strings-구현하기-example-implementing-f-strings-with-t-strings">예제: t-strings로 f-strings 구현하기 (Example: Implementing f-strings with t-strings)</a></li><li><a href="#예제-구조화된-로깅-example-structured-logging">예제: 구조화된 로깅 (Example: Structured Logging)</a><ul><li><a href="#접근-방식-1-커스텀-로그-메시지-approach-1-custom-log-messages">접근 방식 1: 커스텀 로그 메시지 (Approach 1: Custom Log Messages)</a></li><li><a href="#접근-방식-2-커스텀-포맷터-approach-2-custom-formatters">접근 방식 2: 커스텀 포맷터 (Approach 2: Custom Formatters)</a></li></ul></li><li><a href="#예제-html-템플릿-example-html-templating">예제: HTML 템플릿 (Example: HTML Templating)</a></li></ul></li><li><a href="#하위-호환성-backwards-compatibility">하위 호환성 (Backwards Compatibility)</a></li><li><a href="#보안-영향-security-implications">보안 영향 (Security Implications)</a></li><li><a href="#교육-방법-how-to-teach-this">교육 방법 (How To Teach This)</a></li><li><a href="#또-다른-템플릿-접근-방식이-필요한-이유-why-another-templating-approach">또 다른 템플릿 접근 방식이 필요한 이유 (Why another templating approach?)</a></li><li><a href="#템플릿-처리에서-흔히-볼-수-있는-패턴-common-patterns-seen-in-processing-templates">템플릿 처리에서 흔히 볼 수 있는 패턴 (Common Patterns Seen in Processing Templates)</a><ul><li><a href="#구조적-패턴-매칭-structural-pattern-matching">구조적 패턴 매칭 (Structural Pattern Matching)</a></li><li><a href="#메모이제이션-memoizing">메모이제이션 (Memoizing)</a></li><li><a href="#중간-표현으로-파싱-parsing-to-intermediate-representations">중간 표현으로 파싱 (Parsing to Intermediate Representations)</a></li><li><a href="#컨텍스트에-민감한-보간-처리-context-sensitive-processing-of-interpolations">컨텍스트에 민감한 보간 처리 (Context-sensitive Processing of Interpolations)</a></li><li><a href="#중첩된-템플릿-문자열-nested-template-strings">중첩된 템플릿 문자열 (Nested Template Strings)</a></li><li><a href="#지연-평가-접근-방식-approaches-to-lazy-evaluation">지연 평가 접근 방식 (Approaches to Lazy Evaluation)</a></li><li><a href="#비동기-평가-접근-방식-approaches-to-asynchronous-evaluation">비동기 평가 접근 방식 (Approaches to Asynchronous Evaluation)</a></li><li><a href="#템플릿-재사용-접근-방식-approaches-to-template-reuse">템플릿 재사용 접근 방식 (Approaches to Template Reuse)</a></li><li><a href="#형식-문자열과의-관계-relation-to-format-strings">형식 문자열과의 관계 (Relation to Format Strings)</a></li></ul></li><li><a href="#참조-구현-reference-implementation">참조 구현 (Reference Implementation)</a></li><li><a href="#거부된-아이디어-rejected-ideas">거부된 아이디어 (Rejected Ideas)</a><ul><li><a href="#임의의-문자열-리터럴-접두사-arbitrary-string-literal-prefixes">임의의 문자열 리터럴 접두사 (Arbitrary String Literal Prefixes)</a></li><li><a href="#보간의-지연-평가-delayed-evaluation-of-interpolations">보간의 지연 평가 (Delayed Evaluation of Interpolations)</a></li><li><a href="#template-및-interpolation을-프로토콜로-만들기-making-template-and-interpolation-into-protocols">Template 및 Interpolation을 프로토콜로 만들기 (Making Template and Interpolation Into Protocols)</a></li><li><a href="#template-및-interpolation에-대한-__eq__-및-__hash__-오버라이드-overridden-eq-and-hash-for-template-and-interpolation">Template 및 Interpolation에 대한 __eq__ 및 __hash__ 오버라이드 (Overridden eq and hash for Template and Interpolation)</a></li><li><a href="#추가-decoded-타입-an-additional-decoded-type">추가 Decoded 타입 (An Additional Decoded Type)</a></li><li><a href="#template-및-interpolation의-최종-위치-the-final-home-for-template-and-interpolation">Template 및 Interpolation의 최종 위치 (The Final Home for Template and Interpolation)</a></li><li><a href="#원본-템플릿-리터럴의-완전한-재구성-활성화-enable-full-reconstruction-of-original-template-literal">원본 템플릿 리터럴의 완전한 재구성 활성화 (Enable Full Reconstruction of Original Template Literal)</a></li><li><a href="#템플릿-연결-금지-disallowing-template-concatenation">템플릿 연결 금지 (Disallowing Template Concatenation)</a></li><li><a href="#임의의-변환-값-arbitrary-conversion-values">임의의 변환 값 (Arbitrary Conversion Values)</a></li><li><a href="#interpolation에서-conversion-제거-removing-conversion-from-interpolation">Interpolation에서 conversion 제거 (Removing conversion From Interpolation)</a></li><li><a href="#대체-보간-기호-alternate-interpolation-symbols">대체 보간 기호 (Alternate Interpolation Symbols)</a></li><li><a href="#template의-대체-레이아웃-alternate-layouts-for-template">Template의 대체 레이아웃 (Alternate Layouts for Template)</a></li><li><a href="#템플릿-종류를-설명하는-메커니즘-mechanism-to-describe-the-kind-of-template">템플릿 “종류”를 설명하는 메커니즘 (Mechanism to Describe the “Kind” of Template)</a></li><li><a href="#바이너리-템플릿-문자열-binary-template-strings">바이너리 템플릿 문자열 (Binary Template Strings)</a></li></ul></li><li><a href="#감사의-말-acknowledgements">감사의 말 (Acknowledgements)</a></li></ul></li></ul>

            </nav>
          </aside>
        
        <blockquote>
  <p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0750/">PEP 750 - Template Strings</a></p>

  <table>
    <tbody>
      <tr>
        <td><strong>상태:</strong> Final</td>
        <td><strong>유형:</strong> Standards Track</td>
        <td><strong>작성일:</strong> 08-Jul-2024</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h1 id="pep-750--template-strings">PEP 750 – Template Strings</h1>

<ul>
  <li><strong>작성자:</strong> Jim Baker 외 다수</li>
  <li><strong>논의처:</strong> Discourse thread</li>
  <li><strong>상태:</strong> Final</li>
  <li><strong>유형:</strong> Standards Track</li>
  <li><strong>생성일:</strong> 2024년 7월 8일</li>
  <li><strong>Python 버전:</strong> 3.14</li>
  <li><strong>해결일:</strong> 2025년 4월 10일</li>
</ul>

<p><strong>중요:</strong> 이 PEP는 역사적인 문서이며, 최신 공식 문서는 <a href="https://docs.python.org/3.14/reference/lexical_analysis.html#template-strings">Template strings</a>에서 확인할 수 있습니다.</p>

<h2 id="개요-abstract">개요 (Abstract)</h2>

<p>이 PEP는 커스텀 문자열 처리를 위한 Template Strings (템플릿 문자열)를 소개합니다.</p>

<p>템플릿 문자열은 <code class="language-plaintext highlighter-rouge">f-strings</code>의 일반화된 형태로, <code class="language-plaintext highlighter-rouge">f</code> 접두사 대신 <code class="language-plaintext highlighter-rouge">t</code> 접두사를 사용합니다. <code class="language-plaintext highlighter-rouge">str</code>로 평가되는 대신, <code class="language-plaintext highlighter-rouge">t-strings</code>는 새로운 타입인 <code class="language-plaintext highlighter-rouge">Template</code>으로 평가됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">template</span><span class="p">:</span> <span class="n">Template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {name}</span><span class="sh">"</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Template</code>은 개발자가 문자열과 보간된 값(interpolated values)이 결합되기 전에 이들에 접근할 수 있도록 합니다. 이는 Python 언어에 유연한 기본 문자열 처리 기능을 제공하고, 보안 검사, 웹 템플릿, 도메인 특화 언어(DSL) 등을 가능하게 합니다.</p>

<h2 id="다른-peps와의-관계-relationship-with-other-peps">다른 PEPs와의 관계 (Relationship With Other PEPs)</h2>

<ul>
  <li>Python은 PEP 498을 통해 Python 3.6에서 <code class="language-plaintext highlighter-rouge">f-strings</code>를 도입했습니다.</li>
  <li>문법은 PEP 701에서 공식화되었고 일부 제한 사항이 해제되었습니다. 이 PEP는 PEP 701을 기반으로 합니다.</li>
  <li>PEP 498과 거의 동시에 PEP 501이 “i-strings”(interpolation template strings)를 제공하기 위해 작성되었으나, <code class="language-plaintext highlighter-rouge">f-strings</code> 경험이 더 필요하여 연기되었습니다.</li>
  <li>이 PEP는 2023년 3월 다른 저자에 의해 “t-strings”라는 템플릿 리터럴 문자열로 작업이 재개되었고, PEP 701 위에 구축되었습니다.</li>
  <li>이 PEP의 저자들은 PEP 501의 업데이트된 작업에 대한 일반화 및 단순화로 간주합니다.</li>
</ul>

<h2 id="동기-motivation">동기 (Motivation)</h2>

<p>Python의 <code class="language-plaintext highlighter-rouge">f-strings</code>는 사용하기 쉽고 매우 인기가 많습니다. 그러나 시간이 지남에 따라 개발자들은 특정 사용 사례에 적합하지 않은 제약 사항에 직면했습니다. 특히 <code class="language-plaintext highlighter-rouge">f-strings</code>는 보간된 값들이 최종 문자열로 결합되기 전에 가로채서 변환할 방법이 없습니다.</p>

<p>그 결과, <code class="language-plaintext highlighter-rouge">f-strings</code>를 부주의하게 사용하면 보안 취약점으로 이어질 수 있습니다. 예를 들어:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sqlite3</code>를 사용하여 SQL 쿼리를 실행하는 사용자가 <code class="language-plaintext highlighter-rouge">f-string</code>을 사용하여 값을 SQL 표현식에 삽입하려 할 경우, SQL 인젝션 공격으로 이어질 수 있습니다.</li>
  <li>HTML을 구축하는 개발자가 이스케이프되지 않은 사용자 입력을 문자열에 포함하면, Cross-Site Scripting (XSS) 취약점이 발생할 수 있습니다.</li>
</ul>

<p>더 나아가, 보간된 값들을 최종 문자열로 결합하기 전에 변환할 수 없다는 점은 더 복잡한 문자열 처리 작업에서 <code class="language-plaintext highlighter-rouge">f-strings</code>의 유용성을 제한합니다.</p>

<p>템플릿 문자열은 개발자에게 문자열과 보간된 값에 대한 접근 권한을 제공함으로써 이러한 문제들을 해결합니다.</p>

<p>예를 들어, HTML을 생성하고 싶다고 가정해 봅시다. 템플릿 문자열을 사용하면 콘텐츠를 자동으로 새니타이즈(sanitize)할 수 있는 <code class="language-plaintext highlighter-rouge">html()</code> 함수를 정의할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">evil</span> <span class="o">=</span> <span class="sh">"</span><span class="s">&lt;script&gt;alert(</span><span class="sh">'</span><span class="s">evil</span><span class="sh">'</span><span class="s">)&lt;/script&gt;</span><span class="sh">"</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">&lt;p&gt;{evil}&lt;/p&gt;</span><span class="sh">"</span>
<span class="c1"># html() 함수를 통해 악성 스크립트가 이스케이프됨
</span><span class="k">assert</span> <span class="nf">html</span><span class="p">(</span><span class="n">template</span><span class="p">)</span> <span class="o">==</span> <span class="sh">"</span><span class="s">&lt;p&gt;&amp;lt;script&amp;gt;alert(</span><span class="sh">'</span><span class="s">evil</span><span class="sh">'</span><span class="s">)&amp;lt;/script&amp;gt;&lt;/p&gt;</span><span class="sh">"</span>
</code></pre></div></div>

<p>또한, <code class="language-plaintext highlighter-rouge">html()</code> 함수는 딕셔너리를 사용하여 HTML 요소에 속성을 쉽게 추가할 수 있도록 합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">src</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">shrubbery.jpg</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">alt</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">looks nice</span><span class="sh">"</span><span class="p">}</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">&lt;img {attributes} /&gt;</span><span class="sh">"</span>
<span class="k">assert</span> <span class="nf">html</span><span class="p">(</span><span class="n">template</span><span class="p">)</span> <span class="o">==</span> <span class="sh">'</span><span class="s">&lt;img src=</span><span class="sh">"</span><span class="s">shrubbery.jpg</span><span class="sh">"</span><span class="s"> alt=</span><span class="sh">"</span><span class="s">looks nice</span><span class="sh">"</span><span class="s"> /&gt;</span><span class="sh">'</span>
</code></pre></div></div>

<p>이러한 예제들은 <code class="language-plaintext highlighter-rouge">f-strings</code>로는 불가능합니다. 보간된 값들을 가로채고 변환하는 메커니즘을 제공함으로써 템플릿 문자열은 광범위한 문자열 처리 사용 사례를 가능하게 합니다.</p>

<h2 id="사양-specification">사양 (Specification)</h2>

<h3 id="템플릿-문자열-리터럴-template-string-literals">템플릿 문자열 리터럴 (Template String Literals)</h3>

<p>이 PEP는 템플릿 문자열 리터럴을 정의하기 위한 새로운 문자열 접두사 <code class="language-plaintext highlighter-rouge">t</code>를 소개합니다. 이 리터럴들은 표준 라이브러리 모듈 <code class="language-plaintext highlighter-rouge">string.templatelib</code>에 있는 새로운 타입 <code class="language-plaintext highlighter-rouge">Template</code>으로 해석됩니다.</p>

<p>다음 코드는 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스를 생성합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">string.templatelib</span> <span class="kn">import</span> <span class="n">Template</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">This is a template string.</span><span class="sh">"</span>
<span class="k">assert</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">Template</span><span class="p">)</span>
</code></pre></div></div>

<p>템플릿 문자열 리터럴은 PEP 701의 전체 문법을 지원합니다. 여기에는 보간(interpolations) 내에 템플릿 문자열을 중첩하는 기능과 모든 유효한 따옴표(<code class="language-plaintext highlighter-rouge">'</code>, <code class="language-plaintext highlighter-rouge">"</code>, <code class="language-plaintext highlighter-rouge">'''</code>, <code class="language-plaintext highlighter-rouge">"""</code>)를 사용하는 기능이 포함됩니다.</p>

<ul>
  <li>다른 문자열 접두사처럼 <code class="language-plaintext highlighter-rouge">t</code> 접두사는 따옴표 바로 앞에 와야 합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">f-strings</code>와 마찬가지로 소문자 <code class="language-plaintext highlighter-rouge">t</code>와 대문자 <code class="language-plaintext highlighter-rouge">T</code> 접두사 모두 지원됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">f-strings</code>와 마찬가지로 <code class="language-plaintext highlighter-rouge">t-strings</code>는 <code class="language-plaintext highlighter-rouge">u</code> 또는 <code class="language-plaintext highlighter-rouge">b</code> 접두사와 결합될 수 없습니다.</li>
  <li>또한, <code class="language-plaintext highlighter-rouge">f-strings</code>와 <code class="language-plaintext highlighter-rouge">t-strings</code>는 결합될 수 없으므로 <code class="language-plaintext highlighter-rouge">ft</code> 접두사는 유효하지 않습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">t-strings</code>는 <code class="language-plaintext highlighter-rouge">r</code> 접두사와 결합될 수 있습니다. 자세한 내용은 “Raw Template Strings” 섹션을 참조하십시오.</li>
</ul>

<h3 id="template-타입-the-template-type">Template 타입 (The Template Type)</h3>

<p>템플릿 문자열은 새로운 불변(immutable) 타입인 <code class="language-plaintext highlighter-rouge">string.templatelib.Template</code>의 인스턴스로 평가됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Template</span><span class="p">:</span>
    <span class="n">strings</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="p">...]</span>
    <span class="sh">"""</span><span class="s">
    템플릿의 문자열 부분으로 구성된 비어 있지 않은 튜플이며,
    템플릿의 보간 수 N에 대해 N+1개의 항목을 가집니다.
    </span><span class="sh">"""</span>
    <span class="n">interpolations</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Interpolation</span><span class="p">,</span> <span class="p">...]</span>
    <span class="sh">"""</span><span class="s">
    템플릿의 보간 부분으로 구성된 튜플입니다.
    보간이 없는 경우 빈 튜플이 됩니다.
    </span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Interpolation</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        새로운 Template 인스턴스를 생성합니다. 인수는 어떤 순서로든 제공될 수 있습니다.
        </span><span class="sh">"""</span>
        <span class="bp">...</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">object</span><span class="p">,</span> <span class="p">...]:</span>
        <span class="sh">"""</span><span class="s">
        템플릿 내 각 Interpolation의 `value` 속성으로 구성된 튜플을 반환합니다.
        보간이 없는 경우 빈 튜플이 됩니다.
        </span><span class="sh">"""</span>
        <span class="bp">...</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="n">Interpolation</span><span class="p">]:</span>
        <span class="sh">"""</span><span class="s">
        템플릿의 문자열 부분과 보간을 나타나는 순서대로 반복합니다.
        빈 문자열은 포함되지 않습니다.
        </span><span class="sh">"""</span>
        <span class="bp">...</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">strings</code> 및 <code class="language-plaintext highlighter-rouge">interpolations</code> 속성은 리터럴 내의 문자열 부분과 모든 보간에 접근할 수 있도록 합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {name}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
</code></pre></div></div>

<h3 id="interpolation-타입-the-interpolation-type">Interpolation 타입 (The Interpolation Type)</h3>

<p><code class="language-plaintext highlighter-rouge">Interpolation</code> 타입은 템플릿 문자열 내의 표현식을 나타냅니다. <code class="language-plaintext highlighter-rouge">Template</code>과 마찬가지로 <code class="language-plaintext highlighter-rouge">string.templatelib</code> 모듈에 있는 새로운 클래스입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Interpolation</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">object</span>
    <span class="n">expression</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">conversion</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">s</span><span class="sh">"</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span>
    <span class="n">format_spec</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">__match_args__</span> <span class="o">=</span> <span class="p">(</span><span class="sh">"</span><span class="s">value</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">expression</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">conversion</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">format_spec</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span>
        <span class="n">cls</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span>
        <span class="n">expression</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sh">""</span><span class="p">,</span>
        <span class="n">conversion</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">s</span><span class="sh">"</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">format_spec</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sh">""</span><span class="p">,</span>
    <span class="p">):</span> <span class="bp">...</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Interpolation</code> 타입은 얕은 불변(shallow immutable)입니다. 속성은 재할당될 수 없습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">value</code> 속성은 보간의 평가된 결과입니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {name}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
</code></pre></div>    </div>
  </li>
  <li>템플릿 문자열 리터럴에서 보간이 생성될 때, <code class="language-plaintext highlighter-rouge">expression</code> 속성은 보간의 원래 텍스트를 포함합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {name}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">expression</span> <span class="o">==</span> <span class="sh">"</span><span class="s">name</span><span class="sh">"</span>
</code></pre></div>    </div>
    <p>개발자가 명시적으로 <code class="language-plaintext highlighter-rouge">Interpolation</code>을 구성할 때, <code class="language-plaintext highlighter-rouge">expression</code> 속성의 값을 선택적으로 제공할 수 있습니다. 문자열로 저장되지만, 유효한 Python 표현식이어야 합니다. 값이 제공되지 않으면 <code class="language-plaintext highlighter-rouge">expression</code> 속성은 기본적으로 빈 문자열(<code class="language-plaintext highlighter-rouge">""</code>)이 됩니다.
대부분의 템플릿 처리 코드에서 <code class="language-plaintext highlighter-rouge">expression</code> 속성은 사용되지 않을 것으로 예상됩니다. 디버깅 및 인트로스펙션(introspection)을 위해 제공됩니다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">conversion</code> 속성은 선택적으로 사용할 수 있는 변환으로, <code class="language-plaintext highlighter-rouge">repr()</code>, <code class="language-plaintext highlighter-rouge">str()</code>, <code class="language-plaintext highlighter-rouge">ascii()</code> 변환에 해당하는 <code class="language-plaintext highlighter-rouge">r</code>, <code class="language-plaintext highlighter-rouge">s</code>, <code class="language-plaintext highlighter-rouge">a</code> 중 하나입니다. <code class="language-plaintext highlighter-rouge">f-strings</code>와 마찬가지로 다른 변환은 지원되지 않습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {name!r}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">conversion</span> <span class="o">==</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span>
</code></pre></div>    </div>
    <p>변환이 제공되지 않으면 <code class="language-plaintext highlighter-rouge">conversion</code>은 <code class="language-plaintext highlighter-rouge">None</code>입니다.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">format_spec</code> 속성은 형식 지정(format specification)입니다. <code class="language-plaintext highlighter-rouge">f-strings</code>와 마찬가지로 값의 표현 방식을 정의하는 임의의 문자열입니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Value: {value:.2f}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">format_spec</span> <span class="o">==</span> <span class="sh">"</span><span class="s">.2f</span><span class="sh">"</span>
</code></pre></div>    </div>
    <p><code class="language-plaintext highlighter-rouge">f-strings</code>의 형식 지정은 그 자체로 보간을 포함할 수 있습니다. 템플릿 문자열에서도 허용되며, <code class="language-plaintext highlighter-rouge">format_spec</code>은 즉시 평가된 결과로 설정됩니다.</p>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">precision</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Value: {value:.{precision}f}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">format_spec</span> <span class="o">==</span> <span class="sh">"</span><span class="s">.2f</span><span class="sh">"</span>
</code></pre></div>    </div>
    <p>형식 지정이 제공되지 않으면 <code class="language-plaintext highlighter-rouge">format_spec</code>은 기본적으로 빈 문자열(<code class="language-plaintext highlighter-rouge">""</code>)이 됩니다. 이는 Python의 내장 <code class="language-plaintext highlighter-rouge">format()</code> 함수의 <code class="language-plaintext highlighter-rouge">format_spec</code> 매개변수와 일치합니다.</p>

    <p><code class="language-plaintext highlighter-rouge">f-strings</code>와 달리, <code class="language-plaintext highlighter-rouge">conversion</code> 및 <code class="language-plaintext highlighter-rouge">format_spec</code> 속성을 해석하는 방법은 템플릿을 처리하는 코드에 달려 있습니다. 이러한 코드가 이 속성들을 반드시 사용해야 하는 것은 아니지만, 존재하는 경우 존중되어야 하며, 가능한 한 <code class="language-plaintext highlighter-rouge">f-strings</code>의 동작과 일치해야 합니다. 예를 들어, <code class="language-plaintext highlighter-rouge">{value:.2f}</code>를 사용하는 템플릿 문자열이 처리될 때 값을 소수점 이하 두 자리로 반올림하지 않는다면 놀라울 것입니다.</p>
  </li>
</ul>

<h3 id="templatevalues-속성-the-templatevalues-property">Template.values 속성 (The Template.values Property)</h3>

<p><code class="language-plaintext highlighter-rouge">Template.values</code> 속성은 템플릿 내 각 <code class="language-plaintext highlighter-rouge">Interpolation</code>의 <code class="language-plaintext highlighter-rouge">value</code> 속성에 접근하기 위한 단축키이며 다음 코드와 동일합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@property</span>
<span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">object</span><span class="p">,</span> <span class="p">...]:</span>
    <span class="k">return</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">interpolations</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="템플릿-내용-반복-iterating-template-contents">템플릿 내용 반복 (Iterating Template Contents)</h3>

<p><code class="language-plaintext highlighter-rouge">Template.__iter__()</code> 메서드는 템플릿의 전체 내용에 접근하는 간단한 방법을 제공합니다. 이는 문자열 부분과 보간을 나타나는 순서대로, 빈 문자열을 제외하고 반환합니다.</p>

<p><code class="language-plaintext highlighter-rouge">__iter__()</code> 메서드는 다음 코드와 동일합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="n">Interpolation</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">zip_longest</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">strings</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">interpolations</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">s</span>
        <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">i</span>
</code></pre></div></div>

<p>다음 예제는 <code class="language-plaintext highlighter-rouge">__iter__()</code> 메서드의 동작을 보여줍니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="nf">list</span><span class="p">(</span><span class="n">t</span><span class="sh">""</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]</span>
<span class="k">assert</span> <span class="nf">list</span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">Hello</span><span class="sh">"</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="sh">"</span><span class="s">Hello</span><span class="sh">"</span><span class="p">]</span>

<span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {name}!</span><span class="sh">"</span>
<span class="n">contents</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
<span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
<span class="k">assert</span> <span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">expression</span> <span class="o">==</span> <span class="sh">"</span><span class="s">name</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">contents</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">!</span><span class="sh">"</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Template.strings</code>에 존재할 수 있는 빈 문자열은 <code class="language-plaintext highlighter-rouge">__iter__()</code> 메서드의 출력에 포함되지 않습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Eat</span><span class="sh">"</span>
<span class="n">second</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Red Leicester</span><span class="sh">"</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">{first}{second}</span><span class="sh">"</span>
<span class="n">contents</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
<span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
<span class="k">assert</span> <span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">Eat</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">expression</span> <span class="o">==</span> <span class="sh">"</span><span class="s">first</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">Red Leicester</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">expression</span> <span class="o">==</span> <span class="sh">"</span><span class="s">second</span><span class="sh">"</span>
<span class="c1"># 그러나 strings 속성에는 빈 문자열이 포함됩니다:
</span><span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">strings</span> <span class="o">==</span> <span class="p">(</span><span class="sh">""</span><span class="p">,</span> <span class="sh">""</span><span class="p">,</span> <span class="sh">""</span><span class="p">)</span>
</code></pre></div></div>

<p>템플릿 처리 코드는 요구 사항과 편의에 따라 <code class="language-plaintext highlighter-rouge">strings</code>, <code class="language-plaintext highlighter-rouge">interpolations</code>, <code class="language-plaintext highlighter-rouge">values</code>, <code class="language-plaintext highlighter-rouge">__iter__()</code>의 어떤 조합으로든 작업할 수 있습니다.</p>

<h3 id="템플릿-문자열-처리-processing-template-strings">템플릿 문자열 처리 (Processing Template Strings)</h3>

<p>개발자는 템플릿 문자열을 처리하기 위한 임의의 코드를 작성할 수 있습니다. 예를 들어, 다음 함수는 템플릿의 정적 부분을 소문자로, 보간을 대문자로 렌더링합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">string.templatelib</span> <span class="kn">import</span> <span class="n">Template</span><span class="p">,</span> <span class="n">Interpolation</span>

<span class="k">def</span> <span class="nf">lower_upper</span><span class="p">(</span><span class="n">template</span><span class="p">:</span> <span class="n">Template</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">정적 부분은 소문자로, 보간은 대문자로 렌더링합니다.</span><span class="sh">"""</span>
    <span class="n">parts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">template</span><span class="p">:</span>
        <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Interpolation</span><span class="p">):</span>
            <span class="n">parts</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">value</span><span class="p">).</span><span class="nf">upper</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parts</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="nf">lower</span><span class="p">())</span>
    <span class="k">return</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>

<span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">world</span><span class="sh">"</span>
<span class="k">assert</span> <span class="nf">lower_upper</span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">HELLO {name}</span><span class="sh">"</span><span class="p">)</span> <span class="o">==</span> <span class="sh">"</span><span class="s">hello WORLD</span><span class="sh">"</span>
</code></pre></div></div>

<p>템플릿 문자열이 특정 방식으로 처리되어야 한다는 요구 사항은 없습니다. 템플릿을 처리하는 코드는 문자열을 반환할 의무가 없습니다. 템플릿 문자열은 유연하고 범용적인 기능입니다.</p>

<h3 id="템플릿-문자열-연결-template-string-concatenation">템플릿 문자열 연결 (Template String Concatenation)</h3>

<p>템플릿 문자열은 <code class="language-plaintext highlighter-rouge">+</code>를 사용한 명시적 연결을 지원합니다. <code class="language-plaintext highlighter-rouge">Template.__add__()</code>를 통해 두 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스에 대한 연결이 지원됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="k">assert</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span> <span class="o">+</span> <span class="n">t</span><span class="sh">"</span><span class="s">{name}</span><span class="sh">"</span><span class="p">,</span> <span class="n">Template</span><span class="p">)</span>
<span class="nf">assert </span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span> <span class="o">+</span> <span class="n">t</span><span class="sh">"</span><span class="s">{name}</span><span class="sh">"</span><span class="p">).</span><span class="n">strings</span> <span class="o">==</span> <span class="p">(</span><span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span><span class="p">,</span> <span class="sh">""</span><span class="p">)</span>
<span class="nf">assert </span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span> <span class="o">+</span> <span class="n">t</span><span class="sh">"</span><span class="s">{name}</span><span class="sh">"</span><span class="p">).</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
</code></pre></div></div>

<p>두 템플릿 문자열 리터럴의 암시적 연결도 지원됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="k">assert</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span> <span class="n">t</span><span class="sh">"</span><span class="s">{name}</span><span class="sh">"</span><span class="p">,</span> <span class="n">Template</span><span class="p">)</span>
<span class="nf">assert </span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span> <span class="n">t</span><span class="sh">"</span><span class="s">{name}</span><span class="sh">"</span><span class="p">).</span><span class="n">strings</span> <span class="o">==</span> <span class="p">(</span><span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span><span class="p">,</span> <span class="sh">""</span><span class="p">)</span>
<span class="nf">assert </span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span> <span class="n">t</span><span class="sh">"</span><span class="s">{name}</span><span class="sh">"</span><span class="p">).</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Template</code>과 <code class="language-plaintext highlighter-rouge">str</code>의 암시적 및 명시적 연결은 금지됩니다. 이는 <code class="language-plaintext highlighter-rouge">str</code>이 정적 문자열 부분으로 처리되어야 하는지, 아니면 보간으로 처리되어야 하는지 모호하기 때문입니다.</p>

<p><code class="language-plaintext highlighter-rouge">Template</code>과 <code class="language-plaintext highlighter-rouge">str</code>을 결합하려면 개발자는 <code class="language-plaintext highlighter-rouge">str</code>을 어떻게 처리할지 명시적으로 결정해야 합니다. <code class="language-plaintext highlighter-rouge">str</code>이 정적 문자열 부분으로 의도된 경우 <code class="language-plaintext highlighter-rouge">Template</code>으로 래핑(wrap)해야 합니다. <code class="language-plaintext highlighter-rouge">str</code>이 보간 값으로 의도된 경우 <code class="language-plaintext highlighter-rouge">Interpolation</code>으로 래핑하고 <code class="language-plaintext highlighter-rouge">Template</code> 생성자에 전달해야 합니다. 예를 들어:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="c1"># `name`을 정적 문자열 부분으로 처리
</span><span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span> <span class="o">+</span> <span class="nc">Template</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># `name`을 보간으로 처리
</span><span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span> <span class="o">+</span> <span class="nc">Template</span><span class="p">(</span><span class="nc">Interpolation</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="template-및-interpolation-동등성-template-and-interpolation-equality">Template 및 Interpolation 동등성 (Template and Interpolation Equality)</h3>

<p><code class="language-plaintext highlighter-rouge">Template</code> 및 <code class="language-plaintext highlighter-rouge">Interpolation</code> 인스턴스는 객체 ID(<code class="language-plaintext highlighter-rouge">is</code>)로 비교됩니다.</p>

<p><code class="language-plaintext highlighter-rouge">Template</code> 인스턴스는 템플릿 처리 코드에 의해 사용될 의도로, 문자열 또는 다른 타입을 반환할 수 있습니다. 이러한 타입은 필요에 따라 자체 동등성 의미(equality semantics)를 제공할 수 있습니다.</p>

<h3 id="순서-지정-미지원-no-support-for-ordering">순서 지정 미지원 (No Support for Ordering)</h3>

<p><code class="language-plaintext highlighter-rouge">Template</code> 및 <code class="language-plaintext highlighter-rouge">Interpolation</code> 타입은 순서 지정을 지원하지 않습니다. 이는 어휘적 순서 지정을 지원하는 Python의 다른 모든 문자열 리터럴 타입과 다릅니다. 보간에는 임의의 값이 포함될 수 있으므로 자연스러운 순서가 없습니다. 결과적으로 <code class="language-plaintext highlighter-rouge">Template</code> 및 <code class="language-plaintext highlighter-rouge">Interpolation</code> 타입 모두 표준 비교 메서드를 구현하지 않습니다.</p>

<h3 id="디버그-지정자-지원--support-for-the-debug-specifier---">디버그 지정자 지원 (<code class="language-plaintext highlighter-rouge">=</code>) (Support for the debug specifier ( = ))</h3>

<p>디버그 지정자 <code class="language-plaintext highlighter-rouge">=</code>는 템플릿 문자열에서 지원되며, <code class="language-plaintext highlighter-rouge">f-strings</code>에서와 유사하게 동작하지만 구현상의 제약으로 인해 약간의 차이가 있습니다.</p>

<p>특히 <code class="language-plaintext highlighter-rouge">t'{value=}'</code>는 <code class="language-plaintext highlighter-rouge">t'value={value!r}'</code>로 처리됩니다. 첫 번째 정적 문자열은 <code class="language-plaintext highlighter-rouge">""</code>에서 <code class="language-plaintext highlighter-rouge">"value="</code>로 다시 작성되고, 변환은 기본적으로 <code class="language-plaintext highlighter-rouge">r</code>로 설정됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {name=}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">Hello name=</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">conversion</span> <span class="o">==</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span>
</code></pre></div></div>

<ul>
  <li>변환이 명시적으로 제공되면 유지됩니다: <code class="language-plaintext highlighter-rouge">t'{value=!s}'</code>는 <code class="language-plaintext highlighter-rouge">t'value={value!s}'</code>로 처리됩니다.</li>
  <li>변환 없이 형식 문자열이 제공되면, 변환은 <code class="language-plaintext highlighter-rouge">None</code>으로 설정됩니다: <code class="language-plaintext highlighter-rouge">t'{value=:fmt}'</code>는 <code class="language-plaintext highlighter-rouge">t'value={value:fmt}'</code>로 처리됩니다.</li>
  <li>디버그 지정자에서 공백은 유지되므로 <code class="language-plaintext highlighter-rouge">t'{value = }'</code>는 <code class="language-plaintext highlighter-rouge">t'value = {value!r}'</code>로 처리됩니다.</li>
</ul>

<h3 id="raw-template-strings-원시-템플릿-문자열">Raw Template Strings (원시 템플릿 문자열)</h3>

<p><code class="language-plaintext highlighter-rouge">rt</code> (또는 <code class="language-plaintext highlighter-rouge">tr</code>) 접두사를 사용하여 raw 템플릿 문자열이 지원됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">trade</span> <span class="o">=</span> <span class="sh">'</span><span class="s">shrubberies</span><span class="sh">'</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">rt</span><span class="sh">'</span><span class="s">Did you say </span><span class="sh">"</span><span class="s">{trade}</span><span class="sh">"</span><span class="s">?</span><span class="se">\n</span><span class="sh">'</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sa">r</span><span class="sh">'</span><span class="s">Did you say </span><span class="sh">"'</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sa">r</span><span class="sh">'"</span><span class="s">?\n</span><span class="sh">'</span>
</code></pre></div></div>

<p>이 예제에서 <code class="language-plaintext highlighter-rouge">\n</code>은 줄 바꿈 문자가 아닌 두 개의 별도 문자(백슬래시 다음에 ‘n’)로 처리됩니다. 이는 Python의 raw 문자열 동작과 일치합니다.</p>

<p>일반 템플릿 문자열과 마찬가지로 raw 템플릿 문자열 내의 보간은 정상적으로 처리되어 raw 문자열 동작과 동적 콘텐츠의 조합을 허용합니다.</p>

<h3 id="보간-표현식-평가-interpolation-expression-evaluation">보간 표현식 평가 (Interpolation Expression Evaluation)</h3>

<p>보간에 대한 표현식 평가는 PEP 498과 동일합니다.</p>

<p>문자열에서 추출된 표현식은 템플릿 문자열이 나타난 컨텍스트에서 평가됩니다. 즉, 표현식은 지역 변수 및 전역 변수를 포함하여 어휘적 스코프(lexical scope)에 완전히 접근할 수 있습니다. 함수 및 메서드 호출을 포함한 모든 유효한 Python 표현식이 사용될 수 있습니다.</p>

<p>템플릿 문자열은 <code class="language-plaintext highlighter-rouge">f-strings</code>와 마찬가지로 왼쪽에서 오른쪽으로 즉시(eagerly) 평가됩니다. 이는 템플릿 문자열이 처리될 때 보간이 즉시 평가되며, 지연되거나 람다(lambdas)로 래핑되지 않음을 의미합니다.</p>

<h3 id="예외-exceptions">예외 (Exceptions)</h3>

<p><code class="language-plaintext highlighter-rouge">t-string</code> 리터럴에서 발생하는 예외는 <code class="language-plaintext highlighter-rouge">f-string</code> 리터럴에서 발생하는 예외와 동일합니다.</p>

<h3 id="template__str__-구현-없음-no-templatestr-implementation">Template.__str__() 구현 없음 (No Template.<strong>str</strong>() Implementation)</h3>

<p><code class="language-plaintext highlighter-rouge">Template</code> 타입은 특수화된 <code class="language-plaintext highlighter-rouge">__str__()</code> 구현을 제공하지 않습니다.</p>

<p>이는 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스가 템플릿 처리 코드에 의해 사용될 의도로, 문자열 또는 다른 타입을 반환할 수 있기 때문입니다. <code class="language-plaintext highlighter-rouge">Template</code>을 문자열로 변환하는 표준적인 방법은 없습니다.</p>

<p><code class="language-plaintext highlighter-rouge">Template</code> 및 <code class="language-plaintext highlighter-rouge">Interpolation</code> 타입 모두 유용한 <code class="language-plaintext highlighter-rouge">__repr__()</code> 구현을 제공합니다.</p>

<h3 id="stringtemplatelib-모듈-the-stringtemplatelib-module">string.templatelib 모듈 (The string.templatelib Module)</h3>

<p><code class="language-plaintext highlighter-rouge">string</code> 모듈은 패키지로 변환되며, <code class="language-plaintext highlighter-rouge">Template</code> 및 <code class="language-plaintext highlighter-rouge">Interpolation</code> 타입을 포함하는 새로운 <code class="language-plaintext highlighter-rouge">templatelib</code> 서브모듈을 가집니다. 이 PEP의 구현 이후, 이 새로운 모듈은 <code class="language-plaintext highlighter-rouge">convert()</code>와 같은 관련 함수나 향후 잠재적인 템플릿 처리 코드(예: 셸 스크립트 도우미)에 사용될 수 있습니다.</p>

<h2 id="예제-examples">예제 (Examples)</h2>

<p>이 PEP의 모든 예제는 공개 <code class="language-plaintext highlighter-rouge">pep750-examples</code> Git 저장소에 완전히 테스트된 참조 구현이 제공됩니다.</p>

<h3 id="예제-t-strings로-f-strings-구현하기-example-implementing-f-strings-with-t-strings">예제: t-strings로 f-strings 구현하기 (Example: Implementing f-strings with t-strings)</h3>

<p><code class="language-plaintext highlighter-rouge">t-strings</code>를 사용하여 <code class="language-plaintext highlighter-rouge">f-strings</code>를 “구현”하는 것은 쉽습니다. 즉, <code class="language-plaintext highlighter-rouge">f-string</code> 리터럴과 매우 유사하게 <code class="language-plaintext highlighter-rouge">Template</code>을 처리하고 동일한 결과를 반환하는 함수 <code class="language-plaintext highlighter-rouge">f(template: Template) -&gt; str</code>을 작성할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="n">value</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">templated</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {name!r}, value: {value:.2f}</span><span class="sh">"</span>
<span class="n">formatted</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Hello </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s">, value: </span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="nf">f</span><span class="p">(</span><span class="n">templated</span><span class="p">)</span> <span class="o">==</span> <span class="n">formatted</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">f()</code> 함수는 <code class="language-plaintext highlighter-rouge">!r</code>과 같은 변환 지정자와 <code class="language-plaintext highlighter-rouge">:.2f</code>와 같은 형식 지정자(format specifiers)를 모두 지원합니다. 전체 코드는 매우 간단합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">string.templatelib</span> <span class="kn">import</span> <span class="n">Template</span><span class="p">,</span> <span class="n">Interpolation</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Literal</span>

<span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">conversion</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">s</span><span class="sh">"</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">conversion</span> <span class="o">==</span> <span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">ascii</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">conversion</span> <span class="o">==</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">conversion</span> <span class="o">==</span> <span class="sh">"</span><span class="s">s</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">template</span><span class="p">:</span> <span class="n">Template</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">template</span><span class="p">:</span>
        <span class="k">match</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">case</span> <span class="nf">str</span><span class="p">()</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">parts</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">case</span><span class="w"> </span>Interpolation(value, <span class="k">_</span><span class="p">,</span> <span class="n">conversion</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nf">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">conversion</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nf">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">)</span>
                <span class="n">parts</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="예제-구조화된-로깅-example-structured-logging">예제: 구조화된 로깅 (Example: Structured Logging)</h3>

<p>구조화된 로깅을 통해 개발자는 JSON과 같은 기계가 읽을 수 있는 형식으로 데이터를 로깅할 수 있습니다. <code class="language-plaintext highlighter-rouge">t-strings</code>를 사용하면 개발자는 단일 로그 문만으로 사람이 읽을 수 있는 메시지와 함께 구조화된 데이터를 쉽게 로깅할 수 있습니다.</p>

<p>템플릿 문자열로 구조화된 로깅을 구현하는 두 가지 다른 접근 방식을 제시합니다.</p>

<h4 id="접근-방식-1-커스텀-로그-메시지-approach-1-custom-log-messages">접근 방식 1: 커스텀 로그 메시지 (Approach 1: Custom Log Messages)</h4>

<p>Python Logging Cookbook에는 구조화된 로깅을 구현하는 방법에 대한 짧은 섹션이 있습니다.</p>

<p>로깅 Cookbook은 간단한 텍스트 메시지와 별도의 값 딕셔너리로 구성되는 새로운 “메시지” 클래스 <code class="language-plaintext highlighter-rouge">StructuredMessage</code>를 생성할 것을 제안합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span> <span class="o">=</span> <span class="nc">StructuredMessage</span><span class="p">(</span><span class="sh">"</span><span class="s">user action</span><span class="sh">"</span><span class="p">,</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">action</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">traded</span><span class="sh">"</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">amount</span><span class="sh">"</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">item</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">shrubs</span><span class="sh">"</span>
<span class="p">})</span>
<span class="n">logging</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<span class="c1"># 출력:
# user action &gt;&gt;&gt; {"action": "traded", "amount": 42, "item": "shrubs"}
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">StructuredMessage.__str__()</code> 메서드는 사람이 읽을 수 있는 메시지와 값을 모두 형식화하여 최종 문자열로 결합합니다.</p>

<p>템플릿 문자열을 사용하여 <code class="language-plaintext highlighter-rouge">StructuredMessage</code>의 개선된 버전을 구현할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">json</span>
<span class="kn">import</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="n">string.templatelib</span> <span class="kn">import</span> <span class="n">Interpolation</span><span class="p">,</span> <span class="n">Template</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Mapping</span>

<span class="k">class</span> <span class="nc">TemplateMessage</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Template</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">template</span> <span class="o">=</span> <span class="n">template</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">message</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># 이전 예제의 f() 함수를 사용
</span>        <span class="k">return</span> <span class="nf">f</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">template</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">object</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">item</span><span class="p">.</span><span class="n">expression</span><span class="p">:</span> <span class="n">item</span><span class="p">.</span><span class="n">value</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">template</span> <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Interpolation</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">message</span><span class="si">}</span><span class="s"> &gt;&gt;&gt; </span><span class="si">{</span><span class="n">json</span><span class="p">.</span><span class="nf">dumps</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">values</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">TemplateMessage</span> <span class="c1"># 선택 사항, 가독성 향상
</span><span class="n">action</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">item</span> <span class="o">=</span> <span class="sh">"</span><span class="s">traded</span><span class="sh">"</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="sh">"</span><span class="s">shrubs</span><span class="sh">"</span>
<span class="n">logging</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="nf">_</span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">User {action}: {amount:.2f} {item}</span><span class="sh">"</span><span class="p">))</span>
<span class="c1"># 출력:
# User traded: 42.00 shrubs &gt;&gt;&gt; {"action": "traded", "amount": 42, "item": "shrubs"}
</span></code></pre></div></div>

<p>템플릿 문자열은 커스텀 메시지 클래스를 정의하는 더 우아한 방법을 제공합니다. 템플릿 문자열을 사용하면 개발자는 더 이상 형식 문자열과 값 딕셔너리가 동기화되도록 신경 쓸 필요가 없습니다. 단일 템플릿 문자열 리터럴만 있으면 됩니다. <code class="language-plaintext highlighter-rouge">TemplateMessage</code> 구현은 <code class="language-plaintext highlighter-rouge">Interpolation.expression</code> 및 <code class="language-plaintext highlighter-rouge">Interpolation.value</code> 속성에서 구조화된 키와 값을 자동으로 추출할 수 있습니다.</p>

<h4 id="접근-방식-2-커스텀-포맷터-approach-2-custom-formatters">접근 방식 2: 커스텀 포맷터 (Approach 2: Custom Formatters)</h4>

<p>커스텀 메시지는 구조화된 로깅에 대한 합리적인 접근 방식이지만 약간 어색할 수 있습니다. 이를 사용하려면 개발자는 작성하는 모든 로그 메시지를 커스텀 클래스로 래핑해야 합니다. 이는 잊기 쉬울 수 있습니다.</p>

<p>대안적인 접근 방식은 커스텀 <code class="language-plaintext highlighter-rouge">logging.Formatter</code> 클래스를 정의하는 것입니다. 이 접근 방식은 더 유연하며 최종 출력에 대한 더 많은 제어를 허용합니다. 특히, 단일 템플릿 문자열을 가져와 여러 형식(사람이 읽을 수 있는 형식 및 JSON)으로 별도의 로그 스트림으로 출력하는 것이 가능합니다.</p>

<p>사람이 읽을 수 있는 출력을 위한 <code class="language-plaintext highlighter-rouge">MessageFormatter</code>와 JSON 출력을 위한 <code class="language-plaintext highlighter-rouge">ValuesFormatter</code>라는 두 개의 간단한 포맷터를 정의합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">json</span>
<span class="kn">import</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="n">logging</span> <span class="kn">import</span> <span class="n">Formatter</span><span class="p">,</span> <span class="n">LogRecord</span>
<span class="kn">from</span> <span class="n">string.templatelib</span> <span class="kn">import</span> <span class="n">Interpolation</span><span class="p">,</span> <span class="n">Template</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Mapping</span>

<span class="k">class</span> <span class="nc">MessageFormatter</span><span class="p">(</span><span class="n">Formatter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">message</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Template</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># 이전 예제의 f() 함수를 사용
</span>        <span class="k">return</span> <span class="nf">f</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">record</span><span class="p">:</span> <span class="n">LogRecord</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">record</span><span class="p">.</span><span class="n">msg</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Template</span><span class="p">):</span>
            <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="nf">format</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">message</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ValuesFormatter</span><span class="p">(</span><span class="n">Formatter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">template</span><span class="p">:</span> <span class="n">Template</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">item</span><span class="p">.</span><span class="n">expression</span><span class="p">:</span> <span class="n">item</span><span class="p">.</span><span class="n">value</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">template</span> <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Interpolation</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">record</span><span class="p">:</span> <span class="n">LogRecord</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">record</span><span class="p">.</span><span class="n">msg</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">Template</span><span class="p">):</span>
            <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="nf">format</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">json</span><span class="p">.</span><span class="nf">dumps</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">values</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
</code></pre></div></div>

<p>그런 다음 로거를 구성할 때 이 포맷터들을 사용할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">logging</span>
<span class="kn">import</span> <span class="n">sys</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="nf">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="n">message_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="nc">StreamHandler</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">)</span>
<span class="n">message_handler</span><span class="p">.</span><span class="nf">setFormatter</span><span class="p">(</span><span class="nc">MessageFormatter</span><span class="p">())</span>
<span class="n">logger</span><span class="p">.</span><span class="nf">addHandler</span><span class="p">(</span><span class="n">message_handler</span><span class="p">)</span>

<span class="n">values_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="nc">StreamHandler</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
<span class="n">values_handler</span><span class="p">.</span><span class="nf">setFormatter</span><span class="p">(</span><span class="nc">ValuesFormatter</span><span class="p">())</span>
<span class="n">logger</span><span class="p">.</span><span class="nf">addHandler</span><span class="p">(</span><span class="n">values_handler</span><span class="p">)</span>

<span class="n">action</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">item</span> <span class="o">=</span> <span class="sh">"</span><span class="s">traded</span><span class="sh">"</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="sh">"</span><span class="s">shrubs</span><span class="sh">"</span>
<span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">User {action}: {amount:.2f} {item}</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># sys.stdout으로 출력:
# User traded: 42.00 shrubs
# 동시에, sys.stderr으로 출력:
# {"action": "traded", "amount": 42, "item": "shrubs"}
</span></code></pre></div></div>

<p>이 접근 방식은 구조화된 로깅에 대한 커스텀 메시지 접근 방식에 비해 몇 가지 장점이 있습니다.</p>

<ul>
  <li>개발자는 커스텀 클래스로 래핑하지 않고도 <code class="language-plaintext highlighter-rouge">t-string</code>을 직접 로깅할 수 있습니다.</li>
  <li>사람이 읽을 수 있는 출력과 구조화된 출력을 별도의 로그 스트림으로 보낼 수 있습니다. 이는 사람이 읽을 수 있는 데이터와 독립적으로 구조화된 데이터를 처리하는 로그 집계 시스템에 유용합니다.</li>
</ul>

<h3 id="예제-html-템플릿-example-html-templating">예제: HTML 템플릿 (Example: HTML Templating)</h3>

<p>이 PEP에는 여러 짧은 HTML 템플릿 예제가 포함되어 있습니다. “동기 (Motivation)” 섹션(및 이 PEP의 다른 몇 군데)에 언급된 “가상의” <code class="language-plaintext highlighter-rouge">html()</code> 함수가 존재하며 <code class="language-plaintext highlighter-rouge">pep750-examples</code> 저장소에서 사용할 수 있습니다.</p>

<h2 id="하위-호환성-backwards-compatibility">하위 호환성 (Backwards Compatibility)</h2>

<p><code class="language-plaintext highlighter-rouge">f-strings</code>와 마찬가지로 템플릿 문자열의 사용은 이전 버전과의 구문적 하위 호환성을 깨는 요소가 됩니다.</p>

<h2 id="보안-영향-security-implications">보안 영향 (Security Implications)</h2>

<p>보간과 관련하여 템플릿 문자열 작업의 보안 영향은 다음과 같습니다.</p>

<ul>
  <li>스코프(Scope) 조회는 <code class="language-plaintext highlighter-rouge">f-strings</code>와 동일합니다(어휘적 스코프). 이 모델은 실제로 잘 작동하는 것으로 나타났습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Template</code> 인스턴스를 처리하는 코드는 모든 보간이 나타나는 컨텍스트를 존중하는 등 안전한 방식으로 처리되도록 보장할 수 있습니다.</li>
</ul>

<h2 id="교육-방법-how-to-teach-this">교육 방법 (How To Teach This)</h2>

<p>템플릿 문자열에는 여러 대상이 있습니다.</p>

<ul>
  <li>템플릿 문자열 및 처리 함수를 사용하는 개발자</li>
  <li>템플릿 처리 코드의 작성자</li>
  <li>템플릿 문자열로 흥미로운 메커니즘을 구축하는 프레임워크 작성자</li>
</ul>

<p>개발자를 교육하는 것은 간단할 것으로 예상됩니다. 언뜻 보기에 템플릿 문자열은 <code class="language-plaintext highlighter-rouge">f-strings</code>와 똑같이 생겼습니다. 문법은 친숙하고 스코핑 규칙은 동일하게 유지됩니다.</p>

<p>개발자가 가장 먼저 배워야 할 것은 템플릿 문자열 리터럴이 문자열로 평가되지 않고, 새로운 타입인 <code class="language-plaintext highlighter-rouge">Template</code>으로 평가된다는 것입니다. 이는 템플릿 처리 코드에 의해 사용될 의도로 만들어진 간단한 타입입니다. 개발자가 처리 함수를 호출해야만 원하는 결과(일반적으로 문자열)를 얻을 수 있으며, 물론 처리 코드는 임의의 타입을 반환할 수 있습니다.</p>

<p>개발자는 또한 템플릿 문자열이 <code class="language-plaintext highlighter-rouge">f-strings</code> 및 <code class="language-plaintext highlighter-rouge">str.format()</code>과 같은 다른 문자열 형식화 방법과 어떻게 관련되는지 이해해야 할 것입니다. 각 방법을 언제 사용해야 할지 결정해야 합니다. 간단한 문자열만 필요하고 보안 영향이 없다면 <code class="language-plaintext highlighter-rouge">f-strings</code>가 최선의 선택일 것입니다. 형식 문자열이 사용되는 대부분의 경우, 템플릿 문자열 생성을 래핑하는 함수로 대체할 수 있습니다. 형식 문자열이 사용자 입력, 파일 시스템 또는 데이터베이스에서 얻어지는 경우, 원한다면 이를 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스로 변환하는 코드를 작성할 수 있습니다.</p>

<p>개발자는 <code class="language-plaintext highlighter-rouge">t-strings</code>가 거의 항상 처리 함수와 함께 사용된다는 것을 배울 것이기 때문에 <code class="language-plaintext highlighter-rouge">Template</code> 타입의 세부 사항을 반드시 이해할 필요는 없습니다. 디스크립터(descriptors) 및 데코레이터(decorators)와 마찬가지로, <code class="language-plaintext highlighter-rouge">t-string</code> 처리 함수를 작성하는 개발자보다 <code class="language-plaintext highlighter-rouge">t-strings</code>를 사용하는 개발자가 훨씬 더 많을 것으로 예상됩니다.</p>

<p>시간이 지남에 따라 소수의 더 고급 개발자들은 자체 템플릿 처리 코드를 작성하기를 원할 것입니다. 처리 코드를 작성하는 것은 종종 형식 문법(formal grammars)의 관점에서 생각해야 합니다. 개발자는 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스의 <code class="language-plaintext highlighter-rouge">strings</code> 및 <code class="language-plaintext highlighter-rouge">interpolation</code> 속성과 함께 작업하는 방법과 컨텍스트에 민감한 방식으로 보간을 처리하는 방법을 배워야 합니다. 더 정교한 문법은 추상 구문 트리(AST)와 같은 중간 표현(intermediate representations)으로 파싱해야 할 가능성이 높습니다. 훌륭한 템플릿 처리 코드는 적절할 때 형식 지정자 및 변환을 처리할 것입니다. 프로덕션 수준의 템플릿 처리 코드(예: HTML 템플릿을 지원하기 위한)를 작성하는 것은 큰 작업이 될 수 있습니다.</p>

<p>템플릿 문자열은 프레임워크 작성자에게 도구 상자에 강력한 새 도구를 제공할 것으로 예상됩니다. 템플릿 문자열의 기능이 템플릿 엔진과 같은 기존 도구와 겹치지만, <code class="language-plaintext highlighter-rouge">t-strings</code>는 해당 로직을 언어 자체로 옮깁니다. Python의 모든 강력함과 일반성을 문자열 처리 작업에 적용하는 것은 프레임워크 작성자에게 새로운 가능성을 열어줍니다.</p>

<h2 id="또-다른-템플릿-접근-방식이-필요한-이유-why-another-templating-approach">또 다른 템플릿 접근 방식이 필요한 이유 (Why another templating approach?)</h2>

<p>Python 세계에는 Jinja와 같이 널리 채택된 성숙한 템플릿 언어가 이미 존재합니다. 새로운 템플릿 시스템 생성을 위한 지원을 구축하는 이유는 무엇일까요?</p>

<p>Jinja와 같은 프로젝트는 템플릿이 개발자에 의한 소프트웨어의 일부라기보다는 디자이너 또는 심지어 사용자(예: CMS)가 생성한 콘텐츠의 일부인 경우 여전히 필요합니다.</p>

<p>프런트엔드 개발의 추세는 템플릿을 소프트웨어의 일부로 간주하고 개발자가 작성합니다. 그들은 최신 언어 기능과 좋은 툴링 경험을 원합니다. PEP 750은 비정적 부분이 Python인 DSL(Domain-Specific Languages)을 구상합니다. 즉, 동일한 스코프 규칙, 타이핑, 표현식 구문 등을 가집니다.</p>

<h2 id="템플릿-처리에서-흔히-볼-수-있는-패턴-common-patterns-seen-in-processing-templates">템플릿 처리에서 흔히 볼 수 있는 패턴 (Common Patterns Seen in Processing Templates)</h2>

<h3 id="구조적-패턴-매칭-structural-pattern-matching">구조적 패턴 매칭 (Structural Pattern Matching)</h3>

<p>구조적 패턴 매칭을 사용하여 <code class="language-plaintext highlighter-rouge">Template</code>을 반복하는 것은 많은 템플릿 함수 구현에서 예상되는 모범 사례입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">string.templatelib</span> <span class="kn">import</span> <span class="n">Template</span><span class="p">,</span> <span class="n">Interpolation</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">template</span><span class="p">:</span> <span class="n">Template</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">template</span><span class="p">:</span>
        <span class="k">match</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">case</span> <span class="nf">str</span><span class="p">()</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
                <span class="p">...</span> <span class="c1"># 각 문자열 부분 처리
</span>            <span class="k">case</span> <span class="nc">Interpolation</span><span class="p">()</span> <span class="k">as</span> <span class="n">interpolation</span><span class="p">:</span>
                <span class="p">...</span> <span class="c1"># 각 보간 처리
</span></code></pre></div></div>

<p>처리 코드는 <code class="language-plaintext highlighter-rouge">Interpolation</code> 타입의 속성에 대해 하위 매칭(sub-match)하는 것이 일반적일 수도 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
    <span class="k">case</span> <span class="nc">Interpolation</span><span class="p">(</span><span class="nf">int</span><span class="p">()):</span>
        <span class="p">...</span> <span class="c1"># 정수 값을 가진 보간 처리
</span>    <span class="k">case</span> <span class="nc">Interpolation</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="nf">str</span><span class="p">()</span> <span class="k">as</span> <span class="n">s</span><span class="p">):</span>
        <span class="p">...</span> <span class="c1"># 문자열 값을 가진 보간 처리
</span>    <span class="c1"># 등등
</span></code></pre></div></div>

<h3 id="메모이제이션-memoizing">메모이제이션 (Memoizing)</h3>

<p>템플릿 함수는 템플릿의 정적 및 동적 부분을 효율적으로 처리할 수 있습니다. <code class="language-plaintext highlighter-rouge">Template</code> 객체의 구조는 효과적인 메모이제이션(memoization)을 허용합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">strings</span> <span class="o">=</span> <span class="n">template</span><span class="p">.</span><span class="n">strings</span> <span class="c1"># 정적 문자열 부분
</span><span class="n">values</span> <span class="o">=</span> <span class="n">template</span><span class="p">.</span><span class="n">values</span> <span class="c1"># 동적 보간된 값
</span></code></pre></div></div>

<p>이러한 분리를 통해 처리된 정적 부분은 캐시하고 동적 부분은 필요에 따라 삽입할 수 있습니다. 템플릿 처리 코드의 작성자는 정적 문자열을 캐시 키로 사용하여 유사한 템플릿이 반복적으로 사용될 때 상당한 성능 향상을 이끌어낼 수 있습니다.</p>

<h3 id="중간-표현으로-파싱-parsing-to-intermediate-representations">중간 표현으로 파싱 (Parsing to Intermediate Representations)</h3>

<p>템플릿을 처리하는 코드는 템플릿 문자열을 AST(Abstract Syntax Tree)와 같은 중간 표현으로 파싱할 수 있습니다. 많은 템플릿 처리 라이브러리가 이 접근 방식을 사용할 것으로 예상됩니다.</p>

<p>예를 들어, 우리의 이론적인 <code class="language-plaintext highlighter-rouge">html()</code> 함수(<code class="language-plaintext highlighter-rouge">Motivation</code> 섹션 참조)는 <code class="language-plaintext highlighter-rouge">str</code>을 반환하는 대신 동일한 패키지에 정의된 HTML <code class="language-plaintext highlighter-rouge">Element</code>를 반환할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Element</span><span class="p">:</span>
    <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">attributes</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bool</span><span class="p">]</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="n">Element</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="bp">...</span>

<span class="k">def</span> <span class="nf">html</span><span class="p">(</span><span class="n">template</span><span class="p">:</span> <span class="n">Template</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Element</span><span class="p">:</span> <span class="bp">...</span>
</code></pre></div></div>

<p>그러면 <code class="language-plaintext highlighter-rouge">str(element)</code>를 호출하면 HTML이 렌더링되지만, 그동안 <code class="language-plaintext highlighter-rouge">Element</code>는 다양한 방식으로 조작될 수 있습니다.</p>

<h3 id="컨텍스트에-민감한-보간-처리-context-sensitive-processing-of-interpolations">컨텍스트에 민감한 보간 처리 (Context-sensitive Processing of Interpolations)</h3>

<p>가상의 <code class="language-plaintext highlighter-rouge">html()</code> 함수를 계속해서, 이를 컨텍스트에 민감하게 만들 수 있습니다. 보간은 템플릿에 나타나는 위치에 따라 다르게 처리될 수 있습니다.</p>

<p>예를 들어, <code class="language-plaintext highlighter-rouge">html()</code> 함수는 여러 종류의 보간을 지원할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">attributes</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">id</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">main</span><span class="sh">"</span><span class="p">}</span>
<span class="n">attribute_value</span> <span class="o">=</span> <span class="sh">"</span><span class="s">shrubbery</span><span class="sh">"</span>
<span class="n">content</span> <span class="o">=</span> <span class="sh">"</span><span class="s">hello</span><span class="sh">"</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">&lt;div {attributes} data-value={attribute_value}&gt;{content}&lt;/div&gt;</span><span class="sh">"</span>
<span class="n">element</span> <span class="o">=</span> <span class="nf">html</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
<span class="k">assert</span> <span class="nf">str</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">==</span> <span class="sh">'</span><span class="s">&lt;div id=</span><span class="sh">"</span><span class="s">main</span><span class="sh">"</span><span class="s"> data-value=</span><span class="sh">"</span><span class="s">shrubbery</span><span class="sh">"</span><span class="s">&gt;hello&lt;/div&gt;</span><span class="sh">'</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">{attributes}</code> 보간은 HTML 태그 컨텍스트에서 발생하고 해당하는 속성 이름이 없기 때문에 속성 딕셔너리로 처리됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">{attribute_value}</code> 보간은 단순한 문자열 값으로 처리되고 최종 문자열에 포함되기 전에 인용됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">{content}</code> 보간은 잠재적으로 안전하지 않은 콘텐츠로 처리되고 최종 문자열에 포함되기 전에 이스케이프됩니다.</li>
</ul>

<h3 id="중첩된-템플릿-문자열-nested-template-strings">중첩된 템플릿 문자열 (Nested Template Strings)</h3>

<p><code class="language-plaintext highlighter-rouge">html()</code> 함수로 한 단계 더 나아가 중첩된 템플릿 문자열을 지원할 수 있습니다. 이를 통해 더 간단한 템플릿으로 더 복잡한 HTML 구조를 구축할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="n">content</span> <span class="o">=</span> <span class="nf">html</span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">&lt;p&gt;Hello {name}&lt;/p&gt;</span><span class="sh">"</span><span class="p">)</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">&lt;div&gt;{content}&lt;/div&gt;</span><span class="sh">"</span>
<span class="n">element</span> <span class="o">=</span> <span class="nf">html</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
<span class="k">assert</span> <span class="nf">str</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">==</span> <span class="sh">'</span><span class="s">&lt;div&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;</span><span class="sh">'</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">{content}</code> 보간은 <code class="language-plaintext highlighter-rouge">Element</code> 인스턴스이므로 최종 문자열에 포함되기 전에 이스케이프될 필요가 없습니다.</p>

<p><code class="language-plaintext highlighter-rouge">html()</code> 함수에 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스가 전달되면 중첩된 템플릿에 대해 재귀적으로 자신을 호출하여 자동으로 <code class="language-plaintext highlighter-rouge">Element</code>로 변환할 수 있다는 멋진 단순화를 상상할 수 있습니다.</p>

<p>템플릿의 중첩 및 구성은 템플릿 처리 코드에서 일반적인 패턴이 될 것이며, 적절한 경우 단순한 문자열 연결보다 선호될 것으로 예상됩니다.</p>

<h3 id="지연-평가-접근-방식-approaches-to-lazy-evaluation">지연 평가 접근 방식 (Approaches to Lazy Evaluation)</h3>

<p><code class="language-plaintext highlighter-rouge">f-strings</code>와 마찬가지로 <code class="language-plaintext highlighter-rouge">t-string</code> 리터럴의 보간은 즉시 평가됩니다. 그러나 지연 평가(lazy evaluation)가 바람직할 수 있는 경우가 있습니다.</p>

<p>단일 보간이 평가하는 데 비용이 많이 드는 경우, 템플릿 문자열 리터럴에서 람다로 명시적으로 래핑할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {(lambda: name)}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="nf">callable</span><span class="p">(</span><span class="n">template</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">template</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">value</span><span class="p">()</span> <span class="o">==</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
</code></pre></div></div>

<p>물론, 이는 템플릿 처리 코드가 호출 가능한 보간 값을 예상하고 처리한다고 가정합니다. (이터레이터(iterators), 어웨이터블(awaitables) 등도 지원할 수 있다고 상상할 수 있습니다.) 이는 PEP의 요구 사항은 아니지만, 템플릿 처리 코드에서 일반적인 패턴입니다.</p>

<p>일반적으로 커뮤니티가 템플릿 문자열에서 보간의 지연 평가에 대한 모범 사례를 개발하고, 합리적인 경우 공통 라이브러리가 템플릿 처리 코드에서 호출 가능한 또는 어웨이터블(awaitable) 값을 지원하기를 바랍니다.</p>

<h3 id="비동기-평가-접근-방식-approaches-to-asynchronous-evaluation">비동기 평가 접근 방식 (Approaches to Asynchronous Evaluation)</h3>

<p>지연 평가와 밀접하게 관련된 것은 비동기 평가(asynchronous evaluation)입니다.</p>

<p><code class="language-plaintext highlighter-rouge">f-strings</code>와 마찬가지로 <code class="language-plaintext highlighter-rouge">await</code> 키워드는 보간에서 허용됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_name</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="sh">"</span><span class="s">Sleepy</span><span class="sh">"</span>
    <span class="c1"># f() 함수는 이전 f-string 예제에서 가져옴
</span>    <span class="k">assert</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="sh">"</span><span class="s">Hello {await get_name()}</span><span class="sh">"</span><span class="p">)</span> <span class="o">==</span> <span class="sh">"</span><span class="s">Hello Sleepy</span><span class="sh">"</span>
</code></pre></div></div>

<p>더 정교한 템플릿 처리 코드는 이를 활용하여 보간에서 비동기 작업을 수행할 수 있습니다. 예를 들어, “스마트한” 처리 함수는 보간이 어웨이터블임을 예상하고 템플릿 문자열을 처리하기 전에 <code class="language-plaintext highlighter-rouge">await</code>할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">async_f</span><span class="p">(</span><span class="n">template</span><span class="p">:</span> <span class="n">Template</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="c1"># ... async 처리 로직
</span>    <span class="k">pass</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_name</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="sh">"</span><span class="s">Sleepy</span><span class="sh">"</span>
    <span class="n">template</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {get_name}</span><span class="sh">"</span>
    <span class="k">assert</span> <span class="k">await</span> <span class="nf">async_f</span><span class="p">(</span><span class="n">template</span><span class="p">)</span> <span class="o">==</span> <span class="sh">"</span><span class="s">Hello Sleepy</span><span class="sh">"</span>
</code></pre></div></div>

<p>이는 <code class="language-plaintext highlighter-rouge">async_f()</code>의 템플릿 처리 코드가 비동기적이고 보간 값(<code class="language-plaintext highlighter-rouge">get_name</code> 코루틴)을 <code class="language-plaintext highlighter-rouge">await</code>할 수 있다고 가정합니다.</p>

<h3 id="템플릿-재사용-접근-방식-approaches-to-template-reuse">템플릿 재사용 접근 방식 (Approaches to Template Reuse)</h3>

<p>개발자가 다른 값으로 템플릿 문자열을 여러 번 재사용하려면 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스를 반환하는 함수를 작성할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reusable</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">question</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Template</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {name}, {question}?</span><span class="sh">"</span>

<span class="n">template1</span> <span class="o">=</span> <span class="nf">reusable</span><span class="p">(</span><span class="sh">"</span><span class="s">friend</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">how are you</span><span class="sh">"</span><span class="p">)</span>
<span class="n">template2</span> <span class="o">=</span> <span class="nf">reusable</span><span class="p">(</span><span class="sh">"</span><span class="s">King Arthur</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">what is your quest</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>물론 이는 <code class="language-plaintext highlighter-rouge">f-strings</code>가 재사용될 수 있는 방식과 다르지 않습니다.</p>

<h3 id="형식-문자열과의-관계-relation-to-format-strings">형식 문자열과의 관계 (Relation to Format Strings)</h3>

<p>오래된 <code class="language-plaintext highlighter-rouge">str.format()</code> 메서드는 나중에 값을 형식화하는 데 사용할 수 있는 형식 문자열(format strings)을 허용합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alas_fmt</span> <span class="o">=</span> <span class="sh">"</span><span class="s">We</span><span class="sh">'</span><span class="s">re all out of {cheese}.</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">alas_fmt</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">cheese</span><span class="o">=</span><span class="sh">"</span><span class="s">Red Leicester</span><span class="sh">"</span><span class="p">)</span> <span class="o">==</span> <span class="sh">"</span><span class="s">We</span><span class="sh">'</span><span class="s">re all out of Red Leicester.</span><span class="sh">"</span>
</code></pre></div></div>

<p>형식 문자열을 일종의 함수 정의로 생각할 수 있습니다. <code class="language-plaintext highlighter-rouge">str.format()</code> 호출은 일종의 함수 호출로 볼 수 있습니다. <code class="language-plaintext highlighter-rouge">t-string</code>의 해당 기능은 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스를 반환하는 표준 Python 함수를 정의하는 것입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">make_template</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">cheese</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Template</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">t</span><span class="sh">"</span><span class="s">We</span><span class="sh">'</span><span class="s">re all out of {cheese}.</span><span class="sh">"</span>

<span class="n">template</span> <span class="o">=</span> <span class="nf">make_template</span><span class="p">(</span><span class="n">cheese</span><span class="o">=</span><span class="sh">"</span><span class="s">Red Leicester</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># 위 f-string 예제의 f() 함수를 사용
</span><span class="k">assert</span> <span class="nf">f</span><span class="p">(</span><span class="n">template</span><span class="p">)</span> <span class="o">==</span> <span class="sh">"</span><span class="s">We</span><span class="sh">'</span><span class="s">re all out of Red Leicester.</span><span class="sh">"</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">make_template()</code> 함수 자체는 형식 문자열과 유사하다고 생각할 수 있습니다. <code class="language-plaintext highlighter-rouge">make_template()</code> 호출은 <code class="language-plaintext highlighter-rouge">str.format()</code> 호출과 유사합니다.</p>

<p>물론, 파일 시스템이나 데이터베이스와 같은 외부 소스에서 형식 문자열을 로드하는 것이 일반적입니다. 다행히 <code class="language-plaintext highlighter-rouge">Template</code> 및 <code class="language-plaintext highlighter-rouge">Interpolation</code>은 단순한 Python 타입이므로, 이전 스타일의 형식 문자열을 가져와 동등한 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스를 반환하는 함수를 작성할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">from_format</span><span class="p">(</span><span class="n">fmt</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Template</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">`fmt`를 파싱하고 `Template` 인스턴스를 반환합니다.</span><span class="sh">"""</span>
    <span class="bp">...</span>

<span class="c1"># 파일, 데이터베이스 등에서 로드
</span><span class="n">fmt</span> <span class="o">=</span> <span class="sh">"</span><span class="s">We</span><span class="sh">'</span><span class="s">re all out of {cheese}.</span><span class="sh">"</span>
<span class="n">template</span> <span class="o">=</span> <span class="nf">from_format</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">cheese</span><span class="o">=</span><span class="sh">"</span><span class="s">Red Leicester</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># 위 f-string 예제의 f() 함수를 사용
</span><span class="k">assert</span> <span class="nf">f</span><span class="p">(</span><span class="n">template</span><span class="p">)</span> <span class="o">==</span> <span class="sh">"</span><span class="s">We</span><span class="sh">'</span><span class="s">re all out of Red Leicester.</span><span class="sh">"</span>
</code></pre></div></div>

<p>이는 개발자가 이전에 형식 문자열을 사용했을 곳에 템플릿 문자열을 사용할 수 있도록 하는 강력한 패턴입니다. <code class="language-plaintext highlighter-rouge">from_format()</code>의 전체 구현은 예제 저장소에서 사용할 수 있으며, 형식 문자열의 전체 문법을 지원합니다.</p>

<h2 id="참조-구현-reference-implementation">참조 구현 (Reference Implementation)</h2>

<p>PEP 750의 CPython 구현이 제공됩니다.</p>

<p>또한 참조 구현을 기반으로 구축된 예제 및 테스트의 공개 저장소가 있습니다. 템플릿 문자열을 가지고 놀고 싶다면 이 저장소가 시작하기에 좋은 곳입니다.</p>

<h2 id="거부된-아이디어-rejected-ideas">거부된 아이디어 (Rejected Ideas)</h2>

<p>이 PEP는 여러 중요한 개정판을 거쳤습니다. 또한 PEP 501의 개정판과 Discourse 논의에서 상당히 많은 흥미로운 아이디어들이 고려되었습니다.</p>

<p>고려되었지만 거부된 가장 중요한 아이디어들을 문서화하려고 합니다.</p>

<h3 id="임의의-문자열-리터럴-접두사-arbitrary-string-literal-prefixes">임의의 문자열 리터럴 접두사 (Arbitrary String Literal Prefixes)</h3>

<p>JavaScript 태그된 템플릿 리터럴(tagged template literals)에서 영감을 받아, 이 PEP의 이전 버전은 리터럴 문자열 앞에 임의의 “태그” 접두사를 허용했습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_tag</span><span class="sh">'</span><span class="s">Hello {name}</span><span class="sh">'</span>
</code></pre></div></div>

<p>접두사는 “태그 함수(tag function)”라고 불리는 특별한 호출 가능한(callable) 객체였습니다. 태그 함수는 인자 목록으로 템플릿 문자열의 부분들을 받았습니다. 그런 다음 문자열을 처리하고 임의의 값을 반환할 수 있었습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_tag</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Interpolation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span> <span class="bp">...</span>
</code></pre></div></div>

<p>이 접근 방식은 여러 가지 이유로 거부되었습니다.</p>

<ul>
  <li>완전한 일반성을 구축하기에는 너무 복잡하다고 판단되었습니다. JavaScript는 템플릿 문자열 앞에 임의의 표현식을 허용하며, 이는 Python에서 구현하기에 상당한 도전입니다.</li>
  <li>새로운 문자열 접두사의 향후 도입을 배제했습니다.</li>
  <li>네임스페이스를 불필요하게 오염시키는 것으로 보였습니다.</li>
</ul>

<p>단일 <code class="language-plaintext highlighter-rouge">t</code> 접두사를 사용하는 것이 더 간단하고 Python스러운 접근 방식이며, <code class="language-plaintext highlighter-rouge">f-strings</code>의 일반화로서 템플릿 문자열의 역할과 더 일치한다고 판단되었습니다.</p>

<h3 id="보간의-지연-평가-delayed-evaluation-of-interpolations">보간의 지연 평가 (Delayed Evaluation of Interpolations)</h3>

<p>이 PEP의 초기 버전은 보간이 지연 평가되어야 한다고 제안했습니다. 모든 보간은 암시적 람다로 “래핑”되었습니다. 즉시 평가되는 <code class="language-plaintext highlighter-rouge">value</code> 속성 대신, 보간에는 보간 값을 해결하는 <code class="language-plaintext highlighter-rouge">getvalue()</code> 메서드가 있었습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Interpolation</span><span class="p">:</span>
    <span class="bp">...</span>
    <span class="n">_value</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">object</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">getvalue</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_value</span><span class="p">()</span>
</code></pre></div></div>

<p>이는 여러 가지 이유로 거부되었습니다.</p>

<ul>
  <li>템플릿 문자열의 압도적인 대다수 사용 사례는 자연스럽게 즉시 평가를 요구합니다.</li>
  <li>지연 평가는 <code class="language-plaintext highlighter-rouge">f-strings</code>의 동작과 상당한 차이가 있을 것입니다.</li>
  <li>암시적 람다 래핑은 타입 힌트(type hints) 및 정적 분석(static analysis)에 어려움을 초래합니다.</li>
</ul>

<p>가장 중요하게도, 지연 평가가 바람직한 많은 경우에 암시적 람다 래핑에 대한 실현 가능한(완벽하지는 않지만) 대안이 있습니다. 자세한 내용은 위의 “Approaches to Lazy Evaluation” 섹션을 참조하십시오.</p>

<p>이 PEP에서는 지연 평가가 거부되었지만, 커뮤니티가 이 아이디어를 계속 탐구하기를 바랍니다.</p>

<h3 id="template-및-interpolation을-프로토콜로-만들기-making-template-and-interpolation-into-protocols">Template 및 Interpolation을 프로토콜로 만들기 (Making Template and Interpolation Into Protocols)</h3>

<p>이 PEP의 초기 버전은 <code class="language-plaintext highlighter-rouge">Template</code> 및 <code class="language-plaintext highlighter-rouge">Interpolation</code> 타입을 클래스 대신 런타임 검사 가능 프로토콜(runtime checkable protocols)로 제안했습니다.</p>

<p>결론적으로, 클래스를 사용하는 것이 더 간단하다고 판단되었습니다.</p>

<h3 id="template-및-interpolation에-대한-__eq__-및-__hash__-오버라이드-overridden-eq-and-hash-for-template-and-interpolation">Template 및 Interpolation에 대한 __eq__ 및 __hash__ 오버라이드 (Overridden <strong>eq</strong> and <strong>hash</strong> for Template and Interpolation)</h3>

<p>이 PEP의 이전 버전은 <code class="language-plaintext highlighter-rouge">Template</code> 및 <code class="language-plaintext highlighter-rouge">Interpolation</code> 타입이 자체 <code class="language-plaintext highlighter-rouge">__eq__</code> 및 <code class="language-plaintext highlighter-rouge">__hash__</code> 구현을 가져야 한다고 제안했습니다.</p>

<ul>
  <li>템플릿은 <code class="language-plaintext highlighter-rouge">strings</code> 및 <code class="language-plaintext highlighter-rouge">interpolations</code>가 같으면 같다고 간주되었습니다.</li>
  <li>보간은 <code class="language-plaintext highlighter-rouge">value</code>, <code class="language-plaintext highlighter-rouge">expression</code>, <code class="language-plaintext highlighter-rouge">conversion</code>, <code class="language-plaintext highlighter-rouge">format_spec</code>이 같으면 같다고 간주되었습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Interpolation</code> 해싱은 튜플 해싱과 유사했습니다. 즉, <code class="language-plaintext highlighter-rouge">Interpolation</code>은 <code class="language-plaintext highlighter-rouge">value</code>가 해시 가능할 때만 해시 가능했습니다.</li>
</ul>

<p>이것은 <code class="language-plaintext highlighter-rouge">Template.__hash__</code>가 템플릿 처리 코드에서 캐시 키로 유용하지 않기 때문에 거부되었습니다. 이는 개발자에게 혼란을 줄 수 있다는 우려가 있었습니다.</p>

<p>이러한 <code class="language-plaintext highlighter-rouge">__eq__</code> 및 <code class="language-plaintext highlighter-rouge">__hash__</code> 구현을 삭제함으로써 다음과 같은 assert를 작성할 수 있는 능력을 잃게 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">World</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello </span><span class="sh">"</span> <span class="o">+</span> <span class="n">t</span><span class="sh">"</span><span class="s">{name}</span><span class="sh">"</span> <span class="o">==</span> <span class="n">t</span><span class="sh">"</span><span class="s">Hello {name}</span><span class="sh">"</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Template</code> 인스턴스가 추가 코드에 의해 빠르게 처리될 의도이므로, 이러한 assert의 유용성은 제한적이라고 판단했습니다.</p>

<h3 id="추가-decoded-타입-an-additional-decoded-type">추가 Decoded 타입 (An Additional Decoded Type)</h3>

<p>이 PEP의 초기 버전은 템플릿 문자열의 “정적 문자열” 부분을 나타내기 위한 <code class="language-plaintext highlighter-rouge">Decoded</code>라는 추가 타입을 제안했습니다. 이 타입은 <code class="language-plaintext highlighter-rouge">str</code>에서 파생되었으며, 문자열의 원래 텍스트를 제공하는 단일 <code class="language-plaintext highlighter-rouge">raw</code> 속성을 가졌습니다. 우리는 일반 <code class="language-plaintext highlighter-rouge">str</code>을 사용하고 <code class="language-plaintext highlighter-rouge">r</code> 및 <code class="language-plaintext highlighter-rouge">t</code> 접두사의 조합을 허용하는 더 간단한 접근 방식을 선호하여 이를 거부했습니다.</p>

<h3 id="template-및-interpolation의-최종-위치-the-final-home-for-template-and-interpolation">Template 및 Interpolation의 최종 위치 (The Final Home for Template and Interpolation)</h3>

<p>이 PEP의 이전 버전은 <code class="language-plaintext highlighter-rouge">Template</code> 및 <code class="language-plaintext highlighter-rouge">Interpolation</code> 타입을 <code class="language-plaintext highlighter-rouge">types</code>, <code class="language-plaintext highlighter-rouge">collections</code>, <code class="language-plaintext highlighter-rouge">collections.abc</code>, 심지어 새로운 최상위 모듈인 <code class="language-plaintext highlighter-rouge">templatelib</code>에 배치할 것을 제안했습니다. 최종 결정은 <code class="language-plaintext highlighter-rouge">string.templatelib</code>에 배치하는 것이었습니다.</p>

<h3 id="원본-템플릿-리터럴의-완전한-재구성-활성화-enable-full-reconstruction-of-original-template-literal">원본 템플릿 리터럴의 완전한 재구성 활성화 (Enable Full Reconstruction of Original Template Literal)</h3>

<p>이 PEP의 이전 버전은 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스에서 원본 템플릿 문자열의 텍스트를 완전히 재구성할 수 있도록 시도했습니다. 이는 지나치게 복잡하다고 판단되어 거부되었습니다. 템플릿 리터럴 소스와 기본 AST 간의 매핑은 일대일이 아니며, 원본 소스 텍스트로 라운드 트립(round-tripping)하는 데 몇 가지 제한 사항이 있습니다.</p>

<p>첫째, <code class="language-plaintext highlighter-rouge">Interpolation.format_spec</code>은 제공되지 않으면 <code class="language-plaintext highlighter-rouge">""</code>로 기본 설정됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">template1</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">{value}</span><span class="sh">"</span>
<span class="n">template2</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">{value:}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template1</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">format_spec</span> <span class="o">==</span> <span class="sh">""</span>
<span class="k">assert</span> <span class="n">template2</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">format_spec</span> <span class="o">==</span> <span class="sh">""</span>
</code></pre></div></div>

<p>다음으로, 디버그 지정자 <code class="language-plaintext highlighter-rouge">=</code>는 특수한 경우로 처리되며 AST가 생성되기 전에 처리됩니다. 따라서 <code class="language-plaintext highlighter-rouge">t"{value=}"</code>와 <code class="language-plaintext highlighter-rouge">t"value={value!r}"</code>를 구별하는 것은 불가능합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">template1</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">{value=}</span><span class="sh">"</span>
<span class="n">template2</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">value={value!r}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template1</span><span class="p">.</span><span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value=</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template1</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">expression</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template1</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">conversion</span> <span class="o">==</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template2</span><span class="p">.</span><span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value=</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template2</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">expression</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template2</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">conversion</span> <span class="o">==</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span>
</code></pre></div></div>

<p>마지막으로, <code class="language-plaintext highlighter-rouge">f-strings</code>의 형식 지정자는 임의의 중첩을 허용합니다. 이 PEP 및 참조 구현에서는 지정자가 즉시 평가되어 <code class="language-plaintext highlighter-rouge">Interpolation</code>의 <code class="language-plaintext highlighter-rouge">format_spec</code>을 설정하므로 원래 표현식을 잃게 됩니다. 예를 들어:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">precision</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">template1</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">{value:.2f}</span><span class="sh">"</span>
<span class="n">template2</span> <span class="o">=</span> <span class="n">t</span><span class="sh">"</span><span class="s">{value:.{precision}f}</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template1</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">format_spec</span> <span class="o">==</span> <span class="sh">"</span><span class="s">.2f</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">template2</span><span class="p">.</span><span class="n">interpolations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">format_spec</span> <span class="o">==</span> <span class="sh">"</span><span class="s">.2f</span><span class="sh">"</span>
</code></pre></div></div>

<p>이러한 제한 사항이 실제로 중요한 문제가 될 것이라고는 예상하지 않습니다. 원본 템플릿 문자열 리터럴을 얻어야 하는 개발자는 항상 <code class="language-plaintext highlighter-rouge">inspect.getsource()</code> 또는 유사한 도구를 사용할 수 있습니다.</p>

<h3 id="템플릿-연결-금지-disallowing-template-concatenation">템플릿 연결 금지 (Disallowing Template Concatenation)</h3>

<p>이 PEP의 이전 버전은 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스가 연결을 지원해서는 안 된다고 제안했습니다. 여러 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스의 연결을 허용하는 방향으로 거부되었습니다.</p>

<p>하나 또는 모든 형태의 연결을 거부하는 데는 합리적인 주장이 있습니다. 즉, 이는 잠재적인 버그 클래스를 차단하며, 특히 템플릿 문자열이 연결이 항상 동일한 의미(또는 어떤 의미도)를 갖지 않는 복잡한 문법을 포함할 것이라는 관점을 취할 때 그렇습니다.</p>

<p>더욱이, 이 PEP의 초기 버전은 JavaScript의 태그된 템플릿 리터럴에 더 가까운 구문을 제안했으며, 여기서 임의의 호출 가능한(callable) 객체를 문자열 리터럴의 접두사로 사용할 수 있었습니다. 호출 가능한 객체가 연결을 지원하는 타입을 반환한다는 보장이 없었습니다.</p>

<p>결론적으로, 새로운 문자열 타입이 연결을 지원하지 않는다는 것이 개발자들에게 줄 놀라움이 지원함으로써 발생하는 이론적인 해로움보다 클 것이라고 판단했습니다.</p>

<p>이 PEP는 두 <code class="language-plaintext highlighter-rouge">Template</code>의 연결을 지원하지만, <code class="language-plaintext highlighter-rouge">Template</code>과 <code class="language-plaintext highlighter-rouge">str</code>의 연결은 지원하지 않습니다. 이는 <code class="language-plaintext highlighter-rouge">str</code>이 정적 문자열로 처리되어야 하는지 또는 보간으로 처리되어야 하는지 모호하기 때문입니다. 개발자는 위에서 설명한 대로 <code class="language-plaintext highlighter-rouge">str</code>을 다른 <code class="language-plaintext highlighter-rouge">Template</code>과 연결하기 전에 <code class="language-plaintext highlighter-rouge">Template</code> 인스턴스로 래핑해야 합니다.</p>

<p>템플릿 문자열을 사용하는 코드는 연결보다는 중첩 및 구성을 통해 더 큰 템플릿을 구축하는 것이 더 일반적일 것으로 예상됩니다.</p>

<h3 id="임의의-변환-값-arbitrary-conversion-values">임의의 변환 값 (Arbitrary Conversion Values)</h3>

<p>Python은 가능한 변환 타입 값으로 <code class="language-plaintext highlighter-rouge">r</code>, <code class="language-plaintext highlighter-rouge">s</code>, 또는 <code class="language-plaintext highlighter-rouge">a</code>만 허용합니다. 다른 값을 할당하려고 하면 <code class="language-plaintext highlighter-rouge">SyntaxError</code>가 발생합니다.</p>

<p>이론적으로 템플릿 함수는 다른 변환 타입을 처리하도록 선택할 수 있습니다. 그러나 이 PEP는 PEP 701을 엄격하게 준수합니다. 허용되는 값에 대한 모든 변경 사항은 별도의 PEP에서 다루어져야 합니다.</p>

<h3 id="interpolation에서-conversion-제거-removing-conversion-from-interpolation">Interpolation에서 conversion 제거 (Removing conversion From Interpolation)</h3>

<p>이 PEP를 초안 작성하는 동안 <code class="language-plaintext highlighter-rouge">Interpolation</code>에서 <code class="language-plaintext highlighter-rouge">conversion</code> 속성을 제거하고, <code class="language-plaintext highlighter-rouge">Interpolation.value</code>가 설정되기 전에 변환이 즉시 수행되도록 지정하는 것을 고려했습니다.</p>

<p>이는 템플릿 처리 코드 작성 작업을 단순화하기 위한 것이었습니다. <code class="language-plaintext highlighter-rouge">conversion</code> 속성은 확장성이 제한적입니다(<code class="language-plaintext highlighter-rouge">Literal["r", "s", "a"] | None</code>으로 타입 지정됨). 커스텀 형식 지정자로 더 잘 달성할 수 없는 템플릿 문자열에 상당한 가치나 유연성을 추가하는지는 명확하지 않습니다. 형식 지정자와 달리 Python의 내장 <code class="language-plaintext highlighter-rouge">format()</code>과 동등한 것이 없습니다. (대신 “Examples” 섹션에 <code class="language-plaintext highlighter-rouge">convert()</code>의 샘플 구현을 포함합니다.)</p>

<p>궁극적으로 우리는 <code class="language-plaintext highlighter-rouge">f-strings</code>와의 호환성을 유지하고 향후 확장성을 허용하기 위해 <code class="language-plaintext highlighter-rouge">conversion</code> 속성을 <code class="language-plaintext highlighter-rouge">Interpolation</code> 타입에 유지하기로 결정했습니다.</p>

<h3 id="대체-보간-기호-alternate-interpolation-symbols">대체 보간 기호 (Alternate Interpolation Symbols)</h3>

<p>이 PEP의 초기 단계에서 템플릿 문자열에서 보간에 대한 대체 기호를 허용하는 것을 고려했습니다. 예를 들어, i18n 또는 다른 목적에 유용할 수 있다는 생각으로 <code class="language-plaintext highlighter-rouge">{name}</code>의 대안으로 <code class="language-plaintext highlighter-rouge">${name}</code>을 허용하는 것을 고려했습니다. 자세한 내용은 Discourse 스레드를 참조하십시오.</p>

<p>이는 <code class="language-plaintext highlighter-rouge">t-string</code> 문법을 <code class="language-plaintext highlighter-rouge">f-string</code> 문법과 가능한 한 가깝게 유지하는 것을 선호하여 거부되었습니다.</p>

<h3 id="template의-대체-레이아웃-alternate-layouts-for-template">Template의 대체 레이아웃 (Alternate Layouts for Template)</h3>

<p>이 PEP 개발 중에 <code class="language-plaintext highlighter-rouge">Template</code> 타입에 대한 여러 대체 레이아웃을 고려했습니다. 많은 것들이 문자열과 보간을 모두 포함하는 단일 <code class="language-plaintext highlighter-rouge">args</code> 튜플에 초점을 맞췄습니다. 변형에는 다음이 포함되었습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">args</code>는 <code class="language-plaintext highlighter-rouge">tuple[str | Interpolation, ...]</code>이었고, 첫 번째 및 마지막 항목이 문자열이고 문자열과 보간이 항상 번갈아 나타난다는 약속이 있었습니다. 이는 <code class="language-plaintext highlighter-rouge">args</code>가 항상 비어 있지 않고 인접한 보간 사이에 빈 문자열이 삽입됨을 의미했습니다. 이는 교대가 타입 시스템에 의해 포착될 수 없고 우리가 만들고자 하는 보장이 아니었기 때문에 거부되었습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">args</code>는 <code class="language-plaintext highlighter-rouge">tuple[str | Interpolation, ...]</code>으로 유지되었지만 인터리빙(interleaving)을 지원하지 않았습니다. 결과적으로 빈 문자열은 시퀀스에 추가되지 않았습니다. 더 이상 <code class="language-plaintext highlighter-rouge">args[::2]</code>로 정적 문자열을 얻을 수 없었고, 대신 문자열과 보간을 구별하기 위해 인스턴스 검사 또는 구조적 패턴 매칭을 사용해야 했습니다. 이 접근 방식은 성능 최적화를 위한 향후 기회가 적다고 판단되어 거부되었습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">args</code>는 <code class="language-plaintext highlighter-rouge">Sequence[tuple[str, Interpolation | None]]</code>으로 타입 지정되었습니다. 각 정적 문자열은 인접한 보간과 쌍을 이루었습니다. 최종 문자열 부분에는 해당하는 보간이 없었습니다. 이는 지나치게 복잡하다고 판단되어 거부되었습니다.</li>
</ul>

<h3 id="템플릿-종류를-설명하는-메커니즘-mechanism-to-describe-the-kind-of-template">템플릿 “종류”를 설명하는 메커니즘 (Mechanism to Describe the “Kind” of Template)</h3>

<p><code class="language-plaintext highlighter-rouge">t-strings</code>가 인기를 얻으면 템플릿 문자열에서 발견되는 콘텐츠의 “종류”(예: “sql”, “html”, “css” 등)를 설명하는 방법이 유용할 수 있습니다. 이는 린터(linters), 포맷터(formatters), 타입 체커(type checkers), IDE와 같은 도구에서 강력한 새 기능을 가능하게 할 수 있습니다. (예를 들어, <code class="language-plaintext highlighter-rouge">t-strings</code>에서 HTML을 포맷하는 <code class="language-plaintext highlighter-rouge">black</code>이나 주어진 속성이 HTML 태그에 유효한지 확인하는 <code class="language-plaintext highlighter-rouge">mypy</code>를 상상해 보세요.) 흥미롭기는 하지만, 이 PEP는 특정 메커니즘을 제안하지 않습니다. 시간이 지남에 따라 커뮤니티가 이 목적을 위한 규칙을 개발하기를 바랍니다.</p>

<h3 id="바이너리-템플릿-문자열-binary-template-strings">바이너리 템플릿 문자열 (Binary Template Strings)</h3>

<p><code class="language-plaintext highlighter-rouge">t-strings</code>와 바이트(<code class="language-plaintext highlighter-rouge">tb</code>)의 조합은 이 PEP의 범위를 벗어나는 것으로 간주됩니다. 그러나 <code class="language-plaintext highlighter-rouge">f-strings</code>와 달리 <code class="language-plaintext highlighter-rouge">t-strings</code>와 바이트를 결합할 수 없는 근본적인 이유는 없습니다. 향후 PEP에서 지원이 고려될 수 있습니다.</p>

<h2 id="감사의-말-acknowledgements">감사의 말 (Acknowledgements)</h2>

<p>템플릿 문자열로 이어진 아이디어 개발에 기여해준 Ryan Morshead에게 감사드립니다. 또한 몇 년 전에 유사한 아이디어를 다룬 Dropbox의 <code class="language-plaintext highlighter-rouge">pyxl</code>에게 특별한 언급을 합니다. Andrea Giammarchi는 이 PEP의 초기 초안에 대해 사려 깊은 피드백을 제공했습니다. 마지막으로, <code class="language-plaintext highlighter-rouge">tagged</code> 라이브러리에 대한 선구적인 작업에 대해 Joachim Viide에게 감사드립니다. <code class="language-plaintext highlighter-rouge">tagged</code>는 템플릿 문자열의 전신일 뿐만 아니라 GitHub 이슈 댓글을 통해 전체 노력이 시작된 곳입니다!</p>

<blockquote>
  <p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/tags/#python" class="page__taxonomy-item" rel="tag">Python</a><span class="sep">, </span>
    
      <a href="/tags/#translation" class="page__taxonomy-item" rel="tag">Translation</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/categories/#python" class="page__taxonomy-item" rel="tag">Python</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2025-09-27">September 27, 2025</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/python/pep/749/" class="pagination--pager" title="[Accepted] PEP 749 - Implementing PEP 649
">Previous</a>
    
    
      <a href="/python/pep/751/" class="pagination--pager" title="[Final] PEP 751 - A file format to record Python dependencies for installation reproducibility
">Next</a>
    
  </nav>


    </div>

    
  </article>

</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 secrett2633. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'secrett2633/secrett2633.github.io');
    script.setAttribute('issue-term', 'pathname');
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





  </body>
</html>
