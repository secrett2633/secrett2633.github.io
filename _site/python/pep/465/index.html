<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <style> 
      ::-webkit-scrollbar{ 
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-track {
        width: 0px;
        background-color: #626262;
        /* border-radius: 5px; */
      }

      ::-webkit-scrollbar-thumb {
        width: 0px;
        background-color: #E2E2E2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-thumb:hover {
        width: 10px;
        height: 20px;
        /* background-color: rgba(190, 190, 190, 0.2); */
        background-color: #A2A2A2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-track:hover {
        width: 10px;
        /* background-color: rgba(150, 150, 150, 0.1); */
        background-color: #626262;
        border-radius: 5px;
        /* background: transparent; */
        /* border-radius: 10px; */
      }

      ::-webkit-scrollbar-button:start:decrement,::-webkit-scrollbar-button:end:increment {
          width:0px;
          height: 0px;
          /* background-color: rgb(14, 221, 24); */
          /* border-radius: 50%; */
      }
    </style>
    
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[Final] PEP 465 - A dedicated infix operator for matrix multiplication | secrett2633</title>
<meta name="description" content="Python Enhancement Proposal 465: ‘A dedicated infix operator for matrix multiplication’에 대한 한국어 번역입니다.">


  <meta name="author" content="secrett2633">
  
  <meta property="article:author" content="secrett2633">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="secrett2633's blog">
<meta property="og:title" content="[Final] PEP 465 - A dedicated infix operator for matrix multiplication">
<meta property="og:url" content="http://localhost:4000/python/pep/465/">


  <meta property="og:description" content="Python Enhancement Proposal 465: ‘A dedicated infix operator for matrix multiplication’에 대한 한국어 번역입니다.">







  <meta property="article:published_time" content="2025-09-26T22:12:46+09:00">



  <meta property="article:modified_time" content="2025-09-26T22:12:46+09:00">



  

  


<link rel="canonical" href="http://localhost:4000/python/pep/465/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "secrett2633",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="secrett2633's blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->


    <link rel="icon" type="image/png" sizes="32x32" href="https://secrett2633.github.io/assets/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://secrett2633.github.io/assets/images/favicon/favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          secrett2633's blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://github.com/secrett2633">GitHub</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <!-- 2022.02.17 author content hidden -->
  <!-- <div class="author__content">
    
      <h3 class="author__name" itemprop="name">secrett2633</h3>
    
    
  </div> -->

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">Backend</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/backend/django/">Django</a></li>
          
            <li><a href="/backend/logging/">Logging</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">Python</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/python/pep/">PEP</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">AI/ML</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/ai/llm/">LLM</a></li>
          
            <li><a href="/ai/review/">Review</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">DevOps</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/devops/nginx/">Nginx</a></li>
          
            <li><a href="/devops/docker/">Docker</a></li>
          
            <li><a href="/devops/safeline/">SafeLine</a></li>
          
            <li><a href="/devops/jenkins/">Jenkins</a></li>
          
            <li><a href="/devops/github-actions/">GitHub Actions</a></li>
          
            <li><a href="/devops/aws/">AWS</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">etc</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/etc/me/">Me</a></li>
          
            <li><a href="/etc/chrome-extension/">Chrome Extension</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[Final] PEP 465 - A dedicated infix operator for matrix multiplication">
    <meta itemprop="description" content="Python Enhancement Proposal 465: ‘A dedicated infix operator for matrix multiplication’에 대한 한국어 번역입니다.">
    <meta itemprop="datePublished" content="2025-09-26T22:12:46+09:00">
    <meta itemprop="dateModified" content="2025-09-26T22:12:46+09:00">

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">[Final] PEP 465 - A dedicated infix operator for matrix multiplication
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2025-09-26T22:12:46+09:00">September 26, 2025</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#pep-465-행렬-곱셈을-위한-전용-중위infix-연산자--추가-제안">PEP 465: 행렬 곱셈을 위한 전용 중위(Infix) 연산자 @ 추가 제안</a><ul><li><a href="#요약">요약</a></li><li><a href="#제안-specification">제안 (Specification)</a></li><li><a href="#동기-motivation">동기 (Motivation)</a><ul><li><a href="#개요-executive-summary">개요 (Executive summary)</a></li><li><a href="#현재-상황의-문제점-background-whats-wrong-with-the-status-quo">현재 상황의 문제점 (Background: What’s wrong with the status quo?)</a></li><li><a href="#행렬-곱셈이-중위-연산자여야-하는-이유-why-should-matrix-multiplication-be-infix">행렬 곱셈이 중위 연산자여야 하는 이유 (Why should matrix multiplication be infix?)</a></li><li><a href="#비전문-프로그래머에게-투명한-문법이-특히-중요한-이유-transparent-syntax-is-especially-crucial-for-non-expert-programmers">비전문 프로그래머에게 투명한 문법이 특히 중요한 이유 (Transparent syntax is especially crucial for non-expert programmers)</a></li><li><a href="#행렬-곱셈이-틈새-시장-요구-사항에-불과한가-but-isnt-matrix-multiplication-a-pretty-niche-requirement">행렬 곱셈이 틈새 시장 요구 사항에 불과한가? (But isn’t matrix multiplication a pretty niche requirement?)</a></li><li><a href="#는-행렬-공식에-유용하지만-얼마나-자주-사용될까-so--is-good-for-matrix-formulas-but-how-common-are-those-really">@는 행렬 공식에 유용하지만, 얼마나 자주 사용될까? (So @ is good for matrix formulas, but how common are those really?)</a></li><li><a href="#표준-라이브러리에서-사용되지-않는-연산자를-추가하는-것이-이상한가-but-isnt-it-weird-to-add-an-operator-with-no-stdlib-uses">표준 라이브러리에서 사용되지 않는 연산자를 추가하는 것이 이상한가? (But isn’t it weird to add an operator with no stdlib uses?)</a></li></ul></li><li><a href="#호환성-고려-사항-compatibility-considerations">호환성 고려 사항 (Compatibility considerations)</a></li><li><a href="#의도된-사용법-세부-사항-intended-usage-details">의도된 사용법 세부 사항 (Intended usage details)</a></li><li><a href="#채택-adoption">채택 (Adoption)</a></li><li><a href="#구현-세부-사항-implementation-details">구현 세부 사항 (Implementation details)</a></li><li><a href="#명세-세부-사항에-대한-근거-rationale-for-specification-details">명세 세부 사항에 대한 근거 (Rationale for specification details)</a><ul><li><a href="#연산자-선택-choice-of-operator">연산자 선택 (Choice of operator)</a></li><li><a href="#우선순위-및-결합성-precedence-and-associativity">우선순위 및 결합성 (Precedence and associativity)</a></li><li><a href="#내장-타입에-대한-비정의-non-definitions-for-built-in-types">내장 타입에 대한 (비)정의 ((Non)-Definitions for built-in types)</a></li><li><a href="#행렬-거듭제곱의-미정의-non-definition-of-matrix-power">행렬 거듭제곱의 미정의 (Non-definition of matrix power)</a></li></ul></li><li><a href="#새로운-연산자-추가에-대한-거부된-대안-rejected-alternatives-to-adding-a-new-operator">새로운 연산자 추가에 대한 거부된 대안 (Rejected alternatives to adding a new operator)</a></li><li><a href="#참고-자료-references">참고 자료 (References)</a></li></ul></li></ul>

            </nav>
          </aside>
        
        <blockquote>
  <p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0465/">PEP 465 - A dedicated infix operator for matrix multiplication</a></p>

  <table>
    <tbody>
      <tr>
        <td><strong>상태:</strong> Final</td>
        <td><strong>유형:</strong> Standards Track</td>
        <td><strong>작성일:</strong> 20-Feb-2014</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h2 id="pep-465-행렬-곱셈을-위한-전용-중위infix-연산자--추가-제안">PEP 465: 행렬 곱셈을 위한 전용 중위(Infix) 연산자 <code class="language-plaintext highlighter-rouge">@</code> 추가 제안</h2>

<h3 id="요약">요약</h3>

<p>이 PEP는 Python에 행렬 곱셈을 위한 새로운 이항(binary) 연산자 <code class="language-plaintext highlighter-rouge">@</code>를 도입할 것을 제안합니다. 이 연산자는 파이썬 3.5부터 도입되었습니다.</p>

<h3 id="제안-specification">제안 (Specification)</h3>

<p><code class="language-plaintext highlighter-rouge">@</code> 연산자는 <code class="language-plaintext highlighter-rouge">*</code> 연산자와 동일한 연산자 우선순위와 좌측 결합성(left-associativity)을 가지며, <code class="language-plaintext highlighter-rouge">__matmul__</code> 메서드에 의해 구현됩니다. 또한, 해당 제자리(in-place) 버전인 <code class="language-plaintext highlighter-rouge">@=</code> 연산자는 <code class="language-plaintext highlighter-rouge">__imatmul__</code> 메서드를 통해 구현됩니다.</p>

<p>이러한 메서드는 내장 타입이나 표준 라이브러리 타입에는 추가되지 않습니다. 하지만 <code class="language-plaintext highlighter-rouge">numpy</code>와 같은 다수의 수치 계산 라이브러리에서 이 연산자에 대한 권장 시맨틱(semantics)에 합의를 이루었습니다.</p>

<p><strong>연산자 우선순위 및 결합성:</strong></p>

<table>
  <thead>
    <tr>
      <th>연산자</th>
      <th>우선순위/결합성</th>
      <th>메서드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">@</code></td>
      <td><code class="language-plaintext highlighter-rouge">*</code>와 동일</td>
      <td><code class="language-plaintext highlighter-rouge">__matmul__</code>, <code class="language-plaintext highlighter-rouge">__rmatmul__</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">@=</code></td>
      <td>N/A</td>
      <td><code class="language-plaintext highlighter-rouge">__imatmul__</code></td>
    </tr>
  </tbody>
</table>

<h3 id="동기-motivation">동기 (Motivation)</h3>

<h4 id="개요-executive-summary">개요 (Executive summary)</h4>

<p>수치 계산 코드에서는 원소별 곱셈(elementwise multiplication)과 행렬 곱셈(matrix multiplication)이라는 두 가지 중요한 연산이 Python의 <code class="language-plaintext highlighter-rouge">*</code> 연산자 사용을 두고 경쟁해왔습니다. Numeric 라이브러리가 처음 제안된 이래 약 20년 동안 이 문제를 해결하기 위한 많은 시도가 있었지만, 만족스러운 해결책은 없었습니다.</p>

<p>현재 대부분의 수치 Python 코드에서는 원소별 곱셈에 <code class="language-plaintext highlighter-rouge">*</code>를 사용하고, 행렬 곱셈에는 함수/메서드 호출 문법을 사용합니다 (<code class="language-plaintext highlighter-rouge">numpy.dot(a, b)</code> 또는 <code class="language-plaintext highlighter-rouge">a.dot(b)</code>). 그러나 이로 인해 코드가 가독성이 떨어지고 복잡해지는 문제가 발생합니다. 이 문제는 너무 심각해서 일부 코드베이스에서는 반대 규칙(행렬 곱셈에 <code class="language-plaintext highlighter-rouge">*</code>를 사용하는)을 계속 사용하며 API 파편화를 초래했습니다.</p>

<p>현재 Python 문법 내에서 수치 API를 설계하는 좋은 해결책은 없어 보이며, 단지 다양한 방식으로 나쁜 선택지만 존재합니다. 이러한 문제를 해결하기 위한 최소한의 Python 문법 변경은 행렬 곱셈을 위한 새로운 중위 연산자 하나를 추가하는 것입니다.</p>

<p>행렬 곱셈은 다른 이항 연산과 구별되는 독특한 특징들을 가지고 있으며, 전용 중위 연산자 추가에 대한 강력한 근거를 제공합니다:</p>

<ul>
  <li>기존 수치 연산자와 마찬가지로, 수학, 과학, 공학의 모든 분야에서 행렬 곱셈에 중위 표기법을 사용하는 방대한 선례가 있습니다. <code class="language-plaintext highlighter-rouge">@</code>는 Python의 기존 연산자 시스템의 빈틈을 조화롭게 채워줍니다.</li>
  <li><code class="language-plaintext highlighter-rouge">@</code>는 실제 코드의 가독성을 크게 향상시킵니다.</li>
  <li><code class="language-plaintext highlighter-rouge">@</code>는 가독성 낮은 코드와 API 파편화로 인해 특히 어려움을 겪는 비전문 프로그래머들을 위한 학습 진입 장벽을 낮춥니다.</li>
  <li><code class="language-plaintext highlighter-rouge">@</code>는 Python 사용자 커뮤니티의 상당하고 성장하는 부분에 이점을 제공할 것입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">@</code>는 자주 사용될 것이며, 심지어 <code class="language-plaintext highlighter-rouge">//</code>나 비트와이즈 연산자보다 더 자주 사용될 수 있다는 증거가 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">@</code>는 Python 수치 커뮤니티가 파편화를 줄이고, 모든 수치 배열 객체에 대한 단일 합의 오리 타이핑(duck type)을 표준화할 수 있도록 합니다.</li>
</ul>

<h4 id="현재-상황의-문제점-background-whats-wrong-with-the-status-quo">현재 상황의 문제점 (Background: What’s wrong with the status quo?)</h4>

<p>수치 계산 시, <code class="language-plaintext highlighter-rouge">n</code>차원 배열(n-dimensional array)은 대량의 숫자에 대해 한 번에 간단한 연산을 적용할 수 있게 하는 기본 객체입니다. <code class="language-plaintext highlighter-rouge">numpy</code>는 Python에서 이러한 배열을 제공하는 가장 유명한 라이브러리입니다.</p>

<p><code class="language-plaintext highlighter-rouge">n</code>차원 배열을 다룰 때, 곱셈을 정의하는 두 가지 방법이 있습니다:</p>

<ol>
  <li><strong>원소별 곱셈 (Elementwise multiplication):</strong>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[1, 2],    [[11, 12],    [[1 * 11, 2 * 12],
 [3, 4]] x   [13, 14]] =   [3 * 13, 4 * 14]]
</code></pre></div>    </div>
    <p>이 방식은 <code class="language-plaintext highlighter-rouge">for</code> 루프 없이 대량의 값에 대해 빠르고 쉽게 곱셈을 수행할 수 있어 유용합니다. <code class="language-plaintext highlighter-rouge">numpy</code>와 같은 라이브러리의 배열 객체를 사용할 때, 모든 Python 연산자는 모든 차원의 배열에 대해 원소별로 작동합니다.</p>
  </li>
  <li><strong>행렬 곱셈 (Matrix multiplication):</strong>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[1, 2],    [[11, 12],    [[1 * 11 + 2 * 13, 1 * 12 + 2 * 14],
 [3, 4]] x   [13, 14]] =   [3 * 11 + 4 * 13, 3 * 12 + 4 * 14]]
</code></pre></div>    </div>
    <p>행렬 곱셈은 2D 배열(행렬)에 대해서만 정의되며, 다른 연산들과 달리 중요한 “행렬” 버전이 있는 유일한 곱셈 연산입니다. 모든 수치 응용 분야에서 매우 중요하게 사용됩니다.</p>
  </li>
</ol>

<p>Python 문법은 현재 단일 곱셈 연산자 <code class="language-plaintext highlighter-rouge">*</code>만 허용하므로, 배열과 유사한 객체를 제공하는 라이브러리는 <code class="language-plaintext highlighter-rouge">*</code>를 원소별 곱셈에 사용할지, 아니면 행렬 곱셈에 사용할지 결정해야 합니다. 불행히도, 일반적인 수치 계산에서는 두 연산 모두 자주 사용되며, 두 경우 모두 함수 호출 문법보다는 중위 연산자 사용에 큰 이점이 있습니다. 이로 인해 어떤 규칙이 최적인지 불분명하며, 프로젝트 간 API 파편화가 발생합니다. 예를 들어 <code class="language-plaintext highlighter-rouge">numpy.ndarray</code>는 <code class="language-plaintext highlighter-rouge">*</code>를 원소별 곱셈에 사용하고, <code class="language-plaintext highlighter-rouge">numpy.matrix</code>는 <code class="language-plaintext highlighter-rouge">*</code>를 행렬 곱셈에 사용하여 코드 통합 시 문제를 야기합니다.</p>

<p>PEP 238이 <code class="language-plaintext highlighter-rouge">/</code>를 <code class="language-plaintext highlighter-rouge">/</code>와 <code class="language-plaintext highlighter-rouge">//</code> 두 연산자로 나눴던 것처럼, 이 PEP는 <code class="language-plaintext highlighter-rouge">*</code>를 원소별 곱셈을 위한 <code class="language-plaintext highlighter-rouge">*</code>와 행렬 곱셈을 위한 <code class="language-plaintext highlighter-rouge">@</code>로 나눌 것을 제안합니다.</p>

<h4 id="행렬-곱셈이-중위-연산자여야-하는-이유-why-should-matrix-multiplication-be-infix">행렬 곱셈이 중위 연산자여야 하는 이유 (Why should matrix multiplication be infix?)</h4>

<p>현재 대부분의 Python 수치 코드는 <code class="language-plaintext highlighter-rouge">numpy.dot(a, b)</code> 또는 <code class="language-plaintext highlighter-rouge">a.dot(b)</code>와 같은 문법을 사용하여 행렬 곱셈을 수행합니다. 이 방법은 작동하지만, 전 세계 수학, 과학, 공학 분야에서 보편적으로 중위 표기법이 사용되어 왔기 때문에 가독성 측면에서 중위 연산자가 훨씬 우수합니다.</p>

<p>예를 들어, 통계 가설 검정에서 사용되는 OLS 회귀 모델의 선형 가설 검정 수식 <code class="language-plaintext highlighter-rouge">S = (Hβ − r)T(HVHT) − 1(Hβ − r)</code>을 구현하는 경우를 살펴보겠습니다.</p>

<ul>
  <li><strong>현재 <code class="language-plaintext highlighter-rouge">dot</code> 함수 사용 시:</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">((</span><span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">).</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="nf">inv</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="n">H</span><span class="p">.</span><span class="n">T</span><span class="p">)),</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li><strong>현재 <code class="language-plaintext highlighter-rouge">dot</code> 메서드 사용 시:</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">).</span><span class="n">T</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="nf">inv</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">V</span><span class="p">).</span><span class="nf">dot</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="n">T</span><span class="p">))).</span><span class="nf">dot</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">@</code> 연산자 사용 시:</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">H</span> <span class="o">@</span> <span class="n">beta</span> <span class="o">-</span> <span class="n">r</span><span class="p">).</span><span class="n">T</span> <span class="o">@</span> <span class="nf">inv</span><span class="p">(</span><span class="n">H</span> <span class="o">@</span> <span class="n">V</span> <span class="o">@</span> <span class="n">H</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">H</span> <span class="o">@</span> <span class="n">beta</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div>    </div>
    <p><code class="language-plaintext highlighter-rouge">@</code> 연산자를 사용하면 원본 수식의 기호와 코드가 1:1로 투명하게 매핑되어 훨씬 읽기 쉽습니다. <code class="language-plaintext highlighter-rouge">@</code>는 불필요한 괄호를 줄여 코드를 더 간결하고 명확하게 만들며, 전문가와 비전문가 모두에게 행렬 코드의 사용성을 크게 향상시킵니다.</p>
  </li>
</ul>

<h4 id="비전문-프로그래머에게-투명한-문법이-특히-중요한-이유-transparent-syntax-is-especially-crucial-for-non-expert-programmers">비전문 프로그래머에게 투명한 문법이 특히 중요한 이유 (Transparent syntax is especially crucial for non-expert programmers)</h4>

<p>많은 과학 분야 코드는 해당 분야의 전문가들이 작성하지만, 프로그래밍 전문가는 아닌 경우가 많습니다. 이러한 사용자들은 수학 공식과 코드 간의 투명한 매핑이 매우 중요하며, 이는 코드를 작성하는 데 성공하느냐 실패하느냐의 차이를 만듭니다. <code class="language-plaintext highlighter-rouge">numpy.matrix</code> 타입이 <code class="language-plaintext highlighter-rouge">*</code>를 행렬 곱셈으로 정의하는 이유도 이러한 교육적 사용 사례 때문이며, <code class="language-plaintext highlighter-rouge">@</code> 연산자는 시작 및 고급 사용자 모두에게 더 나은 문법을 제공하고, 처음부터 동일한 표기법으로 표준화할 수 있도록 돕습니다.</p>

<h4 id="행렬-곱셈이-틈새-시장-요구-사항에-불과한가-but-isnt-matrix-multiplication-a-pretty-niche-requirement">행렬 곱셈이 틈새 시장 요구 사항에 불과한가? (But isn’t matrix multiplication a pretty niche requirement?)</h4>

<p>세계는 연속 데이터로 가득 차 있으며, 컴퓨터는 이를 정교하게 처리해야 하는 요구가 점점 늘고 있습니다. 배열(Array)은 금융, 머신러닝, 3D 그래픽, 컴퓨터 비전, 로봇 공학, 운영 연구, 계량 경제학, 기상학, 전산 언어학, 추천 시스템, 신경 과학, 천문학, 생물 정보학 등 다양한 응용 분야의 공통 언어입니다. 이러한 분야의 대부분에서 Python은 전통적인 이산 데이터 구조와 현대적인 수치 데이터 유형 및 알고리즘을 우아하게 혼합할 수 있는 능력 덕분에 빠르게 지배적인 역할을 하고 있습니다.</p>

<p>2013년에는 수치 Python에 특화된 7개의 국제 컨퍼런스가 개최되었고, PyCon 2014에서는 튜토리얼의 약 20%가 행렬 사용과 관련되어 있었습니다. GitHub 코드 검색 결과(<code class="language-plaintext highlighter-rouge">2014-04-10 기준</code>), <code class="language-plaintext highlighter-rouge">numpy</code>는 <code class="language-plaintext highlighter-rouge">sys</code>, <code class="language-plaintext highlighter-rouge">os</code>, <code class="language-plaintext highlighter-rouge">re</code> 다음으로 가장 많이 임포트되는 모듈 중 하나이며, <code class="language-plaintext highlighter-rouge">subprocess</code>, <code class="language-plaintext highlighter-rouge">math</code>, <code class="language-plaintext highlighter-rouge">pickle</code>, <code class="language-plaintext highlighter-rouge">threading</code>과 같은 표준 라이브러리 모듈보다도 더 많이 임포트됩니다. 이는 수치 계산이 현대 Python 사용의 주류를 이루고 있음을 시사합니다.</p>

<p>또한, 정수 나눗셈 연산자 <code class="language-plaintext highlighter-rouge">//</code>와 같이 특정 상황에서 매우 유용한 특수 산술 연산을 위해 중위 연산자를 추가한 선례가 있습니다. <code class="language-plaintext highlighter-rouge">//</code>나 비트와이즈 연산자를 사용해본 적이 없는 Python 프로그래머가 많을 수 있지만, <code class="language-plaintext highlighter-rouge">@</code>는 <code class="language-plaintext highlighter-rouge">//</code>보다 더 틈새 시장에 속하지 않습니다.</p>

<h4 id="는-행렬-공식에-유용하지만-얼마나-자주-사용될까-so--is-good-for-matrix-formulas-but-how-common-are-those-really"><code class="language-plaintext highlighter-rouge">@</code>는 행렬 공식에 유용하지만, 얼마나 자주 사용될까? (So @ is good for matrix formulas, but how common are those really?)</h4>

<p>표준 라이브러리, scikit-learn, nipy의 코드 베이스에서 연산자 사용 빈도를 분석한 결과, 행렬 곱셈 연산(dot)은 이 두 수치 패키지에서만 약 780번 사용되었으며, 대부분의 비교 연산자(<code class="language-plaintext highlighter-rouge">!=</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>)보다 더 자주 사용됩니다. 표준 라이브러리까지 포함한 전체 코드 베이스에서는 행렬 곱셈이 비트와이즈 연산자들보다 더 자주 사용되고, <code class="language-plaintext highlighter-rouge">//</code>보다 2배 더 자주 사용됩니다. 이는 수치 프로그래밍이 일반적이고 주류 활동임을 나타냅니다.</p>

<h4 id="표준-라이브러리에서-사용되지-않는-연산자를-추가하는-것이-이상한가-but-isnt-it-weird-to-add-an-operator-with-no-stdlib-uses">표준 라이브러리에서 사용되지 않는 연산자를 추가하는 것이 이상한가? (But isn’t it weird to add an operator with no stdlib uses?)</h4>

<p>특이한 경우이기는 하지만, 중요한 것은 변경 사항이 사용자에게 이점을 제공하는지 여부입니다. <code class="language-plaintext highlighter-rouge">@</code>가 많이 사용될 것이 분명하며, 이 PEP는 Python 수치 커뮤니티가 모든 배열과 유사한 객체에 대한 표준 오리 타이핑에 최종 합의에 도달할 수 있게 하는 중요한 조각을 제공합니다. 이는 표준 라이브러리에 수치 배열 타입을 추가하는 데 필요한 전제 조건입니다.</p>

<h3 id="호환성-고려-사항-compatibility-considerations">호환성 고려 사항 (Compatibility considerations)</h3>

<p>현재 Python 코드에서 <code class="language-plaintext highlighter-rouge">@</code> 토큰의 유일한 합법적인 사용처는 데코레이터에서 문장 시작 부분입니다. 새로운 연산자는 모두 중위 연산자이므로 문장 시작 부분에는 나타날 수 없습니다. 따라서 이 연산자들을 추가해도 기존 코드가 손상되지 않으며, 데코레이터 <code class="language-plaintext highlighter-rouge">@</code>와 새로운 연산자 사이에 구문 분석(parsing) 모호성도 없습니다.</p>

<p>또한, 행렬을 사용하지 않는 사용자가 이 변경 사항으로 인해 Python 언어에 대한 이해를 업데이트하는 데 드는 정신적 비용도 최소화됩니다.</p>

<h3 id="의도된-사용법-세부-사항-intended-usage-details">의도된 사용법 세부 사항 (Intended usage details)</h3>

<p>이 섹션은 정보 제공을 목적으로 하며, 배열 또는 행렬과 유사한 객체를 제공하는 여러 라이브러리가 <code class="language-plaintext highlighter-rouge">@</code>를 구현하는 방법에 대한 합의를 문서화합니다.</p>

<p><code class="language-plaintext highlighter-rouge">numpy</code> 용어를 사용하여 임의의 다차원 배열을 설명합니다.</p>

<ul>
  <li><strong>2차원 입력:</strong> 일반적인 행렬로 간주하며, 전통적인 행렬 곱셈을 적용합니다. 예를 들어, <code class="language-plaintext highlighter-rouge">arr(2, 3) @ arr(3, 4)</code>는 <code class="language-plaintext highlighter-rouge">(2, 4)</code> 형태의 배열을 반환합니다.</li>
  <li><strong>1차원 벡터 입력:</strong> 형태에 ‘1’을 앞 또는 뒤에 붙여 2차원으로 승격된 후 연산이 수행됩니다. 이로 인해 <code class="language-plaintext highlighter-rouge">matrix @ vector</code>와 <code class="language-plaintext highlighter-rouge">vector @ matrix</code> 모두 허용되며 1차원 벡터를 반환하고, <code class="language-plaintext highlighter-rouge">vector @ vector</code>는 스칼라를 반환합니다. 예를 들어:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">arr(2, 3) @ arr(3)</code>는 <code class="language-plaintext highlighter-rouge">arr(3)</code>을 <code class="language-plaintext highlighter-rouge">(3, 1)</code> 형태의 행렬로 처리하여 <code class="language-plaintext highlighter-rouge">(2,)</code> 형태의 1차원 벡터를 반환합니다.</li>
      <li><code class="language-plaintext highlighter-rouge">arr(3) @ arr(3)</code>는 내적(inner product)을 수행하여 스칼라 값을 반환합니다.
이러한 정의는 일부 경우 <code class="language-plaintext highlighter-rouge">@</code>를 비결합적(non-associative)으로 만들 수 있지만, 실제 사용 사례의 중요성 때문에 채택되었습니다.</li>
    </ul>
  </li>
  <li><strong>2차원보다 큰 입력:</strong> 마지막 두 차원을 곱할 행렬의 차원으로 취급하고, 다른 차원에 걸쳐 ‘브로드캐스트(broadcast)’됩니다. 예를 들어, <code class="language-plaintext highlighter-rouge">arr(10, 2, 3) @ arr(10, 3, 4)</code>는 10개의 개별 행렬 곱셈을 수행하여 <code class="language-plaintext highlighter-rouge">(10, 2, 4)</code> 형태의 배열을 반환합니다.</li>
  <li><strong>0차원 (스칼라) 입력:</strong> 오류를 발생시킵니다. 스칼라와 행렬의 곱셈은 <code class="language-plaintext highlighter-rouge">*</code> 연산자로 이미 처리됩니다.</li>
</ul>

<h3 id="채택-adoption">채택 (Adoption)</h3>

<p>현재 원소별 곱셈과 행렬 곱셈에 다른 API를 사용하는 기존 Python 프로젝트들은 이 PEP의 승인에 따라 다음과 같이 전환할 계획을 가지고 있습니다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">*</code>를 원소별 곱셈에, 함수/메서드 호출을 행렬 곱셈에 사용하는 프로젝트:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">numpy</code>, <code class="language-plaintext highlighter-rouge">pandas</code>, <code class="language-plaintext highlighter-rouge">blaze</code>, <code class="language-plaintext highlighter-rouge">theano</code> 등의 개발자들은 위에서 설명한 시맨틱을 사용하여 <code class="language-plaintext highlighter-rouge">@</code>를 구현할 의사를 표명했습니다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">*</code>를 행렬 곱셈에, 함수/메서드 호출을 원소별 곱셈에 사용하는 프로젝트:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">numpy</code> (<code class="language-plaintext highlighter-rouge">numpy.matrix</code>), <code class="language-plaintext highlighter-rouge">scipy.sparse</code>, <code class="language-plaintext highlighter-rouge">pyoperators</code>, <code class="language-plaintext highlighter-rouge">pyviennacl</code> 등의 프로젝트는 이 PEP가 수락되면 현재 API에서 원소별 <code class="language-plaintext highlighter-rouge">*</code>, 행렬 곱셈 <code class="language-plaintext highlighter-rouge">@</code> 규칙으로 전환할 의사를 표명했습니다. 이는 이 PEP가 수락될 경우 API 파편화가 해소될 프로젝트 목록입니다.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">*</code>를 행렬 곱셈에 사용하고, 원소별 행렬 곱셈에 크게 신경 쓰지 않는 프로젝트:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">sympy</code>, <code class="language-plaintext highlighter-rouge">sage</code>와 같은 프로젝트는 추상 수학적 객체로서의 행렬에 초점을 맞추며, 원소별 연산의 필요성이 적습니다. 이들은 <code class="language-plaintext highlighter-rouge">@</code>가 수락되더라도 <code class="language-plaintext highlighter-rouge">*</code>를 행렬 곱셈에 계속 사용할 것이며, <code class="language-plaintext highlighter-rouge">@</code>를 별칭으로 추가할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="구현-세부-사항-implementation-details">구현 세부 사항 (Implementation details)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">operator.matmul</code> 및 <code class="language-plaintext highlighter-rouge">operator.__matmul__</code> 함수가 표준 라이브러리에 추가됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">PyObject* PyObject_MatrixMultiply(PyObject *o1, PyObject *o2)</code> 함수가 C API에 추가됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">MatMult</code>라는 새로운 AST(Abstract Syntax Tree) 노드, 새로운 토큰 <code class="language-plaintext highlighter-rouge">ATEQUAL</code>, 그리고 새로운 바이트코드 opcodes <code class="language-plaintext highlighter-rouge">BINARY_MATRIX_MULTIPLY</code> 및 <code class="language-plaintext highlighter-rouge">INPLACE_MATRIX_MULTIPLY</code>가 추가됩니다.</li>
  <li>두 개의 새로운 타입 슬롯이 추가됩니다.</li>
</ul>

<h3 id="명세-세부-사항에-대한-근거-rationale-for-specification-details">명세 세부 사항에 대한 근거 (Rationale for specification details)</h3>

<h4 id="연산자-선택-choice-of-operator">연산자 선택 (Choice of operator)</h4>

<p><code class="language-plaintext highlighter-rouge">@</code>를 선택한 이유는 다음과 같습니다:</p>

<ul>
  <li>미국 영어 키보드에 있는 기호 중 Python 표현식 컨텍스트에서 아직 의미가 없는 <code class="language-plaintext highlighter-rouge">@</code>, 백틱, <code class="language-plaintext highlighter-rouge">$</code>, <code class="language-plaintext highlighter-rouge">!</code>, <code class="language-plaintext highlighter-rouge">?</code> 중에서 <code class="language-plaintext highlighter-rouge">@</code>가 가장 적합합니다. <code class="language-plaintext highlighter-rouge">!</code>와 <code class="language-plaintext highlighter-rouge">?</code>는 프로그래밍 맥락에서 이미 다른 의미를 가지고 있고, 백틱은 BDFL에 의해 Python에서 금지되었으며, <code class="language-plaintext highlighter-rouge">$</code>는 <code class="language-plaintext highlighter-rouge">*</code>나 <code class="language-plaintext highlighter-rouge">·</code>와 더 이질적이며 Perl/PHP의 영향이 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">@</code>는 “스칼라/원소별 곱셈과 구별되는 행렬 곱셈”을 의미하는 데 필요한 연산자입니다. 프로그래밍이나 수학에서 이러한 의미를 가진 관습적인 기호는 없습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">@</code>는 데코레이터에서 이미 익숙하게 사용되는 친숙한 문자이지만, 데코레이터 사용과 수학 표현식 사용은 실제에서 혼동하기 어려울 정도로 충분히 다릅니다.</li>
  <li>키보드 레이아웃에 관계없이 널리 접근 가능합니다 (이메일 주소에서의 사용 덕분에).</li>
  <li><code class="language-plaintext highlighter-rouge">*</code>와 <code class="language-plaintext highlighter-rouge">·</code>처럼 둥근 형태를 가집니다.</li>
  <li><code class="language-plaintext highlighter-rouge">mATrices</code>라는 연상 기호가 귀엽습니다.</li>
  <li>회전하는 모양은 행렬 곱셈을 정의하는 행과 열에 대한 동시 스캔을 연상시킵니다.</li>
  <li>비대칭성은 비결합적인 특성을 암시합니다.</li>
</ul>

<h4 id="우선순위-및-결합성-precedence-and-associativity">우선순위 및 결합성 (Precedence and associativity)</h4>

<p><code class="language-plaintext highlighter-rouge">@</code> 연산자는 대부분의 Python 연산자와 마찬가지로 <strong>좌측 결합성(left-associative)</strong>을 가집니다.
비록 행렬 곱셈이 함수 적용/합성과 유사하여 일부 수학적으로 정교한 사용자들은 우측 결합성을 직관적으로 생각할 수 있고, <code class="language-plaintext highlighter-rouge">Mat @ (Mat @ vec)</code>과 같이 평가될 때 효율성 이점이 있을 수 있다는 주장이 있었지만, 다음 이유들로 인해 좌측 결합성이 채택되었습니다:</p>

<ul>
  <li>실제 코드에서 <code class="language-plaintext highlighter-rouge">Mat @ Mat @ vec</code> 유형의 표현식이 지배적이라는 증거를 찾을 수 없었습니다.</li>
  <li>R, Matlab, Julia, IDL, Gauss 등 선형 대수에 중점을 둔 다른 언어들도 행렬 곱셈 연산자를 압도적으로 좌측 결합성으로 만듭니다.</li>
  <li>좌측 결합성은 <code class="language-plaintext highlighter-rouge">@</code>가 <code class="language-plaintext highlighter-rouge">*</code>와 유사하게 작동한다고 배우고 기억하기 훨씬 쉽습니다.</li>
</ul>

<h4 id="내장-타입에-대한-비정의-non-definitions-for-built-in-types">내장 타입에 대한 (비)정의 ((Non)-Definitions for built-in types)</h4>

<p><code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">int</code> 등과 같은 내장 수치 타입이나 <code class="language-plaintext highlighter-rouge">numbers.Number</code> 계층에는 <code class="language-plaintext highlighter-rouge">__matmul__</code> 또는 <code class="language-plaintext highlighter-rouge">__matpow__</code>가 정의되지 않습니다. 이러한 타입은 스칼라를 나타내며, <code class="language-plaintext highlighter-rouge">@</code>의 합의된 시맨틱은 스칼라에 대해 오류를 발생시켜야 하기 때문입니다.</p>

<p><code class="language-plaintext highlighter-rouge">memoryview</code> 또는 <code class="language-plaintext highlighter-rouge">array.array</code> 객체에는 현재 <code class="language-plaintext highlighter-rouge">__matmul__</code> 메서드가 정의되지 않습니다. 이는 해당 타입이 수치 작업에 사용되기 전에 상당한 추가 작업이 필요하며, 효율적인 행렬 곱셈 구현의 복잡성 (BLAS 라이브러리 링크 및 <code class="language-plaintext highlighter-rouge">multiprocessing</code> 문제) 때문입니다.</p>

<p><code class="language-plaintext highlighter-rouge">str</code>, <code class="language-plaintext highlighter-rouge">list</code> 등 <code class="language-plaintext highlighter-rouge">__mul__</code>을 정의하는 비수치 Python 내장 타입에 대해서도 <code class="language-plaintext highlighter-rouge">__matmul__</code>은 정의되지 않습니다.</p>

<h4 id="행렬-거듭제곱의-미정의-non-definition-of-matrix-power">행렬 거듭제곱의 미정의 (Non-definition of matrix power)</h4>

<p>이 PEP의 초기 버전에서는 <code class="language-plaintext highlighter-rouge">**</code>와 유사한 행렬 거듭제곱 연산자 <code class="language-plaintext highlighter-rouge">@@</code>도 제안했지만, 그 유용성이 불분명하여 현재는 제외되었습니다. <code class="language-plaintext highlighter-rouge">@</code> 연산자에 대한 경험이 더 쌓인 후에 <code class="language-plaintext highlighter-rouge">@@</code>의 필요성이 입증되면 다시 논의될 예정입니다.</p>

<h3 id="새로운-연산자-추가에-대한-거부된-대안-rejected-alternatives-to-adding-a-new-operator">새로운 연산자 추가에 대한 거부된 대안 (Rejected alternatives to adding a new operator)</h3>

<p>지난 수십 년 동안 Python 수치 커뮤니티는 행렬 곱셈과 원소별 곱셈 연산 사이의 긴장을 해결하기 위한 다양한 방법을 모색했습니다. PEP 211과 PEP 225는 이 문제를 해결하기 위한 초기 시도였지만 심각한 결함이 있었습니다. 이후의 경험을 통해 수치 Python과 코어 Python 모두를 위한 최상의 해결책은 행렬 곱셈을 위한 단일 중위 연산자를 추가하는 것이라는 합의에 도달했습니다.</p>

<p>거부된 주요 대안들은 다음과 같습니다:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">__mul__</code>을 행렬 곱셈으로 정의하는 두 번째 타입 사용:</strong> <code class="language-plaintext highlighter-rouge">numpy.matrix</code> 타입으로 수년 동안 시도되었지만, 배열에 대한 충돌하는 오리 타이핑으로 인해 <code class="language-plaintext highlighter-rouge">numpy</code> 개발자와 하위 패키지 개발자들 사이에서 <code class="language-plaintext highlighter-rouge">numpy.matrix</code>를 거의 사용하지 말아야 한다는 강력한 합의를 이끌어냈습니다.</li>
  <li><strong>많은 새로운 연산자 추가 또는 중위 연산자를 정의하기 위한 새로운 일반 문법 추가:</strong> 일반적으로 Pythonic하지 않으며, BDFL에 의해 반복적으로 거부되었습니다. 과학 Python 커뮤니티는 행렬 곱셈을 위한 하나의 연산자 추가만으로 해결할 수 없는 고통스러운 문제를 해결하기에 충분하다는 합의에 도달했습니다.</li>
  <li><strong>일반 Python에서 다른 의미를 가지는 새로운 <code class="language-plaintext highlighter-rouge">@</code> 연산자를 추가하고 수치 코드에서 오버로드:</strong> PEP 211이 취했던 접근 방식이었으나, <code class="language-plaintext highlighter-rouge">itertools.product</code>가 전용 연산자를 필요로 할 만큼 중요하지 않다는 문제가 있었습니다. 행렬 곱셈은 중위 연산자로 포함될 만한 독특하고 강력한 근거를 가집니다.</li>
  <li><strong>배열 타입에 <code class="language-plaintext highlighter-rouge">.dot</code> 메서드를 추가하여 “유사 중위(pseudo-infix)” <code class="language-plaintext highlighter-rouge">A.dot(B)</code> 문법 허용:</strong> <code class="language-plaintext highlighter-rouge">numpy</code>에 수년 동안 존재했지만, 여전히 실제 중위 표기법보다 가독성이 떨어지며 과도한 괄호 문제가 있습니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">with</code> 블록을 사용하여 단일 코드 블록 내에서 <code class="language-plaintext highlighter-rouge">*</code>의 의미 전환:</strong> 전역 상태 확인 문제와 동적 스코프(dynamically scoped) 문제로 인해 안전하게 사용하기 어렵습니다.</li>
  <li><strong>수치 지향 연산자 및 기타 구문을 추가하는 언어 전처리기 사용:</strong> 하나의 이항 연산자를 지원하기 위해 새로운 언어를 정의하는 것은 비실용적입니다. Python의 강점은 전문화된 수치 코드를 다른 일반적인 코드와 혼합할 수 있다는 점인데, “수치 Python”을 “실제 Python”과 분리하는 것은 혼란을 야기하고 파편화를 증가시킵니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">*dot*</code>과 같은 “새로운 중위 연산자”를 정의하기 위한 오버로딩 해킹 사용:</strong> 아름답지 않고 Pythonic하지 않으며, 초보자에게 특히 불친절합니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">arr.M * arr</code>과 같은 구문을 지원하기 위해 특수 “파사드(facade)” 타입 사용:</strong> “마법 같은” 특성으로 인해 위의 해킹과 유사한 반대를 받습니다. 또한, 파사드 객체가 다른 배열 객체와 파사드 객체 모두를 인식해야 하는 등 비직관적인 복잡성을 야기합니다.</li>
</ul>

<h3 id="참고-자료-references">참고 자료 (References)</h3>

<p>https://peps.python.org/pep-0465/</p>

<blockquote>
  <p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/tags/#python" class="page__taxonomy-item" rel="tag">Python</a><span class="sep">, </span>
    
      <a href="/tags/#translation" class="page__taxonomy-item" rel="tag">Translation</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/categories/#python" class="page__taxonomy-item" rel="tag">Python</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2025-09-26">September 26, 2025</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/python/pep/464/" class="pagination--pager" title="[Final] PEP 464 - Removal of the PyPI Mirror Authenticity API
">Previous</a>
    
    
      <a href="/python/pep/466/" class="pagination--pager" title="[Final] PEP 466 - Network Security Enhancements for Python 2.7.x
">Next</a>
    
  </nav>


    </div>

    
  </article>

</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 secrett2633. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'secrett2633/secrett2633.github.io');
    script.setAttribute('issue-term', 'pathname');
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





  </body>
</html>
