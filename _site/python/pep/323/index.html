<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <style> 
      ::-webkit-scrollbar{ 
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-track {
        width: 0px;
        background-color: #626262;
        /* border-radius: 5px; */
      }

      ::-webkit-scrollbar-thumb {
        width: 0px;
        background-color: #E2E2E2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-thumb:hover {
        width: 10px;
        height: 20px;
        /* background-color: rgba(190, 190, 190, 0.2); */
        background-color: #A2A2A2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-track:hover {
        width: 10px;
        /* background-color: rgba(150, 150, 150, 0.1); */
        background-color: #626262;
        border-radius: 5px;
        /* background: transparent; */
        /* border-radius: 10px; */
      }

      ::-webkit-scrollbar-button:start:decrement,::-webkit-scrollbar-button:end:increment {
          width:0px;
          height: 0px;
          /* background-color: rgb(14, 221, 24); */
          /* border-radius: 50%; */
      }
    </style>
    
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[Deferred] PEP 323 - Copyable Iterators | secrett2633</title>
<meta name="description" content="Python Enhancement Proposal 323: ‘Copyable Iterators’에 대한 한국어 번역입니다.">


  <meta name="author" content="secrett2633">
  
  <meta property="article:author" content="secrett2633">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="secrett2633's blog">
<meta property="og:title" content="[Deferred] PEP 323 - Copyable Iterators">
<meta property="og:url" content="http://localhost:4000/python/pep/323/">


  <meta property="og:description" content="Python Enhancement Proposal 323: ‘Copyable Iterators’에 대한 한국어 번역입니다.">







  <meta property="article:published_time" content="2025-09-26T18:31:01+09:00">



  <meta property="article:modified_time" content="2025-09-26T18:31:01+09:00">



  

  


<link rel="canonical" href="http://localhost:4000/python/pep/323/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "secrett2633",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="secrett2633's blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->


    <link rel="icon" type="image/png" sizes="32x32" href="https://secrett2633.github.io/assets/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://secrett2633.github.io/assets/images/favicon/favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          secrett2633's blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://github.com/secrett2633">GitHub</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <!-- 2022.02.17 author content hidden -->
  <!-- <div class="author__content">
    
      <h3 class="author__name" itemprop="name">secrett2633</h3>
    
    
  </div> -->

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
      
    
    
      <nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    <!-- Backend -->
    <li>
      <span class="nav__sub-title">Backend</span>
      <hr>
      <ul>
        <li><a href="/backend/django/">Django</a></li>
        <li><a href="/backend/logging/">Logging</a></li>
      </ul>
    </li>

    <!-- Python -->
    <li>
      <span class="nav__sub-title">Python</span>
      <hr>
      <ul>
        <li><a href="/python/pep/">PEP</a></li>
      </ul>
    </li>

    <!-- AI/ML -->
    <li>
      <span class="nav__sub-title">AI/ML</span>
      <hr>
      <ul>
        <li><a href="/ai/llm/">LLM</a></li>
        <li><a href="/ai/review/">Review</a></li>
      </ul>
    </li>

    <!-- DevOps -->
    <li>
      <span class="nav__sub-title">DevOps</span>
      <hr>
      <ul>
        <li><a href="/devops/nginx/">Nginx</a></li>
        <li><a href="/devops/docker/">Docker</a></li>
        <li><a href="/devops/safeline/">SafeLine</a></li>
        <li><a href="/devops/jenkins/">Jenkins</a></li>
        <li><a href="/devops/github-actions/">GitHub Actions</a></li>
        <li><a href="/devops/aws/">AWS</a></li>
      </ul>
    </li>

    <!-- etc -->
    <li>
      <span class="nav__sub-title">etc</span>
      <hr>
      <ul>
        <li><a href="/etc/me/">Me</a></li>
        <li><a href="/etc/chrome-extension/">Chrome Extension</a></li>
      </ul>
    </li>
  </ul>
</nav>
    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[Deferred] PEP 323 - Copyable Iterators">
    <meta itemprop="description" content="Python Enhancement Proposal 323: ‘Copyable Iterators’에 대한 한국어 번역입니다.">
    <meta itemprop="datePublished" content="2025-09-26T18:31:01+09:00">
    <meta itemprop="dateModified" content="2025-09-26T18:31:01+09:00">

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">[Deferred] PEP 323 - Copyable Iterators
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2025-09-26T18:31:01+09:00">September 26, 2025</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#개요">개요</a></li><li><a href="#연기-deferral">연기 (Deferral)</a></li><li><a href="#추상-abstract">추상 (Abstract)</a></li><li><a href="#업데이트-및-코멘트-update-and-comments">업데이트 및 코멘트 (Update and Comments)</a></li><li><a href="#동기-motivation">동기 (Motivation)</a></li><li><a href="#명세-specification">명세 (Specification)</a></li><li><a href="#세부-사항-details">세부 사항 (Details)</a></li><li><a href="#이론적-근거-rationale">이론적 근거 (Rationale)</a></li><li><a href="#참조-references">참조 (References)</a></li><li><a href="#저작권-copyright">저작권 (Copyright)</a></li></ul>

            </nav>
          </aside>
        
        <blockquote>
  <p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0323/">PEP 323 - Copyable Iterators</a></p>

  <table>
    <tbody>
      <tr>
        <td><strong>상태:</strong> Deferred</td>
        <td><strong>유형:</strong> Standards Track</td>
        <td><strong>작성일:</strong> 25-Oct-2003</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<p>PEP 323 – 복사 가능한 이터레이터 (Copyable Iterators)</p>

<hr />

<h2 id="개요">개요</h2>

<p>이 PEP (Python Enhancement Proposal)는 일부 이터레이터 (iterator) 유형이 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 통해 인스턴스의 얕은 복사 (shallow copy)를 지원해야 한다고 제안합니다. 이 제안은 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 사용하는 코드가 어떻게 이러한 기능을 활용할 수 있는지 보여줍니다.</p>

<p><strong>상태:</strong> 연기됨 (Deferred)
<strong>작성자:</strong> Alex Martelli
<strong>생성일:</strong> 2003년 10월 25일
<strong>Python 버전:</strong> 2.5</p>

<h2 id="연기-deferral">연기 (Deferral)</h2>

<p>이 PEP는 연기되었습니다. 복사 가능한 이터레이터는 좋은 아이디어였지만, 4년이 지난 후에도 구현되거나 광범위한 관심을 받지 못했습니다.</p>

<h2 id="추상-abstract">추상 (Abstract)</h2>

<p>이 PEP는 특정 요구 사항을 충족하는 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 노출함으로써 일부 이터레이터 타입이 인스턴스의 얕은 복사를 지원해야 한다고 제안하며, 이터레이터를 사용하는 코드가 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 활용하는 방법을 제시합니다.</p>

<h2 id="업데이트-및-코멘트-update-and-comments">업데이트 및 코멘트 (Update and Comments)</h2>

<p><code class="language-plaintext highlighter-rouge">__copy__</code> 지원은 Python 2.4의 <code class="language-plaintext highlighter-rouge">itertools.tee()</code>에 포함되었습니다. 기존 이터레이터에 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 추가하면 <code class="language-plaintext highlighter-rouge">tee()</code>의 동작이 변경될 수 있습니다. 현재 복사된 이터레이터는 원래 이터레이터에 묶여 있으며, 원본이 진행되면 모든 복사본도 진행됩니다. 좋은 관행은 <code class="language-plaintext highlighter-rouge">a, b = tee(a)</code>처럼 원본을 덮어쓰는 것입니다. 이 관행을 따르지 않는 코드는 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드가 이터레이터에 추가될 경우 의미적 변화를 관찰할 수 있습니다.</p>

<h2 id="동기-motivation">동기 (Motivation)</h2>

<p>Python 2.3까지 대부분의 내장 이터레이터 유형은 인스턴스를 복사할 수 없었습니다. 사용자가 작성한 이터레이터는 <code class="language-plaintext highlighter-rouge">copy.copy</code>를 호출할 수 있지만, 복사 결과로 원본과 독립적으로 이터레이션할 수 있는 별도의 이터레이터 객체를 반환할 수도 있고 그렇지 않을 수도 있습니다.</p>

<p>현재 사용자 정의 이터레이터 타입에서 <code class="language-plaintext highlighter-rouge">copy.copy</code> 지원은 거의 항상 “우발적”입니다. 즉, Python 표준 라이브러리의 <code class="language-plaintext highlighter-rouge">copy</code> 모듈에 있는 <code class="language-plaintext highlighter-rouge">copy</code> 메서드의 표준 메커니즘은 복사본을 만들고 반환하지만, 복사본이 원본과 독립적으로 이터레이션 가능하려면 해당 클래스의 <code class="language-plaintext highlighter-rouge">.next()</code> 호출이 인스턴스 상태를 기존 값 변경이 아닌 새 값으로 속성을 재할당함으로써만 변경해야 합니다.</p>

<p>예를 들어, “인덱스” 상태가 정수 속성으로 유지되는 이터레이터는 유용한 복사본을 제공할 수 있습니다. 반면에 “인덱스” 상태가 리스트 속성으로 유지되는 이터레이터는 <code class="language-plaintext highlighter-rouge">.next()</code> 실행 시 동일한 리스트 객체를 변경할 것이므로, 이러한 이터레이터의 복사본은 원본과 독립적으로 이터레이션할 수 없습니다.</p>

<p>이러한 상황 때문에 <code class="language-plaintext highlighter-rouge">copy.copy(it)</code>는 유용하지 않으며 널리 사용되지 않습니다. 그러나 이터레이터의 “스냅샷”을 “북마크”처럼 얻어 시퀀스를 계속 이터레이션하다가 나중에 북마크 지점부터 다시 이터레이션할 수 있는 많은 경우가 있습니다. 이러한 “북마킹”을 지원하기 위해 <code class="language-plaintext highlighter-rouge">itertools</code> 모듈은 Python 2.4에서 <code class="language-plaintext highlighter-rouge">tee</code> 함수를 추가했습니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">it</span><span class="p">,</span> <span class="n">bookmark</span> <span class="o">=</span> <span class="n">itertools</span><span class="p">.</span><span class="nf">tee</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</code></pre></div></div>
<p>이 호출 후에 <code class="language-plaintext highlighter-rouge">it</code>와 <code class="language-plaintext highlighter-rouge">bookmark</code>는 원래 <code class="language-plaintext highlighter-rouge">it</code>와 동일한 기본 시퀀스에 대해 독립적으로 이터레이션할 수 있는 이터레이터가 되어 “이터레이터 복사”에 대한 애플리케이션 요구 사항을 충족합니다. <code class="language-plaintext highlighter-rouge">it</code>의 이전 값은 다시 사용해서는 안 됩니다.</p>

<p>그러나 <code class="language-plaintext highlighter-rouge">itertools.tee</code>는 인수로 전달된 이터레이터의 특성에 대해 가정을 할 수 없을 때, 두 “티된” 이터레이터 중 하나만 진행했지만 둘 다 아직 진행하지 않은 모든 항목을 메모리에 저장해야 합니다. 이는 두 이터레이터가 진행에서 서로 크게 멀어질 경우 메모리 비용이 상당히 커질 수 있습니다.</p>

<p>이 PEP는 중요한 경우 <code class="language-plaintext highlighter-rouge">itertools.tee</code>가 메모리 비용을 최소화하면서 작동하도록 하는 또 다른 아이디어를 제안합니다. 이는 사용자 코드도 이터레이터를 복사할지, 리스트로 만들지, 보조 디스크 파일을 사용할지 결정하는 데 활용할 수 있습니다.</p>

<p>핵심 고려 사항은 시퀀스 위에 내장 함수 <code class="language-plaintext highlighter-rouge">iter</code>가 만드는 이터레이터와 같은 일부 중요한 이터레이터는 본질적으로 복사하기 쉽다는 것입니다. 단순히 동일한 시퀀스에 대한 다른 참조와 정수 인덱스의 복사본을 얻으면 됩니다. 그러나 Python 2.3에서는 이러한 이터레이터가 상태를 노출하지 않으며 <code class="language-plaintext highlighter-rouge">copy.copy</code>를 지원하지 않습니다.</p>

<p>따라서 이 PEP의 목적은 이러한 이터레이터 유형이 적절한 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 노출하도록 하는 것입니다. 마찬가지로, 독립적인 이터레이션에 적합하고 시간 및 공간 비용이 제한적인 인스턴스 복사본을 제공할 수 있는 사용자 정의 이터레이터 유형도 적절한 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 노출해야 합니다. <code class="language-plaintext highlighter-rouge">copy.copy</code>는 타입이 인스턴스 복사 방식을 제어하는 다른 방법도 지원하지만, 단순화를 위해 복사를 지원하는 이터레이터 타입은 항상 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 노출하는 방식으로만 이를 수행하도록 제안됩니다.</p>

<p>이터레이터가 가능한 경우 적절한 <code class="language-plaintext highlighter-rouge">__copy__</code>를 노출하면 <code class="language-plaintext highlighter-rouge">itertools.tee</code> 및 유사한 사용자 코드의 쉬운 최적화를 가능하게 합니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tee</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nf">iter</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">copier</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">__copy__</span>
    <span class="k">except</span> <span class="nb">AttributeError</span><span class="p">:</span>
        <span class="c1"># 복사 불가능한 이터레이터, 필요한 모든 어려운 작업 수행
</span>        <span class="c1"># [생략!]
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">it</span><span class="p">,</span> <span class="nf">copier</span><span class="p">()</span>
</code></pre></div></div>
<p>이 함수는 <code class="language-plaintext highlighter-rouge">copy.copy(it)</code>를 호출하지 않습니다. 이는 이 PEP가 구현된 후에도 일부 사용자 정의 클래스로 구현된 이터레이터 유형에 대해 “단순히 성공할 수도” 있지만, 실제로 적절한 “독립적으로 이터레이션 가능한” 복사 객체를 결과로 제공하지 않을 수 있기 때문입니다.</p>

<h2 id="명세-specification">명세 (Specification)</h2>

<p>모든 이터레이터 타입 <code class="language-plaintext highlighter-rouge">X</code>는 <code class="language-plaintext highlighter-rouge">X</code>의 어떤 인스턴스 <code class="language-plaintext highlighter-rouge">x</code>에 대해서도 인자 없이 호출할 수 있는 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 노출할 수 있습니다. 이 메서드는 이터레이터 타입이 합리적으로 적은 계산 및 메모리 노력으로 복사 가능성을 제공할 수 있는 경우에만 노출되어야 합니다. 또한, <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드가 반환하는 새 객체 <code class="language-plaintext highlighter-rouge">y</code>는 <code class="language-plaintext highlighter-rouge">x</code>와 독립적이고 별도로 이터레이션되며, 동일한 “기본 시퀀스” 항목을 따라 진행하는 <code class="language-plaintext highlighter-rouge">X</code>의 새 인스턴스여야 합니다.</p>

<p>예를 들어, <code class="language-plaintext highlighter-rouge">Iter</code> 클래스가 시퀀스에 대한 내장 <code class="language-plaintext highlighter-rouge">iter</code>의 기능을 본질적으로 복제한다고 가정합니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Iter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span>
        <span class="n">self</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">index</span><span class="p">]</span>
        <span class="k">except</span> <span class="nb">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">StopIteration</span>
        <span class="n">self</span><span class="p">.</span><span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>
<p>이 <code class="language-plaintext highlighter-rouge">Iter</code> 클래스를 이 PEP에 부합하도록 만들려면, <code class="language-plaintext highlighter-rouge">Iter</code> 클래스 본문에 다음 추가가면 충분합니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">__class__</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">sequence</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">index</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>
<p>이 경우 <code class="language-plaintext highlighter-rouge">__copy__</code>는 시퀀스를 복사하려고 시도하지 않습니다. 원본 또는 복사된 이터레이터 중 하나 또는 둘 다 시퀀스를 진행하는 동안 시퀀스가 변경되면 이터레이션 동작이 잘못될 가능성이 높습니다. 이는 변경 가능한 시퀀스를 이터레이션하는 이터레이터의 일반적인 Python 동작을 변경하는 것은 <code class="language-plaintext highlighter-rouge">__copy__</code>의 책임이 아닙니다 (이는 이터레이터의 <code class="language-plaintext highlighter-rouge">__deepcopy__</code> 메서드에 대한 명세일 수 있지만, 이 PEP는 이를 다루지 않습니다).</p>

<p>또한, 주어진 인수로 호출된 임의 인스턴스의 특정 메서드로부터 무한한 결과 시퀀스를 제공하는 “랜덤 이터레이터”를 고려해 보십시오:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">RandomIterator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">bound_method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">call</span> <span class="o">=</span> <span class="n">bound_method</span>
        <span class="n">self</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">args</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">new</span>
        <span class="n">im_self</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">call</span><span class="p">.</span><span class="n">im_self</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">new</span><span class="p">.</span><span class="nf">instancemethod</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">call</span><span class="p">.</span><span class="n">im_func</span><span class="p">,</span> <span class="n">im_self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">__class__</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">args</span><span class="p">)</span>
</code></pre></div></div>
<p>이 이터레이터 유형은 이름이 의미하는 것보다 약간 더 일반적입니다. <code class="language-plaintext highlighter-rouge">im_self</code>를 복사하기 위해 <code class="language-plaintext highlighter-rouge">copy.copy</code>를 사용해야 합니다. <code class="language-plaintext highlighter-rouge">random.Random</code> 인스턴스는 <code class="language-plaintext highlighter-rouge">__getstate__</code> 및 <code class="language-plaintext highlighter-rouge">__setstate__</code>를 통해 복사를 지원하며, <code class="language-plaintext highlighter-rouge">__copy__</code>를 통하지 않습니다. <code class="language-plaintext highlighter-rouge">copy.copy</code>를 사용하는 것이 객체의 얕은 복사본을 얻는 일반적인 방법입니다.</p>

<h2 id="세부-사항-details">세부 사항 (Details)</h2>

<p>사용자 정의 이터레이터 타입이 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 지원하도록 권장하는 것 외에도 (메모리 및 런타임 비용이 적고 독립적으로 이터레이션 가능한 이터레이터 객체의 복사본을 생성할 수 있는 경우에만), 이 PEP의 구현은 특히 내장 <code class="language-plaintext highlighter-rouge">iter</code>가 반환하는 시퀀스 이터레이터와 내장 <code class="language-plaintext highlighter-rouge">dict</code> 타입의 <code class="language-plaintext highlighter-rouge">__iter__</code>, <code class="language-plaintext highlighter-rouge">iterkeys</code>, <code class="language-plaintext highlighter-rouge">itervalues</code>, <code class="language-plaintext highlighter-rouge">iteritems</code> 메서드가 반환하는 딕셔너리 이터레이터에 복사 가능성을 추가하는 것을 포함할 것입니다.</p>

<p>제너레이터 함수에 의해 생성된 이터레이터는 복사할 수 없습니다. 그러나 Python 2.4의 새 “제너레이터 표현식” (PEP 289)에 의해 생성된 이터레이터는 기본 이터레이터가 복사 가능한 경우 복사 가능해야 합니다. 제너레이터 표현식에 가능한 엄격한 제한은 제너레이터의 훨씬 더 넓은 일반성에 비해 이를 실현 가능하게 만들어야 합니다. 마찬가지로 내장 함수 <code class="language-plaintext highlighter-rouge">enumerate</code> 및 <code class="language-plaintext highlighter-rouge">itertools</code> 모듈에서 제공하는 특정 함수에 의해 생성된 이터레이터는 기본 이터레이터가 복사 가능한 경우 복사 가능해야 합니다.</p>

<p>이 PEP의 구현은 또한 동기 섹션에서 언급된 새로운 <code class="language-plaintext highlighter-rouge">itertools.tee</code> 함수의 최적화를 포함할 것입니다.</p>

<h2 id="이론적-근거-rationale">이론적 근거 (Rationale)</h2>

<p>이터레이터의 (얕은) 복사에 대한 주요 사용 사례는 <code class="language-plaintext highlighter-rouge">itertools.tee</code> (2.4에 새로 추가됨) 함수와 동일합니다. 사용자 코드는 이터레이터를 직접 복사하려고 시도하지 않을 것입니다. 왜냐하면 복사 불가능한 경우를 별도로 처리해야 하기 때문입니다. <code class="language-plaintext highlighter-rouge">itertools.tee</code>를 호출하면 적절한 경우 내부적으로 복사를 수행하고, 복사 불가능한 이터레이터에 대해서는 암시적으로 최대한 효율적인 비복사 전략으로 대체됩니다. (때때로 사용자 코드는 다른 전략, 예를 들어 리스트를 만들거나 시퀀스를 디스크에 저장하는 것과 같은 방식으로 복사 불가능한 이터레이터를 처리하기 위해 더 직접적인 제어를 원할 수도 있습니다).</p>

<p>“tee”된 이터레이터는 “참조 지점” 역할을 하여 시퀀스 처리가 알려진 지점에서 계속되거나 재개될 수 있도록 하는 동시에, 다른 독립적인 이터레이터는 필요에 따라 시퀀스의 더 먼 부분을 “탐색”하기 위해 자유롭게 진행될 수 있습니다. 간단한 예: 숫자의 이터레이터 (양수라고 가정)를 받아서, 입력 이터레이터의 각 항목에 해당하는 총합의 분수 값을 반환하는 제너레이터 함수입니다. 호출자는 총합을 미리 알고 있다면 값으로 전달할 수 있습니다. 그렇지 않으면 이 제너레이터 함수를 호출하여 반환된 이터레이터는 먼저 총합을 계산합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fractions</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">total</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">numbers</span><span class="p">,</span> <span class="n">aux</span> <span class="o">=</span> <span class="n">itertools</span><span class="p">.</span><span class="nf">tee</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">item</span> <span class="o">/</span> <span class="n">total</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">numbers</code> 이터레이터를 “tee”할 수 있는 기능은, <code class="language-plaintext highlighter-rouge">numbers</code> 이터레이터가 복사 가능한 경우, 필요한 경우 총합을 미리 계산하는 데 <code class="language-plaintext highlighter-rouge">O(N)</code> 보조 메모리를 반드시 요구하지 않으면서 이 제너레이터가 작동하도록 합니다.</p>

<p>“이터레이터 북마킹”의 또 다른 예로, 가끔 “후위 연산자” 역할을 하는 문자열이 포함된 숫자 스트림을 생각해 봅시다. 가장 흔한 연산자는 <code class="language-plaintext highlighter-rouge">'+'</code>이며, 이 경우 이전의 모든 숫자 (이전 연산자가 있었다면 그 이후, 아니면 처음부터)를 합산하여 결과를 yield 해야 합니다. 때때로 <code class="language-plaintext highlighter-rouge">'*'</code>를 발견할 수도 있는데, 이는 이전 숫자를 합산하는 대신 곱해야 한다는 점만 다릅니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">filter_weird_stream</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nf">iter</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">it</span><span class="p">,</span> <span class="n">bookmark</span> <span class="o">=</span> <span class="n">itertools</span><span class="p">.</span><span class="nf">tee</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="sh">'</span><span class="s">+</span><span class="sh">'</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">total</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">item</span> <span class="o">==</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span>
                <span class="n">product</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">bookmark</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">product</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">product</span> <span class="o">*=</span> <span class="n">item</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># bookmark loop did not break
</span>                    <span class="k">yield</span> <span class="n">product</span> <span class="c1"># yield final product if no more '*'
</span>                <span class="k">break</span> <span class="c1"># break from outer loop after '*' is handled
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">item</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># it loop did not break
</span>            <span class="c1"># Reached end of stream, yield final total if no operator
</span>            <span class="c1"># This part needs careful handling based on exact requirements.
</span>            <span class="c1"># For simplicity, let's assume stream always ends with an operator or is empty.
</span>            <span class="k">if</span> <span class="n">total</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># If there were numbers before EOF and no operator
</span>                <span class="k">yield</span> <span class="n">total</span>
            <span class="k">raise</span> <span class="nb">StopIteration</span>
</code></pre></div></div>
<p><strong>참고:</strong> 위의 <code class="language-plaintext highlighter-rouge">filter_weird_stream</code> 예제는 원본 PEP의 코드와 약간 다르게 해석될 수 있습니다. 특히 <code class="language-plaintext highlighter-rouge">else</code> 블록의 처리는 상황에 따라 다르게 구현될 수 있습니다. PEP의 예제는 <code class="language-plaintext highlighter-rouge">'*'</code> 연산자 후 <code class="language-plaintext highlighter-rouge">it</code>가 소비되는 것을 보여주며, <code class="language-plaintext highlighter-rouge">bookmark</code>는 그 지점부터 다시 시작합니다. 원본 코드를 그대로 옮기기보다는 핵심 개념을 설명하는 데 집중했습니다.</p>

<p><code class="language-plaintext highlighter-rouge">itertools.tee</code>의 유사한 사용 사례는 이터레이터로 표현된 명령 스트림에 대한 “실행 취소”, 토큰 스트림 파싱에 대한 “백트래킹” 등과 같은 작업을 지원할 수 있습니다. (물론, 각 경우에 작업의 세부 사항에 따라 단일 이터레이터로 시퀀스를 진행하는 동안 시퀀스의 관련 부분을 리스트에 저장하는 것과 같은 더 간단한 가능성도 고려해야 합니다).</p>

<p>다음은 기본 이터레이터가 <code class="language-plaintext highlighter-rouge">__copy__</code>를 지원하는 경우 내장 <code class="language-plaintext highlighter-rouge">enumerate</code>가 <code class="language-plaintext highlighter-rouge">__copy__</code>를 지원하도록 확장될 수 있는 방법에 대한 순수 Python 예제입니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">enumerate</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">it</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">it</span> <span class="o">=</span> <span class="nf">iter</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">i</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">it</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="nf">__new__</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">__class__</span><span class="p">)</span> <span class="c1"># Use __new__ with class argument
</span>        <span class="n">result</span><span class="p">.</span><span class="n">it</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">it</span><span class="p">.</span><span class="nf">__copy__</span><span class="p">()</span>
        <span class="n">result</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">i</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>
<p><strong>참고:</strong> <code class="language-plaintext highlighter-rouge">__new__</code> 호출 방식은 Python 2.x와 3.x에서 약간 다를 수 있습니다. 위 코드는 Python 2.x 스타일을 따릅니다.</p>

<p>다음은 이터레이터의 “우발적인 복사 가능성”으로 인해 발생하는 “취약성”의 한 예입니다. 즉, <code class="language-plaintext highlighter-rouge">copy.copy</code>가 성공하더라도 결과로 원본과 독립적으로 이터레이션할 수 있는 이터레이터를 받을 것이라고 기대해서는 안 됩니다. 다음은 간단한 중첩 리스트인 “트리”를 (선위 순서로) 이터레이션하는 이터레이터 클래스입니다. 리스트인 항목은 하위 트리로, 다른 항목은 리프로 처리됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListreeIter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">indx</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span>
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">indx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">StopIteration</span>
        <span class="n">self</span><span class="p">.</span><span class="n">indx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">self</span><span class="p">.</span><span class="n">indx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">except</span> <span class="nb">IndexError</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="n">self</span><span class="p">.</span><span class="n">indx</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
        <span class="k">if</span> <span class="nf">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">indx</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
</code></pre></div></div>
<p>다음 코드는 의도한 대로 작동하지 않습니다. <code class="language-plaintext highlighter-rouge">copy.copy</code>가 수행하는 우발적인 복사가 “인덱스” 리스트인 변경 가능한 속성 <code class="language-plaintext highlighter-rouge">it.indx</code>를 복제하는 대신 공유하기 때문에, <code class="language-plaintext highlighter-rouge">cop</code> 이터레이터는 원본 <code class="language-plaintext highlighter-rouge">it</code> 이터레이터가 진행됨에 따라 단계별로 소모되고 고갈됩니다. 따라서 이 이터레이터의 “클라이언트 코드”는 시퀀스의 일부를 이터레이터를 <code class="language-plaintext highlighter-rouge">copy.copy</code>하여 두 번 이터레이션하려고 시도하지만, 이는 올바르지 않습니다.</p>

<p>올바른 해결책 중 하나는 <code class="language-plaintext highlighter-rouge">itertools.tee</code>를 사용하는 것입니다. 즉, 첫 번째 <code class="language-plaintext highlighter-rouge">for</code> 루프를 다음과 같이 변경합니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">it</span><span class="p">,</span> <span class="n">cop</span> <span class="o">=</span> <span class="n">itertools</span><span class="p">.</span><span class="nf">tee</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
        <span class="k">break</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
</code></pre></div></div>
<p>(이 루프를 두 부분으로 나누어야 합니다. 그렇지 않으면 <code class="language-plaintext highlighter-rouge">tee()</code> 호출 후 더 이상 사용해서는 안 되는 <code class="language-plaintext highlighter-rouge">it</code>의 원래 값에서 계속 루프를 돌게 됩니다!) 또는 리스트를 만듭니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">cop</span> <span class="o">=</span> <span class="n">lit</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
        <span class="k">break</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lit</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
</code></pre></div></div>
<p>(다시, <code class="language-plaintext highlighter-rouge">list(it)</code> 호출에 의해 이터레이터 <code class="language-plaintext highlighter-rouge">it</code>가 소진되므로 루프를 두 부분으로 나누어야 합니다).</p>

<p>마지막으로, 이 PEP가 권장하는 대로 <code class="language-plaintext highlighter-rouge">ListreeIter</code>가 적절한 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 제공한다면 이 모든 해결책이 작동할 것입니다:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">__class__</span><span class="p">.</span><span class="nf">__new__</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">__class__</span><span class="p">)</span> <span class="c1"># Use __new__ with class argument
</span>        <span class="n">result</span><span class="p">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="n">indx</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">indx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>
<p>복사본을 “더 깊이” 만들 필요는 없지만, 두 개의 변경 가능한 “인덱스 상태” 속성은 “적절한” (독립적으로 이터레이션 가능한) 이터레이터 복사본을 얻기 위해 실제로 복사되어야 합니다.</p>

<p>권장되는 해결책은 <code class="language-plaintext highlighter-rouge">ListreeIter</code> 클래스가 이 <code class="language-plaintext highlighter-rouge">__copy__</code> 메서드를 제공하고 클라이언트 코드가 <code class="language-plaintext highlighter-rouge">itertools.tee</code>를 사용하는 것입니다 (위에서 보여준 두 부분으로 나뉜 루프와 함께). 이렇게 하면 클라이언트 코드가 사용할 수 있는 다양한 이터레이터 유형에 대해 최대한 관용적이며, 동시에 이 특정 이터레이터 유형의 “tee”ing에 대해 좋은 성능을 달성할 수 있습니다.</p>

<h2 id="참조-references">참조 (References)</h2>

<ul>
  <li>python-dev 토론 시작 게시물: <a href="https://mail.python.org/pipermail/python-dev/2003-October/038969.html">https://mail.python.org/pipermail/python-dev/2003-October/038969.html</a></li>
  <li>표준 라이브러리의 <code class="language-plaintext highlighter-rouge">copy</code> 모듈 온라인 문서: <a href="https://docs.python.org/release/2.6/library/copy.html">https://docs.python.org/release/2.6/library/copy.html</a></li>
</ul>

<h2 id="저작권-copyright">저작권 (Copyright)</h2>

<p>이 문서는 공개 도메인에 배치되었습니다.</p>

<blockquote>
  <p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/tags/#python" class="page__taxonomy-item" rel="tag">Python</a><span class="sep">, </span>
    
      <a href="/tags/#translation" class="page__taxonomy-item" rel="tag">Translation</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/categories/#python" class="page__taxonomy-item" rel="tag">Python</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2025-09-26">September 26, 2025</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/python/pep/322/" class="pagination--pager" title="[Final] PEP 322 - Reverse Iteration
">Previous</a>
    
    
      <a href="/python/pep/324/" class="pagination--pager" title="[Final] PEP 324 - subprocess - New process module
">Next</a>
    
  </nav>


    </div>

    
  </article>

</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 secrett2633. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'secrett2633/secrett2633.github.io');
    script.setAttribute('issue-term', 'pathname');
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





  </body>
</html>
