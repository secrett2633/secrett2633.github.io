<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <style> 
      ::-webkit-scrollbar{ 
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-track {
        width: 0px;
        background-color: #626262;
        /* border-radius: 5px; */
      }

      ::-webkit-scrollbar-thumb {
        width: 0px;
        background-color: #E2E2E2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-thumb:hover {
        width: 10px;
        height: 20px;
        /* background-color: rgba(190, 190, 190, 0.2); */
        background-color: #A2A2A2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-track:hover {
        width: 10px;
        /* background-color: rgba(150, 150, 150, 0.1); */
        background-color: #626262;
        border-radius: 5px;
        /* background: transparent; */
        /* border-radius: 10px; */
      }

      ::-webkit-scrollbar-button:start:decrement,::-webkit-scrollbar-button:end:increment {
          width:0px;
          height: 0px;
          /* background-color: rgb(14, 221, 24); */
          /* border-radius: 50%; */
      }
    </style>
    
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[Withdrawn] PEP 555 - Context-local variables (contextvars) | secrett2633</title>
<meta name="description" content="Python Enhancement Proposal 555: ‘Context-local variables (contextvars)’에 대한 한국어 번역입니다.">


  <meta name="author" content="secrett2633">
  
  <meta property="article:author" content="secrett2633">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="secrett2633's blog">
<meta property="og:title" content="[Withdrawn] PEP 555 - Context-local variables (contextvars)">
<meta property="og:url" content="http://localhost:4000/python/pep/555/">


  <meta property="og:description" content="Python Enhancement Proposal 555: ‘Context-local variables (contextvars)’에 대한 한국어 번역입니다.">







  <meta property="article:published_time" content="2025-09-26T23:40:56+09:00">



  <meta property="article:modified_time" content="2025-09-26T23:40:56+09:00">



  

  


<link rel="canonical" href="http://localhost:4000/python/pep/555/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "secrett2633",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="secrett2633's blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->


    <link rel="icon" type="image/png" sizes="32x32" href="https://secrett2633.github.io/assets/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://secrett2633.github.io/assets/images/favicon/favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          secrett2633's blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://github.com/secrett2633">GitHub</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <!-- 2022.02.17 author content hidden -->
  <!-- <div class="author__content">
    
      <h3 class="author__name" itemprop="name">secrett2633</h3>
    
    
  </div> -->

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">Backend</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/backend/django/">Django</a></li>
          
            <li><a href="/backend/logging/">Logging</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">Python</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/python/pep/">PEP</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">AI/ML</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/ai/llm/">LLM</a></li>
          
            <li><a href="/ai/review/">Review</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">DevOps</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/devops/nginx/">Nginx</a></li>
          
            <li><a href="/devops/docker/">Docker</a></li>
          
            <li><a href="/devops/safeline/">SafeLine</a></li>
          
            <li><a href="/devops/jenkins/">Jenkins</a></li>
          
            <li><a href="/devops/github-actions/">GitHub Actions</a></li>
          
            <li><a href="/devops/aws/">AWS</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">etc</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/etc/me/">Me</a></li>
          
            <li><a href="/etc/chrome-extension/">Chrome Extension</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[Withdrawn] PEP 555 - Context-local variables (contextvars)">
    <meta itemprop="description" content="Python Enhancement Proposal 555: ‘Context-local variables (contextvars)’에 대한 한국어 번역입니다.">
    <meta itemprop="datePublished" content="2025-09-26T23:40:56+09:00">
    <meta itemprop="dateModified" content="2025-09-26T23:40:56+09:00">

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">[Withdrawn] PEP 555 - Context-local variables (contextvars)
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2025-09-26T23:40:56+09:00">September 26, 2025</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#pep-555-context-local-variables-contextvars-컨텍스트-로컬-변수">PEP 555: Context-local variables (contextvars) (컨텍스트-로컬 변수)</a><ul><li><a href="#개요-abstract">개요 (Abstract)</a></li><li><a href="#배경-rationale">배경 (Rationale)</a></li><li><a href="#제안-proposal">제안 (Proposal)</a><ul><li><a href="#의미론-및-고수준-api-semantics-and-higher-level-api">의미론 및 고수준 API (Semantics and higher-level API)</a><ul><li><a href="#핵심-개념-core-concept">핵심 개념 (Core concept)</a></li><li><a href="#서브루틴으로-리팩토링-refactoring-into-subroutines">서브루틴으로 리팩토링 (Refactoring into subroutines)</a></li><li><a href="#제너레이터-및-제너레이터-기반-코루틴의-의미론-semantics-for-generators-and-generator-based-coroutines">제너레이터 및 제너레이터 기반 코루틴의 의미론 (Semantics for generators and generator-based coroutines)</a></li></ul></li><li><a href="#프레임워크-작성자를-위한-특별-기능-special-functionality-for-framework-authors">프레임워크 작성자를 위한 특별 기능 (Special functionality for framework authors)</a><ul><li><a href="#leaking_yields-유출되는-yield">leaking_yields (유출되는 yield)</a></li><li><a href="#contextvar-할당-캡처-capturing-contextvar-assignments">contextvar 할당 캡처 (Capturing contextvar assignments)</a></li><li><a href="#컨텍스트-상태의-스냅샷-가져오기-getting-a-snapshot-of-context-state">컨텍스트 상태의 스냅샷 가져오기 (Getting a snapshot of context state)</a></li><li><a href="#클린-상태에서-코드-실행-running-code-in-a-clean-state">클린 상태에서 코드 실행 (Running code in a clean state)</a></li></ul></li></ul></li><li><a href="#구현-implementation">구현 (Implementation)</a><ul><li><a href="#핵심-개념의-데이터-구조-및-구현-data-structures-and-implementation-of-the-core-concept">핵심 개념의 데이터 구조 및 구현 (Data structures and implementation of the core concept)</a></li><li><a href="#제너레이터-및-코루틴-의미론의-구현-implementation-of-generator-and-coroutine-semantics">제너레이터 및 코루틴 의미론의 구현 (Implementation of generator and coroutine semantics)</a></li></ul></li><li><a href="#하위-호환성-backwards-compatibility">하위 호환성 (Backwards compatibility)</a></li><li><a href="#미해결-문제-open-issues">미해결 문제 (Open Issues)</a><ul><li><a href="#순서가-뒤바뀐-해제-out-of-order-de-assignments">순서가 뒤바뀐 해제 (Out-of-order de-assignments)</a></li></ul></li><li><a href="#거부된-아이디어-rejected-ideas">거부된 아이디어 (Rejected Ideas)</a><ul><li><a href="#서브루틴-스코프에-연결된-동적-스코핑-dynamic-scoping-linked-to-subroutine-scopes">서브루틴 스코프에 연결된 동적 스코핑 (Dynamic scoping linked to subroutine scopes)</a></li></ul></li></ul></li></ul>

            </nav>
          </aside>
        
        <blockquote>
  <p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0555/">PEP 555 - Context-local variables (contextvars)</a></p>

  <table>
    <tbody>
      <tr>
        <td><strong>상태:</strong> Withdrawn</td>
        <td><strong>유형:</strong> Standards Track</td>
        <td><strong>작성일:</strong> 06-Sep-2017</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h1 id="pep-555-context-local-variables-contextvars-컨텍스트-로컬-변수">PEP 555: Context-local variables (contextvars) (컨텍스트-로컬 변수)</h1>

<ul>
  <li><strong>작성자</strong>: Koos Zevenhoven</li>
  <li><strong>상태</strong>: 철회됨 (Withdrawn)</li>
  <li><strong>유형</strong>: 표준 트랙 (Standards Track)</li>
  <li><strong>생성일</strong>: 2017년 9월 6일</li>
  <li><strong>Python 버전</strong>: 3.7</li>
  <li><strong>사후 변경 이력</strong>: 2017년 9월 6일</li>
</ul>

<h2 id="개요-abstract">개요 (Abstract)</h2>

<p>특별한 경우에, 코드는 함수 호출 체인을 따라 하위 호출자(callees)에게 명시적으로 인자를 전달하지 않고도 정보를 전달하기를 원할 때가 있습니다. 이 제안은 특정 컨텍스트 변수(context variable)에 주어진 값이 할당된 컨텍스트 안팎으로 코드가 명시적으로 전환될 수 있도록 하는 구조를 설명합니다.</p>

<p>이것은 전통적인 단일 스레드(또는 스레드-안전하지 않은) 코드의 전역 변수(global variables)나 전통적인 동시성-안전하지 않은 코드(단일 또는 다중 스레드)의 스레드-로컬 저장소(thread-local storage)와 같은 것들의 일부 사용에 대한 현대적인 대안입니다. 특히, 제안된 메커니즘은 비동기적으로 실행되는 코루틴(coroutines)과 같은 최신 동시성 실행 메커니즘에서도 사용할 수 있으며, 이때 동시적으로 실행되는 호출 체인들이 서로의 컨텍스트에 간섭하지 않습니다.</p>

<p>“호출 체인”은 일반 함수, <code class="language-plaintext highlighter-rouge">await</code>된 코루틴, 또는 제너레이터(generators)로 구성될 수 있습니다. 컨텍스트 변수 스코프(scope)의 의미론은 모든 경우에 동일하며, 컨텍스트 변수의 의미론에 영향을 주지 않고 코드를 서브루틴(여기서는 함수, 하위 제너레이터 또는 하위 코루틴을 의미)으로 자유롭게 리팩토링(refactoring)할 수 있습니다. 구현과 관련하여, 이 제안은 CPython 인터프리터 및 다른 Python 인터프리터에 대한 단순성과 최소한의 변경을 목표로 합니다.</p>

<h2 id="배경-rationale">배경 (Rationale)</h2>

<p>이 제안에서 “호출 체인” 또는 “호출 트리”는 일반 함수 호출, <code class="language-plaintext highlighter-rouge">await</code> 또는 <code class="language-plaintext highlighter-rouge">yield from</code>을 사용하는 표현식 등 가능한 모든 조합을 사용하여 서브루틴이 체인(중첩)으로 실행되는 것을 의미합니다.</p>

<p>때때로 호출 체인을 따라 필요한 정보를 인자로 전달하는 것은 필요한 함수 시그니처(signature)를 상당히 복잡하게 만들거나, 실제로는 불가능할 수도 있습니다. 이러한 경우, 이 정보를 저장할 다른 장소를 찾을 수 있습니다. 몇 가지 역사적인 예시를 살펴보겠습니다.</p>

<p>가장 순진한(naive) 옵션은 값을 전역 변수(global variable) 또는 유사한 곳에 할당하여 호출 체인 아래의 코드가 접근할 수 있도록 하는 것입니다. 그러나 이는 코드를 즉시 스레드-안전하지 않게 만듭니다. 여러 스레드가 있을 때 모든 스레드가 동일한 전역 변수에 할당하며, 다른 스레드가 호출 체인의 어느 지점에서든 간섭할 수 있기 때문입니다.</p>

<p>약간 덜 순진한 옵션은 정보를 스레드-로컬 저장소(thread-local storage)에 스레드별(per-thread) 정보로 저장하는 것입니다. 여기서 각 스레드는 다른 스레드가 간섭할 수 없는 변수의 “자신만의 복사본”을 가집니다. 이것이 비록 이상적이지는 않지만, 많은 경우에 최선의 해결책이었습니다. 그러나 제너레이터와 코루틴 덕분에 호출 체인의 실행은 중단되었다가 재개될 수 있으며, 다른 컨텍스트의 코드가 동시적으로 실행될 수 있습니다. 따라서 스레드-로컬 저장소를 사용하는 것은 동시성-안전하지 않습니다(concurrency-unsafe). 다른 컨텍스트의 다른 호출 체인이 스레드-로컬 변수에 간섭할 수 있기 때문입니다.</p>

<p>이러한 문제점을 해결하기 위해 “동시성-로컬(concurrency-local)” 또는 “태스크-로컬(task-local) 저장소”와 같은 개념이 필요할 수 있습니다. 이는 비동기 실행 및 동시성을 위한 “스레드”와 유사한 개념으로, 실행 순서에 모호함 없이 순차적으로 실행될 것이 보장되는 가장 큰 코드 및 중첩 호출의 양으로 볼 수 있습니다. 이러한 동시성-로컬 변수에서는 다른 코드 경로가 백그라운드에서 값에 간섭하지 않고도 호출 체인을 따라 하위 호출자에게 정보를 전달할 수 있습니다.</p>

<p>그러나 전역 변수, 스레드-로컬 변수, 태스크-로컬 변수 모두 호출 체인을 따라 실행 컨텍스트 정보를 전달하는 목적으로 사용되도록 의도된 것은 아닙니다. 변수의 스코프는 프로그래머(일반적으로 라이브러리 작성자)에 의해 제어되어야 하며, 필요 이상으로 넓어서는 안 됩니다. 이 제안은 태스크-로컬 변수(및 전역 변수, 스레드-로컬 변수)가 이 제안이 의도하는 종류의 컨텍스트-바운드 정보 전달과는 무관하다고 주장합니다. 따라서 이 제안은 컨텍스트-로컬 변수(context-local variables, 또는 context variables, contextvars)의 의미론과 구현 개요를 설명합니다. 실제로, 이 PEP의 부작용으로 비동기 프레임워크는 제안된 기능을 사용하여 태스크-로컬 변수를 구현할 수 있습니다.</p>

<h2 id="제안-proposal">제안 (Proposal)</h2>

<p>제안된 의미론은 Python에서 이미 사용 가능한 어떤 것의 직접적인 확장이 아니므로, 이 제안은 먼저 비교적 높은 수준에서 의미론과 API 측면에서 설명됩니다. 특히, <code class="language-plaintext highlighter-rouge">with</code> 문(Python <code class="language-plaintext highlighter-rouge">with statements</code>)은 제안된 의미론과 잘 맞기 때문에 설명에 많이 사용됩니다. 그러나 기본 <code class="language-plaintext highlighter-rouge">__enter__</code> 및 <code class="language-plaintext highlighter-rouge">__exit__</code> 메서드는 저수준의 속도 최적화된 (C) API의 함수에 해당합니다.</p>

<h3 id="의미론-및-고수준-api-semantics-and-higher-level-api">의미론 및 고수준 API (Semantics and higher-level API)</h3>

<h4 id="핵심-개념-core-concept">핵심 개념 (Core concept)</h4>

<p>컨텍스트-로컬 변수는 <code class="language-plaintext highlighter-rouge">contextvars.Var</code>의 단일 인스턴스(예: <code class="language-plaintext highlighter-rouge">cvar</code>)로 표현됩니다. <code class="language-plaintext highlighter-rouge">cvar</code> 객체에 접근할 수 있는 모든 코드는 현재 컨텍스트에 대한 <code class="language-plaintext highlighter-rouge">cvar</code>의 값을 요청할 수 있습니다. 고수준 API에서 이 값은 <code class="language-plaintext highlighter-rouge">cvar.value</code> 속성으로 제공됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">contextvars</span>

<span class="n">cvar</span> <span class="o">=</span> <span class="n">contextvars</span><span class="p">.</span><span class="nc">Var</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="sh">"</span><span class="s">example context variable</span><span class="sh">"</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span> <span class="c1"># 기본값이 적용됩니다.
</span>
<span class="c1"># 이 컨텍스트에 대한 cvar 할당이 없으므로, cvar.value는 기본값을 반환합니다.
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">contextvars</code>에 새 값을 할당하는 것은 스코프(scope)를 매우 인식하는 방식으로 이루어집니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="n">new_value</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">new_value</span>
    <span class="c1"># 여기, 또는 여기에서 호출 체인 아래의 모든 코드는 다음을 봅니다:
</span>    <span class="c1"># cvar.value는 new_value입니다.
</span>    <span class="c1"># 중첩된 컨텍스트에서 다른 값이 할당되지 않는 한
</span>    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">new_value</span>
<span class="c1"># cvar에 대한 new_value 할당은 더 이상 보이지 않습니다.
</span><span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">cvar.assign(value)</code>는 다른 객체, 즉 <code class="language-plaintext highlighter-rouge">contextvars.Assignment(cvar, new_value)</code>를 반환합니다. 여기서 본질적인 부분은 컨텍스트 변수 할당(<code class="language-plaintext highlighter-rouge">Assignment.__enter__</code>)이 해제(<code class="language-plaintext highlighter-rouge">Assignment.__exit__</code>)와 짝을 이룬다는 것입니다. 이러한 연산은 할당된 값의 스코프 경계를 설정합니다.</p>

<p>동일한 컨텍스트 변수에 대한 할당은 중첩될 수 있으며, 더 좁은 컨텍스트에서 외부 할당을 재정의합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span>
<span class="k">with</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">outer</span><span class="sh">"</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">outer</span><span class="sh">"</span>
    <span class="k">with</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">inner</span><span class="sh">"</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">inner</span><span class="sh">"</span>
    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">outer</span><span class="sh">"</span>
<span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span>
</code></pre></div></div>

<p>또한 여러 변수가 서로 영향을 주지 않고 중첩 방식으로 할당될 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cvar1</span> <span class="o">=</span> <span class="n">contextvars</span><span class="p">.</span><span class="nc">Var</span><span class="p">()</span>
<span class="n">cvar2</span> <span class="o">=</span> <span class="n">contextvars</span><span class="p">.</span><span class="nc">Var</span><span class="p">()</span>

<span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span> <span class="c1"># 기본값은 None입니다.
</span><span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span>

<span class="k">with</span> <span class="n">cvar1</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">value1</span><span class="sh">"</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value1</span><span class="sh">"</span>
    <span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span>
    <span class="k">with</span> <span class="n">cvar2</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">value2</span><span class="sh">"</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value1</span><span class="sh">"</span>
        <span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value2</span><span class="sh">"</span>
    <span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value1</span><span class="sh">"</span>
    <span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span>
</code></pre></div></div>

<p>더 편리한 Python 구문으로는 다음과 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="n">cvar1</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">value1</span><span class="sh">"</span><span class="p">),</span> <span class="n">cvar2</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">value2</span><span class="sh">"</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value1</span><span class="sh">"</span>
    <span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value2</span><span class="sh">"</span>
</code></pre></div></div>

<p>다른 컨텍스트, 다른 스레드 또는 다른 동시적으로 실행되는 태스크(task)나 코드 경로에서는 컨텍스트 변수가 완전히 다른 상태를 가질 수 있습니다. 따라서 프로그래머는 현재 컨텍스트에 대해서만 걱정하면 됩니다.</p>

<h4 id="서브루틴으로-리팩토링-refactoring-into-subroutines">서브루틴으로 리팩토링 (Refactoring into subroutines)</h4>

<p><code class="language-plaintext highlighter-rouge">contextvars</code>를 사용하는 코드는 의미론에 영향을 주지 않고 서브루틴으로 리팩토링될 수 있습니다. 예를 들면 다음과 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assi</span> <span class="o">=</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">new_value</span><span class="sh">"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply</span><span class="p">():</span>
    <span class="n">assi</span><span class="p">.</span><span class="nf">__enter__</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span> <span class="c1"># 이 부분은 예시 코드의 오류로 보이며, 사실은 'new_value'여야 합니다.
</span><span class="nf">apply</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">new_value</span><span class="sh">"</span>
<span class="n">assi</span><span class="p">.</span><span class="nf">__exit__</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span>
</code></pre></div></div>

<p>비동기 컨텍스트(<code class="language-plaintext highlighter-rouge">await</code> 표현식이 사용되는 곳)에서도 유사하게 적용될 수 있습니다. 이제 서브루틴은 코루틴이 될 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assi</span> <span class="o">=</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">new_value</span><span class="sh">"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">apply</span><span class="p">():</span>
    <span class="n">assi</span><span class="p">.</span><span class="nf">__enter__</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span> <span class="c1"># 이 부분도 예시 코드의 오류로 보이며, 사실은 'new_value'여야 합니다.
</span><span class="k">await</span> <span class="nf">apply</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">new_value</span><span class="sh">"</span>
<span class="n">assi</span><span class="p">.</span><span class="nf">__exit__</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span>
</code></pre></div></div>

<p>서브루틴이 제너레이터인 경우:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">apply</span><span class="p">():</span>
    <span class="k">yield</span> <span class="n">assi</span><span class="p">.</span><span class="nf">__enter__</span><span class="p">()</span>
</code></pre></div></div>

<p>이는 <code class="language-plaintext highlighter-rouge">yield from apply()</code> 또는 <code class="language-plaintext highlighter-rouge">next</code>나 <code class="language-plaintext highlighter-rouge">.send</code> 호출을 사용하여 호출됩니다.</p>

<h4 id="제너레이터-및-제너레이터-기반-코루틴의-의미론-semantics-for-generators-and-generator-based-coroutines">제너레이터 및 제너레이터 기반 코루틴의 의미론 (Semantics for generators and generator-based coroutines)</h4>

<p>제너레이터, 코루틴, 비동기 제너레이터는 일반 함수와 매우 유사하게 서브루틴 역할을 합니다. 그러나 <code class="language-plaintext highlighter-rouge">yield</code> 표현식에 의해 중단될 수 있는 추가적인 가능성을 가집니다. 제너레이터 내에서 진입된 할당 컨텍스트는 일반적으로 <code class="language-plaintext highlighter-rouge">yield</code>를 넘어 보존됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">genfunc</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">new_value</span><span class="sh">"</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">new_value</span><span class="sh">"</span>
        <span class="k">yield</span>
        <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">new_value</span><span class="sh">"</span>

<span class="n">g</span> <span class="o">=</span> <span class="nf">genfunc</span><span class="p">()</span>
<span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># yield까지 실행
</span><span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span> <span class="c1"># 외부 컨텍스트에서는 기본값
</span><span class="k">with</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">another_value</span><span class="sh">"</span><span class="p">):</span>
    <span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># 제너레이터 내부에서는 여전히 "new_value"를 보고 yield 다음 코드를 실행
</span></code></pre></div></div>

<p>그러나 제너레이터에 보이는 외부 컨텍스트는 <code class="language-plaintext highlighter-rouge">yield</code>를 넘어 상태를 변경할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">genfunc</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value2</span><span class="sh">"</span> <span class="c1"># 첫 번째 yield 전에 외부 컨텍스트의 "value2"를 봅니다.
</span>    <span class="k">yield</span>
    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value1</span><span class="sh">"</span> <span class="c1"># 두 번째 yield 전에 외부 컨텍스트의 "value1"을 봅니다.
</span>    <span class="k">yield</span>
    <span class="k">with</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">value3</span><span class="sh">"</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value3</span><span class="sh">"</span> <span class="c1"># 내부에서 "value3"을 할당합니다.
</span>
<span class="k">with</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">value1</span><span class="sh">"</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="nf">genfunc</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">value2</span><span class="sh">"</span><span class="p">):</span>
        <span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># genfunc()의 첫 번째 부분 실행
</span>    <span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># genfunc()의 두 번째 부분 실행
</span>    <span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># genfunc()의 세 번째 부분 실행
</span><span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value1</span><span class="sh">"</span> <span class="c1"># 최종적으로 외부 컨텍스트는 "value1"로 돌아옵니다.
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">async def ... yield ...</code>로 정의된 비동기 제너레이터에도 유사한 의미론이 적용됩니다.</p>

<p>기본적으로 제너레이터 내에서 할당된 값은 <code class="language-plaintext highlighter-rouge">yield</code>를 통해 제너레이터를 구동하는 외부 코드로 유출되지 않습니다. 그러나 제너레이터가 <code class="language-plaintext highlighter-rouge">StopIteration</code> 또는 다른 예외로 종료된 후에는 제너레이터 내에서 진입되고 열려 있던 할당 컨텍스트가 제너레이터 외부에서 보이게 됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assi</span> <span class="o">=</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">new_value</span><span class="sh">"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">genfunc</span><span class="p">():</span>
    <span class="k">yield</span> <span class="n">assi</span><span class="p">.</span><span class="nf">__enter__</span><span class="p">()</span> <span class="c1"># __enter__는 yield 이후에 호출될 것입니다.
</span>    <span class="k">yield</span>

<span class="n">g</span> <span class="o">=</span> <span class="nf">genfunc</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span>
<span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># 첫 번째 yield까지 실행, 아직 __enter__()는 호출되지 않음
</span><span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span>
<span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># assi.__enter__()가 여기서 호출됩니다. 두 번째 yield까지 실행
</span><span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">new_value</span><span class="sh">"</span> <span class="c1"># 이제 외부에서 'new_value'를 봅니다.
</span><span class="n">assi</span><span class="p">.</span><span class="nf">__exit__</span><span class="p">()</span> <span class="c1"># 외부에서 직접 __exit__() 호출, 컨텍스트를 되돌립니다.
</span><span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">the default value</span><span class="sh">"</span>
</code></pre></div></div>

<h3 id="프레임워크-작성자를-위한-특별-기능-special-functionality-for-framework-authors">프레임워크 작성자를 위한 특별 기능 (Special functionality for framework authors)</h3>

<p><code class="language-plaintext highlighter-rouge">asyncio</code> 또는 서드파티 라이브러리와 같은 프레임워크는 Python 인터프리터에 의해 결정되지 않는 경우에 원하는 의미론을 달성하기 위해 <code class="language-plaintext highlighter-rouge">contextvars</code>의 추가 기능을 사용할 수 있습니다.</p>

<h4 id="leaking_yields-유출되는-yield"><code class="language-plaintext highlighter-rouge">leaking_yields</code> (유출되는 yield)</h4>

<p><code class="language-plaintext highlighter-rouge">contextvars.leaking_yields</code> 데코레이터를 사용하면 <code class="language-plaintext highlighter-rouge">yield</code> 표현식을 통해 컨텍스트가 제너레이터를 구동하는 외부 컨텍스트로 유출되도록 선택할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@contextvars.leaking_yields</span>
<span class="k">def</span> <span class="nf">genfunc</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">outer</span><span class="sh">"</span>
    <span class="k">with</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">inner</span><span class="sh">"</span><span class="p">):</span>
        <span class="k">yield</span>
        <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">inner</span><span class="sh">"</span>
    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">outer</span><span class="sh">"</span>

<span class="n">g</span> <span class="o">=</span> <span class="nf">genfunc</span><span class="p">()</span>
<span class="k">with</span> <span class="n">cvar</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">outer</span><span class="sh">"</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">outer</span><span class="sh">"</span>
    <span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># yield까지 실행, 내부 "inner"가 외부로 유출됩니다.
</span>    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">inner</span><span class="sh">"</span>
    <span class="nf">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="c1"># yield 이후 코드 실행, "inner" 컨텍스트를 빠져나오고 다시 "outer"가 유출됩니다.
</span>    <span class="k">assert</span> <span class="n">cvar</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">outer</span><span class="sh">"</span>
</code></pre></div></div>

<h4 id="contextvar-할당-캡처-capturing-contextvar-assignments"><code class="language-plaintext highlighter-rouge">contextvar</code> 할당 캡처 (Capturing contextvar assignments)</h4>

<p><code class="language-plaintext highlighter-rouge">contextvars.capture()</code>를 사용하면 코드 블록에 의해 진입된 할당 컨텍스트를 캡처할 수 있습니다. 코드 블록에 의해 적용된 변경 사항은 나중에 다른 컨텍스트에서도 되돌리고 다시 적용할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cvar1</span> <span class="o">=</span> <span class="n">contextvars</span><span class="p">.</span><span class="nc">Var</span><span class="p">()</span>
<span class="n">cvar2</span> <span class="o">=</span> <span class="n">contextvars</span><span class="p">.</span><span class="nc">Var</span><span class="p">()</span>

<span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span> <span class="c1"># 기본값
</span><span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span> <span class="c1"># 기본값
</span>
<span class="n">assi1</span> <span class="o">=</span> <span class="n">cvar1</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">value1_original</span><span class="sh">"</span><span class="p">)</span>
<span class="n">assi2</span> <span class="o">=</span> <span class="n">cvar1</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">value2_overridden</span><span class="sh">"</span><span class="p">)</span>

<span class="k">with</span> <span class="n">contextvars</span><span class="p">.</span><span class="nf">capture</span><span class="p">()</span> <span class="k">as</span> <span class="n">delta</span><span class="p">:</span>
    <span class="n">assi1</span><span class="p">.</span><span class="nf">__enter__</span><span class="p">()</span> <span class="c1"># cvar1 = "value1_original"
</span>    <span class="k">with</span> <span class="n">cvar2</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">not captured</span><span class="sh">"</span><span class="p">):</span> <span class="c1"># 이 할당은 capture() 블록 밖에서 이루어져 캡처되지 않습니다.
</span>        <span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">not captured</span><span class="sh">"</span>
    <span class="n">assi2</span><span class="p">.</span><span class="nf">__enter__</span><span class="p">()</span> <span class="c1"># cvar1 = "value2_overridden" (assi1 오버라이드)
</span>    <span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value2_overridden</span><span class="sh">"</span>

<span class="n">delta</span><span class="p">.</span><span class="nf">revert</span><span class="p">()</span> <span class="c1"># 캡처된 변경사항을 되돌립니다.
</span><span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span> <span class="c1"># "not captured"는 캡처되지 않았으므로 원래 상태
</span>
<span class="k">with</span> <span class="n">cvar1</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">some_other_value_1</span><span class="sh">"</span><span class="p">),</span> <span class="n">cvar2</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">some_other_value_2</span><span class="sh">"</span><span class="p">):</span>
    <span class="n">delta</span><span class="p">.</span><span class="nf">reapply</span><span class="p">()</span> <span class="c1"># 캡처된 변경사항을 다시 적용합니다.
</span>    <span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">value2_overridden</span><span class="sh">"</span> <span class="c1"># delta에 의해 다시 적용된 값
</span>    <span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">some_other_value_2</span><span class="sh">"</span> <span class="c1"># cvar2 할당은 캡처되지 않았고, 외부 with 블록의 영향을 받습니다.
</span></code></pre></div></div>

<p>그러나 <code class="language-plaintext highlighter-rouge">delta</code>의 내용에 해제(deassignments)가 포함되어 있다면 “delta”를 다시 적용하는 것이 불가능할 수 있습니다.</p>

<h4 id="컨텍스트-상태의-스냅샷-가져오기-getting-a-snapshot-of-context-state">컨텍스트 상태의 스냅샷 가져오기 (Getting a snapshot of context state)</h4>

<p><code class="language-plaintext highlighter-rouge">contextvars.get_local_state()</code> 함수는 함수가 호출된 컨텍스트에서 모든 컨텍스트-로컬 변수에 적용된 할당을 나타내는 객체를 반환합니다. 이는 실행 시작부터 모든 컨텍스트 변경 사항을 캡처하기 위해 <code class="language-plaintext highlighter-rouge">contextvars.capture()</code>를 사용하는 것과 동일하게 볼 수 있습니다. 반환된 객체는 위와 같이 <code class="language-plaintext highlighter-rouge">.revert()</code> 및 <code class="language-plaintext highlighter-rouge">.reapply()</code> 메서드를 지원합니다.</p>

<h4 id="클린-상태에서-코드-실행-running-code-in-a-clean-state">클린 상태에서 코드 실행 (Running code in a clean state)</h4>

<p>위의 기본 기능을 사용하여 적용된 모든 컨텍스트 변경 사항을 되돌릴 수 있지만, 클린 컨텍스트에서 코드 블록을 실행하는 더 편리한 방법이 제공됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="n">context_vars</span><span class="p">.</span><span class="nf">clean_context</span><span class="p">():</span>
    <span class="c1"># 여기서는 모든 컨텍스트 변수가 기본값으로 시작합니다.
</span>    <span class="c1"># 이 블록을 벗어나면, 상태는 with 블록 이전으로 돌아갑니다.
</span></code></pre></div></div>

<h2 id="구현-implementation">구현 (Implementation)</h2>

<p>이 섹션은 설명된 의미론이 어떻게 구현될 수 있는지 다양한 수준의 세부 사항으로 설명합니다. 현재는 단순성을 목표로 하지만 충분한 기능을 가진 구현이 설명됩니다.</p>

<h3 id="핵심-개념의-데이터-구조-및-구현-data-structures-and-implementation-of-the-core-concept">핵심 개념의 데이터 구조 및 구현 (Data structures and implementation of the core concept)</h3>

<p>Python 인터프리터의 각 스레드는 <code class="language-plaintext highlighter-rouge">contextvars.Assignment</code> 객체의 자체 스택을 유지하며, 각 객체는 연결 리스트(linked list)처럼 이전(외부) 할당에 대한 포인터(pointer)를 가집니다. 로컬 상태(<code class="language-plaintext highlighter-rouge">contextvars.get_local_state()</code>에 의해 반환됨)는 스택의 상단에 대한 참조와 스택 하단에 대한 포인터/약한 참조(weak reference)로 구성됩니다. 이는 효율적인 스택 조작을 가능하게 합니다. <code class="language-plaintext highlighter-rouge">contextvars.capture()</code>에 의해 생성된 객체는 유사하지만, 캡처 블록 시작 시점의 스택 상단을 가리키는 하단 참조와 함께 스택의 일부만 참조합니다.</p>

<p>이제 스택은 할당 <code class="language-plaintext highlighter-rouge">__enter__</code> 및 <code class="language-plaintext highlighter-rouge">__exit__</code> 메서드에 따라 진화합니다. 예를 들어:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cvar1</span> <span class="o">=</span> <span class="n">contextvars</span><span class="p">.</span><span class="nc">Var</span><span class="p">()</span>
<span class="n">cvar2</span> <span class="o">=</span> <span class="n">contextvars</span><span class="p">.</span><span class="nc">Var</span><span class="p">()</span>

<span class="c1"># 스택: []
</span><span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span>

<span class="k">with</span> <span class="n">cvar1</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">outer</span><span class="sh">"</span><span class="p">):</span>
    <span class="c1"># 스택: [Assignment(cvar1, "outer")]
</span>    <span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">outer</span><span class="sh">"</span>
    <span class="k">with</span> <span class="n">cvar1</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">inner</span><span class="sh">"</span><span class="p">):</span>
        <span class="c1"># 스택: [Assignment(cvar1, "outer"),
</span>        <span class="c1">#         Assignment(cvar1, "inner")]
</span>        <span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">inner</span><span class="sh">"</span>
        <span class="k">with</span> <span class="n">cvar2</span><span class="p">.</span><span class="nf">assign</span><span class="p">(</span><span class="sh">"</span><span class="s">hello</span><span class="sh">"</span><span class="p">):</span>
            <span class="c1"># 스택: [Assignment(cvar1, "outer"),
</span>            <span class="c1">#         Assignment(cvar1, "inner"),
</span>            <span class="c1">#         Assignment(cvar2, "hello")]
</span>            <span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">hello</span><span class="sh">"</span>
        <span class="c1"># 스택: [Assignment(cvar1, "outer"),
</span>        <span class="c1">#         Assignment(cvar1, "inner")]
</span>        <span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">inner</span><span class="sh">"</span>
        <span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span>
    <span class="c1"># 스택: [Assignment(cvar1, "outer")]
</span>    <span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="sh">"</span><span class="s">outer</span><span class="sh">"</span>
<span class="c1"># 스택: []
</span><span class="k">assert</span> <span class="n">cvar1</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="k">assert</span> <span class="n">cvar2</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">cvar1.value</code>를 사용하여 컨텍스트에서 값을 가져오는 것은 스택에서 <code class="language-plaintext highlighter-rouge">cvar1</code> 할당의 가장 위에 있는 항목을 찾아 해당 값을 반환하거나, 스택에서 할당을 찾지 못한 경우 기본값을 반환하는 방식으로 구현될 수 있습니다. 그러나 대부분의 경우 O(1) 연산으로 최적화될 수 있습니다. 스택을 검색하는 것만으로도 스택이 매우 커질 의도가 없기 때문에 합리적으로 빠를 수 있습니다.</p>

<h3 id="제너레이터-및-코루틴-의미론의-구현-implementation-of-generator-and-coroutine-semantics">제너레이터 및 코루틴 의미론의 구현 (Implementation of generator and coroutine semantics)</h3>

<p>제너레이터, 코루틴, 비동기 제너레이터 내에서는 할당 및 해제가 다른 곳과 정확히 동일한 방식으로 처리됩니다. 그러나 내장 제너레이터 메서드 <code class="language-plaintext highlighter-rouge">send</code>, <code class="language-plaintext highlighter-rouge">__next__</code>, <code class="language-plaintext highlighter-rouge">throw</code>, <code class="language-plaintext highlighter-rouge">close</code>에 일부 변경이 필요합니다. 다음은 제너레이터의 <code class="language-plaintext highlighter-rouge">send</code>에 필요한 변경 사항의 Python 등가물입니다 (여기서 <code class="language-plaintext highlighter-rouge">_old_send</code>는 Python 3.6의 동작을 참조합니다).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">gi_contextvars</span> <span class="ow">is</span> <span class="n">LEAK</span><span class="p">:</span> <span class="c1"># contextvars.leaking_yields로 데코레이트된 경우
</span>        <span class="c1"># yield를 통해 컨텍스트를 유출하기 위해 아무것도 할 필요가 없습니다 :)
</span>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">_old_send</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">contextvars</span><span class="p">.</span><span class="nf">capture</span><span class="p">()</span> <span class="k">as</span> <span class="n">delta</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">gi_contextvars</span><span class="p">:</span>
                <span class="c1"># 이전 반복에서 캡처된 내용이 0이 아닌 경우
</span>                <span class="n">self</span><span class="p">.</span><span class="n">gi_contextvars</span><span class="p">.</span><span class="nf">reapply</span><span class="p">()</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">_old_send</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">Exception</span><span class="p">:</span>
        <span class="k">raise</span> <span class="c1"># 호출 프레임으로 돌아갑니다 (예: StopIteration)
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 일시 중단(suspending) 중, 컨텍스트 변경 사항을 되돌리지만 나중에 사용하기 위해 저장합니다.
</span>        <span class="n">delta</span><span class="p">.</span><span class="nf">revert</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">gi_contextvars</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="k">return</span> <span class="n">ret</span>
</code></pre></div></div>

<p>다른 메서드에 대한 해당 수정 사항은 본질적으로 동일합니다. 이는 코루틴 및 비동기 제너레이터에도 동일하게 적용됩니다.</p>

<p><code class="language-plaintext highlighter-rouge">contextvars</code>를 사용하지 않는 코드의 경우, 추가 사항은 O(1)이며 본질적으로 몇 개의 포인터 비교로 줄어듭니다. <code class="language-plaintext highlighter-rouge">contextvars</code>를 사용하는 코드의 경우에도 대부분의 경우 추가 사항은 O(1)입니다.</p>

<h2 id="하위-호환성-backwards-compatibility">하위 호환성 (Backwards compatibility)</h2>

<p>완전히 새로운 기능이 제안되므로 직접적인 하위 호환성 문제는 없습니다.</p>

<p>그러나 스레드-로컬 저장소의 다양한 전통적인 사용법은 동시성-안전성을 위해 <code class="language-plaintext highlighter-rouge">contextvars</code>로의 원활한 전환이 필요할 수 있습니다. 이를 위한 몇 가지 접근 방식이 있으며, 비동기 프레임워크의 약간의 도움으로 태스크-로컬 저장소를 에뮬레이트(emulate)하는 것을 포함합니다. 원하는 의미론이 프레임워크의 설계에 따라 달라질 수 있으므로 완전히 일반적인 구현은 제공될 수 없습니다.</p>

<p>전환을 처리하는 또 다른 방법은 코드가 먼저 <code class="language-plaintext highlighter-rouge">contextvars</code>를 사용하여 생성된 컨텍스트를 찾는 것입니다. 새 스타일 컨텍스트가 설정되지 않았거나 코드가 이전 Python 버전에서 실행되어 실패하는 경우, 스레드-로컬 저장소로 폴백(fallback)됩니다.</p>

<h2 id="미해결-문제-open-issues">미해결 문제 (Open Issues)</h2>

<h3 id="순서가-뒤바뀐-해제-out-of-order-de-assignments">순서가 뒤바뀐 해제 (Out-of-order de-assignments)</h3>

<p>이 제안에서 모든 변수 해제는 이전 할당과 반대 순서로 이루어집니다. 이는 두 가지 유용한 속성을 가집니다: <code class="language-plaintext highlighter-rouge">with</code> 문을 사용하여 할당 스코프를 정의하도록 권장하고 오류를 조기에 포착하는 경향이 있습니다 (<code class="language-plaintext highlighter-rouge">.__exit__()</code> 호출을 잊으면 의미 있는 오류가 발생하는 경우가 많습니다). 이를 요구 사항으로 두는 것은 구현 단순성과 성능 면에서도 유리합니다. 그럼에도 불구하고, 순서가 뒤바뀐 컨텍스트 종료를 허용하는 것이 전적으로 불가능한 것은 아니며, 이를 위한 합리적인 구현 전략도 존재합니다.</p>

<h2 id="거부된-아이디어-rejected-ideas">거부된 아이디어 (Rejected Ideas)</h2>

<h3 id="서브루틴-스코프에-연결된-동적-스코핑-dynamic-scoping-linked-to-subroutine-scopes">서브루틴 스코프에 연결된 동적 스코핑 (Dynamic scoping linked to subroutine scopes)</h3>

<p>값 가시성(value visibility)의 스코프는 코드가 서브루틴으로 리팩토링되는 방식에 의해 결정되어서는 안 됩니다. 할당 스코프를 변수별로 제어하는 것이 필요합니다.</p>

<hr />
<p><strong>참고:</strong> 이 PEP 555는 “철회됨(Withdrawn)” 상태입니다. 이는 제안이 더 이상 활발하게 개발되거나 Python에 포함될 것으로 예상되지 않는다는 의미입니다. 하지만, <code class="language-plaintext highlighter-rouge">contextvars</code> 모듈은 이후 PEP 567: Context Variables 에 의해 Python 3.7에 도입되었으며, PEP 555의 아이디어는 <code class="language-plaintext highlighter-rouge">contextvars</code> 모듈의 기반이 되었습니다. PEP 567은 PEP 555를 기반으로 하고 있지만, 이 문서 자체는 철회된 것으로 명시되어 있습니다.</p>

<blockquote>
  <p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/tags/#python" class="page__taxonomy-item" rel="tag">Python</a><span class="sep">, </span>
    
      <a href="/tags/#translation" class="page__taxonomy-item" rel="tag">Translation</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/categories/#python" class="page__taxonomy-item" rel="tag">Python</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2025-09-26">September 26, 2025</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/python/pep/554/" class="pagination--pager" title="[Superseded] PEP 554 - Multiple Interpreters in the Stdlib
">Previous</a>
    
    
      <a href="/python/pep/556/" class="pagination--pager" title="[Deferred] PEP 556 - Threaded garbage collection
">Next</a>
    
  </nav>


    </div>

    
  </article>

</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 secrett2633. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'secrett2633/secrett2633.github.io');
    script.setAttribute('issue-term', 'pathname');
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





  </body>
</html>
