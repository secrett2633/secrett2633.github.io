<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <style> 
      ::-webkit-scrollbar{ 
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-track {
        width: 0px;
        background-color: #626262;
        /* border-radius: 5px; */
      }

      ::-webkit-scrollbar-thumb {
        width: 0px;
        background-color: #E2E2E2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-thumb:hover {
        width: 10px;
        height: 20px;
        /* background-color: rgba(190, 190, 190, 0.2); */
        background-color: #A2A2A2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-track:hover {
        width: 10px;
        /* background-color: rgba(150, 150, 150, 0.1); */
        background-color: #626262;
        border-radius: 5px;
        /* background: transparent; */
        /* border-radius: 10px; */
      }

      ::-webkit-scrollbar-button:start:decrement,::-webkit-scrollbar-button:end:increment {
          width:0px;
          height: 0px;
          /* background-color: rgb(14, 221, 24); */
          /* border-radius: 50%; */
      }
    </style>
    
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[Superseded] PEP 433 - Easier suppression of file descriptor inheritance | secrett2633</title>
<meta name="description" content="Python Enhancement Proposal 433: ‘Easier suppression of file descriptor inheritance’에 대한 한국어 번역입니다.">


  <meta name="author" content="secrett2633">
  
  <meta property="article:author" content="secrett2633">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="secrett2633's blog">
<meta property="og:title" content="[Superseded] PEP 433 - Easier suppression of file descriptor inheritance">
<meta property="og:url" content="http://localhost:4000/python/pep/433/">


  <meta property="og:description" content="Python Enhancement Proposal 433: ‘Easier suppression of file descriptor inheritance’에 대한 한국어 번역입니다.">







  <meta property="article:published_time" content="2025-09-26T21:45:26+09:00">



  <meta property="article:modified_time" content="2025-09-26T21:45:26+09:00">



  

  


<link rel="canonical" href="http://localhost:4000/python/pep/433/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "secrett2633",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="secrett2633's blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->


    <link rel="icon" type="image/png" sizes="32x32" href="https://secrett2633.github.io/assets/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://secrett2633.github.io/assets/images/favicon/favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          secrett2633's blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://github.com/secrett2633">GitHub</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <!-- 2022.02.17 author content hidden -->
  <!-- <div class="author__content">
    
      <h3 class="author__name" itemprop="name">secrett2633</h3>
    
    
  </div> -->

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
      
    
    
      <nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    <!-- Backend -->
    <li>
      <span class="nav__sub-title">Backend</span>
      <hr>
      <ul>
        <li><a href="/backend/django/">Django</a></li>
        <li><a href="/backend/logging/">Logging</a></li>
      </ul>
    </li>

    <!-- Python -->
    <li>
      <span class="nav__sub-title">Python</span>
      <hr>
      <ul>
        <li><a href="/python/pep/">PEP</a></li>
      </ul>
    </li>

    <!-- AI/ML -->
    <li>
      <span class="nav__sub-title">AI/ML</span>
      <hr>
      <ul>
        <li><a href="/ai/llm/">LLM</a></li>
        <li><a href="/ai/review/">Review</a></li>
      </ul>
    </li>

    <!-- DevOps -->
    <li>
      <span class="nav__sub-title">DevOps</span>
      <hr>
      <ul>
        <li><a href="/devops/nginx/">Nginx</a></li>
        <li><a href="/devops/docker/">Docker</a></li>
        <li><a href="/devops/safeline/">SafeLine</a></li>
        <li><a href="/devops/jenkins/">Jenkins</a></li>
        <li><a href="/devops/github-actions/">GitHub Actions</a></li>
        <li><a href="/devops/aws/">AWS</a></li>
      </ul>
    </li>

    <!-- etc -->
    <li>
      <span class="nav__sub-title">etc</span>
      <hr>
      <ul>
        <li><a href="/etc/me/">Me</a></li>
        <li><a href="/etc/chrome-extension/">Chrome Extension</a></li>
      </ul>
    </li>
  </ul>
</nav>
    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[Superseded] PEP 433 - Easier suppression of file descriptor inheritance">
    <meta itemprop="description" content="Python Enhancement Proposal 433: ‘Easier suppression of file descriptor inheritance’에 대한 한국어 번역입니다.">
    <meta itemprop="datePublished" content="2025-09-26T21:45:26+09:00">
    <meta itemprop="dateModified" content="2025-09-26T21:45:26+09:00">

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">[Superseded] PEP 433 - Easier suppression of file descriptor inheritance
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2025-09-26T21:45:26+09:00">September 26, 2025</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#pep-433--파일-디스크립터-상속을-더-쉽게-억제하기-easier-suppression-of-file-descriptor-inheritance">PEP 433 – 파일 디스크립터 상속을 더 쉽게 억제하기 (Easier suppression of file descriptor inheritance)</a><ul><li><a href="#목차">목차</a></li><li><a href="#요약-abstract">요약 (Abstract)</a></li><li><a href="#배경-rationale">배경 (Rationale)</a><ul><li><a href="#python-33에서의-현황">Python 3.3에서의 현황</a></li><li><a href="#파일-디스크립터-상속-문제">파일 디스크립터 상속 문제</a><ul><li><a href="#보안-security">보안 (Security)</a></li><li><a href="#원자성-atomicity">원자성 (Atomicity)</a></li><li><a href="#이식성-portability">이식성 (Portability)</a></li></ul></li><li><a href="#범위-scope">범위 (Scope)</a></li></ul></li><li><a href="#제안-proposal">제안 (Proposal)</a></li><li><a href="#대안-alternatives">대안 (Alternatives)</a><ul><li><a href="#상속이-기본적으로-활성화되고-기본값은-설정-불가능">상속이 기본적으로 활성화되고, 기본값은 설정 불가능</a></li><li><a href="#상속이-기본적으로-활성화되고-기본값은-true로만-설정-가능">상속이 기본적으로 활성화되고, 기본값은 True로만 설정 가능</a></li><li><a href="#상속을-기본적으로-비활성화">상속을 기본적으로 비활성화</a></li><li><a href="#fork-이후-파일-디스크립터-닫기">fork() 이후 파일 디스크립터 닫기</a></li><li><a href="#open-모드에-e-플래그-추가">open(): 모드에 “e” 플래그 추가</a></li><li><a href="#새로운-매개변수-이름에-대한-논의">새로운 매개변수 이름에 대한 논의</a></li></ul></li><li><a href="#파일-디스크립터-상속을-사용하는-애플리케이션">파일 디스크립터 상속을 사용하는 애플리케이션</a></li><li><a href="#성능-performances">성능 (Performances)</a></li><li><a href="#구현-implementation">구현 (Implementation)</a><ul><li><a href="#osget_cloexecfd">os.get_cloexec(fd)</a></li><li><a href="#osset_cloexecfd-cloexectrue">os.set_cloexec(fd, cloexec=True)</a></li><li><a href="#open">open()</a></li><li><a href="#osdup">os.dup()</a></li><li><a href="#osdup2">os.dup2()</a></li><li><a href="#ospipe">os.pipe()</a></li><li><a href="#socketsocket">socket.socket()</a></li><li><a href="#socketsocketpair">socket.socketpair()</a></li><li><a href="#socketsocketaccept">socket.socket.accept()</a></li></ul></li><li><a href="#하위-호환성-backward-compatibility">하위 호환성 (Backward compatibility)</a></li><li><a href="#부록-운영-체제-지원-appendix-operating-system-support">부록: 운영 체제 지원 (Appendix: Operating system support)</a><ul><li><a href="#windows">Windows</a></li><li><a href="#ioctl">ioctl</a></li><li><a href="#fcntl">fcntl</a></li><li><a href="#원자적-플래그-atomic-flags">원자적 플래그 (Atomic flags)</a></li></ul></li><li><a href="#링크-links">링크 (Links)</a></li><li><a href="#각주-footnotes">각주 (Footnotes)</a></li><li><a href="#저작권-copyright">저작권 (Copyright)</a></li></ul></li></ul>

            </nav>
          </aside>
        
        <blockquote>
  <p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0433/">PEP 433 - Easier suppression of file descriptor inheritance</a></p>

  <table>
    <tbody>
      <tr>
        <td><strong>상태:</strong> Superseded</td>
        <td><strong>유형:</strong> Standards Track</td>
        <td><strong>작성일:</strong> 10-Jan-2013</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h1 id="pep-433--파일-디스크립터-상속을-더-쉽게-억제하기-easier-suppression-of-file-descriptor-inheritance">PEP 433 – 파일 디스크립터 상속을 더 쉽게 억제하기 (Easier suppression of file descriptor inheritance)</h1>

<ul>
  <li><strong>작성자</strong>: Victor Stinner <vstinner at="" python.org=""></vstinner></li>
  <li><strong>상태</strong>: Superseded (폐기됨 - PEP 446으로 대체됨)</li>
  <li><strong>유형</strong>: Standards Track</li>
  <li><strong>생성일</strong>: 2013년 1월 10일</li>
  <li><strong>Python 버전</strong>: 3.4</li>
  <li><strong>대체</strong>: PEP 446</li>
</ul>

<h2 id="목차">목차</h2>
<ul>
  <li><a href="#요약-abstract">요약 (Abstract)</a></li>
  <li><a href="#배경-rationale">배경 (Rationale)</a>
    <ul>
      <li><a href="#python-33에서의-현황">Python 3.3에서의 현황</a></li>
      <li><a href="#파일-디스크립터-상속-문제">파일 디스크립터 상속 문제</a>
        <ul>
          <li><a href="#보안-security">보안 (Security)</a></li>
          <li><a href="#원자성-atomicity">원자성 (Atomicity)</a></li>
          <li><a href="#이식성-portability">이식성 (Portability)</a></li>
        </ul>
      </li>
      <li><a href="#범위-scope">범위 (Scope)</a></li>
    </ul>
  </li>
  <li><a href="#제안-proposal">제안 (Proposal)</a></li>
  <li><a href="#대안-alternatives">대안 (Alternatives)</a>
    <ul>
      <li><a href="#상속이-기본적으로-활성화되고-기본값은-설정-불가능">상속이 기본적으로 활성화되고, 기본값은 설정 불가능</a></li>
      <li><a href="#상속이-기본적으로-활성화되고-기본값은-true로만-설정-가능">상속이 기본적으로 활성화되고, 기본값은 <code class="language-plaintext highlighter-rouge">True</code>로만 설정 가능</a></li>
      <li><a href="#상속을-기본적으로-비활성화">상속을 기본적으로 비활성화</a></li>
      <li><a href="#fork-이후-파일-디스크립터-닫기"><code class="language-plaintext highlighter-rouge">fork()</code> 이후 파일 디스크립터 닫기</a></li>
      <li><a href="#open-모드에-e-플래그-추가"><code class="language-plaintext highlighter-rouge">open()</code>: 모드에 “e” 플래그 추가</a></li>
      <li><a href="#새로운-매개변수-이름에-대한-논의">새로운 매개변수 이름에 대한 논의</a></li>
    </ul>
  </li>
  <li><a href="#파일-디스크립터-상속을-사용하는-애플리케이션">파일 디스크립터 상속을 사용하는 애플리케이션</a></li>
  <li><a href="#성능-performances">성능 (Performances)</a></li>
  <li><a href="#구현-implementation">구현 (Implementation)</a>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">os.get_cloexec(fd)</code></li>
      <li><code class="language-plaintext highlighter-rouge">os.set_cloexec(fd, cloexec=True)</code></li>
      <li><code class="language-plaintext highlighter-rouge">open()</code></li>
      <li><code class="language-plaintext highlighter-rouge">os.dup()</code></li>
      <li><code class="language-plaintext highlighter-rouge">os.dup2()</code></li>
      <li><code class="language-plaintext highlighter-rouge">os.pipe()</code></li>
      <li><code class="language-plaintext highlighter-rouge">socket.socket()</code></li>
      <li><code class="language-plaintext highlighter-rouge">socket.socketpair()</code></li>
      <li><code class="language-plaintext highlighter-rouge">socket.socket.accept()</code></li>
    </ul>
  </li>
  <li><a href="#하위-호환성-backward-compatibility">하위 호환성 (Backward compatibility)</a></li>
  <li><a href="#부록-운영-체제-지원-appendix-operating-system-support">부록: 운영 체제 지원 (Appendix: Operating system support)</a>
    <ul>
      <li><a href="#windows">Windows</a></li>
      <li><code class="language-plaintext highlighter-rouge">ioctl</code></li>
      <li><code class="language-plaintext highlighter-rouge">fcntl</code></li>
      <li><a href="#원자적-플래그-atomic-flags">원자적 플래그 (Atomic flags)</a></li>
    </ul>
  </li>
  <li><a href="#링크-links">링크 (Links)</a></li>
  <li><a href="#각주-footnotes">각주 (Footnotes)</a></li>
  <li><a href="#저작권-copyright">저작권 (Copyright)</a></li>
</ul>

<h2 id="요약-abstract">요약 (Abstract)</h2>

<p>이 PEP는 파일 디스크립터 (File Descriptor)를 생성하는 함수에 새로운 선택적 <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수를 추가하고, 이 매개변수의 기본값을 변경하는 다양한 방법을 도입하며, 다음과 같은 네 가지 새로운 함수를 추가할 것을 제안합니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">os.get_cloexec(fd)</code></li>
  <li><code class="language-plaintext highlighter-rouge">os.set_cloexec(fd, cloexec=True)</code></li>
  <li><code class="language-plaintext highlighter-rouge">sys.getdefaultcloexec()</code></li>
  <li><code class="language-plaintext highlighter-rouge">sys.setdefaultcloexec(cloexec)</code></li>
</ul>

<h2 id="배경-rationale">배경 (Rationale)</h2>

<p>파일 디스크립터는 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 가지고 있으며, 이 플래그는 파일 디스크립터가 상속될지 여부를 나타냅니다.</p>

<p>UNIX 시스템에서 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그가 설정되면, 파일 디스크립터는 자식 프로세스의 실행 시 닫히므로 상속되지 않습니다. 그렇지 않으면 파일 디스크립터는 자식 프로세스에 의해 상속됩니다.</p>

<p>Windows 시스템에서 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그가 설정되면 파일 디스크립터는 상속되지 않습니다. <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그가 해제되고 <code class="language-plaintext highlighter-rouge">CreateProcess()</code> 함수가 <code class="language-plaintext highlighter-rouge">bInheritHandles</code> 매개변수를 <code class="language-plaintext highlighter-rouge">TRUE</code>로 설정하여 호출될 경우 (예를 들어 <code class="language-plaintext highlighter-rouge">subprocess.Popen</code>이 <code class="language-plaintext highlighter-rouge">close_fds=False</code>로 생성될 때), 파일 디스크립터는 자식 프로세스에 의해 상속됩니다. Windows에는 “close-on-exec” 플래그는 없지만, 그와 반대되는 값을 가진 상속 플래그가 있습니다. 예를 들어, <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하는 것은 핸들(handle)의 <code class="language-plaintext highlighter-rouge">HANDLE_FLAG_INHERIT</code> 플래그를 해제하는 것을 의미합니다.</p>

<h3 id="python-33에서의-현황">Python 3.3에서의 현황</h3>

<p>UNIX에서는 Python 3.2부터 <code class="language-plaintext highlighter-rouge">subprocess</code> 모듈이 기본적으로 파일 디스크립터 2번(stderr)보다 큰 모든 파일 디스크립터를 닫습니다. [cite: 1,  각주 1] 부모 프로세스에 의해 생성된 모든 파일 디스크립터는 자식 프로세스에서 자동으로 닫힙니다.</p>

<p><code class="language-plaintext highlighter-rouge">xmlrpc.server.SimpleXMLRPCServer</code>는 리스닝 소켓 (listening socket)의 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하지만, 부모 클래스인 <code class="language-plaintext highlighter-rouge">socketserver.TCPServer</code>는 이 플래그를 설정하지 않습니다.</p>

<p><code class="language-plaintext highlighter-rouge">os.spawn*()</code> 및 <code class="language-plaintext highlighter-rouge">os.exec*()</code> 계열 함수와 <code class="language-plaintext highlighter-rouge">exec()</code> 또는 <code class="language-plaintext highlighter-rouge">fork()</code> + <code class="language-plaintext highlighter-rouge">exec()</code>를 호출하는 서드파티 모듈을 통해 서브프로세스를 생성하거나 새 프로그램을 실행할 때 파일 디스크립터가 닫히지 않는 다른 경우가 있습니다. 이 경우, 파일 디스크립터는 부모 프로세스와 자식 프로세스 간에 공유되는데, 이는 일반적으로 예상치 못한 동작이며 다양한 문제를 야기합니다.</p>

<p>이 PEP는 Python 3.2에서 <code class="language-plaintext highlighter-rouge">subprocess</code> 모듈의 변경으로 시작된 작업을 계속하여, <code class="language-plaintext highlighter-rouge">subprocess</code>를 사용하는 코드뿐만 아니라 모든 코드에서 이 문제를 해결할 것을 제안합니다.</p>

<h3 id="파일-디스크립터-상속-문제">파일 디스크립터 상속 문제</h3>

<p>부모 프로세스에서 파일 디스크립터를 닫아도 관련 리소스 (파일, 소켓 등)는 자식 프로세스에서 여전히 열려 있기 때문에 닫히지 않습니다.</p>

<p><code class="language-plaintext highlighter-rouge">TCPServer</code>의 리스닝 소켓은 <code class="language-plaintext highlighter-rouge">exec()</code> 시 닫히지 않습니다. 이로 인해 자식 프로세스가 새 클라이언트로부터 연결을 받을 수 있으며, 만약 부모 프로세스가 리스닝 소켓을 닫고 동일한 주소에 새 리스닝 소켓을 생성하려고 하면 “address already in use” (주소가 이미 사용 중) 오류가 발생할 수 있습니다.</p>

<p>파일 디스크립터를 닫지 않으면 리소스 고갈로 이어질 수 있습니다. 부모가 모든 파일을 닫아도, 자식 프로세스에 파일이 여전히 열려 있기 때문에 “too many files” (파일이 너무 많음) 오류로 인해 새 파일 디스크립터 생성이 실패할 수 있습니다.</p>

<p>관련된 문제들은 다음과 같습니다.</p>
<ul>
  <li>Issue #2320: <code class="language-plaintext highlighter-rouge">subprocess</code>에서 <code class="language-plaintext highlighter-rouge">stdin</code>을 사용하는 경합 조건 (Race condition) (2008)</li>
  <li>Issue #3006: <code class="language-plaintext highlighter-rouge">subprocess.Popen</code>이 닫힌 후에도 소켓이 열려 있음 (2008)</li>
  <li>Issue #7213: <code class="language-plaintext highlighter-rouge">subprocess</code>가 <code class="language-plaintext highlighter-rouge">Popen</code> 인스턴스 간에 열린 파일 디스크립터를 누출하여 중단 발생 (2009)</li>
  <li>Issue #12786: <code class="language-plaintext highlighter-rouge">stdin</code>이 닫힐 때 <code class="language-plaintext highlighter-rouge">subprocess.wait()</code>가 중단됨 (2011)</li>
</ul>

<h4 id="보안-security">보안 (Security)</h4>

<p>파일 디스크립터 누출은 중대한 보안 취약점입니다. 신뢰할 수 없는 자식 프로세스가 암호와 같은 민감한 데이터를 읽거나 누출된 파일 디스크립터를 통해 부모 프로세스를 제어할 수 있습니다. 예를 들어, <code class="language-plaintext highlighter-rouge">chroot</code>를 탈출하는 알려진 취약점입니다.</p>

<p>CERT 권고 사항: FIO42-C. 더 이상 필요하지 않은 파일은 올바르게 닫히도록 해야 합니다.</p>

<p>취약점 사례:</p>
<ul>
  <li>OpenSSH Security Advisory: <code class="language-plaintext highlighter-rouge">portable-keysign-rand-helper.adv</code> (2011년 4월)</li>
  <li>CWE-403: 의도하지 않은 제어 영역으로의 파일 디스크립터 노출 (2008)</li>
  <li><code class="language-plaintext highlighter-rouge">mod_php</code>를 통한 Apache <code class="language-plaintext highlighter-rouge">https</code> 하이재킹 (2003년 12월)</li>
  <li>Apache: <code class="language-plaintext highlighter-rouge">APR_FOPEN_NOCLEANUP</code>이 설정되지 않은 경우 <code class="language-plaintext highlighter-rouge">Apr</code>는 <code class="language-plaintext highlighter-rouge">FD_CLOEXEC</code>을 설정해야 함 (2009년 수정됨)</li>
  <li>PHP: <code class="language-plaintext highlighter-rouge">system()</code> (및 유사 함수)는 Apache에 의해 열린 핸들을 정리하지 않음 (2013년 1월 기준 미수정)</li>
</ul>

<h4 id="원자성-atomicity">원자성 (Atomicity)</h4>

<p>멀티스레드 애플리케이션에서 <code class="language-plaintext highlighter-rouge">fcntl()</code>을 사용하여 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하는 것은 안전하지 않습니다. 만약 파일 디스크립터 생성과 <code class="language-plaintext highlighter-rouge">fcntl(fd, F_SETFD, new_flags)</code> 호출 사이에 스레드가 <code class="language-plaintext highlighter-rouge">fork()</code> 및 <code class="language-plaintext highlighter-rouge">exec()</code>를 호출한다면, 파일 디스크립터는 자식 프로세스에 의해 상속될 것입니다. 최신 운영 체제는 파일 디스크립터 생성 중에 플래그를 설정하는 함수를 제공하여 경합 조건 (race condition)을 방지합니다.</p>

<h4 id="이식성-portability">이식성 (Portability)</h4>

<p>Python 3.2는 <code class="language-plaintext highlighter-rouge">socket.SOCK_CLOEXEC</code> 플래그를 추가했고, Python 3.3은 <code class="language-plaintext highlighter-rouge">os.O_CLOEXEC</code> 플래그와 <code class="language-plaintext highlighter-rouge">os.pipe2()</code> 함수를 추가했습니다. Python 3.3에서는 파일 열기, 파이프 또는 소켓 생성 시 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 원자적으로 (atomically) 설정하는 것이 이미 가능합니다.</p>

<p>문제는 이러한 플래그와 함수들이 이식성이 없다는 것입니다. 즉, 최신 버전의 운영 체제에서만 지원됩니다. <code class="language-plaintext highlighter-rouge">O_CLOEXEC</code> 및 <code class="language-plaintext highlighter-rouge">SOCK_CLOEXEC</code> 플래그는 오래된 Linux 버전에서는 무시되므로, <code class="language-plaintext highlighter-rouge">fcntl(fd, F_GETFD)</code>를 사용하여 <code class="language-plaintext highlighter-rouge">FD_CLOEXEC</code> 플래그를 확인해야 합니다. 커널이 <code class="language-plaintext highlighter-rouge">O_CLOEXEC</code> 또는 <code class="language-plaintext highlighter-rouge">SOCK_CLOEXEC</code> 플래그를 무시하는 경우, <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하기 위해 <code class="language-plaintext highlighter-rouge">fcntl(fd, F_SETFD, flags)</code> 호출이 필요합니다.</p>

<p>참고: OpenBSD 5.2 이전 버전은 <code class="language-plaintext highlighter-rouge">fork()</code>가 <code class="language-plaintext highlighter-rouge">exec()</code> 전에 사용되면 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그가 설정된 파일 디스크립터를 닫지 않지만, <code class="language-plaintext highlighter-rouge">exec()</code>가 <code class="language-plaintext highlighter-rouge">fork()</code> 없이 호출되면 올바르게 작동합니다.</p>

<h3 id="범위-scope">범위 (Scope)</h3>

<p>애플리케이션은 <code class="language-plaintext highlighter-rouge">fork()</code> 이후에도 파일 디스크립터를 명시적으로 닫아야 합니다. <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그는 <code class="language-plaintext highlighter-rouge">exec()</code> 이후, 즉 <code class="language-plaintext highlighter-rouge">fork()</code> + <code class="language-plaintext highlighter-rouge">exec()</code> 이후에만 파일 디스크립터를 닫습니다.</p>

<p>이 PEP는 Python 표준 라이브러리 또는 표준 라이브러리를 사용하는 모듈에 의해 생성된 파일 디스크립터의 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그만 변경합니다. 표준 라이브러리를 사용하지 않는 서드파티 모듈은 이 PEP에 따르도록 수정되어야 합니다. 예를 들어, 새로운 <code class="language-plaintext highlighter-rouge">os.set_cloexec()</code> 함수를 사용할 수 있습니다.</p>

<p>참고: <code class="language-plaintext highlighter-rouge">exec()</code> 없는 <code class="language-plaintext highlighter-rouge">fork()</code>의 가능한 해결책은 “Close file descriptors after fork” 섹션을 참조하십시오.</p>

<h2 id="제안-proposal">제안 (Proposal)</h2>

<p>파일 디스크립터를 생성하는 함수에 새로운 선택적 <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수를 추가하고, 이 매개변수의 기본값을 변경하는 다양한 방법을 추가합니다.</p>

<p>다음과 같은 새로운 함수를 추가합니다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">os.get_cloexec(fd:int) -&gt; bool</code>: 파일 디스크립터의 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 가져옵니다. 모든 플랫폼에서 사용 가능하지 않을 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">os.set_cloexec(fd:int, cloexec:bool=True)</code>: 파일 디스크립터에 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하거나 해제합니다. 모든 플랫폼에서 사용 가능하지 않을 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sys.getdefaultcloexec() -&gt; bool</code>: <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수의 현재 기본값을 가져옵니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sys.setdefaultcloexec(cloexec: bool)</code>: <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수의 기본값을 설정합니다.</li>
</ul>

<p>다음 함수들에 새로운 선택적 <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수를 추가합니다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">asyncore.dispatcher.create_socket()</code></li>
  <li><code class="language-plaintext highlighter-rouge">io.FileIO</code></li>
  <li><code class="language-plaintext highlighter-rouge">io.open()</code></li>
  <li><code class="language-plaintext highlighter-rouge">open()</code></li>
  <li><code class="language-plaintext highlighter-rouge">os.dup()</code></li>
  <li><code class="language-plaintext highlighter-rouge">os.dup2()</code></li>
  <li><code class="language-plaintext highlighter-rouge">os.fdopen()</code></li>
  <li><code class="language-plaintext highlighter-rouge">os.open()</code></li>
  <li><code class="language-plaintext highlighter-rouge">os.openpty()</code></li>
  <li><code class="language-plaintext highlighter-rouge">os.pipe()</code></li>
  <li><code class="language-plaintext highlighter-rouge">select.devpoll()</code></li>
  <li><code class="language-plaintext highlighter-rouge">select.epoll()</code></li>
  <li><code class="language-plaintext highlighter-rouge">select.kqueue()</code></li>
  <li><code class="language-plaintext highlighter-rouge">socket.socket()</code></li>
  <li><code class="language-plaintext highlighter-rouge">socket.socket.accept()</code></li>
  <li><code class="language-plaintext highlighter-rouge">socket.socket.dup()</code></li>
  <li><code class="language-plaintext highlighter-rouge">socket.socket.fromfd</code></li>
  <li><code class="language-plaintext highlighter-rouge">socket.socketpair()</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수의 기본값은 <code class="language-plaintext highlighter-rouge">sys.getdefaultcloexec()</code>입니다.</p>

<p>기본적으로 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하기 위해 새로운 명령줄 옵션 <code class="language-plaintext highlighter-rouge">-e</code>와 환경 변수 <code class="language-plaintext highlighter-rouge">PYTHONCLOEXEC</code>를 추가합니다.</p>

<p><code class="language-plaintext highlighter-rouge">subprocess</code> 모듈은 <code class="language-plaintext highlighter-rouge">pass_fds</code> 매개변수에 나열된 파일 디스크립터의 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 해제합니다.</p>

<p>표준 라이브러리에서 파일 디스크립터를 생성하는 모든 함수는 <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수의 기본값인 <code class="language-plaintext highlighter-rouge">sys.getdefaultcloexec()</code>를 따라야 합니다.</p>

<p>파일 디스크립터 0 (<code class="language-plaintext highlighter-rouge">stdin</code>), 1 (<code class="language-plaintext highlighter-rouge">stdout</code>), 2 (<code class="language-plaintext highlighter-rouge">stderr</code>)는 상속될 것으로 예상되지만, Python은 이들을 다르게 처리하지 않습니다. 표준 스트림을 대체하기 위해 <code class="language-plaintext highlighter-rouge">os.dup2()</code>가 사용될 경우, <code class="language-plaintext highlighter-rouge">cloexec=False</code>를 명시적으로 지정해야 합니다.</p>

<p>제안의 단점:</p>
<ul>
  <li>새로 생성된 파일 디스크립터에서 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그가 설정될지 여부를 소스 코드만으로는 알 수 없게 됩니다.</li>
  <li>파일 디스크립터의 상속이 중요한 경우, <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수를 명시적으로 지정해야 하며, 그렇지 않으면 라이브러리나 애플리케이션이 <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수의 기본값에 따라 다르게 작동할 수 있습니다.</li>
</ul>

<h2 id="대안-alternatives">대안 (Alternatives)</h2>

<h3 id="상속이-기본적으로-활성화되고-기본값은-설정-불가능">상속이 기본적으로 활성화되고, 기본값은 설정 불가능</h3>

<p>파일 디스크립터를 생성하는 함수에 새로운 선택적 <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수를 추가합니다. <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수의 기본값은 <code class="language-plaintext highlighter-rouge">False</code>이며, 이 기본값은 변경할 수 없습니다. 파일 디스크립터 상속이 기본적으로 활성화되는 것은 POSIX 및 Windows의 기본 동작과도 일치합니다. 이 대안은 가장 보수적인 옵션입니다.</p>

<p>이 옵션은 “배경” 섹션에 나열된 문제를 해결하지 못하며, 단지 문제를 해결하기 위한 도우미를 제공할 뿐입니다. 이러한 모든 문제를 해결하기 위해 애플리케이션에서 사용되는 각 모듈에서 파일 디스크립터를 생성하는 모든 함수를 수정하여 <code class="language-plaintext highlighter-rouge">cloexec=True</code>를 설정해야 합니다.</p>

<h3 id="상속이-기본적으로-활성화되고-기본값은-true로만-설정-가능">상속이 기본적으로 활성화되고, 기본값은 <code class="language-plaintext highlighter-rouge">True</code>로만 설정 가능</h3>

<p>이 대안은 제안을 기반으로 합니다. 유일한 차이점은 <code class="language-plaintext highlighter-rouge">sys.setdefaultcloexec()</code>가 어떤 인수도 받지 않고, <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수의 기본값을 <code class="language-plaintext highlighter-rouge">True</code>로만 설정할 수 있다는 것입니다.</p>

<h3 id="상속을-기본적으로-비활성화">상속을 기본적으로 비활성화</h3>

<p>이 대안은 제안을 기반으로 합니다. 유일한 차이점은 <code class="language-plaintext highlighter-rouge">cloexec</code> 매개변수의 기본값이 <code class="language-plaintext highlighter-rouge">True</code>라는 것입니다 (기존 <code class="language-plaintext highlighter-rouge">False</code> 대신).</p>

<p>자식 프로세스에 의해 파일이 상속되어야 하는 경우, <code class="language-plaintext highlighter-rouge">cloexec=False</code> 매개변수를 사용할 수 있습니다.</p>

<p>기본적으로 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하는 것의 장점:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">exec</code> 시 FD (파일 디스크립터) 상속으로 인해 발생하는 문제로 고통받는 프로그램 (Inherited file descriptors issues 및 Security 참조)이 상속에 의존하는 프로그램 (Applications using inheritance of file descriptors 참조)보다 훨씬 많습니다.</li>
</ul>

<p>기본적으로 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하는 것의 단점:</p>
<ul>
  <li>“최소 놀람의 원칙” (principle of least surprise)을 위반합니다. <code class="language-plaintext highlighter-rouge">os</code> 모듈을 사용하는 개발자들은 Python이 POSIX 표준을 따르고 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그가 기본적으로 설정되지 않을 것이라고 예상할 수 있습니다. <code class="language-plaintext highlighter-rouge">os</code> 모듈은 시스템 호출 (C 표준 라이브러리의 함수)에 대한 얇은 래퍼 (thin wrapper)로 작성되었습니다. <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하는 원자적 플래그가 지원되지 않는 경우 (Appendix: Operating system support 참조), 단일 Python 함수 호출이 2개 또는 3개의 시스템 호출을 할 수 있습니다 (Performances 섹션 참조). 추가적인 시스템 호출이 있다면 Python을 느리게 할 수 있습니다 (Performances 참조).</li>
</ul>

<p>하위 호환성: 파일 디스크립터 상속에 의존하는 프로그램은 소수에 불과하며, 일반적으로 하나 또는 몇 개의 파일 디스크립터만 전달합니다. 이러한 프로그램들은 <code class="language-plaintext highlighter-rouge">EBADF</code> 오류로 즉시 실패할 것이고, <code class="language-plaintext highlighter-rouge">cloexec=False</code> 매개변수를 추가하거나 <code class="language-plaintext highlighter-rouge">os.set_cloexec(fd, False)</code>를 사용하여 쉽게 수정할 수 있을 것입니다.</p>

<p><code class="language-plaintext highlighter-rouge">subprocess</code> 모듈은 <code class="language-plaintext highlighter-rouge">Popen</code> 생성자의 <code class="language-plaintext highlighter-rouge">pass_fds</code> 매개변수에 나열된 파일 디스크립터의 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 해제하도록 어차피 변경될 것입니다. 따라서 이러한 프로그램들이 <code class="language-plaintext highlighter-rouge">subprocess</code> 모듈을 사용하는 경우 어떤 수정도 필요하지 않을 수 있습니다.</p>

<h3 id="fork-이후-파일-디스크립터-닫기"><code class="language-plaintext highlighter-rouge">fork()</code> 이후 파일 디스크립터 닫기</h3>

<p>이 PEP는 <code class="language-plaintext highlighter-rouge">exec()</code> 없이 <code class="language-plaintext highlighter-rouge">fork()</code>를 사용하는 애플리케이션의 문제를 해결하지 않습니다. Python은 <code class="language-plaintext highlighter-rouge">fork</code> 이후 호출될 콜백 (callback)을 등록하는 일반적인 프로세스가 필요하며, Issue #16500: <code class="language-plaintext highlighter-rouge">atfork</code> 모듈 추가를 참조하십시오. 이러한 레지스트리는 <code class="language-plaintext highlighter-rouge">fork()</code> 직후 파일 디스크립터를 닫는 데 사용될 수 있습니다.</p>

<p>단점:</p>
<ul>
  <li>Windows에서는 <code class="language-plaintext highlighter-rouge">fork()</code>가 존재하지 않으므로 Windows에서는 이 문제가 해결되지 않습니다.</li>
  <li>이 대안은 <code class="language-plaintext highlighter-rouge">fork()</code> 없이 <code class="language-plaintext highlighter-rouge">exec()</code>를 사용하는 프로그램의 문제를 해결하지 못합니다.</li>
  <li>서드파티 모듈은 C 함수 <code class="language-plaintext highlighter-rouge">fork()</code>를 직접 호출할 수 있으며, 이 경우 “atfork” 콜백이 호출되지 않습니다.</li>
  <li>파일 디스크립터를 생성하는 모든 함수는 콜백을 등록해야 하며, 파일이 닫힐 때 콜백을 등록 해제해야 합니다. 또는 열린 모든 파일 디스크립터 목록이 유지되어야 합니다.</li>
  <li>파일 디스크립터를 자동으로 닫는 것은 Python보다는 운영 체제가 더 적합한 곳입니다. 예를 들어, 파일을 닫는 것과 파일을 닫는 콜백을 등록 해제하는 것 사이의 경합 조건을 피하기는 쉽지 않습니다.</li>
</ul>

<h3 id="open-모드에-e-플래그-추가"><code class="language-plaintext highlighter-rouge">open()</code>: 모드에 “e” 플래그 추가</h3>

<p>새로운 “e” 모드는 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 (최선을 다해) 설정할 것입니다.</p>

<p>이 대안은 <code class="language-plaintext highlighter-rouge">open()</code>에 대한 문제만 해결합니다. <code class="language-plaintext highlighter-rouge">socket.socket()</code> 및 <code class="language-plaintext highlighter-rouge">os.pipe()</code>에는 예를 들어 <code class="language-plaintext highlighter-rouge">mode</code> 매개변수가 없습니다.</p>

<p>GNU libc는 버전 2.7부터 <code class="language-plaintext highlighter-rouge">fopen()</code>에 “e” 플래그를 지원합니다. 이는 <code class="language-plaintext highlighter-rouge">O_CLOEXEC</code>가 사용 가능하면 사용하고, 그렇지 않으면 <code class="language-plaintext highlighter-rouge">fcntl(fd, F_SETFD, FD_CLOEXEC)</code>를 사용합니다. Visual Studio에서는 <code class="language-plaintext highlighter-rouge">fopen()</code>이 <code class="language-plaintext highlighter-rouge">O_NOINHERIT</code>를 사용하는 “N” 플래그를 허용합니다.</p>

<h3 id="새로운-매개변수-이름에-대한-논의">새로운 매개변수 이름에 대한 논의</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inherit</code>, <code class="language-plaintext highlighter-rouge">inherited</code>: Windows 정의에 더 가깝습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">sensitive</code>, <code class="language-plaintext highlighter-rouge">sterile</code>: “자손을 생산하지 않는다”는 의미입니다.</li>
</ul>

<h2 id="파일-디스크립터-상속을-사용하는-애플리케이션">파일 디스크립터 상속을 사용하는 애플리케이션</h2>

<p>대부분의 개발자는 파일 디스크립터가 기본적으로 상속된다는 사실을 알지 못합니다. 대부분의 프로그램은 파일 디스크립터 상속에 의존하지 않습니다. 예를 들어, <code class="language-plaintext highlighter-rouge">subprocess.Popen</code>은 Python 3.2에서 자식 프로세스에서 기본적으로 2번보다 큰 모든 파일 디스크립터를 닫도록 변경되었습니다. 아직 이 동작 변경에 대해 불평한 사용자는 없습니다.</p>

<p><code class="language-plaintext highlighter-rouge">fork</code>를 사용하는 네트워크 서버는 클라이언트 소켓을 자식 프로세스로 전달하고 싶을 수 있습니다. 예를 들어, UNIX에서 CGI 서버는 <code class="language-plaintext highlighter-rouge">dup2()</code>를 사용하여 파일 디스크립터 0 (<code class="language-plaintext highlighter-rouge">stdin</code>) 및 1 (<code class="language-plaintext highlighter-rouge">stdout</code>)을 통해 클라이언트 소켓을 전달합니다.</p>

<p>TCP 포트 1024 미만의 포트에서 소켓을 리스닝하거나 암호와 같은 민감한 데이터를 포함하는 파일을 읽는 것과 같은 제한된 리소스에 접근하기 위한 일반적인 관행은 다음과 같습니다. 루트 사용자 (root user)로 시작하여 파일 디스크립터를 생성하고, 자식 프로세스를 생성한 다음, 권한을 포기하고 (예: 현재 사용자 변경), 파일 디스크립터를 자식 프로세스로 전달한 후 부모 프로세스를 종료합니다.</p>

<p>이러한 사용 사례에서는 보안이 매우 중요합니다. 다른 파일 디스크립터를 누출하는 것은 심각한 보안 취약점이 될 것입니다 (Security 참조). 루트 프로세스는 종료하지 않고 자식 프로세스를 모니터링할 수 있으며, 이전 자식 프로세스가 충돌하면 새로운 자식 프로세스를 재시작하고 동일한 파일 디스크립터를 전달할 수 있습니다.</p>

<p>명령줄 옵션을 사용하여 부모 프로세스로부터 파일 디스크립터를 가져오는 프로그램의 예:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">gpg</code>: <code class="language-plaintext highlighter-rouge">--status-fd &lt;fd&gt;</code>, <code class="language-plaintext highlighter-rouge">--logger-fd &lt;fd&gt;</code> 등</li>
  <li><code class="language-plaintext highlighter-rouge">openssl</code>: <code class="language-plaintext highlighter-rouge">-pass fd:&lt;fd&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">qemu</code>: <code class="language-plaintext highlighter-rouge">-add-fd &lt;fd&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">valgrind</code>: <code class="language-plaintext highlighter-rouge">--log-fd=&lt;fd&gt;</code>, <code class="language-plaintext highlighter-rouge">--input-fd=&lt;fd&gt;</code> 등</li>
  <li><code class="language-plaintext highlighter-rouge">xterm</code>: <code class="language-plaintext highlighter-rouge">-S &lt;fd&gt;</code></li>
</ul>

<p>Linux에서는 <code class="language-plaintext highlighter-rouge">/dev/fd/&lt;fd&gt;</code> 파일 이름을 사용하여 파일 이름을 예상하는 프로그램에 파일 디스크립터를 전달하는 것이 가능합니다.</p>

<h2 id="성능-performances">성능 (Performances)</h2>

<p><code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하는 것은 새 파일 디스크립터 생성마다 추가적인 시스템 호출 (syscall)을 요구할 수 있습니다. 추가 시스템 호출의 수는 플래그를 설정하는 데 사용되는 방법에 따라 달라집니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">O_NOINHERIT</code>: 추가 시스템 호출 없음</li>
  <li><code class="language-plaintext highlighter-rouge">O_CLOEXEC</code>: 하나의 추가 시스템 호출이 발생하지만, 플래그 지원 여부를 확인하기 위해 첫 파일 디스크립터 생성 시에만 발생합니다. 만약 플래그가 지원되지 않으면, Python은 다음 방법으로 폴백(fallback)해야 합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">ioctl(fd, FIOCLEX)</code>: 파일 디스크립터당 하나의 추가 시스템 호출</li>
  <li><code class="language-plaintext highlighter-rouge">fcntl(fd, F_SETFD, flags)</code>: 파일 디스크립터당 두 개의 추가 시스템 호출이 발생하며, 하나는 이전 플래그를 가져오는 데, 다른 하나는 새 플래그를 설정하는 데 사용됩니다.</li>
</ul>

<p>Linux에서 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하는 것은 성능에 미치는 오버헤드가 낮습니다. Linux 3.6에서 <code class="language-plaintext highlighter-rouge">bench_cloexec.py</code>의 벤치마크 결과:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그 미설정: 7.8 us</li>
  <li><code class="language-plaintext highlighter-rouge">O_CLOEXEC</code>: 1% 느림 (7.9 us)</li>
  <li><code class="language-plaintext highlighter-rouge">ioctl()</code>: 3% 느림 (8.0 us)</li>
  <li><code class="language-plaintext highlighter-rouge">fcntl()</code>: 3% 느림 (8.0 us)</li>
</ul>

<h2 id="구현-implementation">구현 (Implementation)</h2>

<h3 id="osget_cloexecfd"><code class="language-plaintext highlighter-rouge">os.get_cloexec(fd)</code></h3>

<p>파일 디스크립터의 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 가져옵니다.</p>

<p>의사 코드:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">os</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="sh">'</span><span class="s">nt</span><span class="sh">'</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">get_cloexec</span><span class="p">(</span><span class="n">fd</span><span class="p">):</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">_winapi</span><span class="p">.</span><span class="nf">_get_osfhandle</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="n">_winapi</span><span class="p">.</span><span class="nc">GetHandleInformation</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
        <span class="k">return</span> <span class="ow">not</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">_winapi</span><span class="p">.</span><span class="n">HANDLE_FLAG_INHERIT</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="n">fcntl</span>
    <span class="k">except</span> <span class="nb">ImportError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">get_cloexec</span><span class="p">(</span><span class="n">fd</span><span class="p">):</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">.</span><span class="nf">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fcntl</span><span class="p">.</span><span class="n">F_GETFD</span><span class="p">)</span>
            <span class="k">return</span> <span class="nf">bool</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">fcntl</span><span class="p">.</span><span class="n">FD_CLOEXEC</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="osset_cloexecfd-cloexectrue"><code class="language-plaintext highlighter-rouge">os.set_cloexec(fd, cloexec=True)</code></h3>

<p>파일 디스크립터에 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하거나 해제합니다. 이 플래그는 파일 디스크립터 생성 이후에 설정되므로 원자적 (atomic)이지 않습니다.</p>

<p>의사 코드:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">os</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="sh">'</span><span class="s">nt</span><span class="sh">'</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">set_cloexec</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">cloexec</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">_winapi</span><span class="p">.</span><span class="nf">_get_osfhandle</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">_winapi</span><span class="p">.</span><span class="n">HANDLE_FLAG_INHERIT</span>
        <span class="k">if</span> <span class="n">cloexec</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="n">_winapi</span><span class="p">.</span><span class="nc">SetHandleInformation</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">fnctl</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">ioctl</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="n">ioctl</span>
    <span class="k">except</span> <span class="nb">ImportError</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="n">fcntl</span>
        <span class="k">except</span> <span class="nb">ImportError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">if</span> <span class="n">ioctl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nf">hasattr</span><span class="p">(</span><span class="sh">'</span><span class="s">FIOCLEX</span><span class="sh">'</span><span class="p">,</span> <span class="n">ioctl</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">set_cloexec</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">cloexec</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cloexec</span><span class="p">:</span>
                <span class="n">ioctl</span><span class="p">.</span><span class="nf">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">ioctl</span><span class="p">.</span><span class="n">FIOCLEX</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ioctl</span><span class="p">.</span><span class="nf">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">ioctl</span><span class="p">.</span><span class="n">FIONCLEX</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fnctl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">set_cloexec</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">cloexec</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">.</span><span class="nf">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fcntl</span><span class="p">.</span><span class="n">F_GETFD</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cloexec</span><span class="p">:</span>
                <span class="n">flags</span> <span class="o">|=</span> <span class="n">FD_CLOEXEC</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FD_CLOEXEC</span>
            <span class="n">fcntl</span><span class="p">.</span><span class="nf">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fcntl</span><span class="p">.</span><span class="n">F_SETFD</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">fcntl</code>보다 <code class="language-plaintext highlighter-rouge">ioctl</code>이 선호되는데, <code class="language-plaintext highlighter-rouge">ioctl</code>은 단일 시스템 호출만 필요한 반면 <code class="language-plaintext highlighter-rouge">fcntl</code>은 두 개의 시스템 호출이 필요하기 때문입니다.</p>

<p>참고: <code class="language-plaintext highlighter-rouge">fcntl(fd, F_SETFD, flags)</code>는 하나의 플래그 (<code class="language-plaintext highlighter-rouge">FD_CLOEXEC</code>)만 지원하므로 <code class="language-plaintext highlighter-rouge">fcntl(fd, F_GETFD)</code>를 피할 수 있습니다. 하지만 미래에 다른 플래그를 삭제할 수도 있으므로, 두 함수 호출을 유지하는 것이 더 안전합니다.</p>

<p>참고: GNU libc의 <code class="language-plaintext highlighter-rouge">fopen()</code> 함수는 <code class="language-plaintext highlighter-rouge">fcntl(fd, F_SETFD, flags)</code>가 실패하더라도 오류를 무시합니다.</p>

<h3 id="open"><code class="language-plaintext highlighter-rouge">open()</code></h3>

<ul>
  <li>Windows: <code class="language-plaintext highlighter-rouge">open()</code> with <code class="language-plaintext highlighter-rouge">O_NOINHERIT</code> flag [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">open()</code> with <code class="language-plaintext highlighter-rouge">O_CLOEXEC</code> flag [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">open()</code> + <code class="language-plaintext highlighter-rouge">os.set_cloexec(fd, True)</code> [최선 노력 (best-effort)]</li>
</ul>

<h3 id="osdup"><code class="language-plaintext highlighter-rouge">os.dup()</code></h3>

<ul>
  <li>Windows: <code class="language-plaintext highlighter-rouge">DuplicateHandle()</code> [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">fcntl(fd, F_DUPFD_CLOEXEC)</code> [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">dup()</code> + <code class="language-plaintext highlighter-rouge">os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>

<h3 id="osdup2"><code class="language-plaintext highlighter-rouge">os.dup2()</code></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fcntl(fd, F_DUP2FD_CLOEXEC, fd2)</code> [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">dup3()</code> with <code class="language-plaintext highlighter-rouge">O_CLOEXEC</code> flag [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">dup2()</code> + <code class="language-plaintext highlighter-rouge">os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>

<h3 id="ospipe"><code class="language-plaintext highlighter-rouge">os.pipe()</code></h3>

<ul>
  <li>Windows: <code class="language-plaintext highlighter-rouge">CreatePipe()</code> with <code class="language-plaintext highlighter-rouge">SECURITY_ATTRIBUTES.bInheritHandle=TRUE</code>, or <code class="language-plaintext highlighter-rouge">_pipe()</code> with <code class="language-plaintext highlighter-rouge">O_NOINHERIT</code> flag [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">pipe2()</code> with <code class="language-plaintext highlighter-rouge">O_CLOEXEC</code> flag [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">pipe()</code> + <code class="language-plaintext highlighter-rouge">os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>

<h3 id="socketsocket"><code class="language-plaintext highlighter-rouge">socket.socket()</code></h3>

<ul>
  <li>Windows: <code class="language-plaintext highlighter-rouge">WSASocket()</code> with <code class="language-plaintext highlighter-rouge">WSA_FLAG_NO_HANDLE_INHERIT</code> flag [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">socket()</code> with <code class="language-plaintext highlighter-rouge">SOCK_CLOEXEC</code> flag [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">socket()</code> + <code class="language-plaintext highlighter-rouge">os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>

<h3 id="socketsocketpair"><code class="language-plaintext highlighter-rouge">socket.socketpair()</code></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">socketpair()</code> with <code class="language-plaintext highlighter-rouge">SOCK_CLOEXEC</code> flag [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">socketpair()</code> + <code class="language-plaintext highlighter-rouge">os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>

<h3 id="socketsocketaccept"><code class="language-plaintext highlighter-rouge">socket.socket.accept()</code></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">accept4()</code> with <code class="language-plaintext highlighter-rouge">SOCK_CLOEXEC</code> flag [원자적]</li>
  <li><code class="language-plaintext highlighter-rouge">accept()</code> + <code class="language-plaintext highlighter-rouge">os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>

<h2 id="하위-호환성-backward-compatibility">하위 호환성 (Backward compatibility)</h2>

<p>하위 호환성을 깨는 변경 사항은 없습니다. 기본 동작은 변경되지 않으며, <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그는 기본적으로 설정되지 않습니다.</p>

<h2 id="부록-운영-체제-지원-appendix-operating-system-support">부록: 운영 체제 지원 (Appendix: Operating system support)</h2>

<h3 id="windows">Windows</h3>

<p>Windows에는 “자식 프로세스에서 상속하지 않음”을 의미하는 <code class="language-plaintext highlighter-rouge">O_NOINHERIT</code> 플래그가 있습니다. 예를 들어, <code class="language-plaintext highlighter-rouge">open()</code> 및 <code class="language-plaintext highlighter-rouge">_pipe()</code>에서 지원됩니다. 이 플래그는 <code class="language-plaintext highlighter-rouge">SetHandleInformation(fd, HANDLE_FLAG_INHERIT, 0)</code>을 사용하여 해제할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">CreateProcess()</code>는 <code class="language-plaintext highlighter-rouge">bInheritHandles</code> 매개변수를 가지고 있습니다. 이 값이 <code class="language-plaintext highlighter-rouge">FALSE</code>이면 핸들은 상속되지 않습니다. <code class="language-plaintext highlighter-rouge">TRUE</code>이면 <code class="language-plaintext highlighter-rouge">HANDLE_FLAG_INHERIT</code> 플래그가 설정된 핸들이 상속됩니다. <code class="language-plaintext highlighter-rouge">subprocess.Popen</code>은 <code class="language-plaintext highlighter-rouge">close_fds</code> 옵션을 사용하여 <code class="language-plaintext highlighter-rouge">bInheritHandles</code>를 정의합니다.</p>

<h3 id="ioctl"><code class="language-plaintext highlighter-rouge">ioctl</code></h3>

<p>함수:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ioctl(fd, FIOCLEX, 0)</code>: <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그 설정</li>
  <li><code class="language-plaintext highlighter-rouge">ioctl(fd, FIONCLEX, 0)</code>: <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그 해제</li>
</ul>

<p>가용성: Linux, Mac OS X, QNX, NetBSD, OpenBSD, FreeBSD.</p>

<h3 id="fcntl"><code class="language-plaintext highlighter-rouge">fcntl</code></h3>

<p>함수:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">flags = fcntl(fd, F_GETFD); fcntl(fd, F_SETFD, flags | FD_CLOEXEC)</code>: <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그 설정</li>
  <li><code class="language-plaintext highlighter-rouge">flags = fcntl(fd, F_GETFD); fcntl(fd, F_SETFD, flags &amp; ~FD_CLOEXEC)</code>: <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그 해제</li>
</ul>

<p>가용성: AIX, Digital UNIX, FreeBSD, HP-UX, IRIX, Linux, Mac OS X, OpenBSD, Solaris, SunOS, Unicos.</p>

<h3 id="원자적-플래그-atomic-flags">원자적 플래그 (Atomic flags)</h3>

<p>새로운 플래그:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">O_CLOEXEC</code>: Linux (2.6.23), FreeBSD (8.3), OpenBSD 5.0, Solaris 11, QNX, BeOS, 다음 NetBSD 릴리스 (6.1?)에서 사용 가능합니다. 이 플래그는 POSIX.1-2008의 일부입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">socket()</code> 및 <code class="language-plaintext highlighter-rouge">socketpair()</code>를 위한 <code class="language-plaintext highlighter-rouge">SOCK_CLOEXEC</code> 플래그: Linux 2.6.27, OpenBSD 5.2, NetBSD 6.0에서 사용 가능합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">WSASocket()</code>를 위한 <code class="language-plaintext highlighter-rouge">WSA_FLAG_NO_HANDLE_INHERIT</code> 플래그: Windows 7 SP1, Windows Server 2008 R2 SP1 및 이후 버전에서 지원됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">fcntl()</code>: <code class="language-plaintext highlighter-rouge">F_DUPFD_CLOEXEC</code> 플래그: Linux 2.6.24, OpenBSD 5.0, FreeBSD 9.1, NetBSD 6.0, Solaris 11에서 사용 가능합니다. 이 플래그는 POSIX.1-2008의 일부입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">fcntl()</code>: <code class="language-plaintext highlighter-rouge">F_DUP2FD_CLOEXEC</code> 플래그: FreeBSD 9.1 및 Solaris 11에서 사용 가능합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">recvmsg()</code>: <code class="language-plaintext highlighter-rouge">MSG_CMSG_CLOEXEC</code>: Linux 2.6.23, NetBSD 6.0에서 사용 가능합니다.</li>
</ul>

<p>Linux 2.6.23 이전 버전에서는 <code class="language-plaintext highlighter-rouge">O_CLOEXEC</code> 플래그가 단순히 무시됩니다. 따라서 <code class="language-plaintext highlighter-rouge">fcntl()</code>을 호출하여 플래그가 지원되는지 확인해야 합니다. 작동하지 않으면 <code class="language-plaintext highlighter-rouge">ioctl()</code> 또는 <code class="language-plaintext highlighter-rouge">fcntl()</code>을 사용하여 플래그를 설정해야 합니다.</p>

<p>Linux 2.6.27 이전 버전에서는 <code class="language-plaintext highlighter-rouge">SOCK_CLOEXEC</code> 플래그가 소켓 유형에 설정되면 <code class="language-plaintext highlighter-rouge">socket()</code> 또는 <code class="language-plaintext highlighter-rouge">socketpair()</code>가 실패하고 <code class="language-plaintext highlighter-rouge">errno</code>가 <code class="language-plaintext highlighter-rouge">EINVAL</code>로 설정됩니다.</p>

<p>Windows XPS3에서는 <code class="language-plaintext highlighter-rouge">WSA_FLAG_NO_HANDLE_INHERIT</code> 플래그를 사용하면 <code class="language-plaintext highlighter-rouge">WSASocket()</code>이 <code class="language-plaintext highlighter-rouge">WSAEPROTOTYPE</code> 오류를 반환합니다.</p>

<p>새로운 함수:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">dup3()</code>: Linux 2.6.27 (및 glibc 2.9)에서 사용 가능합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">pipe2()</code>: Linux 2.6.27 (및 glibc 2.9)에서 사용 가능합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">accept4()</code>: Linux 2.6.28 (및 glibc 2.10)에서 사용 가능합니다.</li>
</ul>

<p>Linux 2.6.28 이전 버전에서 <code class="language-plaintext highlighter-rouge">accept4()</code>를 호출하면 <code class="language-plaintext highlighter-rouge">accept4()</code>는 -1 (실패)을 반환하고 <code class="language-plaintext highlighter-rouge">errno</code>는 <code class="language-plaintext highlighter-rouge">ENOSYS</code>로 설정됩니다.</p>

<h2 id="링크-links">링크 (Links)</h2>

<ul>
  <li>Secure File Descriptor Handling (Ulrich Drepper, 2008)</li>
  <li>Tornado 프로젝트의 <code class="language-plaintext highlighter-rouge">win32_support.py</code>: <code class="language-plaintext highlighter-rouge">SetHandleInformation(fd, HANDLE_FLAG_INHERIT, 1)</code>을 사용하여 <code class="language-plaintext highlighter-rouge">fcntl(fd, F_SETFD, FD_CLOEXEC)</code> 에뮬레이션</li>
  <li>LKML: [PATCH] <code class="language-plaintext highlighter-rouge">nextfd(2)</code></li>
</ul>

<p>Python 이슈:</p>
<ul>
  <li>#10115: 소켓 생성 시 플래그의 원자적 설정을 위한 <code class="language-plaintext highlighter-rouge">accept4()</code> 지원</li>
  <li>#12105: <code class="language-plaintext highlighter-rouge">open()</code>이 <code class="language-plaintext highlighter-rouge">O_CLOEXEC</code>와 같은 플래그를 설정할 수 없음</li>
  <li>#12107: <code class="language-plaintext highlighter-rouge">FD_CLOEXEC</code> 플래그 없이 생성된 TCP 리스닝 소켓</li>
  <li>#16500: <code class="language-plaintext highlighter-rouge">atfork</code> 모듈 추가</li>
  <li>#16850: <code class="language-plaintext highlighter-rouge">open()</code>에 “e” 모드 추가: <code class="language-plaintext highlighter-rouge">close-and-exec</code> (<code class="language-plaintext highlighter-rouge">O_CLOEXEC</code>) / <code class="language-plaintext highlighter-rouge">O_NOINHERIT</code></li>
  <li>#16860: <code class="language-plaintext highlighter-rouge">tempfile</code> 모듈에서 <code class="language-plaintext highlighter-rouge">O_CLOEXEC</code> 사용</li>
  <li>#17036: PEP 433 구현</li>
  <li>#16946: <code class="language-plaintext highlighter-rouge">subprocess</code>: <code class="language-plaintext highlighter-rouge">_close_open_fd_range_safe()</code>는 <code class="language-plaintext highlighter-rouge">O_CLOEXEC</code>가 정의되어 있어도 Linux &lt; 2.6.23에서 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정하지 않음</li>
  <li>#17070: PEP 433: 새로운 <code class="language-plaintext highlighter-rouge">cloexec</code>를 사용하여 보안 개선 및 버그 방지</li>
</ul>

<p>다른 언어:</p>
<ul>
  <li>Perl은 새로 생성된 파일 디스크립터의 번호가 <code class="language-plaintext highlighter-rouge">$SYSTEM_FD_MAX</code> (<code class="language-plaintext highlighter-rouge">$^F</code>)보다 큰 경우 <code class="language-plaintext highlighter-rouge">close-on-exec</code> 플래그를 설정합니다. Perl 1부터 존재했습니다.</li>
  <li>Ruby: <code class="language-plaintext highlighter-rouge">FD_CLOEXEC</code> for all <code class="language-plaintext highlighter-rouge">fds</code> (0, 1, 2 제외) 설정. <code class="language-plaintext highlighter-rouge">Kernel::open</code>에 <code class="language-plaintext highlighter-rouge">O_CLOEXEC</code> 플래그 누락: 커밋은 나중에 되돌려졌습니다.</li>
  <li>OCaml: PR#5256: <code class="language-plaintext highlighter-rouge">Unix.open_process*</code>를 사용하여 열린 프로세스는 모든 열린 파일 디스크립터 (소켓 포함)를 상속합니다. OCaml에는 <code class="language-plaintext highlighter-rouge">Unix.set_close_on_exec</code> 함수가 있습니다.</li>
</ul>

<h2 id="각주-footnotes">각주 (Footnotes)</h2>

<p>UNIX에서 Python 3.2부터 <code class="language-plaintext highlighter-rouge">subprocess.Popen()</code>은 기본적으로 모든 파일 디스크립터를 닫습니다 (<code class="language-plaintext highlighter-rouge">close_fds=True</code>). 이는 3번을 포함하여 <code class="language-plaintext highlighter-rouge">local_max_fd</code> (NetBSD에서는 <code class="language-plaintext highlighter-rouge">fcntl(0, F_MAXFD)</code>, 그 외에는 <code class="language-plaintext highlighter-rouge">sysconf(_SC_OPEN_MAX)</code>) 미만까지의 파일 디스크립터를 닫습니다. 만약 오류 파이프의 디스크립터가 3보다 작으면 <code class="language-plaintext highlighter-rouge">ValueError</code>가 발생합니다.</p>

<h2 id="저작권-copyright">저작권 (Copyright)</h2>

<p>이 문서는 공개 도메인으로 지정되었습니다.</p>

<hr />

<blockquote>
  <p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/tags/#python" class="page__taxonomy-item" rel="tag">Python</a><span class="sep">, </span>
    
      <a href="/tags/#translation" class="page__taxonomy-item" rel="tag">Translation</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/categories/#python" class="page__taxonomy-item" rel="tag">Python</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2025-09-26">September 26, 2025</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/python/pep/432/" class="pagination--pager" title="[Withdrawn] PEP 432 - Restructuring the CPython startup sequence
">Previous</a>
    
    
      <a href="/python/pep/434/" class="pagination--pager" title="[Active] PEP 434 - IDLE Enhancement Exception for All Branches
">Next</a>
    
  </nav>


    </div>

    
  </article>

</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 secrett2633. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'secrett2633/secrett2633.github.io');
    script.setAttribute('issue-term', 'pathname');
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





  </body>
</html>
