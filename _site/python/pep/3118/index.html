<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <style> 
      ::-webkit-scrollbar{ 
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-track {
        width: 0px;
        background-color: #626262;
        /* border-radius: 5px; */
      }

      ::-webkit-scrollbar-thumb {
        width: 0px;
        background-color: #E2E2E2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-thumb:hover {
        width: 10px;
        height: 20px;
        /* background-color: rgba(190, 190, 190, 0.2); */
        background-color: #A2A2A2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-track:hover {
        width: 10px;
        /* background-color: rgba(150, 150, 150, 0.1); */
        background-color: #626262;
        border-radius: 5px;
        /* background: transparent; */
        /* border-radius: 10px; */
      }

      ::-webkit-scrollbar-button:start:decrement,::-webkit-scrollbar-button:end:increment {
          width:0px;
          height: 0px;
          /* background-color: rgb(14, 221, 24); */
          /* border-radius: 50%; */
      }
    </style>
    
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[Final] PEP 3118 - Revising the buffer protocol | secrett2633</title>
<meta name="description" content="Python Enhancement Proposal 3118: ‘Revising the buffer protocol’에 대한 한국어 번역입니다.">


  <meta name="author" content="secrett2633">
  
  <meta property="article:author" content="secrett2633">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="secrett2633's blog">
<meta property="og:title" content="[Final] PEP 3118 - Revising the buffer protocol">
<meta property="og:url" content="http://localhost:4000/python/pep/3118/">


  <meta property="og:description" content="Python Enhancement Proposal 3118: ‘Revising the buffer protocol’에 대한 한국어 번역입니다.">







  <meta property="article:published_time" content="2025-09-27T14:26:38+09:00">



  <meta property="article:modified_time" content="2025-09-27T14:26:38+09:00">



  

  


<link rel="canonical" href="http://localhost:4000/python/pep/3118/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "secrett2633",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="secrett2633's blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->


    <link rel="icon" type="image/png" sizes="32x32" href="https://secrett2633.github.io/assets/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://secrett2633.github.io/assets/images/favicon/favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          secrett2633's blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://github.com/secrett2633">GitHub</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <!-- 2022.02.17 author content hidden -->
  <!-- <div class="author__content">
    
      <h3 class="author__name" itemprop="name">secrett2633</h3>
    
    
  </div> -->

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">Backend</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/backend/django/">Django</a></li>
          
            <li><a href="/backend/logging/">Logging</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">Python</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/python/pep/">PEP</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">AI/ML</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/ai/llm/">LLM</a></li>
          
            <li><a href="/ai/review/">Review</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">DevOps</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/devops/nginx/">Nginx</a></li>
          
            <li><a href="/devops/docker/">Docker</a></li>
          
            <li><a href="/devops/safeline/">SafeLine</a></li>
          
            <li><a href="/devops/jenkins/">Jenkins</a></li>
          
            <li><a href="/devops/github-actions/">GitHub Actions</a></li>
          
            <li><a href="/devops/aws/">AWS</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <!-- title -->
              <span class="nav__sub-title">etc</span>
              <hr>
        

        
        <ul>
          
            <li><a href="/etc/me/">Me</a></li>
          
            <li><a href="/etc/chrome-extension/">Chrome Extension</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[Final] PEP 3118 - Revising the buffer protocol">
    <meta itemprop="description" content="Python Enhancement Proposal 3118: ‘Revising the buffer protocol’에 대한 한국어 번역입니다.">
    <meta itemprop="datePublished" content="2025-09-27T14:26:38+09:00">
    <meta itemprop="dateModified" content="2025-09-27T14:26:38+09:00">

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">[Final] PEP 3118 - Revising the buffer protocol
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2025-09-27T14:26:38+09:00">September 27, 2025</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#pep-3118--버퍼-프로토콜-재설계-revising-the-buffer-protocol">PEP 3118 – 버퍼 프로토콜 재설계 (Revising the buffer protocol)</a><ul><li><a href="#개요-abstract">개요 (Abstract)</a></li><li><a href="#도입-배경-rationale">도입 배경 (Rationale)</a></li><li><a href="#제안-개요-proposal-overview">제안 개요 (Proposal Overview)</a></li><li><a href="#사양-specification">사양 (Specification)</a><ul><li><a href="#접근-플래그-access-flags">접근 플래그 (Access flags)</a></li><li><a href="#py_buffer-구조체-the-py_buffer-struct">Py_buffer 구조체 (The Py_buffer struct)</a></li><li><a href="#버퍼-해제-releasing-the-buffer">버퍼 해제 (Releasing the buffer)</a></li><li><a href="#새로운-c-api-호출-제안-new-c-api-calls-are-proposed">새로운 C-API 호출 제안 (New C-API calls are proposed)</a></li><li><a href="#struct-문자열-구문-추가-사항-additions-to-the-struct-string-syntax">struct 문자열 구문 추가 사항 (Additions to the struct string-syntax)</a></li><li><a href="#데이터-형식-설명-예시-examples-of-data-format-descriptions">데이터 형식 설명 예시 (Examples of Data-Format Descriptions)</a></li><li><a href="#영향을-받는-코드-code-to-be-affected">영향을 받는 코드 (Code to be affected)</a></li><li><a href="#문제-및-세부-사항-issues-and-details">문제 및 세부 사항 (Issues and Details)</a></li><li><a href="#코드-code">코드 (Code)</a></li><li><a href="#코드-예시-code-examples">코드 예시 (Code Examples)</a><ul><li><a href="#예시-1-ex-1">예시 1 (Ex. 1)</a></li><li><a href="#예시-2-ex-2">예시 2 (Ex. 2)</a></li><li><a href="#예시-3-ex-3">예시 3 (Ex. 3)</a></li><li><a href="#예시-4-ex-4">예시 4 (Ex. 4)</a></li></ul></li></ul></li></ul></li></ul>

            </nav>
          </aside>
        
        <blockquote>
  <p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-3118/">PEP 3118 - Revising the buffer protocol</a></p>

  <table>
    <tbody>
      <tr>
        <td><strong>상태:</strong> Final</td>
        <td><strong>유형:</strong> Standards Track</td>
        <td><strong>작성일:</strong> 28-Aug-2006</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h1 id="pep-3118--버퍼-프로토콜-재설계-revising-the-buffer-protocol">PEP 3118 – 버퍼 프로토콜 재설계 (Revising the buffer protocol)</h1>

<ul>
  <li><strong>작성자:</strong> Travis Oliphant, Carl Banks</li>
  <li><strong>상태:</strong> Final</li>
  <li><strong>유형:</strong> Standards Track</li>
  <li><strong>생성일:</strong> 2006년 8월 28일</li>
  <li><strong>Python 버전:</strong> 3.0</li>
  <li><strong>최종 수정일:</strong> 2025년 2월 14일</li>
</ul>

<hr />

<p><strong>중요:</strong> 이 PEP는 역사적인 문서입니다. 최신 공식 문서는 <a href="https://docs.python.org/3/c-api/buffer.html">Buffer Protocol</a>, <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyBufferProcs">PyBufferProcs</a>, <a href="https://docs.python.org/3/c-api/memory.html#c.PyMemoryView_FromObject">PyMemoryView_FromObject</a>에서 찾을 수 있습니다.</p>

<p>이 PEP에서 제안된 모든 기능이 구현된 것은 아닙니다. 특히:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PyObject_CopyToObject</code>는 추가되지 않았습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">struct</code> 문자열 구문 추가 사항 중 <code class="language-plaintext highlighter-rouge">?</code> (<code class="language-plaintext highlighter-rouge">_Bool</code>)를 제외한 나머지는 추가되지 않았습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">PyObject_GetMemoryView</code>는 <code class="language-plaintext highlighter-rouge">PyMemoryView_FromObject</code>로 이름이 변경되었습니다.</li>
</ul>

<p>이 PEP는 10년도 더 전에 출시된 Python 3.0을 대상으로 합니다. 누락된 기능을 추가하려는 모든 제안은 이 PEP의 구현을 완료하는 것이 아니라 새로운 기능으로 논의되어야 합니다.</p>

<h2 id="개요-abstract">개요 (Abstract)</h2>

<p>이 PEP는 Python 3.0에서 메모리 공유 방식을 개선하기 위해 버퍼 인터페이스(PyBufferProcs 함수 포인터)를 재설계할 것을 제안합니다.</p>

<p>특히, API의 문자 버퍼(character buffer) 부분을 없애고, 여러 세그먼트(multiple-segment) 부분을 스트라이드(strided) 메모리 공유와 연계하여 재설계하는 것이 제안됩니다. 또한, 새로운 버퍼 인터페이스는 메모리의 다차원적 특성과 메모리가 포함하는 데이터 형식(data-format)을 공유할 수 있도록 할 것입니다.</p>

<p>이 인터페이스는 모든 확장 모듈(extension module)이 메모리를 공유하는 객체를 생성하거나, 인터페이스를 내보내는 임의의 객체에서 원시 메모리(raw memory)를 사용하고 조작하는 알고리즘을 생성할 수 있도록 합니다.</p>

<h2 id="도입-배경-rationale">도입 배경 (Rationale)</h2>

<p>Python 2.X 버퍼 프로토콜은 다른 Python 타입들이 내부 버퍼 시퀀스에 대한 포인터를 교환할 수 있도록 합니다. 이 기능은 서로 다른 고수준 객체들 간에 큰 메모리 세그먼트를 공유하는 데 매우 유용하지만, 너무 제한적이며 다음과 같은 문제가 있습니다.</p>

<ul>
  <li>잘 사용되지 않는 “세그먼트 시퀀스” 옵션(<code class="language-plaintext highlighter-rouge">bf_getsegcount</code>)이 있으며, 그 동기가 명확하지 않습니다.</li>
  <li>겉보기에 중복되는 문자 버퍼 옵션(<code class="language-plaintext highlighter-rouge">bf_getcharbuffer</code>)이 있습니다.</li>
  <li>소비자(consumer)가 버퍼 API를 내보내는 객체에 메모리 보기를 “다 사용했다”고 알릴 방법이 없으므로, 내보내는 객체가 자신이 소유한 메모리에 대한 포인터를 재할당하는 것이 안전하다고 확신할 방법이 없습니다. (예: <code class="language-plaintext highlighter-rouge">array</code> 객체가 원본 포인터를 가지고 있던 버퍼 객체와 메모리를 공유한 후 메모리를 재할당하여 악명 높은 버퍼 객체 문제를 일으켰습니다.)</li>
  <li>메모리는 단순히 길이(length)를 가진 포인터일 뿐입니다. 메모리 “안에 무엇이 있는지”(float, int, C-구조체 등)를 설명할 방법이 없습니다.</li>
  <li>메모리에 대한 형상(shape) 정보가 제공되지 않습니다. 하지만 여러 배열과 유사한 Python 타입(wxPython, GTK, pyQT, CVXOPT, PyVox, Audio and Video Libraries, ctypes, NumPy, 데이터베이스 인터페이스 등)은 메모리의 형상 해석(shape-interpretation)을 설명하는 표준적인 방법을 활용할 수 있습니다.</li>
  <li>비연속적인 메모리(discontiguous memory)를 공유할 방법이 없습니다 (세그먼트 시퀀스 개념을 통하는 경우 제외).</li>
</ul>

<p>비연속적인 메모리 개념을 사용하는 두 가지 널리 사용되는 라이브러리는 PIL과 NumPy입니다. 하지만 이들의 비연속 배열에 대한 관점은 다릅니다. 제안된 버퍼 인터페이스는 두 가지 메모리 모델 모두의 공유를 허용합니다. 내보내는 객체(Exporter)는 일반적으로 한 가지 접근 방식만 사용할 것이며, 소비자는 각 유형의 비연속 배열을 지원할지 여부를 선택할 수 있습니다.</p>

<p>NumPy는 각 차원에서 상수 스트라이딩(constant striding) 개념을 배열의 기본 개념으로 사용합니다. 이 개념을 통해 더 큰 배열의 간단한 하위 영역을 데이터를 복사하지 않고도 설명할 수 있습니다. 따라서 스트라이드 정보는 공유되어야 하는 추가 정보입니다.</p>

<p>PIL은 더 불투명한 메모리 표현을 사용합니다. 때로는 이미지가 연속적인 메모리 세그먼트에 포함되지만, 때로는 이미지의 연속적인 세그먼트(일반적으로 라인)에 대한 포인터 배열에 포함됩니다. PIL은 원래 버퍼 인터페이스에서 여러 버퍼 세그먼트 개념이 유래한 곳입니다.</p>

<p>NumPy의 스트라이드 메모리 모델은 계산 라이브러리에서 더 자주 사용되며, 그 단순성 때문에 이 모델을 사용한 메모리 공유를 지원하는 것이 합리적입니다. PIL 메모리 모델은 C-코드에서 2차원 배열을 이중 포인터 간접 참조(e.g. <code class="language-plaintext highlighter-rouge">image[i][j]</code>)를 사용하여 접근할 수 있을 때 사용되기도 합니다.</p>

<p>버퍼 인터페이스는 객체가 이 두 가지 메모리 모델 중 하나를 내보낼 수 있도록 허용해야 합니다. 소비자는 연속적인 메모리를 요구하거나, 이 두 가지 메모리 모델 중 하나 또는 둘 다를 처리하는 코드를 자유롭게 작성할 수 있습니다.</p>

<h2 id="제안-개요-proposal-overview">제안 개요 (Proposal Overview)</h2>

<ul>
  <li>버퍼 프로토콜의 문자 버퍼(char-buffer) 및 다중 세그먼트(multiple-segment) 섹션을 제거합니다.</li>
  <li>버퍼를 가져오는 읽기/쓰기 버전을 통합합니다.</li>
  <li>소비자 객체가 메모리 영역을 “다 사용했을” 때 호출되어야 하는 새로운 함수를 인터페이스에 추가합니다.</li>
  <li>메모리에 무엇이 있는지 설명할 수 있도록 새로운 변수를 추가합니다 (현재 <code class="language-plaintext highlighter-rouge">struct</code> 및 <code class="language-plaintext highlighter-rouge">array</code> 모듈에서 수행되는 작업을 통합).</li>
  <li>프로토콜이 형상(shape) 정보를 공유할 수 있도록 새로운 변수를 추가합니다.</li>
  <li>스트라이드(stride) 정보를 공유하기 위한 새로운 변수를 추가합니다.</li>
  <li>포인터 간접 참조(pointer indirection)를 사용하여 접근해야 하는 배열을 공유하기 위한 새로운 메커니즘을 추가합니다.</li>
  <li>핵심(core) 및 표준 라이브러리(standard library)의 모든 객체가 새 인터페이스를 따르도록 수정합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">struct</code> 모듈을 확장하여 더 많은 형식 지정자(format specifiers)를 처리할 수 있도록 합니다.</li>
  <li>버퍼 객체(buffer object)를 버퍼 인터페이스 위에 Python  veneer를 씌운 새로운 메모리 객체(memory object)로 확장합니다.</li>
  <li>버퍼 인터페이스를 지원하는 객체에서 연속적인 데이터(contiguous data)를 쉽게 복사하고 가져올 수 있도록 몇 가지 함수를 추가합니다.</li>
</ul>

<h2 id="사양-specification">사양 (Specification)</h2>

<p>새로운 사양은 복잡한 메모리 공유를 허용하지만, 객체로부터 간단한 연속 바이트 버퍼를 여전히 얻을 수 있습니다. 사실, 새로운 프로토콜은 원본 객체가 연속적인 메모리 청크로 표현되지 않더라도 이를 수행하는 표준 메커니즘을 허용합니다.</p>

<p>가장 쉬운 방법은 제공된 C-API를 사용하여 메모리 청크를 얻는 것입니다.</p>

<p><code class="language-plaintext highlighter-rouge">PyBufferProcs</code> 구조체를 다음과 같이 변경합니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">getbufferproc</span> <span class="n">bf_getbuffer</span><span class="p">;</span>
    <span class="n">releasebufferproc</span> <span class="n">bf_releasebuffer</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyBufferProcs</span><span class="p">;</span>
</code></pre></div></div>

<p>이 두 루틴은 타입 객체(type object)에 대해 선택 사항입니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getbufferproc</span><span class="p">)(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyBuffer</span> <span class="o">*</span><span class="n">view</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
</code></pre></div></div>

<p>이 함수는 성공 시 0을 반환하고 실패 시 -1을 반환합니다 (그리고 오류를 발생시킵니다). 첫 번째 변수는 “내보내는(exporting)” 객체입니다. 두 번째 인수는 <code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체의 주소입니다. 두 인수 모두 <code class="language-plaintext highlighter-rouge">NULL</code>이어서는 안 됩니다.</p>

<p>세 번째 인수는 소비자가 처리할 준비가 된 버퍼의 종류와 따라서 내보내는 객체가 반환할 수 있는 버퍼의 종류를 나타냅니다. 새로운 버퍼 인터페이스는 훨씬 더 복잡한 메모리 공유 가능성을 허용합니다. 일부 소비자는 모든 복잡성을 처리하지 못할 수 있지만, 내보내는 객체가 메모리에 대한 더 간단한 보기를 허용하는지 확인하고 싶을 수 있습니다.</p>

<p>또한, 일부 내보내는 객체는 모든 가능한 방식으로 메모리를 공유할 수 없으며, 일부 소비자에게 특정 작업이 불가능하다고 알리기 위해 오류를 발생시켜야 할 수도 있습니다. 이러한 오류는 실제로 문제를 일으키는 다른 오류가 없는 한 <code class="language-plaintext highlighter-rouge">PyErr_BufferError</code>여야 합니다. 내보내는 객체는 <code class="language-plaintext highlighter-rouge">flags</code> 정보를 사용하여 <code class="language-plaintext highlighter-rouge">PyBuffer</code> 구조체의 얼마나 많은 요소가 기본값 이외의 값으로 채워지는지 단순화하거나, 객체가 메모리에 대한 더 간단한 보기를 지원할 수 없는 경우 오류를 발생시킬 수 있습니다.</p>

<p>내보내는 객체는 항상 버퍼 구조체의 모든 요소를 채워야 합니다 (요청된 것이 없으면 기본값 또는 <code class="language-plaintext highlighter-rouge">NULL</code>로). <code class="language-plaintext highlighter-rouge">PyBuffer_FillInfo</code> 함수는 간단한 경우에 사용될 수 있습니다.</p>

<h3 id="접근-플래그-access-flags">접근 플래그 (Access flags)</h3>

<p>일부 플래그는 특정 종류의 메모리 세그먼트를 요청하는 데 유용하며, 다른 플래그는 소비자가 어떤 종류의 정보를 처리할 수 있는지 내보내는 객체에 알려줍니다. 만약 특정 정보가 소비자에 의해 요청되지 않았지만, 내보내는 객체가 그 정보 없이는 메모리를 공유할 수 없다면, <code class="language-plaintext highlighter-rouge">PyErr_BufferError</code>가 발생해야 합니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PyBUF_SIMPLE</code>
    <ul>
      <li>이것이 기본 플래그 상태(0)입니다. 반환된 버퍼는 쓰기 가능한 메모리를 가질 수도 있고 가지지 않을 수도 있습니다. 형식은 부호 없는 바이트(unsigned bytes)로 가정됩니다. 이것은 “독립적인(stand-alone)” 플래그 상수입니다. 다른 플래그와 <code class="language-plaintext highlighter-rouge">|</code>로 연결할 필요가 없습니다. 내보내는 객체는 이러한 연속적인 바이트 버퍼를 제공할 수 없으면 오류를 발생시킵니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PyBUF_WRITABLE</code>
    <ul>
      <li>반환된 버퍼는 쓰기 가능해야 합니다. 쓰기 가능하지 않으면 오류를 발생시킵니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PyBUF_FORMAT</code>
    <ul>
      <li>이 플래그가 제공되면 반환된 버퍼는 진정한 형식 정보를 가져야 합니다. 이것은 소비자가 실제로 저장된 데이터의 ‘종류’를 확인할 때 사용됩니다. 내보내는 객체는 요청 시 항상 이 정보를 제공할 수 있어야 합니다. 형식이 명시적으로 요청되지 않으면 형식은 <code class="language-plaintext highlighter-rouge">NULL</code>로 반환되어야 합니다 (이는 “B”, 즉 부호 없는 바이트를 의미합니다).</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PyBUF_ND</code>
    <ul>
      <li>반환된 버퍼는 형상(shape) 정보를 제공해야 합니다. 메모리는 C-스타일 연속(C-style contiguous)으로 가정됩니다 (마지막 차원이 가장 빠르게 변함). 내보내는 객체는 이러한 종류의 연속 버퍼를 제공할 수 없으면 오류를 발생시킬 수 있습니다. 이것이 주어지지 않으면 <code class="language-plaintext highlighter-rouge">shape</code>는 <code class="language-plaintext highlighter-rouge">NULL</code>이 됩니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PyBUF_STRIDES</code> ( <code class="language-plaintext highlighter-rouge">PyBUF_ND</code>를 암시)
    <ul>
      <li>반환된 버퍼는 스트라이드(strides) 정보를 제공해야 합니다 (즉, <code class="language-plaintext highlighter-rouge">strides</code>는 <code class="language-plaintext highlighter-rouge">NULL</code>이 아니어야 합니다). 이것은 소비자가 스트라이드된(strided), 비연속적인 배열을 처리할 수 있을 때 사용됩니다. 스트라이드를 처리하는 것은 자동으로 형상(shape)을 처리할 수 있다고 가정합니다. 내보내는 객체는 (하위 오프셋(suboffsets) 없이) 데이터의 스트라이드된 표현만 제공할 수 없으면 오류를 발생시킬 수 있습니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PyBUF_C_CONTIGUOUS</code></li>
  <li><code class="language-plaintext highlighter-rouge">PyBUF_F_CONTIGUOUS</code></li>
  <li><code class="language-plaintext highlighter-rouge">PyBUF_ANY_CONTIGUOUS</code>
    <ul>
      <li>이 플래그들은 반환된 버퍼가 각각 C-연속(C-contiguous, 마지막 차원이 가장 빠르게 변함), Fortran-연속(Fortran contiguous, 첫 번째 차원이 가장 빠르게 변함) 또는 둘 중 하나여야 함을 나타냅니다. 이 모든 플래그는 <code class="language-plaintext highlighter-rouge">PyBUF_STRIDES</code>를 암시하며, <code class="language-plaintext highlighter-rouge">strides</code> 버퍼 정보 구조체가 올바르게 채워질 것을 보장합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PyBUF_INDIRECT</code> ( <code class="language-plaintext highlighter-rouge">PyBUF_STRIDES</code>를 암시)
    <ul>
      <li>반환된 버퍼는 하위 오프셋(suboffsets) 정보를 가져야 합니다 (하위 오프셋이 필요하지 않은 경우 <code class="language-plaintext highlighter-rouge">NULL</code>일 수 있습니다). 이것은 소비자가 이러한 하위 오프셋이 암시하는 간접 배열 참조를 처리할 수 있을 때 사용됩니다.</li>
    </ul>
  </li>
</ul>

<p>특정 종류의 메모리 공유를 위한 플래그의 특수 조합.</p>

<ul>
  <li><strong>다차원 (하지만 연속적)</strong>
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_CONTIG</code> (<code class="language-plaintext highlighter-rouge">PyBUF_ND</code></td>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_WRITABLE</code>)</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li><code class="language-plaintext highlighter-rouge">PyBUF_CONTIG_RO</code> (<code class="language-plaintext highlighter-rouge">PyBUF_ND</code>)</li>
    </ul>
  </li>
  <li><strong>스트라이드를 사용하지만 정렬된 다차원</strong>
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_STRIDED</code> (<code class="language-plaintext highlighter-rouge">PyBUF_STRIDES</code></td>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_WRITABLE</code>)</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li><code class="language-plaintext highlighter-rouge">PyBUF_STRIDED_RO</code> (<code class="language-plaintext highlighter-rouge">PyBUF_STRIDES</code>)</li>
    </ul>
  </li>
  <li><strong>스트라이드를 사용하고 반드시 정렬될 필요는 없는 다차원</strong>
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_RECORDS</code> (<code class="language-plaintext highlighter-rouge">PyBUF_STRIDES</code></td>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_WRITABLE</code></td>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_FORMAT</code>)</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_RECORDS_RO</code> (<code class="language-plaintext highlighter-rouge">PyBUF_STRIDES</code></td>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_FORMAT</code>)</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li><strong>하위 오프셋을 사용하는 다차원</strong>
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_FULL</code> (<code class="language-plaintext highlighter-rouge">PyBUF_INDIRECT</code></td>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_WRITABLE</code></td>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_FORMAT</code>)</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_FULL_RO</code> (<code class="language-plaintext highlighter-rouge">PyBUF_INDIRECT</code></td>
              <td><code class="language-plaintext highlighter-rouge">PyBUF_FORMAT</code>)</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
</ul>

<p>따라서, 객체로부터 간단한 연속 바이트 청크를 원하는 소비자는 <code class="language-plaintext highlighter-rouge">PyBUF_SIMPLE</code>을 사용할 수 있으며, 가장 복잡한 경우를 활용할 줄 아는 소비자는 <code class="language-plaintext highlighter-rouge">PyBUF_FULL</code>을 사용할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">PyBUF_FORMAT</code>이 <code class="language-plaintext highlighter-rouge">flag</code> 인수에 있는 경우에만 형식 정보가 <code class="language-plaintext highlighter-rouge">NULL</code>이 아님을 보장하며, 그렇지 않은 경우 소비자는 부호 없는 바이트(unsigned bytes)로 가정할 것으로 예상됩니다.</p>

<p>연속적인 “부호 없는 바이트” 메모리 청크만 내보낼 수 있는 내보내는 객체를 위해 제공된 플래그에 따라 버퍼 정보 구조체를 올바르게 채우는 데 사용할 수 있는 C-API가 있습니다.</p>

<h3 id="py_buffer-구조체-the-py_buffer-struct"><code class="language-plaintext highlighter-rouge">Py_buffer</code> 구조체 (The Py_buffer struct)</h3>

<p><code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체는 다음과 같습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">bufferinfo</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">readonly</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ndim</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">shape</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">strides</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">suboffsets</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">itemsize</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">internal</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Py_buffer</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">bf_getbuffer</code> 함수를 호출하기 전에 <code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체는 무엇이든 채워질 수 있지만, 새로운 버퍼를 요청할 때는 <code class="language-plaintext highlighter-rouge">buf</code> 필드가 <code class="language-plaintext highlighter-rouge">NULL</code>이어야 합니다. <code class="language-plaintext highlighter-rouge">bf_getbuffer</code>에서 반환되면 <code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체는 버퍼에 대한 관련 정보로 채워집니다. 이 동일한 <code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체는 소비자가 메모리 사용을 마쳤을 때 <code class="language-plaintext highlighter-rouge">bf_releasebuffer</code>(사용 가능한 경우)에 전달되어야 합니다. 호출자는 <code class="language-plaintext highlighter-rouge">releasebuffer</code>가 호출될 때까지 <code class="language-plaintext highlighter-rouge">obj</code>에 대한 참조를 유지할 책임이 있습니다 (즉, <code class="language-plaintext highlighter-rouge">bf_getbuffer</code> 호출은 <code class="language-plaintext highlighter-rouge">obj</code>의 참조 횟수를 변경하지 않습니다).</p>

<p><code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체의 멤버들은 다음과 같습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">buf</code>
    <ul>
      <li>객체의 메모리 시작 부분에 대한 포인터입니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">len</code>
    <ul>
      <li>객체가 사용하는 총 메모리 바이트 수입니다. 이는 <code class="language-plaintext highlighter-rouge">shape</code> 배열과 항목당 바이트 수를 곱한 것과 같아야 합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">readonly</code>
    <ul>
      <li>메모리가 읽기 전용인지 여부를 나타내는 정수 변수입니다. 1은 메모리가 읽기 전용임을 의미하고, 0은 메모리가 쓰기 가능함을 의미합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">format</code>
    <ul>
      <li>메모리의 각 요소에 무엇이 들어있는지를 나타내는 <code class="language-plaintext highlighter-rouge">NULL</code>로 종료되는 형식 문자열(확장 기능을 포함한 <code class="language-plaintext highlighter-rouge">struct</code> 스타일 구문 따름)입니다. 요소의 수는 <code class="language-plaintext highlighter-rouge">len / itemsize</code>이며, <code class="language-plaintext highlighter-rouge">itemsize</code>는 형식에 의해 암시되는 바이트 수입니다. 이것은 <code class="language-plaintext highlighter-rouge">NULL</code>일 수 있으며, 이 경우 표준 부호 없는 바이트(“B”)를 의미합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ndim</code>
    <ul>
      <li>메모리가 나타내는 차원의 수를 저장하는 변수입니다. 0 이상이어야 합니다. 0 값은 <code class="language-plaintext highlighter-rouge">shape</code>, <code class="language-plaintext highlighter-rouge">strides</code>, <code class="language-plaintext highlighter-rouge">suboffsets</code>가 <code class="language-plaintext highlighter-rouge">NULL</code>이어야 함을 의미합니다 (즉, 메모리가 스칼라를 나타냅니다).</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">shape</code>
    <ul>
      <li>메모리의 형상(shape)을 N차원 배열로 나타내는 <code class="language-plaintext highlighter-rouge">ndim</code> 길이의 <code class="language-plaintext highlighter-rouge">Py_ssize_t</code> 배열입니다. <code class="language-plaintext highlighter-rouge">((*shape)[0] * ... * (*shape)[ndims-1])*itemsize = len</code>에 유의하십시오. <code class="language-plaintext highlighter-rouge">ndim</code>이 0인 경우(스칼라를 나타냄) 이것은 <code class="language-plaintext highlighter-rouge">NULL</code>이어야 합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">strides</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Py_ssize_t</code> 길이의 <code class="language-plaintext highlighter-rouge">ndim</code> 배열에 대한 포인터(또는 <code class="language-plaintext highlighter-rouge">ndim</code>이 0인 경우 <code class="language-plaintext highlighter-rouge">NULL</code>)로 채워질 <code class="language-plaintext highlighter-rouge">Py_ssize_t*</code> 변수의 주소입니다. 각 차원에서 다음 요소로 이동하기 위해 건너뛸 바이트 수를 나타냅니다. 호출자가 이를 요청하지 않으면 (<code class="language-plaintext highlighter-rouge">PyBUF_STRIDES</code>가 설정되지 않으면) <code class="language-plaintext highlighter-rouge">NULL</code>로 설정되어 C-스타일 연속 배열을 나타내거나, 불가능한 경우 <code class="language-plaintext highlighter-rouge">PyExc_BufferError</code>가 발생해야 합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">suboffsets</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Py_ssize_t</code> 길이의 <code class="language-plaintext highlighter-rouge">*ndims</code> 배열에 대한 포인터로 채워질 <code class="language-plaintext highlighter-rouge">Py_ssize_t*</code> 변수의 주소입니다. 이 <code class="language-plaintext highlighter-rouge">suboffset</code> 숫자가 0 이상인 경우, 지정된 차원을 따라 저장된 값은 포인터이며 <code class="language-plaintext highlighter-rouge">suboffset</code> 값은 역참조(de-referencing) 후 포인터에 추가할 바이트 수를 지시합니다. 음수 <code class="language-plaintext highlighter-rouge">suboffset</code> 값은 역참조가 발생하지 않아야 함을 나타냅니다 (연속 메모리 블록 내에서 스트라이딩). 모든 <code class="language-plaintext highlighter-rouge">suboffset</code>이 음수인 경우 (즉, 역참조가 필요 없음) 이것은 <code class="language-plaintext highlighter-rouge">NULL</code>이어야 합니다 (기본값). 호출자가 이를 요청하지 않으면 (<code class="language-plaintext highlighter-rouge">PyBUF_INDIRECT</code>가 설정되지 않으면) <code class="language-plaintext highlighter-rouge">NULL</code>로 설정되거나, 불가능한 경우 <code class="language-plaintext highlighter-rouge">PyExc_BufferError</code>가 발생해야 합니다.</li>
    </ul>
  </li>
</ul>

<p>명확성을 위해, <code class="language-plaintext highlighter-rouge">strides</code>와 <code class="language-plaintext highlighter-rouge">suboffsets</code>가 모두 <code class="language-plaintext highlighter-rouge">NULL</code>이 아닐 때 N차원 인덱스가 가리키는 N차원 배열의 요소에 대한 포인터를 반환하는 함수는 다음과 같습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">get_item_pointer</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndim</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">strides</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">suboffsets</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pointer</span> <span class="o">+=</span> <span class="n">strides</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">pointer</span><span class="p">)</span> <span class="o">+</span> <span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pointer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">suboffset</code>이 역참조 후에 추가된다는 점에 유의하십시오. 따라서 <code class="language-plaintext highlighter-rouge">i</code>번째 차원에서 슬라이싱(slicing)하면 <code class="language-plaintext highlighter-rouge">(i-1)</code>번째 차원의 <code class="language-plaintext highlighter-rouge">suboffsets</code>에 추가됩니다. 첫 번째 차원에서 슬라이싱하면 시작 포인터의 위치가 직접 변경됩니다 (즉, <code class="language-plaintext highlighter-rouge">buf</code>가 수정됩니다).</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">itemsize</code>
    <ul>
      <li>공유 메모리의 각 요소의 <code class="language-plaintext highlighter-rouge">itemsize</code>(바이트 단위)를 저장하는 공간입니다. <code class="language-plaintext highlighter-rouge">PyBuffer_SizeFromFormat</code>을 사용하여 얻을 수 있으므로 기술적으로는 불필요하지만, 내보내는 객체는 형식 문자열을 파싱하지 않고도 이 정보를 알 수 있으며, 스트라이딩을 올바르게 해석하려면 <code class="language-plaintext highlighter-rouge">itemsize</code>를 알아야 합니다. 따라서 저장하는 것이 더 편리하고 빠릅니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">internal</code>
    <ul>
      <li>내보내는 객체가 내부적으로 사용하기 위한 것입니다. 예를 들어, 내보내는 객체가 이를 정수로 재캐스팅하여 버퍼가 해제될 때 <code class="language-plaintext highlighter-rouge">shape</code>, <code class="language-plaintext highlighter-rouge">strides</code>, <code class="language-plaintext highlighter-rouge">suboffsets</code> 배열을 해제해야 하는지에 대한 플래그를 저장하는 데 사용할 수 있습니다. 소비자는 이 값을 절대 변경해서는 안 됩니다.</li>
    </ul>
  </li>
</ul>

<p>내보내는 객체는 <code class="language-plaintext highlighter-rouge">buf</code>, <code class="language-plaintext highlighter-rouge">format</code>, <code class="language-plaintext highlighter-rouge">shape</code>, <code class="language-plaintext highlighter-rouge">strides</code>, <code class="language-plaintext highlighter-rouge">suboffsets</code>가 가리키는 모든 메모리가 <code class="language-plaintext highlighter-rouge">releasebuffer</code>가 호출될 때까지 유효한지 확인할 책임이 있습니다. 내보내는 객체가 <code class="language-plaintext highlighter-rouge">releasebuffer</code>가 호출되기 전에 객체의 <code class="language-plaintext highlighter-rouge">shape</code>, <code class="language-plaintext highlighter-rouge">strides</code>, 및/또는 <code class="language-plaintext highlighter-rouge">suboffsets</code>를 변경할 수 있기를 원한다면, <code class="language-plaintext highlighter-rouge">getbuffer</code>가 호출될 때 해당 배열을 할당하고 (제공된 버퍼 정보 구조체에서 이들을 가리키도록) <code class="language-plaintext highlighter-rouge">releasebuffer</code>가 호출될 때 해제해야 합니다.</p>

<h3 id="버퍼-해제-releasing-the-buffer">버퍼 해제 (Releasing the buffer)</h3>

<p>동일한 <code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체가 <code class="language-plaintext highlighter-rouge">release-buffer</code> 인터페이스 호출에 사용되어야 합니다. 호출자는 <code class="language-plaintext highlighter-rouge">Py_buffer</code> 구조체 자체의 메모리에 대한 책임이 있습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">releasebufferproc</span><span class="p">)(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">Py_buffer</span> <span class="o">*</span><span class="n">view</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">getbufferproc</code>의 호출자는 객체에서 이전에 획득한 메모리가 더 이상 필요하지 않을 때 이 함수가 호출되도록 해야 합니다. 인터페이스의 내보내는 객체는 <code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체에 포인터로 지정된 모든 메모리가 <code class="language-plaintext highlighter-rouge">releasebuffer</code>가 호출될 때까지 유효하게 유지되도록 해야 합니다.</p>

<p>만약 <code class="language-plaintext highlighter-rouge">bf_releasebuffer</code> 함수가 제공되지 않으면 (즉, <code class="language-plaintext highlighter-rouge">NULL</code>인 경우), 호출할 필요가 전혀 없습니다.</p>

<p>내보내는 객체는 <code class="language-plaintext highlighter-rouge">struct bufferinfo</code>를 통해 공유할 수 있는 메모리, <code class="language-plaintext highlighter-rouge">strides</code>, <code class="language-plaintext highlighter-rouge">shape</code>, <code class="language-plaintext highlighter-rouge">suboffsets</code> 또는 <code class="language-plaintext highlighter-rouge">format</code> 변수를 재할당할 수 있는 경우 <code class="language-plaintext highlighter-rouge">bf_releasebuffer</code> 함수를 정의해야 합니다. 얼마나 많은 <code class="language-plaintext highlighter-rouge">getbuffer</code> 호출이 이루어졌고 공유되었는지 추적하기 위해 여러 메커니즘을 사용할 수 있습니다. 단일 변수를 사용하여 내보내진 “뷰”의 수를 추적하거나, 각 객체에 채워진 <code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체의 연결 리스트를 유지할 수 있습니다.</p>

<p>하지만 내보내는 객체에 의해 특별히 요구되는 것은 <code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체를 통해 공유되는 모든 메모리가 해당 메모리를 내보내는 <code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체에 대해 <code class="language-plaintext highlighter-rouge">releasebuffer</code>가 호출될 때까지 유효하게 유지되도록 하는 것입니다.</p>

<h3 id="새로운-c-api-호출-제안-new-c-api-calls-are-proposed">새로운 C-API 호출 제안 (New C-API calls are proposed)</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">int PyObject_CheckBuffer(PyObject *obj)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">getbuffer</code> 함수를 사용할 수 있으면 1을 반환하고, 그렇지 않으면 0을 반환합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">getbuffer</code> 함수 호출의 C-API 버전입니다. 객체가 필요한 함수 포인터를 가지고 있는지 확인하고 호출을 실행합니다. 실패 시 -1을 반환하고 오류를 발생시키며, 성공 시 0을 반환합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">void PyBuffer_Release(PyObject *obj, Py_buffer *view)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">releasebuffer</code> 함수 호출의 C-API 버전입니다. 객체가 필요한 함수 포인터를 가지고 있는지 확인하고 호출을 실행합니다. 이 함수는 객체에 <code class="language-plaintext highlighter-rouge">releasebuffer</code> 함수가 없더라도 항상 성공합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PyObject *PyObject_GetMemoryView(PyObject *obj)</code>
    <ul>
      <li>버퍼 인터페이스를 정의하는 객체로부터 <code class="language-plaintext highlighter-rouge">memory-view</code> 객체를 반환합니다.</li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">memory-view</code> 객체는 버퍼 객체를 대체할 수 있는 확장된 버퍼 객체입니다 (하지만 단순한 1차원 <code class="language-plaintext highlighter-rouge">memory-view</code> 객체로 유지될 수 있으므로 반드시 대체할 필요는 없습니다). 그 C-구조체는 다음과 같습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
    <span class="n">Py_buffer</span> <span class="n">view</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyMemoryViewObject</span><span class="p">;</span>
</code></pre></div></div>

<p>이것은 <code class="language-plaintext highlighter-rouge">base</code>에 대한 참조가 유지되고 메모리 뷰가 다시 가져와지지 않는다는 점을 제외하면 현재 버퍼 객체와 기능적으로 유사합니다. 따라서 이 <code class="language-plaintext highlighter-rouge">memory-view</code> 객체는 삭제될 때까지 <code class="language-plaintext highlighter-rouge">base</code>의 메모리를 유지합니다.</p>

<p>이 <code class="language-plaintext highlighter-rouge">memory-view</code> 객체는 다차원 슬라이싱(multi-dimensional slicing)을 지원하며, Python에서 이를 수행하는 최초의 객체가 될 것입니다. <code class="language-plaintext highlighter-rouge">memory-view</code> 객체의 슬라이스는 동일한 <code class="language-plaintext highlighter-rouge">base</code>를 가지지만 <code class="language-plaintext highlighter-rouge">base</code> 객체에 대한 다른 뷰(view)를 가지는 다른 <code class="language-plaintext highlighter-rouge">memory-view</code> 객체입니다.</p>

<p><code class="language-plaintext highlighter-rouge">memory-view</code>에서 “요소”가 반환될 때마다 항상 <code class="language-plaintext highlighter-rouge">bytes</code> 객체이며, 그 형식은 <code class="language-plaintext highlighter-rouge">memoryview</code> 객체의 <code class="language-plaintext highlighter-rouge">format</code> 속성에 의해 해석되어야 합니다. 원한다면 <code class="language-plaintext highlighter-rouge">struct</code> 모듈을 사용하여 Python에서 바이트를 “디코딩”할 수 있습니다. 또는 내용을 NumPy 배열이나 버퍼 프로토콜을 사용하는 다른 객체에 전달할 수 있습니다.</p>

<p>Python 이름은 <code class="language-plaintext highlighter-rouge">__builtin__.memoryview</code>가 될 것입니다.</p>

<p>메서드:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">__getitem__</code> (다차원 슬라이싱 지원)</li>
  <li><code class="language-plaintext highlighter-rouge">__setitem__</code> (다차원 슬라이싱 지원)</li>
  <li><code class="language-plaintext highlighter-rouge">tobytes</code> (메모리 복사본의 새 <code class="language-plaintext highlighter-rouge">bytes</code> 객체를 얻음).</li>
  <li><code class="language-plaintext highlighter-rouge">tolist</code> (메모리의 “중첩된” 리스트를 얻음. <code class="language-plaintext highlighter-rouge">struct</code> 모듈의 <code class="language-plaintext highlighter-rouge">unpack</code>이 하는 것처럼 모든 것이 표준 Python 객체로 해석됩니다. 실제로 이를 위해 <code class="language-plaintext highlighter-rouge">struct.unpack</code>을 사용합니다).</li>
</ul>

<p>속성 (<code class="language-plaintext highlighter-rouge">base</code> 객체의 메모리에서 가져옴):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">format</code></li>
  <li><code class="language-plaintext highlighter-rouge">itemsize</code></li>
  <li><code class="language-plaintext highlighter-rouge">shape</code></li>
  <li><code class="language-plaintext highlighter-rouge">strides</code></li>
  <li><code class="language-plaintext highlighter-rouge">suboffsets</code></li>
  <li><code class="language-plaintext highlighter-rouge">readonly</code></li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ndim</code></p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Py_ssize_t PyBuffer_SizeFromFormat(const char *)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">struct</code> 스타일 설명에서 데이터 형식 영역의 암시된 <code class="language-plaintext highlighter-rouge">itemsize</code>를 반환합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PyObject * PyMemoryView_GetContiguous(PyObject *obj, int buffertype, char fortran)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">obj</code>로 표현되는 연속적인 메모리 청크에 대한 <code class="language-plaintext highlighter-rouge">memoryview</code> 객체를 반환합니다. 복사가 이루어져야 하는 경우 (<code class="language-plaintext highlighter-rouge">obj</code>가 가리키는 메모리가 연속적이지 않기 때문), 새로운 <code class="language-plaintext highlighter-rouge">bytes</code> 객체가 생성되어 반환된 <code class="language-plaintext highlighter-rouge">memory view</code> 객체의 <code class="language-plaintext highlighter-rouge">base</code> 객체가 됩니다.</li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">buffertype</code> 인수는 반환된 버퍼가 읽기 가능, 쓰기 가능, 또는 복사가 이루어져야 하는 경우 원본 버퍼를 업데이트하도록 설정할지 여부를 결정하기 위해 <code class="language-plaintext highlighter-rouge">PyBUF_READ</code>, <code class="language-plaintext highlighter-rouge">PyBUF_WRITE</code>, <code class="language-plaintext highlighter-rouge">PyBUF_UPDATEIFCOPY</code>가 될 수 있습니다. <code class="language-plaintext highlighter-rouge">buffertype</code>이 <code class="language-plaintext highlighter-rouge">PyBUF_WRITE</code>이고 버퍼가 연속적이지 않으면 오류가 발생합니다. 이 경우 사용자는 <code class="language-plaintext highlighter-rouge">PyBUF_UPDATEIFCOPY</code>를 사용하여 쓰기 가능한 임시 연속 버퍼가 반환되도록 할 수 있습니다. 이 연속 버퍼의 내용은 <code class="language-plaintext highlighter-rouge">memoryview</code> 객체가 삭제된 후 원본 객체가 쓰기 가능한 한 원본 객체로 다시 복사됩니다. 이것이 원본 객체에 의해 허용되지 않으면 <code class="language-plaintext highlighter-rouge">BufferError</code>가 발생합니다.</p>

<p>객체가 다차원인 경우, <code class="language-plaintext highlighter-rouge">fortran</code>이 ‘F’이면 기본 배열의 첫 번째 차원이 버퍼에서 가장 빠르게 변합니다. <code class="language-plaintext highlighter-rouge">fortran</code>이 ‘C’이면 마지막 차원이 가장 빠르게 변합니다 (C-스타일 연속). <code class="language-plaintext highlighter-rouge">fortran</code>이 ‘A’이면 중요하지 않으며 객체가 더 효율적이라고 결정하는 것을 얻게 됩니다. 복사가 이루어지면 <code class="language-plaintext highlighter-rouge">PyMem_Free</code>를 호출하여 메모리를 해제해야 합니다.</p>

<p><code class="language-plaintext highlighter-rouge">memoryview</code> 객체에 대한 새로운 참조를 받습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">int PyObject_CopyToObject(PyObject *obj, void *buf, Py_ssize_t len, char fortran)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">buf</code>가 가리키는 연속적인 메모리 청크가 가리키는 <code class="language-plaintext highlighter-rouge">len</code> 바이트의 데이터를 <code class="language-plaintext highlighter-rouge">obj</code>가 내보내는 버퍼로 복사합니다. 성공 시 0을 반환하고, 실패 시 -1을 반환하며 오류를 발생시킵니다. 객체가 쓰기 가능한 버퍼를 가지고 있지 않으면 오류가 발생합니다. <code class="language-plaintext highlighter-rouge">fortran</code>이 ‘F’이면, 객체가 다차원인 경우 데이터는 Fortran-스타일(첫 번째 차원이 가장 빠르게 변함)로 배열에 복사됩니다. <code class="language-plaintext highlighter-rouge">fortran</code>이 ‘C’이면 데이터는 C-스타일(마지막 차원이 가장 빠르게 변함)로 배열에 복사됩니다. <code class="language-plaintext highlighter-rouge">fortran</code>이 ‘A’이면 중요하지 않으며 가장 효율적인 방식으로 복사가 이루어집니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">int PyObject_CopyData(PyObject *dest, PyObject *src)</code>
    <ul>
      <li>이 마지막 세 가지 C-API 호출은 데이터가 실제로 어떻게 저장되어 있든 상관없이 Python 객체에서 연속적인 메모리 영역으로 데이터를 가져오고 내보내는 표준적인 방법을 허용합니다. 이 호출들은 확장된 버퍼 인터페이스를 사용하여 작업을 수행합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">int PyBuffer_IsContiguous(Py_buffer *view, char fortran)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">view</code> 객체에 의해 정의된 메모리가 C-스타일 (<code class="language-plaintext highlighter-rouge">fortran</code> = ‘C’) 또는 Fortran-스타일 (<code class="language-plaintext highlighter-rouge">fortran</code> = ‘F’) 연속적이거나 둘 중 하나 (<code class="language-plaintext highlighter-rouge">fortran</code> = ‘A’)이면 1을 반환합니다. 그렇지 않으면 0을 반환합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">void PyBuffer_FillContiguousStrides(int ndim, Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t itemsize, char fortran)</code>
    <ul>
      <li>주어진 형상(shape)과 요소당 바이트 수(itemsize)를 가진 연속적인 배열(C-스타일, <code class="language-plaintext highlighter-rouge">fortran</code>이 ‘C’이면, 또는 Fortran-스타일, <code class="language-plaintext highlighter-rouge">fortran</code>이 ‘F’이면)의 바이트-스트라이드로 <code class="language-plaintext highlighter-rouge">strides</code> 배열을 채웁니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">int PyBuffer_FillInfo(Py_buffer *view, void *buf, Py_ssize_t len, int readonly, int infoflags)</code>
    <ul>
      <li>주어진 길이의 “부호 없는 바이트” 연속 메모리 청크만 공유할 수 있는 내보내는 객체를 위해 <code class="language-plaintext highlighter-rouge">buffer-info</code> 구조체를 올바르게 채웁니다. 성공 시 0을 반환하고, 오류 시 -1을 반환합니다 (오류 발생 포함).</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">PyExc_BufferError</code>
    <ul>
      <li>내보내는 객체가 소비자가 기대하는 종류의 버퍼를 제공할 수 없기 때문에 발생하는 버퍼 오류를 반환하기 위한 새로운 오류 객체입니다. 이 오류는 소비자가 프로토콜을 제공하지 않는 객체로부터 버퍼를 요청할 때도 발생합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="struct-문자열-구문-추가-사항-additions-to-the-struct-string-syntax"><code class="language-plaintext highlighter-rouge">struct</code> 문자열 구문 추가 사항 (<code class="language-plaintext highlighter-rouge">Additions to the struct string-syntax</code>)</h3>

<p><code class="language-plaintext highlighter-rouge">struct</code> 문자열 구문에는 이미 다른 곳(예: <code class="language-plaintext highlighter-rouge">ctypes</code> 및 NumPy)에서 사용할 수 있는 데이터 형식 설명(data-format descriptions)을 완전히 구현하기 위한 일부 문자가 누락되어 있습니다. Python 2.5 사양은 <a href="http://docs.python.org/library/struct.html">http://docs.python.org/library/struct.html</a>에 있습니다.</p>

<p>다음은 제안된 추가 사항입니다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">문자</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'t'</code></td>
      <td style="text-align: left">비트 (앞에 붙는 숫자가 몇 비트인지 나타냄)</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'?'</code></td>
      <td style="text-align: left">플랫폼 <code class="language-plaintext highlighter-rouge">_Bool</code> 타입</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'g'</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">long double</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'c'</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">ucs-1</code> (latin-1) 인코딩</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'u'</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">ucs-2</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'w'</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">ucs-4</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'O'</code></td>
      <td style="text-align: left">Python 객체에 대한 포인터</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'Z'</code></td>
      <td style="text-align: left">복소수 (다음 지정자가 무엇이든)</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'&amp;'</code></td>
      <td style="text-align: left">특정 포인터 (다른 문자 앞에 붙는 접두사)</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'T{}'</code></td>
      <td style="text-align: left">구조체 (내부에 상세 레이아웃 포함 {})</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'(k1,k2,…,kn)'</code></td>
      <td style="text-align: left">다음에 오는 무엇이든의 다차원 배열</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">':name:'</code></td>
      <td style="text-align: left">이전 요소의 선택적 이름</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'X{}'</code></td>
      <td style="text-align: left">함수에 대한 포인터 (선택적 함수 시그니처 내부에 {} 포함, 반환 값은 <code class="language-plaintext highlighter-rouge">-&gt;</code> 뒤에 붙고 끝에 위치)</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">struct</code> 모듈도 이러한 것들을 이해하고 언팩(unpacking) 시 적절한 Python 객체를 반환하도록 변경될 것입니다. <code class="language-plaintext highlighter-rouge">long-double</code>을 언팩하면 <code class="language-plaintext highlighter-rouge">decimal</code> 객체 또는 <code class="language-plaintext highlighter-rouge">ctypes</code> <code class="language-plaintext highlighter-rouge">long-double</code>이 반환됩니다. <code class="language-plaintext highlighter-rouge">'u'</code> 또는 <code class="language-plaintext highlighter-rouge">'w'</code>를 언팩하면 Python <code class="language-plaintext highlighter-rouge">unicode</code>가 반환됩니다. 다차원 배열을 언팩하면 리스트(1차원 이상인 경우 리스트의 리스트)가 반환됩니다. 포인터를 언팩하면 <code class="language-plaintext highlighter-rouge">ctypes</code> 포인터 객체가 반환됩니다. 함수 포인터를 언팩하면 <code class="language-plaintext highlighter-rouge">ctypes</code> <code class="language-plaintext highlighter-rouge">call-object</code>가 반환될 것입니다. 비트(bit)를 언팩하면 Python <code class="language-plaintext highlighter-rouge">Bool</code>이 반환됩니다. <code class="language-plaintext highlighter-rouge">struct</code> 문자열 구문 내의 공백은 이미 무시되지 않는다면 무시될 것입니다. 명명된 객체(named-object)를 언팩하면 튜플처럼 작동하지만 항목에 이름으로도 접근할 수 있는 <code class="language-plaintext highlighter-rouge">named-tuple</code>과 유사한 객체가 반환됩니다. 중첩된 구조체를 언팩하면 중첩된 튜플이 반환됩니다.</p>

<p>바이트 순서(Endian-specification) (<code class="language-plaintext highlighter-rouge">!</code>, <code class="language-plaintext highlighter-rouge">@</code>, <code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">^</code>)도 문자열 내에서 허용되므로 필요에 따라 변경될 수 있습니다. 이전에 지정된 바이트 순서 문자열은 변경될 때까지 유효합니다. 기본 바이트 순서는 ‘@’이며, 이는 네이티브 데이터 타입과 정렬을 의미합니다. 정렬되지 않은 네이티브 데이터 타입이 요청되면 바이트 순서 지정은 ‘^’입니다.</p>

<p><code class="language-plaintext highlighter-rouge">struct</code> 모듈에 따르면, 숫자 코드 앞에 숫자가 붙어 해당 타입의 개수를 지정할 수 있습니다. <code class="language-plaintext highlighter-rouge">(k1,k2,...,kn)</code> 확장 기능은 데이터가 특정 형식의 (C-스타일 연속, 마지막 차원이 가장 빠르게 변함) 다차원 배열로 보여져야 하는지 여부도 지정할 수 있도록 합니다.</p>

<p><code class="language-plaintext highlighter-rouge">ctypes</code>에 <code class="language-plaintext highlighter-rouge">struct</code> 설명으로부터 <code class="language-plaintext highlighter-rouge">ctypes</code> 객체를 생성하고, <code class="language-plaintext highlighter-rouge">long-double</code> 및 <code class="language-plaintext highlighter-rouge">ucs-2</code>를 <code class="language-plaintext highlighter-rouge">ctypes</code>에 추가하는 함수가 추가되어야 합니다.</p>

<h3 id="데이터-형식-설명-예시-examples-of-data-format-descriptions">데이터 형식 설명 예시 (Examples of Data-Format Descriptions)</h3>

<p>다음은 C-구조체의 예시와 <code class="language-plaintext highlighter-rouge">struct</code> 스타일 구문을 사용하여 어떻게 표현될 수 있는지 보여줍니다.</p>

<p><code class="language-plaintext highlighter-rouge">&lt;named&gt;</code>는 명명된 튜플(아직 지정되지 않음)의 생성자입니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">float</code> <code class="language-plaintext highlighter-rouge">'d'</code> &lt;–&gt; Python <code class="language-plaintext highlighter-rouge">float</code></li>
  <li><code class="language-plaintext highlighter-rouge">complex double</code> <code class="language-plaintext highlighter-rouge">'Zd'</code> &lt;–&gt; Python <code class="language-plaintext highlighter-rouge">complex</code></li>
  <li><code class="language-plaintext highlighter-rouge">RGB Pixel data</code> <code class="language-plaintext highlighter-rouge">'BBB'</code> &lt;–&gt; <code class="language-plaintext highlighter-rouge">(int, int, int)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">'B:r: B:g: B:b:'</code> &lt;–&gt; <code class="language-plaintext highlighter-rouge">&lt;named&gt;((int, int, int), ('r','g','b'))</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Mixed endian</code> (이상하지만 가능) <code class="language-plaintext highlighter-rouge">'&gt;i:big: &lt;i:little:'</code> &lt;–&gt; <code class="language-plaintext highlighter-rouge">&lt;named&gt;((int, int), ('big', 'little'))</code></li>
  <li>
    <p><strong>중첩된 구조체</strong></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ival</span><span class="p">;</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sval</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bval</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cval</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">sub</span><span class="p">;</span>
<span class="p">}</span>
<span class="s">"""i:ival: T{ H:sval: B:bval: B:cval: }:sub: """</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>중첩된 배열</strong></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ival</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="o">*</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span>
<span class="s">"""i:ival: (16,4)d:data: """</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>마지막 예시에서 비교되는 C-구조체는 의도적으로 2차원 배열 <code class="language-plaintext highlighter-rouge">data[16][4]</code>가 아닌 1차원 배열입니다. 이는 C의 정적 다차원 배열(연속적으로 배치됨)과 <code class="language-plaintext highlighter-rouge">data[0][1]</code>와 동일한 구문을 사용하여 요소에 접근하지만 메모리가 반드시 연속적이지는 않은 동적 다차원 배열 간의 혼동을 피하기 위함입니다. <code class="language-plaintext highlighter-rouge">struct</code> 구문은 항상 연속적인 메모리를 사용하며, 다차원 문자는 내보내는 객체가 소비자에게 전달할 메모리에 대한 정보입니다.</p>

<p>다시 말해, <code class="language-plaintext highlighter-rouge">struct</code> 구문 설명은 동일한 메모리 레이아웃을 설명하는 한 C-구문과 정확히 일치할 필요는 없습니다. C-컴파일러가 메모리를 <code class="language-plaintext highlighter-rouge">double</code>형 1차원 배열로 생각할 것이라는 사실은 내보내는 객체가 소비자에게 이 메모리 필드를 4개 요소마다 새로운 차원이 고려되는 2차원 배열로 생각해야 한다고 전달하려는 사실과 무관합니다.</p>

<h3 id="영향을-받는-코드-code-to-be-affected">영향을 받는 코드 (Code to be affected)</h3>

<p>이전 버퍼 인터페이스를 내보내거나 사용하는 Python의 모든 객체와 모듈이 수정될 것입니다. 다음은 부분적인 목록입니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">buffer</code> 객체</li>
  <li><code class="language-plaintext highlighter-rouge">bytes</code> 객체</li>
  <li><code class="language-plaintext highlighter-rouge">string</code> 객체</li>
  <li><code class="language-plaintext highlighter-rouge">unicode</code> 객체</li>
  <li><code class="language-plaintext highlighter-rouge">array</code> 모듈</li>
  <li><code class="language-plaintext highlighter-rouge">struct</code> 모듈</li>
  <li><code class="language-plaintext highlighter-rouge">mmap</code> 모듈</li>
  <li><code class="language-plaintext highlighter-rouge">ctypes</code> 모듈</li>
</ul>

<p>버퍼 API를 사용하는 다른 모든 것.</p>

<h3 id="문제-및-세부-사항-issues-and-details">문제 및 세부 사항 (Issues and Details)</h3>

<p>이 PEP는 기존 버퍼 프로토콜에 C-API와 두 가지 함수를 추가하여 Python 2.6으로 백포팅(back-ported)될 예정입니다.</p>

<p>이 PEP의 이전 버전에서는 읽기/쓰기 잠금(read/write locking) 체계를 제안했지만, 나중에 다음과 같이 인식되었습니다.
a) 잠금이 필요 없는 일반적인 간단한 사용 사례에는 너무 복잡하고,
b) 변경되고 짧게 유지되는 잠금을 사용하여 버퍼에 대한 동시 읽기/쓰기 접근이 필요한 사용 사례에는 너무 간단하다고 판단되었습니다.
따라서 동시 읽기/쓰기 접근에서 일관된 뷰(consistent views)가 필요한 경우 사용자가 버퍼 객체 주변에 자체적인 특정 잠금 체계를 구현하도록 맡겨져 있습니다. 이러한 사용자 체계에 대한 경험이 축적된 후에는 별도의 잠금 API를 포함하는 미래의 PEP가 제안될 수 있습니다.</p>

<p>스트라이드 메모리(strided memory)와 하위 오프셋(suboffsets)의 공유는 새로운 기능이며, 다중 세그먼트 인터페이스의 수정으로 볼 수 있습니다. 이는 NumPy와 PIL에서 영감을 받았습니다. NumPy 객체는 스트라이드 메모리를 관리하는 방법을 이해하는 코드와 스트라이드 메모리를 공유할 수 있어야 합니다. 왜냐하면 스트라이드 메모리는 계산 라이브러리와 인터페이스할 때 매우 흔하기 때문입니다.</p>

<p>또한, 이 접근 방식을 사용하면 복사 없이 두 가지 종류의 메모리 모두에서 작동하는 일반적인 코드를 작성할 수 있어야 합니다.</p>

<p><code class="language-plaintext highlighter-rouge">bufferinfo</code> 구조체의 <code class="language-plaintext highlighter-rouge">format</code> 문자열, <code class="language-plaintext highlighter-rouge">shape</code> 배열, <code class="language-plaintext highlighter-rouge">strides</code> 배열, <code class="language-plaintext highlighter-rouge">suboffsets</code> 배열의 메모리 관리는 항상 내보내는 객체의 책임입니다. 소비자는 이러한 포인터를 다른 메모리로 설정하거나 해제하려고 시도해서는 안 됩니다.</p>

<p>몇 가지 아이디어가 논의되었고 거부되었습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">release-buffer</code>가 호출되는 “releaser” 객체를 두는 것. 이것은 프로토콜을 비대칭적으로 만들었기 때문에 (버퍼를 “얻은” 것과 다른 것에 대해 해제를 호출했음) 받아들일 수 없다고 판단되었습니다. 또한 실제 이점 없이 프로토콜을 복잡하게 만들었습니다.</li>
  <li>모든 <code class="language-plaintext highlighter-rouge">struct</code> 변수를 함수에 별도로 전달하는 것. 이것은 관심 없는 변수에 <code class="language-plaintext highlighter-rouge">NULL</code>을 설정할 수 있다는 장점이 있었지만, 함수 호출을 더 어렵게 만들었습니다. <code class="language-plaintext highlighter-rouge">flags</code> 변수는 소비자가 프로토콜을 호출하는 방식에서 “간단”할 수 있는 동일한 기능을 허용합니다.</li>
</ul>

<h3 id="코드-code">코드 (Code)</h3>

<p>PEP 작성자들은 이 제안에 대한 코드를 기여하고 유지 관리할 것을 약속하지만, 어떠한 도움도 환영할 것입니다.</p>

<h3 id="코드-예시-code-examples">코드 예시 (Code Examples)</h3>

<h4 id="예시-1-ex-1">예시 1 (Ex. 1)</h4>

<p>이 예시는 연속적인 라인을 사용하는 이미지 객체가 버퍼를 어떻게 노출할 수 있는지를 보여줍니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">rgba</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">ImageObject</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">struct</span> <span class="n">rgba</span><span class="o">**</span> <span class="n">lines</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">height</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">width</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">shape_array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">Py_ssize_t</span> <span class="n">stride_array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">Py_ssize_t</span> <span class="n">view_count</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">"lines"</code>는 <code class="language-plaintext highlighter-rouge">malloc</code>으로 할당된 <code class="language-plaintext highlighter-rouge">struct rgba*</code>의 1차원 배열을 가리킵니다. 해당 블록의 각 포인터는 별도로 <code class="language-plaintext highlighter-rouge">malloc</code>으로 할당된 <code class="language-plaintext highlighter-rouge">struct rgba</code> 배열을 가리킵니다.</p>

<p>예를 들어, <code class="language-plaintext highlighter-rouge">x=30, y=50</code>에 있는 픽셀의 빨간색 값에 접근하려면 <code class="language-plaintext highlighter-rouge">"lines[50][30].r"</code>을 사용합니다.</p>

<p>그렇다면 <code class="language-plaintext highlighter-rouge">ImageObject</code>의 <code class="language-plaintext highlighter-rouge">getbuffer</code>는 무엇을 할까요? 오류 검사를 제외하면 다음과 같습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">Image_getbuffer</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Py_buffer</span> <span class="o">*</span><span class="n">view</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">Py_ssize_t</span> <span class="n">suboffsets</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
    <span class="n">view</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">lines</span><span class="p">;</span>
    <span class="n">view</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">height</span><span class="o">*</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
    <span class="n">view</span><span class="o">-&gt;</span><span class="n">readonly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">view</span><span class="o">-&gt;</span><span class="n">ndims</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">shape_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">shape_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
    <span class="n">view</span><span class="o">-&gt;</span><span class="n">shape</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">shape_array</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">stride_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rgba</span><span class="o">*</span><span class="p">);</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">stride_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rgba</span><span class="p">);</span>
    <span class="n">view</span><span class="o">-&gt;</span><span class="n">strides</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">stride_array</span><span class="p">;</span>
    <span class="n">view</span><span class="o">-&gt;</span><span class="n">suboffsets</span> <span class="o">=</span> <span class="n">suboffsets</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">view_count</span> <span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">Image_releasebuffer</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Py_buffer</span> <span class="o">*</span><span class="n">view</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">view_count</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="예시-2-ex-2">예시 2 (Ex. 2)</h4>

<p>이 예시는 (객체가 살아있는 동안에는 재할당되지 않는) 연속적인 메모리 청크를 노출하려는 객체가 이를 어떻게 수행하는지 보여줍니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">myobject_getbuffer</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">Py_buffer</span> <span class="o">*</span><span class="n">view</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">readonly</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="cm">/* Point to buffer */</span>
    <span class="n">len</span> <span class="o">=</span> <span class="cm">/* Set to size of buffer */</span>
    <span class="n">readonly</span> <span class="o">=</span> <span class="cm">/* Set to 1 if readonly */</span>
    <span class="k">return</span> <span class="n">PyObject_FillBufferInfo</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">readonly</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* No releasebuffer is necessary because the memory will never be re-allocated */</span>
</code></pre></div></div>

<h4 id="예시-3-ex-3">예시 3 (Ex. 3)</h4>

<p>Python 객체 <code class="language-plaintext highlighter-rouge">obj</code>에서 간단한 연속 바이트 청크만 얻고 싶은 소비자는 다음을 수행합니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Py_buffer</span> <span class="n">view</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyObject_GetBuffer</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">view</span><span class="p">,</span> <span class="n">Py_BUF_SIMPLE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* error return */</span>
<span class="p">}</span>
<span class="cm">/* Now, view.buf is the pointer to memory
   view.len is the length
   view.readonly is whether or not the memory is read-only. */</span>
<span class="cm">/* After using the information and you don't need it anymore */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyBuffer_Release</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">view</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* error return */</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="예시-4-ex-4">예시 4 (Ex. 4)</h4>

<p>어떤 객체의 메모리도 사용할 수 있지만 연속적인 메모리만 처리하는 알고리즘을 작성하는 소비자는 다음을 수행할 수 있습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
<span class="n">Py_ssize_t</span> <span class="n">len</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">copy</span><span class="p">;</span>
<span class="n">copy</span> <span class="o">=</span> <span class="n">PyObject_GetContiguous</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">format</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* error return */</span>
<span class="p">}</span>
<span class="cm">/* process memory pointed to by buffer if format is correct */</span>
<span class="cm">/* Optional: if, after processing, we want to copy data from buffer back into the object we could do */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PyObject_CopyToObject</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* error return */</span>
<span class="p">}</span>
<span class="cm">/* Make sure that if a copy was made, the memory is freed */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">PyMem_Free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/tags/#python" class="page__taxonomy-item" rel="tag">Python</a><span class="sep">, </span>
    
      <a href="/tags/#translation" class="page__taxonomy-item" rel="tag">Translation</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/categories/#python" class="page__taxonomy-item" rel="tag">Python</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2025-09-27">September 27, 2025</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/python/pep/3117/" class="pagination--pager" title="[Rejected] PEP 3117 - Postfix type declarations
">Previous</a>
    
    
      <a href="/python/pep/3119/" class="pagination--pager" title="[Final] PEP 3119 - Introducing Abstract Base Classes
">Next</a>
    
  </nav>


    </div>

    
  </article>

</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 secrett2633. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'secrett2633/secrett2633.github.io');
    script.setAttribute('issue-term', 'pathname');
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





  </body>
</html>
