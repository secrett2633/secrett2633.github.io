<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <style> 
      ::-webkit-scrollbar{ 
        width: 10px;
        height: 10px;
      }

      ::-webkit-scrollbar-track {
        width: 0px;
        background-color: #626262;
        /* border-radius: 5px; */
      }

      ::-webkit-scrollbar-thumb {
        width: 0px;
        background-color: #E2E2E2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-thumb:hover {
        width: 10px;
        height: 20px;
        /* background-color: rgba(190, 190, 190, 0.2); */
        background-color: #A2A2A2;
        border-radius: 5px;
      }

      ::-webkit-scrollbar-track:hover {
        width: 10px;
        /* background-color: rgba(150, 150, 150, 0.1); */
        background-color: #626262;
        border-radius: 5px;
        /* background: transparent; */
        /* border-radius: 10px; */
      }

      ::-webkit-scrollbar-button:start:decrement,::-webkit-scrollbar-button:end:increment {
          width:0px;
          height: 0px;
          /* background-color: rgb(14, 221, 24); */
          /* border-radius: 50%; */
      }
    </style>
    
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[Final] PEP 526 - Syntax for Variable Annotations | secrett2633</title>
<meta name="description" content="Python Enhancement Proposal 526: ‘Syntax for Variable Annotations’에 대한 한국어 번역입니다.">


  <meta name="author" content="secrett2633">
  
  <meta property="article:author" content="secrett2633">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="secrett2633's blog">
<meta property="og:title" content="[Final] PEP 526 - Syntax for Variable Annotations">
<meta property="og:url" content="http://localhost:4000/python/pep/526/">


  <meta property="og:description" content="Python Enhancement Proposal 526: ‘Syntax for Variable Annotations’에 대한 한국어 번역입니다.">







  <meta property="article:published_time" content="2025-09-26T23:19:02+09:00">



  <meta property="article:modified_time" content="2025-09-26T23:19:02+09:00">



  

  


<link rel="canonical" href="http://localhost:4000/python/pep/526/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "secrett2633",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="secrett2633's blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->


    <link rel="icon" type="image/png" sizes="32x32" href="https://secrett2633.github.io/assets/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://secrett2633.github.io/assets/images/favicon/favicon-16x16.png">
    <meta name="msapplication-TileColor" content="#ffc40d">
    <meta name="theme-color" content="#ffffff">
  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          secrett2633's blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://github.com/secrett2633">GitHub</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <!-- 2022.02.17 author content hidden -->
  <!-- <div class="author__content">
    
      <h3 class="author__name" itemprop="name">secrett2633</h3>
    
    
  </div> -->

  <div class="author__urls-wrapper">
    <!-- <button class="btn btn--inverse">Follow</button> -->
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
    
      
      
      
      
    
    
      <nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    <!-- Backend -->
    <li>
      <span class="nav__sub-title">Backend</span>
      <hr>
      <ul>
        <li><a href="/backend/django/">Django</a></li>
        <li><a href="/backend/logging/">Logging</a></li>
      </ul>
    </li>

    <!-- Python -->
    <li>
      <span class="nav__sub-title">Python</span>
      <hr>
      <ul>
        <li><a href="/python/pep/">PEP</a></li>
      </ul>
    </li>

    <!-- AI/ML -->
    <li>
      <span class="nav__sub-title">AI/ML</span>
      <hr>
      <ul>
        <li><a href="/ai/llm/">LLM</a></li>
        <li><a href="/ai/review/">Review</a></li>
      </ul>
    </li>

    <!-- DevOps -->
    <li>
      <span class="nav__sub-title">DevOps</span>
      <hr>
      <ul>
        <li><a href="/devops/nginx/">Nginx</a></li>
        <li><a href="/devops/docker/">Docker</a></li>
        <li><a href="/devops/safeline/">SafeLine</a></li>
        <li><a href="/devops/jenkins/">Jenkins</a></li>
        <li><a href="/devops/github-actions/">GitHub Actions</a></li>
        <li><a href="/devops/aws/">AWS</a></li>
      </ul>
    </li>

    <!-- etc -->
    <li>
      <span class="nav__sub-title">etc</span>
      <hr>
      <ul>
        <li><a href="/etc/me/">Me</a></li>
        <li><a href="/etc/chrome-extension/">Chrome Extension</a></li>
      </ul>
    </li>
  </ul>
</nav>
    
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[Final] PEP 526 - Syntax for Variable Annotations">
    <meta itemprop="description" content="Python Enhancement Proposal 526: ‘Syntax for Variable Annotations’에 대한 한국어 번역입니다.">
    <meta itemprop="datePublished" content="2025-09-26T23:19:02+09:00">
    <meta itemprop="dateModified" content="2025-09-26T23:19:02+09:00">

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">[Final] PEP 526 - Syntax for Variable Annotations
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2025-09-26T23:19:02+09:00">September 26, 2025</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#개요-abstract">개요 (Abstract)</a></li><li><a href="#배경-rationale">배경 (Rationale)</a><ul><li><a href="#비목표-non-goals">비목표 (Non-goals)</a></li></ul></li><li><a href="#사양-specification">사양 (Specification)</a><ul><li><a href="#전역-및-지역-변수-어노테이션-global-and-local-variable-annotations">전역 및 지역 변수 어노테이션 (Global and local variable annotations)</a></li><li><a href="#클래스-및-인스턴스-변수-어노테이션-class-and-instance-variable-annotations">클래스 및 인스턴스 변수 어노테이션 (Class and instance variable annotations)</a></li><li><a href="#표현식-어노테이션-annotating-expressions">표현식 어노테이션 (Annotating expressions)</a></li><li><a href="#어노테이션이-허용되지-않는-경우-where-annotations-arent-allowed">어노테이션이 허용되지 않는 경우 (Where annotations aren’t allowed)</a></li><li><a href="#스텁-파일의-변수-어노테이션-variable-annotations-in-stub-files">스텁 파일의 변수 어노테이션 (Variable annotations in stub files)</a></li><li><a href="#변수-어노테이션에-대한-권장-코딩-스타일-preferred-coding-style-for-variable-annotations">변수 어노테이션에 대한 권장 코딩 스타일 (Preferred coding style for variable annotations)</a></li></ul></li><li><a href="#표준-라이브러리-및-문서-변경-사항-changes-to-standard-library-and-documentation">표준 라이브러리 및 문서 변경 사항 (Changes to Standard Library and Documentation)</a></li><li><a href="#타입-어노테이션의-런타임-효과-runtime-effects-of-type-annotations">타입 어노테이션의 런타임 효과 (Runtime Effects of Type Annotations)</a><ul><li><a href="#기타-어노테이션-사용-other-uses-of-annotations">기타 어노테이션 사용 (Other uses of annotations)</a></li></ul></li><li><a href="#거부연기된-제안-rejectedpostponed-proposals">거부/연기된 제안 (Rejected/Postponed Proposals)</a></li><li><a href="#하위-호환성-backwards-compatibility">하위 호환성 (Backwards Compatibility)</a></li><li><a href="#구현-implementation">구현 (Implementation)</a></li><li><a href="#저작권-copyright">저작권 (Copyright)</a></li></ul>

            </nav>
          </aside>
        
        <blockquote>
  <p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0526/">PEP 526 - Syntax for Variable Annotations</a></p>

  <table>
    <tbody>
      <tr>
        <td><strong>상태:</strong> Final</td>
        <td><strong>유형:</strong> Standards Track</td>
        <td><strong>작성일:</strong> 09-Aug-2016</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<p><strong>PEP 526 – 변수 어노테이션 구문 (Syntax for Variable Annotations)</strong></p>

<h2 id="개요-abstract">개요 (Abstract)</h2>

<p>PEP 484는 타입 힌트(type hints), 즉 타입 어노테이션(type annotations)을 도입했습니다. 주로 함수 어노테이션에 중점을 두었지만, 변수를 어노테이션하기 위한 타입 주석(type comments) 개념도 함께 소개했습니다.</p>

<p>예시:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 'primes'는 정수 리스트입니다.
</span><span class="n">primes</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># type: List[int]
# 'captain'은 문자열입니다. (참고: 초기값이 문제입니다)
</span><span class="n">captain</span> <span class="o">=</span> <span class="p">...</span> <span class="c1"># type: str
</span>
<span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="c1"># 'stats'는 클래스 변수입니다.
</span>    <span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># type: Dict[str, int]
</span></code></pre></div></div>

<p>이 PEP는 위와 같이 주석을 통해 변수의 타입(클래스 변수 및 인스턴스 변수 포함)을 표현하는 대신, 이를 위한 파이썬 구문을 추가하는 것을 목표로 합니다.</p>

<p>새로운 구문 예시:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">primes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">captain</span><span class="p">:</span> <span class="nb">str</span> <span class="c1"># 참고: 초기값이 없습니다!
</span>
<span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div></div>

<p>PEP 484는 타입 주석이 복잡한 경우 타입 추론(type inference)에 도움이 되도록 의도되었다고 명시하며, 이 PEP는 이러한 의도를 변경하지 않습니다. 그러나 실제로는 타입 주석이 클래스 변수와 인스턴스 변수에도 채택되었으므로, 이 PEP는 이러한 변수에 대한 타입 어노테이션 사용법도 논의합니다.</p>

<h2 id="배경-rationale">배경 (Rationale)</h2>

<p>타입 주석은 충분히 잘 작동하지만, 주석으로 표현된다는 점 때문에 몇 가지 단점이 있습니다.</p>

<ul>
  <li>텍스트 편집기가 타입 어노테이션과 주석을 다르게 강조 표시하는 경우가 많습니다.</li>
  <li>정의되지 않은 변수의 타입을 어노테이션할 방법이 없습니다. <code class="language-plaintext highlighter-rouge">a = None # type: int</code>와 같이 <code class="language-plaintext highlighter-rouge">None</code>으로 초기화해야 합니다.</li>
  <li>조건부 분기(conditional branch)에서 어노테이션된 변수는 읽기 어렵습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">some_value</span><span class="p">:</span>
    <span class="n">my_var</span> <span class="o">=</span> <span class="nf">function</span><span class="p">()</span> <span class="c1"># type: Logger
</span><span class="k">else</span><span class="p">:</span>
    <span class="n">my_var</span> <span class="o">=</span> <span class="nf">another_function</span><span class="p">()</span> <span class="c1"># 여기에는 왜 타입이 없을까요?
</span></code></pre></div>    </div>
  </li>
  <li>타입 주석은 실제로 언어의 일부가 아니므로, 파이썬 스크립트가 이를 파싱하려면 <code class="language-plaintext highlighter-rouge">ast</code> 모듈 대신 사용자 정의 파서(custom parser)가 필요합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">typeshed</code>에서 타입 주석이 많이 사용됩니다. <code class="language-plaintext highlighter-rouge">typeshed</code>를 변수 어노테이션 구문을 사용하도록 마이그레이션하면 스텁 파일(stub files)의 가독성이 향상될 것입니다.</li>
  <li>일반 주석과 타입 주석이 함께 사용되는 상황에서는 구별하기 어렵습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">path</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># type: Optional[str] # 모듈 소스 경로
</span></code></pre></div>    </div>
  </li>
  <li>모듈의 소스 코드를 찾아서 런타임에 파싱하려는 시도 없이는 런타임에 어노테이션을 검색하는 것이 불가능하며, 이는 우아하지 않습니다.</li>
</ul>

<p>이러한 문제들의 대부분은 새로운 구문을 언어의 핵심 부분으로 만듦으로써 완화될 수 있습니다. 또한, 클래스 및 인스턴스 변수에 대한 전용 어노테이션 구문을 갖는 것은 PEP 484에 정의된 명목적 타이핑(nominal typing)을 보완하는 정적 덕 타이핑(static duck-typing)의 길을 열어줄 것입니다.</p>

<h3 id="비목표-non-goals">비목표 (Non-goals)</h3>

<p>이 제안은 런타임에 어노테이션을 검색하기 위한 표준 라이브러리 함수 <code class="language-plaintext highlighter-rouge">typing.get_type_hints</code>의 확장을 동반하지만, 변수 어노테이션은 런타임 타입 검사(runtime type checking)를 위해 설계된 것이 아닙니다. 이러한 기능을 구현하려면 서드파티 패키지가 개발되어야 합니다.</p>

<p>또한 파이썬은 동적 타입 언어(dynamically typed language)로 남을 것이며, 저자들은 타입 힌트가 관례적으로라도 의무화되는 것을 원하지 않는다는 점을 강조해야 합니다. 타입 어노테이션은 정적 타입 언어(statically typed languages)의 변수 선언과 혼동되어서는 안 됩니다. 어노테이션 구문의 목표는 서드파티 도구를 위한 구조화된 타입 메타데이터를 지정하는 쉬운 방법을 제공하는 것입니다.</p>

<p>이 PEP는 타입 검사기가 타입 검사 규칙을 변경하도록 요구하지 않습니다. 단지 타입 주석을 대체할 더 읽기 쉬운 구문을 제공할 뿐입니다.</p>

<h2 id="사양-specification">사양 (Specification)</h2>

<p>타입 어노테이션은 할당문(assignment statement)이나 단일 표현식(single expression)에 추가될 수 있으며, 서드파티 타입 검사기에게 어노테이션 대상의 원하는 타입을 알려줍니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_var</span><span class="p">:</span> <span class="nb">int</span>
<span class="n">my_var</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># 타입 검사를 통과합니다.
</span><span class="n">other_var</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span> <span class="c1"># 타입 검사기에서 오류로 플래그됩니다.
</span>                     <span class="c1"># 하지만 런타임에는 문제 없습니다.
</span></code></pre></div></div>

<p>이 구문은 PEP 484를 넘어 새로운 의미론을 도입하지 않으므로, 다음 세 가지 문장은 동일합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">var</span> <span class="o">=</span> <span class="n">value</span> <span class="c1"># type: annotation
</span><span class="n">var</span><span class="p">:</span> <span class="n">annotation</span><span class="p">;</span> <span class="n">var</span> <span class="o">=</span> <span class="n">value</span>
<span class="n">var</span><span class="p">:</span> <span class="n">annotation</span> <span class="o">=</span> <span class="n">value</span>
</code></pre></div></div>

<p>아래에서는 다양한 맥락에서의 타입 어노테이션 구문과 그 런타임 효과를 명시합니다. 또한 타입 검사기가 어노테이션을 어떻게 해석할 수 있는지 제안하지만, 이러한 제안에 대한 준수는 필수가 아닙니다 (이는 PEP 484의 준수에 대한 태도와 일치합니다).</p>

<h3 id="전역-및-지역-변수-어노테이션-global-and-local-variable-annotations">전역 및 지역 변수 어노테이션 (Global and local variable annotations)</h3>

<p>지역 변수(locals)와 전역 변수(globals)의 타입은 다음과 같이 어노테이션할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">some_number</span><span class="p">:</span> <span class="nb">int</span> <span class="c1"># 초기값 없는 변수
</span><span class="n">some_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 초기값 있는 변수
</span></code></pre></div></div>

<p>초기값을 생략할 수 있으므로, 조건부 분기에서 할당되는 변수의 타이핑이 더 쉬워집니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sane_world</span><span class="p">:</span> <span class="nb">bool</span>
<span class="k">if</span> <span class="mi">2</span><span class="o">+</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
    <span class="n">sane_world</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">sane_world</span> <span class="o">=</span> <span class="bp">False</span>
</code></pre></div></div>

<p>이 구문이 튜플 패킹(tuple packing)을 허용하지만, 튜플 언패킹(tuple unpacking)을 사용할 때는 변수의 타입을 어노테이션할 수 없다는 점에 유의하십시오.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 변수 어노테이션 구문을 사용한 튜플 패킹
</span><span class="n">t</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">...]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1"># 또는
</span><span class="n">t</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">...]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="c1"># Python 3.8 이상에서만 작동
</span>
<span class="c1"># 변수 어노테이션 구문을 사용한 튜플 언패킹
</span><span class="n">header</span><span class="p">:</span> <span class="nb">str</span> <span class="n">kind</span><span class="p">:</span> <span class="nb">int</span> <span class="n">body</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="c1"># 이 구문은 유효하지 않습니다.
</span><span class="n">header</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="n">message</span> <span class="c1"># 각 변수에 개별적으로 어노테이션해야 합니다.
</span></code></pre></div></div>

<p>초기값을 생략하면 변수가 초기화되지 않은 상태로 남습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">:</span> <span class="nb">int</span>
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># NameError 발생
</span></code></pre></div></div>

<p>그러나 지역 변수를 어노테이션하면 인터프리터는 항상 이를 지역 변수로 만듭니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># UnboundLocalError 발생
</span>    <span class="c1"># 'a: int'를 주석 처리하면 NameError가 발생합니다.
</span></code></pre></div></div>

<p>이는 마치 코드가 다음과 같았던 것과 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="k">if</span> <span class="bp">False</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># UnboundLocalError 발생
</span></code></pre></div></div>

<p>중복된 타입 어노테이션은 무시됩니다. 그러나 정적 타입 검사기는 동일한 변수에 대해 다른 타입으로 어노테이션할 경우 경고를 발행할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">:</span> <span class="nb">int</span>
<span class="n">a</span><span class="p">:</span> <span class="nb">str</span> <span class="c1"># 정적 타입 검사기가 이에 대해 경고할 수도 있고 안 할 수도 있습니다.
</span></code></pre></div></div>

<h3 id="클래스-및-인스턴스-변수-어노테이션-class-and-instance-variable-annotations">클래스 및 인스턴스 변수 어노테이션 (Class and instance variable annotations)</h3>

<p>타입 어노테이션은 클래스 본문(class bodies) 및 메서드(methods) 내의 클래스 및 인스턴스 변수를 어노테이션하는 데에도 사용될 수 있습니다. 특히, 값이 없는 표기법 <code class="language-plaintext highlighter-rouge">a: int</code>는 <code class="language-plaintext highlighter-rouge">__init__</code> 또는 <code class="language-plaintext highlighter-rouge">__new__</code>에서 초기화되어야 하는 인스턴스 변수를 어노테이션할 수 있도록 합니다. 제안된 구문은 다음과 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BasicStarship</span><span class="p">:</span>
    <span class="n">captain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sh">'</span><span class="s">Picard</span><span class="sh">'</span> <span class="c1"># 기본값을 가진 인스턴스 변수
</span>    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="c1"># 기본값 없는 인스턴스 변수
</span>    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># 클래스 변수
</span></code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">ClassVar</code>는 <code class="language-plaintext highlighter-rouge">typing</code> 모듈에 의해 정의된 특별한 클래스로, 정적 타입 검사기에게 이 변수가 인스턴스에서 설정되어서는 안 된다는 것을 나타냅니다.</p>

<p><code class="language-plaintext highlighter-rouge">ClassVar</code> 매개변수는 중첩 수준에 관계없이 어떤 타입 변수(type variables)도 포함할 수 없습니다. <code class="language-plaintext highlighter-rouge">ClassVar[T]</code>와 <code class="language-plaintext highlighter-rouge">ClassVar[List[Set[T]]]</code>는 모두 <code class="language-plaintext highlighter-rouge">T</code>가 타입 변수인 경우 유효하지 않습니다.</p>

<p>자세한 예시로 설명할 수 있습니다. 다음 클래스에서:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">captain</span> <span class="o">=</span> <span class="sh">'</span><span class="s">Picard</span><span class="sh">'</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">damage</span><span class="p">,</span> <span class="n">captain</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">damage</span> <span class="o">=</span> <span class="n">damage</span>
        <span class="k">if</span> <span class="n">captain</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">captain</span> <span class="o">=</span> <span class="n">captain</span>
        <span class="c1"># Else keep the default
</span>    <span class="k">def</span> <span class="nf">hit</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">Starship</span><span class="p">.</span><span class="n">stats</span><span class="p">[</span><span class="sh">'</span><span class="s">hits</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">'</span><span class="s">hits</span><span class="sh">'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">stats</code>는 클래스 변수(다양한 게임별 통계를 추적)로 의도되었으며, <code class="language-plaintext highlighter-rouge">captain</code>은 클래스에서 기본값이 설정된 인스턴스 변수입니다. 이 차이는 타입 검사기에 의해 인지되지 않을 수 있습니다. 둘 다 클래스 레벨에서 초기화되지만, <code class="language-plaintext highlighter-rouge">captain</code>은 인스턴스 변수에 대한 편리한 기본값으로만 작용하는 반면, <code class="language-plaintext highlighter-rouge">stats</code>는 진정한 클래스 변수입니다. 즉, 모든 인스턴스에 의해 공유되도록 의도되었습니다.</p>

<p>두 변수 모두 클래스 레벨에서 초기화되므로, 클래스 변수를 <code class="language-plaintext highlighter-rouge">ClassVar[...]</code>로 래핑된 타입으로 어노테이션하여 구별하는 것이 유용합니다. 이러한 방식으로 타입 검사기는 인스턴스에서 동일한 이름의 속성에 대한 우발적인 할당을 플래그할 수 있습니다.</p>

<p>예를 들어, 논의된 클래스를 어노테이션하면 다음과 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">captain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sh">'</span><span class="s">Picard</span><span class="sh">'</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">captain</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">damage</span> <span class="o">=</span> <span class="n">damage</span>
        <span class="k">if</span> <span class="n">captain</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">captain</span> <span class="o">=</span> <span class="n">captain</span>
        <span class="c1"># Else keep the default
</span>    <span class="k">def</span> <span class="nf">hit</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">Starship</span><span class="p">.</span><span class="n">stats</span><span class="p">[</span><span class="sh">'</span><span class="s">hits</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">'</span><span class="s">hits</span><span class="sh">'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">enterprise_d</span> <span class="o">=</span> <span class="nc">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="p">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># 타입 검사기에서 오류로 플래그됩니다.
</span><span class="n">Starship</span><span class="p">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># 이것은 괜찮습니다.
</span></code></pre></div></div>

<p>편의상(그리고 관례상), 인스턴스 변수는 클래스 내부가 아닌 <code class="language-plaintext highlighter-rouge">__init__</code> 또는 다른 메서드에서 어노테이션될 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="nc">TypeVar</span><span class="p">(</span><span class="sh">'</span><span class="s">T</span><span class="sh">'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Box</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">content</span><span class="p">:</span> <span class="n">T</span> <span class="o">=</span> <span class="n">content</span>
</code></pre></div></div>

<h3 id="표현식-어노테이션-annotating-expressions">표현식 어노테이션 (Annotating expressions)</h3>

<p>어노테이션의 대상은 구문상 유효한 모든 단일 할당 대상(single assignment target)일 수 있습니다 (이에 대해 타입 검사기가 무엇을 할지는 타입 검사기에 달려 있습니다).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Cls</span><span class="p">:</span> <span class="k">pass</span>
<span class="n">c</span> <span class="o">=</span> <span class="nc">Cls</span><span class="p">()</span>
<span class="n">c</span><span class="p">.</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># c.x를 int로 어노테이션합니다.
</span><span class="n">c</span><span class="p">.</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="c1"># c.y를 int로 어노테이션합니다.
</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">d</span><span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">]:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># d['a']를 int로 어노테이션합니다.
</span><span class="n">d</span><span class="p">[</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">]:</span> <span class="nb">int</span> <span class="c1"># d['b']를 int로 어노테이션합니다.
</span></code></pre></div></div>

<p>괄호로 묶인 이름조차도 단순한 이름이 아니라 표현식으로 간주된다는 점에 유의하십시오.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="nb">int</span> <span class="c1"># x를 int로 어노테이션하며, (x)는 컴파일러에 의해 표현식으로 처리됩니다.
</span><span class="p">(</span><span class="n">y</span><span class="p">):</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 여기도 마찬가지입니다.
</span></code></pre></div></div>

<h3 id="어노테이션이-허용되지-않는-경우-where-annotations-arent-allowed">어노테이션이 허용되지 않는 경우 (Where annotations aren’t allowed)</h3>

<p>동일한 함수 스코프(function scope) 내에서 <code class="language-plaintext highlighter-rouge">global</code> 또는 <code class="language-plaintext highlighter-rouge">nonlocal</code>에 적용되는 변수를 어노테이션하려고 시도하는 것은 불법입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="c1"># SyntaxError
</span><span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="c1"># 또한 SyntaxError
</span>    <span class="k">global</span> <span class="n">x</span>
</code></pre></div></div>

<p>그 이유는 <code class="language-plaintext highlighter-rouge">global</code>과 <code class="language-plaintext highlighter-rouge">nonlocal</code>은 변수를 소유하지 않기 때문입니다. 따라서 타입 어노테이션은 변수를 소유하는 스코프에 속해야 합니다.</p>

<p>단일 할당 대상과 단일 오른쪽 값만 허용됩니다. 또한 <code class="language-plaintext highlighter-rouge">for</code> 또는 <code class="language-plaintext highlighter-rouge">with</code> 문에서 사용되는 변수는 어노테이션할 수 없습니다. 튜플 언패킹과 유사한 방식으로 미리 어노테이션할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">:</span> <span class="nb">int</span>
<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">my_iter</span><span class="p">:</span>
    <span class="bp">...</span>

<span class="n">f</span><span class="p">:</span> <span class="n">MyFile</span>
<span class="k">with</span> <span class="nf">myfunc</span><span class="p">()</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="bp">...</span>
</code></pre></div></div>

<h3 id="스텁-파일의-변수-어노테이션-variable-annotations-in-stub-files">스텁 파일의 변수 어노테이션 (Variable annotations in stub files)</h3>

<p>변수 어노테이션은 타입 주석보다 읽기 쉽기 때문에 Python 2.7을 포함한 모든 Python 버전의 스텁 파일에서 선호됩니다. 스텁 파일은 Python 인터프리터에 의해 실행되지 않으므로, 변수 어노테이션을 사용해도 오류가 발생하지 않습니다. 타입 검사기는 모든 Python 버전의 스텁에서 변수 어노테이션을 지원해야 합니다. 예를 들어:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 파일 lib.pyi
</span><span class="n">ADDRESS</span><span class="p">:</span> <span class="nb">unicode</span> <span class="o">=</span> <span class="bp">...</span>
<span class="k">class</span> <span class="nc">Error</span><span class="p">:</span>
    <span class="n">cause</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="변수-어노테이션에-대한-권장-코딩-스타일-preferred-coding-style-for-variable-annotations">변수 어노테이션에 대한 권장 코딩 스타일 (Preferred coding style for variable annotations)</h3>

<p>모듈 레벨 변수, 클래스 및 인스턴스 변수, 지역 변수에 대한 어노테이션은 해당 콜론 뒤에 단일 공백이 있어야 합니다. 콜론 앞에는 공백이 없어야 합니다. 할당문에 오른쪽 값이 있는 경우, 등호 양쪽에 정확히 하나의 공백이 있어야 합니다.</p>

<p>예시:
<strong>권장:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">code</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="n">coords</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sh">'</span><span class="s">&lt;unknown&gt;</span><span class="sh">'</span>
</code></pre></div></div>

<p><strong>비권장:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">code</span><span class="p">:</span><span class="nb">int</span> <span class="c1"># 콜론 뒤에 공백 없음
</span><span class="n">code</span> <span class="p">:</span> <span class="nb">int</span> <span class="c1"># 콜론 앞에 공백 있음
</span>
<span class="k">class</span> <span class="nc">Test</span><span class="p">:</span>
    <span class="n">result</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span> <span class="c1"># 등호 양쪽에 공백 없음
</span></code></pre></div></div>

<h2 id="표준-라이브러리-및-문서-변경-사항-changes-to-standard-library-and-documentation">표준 라이브러리 및 문서 변경 사항 (Changes to Standard Library and Documentation)</h2>

<ul>
  <li>새로운 공변(covariant) 타입 <code class="language-plaintext highlighter-rouge">ClassVar[T_co]</code>가 <code class="language-plaintext highlighter-rouge">typing</code> 모듈에 추가됩니다. 이는 유효한 타입이어야 하는 단일 인자만 허용하며, 클래스 인스턴스에서 설정되어서는 안 되는 클래스 변수를 어노테이션하는 데 사용됩니다. 이 제한은 정적 검사기에 의해 보장되지만 런타임에는 보장되지 않습니다. <code class="language-plaintext highlighter-rouge">ClassVar</code> 사용법에 대한 예시 및 설명은 <code class="language-plaintext highlighter-rouge">classvar</code> 섹션을 참조하고, <code class="language-plaintext highlighter-rouge">ClassVar</code> 뒤에 있는 이유에 대한 자세한 정보는 <code class="language-plaintext highlighter-rouge">rejected</code> 섹션을 참조하십시오.</li>
  <li><code class="language-plaintext highlighter-rouge">typing</code> 모듈의 <code class="language-plaintext highlighter-rouge">get_type_hints</code> 함수가 확장되어, 함수뿐만 아니라 모듈 및 클래스에서도 런타임에 타입 어노테이션을 검색할 수 있습니다. 어노테이션은 변수 또는 인자를 해당 타입 힌트에 매핑하는 사전(dictionary) 형태로 반환되며, 전방 참조(forward references)는 평가됩니다. 클래스의 경우, 메서드 결정 순서(method resolution order)에 따라 구성된 매핑(<code class="language-plaintext highlighter-rouge">collections.ChainMap</code>일 수 있음)을 반환합니다.</li>
  <li>어노테이션 사용에 대한 권장 지침이 문서에 추가될 것이며, 이 PEP와 PEP 484에 설명된 사양을 교육적으로 요약한 내용을 포함할 것입니다. 또한, 타입 주석을 타입 어노테이션으로 변환하는 도우미 스크립트가 표준 라이브러리와 별도로 게시될 것입니다.</li>
</ul>

<h2 id="타입-어노테이션의-런타임-효과-runtime-effects-of-type-annotations">타입 어노테이션의 런타임 효과 (Runtime Effects of Type Annotations)</h2>

<p>지역 변수를 어노테이션하면 할당되지 않았더라도 인터프리터는 이를 지역 변수로 처리합니다. 지역 변수에 대한 어노테이션은 평가되지 않습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">NonexistentName</span> <span class="c1"># 오류 없음.
</span></code></pre></div></div>

<p>그러나 모듈 또는 클래스 레벨에 있는 경우, 타입은 평가됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">:</span> <span class="n">NonexistentName</span> <span class="c1"># 오류!
</span><span class="k">class</span> <span class="nc">X</span><span class="p">:</span>
    <span class="n">var</span><span class="p">:</span> <span class="n">NonexistentName</span> <span class="c1"># 오류!
</span></code></pre></div></div>

<p>또한 모듈 또는 클래스 레벨에서 어노테이션되는 항목이 단순한 이름인 경우, 해당 이름과 어노테이션은 모듈 또는 클래스의 <code class="language-plaintext highlighter-rouge">__annotations__</code> 속성(비공개인 경우 변형됨)에 이름에서 평가된 어노테이션으로의 순서 있는 매핑(ordered mapping)으로 저장됩니다. 예시는 다음과 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Dict</span>

<span class="k">class</span> <span class="nc">Player</span><span class="p">:</span> <span class="bp">...</span>

<span class="n">players</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Player</span><span class="p">]</span>
<span class="n">__points</span><span class="p">:</span> <span class="nb">int</span>

<span class="nf">print</span><span class="p">(</span><span class="n">__annotations__</span><span class="p">)</span> <span class="c1"># 출력: {'players': typing.Dict[str, __main__.Player],
</span>                     <span class="c1"># '_Player__points': &lt;class 'int'&gt;}
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">__annotations__</code>는 쓰기 가능하므로 다음이 허용됩니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__annotations__</span><span class="p">[</span><span class="sh">'</span><span class="s">s</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span>
</code></pre></div></div>

<p>그러나 <code class="language-plaintext highlighter-rouge">__annotations__</code>를 순서 있는 매핑이 아닌 다른 것으로 업데이트하려고 시도하면 <code class="language-plaintext highlighter-rouge">TypeError</code>가 발생할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">__annotations__</span> <span class="o">=</span> <span class="mi">42</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># TypeError 발생
</span></code></pre></div></div>

<p>(참고: 오류의 원인인 <code class="language-plaintext highlighter-rouge">__annotations__</code>에 대한 할당은 파이썬 인터프리터에 의해 아무런 문제 없이 허용되지만, 이후의 타입 어노테이션은 이를 <code class="language-plaintext highlighter-rouge">MutableMapping</code>으로 예상하며 실패합니다).</p>

<p>런타임에 어노테이션을 가져오는 권장 방법은 <code class="language-plaintext highlighter-rouge">typing.get_type_hints</code> 함수를 사용하는 것입니다. 모든 던더 속성(dunder attributes)과 마찬가지로 <code class="language-plaintext highlighter-rouge">__annotations__</code>의 문서화되지 않은 사용은 경고 없이 손상될 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">ClassVar</span><span class="p">,</span> <span class="n">get_type_hints</span>

<span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">hitpoints</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">shield</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">captain</span><span class="p">:</span> <span class="nb">str</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">captain</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span> <span class="bp">...</span>

<span class="k">assert</span> <span class="nf">get_type_hints</span><span class="p">(</span><span class="n">Starship</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="sh">'</span><span class="s">hitpoints</span><span class="sh">'</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="sh">'</span><span class="s">stats</span><span class="sh">'</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="sh">'</span><span class="s">shield</span><span class="sh">'</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="sh">'</span><span class="s">captain</span><span class="sh">'</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
<span class="k">assert</span> <span class="nf">get_type_hints</span><span class="p">(</span><span class="n">Starship</span><span class="p">.</span><span class="n">__init__</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="sh">'</span><span class="s">captain</span><span class="sh">'</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="sh">'</span><span class="s">return</span><span class="sh">'</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>
</code></pre></div></div>

<p>어노테이션이 정적으로 발견되지 않으면 <code class="language-plaintext highlighter-rouge">__annotations__</code> 사전이 전혀 생성되지 않습니다. 또한, 함수 호출마다 어노테이션 사전을 생성하고 채워야 하는 비용을 상쇄할 만큼 로컬에서 어노테이션을 사용할 가치가 크지 않습니다. 따라서 함수 레벨의 어노테이션은 평가되지 않으며 저장되지 않습니다.</p>

<h3 id="기타-어노테이션-사용-other-uses-of-annotations">기타 어노테이션 사용 (Other uses of annotations)</h3>

<p>이 PEP를 통해 파이썬은 다음과 같은 구문을 거부하지는 않겠지만:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alice</span><span class="p">:</span> <span class="sh">'</span><span class="s">well done</span><span class="sh">'</span> <span class="o">=</span> <span class="sh">'</span><span class="s">A+</span><span class="sh">'</span>
<span class="n">bob</span><span class="p">:</span> <span class="sh">'</span><span class="s">what a shame</span><span class="sh">'</span> <span class="o">=</span> <span class="sh">'</span><span class="s">F-</span><span class="sh">'</span>
</code></pre></div></div>

<p>이는 타입 어노테이션을 “오류를 발생시키지 않고 평가된다”는 것 이상으로 신경 쓰지 않을 것이기 때문입니다. 그러나 이를 접하는 타입 검사기는 <code class="language-plaintext highlighter-rouge"># type: ignore</code> 또는 <code class="language-plaintext highlighter-rouge">@no_type_check</code>로 비활성화되지 않는 한 이를 플래그할 것입니다.</p>

<p>하지만 파이썬은 “타입”이 무엇인지 신경 쓰지 않으므로, 위 코드 스니펫이 전역 레벨이나 클래스에 있는 경우 <code class="language-plaintext highlighter-rouge">__annotations__</code>에는 <code class="language-plaintext highlighter-rouge">{'alice': 'well done', 'bob': 'what a shame'}</code>가 포함될 것입니다.</p>

<p>이렇게 저장된 어노테이션은 다른 목적으로 사용될 수 있지만, 이 PEP를 통해 우리는 타입 힌트를 어노테이션의 선호되는 사용으로 명시적으로 권장합니다.</p>

<h2 id="거부연기된-제안-rejectedpostponed-proposals">거부/연기된 제안 (Rejected/Postponed Proposals)</h2>

<ul>
  <li><strong>변수 어노테이션을 도입해야 하는가?</strong> 변수 어노테이션은 PEP 484에 의해 승인된 타입 주석 형태로 거의 2년 동안 존재했습니다. 서드파티 타입 검사기(<code class="language-plaintext highlighter-rouge">mypy</code>, <code class="language-plaintext highlighter-rouge">pytype</code>, <code class="language-plaintext highlighter-rouge">PyCharm</code> 등)와 타입 검사기를 사용하는 프로젝트에서 광범위하게 사용됩니다. 그러나 주석 구문에는 배경(Rationale)에 나열된 많은 단점이 있습니다. 이 PEP는 타입 어노테이션의 필요성에 관한 것이 아니라, 그러한 어노테이션을 위한 구문이 무엇이어야 하는지에 관한 것입니다.</li>
  <li><strong>새로운 키워드를 도입해야 하는가?</strong> 좋은 키워드를 선택하는 것은 어렵습니다. 예를 들어 <code class="language-plaintext highlighter-rouge">var</code>는 너무 흔한 변수 이름이므로 사용할 수 없고, 클래스 변수나 전역 변수에 사용하려면 <code class="language-plaintext highlighter-rouge">local</code>이 될 수 없습니다. 둘째, 어떤 키워드를 선택하든 <code class="language-plaintext highlighter-rouge">__future__</code> import가 필요할 것입니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">def</code>를 키워드로 사용해야 하는가?</strong> 제안은 다음과 같았을 것입니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">primes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">captain</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div>    </div>
    <p>이것의 문제는 <code class="language-plaintext highlighter-rouge">def</code>가 수십 년 동안 파이썬 프로그래머(및 도구!)에게 “함수 정의”를 의미한다는 것입니다. 이를 변수 정의에도 사용하는 것은 명확성을 높이지 않습니다 (물론 이것은 주관적입니다).</p>
  </li>
  <li><strong>함수 기반 구문을 사용해야 하는가?</strong> <code class="language-plaintext highlighter-rouge">var = cast(annotation[, value])</code>를 사용하여 변수 타입을 어노테이션하는 것이 제안되었습니다. 이 구문은 AST에 어노테이션이 없는 것과 같은 타입 주석의 일부 문제를 완화하지만, 가독성과 같은 다른 문제를 해결하지 못하고 런타임 오버헤드를 도입할 수 있습니다.</li>
  <li><strong>튜플 언패킹에 타입 어노테이션을 허용해야 하는가?</strong> 이는 모호성을 유발합니다. <code class="language-plaintext highlighter-rouge">x, y: T</code>라는 문장이 무엇을 의미하는지 명확하지 않습니다. <code class="language-plaintext highlighter-rouge">x</code>와 <code class="language-plaintext highlighter-rouge">y</code> 모두 <code class="language-plaintext highlighter-rouge">T</code> 타입인가요, 아니면 <code class="language-plaintext highlighter-rouge">T</code>가 <code class="language-plaintext highlighter-rouge">x</code>와 <code class="language-plaintext highlighter-rouge">y</code>에 분산되는 두 개의 항목으로 구성된 튜플 타입으로 예상되는가요, 아니면 <code class="language-plaintext highlighter-rouge">x</code>가 <code class="language-plaintext highlighter-rouge">Any</code> 타입이고 <code class="language-plaintext highlighter-rouge">y</code>가 <code class="language-plaintext highlighter-rouge">T</code> 타입인가요? (후자는 함수 시그니처에서 발생할 경우의 의미입니다). 독자에게 추측을 맡기는 대신, 적어도 현재로서는 이를 금지합니다.</li>
  <li><strong>어노테이션을 위한 괄호 형식 <code class="language-plaintext highlighter-rouge">(var: type)</code>을 사용해야 하는가?</strong> 위에서 언급한 모호성을 해결하기 위한 방안으로 <code class="language-plaintext highlighter-rouge">python-ideas</code>에서 제기되었지만, 그러한 구문은 복잡하고 이점이 미미하며 가독성이 좋지 않다는 이유로 거부되었습니다.</li>
  <li><strong>연쇄 할당(chained assignments)에 어노테이션을 허용해야 하는가?</strong> 이는 튜플 언패킹과 유사한 모호성 및 가독성 문제를 가집니다. 예를 들어:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">w</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div>    </div>
    <p>여기서 <code class="language-plaintext highlighter-rouge">y</code>와 <code class="language-plaintext highlighter-rouge">z</code>의 타입이 무엇이어야 하는지 모호합니다. 또한 두 번째 줄은 파싱하기 어렵습니다.</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">with</code> 및 <code class="language-plaintext highlighter-rouge">for</code> 문에 어노테이션을 허용해야 하는가?</strong> <code class="language-plaintext highlighter-rouge">for</code> 문에서는 실제 이터러블을 식별하기 어렵게 만들고, <code class="language-plaintext highlighter-rouge">with</code> 문에서는 CPython의 LL(1) 파서를 혼란스럽게 만들 수 있다는 이유로 거부되었습니다.</li>
  <li><strong>함수 정의 시점에 지역 어노테이션을 평가해야 하는가?</strong> 이는 어노테이션의 위치가 주변 코드와 동일한 스코프에 있음을 강력하게 시사하기 때문에 Guido에 의해 거부되었습니다.</li>
  <li><strong>함수 스코프에도 변수 어노테이션을 저장해야 하는가?</strong> 어노테이션을 로컬에서 사용할 수 있는 가치는 함수 호출마다 사전을 생성하고 채우는 비용을 크게 상쇄할 만큼 충분하지 않습니다.</li>
  <li><strong>할당 없이 어노테이션된 변수를 초기화해야 하는가?</strong> <code class="language-plaintext highlighter-rouge">python-ideas</code>에서 <code class="language-plaintext highlighter-rouge">x: int</code>의 <code class="language-plaintext highlighter-rouge">x</code>를 <code class="language-plaintext highlighter-rouge">None</code> 또는 Javascript의 <code class="language-plaintext highlighter-rouge">undefined</code>와 같은 추가적인 특별 상수로 초기화하는 것이 제안되었습니다. 그러나 언어에 또 다른 싱글턴 값을 추가하면 코드의 모든 곳에서 이를 확인해야 할 것입니다. 따라서 Guido는 이에 대해 명확히 “No”라고 말했습니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">typing</code> 모듈에 <code class="language-plaintext highlighter-rouge">InstanceVar</code>도 추가해야 하는가?</strong> 인스턴스 변수는 클래스 변수보다 훨씬 흔합니다. 더 일반적인 사용법이 기본값이 되는 것이 마땅하므로 이는 중복됩니다.</li>
  <li><strong>메서드에서만 인스턴스 변수 어노테이션을 허용해야 하는가?</strong> 문제는 많은 <code class="language-plaintext highlighter-rouge">__init__</code> 메서드가 인스턴스 변수를 초기화하는 것 외에도 많은 작업을 수행하며, (사람이) 모든 인스턴스 변수 어노테이션을 찾기가 더 어려울 것이라는 점입니다. 때로는 <code class="language-plaintext highlighter-rouge">__init__</code>이 더 많은 도우미 메서드로 분할되므로 이를 추적하는 것이 더욱 어려워집니다. 인스턴스 변수 어노테이션을 클래스에 함께 배치하면 찾기 쉽고, 코드를 처음 읽는 사람에게 도움이 됩니다.</li>
  <li><strong>클래스 변수에 <code class="language-plaintext highlighter-rouge">x: class t = v</code> 구문을 사용해야 하는가?</strong> 이는 더 복잡한 파서가 필요하며, <code class="language-plaintext highlighter-rouge">class</code> 키워드는 단순한 구문 하이라이터를 혼란스럽게 할 것입니다. 어쨌든 <code class="language-plaintext highlighter-rouge">ClassVar</code>는 클래스 변수를 <code class="language-plaintext highlighter-rouge">__annotations__</code>에 저장해야 하므로 더 간단한 구문이 선택되었습니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ClassVar</code>를 완전히 잊어야 하는가?</strong> <code class="language-plaintext highlighter-rouge">mypy</code>가 클래스 변수와 인스턴스 변수를 구별하는 방법 없이도 잘 작동하는 것처럼 보였기 때문에 제안되었습니다. 그러나 타입 검사기는 추가 정보를 가지고 유용한 작업을 수행할 수 있습니다. 예를 들어, 인스턴스를 통해 클래스 변수에 우발적인 할당(클래스 변수를 가리는 인스턴스 변수를 생성함)을 플래그할 수 있습니다. 또한 잘 알려진 위험인 변경 가능한 기본값을 가진 인스턴스 변수도 플래그할 수 있습니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ClassVar</code> 대신 <code class="language-plaintext highlighter-rouge">ClassAttr</code>를 사용해야 하는가?</strong> <code class="language-plaintext highlighter-rouge">ClassVar</code>가 더 나은 주된 이유는 다음과 같습니다. 메서드, 디스크립터 등 많은 것들이 클래스 속성입니다. 그러나 특정 속성만 개념적으로 클래스 변수(또는 상수)입니다.</li>
  <li><strong>어노테이션을 평가하지 않고 문자열로 처리해야 하는가?</strong> 이는 항상 평가되는 함수 어노테이션의 동작과 일치하지 않을 것입니다. 비록 미래에 재고될 수 있지만, PEP 484에서는 이것이 별도의 PEP여야 한다고 결정되었습니다.</li>
  <li><strong>클래스 독스트링에 변수 타입을 어노테이션해야 하는가?</strong> 많은 프로젝트에서 이미 다양한 독스트링 규칙을 사용하고 있으며, 종종 일관성이 부족하고 일반적으로 PEP 484 어노테이션 구문을 아직 따르지 않습니다. 또한 이것은 특별하고 정교한 파서가 필요할 것입니다. 이는 결국 PEP의 목적, 즉 서드파티 타입 검사 도구와의 협력을 저해할 것입니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">__annotations__</code>를 디스크립터로 구현해야 하는가?</strong> <code class="language-plaintext highlighter-rouge">__annotations__</code>를 사전이나 <code class="language-plaintext highlighter-rouge">None</code>이 아닌 다른 것으로 설정하는 것을 금지하기 위해 제안되었습니다. Guido는 이를 불필요하다고 거부했습니다. 대신 <code class="language-plaintext highlighter-rouge">__annotations__</code>가 매핑이 아닌 다른 것일 때 업데이트를 시도하면 <code class="language-plaintext highlighter-rouge">TypeError</code>가 발생할 것입니다.</li>
  <li><strong>맨몸 어노테이션(bare annotations)을 <code class="language-plaintext highlighter-rouge">global</code> 또는 <code class="language-plaintext highlighter-rouge">nonlocal</code>과 동일하게 처리해야 하는가?</strong> 거부된 제안은 함수 본문에서 할당 없는 어노테이션의 존재가 어떤 평가도 수반하지 않아야 한다고 선호했습니다. 이와 대조적으로, 이 PEP는 대상이 단일 이름보다 복잡한 경우, 해당 “왼쪽 부분”이 함수 본문에서 발생하는 지점에서 평가되어야 한다고 암시합니다. 이는 단순히 정의되었는지 확인하기 위함입니다. 예를 들어:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">slef</span><span class="p">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div>    </div>
    <p>여기서 <code class="language-plaintext highlighter-rouge">slef</code> 이름은 평가되어야 합니다. 만약 정의되지 않았다면 (이 예시에서 그럴 가능성이 높음), 런타임에 오류가 감지될 것입니다. 이는 초기값이 있을 때 발생하는 상황과 더 일치하므로 놀라움을 덜 줄 것으로 예상됩니다. (또한 대상이 <code class="language-plaintext highlighter-rouge">self.name</code>이었다면, 최적화 컴파일러는 <code class="language-plaintext highlighter-rouge">self</code>가 확실히 정의될 수 있다고 증명할 수 있는 한 <code class="language-plaintext highlighter-rouge">self</code>를 평가할 의무가 없다는 점에 유의하십시오).</p>
  </li>
</ul>

<h2 id="하위-호환성-backwards-compatibility">하위 호환성 (Backwards Compatibility)</h2>

<p>이 PEP는 완전히 하위 호환됩니다.</p>

<h2 id="구현-implementation">구현 (Implementation)</h2>

<p>Python 3.6용 구현은 GitHub에서 찾을 수 있습니다.</p>

<h2 id="저작권-copyright">저작권 (Copyright)</h2>

<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>

<blockquote>
  <p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/tags/#python" class="page__taxonomy-item" rel="tag">Python</a><span class="sep">, </span>
    
      <a href="/tags/#translation" class="page__taxonomy-item" rel="tag">Translation</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#pep" class="page__taxonomy-item" rel="tag">PEP</a><span class="sep">, </span>
    
      <a href="/categories/#python" class="page__taxonomy-item" rel="tag">Python</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2025-09-26">September 26, 2025</time></p>


      </footer>

      

      
  <nav class="pagination">
    
      <a href="/python/pep/525/" class="pagination--pager" title="[Final] PEP 525 - Asynchronous Generators
">Previous</a>
    
    
      <a href="/python/pep/527/" class="pagination--pager" title="[Final] PEP 527 - Removing Un(der)used file types/extensions on PyPI
">Next</a>
    
  </nav>


    </div>

    
  </article>

</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 secrett2633. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function() {
    var commentContainer = document.querySelector('#utterances-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://utteranc.es/client.js');
    script.setAttribute('repo', 'secrett2633/secrett2633.github.io');
    script.setAttribute('issue-term', 'pathname');
    script.setAttribute('theme', 'github-light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>

  





  </body>
</html>
