<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>secrett2633&apos;s blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 27 Sep 2025 22:08:03 +0900</pubDate>
    <lastBuildDate>Sat, 27 Sep 2025 22:08:03 +0900</lastBuildDate>
    <generator>Jekyll v4.3.4</generator>
    
      <item>
        <title>[Active] PEP 0 - Index of Python Enhancement Proposals (PEPs)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-0000/&quot;&gt;PEP 0 - Index of Python Enhancement Proposals (PEPs)&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Active&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 13-Jul-2000&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-0--python-enhancement-proposals-peps-색인&quot;&gt;PEP 0 – Python Enhancement Proposals (PEPs) 색인&lt;/h2&gt;

&lt;h3 id=&quot;소개&quot;&gt;소개&lt;/h3&gt;

&lt;p&gt;PEP 번호는 PEP 편집자에 의해 할당되며, 한 번 할당되면 변경되지 않습니다. PEP 텍스트의 버전 관리 기록은 역사적 기록을 나타냅니다.&lt;/p&gt;

&lt;h3 id=&quot;주제별-색인&quot;&gt;주제별 색인&lt;/h3&gt;

&lt;p&gt;전문 분야에 대한 PEP는 주제별로 색인화되어 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Governance PEPs (거버넌스 PEPs):&lt;/strong&gt; Python 프로젝트의 관리 및 운영 방식에 대한 제안.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Packaging PEPs (패키징 PEPs):&lt;/strong&gt; Python 패키지 배포 및 관리에 대한 제안.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Release PEPs (릴리스 PEPs):&lt;/strong&gt; Python 버전 릴리스 주기 및 프로세스에 대한 제안.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Typing PEPs (타입 힌트 PEPs):&lt;/strong&gt; Python의 타입 힌트(Type Hinting) 기능 및 관련 표준에 대한 제안.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;api&quot;&gt;API&lt;/h3&gt;

&lt;p&gt;PEPs API는 게시된 모든 PEP의 메타데이터를 담고 있는 JSON 파일입니다. 자세한 내용은 해당 API 문서를 참조하세요.&lt;/p&gt;

&lt;h3 id=&quot;수치-색인&quot;&gt;수치 색인&lt;/h3&gt;

&lt;p&gt;모든 PEP를 번호순으로 정렬한 표를 포함합니다.&lt;/p&gt;

&lt;h3 id=&quot;카테고리별-색인&quot;&gt;카테고리별 색인&lt;/h3&gt;

&lt;p&gt;PEP는 상태와 유형에 따라 여러 카테고리로 분류됩니다.&lt;/p&gt;

&lt;h4 id=&quot;프로세스-및-메타-peps-process-and-meta-peps&quot;&gt;프로세스 및 메타-PEPs (Process and Meta-PEPs)&lt;/h4&gt;

&lt;p&gt;Python 커뮤니티의 절차, 워크플로우 또는 거버넌스 변경을 설명하거나 제안하는 PEPs입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEP 1: PEP 목적 및 가이드라인&lt;/li&gt;
  &lt;li&gt;PEP 8: Python 코드 스타일 가이드&lt;/li&gt;
  &lt;li&gt;PEP 13: Python 언어 거버넌스&lt;/li&gt;
  &lt;li&gt;PEP 602: Python 연간 릴리스 주기&lt;/li&gt;
  &lt;li&gt;PEP 609: Python Packaging Authority (PyPA) 거버넌스&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;기타-정보-제공-peps-other-informational-peps&quot;&gt;기타 정보 제공 PEPs (Other Informational PEPs)&lt;/h4&gt;

&lt;p&gt;Python 생태계에 대한 배경 정보, 가이드라인 또는 기타 비규범적인 정보를 담고 있는 PEPs입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEP 20: Python의 Zen&lt;/li&gt;
  &lt;li&gt;PEP 257: Docstring 컨벤션&lt;/li&gt;
  &lt;li&gt;PEP 333: Python 웹 서버 게이트웨이 인터페이스 (WSGI) v1.0&lt;/li&gt;
  &lt;li&gt;PEP 484: 타입 힌트 (Type Hints)&lt;/li&gt;
  &lt;li&gt;PEP 570: Python 위치 전용 매개변수 (Positional-Only Parameters)&lt;/li&gt;
  &lt;li&gt;PEP 572: 할당 표현식 (Assignment Expressions)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;임시-peps-provisional-peps&quot;&gt;임시 PEPs (Provisional PEPs)&lt;/h4&gt;

&lt;p&gt;잠정적으로 승인되었으나 인터페이스가 아직 변경될 수 있는 PEPs입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEP 708: 의존성 혼동 공격 (Dependency Confusion Attacks) 완화를 위한 Repository API 확장&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;승인된-peps-accepted-peps&quot;&gt;승인된 PEPs (Accepted PEPs)&lt;/h4&gt;

&lt;p&gt;승인되었으나 아직 구현되지 않았을 수 있는 PEPs입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEP 458: 서명된 저장소 메타데이터를 통한 안전한 PyPI 다운로드&lt;/li&gt;
  &lt;li&gt;PEP 649: Descriptors를 사용한 Annotation의 지연 평가 (Deferred Evaluation)&lt;/li&gt;
  &lt;li&gt;PEP 686: UTF-8 모드 기본값으로 만들기&lt;/li&gt;
  &lt;li&gt;PEP 703: CPython에서 GIL (Global Interpreter Lock)을 선택 사항으로 만들기&lt;/li&gt;
  &lt;li&gt;PEP 701: f-string의 문법적 형식화&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;검토-중인-peps-open-peps&quot;&gt;검토 중인 PEPs (Open PEPs)&lt;/h4&gt;

&lt;p&gt;현재 논의 및 수정 중인 제안입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEP 467: 바이너리 시퀀스를 위한 사소한 API 개선&lt;/li&gt;
  &lt;li&gt;PEP 480: PyPI 침해 상황에서 살아남기: 패키지의 엔드투엔드 서명&lt;/li&gt;
  &lt;li&gt;PEP 603: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collections&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frozenmap&lt;/code&gt; 타입 추가&lt;/li&gt;
  &lt;li&gt;PEP 638: 문법적 매크로 (Syntactic Macros)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;완료된-peps-finished-peps&quot;&gt;완료된 PEPs (Finished PEPs)&lt;/h4&gt;

&lt;p&gt;승인되었고 구현이 완료되었거나 더 이상 활성화되지 않는 안정적인 인터페이스를 가진 PEPs입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEP 201: Lockstep Iteration&lt;/li&gt;
  &lt;li&gt;PEP 202: List Comprehensions&lt;/li&gt;
  &lt;li&gt;PEP 203: Augmented Assignments&lt;/li&gt;
  &lt;li&gt;PEP 205: Weak References&lt;/li&gt;
  &lt;li&gt;PEP 207: Rich Comparisons&lt;/li&gt;
  &lt;li&gt;PEP 208: Reworking the Coercion Model&lt;/li&gt;
  &lt;li&gt;PEP 214: Extended Print Statement&lt;/li&gt;
  &lt;li&gt;PEP 217: Display Hook for Interactive Use&lt;/li&gt;
  &lt;li&gt;PEP 218: Adding a Built-In Set Object Type&lt;/li&gt;
  &lt;li&gt;PEP 221: Import As&lt;/li&gt;
  &lt;li&gt;PEP 223: Change the Meaning of x Escapes&lt;/li&gt;
  &lt;li&gt;PEP 227: Statically Nested Scopes&lt;/li&gt;
  &lt;li&gt;PEP 229: Using Distutils to Build Python&lt;/li&gt;
  &lt;li&gt;PEP 230: Warning Framework&lt;/li&gt;
  &lt;li&gt;PEP 232: Function Attributes&lt;/li&gt;
  &lt;li&gt;PEP 234: Iterators&lt;/li&gt;
  &lt;li&gt;PEP 235: Import on Case-Insensitive Platforms&lt;/li&gt;
  &lt;li&gt;PEP 236: Back to the &lt;strong&gt;future&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;PEP 237: Unifying Long Integers and Integers&lt;/li&gt;
  &lt;li&gt;PEP 238: Changing the Division Operator&lt;/li&gt;
  &lt;li&gt;PEP 250: Using site-packages on Windows&lt;/li&gt;
  &lt;li&gt;PEP 252: Making Types Look More Like Classes&lt;/li&gt;
  &lt;li&gt;PEP 253: Subtyping Built-in Types&lt;/li&gt;
  &lt;li&gt;PEP 255: Simple Generators&lt;/li&gt;
  &lt;li&gt;PEP 260: Simplify xrange()&lt;/li&gt;
  &lt;li&gt;PEP 261: Support for “wide” Unicode characters&lt;/li&gt;
  &lt;li&gt;PEP 263: Defining Python Source Code Encodings&lt;/li&gt;
  &lt;li&gt;PEP 264: Future statements in simulated shells&lt;/li&gt;
  &lt;li&gt;PEP 273: Import Modules from Zip Archives&lt;/li&gt;
  &lt;li&gt;PEP 274: Dict Comprehensions&lt;/li&gt;
  &lt;li&gt;PEP 277: Unicode file name support for Windows NT&lt;/li&gt;
  &lt;li&gt;PEP 278: Universal Newline Support&lt;/li&gt;
  &lt;li&gt;PEP 279: The enumerate() built-in function&lt;/li&gt;
  &lt;li&gt;PEP 282: A Logging System&lt;/li&gt;
  &lt;li&gt;PEP 285: Adding a bool type&lt;/li&gt;
  &lt;li&gt;PEP 289: Generator Expressions&lt;/li&gt;
  &lt;li&gt;PEP 292: Simpler String Substitutions&lt;/li&gt;
  &lt;li&gt;PEP 293: Codec Error Handling Callbacks&lt;/li&gt;
  &lt;li&gt;PEP 301: Package Index and Metadata for Distutils&lt;/li&gt;
  &lt;li&gt;PEP 302: New Import Hooks&lt;/li&gt;
  &lt;li&gt;PEP 305: CSV File API&lt;/li&gt;
  &lt;li&gt;PEP 307: Extensions to the pickle protocol&lt;/li&gt;
  &lt;li&gt;PEP 308: Conditional Expressions&lt;/li&gt;
  &lt;li&gt;PEP 309: Partial Function Application&lt;/li&gt;
  &lt;li&gt;PEP 311: Simplified Global Interpreter Lock Acquisition for Extensions&lt;/li&gt;
  &lt;li&gt;PEP 318: Decorators for Functions and Methods&lt;/li&gt;
  &lt;li&gt;PEP 322: Reverse Iteration&lt;/li&gt;
  &lt;li&gt;PEP 324: subprocess - New process module&lt;/li&gt;
  &lt;li&gt;PEP 327: Decimal Data Type&lt;/li&gt;
  &lt;li&gt;PEP 328: Imports: Multi-Line and Absolute/Relative&lt;/li&gt;
  &lt;li&gt;PEP 331: Locale-Independent Float/String Conversions&lt;/li&gt;
  &lt;li&gt;PEP 338: Executing modules as scripts&lt;/li&gt;
  &lt;li&gt;PEP 341: Unifying try-except and try-finally&lt;/li&gt;
  &lt;li&gt;PEP 342: Coroutines via Enhanced Generators&lt;/li&gt;
  &lt;li&gt;PEP 343: The “with” Statement&lt;/li&gt;
  &lt;li&gt;PEP 352: Required Superclass for Exceptions&lt;/li&gt;
  &lt;li&gt;PEP 353: Using ssize_t as the index type&lt;/li&gt;
  &lt;li&gt;PEP 357: Allowing Any Object to be Used for Slicing&lt;/li&gt;
  &lt;li&gt;PEP 358: The “bytes” Object&lt;/li&gt;
  &lt;li&gt;PEP 362: Function Signature Object&lt;/li&gt;
  &lt;li&gt;PEP 366: Main module explicit relative imports&lt;/li&gt;
  &lt;li&gt;PEP 370: Per user site-packages directory&lt;/li&gt;
  &lt;li&gt;PEP 371: Addition of the multiprocessing package to the standard library&lt;/li&gt;
  &lt;li&gt;PEP 372: Adding an ordered dictionary to collections&lt;/li&gt;
  &lt;li&gt;PEP 376: Database of Installed Python Distributions&lt;/li&gt;
  &lt;li&gt;PEP 378: Format Specifier for Thousands Separator&lt;/li&gt;
  &lt;li&gt;PEP 380: Syntax for Delegating to a Subgenerator&lt;/li&gt;
  &lt;li&gt;PEP 383: Non-decodable Bytes in System Character Interfaces&lt;/li&gt;
  &lt;li&gt;PEP 384: Defining a Stable ABI&lt;/li&gt;
  &lt;li&gt;PEP 389: argparse - New Command Line Parsing Module&lt;/li&gt;
  &lt;li&gt;PEP 391: Dictionary-Based Configuration For Logging&lt;/li&gt;
  &lt;li&gt;PEP 393: Flexible String Representation&lt;/li&gt;
  &lt;li&gt;PEP 397: Python launcher for Windows&lt;/li&gt;
  &lt;li&gt;PEP 405: Python Virtual Environments&lt;/li&gt;
  &lt;li&gt;PEP 409: Suppressing exception context&lt;/li&gt;
  &lt;li&gt;PEP 412: Key-Sharing Dictionary&lt;/li&gt;
  &lt;li&gt;PEP 414: Explicit Unicode Literal for Python 3.3&lt;/li&gt;
  &lt;li&gt;PEP 415: Implement context suppression with exception attributes&lt;/li&gt;
  &lt;li&gt;PEP 417: Including mock in the Standard Library&lt;/li&gt;
  &lt;li&gt;PEP 418: Add monotonic time, performance counter, and process time functions&lt;/li&gt;
  &lt;li&gt;PEP 420: Implicit Namespace Packages&lt;/li&gt;
  &lt;li&gt;PEP 421: Adding sys.implementation&lt;/li&gt;
  &lt;li&gt;PEP 424: A method for exposing a length hint&lt;/li&gt;
  &lt;li&gt;PEP 425: Compatibility Tags for Built Distributions&lt;/li&gt;
  &lt;li&gt;PEP 427: The Wheel Binary Package Format 1.0&lt;/li&gt;
  &lt;li&gt;PEP 428: The pathlib module – object-oriented filesystem paths&lt;/li&gt;
  &lt;li&gt;PEP 435: Adding an Enum type to the Python standard library&lt;/li&gt;
  &lt;li&gt;PEP 436: The Argument Clinic DSL&lt;/li&gt;
  &lt;li&gt;PEP 440: Version Identification and Dependency Specification&lt;/li&gt;
  &lt;li&gt;PEP 441: Improving Python ZIP Application Support&lt;/li&gt;
  &lt;li&gt;PEP 442: Safe object finalization&lt;/li&gt;
  &lt;li&gt;PEP 443: Single-dispatch generic functions&lt;/li&gt;
  &lt;li&gt;PEP 445: Add new APIs to customize Python memory allocators&lt;/li&gt;
  &lt;li&gt;PEP 446: Make newly created file descriptors non-inheritable&lt;/li&gt;
  &lt;li&gt;PEP 448: Additional Unpacking Generalizations&lt;/li&gt;
  &lt;li&gt;PEP 450: Adding A Statistics Module To The Standard Library&lt;/li&gt;
  &lt;li&gt;PEP 451: A ModuleSpec Type for the Import System&lt;/li&gt;
  &lt;li&gt;PEP 453: Explicit bootstrapping of pip in Python installations&lt;/li&gt;
  &lt;li&gt;PEP 454: Add a new tracemalloc module to trace Python memory allocations&lt;/li&gt;
  &lt;li&gt;PEP 456: Secure and interchangeable hash algorithm&lt;/li&gt;
  &lt;li&gt;PEP 461: Adding % formatting to bytes and bytearray&lt;/li&gt;
  &lt;li&gt;PEP 465: A dedicated infix operator for matrix multiplication&lt;/li&gt;
  &lt;li&gt;PEP 466: Network Security Enhancements for Python 2.7.x&lt;/li&gt;
  &lt;li&gt;PEP 468: Preserving the order of **kwargs in a function.&lt;/li&gt;
  &lt;li&gt;PEP 471: os.scandir() function – a better and faster directory iterator&lt;/li&gt;
  &lt;li&gt;PEP 475: Retry system calls failing with EINTR&lt;/li&gt;
  &lt;li&gt;PEP 476: Enabling certificate verification by default for stdlib http clients&lt;/li&gt;
  &lt;li&gt;PEP 477: Backport ensurepip (PEP 453) to Python 2.7&lt;/li&gt;
  &lt;li&gt;PEP 479: Change StopIteration handling inside generators&lt;/li&gt;
  &lt;li&gt;PEP 484: Type Hints&lt;/li&gt;
  &lt;li&gt;PEP 485: A Function for testing approximate equality&lt;/li&gt;
  &lt;li&gt;PEP 486: Make the Python Launcher aware of virtual environments&lt;/li&gt;
  &lt;li&gt;PEP 487: Simpler customisation of class creation&lt;/li&gt;
  &lt;li&gt;PEP 488: Elimination of PYO files&lt;/li&gt;
  &lt;li&gt;PEP 489: Multi-phase extension module initialization&lt;/li&gt;
  &lt;li&gt;PEP 492: Coroutines with async and await syntax&lt;/li&gt;
  &lt;li&gt;PEP 493: HTTPS verification migration tools for Python 2.7&lt;/li&gt;
  &lt;li&gt;PEP 495: Local Time Disambiguation&lt;/li&gt;
  &lt;li&gt;PEP 498: Literal String Interpolation&lt;/li&gt;
  &lt;li&gt;PEP 503: Simple Repository API&lt;/li&gt;
  &lt;li&gt;PEP 506: Adding A Secrets Module To The Standard Library&lt;/li&gt;
  &lt;li&gt;PEP 508: Dependency specification for Python Software Packages&lt;/li&gt;
  &lt;li&gt;PEP 515: Underscores in Numeric Literals&lt;/li&gt;
  &lt;li&gt;PEP 517: A build-system independent format for source trees&lt;/li&gt;
  &lt;li&gt;PEP 518: Specifying Minimum Build System Requirements for Python Projects&lt;/li&gt;
  &lt;li&gt;PEP 519: Adding a file system path protocol&lt;/li&gt;
  &lt;li&gt;PEP 520: Preserving Class Attribute Definition Order&lt;/li&gt;
  &lt;li&gt;PEP 523: Adding a frame evaluation API to CPython&lt;/li&gt;
  &lt;li&gt;PEP 524: Make os.urandom() blocking on Linux&lt;/li&gt;
  &lt;li&gt;PEP 525: Asynchronous Generators&lt;/li&gt;
  &lt;li&gt;PEP 526: Syntax for Variable Annotations&lt;/li&gt;
  &lt;li&gt;PEP 527: Removing Un(der)used file types/extensions on PyPI&lt;/li&gt;
  &lt;li&gt;PEP 528: Change Windows console encoding to UTF-8&lt;/li&gt;
  &lt;li&gt;PEP 529: Change Windows filesystem encoding to UTF-8&lt;/li&gt;
  &lt;li&gt;PEP 530: Asynchronous Comprehensions&lt;/li&gt;
  &lt;li&gt;PEP 538: Coercing the legacy C locale to a UTF-8 based locale&lt;/li&gt;
  &lt;li&gt;PEP 539: A New C-API for Thread-Local Storage in CPython&lt;/li&gt;
  &lt;li&gt;PEP 540: Add a new UTF-8 Mode&lt;/li&gt;
  &lt;li&gt;PEP 544: Protocols: Structural subtyping (static duck typing)&lt;/li&gt;
  &lt;li&gt;PEP 552: Deterministic pycs&lt;/li&gt;
  &lt;li&gt;PEP 553: Built-in breakpoint()&lt;/li&gt;
  &lt;li&gt;PEP 557: Data Classes&lt;/li&gt;
  &lt;li&gt;PEP 560: Core support for typing module and generic types&lt;/li&gt;
  &lt;li&gt;PEP 561: Distributing and Packaging Type Information&lt;/li&gt;
  &lt;li&gt;PEP 562: Module &lt;strong&gt;getattr&lt;/strong&gt; and &lt;strong&gt;dir&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;PEP 564: Add new time functions with nanosecond resolution&lt;/li&gt;
  &lt;li&gt;PEP 565: Show DeprecationWarning in &lt;strong&gt;main&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;PEP 566: Metadata for Python Software Packages 2.1&lt;/li&gt;
  &lt;li&gt;PEP 567: Context Variables&lt;/li&gt;
  &lt;li&gt;PEP 570: Python Positional-Only Parameters&lt;/li&gt;
  &lt;li&gt;PEP 572: Assignment Expressions&lt;/li&gt;
  &lt;li&gt;PEP 573: Module State Access from C Extension Methods&lt;/li&gt;
  &lt;li&gt;PEP 574: Pickle protocol 5 with out-of-band data&lt;/li&gt;
  &lt;li&gt;PEP 578: Python Runtime Audit Hooks&lt;/li&gt;
  &lt;li&gt;PEP 584: Add Union Operators To dict&lt;/li&gt;
  &lt;li&gt;PEP 585: Type Hinting Generics In Standard Collections&lt;/li&gt;
  &lt;li&gt;PEP 586: Literal Types&lt;/li&gt;
  &lt;li&gt;PEP 587: Python Initialization Configuration&lt;/li&gt;
  &lt;li&gt;PEP 589: TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys&lt;/li&gt;
  &lt;li&gt;PEP 590: Vectorcall: a fast calling protocol for CPython&lt;/li&gt;
  &lt;li&gt;PEP 591: Adding a final qualifier to typing&lt;/li&gt;
  &lt;li&gt;PEP 592: Adding “Yank” Support to the Simple API&lt;/li&gt;
  &lt;li&gt;PEP 593: Flexible function and variable annotations&lt;/li&gt;
  &lt;li&gt;PEP 594: Removing dead batteries from the standard library&lt;/li&gt;
  &lt;li&gt;PEP 597: Add optional EncodingWarning&lt;/li&gt;
  &lt;li&gt;PEP 600: Future ‘manylinux’ Platform Tags for Portable Linux Built Distributions&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;PEP 604: Allow writing union types as X&lt;/td&gt;
          &lt;td&gt;Y&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;PEP 610: Recording the Direct URL Origin of installed distributions&lt;/li&gt;
  &lt;li&gt;PEP 612: Parameter Specification Variables&lt;/li&gt;
  &lt;li&gt;PEP 613: Explicit Type Aliases&lt;/li&gt;
  &lt;li&gt;PEP 614: Relaxing Grammar Restrictions On Decorators&lt;/li&gt;
  &lt;li&gt;PEP 615: Support for the IANA Time Zone Database in the Standard Library&lt;/li&gt;
  &lt;li&gt;PEP 616: String methods to remove prefixes and suffixes&lt;/li&gt;
  &lt;li&gt;PEP 617: New PEG parser for CPython&lt;/li&gt;
  &lt;li&gt;PEP 618: Add Optional Length-Checking To zip&lt;/li&gt;
  &lt;li&gt;PEP 621: Storing project metadata in pyproject.toml&lt;/li&gt;
  &lt;li&gt;PEP 623: Remove wstr from Unicode&lt;/li&gt;
  &lt;li&gt;PEP 624: Remove Py_UNICODE encoder APIs&lt;/li&gt;
  &lt;li&gt;PEP 625: Filename of a Source Distribution&lt;/li&gt;
  &lt;li&gt;PEP 626: Precise line numbers for debugging and other tools.&lt;/li&gt;
  &lt;li&gt;PEP 627: Recording installed projects&lt;/li&gt;
  &lt;li&gt;PEP 628: Add math.tau&lt;/li&gt;
  &lt;li&gt;PEP 629: Versioning PyPI’s Simple API&lt;/li&gt;
  &lt;li&gt;PEP 632: Deprecate distutils module&lt;/li&gt;
  &lt;li&gt;PEP 634: Structural Pattern Matching: Specification&lt;/li&gt;
  &lt;li&gt;PEP 639: Improving License Clarity with Better Package Metadata&lt;/li&gt;
  &lt;li&gt;PEP 643: Metadata for Package Source Distributions&lt;/li&gt;
  &lt;li&gt;PEP 644: Require OpenSSL 1.1.1 or newer&lt;/li&gt;
  &lt;li&gt;PEP 646: Variadic Generics&lt;/li&gt;
  &lt;li&gt;PEP 647: User-Defined Type Guards&lt;/li&gt;
  &lt;li&gt;PEP 652: Maintaining the Stable ABI&lt;/li&gt;
  &lt;li&gt;PEP 654: Exception Groups and except*&lt;/li&gt;
  &lt;li&gt;PEP 655: Marking individual TypedDict items as required or potentially-missing&lt;/li&gt;
  &lt;li&gt;PEP 656: Platform Tag for Linux Distributions Using Musl&lt;/li&gt;
  &lt;li&gt;PEP 657: Include Fine Grained Error Locations in Tracebacks&lt;/li&gt;
  &lt;li&gt;PEP 660: Editable installs for pyproject.toml based builds (wheel based)&lt;/li&gt;
  &lt;li&gt;PEP 667: Consistent views of namespaces&lt;/li&gt;
  &lt;li&gt;PEP 669: Low Impact Monitoring for CPython&lt;/li&gt;
  &lt;li&gt;PEP 670: Convert macros to functions in the Python C API&lt;/li&gt;
  &lt;li&gt;PEP 673: Self Type&lt;/li&gt;
  &lt;li&gt;PEP 675: Arbitrary Literal String Type&lt;/li&gt;
  &lt;li&gt;PEP 678: Enriching Exceptions with Notes&lt;/li&gt;
  &lt;li&gt;PEP 680: tomllib: Support for Parsing TOML in the Standard Library&lt;/li&gt;
  &lt;li&gt;PEP 681: Data Class Transforms&lt;/li&gt;
  &lt;li&gt;PEP 682: Format Specifier for Signed Zero&lt;/li&gt;
  &lt;li&gt;PEP 683: Immortal Objects, Using a Fixed Refcount&lt;/li&gt;
  &lt;li&gt;PEP 684: A Per-Interpreter GIL&lt;/li&gt;
  &lt;li&gt;PEP 685: Comparison of extra names for optional distribution dependencies&lt;/li&gt;
  &lt;li&gt;PEP 688: Making the buffer protocol accessible in Python&lt;/li&gt;
  &lt;li&gt;PEP 689: Unstable C API tier&lt;/li&gt;
  &lt;li&gt;PEP 692: Using TypedDict for more precise **kwargs typing&lt;/li&gt;
  &lt;li&gt;PEP 695: Type Parameter Syntax&lt;/li&gt;
  &lt;li&gt;PEP 696: Type Defaults for Type Parameters&lt;/li&gt;
  &lt;li&gt;PEP 697: Limited C API for Extending Opaque Types&lt;/li&gt;
  &lt;li&gt;PEP 698: Override Decorator for Static Typing&lt;/li&gt;
  &lt;li&gt;PEP 700: Additional Fields for the Simple API for Package Indexes&lt;/li&gt;
  &lt;li&gt;PEP 702: Marking deprecations using the type system&lt;/li&gt;
  &lt;li&gt;PEP 705: TypedDict: Read-only items&lt;/li&gt;
  &lt;li&gt;PEP 706: Filter for tarfile.extractall&lt;/li&gt;
  &lt;li&gt;PEP 709: Inlined comprehensions&lt;/li&gt;
  &lt;li&gt;PEP 715: Disabling bdist_egg distribution uploads on PyPI&lt;/li&gt;
  &lt;li&gt;PEP 721: Using tarfile.data_filter for source distribution extraction&lt;/li&gt;
  &lt;li&gt;PEP 723: Inline script metadata&lt;/li&gt;
  &lt;li&gt;PEP 730: Adding iOS as a supported platform&lt;/li&gt;
  &lt;li&gt;PEP 734: Multiple Interpreters in the Stdlib&lt;/li&gt;
  &lt;li&gt;PEP 735: Dependency Groups in pyproject.toml&lt;/li&gt;
  &lt;li&gt;PEP 737: C API to format a type fully qualified name&lt;/li&gt;
  &lt;li&gt;PEP 738: Adding Android as a supported platform&lt;/li&gt;
  &lt;li&gt;PEP 740: Index support for digital attestations&lt;/li&gt;
  &lt;li&gt;PEP 741: Python Configuration C API&lt;/li&gt;
  &lt;li&gt;PEP 742: Narrowing types with TypeIs&lt;/li&gt;
  &lt;li&gt;PEP 750: Template Strings&lt;/li&gt;
  &lt;li&gt;PEP 751: A file format to record Python dependencies for installation reproducibility&lt;/li&gt;
  &lt;li&gt;PEP 757: C API to import-export Python integers&lt;/li&gt;
  &lt;li&gt;PEP 758: Allow except and except* expressions without parentheses&lt;/li&gt;
  &lt;li&gt;PEP 765: Disallow return/break/continue that exit a finally block&lt;/li&gt;
  &lt;li&gt;PEP 782: Add PyBytesWriter C API&lt;/li&gt;
  &lt;li&gt;PEP 784: Adding Zstandard to the standard library&lt;/li&gt;
  &lt;li&gt;PEP 792: Project status markers in the simple index&lt;/li&gt;
  &lt;li&gt;PEP 3101: Advanced String Formatting&lt;/li&gt;
  &lt;li&gt;PEP 3102: Keyword-Only Arguments&lt;/li&gt;
  &lt;li&gt;PEP 3104: Access to Names in Outer Scopes&lt;/li&gt;
  &lt;li&gt;PEP 3105: Make print a function&lt;/li&gt;
  &lt;li&gt;PEP 3106: Revamping dict.keys(), .values() and .items()&lt;/li&gt;
  &lt;li&gt;PEP 3107: Function Annotations&lt;/li&gt;
  &lt;li&gt;PEP 3108: Standard Library Reorganization&lt;/li&gt;
  &lt;li&gt;PEP 3109: Raising Exceptions in Python 3000&lt;/li&gt;
  &lt;li&gt;PEP 3110: Catching Exceptions in Python 3000&lt;/li&gt;
  &lt;li&gt;PEP 3111: Simple input built-in in Python 3000&lt;/li&gt;
  &lt;li&gt;PEP 3112: Bytes literals in Python 3000&lt;/li&gt;
  &lt;li&gt;PEP 3113: Removal of Tuple Parameter Unpacking&lt;/li&gt;
  &lt;li&gt;PEP 3114: Renaming iterator.next() to iterator.&lt;strong&gt;next&lt;/strong&gt;()&lt;/li&gt;
  &lt;li&gt;PEP 3115: Metaclasses in Python 3000&lt;/li&gt;
  &lt;li&gt;PEP 3116: New I/O&lt;/li&gt;
  &lt;li&gt;PEP 3118: Revising the buffer protocol&lt;/li&gt;
  &lt;li&gt;PEP 3119: Introducing Abstract Base Classes&lt;/li&gt;
  &lt;li&gt;PEP 3120: Using UTF-8 as the default source encoding&lt;/li&gt;
  &lt;li&gt;PEP 3121: Extension Module Initialization and Finalization&lt;/li&gt;
  &lt;li&gt;PEP 3123: Making PyObject_HEAD conform to standard C&lt;/li&gt;
  &lt;li&gt;PEP 3127: Integer Literal Support and Syntax&lt;/li&gt;
  &lt;li&gt;PEP 3129: Class Decorators&lt;/li&gt;
  &lt;li&gt;PEP 3131: Supporting Non-ASCII Identifiers&lt;/li&gt;
  &lt;li&gt;PEP 3132: Extended Iterable Unpacking&lt;/li&gt;
  &lt;li&gt;PEP 3134: Exception Chaining and Embedded Tracebacks&lt;/li&gt;
  &lt;li&gt;PEP 3135: New Super&lt;/li&gt;
  &lt;li&gt;PEP 3137: Immutable Bytes and Mutable Buffer&lt;/li&gt;
  &lt;li&gt;PEP 3138: String representation in Python 3000&lt;/li&gt;
  &lt;li&gt;PEP 3141: A Type Hierarchy for Numbers&lt;/li&gt;
  &lt;li&gt;PEP 3144: IP Address Manipulation Library for the Python Standard Library&lt;/li&gt;
  &lt;li&gt;PEP 3147: PYC Repository Directories&lt;/li&gt;
  &lt;li&gt;PEP 3148: futures - execute computations asynchronously&lt;/li&gt;
  &lt;li&gt;PEP 3149: ABI version tagged .so files&lt;/li&gt;
  &lt;li&gt;PEP 3151: Reworking the OS and IO exception hierarchy&lt;/li&gt;
  &lt;li&gt;PEP 3154: Pickle protocol version 4&lt;/li&gt;
  &lt;li&gt;PEP 3155: Qualified name for classes and functions&lt;/li&gt;
  &lt;li&gt;PEP 3156: Asynchronous IO Support Rebooted: the “asyncio” Module&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;과거의-메타-peps-및-정보-제공-peps-historical-meta-peps-and-informational-peps&quot;&gt;과거의 메타-PEPs 및 정보 제공 PEPs (Historical Meta-PEPs and Informational PEPs)&lt;/h4&gt;

&lt;p&gt;과거에 활동했던 메타-PEPs 및 정보 제공 PEPs입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEP 5: 언어 발전 지침 (Guidelines for Language Evolution)&lt;/li&gt;
  &lt;li&gt;PEP 200: Python 2.0 릴리스 일정 (Python 2.0 Release Schedule)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;연기된-peps-deferred-peps&quot;&gt;연기된 PEPs (Deferred PEPs)&lt;/h4&gt;

&lt;p&gt;추가 연구 또는 업데이트를 위해 연기된 비활성 초안입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEP 213: 속성 접근 핸들러 (Attribute Access Handlers)&lt;/li&gt;
  &lt;li&gt;PEP 312: 간단한 암묵적 람다 (Simple Implicit Lambda)&lt;/li&gt;
  &lt;li&gt;PEP 403: 일반 목적 데코레이터 절 (General purpose decorator clause)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;거부-대체-철회된-peps-rejected-superseded-and-withdrawn-peps&quot;&gt;거부, 대체, 철회된 PEPs (Rejected, Superseded, and Withdrawn PEPs)&lt;/h4&gt;

&lt;p&gt;공식적으로 거부되거나, 다른 PEP로 대체되거나, 제안자 또는 작성자에 의해 철회된 PEPs입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEP 3: 버그 보고서 처리 지침 (Guidelines for Handling Bug Reports)&lt;/li&gt;
  &lt;li&gt;PEP 42: 기능 요청 (Feature Requests)&lt;/li&gt;
  &lt;li&gt;PEP 204: 범위 리터럴 (Range Literals)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;예약된-pep-번호&quot;&gt;예약된 PEP 번호&lt;/h3&gt;

&lt;p&gt;특정 목적으로 예약된 PEP 번호입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEP 801: 예약됨 (Reserved)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pep-유형-키-pep-types-key&quot;&gt;PEP 유형 키 (PEP Types Key)&lt;/h3&gt;

&lt;p&gt;PEP의 유형을 나타내는 키입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;I — Informational (정보 제공):&lt;/strong&gt; Python 생태계에 대한 배경, 가이드라인 또는 기타 정보를 담고 있는 비규범적인 PEP입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;P — Process (프로세스):&lt;/strong&gt; Python 커뮤니티 프로세스, 워크플로우 또는 거버넌스 변경을 설명하거나 제안하는 규범적인 PEP입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;S — Standards Track (표준 트랙):&lt;/strong&gt; Python의 새로운 기능, CPython 구현 변경 또는 생태계 상호 운용성 표준에 대한 규범적인 PEP입니다.&lt;/li&gt;
  &lt;li&gt;자세한 내용은 &lt;a href=&quot;https://peps.python.org/pep-0001/&quot;&gt;PEP 1&lt;/a&gt;을 참조하세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pep-상태-키-pep-status-key&quot;&gt;PEP 상태 키 (PEP Status Key)&lt;/h3&gt;

&lt;p&gt;PEP의 현재 상태를 나타내는 키입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;A — Accepted (승인됨):&lt;/strong&gt; 구현을 위해 승인된 규범적 제안입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;A — Active (활성):&lt;/strong&gt; 현재 유효한 정보 제공 지침이거나 사용 중인 프로세스입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;D — Deferred (연기됨):&lt;/strong&gt; 나중에 다시 논의될 수 있는 비활성 초안입니다.&lt;/li&gt;
  &lt;li&gt;**&lt;문자 없음=&quot;&quot;&gt; — Draft (초안):** 현재 활발히 논의 및 수정 중인 제안입니다.&lt;/문자&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;F — Final (최종):&lt;/strong&gt; 승인 및 구현이 완료되었거나 더 이상 활성화되지 않는 제안입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;P — Provisional (임시):&lt;/strong&gt; 잠정적으로 승인되었으나 추가 피드백이 필요한 제안입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;R — Rejected (거부됨):&lt;/strong&gt; 공식적으로 거부되어 수용되지 않을 제안입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;S — Superseded (대체됨):&lt;/strong&gt; 다른 후속 PEP로 대체된 제안입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;W — Withdrawn (철회됨):&lt;/strong&gt; 스폰서 또는 작성자에 의해 고려 대상에서 제거된 제안입니다.&lt;/li&gt;
  &lt;li&gt;자세한 내용은 &lt;a href=&quot;https://peps.python.org/pep-0001/&quot;&gt;PEP 1&lt;/a&gt;을 참조하세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 21:19:02 +0900</pubDate>
        <link>http://localhost:4000/python/pep/0/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/0/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 8106 - 2025 Term Steering Council election</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8106/&quot;&gt;PEP 8106 - 2025 Term Steering Council election&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 21-Oct-2024&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-8106--2025년-임기-스티어링-카운슬-선거-번역-및-정리&quot;&gt;PEP 8106 – 2025년 임기 스티어링 카운슬 선거 번역 및 정리&lt;/h2&gt;

&lt;h3 id=&quot;1-개요-abstract&quot;&gt;1. 개요 (Abstract)&lt;/h3&gt;

&lt;p&gt;이 문서는 PEP 13에 명시된 바에 따라, Python 스티어링 카운슬(Steering Council)의 2024년 선거 일정 및 기타 세부 사항을 기술합니다. 이 선거는 2025년 임기(즉, Python 3.14)를 위한 스티어링 카운슬 선거입니다.&lt;/p&gt;

&lt;h3 id=&quot;2-도입-배경-및-스티어링-카운슬의-역할&quot;&gt;2. 도입 배경 및 스티어링 카운슬의 역할&lt;/h3&gt;

&lt;p&gt;Python의 거버넌스 모델은 초기 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BDFL (Benevolent Dictator For Life)&lt;/code&gt;이었던 Guido van Rossum의 은퇴 이후 PEP 13에 따라 스티어링 카운슬 체제로 전환되었습니다. 스티어링 카운슬은 Python 프로젝트의 기술적 방향을 이끌고, PEP(Python Enhancement Proposal) 승인, 논쟁 중재, 프로젝트의 전반적인 건강과 발전을 보장하는 중요한 역할을 수행합니다. 매년 핵심 개발자들의 투표를 통해 새로운 임기의 스티어링 카운슬이 선출되며, 이들은 Python의 미래에 큰 영향을 미치게 됩니다. PEP 8106은 이러한 중요한 선거 과정을 상세히 기록하고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;3-선거-관리-election-administration&quot;&gt;3. 선거 관리 (Election Administration)&lt;/h3&gt;

&lt;p&gt;스티어링 카운슬은 Python Software Foundation (PSF)의 인프라 디렉터인 Ee Durbin을 이 선거의 관리자로 임명했습니다.&lt;/p&gt;

&lt;h3 id=&quot;4-일정-schedule&quot;&gt;4. 일정 (Schedule)&lt;/h3&gt;

&lt;p&gt;선거는 2주간의 후보 지명 기간과 2주간의 투표 기간으로 진행되었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;후보 지명 기간:&lt;/strong&gt; 2024년 11월 7일 ~ 2024년 11월 21일 (AoE)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 기간:&lt;/strong&gt; 2024년 11월 25일 ~ 2024년 12월 9일 (AoE)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;AoE (Anywhere on Earth)&lt;/em&gt;: 지구상 어느 곳이든. 즉, 지정된 날짜의 마지막 시간대까지를 의미합니다.&lt;/p&gt;

&lt;h3 id=&quot;5-후보자-candidates&quot;&gt;5. 후보자 (Candidates)&lt;/h3&gt;

&lt;p&gt;후보자는 핵심 팀원(core team member)에 의해 지명되어야 합니다. 후보자가 핵심 팀원인 경우, 스스로를 지명할 수 있습니다.&lt;/p&gt;

&lt;p&gt;지명된 후보자 (이름 알파벳 순):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Donghee Na (나동희)&lt;/li&gt;
  &lt;li&gt;Emily Morehouse&lt;/li&gt;
  &lt;li&gt;Ethan Furman&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith&lt;/li&gt;
  &lt;li&gt;Mariatta&lt;/li&gt;
  &lt;li&gt;Pablo Galindo Salgado&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;철회된 지명은 없었습니다.&lt;/p&gt;

&lt;h3 id=&quot;6-유권자-명부-voter-roll&quot;&gt;6. 유권자 명부 (Voter Roll)&lt;/h3&gt;

&lt;p&gt;모든 활동 중인 Python 핵심 팀원(active Python core team members)이 투표할 자격이 있습니다. 활동 상태는 PEP 13에 설명된 대로 결정되며, python/voters 소프트웨어를 통해 구현됩니다. 투표 용지는 이 선거를 위한 Python 유권자 명부를 기반으로 배포되었습니다. 이 파일은 개인 이메일 주소를 포함하고 있어 공개되지 않지만, 전체 유권자 명부(Complete Voter Roll)는 이름으로 모든 유권자 목록을 제공합니다.&lt;/p&gt;

&lt;h3 id=&quot;7-선거-구현-election-implementation&quot;&gt;7. 선거 구현 (Election Implementation)&lt;/h3&gt;

&lt;p&gt;선거는 Helios Voting Service를 사용하여 실시되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설정 (Configuration):&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;약식 이름 (Short name):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2025-python-steering-council&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;이름 (Name):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2025 Python Steering Council Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설명 (Description):&lt;/strong&gt; PEP 13에 명시된 Python 스티어링 카운슬 선거. 2025년 임기를 위한 스티어링 카운슬 선거.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형 (type):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유권자 별칭 사용 (Use voter aliases):&lt;/strong&gt; [X] (활성화됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;답변 순서 무작위화 (Randomize answer order):&lt;/strong&gt; [X] (활성화됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비공개 (Private):&lt;/strong&gt; [X] (활성화됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;도움 이메일 주소 (Help Email Address):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;psf-election@python.org&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 시작 (Voting starts at):&lt;/strong&gt; 2024년 11월 25일 12:00 UTC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 종료 (Voting ends at):&lt;/strong&gt; 2024년 12월 10일 12:00 UTC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 설정으로 다음과 같은 선거가 진행되었습니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;투표는 일반에 공개되지 않으며, 유권자 명부에 있는 사람만 참여할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;투표 시작 시 투표 용지가 이메일로 발송되었습니다.&lt;/li&gt;
  &lt;li&gt;후보자들은 무작위 순서로 제시되어 편향을 피하는 데 도움이 되었습니다.&lt;/li&gt;
  &lt;li&gt;유권자 신원과 투표 용지는 암호화 기술 발전에 대비하여 보호됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;질문 (Questions):&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;질문 1:&lt;/strong&gt; 0개에서 (승인) 답변까지 선택합니다. 결과 유형: 절대적&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;질문:&lt;/strong&gt; Python 스티어링 카운슬 후보자를 선택하세요.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;답변 #1 - #N:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;후보자&lt;/code&gt; 섹션의 후보자들.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-결과-results&quot;&gt;8. 결과 (Results)&lt;/h3&gt;

&lt;p&gt;전체 100명의 유권자 중 76명이 투표했습니다.&lt;/p&gt;

&lt;p&gt;가장 많은 표를 얻은 상위 5명은 다음과 같습니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Barry Warsaw&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Donghee Na (나동희)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Emily Morehouse&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Gregory P. Smith&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Pablo Galindo Salgado&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PEP 13에 정의된 이해 상충(conflict of interest)은 관찰되지 않았습니다.&lt;/p&gt;

&lt;p&gt;전체 득표수는 다음과 같습니다:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;후보자&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;받은 투표 수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Barry Warsaw&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;58&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Donghee Na&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;48&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Emily Morehouse&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;52&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Ethan Furman&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;31&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Gregory P. Smith&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;50&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Mariatta&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;23&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Pablo Galindo Salgado&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;63&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Thomas Wouters&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;38&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;9-python-사용에-미치는-영향&quot;&gt;9. Python 사용에 미치는 영향&lt;/h3&gt;

&lt;p&gt;이 PEP는 Python 스티어링 카운슬의 선거 절차와 결과를 다루는 정보성 문서이므로, 직접적으로 Python 언어의 기능이나 사용 방식에 즉각적인 변화를 가져오지는 않습니다. 하지만, 이 선거를 통해 선출된 스티어링 카운슬 멤버들은 향후 Python 개발의 주요 의사 결정(예: 새로운 언어 기능 추가, 기존 기능 변경, 개발 우선순위 설정 등)에 직접적으로 관여하게 됩니다. 따라서 이들의 리더십과 방향성은 장기적으로 Python 언어의 진화, 표준 라이브러리의 발전, 그리고 커뮤니티 거버넌스에 지대한 영향을 미쳐, 궁극적으로 모든 Python 개발자의 실제 Python 사용 경험에 중대한 영향을 미치게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:35:42 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8106/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8106/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 8105 - 2024 Term Steering Council election</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8105/&quot;&gt;PEP 8105 - 2024 Term Steering Council election&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 23-Oct-2023&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-8105--2024년-임기-steering-council-선거&quot;&gt;PEP 8105 – 2024년 임기 Steering Council 선거&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Ee Durbin «ee at python.org»
&lt;strong&gt;후원자:&lt;/strong&gt; Thomas Wouters «thomas at python.org»
&lt;strong&gt;상태:&lt;/strong&gt; 최종 (Final)
&lt;strong&gt;유형:&lt;/strong&gt; 정보 제공 (Informational)
&lt;strong&gt;주제:&lt;/strong&gt; 거버넌스 (Governance)
&lt;strong&gt;생성일:&lt;/strong&gt; 2023년 10월 23일&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;초록-abstract&quot;&gt;초록 (Abstract)&lt;/h3&gt;
&lt;p&gt;이 문서는 PEP 13에 명시된 바와 같이 Python Steering Council의 2023년 선거(2024년 임기, 즉 Python 3.13) 일정 및 기타 세부 사항을 설명합니다.&lt;/p&gt;

&lt;h3 id=&quot;선거-관리-election-administration&quot;&gt;선거 관리 (Election Administration)&lt;/h3&gt;
&lt;p&gt;Steering Council은 Python Software Foundation의 인프라 책임자인 Ee Durbin을 선거 관리자로 임명했습니다.&lt;/p&gt;

&lt;h3 id=&quot;일정-schedule&quot;&gt;일정 (Schedule)&lt;/h3&gt;
&lt;p&gt;후보 지명 기간은 2주였으며, 이어서 2주간의 투표 기간이 있었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;후보 지명 기간:&lt;/strong&gt; 2023년 11월 9일 ~ 2023년 11월 22일 AoE (Anywhere on Earth)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 기간:&lt;/strong&gt; 2023년 11월 27일 ~ 2023년 12월 11일 AoE&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;후보자-candidates&quot;&gt;후보자 (Candidates)&lt;/h3&gt;
&lt;p&gt;후보자는 핵심 팀원(core team member)의 지명을 받아야 합니다. 후보자가 핵심 팀원인 경우, 스스로를 지명할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;지명된 후보자 (이름 가나다순):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Donghee Na (나동희)&lt;/li&gt;
  &lt;li&gt;Emily Morehouse&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith&lt;/li&gt;
  &lt;li&gt;Mariatta&lt;/li&gt;
  &lt;li&gt;Pablo Galindo Salgado&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
  &lt;li&gt;Victor Stinner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;철회된 지명:&lt;/strong&gt; 없음&lt;/p&gt;

&lt;h3 id=&quot;유권자-명부-voter-roll&quot;&gt;유권자 명부 (Voter Roll)&lt;/h3&gt;
&lt;p&gt;모든 활동 중인 Python 핵심 팀원(active Python core team members)은 투표 자격이 있습니다. 활동 상태는 PEP 13에 설명된 대로 결정되며, python/voters 소프트웨어를 통해 구현됩니다.&lt;/p&gt;

&lt;p&gt;투표 용지는 이번 선거의 Python Voter Roll을 기반으로 배포되었습니다. 이 파일은 개인 이메일 주소를 포함하고 있어 공개되지 않지만, 모든 유권자 이름 목록이 포함된 전체 유권자 명부(Complete Voter Roll)는 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;선거-구현-election-implementation&quot;&gt;선거 구현 (Election Implementation)&lt;/h3&gt;
&lt;p&gt;선거는 Helios Voting Service를 사용하여 진행되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설정 (Configuration):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;짧은 이름 (Short name):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2024-python-steering-council&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;이름 (Name):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2024 Python Steering Council Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설명 (Description):&lt;/strong&gt; PEP 13에 명시된 Python Steering Council 선거. 2024년 임기를 위한 Steering Council 선거입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형 (type):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유권자 별칭 사용 (Use voter aliases):&lt;/strong&gt; [X] (체크됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;답변 순서 무작위화 (Randomize answer order):&lt;/strong&gt; [X] (체크됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비공개 (Private):&lt;/strong&gt; [X] (체크됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;도움 이메일 주소 (Help Email Address):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;psf-election@python.org&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 시작 (Voting starts at):&lt;/strong&gt; 2023년 11월 27일 12:00 UTC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 종료 (Voting ends at):&lt;/strong&gt; 2023년 12월 11일 12:00 UTC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이는 다음과 같은 선거를 만듭니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;투표는 공개되지 않으며, 유권자 명부에 있는 사람만 참여할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;투표 시작 시 투표 용지가 이메일로 발송됩니다.&lt;/li&gt;
  &lt;li&gt;후보자는 편향을 피하기 위해 무작위 순서로 제시됩니다.&lt;/li&gt;
  &lt;li&gt;유권자의 신원과 투표 용지는 암호화 기술의 발전으로부터 보호됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;질문 (Questions):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;질문 1:&lt;/strong&gt; 0개에서 - (승인) 답변 중에서 선택하십시오. 결과 유형: 절대 (absolute)
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;질문:&lt;/strong&gt; Python Steering Council을 위한 후보자를 선택하십시오.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;답변 #1 - #N:&lt;/strong&gt; 후보자 섹션의 후보자들&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연장된-선거-구현-extended-election-implementation&quot;&gt;연장된 선거 구현 (Extended Election Implementation)&lt;/h3&gt;
&lt;p&gt;발표된 일정과 초기 선거 구현 간의 불일치로 인해, 초기 선거에서 투표권을 행사하지 못한 유권자들에게 추가적인 날짜를 제공하기 위해 연장된 선거가 개최되었습니다.&lt;/p&gt;

&lt;p&gt;초기 선거 결과는 연장된 선거 결과와 합산되었습니다. 초기 선거에서 투표하지 않은 유권자만 투표할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;이 선거도 Helios Voting Service를 사용하여 진행되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설정 (Configuration):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;짧은 이름 (Short name):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2024-python-steering-council-extension&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;이름 (Name):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2024 Python Steering Council Election Extension&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설명 (Description):&lt;/strong&gt; PEP 13에 명시된 Python Steering Council 선거. 2024년 임기를 위한 Steering Council 선거입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형 (type):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유권자 별칭 사용 (Use voter aliases):&lt;/strong&gt; [X] (체크됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;답변 순서 무작위화 (Randomize answer order):&lt;/strong&gt; [X] (체크됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비공개 (Private):&lt;/strong&gt; [X] (체크됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;도움 이메일 주소 (Help Email Address):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;psf-election@python.org&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 시작 (Voting starts at):&lt;/strong&gt; 2023년 12월 11일 12:00 UTC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 종료 (Voting ends at):&lt;/strong&gt; 2023년 12월 12일 12:00 UTC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이는 다음과 같은 선거를 만듭니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;투표는 공개되지 않으며, 유권자 명부에 있는 사람만 참여할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;투표 시작 시 투표 용지가 이메일로 발송됩니다.&lt;/li&gt;
  &lt;li&gt;후보자는 편향을 피하기_위해 무작위 순서로 제시됩니다.&lt;/li&gt;
  &lt;li&gt;유권자의 신원과 투표 용지는 암호화 기술의 발전으로부터 보호됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;질문 (Questions):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;질문 1:&lt;/strong&gt; 0개에서 - (승인) 답변 중에서 선택하십시오. 결과 유형: 절대 (absolute)
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;질문:&lt;/strong&gt; Python Steering Council을 위한 후보자를 선택하십시오.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;답변 #1 - #N:&lt;/strong&gt; 후보자 섹션의 후보자들&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;결과-results&quot;&gt;결과 (Results)&lt;/h3&gt;
&lt;p&gt;자격 있는 유권자 87명 중 68명이 투표했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;최다 득표자 5명:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Pablo Galindo Salgado&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith&lt;/li&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Emily Morehouse&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PEP 13에 정의된 이해 상충(conflict of interest)은 관찰되지 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;전체 득표수는 다음과 같습니다:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;초기 선거 (Initial Election)&lt;/strong&gt;
자격 있는 유권자 87명 중 56명이 투표했습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;후보자&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;득표수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Barry Warsaw&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;35&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Donghee Na&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;27&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Emily Morehouse&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;38&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Gregory P. Smith&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;42&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Mariatta&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Pablo Galindo Salgado&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;48&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Thomas Wouters&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Victor Stinner&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;27&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;연장된 선거 (Election Extension)&lt;/strong&gt;
초기 선거에서 투표권을 행사하지 못한 자격 있는 유권자 31명 중 12명이 투표했습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;후보자&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;득표수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Barry Warsaw&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Donghee Na&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Emily Morehouse&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Gregory P. Smith&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Mariatta&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Pablo Galindo Salgado&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Thomas Wouters&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Victor Stinner&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;합산 결과 (Combined)&lt;/strong&gt;
자격 있는 유권자 87명 중 68명이 투표했습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;후보자&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;득표수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Barry Warsaw&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;43&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Donghee Na&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;32&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Emily Morehouse&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;46&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Gregory P. Smith&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;52&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Mariatta&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Pablo Galindo Salgado&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;60&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Thomas Wouters&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;40&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Victor Stinner&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;35&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h3&gt;
&lt;p&gt;이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;전체-유권자-명부-complete-voter-roll&quot;&gt;전체 유권자 명부 (Complete Voter Roll)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;활동 중인 Python 핵심 개발자 (Active Python core developers):&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Adam Turner&lt;/li&gt;
  &lt;li&gt;Alex Gaynor&lt;/li&gt;
  &lt;li&gt;Alex Waygood&lt;/li&gt;
  &lt;li&gt;Alexander Belopolsky&lt;/li&gt;
  &lt;li&gt;Alyssa Coghlan&lt;/li&gt;
  &lt;li&gt;Ammar Askar&lt;/li&gt;
  &lt;li&gt;Andrew Svetlov&lt;/li&gt;
  &lt;li&gt;Antoine Pitrou&lt;/li&gt;
  &lt;li&gt;Barney Gale&lt;/li&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Batuhan Taskaya&lt;/li&gt;
  &lt;li&gt;Benjamin Peterson&lt;/li&gt;
  &lt;li&gt;Berker Peksağ&lt;/li&gt;
  &lt;li&gt;Brandt Bucher&lt;/li&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Brian Curtin&lt;/li&gt;
  &lt;li&gt;C.A.M. Gerlach&lt;/li&gt;
  &lt;li&gt;Carl Friedrich Bolz-Tereick&lt;/li&gt;
  &lt;li&gt;Carl Meyer&lt;/li&gt;
  &lt;li&gt;Carol Willing&lt;/li&gt;
  &lt;li&gt;Cheryl Sabella&lt;/li&gt;
  &lt;li&gt;Chris Withers&lt;/li&gt;
  &lt;li&gt;Christian Heimes&lt;/li&gt;
  &lt;li&gt;Dennis Sweeney&lt;/li&gt;
  &lt;li&gt;Dino Viehland&lt;/li&gt;
  &lt;li&gt;Donghee Na&lt;/li&gt;
  &lt;li&gt;Emily Morehouse&lt;/li&gt;
  &lt;li&gt;Éric Araujo&lt;/li&gt;
  &lt;li&gt;Eric Snow&lt;/li&gt;
  &lt;li&gt;Eric V. Smith&lt;/li&gt;
  &lt;li&gt;Erlend Egeberg Aasland&lt;/li&gt;
  &lt;li&gt;Ethan Furman&lt;/li&gt;
  &lt;li&gt;Ezio Melotti&lt;/li&gt;
  &lt;li&gt;Facundo Batista&lt;/li&gt;
  &lt;li&gt;Filipe Lains&lt;/li&gt;
  &lt;li&gt;Georg Brandl&lt;/li&gt;
  &lt;li&gt;Giampaolo Rodolà&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith&lt;/li&gt;
  &lt;li&gt;Guido van Rossum&lt;/li&gt;
  &lt;li&gt;Hugo van Kemenade&lt;/li&gt;
  &lt;li&gt;Hynek Schlawack&lt;/li&gt;
  &lt;li&gt;Inada Naoki&lt;/li&gt;
  &lt;li&gt;Irit Katriel&lt;/li&gt;
  &lt;li&gt;Ivan Levkivskyi&lt;/li&gt;
  &lt;li&gt;Jason R. Coombs&lt;/li&gt;
  &lt;li&gt;Jelle Zijlstra&lt;/li&gt;
  &lt;li&gt;Jeremy Kloth&lt;/li&gt;
  &lt;li&gt;Joannah Nanjekye&lt;/li&gt;
  &lt;li&gt;Julien Palard&lt;/li&gt;
  &lt;li&gt;Karthikeyan Singaravelan&lt;/li&gt;
  &lt;li&gt;Ken Jin&lt;/li&gt;
  &lt;li&gt;Kumar Aditya&lt;/li&gt;
  &lt;li&gt;Kurt B. Kaiser&lt;/li&gt;
  &lt;li&gt;Kushal Das&lt;/li&gt;
  &lt;li&gt;Larry Hastings&lt;/li&gt;
  &lt;li&gt;Lukasz Langa&lt;/li&gt;
  &lt;li&gt;Lysandros Nikolaou&lt;/li&gt;
  &lt;li&gt;Marc-André Lemburg&lt;/li&gt;
  &lt;li&gt;Mariatta&lt;/li&gt;
  &lt;li&gt;Mark Dickinson&lt;/li&gt;
  &lt;li&gt;Mark Shannon&lt;/li&gt;
  &lt;li&gt;Nathaniel J. Smith&lt;/li&gt;
  &lt;li&gt;Ned Deily&lt;/li&gt;
  &lt;li&gt;Neil Schemenauer&lt;/li&gt;
  &lt;li&gt;Pablo Galindo&lt;/li&gt;
  &lt;li&gt;Paul Ganssle&lt;/li&gt;
  &lt;li&gt;Paul Moore&lt;/li&gt;
  &lt;li&gt;Petr Viktorin&lt;/li&gt;
  &lt;li&gt;Pradyun Gedam&lt;/li&gt;
  &lt;li&gt;R. David Murray&lt;/li&gt;
  &lt;li&gt;Raymond Hettinger&lt;/li&gt;
  &lt;li&gt;Ronald Oussoren&lt;/li&gt;
  &lt;li&gt;Senthil Kumaran&lt;/li&gt;
  &lt;li&gt;Serhiy Storchaka&lt;/li&gt;
  &lt;li&gt;Shantanu Jain&lt;/li&gt;
  &lt;li&gt;Stefan Behnel&lt;/li&gt;
  &lt;li&gt;Stéphane Wirtel&lt;/li&gt;
  &lt;li&gt;Steve Dower&lt;/li&gt;
  &lt;li&gt;Tal Einat&lt;/li&gt;
  &lt;li&gt;Terry Jan Reedy&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
  &lt;li&gt;Tim Golden&lt;/li&gt;
  &lt;li&gt;Tim Peters&lt;/li&gt;
  &lt;li&gt;Victor Stinner&lt;/li&gt;
  &lt;li&gt;Vinay Sajip&lt;/li&gt;
  &lt;li&gt;Yury Selivanov&lt;/li&gt;
  &lt;li&gt;Zachary Ware&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:34:28 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8105/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8105/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 8104 - 2023 Term Steering Council election</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8104/&quot;&gt;PEP 8104 - 2023 Term Steering Council election&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 08-Nov-2022&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;PEP 8104는 “2023 Term Steering Council election”에 대한 정보성(Informational) PEP로, 2022년 12월에 진행된 Python 스티어링 카운슬(Steering Council) 선거의 일정 및 세부 사항을 다루고 있습니다. 이 문서는 Python 3.12 버전에 해당하는 2023년 임기의 스티어링 카운슬 선거에 대한 내용을 명시합니다.&lt;/p&gt;

&lt;h2 id=&quot;개요-abstract&quot;&gt;개요 (Abstract)&lt;/h2&gt;
&lt;p&gt;이 문서는 PEP 13에 명시된 바와 같이, Python 스티어링 카운슬의 2022년 12월 선거 일정과 기타 세부 사항을 설명합니다. 이는 2023년 임기(즉, Python 3.12) 스티어링 카운슬 선거입니다.&lt;/p&gt;

&lt;h2 id=&quot;선거-관리-election-administration&quot;&gt;선거 관리 (Election Administration)&lt;/h2&gt;
&lt;p&gt;스티어링 카운슬은 Python Software Foundation의 인프라 책임자인 Ee Durbin을 선거 관리자로 임명했습니다.&lt;/p&gt;

&lt;h2 id=&quot;일정-schedule&quot;&gt;일정 (Schedule)&lt;/h2&gt;
&lt;p&gt;선거는 2주간의 후보 지명 기간과 이어진 2주간의 투표 기간으로 구성되었습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;후보 지명 기간:&lt;/strong&gt; 2022년 11월 14일부터 2022년 11월 28일 AoE(Anywhere on Earth)까지.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 기간:&lt;/strong&gt; 2022년 12월 1일부터 2022년 12월 14일 AoE(Anywhere on Earth)까지.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;후보자-candidates&quot;&gt;후보자 (Candidates)&lt;/h2&gt;
&lt;p&gt;후보자는 코어 팀(core team) 멤버에 의해 지명되어야 합니다. 후보자가 코어 팀 멤버인 경우 스스로를 지명할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;지명된 후보자 (알파벳순):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Emily Morehouse&lt;/li&gt;
  &lt;li&gt;Dong-hee Na&lt;/li&gt;
  &lt;li&gt;Pablo Galindo Salgado&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith&lt;/li&gt;
  &lt;li&gt;Victor Stinner&lt;/li&gt;
  &lt;li&gt;Petr Viktorin&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;철회된 지명:&lt;/strong&gt; 없음&lt;/p&gt;

&lt;h2 id=&quot;유권자-명부-voter-roll&quot;&gt;유권자 명부 (Voter Roll)&lt;/h2&gt;
&lt;p&gt;모든 활동 중인 Python 코어 팀 멤버는 투표 자격이 있습니다. 활동 상태는 PEP 13에 설명된 대로 결정되며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python/voters&lt;/code&gt; 소프트웨어를 통해 구현됩니다.&lt;/p&gt;

&lt;p&gt;투표 용지는 이 선거의 Python 유권자 명부를 기반으로 배포되었습니다. 이 파일은 개인 이메일 주소를 포함하고 있어 공개되지 않지만, 명부가 생성되면 이름으로 된 “Complete Voter Roll”이 공개될 예정이었습니다.&lt;/p&gt;

&lt;h2 id=&quot;선거-구현-election-implementation&quot;&gt;선거 구현 (Election Implementation)&lt;/h2&gt;
&lt;p&gt;선거는 Helios Voting Service를 사용하여 진행되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Configuration (구성):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Short name:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2023-python-steering-council&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Name:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2023 Python Steering Council Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; PEP 13에 명시된 Python 스티어링 카운슬 선거. 2023년 임기 스티어링 카운슬 선거입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;type:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Use voter aliases:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[X]&lt;/code&gt; (유권자 별칭 사용)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Randomize answer order:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[X]&lt;/code&gt; (답변 순서 무작위화)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Private:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[X]&lt;/code&gt; (비공개)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Help Email Address:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;psf-election@python.org&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Voting starts at:&lt;/strong&gt; 2022년 12월 1일 12:00 UTC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Voting ends at:&lt;/strong&gt; 2022년 12월 15일 12:00 UTC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이는 다음과 같은 방식으로 선거가 진행됨을 의미합니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;투표는 일반에 공개되지 않으며, 유권자 명부에 있는 사람만 참여할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;투표 시작 시 투표 용지가 이메일로 발송됩니다.&lt;/li&gt;
  &lt;li&gt;후보자는 편향을 피하기 위해 무작위 순서로 제시됩니다.&lt;/li&gt;
  &lt;li&gt;유권자의 신원과 투표 용지는 암호화 기술의 발전으로부터 보호됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Questions (질문):&lt;/strong&gt;
&lt;strong&gt;질문 1:&lt;/strong&gt; Python 스티어링 카운슬 후보자를 선택하십시오.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Select between 0 and - (approval) answers.&lt;/strong&gt; (0개에서 -개까지 (승인) 답변 선택)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Result Type:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;absolute&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Answer #1 - #N:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Candidates from Candidates_ Section&lt;/code&gt; (후보자 섹션의 후보자들)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-results&quot;&gt;결과 (Results)&lt;/h2&gt;
&lt;p&gt;85명의 자격 있는 유권자 중 66명이 투표했습니다.
가장 많은 표를 얻은 상위 5명은 다음과 같습니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Pablo Galindo Salgado&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith&lt;/li&gt;
  &lt;li&gt;Emily Morehouse&lt;/li&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PEP 13에 정의된 이해 상충은 관찰되지 않았습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;전체 득표수:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Pablo Galindo Salgado: 61표&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith: 48표&lt;/li&gt;
  &lt;li&gt;Emily Morehouse: 47표&lt;/li&gt;
  &lt;li&gt;Brett Cannon: 42표&lt;/li&gt;
  &lt;li&gt;Thomas Wouters: 39표&lt;/li&gt;
  &lt;li&gt;Petr Viktorin: 36표&lt;/li&gt;
  &lt;li&gt;Victor Stinner: 34표&lt;/li&gt;
  &lt;li&gt;Dong-hee Na: 29표&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h2&gt;
&lt;p&gt;이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;전체-유권자-명부-complete-voter-roll&quot;&gt;전체 유권자 명부 (Complete Voter Roll)&lt;/h2&gt;
&lt;p&gt;문서에는 선거에 참여할 수 있는 전체 Python 코어 개발자 명단이 이름순으로 나열되어 있습니다. (개인 정보 보호를 위해 이메일 주소는 포함되지 않음)
이 명단은 Python 코어 개발자, 관리자 및 Python Software Foundation 직원에만 접근 가능하다고 명시되어 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:34:01 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8104/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8104/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 8103 - 2022 Term Steering Council election</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8103/&quot;&gt;PEP 8103 - 2022 Term Steering Council election&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 04-Oct-2021&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;pep-8103--2022년도-steering-council-선거&quot;&gt;PEP 8103 – 2022년도 Steering Council 선거&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Ewa Jodlowska, Ee Durbin, Joe Carey&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;후원자:&lt;/strong&gt; Barry Warsaw&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational (정보성)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주제:&lt;/strong&gt; Governance (거버넌스)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;생성일:&lt;/strong&gt; 2021년 10월 4일&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개요-abstract&quot;&gt;개요 (Abstract)&lt;/h2&gt;

&lt;p&gt;이 문서는 PEP 13에 명시된 대로 2021년 12월에 진행된 Python Steering Council (운영 위원회) 선거의 일정 및 기타 세부 사항을 설명합니다. 이는 2022년 임기(즉, Python 3.11 개발 기간)를 위한 Steering Council 선거입니다.&lt;/p&gt;

&lt;h2 id=&quot;선거-관리-election-administration&quot;&gt;선거 관리 (Election Administration)&lt;/h2&gt;

&lt;p&gt;Steering Council은 Python Software Foundation의 인프라 디렉터인 Ee Durbin과 회계 관리자인 Joe Carey를 선거 공동 관리자로 임명했습니다.&lt;/p&gt;

&lt;h2 id=&quot;일정-schedule&quot;&gt;일정 (Schedule)&lt;/h2&gt;

&lt;p&gt;지명 기간(nomination period)은 2주, 투표 기간(voting period)은 2주로 진행되었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;지명 기간:&lt;/strong&gt; 2021년 11월 1일부터 2021년 11월 16일 12:00 UTC (Anywhere on Earth 기준 2021년 11월 15일 말)까지였습니다. 이 내용은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-committers&lt;/code&gt; 메일링 리스트에 공지되었고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;discuss.python.org&lt;/code&gt;에서 진행되었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 기간:&lt;/strong&gt; 2021년 12월 1일 12:00 UTC부터 2021년 12월 16일 12:00 UTC (Anywhere on Earth 기준 2021년 12월 15일 말)까지였습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;후보자-candidates&quot;&gt;후보자 (Candidates)&lt;/h2&gt;

&lt;p&gt;후보자는 코어 팀 멤버에 의해 지명되어야 합니다. 후보자가 코어 팀 멤버인 경우 스스로를 지명할 수 있습니다.&lt;/p&gt;

&lt;p&gt;지명된 후보자(알파벳 순):&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Mariatta&lt;/li&gt;
  &lt;li&gt;David Mertz&lt;/li&gt;
  &lt;li&gt;Dong-hee Na (나동희)&lt;/li&gt;
  &lt;li&gt;Pablo Galindo Salgado&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith&lt;/li&gt;
  &lt;li&gt;Victor Stinner&lt;/li&gt;
  &lt;li&gt;Petr Viktorin&lt;/li&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;철회된 지명은 없었습니다.&lt;/p&gt;

&lt;h2 id=&quot;유권자-명부-voter-roll&quot;&gt;유권자 명부 (Voter Roll)&lt;/h2&gt;

&lt;p&gt;모든 활동 중인 Python 코어 팀 멤버는 투표 자격이 있습니다. 활동 상태는 PEP 13에 설명된 대로 결정되며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python/voters&lt;/code&gt; 소프트웨어를 통해 구현됩니다.&lt;/p&gt;

&lt;p&gt;투표 용지는 이 선거를 위한 Python 유권자 명부(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;The Python Voter Roll&lt;/code&gt;)를 기반으로 배포되었습니다.
이 파일은 개인 이메일 주소를 포함하므로 공개되지 않지만, 명부가 생성되면 이름으로 된 전체 유권자 명부는 공개될 예정이었습니다.&lt;/p&gt;

&lt;h2 id=&quot;선거-구현-election-implementation&quot;&gt;선거 구현 (Election Implementation)&lt;/h2&gt;

&lt;p&gt;선거는 Helios Voting Service를 사용하여 진행되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;설정-configuration&quot;&gt;설정 (Configuration)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Short name:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2022-python-steering-council&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Name:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2022 Python Steering Council Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; PEP 13에 명시된 Python Steering Council 선거입니다. 2022년 임기를 위한 Steering Council 선거입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; Election&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Use voter aliases:&lt;/strong&gt; [X] (유권자 가명 사용)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Randomize answer order:&lt;/strong&gt; [X] (답변 순서 무작위화)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Private:&lt;/strong&gt; [X] (비공개)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Help Email Address:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;psf-election@python.org&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Voting starts at:&lt;/strong&gt; 2021년 12월 1일 00:00 UTC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Voting ends at:&lt;/strong&gt; 2021년 12월 16일 12:00 UTC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 설정으로 다음과 같은 선거가 진행되었습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;투표는 일반에 공개되지 않으며, 유권자 명부에 있는 사람만 참여할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;투표 시작 시 투표 용지가 이메일로 발송됩니다.&lt;/li&gt;
  &lt;li&gt;후보자들은 편향을 피하기 위해 무작위 순서로 제시됩니다.&lt;/li&gt;
  &lt;li&gt;유권자의 신원과 투표 용지는 암호학적 공격으로부터 보호됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;질문-questions&quot;&gt;질문 (Questions)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;질문 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Select between 0 and - (approval) answers.&lt;/strong&gt; (0개에서 승인 가능한 범위 내에서 답변을 선택하세요.)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Result Type:&lt;/strong&gt; absolute (절대값)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Question:&lt;/strong&gt; Select candidates for the Python Steering Council (Python Steering Council 후보자를 선택하세요)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Answer #1 - #N:&lt;/strong&gt; Candidates from Candidates_ Section (후보자 섹션의 후보자들)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-results&quot;&gt;결과 (Results)&lt;/h2&gt;

&lt;p&gt;투표 자격이 있는 85명의 유권자 중 67명이 투표에 참여했습니다.&lt;/p&gt;

&lt;p&gt;가장 많은 표를 얻은 상위 5명은 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Pablo Galindo Salgado&lt;/li&gt;
  &lt;li&gt;Petr Viktorin&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith&lt;/li&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PEP 13에 정의된 이해 상충(conflict of interest)은 관찰되지 않았습니다.&lt;/p&gt;

&lt;p&gt;전체 득표수는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;후보자&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;득표수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Pablo Galindo Salgado&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;61&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Petr Viktorin&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;48&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Thomas Wouters&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;48&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Gregory P. Smith&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;44&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Brett Cannon&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;42&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Barry Warsaw&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;39&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Victor Stinner&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;35&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Mariatta&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;34&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Dong-hee Na&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;26&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;David Mertz&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;24&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h2&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;전체-유권자-명부-complete-voter-roll&quot;&gt;전체 유권자 명부 (Complete Voter Roll)&lt;/h2&gt;

&lt;p&gt;활성 Python 코어 개발자들의 명단은 문서에 포함되어 있습니다. (본 내용에서는 개인 정보 보호를 위해 상세 명단은 생략합니다.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고:&lt;/strong&gt; 유권자 명부 저장소는 개인 이메일 주소를 포함하고 있어 Python 코어 개발자, 관리자 및 Python Software Foundation 직원만 접근할 수 있는 비공개 저장소입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:31:17 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8103/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8103/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 8102 - 2021 Term Steering Council election</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8102/&quot;&gt;PEP 8102 - 2021 Term Steering Council election&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 29-Oct-2020&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;pep-8102--2021년-임기-스티어링-카운슬-선거-2021-term-steering-council-election&quot;&gt;PEP 8102 – 2021년 임기 스티어링 카운슬 선거 (2021 Term Steering Council election)&lt;/h1&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;
&lt;p&gt;이 문서는 PEP 13에 명시된 바와 같이, 2020년 12월에 실시된 Python 스티어링 카운슬 (Steering Council) 선거의 일정 및 세부 사항을 설명합니다. 이 선거는 2021년 임기를 위한 스티어링 카운슬 선거였습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Ewa Jodlowska, Ee Durbin, Joe Carey
&lt;strong&gt;후원자:&lt;/strong&gt; Brett Cannon
&lt;strong&gt;상태:&lt;/strong&gt; 최종 (Final)
&lt;strong&gt;유형:&lt;/strong&gt; 정보 (Informational)
&lt;strong&gt;주제:&lt;/strong&gt; 거버넌스 (Governance)
&lt;strong&gt;생성일:&lt;/strong&gt; 2020년 10월 29일&lt;/p&gt;

&lt;h2 id=&quot;선거-관리-election-administration&quot;&gt;선거 관리 (Election Administration)&lt;/h2&gt;
&lt;p&gt;스티어링 카운슬은 Python Software Foundation (PSF)의 인프라 담당 이사(Director of Infrastructure) Ee Durbin과 회계 관리자(Accounting Manager) Joe Carey를 선거 공동 관리자로 임명했습니다.&lt;/p&gt;

&lt;p&gt;PSF 전무이사(Executive Director) Ewa Jodlowska는 선거와 관련된 공지사항을 전달했습니다.&lt;/p&gt;

&lt;h2 id=&quot;일정-schedule&quot;&gt;일정 (Schedule)&lt;/h2&gt;
&lt;p&gt;선거는 2주간의 후보 지명 기간과 2주간의 투표 기간으로 구성되었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;후보 지명 기간:&lt;/strong&gt; 2020년 11월 1일부터 2020년 11월 16일 12:00 UTC (Anywhere on Earth 기준 2020년 11월 15일 말)까지였습니다. 이 내용은 python-committers에 공지되었고 discuss.python.org에서 진행되었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 기간:&lt;/strong&gt; 2020년 12월 1일 12:00 UTC부터 2020년 12월 16일 12:00 UTC (Anywhere on Earth 기준 2020년 12월 15일 말)까지였습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;후보자-candidates&quot;&gt;후보자 (Candidates)&lt;/h2&gt;
&lt;p&gt;후보자는 핵심 팀 구성원(core team member)에 의해 지명되어야 합니다. 후보자 본인이 핵심 팀 구성원인 경우, 스스로 지명할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;지명된 후보자 (알파벳순):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Carol Willing&lt;/li&gt;
  &lt;li&gt;Christian Heimes&lt;/li&gt;
  &lt;li&gt;David Mertz&lt;/li&gt;
  &lt;li&gt;Matt Harrison&lt;/li&gt;
  &lt;li&gt;Mariatta&lt;/li&gt;
  &lt;li&gt;Pablo Galindo Salgado&lt;/li&gt;
  &lt;li&gt;Raymond Hettinger&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;철회된 지명:&lt;/strong&gt; 없음&lt;/p&gt;

&lt;h2 id=&quot;유권자-명부-voter-roll&quot;&gt;유권자 명부 (Voter Roll)&lt;/h2&gt;
&lt;p&gt;모든 활동적인 Python 핵심 팀 구성원 (active Python core team members)은 투표 자격이 있었습니다. 활동 상태는 PEP 13에 설명된 바와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python/voters&lt;/code&gt; 소프트웨어를 통해 결정되었습니다.&lt;/p&gt;

&lt;p&gt;투표 용지는 이 선거를 위한 Python 유권자 명부를 기반으로 배포되었습니다. 이 파일에는 개인 이메일 주소가 포함되어 있어 공개되지 않았지만, 유권자 명부가 생성될 때 이름으로 된 전체 유권자 명부는 제공될 예정이었습니다.&lt;/p&gt;

&lt;h2 id=&quot;선거-구현-election-implementation&quot;&gt;선거 구현 (Election Implementation)&lt;/h2&gt;
&lt;p&gt;선거는 Helios Voting Service를 사용하여 진행되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설정 (Configuration):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;짧은 이름 (Short name):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2021-python-steering-council&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;이름 (Name):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2021 Python Steering Council Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설명 (Description):&lt;/strong&gt; PEP 13에 명시된 Python 스티어링 카운슬 선거입니다. 이는 2021년 임기를 위한 스티어링 카운슬 선거입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형 (type):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유권자 별칭 사용 (Use voter aliases):&lt;/strong&gt; [X] (활성화됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;답변 순서 무작위화 (Randomize answer order):&lt;/strong&gt; [X] (활성화됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비공개 (Private):&lt;/strong&gt; [X] (활성화됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;도움말 이메일 주소 (Help Email Address):&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;psf-election@python.org&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 시작 시간 (Voting starts at):&lt;/strong&gt; 2020년 12월 1일 00:00 UTC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 종료 시간 (Voting ends at):&lt;/strong&gt; 2020년 12월 16일 12:00 UTC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 설정은 다음과 같은 선거를 만듭니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;투표는 일반에 공개되지 않으며, 유권자 명부에 있는 사람만 참여할&lt;/li&gt;
  &lt;li&gt;수 있습니다.&lt;/li&gt;
  &lt;li&gt;투표가 시작될 때 투표 용지가 이메일로 발송됩니다.&lt;/li&gt;
  &lt;li&gt;후보자는 편향을 피하기 위해 무작위 순서로 제시됩니다.&lt;/li&gt;
  &lt;li&gt;유권자의 신원과 투표 용지는 암호화 기술 발전으로부터 보호됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;질문 (Questions):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;질문 1:&lt;/strong&gt; 0개에서 (승인 투표) 답변 중 선택하세요.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;결과 유형 (Result Type):&lt;/strong&gt; 절대 (absolute)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;질문:&lt;/strong&gt; Python 스티어링 카운슬 후보자를 선택하세요.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;답변 #1 - #N:&lt;/strong&gt; “후보자 (Candidates)” 섹션의 후보자들&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-results&quot;&gt;결과 (Results)&lt;/h2&gt;
&lt;p&gt;자격 있는 유권자 91명 중 74명이 투표에 참여했습니다.&lt;/p&gt;

&lt;p&gt;상위 5명의 득표자는 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Carol Willing&lt;/li&gt;
  &lt;li&gt;Pablo Galindo Salgado&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PEP 13에 정의된 이해 상충(conflict of interest)은 관찰되지 않았습니다.&lt;/p&gt;

&lt;p&gt;전체 득표수는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;후보자 (Candidate)&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;득표수 (Votes Received)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Pablo Galindo Salgado&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;59&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Carol Willing&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;57&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Barry Warsaw&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;56&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Brett Cannon&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;54&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Thomas Wouters&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;52&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Christian Heimes&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;43&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Mariatta&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;42&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Raymond Hettinger&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;31&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;David Mertz&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;28&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Matt Harrison&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;15&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h2&gt;
&lt;p&gt;이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;전체-유권자-명부-complete-voter-roll&quot;&gt;전체 유권자 명부 (Complete Voter Roll)&lt;/h2&gt;
&lt;p&gt;활동적인 Python 핵심 개발자(active Python core developers) 목록은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;(이름 목록이 PEP에 명시되어 있으나, 여기서는 생략하겠습니다. 원문에서 확인할 수 있습니다.)&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:31:05 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8102/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8102/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 8101 - 2020 Term Steering Council election</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8101/&quot;&gt;PEP 8101 - 2020 Term Steering Council election&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 16-Nov-2019&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;PEP 8101은 2019년 12월에 실시된 Python 스티어링 카운슬(Steering Council) 선거에 대한 정보를 담고 있는 문서입니다. 이 문서는 선거의 배경, 절차, 후보자, 투표 결과 등을 상세히 설명하여 Python 커뮤니티의 거버넌스(governance) 및 핵심 개발자들의 참여를 이해하는 데 중요한 정보를 제공합니다.&lt;/p&gt;

&lt;h2 id=&quot;pep-8101-2020년-임기-스티어링-카운슬-선거-2020-term-steering-council-election&quot;&gt;PEP 8101: 2020년 임기 스티어링 카운슬 선거 (2020 Term Steering Council election)&lt;/h2&gt;

&lt;h3 id=&quot;개요-abstract&quot;&gt;개요 (Abstract)&lt;/h3&gt;
&lt;p&gt;이 문서는 PEP 13에 명시된 대로 2019년 12월에 실시된 Python 스티어링 카운슬 선거의 일정 및 세부 사항을 기술합니다. 이 선거는 2020년 임기를 위한 스티어링 카운슬을 선출하기 위한 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;선거-관리-election-administration&quot;&gt;선거 관리 (Election Administration)&lt;/h3&gt;
&lt;p&gt;스티어링 카운슬은 선거 진행을 위해 Python Software Foundation (PSF)의 인프라 담당 이사(Director of Infrastructure)인 Ee Durbin을, 그리고 선거 관련 발표를 위한 커뮤니케이션 담당으로 PSF의 이사(Executive Director)인 Ewa Jodlowska를 임명했습니다.&lt;/p&gt;

&lt;h3 id=&quot;일정-schedule&quot;&gt;일정 (Schedule)&lt;/h3&gt;
&lt;p&gt;선거는 2주간의 후보 지명 기간과 이어진 2주간의 투표 기간으로 구성되었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;후보 지명 기간:&lt;/strong&gt; 2019년 11월 1일부터 2019년 11월 16일 12:00 UTC (11월 15일 AoE(Anywhere on Earth) 자정)까지 진행되었습니다. 이 내용은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-committers&lt;/code&gt; 메일링 리스트에 공지되었으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;discuss.python.org&lt;/code&gt;에서 진행되었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 기간:&lt;/strong&gt; 2019년 12월 1일 12:00 UTC부터 2019년 12월 16일 12:00 UTC (12월 15일 AoE 자정)까지 진행되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;후보자-candidates&quot;&gt;후보자 (Candidates)&lt;/h3&gt;
&lt;p&gt;후보자는 핵심 팀 구성원(core team member)에 의해 지명되어야 합니다. 후보자가 핵심 팀 구성원인 경우, 스스로를 지명할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;지명된 후보자 (알파벳순):&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Kushal Das&lt;/li&gt;
  &lt;li&gt;Christian Heimes&lt;/li&gt;
  &lt;li&gt;Pablo Galindo Salgado&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith&lt;/li&gt;
  &lt;li&gt;Victor Stinner&lt;/li&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Carol Willing&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;철회된 지명:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Guido van Rossum (철회)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;유권자-명부-voter-roll&quot;&gt;유권자 명부 (Voter Roll)&lt;/h3&gt;
&lt;p&gt;모든 활동적인 Python 핵심 팀 구성원이 투표 자격을 가졌습니다.
투표 용지는 이 선거를 위한 Python 유권자 명부를 기반으로 배포되었습니다. 이 파일은 개인 이메일 주소를 포함하고 있어 공개되지 않았지만, 이름으로 구성된 전체 유권자 명부는 제공됩니다.&lt;/p&gt;

&lt;h3 id=&quot;선거-구현-election-implementation&quot;&gt;선거 구현 (Election Implementation)&lt;/h3&gt;
&lt;p&gt;선거는 Helios Voting Service를 사용하여 진행되었습니다.&lt;/p&gt;

&lt;h4 id=&quot;구성-configuration&quot;&gt;구성 (Configuration)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Short name:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2020-python-steering-council&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Name:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2020 Python Steering Council Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; PEP 13에 명시된 Python 스티어링 카운슬 선거입니다. 2020년 임기를 위한 스티어링 카운슬 선거입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Election&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Use voter aliases:&lt;/strong&gt; [X] (유권자 가명 사용)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Randomize answer order:&lt;/strong&gt; [X] (응답 순서 무작위화)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Private:&lt;/strong&gt; [X] (비공개)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Help Email Address:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ee@python.org&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Voting starts at:&lt;/strong&gt; 2019년 12월 1일 12:00 UTC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Voting ends at:&lt;/strong&gt; 2019년 12월 16일 12:00 UTC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이를 통해 다음과 같은 특징을 가진 선거가 생성되었습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;투표는 대중에게 공개되지 않으며, 오직 유권자 명부에 있는 사람만 참여할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;투표가 시작될 때 투표 용지가 이메일로 발송됩니다.&lt;/li&gt;
  &lt;li&gt;후보자는 편향을 피하기 위해 무작위 순서로 제시됩니다.&lt;/li&gt;
  &lt;li&gt;유권자의 신원과 투표 내용은 암호화 기술로부터 보호됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;질문-questions&quot;&gt;질문 (Questions)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;질문 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Select between 0 and - (approval) answers.&lt;/strong&gt; (0개에서 승인된 답변 사이에서 선택)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Result Type:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;absolute&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Question:&lt;/strong&gt; Python 스티어링 카운슬 후보를 선택하세요.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Answer #1 - #N:&lt;/strong&gt; Candidates 섹션의 후보자들.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;결과-results&quot;&gt;결과 (Results)&lt;/h3&gt;
&lt;p&gt;82명의 유권자 중 63명이 투표에 참여했습니다.&lt;/p&gt;

&lt;p&gt;가장 많은 표를 얻은 상위 5명은 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Carol Willing&lt;/li&gt;
  &lt;li&gt;Thomas Wouters&lt;/li&gt;
  &lt;li&gt;Victor Stinner&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PEP 13에 정의된 이해 상충(conflict of interest)은 관찰되지 않았습니다.&lt;/p&gt;

&lt;p&gt;전체 득표수는 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Brett Cannon: 54표&lt;/li&gt;
  &lt;li&gt;Carol Willing: 54표&lt;/li&gt;
  &lt;li&gt;Barry Warsaw: 50표&lt;/li&gt;
  &lt;li&gt;Thomas Wouters: 40표&lt;/li&gt;
  &lt;li&gt;Victor Stinner: 38표&lt;/li&gt;
  &lt;li&gt;Christian Heimes: 37표&lt;/li&gt;
  &lt;li&gt;Pablo Galindo Salgado: 37표&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith: 32표&lt;/li&gt;
  &lt;li&gt;Kushal Das: 30표&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h3&gt;
&lt;p&gt;이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;전체-유권자-명부-complete-voter-roll&quot;&gt;전체 유권자 명부 (Complete Voter Roll)&lt;/h3&gt;
&lt;p&gt;문서에는 Abhilash Raj부터 Zachary Ware까지 활동적인 Python 핵심 개발자들의 전체 목록이 포함되어 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;이 저장소는 개인 이메일 주소를 포함하고 있기 때문에 Python 핵심 개발자, 관리자 및 Python Software Foundation 직원만 접근할 수 있는 비공개 저장소입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:30:45 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8101/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8101/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 8100 - January 2019 Steering Council election</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8100/&quot;&gt;PEP 8100 - January 2019 Steering Council election&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 03-Jan-2019&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;

&lt;p&gt;이 문서는 PEP 13에 명시된 2019년 1월 Python 운영 위원회 선거의 일정 및 기타 세부 사항을 설명합니다. 이는 첫 번째 운영 위원회 선거입니다.&lt;/p&gt;

&lt;h2 id=&quot;선거-관리관-returns-officer&quot;&gt;선거 관리관 (Returns officer)&lt;/h2&gt;

&lt;p&gt;향후 선거에서는 퇴임하는 운영 위원회에서 선거 관리관을 임명하게 됩니다. 그러나 이번이 첫 선거이므로 퇴임하는 운영 위원회가 없으며, PEP 13에 따라 PSF(Python Software Foundation) 전무 이사인 Ewa Jodlowska가 선거 관리관을 임명했습니다. 그녀는 Ee Durbin을 임명했습니다.&lt;/p&gt;

&lt;h2 id=&quot;일정-schedule&quot;&gt;일정 (Schedule)&lt;/h2&gt;

&lt;p&gt;2주간의 후보 지명 기간과 2주간의 투표 기간이 있었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;후보 지명 기간:&lt;/strong&gt; 2019년 1월 7일 ~ 2019년 1월 20일&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 기간:&lt;/strong&gt; 2019년 1월 21일 12:00 UTC ~ 2019년 2월 4일 12:00 UTC (Anywhere on Earth 기준 2019년 2월 3일 종료)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;후보자-candidates&quot;&gt;후보자 (Candidates)&lt;/h2&gt;

&lt;p&gt;후보자는 핵심 팀(core team) 구성원의 지명을 받아야 합니다. 후보자가 핵심 팀 구성원인 경우, 스스로를 지명할 수 있습니다.&lt;/p&gt;

&lt;p&gt;후보 지명 기간이 시작된 후, 다음과 같은 후보자들이 등록되었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Alyssa (Nick) Coghlan&lt;/li&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Guido van Rossum&lt;/li&gt;
  &lt;li&gt;Victor Stinner&lt;/li&gt;
  &lt;li&gt;Yury Selivanov&lt;/li&gt;
  &lt;li&gt;David Mertz&lt;/li&gt;
  &lt;li&gt;Łukasz Langa&lt;/li&gt;
  &lt;li&gt;Benjamin Peterson&lt;/li&gt;
  &lt;li&gt;Mariatta&lt;/li&gt;
  &lt;li&gt;Carol Willing&lt;/li&gt;
  &lt;li&gt;Emily Morehouse&lt;/li&gt;
  &lt;li&gt;Peter Wang&lt;/li&gt;
  &lt;li&gt;Donald Stufft&lt;/li&gt;
  &lt;li&gt;Travis Oliphant&lt;/li&gt;
  &lt;li&gt;Kushal Das&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;유권자-명부-voter-roll&quot;&gt;유권자 명부 (Voter Roll)&lt;/h2&gt;

&lt;p&gt;모든 활동 중인 Python 핵심 팀 구성원은 투표 자격이 있습니다.&lt;/p&gt;

&lt;p&gt;투표 용지는 이 선거의 Python 유권자 명부를 기반으로 배포되었습니다.
이 파일은 개인 이메일 주소를 포함하고 있어 공개되지 않지만, 이름으로 구성된 전체 유권자 명부는 확인할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;선거-구현-election-implementation&quot;&gt;선거 구현 (Election Implementation)&lt;/h2&gt;

&lt;p&gt;선거는 Helios 투표 서비스(Helios Voting Service)를 사용하여 진행되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설정 (Configuration):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;간략한 이름:&lt;/strong&gt; 2019-python-steering-committee&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;이름:&lt;/strong&gt; 2019 Python Steering Committee Election&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설명:&lt;/strong&gt; PEP 13에 명시된 Python 운영 위원회 선거. 이는 첫 번째 운영 위원회 선거입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형:&lt;/strong&gt; Election&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유권자 가명 사용 (Use voter aliases):&lt;/strong&gt; [X]&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;답변 순서 무작위화 (Randomize answer order):&lt;/strong&gt; [X]&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비공개 (Private):&lt;/strong&gt; [X]&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;도움말 이메일 주소:&lt;/strong&gt; ee@python.org&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 시작:&lt;/strong&gt; 2019년 1월 21일 12:00 UTC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 종료:&lt;/strong&gt; 2019년 2월 4일 12:00 UTC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이는 다음과 같은 선거를 생성했습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;투표는 대중에게 공개되지 않으며, 유권자 명부에 있는 사람만 참여할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;투표가 시작되면 투표 용지가 이메일로 발송됩니다.&lt;/li&gt;
  &lt;li&gt;후보자들은 편향을 피하기 위해 무작위 순서로 제시됩니다.&lt;/li&gt;
  &lt;li&gt;유권자의 신원과 투표 용지는 암호학적 발전으로부터 보호됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;질문 (Questions):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;질문 1:&lt;/strong&gt; 0개에서 5개까지의 답변을 선택하세요.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;결과 유형:&lt;/strong&gt; absolute&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;질문:&lt;/strong&gt; Python 운영 위원회 후보자를 선택하세요.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;답변 #1 - #N:&lt;/strong&gt; 후보자 섹션의 후보자 목록&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-results&quot;&gt;결과 (Results)&lt;/h2&gt;

&lt;p&gt;96명의 투표 자격 있는 유권자 중 69명이 투표했습니다.&lt;/p&gt;

&lt;p&gt;상위 5명의 득표자는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Carol Willing&lt;/li&gt;
  &lt;li&gt;Guido van Rossum&lt;/li&gt;
  &lt;li&gt;Alyssa (Nick) Coghlan&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PEP 13에 정의된 이해 상충(conflict of interest)은 관찰되지 않았습니다.&lt;/p&gt;

&lt;p&gt;전체 득표수는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;후보자&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;득표수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Guido van Rossum&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;45&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Brett Cannon&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;44&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Carol Willing&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;33&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Barry Warsaw&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;31&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Alyssa (Nick) Coghlan&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Benjamin Peterson&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;22&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Łukasz Langa&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;21&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Victor Stinner&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;21&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Mariatta&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;20&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Emily Morehouse&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;18&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Yury Selivanov&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;15&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Donald Stufft&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Peter Wang&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Travis Oliphant&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Kushal Das&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Gregory P. Smith&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;David Mertz&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h2&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인(public domain)에 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 문서는 Python 운영 위원회(Steering Council)의 첫 선거에 대한 정보를 제공합니다. Python 개발자들이 이 내용을 통해 Python 프로젝트의 거버넌스 구조와 운영 위원회 구성 과정을 이해하는 데 도움이 될 것입니다. 이는 직접적으로 Python 코드 사용 방식에 영향을 미치는 기술 제안은 아니지만, Python 생태계의 방향성을 결정하는 중요한 거버넌스 문맥을 설명합니다.# PEP 8100 – 2019년 1월 운영 위원회(Steering Council) 선거&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;저자:&lt;/strong&gt; Nathaniel J. Smith, Ee Durbin&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final (최종)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational (정보성)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주제:&lt;/strong&gt; Governance (거버넌스)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;생성일:&lt;/strong&gt; 2019년 1월 3일&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개요-1&quot;&gt;개요&lt;/h2&gt;

&lt;p&gt;이 문서는 PEP 13에 명시된 2019년 1월 Python 운영 위원회 선거의 일정 및 기타 세부 사항을 설명합니다. 이는 첫 번째 운영 위원회 선거입니다.&lt;/p&gt;

&lt;h2 id=&quot;선거-관리관-returns-officer-1&quot;&gt;선거 관리관 (Returns officer)&lt;/h2&gt;

&lt;p&gt;향후 선거에서는 퇴임하는 운영 위원회에서 선거 관리관을 임명하게 됩니다. 그러나 이번이 첫 선거이므로 퇴임하는 운영 위원회가 없으며, PEP 13에 따라 PSF(Python Software Foundation) 전무 이사인 Ewa Jodlowska가 선거 관리관을 임명했습니다. 그녀는 Ee Durbin을 임명했습니다.&lt;/p&gt;

&lt;h2 id=&quot;일정-schedule-1&quot;&gt;일정 (Schedule)&lt;/h2&gt;

&lt;p&gt;2주간의 후보 지명 기간과 2주간의 투표 기간이 있었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;후보 지명 기간:&lt;/strong&gt; 2019년 1월 7일 ~ 2019년 1월 20일&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 기간:&lt;/strong&gt; 2019년 1월 21일 12:00 UTC ~ 2019년 2월 4일 12:00 UTC (Anywhere on Earth 기준 2019년 2월 3일 종료)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;후보자-candidates-1&quot;&gt;후보자 (Candidates)&lt;/h2&gt;

&lt;p&gt;후보자는 핵심 팀(core team) 구성원의 지명을 받아야 합니다. 후보자가 핵심 팀 구성원인 경우, 스스로를 지명할 수 있습니다.&lt;/p&gt;

&lt;p&gt;후보 지명 기간이 시작된 후, 다음과 같은 후보자들이 등록되었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Alyssa (Nick) Coghlan&lt;/li&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Guido van Rossum&lt;/li&gt;
  &lt;li&gt;Victor Stinner&lt;/li&gt;
  &lt;li&gt;Yury Selivanov&lt;/li&gt;
  &lt;li&gt;David Mertz&lt;/li&gt;
  &lt;li&gt;Łukasz Langa&lt;/li&gt;
  &lt;li&gt;Benjamin Peterson&lt;/li&gt;
  &lt;li&gt;Mariatta&lt;/li&gt;
  &lt;li&gt;Carol Willing&lt;/li&gt;
  &lt;li&gt;Emily Morehouse&lt;/li&gt;
  &lt;li&gt;Peter Wang&lt;/li&gt;
  &lt;li&gt;Donald Stufft&lt;/li&gt;
  &lt;li&gt;Travis Oliphant&lt;/li&gt;
  &lt;li&gt;Kushal Das&lt;/li&gt;
  &lt;li&gt;Gregory P. Smith&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;유권자-명부-voter-roll-1&quot;&gt;유권자 명부 (Voter Roll)&lt;/h2&gt;

&lt;p&gt;모든 활동 중인 Python 핵심 팀 구성원은 투표 자격이 있습니다.&lt;/p&gt;

&lt;p&gt;투표 용지는 이 선거의 Python 유권자 명부를 기반으로 배포되었습니다.
이 파일은 개인 이메일 주소를 포함하고 있어 공개되지 않지만, 이름으로 구성된 전체 유권자 명부는 확인할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;선거-구현-election-implementation-1&quot;&gt;선거 구현 (Election Implementation)&lt;/h2&gt;

&lt;p&gt;선거는 Helios 투표 서비스(Helios Voting Service)를 사용하여 진행되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설정 (Configuration):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;간략한 이름:&lt;/strong&gt; 2019-python-steering-committee&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;이름:&lt;/strong&gt; 2019 Python Steering Committee Election&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설명:&lt;/strong&gt; PEP 13에 명시된 Python 운영 위원회 선거. 이는 첫 번째 운영 위원회 선거입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형:&lt;/strong&gt; Election&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유권자 가명 사용 (Use voter aliases):&lt;/strong&gt; [X]&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;답변 순서 무작위화 (Randomize answer order):&lt;/strong&gt; [X]&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비공개 (Private):&lt;/strong&gt; [X]&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;도움말 이메일 주소:&lt;/strong&gt; ee@python.org&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 시작:&lt;/strong&gt; 2019년 1월 21일 12:00 UTC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표 종료:&lt;/strong&gt; 2019년 2월 4일 12:00 UTC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이는 다음과 같은 선거를 생성했습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;투표는 대중에게 공개되지 않으며, 유권자 명부에 있는 사람만 참여할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;투표가 시작되면 투표 용지가 이메일로 발송됩니다.&lt;/li&gt;
  &lt;li&gt;후보자들은 편향을 피하기 위해 무작위 순서로 제시됩니다.&lt;/li&gt;
  &lt;li&gt;유권자의 신원과 투표 용지는 암호학적 발전으로부터 보호됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;질문 (Questions):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;질문 1:&lt;/strong&gt; 0개에서 5개까지의 답변을 선택하세요.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;결과 유형:&lt;/strong&gt; absolute&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;질문:&lt;/strong&gt; Python 운영 위원회 후보자를 선택하세요.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;답변 #1 - #N:&lt;/strong&gt; 후보자 섹션의 후보자 목록&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결과-results-1&quot;&gt;결과 (Results)&lt;/h2&gt;

&lt;p&gt;96명의 투표 자격 있는 유권자 중 69명이 투표했습니다.&lt;/p&gt;

&lt;p&gt;상위 5명의 득표자는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Barry Warsaw&lt;/li&gt;
  &lt;li&gt;Brett Cannon&lt;/li&gt;
  &lt;li&gt;Carol Willing&lt;/li&gt;
  &lt;li&gt;Guido van Rossum&lt;/li&gt;
  &lt;li&gt;Alyssa (Nick) Coghlan&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PEP 13에 정의된 이해 상충(conflict of interest)은 관찰되지 않았습니다.&lt;/p&gt;

&lt;p&gt;전체 득표수는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;후보자&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;득표수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Guido van Rossum&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;45&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Brett Cannon&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;44&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Carol Willing&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;33&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Barry Warsaw&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;31&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Alyssa (Nick) Coghlan&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Benjamin Peterson&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;22&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Łukasz Langa&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;21&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Victor Stinner&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;21&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Mariatta&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;20&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Emily Morehouse&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;18&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Yury Selivanov&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;15&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Donald Stufft&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Peter Wang&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Travis Oliphant&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Kushal Das&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Gregory P. Smith&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;David Mertz&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;저작권-copyright-1&quot;&gt;저작권 (Copyright)&lt;/h2&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인(public domain)에 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 문서는 Python 운영 위원회(Steering Council)의 첫 선거에 대한 정보를 제공합니다. Python 개발자들이 이 내용을 통해 Python 프로젝트의 거버넌스 구조와 운영 위원회 구성 과정을 이해하는 데 도움이 될 것입니다. 이는 직접적으로 Python 코드 사용 방식에 영향을 미치는 기술 제안은 아니지만, Python 생태계의 방향성을 결정하는 중요한 거버넌스 문맥을 설명합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:30:34 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8100/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8100/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Accepted] PEP 8016 - The Steering Council Model</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8016/&quot;&gt;PEP 8016 - The Steering Council Model&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Accepted&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 01-Nov-2018&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-8016--스티어링-위원회-모델&quot;&gt;PEP 8016 – 스티어링 위원회 모델&lt;/h2&gt;

&lt;h3 id=&quot;요약&quot;&gt;요약&lt;/h3&gt;

&lt;p&gt;PEP 8016은 Python 거버넌스 모델을 &lt;strong&gt;스티어링 위원회(Steering Council)&lt;/strong&gt; 중심으로 제안하는 문서입니다. 이 위원회는 광범위한 권한을 가지지만, 이 권한을 가능한 한 드물게 행사하려고 노력합니다. 대신, 다른 801x 시리즈 PEP에서 제안된 것과 같은 표준 프로세스를 수립하는 데 이 권한을 사용합니다. 이는 큰 변경사항을 독립적으로 검토할 수 있는 작은 변경사항들로 나누는 일반적인 철학을 따릅니다. 하나의 PEP에서 모든 것을 시도하기보다는, 향후 거버넌스 결정을 위한 최소한이지만 견고한 기반을 제공하는 데 중점을 둡니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고:&lt;/strong&gt; 이 PEP는 역사적인 목적으로 유지되지만, 현재 공식 거버넌스 문서는 &lt;a href=&quot;https://peps.python.org/pep-0013/&quot;&gt;PEP 13&lt;/a&gt;입니다.&lt;/p&gt;

&lt;h3 id=&quot;pep-수용&quot;&gt;PEP 수용&lt;/h3&gt;

&lt;p&gt;PEP 8016은 2018년 12월 17일 월요일에 PEP 8001에 설명된 핵심 개발자 투표를 통해 수용되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;제안-배경-rationale&quot;&gt;제안 배경 (Rationale)&lt;/h3&gt;

&lt;p&gt;이 제안의 주요 목표는 다음과 같습니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;따분함 유지 (Be boring):&lt;/strong&gt; 거버넌스 전문가는 아니며, Python이 새롭고 시도되지 않은 거버넌스 모델을 실험하는 좋은 장소라고 생각하지 않습니다. 따라서 이 제안은 가능한 한 성숙하고 잘 알려져 있으며 이전에 테스트된 프로세스를 고수합니다. 대부분의 대규모 성공적인 F/OSS 프로젝트에서 가장 흔한 접근 방식은 ‘거의 개입하지 않는’ 위원회이며, 세부 사항은 Django의 거버넌스에서 직접 파생되었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단순함 유지 (Be simple):&lt;/strong&gt; 위원회, (위원회를 선출하는) 핵심 팀, 그리고 문서 변경 프로세스 등, 작동에 필요한 최소한의 요소로 간소화하려고 노력했습니다. 목표는 ‘최소 실행 가능한 거버넌스 (Minimum Viable Governance)’입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;포괄성 유지 (Be comprehensive):&lt;/strong&gt; 정의해야 할 사항에 대해서는 모든 기반을 다루려고 노력했습니다. 다시는 이런 종류의 위기를 겪고 싶지 않기 때문입니다. 명확하고 모호하지 않은 규칙은 혼란과 불만을 최소화하는 데 도움이 됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유연하고 경량화 (Be flexible and light-weight):&lt;/strong&gt; 함께 작업하기 위한 최상의 프로세스를 찾는 데 시간과 실험이 필요하다는 것을 알고 있습니다. 이 문서를 가능한 한 최소한으로 유지함으로써, 나중에 조정할 수 있는 최대한의 유연성을 유지하고, 전체 프로젝트 투표와 같이 무겁고 불안감을 유발하는 프로세스의 필요성을 최소화합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;명세-specification&quot;&gt;명세 (Specification)&lt;/h3&gt;

&lt;h4 id=&quot;스티어링-위원회-the-steering-council&quot;&gt;스티어링 위원회 (The Steering Council)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;구성 (Composition):&lt;/strong&gt; 스티어링 위원회는 5명으로 구성된 위원회입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;임무 (Mandate):&lt;/strong&gt; 스티어링 위원회는 다음을 위해 노력합니다.
    &lt;ul&gt;
      &lt;li&gt;Python 언어 및 CPython 인터프리터의 품질과 안정성을 유지합니다.&lt;/li&gt;
      &lt;li&gt;기여를 가능한 한 접근하기 쉽고, 포괄적이며, 지속 가능하게 만듭니다.&lt;/li&gt;
      &lt;li&gt;핵심 팀과 PSF(Python Software Foundation) 간의 관계를 공식화하고 유지합니다.&lt;/li&gt;
      &lt;li&gt;PEP에 대한 적절한 의사결정 프로세스를 수립합니다.&lt;/li&gt;
      &lt;li&gt;공식적인 자격으로 행동하기 전에 기여자 및 핵심 팀 사이의 합의를 추구합니다.&lt;/li&gt;
      &lt;li&gt;다른 모든 방법이 실패한 결정에 대한 “최종 항소 법원” 역할을 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;권한 (Powers):&lt;/strong&gt; 위원회는 프로젝트에 대한 결정을 내릴 광범위한 권한을 가집니다. 예를 들어, 다음을 수행할 수 있습니다.
    &lt;ul&gt;
      &lt;li&gt;PEP를 수락하거나 거부합니다.&lt;/li&gt;
      &lt;li&gt;프로젝트의 행동 강령을 강제하거나 업데이트합니다.&lt;/li&gt;
      &lt;li&gt;PSF와 협력하여 프로젝트 자산을 관리합니다.&lt;/li&gt;
      &lt;li&gt;권한의 일부를 다른 소위원회 또는 프로세스에 위임합니다.
그러나 이 PEP를 수정하거나, 이 PEP에 명시된 메커니즘을 통해서만 핵심 팀의 구성원 자격에 영향을 미칠 수 있습니다. 위원회는 이러한 권한을 가능한 한 적게 사용하는 방법을 찾아야 합니다. 투표 대신 합의를 추구하는 것이 좋습니다. 개별 PEP에 대해 결정하기보다 PEP 의사결정을 위한 표준 프로세스를 정의하는 것이 좋습니다. 개별 사례에 대해 결정하기보다 행동 강령 위원회를 설립하는 것이 좋습니다.
권한을 사용하기 위해 위원회는 투표를 합니다. 모든 위원회 구성원은 투표하거나 명시적으로 기권해야 합니다. 특정 투표에 이해 상충이 있는 구성원은 기권해야 합니다. 통과하려면 기권하지 않은 위원회 구성원의 과반수 지지가 필요합니다. 가능한 한 위원회의 심의와 투표는 공개적으로 진행됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;위원 선출 (Electing the council):&lt;/strong&gt; 위원회 선거는 두 단계로 구성됩니다.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;1단계:&lt;/strong&gt; 후보자들이 봉사할 의사를 표명합니다. 후보자는 핵심 팀 구성원의 추천을 받아야 하며, 자천도 허용됩니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;2단계:&lt;/strong&gt; 각 핵심 팀 구성원은 0명에서 5명까지의 후보자에게 투표할 수 있습니다. 투표는 익명으로 진행되며, 후보자들은 받은 총 득표수에 따라 순위가 매겨집니다. 동점이 발생하면 후보자 간의 상호 합의로 해결하거나 무작위로 당선자를 선택합니다.
각 단계는 퇴임하는 위원회의 재량에 따라 1~2주 동안 진행됩니다. 초기 선거의 경우 두 단계 모두 2주 동안 진행됩니다. 선거 프로세스는 퇴임하는 스티어링 위원회가 지명한 선거관리관이 관리합니다. 초기 선거의 경우 선거관리관은 PSF 전무이사가 지명합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;임기 (Term):&lt;/strong&gt; 각 기능 릴리스(feature release) 이후 새로운 위원회가 선출됩니다. 각 위원회의 임기는 선거 결과가 확정된 때부터 다음 위원회의 임기가 시작될 때까지입니다. 임기 제한은 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;결원 (Vacancies):&lt;/strong&gt; 위원회 구성원은 언제든지 사임할 수 있습니다. 정규 임기 중 결원이 발생하면 위원회는 투표를 통해 남은 임기를 채울 대체자를 임명할 수 있습니다. 위원회 구성원이 한 달 이상 연락이 두절되면, 나머지 위원회가 투표하여 교체할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;이해 상충 (Conflicts of interest):&lt;/strong&gt; 위원회 구성원이 자신이나 고용주보다는 Python의 최선의 이익을 위해 행동할 것이라고 신뢰하지만, 특정 회사가 Python 개발을 지배하는 것처럼 보이는 것만으로도 해롭고 신뢰를 저해할 수 있습니다. 이해 상충의 외관을 피하기 위해, 위원회 구성원 중 단일 고용주에 속한 사람은 최대 2명으로 제한됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;핵심 팀 구성원 퇴출 (Ejecting core team members):&lt;/strong&gt; 예외적인 상황(예: 심각하고 지속적인 행동 강령 위반)에서는 본인의 의사에 반하여 핵심 팀에서 누군가를 제거해야 할 수도 있습니다. 이는 스티어링 위원회 투표로 이루어질 수 있지만, 다른 스티어링 위원회 투표와 달리 최소 3분의 2의 다수결이 필요합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불신임 투표 (Vote of no confidence):&lt;/strong&gt; 예외적인 상황에서 핵심 팀은 불신임 투표를 통해 현직 위원회 구성원 또는 전체 위원회를 해임할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;핵심-팀-the-core-team&quot;&gt;핵심 팀 (The Core Team)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;역할 (Role):&lt;/strong&gt; 핵심 팀은 Python을 관리하는 신뢰받는 자원봉사자 그룹입니다. 프로젝트 목표 달성에 필요한 많은 역할, 특히 높은 수준의 신뢰를 요구하는 역할을 수행합니다. 그들은 프로젝트의 미래를 형성하는 결정을 내립니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;특권 (Prerogatives):&lt;/strong&gt; 핵심 팀 구성원은 공식 투표에 참여할 수 있으며, 일반적으로 새로운 팀 구성원을 지명하고 스티어링 위원회를 선출하는 데 참여합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;멤버십 (Membership):&lt;/strong&gt; Python 핵심 팀 구성원은 다음을 입증합니다.
    &lt;ul&gt;
      &lt;li&gt;Python 프로젝트 철학에 대한 깊은 이해.&lt;/li&gt;
      &lt;li&gt;건설적이고 도움이 되는 뛰어난 실적.&lt;/li&gt;
      &lt;li&gt;어떤 형태로든 프로젝트 목표에 대한 상당한 기여.&lt;/li&gt;
      &lt;li&gt;Python 개선에 시간을 할애하려는 의지.
핵심 팀 멤버십은 Python 프로젝트의 철학 및 목표와 잘 부합하는 지속적이고 가치 있는 노력을 인정하는 것입니다. 핵심 팀 투표에서 최소 3분의 2의 찬성표를 받고 스티어링 위원회의 거부권이 없으면 부여됩니다. 핵심 팀 구성원은 항상 유망한 기여자를 찾고, 프로젝트가 어떻게 관리되는지 가르치며, 준비가 되면 핵심 팀 투표에 이름을 제출합니다. 핵심 팀 멤버십에는 시간 제한이 없습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;문서-변경-changing-this-document&quot;&gt;문서 변경 (Changing this document)&lt;/h4&gt;

&lt;p&gt;이 문서의 변경은 핵심 팀 투표에서 최소 3분의 2의 찬성표를 필요로 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:30:11 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8016/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8016/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Rejected] PEP 8015 - Organization of the Python community</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8015/&quot;&gt;PEP 8015 - Organization of the Python community&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Rejected&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 04-Oct-2018&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-8015--python-커뮤니티의-조직-organization-of-the-python-community&quot;&gt;PEP 8015 – Python 커뮤니티의 조직 (Organization of the Python community)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Victor Stinner
&lt;strong&gt;상태:&lt;/strong&gt; 거부됨 (Rejected)
&lt;strong&gt;유형:&lt;/strong&gt; 정보 (Informational)
&lt;strong&gt;주제:&lt;/strong&gt; 거버넌스 (Governance)
&lt;strong&gt;생성일:&lt;/strong&gt; 2018년 10월 4일&lt;/p&gt;

&lt;h3 id=&quot;초록-abstract&quot;&gt;초록 (Abstract)&lt;/h3&gt;
&lt;p&gt;이 PEP는 Python 커뮤니티의 현재 조직을 공식화하고 세 가지 주요 변경 사항을 제안합니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;기존의 “Python 팀” 개념을 공식화합니다.&lt;/li&gt;
  &lt;li&gt;Python 팀에 더 많은 자율성을 부여합니다.&lt;/li&gt;
  &lt;li&gt;BDFL(Guido van Rossum)을 5명의 새로운 “Python Steering Committee”로 교체합니다. 이 위원회는 제한된 역할을 가지는데, 주로 의사결정 방식을 결정하지만 직접 의사결정은 하지 않습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PEP는 PEP 위임자(delegate) 또는 핵심 개발자(core developers)의 투표(2/3 이상의 다수결)를 통해 승인됩니다.&lt;/p&gt;

&lt;h3 id=&quot;pep-거부-사유-pep-rejection-rationale&quot;&gt;PEP 거부 사유 (PEP Rejection Rationale)&lt;/h3&gt;
&lt;p&gt;PEP 8015는 2018년 12월 17일 월요일, PEP 8001에 설명된 핵심 개발자 투표를 통해 거부되었습니다. 대신 PEP 8016과 해당 문서에서 설명하는 거버넌스 모델이 채택되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;배경-rationale&quot;&gt;배경 (Rationale)&lt;/h3&gt;
&lt;p&gt;이 PEP는 Python 사용자부터 Python Steering Committee까지 전체 Python 개발 커뮤니티의 조직을 설명합니다. 모든 그룹과 역할을 하나의 문서에 설명함으로써 조직의 일관성을 높이는 데 도움이 됩니다.&lt;/p&gt;

&lt;p&gt;이 거버넌스 변경은 기존 BDFL 조직에서 새로운 Steering Committee 조직으로의 원활한 전환을 위해 변경 사항을 최소화했습니다.&lt;/p&gt;

&lt;p&gt;조직의 핵심 설계 원칙 중 하나는 의사결정 병목 현상을 피하는 것입니다. 토론과 의사결정은 각 주제의 전문가를 찾을 수 있는 Python 팀으로 분산됩니다. 이를 통해 PEP에 대한 토론이 더 원활해지고, 해당 주제에 대한 지식이 풍부한 소수의 사람들이 참여할 것으로 기대됩니다.&lt;/p&gt;

&lt;p&gt;이전에는 대부분의 의사결정이 BDFL(Benevolent Dictator For Life)인 Guido van Rossum에 의해 이루어졌습니다. Python의 인기가 높아지면서 한 개인에게 가해지는 압박이 증가했습니다. 제안된 조직은 압박을 줄이고 개인의 소진을 방지하기 위해 의사결정 및 책임을 분산합니다.&lt;/p&gt;

&lt;p&gt;대부분의 의사결정 권한을 커뮤니티 내에 유지하기 위해 Python Steering Committee의 역할은 매우 제한적입니다. 이는 소수의 개인을 통해 특정 그룹이나 회사가 Python 프로젝트를 “장악”할 위험을 줄이려는 의도입니다. 프로젝트는 자율적이고 모두에게 개방된 상태를 유지해야 합니다.&lt;/p&gt;

&lt;p&gt;가장 민감한 PEP는 민주주의 방식으로 결정됩니다. 즉, 핵심 개발자에게만 허용된 투표를 통해 결정됩니다. 투표 방식은 아래 “PEP 프로세스” 섹션을 참조하십시오.&lt;/p&gt;

&lt;h3 id=&quot;공통-지침-common-guidelines&quot;&gt;공통 지침 (Common Guidelines)&lt;/h3&gt;
&lt;p&gt;Python 커뮤니티는 모든 사람에게 열려 있습니다. 구성원들은 Python 커뮤니티 행동 강령(Python Community Code of Conduct)을 존중해야 하며, 이는 건설적인 토론을 유지하고 모든 사람이 환영받는다고 느끼도록 보장합니다. Python은 자율적인 프로젝트이며 앞으로도 그럴 것입니다. 의사결정 권한을 가진 사람들은 사용자 및 기여자들의 다양성을 반영해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;커뮤니티-조직-community-organization&quot;&gt;커뮤니티 조직 (Community Organization)&lt;/h3&gt;
&lt;p&gt;현재 Python 프로젝트에는 다양한 그룹의 사람들이 참여하고 있습니다. 더 많이 참여할수록 더 많은 의사결정 권한을 얻게 됩니다. 가장 깊은 그룹에 접근하는 사람들이 가장 신뢰받는 사람들이어야 한다는 것이 중요합니다.&lt;/p&gt;

&lt;p&gt;이 PEP는 다음 그룹을 공식화합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Python 사용자 (Python Users)&lt;/li&gt;
  &lt;li&gt;Python 기여자 (Python Contributors)&lt;/li&gt;
  &lt;li&gt;Python 팀 구성원 (Python Teams Members)&lt;/li&gt;
  &lt;li&gt;Python 핵심 개발자 (Python Core Developers)&lt;/li&gt;
  &lt;li&gt;Python Steering Committee 구성원 (Python Steering Committee Members)&lt;/li&gt;
  &lt;li&gt;PSF 행동 강령 워킹 그룹 (PSF Code of Conduct Workgroup)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;python-사용자-python-users&quot;&gt;Python 사용자 (Python Users)&lt;/h4&gt;
&lt;p&gt;이 그룹은 가장 큰 그룹으로, Python을 사용하는 모든 사람을 의미합니다.&lt;/p&gt;

&lt;h4 id=&quot;python-기여자-python-contributors&quot;&gt;Python 기여자 (Python Contributors)&lt;/h4&gt;
&lt;p&gt;Python 사용자가 Python 메일링 리스트에 이메일을 보내거나, Python 버그 트래커에 의견을 남기거나, Python 변경 사항을 제안하거나 검토하는 순간 Python 기여자가 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;python-팀-python-teams&quot;&gt;Python 팀 (Python Teams)&lt;/h4&gt;
&lt;p&gt;Python이 너무 커져서 더 이상 단일 팀으로 운영되기 어려워졌기 때문에, 사람들은 특정 주제에 대해 더 긴밀하게 작업하기 위해 자연스럽게 팀을 구성했습니다. 때로는 이를 “Special Interest Group (SIG)”이라고 부르기도 합니다.&lt;/p&gt;

&lt;p&gt;충분한 수의 개발자가 특정 주제에 관심을 가지면 새로운 팀을 만들 수 있습니다. 일반적으로 주된 행동은 Python Postmaster에게 새로운 “SIG” 메일링 리스트를 생성해달라고 요청하는 것이지만, 팀은 다른 통신 채널을 사용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;팀 구성원은 Python 기여자 및 Python 핵심 개발자입니다. 팀은 자체적으로 조직되며, 누가 팀에 합류할 수 있고 어떻게 합류할지 선택할 책임이 있습니다.&lt;/p&gt;

&lt;p&gt;팀 구성원은 팀 버그 트래커 구성 요소에 대한 버그 분류(bug triage) 권한을 얻을 수 있습니다. 팀에 더 많이 참여할수록 더 많은 의사결정 권한과 책임을 얻게 됩니다.&lt;/p&gt;

&lt;p&gt;팀은 자체 PEP에 대해 결정할 수 있는 권한을 얻을 수도 있지만, Python Steering Committee만이 이를 허용할 수 있습니다(그리고 이 권한을 철회할 수도 있습니다). 이러한 경우는 예외적이며, 현재 Packaging Team만이 그러한 권한을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;부록: Python 팀 예시(Annex: Examples of Python Teams)를 참조하십시오.&lt;/p&gt;

&lt;h4 id=&quot;python-핵심-개발자-python-core-developers&quot;&gt;Python 핵심 개발자 (Python Core Developers)&lt;/h4&gt;
&lt;p&gt;핵심 개발자의 제한된 정의는 변경 사항을 병합(코드 어디든)하고 버그 분류 권한(모든 버그 트래커 구성 요소에 대해)을 가질 수 있는 능력입니다.&lt;/p&gt;

&lt;p&gt;핵심 개발자는 변경 사항을 승인하거나 거부해야 할지, 그리고 (더 중요하게는) 어떤 변경 사항을 만들어서는 안 되는지를 결정하는 데 필요한 기술을 보유하고 있음을 입증한 개발자입니다. Python은 오랜 역사, 하위 호환성에 대한 큰 제약, 높은 품질 기준(예: 변경 사항에 새로운 테스트 필요)을 가지고 있습니다. 이러한 이유로 핵심 개발자가 되는 데는 수개월 이상이 걸릴 수 있습니다.&lt;/p&gt;

&lt;p&gt;핵심 개발자가 된다는 것은 더 많은 책임을 의미합니다. 예를 들어, 개발자가 변경 사항을 병합하면 해당 수정된 코드의 회귀(regression) 및 유지보수에 대한 책임도 지게 됩니다.&lt;/p&gt;

&lt;p&gt;핵심 개발자는 행동 강령(Code of Conduct)에 있어 모범적이어야 합니다. 그들은 기여자들을 멘토링하도록 장려됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기여자를 핵심 개발자로 승격 (Promote a contributor as core developer)&lt;/strong&gt;
기존 핵심 개발자가 기여자가 핵심 그룹에 합류할 준비가 되었다고 판단하면, 해당 핵심 개발자는 기여자에게 핵심 개발자가 될 의향이 있는지 묻습니다. 기여자가 이러한 새로운 책임에 관심이 있다면 투표가 조직됩니다.&lt;/p&gt;

&lt;p&gt;투표는 핵심 개발자에게만 허용되며 공개적으로 1주일 동안 진행됩니다. 일반적으로 승격을 제안하는 핵심 개발자는 투표 설명에 후보자의 작업과 기술을 설명해야 합니다. 기여자는 2/3(&amp;gt;= 2/3) 이상의 찬성(“ +1”) 표를 얻어야만 승격됩니다. “ +1” 및 “ -1” 표만 집계됩니다. 다른 표(예: null, “ -0”, “ +0.5”)는 무시됩니다.&lt;/p&gt;

&lt;p&gt;후보자가 승격되면, 일반적으로 새로운 책임을 처리하는 데 도움을 주기 위해 1개월 동안 멘토를 배정받습니다.&lt;/p&gt;

&lt;p&gt;후보자가 승격되지 않은 경우, 예를 들어 6개월 후와 같이 후보자가 부족한 기술을 얻었을 때 새로운 투표를 다시 조직할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;python-steering-committee&quot;&gt;Python Steering Committee&lt;/h4&gt;
&lt;p&gt;Python Steering Committee는 가장 많은 의사결정 권한을 가지고 있기 때문에 가장 신뢰받는 핵심 개발자들로 구성됩니다. 이 그룹의 역할은 Python이 자율성을 유지하고 개방성을 유지하도록 엄격하게 제한됩니다.&lt;/p&gt;

&lt;p&gt;Python Steering Committee는 5명의 위원으로 구성됩니다. 위원들은 3년 임기로 선출되며 매년 1/3이 교체됩니다(첫해: 1명, 둘째 해: 2명, 셋째 해: 2명). 이러한 방식으로 위원은 Python의 전체 릴리스 기간 동안 활동하며 위원회 구성은 자주 업데이트됩니다. 위원회 위원은 자신이 떠나는 자리에 다시 출마할 수 있습니다. 임기 제한은 없습니다.&lt;/p&gt;

&lt;p&gt;위원회 위원은 Python 핵심 개발자여야 합니다. 위원회 구성원이 Python 사용자 및 기여자의 다양성을 반영하는 것이 중요합니다. 이를 보장하는 작은 단계는 2명(5명 중 50% 미만)만이 동일한 고용주(동일 회사 또는 동일 회사의 자회사)에서 근무할 수 있도록 강제하는 것입니다.&lt;/p&gt;

&lt;p&gt;5명의 위원 수는 위원들의 다양성을 위해, 그리고 위원 중 한 명이 알 수 없는 기간 동안 활동할 수 없게 되더라도 위원회가 계속해서 작동할 수 있도록 보장하기 위해 선택되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python Steering Committee의 역할 (Python Steering Committee Roles)&lt;/strong&gt;
Python Steering Committee의 역할은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PEP가 승인(또는 거부 또는 연기)되는 방식을 결정합니다.&lt;/li&gt;
  &lt;li&gt;Python 팀에 권한을 부여하거나 취소합니다. 예를 들어, 팀이 기여자에게 버그 분류 권한(팀 구성 요소에 대해)을 부여하도록 허용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PEP가 승인(또는 거부 또는 연기)되는 방식을 결정하기 위한 두 가지 옵션이 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;위원회는 PEP 위임자(이전에는 “BDFL-delegate”로 알려짐)를 선출합니다. 이 핵심 개발자는 특정 PEP에 대한 최종 결정을 내릴 것입니다. 위원회는 PEP가 논의되는 Python 팀에서 제안할 수 있는 PEP 위임자를 선택합니다.&lt;/li&gt;
  &lt;li&gt;위원회는 PEP에 대한 투표를 조직할 수 있습니다. 투표 조직에 대한 내용은 “PEP 프로세스”를 참조하십시오. 위원회는 투표가 언제 조직될지 결정합니다. 언어 변경과 같이 모든 Python 사용자에게 영향을 미치는 변경 사항에는 투표가 선호됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위원회는 Python의 “비전”과 일관성을 유지합니다. 또한 중요한 기능이 완료되도록 보장합니다. PEP 위임자를 선택할 수 있는 능력은 이러한 목표를 달성하는 데 도움이 되도록 고안되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python Steering Committee 위원 선출 (Election of Python Steering Committee Members)&lt;/strong&gt;
투표는 Steering Committee에 의해 조직됩니다. 3주 전에 공지되며, 후보자는 이 기간 동안 지원해야 합니다. 투표는 핵심 개발자에게만 허용되며 1주일 동안 진행됩니다. 자체 검열을 피하기 위해 투표는 비밀 투표를 사용합니다. 이는 더 많은 권한을 얻을 수 있는 사람(선출될 경우)의 적대감을 피하기 위함입니다.&lt;/p&gt;

&lt;p&gt;투표는 Condorcet Internet Voting Service (CIVS)와 같은 온라인 서비스를 사용하여 Condorcet 방식의 Schulze/Beatpath/CSSD 변형을 사용합니다. 이 투표 방식은 동점(tie) 발생 위험을 줄입니다. 또한 위원회 구성을 위해 필요한 모든 후보자의 순위를 생성합니다.&lt;/p&gt;

&lt;p&gt;동점이 발생하면, 동점에 관련된 후보자들 사이에서 동일한 투표 방식으로 즉시 새로운 투표가 1주일 동안 조직됩니다. 두 번째 투표에서도 다시 동점이 발생하면, 현재 Steering Committee가 선출된 위원을 선택할 책임이 있습니다.&lt;/p&gt;

&lt;p&gt;위원회 위원이 사임하면, 그를 대체하기 위한 새로운 투표가 조직됩니다.&lt;/p&gt;

&lt;p&gt;위원회 위원의 상황이 위원회 제약 조건(예: 다른 두 위원과 같은 회사로 이동)을 더 이상 충족하지 못하게 변경되면 사임해야 합니다. 위원의 고용주가 다른 두 위원의 고용주에게 인수되는 경우, 임기가 더 일찍 끝나는 위원이 인수가 완료되면 사임해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python Steering Committee 위원 생성 선출 (Election Creating the Python Steering Committee Members)&lt;/strong&gt;
프로세스를 부트스트랩하기 위해 위원회 생성 시 5명의 위원이 선출됩니다. 투표는 정기 위원회 투표와 동일한 규칙을 따르지만, 선출에는 5명의 위원이 필요하며 투표는 PSF 이사회(PSF Board)가 조직합니다.&lt;/p&gt;

&lt;p&gt;위원회 선거에서 상위 5위 득표자 중 3명이 같은 고용주에서 일하는 경우, 그 중 가장 낮은 순위의 후보자는 실격 처리되고 6위 후보자가 5위로 올라갑니다. 유효한 위원회가 구성될 때까지 이 과정이 반복됩니다.&lt;/p&gt;

&lt;p&gt;동점이 발생하면, 동점에 관련된 후보자들과 나머지 자리를 채우기 위한 다음 후보자들 사이에서 즉시 두 번째 투표가 조직됩니다. 투표는 정기 위원회 투표와 동일한 규칙을 따릅니다. 두 번째 투표에서도 여전히 동점이 발생하면 PSF 이사회가 위원을 선출하고 투표 결과에서의 순위를 결정할 책임이 있습니다.&lt;/p&gt;

&lt;p&gt;선출된 위원의 투표 결과 순위는 고유해야 합니다. 1위와 2위는 3년 임기, 2위와 3위는 2년 임기, 5위는 1년 임기로 선출됩니다.&lt;/p&gt;

&lt;p&gt;예시 (동점이 있는 투표 결과):
A B C D E, F G …&lt;/p&gt;

&lt;p&gt;처음 4명의 후보자(A, B, C, D)는 즉시 선출됩니다. E가 다른 두 명의 선출된 위원과 같은 고용주에서 일하는 경우 F도 선출됩니다. 그렇지 않으면 E와 F 사이에서 5번째 자리를 위한 두 번째 투표가 조직됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;특별 사례: Steering Committee 위원과 PEP (Special Case: Steering Committee Members And PEPs)&lt;/strong&gt;
위원회 위원은 PEP 위임자가 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;위원회 위원은 PEP를 제안할 수 있지만, 자신의 PEP의 위임자가 될 수는 없습니다.&lt;/p&gt;

&lt;p&gt;위원회가 PEP에 대한 투표가 필요하다고 결정할 때, 위원회 위원은 핵심 개발자이기도 하므로 투표할 수 있지만, 다른 핵심 개발자보다 더 많은 권한을 가지지는 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;psf-행동-강령-워킹-그룹-psf-code-of-conduct-workgroup&quot;&gt;PSF 행동 강령 워킹 그룹 (PSF Code of Conduct Workgroup)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;헌장 (Charter)&lt;/strong&gt;
이 워킹 그룹의 목적은 PSF의 행동 강령을 시행하고, “Python 관련 기술 및 교육 자료의 지속적인 개발”이라는 PSF의 사명을 지원하는 행동 강령에 대한 지침과 권고를 Python 커뮤니티에 제공함으로써 다양하고 포용적인 Python 커뮤니티를 육성하는 것입니다.&lt;/p&gt;

&lt;p&gt;우리는 다음 세 가지 방식으로 이 공통 목표를 향해 노력합니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;PSF 행동 강령 및 PSF가 지원하는 다른 커뮤니티와 관련된 정책을 검토, 수정 및 조언합니다. 여기에는 PSF 관할의 모든 #python 채팅 커뮤니티 및 python.org 이메일 목록이 포함됩니다.&lt;/li&gt;
  &lt;li&gt;컨퍼런스, 메일링 리스트, Slack/IRC, 코드 저장소 등 다양한 상호 작용 채널에 대한 표준 행동 강령 세트 및 지원 문서를 만듭니다.&lt;/li&gt;
  &lt;li&gt;Python 커뮤니티 주최자가 행동 강령을 구현하고 시행하는 데 도움이 되는 교육 자료 및 기타 프로세스를 개발합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 워킹 그룹의 조직은 ConductWG 헌장(ConductWG Charter)에 의해 정의됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;특별 사례: 핵심 개발자 금지 (Special Case: Ban a core developer)&lt;/strong&gt;
Python 커뮤니티의 다른 구성원과 마찬가지로 PSF 행동 강령 워킹 그룹은 핵심 개발자를 제한된 시간 동안 금지할 수 있습니다. 이 경우 핵심 개발자는 즉시 핵심 개발자 지위를 잃습니다. 핵심 개발자는 행동 강령에 있어 모범적이어야 합니다.&lt;/p&gt;

&lt;p&gt;일반적으로 금지는 다른 모든 옵션이 소진되었을 때 최후의 수단입니다.&lt;/p&gt;

&lt;p&gt;금지 기간이 끝나면 개발자는 일반 기여자로 다시 기여할 수 있습니다.&lt;/p&gt;

&lt;p&gt;개발자가 행동을 변경하면, 다른 핵심 개발자가 개발자를 핵심 개발자로 승격시키기 위한 새로운 투표를 조직할 수 있습니다. 투표는 다른 Python 기여자들과 동일한 절차를 따릅니다.&lt;/p&gt;

&lt;h3 id=&quot;pep-프로세스-pep-process&quot;&gt;PEP 프로세스 (PEP process)&lt;/h3&gt;
&lt;p&gt;PEP에는 두 가지 주요 역할이 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PEP 작성자 (PEP Authors)&lt;/li&gt;
  &lt;li&gt;PEP 위임자 (PEP Delegate)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PEP 작성자는 고품질 PEP를 작성하기 위해 최선을 다합니다.&lt;/p&gt;

&lt;p&gt;PEP 위임자는 작성자가 PEP를 개선하도록 돕고 최종 결정(PEP 수락, 거부 또는 연기)을 내리는 책임이 있습니다. 또한 토론을 안내하는 데 도움을 줄 수 있습니다.&lt;/p&gt;

&lt;p&gt;결정이 내려지지 않은 경우, 작성자는 나중에(예: 1년 후) PEP를 다시 제안할 수 있으며, 가능하다면 변경을 유도할 새로운 데이터를 포함할 수 있습니다. PEP 위임자는 PEP를 거부하지 않고 나중에 토론을 다시 시작하도록 장려하기 위해 PEP를 “연기됨(Deferred)”으로 표시할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;Python 팀에 특정한 PEP는 팀 메일링 리스트에서 논의됩니다. 언어 변경과 같이 모든 Python 개발자에게 영향을 미치는 PEP는 python-dev 메일링 리스트에서 논의되어야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;pep에-대한-투표-vote-on-a-pep&quot;&gt;PEP에 대한 투표 (Vote on a PEP)&lt;/h4&gt;
&lt;p&gt;Python Steering Committee가 PEP에 더 넓은 승인이 필요하다고 결정하면 투표가 조직됩니다.&lt;/p&gt;

&lt;p&gt;투표는 핵심 개발자에게만 허용되며 공개적으로 1주일 전에 공지되고 1주일 동안 진행됩니다. PEP는 1주일 공지 기간 동안 업데이트될 수 있지만, 투표 기간 동안에는 수정되어서는 안 됩니다. 이러한 투표는 PEP가 논의되었던 메일링 리스트에서 이루어집니다. 위원회는 투표가 언제 조직될지 결정합니다. PEP는 투표에 부치기 전에 합리적인 시간 동안 논의되어야 합니다.&lt;/p&gt;

&lt;p&gt;PEP는 2/3(&amp;gt;= 2/3) 이상의 찬성(“ +1”) 표를 얻어야만 승인됩니다. “ +1” 및 “ -1” 표만 집계됩니다. 다른 표(예: null, “ -0”, “ +0.5”)는 무시됩니다.&lt;/p&gt;

&lt;p&gt;PEP는 투표를 통해 승인되거나 거부될 수 있으며, 연기될 수는 없습니다.&lt;/p&gt;

&lt;h4 id=&quot;결정-부재-lack-of-decision&quot;&gt;결정 부재 (Lack of Decision)&lt;/h4&gt;
&lt;p&gt;논의가 합의에 도달하지 못하거나, Python Steering Committee가 PEP 위임자를 선택하지 못하거나, PEP 위임자가 결정을 내리지 못하면 Python이 발전하지 못할 위험이 있습니다.&lt;/p&gt;

&lt;p&gt;그것은 괜찮습니다. 때로는 아무것도 하지 않는 것이 가장 현명한 선택입니다.&lt;/p&gt;

&lt;h4 id=&quot;이-pep-변경-change-this-pep&quot;&gt;이 PEP 변경 (Change this PEP)&lt;/h4&gt;
&lt;p&gt;이 PEP의 첫 번째 버전은 Guido van Rossum이 2018년 7월 BDFL 역할에서 사임하기로 결정한 후에 작성되었습니다. 이 PEP 이전에 Python 커뮤니티 구성원의 역할은 공식화된 적이 없었습니다. 첫 시도에 완벽한 조직을 설계하는 것은 어렵습니다. 이 PEP는 미래에 조직을 조정하고, 예외적인 경우(corner cases)를 처리하는 방법을 명시하고, 실수를 수정하기 위해 업데이트될 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 PEP에 대한 모든 변경 사항은 투표를 통해 검증되어야 합니다. 투표는 3주 전에 공지되며 핵심 개발자에게만 허용되고 python-committers 메일링 리스트에서 공개적으로 진행되며 1주일 동안 진행됩니다. 제안된 PEP 변경 사항은 3주 공지 기간 동안 업데이트될 수 있지만, 투표 기간 동안에는 수정되어서는 안 됩니다.&lt;/p&gt;

&lt;p&gt;변경 사항은 4/5(&amp;gt;= 4/5) 이상의 찬성(“ +1”) 표를 얻어야만 승인됩니다. “ +1” 및 “ -1” 표만 집계됩니다. 다른 표(예: null, “ -0”, “ +0.5”)는 무시됩니다.&lt;/p&gt;

&lt;h3 id=&quot;부록-투표-요약-annex-summary-on-votes&quot;&gt;부록: 투표 요약 (Annex: Summary on votes)&lt;/h3&gt;
&lt;p&gt;| 투표 대상 | 공지 기간 | 공개 기간 | 투표 방식 |
| :—————- | :—– | :—— | :———————————— |
| 기여자 승격 | 없음 | 1주 | 공개, &amp;gt;= 2/3 다수결 |
| PEP | 1주 | 1주 | 공개, &amp;gt;= 2/3 다수결 |
| 이 PEP 변경 | 3주 | 1주 | 공개, &amp;gt;= 4/5 다수결 |
| Steering Committee | 3주 | 1주 | 비공개, Condorcet (Schulze/Beatpath/CSSD) |&lt;/p&gt;

&lt;p&gt;이 모든 투표는 핵심 개발자에게만 허용됩니다.&lt;/p&gt;

&lt;h3 id=&quot;부록-python-팀-예시-annex-examples-of-python-teams&quot;&gt;부록: Python 팀 예시 (Annex: Examples of Python Teams)&lt;/h3&gt;
&lt;p&gt;아래는 몇 가지 Python 팀의 예시입니다(이 목록은 이 PEP에서 최신 상태로 유지되지 않습니다).&lt;/p&gt;

&lt;h4 id=&quot;packaging-team&quot;&gt;Packaging Team&lt;/h4&gt;
&lt;p&gt;Packaging Team은 자체 PEP 카테고리를 운영하며 자체 PEP를 승인(또는 거부)할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;웹사이트:&lt;/strong&gt; packaging.python.org&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메일링 리스트:&lt;/strong&gt; distutils-sig&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버그 트래커 구성 요소:&lt;/strong&gt; Distutils&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;예시 구성원:&lt;/strong&gt; Paul Moore, Alyssa Coghlan, Donald Stuff&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;표준 라이브러리 모듈:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distutils&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;현재 PEP 위임자:&lt;/strong&gt; Paul Moore&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;idle-team&quot;&gt;IDLE Team&lt;/h4&gt;
&lt;p&gt;IDLE은 Python 표준 라이브러리에서 특별한 경우입니다. 단순한 모듈이 아니라 전체 응용 프로그램입니다. 이러한 이유로 코드는 모든 Python 안정 브랜치에서 동일하게 유지하기로 결정되었습니다(표준 라이브러리는 새로운 안정 브랜치에서 분기되지만).&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;버그 트래커 구성 요소:&lt;/strong&gt; IDLE&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;예시 구성원:&lt;/strong&gt; Terry Reedy, Cheryl Sabella, Serhiy Storchaka&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;표준 라이브러리 모듈:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idlelib&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mentorship-team&quot;&gt;Mentorship Team&lt;/h4&gt;
&lt;p&gt;핵심 개발자가 되는 것은 길고 느린 과정입니다. 멘토링은 미래의 핵심 개발자로서 기여자를 훈련하고 신뢰 관계를 구축하는 효율적인 방법입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;웹사이트:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;https://www.python.org/dev/core-mentorship/&lt;/li&gt;
      &lt;li&gt;https://devguide.python.org/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;저장소:&lt;/strong&gt; https://github.com/python/devguide&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메일링 리스트:&lt;/strong&gt; core-mentorship (비공개 아카이브)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;예시 구성원:&lt;/strong&gt; Guido van Rossum, Carol Willing, Victor Stinner&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;참고:&lt;/strong&gt; 이 그룹은 핵심 개발자 승격을 담당하지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;documentation-team&quot;&gt;Documentation Team&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;메일링 리스트:&lt;/strong&gt; doc-sig&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버그 트래커 구성 요소:&lt;/strong&gt; Documentation&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GitHub 태그:&lt;/strong&gt; type-doc&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;예시 구성원:&lt;/strong&gt; Julien Palard, INADA Naoki, Raymond Hettinger
이 팀은 문서 번역도 관리합니다.
“Devguide”를 유지보수하는 Mentorship 팀도 참조하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;security-team&quot;&gt;Security Team&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;웹사이트:&lt;/strong&gt; https://www.python.org/news/security/&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메일링 리스트:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;security@python.org (취약점 보고용)&lt;/li&gt;
      &lt;li&gt;security-sig (공개 목록)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;표준 라이브러리 모듈:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hashlib&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;secrets&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssl&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;예시 구성원:&lt;/strong&gt; Christian Heimes, Benjamin Peterson
security@python.org 메일링 리스트는 초대 전용이며, “Python Security Response Team (PSRT)” 구성원만 이메일을 읽고 회신할 수 있습니다. 반면 security-sig는 공개 목록입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;참고:&lt;/strong&gt; 이 팀은 PEP를 거의 제안하지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;performance-team&quot;&gt;Performance Team&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;웹사이트:&lt;/strong&gt; https://speed.python.org/&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메일링 리스트:&lt;/strong&gt; speed&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;저장소:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;https://github.com/python/performance&lt;/li&gt;
      &lt;li&gt;https://github.com/tobami/codespeed&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버그 트래커 유형:&lt;/strong&gt; Performance&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GitHub 레이블:&lt;/strong&gt; type-performance&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;표준 라이브러리 모듈:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cProfile&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pstats&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timeit&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;예시 구성원:&lt;/strong&gt; Victor Stinner, INADA Naoki, Serhiy Storchaka
성능에 영향을 미치는 PEP는 일반적으로 모든 사람에게 영향을 미치므로 speed 메일링 리스트보다는 python-dev 메일링 리스트에서 논의됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;asynchronous-programming-team&quot;&gt;Asynchronous Programming Team&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;웹사이트:&lt;/strong&gt; https://docs.python.org/dev/library/asyncio.html&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메일링 리스트:&lt;/strong&gt; async-sig&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버그 트래커 구성 요소:&lt;/strong&gt; asyncio&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GitHub 레이블:&lt;/strong&gt; expert-asyncio&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;표준 라이브러리 모듈:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contextvars&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;예시 구성원:&lt;/strong&gt; Andrew Sveltov, Yury Selivanov
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contextvars&lt;/code&gt;만 수정하는 PEP는 async-sig 메일링 리스트에서 논의될 수 있지만, Python 언어에 영향을 미치는 변경 사항은 python-dev에서 논의되어야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;type-hints-team&quot;&gt;Type Hints Team&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;웹사이트:&lt;/strong&gt; http://mypy-lang.org/&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;저장소:&lt;/strong&gt; https://github.com/python/typing&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;mypy 프로젝트를 위한 GitHub 레이블:&lt;/strong&gt; topic-pep-484&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;표준 라이브러리 모듈:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typing&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;예시 구성원:&lt;/strong&gt; Guido van Rossum, Ivan Levkivskyi, Jukka Lehtosalo, Łukasz Langa, Mark Shannon&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;참고:&lt;/strong&gt; Python 3.6 및 이전 버전을 위한 백포트(backport)가 PyPI의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typing&lt;/code&gt;에 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;버전-기록-version-history&quot;&gt;버전 기록 (Version History)&lt;/h3&gt;
&lt;p&gt;이 PEP의 역사:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;버전 7:&lt;/strong&gt; Steering Committee 조정
    &lt;ul&gt;
      &lt;li&gt;Steering Committee는 3명 대신 5명으로 구성됩니다.&lt;/li&gt;
      &lt;li&gt;임기 제한이 없습니다(이전에는 2번의 임기, 총 6년 제한).&lt;/li&gt;
      &lt;li&gt;위원회 위원은 이제 PEP 위임자가 될 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버전 6:&lt;/strong&gt; 투표 조정
    &lt;ul&gt;
      &lt;li&gt;Condorcet 방식 명시: Python Steering Committee 위원 선출에 Schulze/Beatpath/CSSD 변형 사용.&lt;/li&gt;
      &lt;li&gt;동점 처리 방법 및 고용주에 대한 제약 조건 명시.&lt;/li&gt;
      &lt;li&gt;기여자 승격 및 PEP에 대한 투표는 이제 50% + 1 대신 &amp;gt;= 2/3가 필요합니다.&lt;/li&gt;
      &lt;li&gt;이 PEP 변경에 대한 투표는 이제 50% + 1 대신 &amp;gt;= 4/5가 필요합니다.&lt;/li&gt;
      &lt;li&gt;회사 인수 처리 방법 설명.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버전 5:&lt;/strong&gt; Python Steering Committee 위원 선출에 비밀 투표 사용.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버전 4:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;투표 조정: 1개월 대신 1주일 동안 진행되며 미리 공지됩니다.&lt;/li&gt;
      &lt;li&gt;“Python Core Board”를 “Python Steering Committee”로 이름 변경.&lt;/li&gt;
      &lt;li&gt;이 위원회는 PEP를 승인하지 않으며 위원회 위원은 2개 이상의 임기를 중복할 수 없음을 명확히 함.&lt;/li&gt;
      &lt;li&gt;부록에 “Type Hints” 팀 추가.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버전 3:&lt;/strong&gt; “특별 사례: 핵심 개발자 금지” 및 “이 PEP를 업데이트하는 방법” 섹션 추가.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버전 2:&lt;/strong&gt; PSF Board와의 혼동을 피하기 위해 “Python board”를 “Python Core Board”로 이름 변경.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버전 1:&lt;/strong&gt; python-committers 및 discuss.python.org에 게시된 첫 번째 버전.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;저작권:&lt;/strong&gt; 이 문서는 퍼블릭 도메인에 공개되었습니다.
&lt;strong&gt;출처:&lt;/strong&gt; https://github.com/python/peps/blob/main/peps/pep-8015.rst
&lt;strong&gt;최종 수정:&lt;/strong&gt; 2025-02-01 08:55:40 GMT&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:29:53 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8015/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8015/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Rejected] PEP 8014 - The Commons Governance Model</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8014/&quot;&gt;PEP 8014 - The Commons Governance Model&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Rejected&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 16-Sep-2018&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-8014--커먼즈-거버넌스-모델&quot;&gt;PEP 8014 – 커먼즈 거버넌스 모델&lt;/h2&gt;

&lt;h3 id=&quot;요약-abstract&quot;&gt;요약 (Abstract)&lt;/h3&gt;

&lt;p&gt;이 PEP는 절차, 정의된 용어, 비율을 가능한 한 적게 사용하는 거버넌스 모델을 제안합니다. 이 모델은 ‘무정부주의 거버넌스 모델(The Anarchist Governance Model)’이라고도 불릴 수 있지만, 일부 사람들에게 ‘무정부주의’라는 용어가 부정적인 의미로 받아들여질 수 있어 현재는 ‘커먼즈(Commons)’라는 용어를 사용합니다.&lt;/p&gt;

&lt;p&gt;기본 아이디어는 모든 결정이 원칙적으로 전체 커뮤니티의 투표를 거치지만, 실제로는 커뮤니티의 일부만이 투표에 참여한다는 것입니다. 전체 커뮤니티가 투표할 권리가 있더라도, 실제로는 항상 특정 결정에 대해 소수의 일부만이 투표할 것이기 때문입니다. 투표는 편견 없는 위원회(impartial council)에 의해 감독되며, 이 위원회는 결정 통과 여부를 판단합니다. 이 위원회는 찬성 및 반대 투표의 비율뿐만 아니라 총 투표 수, 제안의 중요성, 그리고 개별 투표자와 그들의 투표 방식 등을 고려하여 결정을 내립니다. 이를 통해 위원회는 각 개별 결정이 충분한 다수에 의해 지지되는지 확인할 책임이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;pep-반려-pep-rejection&quot;&gt;PEP 반려 (PEP Rejection)&lt;/h3&gt;

&lt;p&gt;PEP 8014는 2018년 12월 17일 월요일에 PEP 8001에 설명된 핵심 개발자 투표를 통해 반려되었습니다. 대신 PEP 8016과 그 모델이 채택되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;서론-introduction&quot;&gt;서론 (Introduction)&lt;/h3&gt;

&lt;p&gt;커먼즈 거버넌스 모델은 모든 결정이 Python 커뮤니티의 충분한 다수에 의해 승인되거나 적어도 수용될 수 있도록 하는 것을 목표로 합니다.&lt;/p&gt;

&lt;p&gt;하지만 “충분한 다수(sufficient majority)”와 “Python 커뮤니티(Python community)”라는 두 용어는 일반적인 경우에 정량화하기 매우 어렵습니다. 이는 두 용어 모두 실제로 결정되는 특정 상황에 따라 달라지기 때문입니다. 예를 들어, 기존 API에 대한 하위 호환 가능한 변경을 제안하는 PEP의 경우, 처음부터 PEP 투표에 관심이 있었던 핵심 개발자(core developers)들의 단순 다수로도 충분할 수 있습니다. 그러나 Python 3에서 Python 4로의 전환과 같이 더 광범위한 결과를 초래하는 변경의 경우, 진정한 다수가 필요할 수 있으며, 사용자층 내에서 충분한 지지가 있음을 보여주어야 합니다. 또한, 포괄적이지 않은 언어를 폐지하는 결정과 같이 Python 언어 자체를 넘어선 변경의 경우, 이 정의는 더욱 모호해집니다.&lt;/p&gt;

&lt;p&gt;커먼즈 거버넌스 모델은 “충분한 다수”와 “Python 커뮤니티”가 일반적인 경우에 무엇을 의미하는지 정의하지 않고, 특정 경우에 이를 결정할 기관을 제안함으로써 이 문제를 회피하고자 합니다.&lt;/p&gt;

&lt;p&gt;이 모델은 의사 결정 과정을 감독하고, 특정 제안이 사례별로 충분한 지지를 받는지 결정하는 “원로회(Council of Elders)”를 구성할 것을 제안합니다. 모든 개별 PEP에 대해 투표가 진행되며, 원로회는 해당 투표 결과가 이 특정 사례에서 결정을 진행하기에 충분한지 선언합니다. 이 모델은 BDFL (평생 자비로운 독재자)이 전통적으로 의사 결정 과정에서 맡았던 역할에만 초점을 맞추며, 다른 역할은 다루지 않습니다.&lt;/p&gt;

&lt;p&gt;모델 이름의 “커먼즈(Commons)”는 공유 자원으로서 모두가 사용하고 모두가 돌보는 역사적 용어에서 느슨하게 파생되었습니다. 이 모델로 생각해야 할 그림은 따뜻한 여름 저녁, 마을 광장에서 미래 계획을 논의하는 상당수의 농민 집단이 투표를 한 후, 마을 원로들이 결과를 발표하고 연회가 시작되는 모습입니다.&lt;/p&gt;

&lt;p&gt;커먼즈 거버넌스 모델은 전체 커뮤니티에 최고의 권한을 명시적으로 부여한다는 점에서 다른 대부분의 거버넌스 제안(8012를 제외하고)과 다릅니다.&lt;/p&gt;

&lt;h3 id=&quot;제안-배경-rationale&quot;&gt;제안 배경 (Rationale)&lt;/h3&gt;

&lt;p&gt;이 모델의 제안 배경은 모든 것을 명확하게 고정하는 모델이 의도하지 않은 부정적인 부작용을 가질 수 있다는 것입니다. 예를 들어, Python 커미터(committers)에게 투표권을 부여하는 거버넌스 모델은 새로운 후보자가 일하는 회사에 이미 많은 커미터가 있다는 이유로 개인의 커미터 승인을 거부하게 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;또 다른 예로, PEP 승인을 위한 고정된 비율을 설정하는 것은 투표자들 사이에 파벌 형성을 유발하고, 개별 PEP가 개별적인 장점에 따라 판단되지 않고 파벌에 따라 판단될 수 있습니다 (만약 당신이 내 PEP를 지지한다면 나도 당신의 PEP를 지지할 것이다).&lt;/p&gt;

&lt;p&gt;또한, 일인 일표(one-person-one-vote)가 Python과 같은 것에 가장 좋은 모델이 아니라는 문제도 있습니다. 다시 예를 들자면, 분열된 투표(또는 분열에 가까운 투표)의 경우 핵심 개발자 Guido van Rossum의 의견이 핵심 개발자 Jack Jansen의 의견보다 우선되어야 할 수도 있습니다. 이를 투표 모델에서 공식화하려고 하면 매우 복잡한 모델이 될 것이며, 경계 사례에서는 어쨌든 틀릴 것입니다. 여기에 제시된 모델은 그러한 문제들을 (바라건대 현명한) 원로회에 맡깁니다.&lt;/p&gt;

&lt;h3 id=&quot;의사-결정-과정-decision-process&quot;&gt;의사 결정 과정 (Decision Process)&lt;/h3&gt;

&lt;p&gt;모든 중요한 결정은 PEP 과정을 거칩니다. 각 PEP에는 책임자가 있으며, 여기서는 “작성자(author)”라고 불리지만, 단일 인물일 필요는 없으며 실제로 텍스트를 작성한 사람일 필요도 없습니다. 따라서 “작성자”는 “옹호자(champion)” 또는 “관리자(shepherd)” 등으로 읽을 수도 있습니다.&lt;/p&gt;

&lt;p&gt;PEP 작성자는 PEP에 대한 투표를 조직할 책임이 있습니다. 이 투표는 공개적이며, 즉 투표자는 식별되고 결과는 모든 사람에게 알려집니다. 투표는 단순한 +1/0/-1 방식일 수도 있지만, 투표자가 해당 문제에 대해 매우 강한 감정을 느끼는 이유에 대한 간결한 설명과 함께 +2/-2로 확장될 수도 있습니다. 이러한 주석은 원로회에 대한 설명으로 사용될 것입니다. 투표자에게는 커뮤니티 상태(핵심 개발자 등)가 주석으로 추가됩니다.&lt;/p&gt;

&lt;p&gt;투표는 명확하게 정의된 Discourse 카테고리 또는 태그, 특별 메일링 리스트 또는 유사한 기술적 방법(예: vote.python.org와 같은 웹사이트에서 사람들이 로그인하여 커뮤니티 상태가 자동으로 추가되고 신원이 어느 정도 확인될 수 있도록 하는 방식)을 사용하여 토론과 명확하게 분리됩니다.&lt;/p&gt;

&lt;p&gt;PEP 작성자는 PEP와 투표 결과를 원로회에 제출합니다. 원로회는 두 가지를 고려합니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PEP의 중요도(gravity)와 그 영향&lt;/li&gt;
  &lt;li&gt;측정 가능한 투표 결과 (몇 명이 투표했는지, 어떤 개인이 투표했는지, 어떻게 투표했는지)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;원로회는 투표 통과 여부에 대한 잠정적인 결정을 발표하며, 이 결정은 공개됩니다.&lt;/p&gt;

&lt;p&gt;투표 결과가 해당 결정에 대한 커뮤니티의 충분한 지지를 보여주지 못한다고 결정되면, 작성자는 더 많은 지지를 모으고 나중에 투표를 재제출해야 할 책임이 있습니다. 또는 작성자는 제안을 철회할 수 있습니다. 더 많은 지지를 모으는 기간은 한 달이 적절해 보이며, 그 기간 이후에도 투표가 재제출되지 않으면 제안은 반려됩니다.&lt;/p&gt;

&lt;p&gt;잠정적인 결정이 결과가 충분한 지지를 보여준다고 판단되면, 비교적 짧은 대기 기간(수 주 정도)이 시작됩니다. 이 기간 동안 누구든지 원로회에 항소(appeal)할 수 있지만, 투표가 커뮤니티의 충분한 다수를 반영하지 않는다는 근거로만 가능합니다. 대기 기간이 지나면 원로회는 최종 결정을 발표합니다. PEP는 수락되거나, 원로회가 항소에 영향을 받으면 더 많은 지지를 보여주어야 하는 상태로 돌아갑니다.&lt;/p&gt;

&lt;h3 id=&quot;원로회-council-of-elders&quot;&gt;원로회 (Council of Elders)&lt;/h3&gt;

&lt;p&gt;원로회의 의도는 그들이 함께 특정 투표에서 Python 커뮤니티의 의지가 지켜지는지 판단할 수 있도록 하는 것입니다.&lt;/p&gt;

&lt;p&gt;원로회는 BDFL과 동일한 권한을 가진 그룹으로 BDFL을 대체하는 것이 아닙니다. Python의 방향에 대한 지침을 제공하지 않으며, 단지 투표 결과가 커뮤니티의 의지를 대표하는지 확인하려고 합니다. 원로회는 실제 결정권을 가진 미국 대법원과 같지 않으며, 투표 과정만을 감독하여 커뮤니티가 투표에 대표되는지 확인합니다. 그리고 원로회는 스페인 종교 재판과도 전혀 같지 않습니다. (하지만 귀여운 주홍색 예복을 사용하는 데는 어느 정도 장점이 있습니다).&lt;/p&gt;

&lt;p&gt;이 위원회는 네덜란드의 Hoge Raad (불행히도 영어로는 종종 대법원으로 번역됨)와 유사하게, 과정과 절차를 판단하고 사건을 재심을 위해 돌려보낼 수 있습니다. 또한, 많은 국가에 있는 선거 위원회(다른 이름으로)와 유사하게 선거를 감독합니다.&lt;/p&gt;

&lt;h4 id=&quot;위원회-운영-council-operation&quot;&gt;위원회 운영 (Council operation)&lt;/h4&gt;

&lt;p&gt;위원회 구성원은 자원봉사자이며, Python 커뮤니티 내에서 다른 역할도 수행할 가능성이 높습니다 (Python 밖의 삶은 말할 것도 없습니다). 이는 구성원들의 업무 부담을 최소한으로 유지해야 함을 의미합니다. 또한, 개별 위원회 구성원이 언제 위원회 구성원으로서 말하고 언제 자신으로서 말하는지 명확해야 합니다. 그리고 우리는 감정적인 부담에 대해 신경 써야 합니다. 위원회 구성원들은 Python 메일링 리스트의 무작위 비난자들의 결정에 대해 책임을 지지 않아야 합니다.&lt;/p&gt;

&lt;p&gt;이 제안은 두 가지 방법을 통해 업무 부담을 최소화하려고 합니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대부분의 실제 작업은 PEP 작성자와 커뮤니티가 수행하며, 원로회는 투표를 조직하고 결과를 집계하지 않습니다.&lt;/li&gt;
  &lt;li&gt;첫 번째 잠정 결정 이면의 아이디어는 원로회의 실수(주로 PEP의 파급력을 오판하는 것)가 치명적이지 않다는 것입니다. 왜냐하면 커뮤니티가 이러한 실수를 지적할 기회를 가지기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실질적으로 이는 잠정적인 결정이 위원회의 일부에 의해 내려질 수 있으며, 커뮤니티가 이들을 수정할 것을 기대한다는 것을 의미합니다. 2주마다 7명의 근면한 전문가들을 이메일로라도 한자리에 모으는 것은 다소 무리한 요구일 수 있습니다.&lt;/p&gt;

&lt;p&gt;개별 원로가 위원회를 대표하여 말하는 시점을 명확히 하는 가장 좋은 방법은 특별 이메일 주소나 원로들만 게시할 수 있는 Discourse 주제를 사용하는 것입니다. 여기에는 교황이 Ex Cathedra (교황으로서 공식적으로) 말하는 것과 개인으로서 말하는 것 (이 경우 무오하지 않음) 사이의 비유가 있습니다. 원로들은 커뮤니티의 존경받는 구성원일 가능성이 높으며, 그들이 위원회에 속해 있다는 이유로 PEP에 대한 개인적인 의견을 표명할 수 없다고 느끼게 하는 것은 좋지 않습니다.&lt;/p&gt;

&lt;p&gt;커뮤니티 구성원과 원로회 간의 토론, 즉 결정에 항소할 때의 토론은 다른 포럼(Discourse 주제, 메일링 리스트)에서 이루어져야 합니다.&lt;/p&gt;

&lt;p&gt;원로회의 결정은 개별 구성원의 결정이 아닌, 위원회 전체의 결정으로 간주되어야 합니다. 첫 번째 구현에서는 원로들이 자신의 이름으로 게시해야 합니다 (게시하는 주제 또는 특별 배지를 통해 위원회 구성원으로서 말한다는 사실이 전달됨). 만약 원로들이 인신공격의 개별적인 대상이 되는 것으로 밝혀지면, 우리는 이 문제를 재검토하고 익명성을 위한 방법을 모색해야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;자유의-제한-limitation-of-freedom&quot;&gt;자유의 제한 (Limitation of freedom)&lt;/h4&gt;

&lt;p&gt;특정 투표에서 핵심 팀 구성원(전체 핵심 팀 구성원의 50% + 1 이상)의 진정한 다수(찬성 또는 반대)가 있다면 그 결과는 통과됩니다. 특정 투표에서 PSF 투표 회원(50% + 1 이상)의 진정한 다수(찬성 또는 반대)가 있다면 그 결과는 통과됩니다. 그리고 완벽을 기하자면, 앞의 두 진술이 모두 사실이지만 반대 결과가 나온 경우 핵심 팀 구성원들이 승리합니다.&lt;/p&gt;

&lt;p&gt;이러한 제한을 두는 주된 이유는 특정 순간에 기능하는 원로회가 없더라도 결정이 (노력을 통해) 내려질 수 있도록 하기 위함입니다.&lt;/p&gt;

&lt;h4 id=&quot;위원회-구성-council-composition&quot;&gt;위원회 구성 (Council composition)&lt;/h4&gt;

&lt;p&gt;위원회는 너무 크지도 작지도 않아야 하며, 아마도 5명에서 10명 사이가 적절할 것입니다. 이 숫자를 고정할 이유는 없습니다. 구성원들은 Python과 Python 커뮤니티에 대해 잘 알고 있어야 하며, 위원회의 일원으로서 공정하게 운영하려는 의지가 있어야 합니다. 위원회 구성원은 핵심 개발자일 수 있지만 필수는 아닙니다.&lt;/p&gt;

&lt;p&gt;커뮤니티의 모든 사람이 위원회에 의해 대표된다고 느껴야 하므로 위원회가 다양하면 좋을 것입니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;과학자와 기술자&lt;/li&gt;
  &lt;li&gt;진보주의자와 보수주의자 (Python 언어에 대한 관점에서)&lt;/li&gt;
  &lt;li&gt;다양한 문화적 배경, 성별, 연령 등을 가진 사람들&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만, 이것은 위원회 전체에 해당되어야 합니다. 개별 위원회 구성원은 특정 이익 집단을 대표하는 것으로 간주되어서는 안 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;위원회-멤버십-council-membership&quot;&gt;위원회 멤버십 (Council membership)&lt;/h4&gt;

&lt;p&gt;위원회의 권한이 순전히 절차적이기 때문에 구성원들이 비교적 오랫동안 봉사하는 것이 좋을 것입니다. 그러나 위원회가 정기적으로 재설정되는 것이 여전히 좋을 것입니다. 따라서 위원회가 PSF 산하에서 운영되고 매년 신임 투표(vote of confidence)를 받아야 한다고 제안됩니다. 이 투표는 위원회 전체에 대한 것입니다. 위원회에 반대하는 사람들은 기본적으로 “Python은 당신들 같은 원로회 없이 더 낫다”고 말하는 것임을 인지해야 합니다.&lt;/p&gt;

&lt;p&gt;위원회는 일반적으로 새로운 원로를 공동 선임(co-opts)합니다. 이는 아마도 특정 개인이 위원회에 부족한 Python 커뮤니티(또는 언어)의 특정 부분에 대한 지식을 가지고 있다고 여겨지기 때문일 것입니다. 누구나 위원회에 새로운 원로를 제안할 수 있지만 (자신을 포함하여), 위원회는 그 제안을 무시할 수 있습니다. 위원회 구성원들은 언제든지 은퇴할 수 있어야 합니다. 개별 위원회 구성원은 나머지 위원회의 만장일치 투표로 은퇴될 수 있습니다.&lt;/p&gt;

&lt;p&gt;기능하지 않는 위원회를 해임하기 위한 비상 제동 절차(emergency brake procedure)가 있습니다. 한 명의 원로 또는 10명의 핵심 개발자 또는 PSF 투표 회원 그룹이 위원회 전체의 즉각적인 재신임 투표를 요청할 수 있습니다 (아마도 위원회가 임무를 상실하게 할 의도일 것입니다). 이 투표가 원로에 의해 요청되었다면 해당 개인은 투표 결과와 관계없이 즉시 위원회 직위를 잃습니다. 투표가 커뮤니티 구성원에 의해 요청되었고 위원회가 재신임되면 이 절차는 1년 동안 다시 호출될 수 없습니다.&lt;/p&gt;

&lt;p&gt;기능하는 위원회가 없는 경우(현재 초기 상황 또는 불신임 투표 후 위원회가 임무를 상실한 경우) 초기 위원회를 선출해야 합니다. 일반적인 의사소통 채널(Discourse, 메일링 리스트)을 통해 누구든지 (자신을 포함하여) 구성원을 제안할 수 있습니다. 후보자들 사이의 토론과 전체 커뮤니티 내의 토론 후에, 원로회로 자신들을 임명하기 위한 초기 투표를 요청하는 최소 3명의 개인이 나와야 합니다. 이 절차의 의도는 그러한 개인 그룹이 나타나 신임 투표를 요청할 때 압도적인 지지를 기대한다는 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;논의-discussion&quot;&gt;논의 (Discussion)&lt;/h3&gt;

&lt;p&gt;이 PEP는 BDFL의 다른 역할은 다루지 않으며, 오직 투표 과정만을 다룹니다. 가장 중요한 것은 Python의 장기적인 방향이 원로회에 의해 다루어질 것으로 예상되지 않는다는 것입니다. 이는 전체 커뮤니티(또는 커뮤니티의 개별 구성원)의 몫이 될 가능성이 높습니다.&lt;/p&gt;

&lt;p&gt;또한, 외부 세계에 Python과 Python 커뮤니티를 대표하는 상징적인 인물 또는 대변인의 역할도 있습니다. 제 생각으로는 이것 역시 원로회가 처리해야 할 역할이 아니라 다른 사람이나 기관이 맡아야 할 역할입니다.&lt;/p&gt;

&lt;p&gt;이 제안은 진보보다는 보수주의를 선호할 가능성이 높다는 점에 유의해야 합니다. 또는 적어도 이것이 초래할 수 있는 정체의 위험이 미지의 영역으로 무모하게 나아가는 위험보다 더 큽니다. 따라서 이 모델이 도입된다면 PEP 572와 같은 PEP가 통과될 가능성은 낮다는 것을 인식해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h3&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인에 공개되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:29:07 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8014/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8014/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Rejected] PEP 8013 - The External Council Governance Model</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8013/&quot;&gt;PEP 8013 - The External Council Governance Model&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Rejected&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 14-Sep-2018&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-8013--외부-위원회-거버넌스-모델&quot;&gt;PEP 8013 – 외부 위원회 거버넌스 모델&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Steve Dower &lt;steve.dower at=&quot;&quot; python.org=&quot;&quot;&gt;&lt;/steve.dower&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태:&lt;/strong&gt; Rejected (거부됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational (정보성)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주제:&lt;/strong&gt; Governance (거버넌스)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 2018년 9월 14일&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;개요-abstract&quot;&gt;개요 (Abstract)&lt;/h3&gt;

&lt;p&gt;이 PEP는 Python 언어의 최종 의사결정을 담당하는 감사 위원회(Council of Auditors, CoA)를 기반으로 하는 새로운 Python 거버넌스 모델을 제안합니다. 이는 중앙 집중적인 단일 리더를 제안하지 않는다는 점에서 PEP 8010과 다르며, 핵심 커미터(core committers)가 위원회 구성원이 되는 것을 허용하지 않는다는 점에서 PEP 8011과 다릅니다. 이 문서는 위원회의 규모와 역할, 초기 위원회 구성원 선정 방식, 위원회 구성원의 임기 제한, 그리고 후임자 선출 방식에 대해 설명합니다.&lt;/p&gt;

&lt;p&gt;또한, 이 모델의 의도된 행동 방식에 대해 상당한 시간을 할애하여 논의합니다. 많은 프로세스는 명시적으로 지정되지 않고 관련된 사람들에게 맡겨집니다. 최선의 결정을 내릴 사람들을 선택하기 위해서는 관련자들이 CoA의 기대를 이해하는 것이 중요하며, 동시에 CoA가 다양한 상황에 따라 프로세스 요구 사항을 조정할 자유를 허용하는 것도 중요합니다. 이는 프로세스가 명시되지 않았지만 모든 참여자가 유사한 기대를 가질 때만 작동합니다.&lt;/p&gt;

&lt;p&gt;이 PEP는 CoA의 구성원 이름을 명시하지 않습니다. 이 모델이 채택된다면, 이 PEP에 설명된 모든 직책 보유자의 이름과 함께 PEP 13에 명문화될 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;pep-거부-pep-rejection&quot;&gt;PEP 거부 (PEP Rejection)&lt;/h3&gt;

&lt;p&gt;PEP 8013은 2018년 12월 17일 월요일에 PEP 8001에 설명된 핵심 개발자 투표를 통해 거부되었습니다. 대신 PEP 8016과 그에 설명된 거버넌스 모델이 선택되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;회색-영역의-중요성-the-importance-of-the-grey-area&quot;&gt;회색 영역의 중요성 (The Importance of the Grey Area)&lt;/h3&gt;

&lt;p&gt;실제 의사결정 과정에서는 항상 회색 영역(grey area)이 존재하기 마련입니다. 여기에는 예상치 못한 시나리오와 “정답”이 없는 경우가 포함됩니다.&lt;/p&gt;

&lt;p&gt;많은 프로세스 계획은 유연성이 필요하지 않을 정도로 프로세스를 명확하게 정의하여 회색 영역을 최소화하려고 시도합니다.&lt;/p&gt;

&lt;p&gt;이 제안은 의도적으로 그 반대의 길을 택합니다. 목표는 예상치 못한 상황을 처리할 최적의 인력을 선택하기 위한 강력한 프레임워크를 제공하는 것이며, 그 사람들이 그러한 상황을 어떻게 처리해야 하는지는 정의하지 않는 것입니다.&lt;/p&gt;

&lt;p&gt;몇몇 상황에 대한 “좋은” 반응의 예시가 설명을 위해 제공됩니다. “최적의” 사람들이 이러한 예시에 부합하는 행동을 할 것이라는 희망이 있습니다. 제안된 프로세스는 그러한 사람들이 최적의 인력이 아닐 경우 발생할 수 있는 피해를 최소화하도록 설계되었습니다.&lt;/p&gt;

&lt;p&gt;회색 영역은 항상 존재할 수밖에 없습니다. 이 제안은 이를 방지하려고 하기보다는 의도적으로 수용하고 그 안에서 작동합니다.&lt;/p&gt;

&lt;h3 id=&quot;모델-개요-model-overview&quot;&gt;모델 개요 (Model Overview)&lt;/h3&gt;

&lt;h4 id=&quot;주요-인물과-그들의-기능-key-people-and-their-functions&quot;&gt;주요 인물과 그들의 기능 (Key people and their functions)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;감사 위원회 (Council of Auditors, CoA)&lt;/strong&gt;는 Python 릴리스 기간 동안 선출되는 두 명에서 네 명의 가변적인 인원으로 구성된 위원회입니다. CoA의 한 구성원은 회장(President)으로 간주되며, 다른 구성원에 비해 약간의 권한을 가집니다.&lt;/p&gt;

&lt;p&gt;CoA는 핵심 개발팀(core development team) 구성원이 작성한 PEP 형태로 논란이 되는 결정을 검토할 책임이 있습니다. CoA는 PEP를 제출된 그대로 수락하거나, 설명이나 변경을 요청할 수 있습니다. 이러한 변경 요청은 어떤 형태나 이유로든 가능합니다. 이러한 유연성은 의도된 것이며, CoA에 다른 구성원들이 선출됨에 따라 프로세스가 시간이 지남에 따라 변경될 수 있도록 합니다. 예상되는 요청 유형의 예시는 이 문서의 뒷부분에서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;CoA는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-committers&lt;/code&gt; 메일링 리스트에 제출된 PEP에 대해서만 의견을 표명합니다. CoA가 다른 메일링 리스트를 팔로우하거나 참여할 것이라는 기대는 없습니다. (이것은 핵심 개발자(core developers)만이 PEP를 제출할 수 있음을 의미합니다. 비핵심 개발자는 다른 메일링 리스트에서 제안서를 작성하고 논의할 수 있지만, 핵심 개발자가 제안을 지지하고 의견 표명을 요청하지 않는 한 수락 절차를 진행할 수 없습니다. 이는 본질적으로 현재 시스템과 동일하지만, CoA 구성원이 최소 한 명의 핵심 개발자에 의해 지지되지 않는 제안을 처리할 것으로 기대되지 않도록 하기 위해 여기에서 명시적으로 언급됩니다.)&lt;/p&gt;

&lt;p&gt;CoA는 핵심 개발자 팀에 의해 선출되지 않은 개인에게 권한을 위임할 수 없습니다. (여기서 관련 사례 중 하나는 기존 BDFL-Delegate 시스템의 구현이 변경되지만, 반드시 해당 시스템의 정신이 변경되는 것은 아닙니다. 이 점에 대한 자세한 논의는 뒷부분, 특히 시나리오 4를 참조하십시오.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;릴리스 관리자 (Release Manager, RM)&lt;/strong&gt;도 자신이 책임지는 릴리스를 명시하는 모든 PEP에 대해 변경을 요청할 수 있는 동일한 권한을 가집니다. 기능 동결(feature freeze) 이후, RM은 해당 릴리스에 대한 책임을 유지하며, CoA는 교체되어 다음 릴리스에 집중하기 시작합니다. 이는 현재 프로세스와 다르지 않습니다. RM 선정 프로세스는 이 제안에서 변경되지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;핵심 개발자 (Core developers)&lt;/strong&gt;는 CoA 구성원을 선출할 책임이 있으며, CoA 구성원에 대해 “불신임 투표(vote of no confidence)”를 발의할 수 있는 능력을 가집니다. 이러한 투표의 세부 사항은 뒷부분에서 논의됩니다.&lt;/p&gt;

&lt;p&gt;핵심 개발자와 CoA 구성원 간의 논의가 계속되고 있지만 성과가 없을 경우, 회장이 개입하여 양측 중 어느 한쪽에 우선권을 부여할 수 있습니다. 논의에 회장이 관여하는 경우, 불신임 투표를 통해 처리해야 합니다.&lt;/p&gt;

&lt;p&gt;CoA 구성원은 언제든지 사임할 수 있습니다. CoA에 최소 두 명의 구성원이 남아 있다면, 그룹을 재충원하기 위한 새로운 선거를 요청할 수 있습니다. 한 명만 남을 경우, 선거는 자동으로 시작됩니다. (회장이 사임하는 시나리오는 뒷부분에서 설명됩니다.)&lt;/p&gt;

&lt;p&gt;의도된 권력 균형은 핵심 개발자들이 개발팀의 방향을 반영하고 신뢰를 얻으며, 선거 전에 한 약속을 지키지 않는 구성원을 해임할 수 있는 CoA 구성원을 선출하는 것입니다.&lt;/p&gt;

&lt;h4 id=&quot;일반적인-의사결정-과정-regular-decision-process&quot;&gt;일반적인 의사결정 과정 (Regular decision process)&lt;/h4&gt;

&lt;p&gt;일반적인 결정은 현재와 동일하게 계속해서 이루어집니다.
명확성을 위해, 논란이 되는 결정은 PEP를 필요로 하며, PEP를 필요로 하는 모든 결정은 논란이 되는 것으로 간주됩니다.
CoA는 어떤 결정이 논란이 되는 결정 과정을 통해 이루어지는 것이 더 나은지 조언을 요청받을 수 있으며, CoA의 개별 구성원이 그러한 제안을 자원할 수도 있지만, 핵심 개발팀은 이 조언에 구속되지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;논란이-되는-의사결정-과정-controversial-decision-process&quot;&gt;논란이 되는 의사결정 과정 (Controversial decision process)&lt;/h4&gt;

&lt;p&gt;논란이 되는 결정은 항상 기존 프로세스를 따라 PEP로 작성됩니다. 승인자(approver) (이전 “BDFL-Delegate”)는 항상 CoA이며, 더 이상 위임될 수 없습니다. 이는 CoA가 제안을 평가하고 CoA에 권고를 제공할 핵심 개발자를 지명하는 것을 막지 않으며, 이는 본질적으로 현재 위임 프로세스와 동일하다는 점에 유의하십시오.&lt;/p&gt;

&lt;p&gt;CoA는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-committers&lt;/code&gt;에 제출되어 의견 표명을 요청한 PEP에 대해 의견을 표명합니다. CoA의 모든 구성원 또는 현재 RM은 자신의 기대를 충족하기 위해 필요한 추가 작업이 무엇인지에 대한 일부 표시를 포함하는 한, 어떤 이유로든 PEP에 대한 변경을 요청할 수 있습니다. 예상되는 이유의 예시는 뒷부분에서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;CoA의 모든 구성원과 RM이 PEP에 대한 우려가 없음을 표시하면, PEP는 공식적으로 수락됩니다. 한 명 이상의 CoA 구성원이 합리적인 시간 내에 응답하지 않으면, CoA 회장은 이를 묵시적 승인으로 해석할 수 있습니다. 회장이 응답하지 않는 것은 불신임 투표를 통해 처리되어야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;선거-임기-election-terms&quot;&gt;선거 임기 (Election terms)&lt;/h4&gt;

&lt;p&gt;CoA 구성원은 릴리스 기간 동안 선출됩니다. 구성원은 이전 릴리스의 기능 동결(feature freeze) 이전에 선출되며, 해당 릴리스의 기능 동결까지 직책을 유지합니다.&lt;/p&gt;

&lt;p&gt;구성원은 원하는 만큼 재선에 출마할 수 있습니다. 임기 제한은 없습니다. 개인이 다시 봉사해서는 안 된다는 합의가 있을 경우, 핵심 개발자들이 CoA 구성원의 재선을 막는 것은 그들의 몫입니다.&lt;/p&gt;

&lt;h4 id=&quot;선거-투표-과정-election-voting-process&quot;&gt;선거 투표 과정 (Election voting process)&lt;/h4&gt;

&lt;p&gt;CoA 각 구성원에 대한 선거 과정은 다음과 같이 진행됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-committers&lt;/code&gt;에 지명 이메일이 발송됩니다.&lt;/li&gt;
  &lt;li&gt;지지 이메일이 발송됩니다.&lt;/li&gt;
  &lt;li&gt;후보자는 자신을 소개하고 자신의 입장을 발표하기 위해 일시적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-committers&lt;/code&gt;에 추가됩니다.&lt;/li&gt;
  &lt;li&gt;투표는 이전 릴리스의 예정된 기능 동결 2주 전에 시작됩니다.&lt;/li&gt;
  &lt;li&gt;투표는 비공개 GitHub 저장소의 문서를 수정하여 이루어집니다.&lt;/li&gt;
  &lt;li&gt;각 핵심 개발자는 원하는 만큼의 후보자에게 +1 표를 추가할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;7일 후, 투표가 마감됩니다.&lt;/li&gt;
  &lt;li&gt;가장 많은 표를 얻은 후보자가 CoA 회장으로 선출됩니다.&lt;/li&gt;
  &lt;li&gt;그 다음으로 많은 표를 얻고 회장이 받은 표 수의 50% 이상을 받은 세 명의 후보자가 CoA의 다른 구성원으로 선출됩니다.&lt;/li&gt;
  &lt;li&gt;동점(ties)을 해결해야 하는 경우, RM은 자신이 선호하는 후보자에게 한 표를 더 줄 수 있습니다.&lt;/li&gt;
  &lt;li&gt;수락된 후보자는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-committers&lt;/code&gt;에 남아 있고, 나머지는 제거됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;불신임-투표-과정-no-confidence-voting-process&quot;&gt;불신임 투표 과정 (No-confidence voting process)&lt;/h4&gt;

&lt;p&gt;불신임 투표는 다음과 같이 진행됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-committers&lt;/code&gt;에 불신임 투표 이메일이 발송됩니다. 이 이메일에는 해당 CoA 구성원의 이름, 지명 사유, 그리고 지명자가 되돌려야 한다고 생각하는 수락된 PEP 목록(선택 사항)이 포함됩니다.&lt;/li&gt;
  &lt;li&gt;7일 이내에 지지 이메일이 발송됩니다.&lt;/li&gt;
  &lt;li&gt;지명된 CoA 구성원은 7일 동안 답변할 수 있으며, 그 후 지명자 또는 지지자가 철회할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;지명자나 지지자가 없는 경우, 추가 조치는 취해지지 않습니다.&lt;/li&gt;
  &lt;li&gt;투표가 즉시 시작됩니다.&lt;/li&gt;
  &lt;li&gt;각 핵심 개발자는 비공개 GitHub 저장소의 문서를 수정하여 +1 표(CoA 구성원 해임) 또는 -1 표(CoA 구성원 유지)를 추가할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;7일 후, 투표가 마감됩니다.&lt;/li&gt;
  &lt;li&gt;+1 표가 -1 표를 초과하는 경우, CoA 구성원은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-committers&lt;/code&gt;에서 제거되며, 지명된 PEP는 남은 CoA 구성원의 요청이 있거나 CoA 구성원이 한 명만 남은 경우 되돌려질 수 있습니다.&lt;/li&gt;
  &lt;li&gt;제거된 구성원을 대체하기 위한 새로운 선거는 일반적인 절차에 따라 개최될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;CoA 회장이 제거되는 경우, 원래 두 번째로 많은 표를 얻은 후보자가 회장이 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;의도된-행동-방식의-예시-examples-of-intended-behaviour&quot;&gt;의도된 행동 방식의 예시 (Examples of intended behaviour)&lt;/h3&gt;

&lt;p&gt;이 섹션에서는 CoA와 핵심 개발자 간에 우리가 기대하는 상호작용의 몇 가지 예를 설명합니다. 이들 중 어느 것도 구속력 있는 설명은 아니지만, 우리가 기대하는 프로세스 유형에 대한 합의를 이루기 위한 것입니다. CoA 후보자들은 자신이 선호하는 프로세스를 기반으로 캠페인을 벌일 수 있으며, 핵심 개발자들은 이를 바탕으로 투표를 할당해야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;시나리오-1---모호한-pep의-경우-scenario-1---the-case-of-the-vague-pep&quot;&gt;시나리오 1 - 모호한 PEP의 경우 (Scenario 1 - The Case of the Vague PEP)&lt;/h4&gt;

&lt;p&gt;과거에는 초기 제안서가 제안자 외에는 누구도 구현할 수 없을 정도로 세부 사항이 부족한 경우가 많았습니다. 이를 피하기 위해, CoA는 PEP가 제출될 때 “새로운 시각”으로 읽어야 하며, 암시적인 맥락을 추론하거나 사용해서는 안 됩니다. 그런 다음, PEP의 어떤 측면이 명확하지 않을 때, CoA는 제안을 거부하고 설명을 요청할 수 있습니다.&lt;/p&gt;

&lt;p&gt;제안이 거부되었으므로, 다시 검토받기 위해서는 수정하여 재제출되어야 합니다. CoA는 PEP를 거부할 때 얼마나 많은 지침을 제공할지 결정할 것입니다. 이는 재제출될 가능성이 있는 횟수(그리고 CoA의 작업량)에 영향을 미치기 때문입니다. 이는 최종 PEP 텍스트가 필요한 모든 정보와 함께 독립적으로 존재하도록 보장합니다.&lt;/p&gt;

&lt;h4 id=&quot;시나리오-2---끝없는-논의의-경우-scenario-2---the-case-of-the-endless-discussion&quot;&gt;시나리오 2 - 끝없는 논의의 경우 (Scenario 2 - The Case of the Endless Discussion)&lt;/h4&gt;

&lt;p&gt;때때로 Python 기여자들 간의 논의가 더 이상 가치를 제공하지 않는 것처럼 보일 수 있습니다. 예를 들어, 많은 이메일이 이미 다루어진 요점을 반복하거나 다른 사람들에게 적극적으로 적대적일 때, “논의”를 계속하는 것은 무의미합니다.&lt;/p&gt;

&lt;p&gt;의견 표명 요청의 일부로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-committers&lt;/code&gt;에서 이러한 논의가 발생할 경우, CoA 구성원은 제안을 거부함으로써 간단히 스레드(thread)가 끝났음을 선언해야 합니다. 알려진 대부분의 경우, 이러한 종류의 논의는 모든 우려가 제안서에서 충분히 다루어지지 않았으며, 저자가 일부 섹션을 보완해야 할 수도 있음을 나타냅니다.&lt;/p&gt;

&lt;p&gt;대안으로, 다른 CoA 구성원의 거부가 없는 경우, 회장은 제안을 수락함으로써 스레드가 끝났음을 선언할 수 있습니다. 이상적으로는 이는 나머지 CoA와 RM에게 우려 사항이 없음을 직접 확인한 후에 이루어져야 합니다.&lt;/p&gt;

&lt;p&gt;다른 목록에서 이러한 논의가 발생할 경우, CoA 구성원은 다른 핵심 개발자(특히 해당 주제 영역의 전문가로 지명된 핵심 개발자)와 유사하게 존경받는 의견으로 간주되어야 합니다. 스레드를 끝낼 특정 권한은 없지만, 제안을 차단할 의도를 미리 밝히는 것은 잠재적으로 무의미한 논의를 해소하는 유용한 방법입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-committers&lt;/code&gt; 외의 논의를 자발적으로 따르는 CoA 구성원은 제안자에게 철회를 제안할 수 있지만, 공식적으로 의견 표명을 위해 제출된 제안만 실제로 승인하거나 거부할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;시나리오-3---고려되지-않은-사용자들의-경우-scenario-3---the-case-of-the-unconsidered-users&quot;&gt;시나리오 3 - 고려되지 않은 사용자들의 경우 (Scenario 3 - The Case of the Unconsidered Users)&lt;/h4&gt;

&lt;p&gt;과거 일부 제안은 특정 사용자 그룹에 미치는 영향을 고려하지 않고 작성되어 의견 표명을 위해 제출될 수 있습니다. 예를 들어, 다양한 머신에서 Python을 사용하는 데 필요한 의존성(dependencies)에 영향을 미치는 제안은 기본적으로 의존성이 일반적으로 사용 가능하므로 많은 사용자가 영향을 받지 않더라도 일부 사용자에게는 부정적인 영향을 미칠 수 있습니다.&lt;/p&gt;

&lt;p&gt;제안이 모든 사용자를 고려하지 않은 것으로 보일 경우, CoA는 판단과 과거 경험을 사용하여 PEP에 설명된 것보다 더 많은 사용자가 변경 사항의 영향을 받는다고 판단하고, PEP가 이러한 사용자도 다룰 것을 요청할 수 있습니다. 그들은 제안자가 이러한 사용자를 식별하고, 어떻게 다루어졌는지 명확히 설명하거나, PEP를 수정하여 명시적으로 다룰 수 있도록 충분히 명확하게 사용자 그룹을 식별해야 합니다. (이것은 다양한 사용자 그룹에 대한 기능의 유용성을 평가하는 것이 아니라, 단순히 PEP가 기능의 유용성이 평가되었음을 나타내는지 여부를 평가하는 것임에 유의하십시오.)&lt;/p&gt;

&lt;p&gt;제안이 특정 결론에 도달하기 위해 결함 있는 논리나 부정확한 데이터를 사용한 것으로 보일 경우, CoA는 다른 정보원(예: 이전 논의 또는 다른 핵심 개발자의 제출물)을 사용하여 특정 요점을 재고할 것을 요청할 수 있습니다. 제안자는 CoA가 얻은 정확한 정보를 사용하여 제안을 업데이트할 필요는 없지만, CoA가 만족하는 수정 사항을 제공해야 합니다. 예를 들어, PEP는 사용자 30%가 영향을 받을 것이라고 나타낼 수 있지만, CoA는 사용자 70%가 영향을 받는다고 주장할 수 있습니다. 성공적인 수정에는 다르지만 더 신뢰할 수 있는 백분율이 포함되거나, 영향을 받는 사용자 수에 더 이상 의존하지 않도록 다시 작성될 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;시나리오-4---위임된-결정의-경우-scenario-4---the-case-of-the-delegated-decision&quot;&gt;시나리오 4 - 위임된 결정의 경우 (Scenario 4 - The Case of the Delegated Decision)&lt;/h4&gt;

&lt;p&gt;일부 제안은 해당 분야 전문가의 검토 및 승인을 필요로 할 수 있습니다. 역사적으로, 이러한 제안은 BDFL-Delegate를 임명하여 제안에 대한 최종 결정을 내리도록 처리되었습니다. 그러나 이 모델에서는 CoA가 최종 의사결정 과정을 위임할 수 없습니다. CoA가 주제 전문가가 특정 제안에 대해 결정해야 한다고 생각할 때, CoA는 한 명 이상의 개인을 BDFL-Delegate와 유사한 직책에 지명하거나(또는 자원하는 것을 수락) 할 수 있습니다. 이러한 전문가 역할의 조건은 CoA가 적절하다고 판단하는 대로 설정될 수 있지만, CoA는 항상 최종 승인 권한을 유지합니다.&lt;/p&gt;

&lt;p&gt;구체적인 예를 들어, 새로운 언어 기능에 대한 제안이 논의되고 있다고 가정해 봅시다. 제안자들은 이 기능이 새로운 개발자들이 언어를 배우기 더 쉽게 만들 것이라고 주장합니다. 공식적인 제안이 이루어지기 전에도 CoA는 X라는 사람이 Python을 가르친 오랜 역사를 가지고 있고 그의 판단이 신뢰할 수 있으므로, X가 승인하지 않는 한 제안을 수락하지 않을 것이라고 밝힐 수 있습니다. (X라는 사람이 핵심 개발자일 필요는 없다는 점에 유의하십시오.)&lt;/p&gt;

&lt;p&gt;이 역할을 부여받은 X는 논의를 주도하고 실현 가능한 대안에 신속하게 집중할 수 있습니다. 결국, X는 자신이 가장 만족하는 대안을 선택하고 CoA에게 승인했음을 알립니다. 제안은 평소와 같이 제출되고, CoA는 X의 의견을 고려하여 검토하고 수락합니다.&lt;/p&gt;

&lt;h3 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h3&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인에 공개되었습니다.
원문: https://github.com/python/peps/blob/main/peps/pep-8013.rst
최종 수정일: 2025-02-01 08:55:40 GMT&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:28:36 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8013/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8013/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Rejected] PEP 8012 - The Community Governance Model</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8012/&quot;&gt;PEP 8012 - The Community Governance Model&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Rejected&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 03-Oct-2018&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;pep-8012--커뮤니티-거버넌스-모델&quot;&gt;PEP 8012 – 커뮤니티 거버넌스 모델&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Łukasz Langa &lt;lukasz at=&quot;&quot; python.org=&quot;&quot;&gt;&lt;/lukasz&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태:&lt;/strong&gt; &lt;strong&gt;Rejected (거부됨)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational (정보성)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주제:&lt;/strong&gt; Governance (거버넌스)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;생성일:&lt;/strong&gt; 2018년 10월 3일&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pep-거부-사유&quot;&gt;PEP 거부 사유&lt;/h2&gt;

&lt;p&gt;PEP 8012는 2018년 12월 17일 월요일, PEP 8001에 명시된 핵심 개발자 투표를 통해 거부되었습니다. 대신 PEP 8016에 설명된 거버넌스 모델이 채택되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;개요-abstract&quot;&gt;개요 (Abstract)&lt;/h2&gt;

&lt;p&gt;이 PEP는 Python 커뮤니티의 합의와 투표를 기반으로 한 새로운 Python 거버넌스 모델을 제안합니다. 이 모델은 Python 언어의 거버넌스를 수행하기 위해 워크그룹(workgroups)에 의존합니다. 이 거버넌스 모델은 중앙 집중식 단일 리더나 운영 위원회(governing council)의 역할 없이 작동합니다.&lt;/p&gt;

&lt;p&gt;이 문서는 Python 언어에 영향을 미치는 결정에 대한 투표가 어떻게, 언제, 왜 수행되는지 설명하며, 투표 자격 기준도 기술합니다. 이 모델이 채택되었다면 PEP 13에 명문화되었을 것입니다.&lt;/p&gt;

&lt;p&gt;이 모델은 이상적이지는 않지만 다른 모델들에 비해 가장 견고하다는 특성 때문에 “가장 덜 나쁜 거버넌스 모델(The Least Worst Governance Model)”이라고 불릴 수 있습니다. 다른 모델들이 내재한 문제들을 피하는 것이 커뮤니티 거버넌스 모델의 가장 중요한 특징이므로, 이 문서는 다른 모델들을 먼저 거부하면서 논의를 시작하는 다소 특이한 방식으로 전개됩니다.&lt;/p&gt;

&lt;h2 id=&quot;거부된-모델들-rejected-models&quot;&gt;거부된 모델들 (Rejected Models)&lt;/h2&gt;

&lt;p&gt;PEP 8012는 자체 모델을 제안하기 전에, 왜 다른 모델들이 적합하지 않은지 설명하며 논의를 시작합니다.&lt;/p&gt;

&lt;h3 id=&quot;또-다른-bdfl-benevolent-dictator-for-life을-갖자&quot;&gt;또 다른 BDFL (Benevolent Dictator For Life)을 갖자&lt;/h3&gt;

&lt;p&gt;이 모델은 우리가 익히 알고 있는 방식이므로 매우 매력적으로 보일 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;도전-과제-또-다른-guido는-없다-challenge-there-is-no-other-guido&quot;&gt;도전 과제: 또 다른 Guido는 없다 (Challenge: There is no other Guido)&lt;/h4&gt;

&lt;p&gt;Guido van Rossum과 같은 독특한 기술, 커뮤니케이션, 조직적 경험을 가진 단 한 명의 사람은 없습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로젝트를 위한 일관된 장기 비전 설정 및 명확한 전달&lt;/li&gt;
  &lt;li&gt;런타임, 표준 라이브러리 및 광범위한 서드파티 라이브러리 컨텍스트에 대한 깊은 기술적 이해&lt;/li&gt;
  &lt;li&gt;모든 관련 당사자가 수용할 수 있는 방식으로 논쟁적인 문제 협상 및 해결&lt;/li&gt;
  &lt;li&gt;수년간 지속적인 참여를 유지할 자유 시간과 에너지&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;위험-악의적인-종신-독재자-risk-malevolent-dictator-for-life&quot;&gt;위험: 악의적인 종신 독재자 (Risk: Malevolent Dictator For Life)&lt;/h4&gt;

&lt;p&gt;만약 첫 번째 Dictator만큼 적합하지 않은 사람을 얻게 된다면 심각한 결과로 이어질 수 있습니다. 기술적 깊이 부족, 근소한 선거, 일관성 없는 비전, 갈등 처리 능력 부족 또는 번아웃 등으로 신뢰를 얻지 못할 수 있습니다. 또한, Dictator 설정은 한 사람에게 집중된 로비 활동을 유발하여 악의적인 행위자가 프로젝트를 조종할 위험이 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;관찰-우리는-실제로-dictator가-필요하지-않다-observation-we-dont-actually-need-a-dictator&quot;&gt;관찰: 우리는 실제로 Dictator가 필요하지 않다 (Observation: We don’t actually need a Dictator)&lt;/h4&gt;

&lt;p&gt;Dictator 모델의 아이러니는 선거가 필요하다는 점입니다. 이 정도로 중대한 두 가지 문제를 커뮤니티 프로세스를 통해 해결할 수 있다면, 이후의 모든 결정에도 계속 이 방식을 사용하는 것이 어떻겠습니까?&lt;/p&gt;

&lt;h4 id=&quot;위험-모호한-제안이-주는-막연한-안도감-risk-the-warm-and-fuzzy-feeling-of-a-vague-proposal&quot;&gt;위험: 모호한 제안이 주는 막연한 안도감 (Risk: The warm and fuzzy feeling of a vague proposal)&lt;/h4&gt;

&lt;p&gt;BDFL 모델이 제안될 때, BDFL이 누가 되어야 하는지 언급하지 않음으로써 위의 비판을 회피하기 쉽습니다. 그러나 이는 구체적인 모델이 아니므로, 가장 나쁜 시나리오까지 고려하여 공정하게 평가해야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;결론&quot;&gt;결론&lt;/h4&gt;

&lt;p&gt;Guido 없이는 이 모델이 미래의 언어에 가장 적합한 이익을 제공하지 못합니다.&lt;/p&gt;

&lt;h3 id=&quot;의회-council를-갖자&quot;&gt;의회 (Council)를 갖자&lt;/h3&gt;

&lt;p&gt;이 그룹은 Dictator의 책임을 대략적으로 공유합니다.&lt;/p&gt;

&lt;h4 id=&quot;위험-책임-분산-및-혼란-risk-dilution-and-confusion&quot;&gt;위험: 책임 분산 및 혼란 (Risk: Dilution and confusion)&lt;/h4&gt;

&lt;p&gt;이 모델은 3~5명 정도의 소그룹을 선호합니다. 한 명이 아닌 여러 명의 권력자를 두면 책임이 분산되는 동시에 로비, 불충분한 신뢰 또는 커뮤니티의 일부 소외 위험이 증폭됩니다.&lt;/p&gt;

&lt;h4 id=&quot;위험-내부-갈등-risk-internal-conflict&quot;&gt;위험: 내부 갈등 (Risk: Internal Conflict)&lt;/h4&gt;

&lt;p&gt;여러 사람이 거버넌스 책임을 공유하면 내부 갈등, 프로젝트의 일관성 없는 장기 비전, 그리고 구성원들의 지속적인 시간 참여 요구가 증가합니다.&lt;/p&gt;

&lt;h4 id=&quot;결론-1&quot;&gt;결론&lt;/h4&gt;

&lt;p&gt;이 모델은 Dictator 모델과 유사한 위험을 가지며, 심지어 더 나쁠 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;동기-motivation&quot;&gt;동기 (Motivation)&lt;/h2&gt;

&lt;p&gt;다른 거버넌스 모델들의 기본 사항을 거부했으니, 느슨하게 정의된 커미터(committers) 그룹 외에 왜 거버넌스 모델이 필요한지 논의합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;안정성과 신뢰성 (Stability and Reliability):&lt;/strong&gt; 단일 커미터가 언어의 미래나 사용성에 영향을 미치는 광범위한 변경을 하는 것을 방지하고 싶습니다. 일관된 비전과 하위 호환성(backwards compatibility)은 모든 프로그래밍 언어에서 중요하지만, Python처럼 매우 동적인 언어(예: 매우 복잡한 하위 호환성 문제)에서는 두 배로 중요합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Python의 다양한 용도 (Diverse Uses of Python):&lt;/strong&gt; Python은 학생부터 과학자, 수백만 줄의 코드를 가진 기업에 이르기까지 다양한 사용자 그룹이 사용합니다. 모든 다양한 사용자를 포용하고자 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;활력 (Vitality):&lt;/strong&gt; 침체를 피하고 싶습니다. Python은 성숙한 프로젝트이지만, 런타임과 프로그래밍 언어 모두 관련성을 유지하기 위해 계속 발전해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;근거-rationale&quot;&gt;근거 (Rationale)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;포괄적 (Inclusive):&lt;/strong&gt; 커뮤니티 모델은 가장 포괄적인 모델입니다. 특정 개인이나 소수 그룹이 다른 사람들에 비해 특권적인 권력을 갖지 않습니다. 기여자(Contributors)와 모든 워크그룹은 자율적으로 선택됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;실용적 (Pragmatic):&lt;/strong&gt; 이 모델은 특정 개인이나 소수 그룹의 이익으로 인해 어떤 사용자 그룹도 불이익을 받지 않도록 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;입증됨 (Proven):&lt;/strong&gt; 이 모델은 작동합니다. Rust, Django, ECMAScript, C++ 등 많은 대규모 오픈 소스 프로젝트가 이 방식으로 운영됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사양-specification&quot;&gt;사양 (Specification)&lt;/h2&gt;

&lt;h3 id=&quot;핵심-인력-및-기능-key-people-and-their-functions&quot;&gt;핵심 인력 및 기능 (Key people and their functions)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;핵심 팀 (The core team):&lt;/strong&gt; GitHub의 “python” 조직 내 “Python core” 팀에 속한 핵심 개발자들로 구성됩니다. 기여는 변경사항 커밋, Pull Request (PR) 검토, 버그 리포트 관리, 공식 채널 토론 등 다양한 형태로 이루어집니다. 비활동적인(dormant) 기여자도 언제든지 기여를 재개할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전문가 (Experts):&lt;/strong&gt; Python Developer’s Guide에 명시된 특정 관심 영역에 대한 전문가로 인정된 핵심 개발자들입니다. 이들은 해당 영역의 버그 트래커 이슈에 응답하고, PR을 검토하며, 영역의 일관된 디자인 진화를 감독합니다. 여러 전문가가 있는 경우, 그들은 핵심 팀 내에서 하위 팀을 구성하며 함께 책임을 집니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중재자 (Moderators):&lt;/strong&gt; 공식 커뮤니케이션 채널에서 토론이 행동 강령(Code of Conduct)을 준수하도록 보장하는 역할을 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;일반적인-의사-결정-과정-regular-decision-process&quot;&gt;일반적인 의사 결정 과정 (Regular decision process)&lt;/h3&gt;

&lt;p&gt;주요 작업은 버그 트래커 이슈와 Pull Request를 통해 진행됩니다. 핵심 개발자들은 변경 사항을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpython&lt;/code&gt; 저장소에 직접 푸시하는 대신 Pull Request를 사용하는 것이 좋습니다. 핵심 개발자가 Pull Request를 승인하면 추가 절차 없이 병합(merge)할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;논쟁적인-의사-결정-과정-controversial-decision-process&quot;&gt;논쟁적인 의사 결정 과정 (Controversial decision process)&lt;/h3&gt;

&lt;p&gt;특정 관심 영역의 실질적인 변경은 PEP를 필요로 합니다. 여기에는 언어의 의미론적(semantic) 또는 구문적(syntactic) 변경, 표준 라이브러리 또는 C API의 하위 호환성 없는 변경, 표준 라이브러리 추가, 언어 기능 제거 등이 포함됩니다.&lt;/p&gt;

&lt;h4 id=&quot;향상된-pep-pep-enhanced&quot;&gt;향상된 PEP (PEP, Enhanced)&lt;/h4&gt;

&lt;p&gt;PEP 프로세스는 다음과 같은 변경 및 명확화를 통해 보완됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PEP는 최종 결정이 내려질 때까지 병합되지 않으며, 그 전까지는 GitHub에서 열린 Pull Request 상태로 유지됩니다.&lt;/li&gt;
  &lt;li&gt;제출된 PEP는 최종 결정을 내릴 권한을 가진 관심 영역과 관련 전문가를 식별해야 합니다.&lt;/li&gt;
  &lt;li&gt;PEP 작성자는 공식 커뮤니케이션 채널을 사용하여 피드백을 수집하고 통합하여 합의를 구축해야 합니다.&lt;/li&gt;
  &lt;li&gt;어느 시점에서 명명된 전문가 중 한 명이 토론의 현재 상태(주요 불일치 지점 및 절충안 포함)를 설명하는 “요약 의견(summary comment)”을 게시합니다. 동시에 전문가는 PEP를 승인(accept), 잠정적 승인(accept provisionally), 거부(reject) 또는 연기(defer)하는 “최종 의견 수렴 기간(Final Comment Period, FCP) 동의(motion)”를 제안합니다.&lt;/li&gt;
  &lt;li&gt;FCP에 들어가려면 관련 관심 영역의 모든 전문가가 PEP에 서명해야 합니다.&lt;/li&gt;
  &lt;li&gt;FCP는 이해관계자들이 결정이 내려지기 전에 최종 이의를 제기할 수 있도록 14일 동안 지속됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;매우-논쟁적인-pep-very-controversial-peps&quot;&gt;매우 논쟁적인 PEP (Very controversial PEPs)&lt;/h4&gt;

&lt;p&gt;핵심 기여자가 특정 PEP에 강하게 반대하는 경우, FCP 동안 투표를 통해 PEP를 거부하는 동의를 제기할 수 있습니다. 이는 최후의 수단이자 드문 경우여야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;연기-및-거부된-pep-재검토-revisiting-deferred-and-rejected-peps&quot;&gt;연기 및 거부된 PEP 재검토 (Revisiting deferred and rejected PEPs)&lt;/h4&gt;

&lt;p&gt;PEP가 연기되거나 거부된 경우, 동일한 아이디어에 대한 또 다른 시도를 하기 전에 관련 전문가에게 먼저 연락해야 합니다. 전문가들이 아이디어를 재검토할 정당한 증거가 있다고 동의하면, 연기되거나 거부된 PEP를 편집하는 Pull Request를 열 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;기타-투표-상황-other-voting-situations&quot;&gt;기타 투표 상황 (Other Voting Situations)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;새로운 핵심 개발자 지명 (Nominating a new core developer):&lt;/strong&gt; 챔피언(champion)이 공식 커뮤니케이션 채널에 게시하여 새로운 핵심 개발자를 지명합니다. 투표가 시작됩니다. 후보자가 이미 다른 사람들에게 충분히 알려지고 신뢰받는 경우에 이루어져야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불신임 투표 (Votes of no confidence):&lt;/strong&gt; 핵심 개발자를 핵심 팀에서 해임하거나, 특정 관심 영역에 대한 전문가 팀을 해체하는 경우입니다. 이는 프로젝트의 기능 장애 영역을 치유하는 방법을 보여주기 위해 명시적으로 언급되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;투표-메커니즘-voting-mechanics&quot;&gt;투표 메커니즘 (Voting Mechanics)&lt;/h3&gt;

&lt;p&gt;모든 투표는 +1/-1/0 (“찬성”/”반대”/”기권”)으로 기록됩니다. 투표는 14일 동안 진행됩니다. 비활동적인 핵심 개발자는 기권할 경우 총계에 포함되지 않지만, 투표를 선택하면 활동적인 것으로 간주됩니다. 투표는 GitHub의 “python” 조직 내 비공개 저장소에 커밋하는 방식으로 이루어지며, 투표 기간이 끝나면 공개됩니다.&lt;/p&gt;

&lt;p&gt;각 상황별로 다른 투표 비율이 요구됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;PEP 거부 투표:&lt;/strong&gt; 비활동적이지 않은 핵심 개발자 인구의 1/3 이상이 명시적으로 거부 투표를 해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;새로운 핵심 개발자 지명:&lt;/strong&gt; 반대 투표가 없어야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불신임 투표:&lt;/strong&gt; 비활동적이지 않은 핵심 개발자 인구의 최소 2/3 이상의 초다수(super-majority)가 동의에 찬성 투표를 해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;누락된-사항-omissions&quot;&gt;누락된 사항 (Omissions)&lt;/h2&gt;

&lt;p&gt;이 문서는 프로젝트 내에서 가능한 관심 영역을 나열하는 것을 의도적으로 생략합니다. 또한 Python Software Foundation과 그 행동 강령 워킹 그룹(Code of Conduct Working Group)에 의해 이루어지는 중재자(Moderators)의 선출 및 관리에 대해서도 다루지 않습니다.&lt;/p&gt;

&lt;h2 id=&quot;acknowledgements-감사의-말씀&quot;&gt;Acknowledgements (감사의 말씀)&lt;/h2&gt;

&lt;p&gt;이 문서를 형성하는 데 도움이 된 PEP 8002 작성자들과, 이 문서에 큰 영감을 준 Alex Crichton 및 Rust 팀의 거버넌스 모델에 감사드립니다.&lt;/p&gt;

&lt;h2 id=&quot;copyright-저작권&quot;&gt;Copyright (저작권)&lt;/h2&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인에 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:28:04 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8012/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8012/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Rejected] PEP 8011 - Python Governance Model Lead by Trio of Pythonistas</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8011/&quot;&gt;PEP 8011 - Python Governance Model Lead by Trio of Pythonistas&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Rejected&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 24-Aug-2018&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-8011-세-명의-파이써니스타가-이끄는-파이썬-거버넌스-모델-제안-거절됨&quot;&gt;PEP 8011: 세 명의 파이써니스타가 이끄는 파이썬 거버넌스 모델 제안 (거절됨)&lt;/h2&gt;

&lt;h3 id=&quot;개요&quot;&gt;개요&lt;/h3&gt;

&lt;p&gt;이 문서는 파이썬 핵심 개발 커뮤니티를 위한 거버넌스(Governance) 모델을 제안하는 PEP 8011의 한국어 번역 및 정리입니다. PEP 8011은 동등한 권한을 가진 세 명의 리더(이하 ‘트리오’ 또는 ‘Trio of Pythonistas, ToP’)가 파이썬 언어에 대한 최종 결정을 내리도록 하는 것을 목표로 했습니다. 이는 단일한 중앙 리더를 제안했던 PEP 8010과는 다르게 세 명의 그룹을 리더로 하는 방식이었으며, 이들을 보조할 전문 워크그룹(working group)의 구성도 함께 제안했습니다.&lt;/p&gt;

&lt;p&gt;이 PEP는 리더십 트라이어드의 역할과 책임, 구성 지침, 파이썬 핵심 개발자들의 책임, 지속 가능성 및 다양성/포괄성 고려 사항 등을 상세히 다루었지만, 최종적으로 핵심 개발자 투표를 통해 &lt;strong&gt;거절되었습니다&lt;/strong&gt;. 대신 PEP 8016에 설명된 거버넌스 모델이 채택되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;주요-제안-내용&quot;&gt;주요 제안 내용&lt;/h3&gt;

&lt;p&gt;PEP 8011은 다음과 같은 사항들을 설명합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;트리오의 역할과 책임&lt;/li&gt;
  &lt;li&gt;트리오 구성원에 대한 지침&lt;/li&gt;
  &lt;li&gt;단일 리더 대신 세 명의 그룹을 선택한 이유&lt;/li&gt;
  &lt;li&gt;트리오에 대한 파이썬 핵심 개발자들의 역할과 책임&lt;/li&gt;
  &lt;li&gt;지속 가능성 고려 사항&lt;/li&gt;
  &lt;li&gt;다양성 및 포괄성 고려 사항&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pep-거절-pep-rejection&quot;&gt;PEP 거절 (PEP Rejection)&lt;/h3&gt;

&lt;p&gt;PEP 8011은 2018년 12월 17일 월요일, PEP 8001에 명시된 핵심 개발자 투표를 통해 거절되었습니다. 대신 PEP 8016 및 해당 PEP가 설명하는 거버넌스 모델이 채택되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;논의-지점-open-discussion-points&quot;&gt;논의 지점 (Open Discussion Points)&lt;/h3&gt;

&lt;p&gt;이 PEP의 매개변수(예: 트리오의 정확한 책임, 임기, 투표 절차, 트리오 해산)에 대한 다양한 수정은 거버넌스 논의 과정에서 허용되었습니다. 이러한 사항들은 PEP가 투표에 부쳐질 준비가 될 때까지 명문화될 예정이었습니다.
이 모델에 대한 경험이 쌓이면서 더 원활한 거버넌스 프로세스를 위해 이러한 매개변수가 조정될 수 있으며, 조정 과정은 일반적으로 PEP 8001에 설명된 투표 절차와 동일할 것으로 예상되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;리더십-트리오의-역할-및-책임-roles-and-responsibilities-of-the-leadership-trio&quot;&gt;리더십 트리오의 역할 및 책임 (Roles and responsibilities of the leadership trio)&lt;/h3&gt;

&lt;p&gt;트리오는 다음을 수행해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;개방적이고, 사려 깊고, 존중하는 태도를 유지해야 합니다. 즉, PSF(Python Software Foundation)의 행동 강령(Code of Conduct)을 준수해야 합니다.&lt;/li&gt;
  &lt;li&gt;팀으로 또는 다른 트리오 구성원이 동의하는 경우 개별적으로 PEP에 대해 발표해야 합니다.&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어로서의 파이썬과 커뮤니티에 비전과 리더십을 제공해야 합니다.&lt;/li&gt;
  &lt;li&gt;자신의 한계를 이해하고, 필요할 때마다 조언을 구해야 합니다.&lt;/li&gt;
  &lt;li&gt;다음 세대 리더들에게 멘토십을 제공해야 합니다.&lt;/li&gt;
  &lt;li&gt;파이썬 핵심 개발자여야 합니다.&lt;/li&gt;
  &lt;li&gt;PSF의 투표권 있는 회원이어야 합니다 (Contributing / Manager / Fellow / Supporter 중 하나).&lt;/li&gt;
  &lt;li&gt;파이썬이 단순한 언어가 아니라 커뮤니티라는 것을 이해해야 합니다. 기술적인 측면뿐만 아니라 커뮤니티 내의 다른 문제들도 인지하고 있어야 합니다.&lt;/li&gt;
  &lt;li&gt;핵심 파이썬 내에서 전문화된 워킹 그룹(working group)의 구성을 촉진해야 합니다.&lt;/li&gt;
  &lt;li&gt;파이썬 커뮤니티에 행동, 문화, 분위기에 대한 좋은 본보기를 제시해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;트리오의-권한-authority-of-the-trio&quot;&gt;트리오의 권한 (Authority of the trio)&lt;/h3&gt;

&lt;p&gt;분쟁이 발생할 경우, 트리오는 PEP(거버넌스 PEP 제외)에 대한 최종 결정 권한, 특정 결정에 PEP가 필요한지 여부를 결정하는 권한, 그리고 전반적인 기술적 분쟁을 해결할 최종 권한을 가집니다. 트리오의 권한은 거버넌스 자체를 변경하거나 발생할 수 있는 기타 비기술적 분쟁을 포함하지 않습니다. 이러한 분쟁은 PEP 8001에 설명된 프로세스를 통해 처리되어야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;트리오의-역할-및-책임에-포함되지-않는-사항-what-are-not-considered-as-the-role-responsibilities-of-the-trio&quot;&gt;트리오의 역할 및 책임에 포함되지 않는 사항 (What are NOT considered as the role responsibilities of the trio)&lt;/h3&gt;

&lt;p&gt;다음은 트리오에게 기대되는 역할은 아니지만, 원한다면 수행할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 아이디어, 비전, 해결해야 할 문제 등을 항상 제시하는 것은 아닙니다. 트리오는 핵심 개발자 및 커뮤니티의 제안을 개방적으로 수용할 것입니다.&lt;/li&gt;
  &lt;li&gt;일상적인 버그 보고에 트리오가 개입할 필요는 없습니다. 모든 핵심 개발자가 결정을 내릴 수 있지만, 해당 분야의 워킹 그룹에 위임하며, 핵심 개발자들 사이에 큰 의견 불일치가 있을 경우 최종적으로 트리오에 위임할 것입니다.&lt;/li&gt;
  &lt;li&gt;파이썬 언어 서밋 및 관련 물류를 운영/결정하지 않습니다.&lt;/li&gt;
  &lt;li&gt;파이썬 핵심 스프린트 및 관련 물류를 운영/결정하지 않습니다.&lt;/li&gt;
  &lt;li&gt;행동 강령(CoC) 관련 사례를 직접 처리하지 않습니다. 이는 PSF CoC 워킹 그룹의 책임이지만, 사례를 목격할 경우 의견을 표명할 것입니다.&lt;/li&gt;
  &lt;li&gt;다른 파이썬 구현체(Cython, IronPython 등)에 대한 결정을 내리지 않습니다.&lt;/li&gt;
  &lt;li&gt;파이썬 컨퍼런스 및 관련 물류를 운영/결정하지 않습니다.&lt;/li&gt;
  &lt;li&gt;파이썬의 전도사가 아닙니다. 트리오가 파이썬을 홍보/광고할 것으로 기대되지 않습니다. 원한다면 할 수 있지만, 기대되는 역할은 아닙니다.&lt;/li&gt;
  &lt;li&gt;파이썬의 교육자가 아닙니다. 트리오가 파이썬을 가르치거나 글을 쓸 것으로 기대되지 않습니다. 원한다면 할 수 있지만, 기대되는 역할은 아닙니다.&lt;/li&gt;
  &lt;li&gt;연중무휴 24시간 내내 활동할 것으로 기대되지 않습니다. 파이썬을 위한 자신의 가용 시간을 자유롭게 결정할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;PEP 에디터가 아닙니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;트리오-구성-지침-guidelines-for-the-formation-of-the-trio&quot;&gt;트리오 구성 지침 (Guidelines for the formation of the trio)&lt;/h3&gt;

&lt;p&gt;이 거버넌스 모델의 성공은 트리오 구성원과 이들이 협력하여 잘 일할 수 있는 능력에 달려 있습니다. 세 명은 파이썬에 대한 유사한 비전을 가져야 하며, 서로를 보완하는 다른 기술을 가질 수 있습니다.&lt;/p&gt;

&lt;p&gt;트리오 구성원을 선택할 때, 핵심 개발자들은 여러 개인을 지명하고 상위 세 명을 선택하는 대신, &lt;strong&gt;세 명으로 구성된 그룹을 지명하고, 단합된 트리오를 구성할 수 있다고 믿는 그룹에 투표&lt;/strong&gt;할 것입니다.&lt;/p&gt;

&lt;p&gt;트리오에게 요구되는 자질은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파이썬 핵심 개발자일 것.&lt;/li&gt;
  &lt;li&gt;PSF 투표권 있는 회원일 것 (Contributing / Manager / Fellow / Supporter 중 하나).&lt;/li&gt;
  &lt;li&gt;선량한 커뮤니티 회원일 것.&lt;/li&gt;
  &lt;li&gt;PSF 행동 강령을 준수할 것 (개방적이고, 사려 깊고, 존중할 것).&lt;/li&gt;
  &lt;li&gt;명시된 역할과 책임을 기꺼이 수락할 의지가 있을 것.&lt;/li&gt;
  &lt;li&gt;자신의 생각을 효과적으로 소통하고 명확하게 표현할 수 있을 것.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음은 트리오 구성원을 고려할 때 요구 사항이 아닙니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“무언가의 BDFL(Benevolent Dictator For Life) 경험”은 요구 사항이 아닙니다.&lt;/li&gt;
  &lt;li&gt;“천재일 것”은 요구 사항이 아닙니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;다양성과-포괄성-diversity-and-inclusivity&quot;&gt;다양성과 포괄성 (Diversity and inclusivity)&lt;/h4&gt;

&lt;p&gt;핵심 파이썬 개발 팀은 PSF의 다양성 성명(diversity statement)을 전적으로 지지하며, 다양한 배경을 가진 사람들의 참여와 기여를 환영합니다. 트리오에 사람들을 지명할 때, 파이썬 핵심 개발자들은 소외된 그룹의 구성원을 포함시키기 위해 모든 노력을 기울일 것입니다.&lt;/p&gt;

&lt;h4 id=&quot;지속-가능성-sustainability&quot;&gt;지속 가능성 (Sustainability)&lt;/h4&gt;

&lt;p&gt;고용주의 지원 부족이나 자유 시간의 부족은 트리오 구성원을 식별하는 데 방해가 되어서는 안 됩니다. 핵심 개발자들이 트리오 구성원으로서 필요한 기술을 가졌다고 판단했지만, 시간 부족이나 재정 지원 부족으로 인해 역할을 수행할 수 없는 경우, 필요한 지원을 제공하기 위해 PSF 또는 다른 당사자들과 논의를 시작해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;다른-거버넌스-모델을-선택하지-않는-이유-why-not-other-governance-model&quot;&gt;다른 거버넌스 모델을 선택하지 않는 이유 (Why not other governance model)&lt;/h3&gt;

&lt;p&gt;파이썬 핵심 커뮤니티는 20년 이상 단일 BDFL 모델에 익숙해져 있으며, 이는 파이썬에 “작동했던” 모델입니다. 갑자기 완전히 다른 모델로 전환하는 것은 커뮤니티의 안정성에 혼란을 줄 수 있습니다. 그러나 커뮤니티는 미래에 계속 진화할 수 있습니다.
이 PEP가 채택된다고 하더라도, 이것이 파이썬의 유일한 미래 거버넌스 모델이 될 것으로 의도된 것은 아닙니다.
이 PEP는 (소규모이긴 하지만) 여러 사람이 이끄는 커뮤니티로의 전환을 제안하며, 추가적인 전문 워크그룹 개념도 도입합니다.&lt;/p&gt;

&lt;h3 id=&quot;세-명-이상은-안-되는-이유-why-not-more-than-three&quot;&gt;세 명 이상은 안 되는 이유 (Why not more than three)&lt;/h3&gt;

&lt;p&gt;“요리사가 너무 많으면 수프를 망친다(Too many chefs spoil the soup)”는 속담처럼, 리더십 팀의 목표는 파이썬 핵심 개발자들이 합의에 도달하고 결정을 내릴 수 있도록 하는 것입니다. 리더십 팀이 클수록 결정을 내리기가 더 어려워집니다.
이는 트리오 구성원들의 이점도 고려한 것입니다. 팀에서 다른 사람들과 협력하는 것은 자연스럽게 일어나는 일이 아니며 많은 노력이 필요합니다. 트리오 구성원들은 장기적으로 팀의 일원이 될 것으로 예상됩니다. 다른 두 사람을 다루는 것만으로도 충분히 어려울 수 있습니다. 트리오가 가능한 한 효율적으로 자신의 임무와 책임을 수행할 수 있도록 하려는 것입니다.
그룹에 사람이 많을수록 회의하고 논의하며 결정을 내리는 데 시간을 맞추기가 더 어려워집니다.&lt;/p&gt;

&lt;h3 id=&quot;트리오에-대한-파이썬-핵심-개발자의-역할-및-책임-roles-and-responsibilities-of-python-core-developers-to-the-trio&quot;&gt;트리오에 대한 파이썬 핵심 개발자의 역할 및 책임 (Roles and responsibilities of Python Core Developers to the trio)&lt;/h3&gt;

&lt;p&gt;핵심 개발자들은 다음을 수행해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;개방적이고, 사려 깊고, 존중하는 태도를 유지해야 합니다. 즉, PSF의 행동 강령을 준수해야 합니다.&lt;/li&gt;
  &lt;li&gt;트리오 개별 구성원이 내린 결정 및 발표는 트리오에서 나온 권위 있는 것으로 간주해야 합니다. 트리오가 결정을 발표하면, 핵심 개발자들은 처음에는 지지하지 않았더라도 (트리오가 그런 결정을 내리기 전에는) 지지해야 합니다.&lt;/li&gt;
  &lt;li&gt;버그 트래커에서 일상적인 의사 결정을 계속하고, 큰 의견 불일치가 있을 경우 트리오에 위임해야 합니다.&lt;/li&gt;
  &lt;li&gt;파이썬 핵심 개발자는 CoC 사례를 직접 처리하지 않습니다. 이는 CoC 워킹 그룹의 책임이지만, 사례를 목격할 경우 의견을 표명할 것입니다.&lt;/li&gt;
  &lt;li&gt;자신이 기술적인 측면뿐만 아니라 더 큰 파이썬 커뮤니티의 일부임을 인지해야 합니다.&lt;/li&gt;
  &lt;li&gt;PSF 투표권 있는 회원이어야 합니다 (Contributing / Manager / Fellow / Supporter 중 하나).&lt;/li&gt;
  &lt;li&gt;파이썬 커뮤니티에 행동, 문화, 분위기에 대한 좋은 본보기를 제시해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;임기-term-limit&quot;&gt;임기 (Term Limit)&lt;/h3&gt;

&lt;p&gt;트리오는 평생 봉사할 것으로 예상되지 않지만, 더 긴 임기가 바람직합니다. 긴 임기의 목적은 불필요한 “선출”의 혼란을 피하고, 언어와 커뮤니티에 안정성과 일관성을 제공하는 것입니다.
현재 파이썬 릴리스 관리자(release manager)는 5년(하나의 릴리스 주기) 동안 직책을 맡고 있으며, 이는 지금까지 잘 작동하는 것으로 보입니다. 따라서 이 PEP는 트리오가 5년 동안 직책을 맡을 것을 제안합니다.&lt;/p&gt;

&lt;h3 id=&quot;트리오의-승계-계획-succession-planning-of-the-trio-open-for-discussion&quot;&gt;트리오의 승계 계획 (Succession planning of the trio (open for discussion))&lt;/h3&gt;

&lt;p&gt;트리오는 해산/은퇴/사임 의사를 최소 1년 전에 핵심 개발자들에게 알려야 합니다. 이는 다음 세대 후임자를 적극적으로 멘토링하고 훈련할 시간을 허용하고, 권력 공백을 피하기 위함입니다.
트리오가 반드시 다음 리더를 선택해야 하는 것은 아닙니다.
이 PEP는 다음 세대에 동일한 거버넌스 모델이 선택되어야 한다고 강제하지 않습니다. 파이썬은 언어이자 커뮤니티로서 계속 진화할 수 있습니다. 1년 전에 해산 의사를 알림으로써, 트리오는 핵심 파이썬 커뮤니티가 이 거버넌스 모델의 성공/실패를 숙고하고, 필요하다면 다른 거버넌스 모델을 선택할 기회를 제공합니다.
그러나 다음 거버넌스 모델과 리더는 트리오가 해산 의사를 발표한 후 1년 이내에 선택/선출되어야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;트리오-구성원-중-한-명이-사임해야-하는-경우-scenario-if-one-member-of-the-trio-needs-to-quit&quot;&gt;트리오 구성원 중 한 명이 사임해야 하는 경우 (Scenario if one member of the trio needs to quit)&lt;/h3&gt;

&lt;p&gt;선택된 트리오 구성원 중 한 명이 예상치 못한 이유로 사임해야 하는 경우 몇 가지 가능한 옵션이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;남은 두 명이 다른 구성원을 선택하여 역할을 채울 수 있습니다.&lt;/li&gt;
  &lt;li&gt;트리오가 해산하기로 결정하고, 핵심 개발자들이 다른 트리오를 지명할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;핵심 개발자들이 다른 거버넌스 모델을 선택할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;트리오는 한 팀(slate)으로 선출되었으므로, 한 명의 손실은 선출된 단위를 깨뜨립니다. 따라서 새로운 선거가 치러져야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;워킹-그룹전문-분야소유권-형성-formation-of-working-groupsarea-of-expertiseownership-previously-bdfl-delegate&quot;&gt;워킹 그룹/전문 분야/소유권 형성 (Formation of working groups/area of expertise/ownership (previously BDFL delegate))&lt;/h3&gt;

&lt;p&gt;핵심 파이썬 및 파이썬 커뮤니티의 특정 영역과 주제는 특정 기술 전문성을 가진 리더를 필요로 합니다. 트리오의 의사 결정을 돕기 위해 해당 특정 영역에서 더 많은 권한을 가진 여러 워킹 그룹이 존재하도록 권장됩니다.
이러한 “전문화된 워킹 그룹/협의회”의 역할은 각자의 영역에서 발생하는 논쟁적인 논의에 대한 최종 의사 결정자가 되는 것입니다.
이러한 워킹 그룹은 리더십 트리오가 소규모 그룹인 것과 유사한 이유로 작아야 합니다 (3-5명).
이러한 워킹 그룹은 파이썬 핵심 개발자와 외부 전문가 모두로 구성되어야 합니다. 이는 내려진 결정이 파이썬 핵심 개발자들에게만 유리하지 않도록 하기 위함입니다.
파이썬 핵심 개발자들은 각자의 주제에 대한 결정을 이러한 워킹 그룹에 위임할 것입니다. 그러나 이러한 그룹은 트리오에 보고하거나 트리오에 위임할 것입니다.&lt;/p&gt;

&lt;p&gt;이러한 워킹 그룹이 필요한 이유는 이전 파이썬 BDFL의 “큰 역할”을 재구성하려는 노력의 일환입니다.&lt;/p&gt;

&lt;h3 id=&quot;psf-회원-자격-확인-affirmation-as-being-a-member-of-the-psf&quot;&gt;PSF 회원 자격 확인 (Affirmation as being a member of the PSF)&lt;/h3&gt;

&lt;p&gt;이 PEP는 핵심 개발자와 트리오 구성원들이 스스로 PSF 회원임을 자가 인증할 것을 제안합니다.
PSF의 일원이라는 것은 파이썬 커뮤니티의 일원이며, PSF의 사명과 다양성 성명을 지지한다는 것을 의미합니다.
PSF 회원으로서 파이썬 핵심 개발자들은 파이썬에 대한 지지를 표명하고 커뮤니티 행동 강령에 동의합니다.&lt;/p&gt;

&lt;h3 id=&quot;트리오라는-이름-선택-이유-reasoning-for-choosing-the-name-trio&quot;&gt;‘트리오’라는 이름 선택 이유 (Reasoning for choosing the name trio)&lt;/h3&gt;

&lt;p&gt;파이썬 비동기 라이브러리인 ‘Trio’와 혼동되지 않도록 합니다.
“트리오(trio)”는 짧고 발음하기 쉬우며, triad, trinity, triumvirate, threesome 등 길고 부정적인 해석을 가질 수 있는 다른 단어들과 다릅니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:27:38 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8011/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8011/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Rejected] PEP 8010 - The Technical Leader Governance Model</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8010/&quot;&gt;PEP 8010 - The Technical Leader Governance Model&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Rejected&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 24-Aug-2018&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;파이썬 개선 제안 (PEP) 8010: 기술 리더 거버넌스 모델&lt;/p&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;
&lt;p&gt;이 문서는 Python Enhancement Proposal (PEP) 8010, 즉 “기술 리더 거버넌스 모델”에 대한 한국어 번역 및 요약입니다. 이 PEP는 단일 기술 프로젝트 리더 모델의 지속을 제안하며, 기존의 BDFL (Benevolent Dictator For Life) 모델을 ‘Gracious Umpire Influencing Decisions Officer (GUIDO)’라는 새로운 명칭으로 대체할 것을 제시했습니다. 이 명칭 변경은 GUIDO가 더 넓은 개발 커뮤니티와의 협의를 통해 Python 언어 의사결정 과정의 최종 중재자로서 확장된 역할을 반영하며, “종신”이라는 개념이 언어나 GUIDO 자신에게 항상 최선은 아닐 수 있다는 인식을 담고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고:&lt;/strong&gt; PEP 8010은 2018년 12월 17일에 핵심 개발자 투표를 통해 &lt;strong&gt;거부&lt;/strong&gt;되었습니다. 대신 PEP 8016과 그 거버넌스 모델이 채택되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;주요-제안-내용-거부되었음&quot;&gt;주요 제안 내용 (거부되었음)&lt;/h2&gt;

&lt;p&gt;이 PEP는 다음과 같은 내용을 기술합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;단일 기술 리더 모델 유지의 근거:&lt;/strong&gt; 단일 기술 리더 모델을 유지하는 이유를 설명합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GUIDO 선출 및 유지 과정:&lt;/strong&gt; GUIDO가 어떻게 선택, 선출, 유지, 소환되고 계승될지에 대한 절차를 명시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GUIDO의 역할:&lt;/strong&gt; Python 언어 발전 과정에서 GUIDO의 역할을 정의합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;임기:&lt;/strong&gt; GUIDO의 임기 길이를 제안합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Council of Pythonistas (CoP)와의 관계:&lt;/strong&gt; 기술적 문제에 대해 GUIDO에게 자문하는 CoP와의 관계를 설명합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CoP의 규모, 선출, 역할:&lt;/strong&gt; CoP의 구성원 수, 선출 방식 및 역할을 정의합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;의사결정 위임 절차:&lt;/strong&gt; 의사결정 위임 과정을 설명합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PEP 프로세스 변경:&lt;/strong&gt; 새로운 거버넌스 모델에 맞춰 PEP 프로세스에 필요한 변경 사항을 제안합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 PEP는 새로운 BDFL을 지명하지 않습니다. 이 모델이 채택될 경우, PEP 13에 이 문서에 설명된 모든 직책 보유자의 이름과 함께 명시될 예정이었습니다.&lt;/p&gt;

&lt;h2 id=&quot;pep-거부&quot;&gt;PEP 거부&lt;/h2&gt;

&lt;p&gt;PEP 8010은 2018년 12월 17일 월요일에 PEP 8001에 설명된 핵심 개발자 투표를 통해 거부되었습니다. 대신 PEP 8016 및 해당 거버넌스 모델이 채택되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;논의-지점&quot;&gt;논의 지점&lt;/h2&gt;

&lt;p&gt;거버넌스 논의 과정에서 CoP의 정확한 규모, 임기, 투표 절차 등 이 PEP의 매개변수에 대한 다양한 조정이 허용됩니다. 이들은 PEP가 투표에 부쳐질 준비가 될 때까지 성문화될 예정이었습니다.&lt;/p&gt;

&lt;p&gt;이 PEP에 설명된 투표 절차 및 이벤트는 PEP 8001에 명시된 투표 방식을 기본으로 하지만, 이 PEP가 작성될 당시 PEP 8001도 논의 중이었으므로 변경될 수 있었습니다.&lt;/p&gt;

&lt;p&gt;이 모델을 통해 경험이 쌓이면서, 향후 GUIDO가 지명될 때 더 원활한 거버넌스 프로세스를 제공하기 위해 이러한 매개변수가 조정될 수 있을 것으로 예상되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;왜-단일-기술-리더인가&quot;&gt;왜 단일 기술 리더인가?&lt;/h2&gt;

&lt;p&gt;다른 모델이 아닌 이 모델을 제안한 이유는 “비전(vision)”에 있습니다. 위원회식 설계는 많은 단점을 가지고 있으며, 이는 당시 기여자들의 다양한 관심사에 기반하여 새로운 기능이 축적되는 언어로 이어질 수 있습니다. 유명한 경구는 “낙타는 위원회가 설계한 말이다(a camel is a horse designed by committee)”라는 것입니다. 위원회가 설계한 언어가 “일관성 있게 유지될(hang together)” 수 있을까요? 규칙이 합리적이고 쉽게 기억되는 일관되고 자기 모순 없는 언어처럼 느껴질까요?&lt;/p&gt;

&lt;p&gt;단일 기술 리더는 위원회가 할 수 있는 것보다 더 많은 비전을 추진할 수 있습니다. 각 참여자는 “Python”이 무엇인지에 대한 자신만의 비전을 가질 것이며, 이러한 개별 비전이 충돌할 때 우유부단함이나 비논리적인 선택으로 이어질 수 있습니다. 예를 들어, CPython을 3배 더 빠르게 만들어야 할까요, 아니면 C API를 보존해야 할까요? 이는 어느 쪽도 옳고 그르지 않기 때문에 합의를 얻기 매우 어려운 질문입니다. 그러나 잘못된 결정을 내리는 것보다 더 나쁜 것은 합의를 찾을 수 없기 때문에 현 상태를 수용하는 것일 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;유연성&quot;&gt;유연성&lt;/h2&gt;

&lt;p&gt;GUIDO와 CoP 모두에게 명세 부족(underspecification)을 통해 일정 수준의 유연성이 부여됩니다. 이 PEP는 갈등이 어떻게 해결될지 설명하지만, 핵심 개발자, 커뮤니티 구성원, 직책 보유자를 포함한 모든 참여자가 항상 Python과 그 사용자들의 최선의 이익을 염두에 둘 것으로 기대합니다. 이 PEP는 상호 존중과 선의가 항상 합의로 이어질 것이며, 행동 강령(Code of Conduct)이 모든 상호작용과 논의를 관리한다고 가정합니다.&lt;/p&gt;

&lt;h2 id=&quot;guido의-역할&quot;&gt;GUIDO의 역할&lt;/h2&gt;

&lt;p&gt;GUIDO의 가장 중요한 역할 중 하나는 여러 릴리스에 걸쳐 Python 언어 발전에 대한 포괄적이고 넓고 일관된 비전을 제공하는 것입니다. 이는 의사결정이 장기적인 영향을 미치고 상충하는 이점을 가질 때 특히 중요합니다. 예를 들어, C API에 대한 하위 호환성 없는 변경이 Python 성능을 2배 향상시킨다면, 다른 커뮤니티 구성원들은 논쟁의 양측에서 설득력 있게 주장할 것이며, 명확한 합의가 도출되지 않을 수 있습니다. 어느 선택이든 똑같이 유효합니다. CoP와의 협의를 통해 궁극적인 결정을 이끌어내는 것은 GUIDO의 비전이 될 것입니다.&lt;/p&gt;

&lt;p&gt;GUIDO는 PEP 및 기타 문제에 대한 최종 결정권자이며, 특정 변경 사항이 PEP 가치가 있는지 여부를 포함합니다. 오늘날과 마찬가지로, 많은 —사실 대부분의— 결정은 이슈 트래커, 병합 요청, 토론 포럼에서 논의와 해결을 통해 이루어지며, 일반적으로 해당 분야 전문가의 의견이나 주도에 따라 진행됩니다. 이러한 운영 절차가 완벽하게 작동하는 곳에서는 변경 없이 계속될 수 있습니다. 이는 또한 CoP와 GUIDO의 업무 부담을 줄여 가장 중요한 결정과 넓은 시야를 중앙 권한에만 남겨둡니다.&lt;/p&gt;

&lt;p&gt;마찬가지로, 특정 변경 사항이 PEP를 요구한다고 간주되지만, GUIDO가 CoP와의 협의를 통해 최종 결정을 내릴 완전한 신뢰를 가진 전문가를 식별하는 경우, GUIDO는 해당 PEP에 대한 위임자(Delegate)를 지명할 수 있습니다. GUIDO가 최종 권한을 유지하지만, GUIDO는 위임자의 권한을 훼손하지 않고 실제로 PEP의 최종 중재자로서 지지할 것으로 예상됩니다.&lt;/p&gt;

&lt;p&gt;GUIDO는 제안이 Python의 장기적인 비전에 반한다는 것이 분명할 때, 비생산적인 논의, 아이디어, 제안을 중단할 수 있는 완전한 권한을 가집니다. 이는 변경을 주장하는 사람들에게는 공감하지만, 모든 커뮤니티 구성원의 건강과 복지를 염두에 두고 이루어집니다. 막다른 골목 제안에 대한 독성이 있는 논의는 누구에게도 도움이 되지 않으며, 명령에 의해 종료될 수 있습니다.&lt;/p&gt;

&lt;p&gt;요약하자면: GUIDO는 거버넌스 PEP 자체를 변경하는 것을 제외하고, 기술적 또는 비기술적 주제에 대한 최종 선언을 할 권한을 가집니다.&lt;/p&gt;

&lt;h2 id=&quot;권한은-커뮤니티로부터-나온다&quot;&gt;권한은 커뮤니티로부터 나온다&lt;/h2&gt;

&lt;p&gt;GUIDO의 권한은 궁극적으로 커뮤니티에 있습니다. 대다수 커뮤니티의 신뢰를 잃은 무책임한 GUIDO는 소환될 수 있으며, 새로운 투표가 실시될 수 있습니다. 이는 극히 드물고 일어날 가능성이 낮은 사건입니다. 이는 최악의 시나리오에 대한 충분한 임시방편이므로 가볍게 다루어져서는 안 됩니다. GUIDO는 한 가지 결정 때문에 해임되는 것을 두려워해서는 안 됩니다. 비록 그 결정이 대다수의 Python 개발자들이 선호하지 않는 결정이라 할지라도 말입니다. 소환은 Python 언어 또는 커뮤니티에 심각하게 해로운 행동에 대해서만 유보되어야 합니다.&lt;/p&gt;

&lt;p&gt;Council of Pythonistas (아래 참조)는 불신임 투표를 시작할 책임이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;임기-및-연임-제한&quot;&gt;임기 및 연임 제한&lt;/h2&gt;

&lt;p&gt;GUIDO는 세 번의 Python 릴리스 동안, 현재 릴리스 주기를 고려할 때 약 4.5년 동안 봉사합니다. Python의 릴리스 주기가 변경되면, GUIDO의 임기는 전체 릴리스로 반올림하여 4.5년으로 변경되어야 합니다. 반올림 방식은 잠재적인 릴리스 주기 PEP에 맡겨집니다. 이 기간이 지나면, 아래에 명시된 절차에 따라 새로운 선거가 실시됩니다. 연임 제한은 없으므로, GUIDO는 원하는 한 재선에 출마할 수 있습니다.&lt;/p&gt;

&lt;p&gt;GUIDO는 임기를 모두 채울 것으로 예상되지만, 물론 “인생은 예측 불가능합니다(Life Happens)”. GUIDO가 임기 전에 사임해야 하는 경우, 새로운 GUIDO 선출 절차에 따라 공석이 채워집니다. 그러나 새로운 GUIDO는 원래 GUIDO의 남은 임기 동안만 봉사하며, 이 시점에 새로운 선거가 실시됩니다. 사임하는 GUIDO는 후임자가 선출될 때까지 계속 봉사할 수 있습니다.&lt;/p&gt;

&lt;p&gt;과도기 동안, CoP (아래 참조)는 GUIDO의 의무를 수행할 수 있지만, 실질적인 결정(예: 기술 PEP 승인)은 새로 선출될 GUIDO에게 맡기는 것을 선호할 수도 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;guido-선출&quot;&gt;GUIDO 선출&lt;/h2&gt;

&lt;p&gt;선출 과정은 새로운 GUIDO의 공석이 발생하거나, 정상적인 과정에서 GUIDO가 재선에 출마할 때 시작됩니다. GUIDO가 사임하거나 GUIDO의 정규 임기가 끝나기 두 달 전에 선출 과정이 시작되면, 새로운 선거 절차가 시작됩니다.&lt;/p&gt;

&lt;p&gt;투표 전 3주 동안 후보 지명이 가능합니다. 후보자는 현재 Python 핵심 개발자 목록에서 선택되어야 합니다. 비핵심 개발자는 GUIDO로 봉사할 자격이 없습니다. 후보자는 자신을 지명할 수 있지만, 모든 지명은 재청(seconded)되어야 합니다. 지명과 재청은 비공개 저장소에 대한 병합 요청(merge request)으로 진행됩니다.&lt;/p&gt;

&lt;p&gt;지명을 수락하면, 후보자들은 동일한 비공개 저장소를 사용하여 짧은 입장 성명(position statement)을 게시할 수 있으며, 커미터 토론 포럼에도 게시할 수 있습니다. 토론도 있을 수 있습니다! 이 선거 단계는 2주 동안 진행됩니다.&lt;/p&gt;

&lt;p&gt;핵심 개발자들은 PEP 8001에 설명된 절차를 사용하여 3주 동안 투표합니다.&lt;/p&gt;

&lt;h2 id=&quot;council-of-pythonistas-cop&quot;&gt;Council of Pythonistas (CoP)&lt;/h2&gt;

&lt;p&gt;GUIDO를 돕는 것은 소수의 선출된 Python 전문가 팀입니다. 이들은 기술 위원회 구성원 팀으로 봉사합니다. 이들은 GUIDO 앞에 놓인 선택 사항에 대한 통찰력과 논의를 제공합니다. 협의는 양측에서 시작될 수 있습니다. 예를 들어, GUIDO가 특정 선택에 대해 여전히 결정을 내리지 못한 경우, CoP와의 논의는 남은 문제를 명확히 하고, 올바른 질문을 식별하고, GUIDO가 잘 알지 못할 수 있는 다른 Python 사용자들에게 미치는 영향에 대한 통찰력을 제공하는 데 도움이 될 수 있습니다. CoP는 GUIDO의 신뢰할 수 있는 조언자이며, 긴밀한 협력 관계가 예상됩니다.&lt;/p&gt;

&lt;p&gt;CoP는 핵심 개발자 중에서 선출된 3명의 구성원으로 구성됩니다. 그들의 임기는 3년이며, 구성원은 원하는 만큼 여러 번 재선에 출마할 수 있습니다. 연속성을 보장하기 위해 CoP 구성원은 순환 방식으로 선출됩니다. 매년 한 명의 CoP 구성원이 재선에 출마합니다.&lt;/p&gt;

&lt;p&gt;초기 선거를 위한 시차를 부트스트랩하기 위해, 가장 많은 득표를 얻은 CoP 구성원은 3년 동안, 두 번째로 인기 있는 득표자는 2년 동안, 가장 적은 득표를 얻은 CoP 구성원은 초기 1년 동안 봉사합니다.&lt;/p&gt;

&lt;p&gt;투표의 모든 동점은 PEP 8001에서 결정될 절차에 따라 해결될 예정이었습니다.&lt;/p&gt;

&lt;p&gt;지명 및 투표 절차는 GUIDO와 유사합니다. 3주간의 지명 기간이 있으며, 자천이 허용되고 재청되어야 합니다. 그 다음 입장 성명을 게시하는 기간이 있고, 이어서 투표가 진행됩니다.&lt;/p&gt;

&lt;p&gt;CoP는 만장일치 결정으로 GUIDO에 대한 불신임 투표를 시작할 수 있으며, 해당 섹션의 절차를 시작합니다.&lt;/p&gt;

&lt;h2 id=&quot;불신임-투표&quot;&gt;불신임 투표&lt;/h2&gt;

&lt;p&gt;위에서 언급했듯이, CoP는 만장일치 결정으로 GUIDO에 대한 불신임 투표를 시작할 수 있습니다. 이 과정은 가볍게 다루어져서는 안 되지만, 일단 시작되면 최대 두 번의 투표가 시작됩니다. 두 경우 모두 투표는 PEP 8001과 동일한 절차로 이루어지며, 모든 핵심 개발자가 불신임 투표에 참여할 수 있습니다.&lt;/p&gt;

&lt;p&gt;첫 번째 투표는 현재 GUIDO를 소환할지 여부입니다. Python 개발자들의 압도적 다수가 “불신임”에 투표하면, GUIDO는 소환됩니다. 그 다음, 이 직책 보유자의 초기 선출 절차에 따라 새로운 GUIDO를 선출하기 위한 두 번째 투표가 실시됩니다. GUIDO가 없는 기간 동안, 주요 결정은 보류되지만, 정상적인 Python 운영은 물론 계속될 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;일상적인-운영&quot;&gt;일상적인 운영&lt;/h2&gt;

&lt;p&gt;GUIDO는 모든 또는 대부분의 결정에 필요하지 않습니다. Python 개발자들은 이미 위임, 책임, 자기 주도성을 위한 충분한 기회를 가지고 있습니다. 이슈 트래커와 풀 리퀘스트는 이 거버넌스 모델이 선택되기 전과 동일한 기능을 수행합니다. 버그 수정 및 사소한 개선에 대한 대부분의 논의는 항상 그래왔듯이 이러한 포럼에서 이루어질 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;pep-고려-사항&quot;&gt;PEP 고려 사항&lt;/h2&gt;

&lt;p&gt;GUIDO, CoP 구성원, 그리고 Python 커뮤니티의 다른 누구라도 PEP를 제안할 수 있습니다. 잠재적인 PEP의 처리는 PEP 작성자에 관계없이 동일하게 처리됩니다.&lt;/p&gt;

&lt;p&gt;그러나 GUIDO가 PEP를 작성하는 경우, 공정한 PEP 위임자(Delegate)가 선정되어 PEP를 수락하거나 거부할 권한이 부여되어야 합니다. GUIDO는 의사결정 과정에서 스스로를 제외(recuse)해야 합니다. 명확한 합의가 이루어지지 않는 논란이 많은 PEP의 경우, GUIDO가 작성한 PEP에 대한 최종 권한은 CoP에 있습니다.&lt;/p&gt;

&lt;p&gt;PEP 제안은 핵심 개발자가 항상 PEP Shepherd로 선택되어야 한다는 점에서 더욱 강화됩니다. 이 사람은 적절한 절차가 유지되도록 보장합니다. Shepherd는 핵심 개발자 중에서 선택되어야 합니다. 이는 누구든지 PEP를 작성할 수 있지만, 모든 PEP는 최소한 한 명의 핵심 개발자로부터 일정 수준의 후원을 받아야 함을 의미합니다.&lt;/p&gt;

&lt;h2 id=&quot;버전-기록&quot;&gt;버전 기록&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;버전 2&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;“기술 리더 거버넌스 모델(The Technical Leader Governance Model)”로 이름 변경&lt;/li&gt;
  &lt;li&gt;“단일 리더(singular leader)” -&amp;gt; “단일 기술 리더(singular technical leader)”&lt;/li&gt;
  &lt;li&gt;PEP 8001 투표 절차 채택은 해당 PEP가 승인될 때까지 잠정적임&lt;/li&gt;
  &lt;li&gt;GUIDO가 사임할 경우 발생하는 상황 설명&lt;/li&gt;
  &lt;li&gt;소환 투표는 핵심 개발자의 압도적 다수가 찬성해야 성공함&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;저작권&quot;&gt;저작권&lt;/h2&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인에 공개되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:27:12 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8010/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8010/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 8002 - Open Source Governance Survey</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8002/&quot;&gt;PEP 8002 - Open Source Governance Survey&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 24-Aug-2018&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-8002--오픈-소스-거버넌스-설문조사&quot;&gt;PEP 8002 – 오픈 소스 거버넌스 설문조사&lt;/h2&gt;

&lt;p&gt;이 문서는 Python Enhancement Proposal (PEP) 8002의 내용을 한국어 사용자가 이해하기 쉽게 번역하고 정리한 것입니다. Python 개발자들이 이 PEP의 제안 내용, 도입 배경, 그리고 실제 Python 사용에 미치는 영향을 명확하게 이해할 수 있도록 돕는 것을 목표로 합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;초록-abstract&quot;&gt;초록 (Abstract)&lt;/h3&gt;

&lt;p&gt;이 PEP는 기존의 유사한 오픈 소스 및 자유 소프트웨어 프로젝트들의 거버넌스 모델을 조사하고 요약하여 제공합니다. 이는 귀도 반 로섬(Guido van Rossum)의 은퇴 이후 Python의 새로운 거버넌스 모델을 선택하는 데 유용한 참고 자료가 될 것입니다. 각 커뮤니티 설문조사를 개별적인 PEP로 작성하는 대신, 이 PEP에 모든 내용을 모아 정리합니다.&lt;/p&gt;

&lt;h3 id=&quot;배경-rationale&quot;&gt;배경 (Rationale)&lt;/h3&gt;

&lt;p&gt;CPython은 거버넌스 위기를 겪는 첫 번째 오픈 소스 프로젝트가 아닙니다. 다른 프로젝트들도 존재 기간 동안 다양한 거버넌스 옵션을 실험했으며, 때로는 여러 번 변경하기도 했습니다. 이들의 경험에서 얻을 수 있는 유용한 교훈들이 Python의 의사 결정에 도움이 될 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;프로젝트-선택-project-choice&quot;&gt;프로젝트 선택 (Project Choice)&lt;/h3&gt;

&lt;p&gt;많은 오픈 소스 프로젝트가 있지만, CPython과 몇 가지 핵심 지표에서 충분히 유사한 프로젝트들을 조사하는 것이 가장 유익합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;기여자 수와 활동:&lt;/strong&gt; (매우 작은 프로젝트의 거버넌스 모델은 우리의 목적에 그다지 도움이 되지 않으므로 규모에 따른 문제가 있습니다.)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;대부분 또는 부분적으로 커뮤니티 주도:&lt;/strong&gt; (회사 주도 프로젝트는 회사의 계층 구조가 주요 참여자에게 권한을 가지므로 다른 거버넌스 옵션을 사용할 수 있습니다.)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다소 공식적인 의사 결정 과정이 필요한 중요한 설계 결정에 직면한 프로젝트:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;다음은 조사된 프로젝트들의 거버넌스 모델 요약입니다.&lt;/p&gt;

&lt;h3 id=&quot;rust&quot;&gt;Rust&lt;/h3&gt;

&lt;p&gt;Rust의 거버넌스 구조는 Rust RFC #1068에 문서화되어 있습니다. 효과적인 거버넌스 프로세스는 특히 일상적인 운영 세부 사항의 경우, RFC로 완전히 성문화되지 않고 시간이 지남에 따라 유기적으로 성장합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주요 인물 및 기능:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Rust 프로젝트에는 특정 영역을 담당하는 팀이 있습니다. 언어 기능에는 “lang team”이, 툴링에는 “dev tools” 및 “Cargo” 등이 있습니다.&lt;/li&gt;
  &lt;li&gt;논쟁의 여지가 있는 문제에는 논의를 이끄는 촉진자가 있으며, 이들은 종종 의사 결정자가 아닙니다.&lt;/li&gt;
  &lt;li&gt;기여자에게 가장 일반적인 역할은 팀 멤버십입니다.&lt;/li&gt;
  &lt;li&gt;새로운 팀 멤버는 기존 팀 멤버의 지명으로 추가됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;정규 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;주요 작업은 GitHub 이슈 및 Pull Request (PR)를 통해 이루어집니다.&lt;/li&gt;
  &lt;li&gt;모든 병합된 PR은 다음 Rust 안정 버전으로 반영됩니다.&lt;/li&gt;
  &lt;li&gt;IRC 및 Discord에서 공개 계획 및 분류(triage) 회의가 열리지만, 대부분의 작업이 GitHub를 통해 이루어지므로 인기가 많지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;논쟁의 여지가 있는 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;더 크거나 논쟁의 여지가 있는 작업은 RFC 프로세스를 거칩니다.&lt;/li&gt;
  &lt;li&gt;“최종 코멘트 기간(final comment period)”이 끝나면, 팀 멤버가 새로운 반대 의견을 제시하지 않는 한 RFC는 10일 후에 병합됩니다.&lt;/li&gt;
  &lt;li&gt;RFC가 “닫힘(closed)”으로 표시되면, 7일의 유예 기간 동안 닫아야 하는지 여부를 논의할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;새 릴리스 계획:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;6주마다 Rust 컴파일러가 릴리스됩니다.&lt;/li&gt;
  &lt;li&gt;몇 년에 한 번씩 “Edition”이라는 마일스톤 릴리스가 나옵니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;시간에 따른 프로세스 변화:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Rust는 Graydon Hoare에 의해 시작되었으며, Mozilla의 후원 후 Graydon은 BDFL과 같은 역할을 했지만, 2013년 프로젝트를 떠났습니다. 이후 Rust는 BDFL 없이 운영됩니다.&lt;/li&gt;
  &lt;li&gt;“최종 코멘트 기간” 개념은 더 많은 공개 토론을 장려하기 위해 도입되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;openstack&quot;&gt;OpenStack&lt;/h3&gt;

&lt;p&gt;OpenStack Foundation Bylaws는 프로젝트 거버넌스의 기본 구조를 명시하고 있으며, OpenStack Technical Committee (TC)에 일상적인 관리를 위임합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주요 인물 및 기능:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;OpenStack 커뮤니티는 여러 개의 고유한 프로젝트 팀으로 구성됩니다.&lt;/li&gt;
  &lt;li&gt;각 팀은 해당 프로젝트의 Active Project Contributors (APCs)가 선출한 Project Team Lead (PTL)가 이끌고 있습니다.&lt;/li&gt;
  &lt;li&gt;APCs는 OpenStack Foundation의 개별 멤버가 되고 지난 1년 내에 변경 사항을 병합한 기여자입니다.&lt;/li&gt;
  &lt;li&gt;PTL은 팀 내에서 합의에 도달하지 못하는 경우 최종 의사 결정자 역할을 합니다.&lt;/li&gt;
  &lt;li&gt;Technical Committee (TC)는 OpenStack 전체 개발 관리를 담당합니다. 13명의 TC 멤버는 모든 프로젝트 팀의 APC가 직접 선출합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;정규 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PTL 또는 TC 멤버 선거는 Condorcet 선거를 위해 https://civs.cs.cornell.edu를 사용합니다.&lt;/li&gt;
  &lt;li&gt;OpenStack 기여자 커뮤니티는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openstack-dev&lt;/code&gt; 메일링 리스트, gerrit 코드 리뷰 인스턴스, IRC 채널을 주요 논의 도구로 사용합니다.&lt;/li&gt;
  &lt;li&gt;단일 팀에 국한된 정책 결정은 일반적으로 프로젝트의 핵심 리뷰 팀이 내립니다.&lt;/li&gt;
  &lt;li&gt;모든 팀 정책 결정은 Technical Committee가 설정한 전체 정책과 호환되어야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;논쟁의 여지가 있는 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;논쟁적이거나 복잡한 결정은 메일링 리스트 토론으로 확장되는 경우가 많습니다.&lt;/li&gt;
  &lt;li&gt;PTL은 단일 팀에 영향을 미치는 결정에 대한 합의 도달 시점을 결정하고, 합의에 도달하지 못했을 때 최종 결정을 내릴 책임이 있습니다.&lt;/li&gt;
  &lt;li&gt;TC는 팀 간의 문제가 다른 방법으로 해결될 수 없는 경우, 최후의 수단으로서 유사한 의사 결정 그룹 역할을 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;새 릴리스 계획:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;OpenStack은 약 6개월마다 주요 릴리스를 합니다.&lt;/li&gt;
  &lt;li&gt;각 개발 주기(development cycle)의 일정은 릴리스 관리 팀이 제안합니다.&lt;/li&gt;
  &lt;li&gt;각 개발 주기의 우선순위 결정은 팀 수준과 TC 수준에서 이루어집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;시간에 따른 프로세스 변화:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;지난 8년 동안 OpenStack 프로젝트 팀의 수가 2개에서 63개로 증가했으며, TC 구성도 이러한 성장에 맞춰 변경되었습니다.&lt;/li&gt;
  &lt;li&gt;커뮤니티는 원래 프로젝트 팀이 아닌 “프로그램 영역(program areas)”을 중심으로 조직되었지만, 여러 팀이 다른 솔루션을 사용하여 동일한 기능 세트에서 작업하기를 원했을 때 실패했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jupyter&quot;&gt;Jupyter&lt;/h3&gt;

&lt;p&gt;Jupyter의 거버넌스 구조는 Jupyter Governance 저장소의 Main Governance Document에 문서화되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주요 인물 및 기능:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Jupyter 거버넌스의 핵심 인물은 BDFL(Benevolent Dictator For Life), Fernando Perez 및 Steering Council입니다.&lt;/li&gt;
  &lt;li&gt;Fernando Perez는 프로젝트 창립자이자 현재이자 첫 번째 BDFL입니다.&lt;/li&gt;
  &lt;li&gt;Core Contributor는 전문 분야 또는 서브 프로젝트 내에서 프로젝트의 최선의 이익을 위해 행동할 수 있는 커밋 권한과 같은 권한을 부여받은 개인입니다.&lt;/li&gt;
  &lt;li&gt;Steering Council 멤버로 추천 및 초청되려면, 개인이 품질과 양적으로 상당한 기여를 하고 최소 1년 이상 지속적으로 기여한 Project Contributor여야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;정규 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;주요 작업은 GitHub 이슈 및 Pull Request를 통해 이루어집니다.&lt;/li&gt;
  &lt;li&gt;주간 공개 프로젝트 전반 회의가 YouTube에 녹화되어 게시됩니다.&lt;/li&gt;
  &lt;li&gt;논의는 Gitter, Jupyter 메일링 리스트, 그리고 가장 자주 GitHub의 열린 이슈 및/또는 Pull Request에서 발생합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;논쟁의 여지가 있는 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Jupyter 프로젝트 거버넌스의 기반은 개방성(Openness &amp;amp; Transparency), 적극적인 기여(Active Contribution), 기관 중립성(Institutional Neutrality)입니다.&lt;/li&gt;
  &lt;li&gt;Steering Council은 일반적인 커뮤니티 논의가 합리적인 시간 내에 문제에 대한 합의를 생성하지 못할 때 결정을 내릴 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;투표 (Voting):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기술적 결정에 대한 투표는 거의 이루어지지 않습니다.&lt;/li&gt;
  &lt;li&gt;다른 프로젝트 이슈의 경우, Steering Council은 거버넌스 PR 또는 이메일 제안을 통해 결정에 대한 투표를 요청할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;BDFL은 변경 사항을 수락하거나 거부하거나 Steering Council의 결정을 재정의할 수 있지만, 이는 극히 드문 경우입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;릴리스 계획:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Jupyter 프로젝트는 단일 프로젝트가 아닌 여러 프로젝트로 구성되어 있으므로, 릴리스 계획은 주로 프로젝트의 핵심 기여자들이 주도합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;시간에 따른 프로세스 변화:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스는 시간이 지남에 따라 일관되게 유지되었으며, 이 접근 방식은 잘 작동했습니다.&lt;/li&gt;
  &lt;li&gt;이 거버넌스 모델은 방향의 변화라기보다는 프로젝트가 이미 수행하고 있던 것을 공식화한 것이었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;django&quot;&gt;Django&lt;/h3&gt;

&lt;p&gt;거버넌스 구조는 Django Project의 조직 문서에 설명되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주요 인물 및 기능:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트는 세 가지 종류의 기여자를 인정합니다: 핵심 팀 멤버, Technical Board, 그리고 Fellow.&lt;/li&gt;
  &lt;li&gt;Technical Board는 기술적 선택을 이끌어갑니다.&lt;/li&gt;
  &lt;li&gt;Fellow는 새로운 티켓을 분류하고, 커미터와 커뮤니티의 패치를 검토하고 병합하는 유급 계약자입니다.&lt;/li&gt;
  &lt;li&gt;Technical Board는 18개월마다 (모든 주요 Django 릴리스마다) 핵심 팀 멤버에 의해 선출됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;정규 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대부분의 일상적인 결정은 Fellows와 때로는 다른 활동적인 핵심 팀 멤버에 의해 이루어집니다.&lt;/li&gt;
  &lt;li&gt;핵심 팀은 신규 멤버에 대해 투표하며, 이는 투표의 4/5 과반수를 필요로 합니다. Technical Board는 거부권을 가집니다 (지금까지 행사된 적 없음).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;논쟁의 여지가 있는 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Technical Board는 때때로 Django Enhancement Proposals (DEPs)를 승인하지만, 이는 드뭅니다. DEP 프로세스는 PEP를 대략적으로 모델링하며 DEP 1에 문서화되어 있습니다.&lt;/li&gt;
  &lt;li&gt;합의에 도달할 수 없는 경우, Technical Board가 최종 결정권을 가집니다. 이는 행사된 적이 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;DEPs와 PEPs의 차이점:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;주요 차이점은 전체 워크플로가 이메일이 아닌 Pull Request를 기반으로 한다는 것입니다.&lt;/li&gt;
  &lt;li&gt;제출 전과 과정 전반에 걸쳐 핵심 역할이 식별되어야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shepherd&lt;/code&gt; 역할은 Technical Board의 개입 없이 DEP를 완료로 이끄는 역할을 합니다.&lt;/li&gt;
  &lt;li&gt;이러한 프로세스 변경은 BDFL 없는 거버넌스 모델에서 더 분산되고 실행 가능하게 만듭니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;새 릴리스 계획:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;릴리스는 고정된 시간 기반 일정에 따라 이루어지며, 18개월마다 주요 버전이 나옵니다.&lt;/li&gt;
  &lt;li&gt;유급 Fellow가 필요한 작업을 보장하여 정시 릴리스는 일상적입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;시간에 따른 프로세스 변화:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Django는 원래 두 명의 BDFL을 가졌습니다: Jacob Kaplan-Moss와 Adrian Holovaty. 그들은 프로젝트 역사 9년 만에 은퇴했습니다. 이들의 은퇴 이후 DEP 프로세스가 정의되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;typescript&quot;&gt;TypeScript&lt;/h3&gt;

&lt;p&gt;거버넌스 구조는 메인 TypeScript 저장소의 CONTRIBUTING.md 문서 외에는 외부적으로 문서화되어 있지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주요 인물 및 기능:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Microsoft에서 일하는 공식적인 설계 팀과 릴리스 관리 팀이 있습니다.&lt;/li&gt;
  &lt;li&gt;프로젝트의 주요 인물은 현재 Anders Hejlsberg입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;정규 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Microsoft는 강력한 계획 문화를 가지고 있어 개발 로드맵이 미리 발표되고, 설계 논의 노트가 빠르게 게시되며, 회의는 때때로 Skype를 사용하여 방송됩니다.&lt;/li&gt;
  &lt;li&gt;GitHub의 Pull Request를 통해 외부 기여가 장려됩니다.&lt;/li&gt;
  &lt;li&gt;소셜 미디어(트위터)에서도 논의가 이루어집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;논쟁의 여지가 있는 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Hejlsberg는 언어 설계 측면에서 프로젝트의 중심 인물이며, 커뮤니티의 요구 사항을 응집력 있는 전체로 통합합니다.&lt;/li&gt;
  &lt;li&gt;언어 설계에 외부적으로 기여하기 위한 공식적인 프로세스는 없습니다.&lt;/li&gt;
  &lt;li&gt;TypeScript 팀은 커뮤니티 제안을 필터링하고 통합합니다. 이 모델의 단점은 커뮤니티 참여가 Pull Request 및 제안으로 제한된다는 것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;새 릴리스 계획:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Microsoft가 릴리스 일정을 결정하고, 날짜와 기능을 미리 전달합니다.&lt;/li&gt;
  &lt;li&gt;버전별 릴리스는 1~3개월마다 이루어지며, GitHub에서 로드맵을 확인할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;시간에 따른 프로세스 변화:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TypeScript는 Microsoft가 완전히 공개적으로 개발한 최초의 주목할 만한 프로젝트일 것입니다.&lt;/li&gt;
  &lt;li&gt;프로젝트가 이동된 후 커뮤니티 참여가 크게 증가했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;astropy&quot;&gt;Astropy&lt;/h3&gt;

&lt;p&gt;Astropy 프로젝트 팀의 책임은 여러 다른 역할에 걸쳐 분포되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주요 인물 및 기능:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Astropy 프로젝트를 감독하는 주요 기관은 Astropy Coordination Committee (CoCo)입니다.&lt;/li&gt;
  &lt;li&gt;CoCo의 핵심 역할은 재정 문제 처리, Astropy 프로젝트에 참여하려는 새로운 패키지 승인, Astropy Proposals for Enhancement (APEs) 승인 또는 거부 등입니다.&lt;/li&gt;
  &lt;li&gt;위원회는 현재 4명의 멤버로 구성되어 있으며, 요구 사항에 따라 증가하거나 감소할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;정규 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;코드 수준 결정:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;각 서브 패키지에는 공식 유지 관리자(maintainer)와 한 명 이상의 대리인(deputies)이 있습니다.&lt;/li&gt;
      &lt;li&gt;코드 수준 결정은 GitHub 이슈 또는 Pull Request (PR)에서 일반적으로 합의를 기반으로 이루어집니다.&lt;/li&gt;
      &lt;li&gt;구체적인 의견 불일치가 있는 경우, 논의에 참여한 사람들의 다수결 투표로 결정되며, 동점 발생 시 CoCo가 개입합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비 코드 결정:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;비 코드 결정(스프린트 일정, 버그 수정 릴리스 시기 등)은 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;astropy-dev&lt;/code&gt; 메일링 리스트에 메시지 투표 형식으로 발표됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;투표:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;투표는 일반적으로 GitHub 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;astropy-dev&lt;/code&gt; 메일링 리스트에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+1/-1&lt;/code&gt; 형식을 사용합니다.&lt;/li&gt;
      &lt;li&gt;CoCo가 다수결 결정을 재정의할 수 있는 거부 메커니즘은 없습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;논쟁의 여지가 있는 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;간단한 논쟁적 결정은 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;astropy-dev&lt;/code&gt; 메일링 리스트에서 논의되며, 합리적인 시간 후에 명확한 합의/타협이 이루어지거나, CoCo가 정체를 피하기 위해 결정을 내립니다.&lt;/li&gt;
  &lt;li&gt;더 복잡한 결정은 PEP 프로세스를 모델링한 APE 프로세스를 따릅니다. 여기서는 모든 사람에게 공개된 토론 기간이 지난 후 CoCo가 최종 결정을 내립니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;윤리적 문제:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트에는 Code of Conduct 위반과 같은 민감한 문제에 대한 대체 연락처를 제공하는 옴부즈맨(Ombudsperson)이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;새 릴리스 계획:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;주요 릴리스 시기는 고정된 일정(6개월마다)에 따르며, 그 시점에 포함된 모든 것이 릴리스됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;시간에 따른 프로세스 변화:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CoCo와 “오픈 개발” 정신은 프로젝트 초기에 관심 있는 Python 지향 천문학자와 관련 소프트웨어 엔지니어들의 일련의 투표 후에 형성되었습니다.&lt;/li&gt;
  &lt;li&gt;공식적인 역할과 대부분의 다른 사항들은 커뮤니티가 성장함에 따라 진화적인 단계로 나타났습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;자기 평가 (Self-appreciation):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;시간이 있는 사람이라면 누구나 참여하여 제안하거나(보통 PR을 통해) 선호하는 것에 투표할 수 있다는 사실은 “우리는 모두 함께 한다”는 인식을 불러일으키며, 이는 더 잘 조정된 노력으로 이어집니다.&lt;/li&gt;
  &lt;li&gt;또한, CoCo가 주로 동점 해결 기관으로서 기능한다는 것은 자신의 의지를 강요하는 독재자의 느낌이 없으면서도, 완전한 민주적 거버넌스 모델을 경계하는 외부 조직에게 명확한 연락 지점을 제공합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;보너스-microsoft&quot;&gt;보너스: Microsoft&lt;/h3&gt;

&lt;p&gt;위에서 설명한 “관련 프로젝트” 선택 과정에도 불구하고, 재정적으로 의사 결정에 책임이 있는 회사들이 어떻게 결정을 내리는지 고려해 볼 가치가 있습니다. 이는 Python에 즉시 적용 가능한 모델이라기보다는 최종 설계나 선택에 영향을 미칠 수 있는 추가적인 통찰력으로 의도되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주요 인물 및 기능:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Microsoft는 궁극적으로 CEO에게 보고하는 계층 구조를 가지고 있습니다.&lt;/li&gt;
  &lt;li&gt;CEO 아래에는 여러 조직이 있으며, 일부는 엔지니어링 프로젝트에 중점을 둡니다. 이들은 Executive Vice Presidents (EVPs)가 이끌고 CEO에게 보고합니다.&lt;/li&gt;
  &lt;li&gt;각 EVP 아래에는 여러 Corporate Vice Presidents (CVPs)가 있으며, 각 CVP는 하나 이상의 제품을 담당합니다.&lt;/li&gt;
  &lt;li&gt;CVP 아래의 각 제품에는 Program Managers (PMs)와 Engineering Managers로 구성된 팀이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;정규 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;외부 사용자에게 보이지 않는 제품 코드 변경은 전적으로 엔지니어링 팀이 수행합니다.&lt;/li&gt;
  &lt;li&gt;특정 기능 사용자에게 영향을 미치는 결정은 해당 기능의 PM 팀이 내립니다.&lt;/li&gt;
  &lt;li&gt;CVP가 설정한 방향과 명확하게 일치하지 않는 결정은 논쟁의 여지가 있는 프로세스로 에스컬레이션됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;논쟁의 여지가 있는 의사 결정 과정:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;결정이 팀 간 조정을 요구하거나, 이전 CVP 지침과 명확하게 일치하지 않을 때, 팀은 의사 결정을 에스컬레이션합니다.&lt;/li&gt;
  &lt;li&gt;CVPs는 일반적으로 기능 팀 작업의 모든 측면에 대해 자세히 알지 못하므로, 기능 팀은 CVP가 추가 지식 없이 결정할 수 있도록 권장 사항과 충분한 맥락을 모두 제공해야 합니다.&lt;/li&gt;
  &lt;li&gt;CVPs가 내린 결정은 일반적으로 자의적이며 최종적이지만, 일반적으로 그들의 근거를 제공합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;새 릴리스 계획:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;릴리스는 여러 기능 팀을 조정하는 것을 포함하므로, 모든 팀의 입력을 포함하려고 시도하는 경우는 드뭅니다.&lt;/li&gt;
  &lt;li&gt;일정은 계획된 이벤트/컨퍼런스 또는 미디어 관심을 활용할 기회와 같은 광범위한 생태계 요구 사항에 따라 결정됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;부록-1-템플릿-질문-annex-1-template-questions&quot;&gt;부록 1: 템플릿 질문 (Annex 1: Template questions)&lt;/h3&gt;

&lt;p&gt;조사된 프로젝트 평가 및 상호 작용을 안내하는 템플릿으로 다음 질문 세트가 사용되었습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;거버넌스 모델이 어떻게 설정되었는지에 대한 공개 문서가 있습니까?&lt;/li&gt;
  &lt;li&gt;실제로 프로세스는 어떻게 진행됩니까?
    &lt;ul&gt;
      &lt;li&gt;주요 인물은 누구입니까?&lt;/li&gt;
      &lt;li&gt;기여자는 어떤 “특별한 지위”를 가질 수 있습니까? 어떻게 선출/지위가 할당됩니까?&lt;/li&gt;
      &lt;li&gt;정규 결정은 어떻게 이루어집니까?&lt;/li&gt;
      &lt;li&gt;논쟁의 여지가 있는 결정은 어떻게 이루어집니까?&lt;/li&gt;
      &lt;li&gt;투표 메커니즘이 있습니까? 어떻게 작동합니까? 투표는 실제로 얼마나 자주 발생합니까?&lt;/li&gt;
      &lt;li&gt;거부 메커니즘이 있습니까? 실제로 얼마나 자주 사용되었습니까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스는 어떻습니까?
    &lt;ul&gt;
      &lt;li&gt;어떤 부분이 잘 작동합니까?&lt;/li&gt;
      &lt;li&gt;어떤 부분이 더 잘 작동할 수 있습니까?&lt;/li&gt;
      &lt;li&gt;잘 작동하지 않을 때는 어떤 모습입니까?&lt;/li&gt;
      &lt;li&gt;전적으로 당신에게 달려 있다면 무엇을 바꾸겠습니까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관련 프로젝트 작업:
    &lt;ul&gt;
      &lt;li&gt;언제 릴리스가 이루어지고 무엇이 포함될지 어떻게 결정합니까?&lt;/li&gt;
      &lt;li&gt;누가 커밋 권한을 얻는지 어떻게 결정합니까?&lt;/li&gt;
      &lt;li&gt;어디에서 논의를 합니까? (GitHub, 메일링 리스트, 대면 회의 등)&lt;/li&gt;
      &lt;li&gt;RFC/PEP와 유사한 프로세스가 있습니까?&lt;/li&gt;
      &lt;li&gt;누가 해당 토론 채널에 액세스할 수 있습니까? 이 액세스는 어떻게 부여/취소됩니까?&lt;/li&gt;
      &lt;li&gt;누가 해당 토론을 중재합니까?&lt;/li&gt;
      &lt;li&gt;참가자를 검열합니까(어떻게)?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스 진화:
    &lt;ul&gt;
      &lt;li&gt;이 프로세스는 역사적으로 어떻게 진화했습니까?&lt;/li&gt;
      &lt;li&gt;미래에는 어떻게 변경될 수 있습니까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h3&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인에 공개되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:26:46 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8002/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8002/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 8001 - Python Governance Voting Process</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8001/&quot;&gt;PEP 8001 - Python Governance Voting Process&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Process&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 24-Aug-2018&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-8001--python-거버넌스-투표-절차-python-governance-voting-process&quot;&gt;PEP 8001 – Python 거버넌스 투표 절차 (Python Governance Voting Process)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;저자:&lt;/strong&gt; Brett Cannon 외 다수
&lt;strong&gt;상태:&lt;/strong&gt; Final (최종)
&lt;strong&gt;유형:&lt;/strong&gt; Process (절차)
&lt;strong&gt;주제:&lt;/strong&gt; Governance (거버넌스)
&lt;strong&gt;생성일:&lt;/strong&gt; 2018년 8월 24일&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;개요-abstract&quot;&gt;개요 (Abstract)&lt;/h3&gt;

&lt;p&gt;이 PEP는 귀도 반 로섬(Guido van Rossum)의 BDFL(Benevolent Dictator For Life) 역할 은퇴 이후, 새로운 Python 거버넌스 모델을 선정하는 과정을 설명합니다. 이 문서에 명시된 절차에 따라 모델이 선택되면, 해당 내용은 PEP 13에 공식적으로 명문화될 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;동기-및-배경-motivation-and-rationale&quot;&gt;동기 및 배경 (Motivation and Rationale)&lt;/h3&gt;

&lt;p&gt;Guido가 BDFL 역할에서 물러나면서, Python 프로젝트가 앞으로 어떻게 운영될지 결정하는 방법을 선택해야 하는 메타 문제가 발생했습니다. 이 문서는 이러한 선택을 할 수 있는 구체적인 제안을 제시하며, 2018년 9월 Redmond에서 열린 핵심 개발자 스프린트(core sprint) 워킹 그룹의 논의와 결론을 요약합니다. 또한, 이후 discuss.python.org에서 진행된 스레드(thread)의 내용도 포함합니다.&lt;/p&gt;

&lt;p&gt;거버넌스 상황은 신속하게 해결되어야 했습니다. 이상적으로는 2018년 말까지 완료되어 Python 3.8에 중요한 개선 사항이 통합될 수 있도록 해야 했으며, 늦어도 PyCon US 2019까지는 해결되어야 PR 위기를 피할 수 있었습니다.&lt;/p&gt;

&lt;h3 id=&quot;구현-implementation&quot;&gt;구현 (Implementation)&lt;/h3&gt;

&lt;h4 id=&quot;무엇을-투표하는가-what-are-we-voting-for&quot;&gt;무엇을 투표하는가? (What are we voting for?)&lt;/h4&gt;

&lt;p&gt;Python 프로젝트에 어떤 거버넌스 PEP를 구현할지 선택하기 위해 투표합니다. 후보 PEP 목록은 PEP 8000에 명시되어 있으며, 801X 범위의 모든 PEP들로 구성됩니다. 투표의 정당성을 보장하기 위해, 언급된 PEP들은 투표 기간 동안 수정되어서는 안 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;누가-투표할-수-있는가-who-gets-to-vote&quot;&gt;누가 투표할 수 있는가? (Who gets to vote?)&lt;/h4&gt;

&lt;p&gt;모든 CPython 핵심 개발자(core developer)는 투표에 초대됩니다. 투명성과 공정성을 위해, 핵심 개발자들이 거버넌스 상황이 자신에게 직접적인 영향을 미치는지 여부에 따라 자율적으로 판단하여 투표하도록 요청됩니다. 즉, 비활동적인 핵심 개발자 중 앞으로도 계속 비활동적으로 남을 의도가 있는 경우 투표를 자제할 것을 권장합니다.&lt;/p&gt;

&lt;h4 id=&quot;투표는-언제-진행되는가-when-is-the-vote&quot;&gt;투표는 언제 진행되는가? (When is the vote?)&lt;/h4&gt;

&lt;p&gt;2018년 11월 16일부터 11월 30일까지가 공식적인 거버넌스 PEP 검토 기간이었습니다. 이 논의 기간 동안 사소한 수정은 예상되지만, PEP 저자들이 중대한 실질적인 변경을 하는 것은 권장되지 않았습니다. 투표는 2018년 12월 1일부터 12월 16일까지 (Anywhere on Earth, AoE 기준으로) 2주 동안 진행되었습니다.&lt;/p&gt;

&lt;h4 id=&quot;투표는-어디서-진행되는가-where-is-the-vote&quot;&gt;투표는 어디서 진행되는가? (Where is the vote?)&lt;/h4&gt;

&lt;p&gt;투표는 Condorcet Internet Voting Service (CIVS)를 이용한 “비공개(private)” 설문 방식으로 진행되었습니다. 모든 커미터(committer)는 PEP들의 선호도 순위를 매길 수 있는 링크가 담긴 이메일을 받았습니다.&lt;/p&gt;

&lt;p&gt;선거는 PSF(Python Software Foundation) 인프라 디렉터인 Ee Durbin이 감독했습니다. 선거 결과는 익명화된 투표용지(ballots)를 포함하여, 선거 종료 후 12월 17일에 공개되었습니다.&lt;/p&gt;

&lt;p&gt;CIVS 시스템의 투표 설정은 다음과 같았습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;설문 이름:&lt;/strong&gt; Python governance vote (December 2018)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설문 설명:&lt;/strong&gt; Guido의 BDFL 은퇴 발표 이후 CPython 프로젝트가 스스로를 어떻게 거버넌스할지 선택하는 투표입니다.
    &lt;ul&gt;
      &lt;li&gt;모든 투표는 2018년 12월 16일 Anyware on Earth 기준으로 마감되어야 합니다.&lt;/li&gt;
      &lt;li&gt;모든 CPython 핵심 개발자는 투표 자격이 있습니다.&lt;/li&gt;
      &lt;li&gt;비활동적이며 앞으로도 비활동적으로 남을 의도가 있는 핵심 개발자는 투표를 자제할 것을 요청했습니다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;주의:&lt;/strong&gt; 투표는 한 번만 가능하며, 모든 투표는 최종입니다. “Submit ranking”을 클릭하면 변경할 수 없습니다.&lt;/li&gt;
      &lt;li&gt;모든 투표용지는 투표 종료 시점에 게시되지만, &lt;strong&gt;어떤 이름도 첨부되지 않습니다.&lt;/strong&gt; Python 프로젝트나 PSF와 관련된 누구도 투표자의 투표 방식이나 투표 여부를 알 수 없습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;후보 옵션:&lt;/strong&gt; 7개의 거버넌스 모델을 제안하는 PEP들과 “Further discussion” 옵션이 포함되었습니다. “Further discussion”은 현 시점에서 결정을 내리지 않고 논의를 계속하는 옵션을 의미했습니다. 투표자는 이 옵션을 다른 제안들보다 더 좋다고 생각하면 더 높은 순위를 매기고, 모든 제안이 “Further discussion”보다 낫다고 생각하면 “Further discussion”을 가장 낮은 순위에 두도록 했습니다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://peps.python.org/pep-8010/&quot;&gt;PEP 8010: The Technical Leader Governance Model&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://peps.python.org/pep-8011/&quot;&gt;PEP 8011: Python Governance Model Lead by Trio of Pythonistas&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://peps.python.org/pep-8012/&quot;&gt;PEP 8012: The Community Governance Model&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://peps.python.org/pep-8013/&quot;&gt;PEP 8013: The External Council Governance Model&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://peps.python.org/pep-8014/&quot;&gt;PEP 8014: The Commons Governance Model&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://peps.python.org/pep-8015/&quot;&gt;PEP 8015: Organization of the Python community&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://peps.python.org/pep-8016/&quot;&gt;PEP 8016: The Steering Council Model&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Further discussion (추가 논의)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CIVS 시스템 설정 결과:&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;선거는 “비공개(private)”, 즉 초대 전용으로 진행되었습니다.&lt;/li&gt;
      &lt;li&gt;선거 결과는 모든 투표자에게 공개되었습니다.&lt;/li&gt;
      &lt;li&gt;모든 투표용지의 내용과 당선자 결정 방법에 대한 상세 보고서가 대중에게 공개되었습니다.&lt;/li&gt;
      &lt;li&gt;상세 투표용지에는 어떠한 식별 정보도 포함되지 않았으며, CIVS 시스템은 투표 링크가 포함된 이메일이 발송되는 즉시 투표자의 이메일 주소를 폐기했습니다.&lt;/li&gt;
      &lt;li&gt;투표자들은 새로운 선택지를 기입할 수 없었으며, 선거에 지정된 옵션으로만 제한되었습니다.&lt;/li&gt;
      &lt;li&gt;투표자들은 투표 후 자신의 투표를 변경할 수 없었습니다.&lt;/li&gt;
      &lt;li&gt;각 투표용지의 기본 순서는 투표 순서가 선거에 미칠 수 있는 영향을 제거하기 위해 무작위화되었습니다.&lt;/li&gt;
      &lt;li&gt;투표자들은 모든 선택지에 순위를 매겨야 했지만, 여러 선택지에 동일한 순위를 매길 수 있었습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;투표-방식-voting-mechanics&quot;&gt;투표 방식 (Voting mechanics)&lt;/h4&gt;

&lt;p&gt;투표는 순위 투표(ranked ballot) 방식으로 진행됩니다. 각 투표자는 모든 후보 PEP를 가장 선호하는 것부터 가장 덜 선호하는 것까지 순서대로 정렬합니다. 투표는 콘도르세 방식(Condorcet method)을 사용하여 집계되고 당선자가 선택됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고:&lt;/strong&gt; 각 투표자는 단 한 번의 투표만 할 수 있으며, 이후 투표를 수정할 수 없습니다. 선택에 대해 확실하지 않은 경우, 투표 기간의 후반까지 투표를 보류하는 것이 권장됩니다.&lt;/p&gt;

&lt;p&gt;CIVS 시스템은 “순수한(Pure)” 콘도르세 선거 옵션을 제공하지 않지만, 어떤 콘도르세 방식이든 “순수한” 콘도르세 당선자가 존재하면 그 당선자를 선택하며, 존재하지 않는 경우에만 달라집니다. CIVS 시스템은 당선자가 콘도르세 당선자인지, 아니면 단순히 다른 어떤 옵션에 의해서도 패배하지 않았는지를 명시하여 이를 구분합니다. 따라서 CIVS 시스템에서 당선자는 콘도르세 당선자로 명시될 때만 수용됩니다.&lt;/p&gt;

&lt;p&gt;동점(tie)이나 순환(cycle)이 발생하는 드문 경우(콘도르세 방식에서 가능함), 동점이나 순환에 관련된 옵션으로 제한된 새로운 선거가 열려 새로운 당선자를 선택합니다. 이 새로운 선거는 일주일 동안 진행되며, 단일 당선자가 결정될 때까지 반복됩니다.&lt;/p&gt;

&lt;h3 id=&quot;질문-및-답변-questions-and-answers&quot;&gt;질문 및 답변 (Questions and Answers)&lt;/h3&gt;

&lt;h4 id=&quot;콘도르세-방식을-채택한-이유는-무엇인가-why-the-condorcet-method&quot;&gt;콘도르세 방식을 채택한 이유는 무엇인가? (Why the Condorcet method?)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;투표자들이 PEP들의 순위를 매겨 선호도를 표현할 수 있도록 합니다.&lt;/li&gt;
  &lt;li&gt;합의(consensus) 의사 결정 방식입니다.&lt;/li&gt;
  &lt;li&gt;핵심 개발자만을 대상으로 승인 투표(Approval voting) 방식으로 진행된 설문에서, 이 방식이 명확한 선호도를 보였습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;순위-매김에서-일부-후보-pep를-제외하는-것이-허용되는가-is-omitting-any-candidate-peps-in-the-ranking-allowed&quot;&gt;순위 매김에서 일부 후보 PEP를 제외하는 것이 허용되는가? (Is omitting any candidate PEPs in the ranking allowed?)&lt;/h4&gt;

&lt;p&gt;순위 매김에서 후보를 제외하는 투표는 유효하지 않습니다. 이러한 투표는 위에서 언급된 바람직한 특성(투표자들이 대안을 고려하고, 단일 선거에서 결론에 도달하기 위해 가능한 모든 것을 하는 것)과 양립할 수 없기 때문입니다.&lt;/p&gt;

&lt;h4 id=&quot;비활동적인-핵심-개발자가-투표하지-않도록-권장하는-이유는-무엇인가-why-recommend-for-dormant-core-developers-to-not-vote&quot;&gt;비활동적인 핵심 개발자가 투표하지 않도록 권장하는 이유는 무엇인가? (Why recommend for dormant core developers to not vote?)&lt;/h4&gt;

&lt;p&gt;거버넌스 모델의 선택은 Python과 커뮤니티에 광범위하고 장기적인 영향을 미칠 것입니다. 핵심 개발자들에게 그들의 “피부(skin in the game)”를 평가하도록 요청하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고:&lt;/strong&gt; 이는 명령이 아니며, 강제되지 않습니다. 모든 핵심 팀 구성원이 Python의 최선의 이익을 위해 행동할 것이라고 신뢰합니다.&lt;/p&gt;

&lt;h4 id=&quot;투표가-비공개여야-하는-이유는-무엇인가-why-should-the-vote-be-private&quot;&gt;투표가 비공개여야 하는 이유는 무엇인가? (Why should the vote be private?)&lt;/h4&gt;

&lt;p&gt;선거 시스템을 논의할 때, 여러 핵심 개발자들이 공개 투표용지(public ballots)에 대한 우려를 표명했으며, 적어도 한 명의 핵심 개발자는 공개 투표용지 사용 때문에 아예 투표를 기권할 계획이라고 밝혔습니다. Discourse에서 진행된 설문 조사에서는 대다수의 투표자들이 비공개 투표용지를 선호한다는 것이 확인되었습니다.&lt;/p&gt;

&lt;p&gt;비밀 투표(secret ballot)는 많은 이들에게 자유롭고 공정한 선거의 필수 요건으로 간주되며, 사회적 압력이나 투표 방식에 따른 잠재적 파급 효과에 대한 걱정 없이 구성원들이 자신의 진정한 선호도를 투표할 수 있도록 합니다.&lt;/p&gt;

&lt;h4 id=&quot;civs를-사용하는-이유는-무엇인가-why-the-use-of-civs&quot;&gt;CIVS를 사용하는 이유는 무엇인가? (Why the use of CIVS?)&lt;/h4&gt;

&lt;p&gt;이 PEP의 논의 결과, 핵심 개발자들은 비밀 투표를 원했습니다. 불행히도 비밀 투표는 새로운 암호화 기술(novel cryptography) 또는 투표용지를 익명화할 신뢰할 수 있는 제3자(trusted party)를 필요로 합니다. 콘도르세 투표용지를 위한 기존의 새로운 암호화 시스템은 알려진 바가 없으므로, CIVS 시스템이 신뢰할 수 있는 제3자 역할을 하도록 선택되었습니다.&lt;/p&gt;

&lt;p&gt;악의적인 투표자, 선거 감독관 또는 CIVS 관리자가 선거에 어떻게 영향을 미칠 수 있는지 등 CIVS가 제공하는 보안 및 개인 정보 보호에 대한 자세한 정보는 &lt;a href=&quot;http://condorcet.org/civs/info.html&quot;&gt;CIVS 웹사이트&lt;/a&gt;에서 찾을 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;투표자가-투표를-변경할-수-없는-이유는-무엇인가-why-cannot-voters-change-their-vote&quot;&gt;투표자가 투표를 변경할 수 없는 이유는 무엇인가? (Why cannot voters change their vote?)&lt;/h4&gt;

&lt;p&gt;CIVS는 투표자가 투표를 업데이트하는 것을 허용하지 않으며, 이는 선거 감독관이 투표에 영향을 미치는 것을 방지하려는 목표의 일환입니다.&lt;/p&gt;

&lt;h4 id=&quot;콘도르세-방식에-결함은-없는가-are-there-any-deficiencies-in-the-condorcet-method&quot;&gt;콘도르세 방식에 결함은 없는가? (Are there any deficiencies in the Condorcet method?)&lt;/h4&gt;

&lt;p&gt;완벽한 투표 방법은 없습니다. 기버드-새터스웨이트 정리(Gibbard-Satterthwaite theorem)에 따르면, 독재적이지 않은 단일 당선자 순위 투표 방식은 소위 “전략적 투표(tactical voting)”에 취약할 수 있습니다. 이는 사람들이 결과에 영향을 미치기 위해 자신의 진정한 신념대로 투표하지 않을 수 있습니다.&lt;/p&gt;

&lt;p&gt;콘도르세 방식은 또한 순환(cycles) 가능성(콘도르세 역설, Condorcet paradox)을 가집니다. 콘도르세 방식이 일대일 대결에서 다른 옵션을 이길 수 있는지 여부에 따라 당선자를 선택하기 때문에, PEP A &amp;gt; PEP B &amp;gt; PEP C &amp;gt; PEP A와 같은 순환이 발생할 수 있습니다 (가위바위보 게임에서 세 명의 플레이어가 각각 바위, 보, 가위를 냈을 때 누구도 이기지 못하는 상황과 유사). 21명 이상의 투표자가 참여한 실제 선거 데이터 분석 결과에 따르면, 순환은 1.5% 미만으로 발생했습니다.&lt;/p&gt;

&lt;h3 id=&quot;참고-자료-references&quot;&gt;참고 자료 (References)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://discuss.python.org/t/pep-8001-public-or-private-ballots/374/20&quot;&gt;discuss.python.org 스레드&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://discuss.python.org/t/pep-8001-public-or-private-ballots/374/4&quot;&gt;비공개 투표에 대한 논의&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h3&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:25:35 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8001/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8001/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 8000 - Python Language Governance Proposal Overview</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-8000/&quot;&gt;PEP 8000 - Python Language Governance Proposal Overview&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 24-Aug-2018&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;pep-8000--python-언어-거버넌스-제안-개요&quot;&gt;PEP 8000 – Python 언어 거버넌스 제안 개요&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Barry Warsaw &lt;barry at=&quot;&quot; python.org=&quot;&quot;&gt;&lt;/barry&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final (최종)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational (정보성)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주제:&lt;/strong&gt; Governance (거버넌스)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;생성일:&lt;/strong&gt; 2018년 8월 24일&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;초록-abstract&quot;&gt;초록 (Abstract)&lt;/h2&gt;

&lt;p&gt;이 PEP는 Guido van Rossum의 은퇴 이후 새로운 파이썬 언어 거버넌스 모델 선정을 위한 과정에 대한 개요를 제공합니다. 거버넌스 모델이 선정되면, 해당 모델은 PEP 13에 공식적으로 명시될 예정입니다.&lt;/p&gt;

&lt;p&gt;다음은 거버넌스 모델 선정 과정과 관련된 PEP 목록입니다. 8000번대 초반의 PEP들은 거버넌스 모델 선정의 일반적인 과정을 설명합니다.&lt;/p&gt;

&lt;h2 id=&quot;거버넌스-모델-선정-관련-peps&quot;&gt;거버넌스 모델 선정 관련 PEPs&lt;/h2&gt;

&lt;h3 id=&quot;pep-8001---python-거버넌스-투표-절차-python-governance-voting-process&quot;&gt;PEP 8001 - Python 거버넌스 투표 절차 (Python Governance Voting Process)&lt;/h3&gt;

&lt;p&gt;이 PEP는 새로운 거버넌스 모델 투표가 어떻게 진행될지 설명합니다. 투표 방식, 일정, 참여 자격 기준, 그리고 투표 자격이 있는 유권자 명단을 명시합니다.&lt;/p&gt;

&lt;h3 id=&quot;pep-8002---오픈-소스-거버넌스-설문조사-open-source-governance-survey&quot;&gt;PEP 8002 - 오픈 소스 거버넌스 설문조사 (Open Source Governance Survey)&lt;/h3&gt;

&lt;p&gt;유사한 오픈 소스 및 자유 소프트웨어 프로젝트의 거버넌스 모델에 대한 설문조사가 실시될 예정이며, 이 모델들의 요약이 이 PEP에 설명될 것입니다. 이 설문조사는 프로젝트가 성공적으로 거버넌스될 수 있는 방법에 대한 유용한 지표 역할을 하며, 파이썬 자체의 거버넌스 모델에 영감을 줄 수 있습니다. 파이썬은 독특하므로, 조사된 모델을 직접 채택하기보다는 자체적인 거버넌스 방식을 가질 것으로 예상됩니다.&lt;/p&gt;

&lt;p&gt;801X번대의 PEP들은 파이썬 거버넌스에 대한 실제 제안들을 설명합니다. 이러한 PEP들은 거버넌스의 광범위한 범위를 다루고, (거버닝 위원회의 규모와 같은) 세부 사항의 차이는 잠재적으로 표가 분산될 수 있는 개별 PEP가 아닌 동일한 PEP 내에서 다루어질 것으로 예상됩니다.&lt;/p&gt;

&lt;h3 id=&quot;pep-8010---기술-리더-거버넌스-모델-the-technical-leader-governance-model&quot;&gt;PEP 8010 - 기술 리더 거버넌스 모델 (The Technical Leader Governance Model)&lt;/h3&gt;

&lt;p&gt;이 PEP는 단일 기술 프로젝트 리더 모델의 지속을 제안합니다. 자문 위원회가 BDFL(Benevolent Dictator For Life)을 돕거나 지원하는지 여부도 범위 내에 포함됩니다. 이 PEP는 다음 BDFL이나 그러한 자문 위원회의 구성원을 명시하지 않습니다. 이에 대해서는 PEP 13을 참조하십시오.&lt;/p&gt;

&lt;h3 id=&quot;pep-8011---파이썬-개발자-3인조-주도-파이썬-거버넌스-모델-python-governance-model-lead-by-trio-of-pythonistas&quot;&gt;PEP 8011 - 파이썬 개발자 3인조 주도 파이썬 거버넌스 모델 (Python Governance Model Lead by Trio of Pythonistas)&lt;/h3&gt;

&lt;p&gt;이 PEP는 파이썬 개발자 3인조(Trio of Pythonistas, TOP)가 이끄는 새로운 파이썬 거버넌스 모델을 설명합니다. 이는 Trio의 역할과 책임을 설명합니다. 이 PEP는 Trio의 구성원을 명시하지 않습니다. 이에 대해서는 PEP 13을 참조하십시오.&lt;/p&gt;

&lt;h3 id=&quot;pep-8012---커뮤니티-거버넌스-모델-the-community-governance-model&quot;&gt;PEP 8012 - 커뮤니티 거버넌스 모델 (The Community Governance Model)&lt;/h3&gt;

&lt;p&gt;이 PEP는 중앙 집중식 단일 리더 또는 거버닝 위원회의 역할 없이 합의와 투표에 기반한 새로운 파이썬 거버넌스 모델에 대한 임시 제안입니다. 파이썬 언어에 영향을 미치는 결정에 대한 투표가 어떻게, 언제, 왜 진행되는지 설명합니다. 또한 투표 자격 기준도 설명합니다.&lt;/p&gt;

&lt;h3 id=&quot;pep-8013---외부-거버넌스-모델-the-external-governance-model&quot;&gt;PEP 8013 - 외부 거버넌스 모델 (The External Governance Model)&lt;/h3&gt;

&lt;p&gt;이 PEP는 좋은 프로세스를 보장할 책임이 있는 외부 위원회에 기반한 새로운 파이썬 거버넌스 모델을 설명합니다. 핵심 개발팀에 의해 선출된 이 위원회는 충분히 자세하지 않거나, 영향을 받는 모든 사용자를 고려하지 않거나, 다가오는 릴리스에 적합하지 않은 제안을 거부할 수 있습니다. 이 PEP는 그러한 위원회의 구성원을 명시하지 않습니다. 이에 대해서는 PEP 13을 참조하십시오.&lt;/p&gt;

&lt;h3 id=&quot;pep-8014---커먼즈-거버넌스-모델-the-commons-governance-model&quot;&gt;PEP 8014 - 커먼즈 거버넌스 모델 (The Commons Governance Model)&lt;/h3&gt;

&lt;p&gt;이 PEP는 PEP가 수용되기 전에 파이썬 커뮤니티의 충분한 다수 지지를 받도록 보장할 책임이 있는 원로 위원회에 기반한 새로운 파이썬 거버넌스 모델을 설명합니다. 다른 거버넌스 PEP들과 달리, 이 모델은 명시적으로 누가 투표권을 가지며 다수결 투표가 무엇을 의미하는지 지정하지 않습니다. 대신 이는 원로 위원회에 의해 사례별로 결정됩니다.&lt;/p&gt;

&lt;h3 id=&quot;pep-8015---파이썬-커뮤니티의-조직-organization-of-the-python-community&quot;&gt;PEP 8015 - 파이썬 커뮤니티의 조직 (Organization of the Python community)&lt;/h3&gt;

&lt;p&gt;이 PEP는 파이썬 커뮤니티의 현재 조직을 공식화하고 세 가지 주요 변경 사항을 제안합니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;“Python 팀”이라는 기존 개념을 공식화합니다.&lt;/li&gt;
  &lt;li&gt;Python 팀에 더 많은 자율성을 부여합니다.&lt;/li&gt;
  &lt;li&gt;BDFL(Guido van Rossum)을 3명의 새로운 “Python 보드”로 대체하며, 이 보드는 제한된 역할을 가지며 주로 PEP 승인(또는 거부) 방식을 결정합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;pep-8016---스티어링-위원회-모델-the-steering-council-model&quot;&gt;PEP 8016 - 스티어링 위원회 모델 (The Steering Council Model)&lt;/h3&gt;

&lt;p&gt;이 PEP는 스티어링 위원회(Steering Council)를 중심으로 한 파이썬 거버넌스 모델을 제안합니다. 위원회는 광범위한 권한을 가지지만, 가능한 한 드물게 이 권한을 행사하려고 합니다. 대신 이 권한을 사용하여 다른 801X 시리즈 PEP에서 제안된 것과 같은 표준 프로세스를 확립합니다. 이는 큰 변경 사항을 독립적으로 검토할 수 있는 일련의 작은 변경 사항으로 나누는 것이 더 낫다는 일반적인 철학을 따릅니다. 즉, 하나의 PEP에서 모든 것을 시도하는 대신, 추가 거버넌스 결정을 위한 최소한이지만 견고한 기반을 제공하는 데 중점을 둡니다.&lt;/p&gt;

&lt;p&gt;최종 선택 전에 추가 거버넌스 모델이 추가될 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h2&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인에 공개되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:25:09 +0900</pubDate>
        <link>http://localhost:4000/python/pep/8000/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/8000/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 3333 - Python Web Server Gateway Interface v1.0.1</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3333/&quot;&gt;PEP 3333 - Python Web Server Gateway Interface v1.0.1&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Informational&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 26-Sep-2010&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;PEP 3333 – Python Web Server Gateway Interface v1.0.1 번역 및 요약&lt;/p&gt;

&lt;h2 id=&quot;서문-pep-333-독자를-위한&quot;&gt;서문 (PEP 333 독자를 위한)&lt;/h2&gt;

&lt;p&gt;이 문서는 기존 PEP 333의 업데이트된 버전으로, Python 3에서의 사용성을 개선하고, WSGI 프로토콜에 대한 몇 가지 오랜 사실상의 개정 사항을 통합하기 위해 약간 수정되었습니다. 코드 샘플 또한 Python 3에 맞춰 포팅되었습니다.&lt;/p&gt;

&lt;p&gt;절차상의 이유로 별도의 PEP로 지정되었지만, Python 2.x 환경에서 기존의 규격 준수 서버나 애플리케이션의 유효성을 무효화하는 변경 사항은 없습니다. 만약 2.x 애플리케이션 또는 서버가 PEP 333을 준수한다면, 이 PEP 또한 준수하는 것입니다.&lt;/p&gt;

&lt;p&gt;하지만 Python 3 환경에서는 애플리케이션 또는 서버가 “문자열 타입에 대한 참고 사항(A Note On String Types)” 및 “유니코드 문제(Unicode Issues)” 섹션에 명시된 규칙도 따라야 합니다.&lt;/p&gt;

&lt;p&gt;이 문서와 PEP 333 간의 자세한 변경 사항은 SVN 개정 기록 (개정 84854부터)에서 확인할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;

&lt;p&gt;이 문서는 다양한 웹 서버에서 웹 애플리케이션의 이식성을 증진하기 위해 웹 서버와 Python 웹 애플리케이션 또는 프레임워크 간의 표준 인터페이스를 제안합니다.&lt;/p&gt;

&lt;h2 id=&quot;wsgi의-도입-배경-및-목표-pep-333에서-발췌&quot;&gt;WSGI의 도입 배경 및 목표 (PEP 333에서 발췌)&lt;/h2&gt;

&lt;p&gt;현재 Python은 Zope, Quixote, Webware, SkunkWeb, PSO, Twisted Web 등 다양한 웹 애플리케이션 프레임워크를 자랑합니다. 이러한 선택의 폭은 새로운 Python 사용자에게 문제가 될 수 있습니다. 일반적으로 웹 프레임워크의 선택이 사용 가능한 웹 서버의 선택을 제한하고, 그 반대도 마찬가지이기 때문입니다.&lt;/p&gt;

&lt;p&gt;대조적으로, Java는 비슷한 수의 웹 애플리케이션 프레임워크가 있지만, Java의 “servlet” API 덕분에 어떤 Java 웹 애플리케이션 프레임워크로 작성된 애플리케이션이든 servlet API를 지원하는 모든 웹 서버에서 실행될 수 있습니다.&lt;/p&gt;

&lt;p&gt;Python 웹 서버 (Python으로 작성된 Medusa, Python을 내장한 mod_python, 또는 CGI, FastCGI 등 게이트웨이 프로토콜을 통해 Python을 호출하는 서버 등)에서 이러한 API가 널리 사용 가능해진다면, 프레임워크 선택과 웹 서버 선택이 분리되어 사용자는 자신에게 적합한 조합을 자유롭게 선택할 수 있게 될 것입니다. 또한 프레임워크 및 서버 개발자는 각자의 전문 분야에 집중할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;따라서 이 PEP는 웹 서버와 웹 애플리케이션 또는 프레임워크 간의 간단하고 범용적인 인터페이스인 &lt;strong&gt;Python Web Server Gateway Interface (WSGI)&lt;/strong&gt;를 제안합니다.&lt;/p&gt;

&lt;p&gt;WSGI 사양의 존재만으로는 Python 웹 애플리케이션을 위한 기존 서버 및 프레임워크의 상태를 해결할 수 없습니다. 효과를 얻으려면 서버 및 프레임워크 개발자가 실제로 WSGI를 구현해야 합니다.&lt;/p&gt;

&lt;p&gt;하지만 현재 WSGI를 지원하는 서버나 프레임워크가 없기 때문에, WSGI를 구현하는 개발자에게는 즉각적인 보상이 거의 없습니다. 따라서 WSGI는 구현하기 쉬워야 하며, 개발자의 초기 인터페이스 투자 비용이 합리적으로 낮을 수 있도록 해야 합니다.&lt;/p&gt;

&lt;p&gt;이러한 이유로, 인터페이스의 서버 및 프레임워크 양쪽에서 &lt;strong&gt;구현의 단순성&lt;/strong&gt;은 WSGI 인터페이스의 유용성에 절대적으로 중요하며, 모든 설계 결정의 주요 기준이 됩니다.&lt;/p&gt;

&lt;p&gt;다만, 프레임워크 개발자에게 구현의 단순성이 웹 애플리케이션 개발자에게 사용의 용이성과 같지는 않다는 점에 유의해야 합니다. WSGI는 응답 객체 및 쿠키 처리와 같은 부가 기능이 기존 프레임워크의 문제 처리 방식에 방해가 될 수 있으므로, 프레임워크 개발자에게는 “꾸밈없는(no frills)” 인터페이스를 제공합니다. WSGI의 목표는 새로운 웹 프레임워크를 만드는 것이 아니라, 기존 서버와 애플리케이션 또는 프레임워크 간의 쉬운 상호 연결을 촉진하는 것입니다.&lt;/p&gt;

&lt;p&gt;또한 이 목표는 WSGI가 현재 배포된 Python 버전에서 이미 사용할 수 없는 것을 요구하는 것을 배제합니다. 따라서 새로운 표준 라이브러리 모듈은 이 사양에서 제안되거나 요구되지 않으며, WSGI는 Python 2.2 이상의 버전을 요구하지 않습니다. (그러나 향후 Python 버전에서 표준 라이브러리에 의해 제공되는 웹 서버에서 이 인터페이스에 대한 지원을 포함하는 것이 좋습니다.)&lt;/p&gt;

&lt;p&gt;기존 및 미래의 프레임워크 및 서버의 구현 용이성 외에도, 요청 전처리기, 응답 후처리기 및 기타 WSGI 기반 “미들웨어(middleware)” 구성 요소를 쉽게 생성할 수 있어야 합니다. 이러한 구성 요소는 상위 서버에게는 애플리케이션처럼 보이고, 하위 애플리케이션에게는 서버 역할을 수행합니다.&lt;/p&gt;

&lt;p&gt;미들웨어가 간단하고 견고하며 WSGI가 서버 및 프레임워크에서 널리 사용 가능하다면, 완전히 새로운 종류의 Python 웹 애플리케이션 프레임워크(느슨하게 결합된 WSGI 미들웨어 구성 요소로 구성된)의 가능성을 열어줄 수 있습니다. 심지어 기존 프레임워크 개발자들은 자신들의 프레임워크의 기존 서비스를 이러한 방식으로 제공하도록 리팩터링하여, 모놀리식 프레임워크보다는 WSGI와 함께 사용되는 라이브러리에 더 가깝게 만들 수 있습니다. 이렇게 되면 애플리케이션 개발자는 단일 프레임워크의 모든 장단점에 얽매이지 않고 특정 기능에 대해 “최고의 구성 요소”를 선택할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;물론, 이 글이 작성되는 시점에는 그 날이 아직 멀리 떨어져 있습니다. 그동안 WSGI의 충분한 단기 목표는 모든 프레임워크가 모든 서버에서 사용될 수 있도록 하는 것입니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 현재 버전의 WSGI는 웹 서버 또는 서버 게이트웨이와 함께 사용할 애플리케이션 “배포(deploying)”를 위한 특정 메커니즘을 규정하지 않습니다. 현재로서는 이는 서버 또는 게이트웨이에 의해 구현 정의됩니다. 충분한 수의 서버 및 프레임워크가 WSGI를 구현하여 다양한 배포 요구 사항에 대한 현장 경험을 제공한 후에는 WSGI 서버 및 애플리케이션 프레임워크를 위한 배포 표준을 설명하는 또 다른 PEP를 만드는 것이 합리적일 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;사양-개요&quot;&gt;사양 개요&lt;/h2&gt;

&lt;p&gt;WSGI 인터페이스는 “서버” 또는 “게이트웨이” 측과 “애플리케이션” 또는 “프레임워크” 측의 두 가지 측면을 가지고 있습니다. 서버 측은 애플리케이션 측에서 제공하는 호출 가능한 객체(callable object)를 호출합니다. 이 객체가 제공되는 구체적인 방법은 서버 또는 게이트웨이에 달려 있습니다. 일부 서버 또는 게이트웨이는 애플리케이션 배포자가 서버 또는 게이트웨이 인스턴스를 생성하고 애플리케이션 객체를 제공하기 위한 짧은 스크립트를 작성해야 할 것으로 예상됩니다. 다른 서버 및 게이트웨이는 구성 파일 또는 다른 메커니즘을 사용하여 애플리케이션 객체를 어디에서 가져오거나 얻을지 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;“순수한” 서버/게이트웨이 및 애플리케이션/프레임워크 외에도, 이 사양의 양측을 모두 구현하는 “미들웨어(middleware)” 구성 요소를 생성하는 것도 가능합니다. 이러한 구성 요소는 상위 서버에게는 애플리케이션으로 작동하고, 내장된 애플리케이션에게는 서버로 작동하며, 확장된 API, 콘텐츠 변환, 탐색 및 기타 유용한 기능을 제공하는 데 사용될 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 사양 전체에서 “호출 가능한 객체(a callable)”라는 용어는 “함수, 메서드, 클래스, 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__call__&lt;/code&gt; 메서드를 가진 인스턴스”를 의미합니다. 호출 가능한 객체를 구현하는 서버, 게이트웨이 또는 애플리케이션은 자신의 필요에 맞는 적절한 구현 기술을 선택해야 합니다. 반대로, 호출 가능한 객체를 호출하는 서버, 게이트웨이 또는 애플리케이션은 제공된 호출 가능한 객체의 종류에 의존해서는 안 됩니다. 호출 가능한 객체는 호출만 되어야 하며, 내부를 검사해서는 안 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;문자열-타입에-대한-참고-사항-a-note-on-string-types&quot;&gt;문자열 타입에 대한 참고 사항 (A Note On String Types)&lt;/h3&gt;

&lt;p&gt;일반적으로 HTTP는 바이트(bytes)를 다루므로, 이 사양은 주로 바이트 처리에 관한 것입니다. 그러나 이러한 바이트의 내용은 종종 어떤 종류의 텍스트 해석을 가지며, Python에서는 문자열이 텍스트를 처리하는 가장 편리한 방법입니다.&lt;/p&gt;

&lt;p&gt;하지만 많은 Python 버전 및 구현에서 문자열은 바이트가 아닌 유니코드입니다. 이는 HTTP 컨텍스트에서 바이트와 텍스트 간의 올바른 변환과 사용 가능한 API 사이의 신중한 균형을 요구합니다. 특히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 타입이 다른 Python 구현 간에 코드를 이식할 때 중요합니다.&lt;/p&gt;

&lt;p&gt;따라서 WSGI는 두 가지 종류의 “문자열”을 정의합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;“Native” strings&lt;/strong&gt; (항상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 타입으로 구현됨): 요청/응답 헤더 및 메타데이터에 사용됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;“Bytestrings”&lt;/strong&gt; (Python 3에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt; 타입, 다른 버전에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 타입으로 구현됨): 요청 및 응답 본문(예: POST/PUT 입력 데이터 및 HTML 페이지 출력)에 사용됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;혼동하지 마세요: Python의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 타입이 실제로 내부적으로 유니코드이더라도, “native string”의 내용은 여전히 Latin-1 인코딩을 통해 바이트로 변환될 수 있어야 합니다! (자세한 내용은 이 문서의 “유니코드 문제(Unicode Issues)” 섹션을 참조하세요.)&lt;/p&gt;

&lt;p&gt;요컨대, 이 문서에서 “string”이라는 단어를 볼 때는 “native string”, 즉 내부적으로 바이트 또는 유니코드로 구현되었는지와 관계없이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 타입의 객체를 의미합니다. “bytestring”에 대한 참조를 볼 때는 “Python 3에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt; 타입의 객체, Python 2에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 타입의 객체”로 읽어야 합니다.&lt;/p&gt;

&lt;p&gt;따라서 HTTP가 어떤 의미에서는 “실제로 그저 바이트”이더라도, Python의 기본 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 타입을 사용하여 얻을 수 있는 많은 API 편의성이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;애플리케이션프레임워크-측-the-applicationframework-side&quot;&gt;애플리케이션/프레임워크 측 (The Application/Framework Side)&lt;/h3&gt;

&lt;p&gt;애플리케이션 객체는 단순히 두 개의 인수를 받는 호출 가능한 객체입니다. “객체”라는 용어는 실제 객체 인스턴스를 요구하는 것으로 오해해서는 안 됩니다. 함수, 메서드, 클래스, 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__call__&lt;/code&gt; 메서드를 가진 인스턴스 모두 애플리케이션 객체로 사용될 수 있습니다. 사실상 모든 서버/게이트웨이(CGI 제외)가 이러한 반복 요청을 할 것이므로, 애플리케이션 객체는 여러 번 호출될 수 있어야 합니다.&lt;/p&gt;

&lt;p&gt;(참고: 이를 “애플리케이션” 객체라고 부르지만, 애플리케이션 개발자가 WSGI를 웹 프로그래밍 API로 사용할 것이라고 해석해서는 안 됩니다! 애플리케이션 개발자는 기존의 고수준 프레임워크 서비스를 사용하여 애플리케이션을 개발할 것으로 가정됩니다. WSGI는 프레임워크 및 서버 개발자를 위한 도구이며, 애플리케이션 개발자를 직접 지원하기 위한 것이 아닙니다.)&lt;/p&gt;

&lt;p&gt;다음은 두 가지 예제 애플리케이션 객체입니다. 하나는 함수이고 다른 하나는 클래스입니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;HELLO_WORLD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Hello world!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;simple_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;sh&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;가장 간단한 애플리케이션 객체&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;200 OK&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Content-type&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;text/plain&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HELLO_WORLD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;sh&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;동일한 출력을 생성하지만 클래스를 사용합니다.&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# (참고: 여기서는 &apos;AppClass&apos; 자체가 &quot;애플리케이션&quot;이므로,
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# 이를 호출하면 &apos;AppClass&apos;의 인스턴스가 반환되며, 이 인스턴스가
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# 사양에서 요구하는 &quot;애플리케이션 호출 가능 객체&quot;의 반복 가능한
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# 반환 값입니다. 만약 &apos;AppClass&apos;의 *인스턴스*를 애플리케이션
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# 객체로 사용하고 싶다면, 애플리케이션 실행을 위해 호출될
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# &apos;__call__&apos; 메서드를 구현해야 하며, 서버나 게이트웨이가
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# 사용할 인스턴스를 생성해야 합니다.)
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_response&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__iter__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;200 OK&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Content-type&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;text/plain&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HELLO_WORLD&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;서버게이트웨이-측-the-servergateway-side&quot;&gt;서버/게이트웨이 측 (The Server/Gateway Side)&lt;/h3&gt;

&lt;p&gt;서버 또는 게이트웨이는 HTTP 클라이언트로부터 애플리케이션을 대상으로 하는 요청을 받을 때마다 애플리케이션 호출 가능 객체를 한 번 호출합니다. 예를 들어, 애플리케이션 객체를 인수로 받는 함수로 구현된 간단한 CGI 게이트웨이가 있습니다. 이 간단한 예제는 제한된 오류 처리를 가지고 있는데, 기본적으로 잡히지 않은 예외는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys.stderr&lt;/code&gt;로 덤프되고 웹 서버에 의해 로깅되기 때문입니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;enc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getfilesystemencoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;surrogateescape&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unicode_to_wsgi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 환경 변수를 WSGI &quot;bytes-as-unicode&quot; 문자열로 변환합니다.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;iso-8859-1&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wsgi_to_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;iso-8859-1&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run_with_cgi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unicode_to_wsgi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.input&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;buffer&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.errors&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.version&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.multithread&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.multiprocess&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.run_once&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;HTTPS&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.url_scheme&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;https&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.url_scheme&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;headers_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;headers_sent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;buffer&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AssertionError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;write() before start_response()&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers_sent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# 첫 출력이 있기 전에 저장된 헤더를 보냅니다.
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers_sent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers_set&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;wsgi_to_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Status: %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;wsgi_to_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;%s: %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;wsgi_to_bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;flush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers_sent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;# 헤더가 이미 전송되었다면 원래 예외를 다시 발생시킵니다.
&lt;/span&gt;                    &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;with_traceback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 순환 참조를 피합니다.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AssertionError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Headers already set!&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;headers_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 참고: 헤더에 대한 오류 검사는 여기서 *헤더가 설정된 후*에 발생해야 합니다.
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# 이렇게 하면 오류가 발생할 경우 start_response는 exc_info를 설정한 채로만
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# 다시 호출될 수 있습니다.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 본문이 나타날 때까지 헤더를 보내지 않습니다.
&lt;/span&gt;                &lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;headers_sent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 본문이 비어있었다면 지금 헤더를 보냅니다.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasattr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;미들웨어-양측-역할을-수행하는-구성-요소-middleware-components-that-play-both-sides&quot;&gt;미들웨어: 양측 역할을 수행하는 구성 요소 (Middleware: Components that Play Both Sides)&lt;/h3&gt;

&lt;p&gt;단일 객체가 일부 애플리케이션에 대해 서버 역할을 하고, 동시에 일부 서버에 대해 애플리케이션 역할을 수행할 수 있습니다. 이러한 “미들웨어(middleware)” 구성 요소는 다음과 같은 기능을 수행할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대상 URL에 따라 요청을 다른 애플리케이션 객체로 라우팅하고, 그에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;을 재작성합니다.&lt;/li&gt;
  &lt;li&gt;여러 애플리케이션 또는 프레임워크가 동일한 프로세스에서 나란히 실행될 수 있도록 합니다.&lt;/li&gt;
  &lt;li&gt;네트워크를 통해 요청과 응답을 전달하여 로드 밸런싱 및 원격 처리를 수행합니다.&lt;/li&gt;
  &lt;li&gt;XSL 스타일시트 적용과 같은 콘텐츠 후처리를 수행합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 미들웨어의 존재는 인터페이스의 “서버/게이트웨이” 및 “애플리케이션/프레임워크” 양측에 투명하며, 특별한 지원을 필요로 하지 않습니다. 애플리케이션에 미들웨어를 통합하려는 사용자는 마치 애플리케이션인 것처럼 미들웨어 구성 요소를 서버에 제공하고, 미들웨어 구성 요소가 서버인 것처럼 애플리케이션을 호출하도록 구성합니다. 물론 미들웨어가 래핑하는 “애플리케이션”은 실제로 또 다른 미들웨어 구성 요소가 또 다른 애플리케이션을 래핑하는 것일 수 있으며, 이러한 방식으로 “미들웨어 스택”을 형성합니다.&lt;/p&gt;

&lt;p&gt;대부분의 경우 미들웨어는 WSGI의 서버 및 애플리케이션 측의 제한 및 요구 사항을 준수해야 합니다. 그러나 어떤 경우에는 미들웨어에 대한 요구 사항이 “순수한” 서버 또는 애플리케이션보다 더 엄격하며, 이러한 사항은 사양에 명시됩니다.&lt;/p&gt;

&lt;p&gt;다음은 Joe Strout의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;piglatin.py&lt;/code&gt;를 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text/plain&lt;/code&gt; 응답을 Pig Latin으로 변환하는 (농담조의) 미들웨어 구성 요소의 예입니다. (참고: “진짜” 미들웨어 구성 요소는 콘텐츠 타입을 확인하는 더 강력한 방법을 사용하고, 콘텐츠 인코딩도 확인해야 합니다. 또한 이 간단한 예제는 단어가 블록 경계를 넘어 분할될 가능성을 무시합니다.)&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;piglatin&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;piglatin&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LatinIter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;sh&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;변환이 가능한 경우 반복된 출력을 piglatin으로 변환합니다.
    변환 가능성은 애플리케이션이 첫 번째 비어있지 않은 bytestring을 yield하기 전까지
    변경될 수 있으므로, &lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;transform_ok&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;는 변경 가능한 참 값이어야 합니다.
    &lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform_ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasattr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__next__&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform_ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform_ok&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__iter__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__next__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform_ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;piglatin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# Py3에서 바이트 안전해야 합니다.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Latinator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 기본적으로 출력을 변환하지 않습니다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;application&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;application&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__call__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transform_ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start_latin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# 반복 호출일 경우를 대비하여 ok 플래그를 재설정합니다.
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;del&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform_ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:]&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lower&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;content-type&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;text/plain&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;transform_ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;# Content-Length가 있다면 제거합니다. 그렇지 않으면 잘못됩니다.
&lt;/span&gt;                    &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;
                                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lower&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;content-length&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform_ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;write_latin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;piglatin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# Py3에서 바이트 안전해야 합니다.
&lt;/span&gt;                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_latin&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LatinIter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_latin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform_ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Latinator의 제어 하에 foo_app을 실행하고, 예제 CGI 게이트웨이를 사용합니다.
# from foo_app import foo_app
# run_with_cgi(Latinator(foo_app))
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;사양-세부-정보-specification-details&quot;&gt;사양 세부 정보 (Specification Details)&lt;/h2&gt;

&lt;p&gt;애플리케이션 객체는 두 개의 위치 인수를 받아야 합니다. 설명을 위해 이들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;라고 명명했지만, 반드시 이 이름들을 가질 필요는 없습니다. 서버 또는 게이트웨이는 위치 인수를 사용하여(키워드 인수가 아님) 애플리케이션 객체를 호출해야 합니다 (예: 위에 표시된 대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result = application(environ, start_response)&lt;/code&gt;를 호출하여).&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 매개변수는 CGI 스타일의 환경 변수를 포함하는 딕셔너리 객체입니다. 이 객체는 내장 Python 딕셔너리여야 하며(하위 클래스, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UserDict&lt;/code&gt; 또는 다른 딕셔너리 에뮬레이션이 아님), 애플리케이션은 딕셔너리를 원하는 방식으로 수정할 수 있습니다. 딕셔너리는 또한 특정 WSGI 필수 변수(나중에 설명하는 섹션에서 설명)를 포함해야 하며, 아래에 설명할 규칙에 따라 명명된 서버별 확장 변수도 포함할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt; 매개변수는 두 개의 필수 위치 인수와 하나의 선택적 인수를 받는 호출 가능한 객체입니다. 설명을 위해 이 인수들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;status&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;response_headers&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt;라고 명명했지만, 이 이름들을 가질 필요는 없으며, 애플리케이션은 위치 인수를 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt; 호출 가능 객체를 호출해야 합니다 (예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response(status, response_headers)&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;status&lt;/code&gt; 매개변수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;999 Message here&quot;&lt;/code&gt; 형식의 상태 문자열이며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;response_headers&lt;/code&gt;는 HTTP 응답 헤더를 설명하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(header_name, header_value)&lt;/code&gt; 튜플 목록입니다. 선택적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt; 매개변수는 아래 “start_response() Callable” 및 “오류 처리(Error Handling)” 섹션에서 설명합니다. 이 매개변수는 애플리케이션이 오류를 잡아서 브라우저에 오류 메시지를 표시하려고 할 때만 사용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt; 호출 가능 객체는 HTTP 응답 본문의 일부로 작성될 바이트스트링을 하나의 위치 매개변수로 받는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write(body_data)&lt;/code&gt; 호출 가능 객체를 반환해야 합니다. (참고: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 가능 객체는 특정 기존 프레임워크의 명령형 출력 API를 지원하기 위해 제공됩니다. 가능하다면 새 애플리케이션이나 프레임워크에서는 사용하지 않아야 합니다. 자세한 내용은 “버퍼링 및 스트리밍(Buffering and Streaming)” 섹션을 참조하세요.)&lt;/p&gt;

&lt;p&gt;서버에 의해 호출될 때, 애플리케이션 객체는 0개 이상의 바이트스트링을 yield하는 반복 가능한 객체를 반환해야 합니다. 이는 다양한 방식으로 달성될 수 있습니다. 예를 들어, 바이트스트링 목록을 반환하거나, 바이트스트링을 yield하는 제너레이터 함수이거나, 인스턴스가 반복 가능한 클래스일 수 있습니다. 어떻게 달성되든, 애플리케이션 객체는 항상 0개 이상의 바이트스트링을 yield하는 반복 가능한 객체를 반환해야 합니다.&lt;/p&gt;

&lt;p&gt;서버 또는 게이트웨이는 yield된 바이트스트링을 버퍼링되지 않은 방식으로 클라이언트에 전송해야 하며, 다음 바이트스트링을 요청하기 전에 각 바이트스트링의 전송을 완료해야 합니다. (즉, 애플리케이션은 자체 버퍼링을 수행해야 합니다. 애플리케이션 출력이 어떻게 처리되어야 하는지에 대한 자세한 내용은 아래 “버퍼링 및 스트리밍(Buffering and Streaming)” 섹션을 참조하세요.)&lt;/p&gt;

&lt;p&gt;서버 또는 게이트웨이는 yield된 바이트스트링을 이진 바이트 시퀀스로 처리해야 합니다. 특히 줄바꿈 문자가 변경되지 않도록 해야 합니다. 애플리케이션은 작성될 바이트스트링이 클라이언트에 적합한 형식인지 확인해야 합니다. (서버 또는 게이트웨이는 HTTP 전송 인코딩을 적용하거나, 바이트 범위 전송과 같은 HTTP 기능을 구현하기 위해 다른 변환을 수행할 수 있습니다. 자세한 내용은 아래 “기타 HTTP 기능(Other HTTP Features)”을 참조하세요.)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;len(iterable)&lt;/code&gt; 호출이 성공하면 서버는 결과가 정확하다는 것을 신뢰할 수 있어야 합니다. 즉, 애플리케이션이 반환한 반복 가능한 객체가 작동하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__len__()&lt;/code&gt; 메서드를 제공한다면, 정확한 결과를 반환해야 합니다. (이것이 일반적으로 어떻게 사용되는지에 대한 정보는 “Content-Length 헤더 처리(Handling the Content-Length Header)” 섹션을 참조하세요.)&lt;/p&gt;

&lt;p&gt;애플리케이션이 반환한 반복 가능한 객체에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt; 메서드가 있다면, 서버 또는 게이트웨이는 현재 요청이 완료될 때(요청이 정상적으로 완료되었든, 반복 중 애플리케이션 오류 또는 브라우저의 조기 연결 해제로 인해 조기에 종료되었든 관계없이) 해당 메서드를 호출해야 합니다. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt; 메서드 요구 사항은 애플리케이션에 의한 리소스 해제를 지원하기 위한 것입니다. 이 프로토콜은 PEP 342의 제너레이터 지원 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt; 메서드를 가진 다른 일반적인 반복 가능한 객체들을 보완하기 위한 것입니다.)&lt;/p&gt;

&lt;p&gt;제너레이터 또는 다른 사용자 정의 이터레이터를 반환하는 애플리케이션은 서버에 의해 조기에 닫힐 수 있으므로 전체 이터레이터가 소비될 것이라고 가정해서는 안 됩니다.&lt;/p&gt;

&lt;p&gt;(참고: 애플리케이션은 반복 가능한 객체가 첫 번째 본문 바이트스트링을 yield하기 전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response()&lt;/code&gt; 호출 가능 객체를 호출해야 합니다. 그래야 서버가 본문 콘텐츠가 나오기 전에 헤더를 보낼 수 있습니다. 그러나 이 호출은 반복 가능한 객체의 첫 번째 반복에서 수행될 수 있으므로, 서버는 반복 가능한 객체를 반복하기 시작하기 전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response()&lt;/code&gt;가 호출되었다고 가정해서는 안 됩니다.)&lt;/p&gt;

&lt;p&gt;마지막으로, 서버 및 게이트웨이는 애플리케이션이 반환한 반복 가능한 객체의 다른 속성을 직접 사용해서는 안 됩니다. 단, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.file_wrapper&lt;/code&gt;가 반환하는 “파일 래퍼”와 같이 해당 서버 또는 게이트웨이에 특정한 타입의 인스턴스인 경우는 예외입니다(선택적 플랫폼별 파일 처리(Optional Platform-Specific File Handling) 참조). 일반적인 경우, 여기에 지정되거나 PEP 234 반복 API 등을 통해 접근되는 속성만 허용됩니다.&lt;/p&gt;

&lt;h3 id=&quot;environ-변수-environ-variables&quot;&gt;environ 변수 (environ Variables)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 딕셔너리는 Common Gateway Interface 사양에 정의된 이러한 CGI 환경 변수를 포함해야 합니다. 다음 변수들은 값이 빈 문자열인 경우를 제외하고는 항상 존재해야 합니다(아래에 별도로 명시된 경우 제외).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REQUEST_METHOD&lt;/code&gt;&lt;/strong&gt;: “GET” 또는 “POST”와 같은 HTTP 요청 메서드. 이는 절대로 빈 문자열일 수 없으므로 항상 필요합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SCRIPT_NAME&lt;/code&gt;&lt;/strong&gt;: 애플리케이션 객체에 해당하는 요청 URL “경로”의 초기 부분으로, 애플리케이션이 자신의 가상 “위치”를 알 수 있도록 합니다. 애플리케이션이 서버의 “루트”에 해당한다면 빈 문자열일 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PATH_INFO&lt;/code&gt;&lt;/strong&gt;: 요청 URL “경로”의 나머지 부분으로, 애플리케이션 내에서 요청 대상의 가상 “위치”를 지정합니다. 요청 URL이 애플리케이션 루트를 대상으로 하고 후행 슬래시가 없다면 빈 문자열일 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QUERY_STRING&lt;/code&gt;&lt;/strong&gt;: 요청 URL에서 “?” 뒤에 오는 부분 (있다면). 비어 있거나 없을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CONTENT_TYPE&lt;/code&gt;&lt;/strong&gt;: HTTP 요청의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt; 필드 내용. 비어 있거나 없을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CONTENT_LENGTH&lt;/code&gt;&lt;/strong&gt;: HTTP 요청의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt; 필드 내용. 비어 있거나 없을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SERVER_NAME&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SERVER_PORT&lt;/code&gt;&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP_HOST&lt;/code&gt;가 설정되지 않은 경우, 이 변수들을 결합하여 기본값을 결정할 수 있습니다. 자세한 내용은 아래 “URL 재구성(URL Reconstruction)” 섹션을 참조하세요. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SERVER_NAME&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SERVER_PORT&lt;/code&gt;는 필수 문자열이며 절대로 비어 있으면 안 됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SERVER_PROTOCOL&lt;/code&gt;&lt;/strong&gt;: 클라이언트가 요청을 보내는 데 사용한 프로토콜 버전. 일반적으로 “HTTP/1.0” 또는 “HTTP/1.1”과 같으며, 애플리케이션이 HTTP 요청 헤더를 어떻게 처리할지 결정하는 데 사용될 수 있습니다. (이 변수는 요청에 사용된 프로토콜을 나타내므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REQUEST_PROTOCOL&lt;/code&gt;이라고 불려야 할 것입니다. 서버의 응답에 사용될 프로토콜과 반드시 같지는 않기 때문입니다. 그러나 CGI와의 호환성을 위해 기존 이름을 유지해야 합니다.)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP_&lt;/code&gt; 변수&lt;/strong&gt;: 클라이언트가 제공한 HTTP 요청 헤더에 해당하는 변수 (즉, 이름이 “HTTP_“로 시작하는 변수). 이러한 변수의 존재 여부는 요청에서 적절한 HTTP 헤더의 존재 여부와 일치해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서버 또는 게이트웨이는 적용 가능한 한 많은 다른 CGI 변수를 제공하려고 시도해야 합니다. 또한 SSL이 사용 중인 경우, 서버 또는 게이트웨이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTPS=on&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSL_PROTOCOL&lt;/code&gt;과 같은 Apache SSL 환경 변수 중 적용 가능한 것을 최대한 제공해야 합니다. 그러나 위에 나열된 것 이외의 CGI 변수를 사용하는 애플리케이션은 관련 확장을 지원하지 않는 웹 서버에는 이식할 수 없습니다. (예를 들어, 파일을 게시하지 않는 웹 서버는 의미 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DOCUMENT_ROOT&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PATH_TRANSLATED&lt;/code&gt;를 제공할 수 없습니다.)&lt;/p&gt;

&lt;p&gt;WSGI를 준수하는 서버 또는 게이트웨이는 제공하는 변수와 필요에 따라 그 정의를 문서화해야 합니다. 애플리케이션은 필요한 변수의 존재 여부를 확인하고, 해당 변수가 없는 경우를 대비한 대체 계획을 가지고 있어야 합니다.&lt;/p&gt;

&lt;p&gt;참고: 누락된 변수(예: 인증이 발생하지 않은 경우의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REMOTE_USER&lt;/code&gt;)는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 딕셔너리에서 제외해야 합니다. 또한 CGI 정의 변수는 존재하는 경우 “native strings”여야 합니다. 어떤 CGI 변수의 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 타입이 아닌 다른 타입인 것은 이 사양에 대한 위반입니다.&lt;/p&gt;

&lt;p&gt;CGI 정의 변수 외에도, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 딕셔너리는 임의의 운영 체제 “환경 변수”를 포함할 수 있으며, 다음 WSGI 정의 변수를 포함해야 합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;변수&lt;/td&gt;
      &lt;td&gt;값&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Status wsgi.version&lt;/td&gt;
      &lt;td&gt;튜플 (1, 0) 으로, WSGI 버전 1.0을 나타냅니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wsgi.url_scheme&lt;/td&gt;
      &lt;td&gt;애플리케이션이 호출되는 URL의 “scheme” 부분을 나타내는 문자열. 일반적으로 상황에 따라 “http” 또는 “https” 값을 가집니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wsgi.input&lt;/td&gt;
      &lt;td&gt;HTTP 요청 본문 바이트를 읽을 수 있는 입력 스트림 (파일과 유사한 객체). (서버 또는 게이트웨이는 애플리케이션의 요청에 따라 온디맨드(on-demand)로 읽기를 수행할 수 있거나, 클라이언트의 요청 본문을 미리 읽어 메모리 또는 디스크에 버퍼링하거나, 자신의 선호에 따라 이러한 입력 스트림을 제공하는 다른 기술을 사용할 수 있습니다.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wsgi.errors&lt;/td&gt;
      &lt;td&gt;프로그램 또는 기타 오류를 표준화되고 잠재적으로 중앙 집중화된 위치에 기록하기 위해 오류 출력을 쓸 수 있는 출력 스트림 (파일과 유사한 객체). 이는 “텍스트 모드” 스트림이어야 합니다. 즉, 애플리케이션은 줄바꿈으로 “\n”을 사용하고, 서버/게이트웨이에 의해 올바른 줄바꿈으로 변환될 것이라고 가정해야 합니다. (str 타입이 유니코드인 플랫폼에서 오류 스트림은 오류를 발생시키지 않고 임의의 유니코드를 받아들이고 기록해야 합니다. 그러나 스트림의 인코딩으로 렌더링할 수 없는 문자를 대체하는 것은 허용됩니다.)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wsgi.multithread&lt;/td&gt;
      &lt;td&gt;동일한 프로세스 내에서 다른 스레드에 의해 애플리케이션 객체가 동시에 호출될 수 있다면 참(True)으로 평가되어야 하며, 그렇지 않다면 거짓(False)으로 평가되어야 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wsgi.multiprocess&lt;/td&gt;
      &lt;td&gt;동등한 애플리케이션 객체가 다른 프로세스에 의해 동시에 호출될 수 있다면 참(True)으로 평가되어야 하며, 그렇지 않다면 거짓(False)으로 평가되어야 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;wsgi.run_once&lt;/td&gt;
      &lt;td&gt;서버 또는 게이트웨이가 포함된 프로세스의 수명 동안 애플리케이션이 한 번만 호출될 것으로 예상한다면 (그러나 보장하지는 않음!) 참(True)으로 평가되어야 합니다. 일반적으로 이는 CGI(또는 유사한 것) 기반의 게이트웨이에서만 참입니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;마지막으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 딕셔너리는 서버 정의 변수도 포함할 수 있습니다. 이러한 변수는 소문자, 숫자, 점, 밑줄만 사용하여 명명되어야 하며, 정의하는 서버 또는 게이트웨이에 고유한 이름으로 접두사가 붙어야 합니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mod_python&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mod_python.some_variable&lt;/code&gt;과 같은 이름의 변수를 정의할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;입력-및-오류-스트림-input-and-error-streams&quot;&gt;입력 및 오류 스트림 (Input and Error Streams)&lt;/h3&gt;

&lt;p&gt;서버가 제공하는 입력 및 오류 스트림은 다음 메서드를 지원해야 합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;메서드&lt;/th&gt;
      &lt;th&gt;스트림&lt;/th&gt;
      &lt;th&gt;참고 사항&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.version&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 0)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;WSGI 버전 1.0을 나타내는 튜플입니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.url_scheme&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;http&quot;&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;https&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;애플리케이션이 호출되는 URL의 “scheme” 부분을 나타내는 문자열입니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.input&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;입력 스트림 객체&lt;/td&gt;
      &lt;td&gt;HTTP 요청 본문 바이트를 읽을 수 있는 파일과 유사한 객체입니다. 서버는 이 스트림을 온디맨드로 읽거나, 미리 읽어 버퍼링할 수 있습니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.errors&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;출력 스트림 객체&lt;/td&gt;
      &lt;td&gt;프로그램 또는 기타 오류를 기록할 수 있는 파일과 유사한 출력 스트림입니다. “텍스트 모드” 스트림이어야 하며, 애플리케이션은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;\n&quot;&lt;/code&gt;을 줄바꿈으로 사용해야 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.multithread&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;동일한 프로세스 내에서 다른 스레드에 의해 애플리케이션 객체가 동시에 호출될 수 있다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;입니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.multiprocess&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;동등한 애플리케이션 객체가 다른 프로세스에 의해 동시에 호출될 수 있다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;입니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.run_once&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;서버 또는 게이트웨이가 포함된 프로세스의 수명 동안 애플리케이션이 한 번만 호출될 것으로 예상한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;입니다 (보장하지는 않음). 주로 CGI 기반 게이트웨이에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;입니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;start_response-호출-가능-객체-the-start_response-callable&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response()&lt;/code&gt; 호출 가능 객체 (The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response()&lt;/code&gt; Callable)&lt;/h3&gt;

&lt;p&gt;애플리케이션 객체에 전달되는 두 번째 매개변수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response(status, response_headers, exc_info=None)&lt;/code&gt; 형태의 호출 가능한 객체입니다. (모든 WSGI 호출 가능 객체와 마찬가지로 인수는 키워드가 아닌 위치로 제공되어야 합니다.) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt; 호출 가능 객체는 HTTP 응답을 시작하는 데 사용되며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write(body_data)&lt;/code&gt; 호출 가능 객체를 반환해야 합니다 (아래 “버퍼링 및 스트리밍(Buffering and Streaming)” 섹션 참조).&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;status&lt;/code&gt; 인수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;200 OK&quot;&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;404 Not Found&quot;&lt;/code&gt;와 같은 HTTP “상태” 문자열입니다. 즉, Status-Code와 Reason-Phrase로 구성된 문자열이며, 순서대로 단일 공백으로 구분되며 주변에 공백이나 다른 문자가 없습니다. (자세한 내용은 RFC 2616, 섹션 6.1.1 참조.) 문자열에는 제어 문자가 포함되어서는 안 되며, 캐리지 리턴, 라인 피드 또는 이들의 조합으로 종료되어서는 안 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;response_headers&lt;/code&gt; 인수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(header_name, header_value)&lt;/code&gt; 튜플 목록입니다. 이는 Python 리스트여야 하며(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type(response_headers)&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListType&lt;/code&gt;), 서버는 그 내용을 원하는 방식으로 변경할 수 있습니다. 각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;header_name&lt;/code&gt;은 후행 콜론이나 기타 문장 부호 없이 유효한 HTTP 헤더 필드 이름(RFC 2616, 섹션 4.2에 정의됨)이어야 합니다.&lt;/p&gt;

&lt;p&gt;각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;header_value&lt;/code&gt;는 내장되거나 끝에 캐리지 리턴 또는 라인 피드를 포함한 어떤 제어 문자도 포함해서는 안 됩니다. (이러한 요구 사항은 응답 헤더를 검사하거나 수정해야 하는 서버, 게이트웨이 및 중간 응답 처리기가 수행해야 하는 파싱의 복잡성을 최소화하기 위한 것입니다.)&lt;/p&gt;

&lt;p&gt;일반적으로 서버 또는 게이트웨이는 클라이언트에 올바른 헤더가 전송되도록 할 책임이 있습니다. 애플리케이션이 HTTP(또는 효력이 있는 기타 관련 사양)에서 요구하는 헤더를 생략하는 경우, 서버 또는 게이트웨이가 이를 추가해야 합니다. 예를 들어, HTTP &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Date:&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Server:&lt;/code&gt; 헤더는 일반적으로 서버 또는 게이트웨이에서 제공됩니다.&lt;/p&gt;

&lt;p&gt;(서버/게이트웨이 개발자를 위한 알림: HTTP 헤더 이름은 대소문자를 구분하지 않으므로, 애플리케이션에서 제공하는 헤더를 검사할 때 이 점을 고려해야 합니다!)&lt;/p&gt;

&lt;p&gt;애플리케이션과 미들웨어는 HTTP/1.1의 “hop-by-hop” 기능 또는 헤더, HTTP/1.0의 동등한 기능, 또는 클라이언트와 웹 서버 간의 연결 지속성에 영향을 미치는 헤더를 사용하는 것이 금지됩니다. 이러한 기능은 실제 웹 서버의 전유물이며, 서버 또는 게이트웨이는 애플리케이션이 이를 보내려고 시도하는 것을 치명적인 오류로 간주해야 하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response()&lt;/code&gt;에 제공되는 경우 오류를 발생시켜야 합니다. (“hop-by-hop” 기능 및 헤더에 대한 자세한 내용은 아래 “기타 HTTP 기능(Other HTTP Features)” 섹션을 참조하세요.)&lt;/p&gt;

&lt;p&gt;서버는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;가 호출될 때 헤더의 오류를 확인해야 합니다. 그래야 애플리케이션이 아직 실행 중일 때 오류를 발생시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt; 호출 가능 객체는 실제로 응답 헤더를 전송해서는 안 됩니다. 대신, 애플리케이션 반환 값의 첫 번째 반복이 비어있지 않은 바이트스트링을 yield하거나 애플리케이션이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 가능 객체를 처음 호출한 후에만 서버 또는 게이트웨이가 전송하도록 저장해야 합니다. 즉, 실제 본문 데이터가 사용 가능할 때까지 또는 애플리케이션이 반환한 반복 가능한 객체가 소진될 때까지 응답 헤더를 보내서는 안 됩니다. (이 규칙의 유일한 예외는 응답 헤더에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt;가 0으로 명시적으로 포함된 경우입니다.)&lt;/p&gt;

&lt;p&gt;응답 헤더 전송을 지연시키는 것은 버퍼링 및 비동기 애플리케이션이 마지막 순간까지 원래 의도된 출력을 오류 출력으로 대체할 수 있도록 보장하기 위함입니다. 예를 들어, 애플리케이션 버퍼 내에서 본문이 생성되는 동안 오류가 발생하면 애플리케이션은 응답 상태를 “200 OK”에서 “500 Internal Error”로 변경해야 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt; 인수는 제공된 경우 Python &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys.exc_info()&lt;/code&gt; 튜플이어야 합니다. 이 인수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;가 오류 핸들러에 의해 호출될 때만 애플리케이션에서 제공해야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt;가 제공되고 아직 HTTP 헤더가 출력되지 않았다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;는 현재 저장된 HTTP 응답 헤더를 새로 제공된 것으로 교체하여, 오류 발생 시 애플리케이션이 출력에 대해 “마음을 바꿀” 수 있도록 허용해야 합니다.&lt;/p&gt;

&lt;p&gt;그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt;가 제공되고 HTTP 헤더가 이미 전송된 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;는 오류를 발생시켜야 하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt; 튜플을 사용하여 다시 발생시켜야 합니다. 즉:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;with_traceback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 애플리케이션이 잡은 예외를 다시 발생시키고, 원칙적으로 애플리케이션을 중단시켜야 합니다. (HTTP 헤더가 이미 전송된 후에는 애플리케이션이 브라우저에 오류 출력을 시도하는 것은 안전하지 않습니다.) 애플리케이션은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt;를 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;를 호출한 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;가 발생시키는 예외를 잡아서는 안 됩니다. 대신, 이러한 예외가 서버 또는 게이트웨이로 전파되도록 허용해야 합니다. 자세한 내용은 아래 “오류 처리(Error Handling)”를 참조하세요.&lt;/p&gt;

&lt;p&gt;애플리케이션은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt; 인수가 제공되는 경우에만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;를 여러 번 호출할 수 있습니다. 더 정확히 말하면, 현재 애플리케이션 호출 내에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;가 이미 호출된 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt; 인수 없이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;를 호출하는 것은 치명적인 오류입니다. 여기에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;의 첫 호출이 오류를 발생시킨 경우도 포함됩니다. (정확한 논리 예시는 위 CGI 게이트웨이 예시를 참조하세요.)&lt;/p&gt;

&lt;p&gt;참고: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;를 구현하는 서버, 게이트웨이 또는 미들웨어는 추적 및 관련 프레임을 통해 순환 참조가 생성되는 것을 피하기 위해 함수의 실행 기간을 넘어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt; 매개변수에 대한 참조를 유지하지 않도록 해야 합니다. 이를 수행하는 가장 간단한 방법은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# 여기서 exc_info로 작업 수행
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;exc_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 순환 참조 방지
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예제 CGI 게이트웨이는 이 기술의 또 다른 예시를 제공합니다.&lt;/p&gt;

&lt;h3 id=&quot;content-length-헤더-처리-handling-the-content-length-header&quot;&gt;Content-Length 헤더 처리 (Handling the Content-Length Header)&lt;/h3&gt;

&lt;p&gt;애플리케이션이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt; 헤더를 제공하는 경우, 서버는 헤더가 허용하는 것보다 많은 바이트를 클라이언트에 전송해서는 안 되며, 충분한 데이터가 전송되었을 때 응답 반복을 중지하거나, 애플리케이션이 그 지점을 넘어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;를 시도하면 오류를 발생시켜야 합니다. (물론, 애플리케이션이 명시된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt;를 충족하기에 충분한 데이터를 제공하지 않으면, 서버는 연결을 닫고 오류를 기록하거나 보고해야 합니다.)&lt;/p&gt;

&lt;p&gt;애플리케이션이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt; 헤더를 제공하지 않으면, 서버 또는 게이트웨이는 이를 처리하기 위해 여러 접근 방식 중 하나를 선택할 수 있습니다. 이 중 가장 간단한 방법은 응답이 완료될 때 클라이언트 연결을 닫는 것입니다.&lt;/p&gt;

&lt;p&gt;그러나 특정 상황에서 서버 또는 게이트웨이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt; 헤더를 생성하거나, 적어도 클라이언트 연결을 닫을 필요를 피할 수 있습니다. 애플리케이션이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 가능 객체를 호출하지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;len()&lt;/code&gt;이 1인 반복 가능한 객체를 반환하는 경우, 서버는 반복 가능한 객체에서 yield되는 첫 번째 바이트스트링의 길이를 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt;를 자동으로 결정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 서버와 클라이언트 모두 HTTP/1.1 “청크 인코딩(chunked encoding)”을 지원한다면, 서버는 청크 인코딩을 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 또는 반복 가능한 객체에서 yield되는 각 바이트스트링에 대해 청크를 보낼 수 있으며, 따라서 각 청크에 대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt; 헤더를 생성합니다. 이는 서버가 클라이언트 연결을 유지하고 싶다면 그렇게 할 수 있도록 합니다. 서버는 이를 수행할 때 RFC 2616을 완전히 준수해야 하며, 그렇지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt;가 없을 때 처리하기 위한 다른 전략 중 하나로 돌아가야 합니다.&lt;/p&gt;

&lt;p&gt;(참고: 애플리케이션과 미들웨어는 청킹 또는 gzip과 같은 어떤 종류의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Transfer-Encoding&lt;/code&gt;도 출력에 적용해서는 안 됩니다. “hop-by-hop” 작업으로서, 이러한 인코딩은 실제 웹 서버/게이트웨이의 영역입니다. 자세한 내용은 아래 “기타 HTTP 기능(Other HTTP Features)”을 참조하세요.)&lt;/p&gt;

&lt;h3 id=&quot;버퍼링-및-스트리밍-buffering-and-streaming&quot;&gt;버퍼링 및 스트리밍 (Buffering and Streaming)&lt;/h3&gt;

&lt;p&gt;일반적으로 애플리케이션은 (적당한 크기의) 출력을 버퍼링하고 한 번에 모두 보내는 것이 가장 좋은 처리량을 달성합니다. 이는 Zope와 같은 기존 프레임워크에서 일반적인 접근 방식입니다. 출력은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringIO&lt;/code&gt; 또는 유사한 객체에 버퍼링된 다음, 응답 헤더와 함께 한 번에 전송됩니다.&lt;/p&gt;

&lt;p&gt;WSGI의 해당 접근 방식은 애플리케이션이 응답 본문을 단일 바이트스트링으로 포함하는 단일 요소 반복 가능한 객체(예: 리스트)를 단순히 반환하는 것입니다. 이는 HTML 페이지를 렌더링하고 그 텍스트가 메모리에 쉽게 들어가는 대다수의 애플리케이션 기능에 권장되는 접근 방식입니다.&lt;/p&gt;

&lt;p&gt;그러나 대용량 파일의 경우, 또는 HTTP 스트리밍의 특수 용도(예: 멀티파트 “서버 푸시”)의 경우, 애플리케이션은 출력을 더 작은 블록으로 제공해야 할 수 있습니다(예: 대용량 파일을 메모리에 로드하는 것을 피하기 위해). 또한 응답의 일부가 생성하는 데 시간이 오래 걸리지만, 그 앞부분을 먼저 보내는 것이 유용한 경우도 있습니다.&lt;/p&gt;

&lt;p&gt;이러한 경우, 애플리케이션은 일반적으로 출력을 블록별로 생성하는 이터레이터(종종 제너레이터-이터레이터)를 반환합니다. 이러한 블록은 멀티파트 경계와 일치하도록 분할되거나(“서버 푸시”의 경우), 시간이 오래 걸리는 작업(예: 디스크에 있는 파일의 다른 블록 읽기) 직전에 분할될 수 있습니다.&lt;/p&gt;

&lt;p&gt;WSGI 서버, 게이트웨이 및 미들웨어는 어떤 블록의 전송도 지연해서는 안 됩니다. 애플리케이션이 다음 블록을 생성하는 동안에도 블록을 클라이언트에 완전히 전송하거나, 전송을 계속할 것을 보장해야 합니다. 서버/게이트웨이 또는 미들웨어는 세 가지 방법 중 하나로 이 보장을 제공할 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;애플리케이션에 제어를 반환하기 전에 전체 블록을 운영 체제에 전송하고 (모든 OS 버퍼를 플러시하도록 요청).&lt;/li&gt;
  &lt;li&gt;애플리케이션이 다음 블록을 생성하는 동안에도 블록이 계속 전송되도록 다른 스레드를 사용.&lt;/li&gt;
  &lt;li&gt;(미들웨어만) 전체 블록을 상위 게이트웨이/서버로 전송.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 보장을 제공함으로써 WSGI는 애플리케이션이 출력 데이터의 임의 지점에서 전송이 중단되지 않도록 보장할 수 있도록 합니다. 이는 멀티파트 경계 사이의 데이터가 클라이언트에 완전히 전송되어야 하는 멀티파트 “서버 푸시” 스트리밍과 같은 기능에 매우 중요합니다.&lt;/p&gt;

&lt;h3 id=&quot;미들웨어의-블록-경계-처리-middleware-handling-of-block-boundaries&quot;&gt;미들웨어의 블록 경계 처리 (Middleware Handling of Block Boundaries)&lt;/h3&gt;

&lt;p&gt;비동기 애플리케이션 및 서버를 더 잘 지원하기 위해 미들웨어 구성 요소는 애플리케이션 반복 가능한 객체에서 여러 값을 기다리면서 반복을 차단해서는 안 됩니다. 미들웨어가 어떤 출력을 생성하기 전에 애플리케이션에서 더 많은 데이터를 축적해야 하는 경우, 빈 바이트스트링을 yield해야 합니다.&lt;/p&gt;

&lt;p&gt;이 요구 사항을 다른 방식으로 말하자면, 미들웨어 구성 요소는 기본 애플리케이션이 값을 yield할 때마다 적어도 하나의 값을 yield해야 합니다. 미들웨어가 다른 값을 yield할 수 없는 경우, 빈 바이트스트링을 yield해야 합니다.&lt;/p&gt;

&lt;p&gt;이 요구 사항은 비동기 애플리케이션 및 서버가 주어진 수의 애플리케이션 인스턴스를 동시에 실행하는 데 필요한 스레드 수를 줄이기 위해 협력할 수 있도록 보장합니다.&lt;/p&gt;

&lt;p&gt;또한 이 요구 사항은 미들웨어가 기본 애플리케이션이 반복 가능한 객체를 반환하자마자 반복 가능한 객체를 반환해야 함을 의미합니다. 미들웨어가 기본 애플리케이션이 yield하는 데이터를 전송하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 가능 객체를 사용하는 것도 금지됩니다. 미들웨어는 기본 애플리케이션이 미들웨어에서 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 가능 객체를 사용하여 보낸 데이터를 전송하기 위해서만 상위 서버의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 가능 객체를 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;write-호출-가능-객체-the-write-callable&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 가능 객체 (The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; Callable)&lt;/h3&gt;

&lt;p&gt;일부 기존 애플리케이션 프레임워크 API는 WSGI와 다른 방식으로 버퍼링되지 않은 출력을 지원합니다. 구체적으로, 버퍼링되지 않은 데이터 블록을 작성하기 위한 “write” 함수 또는 메서드를 제공하거나, 버퍼링된 “write” 함수와 버퍼를 플러시하는 “flush” 메커니즘을 제공합니다.&lt;/p&gt;

&lt;p&gt;불행히도, 이러한 API는 스레드 또는 다른 특별한 메커니즘이 사용되지 않는 한 WSGI의 “반복 가능한” 애플리케이션 반환 값으로는 구현될 수 없습니다.&lt;/p&gt;

&lt;p&gt;따라서 이러한 프레임워크가 명령형 API를 계속 사용할 수 있도록 WSGI는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt; 호출 가능 객체가 반환하는 특별한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 가능 객체를 포함합니다.&lt;/p&gt;

&lt;p&gt;새로운 WSGI 애플리케이션 및 프레임워크는 가능하다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 가능 객체를 사용하지 않아야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 가능 객체는 명령형 스트리밍 API를 지원하기 위한 엄격한 임시방편(hack)입니다. 일반적으로 애플리케이션은 반환된 반복 가능한 객체를 통해 출력을 생성해야 합니다. 이렇게 하면 웹 서버가 동일한 Python 스레드에서 다른 작업을 번갈아 수행할 수 있어, 전체 서버의 처리량을 향상시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt; 호출 가능 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response()&lt;/code&gt; 호출 가능 객체에 의해 반환되며, 하나의 매개변수(HTTP 응답 본문의 일부로 작성될 바이트스트링)를 받습니다. 이 바이트스트링은 출력 반복 가능한 객체에 의해 yield된 것처럼 정확히 처리됩니다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;가 반환되기 전에, 전달된 바이트스트링이 클라이언트에 완전히 전송되었거나, 애플리케이션이 계속 진행하는 동안 전송을 위해 버퍼링되었음을 보장해야 합니다.&lt;/p&gt;

&lt;p&gt;애플리케이션은 응답 본문의 전부 또는 일부를 생성하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;를 사용하더라도 반복 가능한 객체를 반환해야 합니다. 반환된 반복 가능한 객체는 비어 있을 수 있지만(즉, 비어있지 않은 바이트스트링을 yield하지 않음), 비어있지 않은 바이트스트링을 yield하는 경우, 해당 출력은 서버 또는 게이트웨이에서 정상적으로 처리되어야 합니다(즉, 즉시 전송되거나 대기열에 추가되어야 합니다). 애플리케이션은 반환 반복 가능한 객체 내에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;를 호출해서는 안 되며, 따라서 반복 가능한 객체에 의해 yield된 모든 바이트스트링은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;에 전달된 모든 바이트스트링이 클라이언트에 전송된 후에 전송됩니다.&lt;/p&gt;

&lt;h3 id=&quot;유니코드-문제-unicode-issues&quot;&gt;유니코드 문제 (Unicode Issues)&lt;/h3&gt;

&lt;p&gt;HTTP는 유니코드를 직접 지원하지 않으며, 이 인터페이스도 마찬가지입니다. 모든 인코딩/디코딩은 애플리케이션이 처리해야 합니다. 서버로 전달되거나 서버로부터 전달되는 모든 문자열은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt; 타입이어야 하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unicode&lt;/code&gt; 타입이어서는 안 됩니다. 문자열 객체가 필요한 곳에 유니코드 객체를 사용하는 결과는 정의되지 않습니다.&lt;/p&gt;

&lt;p&gt;또한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response()&lt;/code&gt;에 상태 또는 응답 헤더로 전달되는 문자열은 인코딩과 관련하여 RFC 2616을 따라야 합니다. 즉, ISO-8859-1 문자이거나 RFC 2047 MIME 인코딩을 사용해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringType&lt;/code&gt; 타입이 실제로 유니코드 기반인 Python 플랫폼(예: Jython, IronPython, Python 3 등)에서는 이 사양에서 언급된 모든 “문자열”은 ISO-8859-1 인코딩으로 표현할 수 있는 코드 포인트(포함 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\u0000&lt;/code&gt;부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\u00FF&lt;/code&gt;까지)만 포함해야 합니다. 애플리케이션이 다른 유니코드 문자나 코드 포인트를 포함하는 문자열을 제공하는 것은 치명적인 오류입니다. 마찬가지로, 서버 및 게이트웨이는 다른 유니코드 문자를 포함하는 문자열을 애플리케이션에 제공해서는 안 됩니다.&lt;/p&gt;

&lt;p&gt;다시 말하지만, 이 사양에서 “문자열”로 언급된 모든 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringType&lt;/code&gt; 타입이어야 하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unicode&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UnicodeType&lt;/code&gt; 타입이어서는 안 됩니다. 또한 주어진 플랫폼이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StringType&lt;/code&gt; 객체에서 문자당 8비트 이상을 허용하더라도, 이 사양에서 “문자열”로 언급된 모든 값에 대해서는 하위 8비트만 사용될 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 사양에서 “bytestrings”로 언급된 값(즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.input&lt;/code&gt;에서 읽거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;에 전달되거나 애플리케이션에 의해 yield되는 값)의 경우, Python 3에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt; 타입이어야 하며, 이전 Python 버전에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 타입이어야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;오류-처리-error-handling&quot;&gt;오류 처리 (Error Handling)&lt;/h3&gt;

&lt;p&gt;일반적으로 애플리케이션은 자체 내부 오류를 포착하여 브라우저에 유용한 메시지를 표시하려고 노력해야 합니다. (이 맥락에서 “유용한”의 의미는 애플리케이션이 결정할 문제입니다.)&lt;/p&gt;

&lt;p&gt;그러나 이러한 메시지를 표시하려면 애플리케이션이 아직 브라우저에 데이터를 보내지 않았어야 합니다. 그렇지 않으면 응답이 손상될 위험이 있습니다. 따라서 WSGI는 애플리케이션이 오류 메시지를 보내거나 자동으로 중단될 수 있도록 하는 메커니즘을 제공합니다. 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt; 인수입니다. 다음은 그 사용 예시입니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 여기에 일반 애플리케이션 코드
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;200 Froody&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;content-type&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;text/plain&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;normal body goes here&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# XXX MemoryError, KeyboardInterrupt와 같은 런타임 문제는
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# 이 bare &apos;except:&apos; 이전에 별도의 핸들러에서 처리해야 합니다.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;500 Oops&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;content-type&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;text/plain&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response_headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;exc_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;error body goes here&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예외 발생 시 출력이 작성되지 않았다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt; 호출은 정상적으로 반환되고 애플리케이션은 브라우저로 보낼 오류 본문을 반환합니다. 그러나 이미 브라우저로 출력이 전송되었다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;는 제공된 예외를 다시 발생시킵니다. 이 예외는 애플리케이션에서 포착되지 않아야 하므로, 애플리케이션은 중단됩니다. 그러면 서버 또는 게이트웨이는 이 (치명적인) 예외를 포착하고 응답을 중단할 수 있습니다.&lt;/p&gt;

&lt;p&gt;서버는 애플리케이션 또는 반환 값의 반복을 중단시키는 모든 예외를 포착하고 기록해야 합니다. 애플리케이션 오류 발생 시 브라우저에 부분 응답이 이미 작성되었다면, 서버 또는 게이트웨이는 이미 전송된 헤더가 서버가 깨끗하게 수정할 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text/*&lt;/code&gt; 콘텐츠 타입을 나타내는 경우 출력에 오류 메시지를 추가하려고 시도할 수 있습니다.&lt;/p&gt;

&lt;p&gt;일부 미들웨어는 추가 예외 처리 서비스를 제공하거나 애플리케이션 오류 메시지를 가로채고 교체할 수 있습니다. 이러한 경우 미들웨어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;에 제공된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt;를 다시 발생시키지 않고, 대신 미들웨어별 예외를 발생시키거나, 제공된 인수를 저장한 후 예외 없이 단순히 반환할 수 있습니다. 이렇게 하면 애플리케이션이 오류 본문 반복 가능한 객체를 반환하거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;를 호출하여 미들웨어가 오류 출력을 캡처하고 수정할 수 있도록 합니다. 이러한 기술은 애플리케이션 개발자가 다음을 따르는 한 작동합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;오류 응답을 시작할 때 항상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt;를 제공&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exc_info&lt;/code&gt;가 제공될 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt;가 발생시키는 오류를 절대 포착하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-11-expectcontinue-http-11-expectcontinue&quot;&gt;HTTP 1.1 Expect/Continue (HTTP 1.1 Expect/Continue)&lt;/h3&gt;

&lt;p&gt;HTTP 1.1을 구현하는 서버 및 게이트웨이는 HTTP 1.1의 “expect/continue” 메커니즘에 대한 투명한 지원을 제공해야 합니다. 이는 여러 방법 중 하나로 수행될 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Expect: 100-continue&lt;/code&gt; 요청을 포함하는 요청에 즉시 “100 Continue” 응답으로 응답하고 정상적으로 진행합니다.&lt;/li&gt;
  &lt;li&gt;요청을 정상적으로 진행하지만, 애플리케이션이 입력 스트림에서 처음 읽기를 시도할 때 “100 Continue” 응답을 보내는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.input&lt;/code&gt; 스트림을 애플리케이션에 제공합니다. 그러면 읽기 요청은 클라이언트가 응답할 때까지 차단된 상태로 유지되어야 합니다.&lt;/li&gt;
  &lt;li&gt;클라이언트가 서버가 expect/continue를 지원하지 않는다고 판단하고 자체적으로 요청 본문을 보낼 때까지 기다립니다. (이는 최적이 아니며 권장되지 않습니다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 동작 제한은 HTTP 1.0 요청이나 애플리케이션 객체를 대상으로 하지 않는 요청에는 적용되지 않습니다. HTTP 1.1 Expect/Continue에 대한 자세한 내용은 RFC 2616, 섹션 8.2.3 및 10.1.1을 참조하세요.&lt;/p&gt;

&lt;h3 id=&quot;기타-http-기능-other-http-features&quot;&gt;기타 HTTP 기능 (Other HTTP Features)&lt;/h3&gt;

&lt;p&gt;일반적으로 서버 및 게이트웨이는 “바보처럼” 작동하고 애플리케이션이 출력에 대해 완전한 제어를 할 수 있도록 허용해야 합니다. 응답의 유효한 의미를 변경하지 않는 변경 사항만 수행해야 합니다. 애플리케이션 개발자는 추가 기능을 제공하기 위해 미들웨어 구성 요소를 항상 추가할 수 있으므로, 서버/게이트웨이 개발자는 구현에 보수적이어야 합니다. 어떤 의미에서 서버는 자신을 HTTP “게이트웨이 서버”로, 애플리케이션은 HTTP “원본 서버”로 간주해야 합니다. (이 용어의 정의는 RFC 2616, 섹션 1.3을 참조하세요.)&lt;/p&gt;

&lt;p&gt;그러나 WSGI 서버와 애플리케이션은 HTTP를 통해 통신하지 않으므로, RFC 2616에서 “hop-by-hop” 헤더라고 부르는 것은 WSGI 내부 통신에는 적용되지 않습니다. WSGI 애플리케이션은 “hop-by-hop” 헤더를 생성해서는 안 되며, 그러한 헤더를 생성해야 하는 HTTP 기능을 사용하려고 시도해서도 안 되며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 딕셔너리의 수신 “hop-by-hop” 헤더 내용에 의존해서도 안 됩니다. WSGI 서버는 지원되는 모든 인바운드 “hop-by-hop” 헤더를 자체적으로 처리해야 합니다. 예를 들어, 적용 가능한 경우 청크 인코딩을 포함한 인바운드 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Transfer-Encoding&lt;/code&gt;을 디코딩하는 식입니다.&lt;/p&gt;

&lt;p&gt;이러한 원칙을 다양한 HTTP 기능에 적용하면, 서버가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;If-None-Match&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;If-Modified-Since&lt;/code&gt; 요청 헤더와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Last-Modified&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ETag&lt;/code&gt; 응답 헤더를 통해 캐시 유효성 검사를 처리할 수 있음이 명확해집니다. 그러나 이를 수행할 필요는 없으며, 서버/게이트웨이가 그러한 유효성 검사를 수행할 필요가 없으므로, 애플리케이션이 해당 기능을 지원하려면 자체적으로 캐시 유효성 검사를 수행해야 합니다.&lt;/p&gt;

&lt;p&gt;마찬가지로, 서버는 애플리케이션의 응답을 재인코딩하거나 전송 인코딩할 수 있지만, 애플리케이션은 자체적으로 적절한 콘텐츠 인코딩을 사용해야 하며, 전송 인코딩을 적용해서는 안 됩니다. 서버는 클라이언트가 요청하고 애플리케이션이 바이트 범위를 기본적으로 지원하지 않는 경우 애플리케이션 응답의 바이트 범위를 전송할 수 있습니다. 다시 말하지만, 원하는 경우 애플리케이션은 자체적으로 이 기능을 수행해야 합니다.&lt;/p&gt;

&lt;p&gt;애플리케이션에 대한 이러한 제한 사항이 모든 애플리케이션이 모든 HTTP 기능을 재구현해야 한다는 것을 의미하지는 않습니다. 많은 HTTP 기능은 미들웨어 구성 요소에 의해 부분적으로 또는 완전히 구현될 수 있으므로, 서버 및 애플리케이션 개발자 모두가 동일한 기능을 반복해서 구현할 필요가 없습니다.&lt;/p&gt;

&lt;h3 id=&quot;스레드-지원-thread-support&quot;&gt;스레드 지원 (Thread Support)&lt;/h3&gt;

&lt;p&gt;스레드 지원 또는 지원 부족은 서버에 따라 다릅니다. 여러 요청을 병렬로 실행할 수 있는 서버는 스레드 안전하지 않은 애플리케이션 또는 프레임워크도 해당 서버와 함께 사용할 수 있도록 단일 스레드 방식으로 애플리케이션을 실행하는 옵션을 제공해야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;구현애플리케이션-노트-implementationapplication-notes&quot;&gt;구현/애플리케이션 노트 (Implementation/Application Notes)&lt;/h2&gt;

&lt;h3 id=&quot;서버-확장-api-server-extension-apis&quot;&gt;서버 확장 API (Server Extension APIs)&lt;/h3&gt;

&lt;p&gt;일부 서버 개발자는 애플리케이션 또는 프레임워크 개발자가 특수 목적을 위해 사용할 수 있는 더 고급 API를 노출하고자 할 수 있습니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mod_python&lt;/code&gt; 기반의 게이트웨이는 Apache API의 일부를 WSGI 확장으로 노출할 수 있습니다.&lt;/p&gt;

&lt;p&gt;가장 간단한 경우, 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mod_python.some_api&lt;/code&gt;와 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 변수를 정의하는 것 이상의 것을 요구하지 않습니다. 그러나 많은 경우 미들웨어의 존재 가능성으로 인해 어려울 수 있습니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 변수에서 발견되는 것과 동일한 HTTP 헤더에 대한 접근을 제공하는 API는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;이 미들웨어에 의해 수정된 경우 다른 데이터를 반환할 수 있습니다.&lt;/p&gt;

&lt;p&gt;일반적으로 WSGI 기능의 일부를 복제, 대체 또는 우회하는 모든 확장 API는 미들웨어 구성 요소와 호환되지 않을 위험이 있습니다. 서버/게이트웨이 개발자는 아무도 미들웨어를 사용하지 않을 것이라고 가정해서는 안 됩니다. 일부 프레임워크 개발자는 프레임워크를 거의 전적으로 다양한 종류의 미들웨어로 기능하도록 구성하거나 재구성할 계획이기 때문입니다.&lt;/p&gt;

&lt;p&gt;따라서 최대 호환성을 제공하기 위해 WSGI 기능의 일부를 대체하는 확장 API를 제공하는 서버 및 게이트웨이는 해당 API가 대체하는 API 부분을 사용하여 호출되도록 해당 API를 설계해야 합니다. 예를 들어, HTTP 요청 헤더에 접근하기 위한 확장 API는 애플리케이션이 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;을 전달하도록 요구해야 합니다. 그래야 서버/게이트웨이가 API를 통해 접근 가능한 HTTP 헤더가 미들웨어에 의해 변경되지 않았음을 확인할 수 있습니다. 확장 API가 HTTP 헤더 내용에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;과 항상 일치할 것이라고 보장할 수 없다면, 예를 들어 오류를 발생시키거나, 헤더 컬렉션 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt;을 반환하거나, API에 적절한 방식으로 애플리케이션에 서비스를 거부해야 합니다.&lt;/p&gt;

&lt;p&gt;마찬가지로, 확장 API가 응답 데이터 또는 헤더를 작성하는 대체 수단을 제공하는 경우, 애플리케이션이 확장된 서비스를 얻기 전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt; 호출 가능 객체가 전달되도록 요구해야 합니다. 전달된 객체가 서버/게이트웨이가 원래 애플리케이션에 제공한 것과 동일하지 않다면, 올바른 작동을 보장할 수 없으며 애플리케이션에 확장된 서비스를 제공하는 것을 거부해야 합니다.&lt;/p&gt;

&lt;p&gt;이러한 지침은 파싱된 쿠키, 폼 변수, 세션 등과 같은 정보를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;에 추가하는 미들웨어에도 적용됩니다. 특히, 이러한 미들웨어는 단순히 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;에 채워 넣는 대신, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;에서 작동하는 함수로 이러한 기능을 제공해야 합니다. 이는 미들웨어가 URL 재작성 또는 기타 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 수정을 수행한 후에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;에서 정보가 계산되도록 보장하는 데 도움이 됩니다.&lt;/p&gt;

&lt;p&gt;미들웨어 개발자가 해당 확장을 사용하는 애플리케이션에 의해 중재가 우회되는 것을 방지하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;에서 모든 확장 API를 삭제해야 하는 미래를 피하려면, 서버/게이트웨이 및 미들웨어 개발자 모두 이러한 “안전한 확장” 규칙을 따르는 것이 매우 중요합니다!&lt;/p&gt;

&lt;h3 id=&quot;애플리케이션-구성-application-configuration&quot;&gt;애플리케이션 구성 (Application Configuration)&lt;/h3&gt;

&lt;p&gt;이 사양은 서버가 호출할 애플리케이션을 선택하거나 얻는 방법을 정의하지 않습니다. 이러한 및 기타 구성 옵션은 서버에 매우 특정한 문제입니다. 서버/게이트웨이 개발자는 특정 애플리케이션 객체를 실행하도록 서버를 구성하는 방법과 어떤 옵션(예: 스레딩 옵션)을 사용할지 문서화할 것으로 예상됩니다.&lt;/p&gt;

&lt;p&gt;반면에 프레임워크 개발자는 프레임워크의 기능을 래핑하는 애플리케이션 객체를 생성하는 방법을 문서화해야 합니다. 서버와 애플리케이션 프레임워크를 모두 선택한 사용자는 둘을 연결해야 합니다. 그러나 이제 프레임워크와 서버 모두 공통 인터페이스를 가지므로, 이는 새로운 서버/프레임워크 쌍마다 상당한 엔지니어링 노력이 아니라 단순히 기계적인 문제여야 합니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 일부 애플리케이션, 프레임워크 및 미들웨어는 간단한 문자열 구성 옵션을 받기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 딕셔너리를 사용하고자 할 수 있습니다. 서버 및 게이트웨이는 애플리케이션 배포자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;에 배치할 이름-값 쌍을 지정할 수 있도록 허용함으로써 이를 지원해야 합니다. 가장 간단한 경우, 이 지원은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;os.environ&lt;/code&gt;에서 운영 체제에서 제공하는 모든 환경 변수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 딕셔너리로 복사하는 것만으로 구성될 수 있습니다. 배포자는 원칙적으로 서버 외부에서 또는 CGI의 경우 서버 구성 파일을 통해 이를 구성할 수 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;모든 서버가 쉽게 구성하는 것을 지원하지는 않으므로, 애플리케이션은 이러한 필수 변수를 최소한으로 유지하려고 노력해야 합니다. 물론, 최악의 경우에도 애플리케이션을 배포하는 사람은 필요한 구성 값을 제공하기 위한 스크립트를 생성할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the_app&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;application&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;the_app.configval1&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나 대부분의 기존 애플리케이션 및 프레임워크는 아마도 애플리케이션 또는 프레임워크별 구성 파일의 위치를 나타내는 단일 구성 값만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;에서 필요할 것입니다. (물론, 애플리케이션은 호출할 때마다 다시 읽는 것을 피하기 위해 이러한 구성을 캐시해야 합니다.)&lt;/p&gt;

&lt;h3 id=&quot;url-재구성-url-reconstruction&quot;&gt;URL 재구성 (URL Reconstruction)&lt;/h3&gt;

&lt;p&gt;애플리케이션이 요청의 완전한 URL을 재구성하고자 한다면, Ian Bicking이 기여한 다음 알고리즘을 사용하여 그렇게 할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urllib.parse&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quote&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.url_scheme&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;://&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;HTTP_HOST&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;HTTP_HOST&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;SERVER_NAME&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.url_scheme&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;https&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;SERVER_PORT&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;443&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;SERVER_PORT&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;SERVER_PORT&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;SERVER_PORT&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;quote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;SCRIPT_NAME&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;quote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;PATH_INFO&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;QUERY_STRING&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;QUERY_STRING&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;재구성된 URL은 클라이언트가 요청한 URI와 정확히 같지 않을 수 있다는 점에 유의해야 합니다. 예를 들어, 서버 재작성 규칙은 클라이언트가 원래 요청한 URL을 표준 형식으로 만들기 위해 수정했을 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;이전-22-python-버전-지원-supporting-older-22-versions-of-python&quot;&gt;이전 (&amp;lt;2.2) Python 버전 지원 (Supporting Older (&amp;lt;2.2) Versions of Python)&lt;/h3&gt;

&lt;p&gt;일부 서버, 게이트웨이 또는 애플리케이션은 이전(&amp;lt;2.2) Python 버전을 지원하고자 할 수 있습니다. 현재 작성 시점에 Jython 2.2의 프로덕션 준비 버전이 아직 제공되지 않으므로 Jython이 대상 플랫폼이라면 특히 중요합니다.&lt;/p&gt;

&lt;p&gt;서버 및 게이트웨이의 경우, 이는 비교적 간단합니다. Python 2.2 이전 버전을 대상으로 하는 서버 및 게이트웨이는 애플리케이션이 반환하는 모든 반복 가능한 객체를 반복하기 위해 표준 “for” 루프만 사용하도록 자체적으로 제한해야 합니다. 이것이 2.2 이전 이터레이터 프로토콜(아래에서 더 자세히 논의됨)과 “오늘날의” 이터레이터 프로토콜(PEP 234 참조) 모두와 소스 레벨 호환성을 보장하는 유일한 방법입니다.&lt;/p&gt;

&lt;p&gt;(이 기술은 Python으로 작성된 서버, 게이트웨이 또는 미들웨어에만 적용됩니다. 다른 언어에서 이터레이터 프로토콜을 올바르게 사용하는 방법에 대한 논의는 이 PEP의 범위를 벗어납니다.)&lt;/p&gt;

&lt;p&gt;애플리케이션의 경우, 2.2 이전 Python 버전 지원은 약간 더 복잡합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 객체를 반환하고 반복 가능한 객체로 작동할 것으로 기대해서는 안 됩니다. Python 2.2 이전에는 파일이 반복 가능하지 않았기 때문입니다. (일반적으로 어쨌든 이렇게 해서는 안 됩니다. 대부분의 경우 성능이 매우 좋지 않을 것입니다!) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.file_wrapper&lt;/code&gt; 또는 애플리케이션별 파일 래퍼 클래스를 사용하세요. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.file_wrapper&lt;/code&gt;에 대한 자세한 내용과 파일을 반복 가능한 객체로 래핑하는 데 사용할 수 있는 예제 클래스는 “선택적 플랫폼별 파일 처리(Optional Platform-Specific File Handling)”를 참조하세요.)&lt;/li&gt;
  &lt;li&gt;사용자 정의 반복 가능한 객체를 반환하는 경우, 2.2 이전 이터레이터 프로토콜을 구현해야 합니다. 즉, 정수 키를 받고 소진될 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IndexError&lt;/code&gt;를 발생시키는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__getitem__&lt;/code&gt; 메서드를 제공해야 합니다. (내장 시퀀스 타입도 이 프로토콜을 구현하므로 허용됩니다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;마지막으로, 2.2 이전 Python 버전을 지원하고자 하고, 애플리케이션 반환 값을 반복하거나 자체적으로 반복 가능한 객체를 반환하는 미들웨어는 위의 적절한 권장 사항을 따라야 합니다.&lt;/p&gt;

&lt;p&gt;(참고: 2.2 이전 Python 버전을 지원하려면 모든 서버, 게이트웨이, 애플리케이션 또는 미들웨어는 대상 버전에서 사용할 수 있는 언어 기능만 사용하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;을 사용해야 한다는 것은 말할 필요도 없습니다.)&lt;/p&gt;

&lt;h3 id=&quot;선택적-플랫폼별-파일-처리-optional-platform-specific-file-handling&quot;&gt;선택적 플랫폼별 파일 처리 (Optional Platform-Specific File Handling)&lt;/h3&gt;

&lt;p&gt;일부 운영 환경은 Unix의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendfile()&lt;/code&gt; 호출과 같은 특수한 고성능 파일 전송 기능을 제공합니다. 서버 및 게이트웨이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;의 선택적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.file_wrapper&lt;/code&gt; 키를 통해 이 기능을 노출할 수 있습니다. 애플리케이션은 이 “파일 래퍼”를 사용하여 파일 또는 파일과 유사한 객체를 반복 가능한 객체로 변환한 다음 반환할 수 있습니다. 예를 들면 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.file_wrapper&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.file_wrapper&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filelike&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filelike&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;서버 또는 게이트웨이가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.file_wrapper&lt;/code&gt;를 제공하는 경우, 이는 하나의 필수 위치 매개변수와 하나의 선택적 위치 매개변수를 받는 호출 가능한 객체여야 합니다. 첫 번째 매개변수는 전송될 파일과 유사한 객체이며, 두 번째 매개변수는 선택적인 블록 크기 “제안”(서버/게이트웨이가 사용할 필요는 없음)입니다. 호출 가능한 객체는 반복 가능한 객체를 반환해야 하며, 서버/게이트웨이가 애플리케이션의 반환 값으로 반복 가능한 객체를 실제로 받기 전까지는 데이터 전송을 수행해서는 안 됩니다. (그렇지 않으면 미들웨어가 응답 데이터를 해석하거나 재정의할 수 없게 됩니다.)&lt;/p&gt;

&lt;p&gt;“파일과 유사한” 것으로 간주되려면, 애플리케이션이 제공하는 객체는 선택적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size&lt;/code&gt; 인수를 받는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 메서드를 가져야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt; 메서드를 가질 수 있으며, 그럴 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.file_wrapper&lt;/code&gt;가 반환하는 반복 가능한 객체는 원래 파일과 유사한 객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt; 메서드를 호출하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt; 메서드를 가져야 합니다. “파일과 유사한” 객체가 Python 내장 파일 객체의 이름과 일치하는 다른 메서드나 속성(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fileno()&lt;/code&gt;)을 가지고 있다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.file_wrapper&lt;/code&gt;는 이러한 메서드나 속성이 내장 파일 객체와 동일한 의미를 가진다고 가정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;플랫폼별 파일 처리의 실제 구현은 애플리케이션이 반환되고 서버 또는 게이트웨이가 래퍼 객체가 반환되었는지 확인한 후에 발생해야 합니다. (다시 말하지만, 미들웨어, 오류 핸들러 등의 존재로 인해 생성된 래퍼가 실제로 사용될 것이라고 보장되지 않습니다.)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt; 처리 외에, 애플리케이션에서 파일 래퍼를 반환하는 의미는 애플리케이션이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iter(filelike.read, &apos;&apos;)&lt;/code&gt;를 반환한 것과 동일해야 합니다. 즉, 전송은 전송이 시작될 때 “파일” 내의 현재 위치에서 시작하여 끝에 도달하거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt; 바이트가 작성될 때까지 계속되어야 합니다. (애플리케이션이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Length&lt;/code&gt;를 제공하지 않으면, 서버는 기본 파일 구현에 대한 지식을 사용하여 파일에서 하나를 생성할 수 있습니다.)&lt;/p&gt;

&lt;p&gt;물론, 플랫폼별 파일 전송 API는 일반적으로 임의의 “파일과 유사한” 객체를 허용하지 않습니다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.file_wrapper&lt;/code&gt;는 파일과 유사한 객체가 지원하는 플랫폼별 API와 함께 사용하기에 적합한지 판단하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fileno()&lt;/code&gt;(Unix와 유사한 OS) 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.nio.FileChannel&lt;/code&gt;(Jython 환경)과 같은 것을 검사해야 합니다.&lt;/p&gt;

&lt;p&gt;객체가 플랫폼 API에 적합하지 않더라도, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.file_wrapper&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt;를 래핑하는 반복 가능한 객체를 반환해야 합니다. 그래야 파일 래퍼를 사용하는 애플리케이션이 플랫폼 간에 이식 가능해집니다. 다음은 이전(2.2 이전) 및 새로운 Python 모두에 적합한 간단한 플랫폼 불가지론적 파일 래퍼 클래스입니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FileWrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filelike&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blksize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8192&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filelike&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filelike&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blksize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blksize&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasattr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filelike&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filelike&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__getitem__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filelike&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;IndexError&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 다음은 이를 사용하여 플랫폼별 API에 대한 접근을 제공하는 서버/게이트웨이의 코드 스니펫입니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;wsgi.file_wrapper&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileWrapper&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileWrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# result.filelike이 플랫폼별 API와 함께 사용할 수 있는지 확인하고,
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# 그렇다면 해당 API를 사용하여 결과를 전송합니다.
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# 그렇지 않으면 아래 일반적인 반복 가능한 처리 루프로 폴백합니다.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# etc.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasattr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;질의응답-questions-and-answers&quot;&gt;질의응답 (Questions and Answers)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt;이 딕셔너리여야 하는 이유는 무엇입니까? 서브클래스를 사용하면 무엇이 잘못됩니까?&lt;/strong&gt;
딕셔너리를 요구하는 이유는 서버 간 이식성을 극대화하기 위함입니다. 대안은 딕셔너리의 메서드 중 일부를 표준 및 이식 가능한 인터페이스로 정의하는 것이지만, 실제로는 대부분의 서버가 딕셔너리로 충분하다고 생각하고 프레임워크 개발자는 딕셔너리의 모든 기능을 기대할 것입니다. 그러나 일부 서버가 딕셔너리를 사용하지 않기로 선택하면, 해당 서버가 사양을 “준수”하더라도 상호 운용성 문제가 발생합니다. 따라서 딕셔너리를 의무화하면 사양이 단순화되고 상호 운용성이 보장됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;를 호출하고 바이트스트링/반복 가능한 객체를 yield/반환할 수 있는 이유는 무엇입니까? 한 가지 방법만 선택해야 하지 않습니까?&lt;/strong&gt;
반복 방식만 지원한다면 “푸시(push)” 가용성을 가정하는 현재 프레임워크는 어려움을 겪습니다. 그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;를 통한 푸시만 지원한다면, 대용량 파일 전송 시 서버 성능이 저하됩니다(작업자 스레드가 모든 출력이 전송될 때까지 새 요청 작업을 시작할 수 없는 경우). 따라서 이 절충안은 애플리케이션 프레임워크가 두 가지 접근 방식을 적절히 지원할 수 있도록 허용하며, 푸시 전용 접근 방식보다 서버 구현자에게 약간의 부담만 더 줍니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt;는 무엇을 위한 것입니까?&lt;/strong&gt;
애플리케이션 객체 실행 중에 쓰기 작업이 수행될 때, 애플리케이션은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try/finally&lt;/code&gt; 블록을 사용하여 리소스가 해제되도록 할 수 있습니다. 그러나 애플리케이션이 반복 가능한 객체를 반환하면, 사용된 모든 리소스는 해당 반복 가능한 객체가 가비지 수집될 때까지 해제되지 않습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt; 이디엄은 애플리케이션이 요청이 끝날 때 중요한 리소스를 해제할 수 있도록 하며, PEP 325에서 제안된 제너레이터의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try/finally&lt;/code&gt; 지원과 향후 호환됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이 인터페이스는 왜 이렇게 저수준입니까? 저는 기능 X(예: 쿠키, 세션, 영속성 등)를 원합니다!&lt;/strong&gt;
이것은 또 다른 Python 웹 프레임워크가 아닙니다. 프레임워크가 웹 서버와 통신하는 방식이며, 그 반대도 마찬가지입니다. 이러한 기능을 원한다면, 원하는 기능을 제공하는 웹 프레임워크를 선택해야 합니다. 그리고 해당 프레임워크가 WSGI 애플리케이션을 생성할 수 있도록 한다면, 대부분의 WSGI 지원 서버에서 실행할 수 있어야 합니다. 또한 일부 WSGI 서버는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;environ&lt;/code&gt; 딕셔너리에 제공되는 객체를 통해 추가 서비스를 제공할 수 있습니다. 자세한 내용은 해당 서버 문서를 참조하세요. (물론, 이러한 확장을 사용하는 애플리케이션은 다른 WSGI 기반 서버에는 이식할 수 없습니다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;왜 일반 HTTP 헤더 대신 CGI 변수를 사용합니까? 그리고 WSGI 정의 변수와 왜 섞여 있습니까?&lt;/strong&gt;
많은 기존 웹 프레임워크는 CGI 사양에 크게 의존하고 있으며, 기존 웹 서버는 CGI 변수를 생성하는 방법을 알고 있습니다. 대조적으로, 인바운드 HTTP 정보를 나타내는 다른 방법들은 파편화되어 있고 시장 점유율이 낮습니다. 따라서 CGI “표준”을 사용하는 것이 기존 구현을 활용하는 좋은 방법으로 보입니다. WSGI 변수와 섞는 것에 대해서는, 이를 분리하면 두 개의 딕셔너리 인수를 전달해야 하며, 실제적인 이점은 없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;상태 문자열은 어떻습니까? “200 OK” 대신 200만 전달할 수 없습니까?&lt;/strong&gt;
이렇게 하면 서버 또는 게이트웨이가 숫자 상태와 해당 메시지 테이블을 가져야 하므로 복잡해집니다. 대조적으로, 애플리케이션 또는 프레임워크 개발자는 자신이 사용하는 특정 응답 코드에 맞는 추가 텍스트를 입력하기 쉽고, 기존 프레임워크는 종종 필요한 메시지를 포함하는 테이블을 이미 가지고 있습니다. 따라서 균형을 고려할 때 서버 또는 게이트웨이 대신 애플리케이션/프레임워크가 책임을 지는 것이 더 낫습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.run_once&lt;/code&gt;가 앱을 한 번만 실행한다고 보장하지 않는 이유는 무엇입니까?&lt;/strong&gt;
이는 애플리케이션에게 “자주 실행되지 않도록 준비하라”는 단순한 제안이기 때문입니다. 이는 캐싱, 세션 등에 대한 여러 작동 모드를 가진 애플리케이션 프레임워크를 위한 것입니다. “다중 실행” 모드에서는 이러한 프레임워크가 캐시를 미리 로드할 수 있으며, 각 요청 후에 로그나 세션 데이터를 디스크에 쓰지 않을 수 있습니다. “단일 실행” 모드에서는 이러한 프레임워크가 미리 로드를 피하고 각 요청 후에 필요한 모든 쓰기 작업을 플러시합니다.&lt;/p&gt;

    &lt;p&gt;그러나 후자 모드에서 올바른 작동을 확인하기 위해 애플리케이션 또는 프레임워크를 테스트하려면 여러 번 호출해야 할 수 있습니다(또는 적어도 편리할 수 있음). 따라서 애플리케이션은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.run_once&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;로 설정되었다고 해서 다시 실행되지 않을 것이라고 확실히 가정해서는 안 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;기능 X(딕셔너리, 호출 가능한 객체 등)는 애플리케이션 코드에서 사용하기에 보기 흉합니다. 대신 객체를 사용하지 않는 이유는 무엇입니까?&lt;/strong&gt;
WSGI의 모든 이러한 구현 선택은 기능을 서로 분리하기 위해 특별히 의도된 것입니다. 이러한 기능을 캡슐화된 객체로 재결합하면 서버 또는 게이트웨이를 작성하는 것이 다소 어려워지고, 전체 기능의 작은 부분만 대체하거나 수정하는 미들웨어를 작성하는 것이 훨씬 더 어려워집니다.&lt;/p&gt;

    &lt;p&gt;본질적으로 미들웨어는 “책임 연쇄(Chain of Responsibility)” 패턴을 가지기를 원합니다. 이를 통해 일부 함수에 대한 “핸들러” 역할을 하면서 다른 함수는 변경되지 않은 채로 유지할 수 있습니다. 인터페이스가 확장 가능하게 유지되려면 일반 Python 객체로는 이를 수행하기 어렵습니다. 예를 들어, 확장(예: 미래 WSGI 버전에 의해 정의된 속성)이 전달되도록 하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__getattr__&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__getattribute__&lt;/code&gt; 오버라이드를 사용해야 합니다.&lt;/p&gt;

    &lt;p&gt;이러한 유형의 코드는 100% 정확하게 작성하기가 매우 어렵고, 직접 작성하고 싶어하는 사람이 거의 없습니다. 따라서 다른 사람의 구현을 복사하겠지만, 복사한 사람이 또 다른 엣지 케이스를 수정할 때 업데이트하지 못할 것입니다.&lt;/p&gt;

    &lt;p&gt;더 나아가, 이 필요한 상용구(boilerplate)는 순전히 부가적인 것이며, 애플리케이션 프레임워크 개발자를 위한 약간 더 예쁜 API를 지원하기 위해 미들웨어 개발자들이 지불하는 개발자 세금입니다. 그러나 애플리케이션 프레임워크 개발자는 일반적으로 하나의 프레임워크만 WSGI를 지원하도록 업데이트할 것이며, 프레임워크 전체의 매우 제한된 부분에서만 업데이트할 것입니다. 이는 그들의 첫 번째(그리고 아마도 유일한) WSGI 구현이 될 가능성이 높으므로, 이 사양을 손쉽게 사용하여 구현할 것입니다. 따라서 객체 속성 등으로 API를 “더 예쁘게” 만드는 노력은 이 대상에게는 낭비될 가능성이 높습니다.&lt;/p&gt;

    &lt;p&gt;직접적인 웹 애플리케이션 프로그래밍(웹 프레임워크 개발과 반대)에 사용하기 위해 더 예쁘거나 개선된 WSGI 인터페이스를 원하는 사람들에게는 애플리케이션 개발자가 편리하게 사용할 수 있도록 WSGI를 래핑하는 API 또는 프레임워크를 개발하도록 권장합니다. 이렇게 하면 WSGI는 서버 및 미들웨어 개발자에게는 편리하게 저수준으로 유지되면서도 애플리케이션 개발자에게 “보기 흉하게” 보이지 않을 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;제안논의-중-proposedunder-discussion&quot;&gt;제안/논의 중 (Proposed/Under Discussion)&lt;/h2&gt;

&lt;p&gt;다음 항목들은 현재 Web-SIG 및 다른 곳에서 논의 중이거나 PEP 작성자의 “할 일” 목록에 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.input&lt;/code&gt;이 파일 대신 이터레이터여야 합니까? 이는 비동기 애플리케이션 및 청크 인코딩 입력 스트림에 도움이 될 것입니다.&lt;/li&gt;
  &lt;li&gt;입력이 사용 가능할 때까지 또는 콜백이 발생할 때까지 애플리케이션 출력 반복을 일시 중지하는 선택적 확장이 논의 중입니다.&lt;/li&gt;
  &lt;li&gt;동기 대 비동기 앱 및 서버, 관련 스레딩 모델, 그리고 이러한 영역의 문제/설계 목표에 대한 섹션을 추가합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;감사-acknowledgements&quot;&gt;감사 (Acknowledgements)&lt;/h2&gt;

&lt;p&gt;이 개정된 초안을 가능하게 한 Web-SIG 메일링 리스트의 많은 분들의 사려 깊은 피드백에 감사드립니다. 특히:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Gregory “Grisha” Trubetskoy&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mod_python&lt;/code&gt;의 저자): 첫 초안이 “평범한 CGI”보다 이점을 제공하지 않는다고 비판하여, 더 나은 접근 방식을 찾도록 격려해주셨습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ian Bicking&lt;/strong&gt;: 멀티스레딩 및 다중 프로세스 옵션을 제대로 지정하도록 설득하고, 서버가 애플리케이션에 사용자 정의 확장 데이터를 제공하는 메커니즘을 제공하도록 졸라주셨습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Tony Lownds&lt;/strong&gt;: 상태와 헤더를 받아 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt; 함수를 반환하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_response&lt;/code&gt; 함수 개념을 제시했습니다. 그의 의견은 특히 애플리케이션 오류 메시지를 재정의하는 미들웨어를 허용하는 영역에서 예외 처리 기능 설계에도 영향을 주었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Alan Kennedy&lt;/strong&gt;: (사양이 최종 확정되기 훨씬 전에) WSGI-on-Jython을 구현하려는 용감한 시도로 “이전 Python 버전 지원” 섹션뿐만 아니라 선택적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.file_wrapper&lt;/code&gt; 기능 및 초기 바이트/유니코드 결정에도 영향을 주었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Mark Nottingham&lt;/strong&gt;: HTTP RFC 준수 문제, 특히 그가 지적하기 전까지는 존재조차 몰랐던 HTTP/1.1 기능과 관련하여 사양을 광범위하게 검토했습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Graham Dumpleton&lt;/strong&gt;: (저의 게으름과 어리석음에도 불구하고) WSGI의 Python 3 버전을 만들기 위해 지칠 줄 모르고 노력했으며, “native strings” 대 “byte strings” 개념을 제안하고, 수많은 HTTP, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wsgi.input&lt;/code&gt; 및 기타 개정 사항을 신중하게 해결했습니다. 이 새로운 PEP의 대부분의 공로가 그에게 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;참조-references&quot;&gt;참조 (References)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Python Wiki “Web Programming” 토픽 (https://wiki.python.org/moin/WebProgramming)&lt;/li&gt;
  &lt;li&gt;The Common Gateway Interface Specification, v 1.1, 3rd Draft (https://datatracker.ietf.org/doc/html/draft-coar-cgi-v11-03)&lt;/li&gt;
  &lt;li&gt;mod_ssl Reference, “Environment Variables” (http://www.modssl.org/docs/2.8/ssl_reference.html#ToC25)&lt;/li&gt;
  &lt;li&gt;Procedural issues regarding modifications to PEP 333 (https://mail.python.org/pipermail/python-dev/2010-September/104114.html)&lt;/li&gt;
  &lt;li&gt;SVN revision history for PEP 3333, showing differences from PEP 333 (http://svn.python.org/view/peps/trunk/pep-3333.txt?r1=84854&amp;amp;r2=HEAD)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h2&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인에 공개되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:24:56 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3333/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3333/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 3156 - Asynchronous IO Support Rebooted: the “asyncio” Module</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3156/&quot;&gt;PEP 3156 - Asynchronous IO Support Rebooted: the “asyncio” Module&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 12-Dec-2012&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-3156--비동기-io-지원-재정비-asyncio-모듈&quot;&gt;PEP 3156 – 비동기 I/O 지원 재정비: “asyncio” 모듈&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Guido van Rossum
&lt;strong&gt;상태:&lt;/strong&gt; Final
&lt;strong&gt;타입:&lt;/strong&gt; Standards Track
&lt;strong&gt;생성일:&lt;/strong&gt; 2012년 12월 12일
&lt;strong&gt;Python 버전:&lt;/strong&gt; 3.3&lt;/p&gt;

&lt;h3 id=&quot;요약-abstract&quot;&gt;요약 (Abstract)&lt;/h3&gt;
&lt;p&gt;이 문서는 Python 3 (Python 3.3부터)를 위한 비동기 I/O 제안입니다. PEP 3153에서 부족했던 구체적인 제안을 담고 있습니다. 이 제안에는 플러그인 가능한 (pluggable) 이벤트 루프, Twisted와 유사한 트랜스포트(transport) 및 프로토콜(protocol) 추상화, 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt; (PEP 380) 기반의 상위 수준 스케줄러가 포함됩니다. 제안된 패키지 이름은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio&lt;/code&gt;입니다.&lt;/p&gt;

&lt;h3 id=&quot;서론-introduction&quot;&gt;서론 (Introduction)&lt;/h3&gt;

&lt;h4 id=&quot;상태-status&quot;&gt;상태 (Status)&lt;/h4&gt;
&lt;p&gt;‘Tulip’이라는 코드명으로 참조 구현이 존재하며, 이 저장소를 기반으로 하는 패키지가 PyPI에 제공되어 Python 3.3 설치에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio&lt;/code&gt; 패키지를 사용할 수 있도록 합니다. 2013년 10월 20일부로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio&lt;/code&gt; 패키지는 Python 3.4 저장소에 체크인되어 Python 3.4-alpha-4와 함께 “잠정적 (provisional)” API 상태로 릴리스되었습니다. 이는 API에 대한 초기 피드백을 늘리기 위한 조치이며, PEP의 강제적인 수용을 의미하지 않습니다. 이 패키지는 Python 3.4에서 잠정적 상태를 유지하고 Python 3.5에서 최종 상태로 진행될 예정입니다.&lt;/p&gt;

&lt;h4 id=&quot;의존성-dependencies&quot;&gt;의존성 (Dependencies)&lt;/h4&gt;
&lt;p&gt;제안된 많은 기능에는 Python 3.3이 필요합니다. 참조 구현 (Tulip)은 Python 3.3 이상의 새로운 언어나 표준 라이브러리 기능, 서드파티 모듈 또는 패키지, 그리고 C 코드(Windows의 선택적 IOCP 지원 제외)를 필요로 하지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;모듈-네임스페이스-module-namespace&quot;&gt;모듈 네임스페이스 (Module Namespace)&lt;/h4&gt;
&lt;p&gt;여기서의 명세는 새로운 최상위 패키지인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio&lt;/code&gt;에 속합니다. 다양한 컴포넌트는 패키지의 별도 서브모듈에 위치합니다. 패키지는 각 서브모듈에서 공통 API를 임포트하여 패키지 속성으로 사용할 수 있도록 합니다 ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; 패키지와 유사). 덜 일반적인 API는 해당 서브모듈에서 명시적으로 임포트해야 하며, 이 경우 서브모듈 이름은 명세의 일부입니다.&lt;/p&gt;

&lt;h4 id=&quot;상호-운용성-interoperability&quot;&gt;상호 운용성 (Interoperability)&lt;/h4&gt;
&lt;p&gt;이벤트 루프는 대부분의 상호 운용성이 발생하는 지점입니다. Twisted, Tornado 또는 gevent와 같은 프레임워크가 경량 어댑터 또는 프록시를 사용하여 기본 이벤트 루프 구현을 자체 요구 사항에 맞게 조정하거나, 자체 이벤트 루프 구현을 기반으로 기본 이벤트 루프 구현을 대체하는 것이 쉬워야 합니다.&lt;/p&gt;

&lt;p&gt;이 상호 운용성을 효과적으로 만들기 위해, 서드파티 프레임워크에서 선호되는 적응 방향은 기본 이벤트 루프를 유지하고 이를 프레임워크의 API에 맞게 조정하는 것입니다. 이상적으로는 모든 서드파티 프레임워크가 자체 이벤트 루프 구현을 표준 구현으로 대체하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;두 가지 적응 방향을 모두 지원하기 위해 두 개의 별도 API가 지정됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;현재 이벤트 루프를 관리하기 위한 인터페이스.&lt;/li&gt;
  &lt;li&gt;적합한 (conforming) 이벤트 루프의 인터페이스.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이벤트 루프 API는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt;에 의존하지 않습니다. 대신 콜백, 추가 인터페이스 (트랜스포트 및 프로토콜) 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 조합하여 사용합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;는 PEP 3148에 정의된 것과 유사하지만, 다른 구현을 가지며 스레드에 묶여 있지 않습니다.&lt;/p&gt;

&lt;p&gt;콜백 사용을 좋아하지 않는 사용자를 위해, PEP 380의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 또는 PEP 492의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await&lt;/code&gt; 표현식을 사용하여 코루틴으로 비동기 I/O 코드를 작성하기 위한 스케줄러가 제공됩니다. 스케줄러는 플러그인 가능하지 않습니다. 플러그인 가능성은 이벤트 루프 수준에서 발생하며, 표준 스케줄러 구현은 모든 적합한 이벤트 루프 구현과 함께 작동해야 합니다.&lt;/p&gt;

&lt;p&gt;코루틴과 다른 비동기 프레임워크 간의 상호 운용성을 위해, 스케줄러는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;처럼 작동하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt; 클래스를 정의합니다.&lt;/p&gt;

&lt;h4 id=&quot;트랜스포트-및-프로토콜-transports-and-protocols&quot;&gt;트랜스포트 및 프로토콜 (Transports and Protocols)&lt;/h4&gt;
&lt;p&gt;Twisted에 익숙하지 않은 사람들을 위해 트랜스포트와 프로토콜 간의 관계를 간략하게 설명합니다. 가장 높은 수준에서 트랜스포트는 바이트가 어떻게 전송되는지에 관여하고, 프로토콜은 어떤 바이트를 전송할지 (그리고 어느 정도 언제 전송할지) 결정합니다.&lt;/p&gt;

&lt;p&gt;다른 방식으로 설명하면, 트랜스포트는 소켓(또는 유사한 I/O 엔드포인트)에 대한 추상화이며, 프로토콜은 트랜스포트 관점에서 애플리케이션에 대한 추상화입니다.&lt;/p&gt;

&lt;p&gt;트랜스포트와 프로토콜 객체 사이에는 거의 항상 1:1 관계가 있습니다. 프로토콜은 트랜스포트 메서드를 호출하여 데이터를 보내고, 트랜스포트는 프로토콜 메서드를 호출하여 수신된 데이터를 전달합니다. 트랜스포트나 프로토콜 메서드는 “블록”되지 않습니다.&lt;/p&gt;

&lt;p&gt;가장 일반적인 트랜스포트 유형은 양방향 스트림 트랜스포트 (bidirectional stream transport)입니다. 이는 각각 바이트 시퀀스를 전송하는 버퍼링된 스트림 쌍(각 방향으로 하나씩)을 나타냅니다. 가장 일반적인 예는 TCP 연결이나 SSL/TLS 연결입니다.&lt;/p&gt;

&lt;p&gt;프로토콜은 HTTP 또는 SMTP와 같은 “애플리케이션 수준” 프로토콜을 나타낼 수 있습니다. 또한 여러 프로토콜이 공유하는 추상화나 전체 애플리케이션을 구현할 수도 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;이벤트-루프-인터페이스-명세-event-loop-interface-specification&quot;&gt;이벤트 루프 인터페이스 명세 (Event Loop Interface Specification)&lt;/h3&gt;

&lt;h4 id=&quot;이벤트-루프-정책-현재-이벤트-루프-가져오기-및-설정-event-loop-policy-getting-and-setting-the-current-event-loop&quot;&gt;이벤트 루프 정책: 현재 이벤트 루프 가져오기 및 설정 (Event Loop Policy: Getting and Setting the Current Event Loop)&lt;/h4&gt;
&lt;p&gt;이벤트 루프 관리는 전역 (프로세스별) 객체인 이벤트 루프 정책에 의해 제어됩니다. 기본 정책이 있으며, 정책을 변경하는 API도 있습니다. 정책은 컨텍스트 개념을 정의하며, 컨텍스트별로 별도의 이벤트 루프를 관리합니다. 기본 정책의 컨텍스트 개념은 현재 스레드로 정의됩니다.&lt;/p&gt;

&lt;p&gt;현재 컨텍스트에 대한 이벤트 루프를 얻으려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_event_loop()&lt;/code&gt;를 사용합니다. 현재 컨텍스트에 이벤트 루프가 설정되지 않았고 현재 정책이 이벤트를 생성하도록 지정하지 않은 경우 예외가 발생합니다.&lt;/p&gt;

&lt;p&gt;현재 컨텍스트에 대한 이벤트 루프를 설정하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_event_loop(event_loop)&lt;/code&gt;를 사용합니다.&lt;/p&gt;

&lt;p&gt;새로운 이벤트 루프 객체를 생성하고 반환하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new_event_loop()&lt;/code&gt; 함수도 있습니다. 이를 현재 이벤트 루프로 만들려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_event_loop()&lt;/code&gt;를 호출해야 합니다.&lt;/p&gt;

&lt;p&gt;이벤트 루프 정책을 변경하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_event_loop_policy(policy)&lt;/code&gt;를 호출합니다.&lt;/p&gt;

&lt;h4 id=&quot;이벤트-루프를-명시적으로-전달-passing-an-event-loop-around-explicitly&quot;&gt;이벤트 루프를 명시적으로 전달 (Passing an Event Loop Around Explicitly)&lt;/h4&gt;
&lt;p&gt;전역 또는 스레드별 기본 이벤트 루프에 의존하지 않고 이벤트 루프를 사용하는 코드를 작성할 수 있습니다. 이를 위해 현재 이벤트 루프에 대한 액세스가 필요한 모든 API (이벤트 클래스의 메서드가 아닌)는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loop&lt;/code&gt;라는 선택적 키워드 인수를 가집니다.&lt;/p&gt;

&lt;h4 id=&quot;시간-지정-specifying-times&quot;&gt;시간 지정 (Specifying Times)&lt;/h4&gt;
&lt;p&gt;Python에서 모든 타임아웃, 간격 및 지연은 초 단위로 측정되며 정수 또는 부동소수점일 수 있습니다. 그러나 절대 시간은 POSIX 타임스탬프로 지정되지 않습니다. 기본 구현은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.monotonic()&lt;/code&gt;을 사용합니다.&lt;/p&gt;

&lt;h4 id=&quot;임베디드-이벤트-루프-embedded-event-loops&quot;&gt;임베디드 이벤트 루프 (Embedded Event Loops)&lt;/h4&gt;
&lt;p&gt;일부 플랫폼에서는 시스템에서 이벤트 루프가 제공됩니다. 이러한 루프는 사용자 코드가 시작될 때 이미 실행 중일 수 있으며, 프로그램을 종료하지 않고는 중지하거나 닫을 수 없는 경우가 있습니다. 이 경우 이벤트 루프를 시작, 중지 및 닫는 메서드를 구현할 수 없으며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_running()&lt;/code&gt;은 항상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를 반환할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;이벤트-루프-클래스-event-loop-classes&quot;&gt;이벤트 루프 클래스 (Event Loop Classes)&lt;/h4&gt;
&lt;p&gt;실제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventLoop&lt;/code&gt;라는 클래스는 없습니다. 모든 메서드를 구현 없이 정의하고 주로 문서를 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AbstractEventLoop&lt;/code&gt; 클래스가 있습니다. 다음 구체적인 클래스가 정의됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SelectorEventLoop&lt;/code&gt;&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;selectors&lt;/code&gt; 모듈 (Python 3.4의 새로운 기능)을 기반으로 하는 전체 API의 구체적인 구현입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProactorEventLoop&lt;/code&gt;&lt;/strong&gt;: I/O 이벤트 처리 및 시그널 처리 메서드를 제외한 API의 구체적인 구현입니다. Windows (또는 “오버랩 I/O”에 대한 유사 API를 지원하는 다른 플랫폼)에서만 정의됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;이벤트-루프-메서드-개요-event-loop-methods-overview&quot;&gt;이벤트 루프 메서드 개요 (Event Loop Methods Overview)&lt;/h4&gt;
&lt;p&gt;적합한 이벤트 루프의 메서드는 여러 범주로 그룹화됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;시작, 중지 및 닫기&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run_forever()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run_until_complete()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stop()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_running()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_closed()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기본 및 타이밍 콜백&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_soon()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_later()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_at()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스레드 상호 작용&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_soon_threadsafe()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run_in_executor()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_default_executor()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인터넷 이름 조회&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getnameinfo()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인터넷 연결&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_connection()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_server()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_datagram_endpoint()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;래핑된 소켓 메서드&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock_recv()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock_sendall()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock_connect()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock_accept()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;태스크 및 퓨처 지원&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_future()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_task()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_task_factory()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_task_factory()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오류 처리&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_exception_handler()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_exception_handler()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default_exception_handler()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_exception_handler()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디버그 모드&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_debug()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_debug()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 번째 범주의 메서드는 적합한 이벤트 루프 구현에 의해 지원될 수 있습니다. 지원되지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NotImplementedError&lt;/code&gt;를 발생시킵니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;I/O 콜백&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_reader()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove_reader()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_writer()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove_writer()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;파이프 및 서브프로세스&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect_read_pipe()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect_write_pipe()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subprocess_shell()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subprocess_exec()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시그널 콜백&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_signal_handler()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove_signal_handler()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;이벤트-루프-메서드-event-loop-methods&quot;&gt;이벤트 루프 메서드 (Event Loop Methods)&lt;/h4&gt;

&lt;h5 id=&quot;시작-중지-및-닫기-starting-stopping-and-closing&quot;&gt;시작, 중지 및 닫기 (Starting, Stopping and Closing)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run_forever()&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stop()&lt;/code&gt;이 호출될 때까지 이벤트 루프를 실행합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run_until_complete(future)&lt;/code&gt;: Future가 완료될 때까지 이벤트 루프를 실행합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stop()&lt;/code&gt;: 가능한 한 빨리 이벤트 루프를 중지합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_running()&lt;/code&gt;: 이벤트 루프가 현재 실행 중이면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를, 중지되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt;: 이벤트 루프를 닫고, 보유하고 있는 모든 리소스 (예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoll()&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kqueue()&lt;/code&gt;가 사용하는 파일 디스크립터)를 해제합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_closed()&lt;/code&gt;: 이벤트 루프가 닫혔으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를, 그렇지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;를 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;기본-콜백-basic-callbacks&quot;&gt;기본 콜백 (Basic Callbacks)&lt;/h5&gt;
&lt;p&gt;동일한 이벤트 루프와 관련된 콜백은 엄격하게 직렬화됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_soon(callback, *args)&lt;/code&gt;: 콜백을 가능한 한 빨리 호출하도록 스케줄링합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_later(delay, callback, *args)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delay&lt;/code&gt; 초 후에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callback(*args)&lt;/code&gt;가 호출되도록 준비합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_at(when, callback, *args)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_later()&lt;/code&gt;와 유사하지만, 시간이 절대 시간으로 표현됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time()&lt;/code&gt;: 이벤트 루프의 클록에 따른 현재 시간을 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;스레드-상호-작용-thread-interaction&quot;&gt;스레드 상호 작용 (Thread interaction)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_soon_threadsafe(callback, *args)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_soon()&lt;/code&gt;과 유사하지만, 다른 스레드에서 호출될 때 이벤트 루프가 I/O 대기 중이라면 이벤트 루프를 블록 해제합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run_in_executor(executor, callback, *args)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;executor&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callback(*args)&lt;/code&gt;를 호출하도록 준비합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_default_executor(executor)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run_in_executor()&lt;/code&gt;에서 사용하는 기본 Executor를 설정합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;인터넷-이름-조회-internet-name-lookups&quot;&gt;인터넷 이름 조회 (Internet name lookups)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo(host, port, family=0, type=0, proto=0, flags=0)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.getaddrinfo()&lt;/code&gt; 함수와 유사하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getnameinfo(sockaddr, flags=0)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.getnameinfo()&lt;/code&gt;와 유사하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;인터넷-연결-internet-connections&quot;&gt;인터넷 연결 (Internet connections)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_connection(protocol_factory, host, port, &amp;lt;options&amp;gt;)&lt;/code&gt;: 지정된 인터넷 호스트 및 포트에 스트림 연결을 생성합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_server(protocol_factory, host, port, &amp;lt;options&amp;gt;)&lt;/code&gt;: 연결을 수락하는 서비스 루프에 들어갑니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_datagram_endpoint(protocol_factory, local_addr=None, remote_addr=None, &amp;lt;options&amp;gt;)&lt;/code&gt;: 데이터그램(일반적으로 UDP 패킷)을 보내고 받는 엔드포인트를 생성합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;래핑된-소켓-메서드-wrapped-socket-methods&quot;&gt;래핑된 소켓 메서드 (Wrapped Socket Methods)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock_recv(sock, n)&lt;/code&gt;: 소켓 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock&lt;/code&gt;에서 최대 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; 바이트를 수신합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock_sendall(sock, data)&lt;/code&gt;: 소켓 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock&lt;/code&gt;으로 바이트 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt;를 보냅니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock_connect(sock, address)&lt;/code&gt;: 지정된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;address&lt;/code&gt;에 연결합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock_accept(sock)&lt;/code&gt;: 소켓에서 연결을 수락합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;io-콜백-io-callbacks&quot;&gt;I/O 콜백 (I/O Callbacks)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_reader(fd, callback, *args)&lt;/code&gt;: 파일 디스크립터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt;가 읽기 준비가 되었을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callback(*args)&lt;/code&gt;가 호출되도록 준비합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_writer(fd, callback, *args)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_reader()&lt;/code&gt;와 유사하지만, 읽기 대신 쓰기를 위해 콜백을 등록합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove_reader(fd)&lt;/code&gt;: 파일 디스크립터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fd&lt;/code&gt;에 대한 현재 읽기 콜백을 취소합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove_writer(fd)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_writer()&lt;/code&gt;에 대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove_reader()&lt;/code&gt;와 유사합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;파이프-및-서브프로세스-pipes-and-subprocesses&quot;&gt;파이프 및 서브프로세스 (Pipes and Subprocesses)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect_read_pipe(protocol_factory, pipe)&lt;/code&gt;: UNIX 파이프의 읽기 끝을 래핑하는 파일 유사 객체에서 단방향 스트림 연결을 생성합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect_write_pipe(protocol_factory, pipe)&lt;/code&gt;: UNIX 파이프의 쓰기 끝을 래핑하는 파일 유사 객체에서 단방향 스트림 연결을 생성합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subprocess_shell(protocol_factory, cmd, &amp;lt;options&amp;gt;)&lt;/code&gt;: 플랫폼의 “쉘” 구문을 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmd&lt;/code&gt;로부터 서브프로세스를 생성합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subprocess_exec(protocol_factory, *args, &amp;lt;options&amp;gt;)&lt;/code&gt;: 하나 이상의 문자열 인수로부터 서브프로세스를 생성합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;시그널-콜백-signal-callbacks&quot;&gt;시그널 콜백 (Signal callbacks)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_signal_handler(sig, callback, *args)&lt;/code&gt;: 시그널 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sig&lt;/code&gt;가 수신될 때마다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callback(*args)&lt;/code&gt;가 호출되도록 준비합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove_signal_handler(sig)&lt;/code&gt;: 시그널 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sig&lt;/code&gt;에 대한 핸들러가 설정되어 있다면 제거합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;콜백의-상호-배제-mutual-exclusion-of-callbacks&quot;&gt;콜백의 상호 배제 (Mutual Exclusion of Callbacks)&lt;/h4&gt;
&lt;p&gt;이벤트 루프는 콜백의 상호 배제를 강제해야 합니다. 즉, 이전에 실행 중인 콜백이 아직 실행 중인 동안에는 새로운 콜백을 시작해서는 안 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;예외-exceptions&quot;&gt;예외 (Exceptions)&lt;/h4&gt;
&lt;p&gt;Python에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exception&lt;/code&gt; 클래스에서 파생된 예외와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BaseException&lt;/code&gt;에서 파생된 예외 두 가지 범주가 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exception&lt;/code&gt;에서 파생된 예외는 일반적으로 적절하게 잡아서 처리됩니다. 그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BaseException&lt;/code&gt;에서만 파생된 예외는 일반적으로 잡히지 않으며, 일반적으로 트레이스백과 함께 프로그램이 종료됩니다.&lt;/p&gt;

&lt;p&gt;이벤트 루프는 후자의 범주를 예외 핸들러로 전달합니다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt; 딕셔너리를 매개변수로 받는 콜백입니다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt;는 ‘message’, ‘exception’, ‘source_traceback’, ‘handle_traceback’과 같은 키를 가질 수 있습니다.&lt;/p&gt;

&lt;p&gt;이벤트 루프에는 예외 처리와 관련된 다음과 같은 메서드가 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_exception_handler()&lt;/code&gt;: 루프에 등록된 현재 예외 핸들러를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_exception_handler(handler)&lt;/code&gt;: 예외 핸들러를 설정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default_exception_handler(context)&lt;/code&gt;: 이 루프 구현을 위한 기본 예외 핸들러입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_exception_handler(context)&lt;/code&gt;: 등록된 예외 핸들러에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt;를 전달합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;디버그-모드-debug-mode&quot;&gt;디버그 모드 (Debug Mode)&lt;/h4&gt;
&lt;p&gt;기본적으로 루프는 릴리스 모드에서 작동합니다. 애플리케이션은 성능 저하를 감수하고 더 나은 오류 보고를 위해 디버그 모드를 활성화할 수 있습니다.&lt;/p&gt;

&lt;p&gt;디버그 모드에서는 많은 추가 검사가 활성화됩니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;future&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task&lt;/code&gt;의 처리되지 않은 예외에 대한 소스 트레이스백을 사용할 수 있습니다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loop.slow_callback_duration&lt;/code&gt; 속성은 느린 콜백이 보고되기 전에 두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt; 지점 사이에서 허용되는 최대 실행 시간을 제어합니다.&lt;/p&gt;

&lt;p&gt;디버그 모드와 관련된 두 가지 메서드가 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_debug()&lt;/code&gt;: 디버그 모드가 활성화되어 있으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를, 그렇지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_debug(enabled)&lt;/code&gt;: 인수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;이면 디버그 모드를 활성화합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PYTHONASYNCIODEBUG&lt;/code&gt; 환경 변수가 정의되어 있고 비어 있지 않으면 디버그 모드가 자동으로 활성화됩니다.&lt;/p&gt;

&lt;h4 id=&quot;핸들-handles&quot;&gt;핸들 (Handles)&lt;/h4&gt;
&lt;p&gt;일회성 콜백 ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_soon()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_later()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_at()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call_soon_threadsafe()&lt;/code&gt; )을 등록하는 다양한 메서드는 모두 콜백을 취소하는 데 사용할 수 있는 등록을 나타내는 객체를 반환합니다. 이 객체를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handle&lt;/code&gt;이라고 합니다. 핸들은 불투명하며 하나의 공개 메서드만 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancel()&lt;/code&gt;: 콜백을 취소합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_reader()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_writer()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_signal_handler()&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handle&lt;/code&gt;을 반환하지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;서버-servers&quot;&gt;서버 (Servers)&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_server()&lt;/code&gt; 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Server&lt;/code&gt; 인스턴스를 반환하며, 이는 요청을 수락하는 데 사용되는 소켓(또는 기타 네트워크 객체)을 래핑합니다. 이 클래스에는 두 가지 공개 메서드가 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt;: 서비스를 닫습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait_closed()&lt;/code&gt;: 서비스가 닫히고 모든 수락된 요청이 처리될 때까지 블록하는 코루틴입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;퓨처-futures&quot;&gt;퓨처 (Futures)&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.Future&lt;/code&gt; 클래스는 PEP 3148에 명세된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;concurrent.futures.Future&lt;/code&gt; 클래스와 의도적으로 유사하지만 약간의 차이가 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.Future&lt;/code&gt;는 다음과 같은 공개 API를 지원합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancel()&lt;/code&gt;: Future를 취소하려고 시도합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancelled()&lt;/code&gt;: Future가 성공적으로 취소되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;done()&lt;/code&gt;: Future가 완료되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result()&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_result()&lt;/code&gt;로 설정된 결과를 반환하거나, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_exception()&lt;/code&gt;으로 설정된 예외를 발생시킵니다. 취소되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CancelledError&lt;/code&gt;를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exception()&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_exception()&lt;/code&gt;으로 예외가 설정되었으면 예외를 반환하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_result()&lt;/code&gt;로 결과가 설정되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt;을 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_done_callback(fn)&lt;/code&gt;: Future가 완료될 때 실행될 콜백을 추가합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove_done_callback(fn)&lt;/code&gt;: 콜백 목록에서 인수를 제거합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_result(result)&lt;/code&gt;: Future를 완료 상태로 만들고 콜백을 스케줄링합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_exception(exception)&lt;/code&gt;: Future를 완료 상태로 만들고 콜백을 스케줄링합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음 예외가 정의됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InvalidStateError&lt;/code&gt;: Future가 메서드를 호출하기에 적합하지 않은 상태일 때 발생합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InvalidTimeoutError&lt;/code&gt;: 0이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 인수가 주어졌을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exception()&lt;/code&gt;에 의해 발생합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CancelledError&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;concurrent.futures.CancelledError&lt;/code&gt;의 별칭입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TimeoutError&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;concurrent.futures.TimeoutError&lt;/code&gt;의 별칭입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.Future&lt;/code&gt; 객체는 코루틴에서 사용될 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 표현식에 허용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;와 관련된 몇 가지 공개 함수는 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.async(arg)&lt;/code&gt;: 코루틴 객체 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 인수로 받아 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.wrap_future(future)&lt;/code&gt;: PEP 3148 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 받아 이벤트 루프와 호환되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;트랜스포트-transports&quot;&gt;트랜스포트 (Transports)&lt;/h4&gt;
&lt;p&gt;트랜스포트와 프로토콜은 Twisted 및 PEP 3153의 강력한 영향을 받았습니다. 사용자는 거의 트랜스포트를 구현하거나 인스턴스화하지 않습니다. 대신 이벤트 루프는 트랜스포트를 설정하는 유틸리티 메서드를 제공합니다.&lt;/p&gt;

&lt;h5 id=&quot;모든-트랜스포트용-메서드-methods-for-all-transports&quot;&gt;모든 트랜스포트용 메서드 (Methods For All Transports)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_extra_info(name, default=None)&lt;/code&gt;: 트랜스포트에 대한 구현별 정보를 반환하는 포괄적인 메서드입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;양방향-스트림-트랜스포트-bidirectional-stream-transports&quot;&gt;양방향 스트림 트랜스포트 (Bidirectional Stream Transports)&lt;/h5&gt;
&lt;p&gt;양방향 스트림 트랜스포트는 소켓 또는 유사한 것 (예: UNIX 파이프 쌍 또는 SSL/TLS 연결) 위에 있는 추상화입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write(data)&lt;/code&gt;: 바이트를 씁니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;writelines(iterable)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iterable&lt;/code&gt;의 각 데이터에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;를 호출하는 것과 같습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_eof()&lt;/code&gt;: 연결의 쓰기 끝을 닫습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;can_write_eof()&lt;/code&gt;: 프로토콜이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_eof()&lt;/code&gt;를 지원하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_write_buffer_size()&lt;/code&gt;: 트랜스포트의 쓰기 버퍼 현재 크기를 바이트 단위로 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_write_buffer_limits(high=None, low=None)&lt;/code&gt;: 흐름 제어를 위한 상위 및 하위 워터 마크를 설정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pause_reading()&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resume_reading()&lt;/code&gt; 호출 전까지 프로토콜로의 데이터 전달을 일시 중단합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resume_reading()&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_received()&lt;/code&gt;를 통해 프로토콜로의 데이터 전달을 다시 시작합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt;: 다른 쪽 엔티티와의 연결을 끊습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abort()&lt;/code&gt;: 즉시 연결을 끊습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;단방향-스트림-트랜스포트-unidirectional-stream-transports&quot;&gt;단방향 스트림 트랜스포트 (Unidirectional Stream Transports)&lt;/h5&gt;
&lt;p&gt;쓰기 스트림 트랜스포트는 양방향 스트림 트랜스포트에 설명된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;writelines()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_eof()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;can_write_eof()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abort()&lt;/code&gt; 메서드를 지원합니다.
읽기 스트림 트랜스포트는 양방향 스트림 트랜스포트에 설명된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pause_reading()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resume_reading()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt; 메서드를 지원합니다.&lt;/p&gt;

&lt;h5 id=&quot;데이터그램-트랜스포트-datagram-transports&quot;&gt;데이터그램 트랜스포트 (Datagram Transports)&lt;/h5&gt;
&lt;p&gt;데이터그램 트랜스포트는 다음과 같은 메서드를 가집니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendto(data, addr=None)&lt;/code&gt;: 데이터그램을 보냅니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abort()&lt;/code&gt;: 즉시 트랜스포트를 닫습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt;: 트랜스포트를 닫습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;서브프로세스-트랜스포트-subprocess-transports&quot;&gt;서브프로세스 트랜스포트 (Subprocess Transports)&lt;/h5&gt;
&lt;p&gt;서브프로세스 트랜스포트는 다음과 같은 메서드를 가집니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_pid()&lt;/code&gt;: 서브프로세스의 프로세스 ID를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_returncode()&lt;/code&gt;: 프로세스가 종료된 경우 프로세스 반환 코드를 반환하고, 그렇지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt;을 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_pipe_transport(fd)&lt;/code&gt;: 인수에 해당하는 파이프 트랜스포트를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send_signal(signal)&lt;/code&gt;: 서브프로세스에 시그널을 보냅니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terminate()&lt;/code&gt;: 서브프로세스를 종료합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kill()&lt;/code&gt;: 서브프로세스를 강제 종료합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close()&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terminate()&lt;/code&gt;의 별칭입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;프로토콜-protocols&quot;&gt;프로토콜 (Protocols)&lt;/h4&gt;
&lt;p&gt;프로토콜은 항상 트랜스포트와 함께 사용됩니다.&lt;/p&gt;

&lt;h5 id=&quot;스트림-프로토콜-stream-protocols&quot;&gt;스트림 프로토콜 (Stream Protocols)&lt;/h5&gt;
&lt;p&gt;양방향 스트림 프로토콜은 트랜스포트에 의해 호출될 다음 메서드를 구현해야 합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connection_made(transport)&lt;/code&gt;: 트랜스포트가 준비되었고 다른 쪽 엔티티에 연결되었음을 나타냅니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_received(data)&lt;/code&gt;: 트랜스포트가 연결에서 일부 바이트를 읽었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eof_received()&lt;/code&gt;: 다른 쪽 끝에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_eof()&lt;/code&gt; (또는 이에 상응하는 것)를 호출했을 때 호출됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pause_writing()&lt;/code&gt;: 프로토콜이 트랜스포트에 데이터 쓰기를 일시적으로 중지하도록 요청합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resume_writing()&lt;/code&gt;: 프로토콜이 트랜스포트에 데이터 쓰기를 다시 시작해도 안전하다고 알려줍니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connection_lost(exc)&lt;/code&gt;: 트랜스포트가 닫혔거나 중단되었거나, 다른 쪽 끝이 연결을 깔끔하게 닫았음을 감지했거나, 예기치 않은 오류가 발생했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;데이터그램-프로토콜-datagram-protocols&quot;&gt;데이터그램 프로토콜 (Datagram Protocols)&lt;/h5&gt;
&lt;p&gt;데이터그램 프로토콜은 스트림 프로토콜과 동일한 시그니처를 가진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connection_made()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connection_lost()&lt;/code&gt; 메서드를 가집니다. 또한 다음 메서드를 가집니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;datagram_received(data, addr)&lt;/code&gt;: 데이터그램 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt;가 원격 주소 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addr&lt;/code&gt;에서 수신되었음을 나타냅니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;error_received(exc)&lt;/code&gt;: 전송 또는 수신 작업이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt; 예외를 발생시켰음을 나타냅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;서브프로세스-프로토콜-subprocess-protocol&quot;&gt;서브프로세스 프로토콜 (Subprocess Protocol)&lt;/h5&gt;
&lt;p&gt;서브프로세스 프로토콜은 스트림 프로토콜과 동일한 시그니처를 가진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connection_made()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connection_lost()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pause_writing()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resume_writing()&lt;/code&gt; 메서드를 가집니다. 또한 다음 메서드를 가집니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pipe_data_received(fd, data)&lt;/code&gt;: 서브프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stdout&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stderr&lt;/code&gt;에 데이터를 쓸 때 호출됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pipe_connection_lost(fd, exc)&lt;/code&gt;: 서브프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stdin&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stdout&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stderr&lt;/code&gt;를 닫을 때 호출됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;process_exited()&lt;/code&gt;: 서브프로세스가 종료되었을 때 호출됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;콜백-스타일-callback-style&quot;&gt;콜백 스타일 (Callback Style)&lt;/h4&gt;
&lt;p&gt;콜백을 받는 대부분의 인터페이스는 위치 인수도 받습니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo(&quot;abc&quot;, 42)&lt;/code&gt;가 곧 호출되도록 준비하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loop.call_soon(foo, &quot;abc&quot;, 42)&lt;/code&gt;를 호출합니다. 이 규칙은 일반적인 콜백 프로그래밍에서 필요한 작은 람다 함수의 수를 크게 줄여줍니다. 이 규칙은 특히 키워드 인수를 지원하지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;코루틴-및-스케줄러-coroutines-and-the-scheduler&quot;&gt;코루틴 및 스케줄러 (Coroutines and the Scheduler)&lt;/h4&gt;
&lt;p&gt;이 부분은 이벤트 루프 인터페이스와 상태가 다르기 때문에 별도의 최상위 섹션으로 분류됩니다. 코루틴 사용은 선택 사항이며, 콜백만 사용하여 코드를 작성하는 것도 완벽하게 괜찮습니다.&lt;/p&gt;

&lt;h5 id=&quot;코루틴-coroutines&quot;&gt;코루틴 (Coroutines)&lt;/h5&gt;
&lt;p&gt;코루틴은 특정 규칙을 따르는 제너레이터입니다. 문서화를 위해 모든 코루틴은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@asyncio.coroutine&lt;/code&gt;으로 데코레이션되어야 하지만, 이는 엄격하게 강제될 수 없습니다. 코루틴은 원래의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt; 구문 대신 PEP 380에 도입된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 구문을 사용합니다.&lt;/p&gt;

&lt;p&gt;코루틴이 할 수 있는 일:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result = yield from future&lt;/code&gt;: future가 완료될 때까지 코루틴을 일시 중단하고, future의 결과를 반환하거나 예외를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result = yield from coroutine&lt;/code&gt;: 다른 코루틴이 결과를 생성할 때까지 기다립니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return expression&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt;을 사용하여 이 코루틴을 기다리는 코루틴에 결과를 생성합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;raise exception&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt;을 사용하여 이 코루틴을 기다리는 코루틴에서 예외를 발생시킵니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;코루틴을 호출해도 코드가 실행되지는 않습니다. 이는 단순히 제너레이터이며, 호출에 의해 반환된 코루틴 객체는 실제로 제너레이터 객체로, 반복되기 전까지는 아무것도 하지 않습니다.&lt;/p&gt;

&lt;h5 id=&quot;여러-코루틴-기다리기-waiting-for-multiple-coroutines&quot;&gt;여러 코루틴 기다리기 (Waiting for Multiple Coroutines)&lt;/h5&gt;
&lt;p&gt;여러 코루틴 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 기다리기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;concurrent.futures&lt;/code&gt; 패키지의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;as_completed()&lt;/code&gt; API와 유사한 두 가지 API가 제공됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.wait(fs, timeout=None, return_when=ALL_COMPLETED)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs&lt;/code&gt;로 주어진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 또는 코루틴이 완료될 때까지 기다리는 코루틴입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.as_completed(fs, timeout=None)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 또는 코루틴의 값을 반환하는 이터레이터를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.wait_for(f, timeout)&lt;/code&gt;: 타임아웃을 사용하여 단일 코루틴 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 기다리는 편의 기능입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.gather(f1, f2, ...)&lt;/code&gt;: 모든 인수 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 또는 코루틴)가 완료될 때까지 기다리고 해당 결과 목록을 반환하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.shield(f)&lt;/code&gt;: 취소로부터 보호하면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 기다립니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;슬리핑-sleeping&quot;&gt;슬리핑 (Sleeping)&lt;/h5&gt;
&lt;p&gt;코루틴 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.sleep(delay)&lt;/code&gt;는 지정된 시간 지연 후에 반환됩니다.&lt;/p&gt;

&lt;h5 id=&quot;태스크-tasks&quot;&gt;태스크 (Tasks)&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;는 독립적으로 실행되는 코루틴을 관리하는 객체입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt; 인터페이스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 인터페이스와 동일하며, 실제로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;의 서브클래스입니다.
완료되지 않은 태스크를 취소하면 코루틴에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.CancelledError&lt;/code&gt; 예외가 발생합니다.&lt;/p&gt;

&lt;p&gt;코루틴을 태스크로 변환하려면 코루틴 함수를 호출하고 결과 코루틴 객체를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loop.create_task()&lt;/code&gt; 메서드에 전달합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.ensure_future()&lt;/code&gt;를 사용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Task&lt;/code&gt; 클래스는 새로운 메서드를 추가하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;에서 파생됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;current_task(loop=None)&lt;/code&gt;: 이벤트 루프에서 현재 실행 중인 태스크를 반환하는 클래스 메서드입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;all_tasks(loop=None)&lt;/code&gt;: 루프에 대한 모든 활성 태스크 세트를 반환하는 클래스 메서드입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;스케줄러-the-scheduler&quot;&gt;스케줄러 (The Scheduler)&lt;/h5&gt;
&lt;p&gt;스케줄러는 공개 인터페이스가 없습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from future&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from task&lt;/code&gt;를 사용하여 상호 작용합니다.&lt;/p&gt;

&lt;h4 id=&quot;편의-유틸리티-convenience-utilities&quot;&gt;편의 유틸리티 (Convenience Utilities)&lt;/h4&gt;
&lt;p&gt;FTP 또는 HTTP와 같은 기본 스트림 기반 클라이언트 및 서버 작성을 단순화하기 위해 몇 가지 함수와 클래스가 제공됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.open_connection(host, port)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventLoop.create_connection()&lt;/code&gt;의 래퍼로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(reader, writer)&lt;/code&gt; 쌍을 반환하는 코루틴입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.start_server(client_connected_cb, host, port)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventLoop.create_server()&lt;/code&gt;의 래퍼로, 간단한 콜백 함수를 받습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StreamReader&lt;/code&gt;: 읽기 전용 바이너리 스트림과 유사한 인터페이스를 제공하는 클래스입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StreamWriter&lt;/code&gt;: 쓰기 전용 바이너리 스트림과 유사한 인터페이스를 제공하는 클래스입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StreamReaderProtocol&lt;/code&gt;: 양방향 스트림 트랜스포트/프로토콜 인터페이스와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StreamReader&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StreamWriter&lt;/code&gt; 클래스 사이의 어댑터로 사용되는 프로토콜 구현입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;동기화-synchronization&quot;&gt;동기화 (Synchronization)&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;threading&lt;/code&gt; 모듈의 잠금, 이벤트, 조건 및 세마포어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.locks&lt;/code&gt; 서브모듈을 임포트하여 구현되고 액세스할 수 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queue&lt;/code&gt; 모듈의 큐는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.queues&lt;/code&gt; 서브모듈을 임포트하여 구현되고 액세스할 수 있습니다.&lt;/p&gt;

&lt;h5 id=&quot;잠금-locks&quot;&gt;잠금 (Locks)&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.locks&lt;/code&gt;에서 다음 클래스가 제공됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Event&lt;/code&gt;를 제외한 모든 클래스에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; 문을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt;과 함께 사용하여 잠금을 획득하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; 블록을 나가는 방식에 관계없이 잠금이 해제되도록 할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lock&lt;/code&gt;: 기본 뮤텍스.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Event&lt;/code&gt;: 이벤트 변수.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Condition&lt;/code&gt;: 조건 변수.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Semaphore&lt;/code&gt;: 세마포어.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BoundedSemaphore&lt;/code&gt;: 바운드 세마포어.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;큐-queues&quot;&gt;큐 (Queues)&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.queues&lt;/code&gt;에서 다음 클래스와 예외가 제공됩니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Queue&lt;/code&gt;: 표준 큐.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PriorityQueue&lt;/code&gt;: 우선순위 순서로 항목을 검색하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Queue&lt;/code&gt;의 서브클래스.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LifoQueue&lt;/code&gt;: 가장 최근에 추가된 항목을 먼저 검색하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Queue&lt;/code&gt;의 서브클래스.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JoinableQueue&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task_done()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;join()&lt;/code&gt; 메서드를 가진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Queue&lt;/code&gt;의 서브클래스.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Empty&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Full&lt;/code&gt;: 큐가 비어 있거나 가득 찼을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_nowait()&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put_nowait()&lt;/code&gt;가 호출될 때 발생하는 예외.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;기타-miscellaneous&quot;&gt;기타 (Miscellaneous)&lt;/h4&gt;

&lt;h5 id=&quot;로깅-logging&quot;&gt;로깅 (Logging)&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio&lt;/code&gt; 패키지에서 수행되는 모든 로깅은 단일 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logging.Logger&lt;/code&gt; 객체인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.logger&lt;/code&gt;를 사용합니다.&lt;/p&gt;

&lt;h5 id=&quot;unix에서-sigchld-처리-sigchld-handling-on-unix&quot;&gt;UNIX에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGCHLD&lt;/code&gt; 처리 (SIGCHLD handling on UNIX)&lt;/h5&gt;
&lt;p&gt;서브프로세스 프로토콜에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;process_exited()&lt;/code&gt; 메서드를 효율적으로 구현하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIGCHLD&lt;/code&gt; 시그널 핸들러가 필요합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.get_child_watcher()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio.set_child_watcher()&lt;/code&gt; 두 가지 추가 함수와 이벤트 루프 정책에 해당하는 메서드가 있습니다.&lt;/p&gt;

&lt;p&gt;두 가지 자식 감시자 (child watcher) 구현 클래스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FastChildWatcher&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SafeChildWatcher&lt;/code&gt;입니다. 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SafeChildWatcher&lt;/code&gt; 클래스가 사용됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FastChildWatcher&lt;/code&gt; 클래스는 효율적이지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncio&lt;/code&gt; 이벤트 루프를 사용하지 않고 서브프로세스를 생성하는 다른 코드와 충돌할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;위시-리스트-wish-list&quot;&gt;위시 리스트 (Wish List)&lt;/h4&gt;
&lt;p&gt;(이 기능들이 바람직하다는 데는 동의하지만, Python 3.4 베타 1이 릴리스될 때 구현이 제공되지 않았습니다. Python 3.5에 추가될 예정입니다.)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TCP 소켓을 SSL/TLS로 업그레이드하는 “start TLS” 작업 지원.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;공개-문제-open-issues&quot;&gt;공개 문제 (Open Issues)&lt;/h4&gt;
&lt;p&gt;(이러한 문제는 PEP가 수용되면서 사실상 현상 유지로 해결되었습니다. 그러나 PEP의 잠정적 상태는 Python 3.5에서 이러한 결정을 재검토할 수 있도록 합니다.)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_connection()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_datagram_endpoint()&lt;/code&gt;에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proto&lt;/code&gt; 인수가 있지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create_server()&lt;/code&gt;에는 없는 이유는 무엇입니까?&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getaddrinfo()&lt;/code&gt;에 대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;family&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flag&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proto&lt;/code&gt; 인수가 때때로 0이고 때로는 명명된 상수 (값도 0인)인 이유는 무엇입니까?&lt;/li&gt;
  &lt;li&gt;루프가 중지되는 중인지 여부를 알려주는 다른 조회 메서드가 필요합니까?&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handle&lt;/code&gt;에 대한 더 완전한 공개 API가 필요합니까?&lt;/li&gt;
  &lt;li&gt;디버깅 API가 필요합니까?&lt;/li&gt;
  &lt;li&gt;인트로스펙션 API가 필요합니까?&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock_sendto()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sock_recvfrom()&lt;/code&gt;와 같은 더 많은 소켓 I/O 메서드가 필요합니까?&lt;/li&gt;
  &lt;li&gt;다양한 타임아웃을 제어하는 API가 필요할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;참고-자료-references&quot;&gt;참고 자료 (References)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;PEP 492: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;async&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await&lt;/code&gt;의 의미를 설명합니다.&lt;/li&gt;
  &lt;li&gt;PEP 380: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt;의 의미를 설명합니다.&lt;/li&gt;
  &lt;li&gt;PEP 3148: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;concurrent.futures.Future&lt;/code&gt;를 설명합니다.&lt;/li&gt;
  &lt;li&gt;PEP 3153: 거부되었지만, 트랜스포트와 프로토콜을 분리할 필요성을 잘 설명합니다.&lt;/li&gt;
  &lt;li&gt;PEP 418: 시간 유지 문제에 대해 논의합니다.&lt;/li&gt;
  &lt;li&gt;Tulip repo: http://code.google.com/p/tulip/&lt;/li&gt;
  &lt;li&gt;PyPI: Python Package Index at http://pypi.python.org/&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;감사-acknowledgments&quot;&gt;감사 (Acknowledgments)&lt;/h4&gt;
&lt;p&gt;PEP 3153 외에도 PEP 380 및 Greg Ewing의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 튜토리얼, Twisted, Tornado, ZeroMQ, pyftpdlib 및 wattle (Steve Dower의 반대 제안)의 영향을 받았습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:21:50 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3156/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3156/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 3155 - Qualified name for classes and functions</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3155/&quot;&gt;PEP 3155 - Qualified name for classes and functions&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 29-Oct-2011&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;pep-3155--클래스-및-함수를-위한-qualified-name-정규화된-이름&quot;&gt;PEP 3155 – 클래스 및 함수를 위한 Qualified Name (정규화된 이름)&lt;/h1&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;
&lt;p&gt;PEP 3155는 Python의 클래스(class)와 함수(function) 객체에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;이라는 새로운 속성을 추가하는 것을 제안합니다. 이 속성은 객체가 정의된 모듈(module) 최상위 레벨로부터 객체까지의 “점(.)으로 구분된 경로”를 제공하여, 중첩된 클래스, 메서드, 중첩 함수에 대한 인트로스펙션(introspection) 기능을 크게 향상시킵니다. 이 PEP는 Python 3.3에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Final&lt;/code&gt; (최종)으로 채택되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;제안-배경-rationale&quot;&gt;제안 배경 (Rationale)&lt;/h2&gt;
&lt;p&gt;Python의 인트로스펙션 기능은 오랫동안 중첩된 클래스에 대한 지원이 부족했습니다. 예를 들어, 클래스 객체만으로는 해당 클래스가 다른 클래스 내부에 정의되었는지, 아니면 모듈 최상위 레벨에 정의되었는지 알 수 없었고, 전자의 경우 어떤 클래스 안에 정의되었는지도 파악할 수 없었습니다.&lt;/p&gt;

&lt;p&gt;Python 3에서는 과거 “언바운드 메서드(unbound methods)”로 알려졌던 개념이 사라지면서 이러한 인트로스펙션 제한이 더욱 심화되었습니다. Python 2에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C.f.im_class&lt;/code&gt;와 같이 메서드 객체로부터 해당 메서드를 정의한 클래스를 찾아갈 수 있었지만, Python 3에서는 이러한 기능이 제거되었습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Python 2 예시
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;im_class&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# &amp;lt;class &apos;__main__.C&apos;&amp;gt;
&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;``````&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;python&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Python 3 예시
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;im_class&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# AttributeError: &apos;function&apos; object has no attribute &apos;im_class&apos;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이러한 제한은 사용자에게 제공되는 인트로스펙션 기능을 제한하며, 특히 Twisted Core와 같이 메서드 객체 인트로스펙션 문제가 여러 번 발생했던 소프트웨어를 Python 3으로 포팅할 때 실제 문제를 야기했습니다. 또한, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pickle&lt;/code&gt; 모듈의 지원에도 영향을 미쳤습니다.&lt;/p&gt;

&lt;h2 id=&quot;제안-내용-proposal&quot;&gt;제안 내용 (Proposal)&lt;/h2&gt;

&lt;p&gt;이 PEP는 함수와 클래스에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt; 속성을 추가할 것을 제안합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최상위 레벨(Top-level) 함수 및 클래스:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__name__&lt;/code&gt; 속성과 동일합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중첩된 클래스, 메서드, 중첩 함수:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;은 모듈 최상위 레벨로부터 객체까지의 “점(.)으로 구분된 경로”를 포함합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;함수의 로컬 네임스페이스(local namespace):&lt;/strong&gt; 이 경로에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;locals&amp;gt;&lt;/code&gt;라는 구성 요소로 표현됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repr()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str()&lt;/code&gt; 동작 변경:&lt;/strong&gt; 함수와 클래스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repr()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str()&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__name__&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;을 사용하도록 수정됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;중첩-클래스-예시-example-with-nested-classes&quot;&gt;중첩 클래스 예시 (Example with nested classes)&lt;/h3&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;출력:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C
C.f
C.D
C.D.g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;중첩-함수-예시-example-with-nested-functions&quot;&gt;중첩 함수 예시 (Example with nested functions)&lt;/h3&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;출력:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f
f.&amp;lt;locals&amp;gt;.g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;제약-사항-limitations&quot;&gt;제약 사항 (Limitations)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;중첩 함수 (및 함수 내에 정의된 클래스):&lt;/strong&gt; 중첩된 함수(그리고 함수 내에 정의된 클래스)의 경우, 함수의 네임스페이스는 외부에서 접근할 수 없기 때문에 점(.)으로 구분된 경로를 프로그래밍 방식으로 탐색할 수는 없습니다. 그러나 사람(개발자)이 읽기에는 단순한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__name__&lt;/code&gt;보다 훨씬 유용합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;정적 계산:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__name__&lt;/code&gt; 속성처럼, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt; 속성도 정적으로(statically) 계산되므로 재할당(rebinding)을 자동으로 따르지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;논의-discussion&quot;&gt;논의 (Discussion)&lt;/h2&gt;

&lt;h3 id=&quot;모듈-이름을-제외하는-이유-excluding-the-module-name&quot;&gt;모듈 이름을 제외하는 이유 (Excluding the module name)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__name__&lt;/code&gt;과 마찬가지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;은 모듈 이름을 포함하지 않습니다. 이는 모듈 별칭(aliasing) 및 재할당에 독립적이며, 컴파일 시점에 계산할 수 있도록 합니다.&lt;/p&gt;

&lt;h3 id=&quot;언바운드-메서드를-부활시키지-않는-이유-reviving-unbound-methods&quot;&gt;언바운드 메서드를 부활시키지 않는 이유 (Reviving unbound methods)&lt;/h3&gt;
&lt;p&gt;언바운드 메서드(unbound methods)를 부활시키는 것은 이 PEP가 해결하는 문제의 일부만을 해결할 뿐이며, 더 높은 비용(추가적인 객체 타입과 추가적인 간접 참조, 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt; 속성 추가보다 더 복잡함)이 수반됩니다.&lt;/p&gt;

&lt;h3 id=&quot;이름-선택-naming-choice&quot;&gt;이름 선택 (Naming choice)&lt;/h3&gt;
&lt;p&gt;“Qualified name”은 추가되는 속성이 무엇을 의미하는지 짧은 구절로 가장 잘 표현합니다. 이는 모듈 이름을 의도적으로 포함하지 않으므로 “full name” 또는 “fully qualified name”이 아닙니다. “path”라고 부르면 파일 시스템 경로 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__file__&lt;/code&gt; 속성과 혼동될 위험이 있습니다.&lt;/p&gt;

&lt;p&gt;속성 이름에 대한 첫 번째 제안은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qname__&lt;/code&gt;이었지만, 많은 사람들이 (XML 사양과 같은 곳에서 이전의 전문 용어 사용에 대해 알지 못했기 때문에) 모호하고 명확하지 않다고 여겼습니다. 이로 인해 약간 더 길지만 더 명시적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;이 최종적으로 선택되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;실제-python-사용에-미치는-영향&quot;&gt;실제 Python 사용에 미치는 영향&lt;/h2&gt;

&lt;p&gt;PEP 3155의 도입으로 Python 개발자들은 다음과 같은 이점을 얻게 됩니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;향상된 인트로스펙션:&lt;/strong&gt; 중첩된 클래스, 메서드, 함수를 포함하여 모든 Python 객체의 “출생지”를 명확하게 파악할 수 있게 되었습니다. 이는 디버깅, 로깅, 프레임워크 개발 시 객체의 완전한 식별 경로가 필요할 때 매우 유용합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디버깅 및 로깅:&lt;/strong&gt; 오류 메시지나 로그에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;을 활용하여 특정 함수나 클래스가 호출된 위치를 더 정확하게 표시할 수 있게 되었습니다. 이는 복잡한 애플리케이션에서 문제의 근원을 찾아내는 데 큰 도움이 됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;직렬화(Pickling) 개선:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pickle&lt;/code&gt; 모듈과 같은 직렬화 도구들이 객체를 더 정확하게 식별하고 복원하는 데 활용될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메타프로그래밍(Metaprogramming) 용이성:&lt;/strong&gt; 런타임에 코드를 분석하거나 생성하는 메타프로그래밍 시, 객체의 정규화된 이름은 동적인 코드 조작에 필요한 정보를 제공합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;은 Python 3.3부터 표준으로 채택되어 현재 모든 최신 Python 버전에서 사용할 수 있는 중요한 인트로스펙션 도구입니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;참고 자료:&lt;/strong&gt;
 PEP 3155 – Qualified name for classes and functions. peps.python.org.
 “QName” entry in Wikipedia. en.wikipedia.org/wiki/QName.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The translation and summary are complete, adhering to all the specified guidelines.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Professionalism maintained.&lt;/li&gt;
  &lt;li&gt;Terminology handled as requested (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List Comprehension&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Generator (제너레이터)&lt;/code&gt; - though not directly used in this PEP, the principle is applied to terms like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;introspection&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unbound methods&lt;/code&gt;). Code keywords not translated.&lt;/li&gt;
  &lt;li&gt;Markdown used for readability.&lt;/li&gt;
  &lt;li&gt;Accuracy and completeness ensured.&lt;/li&gt;
  &lt;li&gt;Citations added.&lt;/li&gt;
  &lt;li&gt;Impact on Python usage clearly explained.# PEP 3155 – 클래스 및 함수를 위한 Qualified Name (정규화된 이름)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개요-1&quot;&gt;개요&lt;/h2&gt;
&lt;p&gt;PEP 3155는 Python의 클래스(class)와 함수(function) 객체에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;이라는 새로운 속성을 추가하는 것을 제안하며, 이는 Python 3.3에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Final&lt;/code&gt; (최종)으로 채택되었습니다. 이 속성은 객체가 정의된 모듈(module) 최상위 레벨로부터 객체까지의 “점(.)으로 구분된 경로”를 제공하여, 중첩된 클래스, 메서드, 중첩 함수에 대한 인트로스펙션(introspection) 기능을 크게 향상시킵니다.&lt;/p&gt;

&lt;h2 id=&quot;제안-배경-rationale-1&quot;&gt;제안 배경 (Rationale)&lt;/h2&gt;
&lt;p&gt;Python의 인트로스펙션 기능은 오랫동안 중첩된 클래스에 대한 지원이 부족했습니다. 클래스 객체만으로는 해당 클래스가 다른 클래스 내부에 정의되었는지, 또는 모듈 최상위 레벨에 정의되었는지 알 수 없었으며, 중첩된 경우 어떤 클래스 안에 정의되었는지도 파악할 수 없었습니다.&lt;/p&gt;

&lt;p&gt;Python 3에서는 과거 “언바운드 메서드(unbound methods)”로 알려졌던 개념이 사라지면서 이러한 인트로스펙션 제한이 더욱 심화되었습니다. Python 2에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C.f.im_class&lt;/code&gt;를 통해 메서드 객체로부터 해당 메서드를 정의한 클래스를 찾아갈 수 있었지만, Python 3에서는 이 기능이 제거되었습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Python 2 예시
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# C.f.im_class는 &amp;lt;class &apos;__main__.C&apos;&amp;gt;를 반환
&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;``````&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;python&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Python 3 예시
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# C.f.im_class는 AttributeError를 발생시킴
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이러한 제한은 사용자에게 제공되는 인트로스펙션 기능을 제한하며, 소프트웨어를 Python 3으로 포팅(porting)할 때, 특히 메서드 객체 인트로스펙션 문제가 여러 번 발생했던 Twisted Core와 같은 경우 실제 문제를 야기했습니다. 또한, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pickle&lt;/code&gt; 모듈의 직렬화(serialization) 지원에도 영향을 미쳤습니다.&lt;/p&gt;

&lt;h2 id=&quot;제안-내용-proposal-1&quot;&gt;제안 내용 (Proposal)&lt;/h2&gt;

&lt;p&gt;이 PEP는 함수와 클래스에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt; 속성을 추가할 것을 제안합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최상위 레벨(Top-level) 함수 및 클래스:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt; 속성은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__name__&lt;/code&gt; 속성과 동일합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중첩된 클래스, 메서드, 중첩 함수:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt; 속성은 모듈 최상위 레벨로부터 객체까지의 “점(.)으로 구분된 경로”를 포함합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;함수의 로컬 네임스페이스(local namespace):&lt;/strong&gt; 경로에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;locals&amp;gt;&lt;/code&gt;라는 구성 요소로 표현됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repr()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str()&lt;/code&gt; 동작 변경:&lt;/strong&gt; 함수와 클래스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repr()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str()&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__name__&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;을 사용하도록 수정됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;중첩-클래스-예시-example-with-nested-classes-1&quot;&gt;중첩 클래스 예시 (Example with nested classes)&lt;/h3&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;# 출력: C
&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# 출력: C.f
&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# 출력: C.D
&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 출력: C.D.g
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;중첩-함수-예시-example-with-nested-functions-1&quot;&gt;중첩 함수 예시 (Example with nested functions)&lt;/h3&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;# 출력: f
&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__qualname__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# 출력: f.&amp;lt;locals&amp;gt;.g
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;제약-사항-limitations-1&quot;&gt;제약 사항 (Limitations)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;중첩 함수:&lt;/strong&gt; 중첩된 함수(및 함수 내에 정의된 클래스)의 경우, 함수의 네임스페이스는 외부에서 접근할 수 없으므로 점(.)으로 구분된 경로를 프로그래밍 방식으로 탐색할 수는 없습니다. 그러나 개발자가 읽기에는 단순한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__name__&lt;/code&gt;보다 훨씬 유용합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;정적 계산:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__name__&lt;/code&gt; 속성처럼, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt; 속성도 정적으로(statically) 계산되므로 재할당(rebinding)을 자동으로 따르지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;논의-discussion-1&quot;&gt;논의 (Discussion)&lt;/h2&gt;

&lt;h3 id=&quot;모듈-이름을-제외하는-이유-excluding-the-module-name-1&quot;&gt;모듈 이름을 제외하는 이유 (Excluding the module name)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__name__&lt;/code&gt;과 마찬가지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;은 모듈 이름을 포함하지 않습니다. 이는 모듈 별칭(aliasing) 및 재할당에 독립적이며, 컴파일 시점에 계산할 수 있도록 합니다.&lt;/p&gt;

&lt;h3 id=&quot;언바운드-메서드를-부활시키지-않는-이유-reviving-unbound-methods-1&quot;&gt;언바운드 메서드를 부활시키지 않는 이유 (Reviving unbound methods)&lt;/h3&gt;
&lt;p&gt;언바운드 메서드(unbound methods)를 부활시키는 것은 이 PEP가 해결하는 문제의 일부만을 해결할 뿐이며, 더 높은 비용(추가적인 객체 타입과 추가적인 간접 참조)이 수반됩니다.&lt;/p&gt;

&lt;h3 id=&quot;이름-선택-naming-choice-1&quot;&gt;이름 선택 (Naming choice)&lt;/h3&gt;
&lt;p&gt;“Qualified name”은 추가되는 속성이 무엇을 의미하는지 짧은 구절로 가장 잘 표현합니다. 이는 모듈 이름을 의도적으로 포함하지 않으므로 “full name” 또는 “fully qualified name”이 아닙니다. “path”라고 부르면 파일 시스템 경로 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__file__&lt;/code&gt; 속성과 혼동될 위험이 있습니다.&lt;/p&gt;

&lt;p&gt;속성 이름에 대한 첫 번째 제안은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qname__&lt;/code&gt;이었지만, 많은 사람들이 (XML 사양과 같은 곳에서 이전의 전문 용어 사용에 대해 알지 못했기 때문에) 모호하고 명확하지 않다고 여겼습니다. 이로 인해 약간 더 길지만 더 명시적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;이 최종적으로 선택되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;실제-python-사용에-미치는-영향-1&quot;&gt;실제 Python 사용에 미치는 영향&lt;/h2&gt;

&lt;p&gt;PEP 3155의 도입으로 Python 개발자들은 다음과 같은 이점을 얻게 됩니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;향상된 인트로스펙션:&lt;/strong&gt; 중첩된 클래스, 메서드, 함수를 포함하여 모든 Python 객체의 “출생지”를 명확하게 파악할 수 있게 되었습니다. 이는 디버깅, 로깅, 프레임워크 개발 시 객체의 완전한 식별 경로가 필요할 때 매우 유용합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디버깅 및 로깅:&lt;/strong&gt; 오류 메시지나 로그에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;을 활용하여 특정 함수나 클래스가 호출된 위치를 더 정확하게 표시할 수 있게 되었습니다. 이는 복잡한 애플리케이션에서 문제의 근원을 찾아내는 데 큰 도움이 됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;직렬화(Pickling) 개선:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pickle&lt;/code&gt; 모듈과 같은 직렬화 도구들이 객체를 더 정확하게 식별하고 복원하는 데 활용될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메타프로그래밍(Metaprogramming) 용이성:&lt;/strong&gt; 런타임에 코드를 분석하거나 생성하는 메타프로그래밍 시, 객체의 정규화된 이름은 동적인 코드 조작에 필요한 정보를 제공합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt;은 Python 3.3부터 표준으로 채택되어 현재 모든 최신 Python 버전에서 사용할 수 있는 중요한 인트로스펙션 도구입니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;참고 자료:&lt;/strong&gt;
 PEP 3155 – Qualified name for classes and functions. peps.python.org.
 “QName” entry in Wikipedia. en.wikipedia.org/wiki/QName.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:20:50 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3155/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3155/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 3154 - Pickle protocol version 4</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3154/&quot;&gt;PEP 3154 - Pickle protocol version 4&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 11-Aug-2011&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-3154--pickle-프로토콜-버전-4&quot;&gt;PEP 3154 – Pickle 프로토콜 버전 4&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Antoine Pitrou&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final (최종)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track (표준 트랙)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;생성일:&lt;/strong&gt; 2011년 8월 11일&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Python 버전:&lt;/strong&gt; 3.4&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;초록-abstract&quot;&gt;초록 (Abstract)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pickle&lt;/code&gt; 모듈을 사용하여 직렬화된 데이터는 Python 버전 간에 이식 가능해야 합니다. 또한, 최신 언어 기능과 구현별 기능도 지원해야 합니다. 이러한 이유로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pickle&lt;/code&gt; 모듈은 여러 프로토콜(현재 0부터 3까지)을 인식하며, 각 프로토콜은 다른 Python 버전에서 도입되었습니다. 낮은 번호의 프로토콜 버전을 사용하면 이전 Python 버전과 데이터를 교환할 수 있으며, 높은 번호의 프로토콜을 사용하면 최신 기능에 접근하고 때로는 더 효율적인 자원 사용(직렬화/역직렬화에 필요한 CPU 시간 및 데이터 전송에 필요한 디스크 크기/네트워크 대역폭)이 가능합니다.&lt;/p&gt;

&lt;h3 id=&quot;도입-배경-rationale&quot;&gt;도입 배경 (Rationale)&lt;/h3&gt;

&lt;p&gt;현재 최신 프로토콜인 프로토콜 3은 Python 3.0과 함께 등장했으며, 언어의 새로운 호환 불가능한 기능(주로 기본 Unicode 문자열 및 새로운 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt; 객체)을 지원합니다. 당시에는 다른 방식으로 프로토콜을 개선할 기회가 주어지지 않았습니다.&lt;/p&gt;

&lt;p&gt;이 PEP는 새로운 pickle 프로토콜 버전에서 점진적인 개선 사항들을 추진하려는 시도입니다. 새로운 pickle 프로토콜의 도입은 드문 일이므로, 가능한 한 많은 개선 사항을 모으기 위해 PEP 프로세스가 활용되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;제안된-변경-사항-proposed-changes&quot;&gt;제안된 변경 사항 (Proposed changes)&lt;/h3&gt;

&lt;h4 id=&quot;프레이밍-framing&quot;&gt;프레이밍 (Framing)&lt;/h4&gt;

&lt;p&gt;기존에는 스트림에서 객체를 역직렬화할 때( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loads()&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load()&lt;/code&gt; 호출) 파일과 유사한 객체에서 많은 작은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 호출이 발생하여 잠재적으로 성능에 큰 영향을 미칠 수 있었습니다.&lt;/p&gt;

&lt;p&gt;반면, 프로토콜 4는 바이너리 프레이밍 기능을 제공합니다. pickle의 일반적인 구조는 다음과 같습니다:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+------+------+
| 0x80 | 0x04 | 프로토콜 헤더 (2 bytes)
+------+------+-----------+
| OP   | FRAME opcode (1 byte)
+------+------+-----------+
| MM MM MM MM MM MM MM MM | 프레임 크기 (8 bytes, little-endian)
+------+------------------+
| .... | 첫 번째 프레임 내용 (M bytes)
+------+
| OP   | FRAME opcode (1 byte)
+------+------+-----------+
| NN NN NN NN NN NN NN NN | 프레임 크기 (8 bytes, little-endian)
+------+------------------+
| .... | 두 번째 프레임 내용 (N bytes)
+------+
etc.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;구현을 단순하게 유지하기 위해 pickle opcode가 프레임 경계를 넘어가는 것은 금지됩니다. 피클러(pickler)는 그러한 pickle을 생성하지 않도록 주의하고, 언피클러(unpickler)는 이를 거부합니다. 또한, “마지막 프레임” 마커는 없습니다. 마지막 프레임은 단순히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STOP&lt;/code&gt; opcode로 끝나는 프레임입니다. 잘 작성된 C 구현은 프레이밍 계층에 추가적인 메모리 복사가 필요 없어 전반적인 (역)직렬화 효율성을 유지합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고:&lt;/strong&gt; 피클러가 pickle 스트림을 프레임으로 분할하는 방법은 구현 세부 사항입니다. 예를 들어, 약 64 KiB에 도달하자마자 프레임을 “닫는” 것은 성능과 pickle 크기 오버헤드 모두에 합리적인 선택입니다.&lt;/p&gt;

&lt;h4 id=&quot;모든-opcode에-대한-바이너리-인코딩-binary-encoding-for-all-opcodes&quot;&gt;모든 opcode에 대한 바이너리 인코딩 (Binary encoding for all opcodes)&lt;/h4&gt;

&lt;p&gt;프로토콜 3에서 여전히 사용되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GLOBAL&lt;/code&gt; opcode는 pickle 스트림에서 줄 바꿈(newlines)을 찾는 소위 “텍스트” 모드를 사용합니다. 이는 또한 바이너리 프레이밍의 구현을 복잡하게 만듭니다. 프로토콜 4는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GLOBAL&lt;/code&gt; opcode의 사용을 금지하고, 스택에서 피연산자를 가져오는 새로운 opcode인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STACK_GLOBAL&lt;/code&gt;로 대체합니다.&lt;/p&gt;

&lt;h4 id=&quot;더-많은-조회-가능한-객체-직렬화-serializing-more-lookupable-objects&quot;&gt;더 많은 “조회 가능한” 객체 직렬화 (Serializing more “lookupable” objects)&lt;/h4&gt;

&lt;p&gt;기본적으로 pickle은 모듈-전역 함수와 클래스만 직렬화할 수 있습니다. 바인딩되지 않은 메서드(unbound methods)와 같은 다른 종류의 객체를 지원하는 것은 일반적인 요청입니다. 실제로 바인딩된 메서드(bound methods)와 같은 일부 객체에 대한 서드 파티 지원은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multiprocessing&lt;/code&gt; 모듈에 구현되어 있습니다.&lt;/p&gt;

&lt;p&gt;PEP 3155의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__qualname__&lt;/code&gt; 속성은 이름으로 더 많은 객체를 조회할 수 있게 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STACK_GLOBAL&lt;/code&gt; opcode가 점(dot)으로 구분된 이름을 허용하면 표준 pickle 구현이 이러한 모든 종류의 객체를 지원할 수 있게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;대형-객체를-위한-64비트-opcode-64-bit-opcodes-for-large-objects&quot;&gt;대형 객체를 위한 64비트 opcode (64-bit opcodes for large objects)&lt;/h4&gt;

&lt;p&gt;현재 프로토콜 버전은 다양한 내장 타입( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt;)의 객체 크기를 32비트 정수로 내보냅니다. 이는 대용량 데이터의 직렬화를 금지합니다. 매우 큰 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 객체를 지원하기 위해 새로운 opcode가 필요합니다.&lt;/p&gt;

&lt;h4 id=&quot;set-및-frozenset을-위한-네이티브-opcode-native-opcodes-for-sets-and-frozensets&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frozenset&lt;/code&gt;을 위한 네이티브 opcode (Native opcodes for sets and frozensets)&lt;/h4&gt;

&lt;p&gt;많은 일반적인 내장 타입(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dict&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tuple&lt;/code&gt;)은 직렬화 및 역직렬화 시 자원 소비를 개선하기 위한 전용 opcode를 가지고 있습니다. 그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frozenset&lt;/code&gt;은 그렇지 않습니다. 이러한 opcode를 추가하는 것은 명백한 개선 사항입니다. 또한, 전용 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt; 지원은 자기 참조 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt;을 pickle할 수 없던 현재의 문제를 해결하는 데 도움이 될 수 있습니다 [2, cite: 1].&lt;/p&gt;

&lt;h4 id=&quot;키워드-인수로-__new__-호출-calling-new-with-keyword-arguments&quot;&gt;키워드 인수로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__new__&lt;/code&gt; 호출 (Calling &lt;strong&gt;new&lt;/strong&gt; with keyword arguments)&lt;/h4&gt;

&lt;p&gt;현재, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__new__&lt;/code&gt; 메서드가 키워드 전용 인수를 사용하도록 요구하는 클래스는 pickle될 수 없습니다(또는 오히려 역직렬화될 수 없습니다) [3, cite: 1]. 새로운 특수 메서드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__getnewargs_ex__&lt;/code&gt;)와 새로운 opcode(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NEWOBJ_EX&lt;/code&gt;)가 모두 필요합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__getnewargs_ex__&lt;/code&gt; 메서드가 존재한다면, 두 개의 항목을 가진 튜플 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(args, kwargs)&lt;/code&gt;를 반환해야 합니다. 여기서 첫 번째 항목은 위치 인수(positional arguments)의 튜플이고, 두 번째 항목은 클래스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__new__&lt;/code&gt; 메서드에 대한 키워드 인수(keyword arguments)의 딕셔너리입니다.&lt;/p&gt;

&lt;h4 id=&quot;더-나은-문자열-인코딩-better-string-encoding&quot;&gt;더 나은 문자열 인코딩 (Better string encoding)&lt;/h4&gt;

&lt;p&gt;짧은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 객체는 현재 길이가 4바이트 정수로 인코딩되어 낭비가 심합니다. 1바이트 길이 접두사를 가진 특정 opcode는 많은 pickle의 크기를 줄일 것입니다.&lt;/p&gt;

&lt;h4 id=&quot;더-작은-메모화-smaller-memoization&quot;&gt;더 작은 메모화 (Smaller memoization)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUT&lt;/code&gt; opcode는 스택의 최상단 항목이 메모 딕셔너리의 어느 항목에 메모화될지 선택하기 위한 명시적인 인덱스를 모두 필요로 합니다. 그러나 실제로는 이러한 숫자는 순차적으로 할당됩니다. 새로운 opcode인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEMOIZE&lt;/code&gt;는 대신 스택의 최상단 항목을 메모 딕셔너리의 현재 크기와 동일한 인덱스에 저장합니다. 이는 모든 비원자적 데이터 타입에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUT&lt;/code&gt; opcode가 방출되므로 더 짧은 pickle을 가능하게 합니다.&lt;/p&gt;

&lt;h3 id=&quot;새로운-opcode-요약-summary-of-new-opcodes&quot;&gt;새로운 opcode 요약 (Summary of new opcodes)&lt;/h3&gt;

&lt;p&gt;다음은 제안된 구현의 상태를 반영합니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FRAME&lt;/code&gt;&lt;/strong&gt;: 새로운 프레임을 도입합니다 (8바이트 프레임 크기와 프레임 내용이 뒤따릅니다).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHORT_BINUNICODE&lt;/code&gt;&lt;/strong&gt;: 1바이트 크기 접두사(따라서 256바이트 미만)를 가진 UTF8 인코딩 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 객체를 스택에 푸시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BINUNICODE8&lt;/code&gt;&lt;/strong&gt;: 8바이트 크기 접두사를 가진 UTF8 인코딩 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt; 객체(2^32바이트보다 긴 문자열로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BINUNICODE&lt;/code&gt;를 사용하여 직렬화할 수 없는 경우)를 스택에 푸시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BINBYTES8&lt;/code&gt;&lt;/strong&gt;: 8바이트 크기 접두사를 가진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt; 객체(2^32바이트보다 긴 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt; 객체로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BINBYTES&lt;/code&gt;를 사용하여 직렬화할 수 없는 경우)를 스택에 푸시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EMPTY_SET&lt;/code&gt;&lt;/strong&gt;: 새로운 빈 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt; 객체를 스택에 푸시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADDITEMS&lt;/code&gt;&lt;/strong&gt;: 스택 최상단 항목들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt;에 추가합니다 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EMPTY_SET&lt;/code&gt;과 함께 사용).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FROZENSET&lt;/code&gt;&lt;/strong&gt;: 스택 최상단 항목들로부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;frozenset&lt;/code&gt; 객체를 생성하고 스택에 푸시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NEWOBJ_EX&lt;/code&gt;&lt;/strong&gt;: 스택 최상단 세 항목 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cls&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;args&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kwargs&lt;/code&gt;를 가져와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cls.__new__(*args, **kwargs)&lt;/code&gt; 호출 결과를 스택에 푸시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STACK_GLOBAL&lt;/code&gt;&lt;/strong&gt;: 스택 최상단 두 항목 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;module_name&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qualname&lt;/code&gt;을 가져와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;module_name&lt;/code&gt;이라는 모듈에서 점(dot)으로 구분된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qualname&lt;/code&gt;을 조회한 결과를 스택에 푸시합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MEMOIZE&lt;/code&gt;&lt;/strong&gt;: 스택 최상단 객체를 메모 딕셔너리에 메모 딕셔너리의 현재 크기와 동일한 인덱스로 저장합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;대안-아이디어-alternative-ideas&quot;&gt;대안 아이디어 (Alternative ideas)&lt;/h3&gt;

&lt;h4 id=&quot;프리페칭-prefetching&quot;&gt;프리페칭 (Prefetching)&lt;/h4&gt;

&lt;p&gt;Serhiy Storchaka는 알려진 pickle 청크를 명시적으로 선언하기 위해 프레이밍을 특별한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PREFETCH&lt;/code&gt; opcode(2 또는 4바이트 인수 포함)로 대체할 것을 제안했습니다. 대용량 데이터는 이러한 청크 외부에 pickle될 수 있습니다. 순진한(naïve) 언피클러는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PREFETCH&lt;/code&gt; opcode를 건너뛰고도 pickle을 제대로 디코딩할 수 있어야 하지만, 적절한 오류 처리를 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PREFETCH&lt;/code&gt; 길이가 opcode 경계에 해당하는지 확인해야 할 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;감사-acknowledgments&quot;&gt;감사 (Acknowledgments)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Alexandre Vassalotti&lt;/li&gt;
  &lt;li&gt;Serhiy Storchaka&lt;/li&gt;
  &lt;li&gt;Stefan Mihaila&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;참고-자료-references&quot;&gt;참고 자료 (References)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;“pickle not 64-bit ready”: &lt;a href=&quot;http://bugs.python.org/issue11564&quot;&gt;http://bugs.python.org/issue11564&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;“Cannot pickle self-referencing sets”: &lt;a href=&quot;http://bugs.python.org/issue9269&quot;&gt;http://bugs.python.org/issue9269&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;“pickle/copyreg doesn’t support keyword only arguments in &lt;strong&gt;new&lt;/strong&gt;”: &lt;a href=&quot;http://bugs.python.org/issue4727&quot;&gt;http://bugs.python.org/issue4727&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;“pickle should support methods”: &lt;a href=&quot;http://bugs.python.org/issue9276&quot;&gt;http://bugs.python.org/issue9276&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Lib/multiprocessing/forking.py: &lt;a href=&quot;http://hg.python.org/cpython/file/baea9f5f973c/Lib/multiprocessing/forking.py#l54&quot;&gt;http://hg.python.org/cpython/file/baea9f5f973c/Lib/multiprocessing/forking.py#l54&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Implement PEP 3154, by Alexandre Vassalotti &lt;a href=&quot;http://bugs.python.org/issue17810&quot;&gt;http://bugs.python.org/issue17810&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Implement PEP 3154, by Stefan Mihaila &lt;a href=&quot;http://bugs.python.org/issue15642&quot;&gt;http://bugs.python.org/issue15642&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h3&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인에 공개되었습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 19:20:26 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3154/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3154/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Superseded] PEP 3153 - Asynchronous IO support</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3153/&quot;&gt;PEP 3153 - Asynchronous IO support&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Superseded&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 29-May-2011&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;pep-3153--비동기-io-지원&quot;&gt;PEP 3153 – 비동기 IO 지원&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Laurens Van Houtven &lt;_ at=&quot;&quot; lvh.cc=&quot;&quot;&gt;&lt;/_&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태:&lt;/strong&gt; 대체됨 (Superseded)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형:&lt;/strong&gt; 표준 트랙 (Standards Track)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;생성일:&lt;/strong&gt; 2011년 5월 29일&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;후속 PEP:&lt;/strong&gt; PEP 3156에 의해 대체됨 (Superseded-By: 3156)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;초록-abstract&quot;&gt;초록 (Abstract)&lt;/h2&gt;

&lt;p&gt;이 PEP는 파이썬 표준 라이브러리를 위한 비동기 IO (Asynchronous IO) 추상화를 설명합니다. 목표는 다양한 비동기 IO 백엔드에 의해 구현될 수 있고, 라이브러리 개발자들이 다양한 백엔드 간에 이식 가능한 (portable) 코드를 작성할 수 있는 공통의 대상을 제공하는 추상화에 도달하는 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;도입-배경-rationale&quot;&gt;도입 배경 (Rationale)&lt;/h2&gt;

&lt;p&gt;현재 파이썬에서 비동기 코드를 작성하려는 개발자들은 몇 가지 선택지를 가지고 있습니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncore&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asynchat&lt;/code&gt; 모듈&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select&lt;/code&gt; 모듈 기반의 맞춤형 (bespoke) 솔루션&lt;/li&gt;
  &lt;li&gt;Twisted 또는 gevent와 같은 서드 파티 라이브러리 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만 이 PEP는 이러한 각 옵션에 단점이 있음을 지적하며, 이를 해결하고자 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asyncore&lt;/code&gt; 모듈은 파이썬 표준 라이브러리의 일부로 오랫동안 존재했지만, 현대적인 비동기 네트워킹 모듈의 기대에 미치지 못하는 유연하지 않은 API로 인해 근본적인 결함을 가지고 있습니다. 또한, 비동기 네트워킹의 잠재력을 완전히 활용하는 데 필요한 모든 도구를 개발자에게 제공하기에는 너무 단순한 접근 방식을 취하고 있습니다.&lt;/p&gt;

&lt;p&gt;현재 프로덕션 환경에서 가장 인기 있는 해결책은 서드 파티 라이브러리를 사용하는 것입니다. 이러한 라이브러리들은 만족스러운 솔루션을 제공하는 경우가 많지만, 라이브러리 간의 호환성 부족으로 인해 코드베이스가 사용 중인 특정 라이브러리에 강하게 결합되는 경향이 있습니다.&lt;/p&gt;

&lt;p&gt;서로 다른 비동기 IO 라이브러리 간의 현재 이식성 부족은 서드 파티 라이브러리 개발자들에게 많은 중복된 노력을 야기합니다. 충분히 강력한 추상화는 비동기 코드를 한 번 작성하여 모든 곳에서 사용할 수 있게 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;궁극적으로 추가되는 목표는 표준 라이브러리의 와이어 및 네트워크 프로토콜 구현이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recv()&lt;/code&gt;를 블로킹 방식으로 호출하는 것을 포함하여 모든 것을 처리하는 독립형 라이브러리가 아니라, 실제 프로토콜 구현으로 발전하는 것입니다. 이는 동기 및 비동기 코드 모두에서 쉽게 재사용될 수 있음을 의미합니다.&lt;/p&gt;

&lt;h2 id=&quot;통신-추상화-communication-abstractions&quot;&gt;통신 추상화 (Communication abstractions)&lt;/h2&gt;

&lt;h3 id=&quot;트랜스포트-transports&quot;&gt;트랜스포트 (Transports)&lt;/h3&gt;

&lt;p&gt;트랜스포트는 다양한 종류의 연결에서 바이트를 읽고 쓰는 데 사용되는 균일한 API를 제공합니다. 이 PEP에서 트랜스포트는 항상 순서가 지정되고 (ordered), 신뢰할 수 있으며 (reliable), 양방향 (bidirectional)이고, 스트림 지향적인 (stream-oriented) 두 개의 종단점 (two-endpoint) 연결입니다. 이는 TCP 소켓, SSL 연결, 파이프 (이름 지정 여부와 관계없이), 직렬 포트 등이 될 수 있습니다. 이는 POSIX 플랫폼의 파일 디스크립터나 Windows의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Handle&lt;/code&gt; 또는 특정 플랫폼에 적합한 다른 데이터 구조를 추상화할 수 있습니다. 트랜스포트는 해당 플랫폼 데이터 구조를 사용하는 모든 특정 구현 세부 사항을 캡슐화하고 애플리케이션 개발자에게 균일한 인터페이스를 제공합니다.&lt;/p&gt;

&lt;p&gt;트랜스포트는 두 가지와 통신합니다: 한편으로는 연결의 다른 쪽 끝, 다른 한편으로는 프로토콜. 이는 특정 기본 전송 메커니즘과 프로토콜 간의 다리 역할을 합니다. 트랜스포트의 역할은 프로토콜이 바이트를 보내고 받을 수 있도록 하여, 이 바이트들이 결국 와이어를 통해 전송되기 위해 필요한 모든 마법을 처리하는 것으로 설명할 수 있습니다.&lt;/p&gt;

&lt;p&gt;트랜스포트의 주요 기능은 바이트를 프로토콜로 보내고, 기본 프로토콜로부터 바이트를 받는 것입니다. 트랜스포트에 쓰기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_sequence&lt;/code&gt; 메서드를 사용하여 수행됩니다. 후자 메서드는 일부 트랜스포트 메커니즘의 특정 기능을 활용할 수 있도록 하는 성능 최적화입니다. 특히, 이는 트랜스포트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;writev&lt;/code&gt;를 사용할 수 있도록 하는데, 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scatter/gather IO&lt;/code&gt;로도 알려져 있습니다.&lt;/p&gt;

&lt;p&gt;트랜스포트는 일시 중지 (paused) 및 재개 (resumed)될 수 있습니다. 이렇게 하면 프로토콜에서 오는 데이터를 버퍼링하고, 수신된 데이터를 프로토콜로 보내는 것을 중단합니다.&lt;/p&gt;

&lt;p&gt;트랜스포트는 또한 닫히거나 (closed), 부분적으로 닫히거나 (half-closed), 중단될 (aborted) 수 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;closed&lt;/code&gt; 트랜스포트는 큐에 있는 모든 데이터를 기본 메커니즘에 쓰는 것을 완료한 다음, 데이터 읽기 또는 쓰기를 중단합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aborting&lt;/code&gt; 트랜스포트는 큐에 있는 데이터를 보내지 않고 연결을 닫아 작업을 중단합니다. 이후의 쓰기는 예외를 발생시킵니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;half-closed&lt;/code&gt; 트랜스포트는 더 이상 쓰기가 불가능하지만, 들어오는 데이터는 계속 수락합니다.&lt;/p&gt;

&lt;h3 id=&quot;프로토콜-protocols&quot;&gt;프로토콜 (Protocols)&lt;/h3&gt;

&lt;p&gt;프로토콜은 새로운 사용자에게 더 친숙할 것입니다. 이 용어는 프로토콜이라는 이름에서 기대하는 바와 일치합니다: HTTP, IRC, SMTP와 같이 대부분의 사람들이 먼저 떠올리는 프로토콜은 모두 프로토콜에 구현될 수 있는 예시입니다.&lt;/p&gt;

&lt;p&gt;프로토콜의 가장 짧고 유용한 정의는 트랜스포트와 나머지 애플리케이션 로직 간의 (일반적으로 양방향) 다리입니다. 프로토콜은 트랜스포트로부터 바이트를 수신하고 그 정보를 어떤 동작 (behavior)으로 변환하는데, 이는 일반적으로 객체에 대한 몇 가지 메서드 호출로 이어집니다. 유사하게, 애플리케이션 로직은 프로토콜에 몇 가지 메서드를 호출하고, 프로토콜은 이를 바이트로 변환하여 트랜스포트에 전달합니다.&lt;/p&gt;

&lt;p&gt;가장 간단한 프로토콜 중 하나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\r\n&lt;/code&gt;으로 데이터가 구분되는 라인 기반 프로토콜입니다. 프로토콜은 트랜스포트로부터 바이트를 수신하고, 최소한 하나의 완전한 라인이 있을 때까지 버퍼링합니다. 이 작업이 완료되면, 이 라인을 어떤 객체에 전달합니다. 이상적으로는 콜러블(callable)을 사용하거나 프로토콜에 의해 구성된 완전히 별도의 객체를 사용하여 달성되겠지만, 서브클래싱을 통해서도 구현될 수 있습니다 (Twisted의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LineReceiver&lt;/code&gt;의 경우와 같이). 다른 방향의 경우, 프로토콜은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_line&lt;/code&gt; 메서드를 가질 수 있으며, 이 메서드는 필요한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\r\n&lt;/code&gt;을 추가하고 새로운 바이트 버퍼를 트랜스포트로 전달합니다.&lt;/p&gt;

&lt;p&gt;이 PEP는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChunkProtocol&lt;/code&gt;이라는 일반화된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LineReceiver&lt;/code&gt;를 제안합니다. 여기서 “청크 (chunk)”는 지정된 구분자로 구분되는 스트림 내의 메시지입니다. 인스턴스는 구분자와 함께 데이터 청크가 수신되면 호출될 콜러블을 인자로 받습니다 (Twisted의 서브클래싱 동작과는 다릅니다). &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChunkProtocol&lt;/code&gt;은 위에 설명된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_line&lt;/code&gt; 메서드와 유사한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_chunk&lt;/code&gt; 메서드도 가집니다.&lt;/p&gt;

&lt;h3 id=&quot;프로토콜과-트랜스포트를-분리하는-이유-why-separate-protocols-and-transports&quot;&gt;프로토콜과 트랜스포트를 분리하는 이유 (Why separate protocols and transports?)&lt;/h3&gt;

&lt;p&gt;프로토콜과 트랜스포트 간의 이러한 분리는 처음 접하는 사람들을 종종 혼란스럽게 합니다. 실제로 표준 라이브러리 자체는 많은 경우에 이러한 구분을 하지 않으며, 특히 사용자에게 제공하는 API에서는 더욱 그렇습니다.&lt;/p&gt;

&lt;p&gt;그럼에도 불구하고 이는 매우 유용한 구분입니다. 최악의 경우, 관심사의 명확한 분리를 통해 구현을 단순화합니다. 그러나 이는 종종 훨씬 더 유용한 목적인, 다양한 트랜스포트에서 프로토콜을 재사용할 수 있게 하는 역할을 합니다.&lt;/p&gt;

&lt;p&gt;간단한 RPC 프로토콜을 생각해 봅시다. 동일한 바이트가 파이프나 소켓과 같은 여러 다른 트랜스포트를 통해 전송될 수 있습니다. 이를 돕기 위해 프로토콜을 트랜스포트와 분리합니다. 프로토콜은 단순히 바이트를 읽고 쓰며, 그 바이트가 최종적으로 전송되는 메커니즘에는 크게 신경 쓰지 않습니다.&lt;/p&gt;

&lt;p&gt;이는 또한 프로토콜을 쉽게 스택하거나 중첩할 수 있게 하여, 코드 재사용을 더욱 증가시킵니다. 이에 대한 일반적인 예시는 JSON-RPC입니다. 사양에 따르면, JSON-RPC는 소켓과 HTTP 모두에서 사용될 수 있습니다. 실제로는 주로 HTTP 내에 캡슐화되는 경향이 있습니다. 프로토콜-트랜스포트 추상화를 통해 HTTP를 트랜스포트처럼 사용할 수 있는 프로토콜 및 트랜스포트 스택을 구축할 수 있습니다. JSON-RPC의 경우, 대략 다음과 같은 스택을 얻을 수 있습니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TCP 소켓 트랜스포트&lt;/li&gt;
  &lt;li&gt;HTTP 프로토콜&lt;/li&gt;
  &lt;li&gt;HTTP 기반 트랜스포트&lt;/li&gt;
  &lt;li&gt;JSON-RPC 프로토콜&lt;/li&gt;
  &lt;li&gt;애플리케이션 코드&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;흐름-제어-flow-control&quot;&gt;흐름 제어 (Flow control)&lt;/h2&gt;

&lt;h3 id=&quot;컨슈머-consumers&quot;&gt;컨슈머 (Consumers)&lt;/h3&gt;

&lt;p&gt;컨슈머는 프로듀서가 생성한 바이트를 소비합니다. 프로듀서와 함께 흐름 제어를 가능하게 합니다.&lt;/p&gt;

&lt;p&gt;컨슈머는 흐름 제어에서 주로 수동적인 역할을 합니다. 프로듀서가 일부 데이터를 사용할 수 있을 때마다 호출됩니다. 그런 다음 해당 데이터를 처리하고 일반적으로 제어를 다시 프로듀서에게 양도합니다.&lt;/p&gt;

&lt;p&gt;컨슈머는 일반적으로 어떤 종류의 버퍼를 구현합니다. 컨슈머는 해당 버퍼의 현재 상태를 프로듀서에게 알려줌으로써 흐름 제어를 가능하게 합니다. 컨슈머는 프로듀서에게 생산을 완전히 중단하거나, 일시적으로 중단하거나, 이전에 일시 중지하도록 지시받았다면 생산을 재개하도록 지시할 수 있습니다.&lt;/p&gt;

&lt;p&gt;프로듀서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register&lt;/code&gt; 메서드를 사용하여 컨슈머에 등록됩니다.&lt;/p&gt;

&lt;h3 id=&quot;프로듀서-producers&quot;&gt;프로듀서 (Producers)&lt;/h3&gt;

&lt;p&gt;컨슈머가 바이트를 소비하는 곳에서, 프로듀서는 바이트를 생성합니다.&lt;/p&gt;

&lt;p&gt;프로듀서는 Twisted에서 발견되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IPushProducer&lt;/code&gt; 인터페이스를 모델로 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IPullProducer&lt;/code&gt;도 있지만, 전반적으로 흥미가 훨씬 적으므로 이 PEP의 범위 밖일 것입니다.&lt;/p&gt;

&lt;p&gt;프로듀서는 생산을 완전히 중단하도록 지시받을 수 있지만, 가장 흥미로운 두 가지 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pause&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resume&lt;/code&gt;입니다. 이 메서드들은 일반적으로 컨슈머에 의해 호출되며, 더 많은 데이터를 처리 (“소비”)할 준비가 되었는지 여부를 나타냅니다. 컨슈머와 프로듀서는 흐름 제어를 가능하게 하기 위해 협력합니다.&lt;/p&gt;

&lt;p&gt;Twisted &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IPushProducer&lt;/code&gt; 인터페이스 외에도, 프로듀서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;half_register&lt;/code&gt; 메서드를 가지고 있습니다. 이 메서드는 컨슈머가 해당 프로듀서를 등록하려고 할 때 컨슈머와 함께 호출됩니다. 대부분의 경우, 이는 단순히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.consumer = consumer&lt;/code&gt;를 설정하는 경우일 것이지만, 일부 프로듀서는 컨슈머가 등록될 때 더 복잡한 사전 조건이나 동작을 요구할 수 있습니다. 최종 사용자는 이 메서드를 직접 호출하지 않아야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;고려된-api-대안-considered-api-alternatives&quot;&gt;고려된 API 대안 (Considered API alternatives)&lt;/h2&gt;

&lt;h3 id=&quot;프로듀서로서의-제너레이터-generators-as-producers&quot;&gt;프로듀서로서의 제너레이터 (Generators as producers)&lt;/h3&gt;

&lt;p&gt;제너레이터 (Generators)는 프로듀서를 구현하는 방법으로 제안되었습니다. 그러나 여기에는 몇 가지 문제가 있는 것으로 보입니다.&lt;/p&gt;

&lt;p&gt;첫째, 개념적인 문제가 있습니다. 제너레이터는 어떤 의미에서 “수동적 (passive)”입니다. 메서드 호출을 통해 행동하도록 지시받아야 합니다. 프로듀서는 “능동적 (active)”입니다. 즉, 이러한 메서드 호출을 시작합니다. 실제 프로듀서는 컨슈머와 대칭적인 관계를 가집니다. 제너레이터가 프로듀서로 전환되는 경우, 컨슈머만이 참조를 가지고 프로듀서는 컨슈머의 존재를 알지 못합니다.&lt;/p&gt;

&lt;p&gt;이러한 개념적인 문제는 몇 가지 기술적인 문제로도 이어집니다. 컨슈머에 대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt; 메서드 호출이 성공한 후, (푸시) 프로듀서는 다시 자유롭게 행동할 수 있습니다. 제너레이터의 경우, 반복 프로토콜을 통해 다음 객체를 요청하거나 (무기한 블로킹될 수 있는 프로세스), 어떤 종류의 시그널 예외를 발생시켜 알려주어야 할 것입니다.&lt;/p&gt;

&lt;p&gt;이러한 시그널링 설정은 기술적으로 실행 가능한 솔루션을 제공할 수 있지만, 여전히 만족스럽지 않습니다. 우선, 이는 컨슈머에 불필요한 복잡성을 도입합니다. 컨슈머는 이제 데이터를 수신하고 처리하는 방법뿐만 아니라, 새로운 데이터를 요청하는 방법과 새로운 데이터를 사용할 수 없는 경우를 처리하는 방법도 이해해야 합니다.&lt;/p&gt;

&lt;p&gt;이 후자의 엣지 케이스는 특히 문제가 됩니다. 전체 작업이 블로킹되어서는 안 되기 때문에 처리해야 합니다. 그러나 제너레이터는 종료하지 않고는 반복 중에 예외를 발생시킬 수 없으므로, 제너레이터의 상태를 잃게 됩니다. 결과적으로, 사용 가능한 데이터 부족을 알리는 것은 예외 메커니즘을 사용하는 대신, 센티넬 값 (sentinel value)을 사용하여 수행되어야 할 것입니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 실제로 작동하는 코드를 통해 제너레이터가 프로듀서로 어떻게 사용될 수 있는지 시연한 사람이 아무도 없었습니다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료-references&quot;&gt;참고 자료 (References)&lt;/h2&gt;

&lt;p&gt;PEP 3153 – Asynchronous IO support, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;peps.python.org&lt;/code&gt;.
 Sections 2.1 and 2.2 of the JSON-RPC specification.&lt;/p&gt;

&lt;h2 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h2&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인에 공개되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 14:42:18 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3153/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3153/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Rejected] PEP 3152 - Cofunctions</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3152/&quot;&gt;PEP 3152 - Cofunctions&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Rejected&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 13-Feb-2009&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;개요-abstract&quot;&gt;개요 (Abstract)&lt;/h3&gt;

&lt;p&gt;PEP 3152는 ‘cofunction’이라는 특수한 유형의 제너레이터(generator)를 정의하고 호출하기 위한 새로운 문법을 제안했습니다. 이 제안의 목표는 제너레이터 기반 코루틴(coroutine)을 작성하는 과정을 간소화하고, 이러한 코드 작성 시 흔히 발생하는 특정 유형의 오류를 조기에 감지하도록 돕는 것이었습니다. 이러한 오류는 진단하기 어려운 증상을 유발하는 경향이 있습니다.&lt;/p&gt;

&lt;p&gt;이 제안은 PEP 380에 설명된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 메커니즘을 기반으로 하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;의 일부 의미론을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt;을 통해 설명합니다. 그러나 필요하다면 PEP 380과 독립적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;을 정의하고 구현하는 것도 가능했을 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;반려-rejection&quot;&gt;반려 (Rejection)&lt;/h3&gt;

&lt;p&gt;PEP 3152는 반려(Rejected)되었습니다. 상세한 반려 사유는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://mail.python.org/pipermail/python-dev/2015-April/139503.html&lt;/code&gt;에서 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;사양-specification&quot;&gt;사양 (Specification)&lt;/h3&gt;

&lt;h4 id=&quot;cofunction-정의-cofunction-definitions&quot;&gt;Cofunction 정의 (Cofunction definitions)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;을 정의하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;codef&lt;/code&gt;라는 새로운 키워드가 도입되었습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;은 다음과 같은 특징을 가진 특별한 종류의 제너레이터입니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 표현식을 포함하지 않더라도 항상 제너레이터입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;은 일반 함수와 동일한 방식으로 호출될 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;을 일반적인 방식으로 호출하려고 시도하면 예외(Exception)가 발생합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cocall-cocalls&quot;&gt;Cocall (Cocalls)&lt;/h4&gt;

&lt;p&gt;하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;에서 다른 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;을 호출할 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cocall&lt;/code&gt;이라는 새로운 키워드를 사용하여 호출을 표시합니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cocall f(*args, **kwds)&lt;/code&gt; 표현식은 의미상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from f.__cocall__(*args, **kwds)&lt;/code&gt;와 동등합니다. 다만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cocall__&lt;/code&gt;이 반환하는 객체는 이터레이터(iterator)일 것으로 예상되므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iter()&lt;/code&gt;를 호출하는 단계는 건너뜁니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cocall&lt;/code&gt; 표현식의 전체 문법은 다음과 같습니다:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;atom: cocall | &amp;lt;기존 atom의 대안&amp;gt;
cocall: &apos;cocall&apos; atom cotrailer* &apos;(&apos; [arglist] &apos;)&apos;
cotrailer: &apos;[&apos; subscriptlist &apos;]&apos; | &apos;.&apos; NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cocall&lt;/code&gt; 키워드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt; 내부에서만 문법적으로 유효합니다. 다른 컨텍스트에서 사용하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyntaxError&lt;/code&gt;가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cocall__&lt;/code&gt;을 구현하는 객체는 이터레이터 프로토콜(iterator protocol)을 따르는 객체를 반환할 것으로 예상됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cofunction&lt;/code&gt;은 일반 제너레이터 함수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__call__&lt;/code&gt;에 응답하는 방식과 동일하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cocall__&lt;/code&gt;에 응답합니다. 즉, 제너레이터 이터레이터(generator-iterator)를 반환합니다.&lt;/p&gt;

&lt;p&gt;다른 호출 가능(callable) 객체, 특히 바운드 메서드(bound methods)를 감싸는 특정 객체는 내부 객체로 위임하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cocall__&lt;/code&gt; 구현을 갖게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;새로운-내장-함수-속성-및-c-api-함수-new-builtins-attributes-and-c-api-functions&quot;&gt;새로운 내장 함수, 속성 및 C API 함수 (New builtins, attributes and C API functions)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;과 비(非)코루틴 코드를 연결하는 것을 용이하게 하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;costart&lt;/code&gt;라는 내장 함수가 제공될 예정이었습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;costart&lt;/code&gt;의 정의는 다음과 같습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;costart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;__cocall__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한, 이에 상응하는 C API 함수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PyObject *PyObject_CoCall(PyObject *obj, PyObject *args, PyObject *kwds)&lt;/code&gt;도 제공될 예정이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;이 별개의 객체 유형인지, 아니면 제너레이터 함수처럼 특별히 표시된 함수 인스턴스(instance)인지는 명시되지 않았습니다. 후자일 경우, 주어진 함수 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cofunction&lt;/code&gt;인지 테스트할 수 있도록 읽기 전용(read-only) 불리언(boolean) 속성 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__iscofunction__&lt;/code&gt;이 제공되어야 한다고 명시되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;동기-및-근거-motivation-and-rationale&quot;&gt;동기 및 근거 (Motivation and Rationale)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 문법은 제너레이터의 작업 일부를 다른 함수에 위임하는 목적으로 사용될 때 비교적 자명합니다. 또한 제너레이터 기반 코루틴 구현에도 효과적으로 사용될 수 있지만, 이 목적에 사용될 때는 다소 어색하게 읽히고 코드의 진정한 의도를 모호하게 만드는 경향이 있습니다.&lt;/p&gt;

&lt;p&gt;더 나아가, 제너레이터를 코루틴으로 사용하는 것은 오류가 발생하기 쉽습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt;을 사용해야 할 때 사용하지 않거나, 사용하지 말아야 할 때 사용하면 모호하고 혼란스러운 증상이 나타날 수 있습니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 때로는 아무것도 yield 하지 않더라도 함수가 코루틴이어야 할 필요가 있으며, 이러한 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if 0: yield&lt;/code&gt;와 같은 편법(kludges)을 사용하여 강제로 제너레이터로 만드는 것이 필요했습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;codef&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cocall&lt;/code&gt; 구문은 다음과 같은 문제들을 해결하고자 했습니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;첫 번째 문제(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield from&lt;/code&gt; 사용 시 의미 모호성)는 문법이 의도(함수가 코루틴의 일부를 형성함)를 직접적으로 반영하도록 하여 해결합니다.&lt;/li&gt;
  &lt;li&gt;두 번째 문제(코루틴과 비(非)코루틴 코드의 혼합으로 인한 오류)는 말이 안 되는 방식으로 코루틴과 비(非)코루틴 코드를 혼합하는 것을 불가능하게 함으로써 해결합니다. 규칙을 위반하면 정확히 무엇이 문제인지, 어디에서 문제가 발생했는지 알려주는 예외가 발생합니다.&lt;/li&gt;
  &lt;li&gt;마지막으로, 함수의 정의 형식이 함수가 코루틴인지 여부를 결정하도록 함으로써 더미 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;의 필요성을 없앱니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로토타입-구현-prototype-implementation&quot;&gt;프로토타입 구현 (Prototype Implementation)&lt;/h3&gt;

&lt;p&gt;Python 3.1.2에 대한 패치 형태의 구현은 다음에서 찾을 수 있습니다:
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://www.cosc.canterbury.ac.nz/greg.ewing/python/generators/cofunctions.html&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h3&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 14:41:43 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3152/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3152/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 3151 - Reworking the OS and IO exception hierarchy</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3151/&quot;&gt;PEP 3151 - Reworking the OS and IO exception hierarchy&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 21-Jul-2010&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;pep-3151--os-및-io-예외-계층-구조-재작업&quot;&gt;PEP 3151 – OS 및 IO 예외 계층 구조 재작업&lt;/h1&gt;

&lt;p&gt;이 문서는 Python Enhancement Proposal (PEP) 3151의 내용을 한국어 사용자가 이해하기 쉽도록 번역하고 정리한 것입니다. Python 개발자들이 이 PEP의 제안 내용, 도입 배경, 그리고 실제 Python 사용에 미치는 영향을 명확하게 이해할 수 있도록 돕는 것이 목표입니다.&lt;/p&gt;

&lt;p&gt;작성자: Antoine Pitrou
BDFL-Delegate: Barry Warsaw
상태: Final
유형: Standards Track
생성일: 2010년 7월 21일
Python 버전: 3.3&lt;/p&gt;

&lt;h2 id=&quot;요약-abstract&quot;&gt;요약 (Abstract)&lt;/h2&gt;

&lt;p&gt;표준 예외(exception) 계층 구조는 Python 언어의 중요한 부분입니다. 이는 ‘일반적(generic)’이면서도 ‘선택적(selective)’이라는 두 가지 특징을 가지고 있습니다. 같은 예외 유형이 다양한 맥락에서 발생하고 처리될 수 있다는 점에서 ‘일반적’이며(예: 정수에 무언가를 추가하거나, 문자열 메서드를 호출하거나, 소켓에 객체를 쓰는 등 잘못된 인자 유형에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TypeError&lt;/code&gt;가 발생), 사용자가 특정 종류의 오류 조건을 쉽게 처리(무시, 검사, 처리, 저장 또는 캡슐화 등)하면서 다른 오류는 상위 호출 컨텍스트로 전파되도록 허용한다는 점에서 ‘선택적’입니다. 예를 들어, 다른 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArithmeticError&lt;/code&gt; (예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OverflowError&lt;/code&gt;)의 기본 처리에 영향을 주지 않으면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ZeroDivisionError&lt;/code&gt;만 잡을 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 PEP는 위에서 언급된 특징들을 더 잘 구현하기 위해 예외 계층 구조의 일부, 즉 운영 체제 호출과 관련된 오류(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap.error&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select.error&lt;/code&gt; 및 이들의 모든 서브클래스)에 대한 변경을 제안합니다.&lt;/p&gt;

&lt;h2 id=&quot;배경-rationale&quot;&gt;배경 (Rationale)&lt;/h2&gt;

&lt;h3 id=&quot;혼란스러운-os-관련-예외-집합&quot;&gt;혼란스러운 OS 관련 예외 집합&lt;/h3&gt;

&lt;p&gt;현재 OS 관련(또는 시스템 호출 관련) 예외는 다음과 같은 하위 계층 구조로 구성된 다양한 클래스입니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-- EnvironmentError
    +-- IOError
        +-- io.BlockingIOError
        +-- io.UnsupportedOperation (ValueError도 상속)
    +-- socket.error
        +-- socket.gaierror
        +-- socket.herror
        +-- socket.timeout
    +-- OSError
        +-- VMSError
        +-- WindowsError
    +-- mmap.error
    +-- select.error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 일부 구분은 구현상의 고려 사항으로 설명될 수 있지만, 상위 수준에서는 종종 논리적이지 않습니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 구분하는 경계는 종종 모호합니다. 다음 예시를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;fff&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Traceback &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;most&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;lt;stdin&amp;gt;&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;OSError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Errno&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;such&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;directory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;fff&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;fff&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Traceback &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;most&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;lt;stdin&amp;gt;&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;IOError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Errno&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;No&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;such&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;directory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;fff&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;동일한 오류 조건(존재하지 않는 파일)이 호출된 라이브러리 함수에 따라 두 가지 다른 예외로 발생합니다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;os&lt;/code&gt; 모듈은 exclusively &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt; (또는 서브클래스 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt;)를 발생시키고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io&lt;/code&gt; 모듈은 주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시키기 때문입니다. 그러나 사용자는 오류의 출처(추적 메시지나 애플리케이션 소스 코드를 통해 명확하기 때문)보다는 오류의 본질에 관심이 있습니다.&lt;/p&gt;

&lt;p&gt;실제로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;를 포착하되 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;는 포착하지 않는 상황이나 그 반대의 상황을 생각하기 어렵습니다.&lt;/p&gt;

&lt;p&gt;이러한 구분의 모호성을 추가적으로 증명하는 것은 표준 라이브러리 자체도 때때로 결정을 내리는 데 어려움을 겪는다는 것입니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select&lt;/code&gt; 모듈에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;poll&lt;/code&gt; 객체, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kqueue&lt;/code&gt; 객체 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoll&lt;/code&gt; 객체를 사용하는지에 따라 유사한 실패가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select.error&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다. 이는 사용자 코드를 불필요하게 복잡하게 만드는데, 단일 프리미티브의 정확한 구현에 따라 런타임에 다양한 예외 유형을 포착할 준비를 해야 하기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt;의 경우, 이는 무의미한 구분으로 보입니다. 첫째, Windows 시스템에서만 존재하여 크로스 플랫폼 애플리케이션에서 번거로운 호환성 코드를 필요로 합니다. 둘째, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;를 상속하며 다른 시스템에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;가 발생하는 것과 유사한 오류에 대해 발생합니다. 셋째, 낮은 수준의 예외 세부 정보에 접근하려는 사용자는 어차피 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;winerror&lt;/code&gt; 속성을 검사해야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고:&lt;/strong&gt; [Appendix B]는 인터프리터와 표준 라이브러리 전반에 걸쳐 다양한 예외 유형의 사용을 조사합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;세분화된-예외의-부족&quot;&gt;세분화된 예외의 부족&lt;/h3&gt;

&lt;p&gt;현재 다양한 OS 관련 예외는 사용자가 원하는 종류의 실패를 쉽게 필터링할 수 있도록 허용하지 않습니다. 예를 들어, 파일이 존재하면 삭제하는 작업을 고려해 보십시오. “Look Before You Leap (LBYL)” 방식은 명백한 경쟁 조건(race condition) 문제가 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;os.path.exists&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;os.remove&lt;/code&gt; 호출 사이에 다른 스레드나 프로세스에 의해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filename&lt;/code&gt;으로 명명된 파일이 생성되면, 해당 파일은 삭제되지 않습니다. 이는 애플리케이션에 버그나 심지어 보안 문제를 야기할 수 있습니다.&lt;/p&gt;

&lt;p&gt;따라서, 파일 삭제를 시도하고 파일이 존재하지 않는 경우 오류를 무시하는 것이 해결책입니다(“Easier to Ask Forgiveness than to get Permission (EAFP)”으로 알려진 방식). 신중한 코드는 다음과 같이 작성됩니다(POSIX 및 Windows 시스템 모두에서 작동).&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;OSError&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENOENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 심지어:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;EnvironmentError&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENOENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 작성해야 할 양이 훨씬 많고, 사용자에게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 모듈의 다양한 암호 같은 니모닉(mnemonic)을 기억하도록 강요합니다. 이는 추가적인 인지적 부담을 주고 빠르게 지루해집니다. 결과적으로 많은 프로그래머는 예외를 너무 광범위하게 무시하는 다음 코드를 대신 작성합니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;OSError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;os.remove&lt;/code&gt;는 파일이 존재하지 않을 뿐만 아니라 다른 가능한 상황(예: 파일명이 디렉토리를 가리키거나, 현재 프로세스에 파일 삭제 권한이 없는 경우)에서도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;를 발생시킬 수 있으며, 이 모든 상황은 애플리케이션 로직의 버그를 나타내므로 무시되어서는 안 됩니다. 프로그래머가 대신 작성하고 싶은 것은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;FileNotFoundError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;호환성-전략-compatibility-strategy&quot;&gt;호환성 전략 (Compatibility strategy)&lt;/h2&gt;

&lt;p&gt;예외 계층 구조를 재작업하는 것은 분명히 기존 코드의 일부 의미를 변경할 것입니다. 정확한 의미를 변경하지 않고 현재 상황을 개선하는 것은 불가능하지만, 더 좁은 유형의 호환성, 즉 ‘유용한 호환성(useful compatibility)’을 정의하는 것은 가능합니다.&lt;/p&gt;

&lt;p&gt;이를 위해 먼저 ‘신중한(careful)’ 예외 처리와 ‘부주의한(careless)’ 예외 처리가 무엇인지 설명해야 합니다. ‘부주의한(또는 ‘순진한’)’ 코드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 속성을 확인하지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.error&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap.error&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select.error&lt;/code&gt; 중 어떤 것이든 맹목적으로 포착하는 코드로 정의됩니다. 이러한 예외 유형은 너무 광범위하여 의미 있는 어떤 것도 나타내지 않기 때문입니다. 이들 중 어떤 것이든 잘못된 파일 디스크립터(일반적으로 프로그래밍 오류를 나타냄), 연결되지 않은 소켓(마찬가지), 소켓 타임아웃, 파일 유형 불일치, 유효하지 않은 인수, 전송 실패, 불충분한 권한, 존재하지 않는 디렉토리, 가득 찬 파일 시스템 등 다양한 오류 조건에 대해 발생할 수 있습니다.&lt;/p&gt;

&lt;p&gt;(게다가, 특정 예외의 사용은 불규칙합니다. [Appendix B]는 구현에 따라 다른 예외를 발생시키는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select&lt;/code&gt; 모듈의 경우를 설명합니다.)&lt;/p&gt;

&lt;p&gt;‘신중한’ 코드는 위의 예외 중 하나를 포착할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 속성을 검사하여 실제 오류 조건을 판단하고 그에 따라 조치를 취하는 코드로 정의됩니다.&lt;/p&gt;

&lt;p&gt;이제 ‘유용한 호환성’을 다음과 같이 정의할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;유용한 호환성&lt;/strong&gt;은 예외 포착을 더 좁게 만들지 않지만, ‘부주의한’ 예외 포착 코드의 경우 더 넓어질 수 있습니다. 다음 유형의 코드 조각이 주어졌을 때, 이 PEP 이전에 포착된 모든 예외는 이 PEP 이후에도 포착되지만, 그 반대는 사실이 아닐 수 있습니다 (왜냐하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt; 및 기타 예외의 통합은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;except&lt;/code&gt; 절이 약간 더 넓은 범위를 포괄함을 의미하기 때문입니다).&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;OSError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;유용한 호환성&lt;/strong&gt;은 ‘신중한’ 예외 포착 코드의 동작을 변경하지 않습니다. 다음 유형의 코드 조각이 주어졌을 때, 이 PEP가 구현되었는지 여부와 관계없이 동일한 오류가 무시되거나 다시 발생해야 합니다.&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;OSError&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENOENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 타협의 근거는 ‘부주의한’ 코드는 실제로 도울 수 없지만, 적어도 “작동하는” 코드가 갑자기 오류를 발생시키고 충돌하지는 않을 것이라는 점입니다. 이는 이러한 코드가 cron 작업이나 자동화된 시스템 관리 프로그램에서 사용되는 스크립트에 존재할 가능성이 높기 때문에 중요합니다.&lt;/p&gt;

&lt;p&gt;반면에 ‘신중한’ 코드는 불이익을 받아서는 안 됩니다. 사실, 이 PEP의 한 가지 목적은 ‘신중한’ 코드 작성을 용이하게 하는 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;1단계-예외-유형-통합-coalesce-exception-types&quot;&gt;1단계: 예외 유형 통합 (coalesce exception types)&lt;/h3&gt;

&lt;p&gt;해결책의 첫 번째 단계는 기존 예외 유형을 통합하는 것입니다. 다음 변경 사항이 제안됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.error&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select.error&lt;/code&gt;를 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;로 앨리어싱(alias)합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap.error&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;로 앨리어싱합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VMSError&lt;/code&gt;를 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;로 앨리어싱합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;로 앨리어싱합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EnvironmentError&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;로 통합합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 각 변경 사항은 정확한 호환성을 유지하지는 않지만, 유용한 호환성(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;compatibility&quot;&lt;/code&gt; 섹션 참조)을 유지합니다.&lt;/p&gt;

&lt;p&gt;이러한 각 변경 사항은 개별적으로 수락되거나 거부될 수 있지만, 물론 이 첫 번째 단계가 완전히 수락될 때 가장 큰 영향을 얻을 수 있다고 간주됩니다. 이 경우, IO 예외 하위 계층 구조는 다음과 같이 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-- OSError (IOError, WindowsError, EnvironmentError 등을 대체)
    +-- io.BlockingIOError
    +-- io.UnsupportedOperation (ValueError도 상속)
    +-- socket.gaierror
    +-- socket.herror
    +-- socket.timeout
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;정당화-justification&quot;&gt;정당화 (Justification)&lt;/h4&gt;

&lt;p&gt;이 첫 번째 단계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rationale&lt;/code&gt; 섹션에서 설명한 대로 사용자에게 더 간단한 환경을 제공할 뿐만 아니라, 2단계의 더 좋고 완전한 해결책을 가능하게 합니다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Prerequisite&lt;/code&gt; 참조).&lt;/p&gt;

&lt;p&gt;일반적인 OS 관련 예외의 공식 이름으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;를 유지하는 이유는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;보다 더 일반적(generic)이기 때문입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EnvironmentError&lt;/code&gt;는 입력하기 더 번거롭고 훨씬 덜 알려져 있습니다.&lt;/p&gt;

&lt;p&gt;[Appendix B]의 조사는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;가 현재 표준 라이브러리에서 지배적인 오류임을 보여줍니다. 타사 Python 코드의 경우, Google Code Search는 사용자 코드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EnvironmentError&lt;/code&gt;보다 10배 더 인기가 많고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;보다 3배 더 인기가 많다는 것을 보여줍니다. 그러나 중기적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 Deprecate할 의도는 없으므로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;의 낮은 인기는 문제가 되지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;예외-속성-exception-attributes&quot;&gt;예외 속성 (Exception attributes)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;로 통합되므로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;는 Windows에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;winerror&lt;/code&gt; 속성을 얻게 됩니다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filename&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strerror&lt;/code&gt; 속성에서 이미 그렇듯이, 의미 없는 상황에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt;으로 설정됩니다(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;가 Python 코드에 의해 직접 발생될 때).&lt;/p&gt;

&lt;h4 id=&quot;이름-deprecate-deprecation-of-names&quot;&gt;이름 Deprecate (Deprecation of names)&lt;/h4&gt;

&lt;p&gt;다음 단락들은 오래된 예외 이름에 대한 가능한 Deprecation 전략을 설명합니다. 그러나, 당분간은 이들을 앨리어스로 유지하기로 결정했습니다. 이 결정은 Python 4.0을 위해 수정될 수 있습니다.&lt;/p&gt;

&lt;h5 id=&quot;내장-예외-built-in-exceptions&quot;&gt;내장 예외 (built-in exceptions)&lt;/h5&gt;

&lt;p&gt;오래된 내장 예외를 Deprecate하는 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;builtins&lt;/code&gt; 네임스페이스의 모든 조회를 가로채는 방식으로 직접적으로 수행될 수 없습니다. 이는 성능에 중요한 부분이기 때문입니다. 또한 객체 수준에서 작업할 수도 없습니다. Deprecate된 이름이 Deprecate되지 않은 객체에 앨리어스될 것이기 때문입니다.&lt;/p&gt;

&lt;p&gt;한 가지 해결책은 컴파일 시간에 이러한 이름을 인식하고, 일반적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOAD_GLOBAL&lt;/code&gt; 대신 별도의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOAD_OLD_GLOBAL&lt;/code&gt; opcode를 방출하는 것입니다. 이 특수 opcode는 이름이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;globals&lt;/code&gt; 네임스페이스에 없고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;builtins&lt;/code&gt; 네임스페이스에만 있을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DeprecationWarning&lt;/code&gt; (또는 결정된 정책에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PendingDeprecationWarning&lt;/code&gt;)을 처리합니다. 이는 잘못된 긍정(false positives)을 피하기에 충분하며(예: 어떤 모듈에서 자신만의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;를 정의하는 경우), 잘못된 부정(false negatives)은 드물 것입니다(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;builtins&lt;/code&gt; 모듈을 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;에 직접 접근하는 경우).&lt;/p&gt;

&lt;h5 id=&quot;모듈-수준-예외-module-level-exceptions&quot;&gt;모듈 수준 예외 (module-level exceptions)&lt;/h5&gt;

&lt;p&gt;위의 접근 방식은 코드 객체를 컴파일할 때 일부 모듈을 특별하게 처리해야 하므로 쉽게 사용할 수 없습니다. 그러나 이러한 이름은 구성상 훨씬 덜 가시적이며(builtins 네임스페이스에 나타나지 않음) 덜 알려져 있으므로, 자체 네임스페이스에 남겨두기로 결정할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;2단계-추가-서브클래스-정의-define-additional-subclasses&quot;&gt;2단계: 추가 서브클래스 정의 (define additional subclasses)&lt;/h3&gt;

&lt;p&gt;해결책의 두 번째 단계는 특정 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 값에 대해 부모 클래스 대신 서브클래스가 발생하도록 계층 구조를 확장하는 것입니다. 어떤 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 값을 사용할지는 논의의 대상이지만, 기존 예외 매칭 관행에 대한 조사([Appendix A] 참조)는 모든 값의 합리적인 부분 집합을 제안하는 데 도움이 됩니다. 모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 니모닉을 매핑하려는 시도는 어리석고 무의미하며 루트 네임스페이스를 오염시킬 것입니다.&lt;/p&gt;

&lt;p&gt;더 나아가, 몇몇 경우에는 다른 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 값이 동일한 예외 서브클래스를 발생시킬 수 있습니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EAGAIN&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EALREADY&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EWOULDBLOCK&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EINPROGRESS&lt;/code&gt;는 모두 논블로킹(non-blocking) 소켓에서의 작업이 블로킹될 것임을 알리는 데 사용됩니다(따라서 나중에 다시 시도해야 함). 따라서 이들은 모두 동일한 서브클래스를 발생시키고, 사용자가 원한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 속성을 검사하도록 할 수 있습니다([예외 속성] 참조).&lt;/p&gt;

&lt;h4 id=&quot;전제-조건-prerequisite&quot;&gt;전제 조건 (Prerequisite)&lt;/h4&gt;

&lt;p&gt;1단계는 이에 대한 느슨한 전제 조건입니다.&lt;/p&gt;

&lt;p&gt;전제 조건인 이유는 현재 일부 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt;는 맥락에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt; 모두에 연결될 수 있기 때문입니다(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENOENT&lt;/code&gt;). 유용한 호환성을 깨고 싶지 않다면, 현재 성공할 예외를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;except OSError&lt;/code&gt; (또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;)가 일치시키지 못하도록 할 수 없습니다.&lt;/p&gt;

&lt;p&gt;느슨한 이유는 기존 예외 클래스가 통합되지 않은 경우 2단계의 부분적 해결을 결정할 수 있기 때문입니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENOENT&lt;/code&gt;는 이전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;가 발생했던 곳에서 가상의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FileNotFoundError&lt;/code&gt;를 발생시킬 수 있지만, 그렇지 않은 경우에는 계속 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;를 발생시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;새로운 서브클래스가 모든 기존 슈퍼클래스(또는 적어도 가장 일반적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;)와 일치하기 위해 다중 상속을 사용한다면 1단계에 대한 의존성은 완전히 제거될 수 있습니다. 그러나 이는 계층 구조를 더 복잡하게 만들고 따라서 사용자가 이해하기 어렵게 만들 것입니다.&lt;/p&gt;

&lt;h4 id=&quot;새로운-예외-클래스-new-exception-classes&quot;&gt;새로운 예외 클래스 (New exception classes)&lt;/h4&gt;

&lt;p&gt;다음은 설명과 매핑된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 값 목록과 함께 논의를 위해 제출된 잠정적인 서브클래스 목록입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FileExistsError&lt;/code&gt;: 이미 존재하는 파일이나 디렉토리를 생성하려 할 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EEXIST&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FileNotFoundError&lt;/code&gt;: 파일이나 디렉토리가 요청되었으나 존재하지 않는 모든 상황 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENOENT&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IsADirectoryError&lt;/code&gt;: 디렉토리에 대해 파일 수준 작업(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;os.remove()&lt;/code&gt; 등)이 요청될 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EISDIR&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NotADirectoryError&lt;/code&gt;: 디렉토리 수준 작업이 다른 것에 대해 요청될 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENOTDIR&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PermissionError&lt;/code&gt;: 적절한 접근 권한 없이 작업을 실행하려 할 때(예: 파일 시스템 권한) (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EACCES&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EPERM&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlockingIOError&lt;/code&gt;: 논블로킹(non-blocking) 작업으로 설정된 객체(예: 소켓)에서 작업이 블로킹될 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EAGAIN&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EALREADY&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EWOULDBLOCK&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EINPROGRESS&lt;/code&gt;); 이는 기존 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io.BlockingIOError&lt;/code&gt;의 역할 확장입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BrokenPipeError&lt;/code&gt;: 다른 쪽 끝이 닫힌 파이프에 쓰려고 하거나, 쓰기 위해 종료된 소켓에 쓰려고 할 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EPIPE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESHUTDOWN&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InterruptedError&lt;/code&gt;: 시스템 호출이 들어오는 신호에 의해 중단될 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EINTR&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConnectionAbortedError&lt;/code&gt;: 피어(peer)에 의해 연결 시도가 중단될 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECONNABORTED&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConnectionRefusedError&lt;/code&gt;: 피어에 의해 연결이 거부될 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECONNREFUSED&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConnectionResetError&lt;/code&gt;: 피어에 의해 연결이 재설정될 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECONNRESET&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TimeoutError&lt;/code&gt;: 연결 시간이 초과될 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ETIMEDOUT&lt;/code&gt;); 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.timeout&lt;/code&gt;을 대체하고 다른 유형의 타임아웃(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lock.acquire()&lt;/code&gt;)에도 유용한 일반적인 타임아웃 예외로 재구성될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChildProcessError&lt;/code&gt;: 자식 프로세스에 대한 작업이 실패할 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECHILD&lt;/code&gt;); 이는 주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 계열 함수에 의해 발생합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProcessLookupError&lt;/code&gt;: 주어진 프로세스(예: 프로세스 ID로 식별됨)가 존재하지 않을 때 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESRCH&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또한, 다음 예외 클래스의 포함이 제안됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConnectionError&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConnectionAbortedError&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConnectionRefusedError&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConnectionResetError&lt;/code&gt;의 기본 클래스입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음 그림은 제안된 추가 사항과 해당 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 값(해당하는 경우)을 요약하려고 합니다. 하위 계층 구조의 루트(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;, 1단계가 완전히 수락되었다고 가정)는 표시되지 않습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+-- BlockingIOError           EAGAIN, EALREADY, EWOULDBLOCK, EINPROGRESS
+-- ChildProcessError         ECHILD
+-- ConnectionError
|   +-- BrokenPipeError       EPIPE, ESHUTDOWN
|   +-- ConnectionAbortedError ECONNABORTED
|   +-- ConnectionRefusedError ECONNREFUSED
|   +-- ConnectionResetError   ECONNRESET
+-- FileExistsError           EEXIST
+-- FileNotFoundError         ENOENT
+-- InterruptedError          EINTR
+-- IsADirectoryError         EISDIR
+-- NotADirectoryError        ENOTDIR
+-- PermissionError           EACCES, EPERM
+-- ProcessLookupError        ESRCH
+-- TimeoutError              ETIMEDOUT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;명명-naming&quot;&gt;명명 (Naming)&lt;/h4&gt;

&lt;p&gt;다양한 명명 논란이 발생할 수 있습니다. 그 중 하나는 모든 예외 클래스 이름이 “Error”로 끝나야 하는지 여부입니다. 찬성하는 쪽은 나머지 예외 계층 구조와의 일관성을 주장하고, 반대하는 쪽은 간결성(특히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConnectionAbortedError&lt;/code&gt;와 같은 긴 이름의 경우)을 주장합니다.&lt;/p&gt;

&lt;h4 id=&quot;예외-속성-exception-attributes-1&quot;&gt;예외 속성 (Exception attributes)&lt;/h4&gt;

&lt;p&gt;유용한 호환성을 유지하기 위해, 이러한 서브클래스는 슈퍼클래스에 정의된 다양한 예외 속성(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filename&lt;/code&gt;, 선택적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;winerror&lt;/code&gt;)에 대해 적절한 값을 설정해야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;구현-implementation&quot;&gt;구현 (Implementation)&lt;/h4&gt;

&lt;p&gt;서브클래스가 전적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 값에 기반하여 발생하도록 제안되었으므로, 확장 모듈(표준 또는 타사)에서는 거의 또는 전혀 변경이 필요하지 않습니다.&lt;/p&gt;

&lt;p&gt;첫 번째 가능성은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PyErr_SetFromErrno()&lt;/code&gt; 계열 함수(Windows에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PyErr_SetFromWindowsErr()&lt;/code&gt;)를 적절한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt; 서브클래스를 발생시키도록 조정하는 것입니다. 그러나 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lib/tempfile.py&lt;/code&gt;에서 볼 수 있는 다음 관용구를 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;를 직접 발생시키는 Python 코드는 다루지 못할 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IOError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EEXIST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;No usable temporary file name found&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Marc-Andre Lemburg가 제안한 두 번째 가능성은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError.__new__&lt;/code&gt;를 적절한 서브클래스를 인스턴스화하도록 조정하는 것입니다. 이는 위와 같은 Python 코드도 다루는 이점이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;가능한-반론-possible-objections&quot;&gt;가능한 반론 (Possible objections)&lt;/h2&gt;

&lt;h3 id=&quot;네임스페이스-오염-namespace-pollution&quot;&gt;네임스페이스 오염 (Namespace pollution)&lt;/h3&gt;

&lt;p&gt;예외 계층 구조를 더 세분화하면 루트(또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;builtins&lt;/code&gt;) 네임스페이스가 커집니다. 그러나 다음 이유로 이는 완화되어야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제안된 추가 클래스는 소수에 불과합니다.&lt;/li&gt;
  &lt;li&gt;표준 예외 유형은 루트 네임스페이스에 있지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CamelCase&lt;/code&gt; 규칙을 사용하는 반면 거의 모든 다른 내장(builtins)은 소문자 명명(True, False, None, Ellipsis, NotImplemented 제외)을 사용한다는 사실로 시각적으로 구별됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대안은 더 세분화된 예외를 포함하는 별도의 모듈을 제공하는 것이지만, 이는 사용자가 이미 접근 가능한 이름을 사용하는 대신 새 모듈을 먼저 가져와야 하므로 ‘부주의한’ 코드보다 ‘신중한’ 코드를 장려하려는 목적에 어긋날 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;이전-논의-earlier-discussion&quot;&gt;이전 논의 (Earlier discussion)&lt;/h2&gt;

&lt;p&gt;이러한 공식적인 제안은 이번이 처음이지만, 이러한 아이디어는 과거에 비공식적인 지지를 얻었습니다. 이는 세분화된 예외 클래스의 도입과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;의 통합 모두에 해당합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt;만 제거하는 것은 다른 PEP의 일부로 논의되고 거부되었지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;와의 구분이 의미 없다는 합의가 있는 것으로 보였습니다. 이는 적어도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;와의 앨리어싱을 지지합니다.&lt;/p&gt;

&lt;h2 id=&quot;구현-implementation-1&quot;&gt;구현 (Implementation)&lt;/h2&gt;

&lt;p&gt;참조 구현은 Python 3.3에 통합되었습니다. 이전에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://hg.python.org/features/pep-3151/&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pep-3151&lt;/code&gt; 브랜치에서 개발되었으며, 버그 트래커 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://bugs.python.org/issue12555&lt;/code&gt;에서도 추적되었습니다. Linux, Windows, OpenIndiana, FreeBSD 빌드봇을 포함한 다양한 시스템에서 성공적으로 테스트되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt;의 각 생성자가 호환되지 않는다는 문제가 있었습니다. 이를 해결하는 방법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt; 시그니처를 유지하고 네 번째 선택적 인수를 추가하여 Windows 오류 코드(POSIX &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt;와 다름)를 전달할 수 있도록 하는 것입니다. 네 번째 인수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;winerror&lt;/code&gt;로 저장되고 해당 POSIX 번역은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt;로 저장됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PyErr_SetFromWindowsErr*&lt;/code&gt; 함수는 올바른 생성자 호출을 사용하도록 조정되었습니다.&lt;/p&gt;

&lt;p&gt;약간 복잡한 상황은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PyErr_SetExcFromWindowsErr*&lt;/code&gt; 함수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;와 함께 호출될 때 발생합니다. 이 경우 예외 객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 속성은 POSIX 번역(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EPIPE&lt;/code&gt;의 경우 32) 대신 Windows 오류 코드(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ERROR_BROKEN_PIPE&lt;/code&gt;의 경우 109)를 저장하게 됩니다. 소켓 오류 코드가 아닌 경우, 이는 호환성 문제가 없는 개인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_multiprocessing&lt;/code&gt; 모듈에서만 발생합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고:&lt;/strong&gt; 소켓 오류의 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 모듈에 반영된 “POSIX &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt;“는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WSAGetLastError&lt;/code&gt; 시스템 호출에 의해 반환되는 Windows 소켓 오류 코드와 수치적으로 동일합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EWOULDBLOCK&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10035&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WSAEWOULDBLOCK&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10035&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;가능한-대안-possible-alternative&quot;&gt;가능한 대안 (Possible alternative)&lt;/h2&gt;

&lt;h3 id=&quot;패턴-매칭-pattern-matching&quot;&gt;패턴 매칭 (Pattern matching)&lt;/h3&gt;

&lt;p&gt;또 다른 가능성은 예외를 포착할 때 고급 패턴 매칭 구문을 도입하는 것입니다. 예를 들어:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;OSError&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENOENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 제안에는 여러 가지 문제가 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;새로운 구문을 도입하며, 이는 예외 계층 구조를 재작업하는 것보다 더 큰 변경으로 인식됩니다.&lt;/li&gt;
  &lt;li&gt;입력 노력(typing effort)을 크게 줄이지 않습니다.&lt;/li&gt;
  &lt;li&gt;프로그래머에게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 니모닉을 기억해야 하는 부담을 덜어주지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;이-pep에-의해-무시된-예외-exceptions-ignored-by-this-pep&quot;&gt;이 PEP에 의해 무시된 예외 (Exceptions ignored by this PEP)&lt;/h2&gt;

&lt;p&gt;이 PEP는 다양한 프로토콜 및 파일 형식 구현(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GzipFile&lt;/code&gt;)에서 잘린 입력 스트림을 나타내는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EOFError&lt;/code&gt;를 무시합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EOFError&lt;/code&gt;는 OS 또는 IO 관련 오류가 아니며, 더 높은 수준에서 발생하는 논리적 오류입니다.&lt;/p&gt;

&lt;p&gt;이 PEP는 또한 OpenSSL 라이브러리에 의해 신호된 오류를 전파하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssl&lt;/code&gt; 모듈에서 발생하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSLError&lt;/code&gt;를 무시합니다. 이상적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSLError&lt;/code&gt;는 자체 오류 유형 상수(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssl.SSL_ERROR_WANT_READ&lt;/code&gt; 등)를 정의하므로 유사하지만 별도의 처리가 필요할 것입니다. Python 3.2에서는 소켓 타임아웃을 나타낼 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SSLError&lt;/code&gt;가 이미 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.timeout&lt;/code&gt;으로 대체되었습니다(issue 10272 참조).&lt;/p&gt;

&lt;p&gt;마지막으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.gaierror&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.herror&lt;/code&gt;의 운명은 아직 결정되지 않았습니다. 이들은 덜 암호적인 이름을 가질 가치가 있지만, 예외 계층 구조 재조직 노력과는 별도로 처리될 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;appendix-a-일반적인-errno-조사-survey-of-common-errnos&quot;&gt;Appendix A: 일반적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 조사 (Survey of common errnos)&lt;/h2&gt;

&lt;p&gt;다음은 표준 라이브러리 및 해당 테스트에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;except&lt;/code&gt; 절의 일부로 확인된 다양한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 니모닉의 간략한 목록입니다.&lt;/p&gt;

&lt;h3 id=&quot;oserror와-관련된-일반적인-errno&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;와 관련된 일반적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EBADF&lt;/code&gt;: 잘못된 파일 디스크립터 (일반적으로 파일 디스크립터가 닫혔음을 의미)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EEXIST&lt;/code&gt;: 파일 또는 디렉토리가 존재함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EINTR&lt;/code&gt;: 인터럽트된 함수 호출&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EISDIR&lt;/code&gt;: 디렉토리임&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENOTDIR&lt;/code&gt;: 디렉토리가 아님&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENOENT&lt;/code&gt;: 파일 또는 디렉토리가 없음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EOPNOTSUPP&lt;/code&gt;: 소켓에서 지원되지 않는 작업 (기존 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io.UnsupportedOperation&lt;/code&gt;과의 혼동 가능성)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EPERM&lt;/code&gt;: 작업이 허용되지 않음 (예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;os.setuid()&lt;/code&gt; 사용 시)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ioerror와-관련된-일반적인-errno&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;와 관련된 일반적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EACCES&lt;/code&gt;: 권한 거부됨 (파일 시스템 작업의 경우)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EBADF&lt;/code&gt;: 잘못된 파일 디스크립터 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select.epoll&lt;/code&gt; 사용 시); 쓰기 전용 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GzipFile&lt;/code&gt;에 대한 읽기 작업, 또는 그 반대&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EBUSY&lt;/code&gt;: 장치 또는 리소스 사용 중&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EISDIR&lt;/code&gt;: 디렉토리임 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open()&lt;/code&gt; 시도 시)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENODEV&lt;/code&gt;: 장치가 없음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENOENT&lt;/code&gt;: 파일 또는 디렉토리가 없음 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open()&lt;/code&gt; 시도 시)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ETIMEDOUT&lt;/code&gt;: 연결 시간 초과&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;socketerror와-관련된-일반적인-errno&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.error&lt;/code&gt;와 관련된 일반적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;이러한 모든 오류는 소켓의 파일 디스크립터에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt;를 호출하는 경우와 같이 일반 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;와도 연관될 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EAGAIN&lt;/code&gt;: 리소스 일시적으로 사용 불가 (논블로킹 소켓 호출 중 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect()&lt;/code&gt; 제외)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EALREADY&lt;/code&gt;: 연결이 이미 진행 중 (논블로킹 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect()&lt;/code&gt; 중)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EINPROGRESS&lt;/code&gt;: 작업 진행 중 (논블로킹 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect()&lt;/code&gt; 중)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EINTR&lt;/code&gt;: 인터럽트된 함수 호출&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EISCONN&lt;/code&gt;: 소켓이 연결됨&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECONNABORTED&lt;/code&gt;: 피어에 의해 연결 중단됨 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;accept()&lt;/code&gt; 호출 중)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECONNREFUSED&lt;/code&gt;: 피어에 의해 연결 거부됨&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECONNRESET&lt;/code&gt;: 피어에 의해 연결 재설정됨&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENOTCONN&lt;/code&gt;: 소켓이 연결되지 않음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESHUTDOWN&lt;/code&gt;: 전송 엔드포인트 종료 후 전송할 수 없음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EWOULDBLOCK&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EAGAIN&lt;/code&gt;과 동일한 이유&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;selecterror와-관련된-일반적인-errno&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select.error&lt;/code&gt;와 관련된 일반적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EINTR&lt;/code&gt;: 인터럽트된 함수 호출&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;appendix-b-발생한-os-및-io-오류-조사-survey-of-raised-os-and-io-errors&quot;&gt;Appendix B: 발생한 OS 및 IO 오류 조사 (Survey of raised OS and IO errors)&lt;/h2&gt;

&lt;h3 id=&quot;vmserror에-대하여-about-vmserror&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VMSError&lt;/code&gt;에 대하여 (About VMSError)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VMSError&lt;/code&gt;는 인터프리터 코어와 표준 라이브러리에서 전혀 사용되지 않습니다. 이는 2002년 Jean-François Piéronne이 제출한 OpenVMS 패치의 일부로 추가되었습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VMSError&lt;/code&gt;를 포함시킨 동기는 타사 패키지에서 발생할 수 있었기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;인터프리터-코어-interpreter-core&quot;&gt;인터프리터 코어 (Interpreter core)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PYTHONSTARTUP&lt;/code&gt; 처리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다(그러나 오류는 버려집니다).&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ PYTHONSTARTUP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;foox ./python
Python 3.2a0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;py3k:82920M, Jul 16 2010, 22:53:23&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;GCC 4.4.3] on linux2
Type &lt;span class=&quot;s2&quot;&gt;&quot;help&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;copyright&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;credits&quot;&lt;/span&gt; or &lt;span class=&quot;s2&quot;&gt;&quot;license&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;more information.
Could not open PYTHONSTARTUP
IOError: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Errno 2] No such file or directory: &lt;span class=&quot;s1&quot;&gt;&apos;foox&apos;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PyObject_Print()&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FILE *&lt;/code&gt; 매개변수(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stdout&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stderr&lt;/code&gt;에 해당)에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ferror()&lt;/code&gt;가 오류를 신호할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mbcs&lt;/code&gt; 인코딩을 사용하는 유니코드 인코딩 및 디코딩은 일부 오류 조건에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt;를 발생시킬 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;표준-라이브러리-standard-library&quot;&gt;표준 라이브러리 (Standard library)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;bz2&lt;/strong&gt;: 전반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;는 사용되지 않음).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;curses&lt;/strong&gt;: 검사되지 않음.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;dbm.gnu, dbm.ndbm&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_dbm.error&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_gdbm.error&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 상속합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;fcntl&lt;/strong&gt;: 전반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;는 사용되지 않음).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;imp module&lt;/strong&gt;: 잘못된 파일 디스크립터에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;io module&lt;/strong&gt;: Unix에서 디렉토리를 열려고 할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다. 지원되지 않는 작업에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;io.UnsupportedOperation&lt;/code&gt; (전자를 상속)을 발생시킵니다. 하위 I/O 계층이 오작동할 때(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API&lt;/code&gt;를 위반할 때) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TypeError&lt;/code&gt;를 발생시킵니다. 기본 OS 리소스가 유효하지 않게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다. 논블로킹 객체에 대한 호출이 블로킹될 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BlockingIOError&lt;/code&gt; (IOError 상속)를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;mmap&lt;/strong&gt;: Unix에서는 전반적으로 자체 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap.error&lt;/code&gt; (EnvironmentError 상속)를 발생시킵니다. 그러나 Windows에서는 대부분 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt;를 발생시킵니다(소스 코드에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap.error&lt;/code&gt;의 몇 가지 발생도 있음).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;multiprocessing&lt;/strong&gt;: 검사되지 않음.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;os / posix&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;os&lt;/code&gt; (또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;posix&lt;/code&gt;) 모듈은 전반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;를 발생시킵니다. Windows에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt;가 대신 발생할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ossaudiodev&lt;/strong&gt;: 전반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;는 사용되지 않음).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;readline&lt;/strong&gt;: 다양한 파일 처리 함수에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;select&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;poll&lt;/code&gt; 객체는 아무것도 상속하지 않는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select.error&lt;/code&gt;를 발생시킵니다(그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;poll.modify()&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다). &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epoll&lt;/code&gt; 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kqueue&lt;/code&gt; 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OSError&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 모두 발생시킵니다. 부수적으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EnvironmentError&lt;/code&gt;를 상속하지 않는다는 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select.error&lt;/code&gt;가 유용한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt; 속성을 얻지 못한다는 것을 의미합니다. 사용자 코드는 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;args[0]&lt;/code&gt;을 확인해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;signal&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal.ItimerError&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 상속합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;socket&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.error&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 상속합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sys&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetVersionEx()&lt;/code&gt; 호출이 실패하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys.getwindowsversion()&lt;/code&gt;은 잘못된 오류 번호와 함께 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WindowsError&lt;/code&gt;를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;time&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.time()&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.sleep()&lt;/code&gt;의 내부 오류에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;zipimport&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zipimporter.get_data()&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IOError&lt;/code&gt;를 발생시킬 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;감사-acknowledgments&quot;&gt;감사 (Acknowledgments)&lt;/h2&gt;

&lt;p&gt;Alyssa Coghlan으로부터 상당한 의견을 받았습니다.&lt;/p&gt;

&lt;h2 id=&quot;참조-references&quot;&gt;참조 (References)&lt;/h2&gt;

&lt;p&gt;“IO module precisions and exception hierarchy”: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://mail.python.org/pipermail/python-dev/2009-September/092130.html&lt;/code&gt;
 Google Code Search of IOError in Python code: 약 40000개 결과; OSError: 약 15200개 결과; EnvironmentError: 약 3000개 결과
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://bugs.python.org/issue614055&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h2&gt;

&lt;p&gt;이 문서는 퍼블릭 도메인에 공개되었습니다.
Source: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://github.com/python/peps/blob/main/peps/pep-3151.rst&lt;/code&gt;
최종 수정: 2025-02-01 08:59:27 GMT&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 14:41:26 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3151/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3151/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Deferred] PEP 3150 - Statement local namespaces (aka “given” clause)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3150/&quot;&gt;PEP 3150 - Statement local namespaces (aka “given” clause)&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Deferred&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 09-Jul-2010&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;다음은 PEP 3150 문서의 내용을 한국어로 번역하고 정리한 것입니다.&lt;/p&gt;

&lt;h1 id=&quot;pep-3150--statement-local-namespaces-일명-given-절&quot;&gt;PEP 3150 – Statement local namespaces (일명 “given” 절)&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Alyssa Coghlan&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상태:&lt;/strong&gt; Deferred (보류됨)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;생성일:&lt;/strong&gt; 2010년 7월 9일&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Python 버전:&lt;/strong&gt; 3.4&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개요-abstract&quot;&gt;개요 (Abstract)&lt;/h2&gt;

&lt;p&gt;이 PEP는 현재 연관된 코드 스위트(code suite)가 없는 여러 Python 문장에 선택적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절을 추가할 것을 제안합니다. 이 절은 연관된 문장 내에서 접근 가능하지만, 포함하는 네임스페이스(namespace)의 일부가 되지 않는 추가적인 이름들을 위한 문장 로컬 네임스페이스(statement local namespace)를 생성합니다.&lt;/p&gt;

&lt;p&gt;연관된 코드 스위트 실행을 통해 생성된 네임스페이스에 대한 전방 참조(forward reference)를 나타내기 위해 새로운 기호인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt;를 도입할 것을 제안합니다. 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;types.SimpleNamespace&lt;/code&gt; 객체에 대한 참조가 될 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;제안-배경-motivation&quot;&gt;제안 배경 (Motivation)&lt;/h2&gt;

&lt;p&gt;주된 동기는 보다 선언적인 프로그래밍 스타일(declarative style of programming)을 가능하게 하는 것입니다. 이는 수행될 연산을 독자에게 먼저 제시하고, 필요한 하위 계산(subcalculations)의 세부 사항을 들여쓰기된 스위트(indented suite)에 제시하는 방식입니다. 예를 들어, 일반 할당 문장(assignment statement)을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def&lt;/code&gt; 문장과 동등하게 만들어, 정의될 항목의 이름이 해당 항목의 값이 계산되는 방식에 대한 세부 사항보다 먼저 독자에게 제시될 수 있도록 합니다. 또한, 이름이 현재 표현식에서만 플레이스홀더(placeholder)로 사용된 다음 이어지는 스위트에서 정의되는 “다중 라인 람다(multi-line lambda)” 방식으로 이름 있는 함수를 사용할 수 있게 합니다.&lt;/p&gt;

&lt;p&gt;두 번째 동기는 모듈(module) 및 클래스(class) 수준 코드에서 중간 계산(interim calculations)을 단순화하면서도 결과 네임스페이스를 오염시키지 않는 것입니다.&lt;/p&gt;

&lt;p&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절과 특정 연산을 수행하는 별도의 함수 정의 간의 관계는, 명시적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; 루프와 동일한 연산 시퀀스를 생성하는 제너레이터(Generator) 간의 기존 관계와 유사하게 의도됩니다.&lt;/p&gt;

&lt;h2 id=&quot;제안-proposal&quot;&gt;제안 (Proposal)&lt;/h2&gt;

&lt;p&gt;이 PEP는 표현식을 포함하거나 순전히 문법적 목적으로 그러한 문장을 대체할 수 있는 단순 문장(simple statements)의 구문에 선택적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절을 추가할 것을 제안합니다. 이 추가의 영향을 받는 단순 문장 목록은 다음과 같습니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expression statement&lt;/code&gt; (표현식 문장)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assignment statement&lt;/code&gt; (할당 문장)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;augmented assignment statement&lt;/code&gt; (증강 할당 문장)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;del statement&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;del&lt;/code&gt; 문장)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return statement&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; 문장)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield statement&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt; 문장)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;raise statement&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;raise&lt;/code&gt; 문장)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert statement&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt; 문장)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pass statement&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pass&lt;/code&gt; 문장)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절은 헤더 라인에서 하위 표현식(subexpressions)을 이름으로 참조할 수 있게 하며, 실제 정의는 들여쓰기된 절에 이어집니다. 간단한 예시는 다음과 같습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sorted_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sort_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attr2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;새로운 기호 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 네임스페이스를 참조하는 데 사용됩니다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;types.SimpleNamespace&lt;/code&gt; 인스턴스가 되므로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?.sort_key&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절에 정의된 이름에 대한 전방 참조로 작동합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절에는 독스트링(docstring)이 허용되며, 결과 네임스페이스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__doc__&lt;/code&gt; 속성으로 첨부됩니다.&lt;/p&gt;

&lt;h3 id=&quot;의미론-semantics&quot;&gt;의미론 (Semantics)&lt;/h3&gt;

&lt;p&gt;다음 문장:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound_a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound_b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound_a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound_b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound_a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound_b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;은 대략 다음 코드와 동일하게 작동합니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;__arg1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__arg2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bound_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound_a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound_b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound_a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound_b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SimpleNamespace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__arg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__arg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__doc__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__doc__&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절은 본질적으로 생성된 다음 즉시 실행되는 중첩 함수(nested function)입니다. 명시적으로 전달되지 않는 한, 이름은 일반적인 스코핑 규칙(scoping rules)을 사용하여 조회되며, 따라서 클래스 스코프(class scope)에 정의된 이름은 보이지 않습니다. 전방 참조로 선언된 이름은 반환되어 헤더 문장에서 사용되며, 주변 네임스페이스에 로컬로 바인딩되지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;문법-변경-syntax-change&quot;&gt;문법 변경 (Syntax Change)&lt;/h3&gt;

&lt;p&gt;제안된 문법 변경은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given_clause&lt;/code&gt;를 여러 단순 문장에 선택적으로 추가합니다.&lt;/p&gt;

&lt;p&gt;새로운 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given_clause&lt;/code&gt;의 정의:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;given_clause: &quot;given&quot; [(NAME &apos;=&apos; test)+ &quot;in&quot;]&quot;:&quot; suite
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 변경은 문법적 모호성을 피하기 위해 기존 문장의 선택적 요소로 추가됩니다. 그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;simple_stmt&lt;/code&gt; 정의와 관련하여 문제가 발생할 수 있으며, 이는 문법의 비 trivial한 재구조화를 필요로 할 수 있다고 언급됩니다.&lt;/p&gt;

&lt;h3 id=&quot;새로운-pep-8-가이드라인-new-pep-8-guidelines&quot;&gt;새로운 PEP 8 가이드라인 (New PEP 8 Guidelines)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-ideas&lt;/code&gt;에서 논의된 바와 같이, 일반 변수 할당 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절을 언제 사용해야 하는지에 대한 적절한 지침을 제공하기 위해 새로운 PEP 8 가이드라인이 개발되어야 합니다. PEP는 PEP 8의 “프로그래밍 컨벤션(Programming Conventions)” 섹션에 다음과 같은 추가를 제안합니다:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;별도의 함수로 합리적으로 분리될 수 있지만 현재 재사용되지 않는 코드의 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절 사용을 고려해야 합니다. 이는 어떤 변수들이 알고리즘 또는 애플리케이션 상태를 유지하기보다는 다른 문장의 하위 구성 요소를 정의하는 데만 사용되는지를 명확하게 보여줍니다. 이는 호출 가능한 인수를 취하는 연산에 다중 라인 함수를 전달할 때 특히 유용한 기술입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절은 간결하게 유지해야 합니다. 복잡해지면 여러 단계로 나누거나 세부 사항을 별도의 함수로 옮겨야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;설계-논의-design-discussion&quot;&gt;설계 논의 (Design Discussion)&lt;/h2&gt;

&lt;h3 id=&quot;키워드-선택-keyword-choice&quot;&gt;키워드 선택 (Keyword Choice)&lt;/h3&gt;

&lt;p&gt;이 제안은 처음에는 Haskell의 유사한 구문 이름을 기반으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where&lt;/code&gt;를 사용했습니다. 그러나 NumPy와 같은 기존 Python 라이브러리에서 SQL 쿼리 조건의 의미로 이미 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where&lt;/code&gt;를 사용하고 있어 혼란을 야기할 수 있다는 지적이 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt;은 변수 이름으로도 사용될 수 있지만 (따라서 새로운 키워드 도입을 위한 일반적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__future__&lt;/code&gt; 절차에 따라 사용이 중단될 수 있음), 새로운 절에 대한 “여기에 이 표현식이 사용할 수 있는 추가 변수들이 있습니다”라는 의미와 훨씬 더 강하게 연관됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; 키워드를 재사용하는 것도 제안되었지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; 절과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; 문장이 비슷하게 보이지만 완전히 다른 작업을 수행하므로 혼란의 가능성이 높다고 지적되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;pep-403과의-관계-relation-to-pep-403&quot;&gt;PEP 403과의 관계 (Relation to PEP 403)&lt;/h3&gt;

&lt;p&gt;PEP 403 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;General Purpose Decorator Clause&lt;/code&gt;)은 기존 데코레이터(decorator) 문법에서 영감을 받은 덜 급진적인 언어 변경을 통해 이 PEP의 주요 목표를 달성하려고 시도합니다.&lt;/p&gt;

&lt;p&gt;두 PEP는 동일한 저자임에도 불구하고 서로 직접 경쟁 관계에 있습니다. PEP 403은 현 상태에서 최소한의 변경으로 유용한 기능을 달성하려는 미니멀리스트적 접근 방식을 대표합니다. 반면 이 PEP는 언어에 더 큰 변경을 요구하는 더 유연한 독립형 문장 설계를 목표로 합니다.&lt;/p&gt;

&lt;p&gt;PEP 403이 제너레이터 표현식(generator expressions)의 동작을 더 잘 설명하는 데 적합한 반면, 이 PEP는 일반적으로 데코레이터 절의 동작을 설명하는 데 더 적합합니다. 두 PEP 모두 컨테이너 컴프리헨션(container comprehensions)의 의미론에 대한 적절한 설명을 지원합니다.&lt;/p&gt;

&lt;h3 id=&quot;컨테이너-컴프리헨션-및-제너레이터-표현식-설명-explaining-container-comprehensions-and-generator-expressions&quot;&gt;컨테이너 컴프리헨션 및 제너레이터 표현식 설명 (Explaining Container Comprehensions and Generator Expressions)&lt;/h3&gt;

&lt;p&gt;제안된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 구문은 컨테이너 컴프리헨션의 스코핑(scoping) 및 실행 순서 의미론을 설명하는 데 원시적인 형태로 사용될 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;seq2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 대략적으로 다음과 동일
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seq2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;given&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 확장에서 중요한 점은 컴프리헨션이 클래스 스코프에서 오작동하는 것처럼 보이는 이유를 설명한다는 것입니다: 가장 바깥쪽 이터레이터(iterator)만 클래스 스코프에서 평가되고, 모든 조건자(predicates), 중첩된 이터레이터 및 값 표현식은 중첩된 스코프 내에서 평가됩니다.&lt;/p&gt;

&lt;h3 id=&quot;데코레이터-절-평가-및-적용-설명-explaining-decorator-clause-evaluation-and-application&quot;&gt;데코레이터 절 평가 및 적용 설명 (Explaining Decorator Clause Evaluation and Application)&lt;/h3&gt;

&lt;p&gt;데코레이터 절의 평가 및 적용에 대한 표준 설명은 실행 순서 단계를 보여주기 위해 숨겨진 컴파일러 변수(hidden compiler variables) 개념을 다루어야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 문장을 사용하면 다음과 같은 데코레이트된 함수 정의를:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@classmethod&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;대략 다음과 같이 설명할 수 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;classname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;d1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;classname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;classmethod&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;classname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;예상되는-반대-의견-anticipated-objections&quot;&gt;예상되는 반대 의견 (Anticipated Objections)&lt;/h2&gt;

&lt;h3 id=&quot;두-가지-방법-two-ways-to-do-it&quot;&gt;두 가지 방법 (Two Ways To Do It)&lt;/h3&gt;

&lt;p&gt;많은 코드가 이제 값을 사용하기 전에 정의하거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절에서 나중에 정의할 수 있게 되어, 두 가지 방법이 생기고, 그 중 어느 것을 선택해야 할지 명확한 방법이 없을 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 PEP는 이것이 “하나의 명확한 방법(one obvious way)”이라는 격언의 잘못된 적용이라고 주장합니다. Python은 이미 코드를 작성하는 여러 방법을 제공하며, 언어는 사람들이 생각하는 방식에 맞춰 코드를 작성할 수 있도록 설계되었습니다. 이러한 스타일 질문은 코드베이스를 담당하는 개발 그룹에 맡겨져야 합니다. 그러나 CPython 및 표준 라이브러리를 위한 명시적인 PEP 8 지침이 필요할 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;순서가-뒤바뀐-실행-out-of-order-execution&quot;&gt;순서가 뒤바뀐 실행 (Out of Order Execution)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절의 본문이 절 헤더의 단순 문장보다 먼저 실행되므로 실행이 다소 이상하게 왔다 갔다 합니다. Python의 다른 부분 중 가장 유사한 것은 리스트 컴프리헨션, 제너레이터 표현식 및 조건 표현식에서의 순서가 뒤바뀐 평가(out of order evaluation)와 데코레이터 함수의 지연된 적용(delayed application)입니다.&lt;/p&gt;

&lt;p&gt;이것이 사실이지만, 이 문법은 사람들이 문제를 (언어의 관점에서 볼 때) 순서 없이 생각하는 경우를 위한 것입니다. 예를 들어, “이 시퀀스의 항목들을 각 항목의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;attr1&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;attr2&lt;/code&gt; 값에 따라 정렬하고 싶다”는 생각을 Python 사용자가 다음과 같이 표현할 수 있게 합니다:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sorted_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;original&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attr2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이는 사용자가 원래 생각한 순서와 동일하며, 정렬 기준에 대한 이름을 따로 만들 필요 없이 키워드 인수 이름을 직접 재사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;인트로스펙션introspection에-해로움-harmful-to-introspection&quot;&gt;인트로스펙션(Introspection)에 해로움 (Harmful to Introspection)&lt;/h3&gt;

&lt;p&gt;모듈(module) 및 클래스(class) 내부를 조사하는 것은 화이트박스 테스트(white-box testing) 및 인터랙티브 디버깅(interactive debugging)에 매우 유용한 도구입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절은 계산 중에 사용되는 임시 상태(temporary state)에 대한 접근을 상당히 효과적으로 방지할 것입니다.&lt;/p&gt;

&lt;p&gt;이는 타당한 우려이지만, 테스트 가능성(testability)을 위한 설계는 프로그래밍의 여러 측면에 걸쳐 있는 문제입니다. 구성 요소가 독립적으로 테스트되어야 하는 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 문장은 정보가 테스트 스위트에 노출되도록 별도의 문장으로 리팩토링(refactored)되어야 합니다. 이는 함수나 제너레이터 내부에 숨겨진 연산을 단순히 독립적으로 테스트하기 위해 별도의 함수로 리팩토링하는 것과 크게 다르지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;실제-영향-평가-부족-lack-of-real-world-impact-assessment&quot;&gt;실제 영향 평가 부족 (Lack of Real World Impact Assessment)&lt;/h3&gt;

&lt;p&gt;현재 PEP의 예시는 거의 모두 비교적 작은 “장난감(toy)” 예시입니다. 이 PEP의 제안은 실제 코드의 가독성이 진정으로 향상되는 예시를 찾기 위해 대규모 코드베이스 (예: 표준 라이브러리 또는 대규모 Twisted 애플리케이션)에 적용되는 테스트를 거쳐야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;미해결-질문-open-questions&quot;&gt;미해결 질문 (Open Questions)&lt;/h2&gt;

&lt;h3 id=&quot;전방-참조를-위한-문법-syntax-for-forward-references&quot;&gt;전방 참조를 위한 문법 (Syntax for Forward References)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt; 기호는 짧고 현재 사용되지 않으며 “여기에 나중에 채워질 무언가가 누락되어 있다”는 것을 암시하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 네임스페이스에 대한 전방 참조에 제안되었습니다. 이 제안은 기존 Python 기능과 깔끔하게 일치하지 않으므로 이미 사용 중인 기호 재사용은 의도적으로 피했습니다.&lt;/p&gt;

&lt;h3 id=&quot;nonlocal-및-global-처리-handling-of-nonlocal-and-global&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonlocal&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global&lt;/code&gt; 처리 (Handling of nonlocal and global)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonlocal&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절 스위트 내에서 명시적으로 허용되지 않으며, 발생 시 문법 오류가 될 것입니다. 해당 스위트 내의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def&lt;/code&gt; 문장 내에 나타나면 정상적으로 작동합니다.&lt;/p&gt;

&lt;h3 id=&quot;break-및-continue-처리-handling-of-break-and-continue&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;break&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;continue&lt;/code&gt; 처리 (Handling of break and continue)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;break&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;continue&lt;/code&gt;는 익명 함수(anonymous functions)가 위 확장과 같이 정의된 것처럼 작동할 것입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절 스위트 내에 나타나면 문법 오류가 되지만, 해당 스위트의 일부로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; 루프 내에 나타나면 정상적으로 작동합니다.&lt;/p&gt;

&lt;h3 id=&quot;return-및-yield-처리-handling-of-return-and-yield&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt; 처리 (Handling of return and yield)&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; 절 스위트 내에서 명시적으로 허용되지 않으며, 발생 시 문법 오류가 될 것입니다. 해당 스위트 내의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def&lt;/code&gt; 문장 내에 나타나면 정상적으로 작동합니다.&lt;/p&gt;

&lt;h2 id=&quot;예시-examples&quot;&gt;예시 (Examples)&lt;/h2&gt;

&lt;h3 id=&quot;이벤트-기반-프로그래밍을-위한-콜백-정의-defining-callbacks-for-event-driven-programming&quot;&gt;이벤트 기반 프로그래밍을 위한 콜백 정의 (Defining callbacks for event driven programming)&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 기존 Python
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 소켓으로 뭔가 처리
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;eb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;logging&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Failed connecting to %s:%s&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;create_connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# becomes:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;create_connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 소켓으로 뭔가 처리
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;eb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;logging&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Failed connecting to %s:%s&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;일반적으로-단일-인스턴스만-갖는-일회성-클래스-정의-defining-one-off-classes-which-typically-only-have-a-single-instance&quot;&gt;일반적으로 단일 인스턴스만 갖는 “일회성” 클래스 정의 (Defining “one-off” classes which typically only have a single instance)&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# becomes:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;public_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MeaningfulClassName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MeaningfulClassName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 여러 라인
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;로컬-네임스페이스를-오염시키지-않고-속성-계산-calculating-attributes-without-polluting-the-local-namespace&quot;&gt;로컬 네임스페이스를 오염시키지 않고 속성 계산 (Calculating attributes without polluting the local namespace)&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 기존 Python (수동 네임스페이스 정리)
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_createenviron&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 27라인 함수
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_createenviron&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;del&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_createenviron&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# becomes:
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;environ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_createenviron&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;_createenviron&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 27라인 함수
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;기본-인수-해킹default-argument-hack-대체-replacing-default-argument-hack&quot;&gt;기본 인수 해킹(default argument hack) 대체 (Replacing default argument hack)&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# becomes:
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decorating_function&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;given&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# Cell 변수이지 locals는 아니지만, 유사한 속도 향상 제공
&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;KeyError&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;KeyError&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;decorating_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 60라인 함수
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;거부된-대안-rejected-alternatives&quot;&gt;거부된 대안 (Rejected Alternatives)&lt;/h2&gt;

&lt;p&gt;이 PEP의 이전 버전은 후행 스위트(trailing suite)의 이름에 대한 암묵적인 전방 참조와 암묵적인 조기 바인딩(early binding) 의미론을 허용했습니다. 이 두 아이디어 모두 표현력의 충분한 증가 없이 제안을 상당히 복잡하게 만들었습니다. 명시적 전방 참조와 조기 바인딩을 가진 현재 제안은 새로운 구문을 기존 스코핑 의미론에 맞추어, 아이디어가 실제로 구현될 가능성을 크게 높였습니다.&lt;/p&gt;

&lt;p&gt;두 스위트 “순서대로(in-order)” 변형에 대한 제안도 있었는데, 이는 순서가 뒤바뀐 실행을 지원하지 않고 이름의 제한된 스코핑을 제공합니다. 그러나 이러한 제안은 사람들이 다중 라인 람다 지원을 요청할 때 불평하는 요점, 즉 하위 표현식의 이름을 정하는 것이 특히 어렵다는 것이 아니라, 사용하는 문장보다 먼저 함수의 이름을 정하는 것이 개발자가 문제를 생각하는 방식과 코드가 일치하지 않게 만든다는 점을 놓치고 있다고 PEP는 주장합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 14:40:31 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3150/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3150/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 3149 - ABI version tagged .so files</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3149/&quot;&gt;PEP 3149 - ABI version tagged .so files&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 09-Jul-2010&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-3149--abi-버전-태그가-지정된-so-파일&quot;&gt;PEP 3149 – ABI 버전 태그가 지정된 .so 파일&lt;/h2&gt;

&lt;h3 id=&quot;개요-abstract&quot;&gt;개요 (Abstract)&lt;/h3&gt;
&lt;p&gt;이 PEP(Python Enhancement Proposal)는 Python의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import&lt;/code&gt; 메커니즘을 확장하여 확장 모듈 파일(.so)을 유사한 방식으로 함께 배치할 수 있는 기능을 정의합니다. 이는 선택적인 빌드-타임(build-time) 기능으로, Python 배포판이 여러 Python 주(major) 버전을 동시에 더 쉽게 제공할 수 있도록 돕습니다.&lt;/p&gt;

&lt;p&gt;이 제안은 PEP 3147에서 순수(pure) Python 소스 코드의 공유를 개선하기 위해 설명된 기능에 대한 보조적인(adjunct) 기능입니다. PEP 3147은 각 소스 파일과 함께 여러 바이트 컴파일 파일(.pyc)을 함께 배치할 수 있도록 했습니다.&lt;/p&gt;

&lt;h3 id=&quot;배경-background&quot;&gt;배경 (Background)&lt;/h3&gt;
&lt;p&gt;PEP 3147은 시스템에 여러 Python 버전이 있을 때 순수 Python 패키지의 파일 시스템 레이아웃을 정의했습니다. 예를 들어, Python 3.2 및 3.3이 설치된 시스템에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;one.py&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;two.py&lt;/code&gt; 소스 모듈을 포함하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alpha&lt;/code&gt; 패키지가 있는 경우, 바이트 컴파일 후의 파일 시스템 레이아웃은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alpha/
    __pycache__/
        __init__.cpython-32.pyc
        __init__.cpython-33.pyc
        one.cpython-32.pyc
        one.cpython-33.pyc
        two.cpython-32.pyc
        two.cpython-33.pyc
    __init__.py
    one.py
    two.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;확장 모듈이 포함된 패키지의 경우, 모듈의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 파일에도 유사한 차별화가 필요합니다. 서로 다른 Python 주 버전용으로 컴파일된 확장 모듈은 ABI(Application Binary Interface) 변경으로 인해 서로 호환되지 않습니다. 또한, 동일한 Python 버전이라도 다른 구성/컴파일 옵션(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--with-wide-unicode&lt;/code&gt;)은 다른 ABI를 초래할 수 있습니다.&lt;/p&gt;

&lt;p&gt;PEP 384는 안정적인 ABI를 정의하지만, 이는 Python 빌드 또는 주 버전 간의 확장 모듈 비호환성을 최소화할 뿐 완전히 제거하지는 못합니다. 따라서 확장 모듈 파일 이름을 구별하기 위한 메커니즘이 제안됩니다.&lt;/p&gt;

&lt;h3 id=&quot;제안의-근거-rationale&quot;&gt;제안의 근거 (Rationale)&lt;/h3&gt;
&lt;p&gt;Ubuntu 및 Debian과 같은 Linux 배포판은 사용자에게 여러 Python 버전을 동시에 제공합니다. 예를 들어, Ubuntu 9.10 Karmic Koala 사용자는 Python 2.5, 2.6, 3.1을 설치할 수 있으며, Python 2.6이 기본값입니다.&lt;/p&gt;

&lt;p&gt;사용 가능한 Python 버전 간에 최대한 많은 것을 공유하기 위해 이러한 배포판은 타사 패키지 모듈(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 파일)을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/usr/share/pyshared&lt;/code&gt;에 설치하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/usr/lib/pythonX.Y/dist-packages&lt;/code&gt;에서 심볼릭 링크(symlink)합니다. PEP 3147 이전(즉, Python 3.2 미만)에는 다양한 설치된 Python 버전으로 바이트 컴파일된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일이 서로 이름 충돌을 일으켰기 때문에 심볼릭 링크가 존재했습니다. Python 3.2 이상 버전의 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일이 더 이상 파일 시스템 이름 충돌을 일으키지 않으므로 모든 순수 Python 패키지를 공유할 수 있습니다. 이러한 심볼릭 링크를 제거하면 Python 배포가 더 간단하고 견고해집니다.&lt;/p&gt;

&lt;p&gt;공유 라이브러리 확장에서도 유사한 상황이 발생합니다. 확장 모듈은 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt; 확장 모듈에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.so&lt;/code&gt;로 이름이 지정되기 때문에, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt;가 여러 Python 버전용으로 제공되면 이 또한 이름 충돌을 일으킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한, 동일한 Python 버전이라도 다른 구성/컴파일 옵션은 확장 모듈에 다른 ABI를 제공할 수 있습니다. 예를 들어 POSIX 시스템에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--with-pydebug&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--with-pymalloc&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--with-wide-unicode&lt;/code&gt; 구성 옵션이 모두 ABI를 변경합니다. 이 PEP는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 확장 모듈 파일의 파일 이름에 빌드-타임 옵션을 인코딩할 것을 제안합니다.&lt;/p&gt;

&lt;p&gt;PyPy도 이 PEP의 혜택을 받아 API용으로 빌드되었지만 다른 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 태그를 가진 확장 모듈의 이름 충돌을 피할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;제안-proposal&quot;&gt;제안 (Proposal)&lt;/h3&gt;
&lt;p&gt;Python 인터프리터 빌드-타임에 선택된 구성/컴파일 옵션은 확장 모듈의 공유 라이브러리 파일 이름에 인코딩됩니다. 이 “태그(tag)”는 모듈 기본 이름과 공유 라이브러리의 운영 파일 시스템 확장자 사이에 나타납니다.&lt;/p&gt;

&lt;p&gt;다음 정보는 공유 라이브러리 파일 이름에 &lt;strong&gt;반드시&lt;/strong&gt; 포함되어야 합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Python 구현 (예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpython&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pypy&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jython&lt;/code&gt; 등)&lt;/li&gt;
  &lt;li&gt;인터프리터의 주(major) 및 부(minor) 버전 번호&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 두 필드는 하이픈으로 구분되며, 주 및 부 버전 번호 사이에는 점이 나타나지 않습니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpython-32&lt;/code&gt;와 같습니다.&lt;/p&gt;

&lt;p&gt;Python 구현은 필요에 따라 파일 이름 태그에 추가 플래그를 포함할 수 있습니다. 예를 들어, POSIX 시스템에서는 다음 플래그도 파일 이름에 기여합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--with-pydebug&lt;/code&gt; (플래그: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--with-pymalloc&lt;/code&gt; (플래그: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--with-wide-unicode&lt;/code&gt; (플래그: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본적으로 Python 3.2에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configure&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--with-pymalloc&lt;/code&gt;을 활성화하므로 공유 라이브러리 파일 이름은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.cpython-32m.so&lt;/code&gt;와 같이 나타납니다. 다른 두 플래그도 활성화되면 파일 이름은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.cpython-32dmu.so&lt;/code&gt;가 됩니다.&lt;/p&gt;

&lt;p&gt;공유 라이브러리 파일 이름 태그는 무조건적으로 사용되며 변경할 수 없습니다. 태그와 확장 모듈 접미사는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sysconfig&lt;/code&gt; 모듈을 통해 다음 변수로 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sysconfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get_config_var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;EXT_SUFFIX&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;.cpython-32mu.so&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sysconfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get_config_var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;SOABI&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;cpython-32mu&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$SOABI&lt;/code&gt;는 태그만 포함하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$EXT_SUFFIX&lt;/code&gt;는 공유 라이브러리 파일의 플랫폼 확장자를 포함하며, 확장 모듈 이름에 추가되는 정확한 접미사입니다.&lt;/p&gt;

&lt;p&gt;임의의 패키지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt;에 대해 배포 패키지가 설치되었을 때 다음과 같은 파일이 보일 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/lib/python/foo.cpython-32m.so
/usr/lib/python/foo.cpython-33m.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(이 경로들은 예시일 뿐입니다. 배포판은 원하는 파일 시스템 레이아웃을 자유롭게 사용할 수 있으며, 이 PEP의 어떤 내용도 Python의 소스 빌드(from-source builds)가 설치되는 위치를 변경하지 않습니다.)&lt;/p&gt;

&lt;p&gt;Python의 동적 모듈 로더는 빌드-타임 옵션과 일치하는 태그를 가진 공유 라이브러리 확장 모듈을 인식하고 임포트합니다. 하위 호환성을 위해 Python은 태그 없는 확장 모듈(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.so&lt;/code&gt;)도 계속 임포트합니다.&lt;/p&gt;

&lt;p&gt;이 공유 라이브러리 태그는 파일 시스템 어디에서 빌드되든 관계없이 모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distutils&lt;/code&gt; 기반 확장 모듈에 전역적으로 사용됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distutils&lt;/code&gt; 이외의 수단으로 빌드된 확장 모듈은 태그를 수동으로 계산하거나 태그 없는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 파일 이름으로 폴백(fallback)해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;입증된-접근-방식-proven-approach&quot;&gt;입증된 접근 방식 (Proven Approach)&lt;/h3&gt;
&lt;p&gt;여기에 설명된 접근 방식은 Python 및 확장 모듈의 디버그 빌드(debug builds)에 다른 확장자를 사용하는 Debian 및 Ubuntu 시스템에서 이미 입증되었습니다. Windows의 디버그 빌드도 이미 동적 라이브러리에 다른 파일 확장자를 사용하며, 실제로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.dll&lt;/code&gt; 파일 이름에 Python 주 및 부 버전을 인코딩합니다(이 PEP에서 제안하는 방식과는 다르게).&lt;/p&gt;

&lt;h3 id=&quot;windows-지원-windows&quot;&gt;Windows 지원 (Windows)&lt;/h3&gt;
&lt;p&gt;이 PEP는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;configure&lt;/code&gt; 스크립트를 사용하는 POSIX 시스템의 빌드 문제만 다룹니다. Windows 또는 다른 플랫폼 지원이 이 PEP에서 명시적으로 허용되지 않는 것은 아니지만, 그러한 플랫폼에서 지원을 평가, 설명 및 구현하려면 플랫폼 전문 지식이 필요합니다. 현재로서는 이 PEP의 기능이 Windows에 유용한지 명확하지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;pep-384-stable-abi&quot;&gt;PEP 384 (Stable ABI)&lt;/h3&gt;
&lt;p&gt;PEP 384는 확장 모듈을 위한 안정적인 ABI를 정의합니다. 이론적으로 PEP 384가 보편적으로 채택되면 모든 확장 모듈이 모든 Python 버전과 호환될 수 있으므로 이 PEP의 필요성이 없어질 것입니다. 하지만 실제로는 보편적인 채택을 달성하는 것이 불가능하며, 위에서 설명한 대로 다른 빌드-타임 플래그가 여전히 ABI에 영향을 미칩니다. 따라서 안정적인 ABI가 있더라도 이 PEP는 여전히 필요할 수 있습니다.&lt;/p&gt;

&lt;p&gt;전체 사양은 PEP 384에 있지만, 관련 문제에 대한 논의는 다음과 같습니다.
PEP 384는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Py_LIMITED_API&lt;/code&gt;로 확장 기능이 컴파일된 경우 API 버전으로 3이 전달되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PyModule_Create()&lt;/code&gt;에 대한 변경 사항을 설명합니다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PYTHON_API_VERSION&lt;/code&gt;을 반영하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PYTHON_ABI_VERSION&lt;/code&gt;이라는 공식 매크로로 형식화되어야 합니다. ABI가 호환되지 않는 방식으로 변경되면 이 버전 번호가 증가할 것입니다. 공유를 용이하게 하기 위해 Python은 이름에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PYTHON_ABI_VERSION&lt;/code&gt; 번호가 포함된 확장 모듈을 검색하도록 확장될 것입니다. 접두사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abi&lt;/code&gt;는 Python의 사용을 위해 예약됩니다.&lt;/p&gt;

&lt;p&gt;따라서, PEP 384의 초기 구현에서 Python이 기본 플래그 세트로 구성될 때 확장 모듈 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt;가 임포트될 때 다음 파일 이름(이 순서로)을 검색합니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.cpython-XYm.so&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.abi3.so&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.so&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distutils&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build_ext&lt;/code&gt; 명령도 모듈 작성자가 해당 ABI 버전을 지원한다고 표시할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abi3&lt;/code&gt; 태그가 있는 공유 라이브러리 파일로 컴파일하도록 확장되어야 합니다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Extension&lt;/code&gt; 클래스에 다음과 같은 키워드 인수를 추가하는 방식으로 하위 호환성을 유지하면서 수행할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Extension&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;foo.c&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Martin v. Löwis는 이 PEP가 PEP 384에 적용되는지에 대한 자신의 생각을 설명했습니다. 요약하면 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--with-pydebug&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PyObject&lt;/code&gt;의 레이아웃을 변경하므로 안정적인 ABI에 의해 지원되지 않습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--with-pymalloc&lt;/code&gt;은 이 문제와 관련이 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--with-wide-unicode&lt;/code&gt;는 더 까다롭지만, Martin은 안정적인 ABI가 플랫폼의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wchar_t&lt;/code&gt;와 일치하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Py_UNICODE&lt;/code&gt;를 사용하도록 강제하는 경향이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;대안-alternatives&quot;&gt;대안 (Alternatives)&lt;/h3&gt;
&lt;p&gt;이 아이디어가 처음 도입된 초기 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-dev&lt;/code&gt; 스레드에서 몇 가지 대안이 제안되었습니다. 완전성을 위해 채택되지 않은 이유와 함께 여기에 나열됩니다.&lt;/p&gt;

&lt;h4 id=&quot;독립적인-디렉터리-또는-심볼릭-링크-independent-directories-or-symlinks&quot;&gt;독립적인 디렉터리 또는 심볼릭 링크 (Independent directories or symlinks)&lt;/h4&gt;
&lt;p&gt;Debian 및 Ubuntu는 단순히 해당 Python 버전의 확장 모듈만 포함하는 버전별 디렉터리를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys.path&lt;/code&gt;에 추가할 수 있습니다. 또는 PEP 3147에서 제거된 심볼릭 링크 트릭을 공유 라이브러리에 대해서만 유지할 수 있습니다. 이 접근 방식은 PEP 3147이 피하려는 본질적인 복잡성을 전파하고, 확장 모듈 수가 전체 Python 패키지 수보다 훨씬 적을 때에도 모든 모듈을 검색하기 위해 잠재적으로 여러 추가 디렉터리를 추가하므로 거부되었습니다. 예를 들어, 넓은 유니코드 포함 여부, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pydebug&lt;/code&gt; 포함 여부, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pymalloc&lt;/code&gt; 포함 여부에 따라 빌드가 제공되면 검색되는 디렉터리 수가 크게 증가합니다.&lt;/p&gt;

&lt;h4 id=&quot;확장-모듈이-있는-패키지를-공유하지-않음-dont-share-packages-with-extension-modules&quot;&gt;확장 모듈이 있는 패키지를 공유하지 않음 (Don’t share packages with extension modules)&lt;/h4&gt;
&lt;p&gt;확장 모듈이 있는 Python 패키지를 배포판의 모든 지원되는 Python 버전 간에 공유하지 않아야 한다는 제안이 있었습니다. PEP 3149가 채택되더라도 확장 모듈은 모든 지원되는 Python 버전용으로 컴파일되어야 하므로, 그러한 패키지를 공유하는 것이 어쨌든 유용하지 않을 수 있습니다. 그러나 확장 기능이 있는 패키지를 공유하지 않는 것은 여러 가지 이유로 실현 불가능합니다.&lt;/p&gt;

&lt;p&gt;순수 Python 패키지가 한 버전에서 공유되는데, 다음 릴리스에서 속도 향상을 위해 확장 모듈이 추가되면 갑자기 공유되지 않아야 할까요? 또한, 모든 확장 공유 라이브러리가 지원되는 모든 Python 버전용으로 한 번 컴파일되고 배포되더라도, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 파일만 복제하는 것과 모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.py&lt;/code&gt; 파일을 복제하는 것 사이에는 큰 차이가 있습니다. 추가 크기는 그러한 패키지의 다운로드 시간을 증가시키고, 더 즉각적으로는 이미 제한된 배포 CD-ROM의 공간 압력을 증가시킵니다.&lt;/p&gt;

&lt;h3 id=&quot;참조-구현-reference-implementation&quot;&gt;참조 구현 (Reference implementation)&lt;/h3&gt;
&lt;p&gt;이 코드에 대한 작업은 Python 3.2로 병합될 준비가 될 때까지 Launchpad의 Bazaar 브랜치에서 추적됩니다. 작업 중인 diff도 볼 수 있으며, 새로운 변경 사항이 업로드될 때 자동으로 업데이트됩니다.&lt;/p&gt;

&lt;h3 id=&quot;저작권-copyright&quot;&gt;저작권 (Copyright)&lt;/h3&gt;
&lt;p&gt;이 문서는 퍼블릭 도메인에 공개되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 14:39:52 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3149/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3149/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 3148 - futures - execute computations asynchronously</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3148/&quot;&gt;PEP 3148 - futures - execute computations asynchronously&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 16-Oct-2009&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;PEP 3148 – futures - 비동기 연산 실행&lt;/p&gt;

&lt;h2 id=&quot;개요-abstract&quot;&gt;개요 (Abstract)&lt;/h2&gt;

&lt;p&gt;이 PEP는 스레드와 프로세스를 활용하여 호출 가능한(callable) 객체의 연산을 용이하게 하는 패키지 설계를 제안합니다. 이 패키지는 비동기 연산을 추상화하여 개발자가 병렬 처리 로직을 직접 관리하는 복잡성을 줄이고, 더 쉽고 효율적인 동시성 프로그래밍을 가능하게 합니다.&lt;/p&gt;

&lt;h2 id=&quot;도입-배경-motivation&quot;&gt;도입 배경 (Motivation)&lt;/h2&gt;

&lt;p&gt;Python은 현재 멀티스레드 및 멀티프로세스 애플리케이션을 구축하기 위한 강력한 기본 요소를 제공하지만, 단순한 작업을 병렬화하는 것은 많은 노력을 필요로 합니다. 예를 들어, 명시적으로 프로세스/스레드를 시작하고, 작업/결과 큐를 구성하며, 완료 또는 기타 종료 조건(예: 실패, 타임아웃)을 기다리는 과정이 복잡합니다. 또한, 각 구성 요소가 자체 병렬 실행 전략을 사용할 경우, 전역 프로세스/스레드 제한을 가진 애플리케이션을 설계하는 것이 어렵습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;futures&lt;/code&gt; 패키지는 이러한 복잡성을 추상화하여 개발자가 더 쉽게 병렬 연산을 수행할 수 있도록 돕습니다.&lt;/p&gt;

&lt;h2 id=&quot;사양-specification&quot;&gt;사양 (Specification)&lt;/h2&gt;

&lt;h3 id=&quot;명명-naming&quot;&gt;명명 (Naming)&lt;/h3&gt;

&lt;p&gt;제안된 패키지는 “futures”라고 불리며 새로운 최상위 패키지인 “concurrent” 안에 위치합니다. “concurrent” 네임스페이스에 포함시키는 이유는 다음과 같습니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;기존의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from __future__ import x&lt;/code&gt; 구문과의 혼동을 방지합니다.&lt;/li&gt;
  &lt;li&gt;라이브러리가 동시성(concurrency)과 관련이 있음을 명확하게 나타냅니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multiprocessing.Pool&lt;/code&gt; 작업과 같이 기존의 동시성 관련 라이브러리들을 미래에 이 네임스페이스로 이동하거나 추가할 수 있는 기반을 마련합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;인터페이스-interface&quot;&gt;인터페이스 (Interface)&lt;/h3&gt;

&lt;p&gt;제안된 패키지는 두 가지 핵심 클래스인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;를 제공합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt;는 호출 가능한 객체와 인수를 받아 비동기 작업 요청을 처리하고, 해당 작업의 실행을 나타내는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 객체를 반환합니다.&lt;/p&gt;

&lt;h4 id=&quot;executor&quot;&gt;Executor&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt;는 비동기적으로 호출을 실행하는 메서드를 제공하는 추상 클래스입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;submit(fn, *args, **kwargs)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fn(*args, **kwargs)&lt;/code&gt;로 실행될 호출 가능 객체를 스케줄링하고, 해당 호출의 실행을 나타내는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 인스턴스를 반환합니다. 이 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 서브클래스에서 구현되어야 하는 추상 메서드입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map(func, *iterables, timeout=None)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map(func, *iterables)&lt;/code&gt;와 유사하지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func&lt;/code&gt;가 비동기적으로 실행되며 여러 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func&lt;/code&gt; 호출이 동시에 이루어질 수 있습니다. 반환된 이터레이터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__next__()&lt;/code&gt;가 호출되었을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map()&lt;/code&gt;에 대한 원래 호출로부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 초 후에 결과가 사용 가능하지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TimeoutError&lt;/code&gt;를 발생시킵니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shutdown(wait=True)&lt;/code&gt;: 현재 보류 중인 퓨처들의 실행이 완료되면 사용 중인 리소스를 해제해야 함을 Executor에 알립니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shutdown&lt;/code&gt; 이후의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor.submit&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor.map&lt;/code&gt; 호출은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RuntimeError&lt;/code&gt;를 발생시킵니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;이면 모든 보류 중인 퓨처가 실행을 마치고 관련 리소스가 해제될 때까지 이 메서드는 반환되지 않습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;이면 즉시 반환되며, 리소스는 모든 퓨처가 완료된 후에 해제됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__enter__()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__exit__(exc_type, exc_val, exc_tb)&lt;/code&gt;: 컨텍스트 매니저로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt;를 사용할 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__exit__&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor.shutdown(wait=True)&lt;/code&gt;를 호출합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;processpoolexecutor&quot;&gt;ProcessPoolExecutor&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProcessPoolExecutor&lt;/code&gt; 클래스는 프로세스 풀을 사용하여 호출을 비동기적으로 실행하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 서브클래스입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProcessPoolExecutor.submit&lt;/code&gt;에 전달되는 호출 가능한 객체와 인수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multiprocessing&lt;/code&gt; 모듈과 동일한 제약 조건에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pickle&lt;/code&gt; 가능해야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProcessPoolExecutor&lt;/code&gt;에 제출된 호출 가능 객체 내에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 메서드를 호출하면 교착 상태(deadlock)가 발생할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__init__(max_workers)&lt;/code&gt;: 최대 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max_workers&lt;/code&gt; 수의 프로세스 풀을 사용하여 호출을 비동기적으로 실행합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max_workers&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt;이거나 제공되지 않으면 머신이 가진 프로세서 수만큼 워커 프로세스가 생성됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;threadpoolexecutor&quot;&gt;ThreadPoolExecutor&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt; 클래스는 스레드 풀을 사용하여 호출을 비동기적으로 실행하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 서브클래스입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;와 관련된 호출 가능 객체가 다른 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;의 결과를 기다릴 때 교착 상태가 발생할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__init__(max_workers)&lt;/code&gt;: 최대 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max_workers&lt;/code&gt; 수의 스레드 풀을 사용하여 호출을 비동기적으로 실행합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;future-객체-future-objects&quot;&gt;Future 객체 (Future Objects)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 클래스는 호출 가능 객체의 비동기 실행을 캡슐화합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 인스턴스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor.submit&lt;/code&gt;에 의해 반환됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancel()&lt;/code&gt;: 호출을 취소하려고 시도합니다. 호출이 현재 실행 중인 경우 취소할 수 없으며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;를 반환하고, 그렇지 않으면 호출이 취소되고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancelled()&lt;/code&gt;: 호출이 성공적으로 취소되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;running()&lt;/code&gt;: 호출이 현재 실행 중이며 취소할 수 없으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;done()&lt;/code&gt;: 호출이 성공적으로 취소되었거나 실행이 완료되었으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result(timeout=None)&lt;/code&gt;: 호출에 의해 반환된 값을 반환합니다. 호출이 아직 완료되지 않은 경우 이 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 초까지 기다립니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 내에 완료되지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TimeoutError&lt;/code&gt;가 발생합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exception(timeout=None)&lt;/code&gt;: 호출에 의해 발생된 예외를 반환합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result&lt;/code&gt;와 유사하게 동작하며, 호출이 예외를 발생시키지 않고 완료되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt;을 반환합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_done_callback(fn)&lt;/code&gt;: 퓨처가 취소되거나 실행을 마쳤을 때 호출될 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fn&lt;/code&gt;을 퓨처에 연결합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fn&lt;/code&gt;은 퓨처를 유일한 인수로 받아 호출됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;내부-future-메서드-internal-future-methods&quot;&gt;내부 Future 메서드 (Internal Future Methods)&lt;/h4&gt;

&lt;p&gt;다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 메서드들은 단위 테스트 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 구현에서 사용하기 위한 것입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_running_or_notify_cancel()&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;와 관련된 작업을 실행하기 전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 구현에서 호출해야 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;를 반환하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;가 취소되었음을 의미하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를 반환하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;가 취소되지 않고 실행 중 상태로 전환되었음을 의미합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_result(result)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;와 관련된 작업의 결과를 설정합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set_exception(exception)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt;와 관련된 작업의 결과를 주어진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Exception&lt;/code&gt;으로 설정합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;모듈-함수-module-functions&quot;&gt;모듈 함수 (Module Functions)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait(fs, timeout=None, return_when=ALL_COMPLETED)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs&lt;/code&gt;에 주어진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 인스턴스들이 완료되기를 기다립니다. 완료된 퓨처를 담는 “done” 세트와 미완료된 퓨처를 담는 “not_done” 세트의 명명된 2-튜플을 반환합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return_when&lt;/code&gt; 인수는 메서드가 언제 반환될지 지정합니다 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIRST_COMPLETED&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIRST_EXCEPTION&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALL_COMPLETED&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;as_completed(fs, timeout=None)&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs&lt;/code&gt;에 주어진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 인스턴스들이 완료(완료되거나 취소됨)될 때마다 해당 퓨처를 반환하는 이터레이터를 제공합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;예시&quot;&gt;예시&lt;/h3&gt;

&lt;p&gt;PEP는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProcessPoolExecutor&lt;/code&gt;를 사용하여 소수(prime number)를 확인하는 예시와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt;를 사용하여 웹 페이지를 크롤링하는 예시를 제공합니다. 이 예시들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;concurrent.futures&lt;/code&gt; 모듈이 복잡한 동시성 로직 없이 어떻게 병렬 작업을 쉽게 처리할 수 있는지 보여줍니다.&lt;/p&gt;

&lt;h2 id=&quot;설계-근거-rationale&quot;&gt;설계 근거 (Rationale)&lt;/h2&gt;

&lt;p&gt;이 모듈의 제안된 설계는 Java의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.util.concurrent&lt;/code&gt; 패키지에 크게 영향을 받았습니다. Java와 마찬가지로 이 모듈의 개념적 기반은 비동기 연산의 진행 상황과 결과를 나타내는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 클래스입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 클래스는 스레드, 프로세스 또는 원격 프로시저 호출을 사용한 평가에 사용될 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 클래스의 구체적인 구현체에 의해 생성됩니다. 참조 구현은 프로세스 또는 스레드 풀을 사용하여 연산을 적극적으로 평가하는 클래스를 제공합니다.&lt;/p&gt;

&lt;p&gt;이 제안은 Python 언어 구문이나 의미에 어떤 변경도 도입하지 않습니다. PEP 3148에 대한 논의를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt; 클래스는 추상 기본 클래스로 만들어졌고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future.remove_done_callback&lt;/code&gt; 메서드는 사용 사례 부족으로 제거되었으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future.add_done_callback&lt;/code&gt; 메서드는 동일한 호출 가능 객체를 여러 번 추가할 수 있도록 수정되었습니다. 또한, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Future&lt;/code&gt; 클래스의 변경 메서드는 해당 퓨처를 생성한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Executor&lt;/code&gt;에만 비공개임을 나타내기 위해 문서화가 개선되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 14:39:26 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3148/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3148/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Final] PEP 3147 - PYC Repository Directories</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3147/&quot;&gt;PEP 3147 - PYC Repository Directories&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Final&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 16-Dec-2009&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;pep-3147--pyc-저장소-디렉터리&quot;&gt;PEP 3147 – PYC 저장소 디렉터리&lt;/h1&gt;

&lt;h2 id=&quot;요약-abstract&quot;&gt;요약 (Abstract)&lt;/h2&gt;
&lt;p&gt;이 PEP는 여러 다른 버전의 Python 인터프리터 간에 Python 소스 코드 파일을 공유하는 방법을 개선하는 Python의 import 메커니즘 확장에 대해 설명합니다. 이는 단일 Python 소스 파일(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.py&lt;/code&gt; 파일)과 함께 여러 바이트 컴파일 파일(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일)이 공존할 수 있도록 허용함으로써 가능합니다. 여기서 설명하는 확장은 Unladen Swallow (PEP 3146)이 활성화된 CPython에서 생성될 수 있는 JIT (Just-In-Time) 출력과 같은 다양한 Python 컴파일 캐시를 지원하는 데에도 사용될 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;배경-background&quot;&gt;배경 (Background)&lt;/h2&gt;
&lt;p&gt;CPython은 소스 코드를 “바이트 코드 (byte code)”로 컴파일하며, 성능 향상을 위해 소스 파일이 변경될 때마다 이 바이트 코드를 파일 시스템에 캐시합니다. 이는 컴파일 단계를 건너뛸 수 있으므로 Python 모듈 로딩을 훨씬 빠르게 만듭니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.py&lt;/code&gt;와 같은 소스 파일의 경우, CPython은 해당 소스 파일 바로 옆에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.pyc&lt;/code&gt; 파일에 바이트 코드를 캐시합니다.&lt;/p&gt;

&lt;p&gt;바이트 코드 파일은 두 개의 32비트 빅 엔디안 숫자와 마샬링된 코드 객체로 구성됩니다. 32비트 숫자는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic number&lt;/code&gt;와 타임스탬프를 나타냅니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic number&lt;/code&gt;는 Python이 바이트 코드 형식을 변경할 때마다 (예: 가상 머신에 새로운 바이트 코드를 추가할 때) 변경됩니다. 이는 이전 버전의 VM용으로 빌드된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일이 문제를 일으키지 않도록 보장합니다. 타임스탬프는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일이 생성된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.py&lt;/code&gt; 파일과 일치하는지 확인하는 데 사용됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic number&lt;/code&gt; 또는 타임스탬프가 일치하지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.py&lt;/code&gt; 파일은 다시 컴파일되고 새로운 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일이 작성됩니다.&lt;/p&gt;

&lt;p&gt;실제로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일은 Python 메이저 릴리스 간에 호환되지 않는 것으로 잘 알려져 있습니다. Python 소스 코드의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import.c&lt;/code&gt; 파일을 살펴보면, 최근의 모든 새로운 CPython 메이저 릴리스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc magic number&lt;/code&gt;를 변경했음을 알 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;제안-동기-rationale&quot;&gt;제안 동기 (Rationale)&lt;/h2&gt;
&lt;p&gt;Ubuntu 및 Debian과 같은 Linux 배포판은 사용자에게 동시에 여러 Python 버전을 제공합니다. 예를 들어, Ubuntu 9.10 Karmic Koala 사용자는 Python 2.5, 2.6, 3.1을 설치할 수 있으며, Python 2.6이 기본입니다.&lt;/p&gt;

&lt;p&gt;이로 인해 시스템에 설치된 서드 파티 Python 소스 파일에 충돌이 발생합니다. 단일 Python 소스 파일을 동시에 여러 Python 버전용으로 컴파일할 수 없기 때문입니다. Python이 일치하지 않는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic number&lt;/code&gt;를 가진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일을 발견하면, 소스를 재컴파일하는 느린 프로세스로 폴백(fallback)합니다. 따라서 시스템에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/usr/share/python/foo.py&lt;/code&gt;가 설치되어 있다면, 두 개의 다른 Python 버전이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일을 놓고 싸우게 되며, 소스가 컴파일될 때마다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일을 다시 작성하게 됩니다. (표준 라이브러리는 여러 버전이 설치되어 있으므로 이 문제의 영향을 받지 않습니다.)&lt;/p&gt;

&lt;p&gt;게다가, 이러한 배포판의 운영 체제 패키징 담당자의 부담을 덜기 위해 배포판 패키지에는 Python 버전 번호가 포함되어 있지 않습니다. 이는 시스템에 설치된 모든 Python 버전에서 공유됩니다. 패키지에 Python 버전 번호를 넣는 것은 유지보수의 악몽이 될 것입니다. 새 Python 릴리스가 추가되거나 제거될 때마다 모든 패키지와 그 의존성을 업데이트해야 하기 때문입니다. 사용 가능한 패키지의 수가 엄청나게 많기 때문에 이 정도의 작업량은 실현 불가능합니다.&lt;/p&gt;

&lt;p&gt;이러한 배포판은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일을 공유할 수 없기 때문에, 소스 코드는 공유하면서 결과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일은 공유되지 않는 위치에 배치하는 정교한 메커니즘이 개발되었습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;symlink&lt;/code&gt; 기반의 Debian 시스템인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-support&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-central&lt;/code&gt;이 그 예시입니다. 이러한 접근 방식은 광범위한 사용자에게 Python 애플리케이션을 제공하기 위한 훨씬 더 복잡하고, 취약하며, 이해하기 어렵고, 단편화된 정책을 만듭니다. 따라서 CPython에 대한 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 공유 문제를 해결하는 것은 이러한 공급업체에게 높은 우선순위입니다.&lt;/p&gt;

&lt;p&gt;이 PEP는 이 문제에 대한 해결책을 제안합니다.&lt;/p&gt;

&lt;h2 id=&quot;제안-내용-proposal&quot;&gt;제안 내용 (Proposal)&lt;/h2&gt;
&lt;p&gt;Python의 import 메커니즘은 모든 Python 패키지 디렉터리 내부에 단일 디렉터리에 바이트 코드 캐시 파일을 쓰고 검색하도록 확장됩니다. 이 디렉터리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt;라고 불릴 것입니다.&lt;/p&gt;

&lt;p&gt;또한, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일 이름에는 컴파일된 Python 버전을 구별하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic string&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tag&lt;/code&gt;라고 불림)이 포함될 것입니다. 이는 단일 Python 소스 파일에 대해 여러 바이트 컴파일된 캐시 파일이 공존할 수 있도록 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic tag&lt;/code&gt;는 구현체에 따라 정의되지만, 구현체 이름과 버전 번호 약어(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cpython-32&lt;/code&gt;)를 포함해야 합니다. 모든 Python 버전 간에 고유해야 하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic number&lt;/code&gt;가 변경될 때마다 새로운 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic tag&lt;/code&gt;가 정의되어야 합니다. 따라서 Python 3.2용 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일의 예시는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.cpython-32.pyc&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic tag&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imp&lt;/code&gt; 모듈의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_tag()&lt;/code&gt; 함수를 통해 사용할 수 있습니다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imp.get_magic()&lt;/code&gt; 함수와 유사합니다.&lt;/p&gt;

&lt;p&gt;이 방식은 Python 패키지 디렉터리의 복잡성을 줄이는 추가적인 이점도 제공합니다.&lt;/p&gt;

&lt;p&gt;Python 소스 파일이 처음 import될 때, 패키지 디렉터리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 디렉터리가 아직 존재하지 않으면 생성됩니다. import된 소스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic-tag&lt;/code&gt; 형식의 이름을 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 디렉터리에 기록됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 디렉터리 또는 그 안의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일 생성이 실패하더라도, import는 PEP 3147 이전과 마찬가지로 성공합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.py&lt;/code&gt; 소스 파일이 없으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 내부의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일은 무시됩니다. 이는 우연히 오래된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일이 import되는 문제를 제거합니다.&lt;/p&gt;

&lt;p&gt;하위 호환성을 위해 Python은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일만 있는 배포판을 계속 지원하지만, 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.py&lt;/code&gt; 파일이 있었을 디렉터리, 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 디렉터리 외부에 있을 때만 가능합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 외부의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.py&lt;/code&gt; 소스 파일이 없을 경우에만 import됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_compile&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compileall&lt;/code&gt;과 같은 도구는 PEP 3147 형식의 레이아웃을 자동으로 생성하도록 확장되지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일만 있는 배포판 레이아웃을 생성하는 옵션도 가질 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;예시-examples&quot;&gt;예시 (Examples)&lt;/h3&gt;
&lt;p&gt;Python 3.2로 패키지를 바이트 컴파일한 후의 디렉터리 구조는 다음과 같습니다:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alpha/
    __pycache__/
        __init__.cpython-32.pyc
        one.cpython-32.pyc
        two.cpython-32.pyc
    __init__.py
    one.py
    two.py
    beta/
        __pycache__/
            __init__.cpython-32.pyc
            three.cpython-32.pyc
            four.cpython-32.pyc
        __init__.py
        three.py
        four.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Python 3.3 및 Unladen Swallow와 같은 다른 Python 버전이 설치된 경우, 바이트 컴파일 후의 파일 시스템은 다음과 같습니다:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alpha/
    __pycache__/
        __init__.cpython-32.pyc
        __init__.cpython-33.pyc
        __init__.unladen-10.pyc
        one.cpython-32.pyc
        one.cpython-33.pyc
        one.unladen-10.pyc
        two.cpython-32.pyc
        two.cpython-33.pyc
        two.unladen-10.pyc
    __init__.py
    one.py
    two.py
    beta/
        __pycache__/
            __init__.cpython-32.pyc
            __init__.cpython-33.pyc
            __init__.unladen-10.pyc
            three.cpython-32.pyc
            three.cpython-33.pyc
            three.unladen-10.pyc
            four.cpython-32.pyc
            four.cpython-33.pyc
            four.unladen-10.pyc
        __init__.py
        three.py
        four.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 디렉터리는 일반적으로 무시될 수 있으므로, 일반적인 디렉터리 목록은 오늘날의 Python보다 훨씬 덜 복잡합니다.&lt;/p&gt;

&lt;h3 id=&quot;python-동작-방식-python-behavior&quot;&gt;Python 동작 방식 (Python behavior)&lt;/h3&gt;
&lt;p&gt;Python이 모듈을 import하기 위해 검색할 때 (예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt;), 몇 가지 상황을 만날 수 있습니다. 현재 Python 규칙에 따라 “일치하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt;“라는 용어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic number&lt;/code&gt;가 현재 인터프리터의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic number&lt;/code&gt;와 일치하고, 소스 파일의 타임스탬프가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일의 타임스탬프와 정확히 일치함을 의미합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Case 0: The steady state&lt;/strong&gt;
Python이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt; 모듈을 import하도록 요청받으면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys.path&lt;/code&gt;를 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.py&lt;/code&gt; 파일을 검색합니다. 발견되면, Python은 일치하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__/foo.&amp;lt;magic&amp;gt;.pyc&lt;/code&gt; 파일이 있는지 확인하고, 있다면 해당 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일이 로드됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Case 1: The first import&lt;/strong&gt;
Python이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.py&lt;/code&gt;를 찾았을 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__/foo.&amp;lt;magic&amp;gt;.pyc&lt;/code&gt; 파일이 없으면, Python은 필요하다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 디렉터리를 생성하고 해당 파일을 생성합니다. Python은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.py&lt;/code&gt; 파일을 파싱하고 바이트 컴파일하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__/foo.&amp;lt;magic&amp;gt;.pyc&lt;/code&gt;에 바이트 코드를 저장합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Case 2: The second import&lt;/strong&gt;
Python이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt; 모듈을 두 번째로 import하도록 요청받으면 (물론 다른 프로세스에서), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys.path&lt;/code&gt;를 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.py&lt;/code&gt; 파일을 다시 검색합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.py&lt;/code&gt; 파일을 찾으면, 일치하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__/foo.&amp;lt;magic&amp;gt;.pyc&lt;/code&gt;를 찾아 바이트 코드를 읽고 평소처럼 계속 진행합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Case 3: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__/foo.&amp;lt;magic&amp;gt;.pyc&lt;/code&gt; with no source&lt;/strong&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.py&lt;/code&gt; 파일이 어떤 식으로든 제거되었지만 캐시된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일은 파일 시스템에 남아 있는 경우, Python은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt;를 import하도록 요청받으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ImportError&lt;/code&gt;를 발생시킵니다. 즉, 소스 파일이 존재하지 않는 한 Python은 캐시 디렉터리에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일을 import하지 않습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Case 4: legacy &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; files and source-less imports&lt;/strong&gt;
Python은 소스 파일이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일 옆에 존재할 때 모든 레거시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일을 무시합니다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.py&lt;/code&gt; 파일 옆에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.pyc&lt;/code&gt; 파일이 있으면 모든 경우에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일은 무시됩니다.
그러나 소스 없는 배포판을 계속 지원하기 위해, 소스 파일이 없으면 Python은 소스 파일이 있었을 위치에 단독 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일이 있다면 이를 import합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Case 5: read-only file systems&lt;/strong&gt;
소스가 읽기 전용 파일 시스템에 있거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 디렉터리 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일을 쓸 수 없는 경우에도 모든 동일한 규칙이 적용됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일 쓰기를 허용하지 않는 권한으로 작성된 경우에도 마찬가지입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;다른-python-구현체-alternative-python-implementations&quot;&gt;다른 Python 구현체 (Alternative Python implementations)&lt;/h3&gt;
&lt;p&gt;Jython, IronPython, PyPy 등 다른 Python 구현체도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 디렉터리를 사용하여 플랫폼에 적합한 컴파일 아티팩트를 저장할 수 있습니다. 예를 들어, Jython은 모듈에 대한 클래스 파일을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__/foo.jython-32.class&lt;/code&gt;에 저장할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;기존-코드에-미치는-영향-effects-on-existing-code&quot;&gt;기존 코드에 미치는 영향 (Effects on existing code)&lt;/h3&gt;
&lt;p&gt;이 PEP의 채택은 Python 내부 및 외부의 기존 코드와 관용구에 영향을 미칠 것입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;PEP 3147 가용성 감지:&lt;/strong&gt;
Python 버전이 PEP 3147 기능을 제공하는지 감지하는 가장 쉬운 방법은 다음을 확인하는 것입니다:
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imp&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;has3147&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasattr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;get_tag&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__file__&lt;/code&gt;:&lt;/strong&gt;
이 PEP는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__file__&lt;/code&gt;의 의미를 변경하지 않습니다.
이 PEP는 모듈에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cached__&lt;/code&gt; 속성 추가를 제안합니다. 이 속성은 항상 읽거나 쓰여진 실제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일을 가리킬 것입니다. 환경 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$PYTHONDONTWRITEBYTECODE&lt;/code&gt;가 설정되었거나, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-B&lt;/code&gt; 옵션이 주어졌거나, 소스가 읽기 전용 파일 시스템에 있는 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cached__&lt;/code&gt; 속성은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일이 존재하지 않았을 경우 기록되었을 위치를 가리킬 것입니다. 이 위치는 물론 경로에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 하위 디렉터리를 포함합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_compile&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compileall&lt;/code&gt;:&lt;/strong&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py_compile&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compileall&lt;/code&gt; 모듈은 새로운 레이아웃을 이해하도록 업데이트될 것입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compileall&lt;/code&gt;에는 레거시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 바이트 컴파일 파일 경로 이름을 작성하기 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-b&lt;/code&gt; 플래그가 추가됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;파일 확장자 검사:&lt;/strong&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt;로 끝나는 파일을 확인하고 마지막 문자를 잘라내어 일치하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.py&lt;/code&gt; 파일을 찾는 일부 코드는 이 PEP가 구현되면 실패할 것입니다. 이를 지원하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imp&lt;/code&gt; 패키지에 두 가지 새로운 메서드가 추가될 것입니다:
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;imp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cache_from_source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pyc_path&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;imp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;source_from_cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pyc_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;py_path&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;대안-alternatives&quot;&gt;대안 (Alternatives)&lt;/h2&gt;
&lt;p&gt;이 섹션에서는 PEP 개발 중에 고려되었지만 거부된 몇 가지 대체 접근 방식 또는 세부 사항을 설명합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;16진수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic tags&lt;/code&gt;:&lt;/strong&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 디렉터리 내부의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일에는 파일 이름에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic tag&lt;/code&gt;가 포함됩니다. 이는 import 시스템이 사용하는 실제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic number&lt;/code&gt;에 대한 니모닉 태그입니다. 이 대신 바이너리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic number&lt;/code&gt;의 16진수 표현을 고유 식별자로 사용할 수도 있었습니다. 그러나 이는 사용자 친화적이지 않으므로 이 PEP에서 제안된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic tag&lt;/code&gt; 방식이 채택되었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PEP 304:&lt;/strong&gt;
철회된 PEP 304와 목표가 일부 겹쳤습니다. PEP 304는 사용자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일을 저장할 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shadow file system hierarchy&lt;/code&gt;를 만들 수 있도록 허용했지만, 이 방식은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일의 위치를 쉽게 찾을 수 없고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$PYTHONBYTECODE&lt;/code&gt; 환경 변수의 적절하고 일관된 사용에 의존하는 등 여러 문제가 있었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fat 바이트 컴파일 파일:&lt;/strong&gt;
이 PEP의 초기 버전은 “fat” Python 바이트 코드 파일을 설명했습니다. 이 파일들은 단일 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyf&lt;/code&gt; 파일에 여러 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 파일과 동일한 내용을 포함하며, 적절한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic number&lt;/code&gt;를 키로 하는 조회 테이블을 가질 것입니다. 그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fat byte compilation files&lt;/code&gt;는 상당히 복잡하고 본질적으로 어려운 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;race conditions&lt;/code&gt;을 도입했기 때문에 현재의 디렉터리 사용 방식이 제안되었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;여러 파일 확장자:&lt;/strong&gt;
PEP 작성자는 여러 개의 얇은 바이트 컴파일 파일이 같은 위치에 존재하되, Python 버전을 지정하기 위해 다른 파일 확장자를 사용하는 접근 방식도 고려했습니다 (예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.pyc25&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.pyc26&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo.pyc31&lt;/code&gt; 등). 그러나 너무 많은 다른 파일을 작성해야 하는 복잡성 때문에 거부되었습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;.pyc:&lt;/strong&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__pycache__&lt;/code&gt; 디렉터리를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pyc&lt;/code&gt; 또는 다른 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dot-file&lt;/code&gt; 이름으로 부르자는 제안이 있었습니다. 이는 *nix 시스템에서 디렉터리를 숨기는 효과를 가질 것입니다. 하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dot-files&lt;/code&gt;는 일부 플랫폼에서만 특별하며, 우리는 사용자로부터 이들을 완전히 숨기기를 원하지 않는다는 등 여러 이유로 거부되었습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 14:39:02 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3147/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3147/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
      <item>
        <title>[Withdrawn] PEP 3146 - Merging Unladen Swallow into CPython</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;원문 링크:&lt;/strong&gt; &lt;a href=&quot;https://peps.python.org/pep-3146/&quot;&gt;PEP 3146 - Merging Unladen Swallow into CPython&lt;/a&gt;&lt;/p&gt;

  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;strong&gt;상태:&lt;/strong&gt; Withdrawn&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;유형:&lt;/strong&gt; Standards Track&lt;/td&gt;
        &lt;td&gt;&lt;strong&gt;작성일:&lt;/strong&gt; 01-Jan-2010&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pep-3146--unladen-swallow을-cpython으로-통합하기-철회됨&quot;&gt;PEP 3146 – Unladen Swallow을 CPython으로 통합하기 (철회됨)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Collin Winter, Jeffrey Yasskin, Reid Kleckner
&lt;strong&gt;상태:&lt;/strong&gt; 철회됨 (Withdrawn)
&lt;strong&gt;유형:&lt;/strong&gt; 표준 트랙 (Standards Track)
&lt;strong&gt;생성일:&lt;/strong&gt; 2010년 1월 1일
&lt;strong&gt;Python 버전:&lt;/strong&gt; 3.3&lt;/p&gt;

&lt;h3 id=&quot;pep-철회&quot;&gt;PEP 철회&lt;/h3&gt;

&lt;p&gt;Unladen Swallow 프로젝트가 중단됨에 따라, 이 PEP는 철회된 것으로 간주됩니다.&lt;/p&gt;

&lt;h3 id=&quot;개요-abstract&quot;&gt;개요 (Abstract)&lt;/h3&gt;

&lt;p&gt;이 PEP는 성능 향상에 중점을 둔 CPython의 오픈 소스 브랜치인 Unladen Swallow 프로젝트를 CPython의 소스 트리로 통합할 것을 제안했습니다. Unladen Swallow는 유효한 Python 2.6.4 애플리케이션 및 C 확장 모듈과 소스 호환성을 가졌습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 CPython에 Just-In-Time (JIT) 컴파일러를 추가하여, 선택된 Python 코드를 최적화된 머신 코드로 컴파일할 수 있도록 했습니다. 고전적인 정적 컴파일러 최적화를 넘어, Unladen Swallow의 JIT 컴파일러는 런타임에 수집된 데이터를 활용하여 코드 동작에 대한 검증된 가정을 세우고, 더 빠른 머신 코드를 생성할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;이 PEP는 Unladen Swallow를 CPython 개발 트리의 별도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k-jit&lt;/code&gt; 브랜치에 통합한 후, 궁극적으로 메인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k&lt;/code&gt; 브랜치와 병합하는 것을 목표로 했습니다. Unladen Swallow는 완성되거나 완벽하지는 않았지만, CPython 로드맵에 통합될 만큼 충분한 성숙도에 도달했다고 판단되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;제안-배경-및-구현-rationale-implementation&quot;&gt;제안 배경 및 구현 (Rationale, Implementation)&lt;/h3&gt;

&lt;p&gt;많은 기업과 개인은 Python이 더 빨라져서 더 많은 프로젝트에 활용되기를 원했습니다. Google도 그러한 회사 중 하나였습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 Google의 수많은 Python 라이브러리, 도구 및 애플리케이션의 성능을 향상시키기 위해 시작된 Google 후원의 CPython 브랜치였습니다. Unladen Swallow의 채택을 최대한 쉽게 만들기 위해, 프로젝트는 처음에는 네 가지 목표를 설정했습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;단일 스레드 코드에서 CPython 2.6.4 기준 대비 5배 성능 향상.&lt;/li&gt;
  &lt;li&gt;유효한 CPython 2.6 애플리케이션과 100% 소스 호환성.&lt;/li&gt;
  &lt;li&gt;유효한 CPython 2.6 C 확장 모듈과 100% 소스 호환성.&lt;/li&gt;
  &lt;li&gt;궁극적으로 CPython으로 다시 병합되도록 설계.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unladen Swallow는 런타임에 피드백을 수집하고 이를 컴파일 시간 최적화에 활용하는 Just-In-Time (JIT) 컴파일러를 구현했습니다. 이는 최신 JavaScript 엔진, 대부분의 Java 가상 머신, Rubinius, MacRuby 등에서 채택된 접근 방식과 유사합니다.&lt;/p&gt;

&lt;p&gt;핵심은 동적 언어가 이론적으로만 동적일 뿐, 실제로는 각 함수나 코드 조각이 상대적으로 정적이며 안정적인 유형 및 자식 함수 세트를 사용한다는 점입니다. CPython의 현재 바이트코드 인터프리터는 실행 중인 코드에 대해 최악의 경우를 가정합니다. Unladen Swallow는 사용자 코드의 이러한 상대적으로 정적인 특성을 활용하여 성능을 향상시켰습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow JIT 컴파일러는 함수의 CPython 바이트코드를 플랫폼별 머신 코드로 변환하며, 런타임에 수집된 데이터와 고전적인 컴파일러 최적화를 사용하여 생성된 머신 코드의 품질을 향상시켰습니다. 프로그램 실행에 실제로 도움이 되는 Python 코드만 컴파일하기 위해, 온라인 휴리스틱을 사용하여 특정 함수의 “핫니스(hotness)”를 평가했습니다. 함수의 핫니스 값이 특정 임계값을 넘으면 컴파일 및 최적화 대상으로 선택되었습니다. 함수가 핫하다고 판단되기 전까지는 표준 CPython &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval&lt;/code&gt; 루프에서 실행되었으며, 이 루프는 실행된 각 바이트코드에 대한 흥미로운 데이터를 기록하도록 계측되었습니다. 이 런타임 데이터는 생성된 머신 코드의 유연성을 줄여 일반적인 경우(common case)에 대해 최적화할 수 있게 했습니다. 예를 들어, 다음 데이터를 수집했습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;브랜치(branch)가 실행되었는지 여부.&lt;/li&gt;
  &lt;li&gt;연산자에 사용된 타입.&lt;/li&gt;
  &lt;li&gt;각 호출 지점(callsite)에서 호출된 함수.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;최적화 시 만들어진 가정이 더 이상 유효하지 않게 되면, 최적화된 머신 코드 실행을 중단하고 인터프리터로 돌아가 나머지 작업을 수행했습니다. 이를 위해 각 최적화된 머신 코드 섹션 앞에는 가드(guard)가 배치되었습니다.&lt;/p&gt;

&lt;p&gt;코드 생성 및 최적화를 위해 LLVM이라는 기존 컴파일러 라이브러리 세트를 재사용했습니다. 이는 소규모 팀이 여러 머신 명령어 세트에서 코드 생성을 이해하고 디버깅하며, 많은 수의 고전적인 컴파일러 최적화를 구현해야 하는 부담을 덜어주었습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 단일 스레드, 순수 Python 코드의 성능 향상에 중점을 두었습니다. CPython의 Global Interpreter Lock (GIL)을 제거하려는 노력은 하지 않았습니다. 이는 Unladen Swallow의 작업과 별개이며, 민감한 문제이므로 메인라인 개발 브랜치에서 수행하는 것이 가장 좋다고 판단했습니다.&lt;/p&gt;

&lt;h3 id=&quot;대안-alternatives&quot;&gt;대안 (Alternatives)&lt;/h3&gt;

&lt;p&gt;Unladen Swallow 팀은 Python 성능 향상을 위한 여러 대안 전략을 고려했지만, 불만족스럽다고 판단했습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Cython, Shedskin&lt;/strong&gt;: 이들은 Python용 정적 컴파일러입니다. 런타임 데이터에 기반한 JIT 컴파일러가 고려하는 전체 코드 범위에 대해 최적화할 수 없다는 한계가 있었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IronPython&lt;/strong&gt;: Microsoft의 .Net 플랫폼용 Python이며, 사실상 Windows 전용이어서 일반적인 CPython 대체제로 부적합했습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Jython&lt;/strong&gt;: Python 2.5의 완전한 구현이지만, Unladen Swallow보다 훨씬 느리고 CPython 확장 모듈을 지원하지 않아 대규모 애플리케이션 마이그레이션 비용이 너무 높았습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Psyco&lt;/strong&gt;: CPython용 특수화 JIT 컴파일러였지만, 32비트 전용이고 x86만 지원하며 유지보수가 매우 어려웠습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PyPy&lt;/strong&gt;: 숫자 코드에서는 좋은 성능을 보였지만, 일부 워크로드에서는 Unladen Swallow보다 느렸습니다. PyPy의 JIT 컴파일러는 32비트 x86 코드 생성만 지원하고, 중요한 모듈이 PyPy에 대해 빌드되지 않으며, CPython과 동일한 임베딩 API를 제공하지 않는 등의 문제가 있었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PyV8&lt;/strong&gt;: V8 위에서 실행되는 실험적인 Python-to-JavaScript 컴파일러로, 전체 Python 언어를 구현하지 않았고 CPython 확장 모듈을 지원하지 않았습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;WPython&lt;/strong&gt;: CPython 인터프리터 루프의 워드코드 기반 재구현으로, 인터프리터 성능에 미미한 개선을 제공했지만 JIT 컴파일러의 대안은 아니었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;성능-performance&quot;&gt;성능 (Performance)&lt;/h3&gt;

&lt;p&gt;Unladen Swallow는 합성 마이크로벤치마크부터 전체 애플리케이션 매크로벤치마크에 이르는 상당히 큰 벤치마크 스위트를 개발했습니다. 이 벤치마크들은 타사 기여자, Google의 내부 워크로드, 그리고 광범위한 Python 커뮤니티에서 널리 사용되는 도구 및 라이브러리(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2to3&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spambayes&lt;/code&gt;)에서 영감을 받았습니다.&lt;/p&gt;

&lt;h4 id=&quot;cpython-264-대비-성능&quot;&gt;CPython 2.6.4 대비 성능&lt;/h4&gt;

&lt;p&gt;벤치마크 결과는 Unladen Swallow가 CPython 2.6.4 대비 다양한 성능 향상을 보였음을 나타냅니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django&lt;/code&gt; 벤치마크는 32비트 환경에서 1.35배 빨라졌고, 64비트 환경에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nbody&lt;/code&gt; 벤치마크가 2.86배 빨라졌습니다. 그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spambayes&lt;/code&gt;와 같은 일부 벤치마크에서는 Unladen Swallow가 더 느리거나 성능 변화가 미미했습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 Python 함수를 머신 코드로 컴파일하기 위해 실행을 블록(block)하여 일부 벤치마크에서 성능 저하가 발생했습니다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;html5lib&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rietveld&lt;/code&gt; 벤치마크의 타임라인 그래프에서 볼 수 있으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2to3&lt;/code&gt;의 전반적인 성능을 저하시켰습니다. 팀은 이 문제를 해결하기 위한 개발 브랜치를 운영했지만, CPython의 현재 스레딩 시스템의 제약으로 인해 예상보다 많은 시간과 노력이 필요했습니다. 이 문제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k&lt;/code&gt; 브랜치로 최종 병합하는 데 있어 중요한 문제로 간주되었습니다.&lt;/p&gt;

&lt;p&gt;초기 목표였던 5배 성능 향상은 달성하지 못했습니다. 이는 LLVM 작업에 예상보다 많은 노력이 필요했고, LLVM의 JIT 인프라에 존재하는 여러 치명적인 버그를 수정하는 데 시간을 할애했기 때문입니다.&lt;/p&gt;

&lt;h4 id=&quot;메모리-사용량-memory-usage&quot;&gt;메모리 사용량 (Memory Usage)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow는 CPython 2.6.4 대비 메모리 사용량이 증가했습니다. 예를 들어, 32비트 환경에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2to3&lt;/code&gt;는 1.77배, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django&lt;/code&gt;는 2.76배, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spambayes&lt;/code&gt;는 6.32배 더 많은 메모리를 사용했습니다. 64비트 환경에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spambayes&lt;/code&gt;가 7.92배 더 많은 메모리를 사용했습니다.&lt;/p&gt;

&lt;p&gt;이러한 메모리 사용량 증가는 LLVM 코드 생성, 분석 및 최적화 라이브러리, 네이티브 코드, LLVM의 메모리 사용량 문제 또는 누수, 머신 코드 최적화 및 생성을 위한 데이터 구조 등 여러 원인에서 비롯되었습니다. 메모리 사용량 감소는 최종 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k&lt;/code&gt; 브랜치 병합을 위한 중요한 문제로 간주되었습니다.&lt;/p&gt;

&lt;h4 id=&quot;시작-시간-start-up-time&quot;&gt;시작 시간 (Start-up Time)&lt;/h4&gt;

&lt;p&gt;LLVM의 코드 생성, 분석 및 최적화 라이브러리를 정적으로 링크(statically linking)하면서 Python 바이너리의 시작 시간이 증가했습니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;normal_startup&lt;/code&gt; 벤치마크에서 CPython 대비 1.6배 느려졌고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startup_nosite&lt;/code&gt; 벤치마크에서는 2.5배 느려졌습니다. 시작 시간 개선은 Unladen Swallow의 병합 우선순위 목록에서 높은 순위를 차지했습니다.&lt;/p&gt;

&lt;h4 id=&quot;바이너리-크기-binary-size&quot;&gt;바이너리 크기 (Binary Size)&lt;/h4&gt;

&lt;p&gt;LLVM 라이브러리를 정적으로 링크함으로써 Python 바이너리의 크기가 크게 증가했습니다. CPython 2.6.4와 3.1.1이 각각 1.3MB 및 1.4MB (32비트)였던 것에 비해, Unladen Swallow r1041은 12MB (32비트 및 64비트)로 증가했습니다. 이는 LLVM의 코드 생성, 분석 및 최적화 라이브러리를 정적으로 링크하기 때문이며, LLVM이 공유 라이브러리(shared linking)를 더 잘 지원하도록 수정하면 해결될 수 있는 문제로 보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;정확성-및-호환성-correctness-and-compatibility&quot;&gt;정확성 및 호환성 (Correctness and Compatibility)&lt;/h3&gt;

&lt;p&gt;Unladen Swallow의 정확성 테스트 스위트에는 CPython의 자체 테스트 스위트(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lib/test/&lt;/code&gt;)뿐만 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Django&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NumPy&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQLAlchemy&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Twisted&lt;/code&gt; 등 여러 중요한 타사 애플리케이션 및 라이브러리가 포함되었습니다. 이러한 애플리케이션들은 Unladen Swallow에서 실행될 때 모든 관련 테스트를 통과했습니다. 또한, Google의 내부 Python 라이브러리 및 애플리케이션에 대해서도 자동 테스트가 수행되었습니다.&lt;/p&gt;

&lt;h4 id=&quot;알려진-비호환성-known-incompatibilities&quot;&gt;알려진 비호환성 (Known Incompatibilities)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow와 호환되지 않는 것으로 알려진 유일한 애플리케이션은 Psyco였습니다. PyGame과 같은 일부 라이브러리는 CPython 2.6.4에서 잘 작동했지만, Unladen Swallow의 변경 사항으로 인해 일부 성능 저하가 발생했습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 CPython 2.6.4와 소스 호환성을 가졌지만, 바이너리 호환성은 없었습니다. 한쪽에 대해 컴파일된 C 확장 모듈은 다른 쪽과 작동하려면 재컴파일이 필요했습니다.&lt;/p&gt;

&lt;h3 id=&quot;플랫폼-지원-platform-support&quot;&gt;플랫폼 지원 (Platform Support)&lt;/h3&gt;

&lt;p&gt;Unladen Swallow는 LLVM의 JIT 컴파일 시스템이 제공하는 플랫폼 지원에 의해 본질적으로 제한되었습니다. LLVM의 JIT는 x86 및 x86-64 시스템에서 가장 잘 지원되며, Unladen Swallow도 이들 플랫폼에서 가장 많은 테스트를 받았습니다. PPC 및 ARM 지원도 존재했지만, 널리 사용되지 않고 버그가 있을 수 있었습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 Linux, Darwin, Windows 운영 체제에서 작동하는 것으로 알려져 있었습니다. LLVM의 JIT가 작동하지 않는 하드웨어 및 소프트웨어 플랫폼을 지원하기 위해, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--without-llvm&lt;/code&gt; 옵션을 제공했습니다. 이 플래그는 LLVM에 의존하는 Unladen Swallow의 모든 부분을 제거하여, 성능 이점은 없지만 작동하고 테스트를 통과하는 Python 바이너리를 생성했습니다.&lt;/p&gt;

&lt;h3 id=&quot;cpython-개발에-미치는-영향-impact-on-cpython-development&quot;&gt;CPython 개발에 미치는 영향 (Impact on CPython Development)&lt;/h3&gt;

&lt;h4 id=&quot;python-또는-cpython-바이트코드-변경-실험-experimenting-with-changes-to-python-or-cpython-bytecode&quot;&gt;Python 또는 CPython 바이트코드 변경 실험 (Experimenting with Changes to Python or CPython Bytecode)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow의 JIT 컴파일러는 CPython 바이트코드에서 작동하므로, 파서(parser)에만 영향을 미치는 Python 언어 변경에는 영향을 받지 않았습니다. CPython 바이트코드 컴파일러 또는 개별 바이트코드의 의미 변경은 먼저 인터프리터 루프에서 프로토타입을 만들고, 의미가 명확해지면 JIT 컴파일러로 포팅하는 것을 권장했습니다.&lt;/p&gt;

&lt;h4 id=&quot;디버깅-debugging&quot;&gt;디버깅 (Debugging)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow 팀은 JIT 컴파일된 Python 코드를 gdb로 더 쉽게 디버깅할 수 있도록 gdb에 변경 사항을 구현했습니다. 이 변경 사항은 gdb 7.0에서 릴리스되었으며, gdb가 JIT 생성 호출 스택 프레임을 식별하고 되감을 수 있게 했습니다.&lt;/p&gt;

&lt;h4 id=&quot;프로파일링-profiling&quot;&gt;프로파일링 (Profiling)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow는 Linux 시스템에서 어셈블리 수준 프로파일링을 지원하기 위해 oProfile 0.9.4 이상과 통합되었습니다. 이는 oProfile이 보고서에서 JIT 컴파일된 함수를 올바르게 심볼화(symbolize)할 수 있음을 의미했습니다.&lt;/p&gt;

&lt;h4 id=&quot;cpython에-c-추가-addition-of-c-to-cpython&quot;&gt;CPython에 C++ 추가 (Addition of C++ to CPython)&lt;/h4&gt;

&lt;p&gt;LLVM을 사용하기 위해 Unladen Swallow는 핵심 CPython 트리 및 빌드 프로세스에 C++를 도입했습니다. 이는 LLVM에 의존하는 피할 수 없는 부분이며, LLVM은 C API를 제공하지만 CPython에 필요한 기능을 모두 노출하지 않았습니다. 이로 인해 Unladen Swallow JIT의 내부 구현과 지원 인프라는 C++로 구현되었습니다. 전체 CPython 코드베이스를 C++로 변환할 것을 제안하지는 않았습니다.&lt;/p&gt;

&lt;h4 id=&quot;llvm-릴리스-c-api-변경-관리-managing-llvm-releases-c-api-changes&quot;&gt;LLVM 릴리스, C++ API 변경 관리 (Managing LLVM Releases, C++ API Changes)&lt;/h4&gt;

&lt;p&gt;LLVM은 6개월마다 정기적으로 릴리스되었으며, 이는 CPython 3.x 릴리스 개발 과정에서 LLVM이 두세 번 릴리스될 수 있음을 의미했습니다. 각 LLVM 릴리스는 더 새롭고 강력한 최적화, 향상된 플랫폼 지원 및 더 정교한 코드 생성을 가져왔습니다. 일반적으로 LLVM 릴리스에는 LLVM C++ API에 대한 비호환적인 변경 사항이 포함되었습니다.&lt;/p&gt;

&lt;p&gt;LLVM 기반 CPython은 한 번에 단일 LLVM 버전과의 호환성을 목표로 하는 것이 오버헤드를 줄이는 데 도움이 될 것이라고 권장되었습니다.&lt;/p&gt;

&lt;h4 id=&quot;cpython-빌드-building-cpython&quot;&gt;CPython 빌드 (Building CPython)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow는 LLVM에 대한 런타임 종속성 외에도, LLVM 기반 C/C++ 컴파일러인 Clang에 대한 빌드 시간 종속성을 포함했습니다. 이는 C 언어 Python 런타임의 일부를 LLVM의 중간 표현(Intermediate Representation, IR)으로 컴파일하는 데 사용되어, 교차 언어 인라이닝(cross-language inlining)을 가능하게 하고 성능을 향상시켰습니다.&lt;/p&gt;

&lt;p&gt;전체 빌드는 LLVM 상호 작용에 필요한 추가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.cc&lt;/code&gt; 파일, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libpython&lt;/code&gt;에 LLVM을 정적으로 링크하는 것, 교차 언어 인라이닝을 가능하게 하기 위해 Python 런타임의 일부를 LLVM IR로 컴파일하는 것 등으로 인해 더 많은 시간이 소요되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;제안된-병합-계획-proposed-merge-plan&quot;&gt;제안된 병합 계획 (Proposed Merge Plan)&lt;/h3&gt;

&lt;p&gt;Unladen Swallow 팀은 CPython의 3.x 개발 라인과의 병합에 노력을 집중할 것을 제안했습니다. Python 3가 미래이며, 성능 향상 노력의 목표가 될 것이라고 언급했습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow를 CPython 소스 트리로 병합하기 위한 계획은 다음과 같았습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CPython SVN 저장소에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k-jit&lt;/code&gt; 브랜치 생성.&lt;/li&gt;
  &lt;li&gt;이 브랜치를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k&lt;/code&gt; 브랜치와 긴밀하게 통합 유지.&lt;/li&gt;
  &lt;li&gt;JIT 관련 패치는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k-jit&lt;/code&gt; 브랜치로, JIT 비관련 패치는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k&lt;/code&gt; 브랜치로 커밋.&lt;/li&gt;
  &lt;li&gt;논란의 여지가 있는 문제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-dev&lt;/code&gt;에서 논의.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unladen Swallow는 CPython 2.6을 기반으로 했으므로, 컴파일러를 Python 3로 포팅해야 했습니다.&lt;/p&gt;

&lt;h3 id=&quot;비상-계획-contingency-plans&quot;&gt;비상 계획 (Contingency Plans)&lt;/h3&gt;

&lt;p&gt;메모리 사용량이나 시작 시간을 CPython 커뮤니티가 만족하는 수준으로 줄이지 못할 경우, 주요 비상 계획은 온라인 JIT 컴파일 전략에서 계측된 CPython 인터프리터 루프를 사용하여 피드백을 얻는 오프라인 AOT(Ahead-Of-Time) 전략으로 전환하는 것이었습니다. 이를 “피드백 지향 최적화(feedback-directed optimization, FDO)”라고 지칭했습니다. FDO 컴파일러는 JIT 컴파일러보다 성능이 떨어질 것으로 예상되었지만, Unladen Swallow JIT 컴파일러를 위해 개발된 코드와 인프라의 많은 부분을 재활용할 수 있을 것이라고 보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;향후-작업-future-work&quot;&gt;향후 작업 (Future Work)&lt;/h3&gt;

&lt;p&gt;JIT 컴파일러는 매우 유연한 도구이며, 그 잠재력을 완전히 발휘하지 못했다고 보았습니다. 아직 구현되지 않은 성능 최적화 목록은 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Python/Python 인라이닝 (inlining)&lt;/strong&gt;: 현재 컴파일러는 순수 Python 함수 간에 인라이닝을 수행하지 않았습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;언박싱 (Unboxing)&lt;/strong&gt;: 숫자 성능에 매우 중요합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;재컴파일, 적응 (Recompilation, adaptation)&lt;/strong&gt;: Unladen Swallow는 현재 Python 함수를 한 번만 컴파일하며, 사용 패턴이 변경되면 재컴파일의 한계가 있었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;정규 표현식 JIT 컴파일 (JIT-compile regular expressions)&lt;/strong&gt;: 최신 JavaScript 엔진은 JIT 컴파일 인프라를 재사용하여 정규 표현식 성능을 향상시켰습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;트레이스 컴파일 (Trace compilation)&lt;/strong&gt;: PyPy 및 Tracemonkey의 결과에 따라, CPython JIT는 어느 정도 트레이스 컴파일을 통합해야 한다고 믿었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로파일 생성/재사용 (Profile generation/reuse)&lt;/strong&gt;: JIT가 수집한 런타임 데이터를 디스크에 저장하고 후속 JIT 컴파일 또는 Cython과 같은 외부 도구에서 재사용할 수 있었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;—PEP 3146, “Unladen Swallow를 CPython으로 통합하기”는 Unladen Swallow 프로젝트를 CPython 소스 트리에 통합하자는 제안이었습니다. Unladen Swallow 프로젝트는 성능 향상에 초점을 맞춘 CPython의 오픈 소스 브랜치였습니다. 이 PEP는 결국 철회되었습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;pep-3146--unladen-swallow를-cpython으로-통합하기-철회됨&quot;&gt;PEP 3146 – Unladen Swallow를 CPython으로 통합하기 (철회됨)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;작성자:&lt;/strong&gt; Collin Winter, Jeffrey Yasskin, Reid Kleckner
&lt;strong&gt;상태:&lt;/strong&gt; 철회됨 (Withdrawn)
&lt;strong&gt;유형:&lt;/strong&gt; 표준 트랙 (Standards Track)
&lt;strong&gt;생성일:&lt;/strong&gt; 2010년 1월 1일
&lt;strong&gt;Python 버전:&lt;/strong&gt; 3.3&lt;/p&gt;

&lt;h3 id=&quot;pep-철회-1&quot;&gt;PEP 철회&lt;/h3&gt;

&lt;p&gt;Unladen Swallow 프로젝트가 중단되었기 때문에, 이 PEP는 철회된 것으로 간주됩니다.&lt;/p&gt;

&lt;h3 id=&quot;개요-abstract-1&quot;&gt;개요 (Abstract)&lt;/h3&gt;

&lt;p&gt;이 PEP는 성능 향상에 중점을 둔 CPython의 오픈 소스 브랜치인 Unladen Swallow 프로젝트를 CPython의 소스 트리로 통합할 것을 제안했습니다. Unladen Swallow는 유효한 Python 2.6.4 애플리케이션 및 C 확장 모듈과 소스 호환이 가능했습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 CPython에 Just-In-Time (JIT) 컴파일러를 추가하여, 선택된 Python 코드를 최적화된 머신 코드로 컴파일할 수 있도록 했습니다. 고전적인 정적 컴파일러 최적화를 넘어, Unladen Swallow의 JIT 컴파일러는 런타임에 수집된 데이터를 활용하여 코드 동작에 대한 검증된 가정을 세우고, 더 빠른 머신 코드를 생성할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;이 PEP는 Unladen Swallow를 CPython 개발 트리의 별도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k-jit&lt;/code&gt; 브랜치에 통합한 후, 궁극적으로 메인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k&lt;/code&gt; 브랜치와 병합하는 것을 목표로 했습니다. Unladen Swallow는 완성되거나 완벽하지는 않았지만, CPython 로드맵에 통합될 만큼 충분한 성숙도에 도달했다고 판단되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;제안-배경-및-구현-rationale-implementation-1&quot;&gt;제안 배경 및 구현 (Rationale, Implementation)&lt;/h3&gt;

&lt;p&gt;많은 기업과 개인은 Python이 더 빨라져서 더 많은 프로젝트에 활용되기를 원했습니다. Google도 그러한 회사 중 하나였습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 Google의 수많은 Python 라이브러리, 도구 및 애플리케이션의 성능을 향상시키기 위해 시작된 Google 후원의 CPython 브랜치였습니다. Unladen Swallow의 채택을 최대한 쉽게 만들기 위해, 프로젝트는 처음에는 네 가지 목표를 설정했습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;단일 스레드 코드에서 CPython 2.6.4 기준 대비 5배 성능 향상.&lt;/li&gt;
  &lt;li&gt;유효한 CPython 2.6 애플리케이션과 100% 소스 호환성.&lt;/li&gt;
  &lt;li&gt;유효한 CPython 2.6 C 확장 모듈과 100% 소스 호환성.&lt;/li&gt;
  &lt;li&gt;궁극적으로 CPython으로 다시 병합되도록 설계.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unladen Swallow는 런타임에 피드백을 수집하고 이를 컴파일 시간 최적화에 활용하는 Just-In-Time (JIT) 컴파일러를 구현했습니다. 이는 최신 JavaScript 엔진, 대부분의 Java 가상 머신, Rubinius, MacRuby 등에서 채택된 접근 방식과 유사합니다.&lt;/p&gt;

&lt;p&gt;핵심은 동적 언어가 이론적으로만 동적일 뿐, 실제로는 각 함수나 코드 조각이 상대적으로 정적이며 안정적인 유형 및 자식 함수 세트를 사용한다는 점입니다. CPython의 현재 바이트코드 인터프리터는 실행 중인 코드에 대해 최악의 경우를 가정합니다. Unladen Swallow는 사용자 코드의 이러한 상대적으로 정적인 특성을 활용하여 성능을 향상시켰습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow JIT 컴파일러는 함수의 CPython 바이트코드를 플랫폼별 머신 코드로 변환하며, 런타임에 수집된 데이터와 고전적인 컴파일러 최적화를 사용하여 생성된 머신 코드의 품질을 향상시켰습니다. 프로그램 실행에 실제로 도움이 되는 Python 코드만 컴파일하기 위해, 온라인 휴리스틱을 사용하여 특정 함수의 “핫니스(hotness)”를 평가했습니다. 함수의 핫니스 값이 특정 임계값을 넘으면 컴파일 및 최적화 대상으로 선택되었습니다. 함수가 핫하다고 판단되기 전까지는 표준 CPython &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval&lt;/code&gt; 루프에서 실행되었으며, 이 루프는 실행된 각 바이트코드에 대한 흥미로운 데이터를 기록하도록 계측되었습니다. 이 런타임 데이터는 생성된 머신 코드의 유연성을 줄여 일반적인 경우(common case)에 대해 최적화할 수 있게 했습니다. 예를 들어, 다음 데이터를 수집했습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;브랜치(branch)가 실행되었는지 여부.&lt;/li&gt;
  &lt;li&gt;연산자에 사용된 타입.&lt;/li&gt;
  &lt;li&gt;각 호출 지점(callsite)에서 호출된 함수.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;최적화 시 만들어진 가정이 더 이상 유효하지 않게 되면, 최적화된 머신 코드 실행을 중단하고 인터프리터로 돌아가 나머지 작업을 수행했습니다. 이를 위해 각 최적화된 머신 코드 섹션 앞에는 가드(guard)가 배치되었습니다.&lt;/p&gt;

&lt;p&gt;코드 생성 및 최적화를 위해 LLVM이라는 기존 컴파일러 라이브러리 세트를 재사용했습니다. 이는 소규모 팀이 여러 머신 명령어 세트에서 코드 생성을 이해하고 디버깅하며, 많은 수의 고전적인 컴파일러 최적화를 구현해야 하는 부담을 덜어주었습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 단일 스레드, 순수 Python 코드의 성능 향상에 중점을 두었습니다. CPython의 Global Interpreter Lock (GIL)을 제거하려는 노력은 하지 않았습니다. 이는 Unladen Swallow의 작업과 별개이며, 민감한 문제이므로 메인라인 개발 브랜치에서 수행하는 것이 가장 좋다고 판단했습니다.&lt;/p&gt;

&lt;h3 id=&quot;대안-alternatives-1&quot;&gt;대안 (Alternatives)&lt;/h3&gt;

&lt;p&gt;Unladen Swallow 팀은 Python 성능 향상을 위한 여러 대안 전략을 고려했지만, 불만족스럽다고 판단했습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Cython, Shedskin&lt;/strong&gt;: 이들은 Python용 정적 컴파일러입니다. 런타임 데이터에 기반한 JIT 컴파일러가 고려하는 전체 코드 범위에 대해 최적화할 수 없다는 한계가 있었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IronPython&lt;/strong&gt;: Microsoft의 .Net 플랫폼용 Python이며, 사실상 Windows 전용이어서 일반적인 CPython 대체제로 부적합했습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Jython&lt;/strong&gt;: Python 2.5의 완전한 구현이지만, Unladen Swallow보다 훨씬 느리고 CPython 확장 모듈을 지원하지 않아 대규모 애플리케이션 마이그레이션 비용이 너무 높았습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Psyco&lt;/strong&gt;: CPython용 특수화 JIT 컴파일러였지만, 32비트 전용이고 x86만 지원하며 유지보수가 매우 어려웠습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PyPy&lt;/strong&gt;: 숫자 코드에서는 좋은 성능을 보였지만, 일부 워크로드에서는 Unladen Swallow보다 느렸습니다. PyPy의 JIT 컴파일러는 32비트 x86 코드 생성만 지원하고, 중요한 모듈이 PyPy에 대해 빌드되지 않으며, CPython과 동일한 임베딩 API를 제공하지 않는 등의 문제가 있었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PyV8&lt;/strong&gt;: V8 위에서 실행되는 실험적인 Python-to-JavaScript 컴파일러로, 전체 Python 언어를 구현하지 않았고 CPython 확장 모듈을 지원하지 않았습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;WPython&lt;/strong&gt;: CPython 인터프리터 루프의 워드코드 기반 재구현으로, 인터프리터 성능에 미미한 개선을 제공했지만 JIT 컴파일러의 대안은 아니었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;성능-performance-1&quot;&gt;성능 (Performance)&lt;/h3&gt;

&lt;p&gt;Unladen Swallow는 합성 마이크로벤치마크부터 전체 애플리케이션 매크로벤치마크에 이르는 상당히 큰 벤치마크 스위트를 개발했습니다. 이 벤치마크들은 타사 기여자, Google의 내부 워크로드, 그리고 광범위한 Python 커뮤니티에서 널리 사용되는 도구 및 라이브러리(예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2to3&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spambayes&lt;/code&gt;)에서 영감을 받았습니다.&lt;/p&gt;

&lt;h4 id=&quot;cpython-264-대비-성능-1&quot;&gt;CPython 2.6.4 대비 성능&lt;/h4&gt;

&lt;p&gt;벤치마크 결과는 Unladen Swallow가 CPython 2.6.4 대비 다양한 성능 향상을 보였음을 나타냅니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django&lt;/code&gt; 벤치마크는 32비트 환경에서 1.35배 빨라졌고, 64비트 환경에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nbody&lt;/code&gt; 벤치마크가 2.86배 빨라졌습니다. 그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spambayes&lt;/code&gt;와 같은 일부 벤치마크에서는 Unladen Swallow가 더 느리거나 성능 변화가 미미했습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 Python 함수를 머신 코드로 컴파일하기 위해 실행을 블록(block)하여 일부 벤치마크에서 성능 저하가 발생했습니다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;html5lib&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rietveld&lt;/code&gt; 벤치마크의 타임라인 그래프에서 볼 수 있으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2to3&lt;/code&gt;의 전반적인 성능을 저하시켰습니다. 팀은 이 문제를 해결하기 위한 개발 브랜치를 운영했지만, CPython의 현재 스레딩 시스템의 제약으로 인해 예상보다 많은 시간과 노력이 필요했습니다. 이 문제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k&lt;/code&gt; 브랜치로 최종 병합하는 데 있어 중요한 문제로 간주되었습니다.&lt;/p&gt;

&lt;p&gt;초기 목표였던 5배 성능 향상은 달성하지 못했습니다. 이는 LLVM 작업에 예상보다 많은 노력이 필요했고, LLVM의 JIT 인프라에 존재하는 여러 치명적인 버그를 수정하는 데 시간을 할애했기 때문입니다.&lt;/p&gt;

&lt;h4 id=&quot;메모리-사용량-memory-usage-1&quot;&gt;메모리 사용량 (Memory Usage)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow는 CPython 2.6.4 대비 메모리 사용량이 증가했습니다. 예를 들어, 32비트 환경에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2to3&lt;/code&gt;는 1.77배, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django&lt;/code&gt;는 2.76배, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spambayes&lt;/code&gt;는 6.32배 더 많은 메모리를 사용했습니다. 64비트 환경에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spambayes&lt;/code&gt;가 7.92배 더 많은 메모리를 사용했습니다.&lt;/p&gt;

&lt;p&gt;이러한 메모리 사용량 증가는 LLVM 코드 생성, 분석 및 최적화 라이브러리, 네이티브 코드, LLVM의 메모리 사용량 문제 또는 누수, 머신 코드 최적화 및 생성을 위한 데이터 구조 등 여러 원인에서 비롯되었습니다. 메모리 사용량 감소는 최종 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k&lt;/code&gt; 브랜치 병합을 위한 중요한 문제로 간주되었습니다.&lt;/p&gt;

&lt;h4 id=&quot;시작-시간-start-up-time-1&quot;&gt;시작 시간 (Start-up Time)&lt;/h4&gt;

&lt;p&gt;LLVM의 코드 생성, 분석 및 최적화 라이브러리를 정적으로 링크(statically linking)하면서 Python 바이너리의 시작 시간이 증가했습니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;normal_startup&lt;/code&gt; 벤치마크에서 CPython 대비 1.6배 느려졌고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startup_nosite&lt;/code&gt; 벤치마크에서는 2.5배 느려졌습니다. 시작 시간 개선은 Unladen Swallow의 병합 우선순위 목록에서 높은 순위를 차지했습니다.&lt;/p&gt;

&lt;h4 id=&quot;바이너리-크기-binary-size-1&quot;&gt;바이너리 크기 (Binary Size)&lt;/h4&gt;

&lt;p&gt;LLVM 라이브러리를 정적으로 링크함으로써 Python 바이너리의 크기가 크게 증가했습니다. CPython 2.6.4와 3.1.1이 각각 1.3MB 및 1.4MB (32비트)였던 것에 비해, Unladen Swallow r1041은 12MB (32비트 및 64비트)로 증가했습니다. 이는 LLVM의 코드 생성, 분석 및 최적화 라이브러리를 정적으로 링크하기 때문이며, LLVM이 공유 라이브러리(shared linking)를 더 잘 지원하도록 수정하면 해결될 수 있는 문제로 보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;정확성-및-호환성-correctness-and-compatibility-1&quot;&gt;정확성 및 호환성 (Correctness and Compatibility)&lt;/h3&gt;

&lt;p&gt;Unladen Swallow의 정확성 테스트 스위트에는 CPython의 자체 테스트 스위트(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lib/test/&lt;/code&gt;)뿐만 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Django&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NumPy&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQLAlchemy&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Twisted&lt;/code&gt; 등 여러 중요한 타사 애플리케이션 및 라이브러리가 포함되었습니다. 이러한 애플리케이션들은 Unladen Swallow에서 실행될 때 모든 관련 테스트를 통과했습니다. 또한, Google의 내부 Python 라이브러리 및 애플리케이션에 대해서도 자동 테스트가 수행되었습니다.&lt;/p&gt;

&lt;h4 id=&quot;알려진-비호환성-known-incompatibilities-1&quot;&gt;알려진 비호환성 (Known Incompatibilities)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow와 호환되지 않는 것으로 알려진 유일한 애플리케이션은 Psyco였습니다. PyGame과 같은 일부 라이브러리는 CPython 2.6.4에서 잘 작동했지만, Unladen Swallow의 변경 사항으로 인해 일부 성능 저하가 발생했습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 CPython 2.6.4와 소스 호환성을 가졌지만, 바이너리 호환성은 없었습니다. 한쪽에 대해 컴파일된 C 확장 모듈은 다른 쪽과 작동하려면 재컴파일이 필요했습니다.&lt;/p&gt;

&lt;h3 id=&quot;플랫폼-지원-platform-support-1&quot;&gt;플랫폼 지원 (Platform Support)&lt;/h3&gt;

&lt;p&gt;Unladen Swallow는 LLVM의 JIT 컴파일 시스템이 제공하는 플랫폼 지원에 의해 본질적으로 제한되었습니다. LLVM의 JIT는 x86 및 x86-64 시스템에서 가장 잘 지원되며, Unladen Swallow도 이들 플랫폼에서 가장 많은 테스트를 받았습니다. PPC 및 ARM 지원도 존재했지만, 널리 사용되지 않고 버그가 있을 수 있었습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow는 Linux, Darwin, Windows 운영 체제에서 작동하는 것으로 알려져 있었습니다. LLVM의 JIT가 작동하지 않는 하드웨어 및 소프트웨어 플랫폼을 지원하기 위해, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--without-llvm&lt;/code&gt; 옵션을 제공했습니다. 이 플래그는 LLVM에 의존하는 Unladen Swallow의 모든 부분을 제거하여, 성능 이점은 없지만 작동하고 테스트를 통과하는 Python 바이너리를 생성했습니다.&lt;/p&gt;

&lt;h3 id=&quot;cpython-개발에-미치는-영향-impact-on-cpython-development-1&quot;&gt;CPython 개발에 미치는 영향 (Impact on CPython Development)&lt;/h3&gt;

&lt;h4 id=&quot;python-또는-cpython-바이트코드-변경-실험-experimenting-with-changes-to-python-or-cpython-bytecode-1&quot;&gt;Python 또는 CPython 바이트코드 변경 실험 (Experimenting with Changes to Python or CPython Bytecode)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow의 JIT 컴파일러는 CPython 바이트코드에서 작동하므로, 파서(parser)에만 영향을 미치는 Python 언어 변경에는 영향을 받지 않았습니다. CPython 바이트코드 컴파일러 또는 개별 바이트코드의 의미 변경은 먼저 인터프리터 루프에서 프로토타입을 만들고, 의미가 명확해지면 JIT 컴파일러로 포팅하는 것을 권장했습니다.&lt;/p&gt;

&lt;h4 id=&quot;디버깅-debugging-1&quot;&gt;디버깅 (Debugging)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow 팀은 JIT 컴파일된 Python 코드를 gdb로 더 쉽게 디버깅할 수 있도록 gdb에 변경 사항을 구현했습니다. 이 변경 사항은 gdb 7.0에서 릴리스되었으며, gdb가 JIT 생성 호출 스택 프레임을 식별하고 되감을 수 있게 했습니다.&lt;/p&gt;

&lt;h4 id=&quot;프로파일링-profiling-1&quot;&gt;프로파일링 (Profiling)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow는 Linux 시스템에서 어셈블리 수준 프로파일링을 지원하기 위해 oProfile 0.9.4 이상과 통합되었습니다. 이는 oProfile이 보고서에서 JIT 컴파일된 함수를 올바르게 심볼화(symbolize)할 수 있음을 의미했습니다.&lt;/p&gt;

&lt;h4 id=&quot;cpython에-c-추가-addition-of-c-to-cpython-1&quot;&gt;CPython에 C++ 추가 (Addition of C++ to CPython)&lt;/h4&gt;

&lt;p&gt;LLVM을 사용하기 위해 Unladen Swallow는 핵심 CPython 트리 및 빌드 프로세스에 C++를 도입했습니다. 이는 LLVM에 의존하는 피할 수 없는 부분이며, LLVM은 C API를 제공하지만 CPython에 필요한 기능을 모두 노출하지 않았습니다. 이로 인해 Unladen Swallow JIT의 내부 구현과 지원 인프라는 C++로 구현되었습니다. 전체 CPython 코드베이스를 C++로 변환할 것을 제안하지는 않았습니다.&lt;/p&gt;

&lt;h4 id=&quot;llvm-릴리스-c-api-변경-관리-managing-llvm-releases-c-api-changes-1&quot;&gt;LLVM 릴리스, C++ API 변경 관리 (Managing LLVM Releases, C++ API Changes)&lt;/h4&gt;

&lt;p&gt;LLVM은 6개월마다 정기적으로 릴리스되었으며, 이는 CPython 3.x 릴리스 개발 과정에서 LLVM이 두세 번 릴리스될 수 있음을 의미했습니다. 각 LLVM 릴리스는 더 새롭고 강력한 최적화, 향상된 플랫폼 지원 및 더 정교한 코드 생성을 가져왔습니다. 일반적으로 LLVM 릴리스에는 LLVM C++ API에 대한 비호환적인 변경 사항이 포함되었습니다.&lt;/p&gt;

&lt;p&gt;LLVM 기반 CPython은 한 번에 단일 LLVM 버전과의 호환성을 목표로 하는 것이 오버헤드를 줄이는 데 도움이 될 것이라고 권장되었습니다.&lt;/p&gt;

&lt;h4 id=&quot;cpython-빌드-building-cpython-1&quot;&gt;CPython 빌드 (Building CPython)&lt;/h4&gt;

&lt;p&gt;Unladen Swallow는 LLVM에 대한 런타임 종속성 외에도, LLVM 기반 C/C++ 컴파일러인 Clang에 대한 빌드 시간 종속성을 포함했습니다. 이는 C 언어 Python 런타임의 일부를 LLVM의 중간 표현(Intermediate Representation, IR)으로 컴파일하는 데 사용되어, 교차 언어 인라이닝(cross-language inlining)을 가능하게 하고 성능을 향상시켰습니다.&lt;/p&gt;

&lt;p&gt;전체 빌드는 LLVM 상호 작용에 필요한 추가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.cc&lt;/code&gt; 파일, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libpython&lt;/code&gt;에 LLVM을 정적으로 링크하는 것, 교차 언어 인라이닝을 가능하게 하기 위해 Python 런타임의 일부를 LLVM IR로 컴파일하는 것 등으로 인해 더 많은 시간이 소요되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;제안된-병합-계획-proposed-merge-plan-1&quot;&gt;제안된 병합 계획 (Proposed Merge Plan)&lt;/h3&gt;

&lt;p&gt;Unladen Swallow 팀은 CPython의 3.x 개발 라인과의 병합에 노력을 집중할 것을 제안했습니다. Python 3가 미래이며, 성능 향상 노력의 목표가 될 것이라고 언급했습니다.&lt;/p&gt;

&lt;p&gt;Unladen Swallow를 CPython 소스 트리로 병합하기 위한 계획은 다음과 같았습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CPython SVN 저장소에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k-jit&lt;/code&gt; 브랜치 생성.&lt;/li&gt;
  &lt;li&gt;이 브랜치를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k&lt;/code&gt; 브랜치와 긴밀하게 통합 유지.&lt;/li&gt;
  &lt;li&gt;JIT 관련 패치는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k-jit&lt;/code&gt; 브랜치로, JIT 비관련 패치는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;py3k&lt;/code&gt; 브랜치로 커밋.&lt;/li&gt;
  &lt;li&gt;논란의 여지가 있는 문제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python-dev&lt;/code&gt;에서 논의.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unladen Swallow는 CPython 2.6을 기반으로 했으므로, 컴파일러를 Python 3로 포팅해야 했습니다.&lt;/p&gt;

&lt;h3 id=&quot;비상-계획-contingency-plans-1&quot;&gt;비상 계획 (Contingency Plans)&lt;/h3&gt;

&lt;p&gt;메모리 사용량이나 시작 시간을 CPython 커뮤니티가 만족하는 수준으로 줄이지 못할 경우, 주요 비상 계획은 온라인 JIT 컴파일 전략에서 계측된 CPython 인터프리터 루프를 사용하여 피드백을 얻는 오프라인 AOT(Ahead-Of-Time) 전략으로 전환하는 것이었습니다. 이를 “피드백 지향 최적화(feedback-directed optimization, FDO)”라고 지칭했습니다. FDO 컴파일러는 JIT 컴파일러보다 성능이 떨어질 것으로 예상되었지만, Unladen Swallow JIT 컴파일러를 위해 개발된 코드와 인프라의 많은 부분을 재활용할 수 있을 것이라고 보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;향후-작업-future-work-1&quot;&gt;향후 작업 (Future Work)&lt;/h3&gt;

&lt;p&gt;JIT 컴파일러는 매우 유연한 도구이며, 그 잠재력을 완전히 발휘하지 못했다고 보았습니다. 아직 구현되지 않은 성능 최적화 목록은 다음과 같습니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Python/Python 인라이닝 (inlining)&lt;/strong&gt;: 현재 컴파일러는 순수 Python 함수 간에 인라이닝을 수행하지 않았습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;언박싱 (Unboxing)&lt;/strong&gt;: 숫자 성능에 매우 중요합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;재컴파일, 적응 (Recompilation, adaptation)&lt;/strong&gt;: Unladen Swallow는 현재 Python 함수를 한 번만 컴파일하며, 사용 패턴이 변경되면 재컴파일의 한계가 있었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;정규 표현식 JIT 컴파일 (JIT-compile regular expressions)&lt;/strong&gt;: 최신 JavaScript 엔진은 JIT 컴파일 인프라를 재사용하여 정규 표현식 성능을 향상시켰습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;트레이스 컴파일 (Trace compilation)&lt;/strong&gt;: PyPy 및 Tracemonkey의 결과에 따라, CPython JIT는 어느 정도 트레이스 컴파일을 통합해야 한다고 믿었습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;프로파일 생성/재사용 (Profile generation/reuse)&lt;/strong&gt;: JIT가 수집한 런타임 데이터를 디스크에 저장하고 후속 JIT 컴파일 또는 Cython과 같은 외부 도구에서 재사용할 수 있었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ &lt;strong&gt;알림:&lt;/strong&gt; 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 27 Sep 2025 14:38:28 +0900</pubDate>
        <link>http://localhost:4000/python/pep/3146/</link>
        <guid isPermaLink="true">http://localhost:4000/python/pep/3146/</guid>
        
        <category>Python</category>
        
        <category>PEP</category>
        
        <category>Translation</category>
        
        
        <category>Python</category>
        
        <category>PEP</category>
        
      </item>
    
  </channel>
</rss> 