<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-245c6e96a76a0f6c.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-e3ea38185bb36cd2.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1615<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 526 - Syntax for Variable Annotations</h1><div class="page__meta"><time dateTime="2025-09-26 23:19:02+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0526/">PEP 526 - Syntax for Variable Annotations</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 09-Aug-2016</p>
</blockquote>
<p><strong>PEP 526 – 변수 어노테이션 구문 (Syntax for Variable Annotations)</strong></p>
<h2>개요 (Abstract)</h2>
<p>PEP 484는 타입 힌트(type hints), 즉 타입 어노테이션(type annotations)을 도입했습니다. 주로 함수 어노테이션에 중점을 두었지만, 변수를 어노테이션하기 위한 타입 주석(type comments) 개념도 함께 소개했습니다.</p>
<p>예시:</p>
<pre><code class="language-python"># 'primes'는 정수 리스트입니다.
primes = [] # type: List[int]
# 'captain'은 문자열입니다. (참고: 초기값이 문제입니다)
captain = ... # type: str

class Starship:
    # 'stats'는 클래스 변수입니다.
    stats = {} # type: Dict[str, int]
</code></pre>
<p>이 PEP는 위와 같이 주석을 통해 변수의 타입(클래스 변수 및 인스턴스 변수 포함)을 표현하는 대신, 이를 위한 파이썬 구문을 추가하는 것을 목표로 합니다.</p>
<p>새로운 구문 예시:</p>
<pre><code class="language-python">primes: List[int] = []
captain: str # 참고: 초기값이 없습니다!

class Starship:
    stats: ClassVar[Dict[str, int]] = {}
</code></pre>
<p>PEP 484는 타입 주석이 복잡한 경우 타입 추론(type inference)에 도움이 되도록 의도되었다고 명시하며, 이 PEP는 이러한 의도를 변경하지 않습니다. 그러나 실제로는 타입 주석이 클래스 변수와 인스턴스 변수에도 채택되었으므로, 이 PEP는 이러한 변수에 대한 타입 어노테이션 사용법도 논의합니다.</p>
<h2>배경 (Rationale)</h2>
<p>타입 주석은 충분히 잘 작동하지만, 주석으로 표현된다는 점 때문에 몇 가지 단점이 있습니다.</p>
<ul>
<li>텍스트 편집기가 타입 어노테이션과 주석을 다르게 강조 표시하는 경우가 많습니다.</li>
<li>정의되지 않은 변수의 타입을 어노테이션할 방법이 없습니다. <code>a = None # type: int</code>와 같이 <code>None</code>으로 초기화해야 합니다.</li>
<li>조건부 분기(conditional branch)에서 어노테이션된 변수는 읽기 어렵습니다.
<pre><code class="language-python">if some_value:
    my_var = function() # type: Logger
else:
    my_var = another_function() # 여기에는 왜 타입이 없을까요?
</code></pre>
</li>
<li>타입 주석은 실제로 언어의 일부가 아니므로, 파이썬 스크립트가 이를 파싱하려면 <code>ast</code> 모듈 대신 사용자 정의 파서(custom parser)가 필요합니다.</li>
<li><code>typeshed</code>에서 타입 주석이 많이 사용됩니다. <code>typeshed</code>를 변수 어노테이션 구문을 사용하도록 마이그레이션하면 스텁 파일(stub files)의 가독성이 향상될 것입니다.</li>
<li>일반 주석과 타입 주석이 함께 사용되는 상황에서는 구별하기 어렵습니다.
<pre><code class="language-python">path = None # type: Optional[str] # 모듈 소스 경로
</code></pre>
</li>
<li>모듈의 소스 코드를 찾아서 런타임에 파싱하려는 시도 없이는 런타임에 어노테이션을 검색하는 것이 불가능하며, 이는 우아하지 않습니다.</li>
</ul>
<p>이러한 문제들의 대부분은 새로운 구문을 언어의 핵심 부분으로 만듦으로써 완화될 수 있습니다. 또한, 클래스 및 인스턴스 변수에 대한 전용 어노테이션 구문을 갖는 것은 PEP 484에 정의된 명목적 타이핑(nominal typing)을 보완하는 정적 덕 타이핑(static duck-typing)의 길을 열어줄 것입니다.</p>
<h3>비목표 (Non-goals)</h3>
<p>이 제안은 런타임에 어노테이션을 검색하기 위한 표준 라이브러리 함수 <code>typing.get_type_hints</code>의 확장을 동반하지만, 변수 어노테이션은 런타임 타입 검사(runtime type checking)를 위해 설계된 것이 아닙니다. 이러한 기능을 구현하려면 서드파티 패키지가 개발되어야 합니다.</p>
<p>또한 파이썬은 동적 타입 언어(dynamically typed language)로 남을 것이며, 저자들은 타입 힌트가 관례적으로라도 의무화되는 것을 원하지 않는다는 점을 강조해야 합니다. 타입 어노테이션은 정적 타입 언어(statically typed languages)의 변수 선언과 혼동되어서는 안 됩니다. 어노테이션 구문의 목표는 서드파티 도구를 위한 구조화된 타입 메타데이터를 지정하는 쉬운 방법을 제공하는 것입니다.</p>
<p>이 PEP는 타입 검사기가 타입 검사 규칙을 변경하도록 요구하지 않습니다. 단지 타입 주석을 대체할 더 읽기 쉬운 구문을 제공할 뿐입니다.</p>
<h2>사양 (Specification)</h2>
<p>타입 어노테이션은 할당문(assignment statement)이나 단일 표현식(single expression)에 추가될 수 있으며, 서드파티 타입 검사기에게 어노테이션 대상의 원하는 타입을 알려줍니다.</p>
<pre><code class="language-python">my_var: int
my_var = 5 # 타입 검사를 통과합니다.
other_var: int = 'a' # 타입 검사기에서 오류로 플래그됩니다.
                     # 하지만 런타임에는 문제 없습니다.
</code></pre>
<p>이 구문은 PEP 484를 넘어 새로운 의미론을 도입하지 않으므로, 다음 세 가지 문장은 동일합니다.</p>
<pre><code class="language-python">var = value # type: annotation
var: annotation; var = value
var: annotation = value
</code></pre>
<p>아래에서는 다양한 맥락에서의 타입 어노테이션 구문과 그 런타임 효과를 명시합니다. 또한 타입 검사기가 어노테이션을 어떻게 해석할 수 있는지 제안하지만, 이러한 제안에 대한 준수는 필수가 아닙니다 (이는 PEP 484의 준수에 대한 태도와 일치합니다).</p>
<h3>전역 및 지역 변수 어노테이션 (Global and local variable annotations)</h3>
<p>지역 변수(locals)와 전역 변수(globals)의 타입은 다음과 같이 어노테이션할 수 있습니다.</p>
<pre><code class="language-python">some_number: int # 초기값 없는 변수
some_list: List[int] = [] # 초기값 있는 변수
</code></pre>
<p>초기값을 생략할 수 있으므로, 조건부 분기에서 할당되는 변수의 타이핑이 더 쉬워집니다.</p>
<pre><code class="language-python">sane_world: bool
if 2+2 == 4:
    sane_world = True
else:
    sane_world = False
</code></pre>
<p>이 구문이 튜플 패킹(tuple packing)을 허용하지만, 튜플 언패킹(tuple unpacking)을 사용할 때는 변수의 타입을 어노테이션할 수 없다는 점에 유의하십시오.</p>
<pre><code class="language-python"># 변수 어노테이션 구문을 사용한 튜플 패킹
t: Tuple[int, ...] = (1, 2, 3)
# 또는
t: Tuple[int, ...] = 1, 2, 3 # Python 3.8 이상에서만 작동

# 변수 어노테이션 구문을 사용한 튜플 언패킹
header: str kind: int body: Optional[List[str]] # 이 구문은 유효하지 않습니다.
header, kind, body = message # 각 변수에 개별적으로 어노테이션해야 합니다.
</code></pre>
<p>초기값을 생략하면 변수가 초기화되지 않은 상태로 남습니다.</p>
<pre><code class="language-python">a: int
print(a) # NameError 발생
</code></pre>
<p>그러나 지역 변수를 어노테이션하면 인터프리터는 항상 이를 지역 변수로 만듭니다.</p>
<pre><code class="language-python">def f():
    a: int
    print(a) # UnboundLocalError 발생
    # 'a: int'를 주석 처리하면 NameError가 발생합니다.
</code></pre>
<p>이는 마치 코드가 다음과 같았던 것과 같습니다.</p>
<pre><code class="language-python">def f():
    if False:
        a = 0
    print(a) # UnboundLocalError 발생
</code></pre>
<p>중복된 타입 어노테이션은 무시됩니다. 그러나 정적 타입 검사기는 동일한 변수에 대해 다른 타입으로 어노테이션할 경우 경고를 발행할 수 있습니다.</p>
<pre><code class="language-python">a: int
a: str # 정적 타입 검사기가 이에 대해 경고할 수도 있고 안 할 수도 있습니다.
</code></pre>
<h3>클래스 및 인스턴스 변수 어노테이션 (Class and instance variable annotations)</h3>
<p>타입 어노테이션은 클래스 본문(class bodies) 및 메서드(methods) 내의 클래스 및 인스턴스 변수를 어노테이션하는 데에도 사용될 수 있습니다. 특히, 값이 없는 표기법 <code>a: int</code>는 <code>__init__</code> 또는 <code>__new__</code>에서 초기화되어야 하는 인스턴스 변수를 어노테이션할 수 있도록 합니다. 제안된 구문은 다음과 같습니다.</p>
<pre><code class="language-python">class BasicStarship:
    captain: str = 'Picard' # 기본값을 가진 인스턴스 변수
    damage: int # 기본값 없는 인스턴스 변수
    stats: ClassVar[Dict[str, int]] = {} # 클래스 변수
</code></pre>
<p>여기서 <code>ClassVar</code>는 <code>typing</code> 모듈에 의해 정의된 특별한 클래스로, 정적 타입 검사기에게 이 변수가 인스턴스에서 설정되어서는 안 된다는 것을 나타냅니다.</p>
<p><code>ClassVar</code> 매개변수는 중첩 수준에 관계없이 어떤 타입 변수(type variables)도 포함할 수 없습니다. <code>ClassVar[T]</code>와 <code>ClassVar[List[Set[T]]]</code>는 모두 <code>T</code>가 타입 변수인 경우 유효하지 않습니다.</p>
<p>자세한 예시로 설명할 수 있습니다. 다음 클래스에서:</p>
<pre><code class="language-python">class Starship:
    captain = 'Picard'
    stats = {}
    def __init__(self, damage, captain=None):
        self.damage = damage
        if captain:
            self.captain = captain
        # Else keep the default
    def hit(self):
        Starship.stats['hits'] = Starship.stats.get('hits', 0) + 1
</code></pre>
<p><code>stats</code>는 클래스 변수(다양한 게임별 통계를 추적)로 의도되었으며, <code>captain</code>은 클래스에서 기본값이 설정된 인스턴스 변수입니다. 이 차이는 타입 검사기에 의해 인지되지 않을 수 있습니다. 둘 다 클래스 레벨에서 초기화되지만, <code>captain</code>은 인스턴스 변수에 대한 편리한 기본값으로만 작용하는 반면, <code>stats</code>는 진정한 클래스 변수입니다. 즉, 모든 인스턴스에 의해 공유되도록 의도되었습니다.</p>
<p>두 변수 모두 클래스 레벨에서 초기화되므로, 클래스 변수를 <code>ClassVar[...]</code>로 래핑된 타입으로 어노테이션하여 구별하는 것이 유용합니다. 이러한 방식으로 타입 검사기는 인스턴스에서 동일한 이름의 속성에 대한 우발적인 할당을 플래그할 수 있습니다.</p>
<p>예를 들어, 논의된 클래스를 어노테이션하면 다음과 같습니다.</p>
<pre><code class="language-python">class Starship:
    captain: str = 'Picard'
    damage: int
    stats: ClassVar[Dict[str, int]] = {}
    def __init__(self, damage: int, captain: str = None):
        self.damage = damage
        if captain:
            self.captain = captain
        # Else keep the default
    def hit(self):
        Starship.stats['hits'] = Starship.stats.get('hits', 0) + 1

enterprise_d = Starship(3000)
enterprise_d.stats = {} # 타입 검사기에서 오류로 플래그됩니다.
Starship.stats = {} # 이것은 괜찮습니다.
</code></pre>
<p>편의상(그리고 관례상), 인스턴스 변수는 클래스 내부가 아닌 <code>__init__</code> 또는 다른 메서드에서 어노테이션될 수 있습니다.</p>
<pre><code class="language-python">from typing import Generic, TypeVar

T = TypeVar('T')

class Box(Generic[T]):
    def __init__(self, content):
        self.content: T = content
</code></pre>
<h3>표현식 어노테이션 (Annotating expressions)</h3>
<p>어노테이션의 대상은 구문상 유효한 모든 단일 할당 대상(single assignment target)일 수 있습니다 (이에 대해 타입 검사기가 무엇을 할지는 타입 검사기에 달려 있습니다).</p>
<pre><code class="language-python">class Cls: pass
c = Cls()
c.x: int = 0 # c.x를 int로 어노테이션합니다.
c.y: int # c.y를 int로 어노테이션합니다.

d = {}
d['a']: int = 0 # d['a']를 int로 어노테이션합니다.
d['b']: int # d['b']를 int로 어노테이션합니다.
</code></pre>
<p>괄호로 묶인 이름조차도 단순한 이름이 아니라 표현식으로 간주된다는 점에 유의하십시오.</p>
<pre><code class="language-python">(x): int # x를 int로 어노테이션하며, (x)는 컴파일러에 의해 표현식으로 처리됩니다.
(y): int = 0 # 여기도 마찬가지입니다.
</code></pre>
<h3>어노테이션이 허용되지 않는 경우 (Where annotations aren't allowed)</h3>
<p>동일한 함수 스코프(function scope) 내에서 <code>global</code> 또는 <code>nonlocal</code>에 적용되는 변수를 어노테이션하려고 시도하는 것은 불법입니다.</p>
<pre><code class="language-python">def f():
    global x: int # SyntaxError
def g():
    x: int # 또한 SyntaxError
    global x
</code></pre>
<p>그 이유는 <code>global</code>과 <code>nonlocal</code>은 변수를 소유하지 않기 때문입니다. 따라서 타입 어노테이션은 변수를 소유하는 스코프에 속해야 합니다.</p>
<p>단일 할당 대상과 단일 오른쪽 값만 허용됩니다. 또한 <code>for</code> 또는 <code>with</code> 문에서 사용되는 변수는 어노테이션할 수 없습니다. 튜플 언패킹과 유사한 방식으로 미리 어노테이션할 수 있습니다.</p>
<pre><code class="language-python">a: int
for a in my_iter:
    ...

f: MyFile
with myfunc() as f:
    ...
</code></pre>
<h3>스텁 파일의 변수 어노테이션 (Variable annotations in stub files)</h3>
<p>변수 어노테이션은 타입 주석보다 읽기 쉽기 때문에 Python 2.7을 포함한 모든 Python 버전의 스텁 파일에서 선호됩니다. 스텁 파일은 Python 인터프리터에 의해 실행되지 않으므로, 변수 어노테이션을 사용해도 오류가 발생하지 않습니다. 타입 검사기는 모든 Python 버전의 스텁에서 변수 어노테이션을 지원해야 합니다. 예를 들어:</p>
<pre><code class="language-python"># 파일 lib.pyi
ADDRESS: unicode = ...
class Error:
    cause: Union[str, unicode]
</code></pre>
<h3>변수 어노테이션에 대한 권장 코딩 스타일 (Preferred coding style for variable annotations)</h3>
<p>모듈 레벨 변수, 클래스 및 인스턴스 변수, 지역 변수에 대한 어노테이션은 해당 콜론 뒤에 단일 공백이 있어야 합니다. 콜론 앞에는 공백이 없어야 합니다. 할당문에 오른쪽 값이 있는 경우, 등호 양쪽에 정확히 하나의 공백이 있어야 합니다.</p>
<p>예시:
<strong>권장:</strong></p>
<pre><code class="language-python">code: int

class Point:
    coords: Tuple[int, int]
    label: str = '&#x3C;unknown>'
</code></pre>
<p><strong>비권장:</strong></p>
<pre><code class="language-python">code:int # 콜론 뒤에 공백 없음
code : int # 콜론 앞에 공백 있음

class Test:
    result: int=0 # 등호 양쪽에 공백 없음
</code></pre>
<h2>표준 라이브러리 및 문서 변경 사항 (Changes to Standard Library and Documentation)</h2>
<ul>
<li>새로운 공변(covariant) 타입 <code>ClassVar[T_co]</code>가 <code>typing</code> 모듈에 추가됩니다. 이는 유효한 타입이어야 하는 단일 인자만 허용하며, 클래스 인스턴스에서 설정되어서는 안 되는 클래스 변수를 어노테이션하는 데 사용됩니다. 이 제한은 정적 검사기에 의해 보장되지만 런타임에는 보장되지 않습니다. <code>ClassVar</code> 사용법에 대한 예시 및 설명은 <code>classvar</code> 섹션을 참조하고, <code>ClassVar</code> 뒤에 있는 이유에 대한 자세한 정보는 <code>rejected</code> 섹션을 참조하십시오.</li>
<li><code>typing</code> 모듈의 <code>get_type_hints</code> 함수가 확장되어, 함수뿐만 아니라 모듈 및 클래스에서도 런타임에 타입 어노테이션을 검색할 수 있습니다. 어노테이션은 변수 또는 인자를 해당 타입 힌트에 매핑하는 사전(dictionary) 형태로 반환되며, 전방 참조(forward references)는 평가됩니다. 클래스의 경우, 메서드 결정 순서(method resolution order)에 따라 구성된 매핑(<code>collections.ChainMap</code>일 수 있음)을 반환합니다.</li>
<li>어노테이션 사용에 대한 권장 지침이 문서에 추가될 것이며, 이 PEP와 PEP 484에 설명된 사양을 교육적으로 요약한 내용을 포함할 것입니다. 또한, 타입 주석을 타입 어노테이션으로 변환하는 도우미 스크립트가 표준 라이브러리와 별도로 게시될 것입니다.</li>
</ul>
<h2>타입 어노테이션의 런타임 효과 (Runtime Effects of Type Annotations)</h2>
<p>지역 변수를 어노테이션하면 할당되지 않았더라도 인터프리터는 이를 지역 변수로 처리합니다. 지역 변수에 대한 어노테이션은 평가되지 않습니다.</p>
<pre><code class="language-python">def f():
    x: NonexistentName # 오류 없음.
</code></pre>
<p>그러나 모듈 또는 클래스 레벨에 있는 경우, 타입은 평가됩니다.</p>
<pre><code class="language-python">x: NonexistentName # 오류!
class X:
    var: NonexistentName # 오류!
</code></pre>
<p>또한 모듈 또는 클래스 레벨에서 어노테이션되는 항목이 단순한 이름인 경우, 해당 이름과 어노테이션은 모듈 또는 클래스의 <code>__annotations__</code> 속성(비공개인 경우 변형됨)에 이름에서 평가된 어노테이션으로의 순서 있는 매핑(ordered mapping)으로 저장됩니다. 예시는 다음과 같습니다.</p>
<pre><code class="language-python">from typing import Dict

class Player: ...

players: Dict[str, Player]
__points: int

print(__annotations__) # 출력: {'players': typing.Dict[str, __main__.Player],
                     # '_Player__points': &#x3C;class 'int'>}
</code></pre>
<p><code>__annotations__</code>는 쓰기 가능하므로 다음이 허용됩니다.</p>
<pre><code class="language-python">__annotations__['s'] = str
</code></pre>
<p>그러나 <code>__annotations__</code>를 순서 있는 매핑이 아닌 다른 것으로 업데이트하려고 시도하면 <code>TypeError</code>가 발생할 수 있습니다.</p>
<pre><code class="language-python">class C:
    __annotations__ = 42
    x: int = 5 # TypeError 발생
</code></pre>
<p>(참고: 오류의 원인인 <code>__annotations__</code>에 대한 할당은 파이썬 인터프리터에 의해 아무런 문제 없이 허용되지만, 이후의 타입 어노테이션은 이를 <code>MutableMapping</code>으로 예상하며 실패합니다).</p>
<p>런타임에 어노테이션을 가져오는 권장 방법은 <code>typing.get_type_hints</code> 함수를 사용하는 것입니다. 모든 던더 속성(dunder attributes)과 마찬가지로 <code>__annotations__</code>의 문서화되지 않은 사용은 경고 없이 손상될 수 있습니다.</p>
<pre><code class="language-python">from typing import Dict, ClassVar, get_type_hints

class Starship:
    hitpoints: int = 50
    stats: ClassVar[Dict[str, int]] = {}
    shield: int = 100
    captain: str
    def __init__(self, captain: str) -> None: ...

assert get_type_hints(Starship) == {'hitpoints': int, 'stats': ClassVar[Dict[str, int]], 'shield': int, 'captain': str}
assert get_type_hints(Starship.__init__) == {'captain': str, 'return': None}
</code></pre>
<p>어노테이션이 정적으로 발견되지 않으면 <code>__annotations__</code> 사전이 전혀 생성되지 않습니다. 또한, 함수 호출마다 어노테이션 사전을 생성하고 채워야 하는 비용을 상쇄할 만큼 로컬에서 어노테이션을 사용할 가치가 크지 않습니다. 따라서 함수 레벨의 어노테이션은 평가되지 않으며 저장되지 않습니다.</p>
<h3>기타 어노테이션 사용 (Other uses of annotations)</h3>
<p>이 PEP를 통해 파이썬은 다음과 같은 구문을 거부하지는 않겠지만:</p>
<pre><code class="language-python">alice: 'well done' = 'A+'
bob: 'what a shame' = 'F-'
</code></pre>
<p>이는 타입 어노테이션을 "오류를 발생시키지 않고 평가된다"는 것 이상으로 신경 쓰지 않을 것이기 때문입니다. 그러나 이를 접하는 타입 검사기는 <code># type: ignore</code> 또는 <code>@no_type_check</code>로 비활성화되지 않는 한 이를 플래그할 것입니다.</p>
<p>하지만 파이썬은 "타입"이 무엇인지 신경 쓰지 않으므로, 위 코드 스니펫이 전역 레벨이나 클래스에 있는 경우 <code>__annotations__</code>에는 <code>{'alice': 'well done', 'bob': 'what a shame'}</code>가 포함될 것입니다.</p>
<p>이렇게 저장된 어노테이션은 다른 목적으로 사용될 수 있지만, 이 PEP를 통해 우리는 타입 힌트를 어노테이션의 선호되는 사용으로 명시적으로 권장합니다.</p>
<h2>거부/연기된 제안 (Rejected/Postponed Proposals)</h2>
<ul>
<li><strong>변수 어노테이션을 도입해야 하는가?</strong> 변수 어노테이션은 PEP 484에 의해 승인된 타입 주석 형태로 거의 2년 동안 존재했습니다. 서드파티 타입 검사기(<code>mypy</code>, <code>pytype</code>, <code>PyCharm</code> 등)와 타입 검사기를 사용하는 프로젝트에서 광범위하게 사용됩니다. 그러나 주석 구문에는 배경(Rationale)에 나열된 많은 단점이 있습니다. 이 PEP는 타입 어노테이션의 필요성에 관한 것이 아니라, 그러한 어노테이션을 위한 구문이 무엇이어야 하는지에 관한 것입니다.</li>
<li><strong>새로운 키워드를 도입해야 하는가?</strong> 좋은 키워드를 선택하는 것은 어렵습니다. 예를 들어 <code>var</code>는 너무 흔한 변수 이름이므로 사용할 수 없고, 클래스 변수나 전역 변수에 사용하려면 <code>local</code>이 될 수 없습니다. 둘째, 어떤 키워드를 선택하든 <code>__future__</code> import가 필요할 것입니다.</li>
<li><strong><code>def</code>를 키워드로 사용해야 하는가?</strong> 제안은 다음과 같았을 것입니다.
<pre><code class="language-python">def primes: List[int] = []
def captain: str
</code></pre>
이것의 문제는 <code>def</code>가 수십 년 동안 파이썬 프로그래머(및 도구!)에게 "함수 정의"를 의미한다는 것입니다. 이를 변수 정의에도 사용하는 것은 명확성을 높이지 않습니다 (물론 이것은 주관적입니다).</li>
<li><strong>함수 기반 구문을 사용해야 하는가?</strong> <code>var = cast(annotation[, value])</code>를 사용하여 변수 타입을 어노테이션하는 것이 제안되었습니다. 이 구문은 AST에 어노테이션이 없는 것과 같은 타입 주석의 일부 문제를 완화하지만, 가독성과 같은 다른 문제를 해결하지 못하고 런타임 오버헤드를 도입할 수 있습니다.</li>
<li><strong>튜플 언패킹에 타입 어노테이션을 허용해야 하는가?</strong> 이는 모호성을 유발합니다. <code>x, y: T</code>라는 문장이 무엇을 의미하는지 명확하지 않습니다. <code>x</code>와 <code>y</code> 모두 <code>T</code> 타입인가요, 아니면 <code>T</code>가 <code>x</code>와 <code>y</code>에 분산되는 두 개의 항목으로 구성된 튜플 타입으로 예상되는가요, 아니면 <code>x</code>가 <code>Any</code> 타입이고 <code>y</code>가 <code>T</code> 타입인가요? (후자는 함수 시그니처에서 발생할 경우의 의미입니다). 독자에게 추측을 맡기는 대신, 적어도 현재로서는 이를 금지합니다.</li>
<li><strong>어노테이션을 위한 괄호 형식 <code>(var: type)</code>을 사용해야 하는가?</strong> 위에서 언급한 모호성을 해결하기 위한 방안으로 <code>python-ideas</code>에서 제기되었지만, 그러한 구문은 복잡하고 이점이 미미하며 가독성이 좋지 않다는 이유로 거부되었습니다.</li>
<li><strong>연쇄 할당(chained assignments)에 어노테이션을 허용해야 하는가?</strong> 이는 튜플 언패킹과 유사한 모호성 및 가독성 문제를 가집니다. 예를 들어:
<pre><code class="language-python">x: int = y = 1
z = w: int = 1
</code></pre>
여기서 <code>y</code>와 <code>z</code>의 타입이 무엇이어야 하는지 모호합니다. 또한 두 번째 줄은 파싱하기 어렵습니다.</li>
<li><strong><code>with</code> 및 <code>for</code> 문에 어노테이션을 허용해야 하는가?</strong> <code>for</code> 문에서는 실제 이터러블을 식별하기 어렵게 만들고, <code>with</code> 문에서는 CPython의 LL(1) 파서를 혼란스럽게 만들 수 있다는 이유로 거부되었습니다.</li>
<li><strong>함수 정의 시점에 지역 어노테이션을 평가해야 하는가?</strong> 이는 어노테이션의 위치가 주변 코드와 동일한 스코프에 있음을 강력하게 시사하기 때문에 Guido에 의해 거부되었습니다.</li>
<li><strong>함수 스코프에도 변수 어노테이션을 저장해야 하는가?</strong> 어노테이션을 로컬에서 사용할 수 있는 가치는 함수 호출마다 사전을 생성하고 채우는 비용을 크게 상쇄할 만큼 충분하지 않습니다.</li>
<li><strong>할당 없이 어노테이션된 변수를 초기화해야 하는가?</strong> <code>python-ideas</code>에서 <code>x: int</code>의 <code>x</code>를 <code>None</code> 또는 Javascript의 <code>undefined</code>와 같은 추가적인 특별 상수로 초기화하는 것이 제안되었습니다. 그러나 언어에 또 다른 싱글턴 값을 추가하면 코드의 모든 곳에서 이를 확인해야 할 것입니다. 따라서 Guido는 이에 대해 명확히 "No"라고 말했습니다.</li>
<li><strong><code>typing</code> 모듈에 <code>InstanceVar</code>도 추가해야 하는가?</strong> 인스턴스 변수는 클래스 변수보다 훨씬 흔합니다. 더 일반적인 사용법이 기본값이 되는 것이 마땅하므로 이는 중복됩니다.</li>
<li><strong>메서드에서만 인스턴스 변수 어노테이션을 허용해야 하는가?</strong> 문제는 많은 <code>__init__</code> 메서드가 인스턴스 변수를 초기화하는 것 외에도 많은 작업을 수행하며, (사람이) 모든 인스턴스 변수 어노테이션을 찾기가 더 어려울 것이라는 점입니다. 때로는 <code>__init__</code>이 더 많은 도우미 메서드로 분할되므로 이를 추적하는 것이 더욱 어려워집니다. 인스턴스 변수 어노테이션을 클래스에 함께 배치하면 찾기 쉽고, 코드를 처음 읽는 사람에게 도움이 됩니다.</li>
<li><strong>클래스 변수에 <code>x: class t = v</code> 구문을 사용해야 하는가?</strong> 이는 더 복잡한 파서가 필요하며, <code>class</code> 키워드는 단순한 구문 하이라이터를 혼란스럽게 할 것입니다. 어쨌든 <code>ClassVar</code>는 클래스 변수를 <code>__annotations__</code>에 저장해야 하므로 더 간단한 구문이 선택되었습니다.</li>
<li><strong><code>ClassVar</code>를 완전히 잊어야 하는가?</strong> <code>mypy</code>가 클래스 변수와 인스턴스 변수를 구별하는 방법 없이도 잘 작동하는 것처럼 보였기 때문에 제안되었습니다. 그러나 타입 검사기는 추가 정보를 가지고 유용한 작업을 수행할 수 있습니다. 예를 들어, 인스턴스를 통해 클래스 변수에 우발적인 할당(클래스 변수를 가리는 인스턴스 변수를 생성함)을 플래그할 수 있습니다. 또한 잘 알려진 위험인 변경 가능한 기본값을 가진 인스턴스 변수도 플래그할 수 있습니다.</li>
<li><strong><code>ClassVar</code> 대신 <code>ClassAttr</code>를 사용해야 하는가?</strong> <code>ClassVar</code>가 더 나은 주된 이유는 다음과 같습니다. 메서드, 디스크립터 등 많은 것들이 클래스 속성입니다. 그러나 특정 속성만 개념적으로 클래스 변수(또는 상수)입니다.</li>
<li><strong>어노테이션을 평가하지 않고 문자열로 처리해야 하는가?</strong> 이는 항상 평가되는 함수 어노테이션의 동작과 일치하지 않을 것입니다. 비록 미래에 재고될 수 있지만, PEP 484에서는 이것이 별도의 PEP여야 한다고 결정되었습니다.</li>
<li><strong>클래스 독스트링에 변수 타입을 어노테이션해야 하는가?</strong> 많은 프로젝트에서 이미 다양한 독스트링 규칙을 사용하고 있으며, 종종 일관성이 부족하고 일반적으로 PEP 484 어노테이션 구문을 아직 따르지 않습니다. 또한 이것은 특별하고 정교한 파서가 필요할 것입니다. 이는 결국 PEP의 목적, 즉 서드파티 타입 검사 도구와의 협력을 저해할 것입니다.</li>
<li><strong><code>__annotations__</code>를 디스크립터로 구현해야 하는가?</strong> <code>__annotations__</code>를 사전이나 <code>None</code>이 아닌 다른 것으로 설정하는 것을 금지하기 위해 제안되었습니다. Guido는 이를 불필요하다고 거부했습니다. 대신 <code>__annotations__</code>가 매핑이 아닌 다른 것일 때 업데이트를 시도하면 <code>TypeError</code>가 발생할 것입니다.</li>
<li><strong>맨몸 어노테이션(bare annotations)을 <code>global</code> 또는 <code>nonlocal</code>과 동일하게 처리해야 하는가?</strong> 거부된 제안은 함수 본문에서 할당 없는 어노테이션의 존재가 어떤 평가도 수반하지 않아야 한다고 선호했습니다. 이와 대조적으로, 이 PEP는 대상이 단일 이름보다 복잡한 경우, 해당 "왼쪽 부분"이 함수 본문에서 발생하는 지점에서 평가되어야 한다고 암시합니다. 이는 단순히 정의되었는지 확인하기 위함입니다. 예를 들어:
<pre><code class="language-python">def foo(self):
    slef.name: str
</code></pre>
여기서 <code>slef</code> 이름은 평가되어야 합니다. 만약 정의되지 않았다면 (이 예시에서 그럴 가능성이 높음), 런타임에 오류가 감지될 것입니다. 이는 초기값이 있을 때 발생하는 상황과 더 일치하므로 놀라움을 덜 줄 것으로 예상됩니다. (또한 대상이 <code>self.name</code>이었다면, 최적화 컴파일러는 <code>self</code>가 확실히 정의될 수 있다고 증명할 수 있는 한 <code>self</code>를 평가할 의무가 없다는 점에 유의하십시오).</li>
</ul>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>이 PEP는 완전히 하위 호환됩니다.</p>
<h2>구현 (Implementation)</h2>
<p>Python 3.6용 구현은 GitHub에서 찾을 수 있습니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-245c6e96a76a0f6c.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-e3ea38185bb36cd2.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/526\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"u-OtsnEdJqLdizIsvqrrQ\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/526/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/526\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"526\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/526\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T7cd9,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0526/\"\u003ePEP 526 - Syntax for Variable Annotations\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 09-Aug-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003ePEP 526 – 변수 어노테이션 구문 (Syntax for Variable Annotations)\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003ePEP 484는 타입 힌트(type hints), 즉 타입 어노테이션(type annotations)을 도입했습니다. 주로 함수 어노테이션에 중점을 두었지만, 변수를 어노테이션하기 위한 타입 주석(type comments) 개념도 함께 소개했습니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 'primes'는 정수 리스트입니다.\r\nprimes = [] # type: List[int]\r\n# 'captain'은 문자열입니다. (참고: 초기값이 문제입니다)\r\ncaptain = ... # type: str\r\n\r\nclass Starship:\r\n    # 'stats'는 클래스 변수입니다.\r\n    stats = {} # type: Dict[str, int]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 PEP는 위와 같이 주석을 통해 변수의 타입(클래스 변수 및 인스턴스 변수 포함)을 표현하는 대신, 이를 위한 파이썬 구문을 추가하는 것을 목표로 합니다.\u003c/p\u003e\n\u003cp\u003e새로운 구문 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eprimes: List[int] = []\r\ncaptain: str # 참고: 초기값이 없습니다!\r\n\r\nclass Starship:\r\n    stats: ClassVar[Dict[str, int]] = {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePEP 484는 타입 주석이 복잡한 경우 타입 추론(type inference)에 도움이 되도록 의도되었다고 명시하며, 이 PEP는 이러한 의도를 변경하지 않습니다. 그러나 실제로는 타입 주석이 클래스 변수와 인스턴스 변수에도 채택되었으므로, 이 PEP는 이러한 변수에 대한 타입 어노테이션 사용법도 논의합니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003e타입 주석은 충분히 잘 작동하지만, 주석으로 표현된다는 점 때문에 몇 가지 단점이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e텍스트 편집기가 타입 어노테이션과 주석을 다르게 강조 표시하는 경우가 많습니다.\u003c/li\u003e\n\u003cli\u003e정의되지 않은 변수의 타입을 어노테이션할 방법이 없습니다. \u003ccode\u003ea = None # type: int\u003c/code\u003e와 같이 \u003ccode\u003eNone\u003c/code\u003e으로 초기화해야 합니다.\u003c/li\u003e\n\u003cli\u003e조건부 분기(conditional branch)에서 어노테이션된 변수는 읽기 어렵습니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif some_value:\r\n    my_var = function() # type: Logger\r\nelse:\r\n    my_var = another_function() # 여기에는 왜 타입이 없을까요?\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e타입 주석은 실제로 언어의 일부가 아니므로, 파이썬 스크립트가 이를 파싱하려면 \u003ccode\u003east\u003c/code\u003e 모듈 대신 사용자 정의 파서(custom parser)가 필요합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etypeshed\u003c/code\u003e에서 타입 주석이 많이 사용됩니다. \u003ccode\u003etypeshed\u003c/code\u003e를 변수 어노테이션 구문을 사용하도록 마이그레이션하면 스텁 파일(stub files)의 가독성이 향상될 것입니다.\u003c/li\u003e\n\u003cli\u003e일반 주석과 타입 주석이 함께 사용되는 상황에서는 구별하기 어렵습니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003epath = None # type: Optional[str] # 모듈 소스 경로\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e모듈의 소스 코드를 찾아서 런타임에 파싱하려는 시도 없이는 런타임에 어노테이션을 검색하는 것이 불가능하며, 이는 우아하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 문제들의 대부분은 새로운 구문을 언어의 핵심 부분으로 만듦으로써 완화될 수 있습니다. 또한, 클래스 및 인스턴스 변수에 대한 전용 어노테이션 구문을 갖는 것은 PEP 484에 정의된 명목적 타이핑(nominal typing)을 보완하는 정적 덕 타이핑(static duck-typing)의 길을 열어줄 것입니다.\u003c/p\u003e\n\u003ch3\u003e비목표 (Non-goals)\u003c/h3\u003e\n\u003cp\u003e이 제안은 런타임에 어노테이션을 검색하기 위한 표준 라이브러리 함수 \u003ccode\u003etyping.get_type_hints\u003c/code\u003e의 확장을 동반하지만, 변수 어노테이션은 런타임 타입 검사(runtime type checking)를 위해 설계된 것이 아닙니다. 이러한 기능을 구현하려면 서드파티 패키지가 개발되어야 합니다.\u003c/p\u003e\n\u003cp\u003e또한 파이썬은 동적 타입 언어(dynamically typed language)로 남을 것이며, 저자들은 타입 힌트가 관례적으로라도 의무화되는 것을 원하지 않는다는 점을 강조해야 합니다. 타입 어노테이션은 정적 타입 언어(statically typed languages)의 변수 선언과 혼동되어서는 안 됩니다. 어노테이션 구문의 목표는 서드파티 도구를 위한 구조화된 타입 메타데이터를 지정하는 쉬운 방법을 제공하는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 타입 검사기가 타입 검사 규칙을 변경하도록 요구하지 않습니다. 단지 타입 주석을 대체할 더 읽기 쉬운 구문을 제공할 뿐입니다.\u003c/p\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003cp\u003e타입 어노테이션은 할당문(assignment statement)이나 단일 표현식(single expression)에 추가될 수 있으며, 서드파티 타입 검사기에게 어노테이션 대상의 원하는 타입을 알려줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003emy_var: int\r\nmy_var = 5 # 타입 검사를 통과합니다.\r\nother_var: int = 'a' # 타입 검사기에서 오류로 플래그됩니다.\r\n                     # 하지만 런타임에는 문제 없습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 구문은 PEP 484를 넘어 새로운 의미론을 도입하지 않으므로, 다음 세 가지 문장은 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003evar = value # type: annotation\r\nvar: annotation; var = value\r\nvar: annotation = value\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래에서는 다양한 맥락에서의 타입 어노테이션 구문과 그 런타임 효과를 명시합니다. 또한 타입 검사기가 어노테이션을 어떻게 해석할 수 있는지 제안하지만, 이러한 제안에 대한 준수는 필수가 아닙니다 (이는 PEP 484의 준수에 대한 태도와 일치합니다).\u003c/p\u003e\n\u003ch3\u003e전역 및 지역 변수 어노테이션 (Global and local variable annotations)\u003c/h3\u003e\n\u003cp\u003e지역 변수(locals)와 전역 변수(globals)의 타입은 다음과 같이 어노테이션할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esome_number: int # 초기값 없는 변수\r\nsome_list: List[int] = [] # 초기값 있는 변수\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e초기값을 생략할 수 있으므로, 조건부 분기에서 할당되는 변수의 타이핑이 더 쉬워집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esane_world: bool\r\nif 2+2 == 4:\r\n    sane_world = True\r\nelse:\r\n    sane_world = False\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 구문이 튜플 패킹(tuple packing)을 허용하지만, 튜플 언패킹(tuple unpacking)을 사용할 때는 변수의 타입을 어노테이션할 수 없다는 점에 유의하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 변수 어노테이션 구문을 사용한 튜플 패킹\r\nt: Tuple[int, ...] = (1, 2, 3)\r\n# 또는\r\nt: Tuple[int, ...] = 1, 2, 3 # Python 3.8 이상에서만 작동\r\n\r\n# 변수 어노테이션 구문을 사용한 튜플 언패킹\r\nheader: str kind: int body: Optional[List[str]] # 이 구문은 유효하지 않습니다.\r\nheader, kind, body = message # 각 변수에 개별적으로 어노테이션해야 합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e초기값을 생략하면 변수가 초기화되지 않은 상태로 남습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ea: int\r\nprint(a) # NameError 발생\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 지역 변수를 어노테이션하면 인터프리터는 항상 이를 지역 변수로 만듭니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef f():\r\n    a: int\r\n    print(a) # UnboundLocalError 발생\r\n    # 'a: int'를 주석 처리하면 NameError가 발생합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 마치 코드가 다음과 같았던 것과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef f():\r\n    if False:\r\n        a = 0\r\n    print(a) # UnboundLocalError 발생\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e중복된 타입 어노테이션은 무시됩니다. 그러나 정적 타입 검사기는 동일한 변수에 대해 다른 타입으로 어노테이션할 경우 경고를 발행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ea: int\r\na: str # 정적 타입 검사기가 이에 대해 경고할 수도 있고 안 할 수도 있습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e클래스 및 인스턴스 변수 어노테이션 (Class and instance variable annotations)\u003c/h3\u003e\n\u003cp\u003e타입 어노테이션은 클래스 본문(class bodies) 및 메서드(methods) 내의 클래스 및 인스턴스 변수를 어노테이션하는 데에도 사용될 수 있습니다. 특히, 값이 없는 표기법 \u003ccode\u003ea: int\u003c/code\u003e는 \u003ccode\u003e__init__\u003c/code\u003e 또는 \u003ccode\u003e__new__\u003c/code\u003e에서 초기화되어야 하는 인스턴스 변수를 어노테이션할 수 있도록 합니다. 제안된 구문은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass BasicStarship:\r\n    captain: str = 'Picard' # 기본값을 가진 인스턴스 변수\r\n    damage: int # 기본값 없는 인스턴스 변수\r\n    stats: ClassVar[Dict[str, int]] = {} # 클래스 변수\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003eClassVar\u003c/code\u003e는 \u003ccode\u003etyping\u003c/code\u003e 모듈에 의해 정의된 특별한 클래스로, 정적 타입 검사기에게 이 변수가 인스턴스에서 설정되어서는 안 된다는 것을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eClassVar\u003c/code\u003e 매개변수는 중첩 수준에 관계없이 어떤 타입 변수(type variables)도 포함할 수 없습니다. \u003ccode\u003eClassVar[T]\u003c/code\u003e와 \u003ccode\u003eClassVar[List[Set[T]]]\u003c/code\u003e는 모두 \u003ccode\u003eT\u003c/code\u003e가 타입 변수인 경우 유효하지 않습니다.\u003c/p\u003e\n\u003cp\u003e자세한 예시로 설명할 수 있습니다. 다음 클래스에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Starship:\r\n    captain = 'Picard'\r\n    stats = {}\r\n    def __init__(self, damage, captain=None):\r\n        self.damage = damage\r\n        if captain:\r\n            self.captain = captain\r\n        # Else keep the default\r\n    def hit(self):\r\n        Starship.stats['hits'] = Starship.stats.get('hits', 0) + 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003estats\u003c/code\u003e는 클래스 변수(다양한 게임별 통계를 추적)로 의도되었으며, \u003ccode\u003ecaptain\u003c/code\u003e은 클래스에서 기본값이 설정된 인스턴스 변수입니다. 이 차이는 타입 검사기에 의해 인지되지 않을 수 있습니다. 둘 다 클래스 레벨에서 초기화되지만, \u003ccode\u003ecaptain\u003c/code\u003e은 인스턴스 변수에 대한 편리한 기본값으로만 작용하는 반면, \u003ccode\u003estats\u003c/code\u003e는 진정한 클래스 변수입니다. 즉, 모든 인스턴스에 의해 공유되도록 의도되었습니다.\u003c/p\u003e\n\u003cp\u003e두 변수 모두 클래스 레벨에서 초기화되므로, 클래스 변수를 \u003ccode\u003eClassVar[...]\u003c/code\u003e로 래핑된 타입으로 어노테이션하여 구별하는 것이 유용합니다. 이러한 방식으로 타입 검사기는 인스턴스에서 동일한 이름의 속성에 대한 우발적인 할당을 플래그할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 논의된 클래스를 어노테이션하면 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Starship:\r\n    captain: str = 'Picard'\r\n    damage: int\r\n    stats: ClassVar[Dict[str, int]] = {}\r\n    def __init__(self, damage: int, captain: str = None):\r\n        self.damage = damage\r\n        if captain:\r\n            self.captain = captain\r\n        # Else keep the default\r\n    def hit(self):\r\n        Starship.stats['hits'] = Starship.stats.get('hits', 0) + 1\r\n\r\nenterprise_d = Starship(3000)\r\nenterprise_d.stats = {} # 타입 검사기에서 오류로 플래그됩니다.\r\nStarship.stats = {} # 이것은 괜찮습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e편의상(그리고 관례상), 인스턴스 변수는 클래스 내부가 아닌 \u003ccode\u003e__init__\u003c/code\u003e 또는 다른 메서드에서 어노테이션될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Generic, TypeVar\r\n\r\nT = TypeVar('T')\r\n\r\nclass Box(Generic[T]):\r\n    def __init__(self, content):\r\n        self.content: T = content\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e표현식 어노테이션 (Annotating expressions)\u003c/h3\u003e\n\u003cp\u003e어노테이션의 대상은 구문상 유효한 모든 단일 할당 대상(single assignment target)일 수 있습니다 (이에 대해 타입 검사기가 무엇을 할지는 타입 검사기에 달려 있습니다).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Cls: pass\r\nc = Cls()\r\nc.x: int = 0 # c.x를 int로 어노테이션합니다.\r\nc.y: int # c.y를 int로 어노테이션합니다.\r\n\r\nd = {}\r\nd['a']: int = 0 # d['a']를 int로 어노테이션합니다.\r\nd['b']: int # d['b']를 int로 어노테이션합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e괄호로 묶인 이름조차도 단순한 이름이 아니라 표현식으로 간주된다는 점에 유의하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e(x): int # x를 int로 어노테이션하며, (x)는 컴파일러에 의해 표현식으로 처리됩니다.\r\n(y): int = 0 # 여기도 마찬가지입니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e어노테이션이 허용되지 않는 경우 (Where annotations aren't allowed)\u003c/h3\u003e\n\u003cp\u003e동일한 함수 스코프(function scope) 내에서 \u003ccode\u003eglobal\u003c/code\u003e 또는 \u003ccode\u003enonlocal\u003c/code\u003e에 적용되는 변수를 어노테이션하려고 시도하는 것은 불법입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef f():\r\n    global x: int # SyntaxError\r\ndef g():\r\n    x: int # 또한 SyntaxError\r\n    global x\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 이유는 \u003ccode\u003eglobal\u003c/code\u003e과 \u003ccode\u003enonlocal\u003c/code\u003e은 변수를 소유하지 않기 때문입니다. 따라서 타입 어노테이션은 변수를 소유하는 스코프에 속해야 합니다.\u003c/p\u003e\n\u003cp\u003e단일 할당 대상과 단일 오른쪽 값만 허용됩니다. 또한 \u003ccode\u003efor\u003c/code\u003e 또는 \u003ccode\u003ewith\u003c/code\u003e 문에서 사용되는 변수는 어노테이션할 수 없습니다. 튜플 언패킹과 유사한 방식으로 미리 어노테이션할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ea: int\r\nfor a in my_iter:\r\n    ...\r\n\r\nf: MyFile\r\nwith myfunc() as f:\r\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e스텁 파일의 변수 어노테이션 (Variable annotations in stub files)\u003c/h3\u003e\n\u003cp\u003e변수 어노테이션은 타입 주석보다 읽기 쉽기 때문에 Python 2.7을 포함한 모든 Python 버전의 스텁 파일에서 선호됩니다. 스텁 파일은 Python 인터프리터에 의해 실행되지 않으므로, 변수 어노테이션을 사용해도 오류가 발생하지 않습니다. 타입 검사기는 모든 Python 버전의 스텁에서 변수 어노테이션을 지원해야 합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 파일 lib.pyi\r\nADDRESS: unicode = ...\r\nclass Error:\r\n    cause: Union[str, unicode]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e변수 어노테이션에 대한 권장 코딩 스타일 (Preferred coding style for variable annotations)\u003c/h3\u003e\n\u003cp\u003e모듈 레벨 변수, 클래스 및 인스턴스 변수, 지역 변수에 대한 어노테이션은 해당 콜론 뒤에 단일 공백이 있어야 합니다. 콜론 앞에는 공백이 없어야 합니다. 할당문에 오른쪽 값이 있는 경우, 등호 양쪽에 정확히 하나의 공백이 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e예시:\r\n\u003cstrong\u003e권장:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecode: int\r\n\r\nclass Point:\r\n    coords: Tuple[int, int]\r\n    label: str = '\u0026#x3C;unknown\u003e'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e비권장:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecode:int # 콜론 뒤에 공백 없음\r\ncode : int # 콜론 앞에 공백 있음\r\n\r\nclass Test:\r\n    result: int=0 # 등호 양쪽에 공백 없음\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e표준 라이브러리 및 문서 변경 사항 (Changes to Standard Library and Documentation)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e새로운 공변(covariant) 타입 \u003ccode\u003eClassVar[T_co]\u003c/code\u003e가 \u003ccode\u003etyping\u003c/code\u003e 모듈에 추가됩니다. 이는 유효한 타입이어야 하는 단일 인자만 허용하며, 클래스 인스턴스에서 설정되어서는 안 되는 클래스 변수를 어노테이션하는 데 사용됩니다. 이 제한은 정적 검사기에 의해 보장되지만 런타임에는 보장되지 않습니다. \u003ccode\u003eClassVar\u003c/code\u003e 사용법에 대한 예시 및 설명은 \u003ccode\u003eclassvar\u003c/code\u003e 섹션을 참조하고, \u003ccode\u003eClassVar\u003c/code\u003e 뒤에 있는 이유에 대한 자세한 정보는 \u003ccode\u003erejected\u003c/code\u003e 섹션을 참조하십시오.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etyping\u003c/code\u003e 모듈의 \u003ccode\u003eget_type_hints\u003c/code\u003e 함수가 확장되어, 함수뿐만 아니라 모듈 및 클래스에서도 런타임에 타입 어노테이션을 검색할 수 있습니다. 어노테이션은 변수 또는 인자를 해당 타입 힌트에 매핑하는 사전(dictionary) 형태로 반환되며, 전방 참조(forward references)는 평가됩니다. 클래스의 경우, 메서드 결정 순서(method resolution order)에 따라 구성된 매핑(\u003ccode\u003ecollections.ChainMap\u003c/code\u003e일 수 있음)을 반환합니다.\u003c/li\u003e\n\u003cli\u003e어노테이션 사용에 대한 권장 지침이 문서에 추가될 것이며, 이 PEP와 PEP 484에 설명된 사양을 교육적으로 요약한 내용을 포함할 것입니다. 또한, 타입 주석을 타입 어노테이션으로 변환하는 도우미 스크립트가 표준 라이브러리와 별도로 게시될 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e타입 어노테이션의 런타임 효과 (Runtime Effects of Type Annotations)\u003c/h2\u003e\n\u003cp\u003e지역 변수를 어노테이션하면 할당되지 않았더라도 인터프리터는 이를 지역 변수로 처리합니다. 지역 변수에 대한 어노테이션은 평가되지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef f():\r\n    x: NonexistentName # 오류 없음.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 모듈 또는 클래스 레벨에 있는 경우, 타입은 평가됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ex: NonexistentName # 오류!\r\nclass X:\r\n    var: NonexistentName # 오류!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한 모듈 또는 클래스 레벨에서 어노테이션되는 항목이 단순한 이름인 경우, 해당 이름과 어노테이션은 모듈 또는 클래스의 \u003ccode\u003e__annotations__\u003c/code\u003e 속성(비공개인 경우 변형됨)에 이름에서 평가된 어노테이션으로의 순서 있는 매핑(ordered mapping)으로 저장됩니다. 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Dict\r\n\r\nclass Player: ...\r\n\r\nplayers: Dict[str, Player]\r\n__points: int\r\n\r\nprint(__annotations__) # 출력: {'players': typing.Dict[str, __main__.Player],\r\n                     # '_Player__points': \u0026#x3C;class 'int'\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e__annotations__\u003c/code\u003e는 쓰기 가능하므로 다음이 허용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e__annotations__['s'] = str\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 \u003ccode\u003e__annotations__\u003c/code\u003e를 순서 있는 매핑이 아닌 다른 것으로 업데이트하려고 시도하면 \u003ccode\u003eTypeError\u003c/code\u003e가 발생할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass C:\r\n    __annotations__ = 42\r\n    x: int = 5 # TypeError 발생\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(참고: 오류의 원인인 \u003ccode\u003e__annotations__\u003c/code\u003e에 대한 할당은 파이썬 인터프리터에 의해 아무런 문제 없이 허용되지만, 이후의 타입 어노테이션은 이를 \u003ccode\u003eMutableMapping\u003c/code\u003e으로 예상하며 실패합니다).\u003c/p\u003e\n\u003cp\u003e런타임에 어노테이션을 가져오는 권장 방법은 \u003ccode\u003etyping.get_type_hints\u003c/code\u003e 함수를 사용하는 것입니다. 모든 던더 속성(dunder attributes)과 마찬가지로 \u003ccode\u003e__annotations__\u003c/code\u003e의 문서화되지 않은 사용은 경고 없이 손상될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Dict, ClassVar, get_type_hints\r\n\r\nclass Starship:\r\n    hitpoints: int = 50\r\n    stats: ClassVar[Dict[str, int]] = {}\r\n    shield: int = 100\r\n    captain: str\r\n    def __init__(self, captain: str) -\u003e None: ...\r\n\r\nassert get_type_hints(Starship) == {'hitpoints': int, 'stats': ClassVar[Dict[str, int]], 'shield': int, 'captain': str}\r\nassert get_type_hints(Starship.__init__) == {'captain': str, 'return': None}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e어노테이션이 정적으로 발견되지 않으면 \u003ccode\u003e__annotations__\u003c/code\u003e 사전이 전혀 생성되지 않습니다. 또한, 함수 호출마다 어노테이션 사전을 생성하고 채워야 하는 비용을 상쇄할 만큼 로컬에서 어노테이션을 사용할 가치가 크지 않습니다. 따라서 함수 레벨의 어노테이션은 평가되지 않으며 저장되지 않습니다.\u003c/p\u003e\n\u003ch3\u003e기타 어노테이션 사용 (Other uses of annotations)\u003c/h3\u003e\n\u003cp\u003e이 PEP를 통해 파이썬은 다음과 같은 구문을 거부하지는 않겠지만:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ealice: 'well done' = 'A+'\r\nbob: 'what a shame' = 'F-'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 타입 어노테이션을 \"오류를 발생시키지 않고 평가된다\"는 것 이상으로 신경 쓰지 않을 것이기 때문입니다. 그러나 이를 접하는 타입 검사기는 \u003ccode\u003e# type: ignore\u003c/code\u003e 또는 \u003ccode\u003e@no_type_check\u003c/code\u003e로 비활성화되지 않는 한 이를 플래그할 것입니다.\u003c/p\u003e\n\u003cp\u003e하지만 파이썬은 \"타입\"이 무엇인지 신경 쓰지 않으므로, 위 코드 스니펫이 전역 레벨이나 클래스에 있는 경우 \u003ccode\u003e__annotations__\u003c/code\u003e에는 \u003ccode\u003e{'alice': 'well done', 'bob': 'what a shame'}\u003c/code\u003e가 포함될 것입니다.\u003c/p\u003e\n\u003cp\u003e이렇게 저장된 어노테이션은 다른 목적으로 사용될 수 있지만, 이 PEP를 통해 우리는 타입 힌트를 어노테이션의 선호되는 사용으로 명시적으로 권장합니다.\u003c/p\u003e\n\u003ch2\u003e거부/연기된 제안 (Rejected/Postponed Proposals)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e변수 어노테이션을 도입해야 하는가?\u003c/strong\u003e 변수 어노테이션은 PEP 484에 의해 승인된 타입 주석 형태로 거의 2년 동안 존재했습니다. 서드파티 타입 검사기(\u003ccode\u003emypy\u003c/code\u003e, \u003ccode\u003epytype\u003c/code\u003e, \u003ccode\u003ePyCharm\u003c/code\u003e 등)와 타입 검사기를 사용하는 프로젝트에서 광범위하게 사용됩니다. 그러나 주석 구문에는 배경(Rationale)에 나열된 많은 단점이 있습니다. 이 PEP는 타입 어노테이션의 필요성에 관한 것이 아니라, 그러한 어노테이션을 위한 구문이 무엇이어야 하는지에 관한 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e새로운 키워드를 도입해야 하는가?\u003c/strong\u003e 좋은 키워드를 선택하는 것은 어렵습니다. 예를 들어 \u003ccode\u003evar\u003c/code\u003e는 너무 흔한 변수 이름이므로 사용할 수 없고, 클래스 변수나 전역 변수에 사용하려면 \u003ccode\u003elocal\u003c/code\u003e이 될 수 없습니다. 둘째, 어떤 키워드를 선택하든 \u003ccode\u003e__future__\u003c/code\u003e import가 필요할 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003edef\u003c/code\u003e를 키워드로 사용해야 하는가?\u003c/strong\u003e 제안은 다음과 같았을 것입니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef primes: List[int] = []\r\ndef captain: str\n\u003c/code\u003e\u003c/pre\u003e\n이것의 문제는 \u003ccode\u003edef\u003c/code\u003e가 수십 년 동안 파이썬 프로그래머(및 도구!)에게 \"함수 정의\"를 의미한다는 것입니다. 이를 변수 정의에도 사용하는 것은 명확성을 높이지 않습니다 (물론 이것은 주관적입니다).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e함수 기반 구문을 사용해야 하는가?\u003c/strong\u003e \u003ccode\u003evar = cast(annotation[, value])\u003c/code\u003e를 사용하여 변수 타입을 어노테이션하는 것이 제안되었습니다. 이 구문은 AST에 어노테이션이 없는 것과 같은 타입 주석의 일부 문제를 완화하지만, 가독성과 같은 다른 문제를 해결하지 못하고 런타임 오버헤드를 도입할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e튜플 언패킹에 타입 어노테이션을 허용해야 하는가?\u003c/strong\u003e 이는 모호성을 유발합니다. \u003ccode\u003ex, y: T\u003c/code\u003e라는 문장이 무엇을 의미하는지 명확하지 않습니다. \u003ccode\u003ex\u003c/code\u003e와 \u003ccode\u003ey\u003c/code\u003e 모두 \u003ccode\u003eT\u003c/code\u003e 타입인가요, 아니면 \u003ccode\u003eT\u003c/code\u003e가 \u003ccode\u003ex\u003c/code\u003e와 \u003ccode\u003ey\u003c/code\u003e에 분산되는 두 개의 항목으로 구성된 튜플 타입으로 예상되는가요, 아니면 \u003ccode\u003ex\u003c/code\u003e가 \u003ccode\u003eAny\u003c/code\u003e 타입이고 \u003ccode\u003ey\u003c/code\u003e가 \u003ccode\u003eT\u003c/code\u003e 타입인가요? (후자는 함수 시그니처에서 발생할 경우의 의미입니다). 독자에게 추측을 맡기는 대신, 적어도 현재로서는 이를 금지합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e어노테이션을 위한 괄호 형식 \u003ccode\u003e(var: type)\u003c/code\u003e을 사용해야 하는가?\u003c/strong\u003e 위에서 언급한 모호성을 해결하기 위한 방안으로 \u003ccode\u003epython-ideas\u003c/code\u003e에서 제기되었지만, 그러한 구문은 복잡하고 이점이 미미하며 가독성이 좋지 않다는 이유로 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e연쇄 할당(chained assignments)에 어노테이션을 허용해야 하는가?\u003c/strong\u003e 이는 튜플 언패킹과 유사한 모호성 및 가독성 문제를 가집니다. 예를 들어:\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ex: int = y = 1\r\nz = w: int = 1\n\u003c/code\u003e\u003c/pre\u003e\n여기서 \u003ccode\u003ey\u003c/code\u003e와 \u003ccode\u003ez\u003c/code\u003e의 타입이 무엇이어야 하는지 모호합니다. 또한 두 번째 줄은 파싱하기 어렵습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ewith\u003c/code\u003e 및 \u003ccode\u003efor\u003c/code\u003e 문에 어노테이션을 허용해야 하는가?\u003c/strong\u003e \u003ccode\u003efor\u003c/code\u003e 문에서는 실제 이터러블을 식별하기 어렵게 만들고, \u003ccode\u003ewith\u003c/code\u003e 문에서는 CPython의 LL(1) 파서를 혼란스럽게 만들 수 있다는 이유로 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e함수 정의 시점에 지역 어노테이션을 평가해야 하는가?\u003c/strong\u003e 이는 어노테이션의 위치가 주변 코드와 동일한 스코프에 있음을 강력하게 시사하기 때문에 Guido에 의해 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e함수 스코프에도 변수 어노테이션을 저장해야 하는가?\u003c/strong\u003e 어노테이션을 로컬에서 사용할 수 있는 가치는 함수 호출마다 사전을 생성하고 채우는 비용을 크게 상쇄할 만큼 충분하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e할당 없이 어노테이션된 변수를 초기화해야 하는가?\u003c/strong\u003e \u003ccode\u003epython-ideas\u003c/code\u003e에서 \u003ccode\u003ex: int\u003c/code\u003e의 \u003ccode\u003ex\u003c/code\u003e를 \u003ccode\u003eNone\u003c/code\u003e 또는 Javascript의 \u003ccode\u003eundefined\u003c/code\u003e와 같은 추가적인 특별 상수로 초기화하는 것이 제안되었습니다. 그러나 언어에 또 다른 싱글턴 값을 추가하면 코드의 모든 곳에서 이를 확인해야 할 것입니다. 따라서 Guido는 이에 대해 명확히 \"No\"라고 말했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003etyping\u003c/code\u003e 모듈에 \u003ccode\u003eInstanceVar\u003c/code\u003e도 추가해야 하는가?\u003c/strong\u003e 인스턴스 변수는 클래스 변수보다 훨씬 흔합니다. 더 일반적인 사용법이 기본값이 되는 것이 마땅하므로 이는 중복됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e메서드에서만 인스턴스 변수 어노테이션을 허용해야 하는가?\u003c/strong\u003e 문제는 많은 \u003ccode\u003e__init__\u003c/code\u003e 메서드가 인스턴스 변수를 초기화하는 것 외에도 많은 작업을 수행하며, (사람이) 모든 인스턴스 변수 어노테이션을 찾기가 더 어려울 것이라는 점입니다. 때로는 \u003ccode\u003e__init__\u003c/code\u003e이 더 많은 도우미 메서드로 분할되므로 이를 추적하는 것이 더욱 어려워집니다. 인스턴스 변수 어노테이션을 클래스에 함께 배치하면 찾기 쉽고, 코드를 처음 읽는 사람에게 도움이 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e클래스 변수에 \u003ccode\u003ex: class t = v\u003c/code\u003e 구문을 사용해야 하는가?\u003c/strong\u003e 이는 더 복잡한 파서가 필요하며, \u003ccode\u003eclass\u003c/code\u003e 키워드는 단순한 구문 하이라이터를 혼란스럽게 할 것입니다. 어쨌든 \u003ccode\u003eClassVar\u003c/code\u003e는 클래스 변수를 \u003ccode\u003e__annotations__\u003c/code\u003e에 저장해야 하므로 더 간단한 구문이 선택되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eClassVar\u003c/code\u003e를 완전히 잊어야 하는가?\u003c/strong\u003e \u003ccode\u003emypy\u003c/code\u003e가 클래스 변수와 인스턴스 변수를 구별하는 방법 없이도 잘 작동하는 것처럼 보였기 때문에 제안되었습니다. 그러나 타입 검사기는 추가 정보를 가지고 유용한 작업을 수행할 수 있습니다. 예를 들어, 인스턴스를 통해 클래스 변수에 우발적인 할당(클래스 변수를 가리는 인스턴스 변수를 생성함)을 플래그할 수 있습니다. 또한 잘 알려진 위험인 변경 가능한 기본값을 가진 인스턴스 변수도 플래그할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eClassVar\u003c/code\u003e 대신 \u003ccode\u003eClassAttr\u003c/code\u003e를 사용해야 하는가?\u003c/strong\u003e \u003ccode\u003eClassVar\u003c/code\u003e가 더 나은 주된 이유는 다음과 같습니다. 메서드, 디스크립터 등 많은 것들이 클래스 속성입니다. 그러나 특정 속성만 개념적으로 클래스 변수(또는 상수)입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e어노테이션을 평가하지 않고 문자열로 처리해야 하는가?\u003c/strong\u003e 이는 항상 평가되는 함수 어노테이션의 동작과 일치하지 않을 것입니다. 비록 미래에 재고될 수 있지만, PEP 484에서는 이것이 별도의 PEP여야 한다고 결정되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e클래스 독스트링에 변수 타입을 어노테이션해야 하는가?\u003c/strong\u003e 많은 프로젝트에서 이미 다양한 독스트링 규칙을 사용하고 있으며, 종종 일관성이 부족하고 일반적으로 PEP 484 어노테이션 구문을 아직 따르지 않습니다. 또한 이것은 특별하고 정교한 파서가 필요할 것입니다. 이는 결국 PEP의 목적, 즉 서드파티 타입 검사 도구와의 협력을 저해할 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e__annotations__\u003c/code\u003e를 디스크립터로 구현해야 하는가?\u003c/strong\u003e \u003ccode\u003e__annotations__\u003c/code\u003e를 사전이나 \u003ccode\u003eNone\u003c/code\u003e이 아닌 다른 것으로 설정하는 것을 금지하기 위해 제안되었습니다. Guido는 이를 불필요하다고 거부했습니다. 대신 \u003ccode\u003e__annotations__\u003c/code\u003e가 매핑이 아닌 다른 것일 때 업데이트를 시도하면 \u003ccode\u003eTypeError\u003c/code\u003e가 발생할 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e맨몸 어노테이션(bare annotations)을 \u003ccode\u003eglobal\u003c/code\u003e 또는 \u003ccode\u003enonlocal\u003c/code\u003e과 동일하게 처리해야 하는가?\u003c/strong\u003e 거부된 제안은 함수 본문에서 할당 없는 어노테이션의 존재가 어떤 평가도 수반하지 않아야 한다고 선호했습니다. 이와 대조적으로, 이 PEP는 대상이 단일 이름보다 복잡한 경우, 해당 \"왼쪽 부분\"이 함수 본문에서 발생하는 지점에서 평가되어야 한다고 암시합니다. 이는 단순히 정의되었는지 확인하기 위함입니다. 예를 들어:\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef foo(self):\r\n    slef.name: str\n\u003c/code\u003e\u003c/pre\u003e\n여기서 \u003ccode\u003eslef\u003c/code\u003e 이름은 평가되어야 합니다. 만약 정의되지 않았다면 (이 예시에서 그럴 가능성이 높음), 런타임에 오류가 감지될 것입니다. 이는 초기값이 있을 때 발생하는 상황과 더 일치하므로 놀라움을 덜 줄 것으로 예상됩니다. (또한 대상이 \u003ccode\u003eself.name\u003c/code\u003e이었다면, 최적화 컴파일러는 \u003ccode\u003eself\u003c/code\u003e가 확실히 정의될 수 있다고 증명할 수 있는 한 \u003ccode\u003eself\u003c/code\u003e를 평가할 의무가 없다는 점에 유의하십시오).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 완전히 하위 호환됩니다.\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003ePython 3.6용 구현은 GitHub에서 찾을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1615,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 526 - Syntax for Variable Annotations\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:19:02+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>