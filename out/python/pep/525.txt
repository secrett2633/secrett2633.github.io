3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-467e37449c5a68fc.js","185","static/chunks/app/layout-b0a450f8e4964582.js"],"default"]
7:I[231,["231","static/chunks/231-467e37449c5a68fc.js","877","static/chunks/app/%5B...slug%5D/page-1f60377561abdb46.js"],""]
8:I[4080,["231","static/chunks/231-467e37449c5a68fc.js","185","static/chunks/app/layout-b0a450f8e4964582.js"],""]
4:["slug","python/pep/525","c"]
0:["WcxaIiCPz9cbpnkGvOjOK",[[["",{"children":[["slug","python/pep/525","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"525\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/525","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","link",null,{"rel":"dns-prefetch","href":"https://www.googletagmanager.com"}],["$","link",null,{"rel":"preconnect","href":"https://www.googletagmanager.com","crossOrigin":"anonymous"}],["$","link",null,{"rel":"dns-prefetch","href":"https://giscus.app"}],["$","link",null,{"rel":"preconnect","href":"https://giscus.app","crossOrigin":"anonymous"}],["$","meta",null,{"httpEquiv":"X-Content-Type-Options","content":"nosniff"}],["$","meta",null,{"name":"referrer","content":"strict-origin-when-cross-origin"}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"WebSite\",\"name\":\"secrett2633's blog\",\"url\":\"https://blog.secrett2633.cloud\",\"description\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\",\"inLanguage\":\"ko\",\"publisher\":{\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\"}}"}}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\",\"sameAs\":[\"https://github.com/secrett2633\"]}"}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":[["$","a",null,{"href":"#main-content","className":"sr-only focus:not-sr-only focus:absolute focus:z-50 focus:p-4 focus:bg-white focus:text-blue-600","children":"본문으로 건너뛰기"}],["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"id":"main-content","className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":["© ",2026," secrett2633. All rights reserved."]}]}]}]}]]}],["$","$L8",null,{"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY","strategy":"afterInteractive"}],["$","$L8",null,{"id":"gtag-init","strategy":"afterInteractive","children":"window.dataLayer = window.dataLayer || [];\n            function gtag(){dataLayer.push(arguments);}\n            gtag('js', new Date());\n            gtag('config', 'G-NE2W3CFPNY');"}]]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","role":"status","aria-label":"로딩 중","children":[["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}],["$","span",null,{"className":"sr-only","children":"로딩 중..."}]]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ddc331716d5e47a2.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L9"]]]]]
b:I[646,["231","static/chunks/231-467e37449c5a68fc.js","877","static/chunks/app/%5B...slug%5D/page-1f60377561abdb46.js"],"default"]
a:T6fcc,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0525/" target="_blank" rel="noopener noreferrer">PEP 525 - Asynchronous Generators</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 28-Jul-2016</p>
</blockquote>
<h2 id="pep-525-비동기-제너레이터-asynchronous-generators"><a href="#pep-525-비동기-제너레이터-asynchronous-generators">PEP 525 – 비동기 제너레이터 (Asynchronous Generators)</a></h2>
<h3 id="개요-abstract"><a href="#개요-abstract">개요 (Abstract)</a></h3>
<p>PEP 492는 Python 3.5에 네이티브 코루틴(native coroutines)과 <code>async</code>/<code>await</code> 문법에 대한 지원을 도입했습니다. 이 PEP 525는 비동기 제너레이터(asynchronous generators) 지원을 추가하여 Python의 비동기 기능을 확장할 것을 제안합니다.</p>
<h3 id="배경-및-목표-rationale-and-goals"><a href="#배경-및-목표-rationale-and-goals">배경 및 목표 (Rationale and Goals)</a></h3>
<p>PEP 255에서 도입된 일반 제너레이터(regular generators)는 복잡한 데이터 생산자를 우아하게 작성하고 이를 이터레이터(iterator)처럼 동작하게 하는 방법을 제공했습니다.</p>
<p>하지만 현재 비동기 이터레이션 프로토콜(<code>async for</code>)에는 이와 동등한 개념이 없습니다. 이로 인해 비동기 데이터 생산자를 작성하는 것이 불필요하게 복잡해지는데, <code>async for</code> 문에서 사용하려면 <code>__aiter__</code>와 <code>__anext__</code>를 구현하는 클래스를 정의해야 하기 때문입니다.</p>
<p>본 제안에 PEP 255의 목표와 배경을 비동기 실행 사례에 적용하면 그대로 유효합니다.</p>
<p>성능은 이 제안의 추가적인 강점입니다. 참조 구현(reference implementation) 테스트 결과, 비동기 제너레이터는 비동기 이터레이터(asynchronous iterator)로 구현된 동일한 기능보다 2배 더 빠릅니다.</p>
<p>코드 품질 개선의 예시로, 다음은 주어진 딜레이(delay)로 숫자를 출력하는 클래스입니다.</p>
<pre><code class="language-python">class Ticker:
    """Yield numbers from 0 to `to` every `delay` seconds."""
    def __init__(self, delay, to):
        self.delay = delay
        self.i = 0
        self.to = to

    def __aiter__(self):
        return self

    async def __anext__(self):
        i = self.i
        if i >= self.to:
            raise StopAsyncIteration
        self.i += 1
        if i:
            await asyncio.sleep(self.delay)
        return i
</code></pre>
<p>동일한 기능을 훨씬 간단한 비동기 제너레이터로 구현할 수 있습니다.</p>
<pre><code class="language-python">async def ticker(delay, to):
    """Yield numbers from 0 to `to` every `delay` seconds."""
    for i in range(to):
        yield i
        await asyncio.sleep(delay)
</code></pre>
<h3 id="사양-specification"><a href="#사양-specification">사양 (Specification)</a></h3>
<p>이 제안은 Python에 비동기 제너레이터 개념을 도입합니다.
이 사양은 Python의 제너레이터와 코루틴(PEP 342, PEP 380, PEP 492) 구현에 대한 지식을 전제로 합니다.</p>
<h4 id="비동기-제너레이터-asynchronous-generators"><a href="#비동기-제너레이터-asynchronous-generators">비동기 제너레이터 (Asynchronous Generators)</a></h4>
<p>Python 제너레이터는 하나 이상의 <code>yield</code> 표현식을 포함하는 모든 함수입니다.</p>
<pre><code class="language-python">def func(): # 일반 함수
    return

def genfunc(): # 제너레이터 함수
    yield
</code></pre>
<p>비동기 제너레이터를 정의하기 위해 동일한 접근 방식을 사용할 것을 제안합니다.</p>
<pre><code class="language-python">async def coro(): # 코루틴 함수
    await smth()

async def asyncgen(): # 비동기 제너레이터 함수
    await smth()
    yield 42
</code></pre>
<p>비동기 제너레이터 함수를 호출한 결과는 PEP 492에 정의된 비동기 이터레이션 프로토콜(asynchronous iteration protocol)을 구현하는 비동기 제너레이터 객체입니다.</p>
<p>비동기 제너레이터에 비어있지 않은 <code>return</code> 문이 있는 경우 <code>SyntaxError</code>가 발생합니다.</p>
<h4 id="비동기-이터레이션-프로토콜-지원-support-for-asynchronous-iteration-protocol"><a href="#비동기-이터레이션-프로토콜-지원-support-for-asynchronous-iteration-protocol">비동기 이터레이션 프로토콜 지원 (Support for Asynchronous Iteration Protocol)</a></h4>
<p>이 프로토콜은 두 가지 특별한 메서드를 구현해야 합니다.</p>
<ul>
<li>비동기 이터레이터(asynchronous iterator)를 반환하는 <code>__aiter__</code> 메서드.</li>
<li>값을 "yield"하기 위해 <code>StopIteration</code> 예외를 사용하고, 이터레이션의 끝을 알리기 위해 <code>StopAsyncIteration</code> 예외를 사용하는 <code>awaitable</code> 객체를 반환하는 <code>__anext__</code> 메서드.</li>
</ul>
<p>비동기 제너레이터는 이 두 메서드를 모두 정의합니다. 간단한 비동기 제너레이터를 수동으로 이터레이션해봅시다.</p>
<pre><code class="language-python">async def genfunc():
    yield 1
    yield 2

gen = genfunc()
assert gen.__aiter__() is gen
assert await gen.__anext__() == 1
assert await gen.__anext__() == 2
await gen.__anext__() # 이 줄은 StopAsyncIteration을 발생시킵니다.
</code></pre>
<h4 id="종료-finalization"><a href="#종료-finalization">종료 (Finalization)</a></h4>
<p>PEP 492는 코루틴을 실행하기 위해 이벤트 루프(event loop) 또는 스케줄러(scheduler)를 필요로 합니다. 비동기 제너레이터는 코루틴에서 사용하도록 설계되었으므로, 실행 및 종료(finalize)하기 위해서도 이벤트 루프가 필요합니다.</p>
<p>비동기 제너레이터는 <code>try..finally</code> 블록과 <code>async with</code>를 가질 수 있습니다. 부분적으로만 이터레이션되고 가비지 컬렉션(garbage collected) 되더라도 제너레이터가 안전하게 종료될 수 있도록 보장하는 것이 중요합니다. 예를 들어:</p>
<pre><code class="language-python">async def square_series(con, to):
    async with con.transaction():
        cursor = con.cursor(
            'SELECT generate_series(0, $1) AS i', to)
        async for row in cursor:
            yield row['i'] ** 2

async for i in square_series(con, 1000):
    if i == 100:
        break
</code></pre>
<p>위 코드는 <code>async with</code>를 사용하여 트랜잭션(transaction) 내에서 데이터베이스 커서(cursor)를 이터레이션하는 비동기 제너레이터를 정의합니다. 이 제너레이터는 <code>async for</code>를 통해 이터레이션되며, 특정 시점에서 이터레이션이 중단됩니다.</p>
<p><code>square_series()</code> 제너레이터는 가비지 컬렉션될 것이며, 제너레이터를 비동기적으로 닫는 메커니즘이 없으면 Python 인터프리터는 아무것도 할 수 없습니다.</p>
<p>이 문제를 해결하기 위해 다음을 제안합니다.</p>
<ul>
<li>
<p>비동기 제너레이터에 특별한 <code>awaitable</code>을 반환하는 <code>aclose</code> 메서드를 구현합니다. 이 메서드를 <code>await</code>하면 정지된 제너레이터에 <code>GeneratorExit</code> 예외를 발생시키고, <code>GeneratorExit</code> 또는 <code>StopAsyncIteration</code>이 발생할 때까지 이터레이션합니다.
이는 일반 Python 제너레이터에 <code>close()</code> 메서드가 하는 일과 매우 유사하지만, <code>aclose()</code>를 실행하려면 이벤트 루프가 필요하다는 점이 다릅니다.</p>
</li>
<li>
<p>비동기 제너레이터가 <code>finally</code> 블록에서 <code>yield</code> 표현식을 실행할 때 <code>RuntimeError</code>를 발생시킵니다 (그러나 <code>await</code>를 사용하는 것은 괜찮습니다).</p>
<pre><code class="language-python">async def gen():
    try:
        yield
    finally:
        await asyncio.sleep(1) # 'await' 사용 가능.
        yield # 'yield' 사용 불가,
              # 이 줄은 RuntimeError를 발생시킵니다.
</code></pre>
</li>
<li>
<p><code>sys</code> 모듈에 <code>set_asyncgen_hooks()</code> 및 <code>get_asyncgen_hooks()</code> 두 가지 새로운 메서드를 추가합니다.</p>
<p><code>sys.set_asyncgen_hooks()</code>의 아이디어는 이벤트 루프가 비동기 제너레이터의 이터레이션 및 종료를 가로챌 수 있도록 하여, 최종 사용자가 종료 문제에 신경 쓸 필요 없이 모든 것이 작동하도록 하는 것입니다.</p>
<p><code>sys.set_asyncgen_hooks()</code>는 두 가지 인수를 허용합니다.</p>
<ul>
<li><code>firstiter</code>: 비동기 제너레이터가 처음 이터레이션될 때 호출될 호출 가능 객체(callable).</li>
<li><code>finalizer</code>: 비동기 제너레이터가 가비지 컬렉션되기 직전에 호출될 호출 가능 객체.</li>
</ul>
<p>비동기 제너레이터가 처음 이터레이션될 때, 현재 <code>finalizer</code>에 대한 참조를 저장합니다.
비동기 제너레이터가 가비지 컬렉션되기 직전에 캐시된 <code>finalizer</code>를 호출합니다. <code>finalizer</code>는 이터레이션이 시작될 때 활성화된 루프와 함께 <code>aclose()</code> 호출을 스케줄링할 것이라고 가정합니다.</p>
<p>예를 들어, <code>asyncio</code>가 비동기 제너레이터의 안전한 종료를 허용하도록 수정되는 방법은 다음과 같습니다.</p>
<pre><code class="language-python"># asyncio/base_events.py
class BaseEventLoop:
    def run_forever(self):
        ...
        old_hooks = sys.get_asyncgen_hooks()
        sys.set_asyncgen_hooks(finalizer=self._finalize_asyncgen)
        try:
            ...
        finally:
            sys.set_asyncgen_hooks(*old_hooks)
        ...

    def _finalize_asyncgen(self, gen):
        self.create_task(gen.aclose())
</code></pre>
<p>두 번째 인수 <code>firstiter</code>는 이벤트 루프가 자체 제어하에 인스턴스화된 비동기 제너레이터의 약한 집합(weak set)을 유지 관리할 수 있도록 합니다. 이를 통해 모든 열려있는 제너레이터를 안전하게 종료하고 이벤트 루프를 닫는 "종료(shutdown)" 메커니즘을 구현할 수 있습니다.</p>
<p><code>sys.set_asyncgen_hooks()</code>는 스레드별(thread-specific)이므로, 여러 이벤트 루프가 병렬 스레드에서 안전하게 사용할 수 있습니다.</p>
<p><code>sys.get_asyncgen_hooks()</code>는 <code>firstiter</code> 및 <code>finalizer</code> 필드를 가진 namedtuple과 유사한 구조를 반환합니다.</p>
</li>
</ul>
<h4 id="asyncio"><a href="#asyncio"><code>asyncio</code></a></h4>
<p><code>asyncio</code> 이벤트 루프는 <code>sys.set_asyncgen_hooks()</code> API를 사용하여 스케줄링된 모든 비동기 제너레이터의 약한 집합을 유지하고, 제너레이터가 가비지 컬렉션될 시점에 <code>aclose()</code> 코루틴 메서드를 스케줄링합니다.</p>
<p><code>asyncio</code> 프로그램이 스케줄링된 모든 비동기 제너레이터를 안정적으로 종료할 수 있도록 하기 위해, 새로운 이벤트 루프 코루틴 메서드 <code>loop.shutdown_asyncgens()</code>를 추가할 것을 제안합니다. 이 메서드는 현재 열려있는 모든 비동기 제너레이터를 <code>aclose()</code> 호출로 닫도록 스케줄링합니다.</p>
<p><code>loop.shutdown_asyncgens()</code> 메서드를 호출한 후, 이벤트 루프는 새로운 비동기 제너레이터가 처음 이터레이션될 때마다 경고를 발생시킬 것입니다. 이는 모든 비동기 제너레이터를 종료하도록 요청한 후에는 프로그램이 새로운 비동기 제너레이터를 이터레이션하는 코드를 실행해서는 안 된다는 아이디어입니다.</p>
<p><code>shutdown_asyncgens</code> 코루틴을 사용하는 예시입니다.</p>
<pre><code class="language-python">try:
    loop.run_forever()
finally:
    loop.run_until_complete(loop.shutdown_asyncgens())
    loop.close()
</code></pre>
<h4 id="비동기-제너레이터-객체-asynchronous-generator-object"><a href="#비동기-제너레이터-객체-asynchronous-generator-object">비동기 제너레이터 객체 (Asynchronous Generator Object)</a></h4>
<p>이 객체는 표준 Python 제너레이터 객체를 모델로 합니다. 본질적으로 비동기 제너레이터의 동작은 동기 제너레이터의 동작을 복제하도록 설계되었으며, 유일한 차이점은 API가 비동기라는 점입니다.</p>
<p>다음 메서드와 속성이 정의됩니다.</p>
<ul>
<li>
<p><code>agen.__aiter__()</code>: <code>agen</code>을 반환합니다.</p>
</li>
<li>
<p><code>agen.__anext__()</code>: <code>await</code>될 때 하나의 비동기 제너레이터 이터레이션을 수행하는 <code>awaitable</code>을 반환합니다.</p>
</li>
<li>
<p><code>agen.asend(val)</code>: <code>val</code> 객체를 <code>agen</code> 제너레이터로 푸시하는 <code>awaitable</code>을 반환합니다. <code>agen</code>이 아직 이터레이션되지 않은 경우, <code>val</code>은 <code>None</code>이어야 합니다.</p>
<p>예시:</p>
<pre><code class="language-python">async def gen():
    await asyncio.sleep(0.1)
    v = yield 42
    print(v)
    await asyncio.sleep(0.2)

g = gen()
await g.asend(None) # 0.1초 동안 sleep 후 42를 반환합니다.
await g.asend('hello') # 'hello'를 출력하고
                       # StopAsyncIteration을 발생시킵니다.
                       # (0.2초 동안 sleep 후)
</code></pre>
</li>
<li>
<p><code>agen.athrow(typ, [val, [tb]])</code>: 예외를 <code>agen</code> 제너레이터로 던지는 <code>awaitable</code>을 반환합니다.</p>
<p>예시:</p>
<pre><code class="language-python">async def gen():
    try:
        await asyncio.sleep(0.1)
        yield 'hello'
    except ZeroDivisionError:
        await asyncio.sleep(0.2)
        yield 'world'

g = gen()
v = await g.asend(None)
print(v) # 0.1초 동안 sleep 후 'hello'를 출력합니다.
v = await g.athrow(ZeroDivisionError)
print(v) # 0.2초 동안 sleep 후 'world'를 출력합니다.
</code></pre>
</li>
<li>
<p><code>agen.aclose()</code>: <code>GeneratorExit</code> 예외를 제너레이터로 던지는 <code>awaitable</code>을 반환합니다. <code>awaitable</code>은 <code>agen</code>이 예외를 처리했다면 <code>yield</code>된 값을 반환할 수 있고, 그렇지 않으면 <code>agen</code>이 닫히고 예외는 호출자(caller)에게 다시 전파됩니다.</p>
</li>
<li>
<p><code>agen.__name__</code> 및 <code>agen.__qualname__</code>: 읽고 쓸 수 있는 이름 및 정규화된 이름(qualified name) 속성입니다.</p>
</li>
<li>
<p><code>agen.ag_await</code>: <code>agen</code>이 현재 <code>await</code>하고 있는 객체 또는 <code>None</code>입니다. 이는 제너레이터의 <code>gi_yieldfrom</code> 및 코루틴의 <code>cr_await</code>와 유사합니다.</p>
</li>
<li>
<p><code>agen.ag_frame</code>, <code>agen.ag_running</code>, <code>agen.ag_code</code>: 표준 제너레이터의 유사한 속성과 동일한 방식으로 정의됩니다.</p>
</li>
</ul>
<p><code>StopIteration</code>과 <code>StopAsyncIteration</code>은 비동기 제너레이터 밖으로 전파되지 않으며, <code>RuntimeError</code>로 대체됩니다.</p>
<h4 id="구현-세부-정보-implementation-details"><a href="#구현-세부-정보-implementation-details">구현 세부 정보 (Implementation Details)</a></h4>
<p>비동기 제너레이터 객체(<code>PyAsyncGenObject</code>)는 <code>PyGenObject</code>와 구조 레이아웃을 공유합니다. 또한, 참조 구현은 세 가지 새로운 객체를 도입합니다.</p>
<ul>
<li><code>PyAsyncGenASend</code>: <code>__anext__</code> 및 <code>asend()</code> 메서드를 구현하는 <code>awaitable</code> 객체입니다.</li>
<li><code>PyAsyncGenAThrow</code>: <code>athrow()</code> 및 <code>aclose()</code> 메서드를 구현하는 <code>awaitable</code> 객체입니다.</li>
<li><code>_PyAsyncGenWrappedValue</code>: 비동기 제너레이터에서 직접 <code>yield</code>된 모든 객체는 암시적으로 이 구조로 묶입니다. 이를 통해 제너레이터 구현은 일반 이터레이션 프로토콜을 사용하여 <code>yield</code>된 객체와 비동기 이터레이션 프로토콜을 사용하여 <code>yield</code>된 객체를 분리할 수 있습니다.</li>
</ul>
<p><code>PyAsyncGenASend</code>와 <code>PyAsyncGenAThrow</code>는 <code>awaitable</code> 객체이며(<code>__await__</code> 메서드가 <code>self</code>를 반환함), 코루틴과 유사한 객체입니다(<code>__iter__</code>, <code>__next__</code>, <code>send()</code>, <code>throw()</code> 메서드를 구현함). 본질적으로 이들은 비동기 제너레이터가 어떻게 이터레이션되는지를 제어합니다.</p>
<h5 id="pyasyncgenasend-및-pyasyncgenathrow"><a href="#pyasyncgenasend-및-pyasyncgenathrow"><code>PyAsyncGenASend</code> 및 <code>PyAsyncGenAThrow</code></a></h5>
<p><code>PyAsyncGenASend</code>는 <code>__anext__</code> 및 <code>asend()</code> 메서드를 구동하고 비동기 이터레이션 프로토콜을 구현하는 코루틴과 유사한 객체입니다.
<code>agen.asend(val)</code> 및 <code>agen.__anext__()</code>는 <code>PyAsyncGenASend</code> 인스턴스(부모 <code>agen</code> 객체에 대한 참조를 유지)를 반환합니다.</p>
<p>데이터 흐름은 다음과 같이 정의됩니다.</p>
<ul>
<li><code>PyAsyncGenASend.send(val)</code>이 처음 호출되면, <code>val</code>은 부모 <code>agen</code> 객체로 푸시됩니다(<code>PyGenObject</code>의 기존 기능을 사용).</li>
<li><code>PyAsyncGenASend</code> 객체에 대한 후속 이터레이션은 <code>None</code>을 <code>agen</code>으로 푸시합니다.</li>
<li><code>_PyAsyncGenWrappedValue</code> 객체가 <code>yield</code>되면, 언박싱(unboxed)되고, 래핑되지 않은(unwrapped) 값을 인수로 하는 <code>StopIteration</code> 예외가 발생합니다.</li>
<li><code>PyAsyncGenASend.throw(*exc)</code>가 처음 호출되면, <code>*exc</code>가 부모 <code>agen</code> 객체로 던져집니다.</li>
<li><code>PyAsyncGenASend</code> 객체에 대한 후속 이터레이션은 <code>None</code>을 <code>agen</code>으로 푸시합니다.</li>
<li><code>_PyAsyncGenWrappedValue</code> 객체가 <code>yield</code>되면, 언박싱되고, 래핑되지 않은 값을 인수로 하는 <code>StopIteration</code> 예외가 발생합니다.</li>
<li>비동기 제너레이터의 <code>return</code> 문은 <code>StopAsyncIteration</code> 예외를 발생시키며, 이는 <code>PyAsyncGenASend.send()</code> 및 <code>PyAsyncGenASend.throw()</code> 메서드를 통해 전파됩니다.</li>
</ul>
<p><code>PyAsyncGenAThrow</code>는 <code>PyAsyncGenASend</code>와 매우 유사합니다. 유일한 차이점은 <code>PyAsyncGenAThrow.send()</code>가 처음 호출될 때 부모 <code>agen</code> 객체에 예외를 던진다는 것입니다(값을 푸시하는 대신).</p>
<h4 id="새로운-표준-라이브러리-함수-및-타입-new-standard-library-functions-and-types"><a href="#새로운-표준-라이브러리-함수-및-타입-new-standard-library-functions-and-types">새로운 표준 라이브러리 함수 및 타입 (New Standard Library Functions and Types)</a></h4>
<ul>
<li><code>types.AsyncGeneratorType</code> – 비동기 제너레이터 객체의 타입입니다.</li>
<li><code>sys.set_asyncgen_hooks()</code> 및 <code>sys.get_asyncgen_hooks()</code> 메서드는 이벤트 루프에서 비동기 제너레이터의 종료자(finalizers) 및 이터레이션 가로채기(interceptors)를 설정하는 데 사용됩니다.</li>
<li><code>inspect.isasyncgen()</code> 및 <code>inspect.isasyncgenfunction()</code> 인트로스펙션(introspection) 함수.</li>
<li><code>asyncio</code> 이벤트 루프의 새로운 메서드: <code>loop.shutdown_asyncgens()</code>.</li>
<li>새로운 <code>collections.abc.AsyncGenerator</code> 추상 기본 클래스(abstract base class).</li>
</ul>
<h4 id="하위-호환성-backwards-compatibility"><a href="#하위-호환성-backwards-compatibility">하위 호환성 (Backwards Compatibility)</a></h4>
<p>이 제안은 완벽하게 하위 호환됩니다.
Python 3.5에서는 <code>yield</code> 표현식이 포함된 <code>async def</code> 함수를 정의하는 것이 <code>SyntaxError</code>이므로, 3.6에서 비동기 제너레이터를 도입하는 것은 안전합니다.</p>
<h4 id="성능-performance"><a href="#성능-performance">성능 (Performance)</a></h4>
<h5 id="일반-제너레이터-regular-generators"><a href="#일반-제너레이터-regular-generators">일반 제너레이터 (Regular Generators)</a></h5>
<p>일반 제너레이터에는 성능 저하가 없습니다. 다음 마이크로 벤치마크는 CPython에서 비동기 제너레이터 유무에 관계없이 동일한 속도로 실행됩니다.</p>
<pre><code class="language-python">def gen():
    i = 0
    while i &#x3C; 100000000:
        yield i
        i += 1
list(gen())
</code></pre>
<h5 id="비동기-이터레이터-대비-개선점-improvements-over-asynchronous-iterators"><a href="#비동기-이터레이터-대비-개선점-improvements-over-asynchronous-iterators">비동기 이터레이터 대비 개선점 (Improvements over asynchronous iterators)</a></h5>
<p>다음 마이크로 벤치마크는 비동기 제너레이터가 순수 Python으로 구현된 비동기 이터레이터보다 약 2.3배 빠름을 보여줍니다.</p>
<pre><code class="language-python">N = 10 ** 7

async def agen():
    for i in range(N):
        yield i

class AIter:
    def __init__(self):
        self.i = 0
    def __aiter__(self):
        return self
    async def __anext__(self):
        i = self.i
        if i >= N:
            raise StopAsyncIteration
        self.i += 1
        return i
</code></pre>
<h3 id="설계-고려-사항-design-considerations"><a href="#설계-고려-사항-design-considerations">설계 고려 사항 (Design Considerations)</a></h3>
<h4 id="aiter-및-anext-내장-함수-aiter-and-anext-builtins"><a href="#aiter-및-anext-내장-함수-aiter-and-anext-builtins"><code>aiter()</code> 및 <code>anext()</code> 내장 함수 (aiter() and anext() builtins)</a></h4>
<p>원래 PEP 492는 <code>__aiter__</code>를 <code>awaitable</code> 객체를 반환해야 하는 메서드로 정의하여 비동기 이터레이터를 생성하도록 했습니다.
그러나 CPython 3.5.2에서 <code>__aiter__</code>는 비동기 이터레이터를 직접 반환하도록 재정의되었습니다. 하위 호환성을 깨는 것을 피하기 위해, Python 3.6에서는 두 가지 방식 모두를 지원하며, <code>__aiter__</code>가 여전히 <code>awaitable</code>을 반환할 수 있지만 <code>DeprecationWarning</code>이 발행되도록 결정되었습니다.</p>
<p>Python 3.6에서 <code>__aiter__</code>의 이러한 이중적인 특성 때문에 <code>aiter()</code> 내장 함수의 동기 구현을 추가할 수 없습니다. 따라서 Python 3.7까지 기다릴 것을 제안합니다.</p>
<h4 id="비동기-리스트딕셔너리세트-컴프리헨션-asynchronous-listdictset-comprehensions"><a href="#비동기-리스트딕셔너리세트-컴프리헨션-asynchronous-listdictset-comprehensions">비동기 리스트/딕셔너리/세트 컴프리헨션 (Asynchronous list/dict/set comprehensions)</a></h4>
<p>비동기 컴프리헨션(comprehensions)의 문법은 비동기 제너레이터 메커니즘과 관련이 없으며, 별도의 PEP에서 고려되어야 합니다.</p>
<h4 id="비동기-yield-from-asynchronous-yield-from"><a href="#비동기-yield-from-asynchronous-yield-from">비동기 <code>yield from</code> (Asynchronous yield from)</a></h4>
<p>비동기 제너레이터에 <code>yield from</code> 지원을 구현하는 것이 이론적으로 가능하지만, 제너레이터 구현을 심각하게 재설계해야 합니다.
<code>yield from</code>은 비동기 제너레이터에 덜 중요합니다. 코루틴 위에 다른 코루틴 프로토콜을 구현하는 메커니즘을 제공할 필요가 없기 때문입니다. 비동기 제너레이터를 구성하기 위해 간단한 <code>async for</code> 루프를 사용할 수 있습니다.</p>
<pre><code class="language-python">async def g1():
    yield 1
    yield 2

async def g2():
    async for v in g1():
        yield v
</code></pre>
<h4 id="asend-및-athrow-메서드가-필요한-이유-why-the-asend-and-athrow-methods-are-necessary"><a href="#asend-및-athrow-메서드가-필요한-이유-why-the-asend-and-athrow-methods-are-necessary"><code>asend()</code> 및 <code>athrow()</code> 메서드가 필요한 이유 (Why the asend() and athrow() methods are necessary)</a></h4>
<p>이 메서드들은 <code>contextlib.contextmanager</code>와 유사한 개념을 비동기 제너레이터를 사용하여 구현할 수 있게 합니다. 예를 들어, 제안된 설계로 다음 패턴을 구현할 수 있습니다.</p>
<pre><code class="language-python">@async_context_manager
async def ctx():
    await open()
    try:
        yield
    finally:
        await close()

async with ctx():
    await ...
</code></pre>
<p>또 다른 이유는 <code>__anext__</code> 객체에서 반환된 객체를 사용하여 비동기 제너레이터로 데이터를 푸시하고 예외를 던지는 것이 가능하지만, 이를 올바르게 수행하기는 어렵다는 것입니다. 명시적인 <code>asend()</code> 및 <code>athrow()</code>를 추가하면 이를 안전하게 수행할 수 있는 길을 열어줄 것입니다.</p>
<p>구현 측면에서 <code>asend()</code>는 <code>__anext__</code>의 약간 더 일반적인 버전이며, <code>athrow()</code>는 <code>aclose()</code>와 매우 유사합니다. 따라서 비동기 제너레이터에 이러한 메서드를 정의해도 추가적인 복잡성은 발생하지 않습니다.</p>
<h3 id="예시-example"><a href="#예시-example">예시 (Example)</a></h3>
<p>현재 참조 구현을 사용한 작동 예시 (0부터 9까지의 숫자를 1초 간격으로 출력합니다):</p>
<pre><code class="language-python">async def ticker(delay, to):
    for i in range(to):
        yield i
        await asyncio.sleep(delay)

async def run():
    async for i in ticker(1, 10):
        print(i)

import asyncio
loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(run())
finally:
    loop.close()
</code></pre>
<h3 id="승인-acceptance"><a href="#승인-acceptance">승인 (Acceptance)</a></h3>
<p>PEP 525는 2016년 9월 6일 Guido에 의해 승인되었습니다.</p>
<h3 id="구현-implementation"><a href="#구현-implementation">구현 (Implementation)</a></h3>
<p>구현은 이슈 28003에서 추적됩니다. 참조 구현 Git 저장소는에서 확인할 수 있습니다.</p>
<h3 id="참고-자료-references"><a href="#참고-자료-references">참고 자료 (References)</a></h3>
<p><a href="https://github.com/1st1/cpython/tree/async_gen" target="_blank" rel="noopener noreferrer">https://github.com/1st1/cpython/tree/async_gen</a>
<a href="https://mail.python.org/pipermail/python-dev/2016-September/146267.html" target="_blank" rel="noopener noreferrer">https://mail.python.org/pipermail/python-dev/2016-September/146267.html</a>
<a href="http://bugs.python.org/issue28003" target="_blank" rel="noopener noreferrer">http://bugs.python.org/issue28003</a></p>
<h3 id="감사-acknowledgments"><a href="#감사-acknowledgments">감사 (Acknowledgments)</a></h3>
<p>이 PEP에 대한 피드백, 코드 검토 및 토론에 대해 Guido van Rossum, Victor Stinner, Elvis Pranskevichus, Nathaniel Smith, Łukasz Langa, Andrew Svetlov 및 기타 여러 사람들에게 감사드립니다.</p>
<h3 id="저작권-copyright"><a href="#저작권-copyright">저작권 (Copyright)</a></h3>
<p>이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.</p>
<blockquote>
<p>⚠️ ** 알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BlogPosting\",\"headline\":\"[Final] PEP 525 - Asynchronous Generators\",\"description\":\"Python Enhancement Proposal 525: 'Asynchronous Generators'에 대한 한국어 번역입니다.\",\"url\":\"https://blog.secrett2633.cloud/python/pep/525\",\"datePublished\":\"2025-09-26T14:17:46.000Z\",\"dateModified\":\"2025-09-26T14:17:46.000Z\",\"author\":{\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\"},\"publisher\":{\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\"},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://blog.secrett2633.cloud/python/pep/525\"},\"image\":\"https://blog.secrett2633.cloud/og-default.png\",\"isAccessibleForFree\":true,\"inLanguage\":\"ko\",\"wordCount\":1905,\"articleSection\":\"Python\",\"keywords\":\"Python, PEP, Translation\"}"}}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BreadcrumbList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"홈\",\"item\":\"https://blog.secrett2633.cloud/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"[Final] PEP 525 - Asynchronous Generators\",\"item\":\"https://blog.secrett2633.cloud/python/pep/525\"}]}"}}],["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","aria-label":"카테고리 네비게이션","children":[["$","div","Backend",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","$L7",null,{"href":"/backend/django","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","$L7",null,{"href":"/backend/logging","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","$L7",null,{"href":"/python/pep","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","$L7",null,{"href":"/ai/llm","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","$L7",null,{"href":"/ai/review","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",2728,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","$L7",null,{"href":"/devops/nginx","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","$L7",null,{"href":"/devops/docker","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","$L7",null,{"href":"/devops/safeline","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","$L7",null,{"href":"/devops/jenkins","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","$L7",null,{"href":"/devops/github-actions","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","$L7",null,{"href":"/devops/aws","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","$L7",null,{"href":"/etc/me","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","$L7",null,{"href":"/etc/chrome-extension","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","div",null,{"className":"flex-1","children":[["$","nav",null,{"aria-label":"breadcrumb","className":"text-sm text-gray-500 mb-4","children":["$","ol",null,{"className":"flex flex-wrap items-center gap-1","children":[["$","li",null,{"children":["$","$L7",null,{"href":"/","className":"hover:text-gray-700","children":"홈"}]}],[["$","li","/python/pep/525",{"className":"flex items-center gap-1","children":[["$","span",null,{"aria-hidden":"true","children":"/"}],["$","span",null,{"className":"text-gray-900","aria-current":"page","children":"[Final] PEP 525 - Asynchronous Generators"}]]}]]]}]}],["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 525 - Asynchronous Generators"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 23:17:46+0900","children":"2025년 9월 26일"}],["$","time",null,{"className":"ml-4","dateTime":"2025-09-26T14:17:46.000Z","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$a"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","span",null,{"className":"text-sm font-medium text-gray-900 mb-2 block","children":"태그"}],[["$","$L7","Python",{"href":"/tags/Python","className":"page__taxonomy-item","children":["#","Python"]}],["$","$L7","PEP",{"href":"/tags/PEP","className":"page__taxonomy-item","children":["#","PEP"]}],["$","$L7","Translation",{"href":"/tags/Translation","className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}],["$","$Lb",null,{"postPermalink":"/python/pep/525","postId":"2025-09-26-pep-0525-asynchronous-generators"}],["$","section",null,{"className":"mt-12 border-t border-gray-200 pt-8","children":[["$","h3",null,{"className":"text-base font-semibold text-gray-900 mb-4","children":["Python"," 의 다른글"]}],["$","ul",null,{"className":"space-y-2 text-sm","children":[["$","li",null,{"className":"text-gray-500","children":["이전글"," ",["$","$L7",null,{"href":"/python/pep/524","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Final] PEP 524 - Make os.urandom() blocking on Linux"}]]}],["$","li",null,{"className":"text-gray-900 font-semibold","children":["현재글 : ","[Final] PEP 525 - Asynchronous Generators"]}],["$","li",null,{"className":"text-gray-500","children":["다음글"," ",["$","$L7",null,{"href":"/python/pep/526","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Final] PEP 526 - Syntax for Variable Annotations"}]]}]]}]]}]]}]]}]]}]]
9:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"[Final] PEP 525 - Asynchronous Generators - secrett2633's blog"}],["$","meta","3",{"name":"description","content":"Python Enhancement Proposal 525: 'Asynchronous Generators'에 대한 한국어 번역입니다."}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","link","5",{"rel":"manifest","href":"/manifest.json","crossOrigin":"use-credentials"}],["$","meta","6",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","7",{"name":"creator","content":"secrett2633"}],["$","meta","8",{"name":"publisher","content":"secrett2633"}],["$","meta","9",{"name":"robots","content":"index, follow"}],["$","meta","10",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","11",{"rel":"canonical","href":"https://blog.secrett2633.cloud/python/pep/525"}],["$","meta","12",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","13",{"property":"og:title","content":"[Final] PEP 525 - Asynchronous Generators"}],["$","meta","14",{"property":"og:description","content":"Python Enhancement Proposal 525: 'Asynchronous Generators'에 대한 한국어 번역입니다."}],["$","meta","15",{"property":"og:url","content":"https://blog.secrett2633.cloud/python/pep/525"}],["$","meta","16",{"property":"og:type","content":"article"}],["$","meta","17",{"property":"article:published_time","content":"2025-09-26T14:17:46.000Z"}],["$","meta","18",{"property":"article:modified_time","content":"2025-09-26T14:17:46.000Z"}],["$","meta","19",{"property":"article:author","content":"secrett2633"}],["$","meta","20",{"property":"article:section","content":"Python"}],["$","meta","21",{"property":"article:tag","content":"Python"}],["$","meta","22",{"property":"article:tag","content":"PEP"}],["$","meta","23",{"property":"article:tag","content":"Translation"}],["$","meta","24",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","25",{"name":"twitter:creator","content":"@secrett2633"}],["$","meta","26",{"name":"twitter:title","content":"[Final] PEP 525 - Asynchronous Generators"}],["$","meta","27",{"name":"twitter:description","content":"Python Enhancement Proposal 525: 'Asynchronous Generators'에 대한 한국어 번역입니다."}],["$","link","28",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","29",{"name":"next-size-adjust"}]]
1:null
