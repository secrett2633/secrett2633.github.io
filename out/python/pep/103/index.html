<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Withdrawn] PEP 103 - Collecting information about git</h1><div class="page__meta"><time dateTime="2025-09-26 16:06:44+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0103/">PEP 103 - Collecting information about git</a></p>
<p><strong>상태:</strong> Withdrawn | <strong>유형:</strong> Informational | <strong>작성일:</strong> 01-Jun-2015</p>
</blockquote>
<h2>PEP 103 – Git 정보 수집 (철회됨)</h2>
<p><strong>작성자:</strong> Oleg Broytman
<strong>상태:</strong> 철회됨 (Withdrawn)
<strong>유형:</strong> 정보성 (Informational)
<strong>생성일:</strong> 2015년 6월 1일
<strong>이력:</strong> 2015년 9월 12일</p>
<hr>
<h3>개요 (Abstract)</h3>
<p>이 정보성 PEP는 Git에 대한 정보를 수집합니다. Git에 대한 많은 문서가 이미 존재하므로, 이 PEP는 Python 개발과 더 관련 있는 복잡한 문제, 시나리오 및 예시에 집중합니다.</p>
<p>향후 이 PEP는 Mercurial에서 Git으로 Python 개발을 마이그레이션하는 데 도움이 되도록 Mercurial과 Git 시나리오의 등가성에 대한 정보를 수집하여 확장될 계획이었습니다.</p>
<p>PEP의 저자는 현재 Mercurial에서 Git으로 Python 개발을 마이그레이션하는 Process PEP를 작성할 계획이 없습니다.</p>
<p><strong>중요:</strong> 이 PEP는 철회되었습니다. 너무 일반적이며 Python 개발과 직접적인 관련이 적습니다. 더 이상 업데이트되지 않습니다. 내용은 Python Wiki로 옮겨졌으며, 이후 업데이트는 위키에서 이루어집니다.</p>
<h3>문서 (Documentation)</h3>
<p>Git은 온라인과 오프라인 모두 풍부한 문서를 제공합니다.</p>
<h4>초보자를 위한 문서 (Documentation for starters)</h4>
<ul>
<li>Git Tutorial: part 1, part 2</li>
<li>Git User's manual</li>
<li>Everyday GIT With 20 Commands Or So</li>
<li>Git workflows</li>
</ul>
<h4>고급 문서 (Advanced documentation)</h4>
<ul>
<li>Git Magic (다양한 번역본 제공)</li>
<li>Pro Git (The Book about git): Amazon에서 구매하거나 PDF, mobi, ePub 형식으로 다운로드 가능하며, 다양한 언어로 번역되어 있습니다.</li>
<li>Git Wiki</li>
<li>Git Buch (독일어)</li>
</ul>
<h4>오프라인 문서 (Offline documentation)</h4>
<p>Git은 내장된 도움말 기능을 제공합니다: <code>git help $TOPIC</code>을 실행하여 확인할 수 있습니다. 예를 들어, <code>git help git</code> 또는 <code>git help help</code>를 실행할 수 있습니다.</p>
<h3>빠른 시작 (Quick start)</h3>
<h4>다운로드 및 설치 (Download and installation)</h4>
<ul>
<li><strong>Unix 사용자:</strong> 패키지 관리자를 사용하여 다운로드 및 설치합니다.</li>
<li><strong>Microsoft Windows:</strong> git-for-windows를 다운로드합니다.</li>
<li><strong>MacOS X:</strong> XCode와 함께 설치된 Git을 사용하거나, MacPorts 또는 git-osx-installer에서 다운로드하거나, Homebrew (<code>brew install git</code>)를 통해 설치합니다.</li>
<li><code>git-cola</code> (repository): Python으로 작성된 GPL 라이선스 Git GUI입니다 (Linux, Windows, MacOS X).</li>
<li><code>TortoiseGit</code>: TortoiseSVN 기반의 Windows Shell 인터페이스 Git 클라이언트입니다 (오픈 소스).</li>
</ul>
<h4>초기 설정 (Initial configuration)</h4>
<p>Git은 모든 커밋(commit)에 작성자(author) 및 커미터(committer)의 이름/이메일을 저장하므로, 실제 이름과 선호하는 이메일을 설정하는 것이 중요합니다.</p>
<pre><code class="language-bash">$ git config --global user.name "User Name"
$ git config --global user.email user.name@example.org
</code></pre>
<h3>이 PEP의 예시 (Examples in this PEP)</h3>
<p>이 PEP의 Git 명령 예시는 다음과 같은 가정을 따릅니다. 사용자는 <code>python</code>이라는 로컬 저장소(local repository)에서 작업하며, <code>origin</code>이라는 상위(upstream) 원격 저장소(remote repo)를 가지고 있습니다. 로컬 저장소에는 <code>v1</code>과 <code>master</code> 두 개의 브랜치(branch)가 있습니다. 대부분의 예시에서는 현재 체크아웃(checkout)된 브랜치가 <code>master</code>입니다. 즉, 다음과 같은 작업을 수행했다고 가정합니다.</p>
<pre><code class="language-bash">$ git clone https://git.python.org/python.git
$ cd python
$ git branch v1 origin/v1
</code></pre>
<p>첫 번째 명령은 원격 저장소를 <code>python</code>이라는 로컬 디렉토리로 클론(clone)하고, 새로운 로컬 브랜치 <code>master</code>를 생성하며, <code>remotes/origin/master</code>를 해당 브랜치의 상위 원격 추적 브랜치(upstream remote-tracking branch)로 설정하고 작업 디렉토리로 체크아웃합니다.</p>
<p>마지막 명령은 새로운 로컬 브랜치 <code>v1</code>을 생성하고 <code>remotes/origin/v1</code>을 해당 브랜치의 상위 원격 추적 브랜치로 설정합니다.</p>
<p>다음 명령으로 동일한 결과를 얻을 수 있습니다.</p>
<pre><code class="language-bash">$ git clone -b v1 https://git.python.org/python.git
$ cd python
$ git checkout --track origin/master
</code></pre>
<p>마지막 명령은 새로운 로컬 브랜치 <code>master</code>를 생성하고 <code>remotes/origin/master</code>를 해당 브랜치의 상위 원격 추적 브랜치로 설정하며 작업 디렉토리로 체크아웃합니다.</p>
<h3>브랜치와 브랜치 (Branches and branches)</h3>
<p>Git 용어는 혼란스러울 수 있습니다. 예를 들어, "branch"라는 용어는 Git에서 두 가지 의미를 가집니다. 하나는 커밋(commit)들의 지향성 있는 선(Directed line of commits, 병합(merge)을 포함할 수 있음)이고, 다른 하나는 커밋들의 선에 할당된 레이블(label) 또는 포인터(pointer)입니다. 커밋 자체에 대해 이야기하는지, 아니면 커밋의 레이블에 대해 이야기하는지 구별하는 것이 중요합니다. 커밋들의 선은 그 자체로 이름이 없으며 일반적으로 길어지고 병합될 뿐입니다. 반면, 레이블은 자유롭게 생성, 이동, 이름 변경 및 삭제될 수 있습니다.</p>
<h3>원격 저장소 및 원격 브랜치 (Remote repositories and remote branches)</h3>
<p>원격 추적 브랜치(remote-tracking branches)는 로컬 저장소에 있는 브랜치(커밋에 대한 포인터)입니다. 이는 Git(및 사용자)이 어떤 브랜치와 커밋이 어떤 원격 저장소에서 풀(pull)되거나 푸시(push)되었는지 기억하기 위한 것입니다 (여러 원격에서 풀하거나 푸시할 수 있습니다). 원격 추적 브랜치는 <code>remotes/$REMOTE</code> 네임스페이스 아래에 존재합니다 (예: <code>remotes/origin/master</code>).</p>
<p>원격 추적 브랜치의 상태를 보려면 다음을 실행합니다.</p>
<pre><code class="language-bash">$ git branch -rv
</code></pre>
<p>로컬 및 원격 추적 브랜치(및 태그)가 가리키는 커밋을 보려면 다음을 실행합니다.</p>
<pre><code class="language-bash">$ git log --decorate
</code></pre>
<p>원격 추적 브랜치에서는 직접 개발하지 않습니다. 원격 브랜치를 상위로 하는 로컬 브랜치를 생성하고 해당 로컬 브랜치에서 개발을 수행합니다. 푸시 시 Git은 커밋을 원격 저장소로 푸시하고 원격 추적 브랜치를 업데이트하며, 풀 시 Git은 원격 저장소에서 커밋을 페치(fetch)하고 원격 추적 브랜치를 업데이트하며 로컬 브랜치를 Fast-forward, 병합 또는 리베이스(rebase)합니다.</p>
<p>다음과 같이 초기 클론을 수행할 때:</p>
<pre><code class="language-bash">$ git clone -b v1 https://git.python.org/python.git
</code></pre>
<p>Git은 원격 저장소 <code>https://git.python.org/python.git</code>을 <code>python</code> 디렉토리로 클론하고, <code>origin</code>이라는 원격을 생성하며, 원격 추적 브랜치를 생성하고, 로컬 브랜치 <code>v1</code>을 생성하며, 이를 상위 <code>remotes/origin/v1</code> 브랜치를 추적하도록 구성하고 <code>v1</code>을 작업 디렉토리로 체크아웃합니다.</p>
<p><code>git status --branch</code> 및 <code>git branch --verbose</code>와 같은 일부 명령은 로컬 브랜치와 원격 브랜치 간의 차이를 보고합니다. 이들은 로컬 저장소의 원격 추적 브랜치와만 비교하며, 해당 원격 추적 브랜치의 상태는 오래되었을 수 있음을 기억하십시오. 원격 추적 브랜치를 업데이트하려면 원격 저장소에서 커밋을 페치하고 병합(또는 리베이스)하거나, 로컬 브랜치를 업데이트하지 않고 원격 추적 브랜치만 업데이트해야 합니다.</p>
<h3>로컬 및 원격 추적 브랜치 업데이트 (Updating local and remote-tracking branches)</h3>
<p>로컬 브랜치를 업데이트하지 않고 원격 추적 브랜치를 업데이트하려면 <code>git remote update [$REMOTE...]</code>를 실행합니다. 예를 들어:</p>
<pre><code class="language-bash">$ git remote update
$ git remote update origin
</code></pre>
<h3>Fetch 및 Pull (Fetch and pull)</h3>
<p>다음 두 명령 사이에는 큰 차이가 있습니다.</p>
<pre><code class="language-bash">$ git fetch $REMOTE $BRANCH
</code></pre>
<pre><code class="language-bash">$ git fetch $REMOTE $BRANCH:$BRANCH
</code></pre>
<p>첫 번째 명령은 <code>$REMOTE</code> 저장소의 <code>$BRANCH</code>에서 로컬 저장소에 없는 커밋을 페치하고, 원격 추적 브랜치를 업데이트하며, 헤드(head) 커밋의 ID(해시)를 <code>.git/FETCH_HEAD</code> 파일에 남깁니다.</p>
<p>두 번째 명령은 <code>$REMOTE</code> 저장소의 <code>$BRANCH</code>에서 로컬 저장소에 없는 커밋을 페치하고, 로컬 브랜치 <code>$BRANCH</code>와 해당 상위 원격 추적 브랜치를 모두 업데이트합니다. 그러나 Fast-forward가 아닌 경우에는 브랜치 업데이트를 거부합니다. 또한 현재 브랜치(현재 체크아웃된 브랜치, <code>HEAD</code>가 가리키는 곳) 업데이트도 거부합니다.</p>
<p>첫 번째 명령은 <code>git pull</code>에 의해 내부적으로 사용됩니다.</p>
<p><code>$ git pull $REMOTE $BRANCH</code>는 다음 명령과 동일합니다.</p>
<pre><code class="language-bash">$ git fetch $REMOTE $BRANCH
$ git merge FETCH_HEAD
</code></pre>
<p>이 경우 <code>$BRANCH</code>는 현재 브랜치여야 합니다. 다른 브랜치를 현재 브랜치로 병합하려면 먼저 해당 비현재 브랜치를 업데이트한 다음 병합합니다.</p>
<pre><code class="language-bash">$ git fetch origin v1:v1 # v1 업데이트
$ git pull --rebase origin master # 병합 대신 리베이스를 사용하여 현재 master 브랜치 업데이트
$ git merge v1
</code></pre>
<p>아직 <code>v1</code>에 커밋을 푸시하지 않았다면, 시나리오는 좀 더 복잡해집니다. Git은 Fast-forward 불가능한 브랜치 업데이트를 거부하며, 강제 풀(force-pull)을 원치 않을 것입니다. 왜냐하면 강제 풀은 푸시되지 않은 커밋을 제거하고 복구해야 하기 때문입니다. 따라서 <code>v1</code>을 리베이스하고 싶지만, 비현재 브랜치를 리베이스할 수 없습니다. 따라서 병합하기 전에 <code>v1</code>을 체크아웃하고 리베이스합니다.</p>
<pre><code class="language-bash">$ git checkout v1
$ git pull --rebase origin v1
$ git checkout master
$ git pull --rebase origin master
$ git merge v1
</code></pre>
<p>Git을 설정하여 몇 개의 브랜치 또는 모든 브랜치를 한 번에 페치/풀하도록 할 수 있으므로, 간단히 다음을 실행할 수 있습니다.</p>
<pre><code class="language-bash">$ git pull origin
</code></pre>
<p>또는 심지어</p>
<pre><code class="language-bash">$ git pull
</code></pre>
<p>페치/풀을 위한 기본 원격 저장소는 <code>origin</code>입니다. 페치할 기본 참조 세트는 매칭 알고리즘을 사용하여 계산됩니다. Git은 양쪽 끝에 동일한 이름을 가진 모든 브랜치를 페치합니다.</p>
<h3>Push</h3>
<p>푸시는 약간 더 간단합니다. <code>push</code> 명령은 하나뿐입니다. 다음을 실행할 때:</p>
<pre><code class="language-bash">$ git push origin v1 master
</code></pre>
<p>Git은 로컬 <code>v1</code>을 원격 <code>v1</code>으로, 로컬 <code>master</code>를 원격 <code>master</code>로 푸시합니다. 다음 명령과 동일합니다.</p>
<pre><code class="language-bash">$ git push origin v1:v1 master:master
</code></pre>
<p>Git은 커밋을 원격 저장소로 푸시하고 원격 추적 브랜치를 업데이트합니다. Git은 Fast-forward 불가능한 커밋 푸시를 거부합니다. 어쨌든 강제 푸시를 할 수 있지만, 자신의 저장소에만 강제 푸시해야 하며, 공개 또는 공유 저장소에는 강제 푸시하지 마십시오. Git이 Fast-forward 불가능한 커밋 푸시를 거부하는 경우, 원격 저장소에서 커밋을 페치하고 병합(또는 페치된 커밋 위에 자신의 커밋을 리베이스)한 다음 푸시하는 것이 좋습니다. 무엇을 왜 하는지 아는 경우에만 강제 푸시하십시오. 아래 "Commit editing and caveats" 섹션을 참조하십시오.</p>
<p>Git을 설정하여 몇 개의 브랜치 또는 모든 브랜치를 한 번에 푸시하도록 할 수 있으므로, 간단히 다음을 실행할 수 있습니다.</p>
<pre><code class="language-bash">$ git push origin
</code></pre>
<p>또는 심지어</p>
<pre><code class="language-bash">$ git push
</code></pre>
<p>푸시를 위한 기본 원격 저장소는 <code>origin</code>입니다. Git 2.0 이전 버전에서 푸시할 기본 참조 세트는 매칭 알고리즘을 사용하여 계산됩니다. Git은 양쪽 끝에 동일한 이름을 가진 모든 브랜치를 푸시합니다. Git 2.0 이상 버전에서 푸시할 기본 참조 세트는 간단한 알고리즘을 사용하여 계산됩니다. Git은 현재 브랜치를 <code>@ {upstream}</code>으로 다시 푸시합니다.</p>
<p>Git 2.0 이전 버전에서 새로운 동작으로 설정하려면 다음을 실행합니다.</p>
<pre><code class="language-bash">$ git config push.default simple
</code></pre>
<p>Git 2.0 이상 버전에서 이전 동작으로 설정하려면 다음을 실행합니다.</p>
<pre><code class="language-bash">$ git config push.default matching
</code></pre>
<p>Git은 원격 non-bare 저장소에서 현재 브랜치인 경우 브랜치 푸시를 허용하지 않습니다. Git은 원격 작업 디렉토리 업데이트를 거부합니다. bare 저장소에만 푸시해야 합니다. non-bare 저장소의 경우 Git은 풀(pull) 기반 워크플로우를 선호합니다.</p>
<p>원격 호스트에 코드를 배포하고 푸시만 사용할 수 있는 경우(워크스테이션이 방화벽 뒤에 있어 풀할 수 없기 때문에), 두 개의 저장소를 사용하여 두 단계로 수행합니다. 워크스테이션에서 원격 호스트의 bare 저장소로 푸시하고, 원격 호스트에 SSH로 연결한 다음 bare 저장소에서 non-bare 배포 저장소로 풀합니다.</p>
<p>이는 Git 2.3에서 변경되었지만, 주의 사항은 블로그 게시물을 참조하십시오. 2.4에서는 push-to-deploy 기능이 더욱 개선되었습니다.</p>
<h3>태그 (Tags)</h3>
<p>Git은 페치/풀 중에 페치되는 커밋을 가리키는 태그를 자동으로 페치합니다. 모든 태그(및 태그가 가리키는 커밋)를 페치하려면 <code>git fetch --tags origin</code>을 실행합니다. 특정 태그를 페치하려면 명시적으로 페치합니다.</p>
<pre><code class="language-bash">$ git fetch origin tag $TAG1 tag $TAG2...
</code></pre>
<p>예를 들어:</p>
<pre><code class="language-bash">$ git fetch origin tag 1.4.2
$ git fetch origin v1:v1 tag 2.1.7
</code></pre>
<p>Git은 태그를 자동으로 푸시하지 않습니다. 이를 통해 비공개 태그를 가질 수 있습니다. 태그를 푸시하려면 명시적으로 나열합니다.</p>
<pre><code class="language-bash">$ git push origin tag 1.4.2
$ git push origin v1 master tag 2.1.7
</code></pre>
<p>또는 모든 태그를 한 번에 푸시합니다.</p>
<pre><code class="language-bash">$ git push --tags origin
</code></pre>
<p>태그가 공개된 후에는 <code>git tag -f</code>로 태그를 이동하거나 <code>git tag -d</code>로 태그를 제거하지 마십시오.</p>
<h3>개인 정보 (Private information)</h3>
<p>클론/페치/풀/푸시 시 Git은 데이터베이스 객체(커밋, 트리, 파일 및 태그)와 심볼릭 참조(브랜치 및 경량 태그)만 복사합니다. 그 외의 모든 것은 저장소에 비공개이며 절대 클론, 업데이트 또는 푸시되지 않습니다. 이는 사용자의 설정, 후크(hooks), 비공개 제외 파일 등입니다.</p>
<p>후크를 배포하려면 작업 트리(working tree)로 복사하고, 추가(add), 커밋(commit), 푸시(push)한 다음 팀원들에게 수동으로 후크를 업데이트하고 설치하도록 지시하십시오.</p>
<h3>커밋 편집 및 주의사항 (Commit editing and caveats)</h3>
<p>게시된(푸시된) 커밋을 편집하지 말라는 경고는 문서에도 나와 있지만, 매우 중요하므로 여기에 다시 반복합니다.</p>
<p>강제 푸시(forced push)에서 복구하는 것은 가능하지만, 팀 전체에게 매우 번거로운 일입니다. 피해주십시오.</p>
<p>아직 게시되지 않은 커밋을 보려면 브랜치의 헤드와 해당 상위 원격 추적 브랜치를 비교합니다.</p>
<pre><code class="language-bash">$ git log origin/master.. # origin/master부터 HEAD(master의)까지
$ git log origin/v1..v1 # origin/v1부터 v1의 헤드까지
</code></pre>
<p>상위 원격 추적 브랜치가 있는 모든 브랜치에 대해 Git은 <code>@ {upstream}</code>(줄여서 <code>@ {u}</code>)이라는 별칭(alias)을 유지하므로, 위 명령은 다음과 같이 주어질 수 있습니다.</p>
<pre><code class="language-bash">$ git log @{u}..
$ git log v1@{u}..v1
</code></pre>
<p>모든 브랜치의 상태를 보려면:</p>
<pre><code class="language-bash">$ git branch -avv
</code></pre>
<p>로컬 브랜치의 상태를 원격 저장소와 비교하려면:</p>
<pre><code class="language-bash">$ git remote show origin
</code></pre>
<p>상위 리베이스에서 복구하는 방법은 <code>git help rebase</code>를 참조하십시오.</p>
<p>한편, 커밋 편집에 대해 너무 두려워하지 마십시오. 아직 푸시되지 않은 커밋은 안전하게 편집, 재정렬, 제거, 결합 및 분할할 수 있습니다. 자신의 (백업) 저장소에 커밋을 푸시한 다음 나중에 편집하고 편집된 커밋을 강제 푸시하여 이미 푸시된 것을 대체할 수도 있습니다. 커밋이 공개 또는 공유 저장소에 있지 않는 한 문제가 되지 않습니다.</p>
<h3>되돌리기 (Undo)</h3>
<p>무슨 일을 하든 당황하지 마십시오. Git의 거의 모든 것은 되돌릴 수 있습니다.</p>
<h4><code>git checkout</code>: 파일 내용 복원 (<code>git checkout: restore file's content</code>)</h4>
<p>예를 들어, <code>git checkout</code>은 파일의 내용을 특정 커밋의 내용으로 복원하는 데 사용될 수 있습니다. 다음과 같이:</p>
<pre><code class="language-bash">git checkout HEAD~ README
</code></pre>
<p>이 명령은 현재 브랜치에서 마지막에서 두 번째 커밋의 <code>README</code> 파일 내용을 복원합니다. 기본적으로 커밋 ID는 단순히 <code>HEAD</code>입니다. 즉, <code>git checkout README</code>는 <code>README</code>를 최신 커밋으로 복원합니다.</p>
<p>(커밋에 있는 파일의 내용을 보려면 <code>git checkout</code>을 사용하지 마십시오. <code>git cat-file -p</code>를 사용하십시오. 예를 들어 <code>git cat-file -p HEAD~:path/to/README</code>.)</p>
<h4><code>git reset</code>: (푸시되지 않은) 커밋 제거 (<code>git reset: remove (non-pushed) commits</code>)</h4>
<p><code>git reset</code>은 현재 브랜치의 헤드를 이동합니다. 헤드는 어떤 커밋이든 가리키도록 이동될 수 있지만, 주로 브랜치 상단에서 하나 또는 몇 개의 (가능하면 푸시되지 않은) 커밋을 제거하는 데 사용됩니다. 즉, 몇 개의 (푸시되지 않은) 커밋을 되돌리기 위해 브랜치를 뒤로 이동시키는 것입니다.</p>
<p><code>git reset</code>에는 <code>soft</code>, <code>hard</code>, <code>mixed</code> 세 가지 작동 모드가 있습니다. 기본값은 <code>mixed</code>입니다. ProGit은 차이점을 매우 명확하게 설명합니다. bare 저장소에는 인덱스나 작업 트리가 없으므로 bare 저장소에서는 <code>soft</code> 리셋만 가능합니다.</p>
<h4>스테이징 해제 (Unstaging)</h4>
<p>경로 또는 경로가 있는 <code>mixed</code> 모드 리셋은 변경 사항을 스테이징 해제(unstage)하는 데 사용될 수 있습니다. 즉, 커밋을 위해 <code>git add</code>로 추가된 변경 사항을 인덱스에서 제거하는 것입니다. 스테이징 해제 및 기타 되돌리기 트릭에 대한 자세한 내용은 The Book을 참조하십시오.</p>
<h4><code>git reflog</code>: 참조 로그 (<code>git reflog: reference log</code>)</h4>
<p><code>git reset</code>으로 커밋을 제거하거나 브랜치 헤드를 이동하는 것은 위험하게 들리며 실제로 그렇습니다. 하지만 되돌리는 방법이 있습니다. 원래 커밋으로 다시 리셋하는 것입니다. Git은 커밋을 즉시 제거하지 않습니다. 참조되지 않은 커밋(Git 용어로는 "dangling commits"라고 함)은 일정 기간(기본값은 2주) 동안 데이터베이스에 남아 있으므로, 이를 다시 리셋하거나 원래 커밋을 가리키는 새 브랜치를 만들 수 있습니다.</p>
<p><code>git commit</code>, <code>git checkout</code>, <code>git fetch</code>, <code>git pull</code>, <code>git rebase</code>, <code>git reset</code> 등으로 브랜치 헤드가 이동할 때마다 Git은 참조 로그(줄여서 reflog)를 저장합니다. 모든 이동에 대해 Git은 헤드가 어디에 있었는지 저장합니다. <code>git reflog</code> 명령은 로그를 보거나 조작하는 데 사용될 수 있습니다.</p>
<p>모든 브랜치 헤드의 이동 외에도 Git은 <code>HEAD</code>의 이동을 저장합니다. <code>HEAD</code>는 (일반적으로) 현재 브랜치를 나타내는 심볼릭 참조입니다. <code>HEAD</code>는 <code>git checkout $BRANCH</code>로 변경됩니다.</p>
<p>기본적으로 <code>git reflog</code>는 <code>HEAD</code>의 이동을 보여줍니다. 즉, 이 명령은 <code>git reflog HEAD</code>와 동일합니다. 브랜치 헤드의 이동을 보려면 <code>git reflog $BRANCH</code> 명령을 사용합니다.</p>
<p>따라서 <code>git reset</code>을 되돌리려면 <code>git reflog</code>에서 원래 커밋을 찾아 <code>git show</code> 또는 <code>git log</code>로 확인하고 <code>git reset $COMMIT_ID</code>를 실행합니다. Git은 브랜치 헤드의 이동을 reflog에 저장하므로, 나중에 그 되돌리기를 다시 되돌릴 수도 있습니다.</p>
<p>더 복잡한 상황에서는 브랜치의 헤드를 리셋하는 것과 함께 일부 커밋을 이동하고 싶을 것입니다. 이를 새 브랜치로 체리픽(cherry-pick)하십시오. 예를 들어, <code>master</code> 브랜치를 원래 커밋으로 되돌리되 현재 브랜치에서 생성된 두 개의 커밋을 보존하려면 다음과 같이 수행합니다.</p>
<pre><code class="language-bash">$ git branch save-master # master를 저장하는 새 브랜치 생성
$ git reflog # master의 원래 위치 찾기
$ git reset $COMMIT_ID
$ git cherry-pick save-master~ save-master
$ git branch -D save-master # 임시 브랜치 제거
</code></pre>
<h4><code>git revert</code>: 커밋 되돌리기 (<code>git revert: revert a commit</code>)</h4>
<p><code>git revert</code>는 하나 또는 여러 커밋을 되돌립니다. 즉, 주어진 커밋의 효과를 되돌리는 새로운 커밋을 생성합니다. 이는 게시된 커밋을 되돌리는 유일한 방법입니다 (<code>git commit --amend</code>, <code>git rebase</code>, <code>git reset</code>은 브랜치를 Fast-forward 불가능한 방식으로 변경하므로 푸시되지 않은 커밋에만 사용해야 합니다).</p>
<p>병합 커밋(merge commit)을 되돌리는 데는 문제가 있습니다. <code>git revert</code>는 병합 커밋으로 인해 생성된 코드를 되돌릴 수 있지만, 병합 사실 자체를 되돌릴 수는 없습니다. "How to revert a faulty merge" 토론을 참조하십시오.</p>
<h4>되돌릴 수 없는 한 가지 (<code>One thing that cannot be undone</code>)</h4>
<p>무엇을 되돌리든, 되돌릴 수 없는 한 가지가 있습니다. 덮어씌워진 커밋되지 않은 변경 사항입니다. 커밋되지 않은 변경 사항은 Git에 속하지 않으므로 Git은 이를 보존하는 데 도움이 될 수 없습니다.</p>
<p>대부분의 경우 Git은 커밋되지 않은 변경 사항을 덮어씌울 명령을 실행할 때 경고를 표시합니다. Git은 <code>git checkout</code>으로 브랜치를 전환하는 것을 허용하지 않습니다. 작업 트리가 깨끗하지 않은 상태에서 리베이스하려고 할 때 Git은 중단시킵니다. 커밋되지 않은 파일 위에 새 커밋을 풀하는 것을 거부합니다.</p>
<p>그러나 정확히 파일 덮어쓰기를 수행하는 명령이 있습니다. <code>git checkout $PATHs</code> 또는 <code>git reset --hard</code>와 같은 명령은 커밋되지 않은 변경 사항을 포함하여 파일을 자동으로 덮어씌웁니다.</p>
<p>이를 염두에 두고 "일찍 커밋하고 자주 커밋하라(commit early, commit often)"는 입장을 이해할 수 있습니다. 가능한 한 자주 커밋하십시오. 편집기 또는 IDE에서 저장할 때마다 커밋하십시오. 푸시하기 전에 커밋을 편집할 수 있습니다. 커밋 메시지를 편집하고, 커밋을 변경하고, 재정렬하고, 결합하고, 분할하고, 제거할 수 있습니다. 그러나 변경 사항을 Git 데이터베이스에 저장하십시오. 변경 사항을 커밋하거나 최소한 <code>git stash</code>로 스태시(stash)하십시오.</p>
<h3>병합 또는 리베이스? (Merge or rebase?)</h3>
<p>인터넷은 "병합 또는 리베이스?"라는 주제에 대한 열띤 토론으로 가득합니다. 대부분은 의미가 없습니다. 많은 브랜치가 있는 크고 복잡한 프로젝트에서 대규모 팀이 DVCS(분산 버전 관리 시스템)를 사용하는 경우 병합을 피할 방법이 없습니다. 따라서 질문은 "리베이스를 사용할 것인가, 그렇다면 언제 리베이스를 사용할 것인가?"로 축소됩니다. 게시된 커밋을 리베이스하지 않는 것이 강력히 권장된다는 점을 고려하면 질문은 더욱 축소됩니다. "푸시되지 않은 커밋에 리베이스를 사용할 것인가?"</p>
<p>이 작은 질문은 팀이 결정할 문제입니다. 선형 히스토리의 아름다움을 보존하기 위해 풀할 때 리베이스를 사용하는 것이 좋습니다. 즉, <code>git pull --rebase</code>를 수행하거나, 모든 새 브랜치에 대해 리베이스의 자동 설정을 구성할 수도 있습니다.</p>
<pre><code class="language-bash">$ git config branch.autosetuprebase always
</code></pre>
<p>그리고 기존 브랜치에 대해 리베이스를 구성합니다.</p>
<pre><code class="language-bash">$ git config branch.$NAME.rebase true
</code></pre>
<p>예를 들어:</p>
<pre><code class="language-bash">$ git config branch.v1.rebase true
$ git config branch.master.rebase true
</code></pre>
<p>그 후 <code>git pull origin master</code>는 <code>git pull --rebase origin master</code>와 동일해집니다.</p>
<p>메인라인 브랜치를 업데이트하기 위해 리베이스를 사용하는 동안 별도의 기능 또는 토픽 브랜치에서 새 커밋을 생성하는 것이 좋습니다. 토픽 브랜치가 준비되면 메인라인으로 병합합니다. 한 번에 많은 수의 충돌을 해결하는 번거로운 작업을 피하려면 토픽 브랜치를 때때로 메인라인으로 병합한 다음 토픽 브랜치로 다시 전환하여 작업을 계속할 수 있습니다. 전체 워크플로우는 다음과 같습니다.</p>
<pre><code class="language-bash">$ git checkout -b issue-42 # 새 이슈 브랜치를 생성하고 전환
...edit/test/commit...
$ git checkout master
$ git pull --rebase origin master # 상위에서 master 업데이트
$ git merge issue-42
$ git branch -d issue-42 # 토픽 브랜치 삭제
$ git push origin master
</code></pre>
<p>토픽 브랜치가 삭제되면 레이블만 제거되고 커밋은 데이터베이스에 남아 있습니다. 이제 커밋은 <code>master</code>에 병합되었습니다.</p>
<pre><code>o--o--o--o--o--M--&#x3C; master - 메인라인 브랜치
 \ /
  --*--*--* - 토픽 브랜치, 이제 이름 없음
</code></pre>
<p>토픽 브랜치는 작은 토픽 브랜치로 인한 브랜치 네임스페이스의 혼란을 피하기 위해 삭제됩니다. 어떤 문제가 해결되었는지 또는 어떤 기능이 구현되었는지에 대한 정보는 커밋 메시지에 있어야 합니다.</p>
<p>그러나 장기 병합된 브랜치의 경우 이처럼 적은 양의 리베이스도 너무 클 수 있습니다. <code>v1</code>과 <code>master</code> 브랜치에서 모두 작업하고 <code>v1</code>을 <code>master</code>로 정기적으로 병합한다고 가정해 보십시오. 얼마 후 <code>master</code>에 많은 병합 및 비병합 커밋이 있을 것입니다. 그런 다음 완료된 작업을 공유 저장소에 푸시하려고 할 때 누군가가 <code>v1</code>에 몇 개의 커밋을 푸시한 것을 발견합니다. 이제 두 가지 똑같이 나쁜 대안 중에서 선택해야 합니다. <code>v1</code>을 페치하고 리베이스한 다음 <code>master</code>에서 모든 작업을 다시 생성해야 하거나(master를 원본으로 리셋하고 v1을 병합한 다음 이전 master에서 모든 비병합 커밋을 체리픽), 새 <code>v1</code>을 병합하고 선형 히스토리의 아름다움을 잃게 됩니다.</p>
<h3>Null-병합 (Null-merges)</h3>
<p>Git에는 Python 핵심 개발자들이 "null-merge"라고 부르는 것에 대한 내장 병합 전략이 있습니다.</p>
<pre><code class="language-bash">$ git merge -s ours v1 # master에 v1 null-병합
</code></pre>
<h3>브랜칭 모델 (Branching models)</h3>
<p>Git은 브랜칭 및 병합과 관련하여 특정 개발 모델을 가정하지 않습니다. 일부 프로젝트는 가장 오래된 브랜치에서 최신 브랜치로 패치를 승격하는 것을 선호하고, 일부는 커밋을 역방향으로 체리픽하는 것을 선호하며, 일부는 스쿼싱(여러 커밋을 하나로 결합)을 사용합니다. 모든 것이 가능합니다.</p>
<p>시작할 몇 가지 예시가 있습니다. <code>git help workflows</code>는 Git 저자들이 Git을 개발하는 방법을 설명합니다.</p>
<p>ProGit 책에는 다양한 프로젝트의 브랜치 관리에 대한 몇 가지 장이 있습니다: "Git Branching - Branching Workflows" 및 "Distributed Git - Contributing to a Project".</p>
<p>Vincent Driessen의 "A successful Git branching model"이라는 잘 알려진 기사도 있습니다. 이 기사는 메인라인, 토픽 및 버그 수정 브랜치를 생성하고 관리하는 데 매우 상세한 규칙 세트를 권장합니다. 이 모델을 지원하기 위해 저자는 <code>git flow</code> 확장을 구현했습니다.</p>
<h3>고급 구성 (Advanced configuration)</h3>
<h4>줄 끝 (Line endings)</h4>
<p>Git에는 서로 다른 줄 끝 스타일을 가진 플랫폼 간의 줄 끝을 처리하는 내장 메커니즘이 있습니다. Git이 CRLF 변환을 수행하도록 허용하려면 <code>.gitattributes</code>를 사용하여 파일에 <code>text</code> 속성을 할당하십시오. 특정 줄 끝이 필요한 파일에는 <code>eol</code> 속성을 할당하십시오. 바이너리 파일의 경우 속성은 당연히 <code>binary</code>입니다.</p>
<p>예를 들어:</p>
<pre><code class="language-bash">$ cat .gitattributes
*.py text
*.txt text
*.png binary
/readme.txt eol=CRLF
</code></pre>
<p>Git이 파일에 사용하는 속성을 확인하려면 <code>git check-attr</code> 명령을 사용합니다. 예를 들어:</p>
<pre><code class="language-bash">$ git check-attr -a -- \*.py
</code></pre>
<h4>유용한 자산 (Useful assets)</h4>
<ul>
<li><code>GitAlias</code> (repository): 별칭(aliases)의 방대한 컬렉션입니다. 자주 사용되는 명령에 대한 신중한 별칭 선택은 많은 키 입력 시간을 절약할 수 있습니다!</li>
<li><code>GitIgnore</code> 및 <code>https://github.com/github/gitignore</code>: 모든 종류의 IDE 및 프로그래밍 언어에 대한 <code>.gitignore</code> 파일 컬렉션입니다. Python도 포함되어 있습니다!</li>
<li><code>pre-commit</code> (repositories): 다국어 pre-commit 후크를 관리하고 유지 관리하기 위한 프레임워크입니다. 이 프레임워크는 Python으로 작성되었으며 많은 프로그래밍 언어에 대한 많은 플러그인을 제공합니다.</li>
</ul>
<h3>고급 주제 (Advanced topics)</h3>
<h4>스테이징 영역 (Staging area)</h4>
<p>스테이징 영역(Staging area), 일명 인덱스(index), 일명 캐시(cache)는 Git의 특징적인 기능입니다. 스테이징 영역은 Git이 커밋하기 전에 패치를 수집하는 곳입니다. 패치 수집 단계와 커밋 단계의 분리는 Git의 매우 유용한 기능을 제공합니다. 커밋하기 전에 수집된 패치를 검토하고 편집할 수도 있습니다. 일부 덩어리(hunks)를 제거하고, 새로운 덩어리를 추가하고, 다시 검토할 수 있습니다.</p>
<p>파일을 인덱스에 추가하려면 <code>git add</code>를 사용합니다. 커밋하기 전에 패치를 수집한다는 것은 새로운(추적되지 않은) 파일뿐만 아니라 모든 변경 사항에 대해 이 작업을 수행해야 함을 의미합니다. 검토 없이 모든 것을 커밋하려는 경우 커밋을 단순화하려면 <code>git commit --all</code> (또는 <code>-a</code>)을 실행합니다. 이 명령은 변경된 모든 추적 파일을 인덱스에 추가한 다음 커밋합니다. 인덱스에 수집된 패치와 관계없이 하나 또는 여러 파일을 커밋하려면 <code>git commit [--only|-o] -- $FILE...</code>을 실행합니다.</p>
<p>패치의 덩어리를 인덱스에 추가하려면 <code>git add --patch</code> (또는 <code>-p</code>)를 사용합니다. 수집된 파일을 인덱스에서 제거하려면 <code>git reset HEAD -- $FILE...</code>을 사용합니다. 수집된 덩어리를 추가/검사/제거하려면 <code>git add --interactive</code> (<code>-i</code>)를 사용합니다.</p>
<p>인덱스와 마지막 커밋 간의 차이(즉, 수집된 패치)를 보려면 <code>git diff --cached</code>를 사용합니다. 작업 트리와 인덱스 간의 차이(즉, 수집되지 않은 패치)를 보려면 <code>git diff</code>를 사용합니다. 작업 트리와 마지막 커밋 간의 차이(즉, 수집된 패치와 수집되지 않은 패치 모두)를 보려면 <code>git diff HEAD</code>를 실행합니다.</p>
<p>Git Wiki의 "WhatIsTheIndex" 및 "IndexCommandQuickref"를 참조하십시오.</p>
<h4>Root</h4>
<p>Git은 어떤 명령을 실행하기 전에 루트( <code>.git</code> 서브디렉토리가 존재하는 프로젝트의 최상위 디렉토리)로 전환합니다. 그러나 Git은 전환하기 전에 현재 디렉토리가 무엇이었는지 기억합니다. 일부 프로그램은 현재 디렉토리를 고려합니다. 예를 들어, <code>git status</code>는 현재 디렉토리를 기준으로 변경 및 알 수 없는 파일의 파일 경로를 보여줍니다. <code>git grep</code>은 현재 디렉토리 아래를 검색합니다. <code>git apply</code>는 현재 디렉토리 아래의 파일을 건드리는 패치에서 해당 덩어리만 적용합니다.</p>
<p>그러나 대부분의 명령은 루트에서 실행되며 현재 디렉토리를 무시합니다. 예를 들어, <code>v1</code> 브랜치용 작업 트리와 <code>master</code> 브랜치용 작업 트리 두 개가 있다고 가정해 보십시오. 두 번째 작업 트리의 하위 디렉토리에서 <code>v1</code>을 병합하려면 최상위 디렉토리에 있는 것처럼 명령을 작성해야 합니다. 예를 들어, <code>project-v1</code>과 <code>project</code> 두 개의 작업 트리를 사용해 봅시다.</p>
<pre><code class="language-bash">$ cd project/subdirectory
$ git fetch ../project-v1 v1:v1
$ git merge v1
</code></pre>
<p><code>git fetch ../project-v1 v1:v1</code>의 경로 <code>../project-v1</code>은 하위 디렉토리에서 명령을 실행했음에도 불구하고 <code>../../project-v1</code>이 아님을 참고하십시오.</p>
<h4>ReReRe</h4>
<p>ReReRe는 반복되는 병합 충돌을 해결하는 데 도움이 되는 메커니즘입니다. 반복되는 병합 충돌의 가장 흔한 원인은 메인라인으로 병합된 다음 병합 커밋이 제거되는 토픽 브랜치입니다. 이는 종종 토픽 브랜치를 테스트하고 ReReRe를 훈련하기 위해 수행됩니다. 병합 커밋은 깔끔한 선형 히스토리를 가지고 하나의 마지막 병합 커밋으로 토픽 브랜치를 마무리하기 위해 제거됩니다.</p>
<p>ReReRe는 성공적인 커밋 전후의 트리 상태를 기억함으로써 작동합니다. 이러한 방식으로 ReReRe는 동일한 파일에 충돌이 나타나면 자동으로 해결할 수 있습니다.</p>
<p>ReReRe는 <code>git rerere</code> 명령으로 수동으로 사용될 수 있지만, 대부분의 경우 자동으로 사용됩니다. 작업 트리에서 다음 명령으로 ReReRe를 활성화합니다.</p>
<pre><code class="language-bash">$ git config rerere.enabled true
$ git config rerere.autoupdate true
</code></pre>
<p>ReReRe를 전역적으로 켤 필요는 없습니다. bare 저장소나 단일 브랜치 저장소에서는 ReReRe를 원치 않을 것입니다. 병합 및 병합 충돌을 자주 수행하고 해결하는 저장소에서만 ReReRe가 필요합니다.</p>
<p>The Book의 "Rerere" 섹션을 참조하십시오.</p>
<h4>데이터베이스 유지 관리 (Database maintenance)</h4>
<p>Git 객체 데이터베이스 및 <code>.git</code> 아래의 기타 파일/디렉토리는 주기적인 유지 관리 및 정리가 필요합니다. 예를 들어, 커밋 편집은 참조되지 않은 객체(Git 용어로는 dangling objects)를 남기며, 이러한 객체는 DB에 불필요한 데이터를 쌓는 것을 방지하기 위해 제거되어야 합니다. <code>git gc</code> 명령은 유지 관리에 사용됩니다. Git은 일부 명령의 일부로 <code>git gc --auto</code>를 자동으로 실행하여 빠른 유지 관리를 수행합니다. 사용자에게는 <code>git gc --aggressive</code>를 가끔 실행하는 것이 권장됩니다. <code>git help gc</code>는 몇백 개의 변경 사항마다 실행하는 것을 권장하며, 더 집중적인 프로젝트의 경우 일주일에 한 번 정도, 활동이 적은 프로젝트의 경우 더 드물게(2주에 한 번 또는 한 달에 한 번) 실행해야 합니다.</p>
<p><code>git gc --aggressive</code>는 dangling 객체를 제거할 뿐만 아니라, 객체 데이터베이스를 인덱싱되고 더 최적화된 팩(pack)으로 재패킹합니다. 또한 심볼릭 참조(브랜치 및 태그)도 패킹합니다. 이를 수행하는 또 다른 방법은 <code>git repack</code>을 실행하는 것입니다.</p>
<p>Linus Torvalds의 <code>git gc --aggressive</code>의 "어리석음"에 관한 잘 알려진 메시지가 있습니다. 이 메시지는 이제 안전하게 무시할 수 있습니다. 오래되고 시대에 뒤떨어진 메시지이며, <code>git gc --aggressive</code>는 그 이후로 훨씬 나아졌습니다.</p>
<p>여전히 <code>git gc --aggressive</code>보다 <code>git repack</code>을 선호하는 사람들을 위한 권장 매개변수는 <code>git repack -a -d -f --depth=20 --window=250</code>입니다. 이 매개변수의 효과에 대한 설명은 이 자세한 실험을 참조하십시오.</p>
<p>때때로 <code>git fsck [--strict]</code>를 실행하여 데이터베이스의 무결성을 확인합니다. <code>git fsck</code>는 dangling 객체 목록을 생성할 수 있습니다. 이는 오류가 아니라 정기적인 유지 관리를 수행해야 한다는 알림입니다.</p>
<h3>팁과 트릭 (Tips and tricks)</h3>
<h4>명령줄 옵션 및 인수 (Command-line options and arguments)</h4>
<p><code>git help cli</code>는 짧은 옵션/플래그를 결합하지 말 것을 권장합니다. 대부분의 경우 결합이 작동합니다. <code>git commit -av</code>는 완벽하게 작동하지만, 작동하지 않는 상황도 있습니다. 예를 들어, <code>git log -p -5</code>는 <code>git log -p5</code>로 결합할 수 없습니다.</p>
<p>일부 옵션에는 인수가 있으며, 일부는 기본 인수도 있습니다. 이 경우 해당 옵션의 인수는 <code> -Oarg</code>와 같이 붙여서 입력해야 합니다. <code>-O arg</code>는 안 됩니다. 왜냐하면 기본 인수가 있는 옵션의 경우 후자는 "-O 옵션에 기본값을 사용하고 arg를 옵션 파서에 추가로 전달"한다는 의미이기 때문입니다. 예를 들어, <code>git grep</code>에는 찾은 파일 이름 목록을 프로그램에 전달하는 <code>-O</code> 옵션이 있습니다. <code>-O</code>의 기본 프로그램은 페이저(일반적으로 <code>less</code>)이지만, 편집기를 사용할 수 있습니다.</p>
<pre><code class="language-bash">$ git grep -Ovim # 하지만 -O vim은 안 됩니다
</code></pre>
<p>덧붙여, Git이 <code>less</code>를 페이저로 사용하도록 지시받은 경우(<code>pager</code>가 Git에 전혀 구성되지 않은 경우 기본적으로 <code>less</code>를 사용하거나, <code>GIT_PAGER</code> 또는 <code>PAGER</code> 환경 변수에서 <code>less</code>를 얻거나, <code>git config [--global] core.pager less</code>로 구성되었거나, <code>git grep -Oless</code> 명령에서 <code>less</code>가 사용된 경우) <code>git grep</code>은 <code>+/$pattern</code> 옵션을 <code>less</code>에 전달하는데, 이는 매우 편리합니다. 불행히도, 페이저가 정확히 <code>less</code>가 아닌 경우(<code>less</code>에 매개변수가 있는 경우에도, 예를 들어 <code>git config [--global] core.pager less -FRSXgimq</code>) <code>git grep</code>은 패턴을 전달하지 않습니다. 다행히도 <code>git grep -Oless</code>는 항상 패턴을 전달합니다.</p>
<h4>Bash/Zsh 완성 (bash/zsh completion)</h4>
<p><code>git rebase --interactive --preserve-merges HEAD~5</code>를 수동으로 입력하는 것은 명령줄 사용을 즐기는 사람들에게도 다소 어렵습니다. 이때 쉘 완성(shell completion)이 큰 도움이 됩니다. Bash/Zsh는 프로그래밍 가능한 완성 기능을 제공하며, 종종 자동으로 설치 및 활성화되므로 Bash/Zsh 및 Git이 설치되어 있다면 이미 완료되었을 가능성이 높습니다. 명령줄에서 사용하기만 하면 됩니다.</p>
<p>필요한 요소가 설치되어 있지 않은 경우 <code>bash_completion</code> 패키지를 설치하고 활성화하십시오. Git 완성 기능을 최신 버전으로 업그레이드하려면 Git contrib에서 필요한 파일을 다운로드하십시오.</p>
<p><code>Git-for-windows</code>에는 Bash 완성이 설치 및 활성화된 <code>git-bash</code>가 함께 제공됩니다.</p>
<h4>Bash/Zsh 프롬프트 (bash/zsh prompt)</h4>
<p>명령줄 애호가를 위해 쉘 프롬프트는 많은 유용한 정보를 담을 수 있습니다. 프롬프트에 Git 정보를 포함하려면 <code>git-prompt.sh</code>를 사용하십시오. 파일의 자세한 지침을 읽으십시오.</p>
<p>다른 프롬프트 변형을 찾으려면 인터넷에서 "git prompt"를 검색하십시오.</p>
<h4>SSH 연결 공유 (SSH connection sharing)</h4>
<p>SSH 연결 공유는 OpenSSH 및 PuTTY와 같은 파생 제품의 기능입니다. SSH 연결 공유는 하나의 연결을 설정하고 동일한 서버에 연결하는 모든 후속 클라이언트에 대해 재사용함으로써 SSH 클라이언트 시작 시간을 줄이는 방법입니다. SSH 연결 공유는 <code>scp</code>, <code>sftp</code>, <code>rsync</code> 및 물론 SSH를 통한 Git과 같은 많은 짧은 SSH 세션 속도를 높이는 데 사용될 수 있습니다. SSH를 통해 액세스할 수 있는 원격 저장소에서 정기적으로 페치/풀/푸시하는 경우 SSH 연결 공유를 사용하는 것이 좋습니다.</p>
<p>SSH 연결 공유를 켜려면 <code>~/.ssh/config</code>에 다음과 같은 내용을 추가합니다.</p>
<pre><code>Host *
  ControlMaster auto
  ControlPath ~/.ssh/mux-%r@%h:%p
  ControlPersist 600
</code></pre>
<p>OpenSSH wikibook을 참조하고 더 많은 정보를 검색하십시오.</p>
<p>SSH 연결 공유는 GitHub, GitLab 및 SourceForge 저장소에서 사용할 수 있지만, BitBucket은 허용하지 않으며 짧은 비활성 기간 후에 마스터 연결을 강제로 닫으므로 SSH에서 다음과 같은 오류가 표시될 수 있습니다. "Connection to bitbucket.org closed by remote host."</p>
<h3>서버의 Git (git on server)</h3>
<p>하나 또는 여러 저장소를 게시하는 가장 간단한 방법은 <code>git daemon</code>입니다. 데몬은 익명 액세스를 제공하며, 기본적으로 읽기 전용입니다. 저장소는 Git 프로토콜(<code>git://</code> URL)로 액세스할 수 있습니다. 쓰기 액세스를 활성화할 수 있지만, 이 프로토콜은 인증 수단이 없으므로 신뢰할 수 있는 LAN 내에서만 활성화해야 합니다. 자세한 내용은 <code>git help daemon</code>을 참조하십시오.</p>
<p>SSH를 통한 Git은 인증 및 저장소 수준 권한 부여를 제공합니다. 저장소는 사용자 또는 그룹 쓰기 가능으로 만들 수 있습니다(<code>git help config</code>에서 <code>core.sharedRepository</code> 매개변수 참조). 일부 프로젝트 요구 사항에 너무 허용적이거나 너무 제한적인 경우, 세분화된 액세스를 허용하도록 구성할 수 있는 래퍼(wrapper) <code>gitolite</code>가 있습니다. <code>gitolite</code>는 Perl로 작성되었으며 많은 문서를 가지고 있습니다.</p>
<p>저장소를 탐색하는 웹 인터페이스는 <code>gitweb</code> 또는 <code>cgit</code>을 사용하여 만들 수 있습니다. 둘 다 CGI 스크립트(Perl 및 C로 작성됨)입니다. 웹 인터페이스 외에도 둘 다 Git에 대한 읽기 전용 dumb HTTP 액세스(<code>http(s)://</code> URL)를 제공합니다. Klaus는 웹 인터페이스와 Git smart HTTP 전송을 모두 구현하는 작고 간단한 WSGI 웹 서버입니다. Python 2 및 Python 3을 지원하며 구문 강조를 수행합니다.</p>
<p>사용자, 그룹 및 프로젝트를 관리하는 기능, 비공개, 그룹 액세스 가능 및 공개 저장소, 이슈 트래커, 위키 페이지, 풀 리퀘스트 및 개발 및 통신을 위한 기타 도구를 포함하는 더 고급 웹 기반 개발 환경도 있습니다. 이러한 환경 중에는 Kallithea 및 pagure가 있으며, 둘 다 Python으로 작성되었습니다. pagure는 Fedora 개발자에 의해 작성되었으며 일부 Fedora 프로젝트 개발에 사용되고 있습니다. GitPrep은 Perl로 작성된 또 다른 GitHub 클론입니다. Gogs는 Go로 작성되었습니다. GitBucket은 Scala로 작성되었습니다.</p>
<p>마지막으로, GitLab. Git을 위한 가장 고급 웹 기반 개발 환경일 것입니다. Ruby로 작성되었으며, 커뮤니티 에디션은 무료 오픈 소스(MIT 라이선스)입니다.</p>
<h3>Mercurial에서 Git으로 (From Mercurial to git)</h3>
<p>Mercurial 저장소를 Git으로 변환하는 많은 도구가 있습니다. 가장 유명한 것은 아마도 <code>hg-git</code> 및 <code>fast-export</code>일 것입니다(몇 년 전에는 <code>hg2git</code>이라는 이름으로 알려졌습니다).</p>
<p>그러나 더 나은 도구, 아마도 최고는 <code>git-remote-hg</code>입니다. 이는 Git에서 Mercurial 저장소로 투명한 양방향(풀 및 푸시) 액세스를 제공합니다. 그 저자는 대부분 객관적인 대안 비교를 작성했습니다.</p>
<p><code>git-remote-hg</code>를 사용하려면, 이를 설치하거나 클론하고 <code>PATH</code>에 추가하거나 (<code>git-remote-hg</code> 스크립트를 <code>PATH</code>에 이미 있는 디렉토리로 복사) Mercurial URL 앞에 <code>hg::</code>를 붙입니다. 예를 들어:</p>
<pre><code class="language-bash">$ git clone https://github.com/felipec/git-remote-hg.git
$ PATH=$PATH:"`pwd`"/git-remote-hg
$ git clone hg::https://hg.python.org/peps/ PEPs
</code></pre>
<p>저장소와 작업하려면 <code>git fetch/pull/push</code>를 포함한 일반 Git 명령을 사용하십시오.</p>
<p>Mercurial 습관을 Git으로 전환하려면 Mercurial Wiki의 "Mercurial for Git users" 페이지를 참조하십시오. 페이지의 두 번째 절반에는 해당 Mercurial 및 Git 명령을 나열하는 표가 있습니다. 양방향으로 완벽하게 작동해야 합니다.</p>
<p>Python 개발자 가이드에도 Git과 Hg의 몇 가지 차이점을 문서화하는 "Mercurial for git developers" 장이 있습니다.</p>
<h3>Git 및 GitHub (Git and GitHub)</h3>
<p><code>gitsome</code>: Git/GitHub 명령줄 인터페이스(CLI)입니다. Python으로 작성되었으며 MacOS, Unix, Windows에서 작동합니다. 자동 완성 기능을 갖춘 Git/GitHub CLI로, 모든 쉘에서 작동하는 많은 GitHub 통합 명령, 쉘 명령과 함께 Python 명령을 실행할 수 있는 내장 Xonsh (Python REPL), 명령 히스토리, 사용자 정의 가능한 하이라이팅, 철저한 문서화를 포함합니다.</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.
원본: <code>https://github.com/python/peps/blob/main/peps/pep-0103.rst</code>
최종 수정: 2024년 4월 14일 20:08:31 GMT</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/103\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"jf5MDuRUbMNVvRN9tv5rq\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/103/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/103\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"103\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/103\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:Tc775,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0103/\"\u003ePEP 103 - Collecting information about git\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Withdrawn | \u003cstrong\u003e유형:\u003c/strong\u003e Informational | \u003cstrong\u003e작성일:\u003c/strong\u003e 01-Jun-2015\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 103 – Git 정보 수집 (철회됨)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Oleg Broytman\n\u003cstrong\u003e상태:\u003c/strong\u003e 철회됨 (Withdrawn)\n\u003cstrong\u003e유형:\u003c/strong\u003e 정보성 (Informational)\n\u003cstrong\u003e생성일:\u003c/strong\u003e 2015년 6월 1일\n\u003cstrong\u003e이력:\u003c/strong\u003e 2015년 9월 12일\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 정보성 PEP는 Git에 대한 정보를 수집합니다. Git에 대한 많은 문서가 이미 존재하므로, 이 PEP는 Python 개발과 더 관련 있는 복잡한 문제, 시나리오 및 예시에 집중합니다.\u003c/p\u003e\n\u003cp\u003e향후 이 PEP는 Mercurial에서 Git으로 Python 개발을 마이그레이션하는 데 도움이 되도록 Mercurial과 Git 시나리오의 등가성에 대한 정보를 수집하여 확장될 계획이었습니다.\u003c/p\u003e\n\u003cp\u003ePEP의 저자는 현재 Mercurial에서 Git으로 Python 개발을 마이그레이션하는 Process PEP를 작성할 계획이 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e중요:\u003c/strong\u003e 이 PEP는 철회되었습니다. 너무 일반적이며 Python 개발과 직접적인 관련이 적습니다. 더 이상 업데이트되지 않습니다. 내용은 Python Wiki로 옮겨졌으며, 이후 업데이트는 위키에서 이루어집니다.\u003c/p\u003e\n\u003ch3\u003e문서 (Documentation)\u003c/h3\u003e\n\u003cp\u003eGit은 온라인과 오프라인 모두 풍부한 문서를 제공합니다.\u003c/p\u003e\n\u003ch4\u003e초보자를 위한 문서 (Documentation for starters)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eGit Tutorial: part 1, part 2\u003c/li\u003e\n\u003cli\u003eGit User's manual\u003c/li\u003e\n\u003cli\u003eEveryday GIT With 20 Commands Or So\u003c/li\u003e\n\u003cli\u003eGit workflows\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e고급 문서 (Advanced documentation)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eGit Magic (다양한 번역본 제공)\u003c/li\u003e\n\u003cli\u003ePro Git (The Book about git): Amazon에서 구매하거나 PDF, mobi, ePub 형식으로 다운로드 가능하며, 다양한 언어로 번역되어 있습니다.\u003c/li\u003e\n\u003cli\u003eGit Wiki\u003c/li\u003e\n\u003cli\u003eGit Buch (독일어)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e오프라인 문서 (Offline documentation)\u003c/h4\u003e\n\u003cp\u003eGit은 내장된 도움말 기능을 제공합니다: \u003ccode\u003egit help $TOPIC\u003c/code\u003e을 실행하여 확인할 수 있습니다. 예를 들어, \u003ccode\u003egit help git\u003c/code\u003e 또는 \u003ccode\u003egit help help\u003c/code\u003e를 실행할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e빠른 시작 (Quick start)\u003c/h3\u003e\n\u003ch4\u003e다운로드 및 설치 (Download and installation)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eUnix 사용자:\u003c/strong\u003e 패키지 관리자를 사용하여 다운로드 및 설치합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMicrosoft Windows:\u003c/strong\u003e git-for-windows를 다운로드합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMacOS X:\u003c/strong\u003e XCode와 함께 설치된 Git을 사용하거나, MacPorts 또는 git-osx-installer에서 다운로드하거나, Homebrew (\u003ccode\u003ebrew install git\u003c/code\u003e)를 통해 설치합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit-cola\u003c/code\u003e (repository): Python으로 작성된 GPL 라이선스 Git GUI입니다 (Linux, Windows, MacOS X).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTortoiseGit\u003c/code\u003e: TortoiseSVN 기반의 Windows Shell 인터페이스 Git 클라이언트입니다 (오픈 소스).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e초기 설정 (Initial configuration)\u003c/h4\u003e\n\u003cp\u003eGit은 모든 커밋(commit)에 작성자(author) 및 커미터(committer)의 이름/이메일을 저장하므로, 실제 이름과 선호하는 이메일을 설정하는 것이 중요합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git config --global user.name \"User Name\"\n$ git config --global user.email user.name@example.org\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e이 PEP의 예시 (Examples in this PEP)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 Git 명령 예시는 다음과 같은 가정을 따릅니다. 사용자는 \u003ccode\u003epython\u003c/code\u003e이라는 로컬 저장소(local repository)에서 작업하며, \u003ccode\u003eorigin\u003c/code\u003e이라는 상위(upstream) 원격 저장소(remote repo)를 가지고 있습니다. 로컬 저장소에는 \u003ccode\u003ev1\u003c/code\u003e과 \u003ccode\u003emaster\u003c/code\u003e 두 개의 브랜치(branch)가 있습니다. 대부분의 예시에서는 현재 체크아웃(checkout)된 브랜치가 \u003ccode\u003emaster\u003c/code\u003e입니다. 즉, 다음과 같은 작업을 수행했다고 가정합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git clone https://git.python.org/python.git\n$ cd python\n$ git branch v1 origin/v1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 명령은 원격 저장소를 \u003ccode\u003epython\u003c/code\u003e이라는 로컬 디렉토리로 클론(clone)하고, 새로운 로컬 브랜치 \u003ccode\u003emaster\u003c/code\u003e를 생성하며, \u003ccode\u003eremotes/origin/master\u003c/code\u003e를 해당 브랜치의 상위 원격 추적 브랜치(upstream remote-tracking branch)로 설정하고 작업 디렉토리로 체크아웃합니다.\u003c/p\u003e\n\u003cp\u003e마지막 명령은 새로운 로컬 브랜치 \u003ccode\u003ev1\u003c/code\u003e을 생성하고 \u003ccode\u003eremotes/origin/v1\u003c/code\u003e을 해당 브랜치의 상위 원격 추적 브랜치로 설정합니다.\u003c/p\u003e\n\u003cp\u003e다음 명령으로 동일한 결과를 얻을 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git clone -b v1 https://git.python.org/python.git\n$ cd python\n$ git checkout --track origin/master\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막 명령은 새로운 로컬 브랜치 \u003ccode\u003emaster\u003c/code\u003e를 생성하고 \u003ccode\u003eremotes/origin/master\u003c/code\u003e를 해당 브랜치의 상위 원격 추적 브랜치로 설정하며 작업 디렉토리로 체크아웃합니다.\u003c/p\u003e\n\u003ch3\u003e브랜치와 브랜치 (Branches and branches)\u003c/h3\u003e\n\u003cp\u003eGit 용어는 혼란스러울 수 있습니다. 예를 들어, \"branch\"라는 용어는 Git에서 두 가지 의미를 가집니다. 하나는 커밋(commit)들의 지향성 있는 선(Directed line of commits, 병합(merge)을 포함할 수 있음)이고, 다른 하나는 커밋들의 선에 할당된 레이블(label) 또는 포인터(pointer)입니다. 커밋 자체에 대해 이야기하는지, 아니면 커밋의 레이블에 대해 이야기하는지 구별하는 것이 중요합니다. 커밋들의 선은 그 자체로 이름이 없으며 일반적으로 길어지고 병합될 뿐입니다. 반면, 레이블은 자유롭게 생성, 이동, 이름 변경 및 삭제될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e원격 저장소 및 원격 브랜치 (Remote repositories and remote branches)\u003c/h3\u003e\n\u003cp\u003e원격 추적 브랜치(remote-tracking branches)는 로컬 저장소에 있는 브랜치(커밋에 대한 포인터)입니다. 이는 Git(및 사용자)이 어떤 브랜치와 커밋이 어떤 원격 저장소에서 풀(pull)되거나 푸시(push)되었는지 기억하기 위한 것입니다 (여러 원격에서 풀하거나 푸시할 수 있습니다). 원격 추적 브랜치는 \u003ccode\u003eremotes/$REMOTE\u003c/code\u003e 네임스페이스 아래에 존재합니다 (예: \u003ccode\u003eremotes/origin/master\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003e원격 추적 브랜치의 상태를 보려면 다음을 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git branch -rv\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e로컬 및 원격 추적 브랜치(및 태그)가 가리키는 커밋을 보려면 다음을 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git log --decorate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e원격 추적 브랜치에서는 직접 개발하지 않습니다. 원격 브랜치를 상위로 하는 로컬 브랜치를 생성하고 해당 로컬 브랜치에서 개발을 수행합니다. 푸시 시 Git은 커밋을 원격 저장소로 푸시하고 원격 추적 브랜치를 업데이트하며, 풀 시 Git은 원격 저장소에서 커밋을 페치(fetch)하고 원격 추적 브랜치를 업데이트하며 로컬 브랜치를 Fast-forward, 병합 또는 리베이스(rebase)합니다.\u003c/p\u003e\n\u003cp\u003e다음과 같이 초기 클론을 수행할 때:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git clone -b v1 https://git.python.org/python.git\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGit은 원격 저장소 \u003ccode\u003ehttps://git.python.org/python.git\u003c/code\u003e을 \u003ccode\u003epython\u003c/code\u003e 디렉토리로 클론하고, \u003ccode\u003eorigin\u003c/code\u003e이라는 원격을 생성하며, 원격 추적 브랜치를 생성하고, 로컬 브랜치 \u003ccode\u003ev1\u003c/code\u003e을 생성하며, 이를 상위 \u003ccode\u003eremotes/origin/v1\u003c/code\u003e 브랜치를 추적하도록 구성하고 \u003ccode\u003ev1\u003c/code\u003e을 작업 디렉토리로 체크아웃합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egit status --branch\u003c/code\u003e 및 \u003ccode\u003egit branch --verbose\u003c/code\u003e와 같은 일부 명령은 로컬 브랜치와 원격 브랜치 간의 차이를 보고합니다. 이들은 로컬 저장소의 원격 추적 브랜치와만 비교하며, 해당 원격 추적 브랜치의 상태는 오래되었을 수 있음을 기억하십시오. 원격 추적 브랜치를 업데이트하려면 원격 저장소에서 커밋을 페치하고 병합(또는 리베이스)하거나, 로컬 브랜치를 업데이트하지 않고 원격 추적 브랜치만 업데이트해야 합니다.\u003c/p\u003e\n\u003ch3\u003e로컬 및 원격 추적 브랜치 업데이트 (Updating local and remote-tracking branches)\u003c/h3\u003e\n\u003cp\u003e로컬 브랜치를 업데이트하지 않고 원격 추적 브랜치를 업데이트하려면 \u003ccode\u003egit remote update [$REMOTE...]\u003c/code\u003e를 실행합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git remote update\n$ git remote update origin\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eFetch 및 Pull (Fetch and pull)\u003c/h3\u003e\n\u003cp\u003e다음 두 명령 사이에는 큰 차이가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git fetch $REMOTE $BRANCH\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git fetch $REMOTE $BRANCH:$BRANCH\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 명령은 \u003ccode\u003e$REMOTE\u003c/code\u003e 저장소의 \u003ccode\u003e$BRANCH\u003c/code\u003e에서 로컬 저장소에 없는 커밋을 페치하고, 원격 추적 브랜치를 업데이트하며, 헤드(head) 커밋의 ID(해시)를 \u003ccode\u003e.git/FETCH_HEAD\u003c/code\u003e 파일에 남깁니다.\u003c/p\u003e\n\u003cp\u003e두 번째 명령은 \u003ccode\u003e$REMOTE\u003c/code\u003e 저장소의 \u003ccode\u003e$BRANCH\u003c/code\u003e에서 로컬 저장소에 없는 커밋을 페치하고, 로컬 브랜치 \u003ccode\u003e$BRANCH\u003c/code\u003e와 해당 상위 원격 추적 브랜치를 모두 업데이트합니다. 그러나 Fast-forward가 아닌 경우에는 브랜치 업데이트를 거부합니다. 또한 현재 브랜치(현재 체크아웃된 브랜치, \u003ccode\u003eHEAD\u003c/code\u003e가 가리키는 곳) 업데이트도 거부합니다.\u003c/p\u003e\n\u003cp\u003e첫 번째 명령은 \u003ccode\u003egit pull\u003c/code\u003e에 의해 내부적으로 사용됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$ git pull $REMOTE $BRANCH\u003c/code\u003e는 다음 명령과 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git fetch $REMOTE $BRANCH\n$ git merge FETCH_HEAD\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 경우 \u003ccode\u003e$BRANCH\u003c/code\u003e는 현재 브랜치여야 합니다. 다른 브랜치를 현재 브랜치로 병합하려면 먼저 해당 비현재 브랜치를 업데이트한 다음 병합합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git fetch origin v1:v1 # v1 업데이트\n$ git pull --rebase origin master # 병합 대신 리베이스를 사용하여 현재 master 브랜치 업데이트\n$ git merge v1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아직 \u003ccode\u003ev1\u003c/code\u003e에 커밋을 푸시하지 않았다면, 시나리오는 좀 더 복잡해집니다. Git은 Fast-forward 불가능한 브랜치 업데이트를 거부하며, 강제 풀(force-pull)을 원치 않을 것입니다. 왜냐하면 강제 풀은 푸시되지 않은 커밋을 제거하고 복구해야 하기 때문입니다. 따라서 \u003ccode\u003ev1\u003c/code\u003e을 리베이스하고 싶지만, 비현재 브랜치를 리베이스할 수 없습니다. 따라서 병합하기 전에 \u003ccode\u003ev1\u003c/code\u003e을 체크아웃하고 리베이스합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git checkout v1\n$ git pull --rebase origin v1\n$ git checkout master\n$ git pull --rebase origin master\n$ git merge v1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGit을 설정하여 몇 개의 브랜치 또는 모든 브랜치를 한 번에 페치/풀하도록 할 수 있으므로, 간단히 다음을 실행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git pull origin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 심지어\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git pull\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e페치/풀을 위한 기본 원격 저장소는 \u003ccode\u003eorigin\u003c/code\u003e입니다. 페치할 기본 참조 세트는 매칭 알고리즘을 사용하여 계산됩니다. Git은 양쪽 끝에 동일한 이름을 가진 모든 브랜치를 페치합니다.\u003c/p\u003e\n\u003ch3\u003ePush\u003c/h3\u003e\n\u003cp\u003e푸시는 약간 더 간단합니다. \u003ccode\u003epush\u003c/code\u003e 명령은 하나뿐입니다. 다음을 실행할 때:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git push origin v1 master\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGit은 로컬 \u003ccode\u003ev1\u003c/code\u003e을 원격 \u003ccode\u003ev1\u003c/code\u003e으로, 로컬 \u003ccode\u003emaster\u003c/code\u003e를 원격 \u003ccode\u003emaster\u003c/code\u003e로 푸시합니다. 다음 명령과 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git push origin v1:v1 master:master\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGit은 커밋을 원격 저장소로 푸시하고 원격 추적 브랜치를 업데이트합니다. Git은 Fast-forward 불가능한 커밋 푸시를 거부합니다. 어쨌든 강제 푸시를 할 수 있지만, 자신의 저장소에만 강제 푸시해야 하며, 공개 또는 공유 저장소에는 강제 푸시하지 마십시오. Git이 Fast-forward 불가능한 커밋 푸시를 거부하는 경우, 원격 저장소에서 커밋을 페치하고 병합(또는 페치된 커밋 위에 자신의 커밋을 리베이스)한 다음 푸시하는 것이 좋습니다. 무엇을 왜 하는지 아는 경우에만 강제 푸시하십시오. 아래 \"Commit editing and caveats\" 섹션을 참조하십시오.\u003c/p\u003e\n\u003cp\u003eGit을 설정하여 몇 개의 브랜치 또는 모든 브랜치를 한 번에 푸시하도록 할 수 있으므로, 간단히 다음을 실행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git push origin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 심지어\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git push\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e푸시를 위한 기본 원격 저장소는 \u003ccode\u003eorigin\u003c/code\u003e입니다. Git 2.0 이전 버전에서 푸시할 기본 참조 세트는 매칭 알고리즘을 사용하여 계산됩니다. Git은 양쪽 끝에 동일한 이름을 가진 모든 브랜치를 푸시합니다. Git 2.0 이상 버전에서 푸시할 기본 참조 세트는 간단한 알고리즘을 사용하여 계산됩니다. Git은 현재 브랜치를 \u003ccode\u003e@ {upstream}\u003c/code\u003e으로 다시 푸시합니다.\u003c/p\u003e\n\u003cp\u003eGit 2.0 이전 버전에서 새로운 동작으로 설정하려면 다음을 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git config push.default simple\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGit 2.0 이상 버전에서 이전 동작으로 설정하려면 다음을 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git config push.default matching\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGit은 원격 non-bare 저장소에서 현재 브랜치인 경우 브랜치 푸시를 허용하지 않습니다. Git은 원격 작업 디렉토리 업데이트를 거부합니다. bare 저장소에만 푸시해야 합니다. non-bare 저장소의 경우 Git은 풀(pull) 기반 워크플로우를 선호합니다.\u003c/p\u003e\n\u003cp\u003e원격 호스트에 코드를 배포하고 푸시만 사용할 수 있는 경우(워크스테이션이 방화벽 뒤에 있어 풀할 수 없기 때문에), 두 개의 저장소를 사용하여 두 단계로 수행합니다. 워크스테이션에서 원격 호스트의 bare 저장소로 푸시하고, 원격 호스트에 SSH로 연결한 다음 bare 저장소에서 non-bare 배포 저장소로 풀합니다.\u003c/p\u003e\n\u003cp\u003e이는 Git 2.3에서 변경되었지만, 주의 사항은 블로그 게시물을 참조하십시오. 2.4에서는 push-to-deploy 기능이 더욱 개선되었습니다.\u003c/p\u003e\n\u003ch3\u003e태그 (Tags)\u003c/h3\u003e\n\u003cp\u003eGit은 페치/풀 중에 페치되는 커밋을 가리키는 태그를 자동으로 페치합니다. 모든 태그(및 태그가 가리키는 커밋)를 페치하려면 \u003ccode\u003egit fetch --tags origin\u003c/code\u003e을 실행합니다. 특정 태그를 페치하려면 명시적으로 페치합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git fetch origin tag $TAG1 tag $TAG2...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git fetch origin tag 1.4.2\n$ git fetch origin v1:v1 tag 2.1.7\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGit은 태그를 자동으로 푸시하지 않습니다. 이를 통해 비공개 태그를 가질 수 있습니다. 태그를 푸시하려면 명시적으로 나열합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git push origin tag 1.4.2\n$ git push origin v1 master tag 2.1.7\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 모든 태그를 한 번에 푸시합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git push --tags origin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e태그가 공개된 후에는 \u003ccode\u003egit tag -f\u003c/code\u003e로 태그를 이동하거나 \u003ccode\u003egit tag -d\u003c/code\u003e로 태그를 제거하지 마십시오.\u003c/p\u003e\n\u003ch3\u003e개인 정보 (Private information)\u003c/h3\u003e\n\u003cp\u003e클론/페치/풀/푸시 시 Git은 데이터베이스 객체(커밋, 트리, 파일 및 태그)와 심볼릭 참조(브랜치 및 경량 태그)만 복사합니다. 그 외의 모든 것은 저장소에 비공개이며 절대 클론, 업데이트 또는 푸시되지 않습니다. 이는 사용자의 설정, 후크(hooks), 비공개 제외 파일 등입니다.\u003c/p\u003e\n\u003cp\u003e후크를 배포하려면 작업 트리(working tree)로 복사하고, 추가(add), 커밋(commit), 푸시(push)한 다음 팀원들에게 수동으로 후크를 업데이트하고 설치하도록 지시하십시오.\u003c/p\u003e\n\u003ch3\u003e커밋 편집 및 주의사항 (Commit editing and caveats)\u003c/h3\u003e\n\u003cp\u003e게시된(푸시된) 커밋을 편집하지 말라는 경고는 문서에도 나와 있지만, 매우 중요하므로 여기에 다시 반복합니다.\u003c/p\u003e\n\u003cp\u003e강제 푸시(forced push)에서 복구하는 것은 가능하지만, 팀 전체에게 매우 번거로운 일입니다. 피해주십시오.\u003c/p\u003e\n\u003cp\u003e아직 게시되지 않은 커밋을 보려면 브랜치의 헤드와 해당 상위 원격 추적 브랜치를 비교합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git log origin/master.. # origin/master부터 HEAD(master의)까지\n$ git log origin/v1..v1 # origin/v1부터 v1의 헤드까지\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e상위 원격 추적 브랜치가 있는 모든 브랜치에 대해 Git은 \u003ccode\u003e@ {upstream}\u003c/code\u003e(줄여서 \u003ccode\u003e@ {u}\u003c/code\u003e)이라는 별칭(alias)을 유지하므로, 위 명령은 다음과 같이 주어질 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git log @{u}..\n$ git log v1@{u}..v1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 브랜치의 상태를 보려면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git branch -avv\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e로컬 브랜치의 상태를 원격 저장소와 비교하려면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git remote show origin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e상위 리베이스에서 복구하는 방법은 \u003ccode\u003egit help rebase\u003c/code\u003e를 참조하십시오.\u003c/p\u003e\n\u003cp\u003e한편, 커밋 편집에 대해 너무 두려워하지 마십시오. 아직 푸시되지 않은 커밋은 안전하게 편집, 재정렬, 제거, 결합 및 분할할 수 있습니다. 자신의 (백업) 저장소에 커밋을 푸시한 다음 나중에 편집하고 편집된 커밋을 강제 푸시하여 이미 푸시된 것을 대체할 수도 있습니다. 커밋이 공개 또는 공유 저장소에 있지 않는 한 문제가 되지 않습니다.\u003c/p\u003e\n\u003ch3\u003e되돌리기 (Undo)\u003c/h3\u003e\n\u003cp\u003e무슨 일을 하든 당황하지 마십시오. Git의 거의 모든 것은 되돌릴 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003egit checkout\u003c/code\u003e: 파일 내용 복원 (\u003ccode\u003egit checkout: restore file's content\u003c/code\u003e)\u003c/h4\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003egit checkout\u003c/code\u003e은 파일의 내용을 특정 커밋의 내용으로 복원하는 데 사용될 수 있습니다. 다음과 같이:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit checkout HEAD~ README\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 명령은 현재 브랜치에서 마지막에서 두 번째 커밋의 \u003ccode\u003eREADME\u003c/code\u003e 파일 내용을 복원합니다. 기본적으로 커밋 ID는 단순히 \u003ccode\u003eHEAD\u003c/code\u003e입니다. 즉, \u003ccode\u003egit checkout README\u003c/code\u003e는 \u003ccode\u003eREADME\u003c/code\u003e를 최신 커밋으로 복원합니다.\u003c/p\u003e\n\u003cp\u003e(커밋에 있는 파일의 내용을 보려면 \u003ccode\u003egit checkout\u003c/code\u003e을 사용하지 마십시오. \u003ccode\u003egit cat-file -p\u003c/code\u003e를 사용하십시오. 예를 들어 \u003ccode\u003egit cat-file -p HEAD~:path/to/README\u003c/code\u003e.)\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003egit reset\u003c/code\u003e: (푸시되지 않은) 커밋 제거 (\u003ccode\u003egit reset: remove (non-pushed) commits\u003c/code\u003e)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003egit reset\u003c/code\u003e은 현재 브랜치의 헤드를 이동합니다. 헤드는 어떤 커밋이든 가리키도록 이동될 수 있지만, 주로 브랜치 상단에서 하나 또는 몇 개의 (가능하면 푸시되지 않은) 커밋을 제거하는 데 사용됩니다. 즉, 몇 개의 (푸시되지 않은) 커밋을 되돌리기 위해 브랜치를 뒤로 이동시키는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egit reset\u003c/code\u003e에는 \u003ccode\u003esoft\u003c/code\u003e, \u003ccode\u003ehard\u003c/code\u003e, \u003ccode\u003emixed\u003c/code\u003e 세 가지 작동 모드가 있습니다. 기본값은 \u003ccode\u003emixed\u003c/code\u003e입니다. ProGit은 차이점을 매우 명확하게 설명합니다. bare 저장소에는 인덱스나 작업 트리가 없으므로 bare 저장소에서는 \u003ccode\u003esoft\u003c/code\u003e 리셋만 가능합니다.\u003c/p\u003e\n\u003ch4\u003e스테이징 해제 (Unstaging)\u003c/h4\u003e\n\u003cp\u003e경로 또는 경로가 있는 \u003ccode\u003emixed\u003c/code\u003e 모드 리셋은 변경 사항을 스테이징 해제(unstage)하는 데 사용될 수 있습니다. 즉, 커밋을 위해 \u003ccode\u003egit add\u003c/code\u003e로 추가된 변경 사항을 인덱스에서 제거하는 것입니다. 스테이징 해제 및 기타 되돌리기 트릭에 대한 자세한 내용은 The Book을 참조하십시오.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003egit reflog\u003c/code\u003e: 참조 로그 (\u003ccode\u003egit reflog: reference log\u003c/code\u003e)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003egit reset\u003c/code\u003e으로 커밋을 제거하거나 브랜치 헤드를 이동하는 것은 위험하게 들리며 실제로 그렇습니다. 하지만 되돌리는 방법이 있습니다. 원래 커밋으로 다시 리셋하는 것입니다. Git은 커밋을 즉시 제거하지 않습니다. 참조되지 않은 커밋(Git 용어로는 \"dangling commits\"라고 함)은 일정 기간(기본값은 2주) 동안 데이터베이스에 남아 있으므로, 이를 다시 리셋하거나 원래 커밋을 가리키는 새 브랜치를 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egit commit\u003c/code\u003e, \u003ccode\u003egit checkout\u003c/code\u003e, \u003ccode\u003egit fetch\u003c/code\u003e, \u003ccode\u003egit pull\u003c/code\u003e, \u003ccode\u003egit rebase\u003c/code\u003e, \u003ccode\u003egit reset\u003c/code\u003e 등으로 브랜치 헤드가 이동할 때마다 Git은 참조 로그(줄여서 reflog)를 저장합니다. 모든 이동에 대해 Git은 헤드가 어디에 있었는지 저장합니다. \u003ccode\u003egit reflog\u003c/code\u003e 명령은 로그를 보거나 조작하는 데 사용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e모든 브랜치 헤드의 이동 외에도 Git은 \u003ccode\u003eHEAD\u003c/code\u003e의 이동을 저장합니다. \u003ccode\u003eHEAD\u003c/code\u003e는 (일반적으로) 현재 브랜치를 나타내는 심볼릭 참조입니다. \u003ccode\u003eHEAD\u003c/code\u003e는 \u003ccode\u003egit checkout $BRANCH\u003c/code\u003e로 변경됩니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 \u003ccode\u003egit reflog\u003c/code\u003e는 \u003ccode\u003eHEAD\u003c/code\u003e의 이동을 보여줍니다. 즉, 이 명령은 \u003ccode\u003egit reflog HEAD\u003c/code\u003e와 동일합니다. 브랜치 헤드의 이동을 보려면 \u003ccode\u003egit reflog $BRANCH\u003c/code\u003e 명령을 사용합니다.\u003c/p\u003e\n\u003cp\u003e따라서 \u003ccode\u003egit reset\u003c/code\u003e을 되돌리려면 \u003ccode\u003egit reflog\u003c/code\u003e에서 원래 커밋을 찾아 \u003ccode\u003egit show\u003c/code\u003e 또는 \u003ccode\u003egit log\u003c/code\u003e로 확인하고 \u003ccode\u003egit reset $COMMIT_ID\u003c/code\u003e를 실행합니다. Git은 브랜치 헤드의 이동을 reflog에 저장하므로, 나중에 그 되돌리기를 다시 되돌릴 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e더 복잡한 상황에서는 브랜치의 헤드를 리셋하는 것과 함께 일부 커밋을 이동하고 싶을 것입니다. 이를 새 브랜치로 체리픽(cherry-pick)하십시오. 예를 들어, \u003ccode\u003emaster\u003c/code\u003e 브랜치를 원래 커밋으로 되돌리되 현재 브랜치에서 생성된 두 개의 커밋을 보존하려면 다음과 같이 수행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git branch save-master # master를 저장하는 새 브랜치 생성\n$ git reflog # master의 원래 위치 찾기\n$ git reset $COMMIT_ID\n$ git cherry-pick save-master~ save-master\n$ git branch -D save-master # 임시 브랜치 제거\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003ccode\u003egit revert\u003c/code\u003e: 커밋 되돌리기 (\u003ccode\u003egit revert: revert a commit\u003c/code\u003e)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003egit revert\u003c/code\u003e는 하나 또는 여러 커밋을 되돌립니다. 즉, 주어진 커밋의 효과를 되돌리는 새로운 커밋을 생성합니다. 이는 게시된 커밋을 되돌리는 유일한 방법입니다 (\u003ccode\u003egit commit --amend\u003c/code\u003e, \u003ccode\u003egit rebase\u003c/code\u003e, \u003ccode\u003egit reset\u003c/code\u003e은 브랜치를 Fast-forward 불가능한 방식으로 변경하므로 푸시되지 않은 커밋에만 사용해야 합니다).\u003c/p\u003e\n\u003cp\u003e병합 커밋(merge commit)을 되돌리는 데는 문제가 있습니다. \u003ccode\u003egit revert\u003c/code\u003e는 병합 커밋으로 인해 생성된 코드를 되돌릴 수 있지만, 병합 사실 자체를 되돌릴 수는 없습니다. \"How to revert a faulty merge\" 토론을 참조하십시오.\u003c/p\u003e\n\u003ch4\u003e되돌릴 수 없는 한 가지 (\u003ccode\u003eOne thing that cannot be undone\u003c/code\u003e)\u003c/h4\u003e\n\u003cp\u003e무엇을 되돌리든, 되돌릴 수 없는 한 가지가 있습니다. 덮어씌워진 커밋되지 않은 변경 사항입니다. 커밋되지 않은 변경 사항은 Git에 속하지 않으므로 Git은 이를 보존하는 데 도움이 될 수 없습니다.\u003c/p\u003e\n\u003cp\u003e대부분의 경우 Git은 커밋되지 않은 변경 사항을 덮어씌울 명령을 실행할 때 경고를 표시합니다. Git은 \u003ccode\u003egit checkout\u003c/code\u003e으로 브랜치를 전환하는 것을 허용하지 않습니다. 작업 트리가 깨끗하지 않은 상태에서 리베이스하려고 할 때 Git은 중단시킵니다. 커밋되지 않은 파일 위에 새 커밋을 풀하는 것을 거부합니다.\u003c/p\u003e\n\u003cp\u003e그러나 정확히 파일 덮어쓰기를 수행하는 명령이 있습니다. \u003ccode\u003egit checkout $PATHs\u003c/code\u003e 또는 \u003ccode\u003egit reset --hard\u003c/code\u003e와 같은 명령은 커밋되지 않은 변경 사항을 포함하여 파일을 자동으로 덮어씌웁니다.\u003c/p\u003e\n\u003cp\u003e이를 염두에 두고 \"일찍 커밋하고 자주 커밋하라(commit early, commit often)\"는 입장을 이해할 수 있습니다. 가능한 한 자주 커밋하십시오. 편집기 또는 IDE에서 저장할 때마다 커밋하십시오. 푸시하기 전에 커밋을 편집할 수 있습니다. 커밋 메시지를 편집하고, 커밋을 변경하고, 재정렬하고, 결합하고, 분할하고, 제거할 수 있습니다. 그러나 변경 사항을 Git 데이터베이스에 저장하십시오. 변경 사항을 커밋하거나 최소한 \u003ccode\u003egit stash\u003c/code\u003e로 스태시(stash)하십시오.\u003c/p\u003e\n\u003ch3\u003e병합 또는 리베이스? (Merge or rebase?)\u003c/h3\u003e\n\u003cp\u003e인터넷은 \"병합 또는 리베이스?\"라는 주제에 대한 열띤 토론으로 가득합니다. 대부분은 의미가 없습니다. 많은 브랜치가 있는 크고 복잡한 프로젝트에서 대규모 팀이 DVCS(분산 버전 관리 시스템)를 사용하는 경우 병합을 피할 방법이 없습니다. 따라서 질문은 \"리베이스를 사용할 것인가, 그렇다면 언제 리베이스를 사용할 것인가?\"로 축소됩니다. 게시된 커밋을 리베이스하지 않는 것이 강력히 권장된다는 점을 고려하면 질문은 더욱 축소됩니다. \"푸시되지 않은 커밋에 리베이스를 사용할 것인가?\"\u003c/p\u003e\n\u003cp\u003e이 작은 질문은 팀이 결정할 문제입니다. 선형 히스토리의 아름다움을 보존하기 위해 풀할 때 리베이스를 사용하는 것이 좋습니다. 즉, \u003ccode\u003egit pull --rebase\u003c/code\u003e를 수행하거나, 모든 새 브랜치에 대해 리베이스의 자동 설정을 구성할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git config branch.autosetuprebase always\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 기존 브랜치에 대해 리베이스를 구성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git config branch.$NAME.rebase true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git config branch.v1.rebase true\n$ git config branch.master.rebase true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 후 \u003ccode\u003egit pull origin master\u003c/code\u003e는 \u003ccode\u003egit pull --rebase origin master\u003c/code\u003e와 동일해집니다.\u003c/p\u003e\n\u003cp\u003e메인라인 브랜치를 업데이트하기 위해 리베이스를 사용하는 동안 별도의 기능 또는 토픽 브랜치에서 새 커밋을 생성하는 것이 좋습니다. 토픽 브랜치가 준비되면 메인라인으로 병합합니다. 한 번에 많은 수의 충돌을 해결하는 번거로운 작업을 피하려면 토픽 브랜치를 때때로 메인라인으로 병합한 다음 토픽 브랜치로 다시 전환하여 작업을 계속할 수 있습니다. 전체 워크플로우는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git checkout -b issue-42 # 새 이슈 브랜치를 생성하고 전환\n...edit/test/commit...\n$ git checkout master\n$ git pull --rebase origin master # 상위에서 master 업데이트\n$ git merge issue-42\n$ git branch -d issue-42 # 토픽 브랜치 삭제\n$ git push origin master\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e토픽 브랜치가 삭제되면 레이블만 제거되고 커밋은 데이터베이스에 남아 있습니다. 이제 커밋은 \u003ccode\u003emaster\u003c/code\u003e에 병합되었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eo--o--o--o--o--M--\u0026#x3C; master - 메인라인 브랜치\n \\ /\n  --*--*--* - 토픽 브랜치, 이제 이름 없음\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e토픽 브랜치는 작은 토픽 브랜치로 인한 브랜치 네임스페이스의 혼란을 피하기 위해 삭제됩니다. 어떤 문제가 해결되었는지 또는 어떤 기능이 구현되었는지에 대한 정보는 커밋 메시지에 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e그러나 장기 병합된 브랜치의 경우 이처럼 적은 양의 리베이스도 너무 클 수 있습니다. \u003ccode\u003ev1\u003c/code\u003e과 \u003ccode\u003emaster\u003c/code\u003e 브랜치에서 모두 작업하고 \u003ccode\u003ev1\u003c/code\u003e을 \u003ccode\u003emaster\u003c/code\u003e로 정기적으로 병합한다고 가정해 보십시오. 얼마 후 \u003ccode\u003emaster\u003c/code\u003e에 많은 병합 및 비병합 커밋이 있을 것입니다. 그런 다음 완료된 작업을 공유 저장소에 푸시하려고 할 때 누군가가 \u003ccode\u003ev1\u003c/code\u003e에 몇 개의 커밋을 푸시한 것을 발견합니다. 이제 두 가지 똑같이 나쁜 대안 중에서 선택해야 합니다. \u003ccode\u003ev1\u003c/code\u003e을 페치하고 리베이스한 다음 \u003ccode\u003emaster\u003c/code\u003e에서 모든 작업을 다시 생성해야 하거나(master를 원본으로 리셋하고 v1을 병합한 다음 이전 master에서 모든 비병합 커밋을 체리픽), 새 \u003ccode\u003ev1\u003c/code\u003e을 병합하고 선형 히스토리의 아름다움을 잃게 됩니다.\u003c/p\u003e\n\u003ch3\u003eNull-병합 (Null-merges)\u003c/h3\u003e\n\u003cp\u003eGit에는 Python 핵심 개발자들이 \"null-merge\"라고 부르는 것에 대한 내장 병합 전략이 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git merge -s ours v1 # master에 v1 null-병합\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e브랜칭 모델 (Branching models)\u003c/h3\u003e\n\u003cp\u003eGit은 브랜칭 및 병합과 관련하여 특정 개발 모델을 가정하지 않습니다. 일부 프로젝트는 가장 오래된 브랜치에서 최신 브랜치로 패치를 승격하는 것을 선호하고, 일부는 커밋을 역방향으로 체리픽하는 것을 선호하며, 일부는 스쿼싱(여러 커밋을 하나로 결합)을 사용합니다. 모든 것이 가능합니다.\u003c/p\u003e\n\u003cp\u003e시작할 몇 가지 예시가 있습니다. \u003ccode\u003egit help workflows\u003c/code\u003e는 Git 저자들이 Git을 개발하는 방법을 설명합니다.\u003c/p\u003e\n\u003cp\u003eProGit 책에는 다양한 프로젝트의 브랜치 관리에 대한 몇 가지 장이 있습니다: \"Git Branching - Branching Workflows\" 및 \"Distributed Git - Contributing to a Project\".\u003c/p\u003e\n\u003cp\u003eVincent Driessen의 \"A successful Git branching model\"이라는 잘 알려진 기사도 있습니다. 이 기사는 메인라인, 토픽 및 버그 수정 브랜치를 생성하고 관리하는 데 매우 상세한 규칙 세트를 권장합니다. 이 모델을 지원하기 위해 저자는 \u003ccode\u003egit flow\u003c/code\u003e 확장을 구현했습니다.\u003c/p\u003e\n\u003ch3\u003e고급 구성 (Advanced configuration)\u003c/h3\u003e\n\u003ch4\u003e줄 끝 (Line endings)\u003c/h4\u003e\n\u003cp\u003eGit에는 서로 다른 줄 끝 스타일을 가진 플랫폼 간의 줄 끝을 처리하는 내장 메커니즘이 있습니다. Git이 CRLF 변환을 수행하도록 허용하려면 \u003ccode\u003e.gitattributes\u003c/code\u003e를 사용하여 파일에 \u003ccode\u003etext\u003c/code\u003e 속성을 할당하십시오. 특정 줄 끝이 필요한 파일에는 \u003ccode\u003eeol\u003c/code\u003e 속성을 할당하십시오. 바이너리 파일의 경우 속성은 당연히 \u003ccode\u003ebinary\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ cat .gitattributes\n*.py text\n*.txt text\n*.png binary\n/readme.txt eol=CRLF\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGit이 파일에 사용하는 속성을 확인하려면 \u003ccode\u003egit check-attr\u003c/code\u003e 명령을 사용합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git check-attr -a -- \\*.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e유용한 자산 (Useful assets)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eGitAlias\u003c/code\u003e (repository): 별칭(aliases)의 방대한 컬렉션입니다. 자주 사용되는 명령에 대한 신중한 별칭 선택은 많은 키 입력 시간을 절약할 수 있습니다!\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGitIgnore\u003c/code\u003e 및 \u003ccode\u003ehttps://github.com/github/gitignore\u003c/code\u003e: 모든 종류의 IDE 및 프로그래밍 언어에 대한 \u003ccode\u003e.gitignore\u003c/code\u003e 파일 컬렉션입니다. Python도 포함되어 있습니다!\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epre-commit\u003c/code\u003e (repositories): 다국어 pre-commit 후크를 관리하고 유지 관리하기 위한 프레임워크입니다. 이 프레임워크는 Python으로 작성되었으며 많은 프로그래밍 언어에 대한 많은 플러그인을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e고급 주제 (Advanced topics)\u003c/h3\u003e\n\u003ch4\u003e스테이징 영역 (Staging area)\u003c/h4\u003e\n\u003cp\u003e스테이징 영역(Staging area), 일명 인덱스(index), 일명 캐시(cache)는 Git의 특징적인 기능입니다. 스테이징 영역은 Git이 커밋하기 전에 패치를 수집하는 곳입니다. 패치 수집 단계와 커밋 단계의 분리는 Git의 매우 유용한 기능을 제공합니다. 커밋하기 전에 수집된 패치를 검토하고 편집할 수도 있습니다. 일부 덩어리(hunks)를 제거하고, 새로운 덩어리를 추가하고, 다시 검토할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e파일을 인덱스에 추가하려면 \u003ccode\u003egit add\u003c/code\u003e를 사용합니다. 커밋하기 전에 패치를 수집한다는 것은 새로운(추적되지 않은) 파일뿐만 아니라 모든 변경 사항에 대해 이 작업을 수행해야 함을 의미합니다. 검토 없이 모든 것을 커밋하려는 경우 커밋을 단순화하려면 \u003ccode\u003egit commit --all\u003c/code\u003e (또는 \u003ccode\u003e-a\u003c/code\u003e)을 실행합니다. 이 명령은 변경된 모든 추적 파일을 인덱스에 추가한 다음 커밋합니다. 인덱스에 수집된 패치와 관계없이 하나 또는 여러 파일을 커밋하려면 \u003ccode\u003egit commit [--only|-o] -- $FILE...\u003c/code\u003e을 실행합니다.\u003c/p\u003e\n\u003cp\u003e패치의 덩어리를 인덱스에 추가하려면 \u003ccode\u003egit add --patch\u003c/code\u003e (또는 \u003ccode\u003e-p\u003c/code\u003e)를 사용합니다. 수집된 파일을 인덱스에서 제거하려면 \u003ccode\u003egit reset HEAD -- $FILE...\u003c/code\u003e을 사용합니다. 수집된 덩어리를 추가/검사/제거하려면 \u003ccode\u003egit add --interactive\u003c/code\u003e (\u003ccode\u003e-i\u003c/code\u003e)를 사용합니다.\u003c/p\u003e\n\u003cp\u003e인덱스와 마지막 커밋 간의 차이(즉, 수집된 패치)를 보려면 \u003ccode\u003egit diff --cached\u003c/code\u003e를 사용합니다. 작업 트리와 인덱스 간의 차이(즉, 수집되지 않은 패치)를 보려면 \u003ccode\u003egit diff\u003c/code\u003e를 사용합니다. 작업 트리와 마지막 커밋 간의 차이(즉, 수집된 패치와 수집되지 않은 패치 모두)를 보려면 \u003ccode\u003egit diff HEAD\u003c/code\u003e를 실행합니다.\u003c/p\u003e\n\u003cp\u003eGit Wiki의 \"WhatIsTheIndex\" 및 \"IndexCommandQuickref\"를 참조하십시오.\u003c/p\u003e\n\u003ch4\u003eRoot\u003c/h4\u003e\n\u003cp\u003eGit은 어떤 명령을 실행하기 전에 루트( \u003ccode\u003e.git\u003c/code\u003e 서브디렉토리가 존재하는 프로젝트의 최상위 디렉토리)로 전환합니다. 그러나 Git은 전환하기 전에 현재 디렉토리가 무엇이었는지 기억합니다. 일부 프로그램은 현재 디렉토리를 고려합니다. 예를 들어, \u003ccode\u003egit status\u003c/code\u003e는 현재 디렉토리를 기준으로 변경 및 알 수 없는 파일의 파일 경로를 보여줍니다. \u003ccode\u003egit grep\u003c/code\u003e은 현재 디렉토리 아래를 검색합니다. \u003ccode\u003egit apply\u003c/code\u003e는 현재 디렉토리 아래의 파일을 건드리는 패치에서 해당 덩어리만 적용합니다.\u003c/p\u003e\n\u003cp\u003e그러나 대부분의 명령은 루트에서 실행되며 현재 디렉토리를 무시합니다. 예를 들어, \u003ccode\u003ev1\u003c/code\u003e 브랜치용 작업 트리와 \u003ccode\u003emaster\u003c/code\u003e 브랜치용 작업 트리 두 개가 있다고 가정해 보십시오. 두 번째 작업 트리의 하위 디렉토리에서 \u003ccode\u003ev1\u003c/code\u003e을 병합하려면 최상위 디렉토리에 있는 것처럼 명령을 작성해야 합니다. 예를 들어, \u003ccode\u003eproject-v1\u003c/code\u003e과 \u003ccode\u003eproject\u003c/code\u003e 두 개의 작업 트리를 사용해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ cd project/subdirectory\n$ git fetch ../project-v1 v1:v1\n$ git merge v1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egit fetch ../project-v1 v1:v1\u003c/code\u003e의 경로 \u003ccode\u003e../project-v1\u003c/code\u003e은 하위 디렉토리에서 명령을 실행했음에도 불구하고 \u003ccode\u003e../../project-v1\u003c/code\u003e이 아님을 참고하십시오.\u003c/p\u003e\n\u003ch4\u003eReReRe\u003c/h4\u003e\n\u003cp\u003eReReRe는 반복되는 병합 충돌을 해결하는 데 도움이 되는 메커니즘입니다. 반복되는 병합 충돌의 가장 흔한 원인은 메인라인으로 병합된 다음 병합 커밋이 제거되는 토픽 브랜치입니다. 이는 종종 토픽 브랜치를 테스트하고 ReReRe를 훈련하기 위해 수행됩니다. 병합 커밋은 깔끔한 선형 히스토리를 가지고 하나의 마지막 병합 커밋으로 토픽 브랜치를 마무리하기 위해 제거됩니다.\u003c/p\u003e\n\u003cp\u003eReReRe는 성공적인 커밋 전후의 트리 상태를 기억함으로써 작동합니다. 이러한 방식으로 ReReRe는 동일한 파일에 충돌이 나타나면 자동으로 해결할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eReReRe는 \u003ccode\u003egit rerere\u003c/code\u003e 명령으로 수동으로 사용될 수 있지만, 대부분의 경우 자동으로 사용됩니다. 작업 트리에서 다음 명령으로 ReReRe를 활성화합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git config rerere.enabled true\n$ git config rerere.autoupdate true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReReRe를 전역적으로 켤 필요는 없습니다. bare 저장소나 단일 브랜치 저장소에서는 ReReRe를 원치 않을 것입니다. 병합 및 병합 충돌을 자주 수행하고 해결하는 저장소에서만 ReReRe가 필요합니다.\u003c/p\u003e\n\u003cp\u003eThe Book의 \"Rerere\" 섹션을 참조하십시오.\u003c/p\u003e\n\u003ch4\u003e데이터베이스 유지 관리 (Database maintenance)\u003c/h4\u003e\n\u003cp\u003eGit 객체 데이터베이스 및 \u003ccode\u003e.git\u003c/code\u003e 아래의 기타 파일/디렉토리는 주기적인 유지 관리 및 정리가 필요합니다. 예를 들어, 커밋 편집은 참조되지 않은 객체(Git 용어로는 dangling objects)를 남기며, 이러한 객체는 DB에 불필요한 데이터를 쌓는 것을 방지하기 위해 제거되어야 합니다. \u003ccode\u003egit gc\u003c/code\u003e 명령은 유지 관리에 사용됩니다. Git은 일부 명령의 일부로 \u003ccode\u003egit gc --auto\u003c/code\u003e를 자동으로 실행하여 빠른 유지 관리를 수행합니다. 사용자에게는 \u003ccode\u003egit gc --aggressive\u003c/code\u003e를 가끔 실행하는 것이 권장됩니다. \u003ccode\u003egit help gc\u003c/code\u003e는 몇백 개의 변경 사항마다 실행하는 것을 권장하며, 더 집중적인 프로젝트의 경우 일주일에 한 번 정도, 활동이 적은 프로젝트의 경우 더 드물게(2주에 한 번 또는 한 달에 한 번) 실행해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egit gc --aggressive\u003c/code\u003e는 dangling 객체를 제거할 뿐만 아니라, 객체 데이터베이스를 인덱싱되고 더 최적화된 팩(pack)으로 재패킹합니다. 또한 심볼릭 참조(브랜치 및 태그)도 패킹합니다. 이를 수행하는 또 다른 방법은 \u003ccode\u003egit repack\u003c/code\u003e을 실행하는 것입니다.\u003c/p\u003e\n\u003cp\u003eLinus Torvalds의 \u003ccode\u003egit gc --aggressive\u003c/code\u003e의 \"어리석음\"에 관한 잘 알려진 메시지가 있습니다. 이 메시지는 이제 안전하게 무시할 수 있습니다. 오래되고 시대에 뒤떨어진 메시지이며, \u003ccode\u003egit gc --aggressive\u003c/code\u003e는 그 이후로 훨씬 나아졌습니다.\u003c/p\u003e\n\u003cp\u003e여전히 \u003ccode\u003egit gc --aggressive\u003c/code\u003e보다 \u003ccode\u003egit repack\u003c/code\u003e을 선호하는 사람들을 위한 권장 매개변수는 \u003ccode\u003egit repack -a -d -f --depth=20 --window=250\u003c/code\u003e입니다. 이 매개변수의 효과에 대한 설명은 이 자세한 실험을 참조하십시오.\u003c/p\u003e\n\u003cp\u003e때때로 \u003ccode\u003egit fsck [--strict]\u003c/code\u003e를 실행하여 데이터베이스의 무결성을 확인합니다. \u003ccode\u003egit fsck\u003c/code\u003e는 dangling 객체 목록을 생성할 수 있습니다. 이는 오류가 아니라 정기적인 유지 관리를 수행해야 한다는 알림입니다.\u003c/p\u003e\n\u003ch3\u003e팁과 트릭 (Tips and tricks)\u003c/h3\u003e\n\u003ch4\u003e명령줄 옵션 및 인수 (Command-line options and arguments)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003egit help cli\u003c/code\u003e는 짧은 옵션/플래그를 결합하지 말 것을 권장합니다. 대부분의 경우 결합이 작동합니다. \u003ccode\u003egit commit -av\u003c/code\u003e는 완벽하게 작동하지만, 작동하지 않는 상황도 있습니다. 예를 들어, \u003ccode\u003egit log -p -5\u003c/code\u003e는 \u003ccode\u003egit log -p5\u003c/code\u003e로 결합할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e일부 옵션에는 인수가 있으며, 일부는 기본 인수도 있습니다. 이 경우 해당 옵션의 인수는 \u003ccode\u003e -Oarg\u003c/code\u003e와 같이 붙여서 입력해야 합니다. \u003ccode\u003e-O arg\u003c/code\u003e는 안 됩니다. 왜냐하면 기본 인수가 있는 옵션의 경우 후자는 \"-O 옵션에 기본값을 사용하고 arg를 옵션 파서에 추가로 전달\"한다는 의미이기 때문입니다. 예를 들어, \u003ccode\u003egit grep\u003c/code\u003e에는 찾은 파일 이름 목록을 프로그램에 전달하는 \u003ccode\u003e-O\u003c/code\u003e 옵션이 있습니다. \u003ccode\u003e-O\u003c/code\u003e의 기본 프로그램은 페이저(일반적으로 \u003ccode\u003eless\u003c/code\u003e)이지만, 편집기를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git grep -Ovim # 하지만 -O vim은 안 됩니다\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e덧붙여, Git이 \u003ccode\u003eless\u003c/code\u003e를 페이저로 사용하도록 지시받은 경우(\u003ccode\u003epager\u003c/code\u003e가 Git에 전혀 구성되지 않은 경우 기본적으로 \u003ccode\u003eless\u003c/code\u003e를 사용하거나, \u003ccode\u003eGIT_PAGER\u003c/code\u003e 또는 \u003ccode\u003ePAGER\u003c/code\u003e 환경 변수에서 \u003ccode\u003eless\u003c/code\u003e를 얻거나, \u003ccode\u003egit config [--global] core.pager less\u003c/code\u003e로 구성되었거나, \u003ccode\u003egit grep -Oless\u003c/code\u003e 명령에서 \u003ccode\u003eless\u003c/code\u003e가 사용된 경우) \u003ccode\u003egit grep\u003c/code\u003e은 \u003ccode\u003e+/$pattern\u003c/code\u003e 옵션을 \u003ccode\u003eless\u003c/code\u003e에 전달하는데, 이는 매우 편리합니다. 불행히도, 페이저가 정확히 \u003ccode\u003eless\u003c/code\u003e가 아닌 경우(\u003ccode\u003eless\u003c/code\u003e에 매개변수가 있는 경우에도, 예를 들어 \u003ccode\u003egit config [--global] core.pager less -FRSXgimq\u003c/code\u003e) \u003ccode\u003egit grep\u003c/code\u003e은 패턴을 전달하지 않습니다. 다행히도 \u003ccode\u003egit grep -Oless\u003c/code\u003e는 항상 패턴을 전달합니다.\u003c/p\u003e\n\u003ch4\u003eBash/Zsh 완성 (bash/zsh completion)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003egit rebase --interactive --preserve-merges HEAD~5\u003c/code\u003e를 수동으로 입력하는 것은 명령줄 사용을 즐기는 사람들에게도 다소 어렵습니다. 이때 쉘 완성(shell completion)이 큰 도움이 됩니다. Bash/Zsh는 프로그래밍 가능한 완성 기능을 제공하며, 종종 자동으로 설치 및 활성화되므로 Bash/Zsh 및 Git이 설치되어 있다면 이미 완료되었을 가능성이 높습니다. 명령줄에서 사용하기만 하면 됩니다.\u003c/p\u003e\n\u003cp\u003e필요한 요소가 설치되어 있지 않은 경우 \u003ccode\u003ebash_completion\u003c/code\u003e 패키지를 설치하고 활성화하십시오. Git 완성 기능을 최신 버전으로 업그레이드하려면 Git contrib에서 필요한 파일을 다운로드하십시오.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eGit-for-windows\u003c/code\u003e에는 Bash 완성이 설치 및 활성화된 \u003ccode\u003egit-bash\u003c/code\u003e가 함께 제공됩니다.\u003c/p\u003e\n\u003ch4\u003eBash/Zsh 프롬프트 (bash/zsh prompt)\u003c/h4\u003e\n\u003cp\u003e명령줄 애호가를 위해 쉘 프롬프트는 많은 유용한 정보를 담을 수 있습니다. 프롬프트에 Git 정보를 포함하려면 \u003ccode\u003egit-prompt.sh\u003c/code\u003e를 사용하십시오. 파일의 자세한 지침을 읽으십시오.\u003c/p\u003e\n\u003cp\u003e다른 프롬프트 변형을 찾으려면 인터넷에서 \"git prompt\"를 검색하십시오.\u003c/p\u003e\n\u003ch4\u003eSSH 연결 공유 (SSH connection sharing)\u003c/h4\u003e\n\u003cp\u003eSSH 연결 공유는 OpenSSH 및 PuTTY와 같은 파생 제품의 기능입니다. SSH 연결 공유는 하나의 연결을 설정하고 동일한 서버에 연결하는 모든 후속 클라이언트에 대해 재사용함으로써 SSH 클라이언트 시작 시간을 줄이는 방법입니다. SSH 연결 공유는 \u003ccode\u003escp\u003c/code\u003e, \u003ccode\u003esftp\u003c/code\u003e, \u003ccode\u003ersync\u003c/code\u003e 및 물론 SSH를 통한 Git과 같은 많은 짧은 SSH 세션 속도를 높이는 데 사용될 수 있습니다. SSH를 통해 액세스할 수 있는 원격 저장소에서 정기적으로 페치/풀/푸시하는 경우 SSH 연결 공유를 사용하는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003eSSH 연결 공유를 켜려면 \u003ccode\u003e~/.ssh/config\u003c/code\u003e에 다음과 같은 내용을 추가합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eHost *\n  ControlMaster auto\n  ControlPath ~/.ssh/mux-%r@%h:%p\n  ControlPersist 600\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOpenSSH wikibook을 참조하고 더 많은 정보를 검색하십시오.\u003c/p\u003e\n\u003cp\u003eSSH 연결 공유는 GitHub, GitLab 및 SourceForge 저장소에서 사용할 수 있지만, BitBucket은 허용하지 않으며 짧은 비활성 기간 후에 마스터 연결을 강제로 닫으므로 SSH에서 다음과 같은 오류가 표시될 수 있습니다. \"Connection to bitbucket.org closed by remote host.\"\u003c/p\u003e\n\u003ch3\u003e서버의 Git (git on server)\u003c/h3\u003e\n\u003cp\u003e하나 또는 여러 저장소를 게시하는 가장 간단한 방법은 \u003ccode\u003egit daemon\u003c/code\u003e입니다. 데몬은 익명 액세스를 제공하며, 기본적으로 읽기 전용입니다. 저장소는 Git 프로토콜(\u003ccode\u003egit://\u003c/code\u003e URL)로 액세스할 수 있습니다. 쓰기 액세스를 활성화할 수 있지만, 이 프로토콜은 인증 수단이 없으므로 신뢰할 수 있는 LAN 내에서만 활성화해야 합니다. 자세한 내용은 \u003ccode\u003egit help daemon\u003c/code\u003e을 참조하십시오.\u003c/p\u003e\n\u003cp\u003eSSH를 통한 Git은 인증 및 저장소 수준 권한 부여를 제공합니다. 저장소는 사용자 또는 그룹 쓰기 가능으로 만들 수 있습니다(\u003ccode\u003egit help config\u003c/code\u003e에서 \u003ccode\u003ecore.sharedRepository\u003c/code\u003e 매개변수 참조). 일부 프로젝트 요구 사항에 너무 허용적이거나 너무 제한적인 경우, 세분화된 액세스를 허용하도록 구성할 수 있는 래퍼(wrapper) \u003ccode\u003egitolite\u003c/code\u003e가 있습니다. \u003ccode\u003egitolite\u003c/code\u003e는 Perl로 작성되었으며 많은 문서를 가지고 있습니다.\u003c/p\u003e\n\u003cp\u003e저장소를 탐색하는 웹 인터페이스는 \u003ccode\u003egitweb\u003c/code\u003e 또는 \u003ccode\u003ecgit\u003c/code\u003e을 사용하여 만들 수 있습니다. 둘 다 CGI 스크립트(Perl 및 C로 작성됨)입니다. 웹 인터페이스 외에도 둘 다 Git에 대한 읽기 전용 dumb HTTP 액세스(\u003ccode\u003ehttp(s)://\u003c/code\u003e URL)를 제공합니다. Klaus는 웹 인터페이스와 Git smart HTTP 전송을 모두 구현하는 작고 간단한 WSGI 웹 서버입니다. Python 2 및 Python 3을 지원하며 구문 강조를 수행합니다.\u003c/p\u003e\n\u003cp\u003e사용자, 그룹 및 프로젝트를 관리하는 기능, 비공개, 그룹 액세스 가능 및 공개 저장소, 이슈 트래커, 위키 페이지, 풀 리퀘스트 및 개발 및 통신을 위한 기타 도구를 포함하는 더 고급 웹 기반 개발 환경도 있습니다. 이러한 환경 중에는 Kallithea 및 pagure가 있으며, 둘 다 Python으로 작성되었습니다. pagure는 Fedora 개발자에 의해 작성되었으며 일부 Fedora 프로젝트 개발에 사용되고 있습니다. GitPrep은 Perl로 작성된 또 다른 GitHub 클론입니다. Gogs는 Go로 작성되었습니다. GitBucket은 Scala로 작성되었습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, GitLab. Git을 위한 가장 고급 웹 기반 개발 환경일 것입니다. Ruby로 작성되었으며, 커뮤니티 에디션은 무료 오픈 소스(MIT 라이선스)입니다.\u003c/p\u003e\n\u003ch3\u003eMercurial에서 Git으로 (From Mercurial to git)\u003c/h3\u003e\n\u003cp\u003eMercurial 저장소를 Git으로 변환하는 많은 도구가 있습니다. 가장 유명한 것은 아마도 \u003ccode\u003ehg-git\u003c/code\u003e 및 \u003ccode\u003efast-export\u003c/code\u003e일 것입니다(몇 년 전에는 \u003ccode\u003ehg2git\u003c/code\u003e이라는 이름으로 알려졌습니다).\u003c/p\u003e\n\u003cp\u003e그러나 더 나은 도구, 아마도 최고는 \u003ccode\u003egit-remote-hg\u003c/code\u003e입니다. 이는 Git에서 Mercurial 저장소로 투명한 양방향(풀 및 푸시) 액세스를 제공합니다. 그 저자는 대부분 객관적인 대안 비교를 작성했습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egit-remote-hg\u003c/code\u003e를 사용하려면, 이를 설치하거나 클론하고 \u003ccode\u003ePATH\u003c/code\u003e에 추가하거나 (\u003ccode\u003egit-remote-hg\u003c/code\u003e 스크립트를 \u003ccode\u003ePATH\u003c/code\u003e에 이미 있는 디렉토리로 복사) Mercurial URL 앞에 \u003ccode\u003ehg::\u003c/code\u003e를 붙입니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ git clone https://github.com/felipec/git-remote-hg.git\n$ PATH=$PATH:\"`pwd`\"/git-remote-hg\n$ git clone hg::https://hg.python.org/peps/ PEPs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e저장소와 작업하려면 \u003ccode\u003egit fetch/pull/push\u003c/code\u003e를 포함한 일반 Git 명령을 사용하십시오.\u003c/p\u003e\n\u003cp\u003eMercurial 습관을 Git으로 전환하려면 Mercurial Wiki의 \"Mercurial for Git users\" 페이지를 참조하십시오. 페이지의 두 번째 절반에는 해당 Mercurial 및 Git 명령을 나열하는 표가 있습니다. 양방향으로 완벽하게 작동해야 합니다.\u003c/p\u003e\n\u003cp\u003ePython 개발자 가이드에도 Git과 Hg의 몇 가지 차이점을 문서화하는 \"Mercurial for git developers\" 장이 있습니다.\u003c/p\u003e\n\u003ch3\u003eGit 및 GitHub (Git and GitHub)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003egitsome\u003c/code\u003e: Git/GitHub 명령줄 인터페이스(CLI)입니다. Python으로 작성되었으며 MacOS, Unix, Windows에서 작동합니다. 자동 완성 기능을 갖춘 Git/GitHub CLI로, 모든 쉘에서 작동하는 많은 GitHub 통합 명령, 쉘 명령과 함께 Python 명령을 실행할 수 있는 내장 Xonsh (Python REPL), 명령 히스토리, 사용자 정의 가능한 하이라이팅, 철저한 문서화를 포함합니다.\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\n원본: \u003ccode\u003ehttps://github.com/python/peps/blob/main/peps/pep-0103.rst\u003c/code\u003e\n최종 수정: 2024년 4월 14일 20:08:31 GMT\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Withdrawn] PEP 103 - Collecting information about git\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 16:06:44+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>