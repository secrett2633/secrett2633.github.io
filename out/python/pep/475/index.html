<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 475 - Retry system calls failing with EINTR</h1><div class="page__meta"><time dateTime="2025-09-26 22:21:40+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0475/">PEP 475 - Retry system calls failing with EINTR</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 29-Jul-2014</p>
</blockquote>
<h2>PEP 475 – <code>EINTR</code> 오류로 실패하는 시스템 호출 재시도</h2>
<h3>초록 (Abstract)</h3>
<p>표준 라이브러리에서 제공하는 시스템 호출 래퍼(wrapper)는 <code>EINTR</code> 오류로 실패할 경우 자동으로 재시도해야 합니다. 이는 애플리케이션 코드에서 이러한 재시도 로직을 직접 처리해야 하는 부담을 덜어주기 위함입니다. 여기서 "시스템 호출"이란 I/O 또는 기타 시스템 자원 처리에 관련된 표준 C 라이브러리 함수들을 의미합니다.</p>
<h3>배경 (Rationale)</h3>
<h4>중단된 시스템 호출 (Interrupted system calls)</h4>
<p>POSIX 시스템에서 시그널(signal)은 흔하게 발생하며, 시스템 호출을 호출하는 코드는 이러한 시그널을 처리할 준비가 되어 있어야 합니다. 일반적인 시그널의 예시는 다음과 같습니다.</p>
<ul>
<li><code>SIGINT</code>: Ctrl+C를 눌렀을 때 발생하는 가장 흔한 시그널입니다. Python은 기본적으로 이 시그널을 받으면 <code>KeyboardInterrupt</code> 예외를 발생시킵니다.</li>
<li><code>SIGCHLD</code>: 자식 프로세스가 종료될 때 서브프로세스(subprocesses)에서 발생합니다.</li>
<li><code>SIGWINCH</code>: 터미널 크기를 조절할 때 터미널에서 실행 중인 애플리케이션에 전송됩니다.</li>
<li><code>SIGCONT</code>: 애플리케이션을 백그라운드로 전환할 때(예: Ctrl+Z를 누른 후 <code>bg</code> 명령어를 입력) 전송됩니다.</li>
</ul>
<p>C 시그널 핸들러를 작성하는 것은 어렵습니다. "비동기-시그널-안전(async-signal-safe)" 함수만 호출할 수 있고(<code>printf()</code>와 <code>malloc()</code>은 async-signal-safe가 아님), 재진입(reentrancy) 문제가 있기 때문입니다. 따라서 시스템 호출 실행 중에 프로세스가 시그널을 받으면, 프로그램이 시그널-안전 함수에 대한 제약 없이 시그널을 처리할 기회를 주기 위해 시스템 호출이 <code>EINTR</code> 오류와 함께 실패할 수 있습니다.</p>
<p>이러한 동작은 시스템에 따라 다릅니다. 특정 시스템에서는 <code>SA_RESTART</code> 플래그를 사용하여 일부 시스템 호출이 <code>EINTR</code>로 실패하는 대신 자동으로 재시도됩니다. 그러나 Python의 <code>signal.signal()</code> 함수는 시그널 핸들러를 설정할 때 <code>SA_RESTART</code> 플래그를 지웁니다. 이로 인해 Python에서는 모든 시스템 호출이 <code>EINTR</code>로 실패할 가능성이 높습니다.</p>
<p>시그널 수신은 예외적인 상황이 아니므로, 견고한 POSIX 코드는 <code>EINTR</code>를 처리할 준비가 되어 있어야 합니다 (대부분의 경우, 이는 호출이 결국 성공하기를 바라면서 루프에서 재시도하는 것을 의미합니다). Python의 특별한 지원 없이는 애플리케이션 코드가 필요 이상으로 장황해질 수 있습니다.</p>
<h4>Python 3.4의 현황 (Status in Python 3.4)</h4>
<p>Python 3.4에서는 <code>InterruptedError</code> 예외(<code>EINTR</code> 전용 예외 클래스) 처리가 모든 호출 지점(call site)에서 개별적으로 중복되어 있었습니다. 실제로 이 예외를 처리하는 Python 모듈은 몇 개에 불과했으며, 수정 사항이 전체 모듈에 적용되기까지는 보통 몇 년이 걸렸습니다.</p>
<p><code>InterruptedError</code> 발생 시 <code>file.read()</code>를 재시도하는 코드 예시는 다음과 같습니다.</p>
<pre><code class="language-python">while True:
    try:
        data = file.read(size)
        break
    except InterruptedError:
        continue
</code></pre>
<p>표준 라이브러리에서 <code>InterruptedError</code>를 처리하는 Python 모듈 목록은 다음과 같습니다.</p>
<ul>
<li><code>asyncio</code></li>
<li><code>asyncore</code></li>
<li><code>io</code>, <code>_pyio</code></li>
<li><code>multiprocessing</code></li>
<li><code>selectors</code></li>
<li><code>socket</code></li>
<li><code>socketserver</code></li>
<li><code>subprocess</code></li>
</ul>
<p>Perl, Java, Go와 같은 다른 프로그래밍 언어들은 <code>EINTR</code>로 실패하는 시스템 호출을 더 낮은 수준에서 재시도하므로, 라이브러리와 애플리케이션이 이에 대해 신경 쓸 필요가 없습니다.</p>
<h4>사용 사례 1: 시그널에 신경 쓰지 않기 (Use Case 1: Don't Bother With Signals)</h4>
<p>대부분의 경우, 사용자는 시그널에 의해 중단되는 것을 원치 않으며 <code>InterruptedError</code> 예외를 예상하지 않습니다. 예를 들어, "Hello World" 예제를 위해 다음처럼 복잡한 코드를 작성하고 싶지는 않을 것입니다.</p>
<pre><code class="language-python">while True:
    try:
        print("Hello World")
        break
    except InterruptedError:
        continue
</code></pre>
<p><code>InterruptedError</code>는 예상치 못한 곳에서 발생할 수 있습니다. 예를 들어, <code>os.close()</code> 및 <code>FileIO.close()</code>도 <code>InterruptedError</code>를 발생시킬 수 있습니다.</p>
<p>이 사용 사례에서의 기대는 Python이 <code>InterruptedError</code>를 숨기고 시스템 호출을 자동으로 재시도하는 것입니다.</p>
<h4>사용 사례 2: 가능한 한 빨리 시그널 알림 받기 (Use Case 2: Be notified of signals as soon as possible)</h4>
<p>때로는 특정 시그널을 예상하고 가능한 한 빨리 처리하기를 원할 수도 있습니다. 예를 들어, Ctrl+C 단축키를 사용하여 프로그램을 즉시 종료하고 싶을 수 있습니다.</p>
<p>또한, 일부 시그널은 애플리케이션을 방해해서는 안 됩니다. 특정 시그널에만 애플리케이션을 중단시키는 두 가지 옵션이 있습니다.</p>
<ol>
<li><code>SIGINT</code>에 대해 <code>KeyboardInterrupt</code>와 같은 예외를 발생시키는 사용자 정의 시그널 핸들러를 설정합니다.</li>
<li><code>select()</code>와 같은 I/O 멀티플렉싱 함수를 Python의 시그널 wakeup 파일 디스크립터와 함께 사용합니다 (<code>signal.set_wakeup_fd()</code> 함수 참고).</li>
</ol>
<p>이 사용 사례에서의 기대는 Python 시그널 핸들러가 제때 실행되고, 핸들러가 예외를 발생시키면 시스템 호출이 실패하고, 그렇지 않으면 재시작하는 것입니다.</p>
<h3>제안 (Proposal)</h3>
<p>이 PEP는 <code>EINTR</code>를 처리하고 재시도를 가장 낮은 수준, 즉 표준 라이브러리(stdlib)에서 제공하는 래퍼에서 처리할 것을 제안합니다 (상위 수준 라이브러리나 애플리케이션이 아닌).</p>
<p>구체적으로, 시스템 호출이 <code>EINTR</code>로 실패하면 해당 Python 래퍼는 주어진 시그널 핸들러를 호출해야 합니다 (<code>PyErr_CheckSignals()</code> 사용). 시그널 핸들러가 예외를 발생시키면 Python 래퍼는 중단되고 해당 예외와 함께 실패합니다.</p>
<p>시그널 핸들러가 성공적으로 반환되면 Python 래퍼는 시스템 호출을 자동으로 재시도합니다. 시스템 호출에 타임아웃(timeout) 매개변수가 포함된 경우, 타임아웃은 다시 계산됩니다.</p>
<h4>수정된 함수 (Modified functions)</h4>
<p>이 PEP를 준수하기 위해 수정되어야 할 표준 라이브러리 함수의 예시는 다음과 같습니다.</p>
<ul>
<li><code>open()</code>, <code>os.open()</code>, <code>io.open()</code></li>
<li><code>faulthandler</code> 모듈의 함수</li>
<li><code>os</code> 함수:
<ul>
<li><code>os.fchdir()</code></li>
<li><code>os.fchmod()</code></li>
<li><code>os.fchown()</code></li>
<li><code>os.fdatasync()</code></li>
<li><code>os.fstat()</code></li>
<li><code>os.fstatvfs()</code></li>
<li><code>os.fsync()</code></li>
<li><code>os.ftruncate()</code></li>
<li><code>os.mkfifo()</code></li>
<li><code>os.mknod()</code></li>
<li><code>os.posix_fadvise()</code></li>
<li><code>os.posix_fallocate()</code></li>
<li><code>os.pread()</code></li>
<li><code>os.pwrite()</code></li>
<li><code>os.read()</code></li>
<li><code>os.readv()</code></li>
<li><code>os.sendfile()</code></li>
<li><code>os.wait3()</code></li>
<li><code>os.wait4()</code></li>
<li><code>os.wait()</code></li>
<li><code>os.waitid()</code></li>
<li><code>os.waitpid()</code></li>
<li><code>os.write()</code></li>
<li><code>os.writev()</code></li>
<li>특수 사례: <code>os.close()</code> 및 <code>os.dup2()</code>는 이제 <code>EINTR</code> 오류를 무시하며, 시스템 호출은 재시도되지 않습니다.</li>
</ul>
</li>
<li><code>select.select()</code>, <code>select.poll.poll()</code>, <code>select.epoll.poll()</code>, <code>select.kqueue.control()</code>, <code>select.devpoll.poll()</code></li>
<li><code>socket.socket()</code> 메서드:
<ul>
<li><code>accept()</code></li>
<li><code>connect()</code> (논블로킹(non-blocking) 소켓 제외)</li>
<li><code>recv()</code></li>
<li><code>recvfrom()</code></li>
<li><code>recvmsg()</code></li>
<li><code>send()</code></li>
<li><code>sendall()</code></li>
<li><code>sendmsg()</code></li>
<li><code>sendto()</code></li>
</ul>
</li>
<li><code>signal.sigtimedwait()</code>, <code>signal.sigwaitinfo()</code></li>
<li><code>time.sleep()</code></li>
</ul>
<p><code>os.close</code>, <code>close()</code> 메서드 및 <code>os.dup2()</code>는 특수 사례로, 재시도하는 대신 <code>EINTR</code>를 무시합니다. 이는 복잡한 이유 때문이며, Linux에서의 동작과 파일 디스크립터가 <code>EINTR</code>가 반환되더라도 실제로 닫힐 수 있다는 사실과 관련이 있습니다.</p>
<p><code>socket.socket.connect()</code> 메서드는 시그널에 의해 중단될 경우(EINTR로 실패할 경우) 논블로킹 소켓에 대해 <code>connect()</code>를 재시도하지 않습니다. 연결은 백그라운드에서 비동기적으로 실행됩니다. 호출자는 소켓이 쓰기 가능해질 때까지 기다린 다음(<code>select.select()</code> 사용 등) <code>socket.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)</code>를 호출하여 연결 성공 여부를 확인해야 합니다.</p>
<h4><code>InterruptedError</code> 처리 (InterruptedError handling)</h4>
<p>중단된 시스템 호출이 자동으로 재시도되므로, 해당 시스템 호출을 호출할 때 <code>InterruptedError</code> 예외가 더 이상 발생하지 않아야 합니다. 따라서 "Python 3.4의 현황"에서 설명된 <code>InterruptedError</code>의 수동 처리는 제거될 수 있으며, 이는 표준 라이브러리 코드를 단순화할 것입니다.</p>
<h4>하위 호환성 (Backward compatibility)</h4>
<p>시스템 호출이 <code>InterruptedError</code>로 중단된다는 사실에 의존하는 애플리케이션은 중단(hang)될 것입니다. 이 PEP의 저자들은 그러한 애플리케이션이 존재한다고 생각하지 않습니다. 왜냐하면 그런 애플리케이션들은 경쟁 조건(race condition)과 같은 다른 문제에 노출될 것이기 때문입니다 (시스템 호출 전에 시그널이 오면 데드락(deadlock) 가능성이 있습니다). 게다가, 그러한 코드는 이식성이 없습니다.</p>
<p>어떤 경우든, 그러한 애플리케이션은 모든 플랫폼과 모든 Python 버전에서 신뢰할 수 있는 동작을 위해 시그널을 다르게 처리하도록 수정되어야 합니다. 가능한 전략은 잘 정의된 예외를 발생시키는 시그널 핸들러를 설정하거나, wakeup 파일 디스크립터를 사용하는 것입니다.</p>
<p>이벤트 루프(event loop)를 사용하는 애플리케이션의 경우, 시그널 처리를 위해 <code>signal.set_wakeup_fd()</code>가 권장되는 옵션입니다. Python의 저수준 시그널 핸들러는 시그널 번호를 파일 디스크립터에 기록하고 이벤트 루프는 이를 읽기 위해 깨어날 것입니다. 이벤트 루프는 시그널 핸들러의 제약 없이 이러한 시그널을 처리할 수 있습니다 (예: 루프는 메인 스레드뿐만 아니라 모든 스레드에서 깨어날 수 있습니다).</p>
<h3>부록 (Appendix)</h3>
<h4>Wakeup 파일 디스크립터 (Wakeup file descriptor)</h4>
<p>Python 3.3부터 <code>signal.set_wakeup_fd()</code>는 시그널 번호를 파일 디스크립터에 기록하며, 이전에는 널 바이트만 기록했습니다. 이를 통해 wakeup 파일 디스크립터를 사용하여 시그널을 구별할 수 있게 되었습니다.</p>
<p>Linux에는 각 시그널에 대한 더 많은 정보를 제공하는 <code>signalfd()</code> 시스템 호출이 있습니다. 예를 들어, 시그널을 보낸 프로세스의 PID와 UID를 알 수 있습니다. 이 함수는 아직 Python에 노출되지 않았습니다.</p>
<p>Unix에서 <code>asyncio</code> 모듈은 wakeup 파일 디스크립터를 사용하여 이벤트 루프를 깨웁니다.</p>
<h4>다중 스레딩 (Multithreading)</h4>
<p>C 시그널 핸들러는 어떤 스레드에서든 호출될 수 있지만, Python 시그널 핸들러는 항상 메인 Python 스레드에서 호출됩니다.</p>
<p>Python의 C API는 메인 Python 스레드를 중단시키기 위해 <code>SIGINT</code> 시그널 핸들러를 호출하는 <code>PyErr_SetInterrupt()</code> 함수를 제공합니다.</p>
<h4>Windows에서의 시그널 (Signals on Windows)</h4>
<h5>제어 이벤트 (Control events)</h5>
<p>Windows는 "제어 이벤트(control events)"를 사용합니다.</p>
<ul>
<li><code>CTRL_BREAK_EVENT</code>: Break (<code>SIGBREAK</code>)</li>
<li><code>CTRL_CLOSE_EVENT</code>: Close event</li>
<li><code>CTRL_C_EVENT</code>: CTRL+C (<code>SIGINT</code>)</li>
<li><code>CTRL_LOGOFF_EVENT</code>: Logoff</li>
<li><code>CTRL_SHUTDOWN_EVENT</code>: Shutdown</li>
</ul>
<p><code>SetConsoleCtrlHandler()</code> 함수를 사용하여 제어 핸들러를 설치할 수 있습니다.</p>
<p><code>CTRL_C_EVENT</code> 및 <code>CTRL_BREAK_EVENT</code> 이벤트는 <code>GenerateConsoleCtrlEvent()</code> 함수를 사용하여 프로세스에 전송될 수 있습니다. 이 함수는 Python에서 <code>os.kill()</code>로 노출됩니다.</p>
<h5>시그널 (Signals)</h5>
<p>Windows에서 지원되는 시그널은 다음과 같습니다.</p>
<ul>
<li><code>SIGABRT</code></li>
<li><code>SIGBREAK</code> (<code>CTRL_BREAK_EVENT</code>): Windows에서만 사용 가능한 시그널</li>
<li><code>SIGFPE</code></li>
<li><code>SIGILL</code></li>
<li><code>SIGINT</code> (<code>CTRL_C_EVENT</code>)</li>
<li><code>SIGSEGV</code></li>
<li><code>SIGTERM</code></li>
</ul>
<h5>SIGINT</h5>
<p><code>SIGINT</code>에 대한 기본 Python 시그널 핸들러는 Windows 이벤트 객체인 <code>sigint_event</code>를 설정합니다.</p>
<p><code>time.sleep()</code>은 <code>WaitForSingleObjectEx()</code>로 구현되며, <code>time.sleep()</code> 매개변수를 타임아웃으로 사용하여 <code>sigint_event</code> 객체를 기다립니다. 따라서 sleep은 <code>SIGINT</code>에 의해 중단될 수 있습니다.</p>
<p><code>_winapi.WaitForMultipleObjects()</code>는 <code>sigint_event</code>를 감시하는 핸들 목록에 자동으로 추가하므로, 이 또한 중단될 수 있습니다.</p>
<p><code>PyOS_StdioReadline()</code>도 <code>fgets()</code>가 실패했을 때 <code>Ctrl-C</code> 또는 <code>Ctrl-Z</code>가 눌렸는지 확인하기 위해 <code>sigint_event</code>를 사용했습니다.</p>
<h3>구현 (Implementation)</h3>
<p>이 PEP의 구현은 이슈 23285에서 추적되었습니다. 2015년 2월 7일에 커밋되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/475\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"e6YNzZ2BVZ8NBZ6boXfWj\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/475/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/475\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"475\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/475\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T3f6e,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0475/\"\u003ePEP 475 - Retry system calls failing with EINTR\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 29-Jul-2014\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 475 – \u003ccode\u003eEINTR\u003c/code\u003e 오류로 실패하는 시스템 호출 재시도\u003c/h2\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e표준 라이브러리에서 제공하는 시스템 호출 래퍼(wrapper)는 \u003ccode\u003eEINTR\u003c/code\u003e 오류로 실패할 경우 자동으로 재시도해야 합니다. 이는 애플리케이션 코드에서 이러한 재시도 로직을 직접 처리해야 하는 부담을 덜어주기 위함입니다. 여기서 \"시스템 호출\"이란 I/O 또는 기타 시스템 자원 처리에 관련된 표준 C 라이브러리 함수들을 의미합니다.\u003c/p\u003e\n\u003ch3\u003e배경 (Rationale)\u003c/h3\u003e\n\u003ch4\u003e중단된 시스템 호출 (Interrupted system calls)\u003c/h4\u003e\n\u003cp\u003ePOSIX 시스템에서 시그널(signal)은 흔하게 발생하며, 시스템 호출을 호출하는 코드는 이러한 시그널을 처리할 준비가 되어 있어야 합니다. 일반적인 시그널의 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSIGINT\u003c/code\u003e: Ctrl+C를 눌렀을 때 발생하는 가장 흔한 시그널입니다. Python은 기본적으로 이 시그널을 받으면 \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e 예외를 발생시킵니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSIGCHLD\u003c/code\u003e: 자식 프로세스가 종료될 때 서브프로세스(subprocesses)에서 발생합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSIGWINCH\u003c/code\u003e: 터미널 크기를 조절할 때 터미널에서 실행 중인 애플리케이션에 전송됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSIGCONT\u003c/code\u003e: 애플리케이션을 백그라운드로 전환할 때(예: Ctrl+Z를 누른 후 \u003ccode\u003ebg\u003c/code\u003e 명령어를 입력) 전송됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eC 시그널 핸들러를 작성하는 것은 어렵습니다. \"비동기-시그널-안전(async-signal-safe)\" 함수만 호출할 수 있고(\u003ccode\u003eprintf()\u003c/code\u003e와 \u003ccode\u003emalloc()\u003c/code\u003e은 async-signal-safe가 아님), 재진입(reentrancy) 문제가 있기 때문입니다. 따라서 시스템 호출 실행 중에 프로세스가 시그널을 받으면, 프로그램이 시그널-안전 함수에 대한 제약 없이 시그널을 처리할 기회를 주기 위해 시스템 호출이 \u003ccode\u003eEINTR\u003c/code\u003e 오류와 함께 실패할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 동작은 시스템에 따라 다릅니다. 특정 시스템에서는 \u003ccode\u003eSA_RESTART\u003c/code\u003e 플래그를 사용하여 일부 시스템 호출이 \u003ccode\u003eEINTR\u003c/code\u003e로 실패하는 대신 자동으로 재시도됩니다. 그러나 Python의 \u003ccode\u003esignal.signal()\u003c/code\u003e 함수는 시그널 핸들러를 설정할 때 \u003ccode\u003eSA_RESTART\u003c/code\u003e 플래그를 지웁니다. 이로 인해 Python에서는 모든 시스템 호출이 \u003ccode\u003eEINTR\u003c/code\u003e로 실패할 가능성이 높습니다.\u003c/p\u003e\n\u003cp\u003e시그널 수신은 예외적인 상황이 아니므로, 견고한 POSIX 코드는 \u003ccode\u003eEINTR\u003c/code\u003e를 처리할 준비가 되어 있어야 합니다 (대부분의 경우, 이는 호출이 결국 성공하기를 바라면서 루프에서 재시도하는 것을 의미합니다). Python의 특별한 지원 없이는 애플리케이션 코드가 필요 이상으로 장황해질 수 있습니다.\u003c/p\u003e\n\u003ch4\u003ePython 3.4의 현황 (Status in Python 3.4)\u003c/h4\u003e\n\u003cp\u003ePython 3.4에서는 \u003ccode\u003eInterruptedError\u003c/code\u003e 예외(\u003ccode\u003eEINTR\u003c/code\u003e 전용 예외 클래스) 처리가 모든 호출 지점(call site)에서 개별적으로 중복되어 있었습니다. 실제로 이 예외를 처리하는 Python 모듈은 몇 개에 불과했으며, 수정 사항이 전체 모듈에 적용되기까지는 보통 몇 년이 걸렸습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eInterruptedError\u003c/code\u003e 발생 시 \u003ccode\u003efile.read()\u003c/code\u003e를 재시도하는 코드 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ewhile True:\r\n    try:\r\n        data = file.read(size)\r\n        break\r\n    except InterruptedError:\r\n        continue\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e표준 라이브러리에서 \u003ccode\u003eInterruptedError\u003c/code\u003e를 처리하는 Python 모듈 목록은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003easyncio\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easyncore\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eio\u003c/code\u003e, \u003ccode\u003e_pyio\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emultiprocessing\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eselectors\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocketserver\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esubprocess\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePerl, Java, Go와 같은 다른 프로그래밍 언어들은 \u003ccode\u003eEINTR\u003c/code\u003e로 실패하는 시스템 호출을 더 낮은 수준에서 재시도하므로, 라이브러리와 애플리케이션이 이에 대해 신경 쓸 필요가 없습니다.\u003c/p\u003e\n\u003ch4\u003e사용 사례 1: 시그널에 신경 쓰지 않기 (Use Case 1: Don't Bother With Signals)\u003c/h4\u003e\n\u003cp\u003e대부분의 경우, 사용자는 시그널에 의해 중단되는 것을 원치 않으며 \u003ccode\u003eInterruptedError\u003c/code\u003e 예외를 예상하지 않습니다. 예를 들어, \"Hello World\" 예제를 위해 다음처럼 복잡한 코드를 작성하고 싶지는 않을 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ewhile True:\r\n    try:\r\n        print(\"Hello World\")\r\n        break\r\n    except InterruptedError:\r\n        continue\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eInterruptedError\u003c/code\u003e는 예상치 못한 곳에서 발생할 수 있습니다. 예를 들어, \u003ccode\u003eos.close()\u003c/code\u003e 및 \u003ccode\u003eFileIO.close()\u003c/code\u003e도 \u003ccode\u003eInterruptedError\u003c/code\u003e를 발생시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 사용 사례에서의 기대는 Python이 \u003ccode\u003eInterruptedError\u003c/code\u003e를 숨기고 시스템 호출을 자동으로 재시도하는 것입니다.\u003c/p\u003e\n\u003ch4\u003e사용 사례 2: 가능한 한 빨리 시그널 알림 받기 (Use Case 2: Be notified of signals as soon as possible)\u003c/h4\u003e\n\u003cp\u003e때로는 특정 시그널을 예상하고 가능한 한 빨리 처리하기를 원할 수도 있습니다. 예를 들어, Ctrl+C 단축키를 사용하여 프로그램을 즉시 종료하고 싶을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, 일부 시그널은 애플리케이션을 방해해서는 안 됩니다. 특정 시그널에만 애플리케이션을 중단시키는 두 가지 옵션이 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eSIGINT\u003c/code\u003e에 대해 \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e와 같은 예외를 발생시키는 사용자 정의 시그널 핸들러를 설정합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eselect()\u003c/code\u003e와 같은 I/O 멀티플렉싱 함수를 Python의 시그널 wakeup 파일 디스크립터와 함께 사용합니다 (\u003ccode\u003esignal.set_wakeup_fd()\u003c/code\u003e 함수 참고).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 사용 사례에서의 기대는 Python 시그널 핸들러가 제때 실행되고, 핸들러가 예외를 발생시키면 시스템 호출이 실패하고, 그렇지 않으면 재시작하는 것입니다.\u003c/p\u003e\n\u003ch3\u003e제안 (Proposal)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003eEINTR\u003c/code\u003e를 처리하고 재시도를 가장 낮은 수준, 즉 표준 라이브러리(stdlib)에서 제공하는 래퍼에서 처리할 것을 제안합니다 (상위 수준 라이브러리나 애플리케이션이 아닌).\u003c/p\u003e\n\u003cp\u003e구체적으로, 시스템 호출이 \u003ccode\u003eEINTR\u003c/code\u003e로 실패하면 해당 Python 래퍼는 주어진 시그널 핸들러를 호출해야 합니다 (\u003ccode\u003ePyErr_CheckSignals()\u003c/code\u003e 사용). 시그널 핸들러가 예외를 발생시키면 Python 래퍼는 중단되고 해당 예외와 함께 실패합니다.\u003c/p\u003e\n\u003cp\u003e시그널 핸들러가 성공적으로 반환되면 Python 래퍼는 시스템 호출을 자동으로 재시도합니다. 시스템 호출에 타임아웃(timeout) 매개변수가 포함된 경우, 타임아웃은 다시 계산됩니다.\u003c/p\u003e\n\u003ch4\u003e수정된 함수 (Modified functions)\u003c/h4\u003e\n\u003cp\u003e이 PEP를 준수하기 위해 수정되어야 할 표준 라이브러리 함수의 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003eos.open()\u003c/code\u003e, \u003ccode\u003eio.open()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efaulthandler\u003c/code\u003e 모듈의 함수\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos\u003c/code\u003e 함수:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eos.fchdir()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.fchmod()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.fchown()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.fdatasync()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.fstat()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.fstatvfs()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.fsync()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.ftruncate()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.mkfifo()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.mknod()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.posix_fadvise()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.posix_fallocate()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.pread()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.pwrite()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.read()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.readv()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.sendfile()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.wait3()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.wait4()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.wait()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.waitid()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.waitpid()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.write()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.writev()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e특수 사례: \u003ccode\u003eos.close()\u003c/code\u003e 및 \u003ccode\u003eos.dup2()\u003c/code\u003e는 이제 \u003ccode\u003eEINTR\u003c/code\u003e 오류를 무시하며, 시스템 호출은 재시도되지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eselect.select()\u003c/code\u003e, \u003ccode\u003eselect.poll.poll()\u003c/code\u003e, \u003ccode\u003eselect.epoll.poll()\u003c/code\u003e, \u003ccode\u003eselect.kqueue.control()\u003c/code\u003e, \u003ccode\u003eselect.devpoll.poll()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket.socket()\u003c/code\u003e 메서드:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eaccept()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econnect()\u003c/code\u003e (논블로킹(non-blocking) 소켓 제외)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erecv()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erecvfrom()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erecvmsg()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esend()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esendall()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esendmsg()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esendto()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esignal.sigtimedwait()\u003c/code\u003e, \u003ccode\u003esignal.sigwaitinfo()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etime.sleep()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eos.close\u003c/code\u003e, \u003ccode\u003eclose()\u003c/code\u003e 메서드 및 \u003ccode\u003eos.dup2()\u003c/code\u003e는 특수 사례로, 재시도하는 대신 \u003ccode\u003eEINTR\u003c/code\u003e를 무시합니다. 이는 복잡한 이유 때문이며, Linux에서의 동작과 파일 디스크립터가 \u003ccode\u003eEINTR\u003c/code\u003e가 반환되더라도 실제로 닫힐 수 있다는 사실과 관련이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esocket.socket.connect()\u003c/code\u003e 메서드는 시그널에 의해 중단될 경우(EINTR로 실패할 경우) 논블로킹 소켓에 대해 \u003ccode\u003econnect()\u003c/code\u003e를 재시도하지 않습니다. 연결은 백그라운드에서 비동기적으로 실행됩니다. 호출자는 소켓이 쓰기 가능해질 때까지 기다린 다음(\u003ccode\u003eselect.select()\u003c/code\u003e 사용 등) \u003ccode\u003esocket.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\u003c/code\u003e를 호출하여 연결 성공 여부를 확인해야 합니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eInterruptedError\u003c/code\u003e 처리 (InterruptedError handling)\u003c/h4\u003e\n\u003cp\u003e중단된 시스템 호출이 자동으로 재시도되므로, 해당 시스템 호출을 호출할 때 \u003ccode\u003eInterruptedError\u003c/code\u003e 예외가 더 이상 발생하지 않아야 합니다. 따라서 \"Python 3.4의 현황\"에서 설명된 \u003ccode\u003eInterruptedError\u003c/code\u003e의 수동 처리는 제거될 수 있으며, 이는 표준 라이브러리 코드를 단순화할 것입니다.\u003c/p\u003e\n\u003ch4\u003e하위 호환성 (Backward compatibility)\u003c/h4\u003e\n\u003cp\u003e시스템 호출이 \u003ccode\u003eInterruptedError\u003c/code\u003e로 중단된다는 사실에 의존하는 애플리케이션은 중단(hang)될 것입니다. 이 PEP의 저자들은 그러한 애플리케이션이 존재한다고 생각하지 않습니다. 왜냐하면 그런 애플리케이션들은 경쟁 조건(race condition)과 같은 다른 문제에 노출될 것이기 때문입니다 (시스템 호출 전에 시그널이 오면 데드락(deadlock) 가능성이 있습니다). 게다가, 그러한 코드는 이식성이 없습니다.\u003c/p\u003e\n\u003cp\u003e어떤 경우든, 그러한 애플리케이션은 모든 플랫폼과 모든 Python 버전에서 신뢰할 수 있는 동작을 위해 시그널을 다르게 처리하도록 수정되어야 합니다. 가능한 전략은 잘 정의된 예외를 발생시키는 시그널 핸들러를 설정하거나, wakeup 파일 디스크립터를 사용하는 것입니다.\u003c/p\u003e\n\u003cp\u003e이벤트 루프(event loop)를 사용하는 애플리케이션의 경우, 시그널 처리를 위해 \u003ccode\u003esignal.set_wakeup_fd()\u003c/code\u003e가 권장되는 옵션입니다. Python의 저수준 시그널 핸들러는 시그널 번호를 파일 디스크립터에 기록하고 이벤트 루프는 이를 읽기 위해 깨어날 것입니다. 이벤트 루프는 시그널 핸들러의 제약 없이 이러한 시그널을 처리할 수 있습니다 (예: 루프는 메인 스레드뿐만 아니라 모든 스레드에서 깨어날 수 있습니다).\u003c/p\u003e\n\u003ch3\u003e부록 (Appendix)\u003c/h3\u003e\n\u003ch4\u003eWakeup 파일 디스크립터 (Wakeup file descriptor)\u003c/h4\u003e\n\u003cp\u003ePython 3.3부터 \u003ccode\u003esignal.set_wakeup_fd()\u003c/code\u003e는 시그널 번호를 파일 디스크립터에 기록하며, 이전에는 널 바이트만 기록했습니다. 이를 통해 wakeup 파일 디스크립터를 사용하여 시그널을 구별할 수 있게 되었습니다.\u003c/p\u003e\n\u003cp\u003eLinux에는 각 시그널에 대한 더 많은 정보를 제공하는 \u003ccode\u003esignalfd()\u003c/code\u003e 시스템 호출이 있습니다. 예를 들어, 시그널을 보낸 프로세스의 PID와 UID를 알 수 있습니다. 이 함수는 아직 Python에 노출되지 않았습니다.\u003c/p\u003e\n\u003cp\u003eUnix에서 \u003ccode\u003easyncio\u003c/code\u003e 모듈은 wakeup 파일 디스크립터를 사용하여 이벤트 루프를 깨웁니다.\u003c/p\u003e\n\u003ch4\u003e다중 스레딩 (Multithreading)\u003c/h4\u003e\n\u003cp\u003eC 시그널 핸들러는 어떤 스레드에서든 호출될 수 있지만, Python 시그널 핸들러는 항상 메인 Python 스레드에서 호출됩니다.\u003c/p\u003e\n\u003cp\u003ePython의 C API는 메인 Python 스레드를 중단시키기 위해 \u003ccode\u003eSIGINT\u003c/code\u003e 시그널 핸들러를 호출하는 \u003ccode\u003ePyErr_SetInterrupt()\u003c/code\u003e 함수를 제공합니다.\u003c/p\u003e\n\u003ch4\u003eWindows에서의 시그널 (Signals on Windows)\u003c/h4\u003e\n\u003ch5\u003e제어 이벤트 (Control events)\u003c/h5\u003e\n\u003cp\u003eWindows는 \"제어 이벤트(control events)\"를 사용합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCTRL_BREAK_EVENT\u003c/code\u003e: Break (\u003ccode\u003eSIGBREAK\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCTRL_CLOSE_EVENT\u003c/code\u003e: Close event\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCTRL_C_EVENT\u003c/code\u003e: CTRL+C (\u003ccode\u003eSIGINT\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCTRL_LOGOFF_EVENT\u003c/code\u003e: Logoff\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCTRL_SHUTDOWN_EVENT\u003c/code\u003e: Shutdown\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eSetConsoleCtrlHandler()\u003c/code\u003e 함수를 사용하여 제어 핸들러를 설치할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCTRL_C_EVENT\u003c/code\u003e 및 \u003ccode\u003eCTRL_BREAK_EVENT\u003c/code\u003e 이벤트는 \u003ccode\u003eGenerateConsoleCtrlEvent()\u003c/code\u003e 함수를 사용하여 프로세스에 전송될 수 있습니다. 이 함수는 Python에서 \u003ccode\u003eos.kill()\u003c/code\u003e로 노출됩니다.\u003c/p\u003e\n\u003ch5\u003e시그널 (Signals)\u003c/h5\u003e\n\u003cp\u003eWindows에서 지원되는 시그널은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSIGABRT\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSIGBREAK\u003c/code\u003e (\u003ccode\u003eCTRL_BREAK_EVENT\u003c/code\u003e): Windows에서만 사용 가능한 시그널\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSIGFPE\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSIGILL\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSIGINT\u003c/code\u003e (\u003ccode\u003eCTRL_C_EVENT\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSIGSEGV\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSIGTERM\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5\u003eSIGINT\u003c/h5\u003e\n\u003cp\u003e\u003ccode\u003eSIGINT\u003c/code\u003e에 대한 기본 Python 시그널 핸들러는 Windows 이벤트 객체인 \u003ccode\u003esigint_event\u003c/code\u003e를 설정합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etime.sleep()\u003c/code\u003e은 \u003ccode\u003eWaitForSingleObjectEx()\u003c/code\u003e로 구현되며, \u003ccode\u003etime.sleep()\u003c/code\u003e 매개변수를 타임아웃으로 사용하여 \u003ccode\u003esigint_event\u003c/code\u003e 객체를 기다립니다. 따라서 sleep은 \u003ccode\u003eSIGINT\u003c/code\u003e에 의해 중단될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e_winapi.WaitForMultipleObjects()\u003c/code\u003e는 \u003ccode\u003esigint_event\u003c/code\u003e를 감시하는 핸들 목록에 자동으로 추가하므로, 이 또한 중단될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyOS_StdioReadline()\u003c/code\u003e도 \u003ccode\u003efgets()\u003c/code\u003e가 실패했을 때 \u003ccode\u003eCtrl-C\u003c/code\u003e 또는 \u003ccode\u003eCtrl-Z\u003c/code\u003e가 눌렸는지 확인하기 위해 \u003ccode\u003esigint_event\u003c/code\u003e를 사용했습니다.\u003c/p\u003e\n\u003ch3\u003e구현 (Implementation)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 구현은 이슈 23285에서 추적되었습니다. 2015년 2월 7일에 커밋되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 475 - Retry system calls failing with EINTR\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:21:40+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>