<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-1a135130af3e1cae.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1318<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 3104 - Access to Names in Outer Scopes</h1><div class="page__meta"><time dateTime="2025-09-27 14:17:40+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-3104/">PEP 3104 - Access to Names in Outer Scopes</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 12-Oct-2006</p>
</blockquote>
<h2>PEP 3104 – 외부 스코프의 이름 접근</h2>
<p><strong>작성자:</strong> Ka-Ping Yee 
<strong>상태:</strong> Final
<strong>유형:</strong> Standards Track
<strong>생성일:</strong> 2006-10-12
<strong>Python 버전:</strong> 3.0
<strong>히스토리:</strong> <a href="https://peps.python.org/pep-3104/">Post-History</a></p>
<h3>요약 (Abstract)</h3>
<p>대부분의 중첩 스코프(nested scopes)를 지원하는 언어에서 코드는 가장 가까운 바깥쪽 스코프(enclosing scope)에 있는 이름을 참조하거나 재할당(rebind, 값 할당)할 수 있습니다. 현재 Python 코드는 어떤 바깥쪽 스코프에 있는 이름이든 참조할 수 있지만, 이름을 재할당할 수 있는 스코프는 두 가지뿐입니다. 즉, 지역 스코프(local scope) (단순 할당 사용) 또는 모듈-전역 스코프(module-global scope) ( <code>global</code> 선언 사용) 입니다.</p>
<p>이러한 제한은 Python-Dev 메일링 리스트 및 다른 곳에서 여러 번 제기되었으며, 이 제한을 제거하기 위한 확장된 논의와 많은 제안으로 이어졌습니다. 이 PEP는 제시된 다양한 대안들과 각각의 장단점을 요약합니다.</p>
<h3>배경 (Rationale)</h3>
<p>버전 2.1 이전에는 Python의 스코프 처리가 표준 C와 유사했습니다. 즉, 파일 내에는 전역(global)과 지역(local)이라는 두 가지 스코프 레벨만 있었습니다. C에서 이는 함수 정의가 중첩될 수 없다는 사실의 자연스러운 결과입니다. 그러나 Python에서는 함수가 일반적으로 최상위 수준에서 정의되더라도 함수 정의는 어디에서나 실행될 수 있습니다. 이로 인해 Python은 의미론 없이 중첩 스코프의 구문적 형태를 가지게 되었고, 일부 프로그래머들에게는 놀라운 불일치를 초래했습니다. 예를 들어, 최상위 수준에서 작동하던 재귀 함수가 다른 함수 내로 이동되면 작동을 멈추게 되었는데, 이는 재귀 함수 자체의 이름이 더 이상 해당 함수의 본문 스코프에서 보이지 않았기 때문입니다. 이는 함수가 다른 컨텍스트에 배치될 때 일관되게 동작해야 한다는 직관을 위반합니다. 다음은 예시입니다.</p>
<pre><code class="language-python">def enclosing_function():
    def factorial(n):
        if n &#x3C; 2:
            return 1
        return n * factorial(n - 1) # NameError 발생
    print(factorial(5))
</code></pre>
<p>Python 2.1은 모든 바깥쪽 스코프에 바인딩된 이름을 보이게 함으로써 정적 중첩 스코프(static nested scoping)에 더 가까워졌습니다 (PEP 227 참조). 이 변경으로 위 코드 예시가 예상대로 작동하게 되었습니다. 그러나 이름에 대한 모든 할당이 해당 이름을 지역(local)으로 암시적으로 선언하기 때문에, 바깥쪽 스코프의 이름을 재할당하는 것은 불가능합니다 ( <code>global</code> 선언이 이름을 전역(global)으로 강제하는 경우 제외). 따라서 다음 코드는 버튼 클릭으로 증가 및 감소할 수 있는 숫자를 표시하도록 의도되었지만, 어휘적 스코프(lexical scoping)에 익숙한 사람이라면 예상하는 대로 작동하지 않습니다.</p>
<pre><code class="language-python">def make_scoreboard(frame, score=0):
    label = Label(frame)
    label.pack()
    for i in [-10, -1, 1, 10]:
        def increment(step=i):
            score = score + step # UnboundLocalError 발생
            label['text'] = score
        button = Button(frame, text='%+d' % i, command=increment)
        button.pack()
    return label
</code></pre>
<p>Python 구문은 <code>increment</code> 내에서 언급된 <code>score</code>라는 이름이 <code>make_scoreboard</code>에 바인딩된 <code>score</code> 변수를 참조하며, <code>increment</code> 내의 지역 변수가 아님을 나타내는 방법을 제공하지 않습니다. Python 사용자 및 개발자들은 이 제한을 제거하여 Python이 JavaScript, Perl, Ruby, Scheme, Smalltalk, GNU 확장 C, C# 2.0을 포함한 많은 프로그래밍 언어에서 표준이 된 Algol 스타일 스코핑 모델의 모든 유연성을 가질 수 있도록 하는 데 관심을 표명했습니다.</p>
<p>이러한 기능이 필요하지 않다는 주장도 있었습니다. 재할당 가능한 외부 변수를 가변 객체로 래핑하여 시뮬레이션할 수 있기 때문입니다.</p>
<pre><code class="language-python">class Namespace: pass
def make_scoreboard(frame, score=0):
    ns = Namespace()
    ns.score = 0
    label = Label(frame)
    label.pack()
    for i in [-10, -1, 1, 10]:
        def increment(step=i):
            ns.score = ns.score + step
            label['text'] = ns.score
        button = Button(frame, text='%+d' % i, command=increment)
        button.pack()
    return label
</code></pre>
<p>그러나 이러한 해결 방법은 기존 스코프의 단점을 부각시킬 뿐입니다. 함수의 목적은 코드를 자체 네임스페이스에 캡슐화하는 것이므로, 프로그래머가 기존 지역 스코프의 누락된 기능을 보완하기 위해 추가 네임스페이스를 생성하고, 각 이름이 실제 스코프에 상주해야 하는지 시뮬레이션된 스코프에 상주해야 하는지 결정해야 하는 것은 불행한 일로 보입니다.</p>
<p>또 다른 일반적인 반대는 원하는 기능을 다소 장황하지만 클래스로 작성할 수 있다는 것입니다. 이 반론에 대한 반박은 다른 구현 스타일의 존재가 지원되는 프로그래밍 구성 요소(중첩 스코프)를 기능적으로 불완전하게 두어야 할 이유가 되지 않는다는 것입니다. Python은 다양한 프로그래밍 패러다임을 지원하고 우아하게 통합함으로써 많은 강점, 실용적인 유연성, 교육적 힘을 얻기 때문에 "다중 패러다임 언어"라고 불리기도 합니다.</p>
<p>스코핑 구문에 대한 제안은 PEP 227의 중첩 스코프 지원이 채택되기 훨씬 전인 1994년에 Python-Dev에 등장했습니다. 당시 Guido의 답변은 "이것은 CSNS(classic static nested scopes)를 도입하는 데 위험할 정도로 가깝습니다. 그렇게 한다면, <code>scoped</code>의 제안된 의미론은 괜찮아 보입니다. 나는 여전히 이런 종류의 구성을 정당화할 만큼 CSNS의 필요성이 충분하지 않다고 생각합니다..."였습니다.</p>
<p>PEP 227 이후, "외부 이름 재할당 논의"는 Python-Dev에 충분히 자주 다시 등장하여 친숙한 이벤트가 되었으며, 최소 2003년부터 현재 형태로 재발했습니다. 이러한 논의에서 제안된 언어 변경 사항 중 채택된 것은 없지만, Guido는 언어 변경이 고려할 가치가 있음을 인정했습니다.</p>
<h3>다른 언어 (Other Languages)</h3>
<p>일부 다른 언어들이 중첩 스코프와 재할당을 어떻게 처리하는지 배경 설명을 위해 이 섹션에서 다룹니다.</p>
<h4>JavaScript, Perl, Scheme, Smalltalk, GNU C, C# 2.0</h4>
<p>이 언어들은 변수 선언을 사용하여 스코프를 나타냅니다. JavaScript에서는 <code>var</code> 키워드로 어휘적으로 스코프가 지정된 변수를 선언합니다. 선언되지 않은 변수 이름은 전역(global)으로 간주됩니다. Perl에서는 <code>my</code> 키워드로 어휘적으로 스코프가 지정된 변수를 선언합니다. 선언되지 않은 변수 이름은 전역으로 간주됩니다. Scheme에서는 모든 변수를 선언해야 합니다 (<code>define</code> 또는 <code>let</code>을 사용하거나 형식 매개변수로). Smalltalk에서는 모든 블록이 세로 막대 사이에 지역 변수 이름 목록을 선언하여 시작할 수 있습니다. C 및 C#은 모든 변수에 대해 타입 선언을 요구합니다. 이 모든 경우에 변수는 선언을 포함하는 스코프에 속합니다.</p>
<h4>Ruby (1.8 기준)</h4>
<p>Ruby는 Python과 마찬가지로 변수 선언을 요구하지 않고 정적으로 중첩된 스코프를 지원하려고 시도하며, 따라서 특이한 해결책을 찾아야 한다는 점에서 유익한 예시입니다. Ruby의 함수는 다른 함수 정의를 포함할 수 있으며, 중괄호로 묶인 코드 블록도 포함할 수 있습니다. 블록은 외부 변수에 접근할 수 있지만, 중첩된 함수는 그렇지 않습니다. 블록 내에서 이름에 대한 할당은 외부 스코프에 이미 바인딩된 이름을 가리지 않는 경우에만 지역 변수의 선언을 의미합니다. 그렇지 않으면 할당은 외부 이름의 재할당으로 해석됩니다. Ruby의 스코핑 구문과 규칙 또한 오랫동안 논의되어 왔으며, Ruby 2.0에서 변경될 가능성이 있습니다.</p>
<h3>제안 개요 (Overview of Proposals)</h3>
<p>Python-Dev에는 외부 스코프의 이름을 재할당하는 방법에 대한 많은 다른 제안들이 있었습니다. 이들은 모두 두 가지 범주로 나뉩니다. 이름이 바인딩되는 스코프(바깥쪽 스코프)에 새로운 구문을 추가하거나, 이름이 사용되는 스코프(안쪽 스코프)에 새로운 구문을 추가하는 것입니다.</p>
<h4>바인딩(바깥쪽) 스코프의 새로운 구문 (New Syntax in the Binding (Outer) Scope)</h4>
<p><strong>스코프 재정의 선언 (Scope Override Declaration)</strong></p>
<p>이 범주의 제안들은 모두 JavaScript의 <code>var</code>와 유사한 새로운 종류의 선언문을 제안합니다. 이 목적을 위해 몇 가지 가능한 키워드가 제안되었습니다.</p>
<ul>
<li><code>scope x</code></li>
<li><code>var x</code></li>
<li><code>my x</code></li>
</ul>
<p>이 모든 제안에서 특정 스코프 <code>S</code> 내의 <code>var x</code>와 같은 선언은 <code>S</code> 내에 중첩된 스코프에서 <code>x</code>에 대한 모든 참조가 <code>S</code>에 바인딩된 <code>x</code>를 참조하도록 합니다.</p>
<p>이 범주의 제안에 대한 주요 반대는 함수 정의의 의미가 컨텍스트에 민감해진다는 것입니다. 함수 정의를 다른 블록 안으로 이동하면, 둘러싸는 블록의 선언 때문에 함수 내의 지역 이름 참조 중 일부가 비지역(nonlocal)이 될 수 있습니다. Ruby 1.8의 블록의 경우 실제로 그러합니다. 다음 예시에서 두 <code>setter</code>는 동일하게 보이지만 다른 효과를 가집니다.</p>
<pre><code class="language-ruby">setter1 = proc { | x | y = x } # y는 여기서는 지역 변수
y = 13
setter2 = proc { | x | y = x } # y는 여기서는 비지역 변수
setter1.call(99)
puts y # 13을 출력
setter2.call(77)
puts y # 77을 출력
</code></pre>
<p>이 제안이 JavaScript 및 Perl의 선언과 유사하지만, 언어에 미치는 영향은 다릅니다. 이 언어들에서는 선언되지 않은 변수가 기본적으로 전역인 반면, Python에서는 선언되지 않은 변수가 기본적으로 지역이기 때문입니다. 따라서 JavaScript 또는 Perl에서 함수를 다른 블록 안으로 이동하면 이전에 전역이었던 이름 참조의 스코프를 줄일 수 있을 뿐이지만, 이 제안이 있는 Python에서는 이전에 지역이었던 이름 참조의 스코프를 확장할 수 있습니다.</p>
<p><strong>필수 변수 선언 (Required Variable Declaration)</strong></p>
<p>더 급진적인 제안은 Python의 스코프 추측 규칙을 완전히 제거하고, Scheme처럼 모든 이름이 바인딩될 스코프에서 선언되어야 한다고 제안합니다. 이 제안에서 <code>var x = 3</code>은 <code>x</code>가 지역 스코프에 속하고 <code>3</code>으로 바인딩되도록 선언하는 반면, <code>x = 3</code>은 기존에 보이는 <code>x</code>를 재할당합니다. <code>var x</code> 선언을 포함하는 바깥쪽 스코프가 없는 컨텍스트에서는 <code>x = 3</code> 문이 정적으로 불법으로 결정됩니다.</p>
<p>이 제안은 간단하고 일관된 모델을 제공하지만, 기존의 모든 Python 코드와 호환되지 않을 것입니다.</p>
<h4>참조(안쪽) 스코프의 새로운 구문 (New Syntax in the Referring (Inner) Scope)</h4>
<p>이 범주에는 세 가지 유형의 제안이 있습니다.</p>
<p><strong>외부 참조 표현식 (Outer Reference Expression)</strong></p>
<p>이 유형의 제안은 변수를 표현식에서 사용할 때 외부 스코프의 변수를 참조하는 새로운 방법을 제안합니다. 이를 위해 제안된 한 가지 구문은 <code>.x</code>이며, 이는 지역 바인딩을 생성하지 않고 <code>x</code>를 참조합니다. 이 제안에 대한 우려는 많은 컨텍스트에서 <code>x</code>와 <code>.x</code>가 상호 교환적으로 사용될 수 있어 독자를 혼란스럽게 할 수 있다는 것입니다. 밀접하게 관련된 아이디어는 스코프 레벨을 올라갈 수를 지정하기 위해 여러 점을 사용하는 것이지만, 대부분은 이것이 너무 오류를 유발하기 쉽다고 간주합니다.</p>
<p><strong>재할당 연산자 (Rebinding Operator)</strong></p>
<p>이 제안은 이름을 지역으로 선언하지 않고 이름을 재할당하는 새로운 할당 유사 연산자를 제안합니다. <code>x = 3</code> 문이 <code>x</code>를 지역 변수로 선언하고 <code>3</code>으로 바인딩하는 반면, <code>x := 3</code> 문은 <code>x</code>의 기존 바인딩을 변경하되 지역으로 선언하지 않습니다.</p>
<p>이것은 간단한 해결책이지만, PEP 3099에 따르면 거부되었습니다 (아마도 놓치기 쉽거나 <code>=</code>와 혼동하기 쉽기 때문일 수 있습니다).</p>
<p><strong>스코프 재정의 선언 (Scope Override Declaration)</strong></p>
<p>이 범주의 제안들은 안쪽 스코프에서 이름이 지역이 되는 것을 방지하는 새로운 종류의 선언문을 제안합니다. 이 문은 <code>global</code> 문과 본질적으로 유사하지만, 이름을 최상위 모듈-레벨 스코프의 바인딩을 참조하게 하는 대신, 가장 가까운 바깥쪽 스코프의 바인딩을 참조하게 합니다.</p>
<p>이 접근 방식은 익숙한 Python 구성 요소와 유사하며 함수 정의에 대한 컨텍스트 독립성을 유지한다는 점에서 매력적입니다.</p>
<p>이 접근 방식은 보안 및 디버깅 관점에서도 장점이 있습니다. 결과적인 Python은 다른 중첩 스코프 언어의 기능과 일치할 뿐만 아니라, 방어적 프로그래밍에 arguably 더 나은 구문을 제공할 것입니다. 대부분의 다른 언어에서는 선언이 기존 이름의 스코프를 축소하므로, 부주의하게 선언을 생략하면 예상보다 광범위한 (즉, 더 위험한) 효과를 초래할 수 있습니다. 이 제안이 있는 Python에서는 선언을 추가하는 추가적인 노력이 비지역 효과의 증가된 위험과 일치합니다 (즉, 가장 적은 저항의 경로가 더 안전한 경로입니다).</p>
<p>이러한 선언에 대해 많은 표기법이 제안되었습니다.</p>
<ul>
<li><code>scoped x</code></li>
<li><code>global x in f</code> (어떤 스코프인지 명시적으로 지정)</li>
<li><code>free x</code></li>
<li><code>outer x</code></li>
<li><code>use x</code></li>
<li><code>global x</code> (<code>global</code>의 의미 변경)</li>
<li><code>nonlocal x</code></li>
<li><code>global x outer</code></li>
<li><code>global in x</code></li>
<li><code>not global x</code></li>
<li><code>extern x</code></li>
<li><code>ref x</code></li>
<li><code>refer x</code></li>
<li><code>share x</code></li>
<li><code>sharing x</code></li>
<li><code>common x</code></li>
<li><code>using x</code></li>
<li><code>borrow x</code></li>
<li><code>reuse x</code></li>
<li><code>scope f x</code> (어떤 스코프인지 명시적으로 지정)</li>
</ul>
<p>가장 일반적으로 논의된 선택은 <code>outer</code>, <code>global</code>, <code>nonlocal</code>이었습니다. <code>outer</code>는 표준 라이브러리에서 변수 이름과 속성 이름으로 모두 사용됩니다. <code>global</code>이라는 단어는 "전역 변수"가 일반적으로 최상위 스코프의 변수를 의미하는 것으로 이해되기 때문에 의미가 충돌합니다. C에서 <code>extern</code> 키워드는 이름이 다른 컴파일 단위의 변수를 참조한다는 의미입니다. <code>nonlocal</code>은 약간 길고 다른 옵션보다 덜 듣기 좋지만, "지역이 아닌"이라는 정확한 의미를 가집니다.</p>
<h3>제안된 해결책 (Proposed Solution)</h3>
<p>이 PEP에서 제안하는 해결책은 참조(안쪽) 스코프에 스코프 재정의 선언을 추가하는 것입니다. Guido는 Python-Dev에서 이 범주의 해결책에 대한 선호를 표명했으며, <code>nonlocal</code>을 키워드로 승인했습니다.</p>
<p>제안된 선언은 다음과 같습니다.</p>
<pre><code class="language-python">nonlocal x
</code></pre>
<p>이는 현재 스코프에서 <code>x</code>가 지역 이름이 되는 것을 방지합니다. 현재 스코프에서 <code>x</code>의 모든 발생은 바깥쪽 둘러싸는 스코프에 바인딩된 <code>x</code>를 참조하게 됩니다. <code>global</code>과 마찬가지로 여러 이름이 허용됩니다.</p>
<pre><code class="language-python">nonlocal x, y, z
</code></pre>
<p>둘러싸는 스코프에 기존 바인딩이 없으면 컴파일러는 <code>SyntaxError</code>를 발생시킵니다. (이를 <code>SyntaxError</code>라고 부르는 것은 다소 무리가 있을 수 있지만, 현재까지 <code>SyntaxError</code>는 알 수 없는 기능 이름과 함께 <code>__future__ import</code>를 포함하여 모든 컴파일 시간 오류에 사용됩니다.) Guido는 외부 바인딩이 없는 이런 종류의 선언은 오류로 간주되어야 한다고 말했습니다.</p>
<p><code>nonlocal</code> 선언이 지역 스코프의 형식 매개변수 이름과 충돌하면 컴파일러는 <code>SyntaxError</code>를 발생시킵니다.</p>
<p>단축 형태도 허용됩니다. 이 경우 <code>nonlocal</code>이 할당 또는 증강 할당 앞에 붙습니다.</p>
<pre><code class="language-python">nonlocal x = 3
</code></pre>
<p>위의 내용은 <code>nonlocal x; x = 3</code>과 정확히 같은 의미를 가집니다. (Guido는 <code>global</code> 문의 유사한 형태를 지지합니다.)</p>
<p>단축 형태의 왼쪽에는 식별자만 허용되며, <code>x[0]</code>와 같은 대상 표현식은 허용되지 않습니다. 그 외의 모든 할당 형태는 허용됩니다. <code>nonlocal</code> 문의 제안된 문법은 다음과 같습니다.</p>
<pre><code>nonlocal_stmt ::= "nonlocal" identifier ("," identifier)* ["=" (target_list "=")+ expression_list]
                | "nonlocal" identifier augop expression_list
</code></pre>
<p>이 모든 할당 형태를 허용하는 이유는 <code>nonlocal</code> 문의 이해를 단순화하기 위함입니다. 단축 형태를 선언과 할당으로 분리하는 것이 그 의미와 유효성을 이해하는 데 충분합니다.</p>
<p><strong>참고:</strong> 원본 PEP 구현에는 단축 구문이 추가되지 않았습니다. 이후 논의에서는 이 구문을 구현해서는 안 된다는 결론을 내렸습니다.</p>
<h3>하위 호환성 (Backward Compatibility)</h3>
<p>이 PEP는 Guido가 제안한 대로 Python 3000(Python 3.x의 초기 명칭)을 대상으로 합니다. 그러나 다른 이들은 이 PEP에서 고려된 일부 옵션이 Python 2.x에서 실행 가능한 충분히 작은 변경 사항일 수 있으며, 이 경우 이 PEP가 2.x 시리즈 PEP로 이동될 수도 있다고 언급했습니다.</p>
<p>새로운 키워드를 도입하는 영향을 (매우 대략적으로) 측정하기 위해, 2006년 11월 5일 Python SVN 저장소 스캔에 따르면 표준 라이브러리에서 제안된 일부 키워드가 식별자로 나타난 횟수는 다음과 같습니다.</p>
<ul>
<li><code>nonlocal</code>: 0</li>
<li><code>use</code>: 2</li>
<li><code>using</code>: 3</li>
<li><code>reuse</code>: 4</li>
<li><code>free</code>: 8</li>
<li><code>outer</code>: 147</li>
</ul>
<p><code>global</code>은 기존 키워드로 214번 나타납니다. <code>global</code>을 외부 스코프 키워드로 사용하는 영향을 측정하면, 그러한 변경으로 인해 표준 라이브러리에서 깨질 파일은 18개입니다 (함수가 전역 스코프에 해당 변수가 도입되기 전에 변수를 <code>global</code>로 선언하기 때문).</p>
<h3>참고 문헌 (References)</h3>
<p>Scoping (was Re: Lambda binding solved?) (Rafael Bracho)
Extended Function syntax (Just van Rossum)
Closure semantics (Guido van Rossum)
... (생략, 원문 참조) ...</p>
<h3>감사의 글 (Acknowledgements)</h3>
<p>이 PEP에 언급된 아이디어와 제안들은 수많은 Python-Dev 게시물에서 얻은 것입니다. 이 PEP에 대한 특정 편집을 제안해 주신 Jim Jewett, Mike Orr, Jason Orendorff, Christian Tanzer에게 감사드립니다.</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-1a135130af3e1cae.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/3104\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"8N6icDw00Cy0kKVlExSq2\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/3104/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/3104\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"3104\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/3104\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T557b,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-3104/\"\u003ePEP 3104 - Access to Names in Outer Scopes\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 12-Oct-2006\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 3104 – 외부 스코프의 이름 접근\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Ka-Ping Yee \r\n\u003cstrong\u003e상태:\u003c/strong\u003e Final\r\n\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track\r\n\u003cstrong\u003e생성일:\u003c/strong\u003e 2006-10-12\r\n\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.0\r\n\u003cstrong\u003e히스토리:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-3104/\"\u003ePost-History\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e요약 (Abstract)\u003c/h3\u003e\n\u003cp\u003e대부분의 중첩 스코프(nested scopes)를 지원하는 언어에서 코드는 가장 가까운 바깥쪽 스코프(enclosing scope)에 있는 이름을 참조하거나 재할당(rebind, 값 할당)할 수 있습니다. 현재 Python 코드는 어떤 바깥쪽 스코프에 있는 이름이든 참조할 수 있지만, 이름을 재할당할 수 있는 스코프는 두 가지뿐입니다. 즉, 지역 스코프(local scope) (단순 할당 사용) 또는 모듈-전역 스코프(module-global scope) ( \u003ccode\u003eglobal\u003c/code\u003e 선언 사용) 입니다.\u003c/p\u003e\n\u003cp\u003e이러한 제한은 Python-Dev 메일링 리스트 및 다른 곳에서 여러 번 제기되었으며, 이 제한을 제거하기 위한 확장된 논의와 많은 제안으로 이어졌습니다. 이 PEP는 제시된 다양한 대안들과 각각의 장단점을 요약합니다.\u003c/p\u003e\n\u003ch3\u003e배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003e버전 2.1 이전에는 Python의 스코프 처리가 표준 C와 유사했습니다. 즉, 파일 내에는 전역(global)과 지역(local)이라는 두 가지 스코프 레벨만 있었습니다. C에서 이는 함수 정의가 중첩될 수 없다는 사실의 자연스러운 결과입니다. 그러나 Python에서는 함수가 일반적으로 최상위 수준에서 정의되더라도 함수 정의는 어디에서나 실행될 수 있습니다. 이로 인해 Python은 의미론 없이 중첩 스코프의 구문적 형태를 가지게 되었고, 일부 프로그래머들에게는 놀라운 불일치를 초래했습니다. 예를 들어, 최상위 수준에서 작동하던 재귀 함수가 다른 함수 내로 이동되면 작동을 멈추게 되었는데, 이는 재귀 함수 자체의 이름이 더 이상 해당 함수의 본문 스코프에서 보이지 않았기 때문입니다. 이는 함수가 다른 컨텍스트에 배치될 때 일관되게 동작해야 한다는 직관을 위반합니다. 다음은 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef enclosing_function():\r\n    def factorial(n):\r\n        if n \u0026#x3C; 2:\r\n            return 1\r\n        return n * factorial(n - 1) # NameError 발생\r\n    print(factorial(5))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 2.1은 모든 바깥쪽 스코프에 바인딩된 이름을 보이게 함으로써 정적 중첩 스코프(static nested scoping)에 더 가까워졌습니다 (PEP 227 참조). 이 변경으로 위 코드 예시가 예상대로 작동하게 되었습니다. 그러나 이름에 대한 모든 할당이 해당 이름을 지역(local)으로 암시적으로 선언하기 때문에, 바깥쪽 스코프의 이름을 재할당하는 것은 불가능합니다 ( \u003ccode\u003eglobal\u003c/code\u003e 선언이 이름을 전역(global)으로 강제하는 경우 제외). 따라서 다음 코드는 버튼 클릭으로 증가 및 감소할 수 있는 숫자를 표시하도록 의도되었지만, 어휘적 스코프(lexical scoping)에 익숙한 사람이라면 예상하는 대로 작동하지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef make_scoreboard(frame, score=0):\r\n    label = Label(frame)\r\n    label.pack()\r\n    for i in [-10, -1, 1, 10]:\r\n        def increment(step=i):\r\n            score = score + step # UnboundLocalError 발생\r\n            label['text'] = score\r\n        button = Button(frame, text='%+d' % i, command=increment)\r\n        button.pack()\r\n    return label\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 구문은 \u003ccode\u003eincrement\u003c/code\u003e 내에서 언급된 \u003ccode\u003escore\u003c/code\u003e라는 이름이 \u003ccode\u003emake_scoreboard\u003c/code\u003e에 바인딩된 \u003ccode\u003escore\u003c/code\u003e 변수를 참조하며, \u003ccode\u003eincrement\u003c/code\u003e 내의 지역 변수가 아님을 나타내는 방법을 제공하지 않습니다. Python 사용자 및 개발자들은 이 제한을 제거하여 Python이 JavaScript, Perl, Ruby, Scheme, Smalltalk, GNU 확장 C, C# 2.0을 포함한 많은 프로그래밍 언어에서 표준이 된 Algol 스타일 스코핑 모델의 모든 유연성을 가질 수 있도록 하는 데 관심을 표명했습니다.\u003c/p\u003e\n\u003cp\u003e이러한 기능이 필요하지 않다는 주장도 있었습니다. 재할당 가능한 외부 변수를 가변 객체로 래핑하여 시뮬레이션할 수 있기 때문입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Namespace: pass\r\ndef make_scoreboard(frame, score=0):\r\n    ns = Namespace()\r\n    ns.score = 0\r\n    label = Label(frame)\r\n    label.pack()\r\n    for i in [-10, -1, 1, 10]:\r\n        def increment(step=i):\r\n            ns.score = ns.score + step\r\n            label['text'] = ns.score\r\n        button = Button(frame, text='%+d' % i, command=increment)\r\n        button.pack()\r\n    return label\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 이러한 해결 방법은 기존 스코프의 단점을 부각시킬 뿐입니다. 함수의 목적은 코드를 자체 네임스페이스에 캡슐화하는 것이므로, 프로그래머가 기존 지역 스코프의 누락된 기능을 보완하기 위해 추가 네임스페이스를 생성하고, 각 이름이 실제 스코프에 상주해야 하는지 시뮬레이션된 스코프에 상주해야 하는지 결정해야 하는 것은 불행한 일로 보입니다.\u003c/p\u003e\n\u003cp\u003e또 다른 일반적인 반대는 원하는 기능을 다소 장황하지만 클래스로 작성할 수 있다는 것입니다. 이 반론에 대한 반박은 다른 구현 스타일의 존재가 지원되는 프로그래밍 구성 요소(중첩 스코프)를 기능적으로 불완전하게 두어야 할 이유가 되지 않는다는 것입니다. Python은 다양한 프로그래밍 패러다임을 지원하고 우아하게 통합함으로써 많은 강점, 실용적인 유연성, 교육적 힘을 얻기 때문에 \"다중 패러다임 언어\"라고 불리기도 합니다.\u003c/p\u003e\n\u003cp\u003e스코핑 구문에 대한 제안은 PEP 227의 중첩 스코프 지원이 채택되기 훨씬 전인 1994년에 Python-Dev에 등장했습니다. 당시 Guido의 답변은 \"이것은 CSNS(classic static nested scopes)를 도입하는 데 위험할 정도로 가깝습니다. 그렇게 한다면, \u003ccode\u003escoped\u003c/code\u003e의 제안된 의미론은 괜찮아 보입니다. 나는 여전히 이런 종류의 구성을 정당화할 만큼 CSNS의 필요성이 충분하지 않다고 생각합니다...\"였습니다.\u003c/p\u003e\n\u003cp\u003ePEP 227 이후, \"외부 이름 재할당 논의\"는 Python-Dev에 충분히 자주 다시 등장하여 친숙한 이벤트가 되었으며, 최소 2003년부터 현재 형태로 재발했습니다. 이러한 논의에서 제안된 언어 변경 사항 중 채택된 것은 없지만, Guido는 언어 변경이 고려할 가치가 있음을 인정했습니다.\u003c/p\u003e\n\u003ch3\u003e다른 언어 (Other Languages)\u003c/h3\u003e\n\u003cp\u003e일부 다른 언어들이 중첩 스코프와 재할당을 어떻게 처리하는지 배경 설명을 위해 이 섹션에서 다룹니다.\u003c/p\u003e\n\u003ch4\u003eJavaScript, Perl, Scheme, Smalltalk, GNU C, C# 2.0\u003c/h4\u003e\n\u003cp\u003e이 언어들은 변수 선언을 사용하여 스코프를 나타냅니다. JavaScript에서는 \u003ccode\u003evar\u003c/code\u003e 키워드로 어휘적으로 스코프가 지정된 변수를 선언합니다. 선언되지 않은 변수 이름은 전역(global)으로 간주됩니다. Perl에서는 \u003ccode\u003emy\u003c/code\u003e 키워드로 어휘적으로 스코프가 지정된 변수를 선언합니다. 선언되지 않은 변수 이름은 전역으로 간주됩니다. Scheme에서는 모든 변수를 선언해야 합니다 (\u003ccode\u003edefine\u003c/code\u003e 또는 \u003ccode\u003elet\u003c/code\u003e을 사용하거나 형식 매개변수로). Smalltalk에서는 모든 블록이 세로 막대 사이에 지역 변수 이름 목록을 선언하여 시작할 수 있습니다. C 및 C#은 모든 변수에 대해 타입 선언을 요구합니다. 이 모든 경우에 변수는 선언을 포함하는 스코프에 속합니다.\u003c/p\u003e\n\u003ch4\u003eRuby (1.8 기준)\u003c/h4\u003e\n\u003cp\u003eRuby는 Python과 마찬가지로 변수 선언을 요구하지 않고 정적으로 중첩된 스코프를 지원하려고 시도하며, 따라서 특이한 해결책을 찾아야 한다는 점에서 유익한 예시입니다. Ruby의 함수는 다른 함수 정의를 포함할 수 있으며, 중괄호로 묶인 코드 블록도 포함할 수 있습니다. 블록은 외부 변수에 접근할 수 있지만, 중첩된 함수는 그렇지 않습니다. 블록 내에서 이름에 대한 할당은 외부 스코프에 이미 바인딩된 이름을 가리지 않는 경우에만 지역 변수의 선언을 의미합니다. 그렇지 않으면 할당은 외부 이름의 재할당으로 해석됩니다. Ruby의 스코핑 구문과 규칙 또한 오랫동안 논의되어 왔으며, Ruby 2.0에서 변경될 가능성이 있습니다.\u003c/p\u003e\n\u003ch3\u003e제안 개요 (Overview of Proposals)\u003c/h3\u003e\n\u003cp\u003ePython-Dev에는 외부 스코프의 이름을 재할당하는 방법에 대한 많은 다른 제안들이 있었습니다. 이들은 모두 두 가지 범주로 나뉩니다. 이름이 바인딩되는 스코프(바깥쪽 스코프)에 새로운 구문을 추가하거나, 이름이 사용되는 스코프(안쪽 스코프)에 새로운 구문을 추가하는 것입니다.\u003c/p\u003e\n\u003ch4\u003e바인딩(바깥쪽) 스코프의 새로운 구문 (New Syntax in the Binding (Outer) Scope)\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e스코프 재정의 선언 (Scope Override Declaration)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e이 범주의 제안들은 모두 JavaScript의 \u003ccode\u003evar\u003c/code\u003e와 유사한 새로운 종류의 선언문을 제안합니다. 이 목적을 위해 몇 가지 가능한 키워드가 제안되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003escope x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evar x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emy x\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 모든 제안에서 특정 스코프 \u003ccode\u003eS\u003c/code\u003e 내의 \u003ccode\u003evar x\u003c/code\u003e와 같은 선언은 \u003ccode\u003eS\u003c/code\u003e 내에 중첩된 스코프에서 \u003ccode\u003ex\u003c/code\u003e에 대한 모든 참조가 \u003ccode\u003eS\u003c/code\u003e에 바인딩된 \u003ccode\u003ex\u003c/code\u003e를 참조하도록 합니다.\u003c/p\u003e\n\u003cp\u003e이 범주의 제안에 대한 주요 반대는 함수 정의의 의미가 컨텍스트에 민감해진다는 것입니다. 함수 정의를 다른 블록 안으로 이동하면, 둘러싸는 블록의 선언 때문에 함수 내의 지역 이름 참조 중 일부가 비지역(nonlocal)이 될 수 있습니다. Ruby 1.8의 블록의 경우 실제로 그러합니다. 다음 예시에서 두 \u003ccode\u003esetter\u003c/code\u003e는 동일하게 보이지만 다른 효과를 가집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ruby\"\u003esetter1 = proc { | x | y = x } # y는 여기서는 지역 변수\r\ny = 13\r\nsetter2 = proc { | x | y = x } # y는 여기서는 비지역 변수\r\nsetter1.call(99)\r\nputs y # 13을 출력\r\nsetter2.call(77)\r\nputs y # 77을 출력\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 제안이 JavaScript 및 Perl의 선언과 유사하지만, 언어에 미치는 영향은 다릅니다. 이 언어들에서는 선언되지 않은 변수가 기본적으로 전역인 반면, Python에서는 선언되지 않은 변수가 기본적으로 지역이기 때문입니다. 따라서 JavaScript 또는 Perl에서 함수를 다른 블록 안으로 이동하면 이전에 전역이었던 이름 참조의 스코프를 줄일 수 있을 뿐이지만, 이 제안이 있는 Python에서는 이전에 지역이었던 이름 참조의 스코프를 확장할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e필수 변수 선언 (Required Variable Declaration)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e더 급진적인 제안은 Python의 스코프 추측 규칙을 완전히 제거하고, Scheme처럼 모든 이름이 바인딩될 스코프에서 선언되어야 한다고 제안합니다. 이 제안에서 \u003ccode\u003evar x = 3\u003c/code\u003e은 \u003ccode\u003ex\u003c/code\u003e가 지역 스코프에 속하고 \u003ccode\u003e3\u003c/code\u003e으로 바인딩되도록 선언하는 반면, \u003ccode\u003ex = 3\u003c/code\u003e은 기존에 보이는 \u003ccode\u003ex\u003c/code\u003e를 재할당합니다. \u003ccode\u003evar x\u003c/code\u003e 선언을 포함하는 바깥쪽 스코프가 없는 컨텍스트에서는 \u003ccode\u003ex = 3\u003c/code\u003e 문이 정적으로 불법으로 결정됩니다.\u003c/p\u003e\n\u003cp\u003e이 제안은 간단하고 일관된 모델을 제공하지만, 기존의 모든 Python 코드와 호환되지 않을 것입니다.\u003c/p\u003e\n\u003ch4\u003e참조(안쪽) 스코프의 새로운 구문 (New Syntax in the Referring (Inner) Scope)\u003c/h4\u003e\n\u003cp\u003e이 범주에는 세 가지 유형의 제안이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e외부 참조 표현식 (Outer Reference Expression)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e이 유형의 제안은 변수를 표현식에서 사용할 때 외부 스코프의 변수를 참조하는 새로운 방법을 제안합니다. 이를 위해 제안된 한 가지 구문은 \u003ccode\u003e.x\u003c/code\u003e이며, 이는 지역 바인딩을 생성하지 않고 \u003ccode\u003ex\u003c/code\u003e를 참조합니다. 이 제안에 대한 우려는 많은 컨텍스트에서 \u003ccode\u003ex\u003c/code\u003e와 \u003ccode\u003e.x\u003c/code\u003e가 상호 교환적으로 사용될 수 있어 독자를 혼란스럽게 할 수 있다는 것입니다. 밀접하게 관련된 아이디어는 스코프 레벨을 올라갈 수를 지정하기 위해 여러 점을 사용하는 것이지만, 대부분은 이것이 너무 오류를 유발하기 쉽다고 간주합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e재할당 연산자 (Rebinding Operator)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e이 제안은 이름을 지역으로 선언하지 않고 이름을 재할당하는 새로운 할당 유사 연산자를 제안합니다. \u003ccode\u003ex = 3\u003c/code\u003e 문이 \u003ccode\u003ex\u003c/code\u003e를 지역 변수로 선언하고 \u003ccode\u003e3\u003c/code\u003e으로 바인딩하는 반면, \u003ccode\u003ex := 3\u003c/code\u003e 문은 \u003ccode\u003ex\u003c/code\u003e의 기존 바인딩을 변경하되 지역으로 선언하지 않습니다.\u003c/p\u003e\n\u003cp\u003e이것은 간단한 해결책이지만, PEP 3099에 따르면 거부되었습니다 (아마도 놓치기 쉽거나 \u003ccode\u003e=\u003c/code\u003e와 혼동하기 쉽기 때문일 수 있습니다).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e스코프 재정의 선언 (Scope Override Declaration)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e이 범주의 제안들은 안쪽 스코프에서 이름이 지역이 되는 것을 방지하는 새로운 종류의 선언문을 제안합니다. 이 문은 \u003ccode\u003eglobal\u003c/code\u003e 문과 본질적으로 유사하지만, 이름을 최상위 모듈-레벨 스코프의 바인딩을 참조하게 하는 대신, 가장 가까운 바깥쪽 스코프의 바인딩을 참조하게 합니다.\u003c/p\u003e\n\u003cp\u003e이 접근 방식은 익숙한 Python 구성 요소와 유사하며 함수 정의에 대한 컨텍스트 독립성을 유지한다는 점에서 매력적입니다.\u003c/p\u003e\n\u003cp\u003e이 접근 방식은 보안 및 디버깅 관점에서도 장점이 있습니다. 결과적인 Python은 다른 중첩 스코프 언어의 기능과 일치할 뿐만 아니라, 방어적 프로그래밍에 arguably 더 나은 구문을 제공할 것입니다. 대부분의 다른 언어에서는 선언이 기존 이름의 스코프를 축소하므로, 부주의하게 선언을 생략하면 예상보다 광범위한 (즉, 더 위험한) 효과를 초래할 수 있습니다. 이 제안이 있는 Python에서는 선언을 추가하는 추가적인 노력이 비지역 효과의 증가된 위험과 일치합니다 (즉, 가장 적은 저항의 경로가 더 안전한 경로입니다).\u003c/p\u003e\n\u003cp\u003e이러한 선언에 대해 많은 표기법이 제안되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003escoped x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eglobal x in f\u003c/code\u003e (어떤 스코프인지 명시적으로 지정)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efree x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eouter x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euse x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eglobal x\u003c/code\u003e (\u003ccode\u003eglobal\u003c/code\u003e의 의미 변경)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enonlocal x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eglobal x outer\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eglobal in x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enot global x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eextern x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eref x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erefer x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eshare x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esharing x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecommon x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eusing x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eborrow x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereuse x\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003escope f x\u003c/code\u003e (어떤 스코프인지 명시적으로 지정)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e가장 일반적으로 논의된 선택은 \u003ccode\u003eouter\u003c/code\u003e, \u003ccode\u003eglobal\u003c/code\u003e, \u003ccode\u003enonlocal\u003c/code\u003e이었습니다. \u003ccode\u003eouter\u003c/code\u003e는 표준 라이브러리에서 변수 이름과 속성 이름으로 모두 사용됩니다. \u003ccode\u003eglobal\u003c/code\u003e이라는 단어는 \"전역 변수\"가 일반적으로 최상위 스코프의 변수를 의미하는 것으로 이해되기 때문에 의미가 충돌합니다. C에서 \u003ccode\u003eextern\u003c/code\u003e 키워드는 이름이 다른 컴파일 단위의 변수를 참조한다는 의미입니다. \u003ccode\u003enonlocal\u003c/code\u003e은 약간 길고 다른 옵션보다 덜 듣기 좋지만, \"지역이 아닌\"이라는 정확한 의미를 가집니다.\u003c/p\u003e\n\u003ch3\u003e제안된 해결책 (Proposed Solution)\u003c/h3\u003e\n\u003cp\u003e이 PEP에서 제안하는 해결책은 참조(안쪽) 스코프에 스코프 재정의 선언을 추가하는 것입니다. Guido는 Python-Dev에서 이 범주의 해결책에 대한 선호를 표명했으며, \u003ccode\u003enonlocal\u003c/code\u003e을 키워드로 승인했습니다.\u003c/p\u003e\n\u003cp\u003e제안된 선언은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003enonlocal x\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 현재 스코프에서 \u003ccode\u003ex\u003c/code\u003e가 지역 이름이 되는 것을 방지합니다. 현재 스코프에서 \u003ccode\u003ex\u003c/code\u003e의 모든 발생은 바깥쪽 둘러싸는 스코프에 바인딩된 \u003ccode\u003ex\u003c/code\u003e를 참조하게 됩니다. \u003ccode\u003eglobal\u003c/code\u003e과 마찬가지로 여러 이름이 허용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003enonlocal x, y, z\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e둘러싸는 스코프에 기존 바인딩이 없으면 컴파일러는 \u003ccode\u003eSyntaxError\u003c/code\u003e를 발생시킵니다. (이를 \u003ccode\u003eSyntaxError\u003c/code\u003e라고 부르는 것은 다소 무리가 있을 수 있지만, 현재까지 \u003ccode\u003eSyntaxError\u003c/code\u003e는 알 수 없는 기능 이름과 함께 \u003ccode\u003e__future__ import\u003c/code\u003e를 포함하여 모든 컴파일 시간 오류에 사용됩니다.) Guido는 외부 바인딩이 없는 이런 종류의 선언은 오류로 간주되어야 한다고 말했습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enonlocal\u003c/code\u003e 선언이 지역 스코프의 형식 매개변수 이름과 충돌하면 컴파일러는 \u003ccode\u003eSyntaxError\u003c/code\u003e를 발생시킵니다.\u003c/p\u003e\n\u003cp\u003e단축 형태도 허용됩니다. 이 경우 \u003ccode\u003enonlocal\u003c/code\u003e이 할당 또는 증강 할당 앞에 붙습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003enonlocal x = 3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 내용은 \u003ccode\u003enonlocal x; x = 3\u003c/code\u003e과 정확히 같은 의미를 가집니다. (Guido는 \u003ccode\u003eglobal\u003c/code\u003e 문의 유사한 형태를 지지합니다.)\u003c/p\u003e\n\u003cp\u003e단축 형태의 왼쪽에는 식별자만 허용되며, \u003ccode\u003ex[0]\u003c/code\u003e와 같은 대상 표현식은 허용되지 않습니다. 그 외의 모든 할당 형태는 허용됩니다. \u003ccode\u003enonlocal\u003c/code\u003e 문의 제안된 문법은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enonlocal_stmt ::= \"nonlocal\" identifier (\",\" identifier)* [\"=\" (target_list \"=\")+ expression_list]\r\n                | \"nonlocal\" identifier augop expression_list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 모든 할당 형태를 허용하는 이유는 \u003ccode\u003enonlocal\u003c/code\u003e 문의 이해를 단순화하기 위함입니다. 단축 형태를 선언과 할당으로 분리하는 것이 그 의미와 유효성을 이해하는 데 충분합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 원본 PEP 구현에는 단축 구문이 추가되지 않았습니다. 이후 논의에서는 이 구문을 구현해서는 안 된다는 결론을 내렸습니다.\u003c/p\u003e\n\u003ch3\u003e하위 호환성 (Backward Compatibility)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 Guido가 제안한 대로 Python 3000(Python 3.x의 초기 명칭)을 대상으로 합니다. 그러나 다른 이들은 이 PEP에서 고려된 일부 옵션이 Python 2.x에서 실행 가능한 충분히 작은 변경 사항일 수 있으며, 이 경우 이 PEP가 2.x 시리즈 PEP로 이동될 수도 있다고 언급했습니다.\u003c/p\u003e\n\u003cp\u003e새로운 키워드를 도입하는 영향을 (매우 대략적으로) 측정하기 위해, 2006년 11월 5일 Python SVN 저장소 스캔에 따르면 표준 라이브러리에서 제안된 일부 키워드가 식별자로 나타난 횟수는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enonlocal\u003c/code\u003e: 0\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euse\u003c/code\u003e: 2\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eusing\u003c/code\u003e: 3\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereuse\u003c/code\u003e: 4\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efree\u003c/code\u003e: 8\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eouter\u003c/code\u003e: 147\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eglobal\u003c/code\u003e은 기존 키워드로 214번 나타납니다. \u003ccode\u003eglobal\u003c/code\u003e을 외부 스코프 키워드로 사용하는 영향을 측정하면, 그러한 변경으로 인해 표준 라이브러리에서 깨질 파일은 18개입니다 (함수가 전역 스코프에 해당 변수가 도입되기 전에 변수를 \u003ccode\u003eglobal\u003c/code\u003e로 선언하기 때문).\u003c/p\u003e\n\u003ch3\u003e참고 문헌 (References)\u003c/h3\u003e\n\u003cp\u003eScoping (was Re: Lambda binding solved?) (Rafael Bracho)\r\nExtended Function syntax (Just van Rossum)\r\nClosure semantics (Guido van Rossum)\r\n... (생략, 원문 참조) ...\u003c/p\u003e\n\u003ch3\u003e감사의 글 (Acknowledgements)\u003c/h3\u003e\n\u003cp\u003e이 PEP에 언급된 아이디어와 제안들은 수많은 Python-Dev 게시물에서 얻은 것입니다. 이 PEP에 대한 특정 편집을 제안해 주신 Jim Jewett, Mike Orr, Jason Orendorff, Christian Tanzer에게 감사드립니다.\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1318,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 3104 - Access to Names in Outer Scopes\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 14:17:40+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>