<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-1a135130af3e1cae.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1318<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Deferred] PEP 532 - A circuit breaking protocol and binary operators</h1><div class="page__meta"><time dateTime="2025-09-26 23:23:40+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0532/">PEP 532 - A circuit breaking protocol and binary operators</a></p>
<p><strong>상태:</strong> Deferred | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 30-Oct-2016</p>
</blockquote>
<h1>PEP 532 – 회로 차단(Circuit Breaking) 프로토콜 및 이항(Binary) 연산자</h1>
<h2>PEP 연기 (PEP Deferral)</h2>
<p>이 PEP에 대한 추가 검토는 최소한 Python 3.8까지 연기되었습니다.</p>
<h2>요약 (Abstract)</h2>
<p>PEP 335, PEP 505, PEP 531 및 관련 논의에서 영감을 받은 이 PEP는 새로운 "회로 차단(circuit breaking)" 프로토콜(메서드 이름 <code>__then__</code> 및 <code>__else__</code> 사용)의 정의를 제안합니다. 이 프로토콜은 다음을 위한 공통적인 기본 의미론적 기반을 제공합니다.</p>
<ul>
<li>조건부 표현식(conditional expressions): <code>LHS if COND else RHS</code></li>
<li>논리적 AND 연산: <code>LHS and RHS</code></li>
<li>논리적 OR 연산: <code>LHS or RHS</code></li>
<li>PEP 505에서 제안된 None-aware 연산자</li>
<li>PEP 535에서 제안된 풍부한 비교 체인 모델</li>
</ul>
<p>새로운 프로토콜을 활용하여, 조건부 표현식의 정의를 수정하여 <code>if</code>와 <code>else</code>를 각각 우측 결합(right-associative) 및 좌측 결합(left-associative)의 범용 단락(short-circuiting) 연산자로 사용할 수 있도록 제안합니다.</p>
<ul>
<li>우측 결합 단락: <code>LHS if RHS</code></li>
<li>좌측 결합 단락: <code>LHS else RHS</code></li>
</ul>
<p>논리적 반전(<code>not EXPR</code>)을 위의 변경 사항과 일관되게 만들기 위해 새로운 논리적 반전 프로토콜(메서드 이름 <code>__not__</code> 사용) 도입을 제안합니다.</p>
<p>회로 차단기의 단락 동작을 강제하기 위해 표현식을 두 번 평가할 필요 없이 <code>operator</code> 모듈에 새로운 <code>operator.short_circuit(obj)</code> 헬퍼 함수가 추가될 예정입니다.</p>
<p>마지막으로, 객체의 참/거짓 값(제어 흐름을 결정하는 데 사용됨)을 단락된 회로 차단 표현식에서 반환하는 값과 분리하기 위해 새로운 표준 <code>types.CircuitBreaker</code> 타입이 제안되며, 특히 일반적인 스위칭 관용구를 나타내기 위해 <code>operator</code> 모듈에 다음 팩토리 함수가 추가됩니다.</p>
<ul>
<li><code>bool(obj)</code>에 따라 전환: <code>operator.true(obj)</code></li>
<li><code>not bool(obj)</code>에 따라 전환: <code>operator.false(obj)</code></li>
<li><code>obj is value</code>에 따라 전환: <code>operator.is_sentinel(obj, value)</code></li>
<li><code>obj is not value</code>에 따라 전환: <code>operator.is_not_sentinel(obj, value)</code></li>
</ul>
<h2>다른 PEP와의 관계 (Relationship with other PEPs)</h2>
<p>이 PEP는 다른 제안들의 광범위한 작업 내역을 기반으로 합니다. 주요 제안 중 일부는 아래에서 논의됩니다.</p>
<h3>PEP 531: 존재 확인 프로토콜 (Existence checking protocol)</h3>
<p>이 PEP는 PEP 531의 직접적인 후속작으로, 거기서 정의된 존재 확인 프로토콜과 새로운 <code>?then</code> 및 <code>?else</code> 문법 연산자를 새로운 회로 차단 프로토콜과 조건부 표현식 및 <code>not</code> 연산자에 대한 조정으로 대체합니다.</p>
<h3>PEP 505: None-aware 연산자</h3>
<p>이 PEP는 PEP 505의 None-aware 연산자 제안을 보완하여, 조건부 표현식의 특정 사용에 대한 고도로 최적화된 문법 설탕(syntactic sugar)으로서 단락 동작을 설명하는 기본 프로토콜 기반 의미론적 프레임워크를 제공합니다.</p>
<p>이 PEP에서 제안된 변경 사항을 고려할 때:</p>
<ul>
<li><code>LHS ?? RHS</code>는 대략 <code>is_not_sentinel(LHS, None) else RHS</code>와 같을 것입니다.</li>
<li><code>EXPR?.attr</code>는 대략 <code>EXPR.attr if is_not_sentinel(EXPR, None)</code>와 같을 것입니다.</li>
<li><code>EXPR?[key]</code>는 대략 <code>EXPR[key] if is_not_sentinel(EXPR, None)</code>와 같을 것입니다.</li>
</ul>
<p>이 세 가지 경우 모두, 전용 문법 형식은 실제로 회로 차단기 인스턴스를 생성하는 것을 피하고 기본 제어 흐름을 직접 구현하도록 최적화됩니다. 후자 두 경우에서는 문법 형식이 <code>EXPR</code>를 두 번 평가하는 것도 피합니다. 이는 None-aware 연산자가 None에 특화되어 있지만, 다른 Sentinel 값은 이 PEP의 더 일반적인 프로토콜 기반 제안을 통해 여전히 사용될 수 있음을 의미합니다.</p>
<h3>PEP 335: 오버로드 가능한 불리언 연산자 (Overloadable Boolean operators)</h3>
<p>PEP 335는 단락 <code>and</code> 및 <code>or</code> 연산자를 직접 오버로드할 수 있는 기능을 제안했으며, 비교 체인 의미론을 오버로드할 수 있는 기능이 그 변경의 결과 중 하나였습니다.</p>
<h3>PEP 535: 풍부한 비교 체인 (Rich comparison chaining)</h3>
<p>위에서 언급했듯이, PEP 535는 PEP 207에 도입된 풍부한 비교 지원을 확장하여 <code>LEFT_BOUND &#x3C; VALUE &#x3C; RIGHT_BOUND</code>와 같은 비교 체인 연산도 처리하기 위해 이 PEP에 정의된 회로 차단 프로토콜을 기반으로 하는 제안입니다.</p>
<h2>명세 (Specification)</h2>
<h3>회로 차단 프로토콜 (<code>if-else</code>)</h3>
<p>조건부 표현식 (<code>LHS if COND else RHS</code>)은 현재 다음과 같이 표현식 수준에서 해석됩니다.</p>
<pre><code class="language-python">if COND:
    _expr_result = LHS
else:
    _expr_result = RHS
</code></pre>
<p>이 PEP는 확인된 조건이 새로운 "회로 차단" 프로토콜을 구현할 수 있도록 확장을 변경하여 표현식의 양쪽 분기 중 하나 또는 둘 다의 결과를 보고 잠재적으로 변경할 수 있도록 제안합니다.</p>
<pre><code class="language-python">_cb = COND
_type_cb = type(_cb)
if _cb:
    _expr_result = LHS
    if hasattr(_type_cb, "__then__"):
        _expr_result = _type_cb.__then__(_cb, _expr_result)
else:
    _expr_result = RHS
    if hasattr(_type_cb, "__else__"):
        _expr_result = _type_cb.__else__(_cb, _expr_result)
</code></pre>
<p>표시된 대로, 인터프리터 구현은 실제로 실행되는 조건부 표현식의 분기에 필요한 프로토콜 메서드만 액세스해야 합니다. 다른 프로토콜 메서드와 마찬가지로, 특수 메서드는 인스턴스에서 직접이 아니라 회로 차단기의 타입을 통해 조회됩니다.</p>
<h3>회로 차단 연산자 (<code>binary if</code> 및 <code>binary else</code>)</h3>
<p>프로토콜의 제안된 이름은 조건부 표현식의 의미론 변경에서 오는 것이 아닙니다. 오히려, 기존의 <code>True</code> 및 <code>False</code> 기반 단락 연산자(<code>or</code> 및 <code>and</code> 각각)와 PEP 505에서 제안된 <code>None</code> 기반 단락 연산자(<code>??</code>)를 보완하기 위해 <code>if</code>와 <code>else</code>를 범용 프로토콜 기반 단락 연산자로 추가하는 제안에서 비롯됩니다. 이 두 연산자는 함께 회로 차단 연산자(circuit breaking operators)로 알려질 것입니다.</p>
<p>이러한 사용을 지원하기 위해, 언어 문법에서 조건부 표현식의 정의는 <code>if</code> 절과 <code>else</code> 절을 모두 선택 사항으로 만들도록 업데이트됩니다.</p>
<pre><code>test: else_test ['if' or_test ['else' test]] | lambdef
else_test: or_test ['else' test]
</code></pre>
<p>문법의 <code>test_nocond</code> 노드(조건부 표현식을 의도적으로 제외하는)의 정의는 변경되지 않으므로, 회로 차단 연산자는 List Comprehension 및 제너레이터(generator) 표현식의 <code>if</code> 절에서 조건부 표현식 자체와 마찬가지로 괄호가 필요합니다.</p>
<p>이 문법 정의는 <code>expr1 if cond else expr2 else expr3</code>와 같이 모호한 경우의 우선순위/결합성을 <code>(expr1 if cond else expr2) else expr3</code>로 해결합니다. 그러나 PEP 8에 "이런 식으로 사용하지 말라"는 지침이 추가될 것입니다. 왜냐하면 이러한 구성은 인터프리터가 어떻게 실행하든 독자에게 본질적으로 혼란스러울 것이기 때문입니다.</p>
<p>우측 결합 회로 차단 연산자 (<code>LHS if RHS</code>)는 다음과 같이 확장됩니다.</p>
<pre><code class="language-python">_cb = RHS
_expr_result = LHS if _cb else _cb
</code></pre>
<p>좌측 결합 회로 차단 연산자 (<code>LHS else RHS</code>)는 다음과 같이 확장됩니다.</p>
<pre><code class="language-python">_cb = LHS
_expr_result = _cb if _cb else RHS
</code></pre>
<p>두 경우 모두 핵심은 회로 차단 표현식이 단락될 때, 조건이 회로 차단기가 아니라면 조건 표현식이 표현식의 결과로 사용된다는 것입니다. 후자의 경우, 적절한 회로 차단 프로토콜 메서드는 평소와 같이 호출되지만, 회로 차단기 자체가 메서드 인수로 제공됩니다. 이를 통해 회로 차단기는 후보 표현식 결과로 전달된 인수가 <code>self</code>인지 확인하여 단락을 안정적으로 감지할 수 있습니다.</p>
<h3>논리적 반전 오버로드 (<code>not</code>)</h3>
<p>모든 회로 차단기 정의에는 여전히 회로 차단기이지만 표현식 평가를 단락할 시점에 대한 답변을 반전시키는 논리적 역(logical inverse)이 있습니다. 예를 들어, 이 PEP에서 제안된 <code>operator.true</code> 및 <code>operator.false</code> 회로 차단기는 서로의 논리적 역입니다.</p>
<p><code>__not__(self)</code>라는 새로운 프로토콜 메서드가 도입되어 회로 차단기 및 다른 타입이 <code>not</code> 표현식을 재정의하여 강제된 불리언 결과 대신 논리적 역을 반환할 수 있도록 합니다.</p>
<p>기존 언어 최적화(예: 불리언 컨텍스트에서 이중 부정을 중복으로 직접 제거하는 것)의 의미론을 유지하기 위해, <code>__not__</code> 구현은 다음 불변식을 준수해야 합니다.</p>
<pre><code class="language-python">assert not bool(obj) == bool(not obj)
</code></pre>
<p>그러나 대칭 회로 차단기(모든 <code>__bool__</code>, <code>__not__</code>, <code>__then__</code>, <code>__else__</code>를 구현하는)는 표현식에 관련된 모든 회로 차단기가 "참"에 대한 일관된 정의를 사용할 때만 불리언 논리의 완전한 의미론을 준수할 것으로 예상됩니다.</p>
<h3>단락 동작 강제 (Forcing short-circuiting behaviour)</h3>
<p>회로 차단기의 단락 동작은 조건부 표현식에서 세 피연산자 모두로 사용하거나 (<code>obj if obj else obj</code>), 회로 차단 표현식에서 두 피연산자 모두로 사용하여 (<code>obj if obj</code> 또는 <code>obj else obj</code>) 강제할 수 있습니다.</p>
<p>이러한 패턴 중 하나를 사용할 필요 없이, 이 PEP는 <code>operator</code> 모듈에 회로 차단기를 명시적으로 단락시키고 다른 객체는 수정하지 않고 통과시키는 전용 함수를 추가할 것을 제안합니다.</p>
<pre><code class="language-python">def short_circuit(obj):
    """
    Replace circuit breakers with their short-circuited result
    Passes other input values through unmodified.
    """
    return obj if obj else obj
</code></pre>
<h3>회로 차단 Identity 비교 (<code>is</code> 및 <code>is not</code>)</h3>
<p>표준 회로 차단기가 없는 경우, 제안된 <code>if</code> 및 <code>else</code> 연산자는 기존 <code>and</code> 및 <code>or</code> 논리 연산자의 특이한 철자가 될 것입니다. 그러나 이 PEP는 적절한 단락 로직을 구현하는 새로운 범용 <code>types.CircuitBreaker</code> 타입과 <code>is</code> 및 <code>is not</code> 연산자에 해당하는 팩토리 함수를 <code>operator</code> 모듈에 제공할 것을 제안합니다.</p>
<p>이들은 조건부 검사가 실패할 때 <code>False</code> 대신 <code>VALUE</code>를 생성하는 방식으로 정의됩니다.</p>
<ul>
<li><code>EXPR if is_sentinel(VALUE, SENTINEL)</code></li>
<li><code>EXPR if is_not_sentinel(VALUE, SENTINEL)</code></li>
</ul>
<p>마찬가지로, 조건부 검사가 성공할 때 <code>True</code> 대신 <code>VALUE</code>를 생성합니다.</p>
<ul>
<li><code>is_sentinel(VALUE, SENTINEL) else EXPR</code></li>
<li><code>is_not_sentinel(VALUE, SENTINEL) else EXPR</code></li>
</ul>
<p>사실상, 이러한 비교는 다음과 같은 형태의 표현식에서 선행 <code>VALUE if</code> 및 후행 <code>else VALUE</code> 절을 생략할 수 있도록 정의됩니다.</p>
<pre><code class="language-python"># "if" 표현식을 처리하기 위해, " else VALUE"는 생략될 때 암시됩니다.
EXPR if is_sentinel(VALUE, SENTINEL) else VALUE
EXPR if is_not_sentinel(VALUE, SENTINEL) else VALUE
# "else" 표현식을 처리하기 위해, "VALUE if "는 생략될 때 암시됩니다.
VALUE if is_sentinel(VALUE, SENTINEL) else EXPR
VALUE if is_not_sentinel(VALUE, SENTINEL) else EXPR
</code></pre>
<p>제안된 <code>types.CircuitBreaker</code> 타입은 이 동작을 다음과 같이 프로그래밍 방식으로 표현합니다.</p>
<pre><code class="language-python">class CircuitBreaker:
    """Simple circuit breaker type"""
    def __init__(self, value, bool_value):
        self.value = value
        self.bool_value = bool(bool_value)
    def __bool__(self):
        return self.bool_value
    def __not__(self):
        return CircuitBreaker(self.value, not self.bool_value)
    def __then__(self, result):
        if result is self:
            return self.value
        return result
    def __else__(self, result):
        if result is self:
            return self.value
        return result
</code></pre>
<p>이러한 회로 차단기의 주요 특징은 일시적(ephemeral)이라는 것입니다. 단락이 발생했다고 통보받으면(후보 표현식 결과로 자신에 대한 참조를 받음으로써), 회로 차단기 래퍼(wrapper) 대신 원래 값을 반환합니다.</p>
<p>단락 감지는 다음과 같이 정의됩니다. 동일한 회로 차단기 인스턴스를 회로 차단 연산자의 양쪽에 명시적으로 전달하거나 조건부 표현식에서 세 피연산자 모두로 사용하면 래퍼가 항상 제거됩니다.</p>
<p><code>operator</code> 모듈의 팩토리 함수는 <code>is</code> 및 <code>is not</code> 연산자를 사용하는 ID 검사에 해당하는 회로 차단기를 생성하기 쉽게 만들 것입니다.</p>
<pre><code class="language-python">def is_sentinel(value, sentinel):
    """Returns a circuit breaker switching on 'value is sentinel'"""
    return types.CircuitBreaker(value, value is sentinel)

def is_not_sentinel(value, sentinel):
    """Returns a circuit breaker switching on 'value is not sentinel'"""
    return types.CircuitBreaker(value, value is not sentinel)
</code></pre>
<h3>참 확인 비교 (Truth checking comparisons)</h3>
<p>단락 특성으로 인해 <code>and</code> 및 <code>or</code> 연산자의 기본 런타임 로직은 이전에 <code>operator</code> 또는 <code>types</code> 모듈을 통해 접근할 수 없었습니다. 회로 차단 연산자와 회로 차단기의 도입은 해당 로직을 <code>operator</code> 모듈에 다음과 같이 캡처할 수 있도록 합니다.</p>
<pre><code class="language-python">def true(value):
    """Returns a circuit breaker switching on 'bool(value)'"""
    return types.CircuitBreaker(value, bool(value))

def false(value):
    """Returns a circuit breaker switching on 'not bool(value)'"""
    return types.CircuitBreaker(value, not bool(value))
</code></pre>
<p><code>LHS or RHS</code>는 사실상 <code>true(LHS) else RHS</code>가 될 것이고, <code>LHS and RHS</code>는 사실상 <code>false(LHS) else RHS</code>가 될 것입니다.</p>
<p>이러한 연산자 정의에는 실제 변경이 없을 것이며, 새로운 회로 차단 프로토콜과 연산자는 개발 시점에 검사의 의미를 하드코딩하는 대신 제어 흐름 로직을 프로그래밍할 수 있는 방법을 제공할 것입니다. 불리언 논리의 규칙을 준수하면, 이러한 표현식은 우측 결합 회로 차단 연산자를 대신 사용하여 역전된 형태로도 확장될 수 있습니다.</p>
<ul>
<li><code>LHS or RHS</code>는 사실상 <code>RHS if false(LHS)</code>가 될 것입니다.</li>
<li><code>LHS and RHS</code>는 사실상 <code>RHS if true(LHS)</code>가 될 것입니다.</li>
</ul>
<h3>None-aware 연산자</h3>
<p>이 PEP와 PEP 505의 None-aware 연산자가 모두 수락된다면, 제안된 <code>is_sentinel</code> 및 <code>is_not_sentinel</code> 회로 차단기 팩토리는 "None 확인(None checking)" 개념을 캡슐화하는 데 사용될 것입니다. 즉, 값이 <code>None</code>인지 확인하고 대체 값으로 폴백하거나(None-coalescing) 전체 표현식의 결과로 통과시키는(None-severing 또는 None-propagating) 것입니다.</p>
<p>이러한 회로 차단기를 고려할 때, <code>LHS ?? RHS</code>는 대략 다음 두 가지와 동일할 것입니다.</p>
<ul>
<li><code>is_not_sentinel(LHS, None) else RHS</code></li>
<li><code>RHS if is_sentinel(LHS, None)</code></li>
</ul>
<p>속성 조회 및 서브스크립트(subscripting) 연산에 제어 흐름을 주입하는 방식 때문에 None-aware 속성 접근 및 None-aware 서브스크립트는 회로 차단 연산자로 직접 표현할 수 없지만, 기본 회로 차단 프로토콜을 통해 여전히 정의될 수 있습니다.</p>
<p>이러한 측면에서 <code>EXPR?.ATTR[KEY].SUBATTR()</code>는 의미론적으로 다음과 동일할 것입니다.</p>
<pre><code class="language-python">_lookup_base = EXPR
_circuit_breaker = is_not_sentinel(_lookup_base, None)
_expr_result = _lookup_base.ATTR[KEY].SUBATTR() if _circuit_breaker
</code></pre>
<p>마찬가지로, <code>EXPR?[KEY].ATTR.SUBATTR()</code>는 의미론적으로 다음과 동일할 것입니다.</p>
<pre><code class="language-python">_lookup_base = EXPR
_circuit_breaker = is_not_sentinel(_lookup_base, None)
_expr_result = _lookup_base[KEY].ATTR.SUBATTR() if _circuit_breaker
</code></pre>
<p>None-aware 연산자의 실제 구현은 회로 차단기 인스턴스를 실제로 생성하는 것을 건너뛰도록 최적화될 것으로 예상되지만, 위 확장은 런타임에 연산자의 관찰 가능한 동작에 대한 정확한 설명을 제공할 것입니다.</p>
<h3>풍부한 체인 비교 (Rich chained comparisons)</h3>
<p>이 가능한 사용 사례에 대한 자세한 논의는 PEP 535를 참조하십시오.</p>
<h3>기타 조건부 구성 (Other conditional constructs)</h3>
<p><code>if</code> 문, <code>while</code> 문, Comprehension 또는 제너레이터(generator) 표현식에는 변경 사항이 제안되지 않습니다. 이러한 구성에 포함된 불리언 절은 전적으로 제어 흐름 목적으로 사용되며 그 자체로 결과를 반환하지 않기 때문입니다.</p>
<p>그러나 이러한 제안이 이 PEP의 범위를 벗어나지만, 여기에 정의된 회로 차단 프로토콜은 다음과 같은 구성을 지원하기에 충분하다는 점은 주목할 가치가 있습니다.</p>
<pre><code class="language-python">def is_not_none(obj):
    return is_sentinel(obj, None)

while is_not_none(dynamic_query()) as result:
    ... # Code using result
</code></pre>
<p>그리고:</p>
<pre><code class="language-python">if is_not_none(re.search(pattern, text)) as match:
    ... # Code using match
</code></pre>
<p>이는 <code>CONDITION</code>을 주어진 이름에 직접 할당하는 대신 <code>operator.short_circuit(CONDITION)</code>의 결과를 <code>as</code> 절에 주어진 이름에 할당함으로써 수행될 수 있습니다.</p>
<h3>스타일 가이드 권장 사항 (Style guide recommendations)</h3>
<p>이 PEP에서 도입된 새로운 기능과 관련하여 PEP 8에 다음 추가 사항이 제안됩니다.</p>
<ul>
<li>조건부 표현식(<code>if-else</code>)과 독립형 회로 차단 연산자(<code>if</code> 및 <code>else</code>)를 단일 표현식에서 결합하는 것을 피하십시오. 상황에 따라 둘 중 하나를 사용하고, 둘 다 사용하지 마십시오.</li>
<li><code>if</code> 문의 <code>if</code> 조건과 Comprehension 및 제너레이터 표현식의 필터(filter) 절의 일부로 조건부 표현식(<code>if-else</code>)과 독립형 회로 차단 연산자(<code>if</code> 및 <code>else</code>)를 사용하는 것을 피하십시오.</li>
</ul>
<h2>근거 (Rationale)</h2>
<h3>새로운 연산자 추가 (Adding new operators)</h3>
<p>PEP 335와 유사하게, 이 PEP의 초기 초안은 새로운 연산자를 제안하기보다 기존 <code>and</code> 및 <code>or</code> 연산자의 해석을 덜 엄격하게 만드는 데 중점을 두었습니다. 그러나 이는 몇 가지 주요 이유로 문제가 있는 것으로 판명되었습니다.</p>
<ul>
<li><code>and</code> 및 <code>or</code> 연산자는 오랫동안 확립된 안정적인 의미를 가지므로, 독자들은 그 의미가 이제 왼쪽 피연산자의 타입에 따라 달라진다면 필연적으로 놀랄 것입니다. 새로운 사용자조차도 이 연산자들에 대한 현재의 잘 알려진 의미론을 가정하는 25년 이상의 교육 자료 때문에 이 변경에 혼란스러워할 것입니다.</li>
<li>CPython을 포함한 Python 인터프리터 구현은 이러한 연산의 의미론이 변경된다면 모두 검토하고 잠재적으로 폐기해야 할 런타임 및 컴파일 시간 최적화를 정의할 때 <code>and</code> 및 <code>or</code>의 기존 의미론을 활용했습니다.</li>
<li>프로토콜을 정의하는 데 필요한 새로운 메서드에 어떤 이름이 적절할지 명확하지 않습니다.</li>
</ul>
<p>대신 기존 <code>if-else</code> 삼항 연산자의 단락 이항 변형을 제안하는 것은 이러한 모든 문제를 해결합니다.</p>
<ul>
<li><code>and</code> 및 <code>or</code>의 런타임 의미론은 완전히 변경되지 않은 채 유지됩니다.</li>
<li>단항 <code>not</code> 연산자의 의미론은 변경되지만, <code>__not__</code> 구현에 필요한 불변식은 불리언 컨텍스트에서 기존 표현식 최적화가 유효하게 유지됨을 의미합니다.</li>
<li><code>__else__</code>는 후행 <code>else</code> 절이 없기 때문에 <code>if</code> 표현식의 단락 결과입니다.</li>
<li><code>__then__</code>은 선행 <code>if</code> 절이 없기 때문에 <code>else</code> 표현식의 단락 결과입니다(메서드 이름이 <code>__if__</code>였다면 이 연결이 더 명확했겠지만, 회로 차단 프로토콜을 호출하지 않는 <code>if</code> 키워드의 다른 용도 때문에 모호할 수 있습니다).</li>
</ul>
<h3>연산자 및 프로토콜 이름 지정 (Naming the operator and protocol)</h3>
<p>"circuit breaking operator", "circuit breaking protocol", "circuit breaker"라는 이름은 모두 "short circuiting operator"라는 구절에서 영감을 받았습니다. 이는 오른쪽 피연산자를 조건부로만 평가하는 연산자에 대한 일반적인 언어 설계 용어입니다.</p>
<p>전기 아날로지(analogy)는 Python의 회로 차단기가 전기 시스템의 회로 차단기가 장비를 손상시키거나 사람에게 해를 끼치기 전에 단락을 감지하고 처리하는 방식과 유사하게 예외가 발생하기 전에 표현식의 단락을 감지하고 처리한다는 것입니다.</p>
<p>Python 수준의 아날로지는 <code>break</code> 문이 루프가 자연스러운 결론에 도달하기 전에 루프를 종료할 수 있게 하는 것처럼, 회로 차단 표현식은 표현식 평가를 종료하고 즉시 결과를 생성할 수 있게 한다는 것입니다.</p>
<h3>기존 키워드 사용 (Using existing keywords)</h3>
<p>기존 키워드를 사용하면 <code>__future__</code> 문 없이 새 연산자를 도입할 수 있는 이점이 있습니다. <code>if</code>와 <code>else</code>는 제안된 새 프로토콜에 의미론적으로 적합하며, 도입된 유일한 추가 문법적 모호성은 새 연산자가 명시적 <code>if-else</code> 조건부 표현식 문법과 결합될 때 발생합니다.</p>
<p>PEP는 인터프리터 구현자가 이를 어떻게 처리해야 하는지 명시적으로 지정하여 이 모호성을 처리하지만, PEP 8에서 인터프리터는 이를 이해하더라도 인간 독자는 아마 그렇지 않을 것이므로, 단일 표현식에서 조건부 표현식과 회로 차단 연산자를 모두 사용하는 것은 좋은 생각이 아닐 것이라고 지적할 것을 제안합니다.</p>
<h3>프로토콜 메서드 이름 지정 (Naming the protocol methods)</h3>
<p><code>__else__</code> 메서드의 이름 지정은 간단했습니다. 연산자 키워드 이름을 재사용하면 명확하고 모호하지 않은 특수 메서드 이름이 됩니다.</p>
<p><code>__then__</code> 메서드의 이름 지정은 덜 간단했습니다. 키워드 기반 이름 <code>__if__</code>를 사용하는 또 다른 가능한 옵션이 있었기 때문입니다.</p>
<p><code>__if__</code>의 문제는 <code>if</code> 키워드가 오른쪽에 표현식과 함께 나타나지만, <code>__if__</code> 특수 메서드가 호출되지 않는 많은 경우가 계속 존재한다는 것입니다. 대신, <code>bool()</code> 내장 함수와 그 기본 특수 메서드(<code>__bool__</code>, <code>__len__</code>)가 호출되고, <code>__if__</code>는 효과가 없을 것입니다.</p>
<p>불리언 프로토콜이 조건부 표현식과 새로운 회로 차단 프로토콜에서 이미 역할을 하고 있으므로, 컴퓨터 과학 및 프로그래밍 언어 설계에서 <code>if</code> 문의 첫 번째 절을 설명하는 데 일반적으로 사용되는 용어에 기반하여 덜 모호한 이름 <code>__then__</code>이 선택되었습니다.</p>
<h3>이항 <code>if</code>를 우측 결합으로 만들기 (Making binary if right-associative)</h3>
<p>조건부 표현식에 의해 설정된 선례는 이항 단락 <code>if</code> 표현식이 일관성 문제로 인해 조건이 오른쪽에 있어야 한다는 것을 의미합니다. 오른쪽 피연산자가 항상 먼저 평가되고, 불리언 컨텍스트에서 오른쪽 피연산자가 참이면 왼쪽 피연산자가 전혀 평가되지 않는다는 점을 고려할 때, 자연스러운 결과는 우측 결합 연산자입니다.</p>
<h3>표준 회로 차단기 이름 지정 (Naming the standard circuit breakers)</h3>
<p>좌측 결합 회로 차단 연산자와만 사용될 때, 단항 검사를 위한 명시적 회로 차단기 이름은 <code>if_</code> 전치사로 시작하면 잘 읽힙니다.</p>
<ul>
<li><code>operator.if_true(LHS) else RHS</code></li>
<li><code>operator.if_false(LHS) else RHS</code></li>
</ul>
<p>그러나 <code>if_</code>를 포함하는 것은 논리적 반전을 수행할 때 잘 읽히지 않습니다.</p>
<ul>
<li><code>not operator.if_true(LHS) else RHS</code></li>
<li><code>not operator.if_false(LHS) else RHS</code></li>
</ul>
<p>또는 우측 결합 회로 차단 연산자를 사용할 때:</p>
<ul>
<li><code>LHS if operator.if_true(RHS)</code></li>
<li><code>LHS if operator.if_false(RHS)</code></li>
</ul>
<p>또는 이항 비교 연산자 이름을 지정할 때:</p>
<ul>
<li><code>operator.if_is_sentinel(VALUE, SENTINEL) else EXPR</code></li>
<li><code>operator.if_is_not_sentinel(VALUE, SENTINEL) else EXPR</code></li>
</ul>
<p>대조적으로, 회로 차단기 이름에서 전치사를 생략하면 단항 검사에 대한 모든 형태에서 합리적으로 잘 읽히는 결과가 나옵니다.</p>
<ul>
<li><code>operator.true(LHS) else RHS</code> (선행 <code>"LHS if "</code> 암시됨)</li>
<li><code>operator.false(LHS) else RHS</code> (선행 <code>"LHS if "</code> 암시됨)</li>
<li><code>not operator.true(LHS) else RHS</code> (선행 <code>"LHS if "</code> 암시됨)</li>
<li><code>not operator.false(LHS) else RHS</code> (선행 <code>"LHS if "</code> 암시됨)</li>
<li><code>LHS if operator.true(RHS)</code> (후행 <code>" else RHS"</code> 암시됨)</li>
<li><code>LHS if operator.false(RHS)</code> (후행 <code>" else RHS"</code> 암시됨)</li>
<li><code>LHS if not operator.true(RHS)</code> (후행 <code>" else RHS"</code> 암시됨)</li>
<li><code>LHS if not operator.false(RHS)</code> (후행 <code>" else RHS"</code> 암시됨)</li>
</ul>
<p>그리고 이항 검사에서도 잘 읽힙니다.</p>
<ul>
<li><code>operator.is_sentinel(VALUE, SENTINEL) else EXPR</code></li>
<li><code>operator.is_not_sentinel(VALUE, SENTINEL) else EXPR</code></li>
<li><code>EXPR if operator.is_sentinel(VALUE, SENTINEL)</code></li>
<li><code>EXPR if operator.is_not_sentinel(VALUE, SENTINEL)</code></li>
</ul>
<h2>위험 및 우려 사항 (Risks and concerns)</h2>
<p>이 PEP는 PEP 335, 505, 531 논의 시 제기된 위험과 우려 사항을 특히 해결하도록 설계되었습니다.</p>
<ul>
<li>기존 <code>and</code> 및 <code>or</code> 연산자에 영향을 미치기보다는 새로운 연산자를 정의하고 체인 비교 정의를 조정합니다(별도의 PEP에서).</li>
<li>제안된 새로운 연산자는 범용 단락 이항 연산자로, <code>None</code>에 대한 ID 확인에만 유연성 없이 초점을 맞추기보다는 <code>and</code> 및 <code>or</code>의 기존 의미론을 표현하는 데에도 사용될 수 있습니다.</li>
<li><code>not</code> 단항 연산자와 <code>is</code> 및 <code>is not</code> 이항 비교 연산자에 대한 변경 사항은 기존 의미론에 기반한 제어 흐름 최적화가 유효하게 유지되도록 정의됩니다.</li>
</ul>
<p>이 접근 방식의 한 가지 결과는 이 PEP 자체만으로는 최종 사용자에게 직접적인 이점을 많이 제공하지 않는다는 것입니다. 일부 일반적인 <code>None if</code> 접두사와 <code>else None</code> 접미사를 특정 형태의 조건부 표현식에서 생략할 수 있게 해주는 것 외에는 말입니다.</p>
<p>대신, 주로 제공하는 것은 PEP 505의 None-aware 연산자 제안과 PEP 535의 풍부한 비교 체인 제안을 조건부 표현식 및 기존 <code>and</code> 및 <code>or</code> 연산자와 공유될 공통 기본 의미론적 프레임워크 위에 추구할 수 있도록 하는 공통 기반입니다.</p>
<h2>설계 논의 (Design Discussion)</h2>
<h3>프로토콜 워크스루 (Protocol walk-through)</h3>
<p>다음 다이어그램은 회로 차단 프로토콜의 핵심 개념을 보여줍니다(인스턴스 대신 타입을 통해 특수 메서드를 조회하는 기술적인 세부 사항은 생략되었습니다).</p>
<p>[회로 차단 프로토콜이 삼항 표현식에 적용된 다이어그램 (Diagram of circuit breaking protocol applied to ternary expression)]</p>
<p>다음 표현식을 살펴보겠습니다.</p>
<pre><code class="language-python">>>> def is_not_none(obj):
... return operator.is_not_sentinel(obj, None)
>>> x if is_not_none(data.get("key")) else y
</code></pre>
<p><code>is_not_none</code>은 <code>None</code>을 Sentinel 값으로 사용하여 제안된 <code>operator.is_not_sentinel</code> <code>types.CircuitBreaker</code> 팩토리를 호출하는 헬퍼 함수입니다. <code>data</code>는 알 수 없는 키로 <code>get()</code> 메서드를 호출할 때 <code>None</code>을 반환하는 컨테이너(예: 내장 <code>dict</code> 인스턴스)입니다.</p>
<p>예제를 다시 작성하여 회로 차단기 인스턴스에 이름을 부여할 수 있습니다.</p>
<pre><code class="language-python">>>> maybe_value = is_not_none(data.get("key"))
>>> x if maybe_value else y
</code></pre>
<p>여기서 <code>maybe_value</code> 회로 차단기 인스턴스는 다이어그램의 <code>breaker</code>에 해당합니다.</p>
<p>삼항 조건은 <code>bool(maybe_value)</code>를 호출하여 평가되며, 이는 Python의 기존 동작과 동일합니다. 동작 변경은 피연산자 <code>x</code> 또는 <code>y</code> 중 하나를 직접 반환하는 대신, 회로 차단 프로토콜이 관련 피연산자를 조건에 사용된 회로 차단기에 전달한다는 것입니다.</p>
<p><code>bool(maybe_value)</code>가 <code>True</code>로 평가되면(즉, 요청된 키가 존재하고 해당 값이 <code>None</code>이 아님), 인터프리터는 <code>type(maybe_value).__then__(maybe_value, x)</code>를 호출합니다. 그렇지 않으면 <code>type(maybe_value).__else__(maybe_value, y)</code>를 호출합니다.</p>
<p>이 프로토콜은 새로운 <code>if</code> 및 <code>else</code> 이항 연산자에도 적용되지만, 이러한 경우 인터프리터는 누락된 세 번째 피연산자를 나타내는 방법이 필요합니다. 이는 회로 차단기 자체를 그 역할로 재사용하여 수행됩니다.</p>
<p>이 두 표현식을 고려해 봅시다.</p>
<pre><code class="language-python">>>> x if data.get("key") is None
>>> x if operator.is_sentinel(data.get("key"), None)
</code></pre>
<p>이 표현식의 첫 번째 형식은 <code>data.get("key") is None</code>이면 <code>x</code>를 반환하지만, 그렇지 않으면 <code>False</code>를 반환하는데, 이는 우리가 원하는 바가 거의 확실히 아닙니다.</p>
<p>대조적으로, 이 표현식의 두 번째 형식은 <code>data.get("key") is None</code>이면 여전히 <code>x</code>를 반환하지만, 그렇지 않으면 <code>data.get("key")</code>를 반환하는데, 이는 훨씬 더 유용한 동작입니다.</p>
<p>이 동작은 명시적으로 이름 지정된 회로 차단기 인스턴스를 사용하여 삼항 표현식으로 다시 작성하여 이해할 수 있습니다.</p>
<pre><code class="language-python">>>> maybe_value = operator.is_sentinel(data.get("key"), None)
>>> x if maybe_value else maybe_value
</code></pre>
<p><code>bool(maybe_value)</code>가 <code>True</code>이면(즉, <code>data.get("key") is None</code>), 인터프리터는 <code>type(maybe_value).__then__(maybe_value, x)</code>를 호출합니다. <code>types.CircuitBreaker.__then__</code>의 구현은 단락이 발생했음을 나타내는 아무것도 보지 못하므로 <code>x</code>를 반환합니다.</p>
<p>대조적으로, <code>bool(maybe_value)</code>가 <code>False</code>이면(즉, <code>data.get("key") is not None</code>), 인터프리터는 <code>type(maybe_value).__else__(maybe_value, maybe_value)</code>를 호출합니다. <code>types.CircuitBreaker.__else__</code>의 구현은 인스턴스 메서드가 자신을 인수로 받았음을 감지하고 회로 차단기 대신 래핑된 값(즉, <code>data.get("key")</code>)을 반환합니다.</p>
<p>동일한 로직이 <code>else</code>에도 적용되지만, 순서가 반대입니다.</p>
<pre><code class="language-python">>>> is_not_none(data.get("key")) else y
</code></pre>
<p>이 표현식은 <code>data.get("key")</code>가 <code>None</code>이 아니면 <code>data.get("key")</code>를 반환하고, 그렇지 않으면 <code>y</code>를 평가하여 반환합니다. 메커니즘을 이해하기 위해 표현식을 다음과 같이 다시 작성합니다.</p>
<pre><code class="language-python">>>> maybe_value = is_not_none(data.get("key"))
>>> maybe_value if maybe_value else y
</code></pre>
<p><code>bool(maybe_value)</code>가 <code>True</code>이면 표현식이 단락되고 인터프리터는 <code>type(maybe_value).__else__(maybe_value, maybe_value)</code>를 호출합니다. <code>types.CircuitBreaker.__then__</code>의 구현은 인스턴스 메서드가 자신을 인수로 받았음을 감지하고 회로 차단기 대신 래핑된 값(즉, <code>data.get("key")</code>)을 반환합니다.</p>
<p><code>bool(maybe_value)</code>가 <code>True</code>이면 인터프리터는 <code>type(maybe_value).__else__(maybe_value, y)</code>를 호출합니다. <code>types.CircuitBreaker.__else__</code>의 구현은 단락이 발생했음을 나타내는 아무것도 보지 못하므로 <code>y</code>를 반환합니다.</p>
<h3>드 모르간의 법칙 준수 (Respecting De Morgan's Laws)</h3>
<p><code>and</code> 및 <code>or</code>와 유사하게, 이항 단락 연산자는 본질적으로 동일한 표현식을 작성하는 여러 방법을 허용할 것입니다. 이러한 겉보기 중복성은 불리언 대수(Boolean algebra)로서 프로토콜을 정의하는 것의 암시적인 결과입니다. 불리언 대수는 "드 모르간의 법칙(De Morgan's Laws)"으로 알려진 한 쌍의 속성을 준수합니다. 이는 <code>and</code> 및 <code>or</code> 연산의 결과를 서로와 적절한 <code>not</code> 연산 조합으로 표현할 수 있는 능력입니다.</p>
<p>Python에서 <code>and</code> 및 <code>or</code>에 대한 이러한 불변식은 다음과 같이 설명할 수 있습니다.</p>
<pre><code class="language-python">assert bool(A and B) == bool(not (not A or not B))
assert bool(A or B) == bool(not (not A and not B))
</code></pre>
<p>즉, 연산자 중 하나를 취하고, 두 피연산자를 반전시키고, 다른 연산자로 전환한 다음, 전체 결과를 반전시키면 원래 연산자와 동일한 답(불리언 의미에서)을 얻을 수 있습니다.</p>
<p>회로 차단기의 경우, 적절한 불변식을 정의하는 것은 단락될 때 표현식 결과에서 자신을 제거하도록 설계되는 경우가 많기 때문에 복잡합니다. 이는 본질적으로 비대칭적인 동작입니다. 따라서 드 모르간의 법칙을 대칭 회로 차단기의 예상 동작에 매핑할 때 그 본질적인 비대칭성을 고려해야 합니다.</p>
<p>이러한 복잡성을 해결할 수 있는 한 가지 방법은 그렇지 않으면 단락될 피연산자를 <code>operator.true</code>로 래핑하여, <code>bool</code>이 전체 결과에 적용될 때, 회로 차단기의 입력 값에 직접 <code>bool</code>을 적용하는 대신 어떤 분기를 평가할지 결정하는 데 사용된 동일한 참 정의를 사용하도록 하는 것입니다.</p>
<p>구체적으로, 새로운 단락 연산자의 경우, <code>__bool__</code> 및 <code>__not__</code>를 모두 구현하는 모든 올바르게 작동하는 대칭 회로 차단기에 대해 다음 속성이 합리적으로 유지될 것으로 예상됩니다.</p>
<pre><code class="language-python">assert bool(B if true(A)) == bool(not (true(not A) else not B))
assert bool(true(A) else B) == bool(not (not B if true(not A)))
</code></pre>
<p>오른쪽 피연산자의 연산 순서(입력 회로 차단기를 반전시킨 후 <code>true</code> 적용)에 유의하십시오. 이는 단순히 <code>type(true(A)).__not__</code>의 동작에 대한 것이 아니라 실제로 <code>type(A).__not__</code>에 대한 주장이 이루어지도록 보장합니다.</p>
<p>최소한 <code>types.CircuitBreaker</code> 인스턴스는 이 논리를 준수하여, 기존 불리언 표현식 최적화(예: 이중 부정 제거)가 계속 적용될 수 있도록 할 것입니다.</p>
<h3>임의의 Sentinel 객체 (Arbitrary sentinel objects)</h3>
<p>PEP 505 및 531과 달리, 이 PEP의 제안은 사용자 정의 Sentinel 객체를 쉽게 처리합니다.</p>
<pre><code class="language-python">_MISSING = object() # 인수가 제공되었는지 확인하기 위한 Sentinel 사용
def my_func(arg=_MISSING):
    arg = make_default() if is_sentinel(arg, _MISSING) # "else arg" implied
</code></pre>
<h3>회로 차단 표현식의 암시적으로 정의된 회로 차단기 (Implicitly defined circuit breakers in circuit breaking expressions)</h3>
<p>이 PEP의 게시되지 않은 초안은 <code>is</code> 및 <code>is not</code> 이항 연산자를 회로 차단 표현식의 컨텍스트에서 사용될 때 자동으로 회로 차단기로 처리하는 아이디어를 탐색했습니다. 불행히도, 이 접근 방식은 필연적으로 두 가지 매우 바람직하지 않은 결과 중 하나를 초래하는 것으로 나타났습니다.</p>
<ul>
<li>이러한 표현식의 반환 타입이 <code>bool</code>에서 <code>types.CircuitBreaker</code>로 보편적으로 변경되어, 하위 호환성 문제를 일으킬 수 있습니다(특히 <code>PyObject_IsTrue</code>를 통해 제공된 값을 전달하거나 인수 파싱 함수 중 하나에서 <code>p</code>(predicate) 형식을 사용하는 대신 <code>PyBool_Check</code>로 내장 불리언 값을 찾는 확장 모듈 API와 작업할 때).</li>
<li>이러한 표현식의 반환 타입이 컨텍스트에 따라 달라져, 다른 일상적인 리팩토링(예: 비교 연산을 지역 변수로 추출하는 것)이 코드의 런타임 의미론에 상당한 영향을 미칠 수 있습니다.</li>
</ul>
<p>이러한 가능한 결과 중 어느 것도 이 PEP의 제안에 의해 보장되는 것으로 보이지 않으므로, 회로 차단기 인스턴스가 API 호출을 통해 명시적으로 생성되어야 하며 암시적으로 생성되지 않는 현재 설계로 되돌아갔습니다.</p>
<h2>구현 (Implementation)</h2>
<p>PEP 505와 마찬가지로, 이러한 변경을 수행하려는 아이디어에 대한 원칙적인 관심이 보류 중이므로 실제 구현은 연기되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-1a135130af3e1cae.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/532\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"8N6icDw00Cy0kKVlExSq2\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/532/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/532\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"532\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/532\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:Ta43c,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0532/\"\u003ePEP 532 - A circuit breaking protocol and binary operators\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Deferred | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 30-Oct-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 532 – 회로 차단(Circuit Breaking) 프로토콜 및 이항(Binary) 연산자\u003c/h1\u003e\n\u003ch2\u003ePEP 연기 (PEP Deferral)\u003c/h2\u003e\n\u003cp\u003e이 PEP에 대한 추가 검토는 최소한 Python 3.8까지 연기되었습니다.\u003c/p\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003ePEP 335, PEP 505, PEP 531 및 관련 논의에서 영감을 받은 이 PEP는 새로운 \"회로 차단(circuit breaking)\" 프로토콜(메서드 이름 \u003ccode\u003e__then__\u003c/code\u003e 및 \u003ccode\u003e__else__\u003c/code\u003e 사용)의 정의를 제안합니다. 이 프로토콜은 다음을 위한 공통적인 기본 의미론적 기반을 제공합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e조건부 표현식(conditional expressions): \u003ccode\u003eLHS if COND else RHS\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e논리적 AND 연산: \u003ccode\u003eLHS and RHS\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e논리적 OR 연산: \u003ccode\u003eLHS or RHS\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ePEP 505에서 제안된 None-aware 연산자\u003c/li\u003e\n\u003cli\u003ePEP 535에서 제안된 풍부한 비교 체인 모델\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e새로운 프로토콜을 활용하여, 조건부 표현식의 정의를 수정하여 \u003ccode\u003eif\u003c/code\u003e와 \u003ccode\u003eelse\u003c/code\u003e를 각각 우측 결합(right-associative) 및 좌측 결합(left-associative)의 범용 단락(short-circuiting) 연산자로 사용할 수 있도록 제안합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e우측 결합 단락: \u003ccode\u003eLHS if RHS\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e좌측 결합 단락: \u003ccode\u003eLHS else RHS\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e논리적 반전(\u003ccode\u003enot EXPR\u003c/code\u003e)을 위의 변경 사항과 일관되게 만들기 위해 새로운 논리적 반전 프로토콜(메서드 이름 \u003ccode\u003e__not__\u003c/code\u003e 사용) 도입을 제안합니다.\u003c/p\u003e\n\u003cp\u003e회로 차단기의 단락 동작을 강제하기 위해 표현식을 두 번 평가할 필요 없이 \u003ccode\u003eoperator\u003c/code\u003e 모듈에 새로운 \u003ccode\u003eoperator.short_circuit(obj)\u003c/code\u003e 헬퍼 함수가 추가될 예정입니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 객체의 참/거짓 값(제어 흐름을 결정하는 데 사용됨)을 단락된 회로 차단 표현식에서 반환하는 값과 분리하기 위해 새로운 표준 \u003ccode\u003etypes.CircuitBreaker\u003c/code\u003e 타입이 제안되며, 특히 일반적인 스위칭 관용구를 나타내기 위해 \u003ccode\u003eoperator\u003c/code\u003e 모듈에 다음 팩토리 함수가 추가됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebool(obj)\u003c/code\u003e에 따라 전환: \u003ccode\u003eoperator.true(obj)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enot bool(obj)\u003c/code\u003e에 따라 전환: \u003ccode\u003eoperator.false(obj)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eobj is value\u003c/code\u003e에 따라 전환: \u003ccode\u003eoperator.is_sentinel(obj, value)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eobj is not value\u003c/code\u003e에 따라 전환: \u003ccode\u003eoperator.is_not_sentinel(obj, value)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e다른 PEP와의 관계 (Relationship with other PEPs)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 다른 제안들의 광범위한 작업 내역을 기반으로 합니다. 주요 제안 중 일부는 아래에서 논의됩니다.\u003c/p\u003e\n\u003ch3\u003ePEP 531: 존재 확인 프로토콜 (Existence checking protocol)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 PEP 531의 직접적인 후속작으로, 거기서 정의된 존재 확인 프로토콜과 새로운 \u003ccode\u003e?then\u003c/code\u003e 및 \u003ccode\u003e?else\u003c/code\u003e 문법 연산자를 새로운 회로 차단 프로토콜과 조건부 표현식 및 \u003ccode\u003enot\u003c/code\u003e 연산자에 대한 조정으로 대체합니다.\u003c/p\u003e\n\u003ch3\u003ePEP 505: None-aware 연산자\u003c/h3\u003e\n\u003cp\u003e이 PEP는 PEP 505의 None-aware 연산자 제안을 보완하여, 조건부 표현식의 특정 사용에 대한 고도로 최적화된 문법 설탕(syntactic sugar)으로서 단락 동작을 설명하는 기본 프로토콜 기반 의미론적 프레임워크를 제공합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP에서 제안된 변경 사항을 고려할 때:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLHS ?? RHS\u003c/code\u003e는 대략 \u003ccode\u003eis_not_sentinel(LHS, None) else RHS\u003c/code\u003e와 같을 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEXPR?.attr\u003c/code\u003e는 대략 \u003ccode\u003eEXPR.attr if is_not_sentinel(EXPR, None)\u003c/code\u003e와 같을 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEXPR?[key]\u003c/code\u003e는 대략 \u003ccode\u003eEXPR[key] if is_not_sentinel(EXPR, None)\u003c/code\u003e와 같을 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 세 가지 경우 모두, 전용 문법 형식은 실제로 회로 차단기 인스턴스를 생성하는 것을 피하고 기본 제어 흐름을 직접 구현하도록 최적화됩니다. 후자 두 경우에서는 문법 형식이 \u003ccode\u003eEXPR\u003c/code\u003e를 두 번 평가하는 것도 피합니다. 이는 None-aware 연산자가 None에 특화되어 있지만, 다른 Sentinel 값은 이 PEP의 더 일반적인 프로토콜 기반 제안을 통해 여전히 사용될 수 있음을 의미합니다.\u003c/p\u003e\n\u003ch3\u003ePEP 335: 오버로드 가능한 불리언 연산자 (Overloadable Boolean operators)\u003c/h3\u003e\n\u003cp\u003ePEP 335는 단락 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e 연산자를 직접 오버로드할 수 있는 기능을 제안했으며, 비교 체인 의미론을 오버로드할 수 있는 기능이 그 변경의 결과 중 하나였습니다.\u003c/p\u003e\n\u003ch3\u003ePEP 535: 풍부한 비교 체인 (Rich comparison chaining)\u003c/h3\u003e\n\u003cp\u003e위에서 언급했듯이, PEP 535는 PEP 207에 도입된 풍부한 비교 지원을 확장하여 \u003ccode\u003eLEFT_BOUND \u0026#x3C; VALUE \u0026#x3C; RIGHT_BOUND\u003c/code\u003e와 같은 비교 체인 연산도 처리하기 위해 이 PEP에 정의된 회로 차단 프로토콜을 기반으로 하는 제안입니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003ch3\u003e회로 차단 프로토콜 (\u003ccode\u003eif-else\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003e조건부 표현식 (\u003ccode\u003eLHS if COND else RHS\u003c/code\u003e)은 현재 다음과 같이 표현식 수준에서 해석됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif COND:\r\n    _expr_result = LHS\r\nelse:\r\n    _expr_result = RHS\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 PEP는 확인된 조건이 새로운 \"회로 차단\" 프로토콜을 구현할 수 있도록 확장을 변경하여 표현식의 양쪽 분기 중 하나 또는 둘 다의 결과를 보고 잠재적으로 변경할 수 있도록 제안합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_cb = COND\r\n_type_cb = type(_cb)\r\nif _cb:\r\n    _expr_result = LHS\r\n    if hasattr(_type_cb, \"__then__\"):\r\n        _expr_result = _type_cb.__then__(_cb, _expr_result)\r\nelse:\r\n    _expr_result = RHS\r\n    if hasattr(_type_cb, \"__else__\"):\r\n        _expr_result = _type_cb.__else__(_cb, _expr_result)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e표시된 대로, 인터프리터 구현은 실제로 실행되는 조건부 표현식의 분기에 필요한 프로토콜 메서드만 액세스해야 합니다. 다른 프로토콜 메서드와 마찬가지로, 특수 메서드는 인스턴스에서 직접이 아니라 회로 차단기의 타입을 통해 조회됩니다.\u003c/p\u003e\n\u003ch3\u003e회로 차단 연산자 (\u003ccode\u003ebinary if\u003c/code\u003e 및 \u003ccode\u003ebinary else\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003e프로토콜의 제안된 이름은 조건부 표현식의 의미론 변경에서 오는 것이 아닙니다. 오히려, 기존의 \u003ccode\u003eTrue\u003c/code\u003e 및 \u003ccode\u003eFalse\u003c/code\u003e 기반 단락 연산자(\u003ccode\u003eor\u003c/code\u003e 및 \u003ccode\u003eand\u003c/code\u003e 각각)와 PEP 505에서 제안된 \u003ccode\u003eNone\u003c/code\u003e 기반 단락 연산자(\u003ccode\u003e??\u003c/code\u003e)를 보완하기 위해 \u003ccode\u003eif\u003c/code\u003e와 \u003ccode\u003eelse\u003c/code\u003e를 범용 프로토콜 기반 단락 연산자로 추가하는 제안에서 비롯됩니다. 이 두 연산자는 함께 회로 차단 연산자(circuit breaking operators)로 알려질 것입니다.\u003c/p\u003e\n\u003cp\u003e이러한 사용을 지원하기 위해, 언어 문법에서 조건부 표현식의 정의는 \u003ccode\u003eif\u003c/code\u003e 절과 \u003ccode\u003eelse\u003c/code\u003e 절을 모두 선택 사항으로 만들도록 업데이트됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etest: else_test ['if' or_test ['else' test]] | lambdef\r\nelse_test: or_test ['else' test]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e문법의 \u003ccode\u003etest_nocond\u003c/code\u003e 노드(조건부 표현식을 의도적으로 제외하는)의 정의는 변경되지 않으므로, 회로 차단 연산자는 List Comprehension 및 제너레이터(generator) 표현식의 \u003ccode\u003eif\u003c/code\u003e 절에서 조건부 표현식 자체와 마찬가지로 괄호가 필요합니다.\u003c/p\u003e\n\u003cp\u003e이 문법 정의는 \u003ccode\u003eexpr1 if cond else expr2 else expr3\u003c/code\u003e와 같이 모호한 경우의 우선순위/결합성을 \u003ccode\u003e(expr1 if cond else expr2) else expr3\u003c/code\u003e로 해결합니다. 그러나 PEP 8에 \"이런 식으로 사용하지 말라\"는 지침이 추가될 것입니다. 왜냐하면 이러한 구성은 인터프리터가 어떻게 실행하든 독자에게 본질적으로 혼란스러울 것이기 때문입니다.\u003c/p\u003e\n\u003cp\u003e우측 결합 회로 차단 연산자 (\u003ccode\u003eLHS if RHS\u003c/code\u003e)는 다음과 같이 확장됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_cb = RHS\r\n_expr_result = LHS if _cb else _cb\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e좌측 결합 회로 차단 연산자 (\u003ccode\u003eLHS else RHS\u003c/code\u003e)는 다음과 같이 확장됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_cb = LHS\r\n_expr_result = _cb if _cb else RHS\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 경우 모두 핵심은 회로 차단 표현식이 단락될 때, 조건이 회로 차단기가 아니라면 조건 표현식이 표현식의 결과로 사용된다는 것입니다. 후자의 경우, 적절한 회로 차단 프로토콜 메서드는 평소와 같이 호출되지만, 회로 차단기 자체가 메서드 인수로 제공됩니다. 이를 통해 회로 차단기는 후보 표현식 결과로 전달된 인수가 \u003ccode\u003eself\u003c/code\u003e인지 확인하여 단락을 안정적으로 감지할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e논리적 반전 오버로드 (\u003ccode\u003enot\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003e모든 회로 차단기 정의에는 여전히 회로 차단기이지만 표현식 평가를 단락할 시점에 대한 답변을 반전시키는 논리적 역(logical inverse)이 있습니다. 예를 들어, 이 PEP에서 제안된 \u003ccode\u003eoperator.true\u003c/code\u003e 및 \u003ccode\u003eoperator.false\u003c/code\u003e 회로 차단기는 서로의 논리적 역입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__not__(self)\u003c/code\u003e라는 새로운 프로토콜 메서드가 도입되어 회로 차단기 및 다른 타입이 \u003ccode\u003enot\u003c/code\u003e 표현식을 재정의하여 강제된 불리언 결과 대신 논리적 역을 반환할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e기존 언어 최적화(예: 불리언 컨텍스트에서 이중 부정을 중복으로 직접 제거하는 것)의 의미론을 유지하기 위해, \u003ccode\u003e__not__\u003c/code\u003e 구현은 다음 불변식을 준수해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eassert not bool(obj) == bool(not obj)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 대칭 회로 차단기(모든 \u003ccode\u003e__bool__\u003c/code\u003e, \u003ccode\u003e__not__\u003c/code\u003e, \u003ccode\u003e__then__\u003c/code\u003e, \u003ccode\u003e__else__\u003c/code\u003e를 구현하는)는 표현식에 관련된 모든 회로 차단기가 \"참\"에 대한 일관된 정의를 사용할 때만 불리언 논리의 완전한 의미론을 준수할 것으로 예상됩니다.\u003c/p\u003e\n\u003ch3\u003e단락 동작 강제 (Forcing short-circuiting behaviour)\u003c/h3\u003e\n\u003cp\u003e회로 차단기의 단락 동작은 조건부 표현식에서 세 피연산자 모두로 사용하거나 (\u003ccode\u003eobj if obj else obj\u003c/code\u003e), 회로 차단 표현식에서 두 피연산자 모두로 사용하여 (\u003ccode\u003eobj if obj\u003c/code\u003e 또는 \u003ccode\u003eobj else obj\u003c/code\u003e) 강제할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 패턴 중 하나를 사용할 필요 없이, 이 PEP는 \u003ccode\u003eoperator\u003c/code\u003e 모듈에 회로 차단기를 명시적으로 단락시키고 다른 객체는 수정하지 않고 통과시키는 전용 함수를 추가할 것을 제안합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef short_circuit(obj):\r\n    \"\"\"\r\n    Replace circuit breakers with their short-circuited result\r\n    Passes other input values through unmodified.\r\n    \"\"\"\r\n    return obj if obj else obj\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e회로 차단 Identity 비교 (\u003ccode\u003eis\u003c/code\u003e 및 \u003ccode\u003eis not\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003e표준 회로 차단기가 없는 경우, 제안된 \u003ccode\u003eif\u003c/code\u003e 및 \u003ccode\u003eelse\u003c/code\u003e 연산자는 기존 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e 논리 연산자의 특이한 철자가 될 것입니다. 그러나 이 PEP는 적절한 단락 로직을 구현하는 새로운 범용 \u003ccode\u003etypes.CircuitBreaker\u003c/code\u003e 타입과 \u003ccode\u003eis\u003c/code\u003e 및 \u003ccode\u003eis not\u003c/code\u003e 연산자에 해당하는 팩토리 함수를 \u003ccode\u003eoperator\u003c/code\u003e 모듈에 제공할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e이들은 조건부 검사가 실패할 때 \u003ccode\u003eFalse\u003c/code\u003e 대신 \u003ccode\u003eVALUE\u003c/code\u003e를 생성하는 방식으로 정의됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eEXPR if is_sentinel(VALUE, SENTINEL)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEXPR if is_not_sentinel(VALUE, SENTINEL)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e마찬가지로, 조건부 검사가 성공할 때 \u003ccode\u003eTrue\u003c/code\u003e 대신 \u003ccode\u003eVALUE\u003c/code\u003e를 생성합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eis_sentinel(VALUE, SENTINEL) else EXPR\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eis_not_sentinel(VALUE, SENTINEL) else EXPR\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e사실상, 이러한 비교는 다음과 같은 형태의 표현식에서 선행 \u003ccode\u003eVALUE if\u003c/code\u003e 및 후행 \u003ccode\u003eelse VALUE\u003c/code\u003e 절을 생략할 수 있도록 정의됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# \"if\" 표현식을 처리하기 위해, \" else VALUE\"는 생략될 때 암시됩니다.\r\nEXPR if is_sentinel(VALUE, SENTINEL) else VALUE\r\nEXPR if is_not_sentinel(VALUE, SENTINEL) else VALUE\r\n# \"else\" 표현식을 처리하기 위해, \"VALUE if \"는 생략될 때 암시됩니다.\r\nVALUE if is_sentinel(VALUE, SENTINEL) else EXPR\r\nVALUE if is_not_sentinel(VALUE, SENTINEL) else EXPR\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제안된 \u003ccode\u003etypes.CircuitBreaker\u003c/code\u003e 타입은 이 동작을 다음과 같이 프로그래밍 방식으로 표현합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass CircuitBreaker:\r\n    \"\"\"Simple circuit breaker type\"\"\"\r\n    def __init__(self, value, bool_value):\r\n        self.value = value\r\n        self.bool_value = bool(bool_value)\r\n    def __bool__(self):\r\n        return self.bool_value\r\n    def __not__(self):\r\n        return CircuitBreaker(self.value, not self.bool_value)\r\n    def __then__(self, result):\r\n        if result is self:\r\n            return self.value\r\n        return result\r\n    def __else__(self, result):\r\n        if result is self:\r\n            return self.value\r\n        return result\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 회로 차단기의 주요 특징은 일시적(ephemeral)이라는 것입니다. 단락이 발생했다고 통보받으면(후보 표현식 결과로 자신에 대한 참조를 받음으로써), 회로 차단기 래퍼(wrapper) 대신 원래 값을 반환합니다.\u003c/p\u003e\n\u003cp\u003e단락 감지는 다음과 같이 정의됩니다. 동일한 회로 차단기 인스턴스를 회로 차단 연산자의 양쪽에 명시적으로 전달하거나 조건부 표현식에서 세 피연산자 모두로 사용하면 래퍼가 항상 제거됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eoperator\u003c/code\u003e 모듈의 팩토리 함수는 \u003ccode\u003eis\u003c/code\u003e 및 \u003ccode\u003eis not\u003c/code\u003e 연산자를 사용하는 ID 검사에 해당하는 회로 차단기를 생성하기 쉽게 만들 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef is_sentinel(value, sentinel):\r\n    \"\"\"Returns a circuit breaker switching on 'value is sentinel'\"\"\"\r\n    return types.CircuitBreaker(value, value is sentinel)\r\n\r\ndef is_not_sentinel(value, sentinel):\r\n    \"\"\"Returns a circuit breaker switching on 'value is not sentinel'\"\"\"\r\n    return types.CircuitBreaker(value, value is not sentinel)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e참 확인 비교 (Truth checking comparisons)\u003c/h3\u003e\n\u003cp\u003e단락 특성으로 인해 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e 연산자의 기본 런타임 로직은 이전에 \u003ccode\u003eoperator\u003c/code\u003e 또는 \u003ccode\u003etypes\u003c/code\u003e 모듈을 통해 접근할 수 없었습니다. 회로 차단 연산자와 회로 차단기의 도입은 해당 로직을 \u003ccode\u003eoperator\u003c/code\u003e 모듈에 다음과 같이 캡처할 수 있도록 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef true(value):\r\n    \"\"\"Returns a circuit breaker switching on 'bool(value)'\"\"\"\r\n    return types.CircuitBreaker(value, bool(value))\r\n\r\ndef false(value):\r\n    \"\"\"Returns a circuit breaker switching on 'not bool(value)'\"\"\"\r\n    return types.CircuitBreaker(value, not bool(value))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eLHS or RHS\u003c/code\u003e는 사실상 \u003ccode\u003etrue(LHS) else RHS\u003c/code\u003e가 될 것이고, \u003ccode\u003eLHS and RHS\u003c/code\u003e는 사실상 \u003ccode\u003efalse(LHS) else RHS\u003c/code\u003e가 될 것입니다.\u003c/p\u003e\n\u003cp\u003e이러한 연산자 정의에는 실제 변경이 없을 것이며, 새로운 회로 차단 프로토콜과 연산자는 개발 시점에 검사의 의미를 하드코딩하는 대신 제어 흐름 로직을 프로그래밍할 수 있는 방법을 제공할 것입니다. 불리언 논리의 규칙을 준수하면, 이러한 표현식은 우측 결합 회로 차단 연산자를 대신 사용하여 역전된 형태로도 확장될 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLHS or RHS\u003c/code\u003e는 사실상 \u003ccode\u003eRHS if false(LHS)\u003c/code\u003e가 될 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLHS and RHS\u003c/code\u003e는 사실상 \u003ccode\u003eRHS if true(LHS)\u003c/code\u003e가 될 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNone-aware 연산자\u003c/h3\u003e\n\u003cp\u003e이 PEP와 PEP 505의 None-aware 연산자가 모두 수락된다면, 제안된 \u003ccode\u003eis_sentinel\u003c/code\u003e 및 \u003ccode\u003eis_not_sentinel\u003c/code\u003e 회로 차단기 팩토리는 \"None 확인(None checking)\" 개념을 캡슐화하는 데 사용될 것입니다. 즉, 값이 \u003ccode\u003eNone\u003c/code\u003e인지 확인하고 대체 값으로 폴백하거나(None-coalescing) 전체 표현식의 결과로 통과시키는(None-severing 또는 None-propagating) 것입니다.\u003c/p\u003e\n\u003cp\u003e이러한 회로 차단기를 고려할 때, \u003ccode\u003eLHS ?? RHS\u003c/code\u003e는 대략 다음 두 가지와 동일할 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eis_not_sentinel(LHS, None) else RHS\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRHS if is_sentinel(LHS, None)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e속성 조회 및 서브스크립트(subscripting) 연산에 제어 흐름을 주입하는 방식 때문에 None-aware 속성 접근 및 None-aware 서브스크립트는 회로 차단 연산자로 직접 표현할 수 없지만, 기본 회로 차단 프로토콜을 통해 여전히 정의될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 측면에서 \u003ccode\u003eEXPR?.ATTR[KEY].SUBATTR()\u003c/code\u003e는 의미론적으로 다음과 동일할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_lookup_base = EXPR\r\n_circuit_breaker = is_not_sentinel(_lookup_base, None)\r\n_expr_result = _lookup_base.ATTR[KEY].SUBATTR() if _circuit_breaker\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마찬가지로, \u003ccode\u003eEXPR?[KEY].ATTR.SUBATTR()\u003c/code\u003e는 의미론적으로 다음과 동일할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_lookup_base = EXPR\r\n_circuit_breaker = is_not_sentinel(_lookup_base, None)\r\n_expr_result = _lookup_base[KEY].ATTR.SUBATTR() if _circuit_breaker\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNone-aware 연산자의 실제 구현은 회로 차단기 인스턴스를 실제로 생성하는 것을 건너뛰도록 최적화될 것으로 예상되지만, 위 확장은 런타임에 연산자의 관찰 가능한 동작에 대한 정확한 설명을 제공할 것입니다.\u003c/p\u003e\n\u003ch3\u003e풍부한 체인 비교 (Rich chained comparisons)\u003c/h3\u003e\n\u003cp\u003e이 가능한 사용 사례에 대한 자세한 논의는 PEP 535를 참조하십시오.\u003c/p\u003e\n\u003ch3\u003e기타 조건부 구성 (Other conditional constructs)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eif\u003c/code\u003e 문, \u003ccode\u003ewhile\u003c/code\u003e 문, Comprehension 또는 제너레이터(generator) 표현식에는 변경 사항이 제안되지 않습니다. 이러한 구성에 포함된 불리언 절은 전적으로 제어 흐름 목적으로 사용되며 그 자체로 결과를 반환하지 않기 때문입니다.\u003c/p\u003e\n\u003cp\u003e그러나 이러한 제안이 이 PEP의 범위를 벗어나지만, 여기에 정의된 회로 차단 프로토콜은 다음과 같은 구성을 지원하기에 충분하다는 점은 주목할 가치가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef is_not_none(obj):\r\n    return is_sentinel(obj, None)\r\n\r\nwhile is_not_none(dynamic_query()) as result:\r\n    ... # Code using result\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif is_not_none(re.search(pattern, text)) as match:\r\n    ... # Code using match\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 \u003ccode\u003eCONDITION\u003c/code\u003e을 주어진 이름에 직접 할당하는 대신 \u003ccode\u003eoperator.short_circuit(CONDITION)\u003c/code\u003e의 결과를 \u003ccode\u003eas\u003c/code\u003e 절에 주어진 이름에 할당함으로써 수행될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e스타일 가이드 권장 사항 (Style guide recommendations)\u003c/h3\u003e\n\u003cp\u003e이 PEP에서 도입된 새로운 기능과 관련하여 PEP 8에 다음 추가 사항이 제안됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e조건부 표현식(\u003ccode\u003eif-else\u003c/code\u003e)과 독립형 회로 차단 연산자(\u003ccode\u003eif\u003c/code\u003e 및 \u003ccode\u003eelse\u003c/code\u003e)를 단일 표현식에서 결합하는 것을 피하십시오. 상황에 따라 둘 중 하나를 사용하고, 둘 다 사용하지 마십시오.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eif\u003c/code\u003e 문의 \u003ccode\u003eif\u003c/code\u003e 조건과 Comprehension 및 제너레이터 표현식의 필터(filter) 절의 일부로 조건부 표현식(\u003ccode\u003eif-else\u003c/code\u003e)과 독립형 회로 차단 연산자(\u003ccode\u003eif\u003c/code\u003e 및 \u003ccode\u003eelse\u003c/code\u003e)를 사용하는 것을 피하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003ch3\u003e새로운 연산자 추가 (Adding new operators)\u003c/h3\u003e\n\u003cp\u003ePEP 335와 유사하게, 이 PEP의 초기 초안은 새로운 연산자를 제안하기보다 기존 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e 연산자의 해석을 덜 엄격하게 만드는 데 중점을 두었습니다. 그러나 이는 몇 가지 주요 이유로 문제가 있는 것으로 판명되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e 연산자는 오랫동안 확립된 안정적인 의미를 가지므로, 독자들은 그 의미가 이제 왼쪽 피연산자의 타입에 따라 달라진다면 필연적으로 놀랄 것입니다. 새로운 사용자조차도 이 연산자들에 대한 현재의 잘 알려진 의미론을 가정하는 25년 이상의 교육 자료 때문에 이 변경에 혼란스러워할 것입니다.\u003c/li\u003e\n\u003cli\u003eCPython을 포함한 Python 인터프리터 구현은 이러한 연산의 의미론이 변경된다면 모두 검토하고 잠재적으로 폐기해야 할 런타임 및 컴파일 시간 최적화를 정의할 때 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e의 기존 의미론을 활용했습니다.\u003c/li\u003e\n\u003cli\u003e프로토콜을 정의하는 데 필요한 새로운 메서드에 어떤 이름이 적절할지 명확하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e대신 기존 \u003ccode\u003eif-else\u003c/code\u003e 삼항 연산자의 단락 이항 변형을 제안하는 것은 이러한 모든 문제를 해결합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e의 런타임 의미론은 완전히 변경되지 않은 채 유지됩니다.\u003c/li\u003e\n\u003cli\u003e단항 \u003ccode\u003enot\u003c/code\u003e 연산자의 의미론은 변경되지만, \u003ccode\u003e__not__\u003c/code\u003e 구현에 필요한 불변식은 불리언 컨텍스트에서 기존 표현식 최적화가 유효하게 유지됨을 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__else__\u003c/code\u003e는 후행 \u003ccode\u003eelse\u003c/code\u003e 절이 없기 때문에 \u003ccode\u003eif\u003c/code\u003e 표현식의 단락 결과입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__then__\u003c/code\u003e은 선행 \u003ccode\u003eif\u003c/code\u003e 절이 없기 때문에 \u003ccode\u003eelse\u003c/code\u003e 표현식의 단락 결과입니다(메서드 이름이 \u003ccode\u003e__if__\u003c/code\u003e였다면 이 연결이 더 명확했겠지만, 회로 차단 프로토콜을 호출하지 않는 \u003ccode\u003eif\u003c/code\u003e 키워드의 다른 용도 때문에 모호할 수 있습니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e연산자 및 프로토콜 이름 지정 (Naming the operator and protocol)\u003c/h3\u003e\n\u003cp\u003e\"circuit breaking operator\", \"circuit breaking protocol\", \"circuit breaker\"라는 이름은 모두 \"short circuiting operator\"라는 구절에서 영감을 받았습니다. 이는 오른쪽 피연산자를 조건부로만 평가하는 연산자에 대한 일반적인 언어 설계 용어입니다.\u003c/p\u003e\n\u003cp\u003e전기 아날로지(analogy)는 Python의 회로 차단기가 전기 시스템의 회로 차단기가 장비를 손상시키거나 사람에게 해를 끼치기 전에 단락을 감지하고 처리하는 방식과 유사하게 예외가 발생하기 전에 표현식의 단락을 감지하고 처리한다는 것입니다.\u003c/p\u003e\n\u003cp\u003ePython 수준의 아날로지는 \u003ccode\u003ebreak\u003c/code\u003e 문이 루프가 자연스러운 결론에 도달하기 전에 루프를 종료할 수 있게 하는 것처럼, 회로 차단 표현식은 표현식 평가를 종료하고 즉시 결과를 생성할 수 있게 한다는 것입니다.\u003c/p\u003e\n\u003ch3\u003e기존 키워드 사용 (Using existing keywords)\u003c/h3\u003e\n\u003cp\u003e기존 키워드를 사용하면 \u003ccode\u003e__future__\u003c/code\u003e 문 없이 새 연산자를 도입할 수 있는 이점이 있습니다. \u003ccode\u003eif\u003c/code\u003e와 \u003ccode\u003eelse\u003c/code\u003e는 제안된 새 프로토콜에 의미론적으로 적합하며, 도입된 유일한 추가 문법적 모호성은 새 연산자가 명시적 \u003ccode\u003eif-else\u003c/code\u003e 조건부 표현식 문법과 결합될 때 발생합니다.\u003c/p\u003e\n\u003cp\u003ePEP는 인터프리터 구현자가 이를 어떻게 처리해야 하는지 명시적으로 지정하여 이 모호성을 처리하지만, PEP 8에서 인터프리터는 이를 이해하더라도 인간 독자는 아마 그렇지 않을 것이므로, 단일 표현식에서 조건부 표현식과 회로 차단 연산자를 모두 사용하는 것은 좋은 생각이 아닐 것이라고 지적할 것을 제안합니다.\u003c/p\u003e\n\u003ch3\u003e프로토콜 메서드 이름 지정 (Naming the protocol methods)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e__else__\u003c/code\u003e 메서드의 이름 지정은 간단했습니다. 연산자 키워드 이름을 재사용하면 명확하고 모호하지 않은 특수 메서드 이름이 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__then__\u003c/code\u003e 메서드의 이름 지정은 덜 간단했습니다. 키워드 기반 이름 \u003ccode\u003e__if__\u003c/code\u003e를 사용하는 또 다른 가능한 옵션이 있었기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__if__\u003c/code\u003e의 문제는 \u003ccode\u003eif\u003c/code\u003e 키워드가 오른쪽에 표현식과 함께 나타나지만, \u003ccode\u003e__if__\u003c/code\u003e 특수 메서드가 호출되지 않는 많은 경우가 계속 존재한다는 것입니다. 대신, \u003ccode\u003ebool()\u003c/code\u003e 내장 함수와 그 기본 특수 메서드(\u003ccode\u003e__bool__\u003c/code\u003e, \u003ccode\u003e__len__\u003c/code\u003e)가 호출되고, \u003ccode\u003e__if__\u003c/code\u003e는 효과가 없을 것입니다.\u003c/p\u003e\n\u003cp\u003e불리언 프로토콜이 조건부 표현식과 새로운 회로 차단 프로토콜에서 이미 역할을 하고 있으므로, 컴퓨터 과학 및 프로그래밍 언어 설계에서 \u003ccode\u003eif\u003c/code\u003e 문의 첫 번째 절을 설명하는 데 일반적으로 사용되는 용어에 기반하여 덜 모호한 이름 \u003ccode\u003e__then__\u003c/code\u003e이 선택되었습니다.\u003c/p\u003e\n\u003ch3\u003e이항 \u003ccode\u003eif\u003c/code\u003e를 우측 결합으로 만들기 (Making binary if right-associative)\u003c/h3\u003e\n\u003cp\u003e조건부 표현식에 의해 설정된 선례는 이항 단락 \u003ccode\u003eif\u003c/code\u003e 표현식이 일관성 문제로 인해 조건이 오른쪽에 있어야 한다는 것을 의미합니다. 오른쪽 피연산자가 항상 먼저 평가되고, 불리언 컨텍스트에서 오른쪽 피연산자가 참이면 왼쪽 피연산자가 전혀 평가되지 않는다는 점을 고려할 때, 자연스러운 결과는 우측 결합 연산자입니다.\u003c/p\u003e\n\u003ch3\u003e표준 회로 차단기 이름 지정 (Naming the standard circuit breakers)\u003c/h3\u003e\n\u003cp\u003e좌측 결합 회로 차단 연산자와만 사용될 때, 단항 검사를 위한 명시적 회로 차단기 이름은 \u003ccode\u003eif_\u003c/code\u003e 전치사로 시작하면 잘 읽힙니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eoperator.if_true(LHS) else RHS\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoperator.if_false(LHS) else RHS\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그러나 \u003ccode\u003eif_\u003c/code\u003e를 포함하는 것은 논리적 반전을 수행할 때 잘 읽히지 않습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enot operator.if_true(LHS) else RHS\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enot operator.if_false(LHS) else RHS\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또는 우측 결합 회로 차단 연산자를 사용할 때:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLHS if operator.if_true(RHS)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLHS if operator.if_false(RHS)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또는 이항 비교 연산자 이름을 지정할 때:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eoperator.if_is_sentinel(VALUE, SENTINEL) else EXPR\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoperator.if_is_not_sentinel(VALUE, SENTINEL) else EXPR\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e대조적으로, 회로 차단기 이름에서 전치사를 생략하면 단항 검사에 대한 모든 형태에서 합리적으로 잘 읽히는 결과가 나옵니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eoperator.true(LHS) else RHS\u003c/code\u003e (선행 \u003ccode\u003e\"LHS if \"\u003c/code\u003e 암시됨)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoperator.false(LHS) else RHS\u003c/code\u003e (선행 \u003ccode\u003e\"LHS if \"\u003c/code\u003e 암시됨)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enot operator.true(LHS) else RHS\u003c/code\u003e (선행 \u003ccode\u003e\"LHS if \"\u003c/code\u003e 암시됨)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enot operator.false(LHS) else RHS\u003c/code\u003e (선행 \u003ccode\u003e\"LHS if \"\u003c/code\u003e 암시됨)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLHS if operator.true(RHS)\u003c/code\u003e (후행 \u003ccode\u003e\" else RHS\"\u003c/code\u003e 암시됨)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLHS if operator.false(RHS)\u003c/code\u003e (후행 \u003ccode\u003e\" else RHS\"\u003c/code\u003e 암시됨)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLHS if not operator.true(RHS)\u003c/code\u003e (후행 \u003ccode\u003e\" else RHS\"\u003c/code\u003e 암시됨)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLHS if not operator.false(RHS)\u003c/code\u003e (후행 \u003ccode\u003e\" else RHS\"\u003c/code\u003e 암시됨)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그리고 이항 검사에서도 잘 읽힙니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eoperator.is_sentinel(VALUE, SENTINEL) else EXPR\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoperator.is_not_sentinel(VALUE, SENTINEL) else EXPR\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEXPR if operator.is_sentinel(VALUE, SENTINEL)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEXPR if operator.is_not_sentinel(VALUE, SENTINEL)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e위험 및 우려 사항 (Risks and concerns)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 PEP 335, 505, 531 논의 시 제기된 위험과 우려 사항을 특히 해결하도록 설계되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기존 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e 연산자에 영향을 미치기보다는 새로운 연산자를 정의하고 체인 비교 정의를 조정합니다(별도의 PEP에서).\u003c/li\u003e\n\u003cli\u003e제안된 새로운 연산자는 범용 단락 이항 연산자로, \u003ccode\u003eNone\u003c/code\u003e에 대한 ID 확인에만 유연성 없이 초점을 맞추기보다는 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e의 기존 의미론을 표현하는 데에도 사용될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enot\u003c/code\u003e 단항 연산자와 \u003ccode\u003eis\u003c/code\u003e 및 \u003ccode\u003eis not\u003c/code\u003e 이항 비교 연산자에 대한 변경 사항은 기존 의미론에 기반한 제어 흐름 최적화가 유효하게 유지되도록 정의됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 접근 방식의 한 가지 결과는 이 PEP 자체만으로는 최종 사용자에게 직접적인 이점을 많이 제공하지 않는다는 것입니다. 일부 일반적인 \u003ccode\u003eNone if\u003c/code\u003e 접두사와 \u003ccode\u003eelse None\u003c/code\u003e 접미사를 특정 형태의 조건부 표현식에서 생략할 수 있게 해주는 것 외에는 말입니다.\u003c/p\u003e\n\u003cp\u003e대신, 주로 제공하는 것은 PEP 505의 None-aware 연산자 제안과 PEP 535의 풍부한 비교 체인 제안을 조건부 표현식 및 기존 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e 연산자와 공유될 공통 기본 의미론적 프레임워크 위에 추구할 수 있도록 하는 공통 기반입니다.\u003c/p\u003e\n\u003ch2\u003e설계 논의 (Design Discussion)\u003c/h2\u003e\n\u003ch3\u003e프로토콜 워크스루 (Protocol walk-through)\u003c/h3\u003e\n\u003cp\u003e다음 다이어그램은 회로 차단 프로토콜의 핵심 개념을 보여줍니다(인스턴스 대신 타입을 통해 특수 메서드를 조회하는 기술적인 세부 사항은 생략되었습니다).\u003c/p\u003e\n\u003cp\u003e[회로 차단 프로토콜이 삼항 표현식에 적용된 다이어그램 (Diagram of circuit breaking protocol applied to ternary expression)]\u003c/p\u003e\n\u003cp\u003e다음 표현식을 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e def is_not_none(obj):\r\n... return operator.is_not_sentinel(obj, None)\r\n\u003e\u003e\u003e x if is_not_none(data.get(\"key\")) else y\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eis_not_none\u003c/code\u003e은 \u003ccode\u003eNone\u003c/code\u003e을 Sentinel 값으로 사용하여 제안된 \u003ccode\u003eoperator.is_not_sentinel\u003c/code\u003e \u003ccode\u003etypes.CircuitBreaker\u003c/code\u003e 팩토리를 호출하는 헬퍼 함수입니다. \u003ccode\u003edata\u003c/code\u003e는 알 수 없는 키로 \u003ccode\u003eget()\u003c/code\u003e 메서드를 호출할 때 \u003ccode\u003eNone\u003c/code\u003e을 반환하는 컨테이너(예: 내장 \u003ccode\u003edict\u003c/code\u003e 인스턴스)입니다.\u003c/p\u003e\n\u003cp\u003e예제를 다시 작성하여 회로 차단기 인스턴스에 이름을 부여할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e maybe_value = is_not_none(data.get(\"key\"))\r\n\u003e\u003e\u003e x if maybe_value else y\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003emaybe_value\u003c/code\u003e 회로 차단기 인스턴스는 다이어그램의 \u003ccode\u003ebreaker\u003c/code\u003e에 해당합니다.\u003c/p\u003e\n\u003cp\u003e삼항 조건은 \u003ccode\u003ebool(maybe_value)\u003c/code\u003e를 호출하여 평가되며, 이는 Python의 기존 동작과 동일합니다. 동작 변경은 피연산자 \u003ccode\u003ex\u003c/code\u003e 또는 \u003ccode\u003ey\u003c/code\u003e 중 하나를 직접 반환하는 대신, 회로 차단 프로토콜이 관련 피연산자를 조건에 사용된 회로 차단기에 전달한다는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebool(maybe_value)\u003c/code\u003e가 \u003ccode\u003eTrue\u003c/code\u003e로 평가되면(즉, 요청된 키가 존재하고 해당 값이 \u003ccode\u003eNone\u003c/code\u003e이 아님), 인터프리터는 \u003ccode\u003etype(maybe_value).__then__(maybe_value, x)\u003c/code\u003e를 호출합니다. 그렇지 않으면 \u003ccode\u003etype(maybe_value).__else__(maybe_value, y)\u003c/code\u003e를 호출합니다.\u003c/p\u003e\n\u003cp\u003e이 프로토콜은 새로운 \u003ccode\u003eif\u003c/code\u003e 및 \u003ccode\u003eelse\u003c/code\u003e 이항 연산자에도 적용되지만, 이러한 경우 인터프리터는 누락된 세 번째 피연산자를 나타내는 방법이 필요합니다. 이는 회로 차단기 자체를 그 역할로 재사용하여 수행됩니다.\u003c/p\u003e\n\u003cp\u003e이 두 표현식을 고려해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e x if data.get(\"key\") is None\r\n\u003e\u003e\u003e x if operator.is_sentinel(data.get(\"key\"), None)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 표현식의 첫 번째 형식은 \u003ccode\u003edata.get(\"key\") is None\u003c/code\u003e이면 \u003ccode\u003ex\u003c/code\u003e를 반환하지만, 그렇지 않으면 \u003ccode\u003eFalse\u003c/code\u003e를 반환하는데, 이는 우리가 원하는 바가 거의 확실히 아닙니다.\u003c/p\u003e\n\u003cp\u003e대조적으로, 이 표현식의 두 번째 형식은 \u003ccode\u003edata.get(\"key\") is None\u003c/code\u003e이면 여전히 \u003ccode\u003ex\u003c/code\u003e를 반환하지만, 그렇지 않으면 \u003ccode\u003edata.get(\"key\")\u003c/code\u003e를 반환하는데, 이는 훨씬 더 유용한 동작입니다.\u003c/p\u003e\n\u003cp\u003e이 동작은 명시적으로 이름 지정된 회로 차단기 인스턴스를 사용하여 삼항 표현식으로 다시 작성하여 이해할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e maybe_value = operator.is_sentinel(data.get(\"key\"), None)\r\n\u003e\u003e\u003e x if maybe_value else maybe_value\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebool(maybe_value)\u003c/code\u003e가 \u003ccode\u003eTrue\u003c/code\u003e이면(즉, \u003ccode\u003edata.get(\"key\") is None\u003c/code\u003e), 인터프리터는 \u003ccode\u003etype(maybe_value).__then__(maybe_value, x)\u003c/code\u003e를 호출합니다. \u003ccode\u003etypes.CircuitBreaker.__then__\u003c/code\u003e의 구현은 단락이 발생했음을 나타내는 아무것도 보지 못하므로 \u003ccode\u003ex\u003c/code\u003e를 반환합니다.\u003c/p\u003e\n\u003cp\u003e대조적으로, \u003ccode\u003ebool(maybe_value)\u003c/code\u003e가 \u003ccode\u003eFalse\u003c/code\u003e이면(즉, \u003ccode\u003edata.get(\"key\") is not None\u003c/code\u003e), 인터프리터는 \u003ccode\u003etype(maybe_value).__else__(maybe_value, maybe_value)\u003c/code\u003e를 호출합니다. \u003ccode\u003etypes.CircuitBreaker.__else__\u003c/code\u003e의 구현은 인스턴스 메서드가 자신을 인수로 받았음을 감지하고 회로 차단기 대신 래핑된 값(즉, \u003ccode\u003edata.get(\"key\")\u003c/code\u003e)을 반환합니다.\u003c/p\u003e\n\u003cp\u003e동일한 로직이 \u003ccode\u003eelse\u003c/code\u003e에도 적용되지만, 순서가 반대입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e is_not_none(data.get(\"key\")) else y\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 표현식은 \u003ccode\u003edata.get(\"key\")\u003c/code\u003e가 \u003ccode\u003eNone\u003c/code\u003e이 아니면 \u003ccode\u003edata.get(\"key\")\u003c/code\u003e를 반환하고, 그렇지 않으면 \u003ccode\u003ey\u003c/code\u003e를 평가하여 반환합니다. 메커니즘을 이해하기 위해 표현식을 다음과 같이 다시 작성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e maybe_value = is_not_none(data.get(\"key\"))\r\n\u003e\u003e\u003e maybe_value if maybe_value else y\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebool(maybe_value)\u003c/code\u003e가 \u003ccode\u003eTrue\u003c/code\u003e이면 표현식이 단락되고 인터프리터는 \u003ccode\u003etype(maybe_value).__else__(maybe_value, maybe_value)\u003c/code\u003e를 호출합니다. \u003ccode\u003etypes.CircuitBreaker.__then__\u003c/code\u003e의 구현은 인스턴스 메서드가 자신을 인수로 받았음을 감지하고 회로 차단기 대신 래핑된 값(즉, \u003ccode\u003edata.get(\"key\")\u003c/code\u003e)을 반환합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebool(maybe_value)\u003c/code\u003e가 \u003ccode\u003eTrue\u003c/code\u003e이면 인터프리터는 \u003ccode\u003etype(maybe_value).__else__(maybe_value, y)\u003c/code\u003e를 호출합니다. \u003ccode\u003etypes.CircuitBreaker.__else__\u003c/code\u003e의 구현은 단락이 발생했음을 나타내는 아무것도 보지 못하므로 \u003ccode\u003ey\u003c/code\u003e를 반환합니다.\u003c/p\u003e\n\u003ch3\u003e드 모르간의 법칙 준수 (Respecting De Morgan's Laws)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e와 유사하게, 이항 단락 연산자는 본질적으로 동일한 표현식을 작성하는 여러 방법을 허용할 것입니다. 이러한 겉보기 중복성은 불리언 대수(Boolean algebra)로서 프로토콜을 정의하는 것의 암시적인 결과입니다. 불리언 대수는 \"드 모르간의 법칙(De Morgan's Laws)\"으로 알려진 한 쌍의 속성을 준수합니다. 이는 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e 연산의 결과를 서로와 적절한 \u003ccode\u003enot\u003c/code\u003e 연산 조합으로 표현할 수 있는 능력입니다.\u003c/p\u003e\n\u003cp\u003ePython에서 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e에 대한 이러한 불변식은 다음과 같이 설명할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eassert bool(A and B) == bool(not (not A or not B))\r\nassert bool(A or B) == bool(not (not A and not B))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e즉, 연산자 중 하나를 취하고, 두 피연산자를 반전시키고, 다른 연산자로 전환한 다음, 전체 결과를 반전시키면 원래 연산자와 동일한 답(불리언 의미에서)을 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e회로 차단기의 경우, 적절한 불변식을 정의하는 것은 단락될 때 표현식 결과에서 자신을 제거하도록 설계되는 경우가 많기 때문에 복잡합니다. 이는 본질적으로 비대칭적인 동작입니다. 따라서 드 모르간의 법칙을 대칭 회로 차단기의 예상 동작에 매핑할 때 그 본질적인 비대칭성을 고려해야 합니다.\u003c/p\u003e\n\u003cp\u003e이러한 복잡성을 해결할 수 있는 한 가지 방법은 그렇지 않으면 단락될 피연산자를 \u003ccode\u003eoperator.true\u003c/code\u003e로 래핑하여, \u003ccode\u003ebool\u003c/code\u003e이 전체 결과에 적용될 때, 회로 차단기의 입력 값에 직접 \u003ccode\u003ebool\u003c/code\u003e을 적용하는 대신 어떤 분기를 평가할지 결정하는 데 사용된 동일한 참 정의를 사용하도록 하는 것입니다.\u003c/p\u003e\n\u003cp\u003e구체적으로, 새로운 단락 연산자의 경우, \u003ccode\u003e__bool__\u003c/code\u003e 및 \u003ccode\u003e__not__\u003c/code\u003e를 모두 구현하는 모든 올바르게 작동하는 대칭 회로 차단기에 대해 다음 속성이 합리적으로 유지될 것으로 예상됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eassert bool(B if true(A)) == bool(not (true(not A) else not B))\r\nassert bool(true(A) else B) == bool(not (not B if true(not A)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e오른쪽 피연산자의 연산 순서(입력 회로 차단기를 반전시킨 후 \u003ccode\u003etrue\u003c/code\u003e 적용)에 유의하십시오. 이는 단순히 \u003ccode\u003etype(true(A)).__not__\u003c/code\u003e의 동작에 대한 것이 아니라 실제로 \u003ccode\u003etype(A).__not__\u003c/code\u003e에 대한 주장이 이루어지도록 보장합니다.\u003c/p\u003e\n\u003cp\u003e최소한 \u003ccode\u003etypes.CircuitBreaker\u003c/code\u003e 인스턴스는 이 논리를 준수하여, 기존 불리언 표현식 최적화(예: 이중 부정 제거)가 계속 적용될 수 있도록 할 것입니다.\u003c/p\u003e\n\u003ch3\u003e임의의 Sentinel 객체 (Arbitrary sentinel objects)\u003c/h3\u003e\n\u003cp\u003ePEP 505 및 531과 달리, 이 PEP의 제안은 사용자 정의 Sentinel 객체를 쉽게 처리합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_MISSING = object() # 인수가 제공되었는지 확인하기 위한 Sentinel 사용\r\ndef my_func(arg=_MISSING):\r\n    arg = make_default() if is_sentinel(arg, _MISSING) # \"else arg\" implied\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e회로 차단 표현식의 암시적으로 정의된 회로 차단기 (Implicitly defined circuit breakers in circuit breaking expressions)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 게시되지 않은 초안은 \u003ccode\u003eis\u003c/code\u003e 및 \u003ccode\u003eis not\u003c/code\u003e 이항 연산자를 회로 차단 표현식의 컨텍스트에서 사용될 때 자동으로 회로 차단기로 처리하는 아이디어를 탐색했습니다. 불행히도, 이 접근 방식은 필연적으로 두 가지 매우 바람직하지 않은 결과 중 하나를 초래하는 것으로 나타났습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이러한 표현식의 반환 타입이 \u003ccode\u003ebool\u003c/code\u003e에서 \u003ccode\u003etypes.CircuitBreaker\u003c/code\u003e로 보편적으로 변경되어, 하위 호환성 문제를 일으킬 수 있습니다(특히 \u003ccode\u003ePyObject_IsTrue\u003c/code\u003e를 통해 제공된 값을 전달하거나 인수 파싱 함수 중 하나에서 \u003ccode\u003ep\u003c/code\u003e(predicate) 형식을 사용하는 대신 \u003ccode\u003ePyBool_Check\u003c/code\u003e로 내장 불리언 값을 찾는 확장 모듈 API와 작업할 때).\u003c/li\u003e\n\u003cli\u003e이러한 표현식의 반환 타입이 컨텍스트에 따라 달라져, 다른 일상적인 리팩토링(예: 비교 연산을 지역 변수로 추출하는 것)이 코드의 런타임 의미론에 상당한 영향을 미칠 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 가능한 결과 중 어느 것도 이 PEP의 제안에 의해 보장되는 것으로 보이지 않으므로, 회로 차단기 인스턴스가 API 호출을 통해 명시적으로 생성되어야 하며 암시적으로 생성되지 않는 현재 설계로 되돌아갔습니다.\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003ePEP 505와 마찬가지로, 이러한 변경을 수행하려는 아이디어에 대한 원칙적인 관심이 보류 중이므로 실제 구현은 연기되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1318,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Deferred] PEP 532 - A circuit breaking protocol and binary operators\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:23:40+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>