3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-17ec11482f243379.js","185","static/chunks/app/layout-c3e2e457f12fb6f6.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js"],""]
4:["slug","python/pep/204","c"]
0:["qd33V0IpW4K1wJhro15P-",[[["",{"children":[["slug","python/pep/204","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"204\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/204","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e975486d410ad4e9.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T3313,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0204/">PEP 204 - Range Literals</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 14-Jul-2000</p>
</blockquote>
<p><strong>작성자:</strong> Thomas Wouters
<strong>상태:</strong> Rejected (거부됨)
<strong>유형:</strong> Standards Track
<strong>작성일:</strong> 2000년 7월 14일
<strong>Python 버전:</strong> 2.0</p>
<hr>
<p><strong>경고:</strong> 이 PEP는 거부되었습니다.</p>
<p>신중한 고려와 숙고 끝에 이 제안은 거부되었습니다. Guido van Rossum은 이 제안이 Range와 Slice 구문 사이의 혼란, 그리고 해결되지 않은 문제들로 인해 Python 2.0에 채택하지 않기로 결정했으며, 이후 제안 전체를 거부했습니다. 새로운 구문과 그 의도가 충분히 명확하지 않다고 판단되었습니다.</p>
<hr>
<h3>서론</h3>
<p>이 PEP는 Python 2.0을 위한 "Range Literal (범위 리터럴)" 제안에 대해 설명합니다. 이 문서는 이 기능의 상태와 소유권을 추적하며, 기능에 대한 설명과 지원에 필요한 변경 사항을 설명합니다. 또한, 메일링 리스트 포럼에서 논의된 내용을 요약하고 관련 추가 정보 URL을 제공합니다.</p>
<h3>리스트 범위 (List ranges)</h3>
<p><code>for</code> 루프에서 자주 사용되는 범위(Range)는 고정된 단계(step)를 가진 숫자 시퀀스입니다. Python의 <code>for</code> 루프는 시퀀스를 직접 순회하도록 설계되었습니다.</p>
<pre><code class="language-python">>>> l = ['a', 'b', 'c', 'd']
>>> for item in l:
... print item
a
b
c
d
</code></pre>
<p>그러나 이 해결책이 항상 적절한 것은 아닙니다. 첫째, <code>for</code> 루프 본문에서 시퀀스를 변경하면 일부 항목이 건너뛰어지는 문제가 발생합니다. 둘째, 시퀀스의 모든 두 번째 요소와 같이 특정 간격으로 순회하는 것이 불가능합니다. 셋째, 때로는 인덱스를 기반으로 요소를 처리해야 하는데, 위 구문에서는 인덱스를 쉽게 사용할 수 없습니다.</p>
<p>이러한 경우를 위해 Python은 숫자로 이루어진 리스트를 생성하는 내장 함수 <code>range()</code>를 제공합니다. <code>range()</code> 함수는 <code>start</code>, <code>end</code>, <code>step</code> 세 가지 인수를 받으며, <code>start</code>와 <code>step</code>은 선택 사항이며 각각 0과 1이 기본값입니다.</p>
<p><code>range()</code> 함수는 <code>start</code>부터 시작하여 <code>step</code>만큼 증가하며 <code>end</code> 직전까지의 숫자로 이루어진 리스트를 생성합니다. 예를 들어, <code>range(10)</code>은 0부터 9까지 총 10개의 숫자를 가진 리스트를 만듭니다.</p>
<p><code>range()</code> 함수를 사용하면 위의 예시는 다음과 같습니다.</p>
<pre><code class="language-python">>>> for i in range(len(l)):
... print l[i]
a
b
c
d
</code></pre>
<p>혹은 <code>l</code>의 두 번째 요소부터 시작하여 그 이후로는 매 두 번째 요소만 처리하는 경우:</p>
<pre><code class="language-python">>>> for i in range(1, len(l), 2):
... print l[i]
b
d
</code></pre>
<p>이 접근 방식에는 몇 가지 단점이 있습니다.</p>
<ul>
<li><strong>목적의 명확성 부족:</strong> 원하는 리스트의 길이와 단계를 결정하기 위해 추가적인 함수 호출과 계산이 필요할 수 있으며, 이는 코드의 가독성을 떨어뜨립니다. 또한, 내장 <code>range()</code> 함수를 동일한 이름의 지역 또는 전역 변수로 "가려낼(shadow)" 수 있어, 사실상 함수가 대체될 수 있습니다.</li>
<li><strong>비효율성:</strong> <code>range()</code> 함수는 오버라이드될 수 있으므로, Python 컴파일러는 <code>for</code> 루프에 대해 가정을 할 수 없으며 별도의 루프 카운터를 유지해야 합니다.</li>
<li><strong>일관성 부족:</strong> 아래에 설명된 바와 같이, 이미 범위를 나타내는 구문이 존재하며, 이는 <code>range()</code>와 정확히 동일한 (선택적) 인수를 동일한 방식으로 사용합니다. 이 구문을 범위로 확장하여 "범위 리터럴"을 형성하는 것이 논리적으로 보입니다.</li>
</ul>
<h3>슬라이스 인덱스 (Slice Indices)</h3>
<p>Python에서 시퀀스는 단일 항목을 가져오거나 항목의 범위를 가져오는 두 가지 방식으로 인덱싱될 수 있습니다. 항목의 범위를 가져오면 원본 시퀀스와 동일한 유형의 새 객체가 생성되며, 여기에는 원본 시퀀스에서 가져온 0개 이상의 항목이 포함됩니다. 이는 "범위 표기법(range notation)"을 사용하여 수행됩니다.</p>
<pre><code class="language-python">>>> l[2:4]
['c', 'd']
</code></pre>
<p>이 범위 표기법은 콜론으로 구분된 0개, 1개 또는 2개의 인덱스로 구성됩니다. 첫 번째 인덱스는 시작 인덱스이고, 두 번째는 끝 인덱스입니다. 어느 하나라도 생략되면 각각 시퀀스의 시작과 끝이 기본값으로 사용됩니다.</p>
<p><code>step</code>을 포함하는 확장된 범위 표기법도 있습니다. 이 표기법은 현재 대부분의 내장 타입에서 지원되지 않지만, 만약 지원된다면 다음과 같이 작동할 것입니다.</p>
<pre><code class="language-python">>>> l[1:4:2]
['b', 'd']
</code></pre>
<p>슬라이스 구문의 세 번째 "인수"는 <code>range()</code>의 <code>step</code> 인수와 정확히 동일합니다. 표준 슬라이스와 확장 슬라이스의 기본 메커니즘은 충분히 다르고 일관성이 없어서 수학 패키지 외의 많은 클래스 및 확장 기능은 확장 변형에 대한 지원을 구현하지 않습니다. 이는 해결되어야 하지만, 이 PEP의 범위 밖입니다.</p>
<p>그러나 확장 슬라이스는 <code>range()</code> 함수 사용의 앞서 언급된 모든 단점을 해결하는 방식으로 범위를 나타내는 완벽하게 유효하고 적용 가능한 구문이 이미 있음을 보여줍니다.</p>
<ul>
<li>더 명확하고 간결한 구문이며, 이미 직관적이고 배우기 쉽다는 것이 입증되었습니다.</li>
<li>Python의 다른 범위 사용(예: 슬라이스)과 일관성이 있습니다.</li>
<li>내장 함수가 아닌 내장 구문이므로 오버라이드될 수 없습니다. 이는 코드를 보는 사람이 코드가 무엇을 하는지 확신할 수 있고, 옵티마이저가 <code>range()</code>가 "가려지는" 것에 대해 걱정할 필요가 없음을 의미합니다.</li>
</ul>
<h3>제안된 해결책</h3>
<p>제안된 범위 리터럴 구현은 리스트 리터럴 구문과 (확장) 슬라이스 구문을 결합하여 범위 리터럴을 형성합니다.</p>
<pre><code class="language-python">>>> [1:10]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> [:5]
[0, 1, 2, 3, 4]
>>> [5:1:-1]
[5, 4, 3, 2]
</code></pre>
<p>범위 리터럴과 슬라이스 구문 사이에는 한 가지 작은 차이점이 있습니다. 슬라이스에서는 <code>start</code>, <code>end</code>, <code>step</code> 모두를 생략하는 것이 가능하지만, 범위 리터럴에서는 <code>end</code>를 생략하는 것이 의미가 없습니다. 슬라이스에서는 <code>end</code>가 리스트의 끝으로 기본 설정되지만, 이는 범위 리터럴에서는 의미가 없습니다.</p>
<h3>참조 구현</h3>
<p>제안된 구현은 SourceForge에서 찾을 수 있습니다. 이 구현은 스택에서 세 인수를 가져와 이를 기반으로 리스트를 생성하는 새로운 바이트코드 <code>BUILD_RANGE</code>를 추가합니다. 생성된 리스트는 다시 스택에 푸시됩니다.</p>
<p>새로운 바이트코드를 사용하는 것은 컴파일 시간에 결과가 알려지지 않은 다른 계산을 기반으로 범위를 생성할 수 있도록 하기 위해 필요합니다.</p>
<p>이 코드는 <code>listobject.c</code>에 두 개의 새로운 함수를 도입하는데, 이 함수들은 현재 private 함수와 완전한 API 호출 사이의 경계에 있습니다.</p>
<ul>
<li><code>PyList_FromRange()</code>: <code>start</code>, <code>end</code>, <code>step</code>으로부터 리스트를 생성하며, 오류 발생 시 <code>NULL</code>을 반환합니다. 프로토타입은 다음과 같습니다.
<pre><code class="language-c">PyObject * PyList_FromRange(long start, long end, long step)
</code></pre>
</li>
<li><code>PyList_GetLenOfRange()</code>: 범위의 길이를 결정하는 데 사용되는 헬퍼(helper) 함수입니다. 이전에는 <code>bltinmodule.c</code>의 정적(static) 함수였지만, 이제 <code>listobject.c</code>와 <code>bltinmodule.c</code> (xrange용) 모두에서 필요합니다. 코드 중복을 피하기 위해 비정적(non-static)으로 만들어졌습니다. 프로토타입은 다음과 같습니다.
<pre><code class="language-c">long PyList_GetLenOfRange(long start, long end, long step)
</code></pre>
</li>
</ul>
<h3>미해결 문제 (Open issues)</h3>
<p>범위 리터럴에서 <code>end</code> 인수를 필수로 요구하는 불일치에 대한 한 가지 가능한 해결책은 <code>xrange()</code> 내장 함수처럼 범위 구문이 리스트 대신 "제너레이터(generator)"를 생성하도록 허용하는 것입니다. 그러나 제너레이터는 리스트가 아니므로, 예를 들어 제너레이터의 항목에 할당하거나 추가하는 것이 불가능할 것입니다.</p>
<p>범위 구문은 튜플(즉, 불변 리스트)을 포함하도록 확장될 수도 있으며, 이 경우 안전하게 제너레이터로 구현될 수 있습니다. 이는 특히 대규모 숫자 배열에 바람직한 해결책일 수 있습니다. 제너레이터는 저장 및 초기화에 거의 필요하지 않으며, 요청 시 적절한 숫자를 계산하고 생성하는 데 성능에 미치는 영향이 작습니다.</p>
<p>하지만 이 아이디어가 채택되더라도, 구문의 한 인스턴스에서는 두 번째 인수를 선택 사항으로 만들고 다른 경우에는 필수가 아닌 "특별 대우(special case)"를 하는 것이 현명할까요?</p>
<p>범위 구문을 일반 리스트 리터럴과 혼합하여 단일 리스트를 생성할 수 있어야 할까요? 예를 들어:</p>
<pre><code class="language-python">>>> [5, 6, 1:6, 7, 9]
</code></pre>
<p>이것이 다음과 같이 생성되어야 할까요?</p>
<pre><code class="language-python">[5, 6, 1, 2, 3, 4, 5, 7, 9]
</code></pre>
<p>범위 리터럴은 또 다른 제안된 새로운 기능인 "List Comprehension (리스트 컴프리헨션)"과 어떻게 상호 작용해야 할까요? 특히, 리스트 컴프리헨션 내에서 리스트를 생성할 수 있어야 할까요? 예를 들어:</p>
<pre><code class="language-python">>>> [x:y for x in (1, 2) y in (3, 4)]
</code></pre>
<p>이 예시는 여러 범위를 가진 단일 리스트를 반환해야 할까요?</p>
<pre><code class="language-python">[1, 2, 1, 2, 3, 2, 2, 3]
</code></pre>
<p>아니면 다음과 같이 리스트들의 리스트를 반환해야 할까요?</p>
<pre><code class="language-python">[[1, 2], [1, 2, 3], [2], [2, 3]]
</code></pre>
<p>그러나 리스트 컴프리헨션의 구문과 의미는 여전히 뜨거운 논쟁의 대상이므로, 이러한 문제는 "list comprehensions" PEP에서 다루는 것이 가장 좋습니다.</p>
<p>범위 리터럴은 정수 외의 객체도 허용합니다. 전달된 객체에 대해 <code>PyInt_AsLong()</code>을 수행하므로, 객체가 정수로 강제 변환될 수 있는 한 허용됩니다. 그러나 결과 리스트는 항상 표준 정수로 구성됩니다.</p>
<p>범위 리터럴은 전달된 유형의 리스트를 생성해야 할까요? <code>long</code> 및 <code>string</code>과 같은 다른 내장 유형의 경우에는 바람직할 수 있습니다.</p>
<pre><code class="language-python">>>> [ 1L : 2L&#x3C;&#x3C;64 : 2&#x3C;&#x3C;32L ]
>>> ["a":"z":"b"]
>>> ["a":"z":2]
</code></pre>
<p>그러나 이것은 너무 많은 "마법"이어서 명확하지 않을 수 있습니다. 또한 사용자 정의 클래스와도 문제가 발생할 수 있습니다. 기본 클래스를 찾고 새 인스턴스를 생성할 수 있더라도, 인스턴스가 <code>__init__</code>에 추가 인수를 요구하여 생성에 실패할 수 있습니다.</p>
<p><code>PyList_FromRange()</code> 및 <code>PyList_GetLenOfRange()</code> 함수는 분류되어야 합니다. 이들은 API의 일부인가요, 아니면 private 함수로 만들어져야 할까요?</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 Public Domain에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1450,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Rejected] PEP 204 - Range Literals"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 16:14:46+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}]]
1:null
