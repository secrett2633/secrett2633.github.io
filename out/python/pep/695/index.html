<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-1a135130af3e1cae.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1318<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 695 - Type Parameter Syntax</h1><div class="page__meta"><time dateTime="2025-09-27 13:03:44+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0695/">PEP 695 - Type Parameter Syntax</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 15-Jun-2022</p>
</blockquote>
<h1>PEP 695 – 타입 매개변수 구문</h1>
<ul>
<li><strong>작성자:</strong> Eric Traut</li>
<li><strong>후원자:</strong> Guido van Rossum</li>
<li><strong>상태:</strong> Final</li>
<li><strong>타입:</strong> Standards Track (표준 트랙)</li>
<li><strong>주제:</strong> Typing (타입 힌트)</li>
<li><strong>생성일:</strong> 2022년 6월 15일</li>
<li><strong>Python 버전:</strong> 3.12</li>
<li><strong>해결책:</strong> Discourse message</li>
</ul>
<h2>초록 (Abstract)</h2>
<p>이 PEP는 제네릭 클래스, 함수 또는 타입 별칭 내에서 타입 매개변수를 지정하기 위한 개선된 구문을 명시합니다. 또한, 타입 별칭을 선언하기 위한 새로운 <code>type</code> 문(statement)을 도입합니다.</p>
<h2>동기 (Motivation)</h2>
<p>PEP 484는 타입 변수(TypeVar)를 언어에 도입했습니다. PEP 612는 매개변수 사양(ParamSpec)을 도입하여 이 개념을 확장했고, PEP 646은 가변 타입 변수(Variadic Type Variables)를 추가했습니다.</p>
<p>제네릭 타입과 타입 매개변수가 점점 더 널리 사용되고 있지만, 타입 매개변수를 지정하는 기존 구문은 여전히 Python에 "억지로 끼워 넣은" 듯한 느낌을 주어, 많은 Python 개발자들 사이에서 혼란의 원인이 되고 있습니다.</p>
<p>Python 정적 타입 시스템(static typing) 커뮤니티 내에서는 제네릭 타입을 지원하는 다른 현대 프로그래밍 언어와 유사한 공식 구문을 제공할 때가 되었다는 합의가 있었습니다. 25개의 인기 있는 타입 힌트가 적용된 Python 라이브러리를 분석한 결과, 모듈의 14%에서 타입 변수(특히 <code>typing.TypeVar</code> 심볼)가 사용된 것으로 나타났습니다.</p>
<h3>혼란의 지점들 (Points of Confusion)</h3>
<p>타입 변수의 사용이 널리 퍼졌음에도 불구하고, 코드 내에서 타입 변수를 지정하는 방식은 많은 Python 개발자들에게 혼란의 원인이 됩니다. 이러한 혼란을 야기하는 몇 가지 요인은 다음과 같습니다.</p>
<ul>
<li><strong>스코핑 규칙의 어려움:</strong> 타입 변수의 스코핑 규칙은 이해하기 어렵습니다. 타입 변수는 일반적으로 전역 스코프(global scope)에 할당되지만, 그 의미론적(semantic) 의미는 제네릭 클래스, 함수 또는 타입 별칭의 컨텍스트 내에서 사용될 때만 유효합니다. 단일 런타임 타입 변수 인스턴스는 여러 제네릭 컨텍스트에서 재사용될 수 있으며, 각 컨텍스트에서 다른 의미론적 의미를 가집니다. 이 PEP는 클래스, 함수 또는 타입 별칭 선언문 내에서 자연스러운 위치에 타입 매개변수를 선언함으로써 이러한 혼란을 해소하고자 합니다.</li>
<li><strong>제네릭 타입 별칭의 오용:</strong> 개발자들이 타입 별칭이 사용될 때 타입 인수가 제공되어야 한다는 점을 명확히 알지 못해 제네릭 타입 별칭이 오용되는 경우가 많습니다. 이로 인해 의도하지 않은 <code>Any</code> 타입 인수가 암시적으로 적용되는 경우가 발생합니다. 이 PEP는 제네릭 타입 별칭 선언을 명확하게 하는 새로운 구문을 추가할 것을 제안합니다.</li>
<li><strong>분산(Variance) 개념의 복잡성:</strong> PEP 483과 PEP 484는 제네릭 클래스 내에서 사용되는 타입 변수의 "분산(variance)" 개념을 도입했습니다. 타입 변수는 <code>invariant</code>, <code>covariant</code>, 또는 <code>contravariant</code>일 수 있습니다. 분산 개념은 대부분의 Python 개발자들에게 잘 이해되지 않는 타입 이론의 고급 세부 사항이지만, 첫 번째 제네릭 클래스를 정의할 때 이 개념에 직면해야 합니다. 이 PEP는 대부분의 개발자가 제네릭 클래스를 정의할 때 분산 개념을 이해할 필요성을 크게 줄입니다.</li>
<li><strong>타입 매개변수 순서의 혼란:</strong> 여러 타입 매개변수가 제네릭 클래스나 타입 별칭과 함께 사용될 때, 타입 매개변수 순서에 대한 규칙이 혼란스러울 수 있습니다. 일반적으로 클래스 또는 타입 별칭 선언문 내에서 처음 나타나는 순서를 기반으로 합니다. 그러나 이는 <code>Generic</code> 또는 <code>Protocol</code> 기본 클래스를 포함함으로써 클래스 정의에서 재정의될 수 있습니다. 이 PEP는 모든 경우에 타입 매개변수 순서를 명시적으로 만들 것을 제안합니다.</li>
<li><strong>여러 제네릭 컨텍스트에서 타입 변수 공유 문제:</strong> 여러 제네릭 컨텍스트에서 타입 변수를 공유하는 관행은 다른 문제를 야기합니다. 최신 에디터는 의미론적 수준에서 심볼에 대해 "모든 참조 찾기" 및 "모든 참조 이름 변경"과 같은 기능을 제공합니다. 타입 매개변수가 여러 제네릭 클래스, 함수 및 타입 별칭 간에 공유될 때 모든 참조는 의미론적으로 동일합니다.</li>
<li><strong>중복되고 번거로운 이름:</strong> 전역 스코프에 정의된 타입 변수는 모듈에 대해 비공개임을 나타내기 위해 밑줄로 시작하는 이름을 지정해야 합니다. 또한, 전역적으로 정의된 타입 변수에는 분산을 나타내는 이름이 주어지는 경우가 많아 "_T_contra" 및 "_KT_co"와 같이 번거로운 이름이 됩니다. 현재 타입 변수를 할당하는 메커니즘은 개발자가 따옴표 안에 중복된 이름("T" = TypeVar("T"))을 제공해야 합니다. 이 PEP는 중복된 이름과 번거로운 변수 이름의 필요성을 없앱니다.</li>
<li><strong><code>typing</code> 모듈 임포트의 필요성:</strong> 현재 타입 매개변수를 정의하려면 <code>TypeVar</code> 및 <code>Generic</code> 심볼을 <code>typing</code> 모듈에서 임포트해야 합니다. 지난 몇몇 Python 릴리스에서 일반적인 사용 사례에 대해 <code>typing</code> 심볼을 임포트할 필요성을 없애려는 노력이 있었고, 이 PEP는 이 목표를 더욱 발전시킵니다.</li>
</ul>
<h2>요약 예시 (Summary Examples)</h2>
<p>이 PEP 이전의 제네릭 클래스 정의는 다음과 같습니다.</p>
<pre><code class="language-python">from typing import Generic, TypeVar

_T_co = TypeVar("_T_co", covariant=True, bound=str)

class ClassA(Generic[_T_co]):
    def method1(self) -> _T_co:
        ...
</code></pre>
<p>새로운 구문으로는 다음과 같습니다.</p>
<pre><code class="language-python">class ClassA[T: str]:
    def method1(self) -> T:
        ...
</code></pre>
<p>현재 제네릭 함수의 예시입니다.</p>
<pre><code class="language-python">from typing import TypeVar

_T = TypeVar("_T")

def func(a: _T, b: _T) -> _T:
    ...
</code></pre>
<p>새로운 구문으로는 다음과 같습니다.</p>
<pre><code class="language-python">def func[T](a: T, b: T) -> T:
    ...
</code></pre>
<p>현재 제네릭 타입 별칭의 예시입니다.</p>
<pre><code class="language-python">from typing import TypeAlias

_T = TypeVar("_T")
ListOrSet: TypeAlias = list[_T] | set[_T]
</code></pre>
<p>새로운 구문으로는 다음과 같습니다.</p>
<pre><code class="language-python">type ListOrSet[T] = list[T] | set[T]
</code></pre>
<h2>사양 (Specification)</h2>
<h3>타입 매개변수 선언 (Type Parameter Declarations)</h3>
<p>제네릭 클래스, 함수 및 타입 별칭에 대한 타입 매개변수를 선언하는 새로운 구문은 다음과 같습니다. 이 구문은 클래스, 함수 또는 타입 별칭의 이름 뒤에 대괄호 안에 쉼표로 구분된 타입 매개변수 목록을 추가하는 것을 지원합니다.</p>
<ul>
<li>단순(비가변) 타입 변수는 꾸밈 없는 이름으로 선언됩니다.</li>
<li>가변 타입 변수는 <code>*</code>가 앞에 붙습니다 (자세한 내용은 PEP 646 참조).</li>
<li>매개변수 사양(ParamSpec)은 <code>**</code>가 앞에 붙습니다 (자세한 내용은 PEP 612 참조).</li>
</ul>
<pre><code class="language-python"># 이 제네릭 클래스는 TypeVar T, TypeVarTuple Ts, ParamSpec P로 매개변수화됩니다.
class ChildClass[T, *Ts, **P]:
    ...
</code></pre>
<p><code>Generic</code>을 기본 클래스로 포함할 필요가 없습니다. 타입 매개변수의 존재에 의해 <code>Generic</code>의 포함이 암시되며, 클래스의 <code>__mro__</code> 및 <code>__orig_bases__</code> 속성에 자동으로 포함됩니다. <code>Generic</code> 기본 클래스를 명시적으로 사용하면 런타임 오류가 발생합니다.</p>
<pre><code class="language-python">class ClassA[T](Generic[T]): # 런타임 오류
    ...
</code></pre>
<p>타입 인수를 포함하는 <code>Protocol</code> 기본 클래스는 런타임 오류를 생성할 수 있습니다. 타입 검사기는 이 경우 오류를 생성해야 합니다.</p>
<pre><code class="language-python">class ClassA[S, T](Protocol): # OK
    ...
class ClassB[S, T](Protocol[S, T]): # 타입 검사기 오류 권장
    ...
</code></pre>
<p>제네릭 클래스, 함수 또는 타입 별칭 내의 타입 매개변수 이름은 해당 클래스, 함수 또는 타입 별칭 내에서 고유해야 합니다. 중복된 이름은 컴파일 시 구문 오류를 생성합니다.</p>
<h3>상한선 지정 (Upper Bound Specification)</h3>
<p>비가변(non-variadic) 타입 매개변수의 경우, 타입 어노테이션(type annotation) 표현식을 사용하여 "상한선(upper bound)" 타입을 지정할 수 있습니다. 상한선이 지정되지 않으면 <code>object</code>가 상한선으로 가정됩니다.</p>
<pre><code class="language-python">class ClassA[T: str]:
    ...
</code></pre>
<p>지정된 상한선 타입은 타입 어노테이션에서 허용되는 표현식 형태를 사용해야 합니다. 따옴표로 묶인 전방 참조(forward references)는 허용됩니다. 상한선 타입은 구체적(concrete)이어야 하며, 제네릭 타입을 사용하려는 시도는 타입 검사기에 의해 오류로 플래그되어야 합니다.</p>
<h3>제약된 타입 지정 (Constrained Type Specification)</h3>
<p>PEP 484는 두 개 이상의 타입으로 제약되는 "제약된 타입 변수(constrained type variable)" 개념을 도입했습니다. 새로운 구문은 두 개 이상의 타입을 포함하는 리터럴 튜플 표현식을 사용하여 이러한 타입의 제약을 지원합니다.</p>
<pre><code class="language-python">class ClassA[AnyStr: (str, bytes)]: # OK
    ...
class ClassB[T: ("ForwardReference", bytes)]: # OK
    ...
class ClassC[T: ()]: # 타입 검사기 오류: 두 개 이상의 타입 필요
    ...
</code></pre>
<h3>런타임에서의 상한선 및 제약 표현 (Runtime Representation of Bounds and Constraints)</h3>
<p><code>TypeVar</code> 객체의 상한선과 제약은 런타임에 <code>__bound__</code> 및 <code>__constraints__</code> 속성을 통해 접근할 수 있습니다. 새로운 구문을 통해 정의된 <code>TypeVar</code> 객체의 경우, 이러한 속성은 아래 "지연 평가(Lazy Evaluation)"에서 설명하는 대로 지연 평가됩니다.</p>
<h3>제네릭 타입 별칭 (Generic Type Alias)</h3>
<p>타입 별칭을 선언하기 위한 새로운 <code>type</code> 문을 도입합니다. <code>class</code> 및 <code>def</code> 문과 유사하게, <code>type</code> 문은 타입 매개변수에 대한 스코프(scope)를 정의합니다.</p>
<pre><code class="language-python"># 비제네릭 타입 별칭
type IntOrStr = int | str
# 제네릭 타입 별칭
type ListOrSet[T] = list[T] | set[T]
</code></pre>
<p>타입 별칭은 따옴표를 사용하지 않고도 자신을 참조할 수 있습니다 (재귀 타입 별칭). <code>type</code> 키워드는 새로운 소프트 키워드(soft keyword)입니다.</p>
<h3>런타임 타입 별칭 클래스 (Runtime Type Alias Class)</h3>
<p>런타임에 <code>type</code> 문은 <code>typing.TypeAliasType</code>의 인스턴스를 생성합니다. 이 클래스는 타입 별칭을 나타내며, <code>__name__</code>, <code>__type_params__</code>, <code>__value__</code>와 같은 속성을 가집니다. 이 모든 속성은 읽기 전용입니다. 타입 별칭의 값은 지연 평가됩니다.</p>
<h3>타입 매개변수 스코프 (Type Parameter Scopes)</h3>
<p>새로운 구문이 사용될 때, 새로운 렉시컬 스코프(lexical scope)가 도입되고 이 스코프는 타입 매개변수를 포함합니다. 타입 매개변수는 내부 스코프에서 이름으로 접근할 수 있습니다.</p>
<ul>
<li>타입 매개변수는 목록의 다른 곳에 선언된 다른 타입 매개변수에게 가시적입니다.</li>
<li>제네릭 클래스의 일부로 선언된 타입 매개변수는 클래스 본문 및 그 안에 포함된 내부 스코프 내에서 유효합니다.</li>
<li>제네릭 함수의 일부로 선언된 타입 매개변수는 함수 본문 및 그 안에 포함된 스코프 내에서 유효하며, 매개변수 및 반환 타입 어노테이션 내에서도 유효합니다.</li>
<li>제네릭 타입 별칭의 일부로 선언된 타입 매개변수는 타입 별칭 표현식 내에서 유효합니다.</li>
</ul>
<p>새로운 타입 매개변수 구문으로 도입된 렉시컬 스코프는 <code>def</code> 또는 <code>class</code> 문으로 도입된 전통적인 스코프와 다릅니다. 타입 매개변수 스코프는 포함하는 스코프에 대한 임시 "오버레이(overlay)"처럼 작동합니다.</p>
<h3>런타임에서 타입 매개변수 접근 (Accessing Type Parameters at Runtime)</h3>
<p>제네릭 클래스, 함수 및 타입 별칭에 <code>__type_params__</code>라는 새로운 속성이 제공됩니다. 이 속성은 클래스, 함수 또는 별칭을 매개변수화하는 타입 매개변수(TypeVar, ParamSpec, TypeVarTuple 인스턴스)의 튜플입니다.</p>
<h3>분산 추론 (Variance Inference)</h3>
<p>이 PEP는 타입 매개변수에 대한 분산을 명시할 필요성을 없앱니다. 대신, 타입 검사기는 클래스 내에서의 사용법에 따라 타입 매개변수의 분산(invariant, covariant, contravariant)을 추론합니다.</p>
<p>분산 추론 알고리즘은 다음과 같습니다.</p>
<ol>
<li>타입 매개변수가 가변(TypeVarTuple)이거나 매개변수 사양(ParamSpec)인 경우, 항상 <code>invariant</code>로 간주됩니다.</li>
<li>타입 매개변수가 <code>infer_variance</code>로 지정되지 않은 전통적인 <code>TypeVar</code> 선언에서 온 경우, 분산은 <code>TypeVar</code> 생성자 호출에 의해 지정됩니다.</li>
<li>클래스의 두 가지 특수화된 버전(<code>upper</code> 및 <code>lower</code>)을 생성하여 해당 타입 매개변수의 호환성을 확인합니다.</li>
<li><code>lower</code>가 <code>upper</code>에 할당 가능한지, <code>upper</code>가 <code>lower</code>에 할당 가능한지 여부에 따라 <code>covariant</code>, <code>contravariant</code>, <code>invariant</code>를 결정합니다.</li>
</ol>
<h3>TypeVar에 대한 자동 분산 (Auto Variance For TypeVar)</h3>
<p>기존 <code>TypeVar</code> 클래스 생성자는 <code>covariant</code> 및 <code>contravariant</code> 키워드 매개변수를 받습니다. 이 둘 다 <code>False</code>이면 타입 변수는 <code>invariant</code>로 가정됩니다. 이 PEP는 <code>infer_variance</code>라는 또 다른 키워드 매개변수를 추가하여 타입 검사기가 타입 변수가 <code>invariant</code>, <code>covariant</code>, <code>contravariant</code> 중 어느 것인지 추론하도록 지시할 것을 제안합니다.</p>
<h3>기존 TypeVar와의 호환성 (Compatibility with Traditional TypeVars)</h3>
<p><code>TypeVar</code>, <code>TypeVarTuple</code>, <code>ParamSpec</code>을 할당하는 기존 메커니즘은 하위 호환성을 위해 유지됩니다. 그러나 이러한 "전통적인" 타입 변수는 새로운 구문을 사용하여 할당된 타입 매개변수와 결합해서는 안 됩니다. 이러한 결합은 타입 검사기에 의해 오류로 플래그되어야 합니다.</p>
<h2>런타임 구현 (Runtime Implementation)</h2>
<h3>문법 변경 (Grammar Changes)</h3>
<p>이 PEP는 새로운 소프트 키워드 <code>type</code>를 도입합니다. 클래스 및 <code>def</code> 문에 선택적 타입 매개변수 절을 추가하고, 타입 별칭 정의를 위한 새로운 <code>type</code> 문을 추가하는 방식으로 문법을 수정합니다.</p>
<h3>AST 변경 (AST Changes)</h3>
<p>이 PEP는 <code>TypeAlias</code>라는 새로운 AST(Abstract Syntax Tree) 노드 타입을 도입합니다. 또한 타입 매개변수를 나타내는 AST 노드 타입 (<code>TypeVar</code>, <code>ParamSpec</code>, <code>TypeVarTuple</code>)을 추가합니다. 기존 <code>FunctionDef</code>, <code>AsyncFunctionDef</code>, <code>ClassDef</code> AST 노드 타입은 함수 또는 클래스와 관련된 타입 매개변수 목록을 포함하는 <code>typeparams</code>라는 선택적 속성을 포함하도록 수정됩니다.</p>
<h3>지연 평가 (Lazy Evaluation)</h3>
<p>이 PEP는 <code>TypeVar</code> 경계, <code>TypeVar</code> 제약 및 타입 별칭의 값을 나타내는 표현식이 나타날 수 있는 세 가지 새로운 컨텍스트를 도입합니다. 이러한 표현식은 아직 정의되지 않은 이름에 대한 참조를 포함할 수 있습니다. PEP 563 및 PEP 649와 유사하게, 이러한 표현식은 런타임 오류를 방지하기 위해 지연 평가(lazy evaluation)를 사용합니다. 각 표현식은 코드 객체로 저장되며, 해당 속성(<code>TypeVar.__bound__</code>, <code>TypeVar.__constraints__</code>, <code>TypeAlias.__value__</code>)이 접근될 때만 평가됩니다.</p>
<h3>스코프 동작 (Scoping Behavior)</h3>
<p>새로운 구문은 기존 Python 스코프와 다르게 동작하는 새로운 종류의 스코프를 필요로 합니다. 새로운 스코프는 함수 스코프와 유사하게 동작하지만, 몇 가지 사소한 차이점이 있습니다. 특히, 클래스 스코프 내에 즉시 위치하는 경우, 클래스 스코프에 정의된 이름에 접근할 수 있습니다.</p>
<h3>라이브러리 변경 (Library Changes)</h3>
<p><code>typing</code> 모듈의 여러 클래스(<code>TypeVar</code>, <code>TypeVarTuple</code>, <code>ParamSpec</code>, <code>Generic</code> 및 새로운 <code>TypeAliasType</code>)는 C로 부분적으로 구현되어야 합니다.</p>
<h2>참조 구현 (Reference Implementation)</h2>
<p>이 제안은 CPython PR #103764에서 프로토타입으로 구현되었습니다. Pyright 타입 검사기는 이 PEP에 설명된 동작을 지원합니다.</p>
<h2>거부된 아이디어 (Rejected Ideas)</h2>
<h3>접두사 절 (Prefix Clause)</h3>
<p><code>def</code> 및 <code>class</code> 문 앞에 타입 매개변수를 지정하는 다양한 구문 옵션이 탐색되었으나, 스코핑 규칙이 불분명하고 데코레이터와 잘 작동하지 않아 거부되었습니다.</p>
<h3>꺽쇠 괄호 (Angle Brackets)</h3>
<p>다른 많은 언어에서 제네릭에 꺽쇠 괄호(<code>&#x3C;></code>)를 사용하지만, Python에서는 라인 브레이크 처리 문제와 <code>list[int]</code>와 같이 명시적인 특수화에 이미 대괄호(<code>[]</code>)를 사용하는 기존 관행과의 불일치 때문에 거부되었습니다.</p>
<h3>경계 구문 (Bounds Syntax)</h3>
<p><code>Scala</code>의 <code>&#x3C;:</code> 토큰, <code>extends</code> 또는 <code>with</code> 키워드, <code>typing.TypeVar</code> 생성자와 유사한 함수 호출 구문 등 다양한 경계 및 제약 구문이 고려되었으나, 단순한 콜론(<code>:</code>) 구문이 다른 많은 프로그래밍 언어와 일치하고 설문조사에서 Python 개발자들에게 크게 선호되어 채택되었습니다.</p>
<h3>명시적 분산 (Explicit Variance)</h3>
<p>타입 매개변수가 <code>invariant</code>, <code>covariant</code>, <code>contravariant</code> 중 무엇인지 명시적으로 지정하는 구문을 추가하는 것이 고려되었으나, 분산은 일반적으로 추론될 수 있으며 대부분의 현대 프로그래밍 언어가 사용법을 기반으로 분산을 추론하기 때문에 거부되었습니다.</p>
<h3>이름 변환 (Name Mangling)</h3>
<p>각 타입 매개변수에 컴파일러가 고유한 "변환된(mangled)" 이름을 부여하는 접근 방식이 고려되었으나, 정규화된 이름이 반드시 고유하지 않다는 문제와 따옴표로 묶인 (전방 참조) 타입 어노테이션을 평가하는 기술과 호환되지 않는다는 문제로 거부되었습니다.</p>
<h2>부록 A: 타입 매개변수 구문 조사 (Appendix A: Survey of Type Parameter Syntax)</h2>
<p>이 섹션에서는 제네릭 타입을 지원하는 다른 인기 있는 프로그래밍 언어에서 사용되는 옵션에 대한 조사를 제공합니다.</p>
<p>다음은 다양한 언어의 타입 매개변수 구문 요약입니다.</p>
<p>| 언어            | 선언 구문 | 상한선     | 하한선    | 기본값 | 분산 사이트 | 분산             |
| :-------------- | :-------- | :--------- | :-------- | :----- | :---------- | :--------------- |
| <strong>C++</strong>         | <code>template &#x3C;></code> | n/a        | n/a       | <code>=</code>    | n/a         | n/a              |
| <strong>Java</strong>        | <code>&#x3C;></code>      | <code>extends</code>  | <code>super</code>   | n/a    | 사용 (use)  | <code>super</code>, <code>extends</code> |
| <strong>C#</strong>          | <code>&#x3C;></code>      | <code>where</code>    | n/a       | n/a    | 선언 (decl) | <code>in</code>, <code>out</code>      |
| <strong>TypeScript</strong>  | <code>&#x3C;></code>      | <code>extends</code>  | n/a       | <code>=</code>    | 선언 (decl) | 추론, <code>in</code>, <code>out</code> |
| <strong>Scala</strong>       | <code>[]</code>      | <code>T &#x3C;: X</code>   | <code>T >: X</code>  | n/a    | 사용, 선언  | <code>+</code>, <code>-</code>         |
| <strong>Swift</strong>       | <code>&#x3C;></code>      | <code>T: X</code>     | n/a       | n/a    | n/a         | n/a              |
| <strong>Rust</strong>        | <code>&#x3C;></code>      | <code>T: X</code>, <code>where</code> | n/a    | <code>=</code>    | n/a         | n/a              |
| <strong>Kotlin</strong>      | <code>&#x3C;></code>      | <code>T: X</code>, <code>where</code> | n/a    | n/a    | 사용, 선언  | <code>in</code>, <code>out</code>      |
| <strong>Julia</strong>       | <code>{}</code>      | <code>T &#x3C;: X</code>   | <code>X &#x3C;: T</code>  | n/a    | n/a         | n/a              |
| <strong>Dart</strong>        | <code>&#x3C;></code>      | <code>extends</code>  | n/a       | n/a    | 선언 (decl) | <code>in</code>, <code>out</code>, <code>inout</code> |
| <strong>Go</strong>          | <code>[]</code>      | <code>T X</code>      | n/a       | n/a    | n/a         | n/a              |
| <strong>Python (제안)</strong> | <code>[]</code>      | <code>T: X</code>     | n/a       | n/a    | 선언 (decl) | 추론             |</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-1a135130af3e1cae.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/695\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"8N6icDw00Cy0kKVlExSq2\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/695/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/695\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"695\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/695\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T5d58,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0695/\"\u003ePEP 695 - Type Parameter Syntax\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 15-Jun-2022\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 695 – 타입 매개변수 구문\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Eric Traut\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e후원자:\u003c/strong\u003e Guido van Rossum\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e타입:\u003c/strong\u003e Standards Track (표준 트랙)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e주제:\u003c/strong\u003e Typing (타입 힌트)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2022년 6월 15일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.12\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e해결책:\u003c/strong\u003e Discourse message\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 제네릭 클래스, 함수 또는 타입 별칭 내에서 타입 매개변수를 지정하기 위한 개선된 구문을 명시합니다. 또한, 타입 별칭을 선언하기 위한 새로운 \u003ccode\u003etype\u003c/code\u003e 문(statement)을 도입합니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePEP 484는 타입 변수(TypeVar)를 언어에 도입했습니다. PEP 612는 매개변수 사양(ParamSpec)을 도입하여 이 개념을 확장했고, PEP 646은 가변 타입 변수(Variadic Type Variables)를 추가했습니다.\u003c/p\u003e\n\u003cp\u003e제네릭 타입과 타입 매개변수가 점점 더 널리 사용되고 있지만, 타입 매개변수를 지정하는 기존 구문은 여전히 Python에 \"억지로 끼워 넣은\" 듯한 느낌을 주어, 많은 Python 개발자들 사이에서 혼란의 원인이 되고 있습니다.\u003c/p\u003e\n\u003cp\u003ePython 정적 타입 시스템(static typing) 커뮤니티 내에서는 제네릭 타입을 지원하는 다른 현대 프로그래밍 언어와 유사한 공식 구문을 제공할 때가 되었다는 합의가 있었습니다. 25개의 인기 있는 타입 힌트가 적용된 Python 라이브러리를 분석한 결과, 모듈의 14%에서 타입 변수(특히 \u003ccode\u003etyping.TypeVar\u003c/code\u003e 심볼)가 사용된 것으로 나타났습니다.\u003c/p\u003e\n\u003ch3\u003e혼란의 지점들 (Points of Confusion)\u003c/h3\u003e\n\u003cp\u003e타입 변수의 사용이 널리 퍼졌음에도 불구하고, 코드 내에서 타입 변수를 지정하는 방식은 많은 Python 개발자들에게 혼란의 원인이 됩니다. 이러한 혼란을 야기하는 몇 가지 요인은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e스코핑 규칙의 어려움:\u003c/strong\u003e 타입 변수의 스코핑 규칙은 이해하기 어렵습니다. 타입 변수는 일반적으로 전역 스코프(global scope)에 할당되지만, 그 의미론적(semantic) 의미는 제네릭 클래스, 함수 또는 타입 별칭의 컨텍스트 내에서 사용될 때만 유효합니다. 단일 런타임 타입 변수 인스턴스는 여러 제네릭 컨텍스트에서 재사용될 수 있으며, 각 컨텍스트에서 다른 의미론적 의미를 가집니다. 이 PEP는 클래스, 함수 또는 타입 별칭 선언문 내에서 자연스러운 위치에 타입 매개변수를 선언함으로써 이러한 혼란을 해소하고자 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e제네릭 타입 별칭의 오용:\u003c/strong\u003e 개발자들이 타입 별칭이 사용될 때 타입 인수가 제공되어야 한다는 점을 명확히 알지 못해 제네릭 타입 별칭이 오용되는 경우가 많습니다. 이로 인해 의도하지 않은 \u003ccode\u003eAny\u003c/code\u003e 타입 인수가 암시적으로 적용되는 경우가 발생합니다. 이 PEP는 제네릭 타입 별칭 선언을 명확하게 하는 새로운 구문을 추가할 것을 제안합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e분산(Variance) 개념의 복잡성:\u003c/strong\u003e PEP 483과 PEP 484는 제네릭 클래스 내에서 사용되는 타입 변수의 \"분산(variance)\" 개념을 도입했습니다. 타입 변수는 \u003ccode\u003einvariant\u003c/code\u003e, \u003ccode\u003ecovariant\u003c/code\u003e, 또는 \u003ccode\u003econtravariant\u003c/code\u003e일 수 있습니다. 분산 개념은 대부분의 Python 개발자들에게 잘 이해되지 않는 타입 이론의 고급 세부 사항이지만, 첫 번째 제네릭 클래스를 정의할 때 이 개념에 직면해야 합니다. 이 PEP는 대부분의 개발자가 제네릭 클래스를 정의할 때 분산 개념을 이해할 필요성을 크게 줄입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e타입 매개변수 순서의 혼란:\u003c/strong\u003e 여러 타입 매개변수가 제네릭 클래스나 타입 별칭과 함께 사용될 때, 타입 매개변수 순서에 대한 규칙이 혼란스러울 수 있습니다. 일반적으로 클래스 또는 타입 별칭 선언문 내에서 처음 나타나는 순서를 기반으로 합니다. 그러나 이는 \u003ccode\u003eGeneric\u003c/code\u003e 또는 \u003ccode\u003eProtocol\u003c/code\u003e 기본 클래스를 포함함으로써 클래스 정의에서 재정의될 수 있습니다. 이 PEP는 모든 경우에 타입 매개변수 순서를 명시적으로 만들 것을 제안합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e여러 제네릭 컨텍스트에서 타입 변수 공유 문제:\u003c/strong\u003e 여러 제네릭 컨텍스트에서 타입 변수를 공유하는 관행은 다른 문제를 야기합니다. 최신 에디터는 의미론적 수준에서 심볼에 대해 \"모든 참조 찾기\" 및 \"모든 참조 이름 변경\"과 같은 기능을 제공합니다. 타입 매개변수가 여러 제네릭 클래스, 함수 및 타입 별칭 간에 공유될 때 모든 참조는 의미론적으로 동일합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e중복되고 번거로운 이름:\u003c/strong\u003e 전역 스코프에 정의된 타입 변수는 모듈에 대해 비공개임을 나타내기 위해 밑줄로 시작하는 이름을 지정해야 합니다. 또한, 전역적으로 정의된 타입 변수에는 분산을 나타내는 이름이 주어지는 경우가 많아 \"_T_contra\" 및 \"_KT_co\"와 같이 번거로운 이름이 됩니다. 현재 타입 변수를 할당하는 메커니즘은 개발자가 따옴표 안에 중복된 이름(\"T\" = TypeVar(\"T\"))을 제공해야 합니다. 이 PEP는 중복된 이름과 번거로운 변수 이름의 필요성을 없앱니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003etyping\u003c/code\u003e 모듈 임포트의 필요성:\u003c/strong\u003e 현재 타입 매개변수를 정의하려면 \u003ccode\u003eTypeVar\u003c/code\u003e 및 \u003ccode\u003eGeneric\u003c/code\u003e 심볼을 \u003ccode\u003etyping\u003c/code\u003e 모듈에서 임포트해야 합니다. 지난 몇몇 Python 릴리스에서 일반적인 사용 사례에 대해 \u003ccode\u003etyping\u003c/code\u003e 심볼을 임포트할 필요성을 없애려는 노력이 있었고, 이 PEP는 이 목표를 더욱 발전시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e요약 예시 (Summary Examples)\u003c/h2\u003e\n\u003cp\u003e이 PEP 이전의 제네릭 클래스 정의는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Generic, TypeVar\r\n\r\n_T_co = TypeVar(\"_T_co\", covariant=True, bound=str)\r\n\r\nclass ClassA(Generic[_T_co]):\r\n    def method1(self) -\u003e _T_co:\r\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 구문으로는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass ClassA[T: str]:\r\n    def method1(self) -\u003e T:\r\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 제네릭 함수의 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import TypeVar\r\n\r\n_T = TypeVar(\"_T\")\r\n\r\ndef func(a: _T, b: _T) -\u003e _T:\r\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 구문으로는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef func[T](a: T, b: T) -\u003e T:\r\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 제네릭 타입 별칭의 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import TypeAlias\r\n\r\n_T = TypeVar(\"_T\")\r\nListOrSet: TypeAlias = list[_T] | set[_T]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 구문으로는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etype ListOrSet[T] = list[T] | set[T]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003ch3\u003e타입 매개변수 선언 (Type Parameter Declarations)\u003c/h3\u003e\n\u003cp\u003e제네릭 클래스, 함수 및 타입 별칭에 대한 타입 매개변수를 선언하는 새로운 구문은 다음과 같습니다. 이 구문은 클래스, 함수 또는 타입 별칭의 이름 뒤에 대괄호 안에 쉼표로 구분된 타입 매개변수 목록을 추가하는 것을 지원합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e단순(비가변) 타입 변수는 꾸밈 없는 이름으로 선언됩니다.\u003c/li\u003e\n\u003cli\u003e가변 타입 변수는 \u003ccode\u003e*\u003c/code\u003e가 앞에 붙습니다 (자세한 내용은 PEP 646 참조).\u003c/li\u003e\n\u003cli\u003e매개변수 사양(ParamSpec)은 \u003ccode\u003e**\u003c/code\u003e가 앞에 붙습니다 (자세한 내용은 PEP 612 참조).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 이 제네릭 클래스는 TypeVar T, TypeVarTuple Ts, ParamSpec P로 매개변수화됩니다.\r\nclass ChildClass[T, *Ts, **P]:\r\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eGeneric\u003c/code\u003e을 기본 클래스로 포함할 필요가 없습니다. 타입 매개변수의 존재에 의해 \u003ccode\u003eGeneric\u003c/code\u003e의 포함이 암시되며, 클래스의 \u003ccode\u003e__mro__\u003c/code\u003e 및 \u003ccode\u003e__orig_bases__\u003c/code\u003e 속성에 자동으로 포함됩니다. \u003ccode\u003eGeneric\u003c/code\u003e 기본 클래스를 명시적으로 사용하면 런타임 오류가 발생합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass ClassA[T](Generic[T]): # 런타임 오류\r\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e타입 인수를 포함하는 \u003ccode\u003eProtocol\u003c/code\u003e 기본 클래스는 런타임 오류를 생성할 수 있습니다. 타입 검사기는 이 경우 오류를 생성해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass ClassA[S, T](Protocol): # OK\r\n    ...\r\nclass ClassB[S, T](Protocol[S, T]): # 타입 검사기 오류 권장\r\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제네릭 클래스, 함수 또는 타입 별칭 내의 타입 매개변수 이름은 해당 클래스, 함수 또는 타입 별칭 내에서 고유해야 합니다. 중복된 이름은 컴파일 시 구문 오류를 생성합니다.\u003c/p\u003e\n\u003ch3\u003e상한선 지정 (Upper Bound Specification)\u003c/h3\u003e\n\u003cp\u003e비가변(non-variadic) 타입 매개변수의 경우, 타입 어노테이션(type annotation) 표현식을 사용하여 \"상한선(upper bound)\" 타입을 지정할 수 있습니다. 상한선이 지정되지 않으면 \u003ccode\u003eobject\u003c/code\u003e가 상한선으로 가정됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass ClassA[T: str]:\r\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지정된 상한선 타입은 타입 어노테이션에서 허용되는 표현식 형태를 사용해야 합니다. 따옴표로 묶인 전방 참조(forward references)는 허용됩니다. 상한선 타입은 구체적(concrete)이어야 하며, 제네릭 타입을 사용하려는 시도는 타입 검사기에 의해 오류로 플래그되어야 합니다.\u003c/p\u003e\n\u003ch3\u003e제약된 타입 지정 (Constrained Type Specification)\u003c/h3\u003e\n\u003cp\u003ePEP 484는 두 개 이상의 타입으로 제약되는 \"제약된 타입 변수(constrained type variable)\" 개념을 도입했습니다. 새로운 구문은 두 개 이상의 타입을 포함하는 리터럴 튜플 표현식을 사용하여 이러한 타입의 제약을 지원합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass ClassA[AnyStr: (str, bytes)]: # OK\r\n    ...\r\nclass ClassB[T: (\"ForwardReference\", bytes)]: # OK\r\n    ...\r\nclass ClassC[T: ()]: # 타입 검사기 오류: 두 개 이상의 타입 필요\r\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e런타임에서의 상한선 및 제약 표현 (Runtime Representation of Bounds and Constraints)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eTypeVar\u003c/code\u003e 객체의 상한선과 제약은 런타임에 \u003ccode\u003e__bound__\u003c/code\u003e 및 \u003ccode\u003e__constraints__\u003c/code\u003e 속성을 통해 접근할 수 있습니다. 새로운 구문을 통해 정의된 \u003ccode\u003eTypeVar\u003c/code\u003e 객체의 경우, 이러한 속성은 아래 \"지연 평가(Lazy Evaluation)\"에서 설명하는 대로 지연 평가됩니다.\u003c/p\u003e\n\u003ch3\u003e제네릭 타입 별칭 (Generic Type Alias)\u003c/h3\u003e\n\u003cp\u003e타입 별칭을 선언하기 위한 새로운 \u003ccode\u003etype\u003c/code\u003e 문을 도입합니다. \u003ccode\u003eclass\u003c/code\u003e 및 \u003ccode\u003edef\u003c/code\u003e 문과 유사하게, \u003ccode\u003etype\u003c/code\u003e 문은 타입 매개변수에 대한 스코프(scope)를 정의합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 비제네릭 타입 별칭\r\ntype IntOrStr = int | str\r\n# 제네릭 타입 별칭\r\ntype ListOrSet[T] = list[T] | set[T]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e타입 별칭은 따옴표를 사용하지 않고도 자신을 참조할 수 있습니다 (재귀 타입 별칭). \u003ccode\u003etype\u003c/code\u003e 키워드는 새로운 소프트 키워드(soft keyword)입니다.\u003c/p\u003e\n\u003ch3\u003e런타임 타입 별칭 클래스 (Runtime Type Alias Class)\u003c/h3\u003e\n\u003cp\u003e런타임에 \u003ccode\u003etype\u003c/code\u003e 문은 \u003ccode\u003etyping.TypeAliasType\u003c/code\u003e의 인스턴스를 생성합니다. 이 클래스는 타입 별칭을 나타내며, \u003ccode\u003e__name__\u003c/code\u003e, \u003ccode\u003e__type_params__\u003c/code\u003e, \u003ccode\u003e__value__\u003c/code\u003e와 같은 속성을 가집니다. 이 모든 속성은 읽기 전용입니다. 타입 별칭의 값은 지연 평가됩니다.\u003c/p\u003e\n\u003ch3\u003e타입 매개변수 스코프 (Type Parameter Scopes)\u003c/h3\u003e\n\u003cp\u003e새로운 구문이 사용될 때, 새로운 렉시컬 스코프(lexical scope)가 도입되고 이 스코프는 타입 매개변수를 포함합니다. 타입 매개변수는 내부 스코프에서 이름으로 접근할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e타입 매개변수는 목록의 다른 곳에 선언된 다른 타입 매개변수에게 가시적입니다.\u003c/li\u003e\n\u003cli\u003e제네릭 클래스의 일부로 선언된 타입 매개변수는 클래스 본문 및 그 안에 포함된 내부 스코프 내에서 유효합니다.\u003c/li\u003e\n\u003cli\u003e제네릭 함수의 일부로 선언된 타입 매개변수는 함수 본문 및 그 안에 포함된 스코프 내에서 유효하며, 매개변수 및 반환 타입 어노테이션 내에서도 유효합니다.\u003c/li\u003e\n\u003cli\u003e제네릭 타입 별칭의 일부로 선언된 타입 매개변수는 타입 별칭 표현식 내에서 유효합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e새로운 타입 매개변수 구문으로 도입된 렉시컬 스코프는 \u003ccode\u003edef\u003c/code\u003e 또는 \u003ccode\u003eclass\u003c/code\u003e 문으로 도입된 전통적인 스코프와 다릅니다. 타입 매개변수 스코프는 포함하는 스코프에 대한 임시 \"오버레이(overlay)\"처럼 작동합니다.\u003c/p\u003e\n\u003ch3\u003e런타임에서 타입 매개변수 접근 (Accessing Type Parameters at Runtime)\u003c/h3\u003e\n\u003cp\u003e제네릭 클래스, 함수 및 타입 별칭에 \u003ccode\u003e__type_params__\u003c/code\u003e라는 새로운 속성이 제공됩니다. 이 속성은 클래스, 함수 또는 별칭을 매개변수화하는 타입 매개변수(TypeVar, ParamSpec, TypeVarTuple 인스턴스)의 튜플입니다.\u003c/p\u003e\n\u003ch3\u003e분산 추론 (Variance Inference)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 타입 매개변수에 대한 분산을 명시할 필요성을 없앱니다. 대신, 타입 검사기는 클래스 내에서의 사용법에 따라 타입 매개변수의 분산(invariant, covariant, contravariant)을 추론합니다.\u003c/p\u003e\n\u003cp\u003e분산 추론 알고리즘은 다음과 같습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e타입 매개변수가 가변(TypeVarTuple)이거나 매개변수 사양(ParamSpec)인 경우, 항상 \u003ccode\u003einvariant\u003c/code\u003e로 간주됩니다.\u003c/li\u003e\n\u003cli\u003e타입 매개변수가 \u003ccode\u003einfer_variance\u003c/code\u003e로 지정되지 않은 전통적인 \u003ccode\u003eTypeVar\u003c/code\u003e 선언에서 온 경우, 분산은 \u003ccode\u003eTypeVar\u003c/code\u003e 생성자 호출에 의해 지정됩니다.\u003c/li\u003e\n\u003cli\u003e클래스의 두 가지 특수화된 버전(\u003ccode\u003eupper\u003c/code\u003e 및 \u003ccode\u003elower\u003c/code\u003e)을 생성하여 해당 타입 매개변수의 호환성을 확인합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elower\u003c/code\u003e가 \u003ccode\u003eupper\u003c/code\u003e에 할당 가능한지, \u003ccode\u003eupper\u003c/code\u003e가 \u003ccode\u003elower\u003c/code\u003e에 할당 가능한지 여부에 따라 \u003ccode\u003ecovariant\u003c/code\u003e, \u003ccode\u003econtravariant\u003c/code\u003e, \u003ccode\u003einvariant\u003c/code\u003e를 결정합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eTypeVar에 대한 자동 분산 (Auto Variance For TypeVar)\u003c/h3\u003e\n\u003cp\u003e기존 \u003ccode\u003eTypeVar\u003c/code\u003e 클래스 생성자는 \u003ccode\u003ecovariant\u003c/code\u003e 및 \u003ccode\u003econtravariant\u003c/code\u003e 키워드 매개변수를 받습니다. 이 둘 다 \u003ccode\u003eFalse\u003c/code\u003e이면 타입 변수는 \u003ccode\u003einvariant\u003c/code\u003e로 가정됩니다. 이 PEP는 \u003ccode\u003einfer_variance\u003c/code\u003e라는 또 다른 키워드 매개변수를 추가하여 타입 검사기가 타입 변수가 \u003ccode\u003einvariant\u003c/code\u003e, \u003ccode\u003ecovariant\u003c/code\u003e, \u003ccode\u003econtravariant\u003c/code\u003e 중 어느 것인지 추론하도록 지시할 것을 제안합니다.\u003c/p\u003e\n\u003ch3\u003e기존 TypeVar와의 호환성 (Compatibility with Traditional TypeVars)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eTypeVar\u003c/code\u003e, \u003ccode\u003eTypeVarTuple\u003c/code\u003e, \u003ccode\u003eParamSpec\u003c/code\u003e을 할당하는 기존 메커니즘은 하위 호환성을 위해 유지됩니다. 그러나 이러한 \"전통적인\" 타입 변수는 새로운 구문을 사용하여 할당된 타입 매개변수와 결합해서는 안 됩니다. 이러한 결합은 타입 검사기에 의해 오류로 플래그되어야 합니다.\u003c/p\u003e\n\u003ch2\u003e런타임 구현 (Runtime Implementation)\u003c/h2\u003e\n\u003ch3\u003e문법 변경 (Grammar Changes)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 새로운 소프트 키워드 \u003ccode\u003etype\u003c/code\u003e를 도입합니다. 클래스 및 \u003ccode\u003edef\u003c/code\u003e 문에 선택적 타입 매개변수 절을 추가하고, 타입 별칭 정의를 위한 새로운 \u003ccode\u003etype\u003c/code\u003e 문을 추가하는 방식으로 문법을 수정합니다.\u003c/p\u003e\n\u003ch3\u003eAST 변경 (AST Changes)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003eTypeAlias\u003c/code\u003e라는 새로운 AST(Abstract Syntax Tree) 노드 타입을 도입합니다. 또한 타입 매개변수를 나타내는 AST 노드 타입 (\u003ccode\u003eTypeVar\u003c/code\u003e, \u003ccode\u003eParamSpec\u003c/code\u003e, \u003ccode\u003eTypeVarTuple\u003c/code\u003e)을 추가합니다. 기존 \u003ccode\u003eFunctionDef\u003c/code\u003e, \u003ccode\u003eAsyncFunctionDef\u003c/code\u003e, \u003ccode\u003eClassDef\u003c/code\u003e AST 노드 타입은 함수 또는 클래스와 관련된 타입 매개변수 목록을 포함하는 \u003ccode\u003etypeparams\u003c/code\u003e라는 선택적 속성을 포함하도록 수정됩니다.\u003c/p\u003e\n\u003ch3\u003e지연 평가 (Lazy Evaluation)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003eTypeVar\u003c/code\u003e 경계, \u003ccode\u003eTypeVar\u003c/code\u003e 제약 및 타입 별칭의 값을 나타내는 표현식이 나타날 수 있는 세 가지 새로운 컨텍스트를 도입합니다. 이러한 표현식은 아직 정의되지 않은 이름에 대한 참조를 포함할 수 있습니다. PEP 563 및 PEP 649와 유사하게, 이러한 표현식은 런타임 오류를 방지하기 위해 지연 평가(lazy evaluation)를 사용합니다. 각 표현식은 코드 객체로 저장되며, 해당 속성(\u003ccode\u003eTypeVar.__bound__\u003c/code\u003e, \u003ccode\u003eTypeVar.__constraints__\u003c/code\u003e, \u003ccode\u003eTypeAlias.__value__\u003c/code\u003e)이 접근될 때만 평가됩니다.\u003c/p\u003e\n\u003ch3\u003e스코프 동작 (Scoping Behavior)\u003c/h3\u003e\n\u003cp\u003e새로운 구문은 기존 Python 스코프와 다르게 동작하는 새로운 종류의 스코프를 필요로 합니다. 새로운 스코프는 함수 스코프와 유사하게 동작하지만, 몇 가지 사소한 차이점이 있습니다. 특히, 클래스 스코프 내에 즉시 위치하는 경우, 클래스 스코프에 정의된 이름에 접근할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e라이브러리 변경 (Library Changes)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003etyping\u003c/code\u003e 모듈의 여러 클래스(\u003ccode\u003eTypeVar\u003c/code\u003e, \u003ccode\u003eTypeVarTuple\u003c/code\u003e, \u003ccode\u003eParamSpec\u003c/code\u003e, \u003ccode\u003eGeneric\u003c/code\u003e 및 새로운 \u003ccode\u003eTypeAliasType\u003c/code\u003e)는 C로 부분적으로 구현되어야 합니다.\u003c/p\u003e\n\u003ch2\u003e참조 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003e이 제안은 CPython PR #103764에서 프로토타입으로 구현되었습니다. Pyright 타입 검사기는 이 PEP에 설명된 동작을 지원합니다.\u003c/p\u003e\n\u003ch2\u003e거부된 아이디어 (Rejected Ideas)\u003c/h2\u003e\n\u003ch3\u003e접두사 절 (Prefix Clause)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edef\u003c/code\u003e 및 \u003ccode\u003eclass\u003c/code\u003e 문 앞에 타입 매개변수를 지정하는 다양한 구문 옵션이 탐색되었으나, 스코핑 규칙이 불분명하고 데코레이터와 잘 작동하지 않아 거부되었습니다.\u003c/p\u003e\n\u003ch3\u003e꺽쇠 괄호 (Angle Brackets)\u003c/h3\u003e\n\u003cp\u003e다른 많은 언어에서 제네릭에 꺽쇠 괄호(\u003ccode\u003e\u0026#x3C;\u003e\u003c/code\u003e)를 사용하지만, Python에서는 라인 브레이크 처리 문제와 \u003ccode\u003elist[int]\u003c/code\u003e와 같이 명시적인 특수화에 이미 대괄호(\u003ccode\u003e[]\u003c/code\u003e)를 사용하는 기존 관행과의 불일치 때문에 거부되었습니다.\u003c/p\u003e\n\u003ch3\u003e경계 구문 (Bounds Syntax)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eScala\u003c/code\u003e의 \u003ccode\u003e\u0026#x3C;:\u003c/code\u003e 토큰, \u003ccode\u003eextends\u003c/code\u003e 또는 \u003ccode\u003ewith\u003c/code\u003e 키워드, \u003ccode\u003etyping.TypeVar\u003c/code\u003e 생성자와 유사한 함수 호출 구문 등 다양한 경계 및 제약 구문이 고려되었으나, 단순한 콜론(\u003ccode\u003e:\u003c/code\u003e) 구문이 다른 많은 프로그래밍 언어와 일치하고 설문조사에서 Python 개발자들에게 크게 선호되어 채택되었습니다.\u003c/p\u003e\n\u003ch3\u003e명시적 분산 (Explicit Variance)\u003c/h3\u003e\n\u003cp\u003e타입 매개변수가 \u003ccode\u003einvariant\u003c/code\u003e, \u003ccode\u003ecovariant\u003c/code\u003e, \u003ccode\u003econtravariant\u003c/code\u003e 중 무엇인지 명시적으로 지정하는 구문을 추가하는 것이 고려되었으나, 분산은 일반적으로 추론될 수 있으며 대부분의 현대 프로그래밍 언어가 사용법을 기반으로 분산을 추론하기 때문에 거부되었습니다.\u003c/p\u003e\n\u003ch3\u003e이름 변환 (Name Mangling)\u003c/h3\u003e\n\u003cp\u003e각 타입 매개변수에 컴파일러가 고유한 \"변환된(mangled)\" 이름을 부여하는 접근 방식이 고려되었으나, 정규화된 이름이 반드시 고유하지 않다는 문제와 따옴표로 묶인 (전방 참조) 타입 어노테이션을 평가하는 기술과 호환되지 않는다는 문제로 거부되었습니다.\u003c/p\u003e\n\u003ch2\u003e부록 A: 타입 매개변수 구문 조사 (Appendix A: Survey of Type Parameter Syntax)\u003c/h2\u003e\n\u003cp\u003e이 섹션에서는 제네릭 타입을 지원하는 다른 인기 있는 프로그래밍 언어에서 사용되는 옵션에 대한 조사를 제공합니다.\u003c/p\u003e\n\u003cp\u003e다음은 다양한 언어의 타입 매개변수 구문 요약입니다.\u003c/p\u003e\n\u003cp\u003e| 언어            | 선언 구문 | 상한선     | 하한선    | 기본값 | 분산 사이트 | 분산             |\r\n| :-------------- | :-------- | :--------- | :-------- | :----- | :---------- | :--------------- |\r\n| \u003cstrong\u003eC++\u003c/strong\u003e         | \u003ccode\u003etemplate \u0026#x3C;\u003e\u003c/code\u003e | n/a        | n/a       | \u003ccode\u003e=\u003c/code\u003e    | n/a         | n/a              |\r\n| \u003cstrong\u003eJava\u003c/strong\u003e        | \u003ccode\u003e\u0026#x3C;\u003e\u003c/code\u003e      | \u003ccode\u003eextends\u003c/code\u003e  | \u003ccode\u003esuper\u003c/code\u003e   | n/a    | 사용 (use)  | \u003ccode\u003esuper\u003c/code\u003e, \u003ccode\u003eextends\u003c/code\u003e |\r\n| \u003cstrong\u003eC#\u003c/strong\u003e          | \u003ccode\u003e\u0026#x3C;\u003e\u003c/code\u003e      | \u003ccode\u003ewhere\u003c/code\u003e    | n/a       | n/a    | 선언 (decl) | \u003ccode\u003ein\u003c/code\u003e, \u003ccode\u003eout\u003c/code\u003e      |\r\n| \u003cstrong\u003eTypeScript\u003c/strong\u003e  | \u003ccode\u003e\u0026#x3C;\u003e\u003c/code\u003e      | \u003ccode\u003eextends\u003c/code\u003e  | n/a       | \u003ccode\u003e=\u003c/code\u003e    | 선언 (decl) | 추론, \u003ccode\u003ein\u003c/code\u003e, \u003ccode\u003eout\u003c/code\u003e |\r\n| \u003cstrong\u003eScala\u003c/strong\u003e       | \u003ccode\u003e[]\u003c/code\u003e      | \u003ccode\u003eT \u0026#x3C;: X\u003c/code\u003e   | \u003ccode\u003eT \u003e: X\u003c/code\u003e  | n/a    | 사용, 선언  | \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e         |\r\n| \u003cstrong\u003eSwift\u003c/strong\u003e       | \u003ccode\u003e\u0026#x3C;\u003e\u003c/code\u003e      | \u003ccode\u003eT: X\u003c/code\u003e     | n/a       | n/a    | n/a         | n/a              |\r\n| \u003cstrong\u003eRust\u003c/strong\u003e        | \u003ccode\u003e\u0026#x3C;\u003e\u003c/code\u003e      | \u003ccode\u003eT: X\u003c/code\u003e, \u003ccode\u003ewhere\u003c/code\u003e | n/a    | \u003ccode\u003e=\u003c/code\u003e    | n/a         | n/a              |\r\n| \u003cstrong\u003eKotlin\u003c/strong\u003e      | \u003ccode\u003e\u0026#x3C;\u003e\u003c/code\u003e      | \u003ccode\u003eT: X\u003c/code\u003e, \u003ccode\u003ewhere\u003c/code\u003e | n/a    | n/a    | 사용, 선언  | \u003ccode\u003ein\u003c/code\u003e, \u003ccode\u003eout\u003c/code\u003e      |\r\n| \u003cstrong\u003eJulia\u003c/strong\u003e       | \u003ccode\u003e{}\u003c/code\u003e      | \u003ccode\u003eT \u0026#x3C;: X\u003c/code\u003e   | \u003ccode\u003eX \u0026#x3C;: T\u003c/code\u003e  | n/a    | n/a         | n/a              |\r\n| \u003cstrong\u003eDart\u003c/strong\u003e        | \u003ccode\u003e\u0026#x3C;\u003e\u003c/code\u003e      | \u003ccode\u003eextends\u003c/code\u003e  | n/a       | n/a    | 선언 (decl) | \u003ccode\u003ein\u003c/code\u003e, \u003ccode\u003eout\u003c/code\u003e, \u003ccode\u003einout\u003c/code\u003e |\r\n| \u003cstrong\u003eGo\u003c/strong\u003e          | \u003ccode\u003e[]\u003c/code\u003e      | \u003ccode\u003eT X\u003c/code\u003e      | n/a       | n/a    | n/a         | n/a              |\r\n| \u003cstrong\u003ePython (제안)\u003c/strong\u003e | \u003ccode\u003e[]\u003c/code\u003e      | \u003ccode\u003eT: X\u003c/code\u003e     | n/a       | n/a    | 선언 (decl) | 추론             |\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1318,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 695 - Type Parameter Syntax\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 13:03:44+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>