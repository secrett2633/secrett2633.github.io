3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-d79d6340e7770dba.js","185","static/chunks/app/layout-b06e577e11976c7d.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js"],""]
4:["slug","python/pep/389","c"]
0:["qNOrJYeuqip9qCFPpDVpu",[[["",{"children":[["slug","python/pep/389","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"389\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/389","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e975486d410ad4e9.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T8509,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0389/">PEP 389 - argparse - New Command Line Parsing Module</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 25-Sep-2009</p>
</blockquote>
<h1>PEP 389 – argparse - 새로운 커맨드 라인 파싱 모듈</h1>
<h2>개요</h2>
<p>이 PEP는 Python 2.7 및 3.2 표준 라이브러리에 <code>argparse</code> 모듈을 포함할 것을 제안합니다.</p>
<h2>동기</h2>
<p><code>argparse</code> 모듈은 표준 라이브러리의 기존 커맨드 라인 파싱 모듈인 <code>getopt</code> 및 <code>optparse</code>보다 더 많은 기능을 제공하는 커맨드 라인 파싱 라이브러리입니다. 이 모듈은 위치 인수(옵션뿐만 아니라), 서브커맨드, 필수 옵션, “/f” 및 “+rgb”와 같은 옵션 문법, 0개 이상 및 1개 이상 스타일 인수, 그리고 다른 두 모듈에는 없는 여러 기능을 지원합니다.</p>
<p><code>argparse</code> 모듈은 이미 이들 모듈의 인기 있는 서드파티 대체재로 자리매김했습니다. IPython (Scipy Python 셸)과 같은 프로젝트에서 사용되며, Debian testing 및 unstable에 포함되어 있고, 2007년부터 표준 라이브러리 포함 요청이 여러 차례 있었습니다. 이러한 인기는 <code>argparse</code>가 Python 라이브러리에 유용한 추가 기능이 될 수 있음을 시사합니다.</p>
<h3><code>getopt</code>와 <code>optparse</code>로는 부족한 이유</h3>
<p><code>argparse</code> 추가에 반대하는 한 가지 주장은 "표준 라이브러리에 이미 두 가지 다른 옵션 파싱 모듈이 있다"는 것입니다. 다음은 <code>argparse</code>에서 제공하지만 <code>getopt</code> 또는 <code>optparse</code>에는 없는 기능 목록입니다.</p>
<ul>
<li>두 가지 옵션 파싱 라이브러리가 있는 것은 사실이지만, 완전한 커맨드 라인 파싱 라이브러리는 없습니다. <code>getopt</code>와 <code>optparse</code>는 모두 옵션만 지원하며 위치 인수는 지원하지 않습니다. <code>argparse</code> 모듈은 둘 다 처리하며, 그 결과 더 나은 도움말 메시지를 생성하여 <code>optparse</code>에서 일반적으로 필요한 <code>usage=</code> 문자열과 같은 중복을 피할 수 있습니다.</li>
<li><code>argparse</code> 모듈은 순수성보다는 실용성을 중요하게 생각합니다. 따라서 <code>argparse</code>는 필수 옵션과 옵션을 식별하는 데 사용되는 문자를 사용자 정의할 수 있도록 허용합니다. 반면 <code>optparse</code>는 "필수 옵션이라는 문구는 자체 모순"이라고 명시하며 <code>-pf</code>, <code>-file</code>, <code>+f</code>, <code>+rgb</code>, <code>/f</code>, <code>/file</code>과 같은 옵션 문법은 <code>optparse</code>에서 지원되지 않으며 앞으로도 지원되지 않을 것이라고 밝힙니다.</li>
<li><code>argparse</code> 모듈은 <code>nargs='?'</code>, <code>nargs='*'</code>, 또는 <code>nargs='+'</code>를 사용하여 가변 개수의 인수를 허용하도록 옵션을 설정할 수 있습니다. <code>optparse</code> 모듈은 이 기능의 일부에 대한 검증되지 않은 레시피를 제공하지만, "옵션이 가변 개수의 인수를 가져야 할 때 상황이 복잡해진다"고 인정합니다.</li>
<li><code>argparse</code> 모듈은 서브커맨드를 지원합니다. 여기서 주 커맨드 라인 파서가 커맨드 라인 인수에 따라 다른 커맨드 라인 파서로 디스패치됩니다. 이는 <code>svn co</code> 및 <code>svn up</code>과 같은 커맨드 라인 인터페이스에서 일반적인 패턴입니다.</li>
</ul>
<h3>기능이 <code>optparse</code>에 추가되지 않는 이유</h3>
<p>위의 모든 기능이 <code>optparse</code>에서 제공되는 것보다 개선된 기능을 제공한다는 것은 분명합니다. 그렇다면 이러한 기능들이 완전히 새로운 모듈을 도입하는 대신 <code>optparse</code>에 패치로 제공되지 않는 이유에 대한 합리적인 질문이 있을 수 있습니다. 사실, <code>argparse</code>의 초기 개발은 그렇게 하려고 했지만, <code>optparse</code>의 여러 가지 상당히 제약적인 설계 결정 때문에 실제로 가능하지 않았습니다. 몇 가지 문제는 다음과 같습니다.</p>
<ul>
<li>
<p><code>optparse</code> 모듈은 파싱 알고리즘의 내부를 노출합니다. 특히, <code>parser.largs</code> 및 <code>parser.rargs</code>는 콜백에 항상 제공된다는 보장이 있습니다. 이는 <code>argparse</code>에서 위치 인수 및 가변 길이 인수를 올바르게 처리하는 데 필요했던 파싱 알고리즘을 개선하는 것을 극도로 어렵게 만듭니다. 예를 들어, <code>argparse</code>의 <code>nargs='+'</code>는 정규 표현식을 사용하여 일치시키므로 <code>parser.largs</code>와 같은 개념이 없습니다.</p>
</li>
<li>
<p><code>optparse</code> 확장 API는 매우 복잡합니다. 예를 들어, 간단한 사용자 정의 문자열-객체 변환 함수를 사용하려면 <code>Option</code>을 서브클래싱하고, 클래스 속성을 해킹하고, 다음과 같이 사용자 정의 옵션 타입을 파서에 지정해야 합니다.</p>
<pre><code class="language-python">class MyOption(Option):
    TYPES = Option.TYPES + ("mytype",)
    TYPE_CHECKER = copy(Option.TYPE_CHECKER)
    TYPE_CHECKER["mytype"] = check_mytype

parser = optparse.OptionParser(option_class=MyOption)
parser.add_option("-m", type="mytype")
</code></pre>
<p>비교를 위해 <code>argparse</code>는 단순히 변환 함수를 <code>type=</code> 인수로 직접 사용할 수 있도록 합니다.</p>
<pre><code class="language-python">parser = argparse.ArgumentParser()
parser.add_option("-m", type=check_mytype)
</code></pre>
<p>그러나 <code>optparse</code>의 복잡한 사용자 정의 API를 고려할 때, 이러한 기능이 해당 API와 어떻게 상호 작용해야 하는지 불분명하며, 간단한 <code>argparse</code> API를 도입하면 기존의 사용자 정의 <code>Option</code> 코드가 손상될 가능성이 높습니다.</p>
</li>
<li>
<p><code>optparse</code>와 <code>argparse</code>는 모두 커맨드 라인 인수를 파싱하고 <code>parse_args</code>가 반환하는 객체에 속성으로 할당합니다. 그러나 <code>optparse</code> 모듈은 사용자 정의 액션의 <code>take_action</code> 메서드에 항상 <code>ensure_value</code> 메서드를 제공하는 <code>values</code> 객체가 전달될 것을 보장하지만, <code>argparse</code> 모듈은 속성을 모든 객체에 할당할 수 있도록 허용합니다.</p>
<pre><code class="language-python">foo_object = ...
parser.parse_args(namespace=foo_object)
foo_object.some_attribute_parsed_from_command_line
</code></pre>
<p><code>optparse</code>를 수정하여 <code>Values</code> 인스턴스 대신 모든 객체를 전달할 수 있도록 하는 것은 <code>ensure_value</code> 메서드에 의존하는 기존의 사용자 정의 액션을 손상시킬 것이기 때문에 어려울 것입니다.</p>
</li>
</ul>
<p>이와 같은 문제들로 인해 <code>argparse</code>가 <code>optparse</code> API와의 호환성을 유지하기가 불합리하게 어려워졌기 때문에 <code>argparse</code>는 독립적인 모듈로 개발되었습니다. 이러한 문제들을 고려할 때, <code>argparse</code>의 모든 기능을 하위 호환성 없이 <code>optparse</code>에 병합하는 것은 불가능해 보입니다.</p>
<h2><code>optparse</code>의 Deprecation (사용 중단)</h2>
<p><code>optparse</code>의 모든 기능이 <code>argparse</code>에서 사용 가능하므로 <code>optparse</code> 모듈은 Deprecated (사용 중단)될 것입니다. 그러나 <code>optparse</code>의 광범위한 사용으로 인해 Deprecation 전략은 기본적으로 표시되지 않는 문서 변경 및 경고만 포함합니다.</p>
<ul>
<li><strong>Python 2.7+ 및 3.2+</strong>: <code>optparse</code> 문서에 다음 내용이 추가될 것입니다.
<blockquote>
<p><code>optparse</code> 모듈은 Deprecated되었으며 더 이상 개발되지 않을 것입니다. 개발은 <code>argparse</code> 모듈로 계속될 것입니다.</p>
</blockquote>
</li>
<li><strong>Python 2.7+</strong>: 커맨드 라인에서 Python 3 호환성 플래그인 <code>-3</code>가 제공되면 <code>optparse</code>를 import할 때 <code>DeprecationWarning</code>이 발생합니다. 그렇지 않으면 경고가 발생하지 않습니다.</li>
<li><strong>Python 3.2+</strong>: <code>optparse</code>를 import할 때 <code>PendingDeprecationWarning</code>이 발생하며, 이는 기본적으로 표시되지 않습니다.</li>
</ul>
<p><code>optparse</code>의 제거 날짜는 제안되지 않았다는 점에 유의하십시오.</p>
<h2><code>getopt</code> 문서 업데이트</h2>
<p><code>getopt</code> 모듈은 Deprecated되지 않을 것입니다. 그러나 <code>argparse</code>를 가리키도록 문서가 여러 곳에서 업데이트될 것입니다. 모듈 상단에는 다음 내용이 추가될 것입니다.</p>
<blockquote>
<p><code>getopt</code> 모듈은 C <code>getopt</code> 함수의 사용자에게 친숙하도록 API가 설계된 커맨드 라인 옵션 파서입니다. C <code>getopt</code> 함수에 익숙하지 않거나 더 적은 코드를 작성하고 더 나은 도움말 및 오류 메시지를 얻고 싶은 사용자는 대신 <code>argparse</code> 모듈을 사용하는 것을 고려해야 합니다.</p>
</blockquote>
<p>또한, 최종 <code>getopt</code> 예제 뒤에 다음 내용이 추가될 것입니다.</p>
<blockquote>
<p>동일한 커맨드 라인 인터페이스를 <code>argparse</code> 모듈을 사용하여 더 적은 코드로 생성할 수 있습니다.</p>
</blockquote>
<pre><code class="language-python">import argparse

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-o', '--output')
    parser.add_argument('-v', dest='verbose', action='store_true')
    args = parser.parse_args()
    # ... do something with args.output ...
    # ... do something with args.verbose ..
</code></pre>
<h2>연기된 사항: 문자열 포매팅</h2>
<p><code>argparse</code> 모듈은 Python 2.3부터 3.2까지 지원하며, 그 결과 전통적인 <code>%(foo)s</code> 스타일 문자열 포매팅에 의존합니다. 새로운 스타일 <code>{foo}</code> 문자열 포매팅을 사용하는 것이 더 나을 수 있다는 제안이 있었습니다. 표준 라이브러리의 모듈에 대해 이를 가장 잘 수행하는 방법에 대한 논의가 있었고, 몇몇 사람들은 <code>%</code>-포매팅을 <code>{}</code>-포매팅으로 자동 변환하는 함수를 개발하고 있습니다. 이들 중 하나가 표준 라이브러리에 추가되면 <code>argparse</code>는 이를 사용하여 두 가지 포매팅 스타일을 모두 지원할 것입니다.</p>
<h2>거부된 사항: <code>getopt</code> 호환성 메서드</h2>
<p>이 PEP가 <code>getopt</code>와 <code>optparse</code>의 Deprecation을 모두 제안했을 때, 다음과 같은 메서드를 추가하는 것에 대한 논의가 있었습니다.</p>
<pre><code class="language-python">ArgumentParser.add_getopt_arguments(options[, long_options])
</code></pre>
<p>그러나 이 메서드는 여러 이유로 추가되지 않을 것입니다.</p>
<ul>
<li><code>getopt</code> 모듈이 Deprecated되지 않으므로 필요성이 줄어들었습니다.</li>
<li>이 메서드는 <code>usage</code> 메시지를 이미 유지하고 있던 <code>getopt</code> 사용자에게 전환을 실제로 용이하게 하지 않을 것입니다. 위 API는 인수에 도움말 메시지를 추가하는 방법을 제공하지 않기 때문입니다.</li>
<li>일부 <code>getopt</code> 사용자는 단일 함수 호출만 필요하다는 것을 매우 중요하게 생각합니다. 위 API는 <code>ArgumentParser()</code>와 <code>parse_args()</code>를 모두 호출해야 하므로 이 요구 사항을 충족하지 않습니다.</li>
</ul>
<h2>범위 외: 다양한 기능 요청</h2>
<p>이 PEP 논의에서 <code>argparse</code>에 대한 몇 가지 기능 요청이 있었습니다.</p>
<ul>
<li>환경 변수에서 인수 기본값 지원</li>
<li>설정 파일에서 인수 기본값 지원</li>
<li>현재 지원되는 "foo subcommand --help" 외에 "foo --help subcommand" 지원</li>
</ul>
<p>이들은 모두 <code>argparse</code> 모듈에 대한 합리적인 기능 요청이지만, 이 PEP의 범위를 벗어나며 <code>argparse</code> 이슈 트래커로 리디렉션되었습니다.</p>
<h2>논의: <code>sys.stderr</code> 및 <code>sys.exit</code></h2>
<p><code>argparse</code>가 기본적으로 항상 <code>sys.stderr</code>에 쓰고 잘못된 인수가 제공될 때 항상 <code>sys.exit</code>를 호출한다는 점에 대한 우려가 있었습니다. 이는 단순한 커맨드 라인 인터페이스를 중심으로 하는 <code>argparse</code> 사용 사례의 대다수에서 원하는 동작입니다. 그러나 어떤 경우에는 <code>argparse</code>가 종료되지 않도록 하거나 메시지를 <code>sys.stderr</code> 이외의 다른 곳에 작성하도록 하는 것이 바람직할 수 있습니다. 이러한 사용 사례는 <code>ArgumentParser</code>를 서브클래싱하고 <code>exit</code> 또는 <code>_print_message</code> 메서드를 오버라이딩하여 지원할 수 있습니다. 후자는 문서화되지 않은 구현 세부 사항이지만, 이것이 일반적인 필요로 밝혀지면 공식적으로 노출될 수 있습니다.</p>
<h2>참조</h2>
<p><code>argparse</code> (http://code.google.com/p/argparse/)
<code>getopt</code> (http://docs.python.org/library/getopt.html)
<code>optparse</code> (http://docs.python.org/library/optparse.html)
IPython의 <code>argparse</code> (http://mail.scipy.org/pipermail/ipython-dev/2009-April/005102.html)
Debian의 <code>argparse</code> (http://packages.debian.org/search?keywords=argparse)
2007-01-03 표준 라이브러리에 <code>argparse</code> 포함 요청 (https://mail.python.org/pipermail/python-list/2007-January/472276.html)
2009-06-09 표준 라이브러리에 <code>argparse</code> 포함 요청 (http://bugs.python.org/issue6247)
2009-09-10 표준 라이브러리에 <code>argparse</code> 포함 요청 (https://mail.python.org/pipermail/stdlib-sig/2009-September/000342.html)
Fredrik Lundh의에 대한 응답 (https://mail.python.org/pipermail/python-list/2007-January/1086892.html)
<code>optparse</code> 가변 인수 (http://docs.python.org/library/optparse.html#callback-example-6-variable-arguments)
<code>parser.largs</code> 및 <code>parser.rargs</code> (http://docs.python.org/library/optparse.html#how-callbacks-are-called)
<code>take_action</code> <code>values</code> 인수 (http://docs.python.org/library/optparse.html#adding-new-actions)
<code>%</code>-포매팅 대신 <code>{}</code>-포매팅 사용 (http://bugs.python.org/msg89279)
<code>%</code>에서 <code>{}</code> 포매팅으로 전환 (https://mail.python.org/pipermail/python-dev/2009-September/092326.html)
Vinay Sajip의 <code>%</code>-에서-<code>{}</code> 변환기 (http://gist.github.com/200936)
Benjamin Peterson의 <code>%</code>-에서-<code>{}</code> 변환기 (http://bazaar.launchpad.net/~gutworth/+junk/mod2format/files)
Guido의 승인 (https://mail.python.org/pipermail/python-dev/2010-February/097839.html)</p>
<h2>저작권</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<hr>
<p>(Note: The acceptance section was very short and simply stated Guido's approval. I included it in the abstract section implicitly, but can add it explicitly if desired. For now, I'll keep it concise as the prompt asks to help developers understand the <em>proposal</em>, <em>background</em>, and <em>impact</em>, rather than minute historical details unless they contribute to the overall understanding of the module itself.)</p>
<p>Let me double check all the requirements:</p>
<ol>
<li><strong>전문성 유지:</strong> Python 생태계에서 통용되는 전문 용어를 정확하게 사용하세요.
<ul>
<li><code>argparse</code>, <code>getopt</code>, <code>optparse</code>, <code>PEP</code>, <code>module</code>, <code>standard library</code>, <code>positional arguments</code>, <code>options</code>, <code>subcommands</code>, <code>callbacks</code>, <code>deprecation</code>, <code>string formatting</code> 등 전문 용어들을 원문과 한국어 번역을 적절히 혼용하여 사용하거나 한국어화 했습니다.</li>
</ul>
</li>
<li><strong>용어 처리:</strong>
<ul>
<li>널리 쓰이는 한국어 용어가 있다면 사용합니다. (예: "표준 라이브러리", "위치 인수")</li>
<li>모호하거나 한국어보다 영어가 더 익숙한 용어는 영어 원문을 그대로 사용하거나 병기합니다. (예: <code>List Comprehension</code>은 없었지만 <code>Generator (제너레이터)</code> 같은 방식. 여기서는 <code>Deprecation (사용 중단)</code> 처럼 병기함.)</li>
<li>코드 내의 키워드(예: <code>async</code>, <code>await</code>, <code>class</code>, <code>def</code>)나 변수명은 절대 번역하지 마세요. (코드 블록의 키워드와 변수명은 번역하지 않았습니다.)</li>
</ul>
</li>
<li><strong>가독성:</strong> 마크다운을 적극 활용하여 구조적으로 정리해주세요. (제목, 소제목, 목록, 코드 블록 등을 활용했습니다.)</li>
<li><strong>번역 정확성:</strong> 번역 정확성을 보장하기 위해 원문 내용을 빠짐없이 마크다운 형태로 번역해주세요. (모든 섹션의 내용을 번역하고 Markdown으로 정리했습니다.)</li>
</ol>
<p>Looks good.The translation is complete and formatted according to the instructions.# PEP 389 – argparse - 새로운 커맨드 라인 파싱 모듈</p>
<h2>수락 (Acceptance)</h2>
<p>이 PEP는 2010년 2월 21일 Guido에 의해 <code>python-dev</code>에서 승인되었습니다.</p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 <code>argparse</code> 모듈을 Python 2.7 및 3.2 버전의 Python 표준 라이브러리에 포함할 것을 제안합니다.</p>
<h2>동기 (Motivation)</h2>
<p><code>argparse</code> 모듈은 표준 라이브러리에 이미 존재하는 커맨드 라인 파싱 모듈인 <code>getopt</code> 및 <code>optparse</code>보다 더 많은 기능을 제공하는 커맨드 라인 파싱 라이브러리입니다. 이 모듈은 위치 인수(옵션뿐만 아니라), 서브커맨드(subcommands), 필수 옵션, “/f” 및 “+rgb”와 같은 옵션 문법, 0개 이상 및 1개 이상 스타일 인수 등 기존 두 모듈에는 없는 다양한 기능을 포함합니다.</p>
<p><code>argparse</code> 모듈은 또한 이미 이들 모듈의 인기 있는 서드파티 대체재로 활용되고 있습니다. IPython (Scipy Python 셸)과 같은 프로젝트에서 사용되며, Debian testing 및 unstable에 포함되어 있고, 2007년부터 표준 라이브러리에 포함해달라는 여러 요청이 있었습니다. 이러한 인기는 <code>argparse</code>가 Python 라이브러리에 매우 가치 있는 추가 기능이 될 수 있음을 시사합니다.</p>
<h3><code>getopt</code>와 <code>optparse</code>로는 부족한 이유</h3>
<p><code>argparse</code> 추가에 반대하는 한 가지 주장은 "표준 라이브러리에 이미 두 가지 다른 옵션 파싱 모듈이 있다"는 것입니다. 다음은 <code>argparse</code>에서 제공하지만 <code>getopt</code> 또는 <code>optparse</code>에는 없는 기능 목록입니다.</p>
<ul>
<li>두 가지 옵션 파싱 라이브러리가 있는 것은 사실이지만, 완전한 커맨드 라인 파싱 라이브러리는 없습니다. <code>getopt</code>와 <code>optparse</code>는 모두 옵션만 지원하며 위치 인수는 지원하지 않습니다. <code>argparse</code> 모듈은 둘 다 처리하며, 그 결과 더 나은 도움말 메시지를 생성하여 <code>optparse</code>에서 일반적으로 필요한 <code>usage=</code> 문자열과 같은 중복을 피할 수 있습니다.</li>
<li><code>argparse</code> 모듈은 순수성보다는 실용성을 중시합니다. 따라서 <code>argparse</code>는 필수 옵션과 옵션을 식별하는 데 사용되는 문자를 사용자 정의할 수 있도록 허용합니다. 반면 <code>optparse</code>는 "필수 옵션이라는 문구는 자체 모순"이라고 명시하며 <code>-pf</code>, <code>-file</code>, <code>+f</code>, <code>+rgb</code>, <code>/f</code>, <code>/file</code>과 같은 옵션 문법은 <code>optparse</code>에서 지원되지 않으며 앞으로도 지원되지 않을 것이라고 밝힙니다.</li>
<li><code>argparse</code> 모듈은 <code>nargs='?'</code>, <code>nargs='*'</code> 또는 <code>nargs='+'</code>를 사용하여 가변 개수의 인수를 허용하도록 옵션을 설정할 수 있습니다. <code>optparse</code> 모듈은 이 기능의 일부에 대한 검증되지 않은 레시피를 제공하지만, "옵션이 가변 개수의 인수를 가져야 할 때 상황이 복잡해진다"고 인정합니다.</li>
<li><code>argparse</code> 모듈은 서브커맨드를 지원합니다. 여기서 메인 커맨드 라인 파서가 커맨드 라인 인수에 따라 다른 커맨드 라인 파서로 디스패치됩니다. 이는 <code>svn co</code> 및 <code>svn up</code>과 같은 커맨드 라인 인터페이스에서 흔히 볼 수 있는 패턴입니다.</li>
</ul>
<h3>기능이 <code>optparse</code>에 추가되지 않는 이유</h3>
<p>위의 모든 기능이 <code>optparse</code>에서 제공되는 것보다 개선된 기능을 제공한다는 것은 분명합니다. 그렇다면 이러한 기능들이 완전히 새로운 모듈을 도입하는 대신 <code>optparse</code>에 패치로 제공되지 않는 이유에 대한 합리적인 질문이 있을 수 있습니다. 사실, <code>argparse</code>의 초기 개발은 그렇게 하려고 했지만, <code>optparse</code>의 여러 가지 상당히 제약적인 설계 결정 때문에 실제로 가능하지 않았습니다. 몇 가지 문제는 다음과 같습니다.</p>
<ul>
<li>
<p><code>optparse</code> 모듈은 파싱 알고리즘의 내부를 노출합니다. 특히, <code>parser.largs</code> 및 <code>parser.rargs</code>는 콜백(callbacks)에 항상 제공된다는 보장이 있습니다. 이는 <code>argparse</code>에서 위치 인수 및 가변 길이 인수를 올바르게 처리하는 데 필요했던 파싱 알고리즘을 개선하는 것을 극도로 어렵게 만듭니다. 예를 들어, <code>argparse</code>의 <code>nargs='+'</code>는 정규 표현식을 사용하여 일치시키므로 <code>parser.largs</code>와 같은 개념이 없습니다.</p>
</li>
<li>
<p><code>optparse</code> 확장 API는 매우 복잡합니다. 예를 들어, 간단한 사용자 정의 문자열-객체 변환 함수를 사용하려면 <code>Option</code>을 서브클래싱하고, 클래스 속성을 수정하며, 다음과 같이 사용자 정의 옵션 타입을 파서에 지정해야 합니다.</p>
<pre><code class="language-python">class MyOption(Option):
    TYPES = Option.TYPES + ("mytype",)
    TYPE_CHECKER = copy(Option.TYPE_CHECKER)
    TYPE_CHECKER["mytype"] = check_mytype

parser = optparse.OptionParser(option_class=MyOption)
parser.add_option("-m", type="mytype")
</code></pre>
<p>비교를 위해 <code>argparse</code>는 단순히 변환 함수를 <code>type=</code> 인수로 직접 사용할 수 있도록 합니다.</p>
<pre><code class="language-python">parser = argparse.ArgumentParser()
parser.add_option("-m", type=check_mytype)
</code></pre>
<p>그러나 <code>optparse</code>의 복잡한 사용자 정의 API를 고려할 때, 이러한 기능이 해당 API와 어떻게 상호 작용해야 하는지 불분명하며, 간단한 <code>argparse</code> API를 도입하면 기존의 사용자 정의 <code>Option</code> 코드가 손상될 가능성이 높습니다.</p>
</li>
<li>
<p><code>optparse</code>와 <code>argparse</code>는 모두 커맨드 라인 인수를 파싱하고 <code>parse_args</code>가 반환하는 객체에 속성으로 할당합니다. 그러나 <code>optparse</code> 모듈은 사용자 정의 액션의 <code>take_action</code> 메서드에 항상 <code>ensure_value</code> 메서드를 제공하는 <code>values</code> 객체가 전달될 것을 보장하지만, <code>argparse</code> 모듈은 속성을 모든 객체에 할당할 수 있도록 허용합니다.</p>
<pre><code class="language-python">foo_object = ...
parser.parse_args(namespace=foo_object)
foo_object.some_attribute_parsed_from_command_line
</code></pre>
<p><code>optparse</code>를 수정하여 <code>Values</code> 인스턴스 대신 모든 객체를 전달할 수 있도록 하는 것은 <code>ensure_value</code> 메서드에 의존하는 기존의 사용자 정의 액션을 손상시킬 것이기 때문에 어려울 것입니다.</p>
</li>
</ul>
<p>이와 같은 문제들로 인해 <code>argparse</code>가 <code>optparse</code> API와의 호환성을 유지하기가 불합리하게 어려워졌기 때문에 <code>argparse</code>는 독립적인 모듈로 개발되었습니다. 이러한 문제들을 고려할 때, <code>argparse</code>의 모든 기능을 하위 호환성 없이 <code>optparse</code>에 병합하는 것은 불가능해 보입니다.</p>
<h2><code>optparse</code>의 Deprecation (사용 중단)</h2>
<p><code>optparse</code>의 모든 기능이 <code>argparse</code>에서 사용 가능하므로 <code>optparse</code> 모듈은 Deprecated (사용 중단)될 것입니다. 그러나 <code>optparse</code>의 광범위한 사용으로 인해 Deprecation 전략은 기본적으로 표시되지 않는 문서 변경 및 경고만 포함합니다.</p>
<ul>
<li><strong>Python 2.7+ 및 3.2+</strong>: <code>optparse</code> 문서에 다음 내용이 추가될 것입니다.
<blockquote>
<p><code>optparse</code> 모듈은 Deprecated (사용 중단)되었으며 더 이상 개발되지 않을 것입니다. 개발은 <code>argparse</code> 모듈로 계속될 것입니다.</p>
</blockquote>
</li>
<li><strong>Python 2.7+</strong>: 커맨드 라인에서 Python 3 호환성 플래그인 <code>-3</code>가 제공되면 <code>optparse</code>를 import할 때 <code>DeprecationWarning</code>이 발생합니다. 그렇지 않으면 경고가 발생하지 않습니다.</li>
<li><strong>Python 3.2+</strong>: <code>optparse</code>를 import할 때 <code>PendingDeprecationWarning</code>이 발생하며, 이는 기본적으로 표시되지 않습니다.</li>
</ul>
<p><code>optparse</code>의 제거 날짜는 제안되지 않았다는 점에 유의하십시오.</p>
<h2><code>getopt</code> 문서 업데이트</h2>
<p><code>getopt</code> 모듈은 Deprecated되지 않을 것입니다. 그러나 <code>argparse</code>를 가리키도록 문서가 여러 곳에서 업데이트될 것입니다. 모듈 상단에는 다음 내용이 추가될 것입니다.</p>
<blockquote>
<p><code>getopt</code> 모듈은 C <code>getopt</code> 함수의 사용자에게 친숙하도록 API가 설계된 커맨드 라인 옵션 파서입니다. C <code>getopt</code> 함수에 익숙하지 않거나 더 적은 코드를 작성하고 더 나은 도움말 및 오류 메시지를 얻고 싶은 사용자는 대신 <code>argparse</code> 모듈을 사용하는 것을 고려해야 합니다.</p>
</blockquote>
<p>또한, 최종 <code>getopt</code> 예제 뒤에 다음 내용이 추가될 것입니다.</p>
<blockquote>
<p>동일한 커맨드 라인 인터페이스를 <code>argparse</code> 모듈을 사용하여 더 적은 코드로 생성할 수 있습니다.</p>
</blockquote>
<pre><code class="language-python">import argparse

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-o', '--output')
    parser.add_argument('-v', dest='verbose', action='store_true')
    args = parser.parse_args()
    # ... do something with args.output ...
    # ... do something with args.verbose ..
</code></pre>
<h2>연기된 사항: 문자열 포매팅 (Deferred: string formatting)</h2>
<p><code>argparse</code> 모듈은 Python 2.3부터 3.2까지 지원하며, 그 결과 전통적인 <code>%(foo)s</code> 스타일 문자열 포매팅에 의존합니다. 새로운 스타일 <code>{foo}</code> 문자열 포매팅을 사용하는 것이 더 나을 수 있다는 제안이 있었습니다. 표준 라이브러리의 모듈에 대해 이를 가장 잘 수행하는 방법에 대한 논의가 있었고, 몇몇 사람들은 <code>%</code>-포매팅을 <code>{}</code>-포매팅으로 자동 변환하는 함수를 개발하고 있습니다. 이들 중 하나가 표준 라이브러리에 추가되면 <code>argparse</code>는 이를 사용하여 두 가지 포매팅 스타일을 모두 지원할 것입니다.</p>
<h2>거부된 사항: <code>getopt</code> 호환성 메서드 (Rejected: getopt compatibility methods)</h2>
<p>이 PEP가 <code>getopt</code>와 <code>optparse</code>의 Deprecation을 모두 제안했을 때, 다음과 같은 메서드를 추가하는 것에 대한 논의가 있었습니다.</p>
<pre><code class="language-python">ArgumentParser.add_getopt_arguments(options[, long_options])
</code></pre>
<p>그러나 이 메서드는 여러 이유로 추가되지 않을 것입니다.</p>
<ul>
<li><code>getopt</code> 모듈이 Deprecated되지 않으므로 필요성이 줄어들었습니다.</li>
<li>이 메서드는 <code>usage</code> 메시지를 이미 유지하고 있던 <code>getopt</code> 사용자에게 전환을 실제로 용이하게 하지 않을 것입니다. 위 API는 인수에 도움말 메시지를 추가하는 방법을 제공하지 않기 때문입니다.</li>
<li>일부 <code>getopt</code> 사용자는 단일 함수 호출만 필요하다는 것을 매우 중요하게 생각합니다. 위 API는 <code>ArgumentParser()</code>와 <code>parse_args()</code>를 모두 호출해야 하므로 이 요구 사항을 충족하지 않습니다.</li>
</ul>
<h2>범위 외 (Out of Scope): 다양한 기능 요청</h2>
<p>이 PEP 논의에서 <code>argparse</code>에 대한 몇 가지 기능 요청이 있었습니다.</p>
<ul>
<li>환경 변수에서 인수 기본값 지원</li>
<li>설정 파일에서 인수 기본값 지원</li>
<li>현재 지원되는 "foo subcommand --help" 외에 "foo --help subcommand" 지원</li>
</ul>
<p>이들은 모두 <code>argparse</code> 모듈에 대한 합리적인 기능 요청이지만, 이 PEP의 범위를 벗어나며 <code>argparse</code> 이슈 트래커로 리디렉션되었습니다.</p>
<h2>논의 (Discussion): <code>sys.stderr</code> 및 <code>sys.exit</code></h2>
<p><code>argparse</code>가 기본적으로 항상 <code>sys.stderr</code>에 쓰고 잘못된 인수가 제공될 때 항상 <code>sys.exit</code>를 호출한다는 점에 대한 우려가 있었습니다. 이는 단순한 커맨드 라인 인터페이스를 중심으로 하는 <code>argparse</code> 사용 사례의 대다수에서 원하는 동작입니다. 그러나 어떤 경우에는 <code>argparse</code>가 종료되지 않도록 하거나 메시지를 <code>sys.stderr</code> 이외의 다른 곳에 작성하도록 하는 것이 바람직할 수 있습니다. 이러한 사용 사례는 <code>ArgumentParser</code>를 서브클래싱하고 <code>exit</code> 또는 <code>_print_message</code> 메서드를 오버라이딩하여 지원할 수 있습니다. 후자는 문서화되지 않은 구현 세부 사항이지만, 이것이 일반적인 필요로 밝혀지면 공식적으로 노출될 수 있습니다.</p>
<h2>참조 (References)</h2>
<p><code>argparse</code> (http://code.google.com/p/argparse/)
<code>getopt</code> (http://docs.python.org/library/getopt.html)
<code>optparse</code> (http://docs.python.org/library/optparse.html)
IPython의 <code>argparse</code> (http://mail.scipy.org/pipermail/ipython-dev/2009-April/005102.html)
Debian의 <code>argparse</code> (http://packages.debian.org/search?keywords=argparse)
2007-01-03 표준 라이브러리에 <code>argparse</code> 포함 요청 (https://mail.python.org/pipermail/python-list/2007-January/472276.html)
2009-06-09 표준 라이브러리에 <code>argparse</code> 포함 요청 (http://bugs.python.org/issue6247)
2009-09-10 표준 라이브러리에 <code>argparse</code> 포함 요청 (https://mail.python.org/pipermail/stdlib-sig/2009-September/000342.html)
Fredrik Lundh의에 대한 응답 (https://mail.python.org/pipermail/python-list/2007-January/1086892.html)
<code>optparse</code> 가변 인수 (http://docs.python.org/library/optparse.html#callback-example-6-variable-arguments)
<code>parser.largs</code> 및 <code>parser.rargs</code> (http://docs.python.org/library/optparse.html#how-callbacks-are-called)
<code>take_action</code> <code>values</code> 인수 (http://docs.python.org/library/optparse.html#adding-new-actions)
<code>%</code>-포매팅 대신 <code>{}</code>-포매팅 사용 (http://bugs.python.org/msg89279)
<code>%</code>에서 <code>{}</code> 포매팅으로 전환 (https://mail.python.org/pipermail/python-dev/2009-September/092326.html)
Vinay Sajip의 <code>%</code>-에서-<code>{}</code> 변환기 (http://gist.github.com/200936)
Benjamin Peterson의 <code>%</code>-에서-<code>{}</code> 변환기 (http://bazaar.launchpad.net/~gutworth/+junk/mod2format/files)
Guido의 승인 (https://mail.python.org/pipermail/python-dev/2010-February/097839.html)</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1025,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 389 - argparse - New Command Line Parsing Module"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 21:08:50+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","22",{"name":"next-size-adjust"}]]
1:null
