<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 520 - Preserving Class Attribute Definition Order</h1><div class="page__meta"><time dateTime="2025-09-26 23:13:52+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0520/">PEP 520 - Preserving Class Attribute Definition Order</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 07-Jun-2016</p>
</blockquote>
<p>PEP 520 – 클래스 속성 정의 순서 유지 (Preserving Class Attribute Definition Order)</p>
<h2>요약 (Abstract)</h2>
<p>클래스 정의 구문은 본질적으로 순서가 있습니다. 여기에 정의된 클래스 속성들 역시 순서가 존재합니다. 이러한 순서는 가독성을 높일 뿐만 아니라 때로는 그 자체가 중요하기도 합니다. 만약 이 순서가 클래스 정의 외부에서 자동으로 접근 가능하다면, 메타클래스(metaclass)를 사용하거나 속성 순서를 수동으로 열거하는 것과 같은 추가적인 상용구 코드(boilerplate) 없이도 속성 순서를 활용할 수 있게 될 것입니다. 이 정보가 이미 존재한다는 점을 고려할 때, 속성 정의 순서에 접근할 수 있도록 하는 것은 합리적인 기대입니다. 그러나 현재 Python은 클래스 정의에서 속성 순서를 보존하지 않습니다.</p>
<p>이 PEP는 클래스 정의 본문에서 속성이 도입되는 순서를 유지하도록 변경합니다. 이제 그 순서는 클래스의 <code>__definition_order__</code> 속성에 보존될 것입니다. 이는 클래스 데코레이터(class decorators) 등에서 원래의 정의 순서를 내부적으로 검사(introspection)할 수 있도록 합니다.</p>
<p>또한, 이 PEP는 기본 클래스 정의 네임스페이스(namespace)가 기본적으로 순서가 있는 매핑(ordered mapping, 예: <code>collections.OrderedDict</code>)이 될 것을 요구합니다. <code>__dict__</code>와 같은 오래된 클래스 네임스페이스는 계속 <code>dict</code>로 유지됩니다.</p>
<p><strong>참고:</strong> Python 3.6에 compact <code>dict</code>가 도입된 이후, <code>__definition_order__</code>는 제거되었습니다. 대신 <code>cls.__dict__</code>가 이제 대부분 동일한 기능을 수행합니다.</p>
<h2>동기 (Motivation)</h2>
<p>클래스 정의의 속성 순서는 이름 순서에 의존하는 도구에 유용할 수 있습니다. 그러나 정의 순서가 자동으로 제공되지 않으면, 그러한 도구는 사용자에게 추가적인 요구 사항을 부과해야 합니다. 예를 들어, 특정 도구를 사용하려면 클래스가 특정 메타클래스를 사용하도록 요구될 수 있습니다. 이러한 요구 사항은 종종 도구 사용을 저해하는 요인이 됩니다.</p>
<p>이 PEP를 활용할 수 있는 몇 가지 도구는 다음과 같습니다.</p>
<ul>
<li>문서 생성기 (documentation generators)</li>
<li>테스트 프레임워크 (testing frameworks)</li>
<li>CLI 프레임워크 (CLI frameworks)</li>
<li>웹 프레임워크 (web frameworks)</li>
<li>설정 생성기 (config generators)</li>
<li>데이터 직렬화기 (data serializers)</li>
<li>Enum 팩토리 (enum factories) (작성자의 원래 동기)</li>
</ul>
<h2>배경 (Background)</h2>
<p>클래스 문(class statement)을 사용하여 클래스가 정의될 때, 클래스 본문(class body)은 네임스페이스 내에서 실행됩니다. 현재 기본적으로 이 네임스페이스는 <code>dict</code>입니다. 만약 메타클래스가 <code>__prepare__()</code>를 정의하면, 해당 호출 결과가 클래스 정의 네임스페이스로 사용됩니다.</p>
<p>실행이 완료되면 정의 네임스페이스는 새 <code>dict</code>로 복사됩니다. 그런 다음 원래 정의 네임스페이스는 폐기됩니다. 새 복사본은 클래스의 네임스페이스로 저장되고 읽기 전용 프록시(read-only proxy)를 통해 <code>__dict__</code>로 노출됩니다.</p>
<p>클래스 속성 정의 순서는 정의 네임스페이스에 이름이 삽입되는 순서로 표현됩니다. 따라서 정의 네임스페이스를 <code>collections.OrderedDict</code>와 같은 순서 있는 매핑으로 전환함으로써 정의 순서에 접근할 수 있습니다. 이는 위에서 설명한 대로 메타클래스와 <code>__prepare__</code>를 사용하여 가능합니다. 실제로 이는 <code>__prepare__</code>를 사용하는 가장 일반적인 사용 사례입니다.</p>
<p>이 시점에서 나중에 정의 순서에 접근하기 위해 유일하게 누락된 것은 정의 네임스페이스가 버려지기 전에 클래스에 저장하는 것입니다. 이 역시 메타클래스를 사용하여 수행할 수 있습니다. 그러나 이는 그러한 메타클래스를 사용하는 클래스에 대해서만 정의 순서가 유지된다는 것을 의미합니다. 여기에는 두 가지 실용적인 문제가 있습니다.</p>
<p>첫째, 메타클래스 사용이 필요합니다. 메타클래스는 코드에 추가적인 복잡성을 도입하며, 경우에 따라(예: 충돌) 문제가 될 수 있습니다. 따라서 기회가 있을 때 메타클래스 필요성을 줄이는 것은 가치 있는 일입니다. PEP 422와 PEP 487에서 이에 대해 자세히 논의합니다. 기본 클래스 정의 네임스페이스에 순서 있는 매핑(예: CPython의 경우 <code>OrderedDict</code>)을 사용하여 <code>__prepare__()</code>의 필요성을 사실상 없애는 기회가 있습니다.</p>
<p>둘째, <code>OrderedDict</code> 기반 메타클래스를 사용하기로 선택한 클래스만 정의 순서에 접근할 수 있습니다. 이는 정의 순서에 대한 보편적인 접근이 중요한 경우에 문제가 됩니다.</p>
<h2>명세 (Specification)</h2>
<p><strong>파트 1:</strong></p>
<ul>
<li>모든 클래스는 <code>__definition_order__</code> 속성을 가집니다.</li>
<li><code>__definition_order__</code>는 식별자(identifier) 튜플(tuple)이거나 <code>None</code>입니다.</li>
<li><code>__definition_order__</code>는 항상 다음과 같이 설정됩니다.
<ul>
<li>클래스 본문 실행 중, 클래스 정의 네임스페이스에 이름이 삽입되는 순서가 튜플에 저장됩니다.</li>
<li>만약 <code>__definition_order__</code>가 클래스 본문에 정의되어 있다면, 식별자 튜플 또는 <code>None</code>이어야 합니다. 다른 값은 <code>TypeError</code>를 발생시킵니다.</li>
<li>클래스 정의가 없는 클래스(예: 내장(builtins) 타입)는 <code>__definition_order__</code>가 <code>None</code>으로 설정됩니다.</li>
<li><code>__prepare__()</code>가 <code>OrderedDict</code>(또는 그 서브클래스)가 아닌 다른 것을 반환한 클래스는 <code>__definition_order__</code>가 <code>None</code>으로 설정됩니다 (단, 위 #2가 적용되는 경우는 예외).</li>
</ul>
</li>
<li>변경되지 않는 사항:
<ul>
<li><code>dir()</code>은 <code>__definition_order__</code>에 의존하지 않습니다.</li>
<li>디스크립터(descriptors)와 사용자 정의 <code>__getattribute__</code> 메서드는 <code>__definition_order__</code>와 관련하여 제약을 받지 않습니다.</li>
</ul>
</li>
</ul>
<p><strong>파트 2:</strong></p>
<ul>
<li>기본 클래스 정의 네임스페이스는 이제 순서 있는 매핑(예: <code>OrderedDict</code>)입니다.</li>
<li><code>cls.__dict__</code>는 변경되지 않고 <code>dict</code>를 둘러싼 읽기 전용 프록시로 유지됩니다.</li>
</ul>
<p>순서 있는 <code>dict</code>를 가진 Python 구현체는 아무것도 변경할 필요가 없다는 점에 유의하십시오.</p>
<p>다음 코드는 파트 1과 파트 2에 대한 대략적으로 동등한 의미를 보여줍니다.</p>
<pre><code class="language-python">from collections import OrderedDict

class Meta(type):
    @classmethod
    def __prepare__(cls, *args, **kwargs):
        return OrderedDict()

class Spam(metaclass=Meta):
    ham = None
    eggs = 5
    __definition_order__ = tuple(locals())
</code></pre>
<h3>왜 튜플인가? (Why a tuple?)</h3>
<p>튜플(tuple)을 사용하는 것은 클래스의 속성이 정의된 순서를 노출한다는 사실을 반영합니다. <code>__definition_order__</code>가 설정될 때쯤에는 정의가 이미 완료되었으므로, 값의 내용과 순서는 변경되지 않습니다. 따라서 우리는 불변성(immutability) 상태를 전달하는 타입을 사용합니다.</p>
<h3>왜 읽기 전용 속성이 아닌가? (Why not a read-only attribute?)</h3>
<p><code>__definition_order__</code>를 읽기 전용 속성(예: <code>cls.__dict__</code>)으로 만드는 것에 대한 몇 가지 타당한 주장이 있습니다. 가장 주목할 만한 점은 읽기 전용 속성이 속성의 "완료" 상태를 전달하며, 이는 <code>__definition_order__</code>에 정확히 해당합니다. 특정 일회성 이벤트(클래스 정의 본문의 실행)의 상태를 나타내므로, 값을 교체하는 것을 허용하면 속성이 원래 클래스 본문에 해당하는지에 대한 신뢰를 떨어뜨릴 것입니다. 또한, 기본적으로 불변(immutable) 접근 방식은 데이터를 추론하기 더 쉽게 만드는 데 도움이 됩니다.</p>
<p>그러나 이 경우 Python에서 흔히 볼 수 있는 잘 확립된 선례에 반대할 강력한 이유는 여전히 없습니다. Guido에 따르면:</p>
<blockquote>
<p>저는 이것이 읽기 전용 속성일 필요가 있다고 생각하지 않습니다. 그런 경우는 거의 없습니다. 일반적으로 우리는 할당을 제한해야 할 강력한 이유가 없는 한 (예: 인터프리터의 내부 상태가 손상될 수 있는 경우) 사용자가 모든 것을 가지고 놀 수 있도록 합니다. 여기에는 그러한 강력한 이유가 보이지 않습니다.</p>
</blockquote>
<p>또한, 쓰기 가능한(writeable) <code>__definition_order__</code>는 동적으로 생성된 클래스(예: Cython에 의해)도 <code>__definition_order__</code>가 제대로 설정될 수 있도록 허용합니다. 이는 <code>type()</code> 또는 C-API와 같은 특정 클래스 생성 도구를 통해 처리될 수 있었으며, 읽기 전용 속성의 의미를 잃을 필요는 없었습니다. 그러나 쓰기 가능한 속성을 사용하면 논쟁의 여지가 없습니다.</p>
<h3>왜 “<code>__attribute_order__</code>”가 아닌가? (Why not “<strong>attribute_order</strong>”?)</h3>
<p><code>__definition_order__</code>는 클래스 정의 본문에 초점을 맞춥니다. 정의 이후 클래스 네임스페이스(<code>__dict__</code>)를 다루는 사용 사례는 별개의 문제입니다. <code>__definition_order__</code>는 클래스 정의 이상에 초점을 맞춘 기능에 대해 상당히 오해의 소지가 있는 이름이 될 것입니다.</p>
<h3>왜 “던더(dunder)” 이름을 무시하지 않는가? (Why not ignore “dunder” names?)</h3>
<p><code>__</code>로 시작하고 끝나는 이름은 인터프리터(interpreter) 사용을 위해 예약되어 있습니다. 실제로는 <code>__definition_order__</code> 사용자에게 관련이 없어야 합니다. 대신, 거의 모든 사람에게는 혼란을 야기하고 (던더 이름을 필터링하는) 동일한 추가 작업을 유발할 뿐입니다. 던더 이름이 중요한 경우에는 클래스 정의에서 <code>__definition_order__</code>를 수동으로 설정할 수 있어 일반적인 경우를 더 간단하게 만듭니다.</p>
<p>그러나 <code>__definition_order__</code>에서 던더 이름을 제외하면 정의 순서에서 해당 위치가 복구 불가능하게 손실됩니다. 기본적으로 던더 이름을 제외하면 던더 이름을 비관습적으로 사용하는 클래스에 예기치 않은 문제를 일으킬 수 있습니다. 이 경우 안전하게 모든 이름을 클래스 정의에서 보존하는 것이 좋습니다. 던더 이름을 필터링하는 것은 쉽기 때문에 큰 문제는 아닙니다.</p>
<pre><code class="language-python">(name for name in cls.__definition_order__ if not (name.startswith('__') and name.endswith('__')))
</code></pre>
<p>사실, 일부 애플리케이션 컨텍스트에서는 <code>_</code>로 시작하는 이름을 무시하거나, 모든 메서드를 제외하거나, 디스크립터만 포함하는 등 유사한 필터링이 적용될 수 있는 다른 기준이 있을 수 있습니다. 궁극적으로 던더 이름은 특별한 경우로 취급할 만큼 특별하지 않습니다.</p>
<p>두어 개의 던더 이름(<code>__name__</code> 및 <code>__qualname__</code>)은 컴파일러에 의해 기본적으로 주입됩니다. 따라서 엄밀히 말해 클래스 정의 본문의 일부는 아니지만 포함될 것입니다.</p>
<h3>왜 빈 튜플 대신 <code>None</code>인가? (Why None instead of an empty tuple?)</h3>
<p><code>__definition_order__</code>를 추가하는 핵심 목표는 이 PEP 이전에 손실되었던 클래스 정의의 정보를 보존하는 것입니다. 한 가지 결과는 <code>__definition_order__</code>가 원래 클래스 정의를 암시한다는 것입니다. <code>None</code>을 사용하면 정의 순서가 없는 클래스를 명확하게 구별할 수 있습니다. 빈 튜플은 정의 문에서 왔지만 속성을 정의하지 않은 클래스를 명확하게 나타냅니다.</p>
<h3>왜 속성을 설정하지 않는 대신 <code>None</code>인가? (Why None instead of not setting the attribute?)</h3>
<p>속성이 없는 것은 <code>__definition_order__</code>를 사용하는 소비자에게 <code>None</code>보다 더 복잡한 처리를 요구합니다.</p>
<h3>왜 수동으로 설정된 값을 제약하는가? (Why constrain manually set values?)</h3>
<p>만약 <code>__definition_order__</code>가 클래스 본문에 수동으로 설정된다면, 그것이 사용될 것입니다. 우리는 <code>__definition_order__</code>의 소비자들이 값에 대해 일관된 기대를 가질 수 있도록 식별자 튜플(또는 <code>None</code>)이어야 한다고 요구합니다. 이는 기능의 유용성을 극대화하는 데 도움이 됩니다.</p>
<p>수동으로 설정된 <code>__definition_order__</code>에 대해 임의의 이터러블(iterable)을 허용하고 튜플로 변환할 수도 있습니다. 그러나 모든 이터러블이 정의 순서를 추론하지는 않습니다(예: <code>set</code>). 따라서 우리는 튜플을 요구하는 것을 선택합니다.</p>
<h3>왜 <code>non-type</code> 객체에서 <code>__definition_order__</code>를 숨기지 않는가? (Why not hide <strong>definition_order</strong> on non-type objects?)</h3>
<p>Python은 클래스 인스턴스에서 조회(lookup)할 때 클래스 특정 속성을 숨기기 위해 많은 노력을 기울이지 않습니다. <code>__definition_order__</code>를 클래스 전용 속성으로 간주하고 객체 조회 시 숨기는 것이 합리적일 수 있지만, 그 점에서 선례를 설정하는 것은 이 PEP의 목표를 넘어섭니다.</p>
<h3><code>__slots__</code>는 어떤가? (What about <strong>slots</strong>?)</h3>
<p><code>__slots__</code>는 클래스 정의 본문의 다른 이름과 마찬가지로 <code>__definition_order__</code>에 추가됩니다. 실제 슬롯(slot) 이름은 정의 네임스페이스에 이름으로 설정되지 않으므로 <code>__definition_order__</code>에 추가되지 않습니다.</p>
<h3><code>__definition_order__</code>가 왜 필요한가? (Why is <strong>definition_order</strong> even necessary?)</h3>
<p>정의 순서는 <code>__dict__</code>에 보존되지 않으므로 클래스 정의 실행이 완료되면 손실됩니다. 클래스는 본문에서 마지막으로 속성을 명시적으로 설정할 수 있습니다. 그러나 이 경우 독립적인 데코레이터는 그렇게 한 클래스만 사용할 수 있습니다. 대신, <code>__definition_order__</code>는 클래스 본문에서 이 정보를 보존하여 보편적으로 사용할 수 있도록 합니다.</p>
<h2>C-API 타입 지원 (Support for C-API Types)</h2>
<p>대부분의 C로 정의된 Python 타입(예: 내장 타입, 확장 모듈)은 정의 순서와 대략적으로 동등한 개념을 가지고 있다고 주장할 수 있습니다. 따라서 <code>__definition_order__</code>는 이러한 타입에 대해 자동으로 설정될 수 있다고 생각할 수 있습니다. 이 PEP는 그러한 지원을 도입하지 않습니다. 그러나 금지하지도 않습니다. 하지만 <code>__definition_order__</code>는 일반적인 속성 할당을 통해 언제든지 설정될 수 있으므로 C-API에서 특별한 처리가 필요하지 않습니다.</p>
<p>특정 사례:</p>
<ul>
<li><code>builtin</code> 타입</li>
<li><code>PyType_Ready</code></li>
<li><code>PyType_FromSpec</code></li>
</ul>
<h2>호환성 (Compatibility)</h2>
<p>이 PEP는 클래스 정의 네임스페이스로 엄격하게 <code>dict</code>에 의존하는 경우를 제외하고는 하위 호환성(backward compatibility)을 깨뜨리지 않습니다. <code>issubclass(OrderedDict, dict)</code>가 <code>True</code>이므로 이는 문제가 되지 않아야 합니다.</p>
<h2>변경 사항 (Changes)</h2>
<p>클래스 구문 외에도 다음은 새로운 동작을 노출합니다.</p>
<ul>
<li><code>builtins.__build_class__</code></li>
<li><code>types.prepare_class</code></li>
<li><code>types.new_class</code></li>
</ul>
<p>또한 <code>builtins.type()</code>의 3인자 형식은 전달되는 네임스페이스에 <code>__definition_order__</code>를 포함하는 것을 허용합니다. <code>__definition_order__</code>가 클래스 본문에 명시적으로 정의될 때와 동일한 제약을 받습니다.</p>
<h2>다른 Python 구현체 (Other Python Implementations)</h2>
<p>피드백에 따라 Python 구현체에 미치는 영향은 최소화될 것으로 예상됩니다. 모든 규정 준수 구현체는 이 PEP에 설명된 대로 <code>__definition_order__</code>를 설정할 것으로 예상됩니다.</p>
<h2>구현 (Implementation)</h2>
<p>구현은 트래커에서 찾을 수 있습니다.</p>
<h2>대안 (Alternatives)</h2>
<h3>순서를 유지하는 <code>cls.__dict__</code> (An Order-preserving cls.<strong>dict</strong>)</h3>
<p>정의 순서를 <code>__definition_order__</code>에 저장하는 대신, 이제 순서가 있는 정의 네임스페이스를 새 <code>OrderedDict</code>로 복사할 수 있었습니다. 그런 다음 이것은 <code>__dict__</code>로 프록시되는 매핑으로 사용될 것입니다. 이렇게 하면 대부분 동일한 의미를 제공할 것입니다.</p>
<p>그러나 <code>__dict__</code>에 <code>OrderedDict</code>를 사용하면 정의 네임스페이스와의 관계가 모호해져 유용성이 떨어집니다.</p>
<p>또한 (특히 <code>OrderedDict</code>의 경우) 이렇게 하면 구체적인 <code>dict</code> C-API의 의미론에 상당한 변경이 필요할 것입니다.</p>
<p>삽입 순서를 (대부분) 보존하는 compact <code>dict</code> 구현으로 전환하는 것에 대한 논의가 있었습니다. 그러나 명시적인 <code>__definition_order__</code>가 없다는 점은 여전히 어려운 문제로 남을 것입니다.</p>
<h3>클래스 정의를 위한 “namespace” 키워드 인자 (A “namespace” Keyword Arg for Class Definition)</h3>
<p>PEP 422는 클래스 정의에 새로운 "namespace" 키워드 인자를 도입했으며, 이는 <code>__prepare__()</code>의 필요성을 효과적으로 대체합니다. 그러나 이 제안은 더 간단한 PEP 487을 위해 철회되었습니다.</p>
<h3><code>OrderedDict</code>로 <code>__prepare__()</code>를 구현하는 표준 라이브러리 메타클래스 (A stdlib Metaclass that Implements <strong>prepare</strong>() with OrderedDict)</h3>
<p>이는 자신만의 메타클래스를 작성하는 것과 동일한 모든 문제를 가지고 있습니다. 유일한 장점은 이 메타클래스를 실제로 작성할 필요가 없다는 것입니다. 따라서 이 PEP의 맥락에서는 어떤 이점도 제공하지 않습니다.</p>
<h3>컴파일 시 <code>__definition_order__</code> 설정 (Set <strong>definition_order</strong> at Compile-time)</h3>
<p>각 클래스의 <code>__qualname__</code>은 컴파일 시 결정됩니다. 이와 동일한 개념을 <code>__definition_order__</code>에 적용할 수 있었습니다. 컴파일 시 <code>__definition_order__</code>를 구성한 결과는 런타임에 수행하는 것과 거의 동일할 것입니다.</p>
<p>구현 난이도는 차치하고, 주요 차이점은 컴파일 시에는 클래스 본문에서 동적으로 설정되는 속성(예: <code>locals()[name] = value</code>)에 대한 정의 순서를 보존하는 것이 실용적이지 않다는 것입니다. 그러나 이러한 속성도 정의 순서에 반영되어야 합니다. 한 가지 가능한 해결책은 클래스 작성자가 동적으로 클래스 속성을 정의하는 경우 <code>__definition_order__</code>를 수동으로 설정하도록 요구하는 것입니다.</p>
<p>궁극적으로 런타임 또는 컴파일 시 <code>OrderedDict</code> 사용 여부는 거의 전적으로 구현 세부 사항입니다.</p>
<h2>참조 (References)</h2>
<ul>
<li><a href="https://mail.python.org/pipermail/python-dev/2016-June/145150.html">Original discussion</a></li>
<li><a href="https://mail.python.org/pipermail/python-dev/2016-June/145173.html">Follow-up 1</a></li>
<li><a href="https://mail.python.org/pipermail/python-dev/2016-June/145214.html">Follow-up 2</a></li>
<li><a href="https://mail.python.org/pipermail/python-dev/2016-June/145229.html">Alyssa (Nick) Coghlan's concerns about mutability</a></li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/520\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/520/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/520\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"520\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/520\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T5651,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0520/\"\u003ePEP 520 - Preserving Class Attribute Definition Order\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 07-Jun-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 520 – 클래스 속성 정의 순서 유지 (Preserving Class Attribute Definition Order)\u003c/p\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e클래스 정의 구문은 본질적으로 순서가 있습니다. 여기에 정의된 클래스 속성들 역시 순서가 존재합니다. 이러한 순서는 가독성을 높일 뿐만 아니라 때로는 그 자체가 중요하기도 합니다. 만약 이 순서가 클래스 정의 외부에서 자동으로 접근 가능하다면, 메타클래스(metaclass)를 사용하거나 속성 순서를 수동으로 열거하는 것과 같은 추가적인 상용구 코드(boilerplate) 없이도 속성 순서를 활용할 수 있게 될 것입니다. 이 정보가 이미 존재한다는 점을 고려할 때, 속성 정의 순서에 접근할 수 있도록 하는 것은 합리적인 기대입니다. 그러나 현재 Python은 클래스 정의에서 속성 순서를 보존하지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 클래스 정의 본문에서 속성이 도입되는 순서를 유지하도록 변경합니다. 이제 그 순서는 클래스의 \u003ccode\u003e__definition_order__\u003c/code\u003e 속성에 보존될 것입니다. 이는 클래스 데코레이터(class decorators) 등에서 원래의 정의 순서를 내부적으로 검사(introspection)할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e또한, 이 PEP는 기본 클래스 정의 네임스페이스(namespace)가 기본적으로 순서가 있는 매핑(ordered mapping, 예: \u003ccode\u003ecollections.OrderedDict\u003c/code\u003e)이 될 것을 요구합니다. \u003ccode\u003e__dict__\u003c/code\u003e와 같은 오래된 클래스 네임스페이스는 계속 \u003ccode\u003edict\u003c/code\u003e로 유지됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e Python 3.6에 compact \u003ccode\u003edict\u003c/code\u003e가 도입된 이후, \u003ccode\u003e__definition_order__\u003c/code\u003e는 제거되었습니다. 대신 \u003ccode\u003ecls.__dict__\u003c/code\u003e가 이제 대부분 동일한 기능을 수행합니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e클래스 정의의 속성 순서는 이름 순서에 의존하는 도구에 유용할 수 있습니다. 그러나 정의 순서가 자동으로 제공되지 않으면, 그러한 도구는 사용자에게 추가적인 요구 사항을 부과해야 합니다. 예를 들어, 특정 도구를 사용하려면 클래스가 특정 메타클래스를 사용하도록 요구될 수 있습니다. 이러한 요구 사항은 종종 도구 사용을 저해하는 요인이 됩니다.\u003c/p\u003e\n\u003cp\u003e이 PEP를 활용할 수 있는 몇 가지 도구는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e문서 생성기 (documentation generators)\u003c/li\u003e\n\u003cli\u003e테스트 프레임워크 (testing frameworks)\u003c/li\u003e\n\u003cli\u003eCLI 프레임워크 (CLI frameworks)\u003c/li\u003e\n\u003cli\u003e웹 프레임워크 (web frameworks)\u003c/li\u003e\n\u003cli\u003e설정 생성기 (config generators)\u003c/li\u003e\n\u003cli\u003e데이터 직렬화기 (data serializers)\u003c/li\u003e\n\u003cli\u003eEnum 팩토리 (enum factories) (작성자의 원래 동기)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e배경 (Background)\u003c/h2\u003e\n\u003cp\u003e클래스 문(class statement)을 사용하여 클래스가 정의될 때, 클래스 본문(class body)은 네임스페이스 내에서 실행됩니다. 현재 기본적으로 이 네임스페이스는 \u003ccode\u003edict\u003c/code\u003e입니다. 만약 메타클래스가 \u003ccode\u003e__prepare__()\u003c/code\u003e를 정의하면, 해당 호출 결과가 클래스 정의 네임스페이스로 사용됩니다.\u003c/p\u003e\n\u003cp\u003e실행이 완료되면 정의 네임스페이스는 새 \u003ccode\u003edict\u003c/code\u003e로 복사됩니다. 그런 다음 원래 정의 네임스페이스는 폐기됩니다. 새 복사본은 클래스의 네임스페이스로 저장되고 읽기 전용 프록시(read-only proxy)를 통해 \u003ccode\u003e__dict__\u003c/code\u003e로 노출됩니다.\u003c/p\u003e\n\u003cp\u003e클래스 속성 정의 순서는 정의 네임스페이스에 이름이 삽입되는 순서로 표현됩니다. 따라서 정의 네임스페이스를 \u003ccode\u003ecollections.OrderedDict\u003c/code\u003e와 같은 순서 있는 매핑으로 전환함으로써 정의 순서에 접근할 수 있습니다. 이는 위에서 설명한 대로 메타클래스와 \u003ccode\u003e__prepare__\u003c/code\u003e를 사용하여 가능합니다. 실제로 이는 \u003ccode\u003e__prepare__\u003c/code\u003e를 사용하는 가장 일반적인 사용 사례입니다.\u003c/p\u003e\n\u003cp\u003e이 시점에서 나중에 정의 순서에 접근하기 위해 유일하게 누락된 것은 정의 네임스페이스가 버려지기 전에 클래스에 저장하는 것입니다. 이 역시 메타클래스를 사용하여 수행할 수 있습니다. 그러나 이는 그러한 메타클래스를 사용하는 클래스에 대해서만 정의 순서가 유지된다는 것을 의미합니다. 여기에는 두 가지 실용적인 문제가 있습니다.\u003c/p\u003e\n\u003cp\u003e첫째, 메타클래스 사용이 필요합니다. 메타클래스는 코드에 추가적인 복잡성을 도입하며, 경우에 따라(예: 충돌) 문제가 될 수 있습니다. 따라서 기회가 있을 때 메타클래스 필요성을 줄이는 것은 가치 있는 일입니다. PEP 422와 PEP 487에서 이에 대해 자세히 논의합니다. 기본 클래스 정의 네임스페이스에 순서 있는 매핑(예: CPython의 경우 \u003ccode\u003eOrderedDict\u003c/code\u003e)을 사용하여 \u003ccode\u003e__prepare__()\u003c/code\u003e의 필요성을 사실상 없애는 기회가 있습니다.\u003c/p\u003e\n\u003cp\u003e둘째, \u003ccode\u003eOrderedDict\u003c/code\u003e 기반 메타클래스를 사용하기로 선택한 클래스만 정의 순서에 접근할 수 있습니다. 이는 정의 순서에 대한 보편적인 접근이 중요한 경우에 문제가 됩니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e파트 1:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모든 클래스는 \u003ccode\u003e__definition_order__\u003c/code\u003e 속성을 가집니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__definition_order__\u003c/code\u003e는 식별자(identifier) 튜플(tuple)이거나 \u003ccode\u003eNone\u003c/code\u003e입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__definition_order__\u003c/code\u003e는 항상 다음과 같이 설정됩니다.\n\u003cul\u003e\n\u003cli\u003e클래스 본문 실행 중, 클래스 정의 네임스페이스에 이름이 삽입되는 순서가 튜플에 저장됩니다.\u003c/li\u003e\n\u003cli\u003e만약 \u003ccode\u003e__definition_order__\u003c/code\u003e가 클래스 본문에 정의되어 있다면, 식별자 튜플 또는 \u003ccode\u003eNone\u003c/code\u003e이어야 합니다. 다른 값은 \u003ccode\u003eTypeError\u003c/code\u003e를 발생시킵니다.\u003c/li\u003e\n\u003cli\u003e클래스 정의가 없는 클래스(예: 내장(builtins) 타입)는 \u003ccode\u003e__definition_order__\u003c/code\u003e가 \u003ccode\u003eNone\u003c/code\u003e으로 설정됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__prepare__()\u003c/code\u003e가 \u003ccode\u003eOrderedDict\u003c/code\u003e(또는 그 서브클래스)가 아닌 다른 것을 반환한 클래스는 \u003ccode\u003e__definition_order__\u003c/code\u003e가 \u003ccode\u003eNone\u003c/code\u003e으로 설정됩니다 (단, 위 #2가 적용되는 경우는 예외).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e변경되지 않는 사항:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edir()\u003c/code\u003e은 \u003ccode\u003e__definition_order__\u003c/code\u003e에 의존하지 않습니다.\u003c/li\u003e\n\u003cli\u003e디스크립터(descriptors)와 사용자 정의 \u003ccode\u003e__getattribute__\u003c/code\u003e 메서드는 \u003ccode\u003e__definition_order__\u003c/code\u003e와 관련하여 제약을 받지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e파트 2:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기본 클래스 정의 네임스페이스는 이제 순서 있는 매핑(예: \u003ccode\u003eOrderedDict\u003c/code\u003e)입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecls.__dict__\u003c/code\u003e는 변경되지 않고 \u003ccode\u003edict\u003c/code\u003e를 둘러싼 읽기 전용 프록시로 유지됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e순서 있는 \u003ccode\u003edict\u003c/code\u003e를 가진 Python 구현체는 아무것도 변경할 필요가 없다는 점에 유의하십시오.\u003c/p\u003e\n\u003cp\u003e다음 코드는 파트 1과 파트 2에 대한 대략적으로 동등한 의미를 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom collections import OrderedDict\n\nclass Meta(type):\n    @classmethod\n    def __prepare__(cls, *args, **kwargs):\n        return OrderedDict()\n\nclass Spam(metaclass=Meta):\n    ham = None\n    eggs = 5\n    __definition_order__ = tuple(locals())\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e왜 튜플인가? (Why a tuple?)\u003c/h3\u003e\n\u003cp\u003e튜플(tuple)을 사용하는 것은 클래스의 속성이 정의된 순서를 노출한다는 사실을 반영합니다. \u003ccode\u003e__definition_order__\u003c/code\u003e가 설정될 때쯤에는 정의가 이미 완료되었으므로, 값의 내용과 순서는 변경되지 않습니다. 따라서 우리는 불변성(immutability) 상태를 전달하는 타입을 사용합니다.\u003c/p\u003e\n\u003ch3\u003e왜 읽기 전용 속성이 아닌가? (Why not a read-only attribute?)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e__definition_order__\u003c/code\u003e를 읽기 전용 속성(예: \u003ccode\u003ecls.__dict__\u003c/code\u003e)으로 만드는 것에 대한 몇 가지 타당한 주장이 있습니다. 가장 주목할 만한 점은 읽기 전용 속성이 속성의 \"완료\" 상태를 전달하며, 이는 \u003ccode\u003e__definition_order__\u003c/code\u003e에 정확히 해당합니다. 특정 일회성 이벤트(클래스 정의 본문의 실행)의 상태를 나타내므로, 값을 교체하는 것을 허용하면 속성이 원래 클래스 본문에 해당하는지에 대한 신뢰를 떨어뜨릴 것입니다. 또한, 기본적으로 불변(immutable) 접근 방식은 데이터를 추론하기 더 쉽게 만드는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e그러나 이 경우 Python에서 흔히 볼 수 있는 잘 확립된 선례에 반대할 강력한 이유는 여전히 없습니다. Guido에 따르면:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e저는 이것이 읽기 전용 속성일 필요가 있다고 생각하지 않습니다. 그런 경우는 거의 없습니다. 일반적으로 우리는 할당을 제한해야 할 강력한 이유가 없는 한 (예: 인터프리터의 내부 상태가 손상될 수 있는 경우) 사용자가 모든 것을 가지고 놀 수 있도록 합니다. 여기에는 그러한 강력한 이유가 보이지 않습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e또한, 쓰기 가능한(writeable) \u003ccode\u003e__definition_order__\u003c/code\u003e는 동적으로 생성된 클래스(예: Cython에 의해)도 \u003ccode\u003e__definition_order__\u003c/code\u003e가 제대로 설정될 수 있도록 허용합니다. 이는 \u003ccode\u003etype()\u003c/code\u003e 또는 C-API와 같은 특정 클래스 생성 도구를 통해 처리될 수 있었으며, 읽기 전용 속성의 의미를 잃을 필요는 없었습니다. 그러나 쓰기 가능한 속성을 사용하면 논쟁의 여지가 없습니다.\u003c/p\u003e\n\u003ch3\u003e왜 “\u003ccode\u003e__attribute_order__\u003c/code\u003e”가 아닌가? (Why not “\u003cstrong\u003eattribute_order\u003c/strong\u003e”?)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e__definition_order__\u003c/code\u003e는 클래스 정의 본문에 초점을 맞춥니다. 정의 이후 클래스 네임스페이스(\u003ccode\u003e__dict__\u003c/code\u003e)를 다루는 사용 사례는 별개의 문제입니다. \u003ccode\u003e__definition_order__\u003c/code\u003e는 클래스 정의 이상에 초점을 맞춘 기능에 대해 상당히 오해의 소지가 있는 이름이 될 것입니다.\u003c/p\u003e\n\u003ch3\u003e왜 “던더(dunder)” 이름을 무시하지 않는가? (Why not ignore “dunder” names?)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e__\u003c/code\u003e로 시작하고 끝나는 이름은 인터프리터(interpreter) 사용을 위해 예약되어 있습니다. 실제로는 \u003ccode\u003e__definition_order__\u003c/code\u003e 사용자에게 관련이 없어야 합니다. 대신, 거의 모든 사람에게는 혼란을 야기하고 (던더 이름을 필터링하는) 동일한 추가 작업을 유발할 뿐입니다. 던더 이름이 중요한 경우에는 클래스 정의에서 \u003ccode\u003e__definition_order__\u003c/code\u003e를 수동으로 설정할 수 있어 일반적인 경우를 더 간단하게 만듭니다.\u003c/p\u003e\n\u003cp\u003e그러나 \u003ccode\u003e__definition_order__\u003c/code\u003e에서 던더 이름을 제외하면 정의 순서에서 해당 위치가 복구 불가능하게 손실됩니다. 기본적으로 던더 이름을 제외하면 던더 이름을 비관습적으로 사용하는 클래스에 예기치 않은 문제를 일으킬 수 있습니다. 이 경우 안전하게 모든 이름을 클래스 정의에서 보존하는 것이 좋습니다. 던더 이름을 필터링하는 것은 쉽기 때문에 큰 문제는 아닙니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e(name for name in cls.__definition_order__ if not (name.startswith('__') and name.endswith('__')))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사실, 일부 애플리케이션 컨텍스트에서는 \u003ccode\u003e_\u003c/code\u003e로 시작하는 이름을 무시하거나, 모든 메서드를 제외하거나, 디스크립터만 포함하는 등 유사한 필터링이 적용될 수 있는 다른 기준이 있을 수 있습니다. 궁극적으로 던더 이름은 특별한 경우로 취급할 만큼 특별하지 않습니다.\u003c/p\u003e\n\u003cp\u003e두어 개의 던더 이름(\u003ccode\u003e__name__\u003c/code\u003e 및 \u003ccode\u003e__qualname__\u003c/code\u003e)은 컴파일러에 의해 기본적으로 주입됩니다. 따라서 엄밀히 말해 클래스 정의 본문의 일부는 아니지만 포함될 것입니다.\u003c/p\u003e\n\u003ch3\u003e왜 빈 튜플 대신 \u003ccode\u003eNone\u003c/code\u003e인가? (Why None instead of an empty tuple?)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e__definition_order__\u003c/code\u003e를 추가하는 핵심 목표는 이 PEP 이전에 손실되었던 클래스 정의의 정보를 보존하는 것입니다. 한 가지 결과는 \u003ccode\u003e__definition_order__\u003c/code\u003e가 원래 클래스 정의를 암시한다는 것입니다. \u003ccode\u003eNone\u003c/code\u003e을 사용하면 정의 순서가 없는 클래스를 명확하게 구별할 수 있습니다. 빈 튜플은 정의 문에서 왔지만 속성을 정의하지 않은 클래스를 명확하게 나타냅니다.\u003c/p\u003e\n\u003ch3\u003e왜 속성을 설정하지 않는 대신 \u003ccode\u003eNone\u003c/code\u003e인가? (Why None instead of not setting the attribute?)\u003c/h3\u003e\n\u003cp\u003e속성이 없는 것은 \u003ccode\u003e__definition_order__\u003c/code\u003e를 사용하는 소비자에게 \u003ccode\u003eNone\u003c/code\u003e보다 더 복잡한 처리를 요구합니다.\u003c/p\u003e\n\u003ch3\u003e왜 수동으로 설정된 값을 제약하는가? (Why constrain manually set values?)\u003c/h3\u003e\n\u003cp\u003e만약 \u003ccode\u003e__definition_order__\u003c/code\u003e가 클래스 본문에 수동으로 설정된다면, 그것이 사용될 것입니다. 우리는 \u003ccode\u003e__definition_order__\u003c/code\u003e의 소비자들이 값에 대해 일관된 기대를 가질 수 있도록 식별자 튜플(또는 \u003ccode\u003eNone\u003c/code\u003e)이어야 한다고 요구합니다. 이는 기능의 유용성을 극대화하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e수동으로 설정된 \u003ccode\u003e__definition_order__\u003c/code\u003e에 대해 임의의 이터러블(iterable)을 허용하고 튜플로 변환할 수도 있습니다. 그러나 모든 이터러블이 정의 순서를 추론하지는 않습니다(예: \u003ccode\u003eset\u003c/code\u003e). 따라서 우리는 튜플을 요구하는 것을 선택합니다.\u003c/p\u003e\n\u003ch3\u003e왜 \u003ccode\u003enon-type\u003c/code\u003e 객체에서 \u003ccode\u003e__definition_order__\u003c/code\u003e를 숨기지 않는가? (Why not hide \u003cstrong\u003edefinition_order\u003c/strong\u003e on non-type objects?)\u003c/h3\u003e\n\u003cp\u003ePython은 클래스 인스턴스에서 조회(lookup)할 때 클래스 특정 속성을 숨기기 위해 많은 노력을 기울이지 않습니다. \u003ccode\u003e__definition_order__\u003c/code\u003e를 클래스 전용 속성으로 간주하고 객체 조회 시 숨기는 것이 합리적일 수 있지만, 그 점에서 선례를 설정하는 것은 이 PEP의 목표를 넘어섭니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003e__slots__\u003c/code\u003e는 어떤가? (What about \u003cstrong\u003eslots\u003c/strong\u003e?)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e__slots__\u003c/code\u003e는 클래스 정의 본문의 다른 이름과 마찬가지로 \u003ccode\u003e__definition_order__\u003c/code\u003e에 추가됩니다. 실제 슬롯(slot) 이름은 정의 네임스페이스에 이름으로 설정되지 않으므로 \u003ccode\u003e__definition_order__\u003c/code\u003e에 추가되지 않습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003e__definition_order__\u003c/code\u003e가 왜 필요한가? (Why is \u003cstrong\u003edefinition_order\u003c/strong\u003e even necessary?)\u003c/h3\u003e\n\u003cp\u003e정의 순서는 \u003ccode\u003e__dict__\u003c/code\u003e에 보존되지 않으므로 클래스 정의 실행이 완료되면 손실됩니다. 클래스는 본문에서 마지막으로 속성을 명시적으로 설정할 수 있습니다. 그러나 이 경우 독립적인 데코레이터는 그렇게 한 클래스만 사용할 수 있습니다. 대신, \u003ccode\u003e__definition_order__\u003c/code\u003e는 클래스 본문에서 이 정보를 보존하여 보편적으로 사용할 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003eC-API 타입 지원 (Support for C-API Types)\u003c/h2\u003e\n\u003cp\u003e대부분의 C로 정의된 Python 타입(예: 내장 타입, 확장 모듈)은 정의 순서와 대략적으로 동등한 개념을 가지고 있다고 주장할 수 있습니다. 따라서 \u003ccode\u003e__definition_order__\u003c/code\u003e는 이러한 타입에 대해 자동으로 설정될 수 있다고 생각할 수 있습니다. 이 PEP는 그러한 지원을 도입하지 않습니다. 그러나 금지하지도 않습니다. 하지만 \u003ccode\u003e__definition_order__\u003c/code\u003e는 일반적인 속성 할당을 통해 언제든지 설정될 수 있으므로 C-API에서 특별한 처리가 필요하지 않습니다.\u003c/p\u003e\n\u003cp\u003e특정 사례:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebuiltin\u003c/code\u003e 타입\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyType_Ready\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyType_FromSpec\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e호환성 (Compatibility)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 클래스 정의 네임스페이스로 엄격하게 \u003ccode\u003edict\u003c/code\u003e에 의존하는 경우를 제외하고는 하위 호환성(backward compatibility)을 깨뜨리지 않습니다. \u003ccode\u003eissubclass(OrderedDict, dict)\u003c/code\u003e가 \u003ccode\u003eTrue\u003c/code\u003e이므로 이는 문제가 되지 않아야 합니다.\u003c/p\u003e\n\u003ch2\u003e변경 사항 (Changes)\u003c/h2\u003e\n\u003cp\u003e클래스 구문 외에도 다음은 새로운 동작을 노출합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebuiltins.__build_class__\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etypes.prepare_class\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etypes.new_class\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한 \u003ccode\u003ebuiltins.type()\u003c/code\u003e의 3인자 형식은 전달되는 네임스페이스에 \u003ccode\u003e__definition_order__\u003c/code\u003e를 포함하는 것을 허용합니다. \u003ccode\u003e__definition_order__\u003c/code\u003e가 클래스 본문에 명시적으로 정의될 때와 동일한 제약을 받습니다.\u003c/p\u003e\n\u003ch2\u003e다른 Python 구현체 (Other Python Implementations)\u003c/h2\u003e\n\u003cp\u003e피드백에 따라 Python 구현체에 미치는 영향은 최소화될 것으로 예상됩니다. 모든 규정 준수 구현체는 이 PEP에 설명된 대로 \u003ccode\u003e__definition_order__\u003c/code\u003e를 설정할 것으로 예상됩니다.\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e구현은 트래커에서 찾을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e대안 (Alternatives)\u003c/h2\u003e\n\u003ch3\u003e순서를 유지하는 \u003ccode\u003ecls.__dict__\u003c/code\u003e (An Order-preserving cls.\u003cstrong\u003edict\u003c/strong\u003e)\u003c/h3\u003e\n\u003cp\u003e정의 순서를 \u003ccode\u003e__definition_order__\u003c/code\u003e에 저장하는 대신, 이제 순서가 있는 정의 네임스페이스를 새 \u003ccode\u003eOrderedDict\u003c/code\u003e로 복사할 수 있었습니다. 그런 다음 이것은 \u003ccode\u003e__dict__\u003c/code\u003e로 프록시되는 매핑으로 사용될 것입니다. 이렇게 하면 대부분 동일한 의미를 제공할 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 \u003ccode\u003e__dict__\u003c/code\u003e에 \u003ccode\u003eOrderedDict\u003c/code\u003e를 사용하면 정의 네임스페이스와의 관계가 모호해져 유용성이 떨어집니다.\u003c/p\u003e\n\u003cp\u003e또한 (특히 \u003ccode\u003eOrderedDict\u003c/code\u003e의 경우) 이렇게 하면 구체적인 \u003ccode\u003edict\u003c/code\u003e C-API의 의미론에 상당한 변경이 필요할 것입니다.\u003c/p\u003e\n\u003cp\u003e삽입 순서를 (대부분) 보존하는 compact \u003ccode\u003edict\u003c/code\u003e 구현으로 전환하는 것에 대한 논의가 있었습니다. 그러나 명시적인 \u003ccode\u003e__definition_order__\u003c/code\u003e가 없다는 점은 여전히 어려운 문제로 남을 것입니다.\u003c/p\u003e\n\u003ch3\u003e클래스 정의를 위한 “namespace” 키워드 인자 (A “namespace” Keyword Arg for Class Definition)\u003c/h3\u003e\n\u003cp\u003ePEP 422는 클래스 정의에 새로운 \"namespace\" 키워드 인자를 도입했으며, 이는 \u003ccode\u003e__prepare__()\u003c/code\u003e의 필요성을 효과적으로 대체합니다. 그러나 이 제안은 더 간단한 PEP 487을 위해 철회되었습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eOrderedDict\u003c/code\u003e로 \u003ccode\u003e__prepare__()\u003c/code\u003e를 구현하는 표준 라이브러리 메타클래스 (A stdlib Metaclass that Implements \u003cstrong\u003eprepare\u003c/strong\u003e() with OrderedDict)\u003c/h3\u003e\n\u003cp\u003e이는 자신만의 메타클래스를 작성하는 것과 동일한 모든 문제를 가지고 있습니다. 유일한 장점은 이 메타클래스를 실제로 작성할 필요가 없다는 것입니다. 따라서 이 PEP의 맥락에서는 어떤 이점도 제공하지 않습니다.\u003c/p\u003e\n\u003ch3\u003e컴파일 시 \u003ccode\u003e__definition_order__\u003c/code\u003e 설정 (Set \u003cstrong\u003edefinition_order\u003c/strong\u003e at Compile-time)\u003c/h3\u003e\n\u003cp\u003e각 클래스의 \u003ccode\u003e__qualname__\u003c/code\u003e은 컴파일 시 결정됩니다. 이와 동일한 개념을 \u003ccode\u003e__definition_order__\u003c/code\u003e에 적용할 수 있었습니다. 컴파일 시 \u003ccode\u003e__definition_order__\u003c/code\u003e를 구성한 결과는 런타임에 수행하는 것과 거의 동일할 것입니다.\u003c/p\u003e\n\u003cp\u003e구현 난이도는 차치하고, 주요 차이점은 컴파일 시에는 클래스 본문에서 동적으로 설정되는 속성(예: \u003ccode\u003elocals()[name] = value\u003c/code\u003e)에 대한 정의 순서를 보존하는 것이 실용적이지 않다는 것입니다. 그러나 이러한 속성도 정의 순서에 반영되어야 합니다. 한 가지 가능한 해결책은 클래스 작성자가 동적으로 클래스 속성을 정의하는 경우 \u003ccode\u003e__definition_order__\u003c/code\u003e를 수동으로 설정하도록 요구하는 것입니다.\u003c/p\u003e\n\u003cp\u003e궁극적으로 런타임 또는 컴파일 시 \u003ccode\u003eOrderedDict\u003c/code\u003e 사용 여부는 거의 전적으로 구현 세부 사항입니다.\u003c/p\u003e\n\u003ch2\u003e참조 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://mail.python.org/pipermail/python-dev/2016-June/145150.html\"\u003eOriginal discussion\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://mail.python.org/pipermail/python-dev/2016-June/145173.html\"\u003eFollow-up 1\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://mail.python.org/pipermail/python-dev/2016-June/145214.html\"\u003eFollow-up 2\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://mail.python.org/pipermail/python-dev/2016-June/145229.html\"\u003eAlyssa (Nick) Coghlan's concerns about mutability\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 520 - Preserving Class Attribute Definition Order\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:13:52+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>