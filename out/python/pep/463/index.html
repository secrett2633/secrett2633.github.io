<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 463 - Exception-catching expressions</h1><div class="page__meta"><time dateTime="2025-09-26 22:11:32+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0463/">PEP 463 - Exception-catching expressions</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 15-Feb-2014</p>
</blockquote>
<h2>PEP 463 – 예외 처리 표현식 (Exception-catching expressions) 번역 및 정리</h2>
<h3>개요</h3>
<p>PEP 463은 표현식(expression) 내에서 예외(exception)를 처리할 수 있는 새로운 문법을 제안했습니다. 이는 PEP 308이 값 기반 조건(value-based conditions)을 표현식에 도입했던 것과 유사하게, 예외 기반 조건(exception-based conditions)을 표현식의 일부로 사용할 수 있도록 하는 것을 목표로 했습니다. 그러나 이 PEP는 결국 "거부됨(Rejected)" 상태가 되었습니다.</p>
<h3>거부 공지 (Rejection Notice)</h3>
<p>PEP 463은 Python-Dev 메일링 리스트에서 거부되었습니다. 제안된 문법 자체는 허용될 수 있다고 보았지만, 제안의 동기와 근거(motivation and rationale)에 대한 동의를 얻지 못했습니다. 특히 <code>dict.get()</code>과 같은 기존 메서드가 <code>except</code> 표현식이 도입되더라도 불필요해지지 않을 것이라는 점, 그리고 EAFP(Easier to Ask for Forgiveness than Permission)가 LBYL(Look Before You Leap)보다 항상 우수하거나 Python에서 "일반적으로 권장된다"는 주장에 동의하지 않았습니다.</p>
<h3>요약 (Abstract)</h3>
<p>PEP 308이 표현식에 값 기반 조건을 도입한 것처럼, 이 시스템은 예외 기반 조건을 표현식의 일부로 사용할 수 있도록 합니다.</p>
<h3>동기 (Motivation)</h3>
<p>많은 함수와 메서드는 예외를 발생시키는 대신 특정 값을 반환하도록 하는 매개변수를 가지고 있습니다. 하지만 현재 시스템은 임시적(ad-hoc)이고 일관성이 없으며, 각 함수가 이러한 기능을 개별적으로 구현해야 합니다. 모든 함수가 이 기능을 지원하는 것도 아닙니다.</p>
<p><strong>예시:</strong></p>
<ul>
<li><code>dict.get(key, default)</code>: <code>KeyError</code> 대신 두 번째 위치 인자(<code>default</code>)를 반환합니다.</li>
<li><code>next(iter, default)</code>: <code>StopIteration</code> 대신 두 번째 위치 인자(<code>default</code>)를 반환합니다.</li>
<li><code>list.pop()</code>: 기본값을 반환하는 방법이 없습니다.</li>
<li><code>seq[index]</code>: 경계 오류(bounds error)를 처리하는 방법이 없습니다.</li>
<li><code>min(sequence, default=default)</code>: <code>ValueError</code> 대신 키워드 인자 <code>default</code>를 반환합니다 (Python 3.4부터).</li>
<li><code>statistics.mean(data)</code>: 빈 이터레이터(empty iterator)를 처리하는 방법이 없습니다.</li>
</ul>
<p>만약 이 기능이 Python 역사 초기에 존재했다면, <code>dict.get()</code>과 같은 메서드를 만들 필요가 없었을 것입니다. 키가 없을 때를 처리하는 한 가지 분명한 방법은 예외에 응답하는 것이었을 테니까요. 대신 우리는 <code>dict.get()</code>과 Python 3.4부터 <code>min(... default=default)</code> 등 수많은 다른 방식들을 사용하고 있습니다.</p>
<p>표현식 내에서 테스트하기 위한 LBYL 문법은 있지만, 현재 EAFP 표기법은 없습니다. 다음을 비교해 보세요.</p>
<pre><code class="language-python"># LBYL:
if key in dic:
    process(dic[key])
else:
    process(None)

# 표현식 형태 (LBYL):
process(dic[key] if key in dic else None)

# EAFP:
try:
    process(dic[key])
except KeyError:
    process(None)

# 제안된 표현식 형태 (EAFP):
process(dic[key] except KeyError: None)
</code></pre>
<p>Python은 일반적으로 EAFP 정책을 권장하지만, 이를 가능하게 하기 위해 <code>dic.get(key,None)</code>과 같은 유틸리티 함수들을 증식시켜야 합니다.</p>
<h3>근거 (Rationale)</h3>
<p>현재 시스템에서는 함수 작성자가 기본값의 필요성을 예측하고 이를 지원하도록 구현해야 합니다. 그렇지 않으면 전체 <code>try/except</code> 블록이 필요합니다.</p>
<p><code>try/except</code>는 문(statement)이기 때문에 표현식 중간에서 예외를 잡는 것이 불가능합니다. <code>if/else</code>가 조건문에, <code>lambda</code>가 함수 정의에 하는 것처럼, 이 제안은 표현식 컨텍스트에서 예외 처리를 가능하게 합니다.</p>
<p>이는 함수가 기본값을 제공하는 깨끗하고 일관된 방법을 제공합니다: 단순히 적절한 예외를 발생시키고, 호출자가 이를 잡습니다.</p>
<p>어떤 상황에서는 LBYL 기법을 사용할 수 있습니다 (예를 들어, 시퀀스의 인덱스를 사용하기 전에 길이가 충분한지 확인하는 것). 이는 모든 경우에 안전하지는 않지만, 종종 편리하기 때문에 프로그래머들은 LBYL의 간결한 표기법을 위해 EAFP의 안전성을 희생하고 싶어 할 것입니다. 또한, 일부 LBYL 기법(예: 세 인자를 가진 <code>getattr</code> 사용)은 코드를 속성 조회(attribute lookup)가 아닌 문자열 리터럴처럼 보이게 만들어 가독성에 영향을 줄 수 있습니다. 편리한 EAFP 표기법은 이 모든 문제를 해결합니다.</p>
<p>이를 위한 헬퍼 함수를 작성하는 편리한 방법은 없습니다. 가장 가까운 것은 <code>lambda</code>를 사용한 다소 지저분한 방식입니다.</p>
<pre><code class="language-python">def except_(expression, exception_list, default):
    try:
        return expression()
    except exception_list:
        return default()

value = except_(lambda: 1/x, ZeroDivisionError, lambda: float("nan"))
</code></pre>
<p>이는 투박하고 여러 <code>except</code> 절(clause)을 처리할 수 없습니다. <code>eval</code>을 사용하는 것은 더욱 투박하고 구현에 의존적인 핵(hack)에 의존합니다.</p>
<p>Raymond Hettinger는 이러한 일관된 API에 대한 열망을 표명했으며, 유사한 요청이 과거에도 여러 번 있었습니다.</p>
<h3>제안 (Proposal)</h3>
<p><code>or</code> 연산자와 세 부분으로 된 <code>if-else</code> 표현식이 거짓 값(falsy value)을 잡고 대체하는 단락 평가(short-circuiting) 방식을 제공하는 것처럼, 이 문법은 예외를 잡고 대체하는 단락 평가 방식을 제공합니다.</p>
<p>현재는 다음과 같이 작동합니다:</p>
<pre><code class="language-python">lst = [1, 2, None, 3]
value = lst[2] or "No value" # None이 거짓 값이므로 "No value"가 됨
</code></pre>
<p>제안은 다음을 추가합니다:</p>
<pre><code class="language-python">lst = [1, 2]
value = (lst[2] except IndexError: "No value") # lst[2]가 IndexError를 발생시키면 "No value"가 됨
</code></pre>
<p>구체적으로 제안된 문법은 다음과 같습니다:</p>
<p><code>(expr except exception_list: default)</code></p>
<p>여기서 <code>expr</code>, <code>exception_list</code>, <code>default</code>는 모두 표현식입니다.</p>
<ol>
<li>먼저 <code>expr</code>이 평가됩니다.</li>
<li>예외가 발생하지 않으면, <code>expr</code>의 값이 전체 표현식의 값이 됩니다.</li>
<li>어떤 예외라도 발생하면, <code>exception_list</code>가 평가되며, <code>try/except</code> 문의 형태와 마찬가지로 타입(type) 또는 튜플(tuple)을 결과로 해야 합니다.</li>
<li>일치하는 예외가 발생하면, 해당 <code>default</code> 표현식이 평가되고 이 값이 전체 표현식의 값이 됩니다.</li>
<li><code>try/except</code> 문의 형태와 마찬가지로, 일치하지 않는 예외는 위로 전파됩니다.</li>
</ol>
<p>전체 표현식은 괄호로 묶어야 합니다. 이는 <code>generator expression</code>이 따르는 규칙과 동일하게, 괄호가 완전히 중복되는 경우가 아니라면 필요합니다. 이는 중첩된 <code>except</code> 표현식의 올바른 해석을 보장하고, 문법의 향후 확장을 허용합니다.</p>
<p><strong>참고:</strong> 현재 제안은 예외 객체(exception object)를 캡처하는 것을 허용하지 않습니다. 이것이 필요한 경우에는 문(statement) 형태를 사용해야 합니다.</p>
<p>이 삼항 연산자(ternary operator)는 <code>lambda</code>와 <code>if/else</code> 사이의 연산자 우선순위(precedence)를 가집니다.</p>
<p>두 단계 캐시(two-level cache)의 다음 예를 고려해 보세요:</p>
<pre><code class="language-python">for key in sequence:
    x = (lvl1[key] except KeyError: (lvl2[key] except KeyError: f(key)))
    # x를 가지고 뭔가 한다
</code></pre>
<p>이것은 다음처럼 다시 작성될 수 없습니다:</p>
<pre><code class="language-python">x = lvl1.get(key, lvl2.get(key, f(key)))
</code></pre>
<p>위 코드는 더 짧지만, <code>get()</code>에 전달할 기본값을 계산해야 하므로 캐시의 목적을 무력화시킵니다. <code>.get()</code> 버전은 역방향으로 계산하고, 예외 테스트 버전은 예상대로 정방향으로 계산합니다. 가장 유용한 등가물은 다음과 같을 것입니다:</p>
<pre><code class="language-python">x = lvl1.get(key) or lvl2.get(key) or f(key)
</code></pre>
<p>이는 값들이 0이 아닐 뿐만 아니라 캐시 객체가 이 기능을 지원하는지에 따라 달라집니다.</p>
<h3>대안 제안 (Alternative Proposals)</h3>
<p><code>python-ideas</code>에서의 논의는 다음과 같은 문법 제안들을 이끌어냈습니다:</p>
<ul>
<li><code>value = expr except default if Exception [as e]</code></li>
<li><code>value = expr except default for Exception [as e]</code></li>
<li><code>value = expr except default from Exception [as e]</code></li>
<li><code>value = expr except Exception [as e] return default</code></li>
<li><code>value = expr except (Exception [as e]: default)</code></li>
<li><code>value = expr except Exception [as e] try default</code></li>
<li><code>value = expr except Exception [as e] continue with default</code></li>
<li><code>value = default except Exception [as e] else expr</code></li>
<li><code>value = try expr except Exception [as e]: default</code></li>
<li><code>value = expr except default # 모든 예외를 잡음</code></li>
<li><code>value = expr except(Exception) default # 지정된 타입의 예외만 잡음</code></li>
<li><code>value = default if expr raise Exception</code></li>
<li><code>value = expr or else default if Exception</code></li>
<li><code>value = expr except Exception [as e] -> default</code></li>
<li><code>value = expr except Exception [as e] pass default</code></li>
</ul>
<p>새로운 키워드를 만드는 대신 기존 키워드를 재사용하는 것이 제안되기도 했습니다. 그러한 제안들은 마지막 형태와 동일한 구조를 가지지만, <code>'pass'</code> 대신 다른 키워드를 사용합니다. 제안된 키워드로는 <code>'then'</code>, <code>'when'</code>, <code>'use'</code> 등이 있습니다. 또한, "default if expr raise Exception" 제안과 관련하여 새로운 키워드 "<code>raises</code>"를 사용하는 것이 제안되었습니다.</p>
<p><code>as</code> 캡처 절(capturing clause)을 포함하는 모든 형태는 단순성을 위해 이 제안에서 연기되었지만, 제안의 정확한 기록으로 위 표에 보존되어 있습니다.</p>
<p>이 제안에서 가장 많이 지지받은 네 가지 형태는 순서대로 다음과 같습니다:</p>
<ol>
<li><code>value = (expr except Exception: default)</code></li>
<li><code>value = (expr except Exception -> default)</code></li>
<li><code>value = (expr except Exception pass default)</code></li>
<li><code>value = (expr except Exception then default)</code></li>
</ol>
<p>네 가지 모두 좌우 평가 순서(left-to-right evaluation order)를 유지합니다: 먼저 기본 표현식, 다음으로 예외 목록, 마지막으로 기본값입니다. 이는 표현식들이 지연 평가(lazily evaluated)되기 때문에 중요합니다.</p>
<p>콜론을 사용하는 선호되는 형태는 "except exception_list:"를 사용하여 <code>try/except</code>와 유사하며, "keyword name_list: subexpression"을 사용하여 <code>lambda</code>와 유사합니다. 또한, 예외를 기본값에 매핑하는 사전(dict) 스타일로 읽을 수도 있습니다. 화살표를 사용하는 것은 많은 프로그래머에게 익숙하지 않고 현재 유사한 의미가 없는 토큰을 도입하지만, 그 외에는 상당히 읽기 쉽습니다. 영어 단어 "pass"는 막연하게 유사한 의미를 가지며 ("pass by value/reference"와 같은 함수 인수의 일반적인 사용을 고려), "pass"는 이미 키워드이지만, 그 의미가 분명히 관련이 없으므로 혼란을 야기할 수 있습니다. "then"을 사용하는 것은 영어에서는 의미가 있지만, 이는 언어에 새로운 키워드를 도입하는 것입니다.</p>
<p>좌우 평가 순서는 대부분의 표현식이 평가되는 순서와 일치하기 때문에 가독성에 매우 중요합니다.</p>
<p>기존 표기법을 유지하되 필수 괄호의 위치를 변경하는 다음 제안도 있었습니다:</p>
<ul>
<li><code>value = expr except (Exception: default)</code></li>
<li><code>value = expr except(Exception: default)</code></li>
</ul>
<p>이는 함수 호출이나 딕셔너리 초기화와 유사합니다. 콜론이 스위트(suite)를 도입하는 것으로 혼동될 수는 없지만, 새로운 문법은 지연 평가를 보장하는데 딕셔너리는 그렇지 않습니다. 혼란을 줄일 잠재력은 혼란을 증가시킬 잠재력에 의해 정당화되지 않는다고 간주되었습니다.</p>
<h3>사용 예시 (Example usage)</h3>
<p>각 예시에는 표현식이 어떻게 파싱될지를 보여주기 위해 대략적으로 동등한 문(statement) 형태가 주어집니다. 이들은 엄밀히 동일하지는 않지만, 동일한 목적을 달성합니다. 인터프리터가 하나를 다른 것으로 번역하는 것은 안전하지 않습니다.</p>
<p>이 예시들 중 상당수는 Python 표준 라이브러리에서 직접 가져온 것으로, 2014년 2월 초 기준 파일 이름과 줄 번호가 정확합니다. 이러한 패턴 중 많은 것들이 매우 일반적입니다.</p>
<ul>
<li>
<p><strong>인자 검색, 기본값은 <code>None</code>:</strong></p>
<pre><code class="language-python">cond = (args[1] except IndexError: None)
# Equivalent statement form:
# try:
#     cond = args[1]
# except IndexError:
#     cond = None
</code></pre>
</li>
<li>
<p><strong>시스템에서 정보를 가져옴 (가능한 경우):</strong></p>
<pre><code class="language-python">pwd = (os.getcwd() except OSError: None)
# Equivalent statement form:
# try:
#     pwd = os.getcwd()
# except OSError:
#     pwd = None
</code></pre>
</li>
<li>
<p><strong>번역 시도, 실패 시 원본으로 대체:</strong></p>
<pre><code class="language-python">e.widget = (self._nametowidget(W) except KeyError: W)
# Equivalent statement form:
# try:
#     e.widget = self._nametowidget(W)
# except KeyError:
#     e.widget = W
</code></pre>
</li>
<li>
<p><strong>이터레이터에서 읽기, 소진 시 빈 줄로 계속:</strong></p>
<pre><code class="language-python">line = (readline() except StopIteration: '')
# Equivalent statement form:
# try:
#     line = readline()
# except StopIteration:
#     line = ''
</code></pre>
</li>
<li>
<p><strong>플랫폼별 정보 검색 (DRY 개선점 주목):</strong></p>
<pre><code class="language-python">_CONFIG_VARS['abiflags'] = (sys.abiflags except AttributeError: '')
# Equivalent statement form:
# try:
#     _CONFIG_VARS['abiflags'] = sys.abiflags
# except AttributeError:
#     _CONFIG_VARS['abiflags'] = ''
</code></pre>
</li>
<li>
<p><strong>인덱싱된 항목 검색, 기본값은 <code>None</code> (<code>dict.get</code>과 유사):</strong></p>
<pre><code class="language-python">def getNamedItem(self, name):
    return (self._attrs[name] except KeyError: None)
# Equivalent statement form:
# def getNamedItem(self, name):
#     try:
#         return self._attrs[name]
#     except KeyError:
#         return None
</code></pre>
</li>
<li>
<p><strong>숫자를 이름으로 번역, 실패 시 숫자로 대체:</strong></p>
<pre><code class="language-python">g = (grp.getgrnam(tarinfo.gname)[2] except KeyError: tarinfo.gid)
u = (pwd.getpwnam(tarinfo.uname)[2] except KeyError: tarinfo.uid)
# Equivalent statement form:
# try:
#     g = grp.getgrnam(tarinfo.gname)[2]
# except KeyError:
#     g = tarinfo.gid
# try:
#     u = pwd.getpwnam(tarinfo.uname)[2]
# except KeyError:
#     u = tarinfo.uid
</code></pre>
</li>
<li>
<p><strong>속성 조회, 실패 시 기본값으로 대체:</strong></p>
<pre><code class="language-python">mode = (f.mode except AttributeError: 'rb')
# Equivalent statement form:
# if hasattr(f, 'mode'):
#     mode = f.mode
# else:
#     mode = 'rb'

return (sys._getframe(1) except AttributeError: None)
# Equivalent statement form:
# return sys._getframe(1) if hasattr(sys, "_getframe") else None
</code></pre>
</li>
<li>
<p><strong>EAFP 모드에서 긴 계산 수행, 0으로 나누기를 sticky NaN으로 처리:</strong></p>
<pre><code class="language-python">value = (calculate(x) except ZeroDivisionError: float("nan"))
# Equivalent statement form:
# try:
#     value = calculate(x)
# except ZeroDivisionError:
#     value = float("nan")
</code></pre>
</li>
<li>
<p><strong>일련의 숫자의 평균 계산, 실패 시 0으로 대체:</strong></p>
<pre><code class="language-python">value = (statistics.mean(lst) except statistics.StatisticsError: 0)
# Equivalent statement form:
# try:
#     value = statistics.mean(lst)
# except statistics.StatisticsError:
#     value = 0
</code></pre>
</li>
<li>
<p><strong>오버라이드(override)의 희소 목록에서 객체 조회:</strong></p>
<pre><code class="language-python">(overrides[x] or default except IndexError: default).ping()
# Equivalent statement form:
# try:
#     (overrides[x] or default).ping()
# except IndexError:
#     default.ping()
</code></pre>
</li>
</ul>
<h4>예외 처리 범위 좁히기 (Narrowing of exception-catching scope)</h4>
<p>Python의 표준 라이브러리에서 가져온 다음 예시들은 <code>try/except</code>의 범위를 편리하게 좁힐 수 있는 방법을 보여줍니다. <code>try/except</code> 문 형태로는 임시 변수가 필요하지만, 표현식으로는 훨씬 깔끔합니다.</p>
<p><code>Lib/ipaddress.py:343</code>:</p>
<pre><code class="language-python">try:
    ips.append(ip.ip)
except AttributeError:
    ips.append(ip.network_address)
</code></pre>
<p>다음과 같이 됩니다:</p>
<pre><code class="language-python">ips.append(ip.ip except AttributeError: ip.network_address)
</code></pre>
<p>표현식 형태는 다음 코드와 거의 동일합니다:</p>
<pre><code class="language-python">try:
    _ = ip.ip
except AttributeError:
    _ = ip.network_address
ips.append(_)
</code></pre>
<p><code>Lib/tempfile.py:130</code>:</p>
<pre><code class="language-python">try:
    dirlist.append(_os.getcwd())
except (AttributeError, OSError):
    dirlist.append(_os.curdir)
</code></pre>
<p>다음과 같이 됩니다:</p>
<pre><code class="language-python">dirlist.append(_os.getcwd() except (AttributeError, OSError): _os.curdir)
</code></pre>
<p><code>Lib/asyncore.py:264</code>:</p>
<pre><code class="language-python">try:
    status.append('%s:%d' % self.addr)
except TypeError:
    status.append(repr(self.addr))
</code></pre>
<p>다음과 같이 됩니다:</p>
<pre><code class="language-python">status.append('%s:%d' % self.addr except TypeError: repr(self.addr))
</code></pre>
<p>각 경우에, 좁혀진 <code>try/except</code>의 범위는 예상치 못한 예외 (예를 들어, "append"를 잘못 입력했을 때의 <code>AttributeError</code>)가 동일한 핸들러에 의해 잡히지 않도록 보장합니다.</p>
<h3>다른 언어와의 비교 (Comparisons with other languages)</h3>
<p>(이 섹션을 정리해 준 Andrew Barnert에게 감사드립니다. 여기에 주어진 예시들은 제안의 현재 버전을 반영하지 않으므로 편집이 필요합니다.)</p>
<ul>
<li><strong>Ruby:</strong> <code>begin...rescue...rescue...else...ensure...end</code>는 표현식입니다.</li>
<li><strong>Erlang:</strong> <code>try</code> 표현식을 가집니다.</li>
<li><strong>ML 계열 언어 (SML, OCaml):</strong> <code>handle</code> 및 <code>try</code>를 통해 예외를 처리합니다.</li>
<li><strong>Oz:</strong> <code>try ... catch ... then</code> 형태를 가집니다.</li>
<li><strong>Lisp 계열 언어 (Clojure, Common Lisp):</strong> <code>try/catch</code>를 특별한 형태(special forms)로 구현합니다.</li>
<li><strong>Lua:</strong> <code>xpcall</code> 함수를 사용합니다.</li>
<li><strong>Haskell:</strong> <code>catch</code>를 사용하여 예외를 처리합니다.</li>
<li><strong>Tcl:</strong> <code>catch</code> 함수를 사용합니다.</li>
<li><strong>Smalltalk:</strong> <code>on:do:</code> 구문을 사용합니다.</li>
</ul>
<p>Haskell의 <code>catch</code>는 제안된 <code>lambda</code>의 콜론과 <code>except</code>의 콜론 사이의 유사성을 더욱 분명하게 보여줍니다.</p>
<pre><code class="language-python">x = expression() except Exception: default()
x = expression() except Exception as e: default(e)
</code></pre>
<h3>연기된 하위 제안 (Deferred sub-proposals)</h3>
<h4>여러 <code>except</code> 절 (Multiple except clauses)</h4>
<p>사용 사례를 검토한 결과, 문(statement) 형태에서만큼 자주 필요하지 않으며, 구문적 합의가 이루어지지 않아 전체 기능이 연기되었습니다.</p>
<p>여러 <code>except</code> 키워드를 사용할 수 있었고, 이는 모두 원래 표현식에서 발생한 예외만 잡을 것입니다.</p>
<pre><code class="language-python"># expr에 의해 발생한 나열된 예외 중 하나를 잡습니다.
# default 표현식에 의해 발생한 예외는 전파됩니다.
value = (expr except Exception1: default1
              except Exception2: default2
              # ...
              except ExceptionN: defaultN )
</code></pre>
<p>현재는 다음 형태 중 하나를 사용해야 합니다:</p>
<pre><code class="language-python"># expr 또는 default1에 의해 발생한 Exception2를 잡습니다.
value = ( (expr except Exception1: default1) except Exception2: default2 )
# default1에 의해 발생한 Exception2만 잡습니다.
value = (expr except Exception1: (default1 except Exception2: default2) )
</code></pre>
<p>괄호 없이 여러 <code>except</code> 절을 나열하는 것은 문법 오류이므로, Python의 향후 버전은 기존 코드를 손상시키지 않고 이 기능을 추가할 수 있습니다.</p>
<h4>예외 객체 캡처 (Capturing the exception object)</h4>
<p><code>try/except</code> 블록에서 <code>as</code>를 사용하여 예외 객체를 캡처하는 것은 지역 이름 바인딩을 생성하고, <code>finally</code> 절에서 해당 바인딩을 암묵적으로 삭제합니다 (참조 루프를 피하기 위함). 표현식 컨텍스트에서는 이것이 거의 의미가 없으며, 예외 객체를 안전하게 캡처하려면 적절한 하위 범위(sub-scope)가 필요합니다. 이는 리스트 컴프리헨션(list comprehension)이 처리되는 방식과 유사합니다.</p>
<p>그러나 CPython은 현재 컴프리헨션의 하위 범위를 중첩된 함수 호출로 구현하는데, 이는 클래스 정의와 같은 일부 컨텍스트에서 문제를 야기할 수 있어 이 제안에는 부적합합니다. 미래에 진정한 하위 범위를 생성하는 방법(컴프리헨션, <code>except</code> 표현식, <code>with</code> 블록 등을 단순화할 수 있는)이 생긴다면 이 제안은 부활할 수 있습니다. 그때까지는 단순한 예외 처리가 이 표현식 표기법에 잘 맞으며, 일반적으로 예외의 타입에만 관심이 있고 그 값에는 관심이 없으므로 큰 손실은 아닙니다.</p>
<p>이 문법은 대화형 Python에서 예외를 편리하게 캡처할 수 있는 방법을 제공할 수 있습니다. 반환 값은 <code>_</code>로 캡처되지만, 예외는 현재 그렇지 않습니다.</p>
<pre><code class="language-python">>>> (expr except Exception as e: e)
</code></pre>
<p>Python 표준 라이브러리를 검토한 결과, <code>as</code>의 사용이 상당히 흔하지만 (대략 5개의 <code>except</code> 절 중 하나), 표현식 형태로 논리적으로 변환될 수 있는 경우에는 극히 드뭅니다. 몇 안 되는 용례는 단순히 변경하지 않고 남겨둘 수 있습니다. 따라서 단순성을 위해 이 제안에는 <code>as</code> 절이 포함되지 않습니다. <code>as</code>는 이미 키워드이므로, 후속 Python 버전은 기존 코드를 손상시키지 않고 이를 추가할 수 있습니다.</p>
<h3>거부된 하위 제안 (Rejected sub-proposals)</h3>
<h4><code>finally</code> 절 (finally clause)</h4>
<p><code>try...finally</code> 또는 <code>try...except...finally</code> 문 형태는 논리적으로 대응하는 표현식 형태가 없습니다. 따라서 <code>finally</code> 키워드는 어떤 식으로든 이 제안의 일부가 아닙니다.</p>
<h4><code>bare except</code>의 다른 의미 (Bare except having different meaning)</h4>
<p>몇몇 제안된 구문에서 예외 타입 이름을 생략하는 것이 쉽고 간결하며 매력적일 수 있었습니다. 편의를 위해 <code>bare 'except'</code> 절이 "except <code>BaseException</code>"보다 더 유용한 의미를 가지도록 하는 것이 유리할 수 있었습니다. 제안에는 <code>Exception</code>을 잡도록 하거나, 특정 "일반적인 예외" 세트(새로운 타입 <code>ExpressionError</code>의 서브클래스)를 잡도록 하거나, 현재 범위에서 <code>ExpressionError</code>라는 튜플을 찾도록 하여 (기본값으로 <code>(ValueError, UnicodeError, AttributeError, EOFError, IOError, OSError, LookupError, NameError, ZeroDivisionError)</code>와 같은) 잡도록 하는 것이 포함되었습니다. 이 모든 것은 여러 가지 이유로 거부되었습니다.</p>
<p>무엇보다도, <code>try/except</code> 문의 형태와의 일관성이 깨질 것입니다. 리스트 컴프리헨션이나 삼항 <code>if</code> 표현식이 수직적인 문 형태로 "풀어써서" 설명될 수 있는 것처럼, 표현식 <code>except</code>도 거의 동등한 문으로 상대적으로 기계적인 번역을 통해 설명될 수 있어야 합니다. 따라서 양쪽에 공통된 어떤 형태의 구문이든 각자 동일한 의미를 가져야 하며, 무엇보다도 한쪽이 다른 쪽보다 더 많은 것을 잡는 미묘한 차이를 가져서는 안 됩니다.</p>
<p>둘째, 잡을 적절한 예외 집합 자체가 큰 논쟁의 여지가 될 것입니다. 어떤 예외를 잡는 것이 "합리적인지" 정확히 예측하는 것은 불가능할 것입니다.</p>
<p>셋째, 예상치 못한 예외를 잡는 어떤 상황도 불필요한 버그를 유발합니다.</p>
<p>결과적으로, <code>bare 'except'</code>의 사용은 두 가지 가능성으로 귀결됩니다: 표현식 형태에서 문법적으로 금지되거나, 문 형태와 정확히 동일한 의미(즉, <code>BaseException</code>을 잡고 <code>as</code>로 캡처할 수 없음)로 허용되는 것입니다.</p>
<h4><code>bare except</code> 절 (Bare except clauses)</h4>
<p>PEP 8은 <code>bare 'except'</code>의 사용을 올바르게 권장하지 않습니다. 문(statement)에서는 문법적으로 유효하고 하위 호환성을 위해 유지되어야 하지만, 그 사용을 장려할 가치는 거의 없습니다. 표현식 <code>except</code> 절에서 "except:"는 <code>SyntaxError</code>입니다; 대신 동등한 전체 형태인 "except <code>BaseException</code>:"을 사용해야 합니다. Python의 향후 버전은 이를 복원하기로 선택할 수도 있으며, 이는 호환성을 깨지 않고 수행할 수 있습니다.</p>
<h4><code>except</code> 절 주위의 괄호 (Parentheses around the except clauses)</h4>
<p>예외를 발생시킬 수 있는 표현식과는 별도로 <code>except</code> 절에 괄호를 붙이는 것이 합법적이어야 하는가? 예시:</p>
<pre><code class="language-python">value = expr ( except Exception1 [as e]: default1
               except Exception2 [as e]: default2
               # ...
               except ExceptionN [as e]: defaultN )
</code></pre>
<p>이는 여러 <code>except</code> 절 및/또는 예외 캡처에 대한 연기된 하위 제안 중 하나 또는 둘 모두가 포함될 때 더욱 설득력이 있습니다.</p>
<p>장점은 미미하며, 독자가 <code>except</code> 절이 표현식과 분리되어 있다고 생각하거나 이것이 함수 호출이라고 생각하도록 혼란시킬 가능성 때문에 설득력이 없습니다. 물론, 원하는 경우 표현식도 괄호로 묶을 수 있으며, 기본값도 마찬가지입니다.</p>
<pre><code class="language-python">value = (expr) except ExceptionType: (default)
</code></pre>
<p>이제 전체 표현식이 괄호로 묶여야 하므로 (이 논의 당시에는 결정되지 않았던 사항), 이 섹션을 구분할 필요성이 줄어들고 많은 경우 중복될 것입니다.</p>
<h4>"except: pass"의 줄임말 (Short-hand for “except: pass”)</h4>
<p>다음은 기술적으로 표현식은 아니지만 유사한 줄임말로 제안되었습니다:</p>
<pre><code class="language-python">statement except Exception: pass
# Equivalent statement form:
# try:
#     statement
# except Exception:
#     pass
</code></pre>
<p>예를 들어, 파일 삭제를 시도하는 일반적인 사용 사례는 다음과 같습니다:</p>
<pre><code class="language-python">os.unlink(some_file) except OSError: pass
</code></pre>
<p>Python 3.4의 <code>contextlib</code>에는 이미 동등한 것이 있습니다:</p>
<pre><code class="language-python">from contextlib import suppress
with suppress(OSError):
    os.unlink(some_file)
</code></pre>
<p>이는 이미 한 줄이므로, 이를 달성하기 위해 새로운 구문이나 문(statement)과 표현식(expression)의 혼동이 필요하지 않습니다.</p>
<h3>일반적인 반대 의견 (Common objections)</h3>
<h4>콜론은 항상 스위트를 도입한다 (Colons always introduce suites)</h4>
<p>Python의 많은 구문 요소가 콜론을 사용하여 문 스위트(<code>if</code>, <code>while</code>, <code>with</code>, <code>for</code> 등)를 도입하는 것은 사실이지만, 이것이 콜론의 유일한 용도는 아닙니다. 현재 Python 구문에는 콜론이 하위 표현식(subexpression)을 도입하는 네 가지 경우가 있습니다:</p>
<ul>
<li>딕셔너리 표현식 (<code>dict display</code>) - <code>{ ... key:value ... }</code></li>
<li>슬라이스 표기법 (<code>slice notation</code>) - <code>[start:stop:step]</code></li>
<li>함수 정의 (<code>function definition</code>) - <code>parameter : annotation</code></li>
<li>람다 (<code>lambda</code>) - <code>arg list: return value</code></li>
</ul>
<p>이 제안은 다섯 번째를 추가할 뿐입니다:</p>
<ul>
<li><code>except</code> 표현식 (<code>except-expression</code>) - <code>exception list: result</code></li>
</ul>
<p>스타일 가이드와 PEP 8은 줄 바꿈된 줄의 끝에 콜론을 두지 않도록 권장해야 합니다. 이는 스위트의 도입처럼 보일 수 있기 때문입니다. 대신 예외 목록 앞에 줄 바꿈을 하여 콜론이 두 표현식 사이에 명확하게 오도록 해야 합니다.</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 공개 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/463\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"SAPzS3zi9tsG5MkeKvxIA\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/463/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/463\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"463\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/463\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T7e87,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0463/\"\u003ePEP 463 - Exception-catching expressions\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 15-Feb-2014\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 463 – 예외 처리 표현식 (Exception-catching expressions) 번역 및 정리\u003c/h2\u003e\n\u003ch3\u003e개요\u003c/h3\u003e\n\u003cp\u003ePEP 463은 표현식(expression) 내에서 예외(exception)를 처리할 수 있는 새로운 문법을 제안했습니다. 이는 PEP 308이 값 기반 조건(value-based conditions)을 표현식에 도입했던 것과 유사하게, 예외 기반 조건(exception-based conditions)을 표현식의 일부로 사용할 수 있도록 하는 것을 목표로 했습니다. 그러나 이 PEP는 결국 \"거부됨(Rejected)\" 상태가 되었습니다.\u003c/p\u003e\n\u003ch3\u003e거부 공지 (Rejection Notice)\u003c/h3\u003e\n\u003cp\u003ePEP 463은 Python-Dev 메일링 리스트에서 거부되었습니다. 제안된 문법 자체는 허용될 수 있다고 보았지만, 제안의 동기와 근거(motivation and rationale)에 대한 동의를 얻지 못했습니다. 특히 \u003ccode\u003edict.get()\u003c/code\u003e과 같은 기존 메서드가 \u003ccode\u003eexcept\u003c/code\u003e 표현식이 도입되더라도 불필요해지지 않을 것이라는 점, 그리고 EAFP(Easier to Ask for Forgiveness than Permission)가 LBYL(Look Before You Leap)보다 항상 우수하거나 Python에서 \"일반적으로 권장된다\"는 주장에 동의하지 않았습니다.\u003c/p\u003e\n\u003ch3\u003e요약 (Abstract)\u003c/h3\u003e\n\u003cp\u003ePEP 308이 표현식에 값 기반 조건을 도입한 것처럼, 이 시스템은 예외 기반 조건을 표현식의 일부로 사용할 수 있도록 합니다.\u003c/p\u003e\n\u003ch3\u003e동기 (Motivation)\u003c/h3\u003e\n\u003cp\u003e많은 함수와 메서드는 예외를 발생시키는 대신 특정 값을 반환하도록 하는 매개변수를 가지고 있습니다. 하지만 현재 시스템은 임시적(ad-hoc)이고 일관성이 없으며, 각 함수가 이러한 기능을 개별적으로 구현해야 합니다. 모든 함수가 이 기능을 지원하는 것도 아닙니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edict.get(key, default)\u003c/code\u003e: \u003ccode\u003eKeyError\u003c/code\u003e 대신 두 번째 위치 인자(\u003ccode\u003edefault\u003c/code\u003e)를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enext(iter, default)\u003c/code\u003e: \u003ccode\u003eStopIteration\u003c/code\u003e 대신 두 번째 위치 인자(\u003ccode\u003edefault\u003c/code\u003e)를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elist.pop()\u003c/code\u003e: 기본값을 반환하는 방법이 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eseq[index]\u003c/code\u003e: 경계 오류(bounds error)를 처리하는 방법이 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emin(sequence, default=default)\u003c/code\u003e: \u003ccode\u003eValueError\u003c/code\u003e 대신 키워드 인자 \u003ccode\u003edefault\u003c/code\u003e를 반환합니다 (Python 3.4부터).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estatistics.mean(data)\u003c/code\u003e: 빈 이터레이터(empty iterator)를 처리하는 방법이 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e만약 이 기능이 Python 역사 초기에 존재했다면, \u003ccode\u003edict.get()\u003c/code\u003e과 같은 메서드를 만들 필요가 없었을 것입니다. 키가 없을 때를 처리하는 한 가지 분명한 방법은 예외에 응답하는 것이었을 테니까요. 대신 우리는 \u003ccode\u003edict.get()\u003c/code\u003e과 Python 3.4부터 \u003ccode\u003emin(... default=default)\u003c/code\u003e 등 수많은 다른 방식들을 사용하고 있습니다.\u003c/p\u003e\n\u003cp\u003e표현식 내에서 테스트하기 위한 LBYL 문법은 있지만, 현재 EAFP 표기법은 없습니다. 다음을 비교해 보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# LBYL:\r\nif key in dic:\r\n    process(dic[key])\r\nelse:\r\n    process(None)\r\n\r\n# 표현식 형태 (LBYL):\r\nprocess(dic[key] if key in dic else None)\r\n\r\n# EAFP:\r\ntry:\r\n    process(dic[key])\r\nexcept KeyError:\r\n    process(None)\r\n\r\n# 제안된 표현식 형태 (EAFP):\r\nprocess(dic[key] except KeyError: None)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython은 일반적으로 EAFP 정책을 권장하지만, 이를 가능하게 하기 위해 \u003ccode\u003edic.get(key,None)\u003c/code\u003e과 같은 유틸리티 함수들을 증식시켜야 합니다.\u003c/p\u003e\n\u003ch3\u003e근거 (Rationale)\u003c/h3\u003e\n\u003cp\u003e현재 시스템에서는 함수 작성자가 기본값의 필요성을 예측하고 이를 지원하도록 구현해야 합니다. 그렇지 않으면 전체 \u003ccode\u003etry/except\u003c/code\u003e 블록이 필요합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etry/except\u003c/code\u003e는 문(statement)이기 때문에 표현식 중간에서 예외를 잡는 것이 불가능합니다. \u003ccode\u003eif/else\u003c/code\u003e가 조건문에, \u003ccode\u003elambda\u003c/code\u003e가 함수 정의에 하는 것처럼, 이 제안은 표현식 컨텍스트에서 예외 처리를 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003e이는 함수가 기본값을 제공하는 깨끗하고 일관된 방법을 제공합니다: 단순히 적절한 예외를 발생시키고, 호출자가 이를 잡습니다.\u003c/p\u003e\n\u003cp\u003e어떤 상황에서는 LBYL 기법을 사용할 수 있습니다 (예를 들어, 시퀀스의 인덱스를 사용하기 전에 길이가 충분한지 확인하는 것). 이는 모든 경우에 안전하지는 않지만, 종종 편리하기 때문에 프로그래머들은 LBYL의 간결한 표기법을 위해 EAFP의 안전성을 희생하고 싶어 할 것입니다. 또한, 일부 LBYL 기법(예: 세 인자를 가진 \u003ccode\u003egetattr\u003c/code\u003e 사용)은 코드를 속성 조회(attribute lookup)가 아닌 문자열 리터럴처럼 보이게 만들어 가독성에 영향을 줄 수 있습니다. 편리한 EAFP 표기법은 이 모든 문제를 해결합니다.\u003c/p\u003e\n\u003cp\u003e이를 위한 헬퍼 함수를 작성하는 편리한 방법은 없습니다. 가장 가까운 것은 \u003ccode\u003elambda\u003c/code\u003e를 사용한 다소 지저분한 방식입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef except_(expression, exception_list, default):\r\n    try:\r\n        return expression()\r\n    except exception_list:\r\n        return default()\r\n\r\nvalue = except_(lambda: 1/x, ZeroDivisionError, lambda: float(\"nan\"))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 투박하고 여러 \u003ccode\u003eexcept\u003c/code\u003e 절(clause)을 처리할 수 없습니다. \u003ccode\u003eeval\u003c/code\u003e을 사용하는 것은 더욱 투박하고 구현에 의존적인 핵(hack)에 의존합니다.\u003c/p\u003e\n\u003cp\u003eRaymond Hettinger는 이러한 일관된 API에 대한 열망을 표명했으며, 유사한 요청이 과거에도 여러 번 있었습니다.\u003c/p\u003e\n\u003ch3\u003e제안 (Proposal)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eor\u003c/code\u003e 연산자와 세 부분으로 된 \u003ccode\u003eif-else\u003c/code\u003e 표현식이 거짓 값(falsy value)을 잡고 대체하는 단락 평가(short-circuiting) 방식을 제공하는 것처럼, 이 문법은 예외를 잡고 대체하는 단락 평가 방식을 제공합니다.\u003c/p\u003e\n\u003cp\u003e현재는 다음과 같이 작동합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elst = [1, 2, None, 3]\r\nvalue = lst[2] or \"No value\" # None이 거짓 값이므로 \"No value\"가 됨\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제안은 다음을 추가합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elst = [1, 2]\r\nvalue = (lst[2] except IndexError: \"No value\") # lst[2]가 IndexError를 발생시키면 \"No value\"가 됨\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e구체적으로 제안된 문법은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e(expr except exception_list: default)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e여기서 \u003ccode\u003eexpr\u003c/code\u003e, \u003ccode\u003eexception_list\u003c/code\u003e, \u003ccode\u003edefault\u003c/code\u003e는 모두 표현식입니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e먼저 \u003ccode\u003eexpr\u003c/code\u003e이 평가됩니다.\u003c/li\u003e\n\u003cli\u003e예외가 발생하지 않으면, \u003ccode\u003eexpr\u003c/code\u003e의 값이 전체 표현식의 값이 됩니다.\u003c/li\u003e\n\u003cli\u003e어떤 예외라도 발생하면, \u003ccode\u003eexception_list\u003c/code\u003e가 평가되며, \u003ccode\u003etry/except\u003c/code\u003e 문의 형태와 마찬가지로 타입(type) 또는 튜플(tuple)을 결과로 해야 합니다.\u003c/li\u003e\n\u003cli\u003e일치하는 예외가 발생하면, 해당 \u003ccode\u003edefault\u003c/code\u003e 표현식이 평가되고 이 값이 전체 표현식의 값이 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etry/except\u003c/code\u003e 문의 형태와 마찬가지로, 일치하지 않는 예외는 위로 전파됩니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e전체 표현식은 괄호로 묶어야 합니다. 이는 \u003ccode\u003egenerator expression\u003c/code\u003e이 따르는 규칙과 동일하게, 괄호가 완전히 중복되는 경우가 아니라면 필요합니다. 이는 중첩된 \u003ccode\u003eexcept\u003c/code\u003e 표현식의 올바른 해석을 보장하고, 문법의 향후 확장을 허용합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 현재 제안은 예외 객체(exception object)를 캡처하는 것을 허용하지 않습니다. 이것이 필요한 경우에는 문(statement) 형태를 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003e이 삼항 연산자(ternary operator)는 \u003ccode\u003elambda\u003c/code\u003e와 \u003ccode\u003eif/else\u003c/code\u003e 사이의 연산자 우선순위(precedence)를 가집니다.\u003c/p\u003e\n\u003cp\u003e두 단계 캐시(two-level cache)의 다음 예를 고려해 보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor key in sequence:\r\n    x = (lvl1[key] except KeyError: (lvl2[key] except KeyError: f(key)))\r\n    # x를 가지고 뭔가 한다\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 다음처럼 다시 작성될 수 없습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ex = lvl1.get(key, lvl2.get(key, f(key)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 더 짧지만, \u003ccode\u003eget()\u003c/code\u003e에 전달할 기본값을 계산해야 하므로 캐시의 목적을 무력화시킵니다. \u003ccode\u003e.get()\u003c/code\u003e 버전은 역방향으로 계산하고, 예외 테스트 버전은 예상대로 정방향으로 계산합니다. 가장 유용한 등가물은 다음과 같을 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ex = lvl1.get(key) or lvl2.get(key) or f(key)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 값들이 0이 아닐 뿐만 아니라 캐시 객체가 이 기능을 지원하는지에 따라 달라집니다.\u003c/p\u003e\n\u003ch3\u003e대안 제안 (Alternative Proposals)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epython-ideas\u003c/code\u003e에서의 논의는 다음과 같은 문법 제안들을 이끌어냈습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except default if Exception [as e]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except default for Exception [as e]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except default from Exception [as e]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except Exception [as e] return default\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except (Exception [as e]: default)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except Exception [as e] try default\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except Exception [as e] continue with default\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = default except Exception [as e] else expr\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = try expr except Exception [as e]: default\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except default # 모든 예외를 잡음\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except(Exception) default # 지정된 타입의 예외만 잡음\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = default if expr raise Exception\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr or else default if Exception\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except Exception [as e] -\u003e default\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except Exception [as e] pass default\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e새로운 키워드를 만드는 대신 기존 키워드를 재사용하는 것이 제안되기도 했습니다. 그러한 제안들은 마지막 형태와 동일한 구조를 가지지만, \u003ccode\u003e'pass'\u003c/code\u003e 대신 다른 키워드를 사용합니다. 제안된 키워드로는 \u003ccode\u003e'then'\u003c/code\u003e, \u003ccode\u003e'when'\u003c/code\u003e, \u003ccode\u003e'use'\u003c/code\u003e 등이 있습니다. 또한, \"default if expr raise Exception\" 제안과 관련하여 새로운 키워드 \"\u003ccode\u003eraises\u003c/code\u003e\"를 사용하는 것이 제안되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eas\u003c/code\u003e 캡처 절(capturing clause)을 포함하는 모든 형태는 단순성을 위해 이 제안에서 연기되었지만, 제안의 정확한 기록으로 위 표에 보존되어 있습니다.\u003c/p\u003e\n\u003cp\u003e이 제안에서 가장 많이 지지받은 네 가지 형태는 순서대로 다음과 같습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003evalue = (expr except Exception: default)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = (expr except Exception -\u003e default)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = (expr except Exception pass default)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = (expr except Exception then default)\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e네 가지 모두 좌우 평가 순서(left-to-right evaluation order)를 유지합니다: 먼저 기본 표현식, 다음으로 예외 목록, 마지막으로 기본값입니다. 이는 표현식들이 지연 평가(lazily evaluated)되기 때문에 중요합니다.\u003c/p\u003e\n\u003cp\u003e콜론을 사용하는 선호되는 형태는 \"except exception_list:\"를 사용하여 \u003ccode\u003etry/except\u003c/code\u003e와 유사하며, \"keyword name_list: subexpression\"을 사용하여 \u003ccode\u003elambda\u003c/code\u003e와 유사합니다. 또한, 예외를 기본값에 매핑하는 사전(dict) 스타일로 읽을 수도 있습니다. 화살표를 사용하는 것은 많은 프로그래머에게 익숙하지 않고 현재 유사한 의미가 없는 토큰을 도입하지만, 그 외에는 상당히 읽기 쉽습니다. 영어 단어 \"pass\"는 막연하게 유사한 의미를 가지며 (\"pass by value/reference\"와 같은 함수 인수의 일반적인 사용을 고려), \"pass\"는 이미 키워드이지만, 그 의미가 분명히 관련이 없으므로 혼란을 야기할 수 있습니다. \"then\"을 사용하는 것은 영어에서는 의미가 있지만, 이는 언어에 새로운 키워드를 도입하는 것입니다.\u003c/p\u003e\n\u003cp\u003e좌우 평가 순서는 대부분의 표현식이 평가되는 순서와 일치하기 때문에 가독성에 매우 중요합니다.\u003c/p\u003e\n\u003cp\u003e기존 표기법을 유지하되 필수 괄호의 위치를 변경하는 다음 제안도 있었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except (Exception: default)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue = expr except(Exception: default)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 함수 호출이나 딕셔너리 초기화와 유사합니다. 콜론이 스위트(suite)를 도입하는 것으로 혼동될 수는 없지만, 새로운 문법은 지연 평가를 보장하는데 딕셔너리는 그렇지 않습니다. 혼란을 줄일 잠재력은 혼란을 증가시킬 잠재력에 의해 정당화되지 않는다고 간주되었습니다.\u003c/p\u003e\n\u003ch3\u003e사용 예시 (Example usage)\u003c/h3\u003e\n\u003cp\u003e각 예시에는 표현식이 어떻게 파싱될지를 보여주기 위해 대략적으로 동등한 문(statement) 형태가 주어집니다. 이들은 엄밀히 동일하지는 않지만, 동일한 목적을 달성합니다. 인터프리터가 하나를 다른 것으로 번역하는 것은 안전하지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 예시들 중 상당수는 Python 표준 라이브러리에서 직접 가져온 것으로, 2014년 2월 초 기준 파일 이름과 줄 번호가 정확합니다. 이러한 패턴 중 많은 것들이 매우 일반적입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e인자 검색, 기본값은 \u003ccode\u003eNone\u003c/code\u003e:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003econd = (args[1] except IndexError: None)\r\n# Equivalent statement form:\r\n# try:\r\n#     cond = args[1]\r\n# except IndexError:\r\n#     cond = None\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e시스템에서 정보를 가져옴 (가능한 경우):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003epwd = (os.getcwd() except OSError: None)\r\n# Equivalent statement form:\r\n# try:\r\n#     pwd = os.getcwd()\r\n# except OSError:\r\n#     pwd = None\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e번역 시도, 실패 시 원본으로 대체:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ee.widget = (self._nametowidget(W) except KeyError: W)\r\n# Equivalent statement form:\r\n# try:\r\n#     e.widget = self._nametowidget(W)\r\n# except KeyError:\r\n#     e.widget = W\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e이터레이터에서 읽기, 소진 시 빈 줄로 계속:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eline = (readline() except StopIteration: '')\r\n# Equivalent statement form:\r\n# try:\r\n#     line = readline()\r\n# except StopIteration:\r\n#     line = ''\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e플랫폼별 정보 검색 (DRY 개선점 주목):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_CONFIG_VARS['abiflags'] = (sys.abiflags except AttributeError: '')\r\n# Equivalent statement form:\r\n# try:\r\n#     _CONFIG_VARS['abiflags'] = sys.abiflags\r\n# except AttributeError:\r\n#     _CONFIG_VARS['abiflags'] = ''\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e인덱싱된 항목 검색, 기본값은 \u003ccode\u003eNone\u003c/code\u003e (\u003ccode\u003edict.get\u003c/code\u003e과 유사):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef getNamedItem(self, name):\r\n    return (self._attrs[name] except KeyError: None)\r\n# Equivalent statement form:\r\n# def getNamedItem(self, name):\r\n#     try:\r\n#         return self._attrs[name]\r\n#     except KeyError:\r\n#         return None\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e숫자를 이름으로 번역, 실패 시 숫자로 대체:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eg = (grp.getgrnam(tarinfo.gname)[2] except KeyError: tarinfo.gid)\r\nu = (pwd.getpwnam(tarinfo.uname)[2] except KeyError: tarinfo.uid)\r\n# Equivalent statement form:\r\n# try:\r\n#     g = grp.getgrnam(tarinfo.gname)[2]\r\n# except KeyError:\r\n#     g = tarinfo.gid\r\n# try:\r\n#     u = pwd.getpwnam(tarinfo.uname)[2]\r\n# except KeyError:\r\n#     u = tarinfo.uid\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e속성 조회, 실패 시 기본값으로 대체:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003emode = (f.mode except AttributeError: 'rb')\r\n# Equivalent statement form:\r\n# if hasattr(f, 'mode'):\r\n#     mode = f.mode\r\n# else:\r\n#     mode = 'rb'\r\n\r\nreturn (sys._getframe(1) except AttributeError: None)\r\n# Equivalent statement form:\r\n# return sys._getframe(1) if hasattr(sys, \"_getframe\") else None\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eEAFP 모드에서 긴 계산 수행, 0으로 나누기를 sticky NaN으로 처리:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003evalue = (calculate(x) except ZeroDivisionError: float(\"nan\"))\r\n# Equivalent statement form:\r\n# try:\r\n#     value = calculate(x)\r\n# except ZeroDivisionError:\r\n#     value = float(\"nan\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e일련의 숫자의 평균 계산, 실패 시 0으로 대체:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003evalue = (statistics.mean(lst) except statistics.StatisticsError: 0)\r\n# Equivalent statement form:\r\n# try:\r\n#     value = statistics.mean(lst)\r\n# except statistics.StatisticsError:\r\n#     value = 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e오버라이드(override)의 희소 목록에서 객체 조회:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e(overrides[x] or default except IndexError: default).ping()\r\n# Equivalent statement form:\r\n# try:\r\n#     (overrides[x] or default).ping()\r\n# except IndexError:\r\n#     default.ping()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e예외 처리 범위 좁히기 (Narrowing of exception-catching scope)\u003c/h4\u003e\n\u003cp\u003ePython의 표준 라이브러리에서 가져온 다음 예시들은 \u003ccode\u003etry/except\u003c/code\u003e의 범위를 편리하게 좁힐 수 있는 방법을 보여줍니다. \u003ccode\u003etry/except\u003c/code\u003e 문 형태로는 임시 변수가 필요하지만, 표현식으로는 훨씬 깔끔합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eLib/ipaddress.py:343\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\r\n    ips.append(ip.ip)\r\nexcept AttributeError:\r\n    ips.append(ip.network_address)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 같이 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eips.append(ip.ip except AttributeError: ip.network_address)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e표현식 형태는 다음 코드와 거의 동일합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\r\n    _ = ip.ip\r\nexcept AttributeError:\r\n    _ = ip.network_address\r\nips.append(_)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eLib/tempfile.py:130\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\r\n    dirlist.append(_os.getcwd())\r\nexcept (AttributeError, OSError):\r\n    dirlist.append(_os.curdir)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 같이 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edirlist.append(_os.getcwd() except (AttributeError, OSError): _os.curdir)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eLib/asyncore.py:264\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\r\n    status.append('%s:%d' % self.addr)\r\nexcept TypeError:\r\n    status.append(repr(self.addr))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 같이 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003estatus.append('%s:%d' % self.addr except TypeError: repr(self.addr))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e각 경우에, 좁혀진 \u003ccode\u003etry/except\u003c/code\u003e의 범위는 예상치 못한 예외 (예를 들어, \"append\"를 잘못 입력했을 때의 \u003ccode\u003eAttributeError\u003c/code\u003e)가 동일한 핸들러에 의해 잡히지 않도록 보장합니다.\u003c/p\u003e\n\u003ch3\u003e다른 언어와의 비교 (Comparisons with other languages)\u003c/h3\u003e\n\u003cp\u003e(이 섹션을 정리해 준 Andrew Barnert에게 감사드립니다. 여기에 주어진 예시들은 제안의 현재 버전을 반영하지 않으므로 편집이 필요합니다.)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRuby:\u003c/strong\u003e \u003ccode\u003ebegin...rescue...rescue...else...ensure...end\u003c/code\u003e는 표현식입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eErlang:\u003c/strong\u003e \u003ccode\u003etry\u003c/code\u003e 표현식을 가집니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eML 계열 언어 (SML, OCaml):\u003c/strong\u003e \u003ccode\u003ehandle\u003c/code\u003e 및 \u003ccode\u003etry\u003c/code\u003e를 통해 예외를 처리합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOz:\u003c/strong\u003e \u003ccode\u003etry ... catch ... then\u003c/code\u003e 형태를 가집니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLisp 계열 언어 (Clojure, Common Lisp):\u003c/strong\u003e \u003ccode\u003etry/catch\u003c/code\u003e를 특별한 형태(special forms)로 구현합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLua:\u003c/strong\u003e \u003ccode\u003expcall\u003c/code\u003e 함수를 사용합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHaskell:\u003c/strong\u003e \u003ccode\u003ecatch\u003c/code\u003e를 사용하여 예외를 처리합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTcl:\u003c/strong\u003e \u003ccode\u003ecatch\u003c/code\u003e 함수를 사용합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSmalltalk:\u003c/strong\u003e \u003ccode\u003eon:do:\u003c/code\u003e 구문을 사용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHaskell의 \u003ccode\u003ecatch\u003c/code\u003e는 제안된 \u003ccode\u003elambda\u003c/code\u003e의 콜론과 \u003ccode\u003eexcept\u003c/code\u003e의 콜론 사이의 유사성을 더욱 분명하게 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ex = expression() except Exception: default()\r\nx = expression() except Exception as e: default(e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e연기된 하위 제안 (Deferred sub-proposals)\u003c/h3\u003e\n\u003ch4\u003e여러 \u003ccode\u003eexcept\u003c/code\u003e 절 (Multiple except clauses)\u003c/h4\u003e\n\u003cp\u003e사용 사례를 검토한 결과, 문(statement) 형태에서만큼 자주 필요하지 않으며, 구문적 합의가 이루어지지 않아 전체 기능이 연기되었습니다.\u003c/p\u003e\n\u003cp\u003e여러 \u003ccode\u003eexcept\u003c/code\u003e 키워드를 사용할 수 있었고, 이는 모두 원래 표현식에서 발생한 예외만 잡을 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# expr에 의해 발생한 나열된 예외 중 하나를 잡습니다.\r\n# default 표현식에 의해 발생한 예외는 전파됩니다.\r\nvalue = (expr except Exception1: default1\r\n              except Exception2: default2\r\n              # ...\r\n              except ExceptionN: defaultN )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재는 다음 형태 중 하나를 사용해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# expr 또는 default1에 의해 발생한 Exception2를 잡습니다.\r\nvalue = ( (expr except Exception1: default1) except Exception2: default2 )\r\n# default1에 의해 발생한 Exception2만 잡습니다.\r\nvalue = (expr except Exception1: (default1 except Exception2: default2) )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e괄호 없이 여러 \u003ccode\u003eexcept\u003c/code\u003e 절을 나열하는 것은 문법 오류이므로, Python의 향후 버전은 기존 코드를 손상시키지 않고 이 기능을 추가할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e예외 객체 캡처 (Capturing the exception object)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003etry/except\u003c/code\u003e 블록에서 \u003ccode\u003eas\u003c/code\u003e를 사용하여 예외 객체를 캡처하는 것은 지역 이름 바인딩을 생성하고, \u003ccode\u003efinally\u003c/code\u003e 절에서 해당 바인딩을 암묵적으로 삭제합니다 (참조 루프를 피하기 위함). 표현식 컨텍스트에서는 이것이 거의 의미가 없으며, 예외 객체를 안전하게 캡처하려면 적절한 하위 범위(sub-scope)가 필요합니다. 이는 리스트 컴프리헨션(list comprehension)이 처리되는 방식과 유사합니다.\u003c/p\u003e\n\u003cp\u003e그러나 CPython은 현재 컴프리헨션의 하위 범위를 중첩된 함수 호출로 구현하는데, 이는 클래스 정의와 같은 일부 컨텍스트에서 문제를 야기할 수 있어 이 제안에는 부적합합니다. 미래에 진정한 하위 범위를 생성하는 방법(컴프리헨션, \u003ccode\u003eexcept\u003c/code\u003e 표현식, \u003ccode\u003ewith\u003c/code\u003e 블록 등을 단순화할 수 있는)이 생긴다면 이 제안은 부활할 수 있습니다. 그때까지는 단순한 예외 처리가 이 표현식 표기법에 잘 맞으며, 일반적으로 예외의 타입에만 관심이 있고 그 값에는 관심이 없으므로 큰 손실은 아닙니다.\u003c/p\u003e\n\u003cp\u003e이 문법은 대화형 Python에서 예외를 편리하게 캡처할 수 있는 방법을 제공할 수 있습니다. 반환 값은 \u003ccode\u003e_\u003c/code\u003e로 캡처되지만, 예외는 현재 그렇지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e (expr except Exception as e: e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 표준 라이브러리를 검토한 결과, \u003ccode\u003eas\u003c/code\u003e의 사용이 상당히 흔하지만 (대략 5개의 \u003ccode\u003eexcept\u003c/code\u003e 절 중 하나), 표현식 형태로 논리적으로 변환될 수 있는 경우에는 극히 드뭅니다. 몇 안 되는 용례는 단순히 변경하지 않고 남겨둘 수 있습니다. 따라서 단순성을 위해 이 제안에는 \u003ccode\u003eas\u003c/code\u003e 절이 포함되지 않습니다. \u003ccode\u003eas\u003c/code\u003e는 이미 키워드이므로, 후속 Python 버전은 기존 코드를 손상시키지 않고 이를 추가할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e거부된 하위 제안 (Rejected sub-proposals)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003efinally\u003c/code\u003e 절 (finally clause)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003etry...finally\u003c/code\u003e 또는 \u003ccode\u003etry...except...finally\u003c/code\u003e 문 형태는 논리적으로 대응하는 표현식 형태가 없습니다. 따라서 \u003ccode\u003efinally\u003c/code\u003e 키워드는 어떤 식으로든 이 제안의 일부가 아닙니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003ebare except\u003c/code\u003e의 다른 의미 (Bare except having different meaning)\u003c/h4\u003e\n\u003cp\u003e몇몇 제안된 구문에서 예외 타입 이름을 생략하는 것이 쉽고 간결하며 매력적일 수 있었습니다. 편의를 위해 \u003ccode\u003ebare 'except'\u003c/code\u003e 절이 \"except \u003ccode\u003eBaseException\u003c/code\u003e\"보다 더 유용한 의미를 가지도록 하는 것이 유리할 수 있었습니다. 제안에는 \u003ccode\u003eException\u003c/code\u003e을 잡도록 하거나, 특정 \"일반적인 예외\" 세트(새로운 타입 \u003ccode\u003eExpressionError\u003c/code\u003e의 서브클래스)를 잡도록 하거나, 현재 범위에서 \u003ccode\u003eExpressionError\u003c/code\u003e라는 튜플을 찾도록 하여 (기본값으로 \u003ccode\u003e(ValueError, UnicodeError, AttributeError, EOFError, IOError, OSError, LookupError, NameError, ZeroDivisionError)\u003c/code\u003e와 같은) 잡도록 하는 것이 포함되었습니다. 이 모든 것은 여러 가지 이유로 거부되었습니다.\u003c/p\u003e\n\u003cp\u003e무엇보다도, \u003ccode\u003etry/except\u003c/code\u003e 문의 형태와의 일관성이 깨질 것입니다. 리스트 컴프리헨션이나 삼항 \u003ccode\u003eif\u003c/code\u003e 표현식이 수직적인 문 형태로 \"풀어써서\" 설명될 수 있는 것처럼, 표현식 \u003ccode\u003eexcept\u003c/code\u003e도 거의 동등한 문으로 상대적으로 기계적인 번역을 통해 설명될 수 있어야 합니다. 따라서 양쪽에 공통된 어떤 형태의 구문이든 각자 동일한 의미를 가져야 하며, 무엇보다도 한쪽이 다른 쪽보다 더 많은 것을 잡는 미묘한 차이를 가져서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e둘째, 잡을 적절한 예외 집합 자체가 큰 논쟁의 여지가 될 것입니다. 어떤 예외를 잡는 것이 \"합리적인지\" 정확히 예측하는 것은 불가능할 것입니다.\u003c/p\u003e\n\u003cp\u003e셋째, 예상치 못한 예외를 잡는 어떤 상황도 불필요한 버그를 유발합니다.\u003c/p\u003e\n\u003cp\u003e결과적으로, \u003ccode\u003ebare 'except'\u003c/code\u003e의 사용은 두 가지 가능성으로 귀결됩니다: 표현식 형태에서 문법적으로 금지되거나, 문 형태와 정확히 동일한 의미(즉, \u003ccode\u003eBaseException\u003c/code\u003e을 잡고 \u003ccode\u003eas\u003c/code\u003e로 캡처할 수 없음)로 허용되는 것입니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003ebare except\u003c/code\u003e 절 (Bare except clauses)\u003c/h4\u003e\n\u003cp\u003ePEP 8은 \u003ccode\u003ebare 'except'\u003c/code\u003e의 사용을 올바르게 권장하지 않습니다. 문(statement)에서는 문법적으로 유효하고 하위 호환성을 위해 유지되어야 하지만, 그 사용을 장려할 가치는 거의 없습니다. 표현식 \u003ccode\u003eexcept\u003c/code\u003e 절에서 \"except:\"는 \u003ccode\u003eSyntaxError\u003c/code\u003e입니다; 대신 동등한 전체 형태인 \"except \u003ccode\u003eBaseException\u003c/code\u003e:\"을 사용해야 합니다. Python의 향후 버전은 이를 복원하기로 선택할 수도 있으며, 이는 호환성을 깨지 않고 수행할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eexcept\u003c/code\u003e 절 주위의 괄호 (Parentheses around the except clauses)\u003c/h4\u003e\n\u003cp\u003e예외를 발생시킬 수 있는 표현식과는 별도로 \u003ccode\u003eexcept\u003c/code\u003e 절에 괄호를 붙이는 것이 합법적이어야 하는가? 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003evalue = expr ( except Exception1 [as e]: default1\r\n               except Exception2 [as e]: default2\r\n               # ...\r\n               except ExceptionN [as e]: defaultN )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 여러 \u003ccode\u003eexcept\u003c/code\u003e 절 및/또는 예외 캡처에 대한 연기된 하위 제안 중 하나 또는 둘 모두가 포함될 때 더욱 설득력이 있습니다.\u003c/p\u003e\n\u003cp\u003e장점은 미미하며, 독자가 \u003ccode\u003eexcept\u003c/code\u003e 절이 표현식과 분리되어 있다고 생각하거나 이것이 함수 호출이라고 생각하도록 혼란시킬 가능성 때문에 설득력이 없습니다. 물론, 원하는 경우 표현식도 괄호로 묶을 수 있으며, 기본값도 마찬가지입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003evalue = (expr) except ExceptionType: (default)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 전체 표현식이 괄호로 묶여야 하므로 (이 논의 당시에는 결정되지 않았던 사항), 이 섹션을 구분할 필요성이 줄어들고 많은 경우 중복될 것입니다.\u003c/p\u003e\n\u003ch4\u003e\"except: pass\"의 줄임말 (Short-hand for “except: pass”)\u003c/h4\u003e\n\u003cp\u003e다음은 기술적으로 표현식은 아니지만 유사한 줄임말로 제안되었습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003estatement except Exception: pass\r\n# Equivalent statement form:\r\n# try:\r\n#     statement\r\n# except Exception:\r\n#     pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어, 파일 삭제를 시도하는 일반적인 사용 사례는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eos.unlink(some_file) except OSError: pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 3.4의 \u003ccode\u003econtextlib\u003c/code\u003e에는 이미 동등한 것이 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom contextlib import suppress\r\nwith suppress(OSError):\r\n    os.unlink(some_file)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 이미 한 줄이므로, 이를 달성하기 위해 새로운 구문이나 문(statement)과 표현식(expression)의 혼동이 필요하지 않습니다.\u003c/p\u003e\n\u003ch3\u003e일반적인 반대 의견 (Common objections)\u003c/h3\u003e\n\u003ch4\u003e콜론은 항상 스위트를 도입한다 (Colons always introduce suites)\u003c/h4\u003e\n\u003cp\u003ePython의 많은 구문 요소가 콜론을 사용하여 문 스위트(\u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003ewhile\u003c/code\u003e, \u003ccode\u003ewith\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e 등)를 도입하는 것은 사실이지만, 이것이 콜론의 유일한 용도는 아닙니다. 현재 Python 구문에는 콜론이 하위 표현식(subexpression)을 도입하는 네 가지 경우가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e딕셔너리 표현식 (\u003ccode\u003edict display\u003c/code\u003e) - \u003ccode\u003e{ ... key:value ... }\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e슬라이스 표기법 (\u003ccode\u003eslice notation\u003c/code\u003e) - \u003ccode\u003e[start:stop:step]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e함수 정의 (\u003ccode\u003efunction definition\u003c/code\u003e) - \u003ccode\u003eparameter : annotation\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e람다 (\u003ccode\u003elambda\u003c/code\u003e) - \u003ccode\u003earg list: return value\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 제안은 다섯 번째를 추가할 뿐입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eexcept\u003c/code\u003e 표현식 (\u003ccode\u003eexcept-expression\u003c/code\u003e) - \u003ccode\u003eexception list: result\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e스타일 가이드와 PEP 8은 줄 바꿈된 줄의 끝에 콜론을 두지 않도록 권장해야 합니다. 이는 스위트의 도입처럼 보일 수 있기 때문입니다. 대신 예외 목록 앞에 줄 바꿈을 하여 콜론이 두 표현식 사이에 명확하게 오도록 해야 합니다.\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 공개 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 463 - Exception-catching expressions\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:11:32+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>