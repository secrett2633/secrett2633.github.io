<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d6cea809dcbae606.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-0395f68b8cc78a20.js" async=""></script><script src="/_next/static/chunks/23-706b53707bbf0661.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-467e37449c5a68fc.js" async=""></script><script src="/_next/static/chunks/app/layout-bb929596377d30e0.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2353<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 489 - Multi-phase extension module initialization</h1><div class="page__meta"><time dateTime="2025-09-26 22:35:12+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0489/">PEP 489 - Multi-phase extension module initialization</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 11-Aug-2013</p>
</blockquote>
<h1>PEP 489 – 다단계 확장 모듈 초기화</h1>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 내장(built-in) 및 확장 모듈(extension module)이 임포트(import) 메커니즘과 상호작용하는 방식을 재설계할 것을 제안합니다. 이 방식은 Python 3.0에서 PEP 3121을 통해 마지막으로 개정되었지만, 당시의 모든 문제를 해결하지는 못했습니다. 목표는 확장 모듈을 Python 모듈의 동작 방식에 더 가깝게 만듦으로써 임포트 관련 문제를 해결하는 것입니다. 특히 PEP 451에서 도입된 <code>ModuleSpec</code> 기반 로딩 메커니즘에 연결하는 것을 목표로 합니다.</p>
<p>이 제안은 PEP 384의 <code>PyType_Spec</code>에서 영감을 받아 확장 모듈 개발자가 필요한 기능만 정의할 수 있도록 하고, 향후 확장 모듈 선언에 추가 기능을 도입할 수 있도록 합니다.</p>
<p>확장 모듈은 클래스의 <code>__new__</code>와 <code>__init__</code>에 비유될 수 있는 두 단계 프로세스로 생성되어, <code>ModuleSpec</code> 아키텍처에 더 잘 들어맞습니다.</p>
<p>새로운 방식을 통해 확장 모듈은 일반 가비지 컬렉션(garbage collection)의 대상이 되고, 재로드(reloading) 및 서브 인터프리터(sub-interpreters)를 지원하는 C-레벨 모듈별 상태를 안전하게 저장할 수 있습니다. 확장 모듈 개발자들은 새로운 API를 사용할 때 이러한 문제를 고려할 것을 권장합니다.</p>
<p>또한 이 제안은 비(非) ASCII 이름을 가진 확장 모듈도 허용합니다.</p>
<p>PEP 3121에서 다루었던 모든 문제가 이 제안에서 해결되는 것은 아닙니다. 특히 런타임 모듈 조회(<code>PyState_FindModule</code>)와 관련된 문제는 향후 PEP로 남겨둡니다.</p>
<h2>동기 (Motivation)</h2>
<p>Python 모듈과 확장 모듈은 동일한 방식으로 설정되지 않습니다. Python 모듈의 경우, 모듈 객체가 먼저 생성되고 설정된 다음 모듈 코드가 실행됩니다 (PEP 302). <code>ModuleSpec</code> 객체 (PEP 451)는 모듈에 대한 정보를 담는 데 사용되며 관련 훅(hook)에 전달됩니다.</p>
<p>확장 모듈 (즉, 공유 라이브러리) 및 내장 모듈의 경우, 모듈 초기화 함수가 즉시 실행되어 생성과 초기화를 모두 수행합니다. 초기화 함수에는 <code>ModuleSpec</code>이나 <code>__file__</code>, 완전한 이름(fully-qualified name)과 같은 포함된 정보가 전달되지 않습니다. 이로 인해 상대 임포트(relative imports) 및 리소스 로딩이 방해받습니다.</p>
<p>Python 3에서는 모듈이 <code>sys.modules</code>에 추가되지 않는 문제도 있습니다. 이는 (잠재적으로 전이적인) 모듈의 재임포트가 실제로 다시 임포트하려고 시도하여, 모듈 초기화 함수를 다시 실행할 때 무한 루프에 빠질 수 있음을 의미합니다. 완전한 모듈 이름에 접근할 수 없으면 모듈을 <code>sys.modules</code>에 올바르게 추가하는 것도 쉽지 않습니다. 이는 특히 Cython으로 생성된 모듈에 문제가 되는데, 해당 모듈의 초기화 코드가 일반 Python 모듈과 동일한 복잡성을 가질 때가 흔합니다. 또한 <code>__file__</code> 및 <code>__name__</code> 정보가 없으면 <code>__init__.py</code> 모듈, 즉 패키지 컴파일을 방해하며, 특히 모듈 초기화 시점에 상대 임포트가 사용될 때 더욱 그렇습니다.</p>
<p>더 나아가, 현재 존재하는 대부분의 확장 모듈은 서브 인터프리터 지원 및/또는 인터프리터 재로드에 문제가 있으며, 현재 인프라로 이러한 기능을 지원하는 것이 가능하더라도 쉽거나 효율적이지 않습니다. 이러한 문제를 해결하는 것이 PEP 3121의 목표였지만, 표준 라이브러리의 일부를 포함한 많은 확장 모듈은 Python 3로 포팅할 때 최소한의 노력을 기울여 이러한 문제가 해결되지 않은 채로 남았습니다. 이 PEP는 이전 버전과의 호환성을 유지하여 부담을 줄이고 확장 모듈 개발자가 포팅 시 이러한 문제를 고려할 충분한 시간을 제공해야 합니다.</p>
<h2>현재 프로세스 (The current process)</h2>
<p>현재 확장 및 내장 모듈은 공유 라이브러리의 파일 이름을 따서 명명된 "PyInit_modulename"이라는 초기화 함수를 내보냅니다. 이 함수는 임포트 메커니즘에 의해 실행되며 완전히 초기화된 모듈 객체를 반환해야 합니다. 이 함수는 인수를 받지 않으므로 임포트 컨텍스트를 알 수 있는 방법이 없습니다.</p>
<p>실행 중에 모듈 초기화 함수는 <code>PyModuleDef</code> 객체를 기반으로 모듈 객체를 생성합니다. 그런 다음 모듈 딕셔너리에 속성을 추가하고, 타입을 생성하는 등으로 모듈을 계속 초기화합니다.</p>
<p>내부적으로 공유 라이브러리 로더는 마지막으로 로드된 모듈의 완전한 모듈 이름을 기록해 두고, 해당 이름과 일치하는 모듈이 생성되면 이 전역 변수를 사용하여 모듈 객체의 완전한 이름을 결정합니다. 이는 모듈 초기화 함수가 먼저 자체 모듈 객체를 생성한다는 가정에 의존하므로 완전히 안전하지 않지만, 실제로는 일반적으로 이 가정이 유지됩니다.</p>
<h2>제안 (The proposal)</h2>
<p>초기화 함수 (<code>PyInit_modulename</code>)는 <code>PyModuleDef</code> 객체에 대한 포인터를 반환할 수 있도록 허용됩니다. 임포트 메커니즘은 모듈 객체를 구성하는 역할을 담당하며, 초기화의 관련 단계에서 (아래 설명된 대로) <code>PyModuleDef</code>에 제공된 훅을 호출합니다.</p>
<p>이 다단계 초기화는 추가적인 가능성입니다. 완전히 초기화된 모듈 객체를 반환하는 현재 방식인 단일 단계 초기화는 계속 허용되므로, 기존 코드는 바이너리 호환성을 포함하여 변경 없이 작동할 것입니다.</p>
<p><code>PyModuleDef</code> 구조체는 PEP 384의 <code>PyType_Spec</code>과 유사하게 슬롯(slots) 목록을 포함하도록 변경될 것입니다. 바이너리 호환성을 유지하고 새로운 구조체 도입을 피하기 위해 (<code>m_reload</code>의 현재 사용되지 않는 포인터가 슬롯을 담도록 변경됩니다. 이는 추가 지원 함수와 모듈별 저장소를 도입할 필요를 방지합니다). 구조체는 다음과 같이 정의됩니다.</p>
<pre><code class="language-c">typedef struct {
    int slot;
    void *value;
} PyModuleDef_Slot;

typedef struct PyModuleDef {
    PyModuleDef_Base m_base;
    const char* m_name;
    const char* m_doc;
    Py_ssize_t m_size;
    PyMethodDef *m_methods;
    PyModuleDef_Slot *m_slots; /* 'inquiry m_reload;'에서 변경됨 */
    traverseproc m_traverse;
    inquiry m_clear;
    freefunc m_free;
} PyModuleDef;
</code></pre>
<p><code>m_slots</code> 멤버는 <code>NULL</code>이거나, ID가 0으로 설정된 슬롯(<code>{0, NULL}</code>)으로 끝나는 <code>PyModuleDef_Slot</code> 구조체 배열을 가리켜야 합니다.</p>
<p>슬롯을 지정하려면 고유한 슬롯 ID를 제공해야 합니다. 새로운 Python 버전은 새로운 슬롯 ID를 도입할 수 있지만, 슬롯 ID는 재활용되지 않습니다. 슬롯은 사용되지 않게 될 수 있지만, Python 3.x 전체에서 계속 지원됩니다.</p>
<p>슬롯의 <code>value</code> 포인터는 슬롯 문서에서 달리 지정되지 않는 한 <code>NULL</code>이 아닐 수 있습니다.</p>
<p>현재 사용 가능한 슬롯은 다음과 같으며, 나중에 설명됩니다.</p>
<ul>
<li><code>Py_mod_create</code></li>
<li><code>Py_mod_exec</code></li>
</ul>
<p>알 수 없는 슬롯 ID는 <code>SystemError</code>와 함께 임포트를 실패하게 합니다.</p>
<p>다단계 초기화를 사용할 때 <code>PyModuleDef</code>의 <code>m_name</code> 필드는 임포트 중에 사용되지 않습니다. 모듈 이름은 <code>ModuleSpec</code>에서 가져옵니다.</p>
<p><code>PyInit_*</code>에서 반환되기 전에 <code>PyModuleDef</code> 객체는 새로 추가된 <code>PyModuleDef_Init</code> 함수를 사용하여 초기화되어야 합니다. 이 함수는 객체 타입 (특정 컴파일러에서는 정적으로 수행할 수 없음), 참조 카운트, 내부 관리 데이터 (<code>m_index</code>)를 설정합니다. 예를 들어, 확장 모듈 "example"은 다음과 같이 내보내집니다.</p>
<pre><code class="language-c">static PyModuleDef example_def = {...}

PyMODINIT_FUNC PyInit_example(void) {
    return PyModuleDef_Init(&#x26;example_def);
}
</code></pre>
<p><code>PyModuleDef</code> 객체는 해당 객체로부터 생성된 모듈의 수명 동안 사용 가능해야 합니다. 일반적으로 정적으로 선언될 것입니다.</p>
<h2>의사 코드 개요 (Pseudo-code Overview)</h2>
<p>수정된 임포터가 어떻게 작동할지에 대한 개요입니다. 로깅이나 오류 및 유효하지 않은 상태 처리와 같은 세부 사항은 생략되었으며, C 코드는 간결한 Python과 유사한 구문으로 제공됩니다.</p>
<p>임포터를 호출하는 프레임워크는 PEP 451에 설명되어 있습니다.</p>
<p><em>(원문의 의사 코드 예시는 너무 길어 여기에 모두 번역하지 않습니다. 핵심은 <code>BuiltinImporter</code>와 <code>ExtensionFileLoader</code>가 <code>create_module</code>과 <code>exec_module</code>을 구현하고, <code>PyModule_FromDefAndSpec</code> 함수가 <code>PyModuleDef</code>와 <code>ModuleSpec</code>을 받아 모듈을 생성하며, <code>PyModule_ExecDef</code> 함수가 모듈의 실행 슬롯을 처리한다는 것입니다.)</em></p>
<h2>모듈 생성 단계 (Module Creation Phase)</h2>
<p>모듈 객체 생성, 즉 <code>ExecutionLoader.create_module</code>의 구현은 <code>Py_mod_create</code> 슬롯에 의해 제어됩니다.</p>
<h3><code>Py_mod_create</code> 슬롯</h3>
<p><code>Py_mod_create</code> 슬롯은 사용자 정의 모듈 서브클래스를 지원하는 데 사용됩니다. <code>value</code> 포인터는 다음 시그니처를 가진 함수를 가리켜야 합니다.</p>
<pre><code class="language-c">PyObject* (*PyModuleCreateFunction)(PyObject *spec, PyModuleDef *def)
</code></pre>
<p>이 함수는 PEP 451에 정의된 <code>ModuleSpec</code> 인스턴스와 <code>PyModuleDef</code> 구조체를 받습니다. 새 모듈 객체를 반환하거나, 오류를 설정하고 <code>NULL</code>을 반환해야 합니다.</p>
<p>이 함수는 새 모듈에 PEP 451에 지정된 임포트 관련 속성(예: <code>__name__</code> 또는 <code>__loader__</code>)을 설정할 책임이 없습니다.</p>
<p>반환된 객체가 <code>types.ModuleType</code>의 인스턴스여야 한다는 요구 사항은 없습니다. 속성 설정 및 가져오기(최소한 임포트 관련 속성 포함)를 지원하는 한 모든 타입을 사용할 수 있습니다. 그러나 <code>ModuleType</code> 인스턴스만 모듈별 기능(예: 모듈별 상태 및 실행 슬롯 처리)을 지원합니다. <code>ModuleType</code> 서브클래스 이외의 것이 반환되면 실행 슬롯을 정의할 수 없으며, 정의될 경우 <code>SystemError</code>가 발생합니다.</p>
<p>이 함수가 호출될 때 모듈의 <code>sys.modules</code> 항목이 아직 채워지지 않는다는 점에 유의하십시오. 동일한 모듈을 다시 임포트하려고 시도하면 (전이적으로라도) 무한 루프가 발생할 수 있습니다. 확장 모듈 개발자는 <code>Py_mod_create</code>를 최소한으로 유지하고, 특히 사용자 코드를 호출하지 않도록 조언됩니다.</p>
<p>여러 <code>Py_mod_create</code> 슬롯은 지정할 수 없습니다. 지정될 경우 임포트가 <code>SystemError</code>와 함께 실패합니다.</p>
<p><code>Py_mod_create</code>가 지정되지 않으면 임포트 메커니즘은 <code>PyModule_New</code>를 사용하여 일반 모듈 객체를 생성합니다. 이름은 <code>spec</code>에서 가져옵니다.</p>
<h3>생성 후 단계 (Post-creation steps)</h3>
<p><code>Py_mod_create</code> 함수가 <code>types.ModuleType</code> 또는 서브클래스의 인스턴스를 반환하거나 (<code>Py_mod_create</code> 슬롯이 없는 경우), 임포트 메커니즘은 <code>PyModuleDef</code>를 모듈과 연결합니다. 이로 인해 <code>PyModuleDef</code>는 실행 단계, <code>PyModule_GetDef</code> 함수 및 가비지 컬렉션 루틴(traverse, clear, free)에서 접근 가능해집니다.</p>
<p><code>Py_mod_create</code> 함수가 모듈 서브클래스를 반환하지 않는 경우, <code>m_size</code>는 0이어야 하고 <code>m_traverse</code>, <code>m_clear</code>, <code>m_free</code>는 모두 <code>NULL</code>이어야 합니다. 그렇지 않으면 <code>SystemError</code>가 발생합니다.</p>
<p>또한, <code>PyModuleDef</code>에 지정된 초기 속성은 타입에 관계없이 모듈 객체에 설정됩니다.</p>
<ul>
<li>Docstring은 <code>m_doc</code>이 <code>NULL</code>이 아니면 설정됩니다.</li>
<li>모듈의 함수는 <code>m_methods</code>가 있으면 초기화됩니다.</li>
</ul>
<h2>모듈 실행 단계 (Module Execution Phase)</h2>
<p>모듈 실행, 즉 <code>ExecutionLoader.exec_module</code>의 구현은 "실행 슬롯"에 의해 제어됩니다. 이 PEP는 <code>Py_mod_exec</code> 하나만 추가하지만, 향후 다른 슬롯이 추가될 수 있습니다.</p>
<p>실행 단계는 모듈 객체와 연결된 <code>PyModuleDef</code>에서 수행됩니다. <code>PyModule_Type</code>의 서브클래스가 아닌 객체 (PyModule_GetDef가 실패하는 경우)의 경우 실행 단계는 건너뜁니다.</p>
<p>실행 슬롯은 여러 번 지정될 수 있으며, 슬롯 배열에 나타나는 순서대로 처리됩니다. 기본 임포트 메커니즘을 사용할 때, 이들은 PEP 451에 지정된 임포트 관련 속성(예: <code>__name__</code> 또는 <code>__loader__</code>)이 설정되고 모듈이 <code>sys.modules</code>에 추가된 후에 처리됩니다.</p>
<h3>실행 전 단계 (Pre-Execution steps)</h3>
<p>실행 슬롯을 처리하기 전에 모듈에 대한 모듈별 상태가 할당됩니다. 이 시점부터 모듈별 상태는 <code>PyModule_GetState</code>를 통해 접근할 수 있습니다.</p>
<h3><code>Py_mod_exec</code> 슬롯</h3>
<p>이 슬롯의 항목은 다음 시그니처를 가진 함수를 가리켜야 합니다.</p>
<pre><code class="language-c">int (*PyModuleExecFunction)(PyObject* module)
</code></pre>
<p>이 함수는 모듈을 초기화하기 위해 호출됩니다. 일반적으로 이는 모듈의 초기 속성을 설정하는 것을 의미합니다. "module" 인수는 초기화할 모듈 객체를 받습니다.</p>
<p>함수는 성공 시 0을 반환해야 하며, 오류 시 예외를 설정하고 -1을 반환해야 합니다.</p>
<p><code>PyModuleExec</code>가 <code>sys.modules</code>의 모듈 항목을 대체하면, 모든 실행 슬롯이 처리된 후 새 객체가 임포트립(importlib) 메커니즘에 의해 사용되고 반환될 것입니다. 이는 임포트 메커니즘 자체의 기능입니다. 슬롯 자체는 모두 생성 단계에서 반환된 모듈을 사용하여 처리됩니다. 실행 단계 동안 <code>sys.modules</code>는 조회되지 않습니다. (확장 모듈의 경우 사용자 정의 모듈 객체를 사용하려면 <code>Py_mod_create</code>를 구현하는 것이 일반적으로 더 나은 해결책입니다.)</p>
<h2>레거시 초기화 (Legacy Init)</h2>
<p>이전 버전과의 호환성을 유지하는 단일 단계 초기화는 계속 지원됩니다. 이 방식에서는 <code>PyInit</code> 함수가 <code>PyModuleDef</code> 객체 대신 완전히 초기화된 모듈을 반환합니다. 이 경우 <code>PyInit</code> 훅은 생성 단계를 구현하며, 실행 단계는 아무것도 하지 않습니다(no-op).</p>
<p>이전 버전의 Python에서 변경 없이 작동해야 하는 모듈은 단일 단계 초기화를 고수해야 합니다. 왜냐하면 다단계 초기화가 제공하는 이점은 이전 버전으로 백포팅할 수 없기 때문입니다.</p>
<p><em>(원문의 예시 코드는 C 코드이므로 번역하지 않고 생략합니다. 핵심은 <code>Py_mod_exec</code> 매크로의 존재 여부에 따라 다단계 초기화를 지원하거나 단일 단계 초기화로 폴백하는 방식을 보여줍니다.)</em></p>
<h2>내장 모듈 (Built-In modules)</h2>
<p>어떤 확장 모듈이든 실행 파일에 링크하고 <code>inittab</code>에 포함시켜 (런타임에 <code>PyImport_AppendInittab</code>을 사용하거나, 설정 시 <code>freeze</code>와 같은 도구를 사용하여) 내장 모듈로 사용할 수 있습니다.</p>
<p>이러한 가능성을 유지하기 위해 이 PEP에서 도입된 확장 모듈 로딩의 모든 변경 사항은 내장 모듈에도 적용될 것입니다. 유일한 예외는 아래에서 설명할 비(非) ASCII 모듈 이름입니다.</p>
<h2>서브 인터프리터 및 인터프리터 재로드 (Subinterpreters and Interpreter Reloading)</h2>
<p>새로운 초기화 방식을 사용하는 확장 모듈은 Python 문서에 언급된 문제를 피하면서 서브 인터프리터 및 여러 <code>Py_Initialize</code> / <code>Py_Finalize</code> 사이클을 올바르게 지원할 것으로 예상됩니다. 이 메커니즘은 이를 쉽게 만들도록 설계되었지만, 확장 모듈 개발자 측에서는 여전히 주의가 필요합니다. 사용자 정의 함수, 메서드 또는 인스턴스가 다른 인터프리터로 유출되어서는 안 됩니다. 이를 달성하기 위해 모든 모듈 수준 상태는 모듈 딕셔너리 또는 <code>PyModule_GetState</code>로 접근 가능한 모듈 객체의 저장소에 보관되어야 합니다. 간단한 규칙은 다음과 같습니다: 변경 가능한 또는 사용자 설정 가능한 클래스 속성이 없는 내장 타입을 제외하고는 어떤 정적 데이터도 정의하지 마십시오.</p>
<h2>다단계 초기화와 호환되지 않는 함수 (Functions incompatible with multi-phase initialization)</h2>
<p><code>PyModule_Create</code> 함수는 <code>non-NULL m_slots</code> 포인터를 가진 <code>PyModuleDef</code> 구조체에 사용될 때 실패합니다. 이 함수는 다단계 초기화에 필요한 <code>ModuleSpec</code> 객체에 접근할 수 없습니다.</p>
<p><code>PyState_FindModule</code> 함수는 <code>NULL</code>을 반환하고, <code>PyState_AddModule</code> 및 <code>PyState_RemoveModule</code>도 <code>non-NULL m_slots</code>를 가진 모듈에서 실패할 것입니다. <code>PyState</code> 등록은 동일한 <code>PyModuleDef</code>에서 여러 모듈 객체가 생성될 수 있기 때문에 비활성화됩니다.</p>
<h2>모듈 상태 및 C-레벨 콜백 (Module state and C-level callbacks)</h2>
<p><code>PyState_FindModule</code>를 사용할 수 없기 때문에 모듈 수준 상태(모듈 수준에서 정의된 함수, 클래스 또는 예외 포함)에 접근해야 하는 모든 함수는 모듈 객체(또는 필요한 특정 객체)에 대한 참조를 직접 또는 간접적으로 받아야 합니다. 이는 현재 두 가지 상황에서 어렵습니다.</p>
<ul>
<li>클래스의 메서드는 클래스에 대한 참조를 받지만, 클래스의 모듈에 대한 참조는 받지 않습니다.</li>
<li>C-레벨 콜백을 사용하는 라이브러리는 콜백 등록 시 사용자 정의 데이터를 받을 수 없는 한 어렵습니다.</li>
</ul>
<p>이러한 경우를 수정하는 것은 이 PEP의 범위를 벗어나지만, 새로운 메커니즘이 모든 모듈에 유용하려면 필요할 것입니다. 적절한 수정 사항은 <code>import-sig</code> 메일링 리스트에서 논의되었습니다 [5, cite: 1].</p>
<p>일반적인 규칙으로, <code>PyState_FindModule</code>에 의존하는 모듈은 현재 새로운 메커니즘으로 포팅하기에 좋은 후보가 아닙니다.</p>
<h2>새로운 함수 (New Functions)</h2>
<p>모듈 생성 단계를 구현하는 새로운 함수와 매크로가 추가될 것입니다. 이들은 <code>PyModule_Create</code> 및 <code>PyModule_Create2</code>와 유사하지만, 추가적인 <code>ModuleSpec</code> 인수를 취하고 <code>non-NULL</code> 슬롯을 가진 모듈 정의를 처리합니다.</p>
<ul>
<li><code>PyObject * PyModule_FromDefAndSpec(PyModuleDef *def, PyObject *spec)</code></li>
<li><code>PyObject * PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)</code></li>
</ul>
<p>모듈 실행 단계를 구현하는 새로운 함수가 추가될 것입니다. 이 함수는 모듈별 상태를 할당하고 (이미 할당되지 않은 경우) 항상 실행 슬롯을 처리합니다. 임포트 메커니즘은 모듈이 재로드되지 않는 한 모듈이 실행될 때 이 메서드를 호출합니다.</p>
<ul>
<li><code>PyAPI_FUNC(int) PyModule_ExecDef(PyObject *module, PyModuleDef *def)</code></li>
</ul>
<p><code>PyModuleDef</code> 객체를 초기화하는 또 다른 함수가 도입될 것입니다. 이 멱등(idempotent) 함수는 타입, 참조 카운트 및 모듈 인덱스를 채웁니다. 인수를 <code>PyObject*</code>로 캐스팅하여 반환하므로 <code>PyInit</code> 함수에서 직접 반환할 수 있습니다.</p>
<ul>
<li><code>PyObject * PyModuleDef_Init(PyModuleDef *);</code></li>
</ul>
<p>또한, 모듈에 Docstring과 메서드를 설정하기 위한 두 가지 헬퍼 함수가 추가될 것입니다.</p>
<ul>
<li><code>int PyModule_SetDocString(PyObject *, const char *)</code></li>
<li><code>int PyModule_AddFunctions(PyObject *, PyMethodDef *)</code></li>
</ul>
<h2>내보내기 훅 이름 (Export Hook Name)</h2>
<p>이식 가능한 C 식별자는 ASCII로 제한되므로, 모듈 이름은 <code>PyInit</code> 훅 이름을 형성하기 위해 인코딩되어야 합니다.</p>
<p>ASCII 모듈 이름의 경우 임포트 훅은 <code>PyInit_&#x3C;modulename></code>으로 명명됩니다. 여기서 <code>&#x3C;modulename></code>은 모듈의 이름입니다.</p>
<p>비(非) ASCII 문자를 포함하는 모듈 이름의 경우 임포트 훅은 <code>PyInitU_&#x3C;encodedname></code>으로 명명됩니다. 여기서 이름은 CPython의 "punycode" 인코딩 (소문자 접미사가 있는 Punycode)을 사용하여 인코딩되며, 하이픈 ("-")은 밑줄 ("_")로 대체됩니다.</p>
<p>Python에서:</p>
<pre><code class="language-python">def export_hook_name(name):
    try:
        suffix = b'_' + name.encode('ascii')
    except UnicodeEncodeError:
        suffix = b'U_' + name.encode('punycode').replace(b'-', b'_')
    return b'PyInit' + suffix
</code></pre>
<p>예시:</p>
<p>| 모듈 이름 | 초기화 훅 이름      |
| :---------- | :------------------- |
| spam        | <code>PyInit_spam</code>        |
| lančmít     | <code>PyInitU_lanmt_2sa6t</code> |
| スパム      | <code>PyInitU_zck5b2b</code>    |</p>
<p>비(非) ASCII 이름을 가진 모듈의 경우 단일 단계 초기화는 지원되지 않습니다.</p>
<p>이 PEP의 초기 구현에서는 비(非) ASCII 이름을 가진 내장 모듈은 지원되지 않을 것입니다.</p>
<h2>모듈 재로드 (Module Reloading)</h2>
<p><code>importlib.reload()</code>를 사용하여 확장 모듈을 재로드하는 것은 임포트 관련 속성을 다시 설정하는 것을 제외하고는 계속해서 아무런 효과가 없을 것입니다.</p>
<p>공유 라이브러리 로딩의 제한(POSIX의 <code>dlopen</code>과 Windows의 <code>LoadModuleEx</code> 모두)으로 인해, 디스크에서 변경된 라이브러리를 일반적으로 다시 로드할 수 없습니다.</p>
<p>모듈의 새 버전을 시도하는 것 외에 재로드의 사용 사례는 드물기 때문에 모든 모듈 개발자가 재로드를 염두에 두어야 할 필요는 없습니다. 재로드와 유사한 기능이 필요한 경우, 개발자는 이를 위한 전용 함수를 내보낼 수 있습니다.</p>
<h2>하나의 라이브러리에 여러 모듈 (Multiple modules in one library)</h2>
<p>하나의 공유 라이브러리에 여러 Python 모듈을 지원하려면, 라이브러리는 라이브러리 파일 이름에 해당하는 것 외에 추가적인 <code>PyInit*</code> 심볼을 내보낼 수 있습니다.</p>
<p>이 메커니즘은 현재 추가 모듈을 로드하는 데만 사용될 수 있으며, 모듈을 찾는 데는 사용될 수 없다는 점에 유의하십시오. (이는 이 PEP에서 수정하려 하지 않는 로더 메커니즘의 한계입니다.) 적절한 파인더가 없는 문제를 해결하기 위해 다음과 같은 코드를 사용할 수 있습니다.</p>
<pre><code class="language-python">import importlib.machinery
import importlib.util

loader = importlib.machinery.ExtensionFileLoader(name, path)
spec = importlib.util.spec_from_loader(name, loader)
module = importlib.util.module_from_spec(spec)
loader.exec_module(module)
return module
</code></pre>
<p>심볼릭 링크(symbolic links)를 지원하는 플랫폼에서는 이를 사용하여 하나의 라이브러리를 여러 이름으로 설치하여, 모든 내보내진 모듈을 일반 임포트 메커니즘에 노출할 수 있습니다.</p>
<h2>API 변경 및 추가 요약 (Summary of API Changes and Additions)</h2>
<p><strong>새로운 함수:</strong></p>
<ul>
<li><code>PyModule_FromDefAndSpec</code> (매크로)</li>
<li><code>PyModule_FromDefAndSpec2</code></li>
<li><code>PyModule_ExecDef</code></li>
<li><code>PyModule_SetDocString</code></li>
<li><code>PyModule_AddFunctions</code></li>
<li><code>PyModuleDef_Init</code></li>
</ul>
<p><strong>새로운 매크로:</strong></p>
<ul>
<li><code>Py_mod_create</code></li>
<li><code>Py_mod_exec</code></li>
</ul>
<p><strong>새로운 타입:</strong></p>
<ul>
<li><code>PyModuleDef_Type</code>이 노출될 것입니다.</li>
</ul>
<p><strong>새로운 구조체:</strong></p>
<ul>
<li><code>PyModuleDef_Slot</code></li>
</ul>
<p><strong>기타 변경 사항:</strong></p>
<ul>
<li><code>PyModuleDef.m_reload</code>가 <code>PyModuleDef.m_slots</code>로 변경됩니다.</li>
<li><code>BuiltinImporter</code> 및 <code>ExtensionFileLoader</code>는 이제 <code>create_module</code> 및 <code>exec_module</code>을 구현할 것입니다.</li>
<li>내부 <code>_imp</code> 모듈은 이전 버전과 호환되지 않는 변경 사항이 있을 것입니다: <code>create_builtin</code>, <code>create_dynamic</code>, <code>exec_dynamic</code>이 추가될 것이며, <code>init_builtin</code>, <code>load_dynamic</code>은 제거될 것입니다.</li>
<li>문서화되지 않은 함수 <code>imp.load_dynamic</code> 및 <code>imp.init_builtin</code>은 이전 버전과 호환되는 심(shim)으로 대체될 것입니다.</li>
</ul>
<h2>이전 버전과의 호환성 (Backwards Compatibility)</h2>
<p>기존 모듈은 새 버전의 Python과 소스 및 바이너리 호환성을 계속 유지할 것입니다. 다단계 초기화를 사용하는 모듈은 이 PEP를 구현하지 않는 Python 버전과 호환되지 않을 것입니다.</p>
<p><code>init_builtin</code> 및 <code>load_dynamic</code> 함수는 <code>_imp</code> 모듈에서 제거될 것입니다 (그러나 <code>imp</code> 모듈에서는 제거되지 않습니다).</p>
<p>모든 변경된 로더 (<code>BuiltinImporter</code> 및 <code>ExtensionFileLoader</code>)는 이전 버전과 호환성을 유지할 것입니다; <code>load_module</code> 메서드는 심으로 대체될 것입니다.</p>
<p><code>Python/import.c</code> 및 <code>Python/importdl.c</code>의 내부 함수는 제거될 것입니다. (구체적으로는 <code>_PyImport_GetDynLoadFunc</code>, <code>_PyImport_GetDynLoadWindows</code>, <code>_PyImport_LoadDynamicModule</code>입니다.)</p>
<h2>가능한 향후 확장 (Possible Future Extensions)</h2>
<p>PEP 384의 <code>PyType_Slot</code>에서 영감을 받은 슬롯 메커니즘은 향후 확장을 가능하게 합니다.</p>
<p>일부 확장 모듈은 많은 상수를 내보냅니다. 예를 들어 <code>_ssl</code>은 다음과 같은 형태의 긴 호출 목록을 가지고 있습니다.</p>
<pre><code class="language-c">PyModule_AddIntConstant(m, "SSL_ERROR_ZERO_RETURN", PY_SSL_ERROR_ZERO_RETURN);
</code></pre>
<p>이를 <code>PyMethodDef</code>와 유사한 선언적 목록으로 변환하면 상용구(boilerplate)를 줄이고, 종종 누락되는 무료 오류 검사를 제공할 수 있습니다.</p>
<p>문자열 상수(String constants) 및 타입도 유사하게 처리될 수 있습니다. (타입의 기본값이 아닌 기본(non-default bases)은 정적으로 이식 가능하게 지정될 수 없다는 점에 유의하십시오. 이 경우 슬롯이 추가되기 전에 실행되는 <code>Py_mod_exec</code> 함수가 필요합니다. 하지만 무료 오류 검사는 여전히 유용할 것입니다.)</p>
<p>또 다른 가능성은 모듈이 Python의 <code>-m</code> 스위치에 주어질 때 실행되는 "main" 함수를 제공하는 것입니다. 이를 위해서는 <code>runpy</code> 모듈이 PEP 451에서 도입된 <code>ModuleSpec</code> 기반 로딩을 활용하도록 수정되어야 합니다. 또한, 원래 정의되지 않은 슬롯에 따라 모듈을 설정하기 위한 메커니즘을 추가해야 할 것입니다.</p>
<h2>구현 (Implementation)</h2>
<p>진행 중인 구현은 GitHub 저장소에서 볼 수 있으며, 패치셋은에 있습니다.</p>
<h2>이전 접근 방식 (Previous Approaches)</h2>
<p>Stefan Behnel의 초기 프로토 PEP는 모듈 클래스를 생성하는 "PyInit_modulename" 훅을 가지고 있었고, 그 <code>__init__</code>가 모듈을 생성하기 위해 호출되었을 것입니다. 이 제안은 (당시에는 존재하지 않았던) PEP 451에 해당하지 않았는데, PEP 451에서는 모듈 생성과 초기화가 별개의 단계로 나뉘어 있습니다. 또한 기존 모듈 객체로 확장을 로드하는 것을 지원하지 않았습니다.</p>
<p>Alyssa (Nick) Coghlan은 "Create" 및 "Exec" 훅을 제안하고 프로토타입 구현을 작성했습니다. 이때 PEP 451은 아직 구현되지 않았으므로 프로토타입은 <code>ModuleSpec</code>을 사용하지 않습니다.</p>
<p>이 PEP의 원래 버전은 Create 및 Exec 훅을 사용했으며, Exec 훅을 사용하여 임의의 미리 구성된 객체로 로드하는 것을 허용했습니다. 이 제안은 확장 모듈 초기화를 Python 모듈이 초기화되는 방식에 더 가깝게 만들었지만, 나중에 이것이 중요한 목표가 아니라는 것이 인식되었습니다. 현재 PEP는 더 간단한 해결책을 설명합니다.</p>
<p>추가적인 반복에서는 <code>PyInit</code>가 기존 방식에 사용되고 <code>PyModuleExport</code>가 다단계 방식에 사용되는 <code>PyInit</code>에 대한 대안으로 "PyModuleExport" 훅을 사용했습니다. 그러나 모듈 이름을 기반으로 훅 이름을 결정할 수 없으면 <code>freeze</code>와 같은 도구에 의한 <code>PyImport_Inittab</code>의 자동 생성이 복잡해졌습니다. 정의를 내보내는 데 완전히 적절하지 않더라도 <code>PyInit</code> 훅 이름만 유지하는 것이 훨씬 더 간단한 해결책을 낳았습니다.</p>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/488/">[Final] PEP 488 - Elimination of PYO files</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 489 - Multi-phase extension module initialization</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/490/">[Rejected] PEP 490 - Chain exceptions at C level</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d6cea809dcbae606.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-bb929596377d30e0.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/489\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d6cea809dcbae606.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"aIY0iLmQmvh4xdeXIovMZ\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/489/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/489\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"489\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/489\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"default\"]\ne:T7d80,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0489/\"\u003ePEP 489 - Multi-phase extension module initialization\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 11-Aug-2013\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 489 – 다단계 확장 모듈 초기화\u003c/h1\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 내장(built-in) 및 확장 모듈(extension module)이 임포트(import) 메커니즘과 상호작용하는 방식을 재설계할 것을 제안합니다. 이 방식은 Python 3.0에서 PEP 3121을 통해 마지막으로 개정되었지만, 당시의 모든 문제를 해결하지는 못했습니다. 목표는 확장 모듈을 Python 모듈의 동작 방식에 더 가깝게 만듦으로써 임포트 관련 문제를 해결하는 것입니다. 특히 PEP 451에서 도입된 \u003ccode\u003eModuleSpec\u003c/code\u003e 기반 로딩 메커니즘에 연결하는 것을 목표로 합니다.\u003c/p\u003e\n\u003cp\u003e이 제안은 PEP 384의 \u003ccode\u003ePyType_Spec\u003c/code\u003e에서 영감을 받아 확장 모듈 개발자가 필요한 기능만 정의할 수 있도록 하고, 향후 확장 모듈 선언에 추가 기능을 도입할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e확장 모듈은 클래스의 \u003ccode\u003e__new__\u003c/code\u003e와 \u003ccode\u003e__init__\u003c/code\u003e에 비유될 수 있는 두 단계 프로세스로 생성되어, \u003ccode\u003eModuleSpec\u003c/code\u003e 아키텍처에 더 잘 들어맞습니다.\u003c/p\u003e\n\u003cp\u003e새로운 방식을 통해 확장 모듈은 일반 가비지 컬렉션(garbage collection)의 대상이 되고, 재로드(reloading) 및 서브 인터프리터(sub-interpreters)를 지원하는 C-레벨 모듈별 상태를 안전하게 저장할 수 있습니다. 확장 모듈 개발자들은 새로운 API를 사용할 때 이러한 문제를 고려할 것을 권장합니다.\u003c/p\u003e\n\u003cp\u003e또한 이 제안은 비(非) ASCII 이름을 가진 확장 모듈도 허용합니다.\u003c/p\u003e\n\u003cp\u003ePEP 3121에서 다루었던 모든 문제가 이 제안에서 해결되는 것은 아닙니다. 특히 런타임 모듈 조회(\u003ccode\u003ePyState_FindModule\u003c/code\u003e)와 관련된 문제는 향후 PEP로 남겨둡니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePython 모듈과 확장 모듈은 동일한 방식으로 설정되지 않습니다. Python 모듈의 경우, 모듈 객체가 먼저 생성되고 설정된 다음 모듈 코드가 실행됩니다 (PEP 302). \u003ccode\u003eModuleSpec\u003c/code\u003e 객체 (PEP 451)는 모듈에 대한 정보를 담는 데 사용되며 관련 훅(hook)에 전달됩니다.\u003c/p\u003e\n\u003cp\u003e확장 모듈 (즉, 공유 라이브러리) 및 내장 모듈의 경우, 모듈 초기화 함수가 즉시 실행되어 생성과 초기화를 모두 수행합니다. 초기화 함수에는 \u003ccode\u003eModuleSpec\u003c/code\u003e이나 \u003ccode\u003e__file__\u003c/code\u003e, 완전한 이름(fully-qualified name)과 같은 포함된 정보가 전달되지 않습니다. 이로 인해 상대 임포트(relative imports) 및 리소스 로딩이 방해받습니다.\u003c/p\u003e\n\u003cp\u003ePython 3에서는 모듈이 \u003ccode\u003esys.modules\u003c/code\u003e에 추가되지 않는 문제도 있습니다. 이는 (잠재적으로 전이적인) 모듈의 재임포트가 실제로 다시 임포트하려고 시도하여, 모듈 초기화 함수를 다시 실행할 때 무한 루프에 빠질 수 있음을 의미합니다. 완전한 모듈 이름에 접근할 수 없으면 모듈을 \u003ccode\u003esys.modules\u003c/code\u003e에 올바르게 추가하는 것도 쉽지 않습니다. 이는 특히 Cython으로 생성된 모듈에 문제가 되는데, 해당 모듈의 초기화 코드가 일반 Python 모듈과 동일한 복잡성을 가질 때가 흔합니다. 또한 \u003ccode\u003e__file__\u003c/code\u003e 및 \u003ccode\u003e__name__\u003c/code\u003e 정보가 없으면 \u003ccode\u003e__init__.py\u003c/code\u003e 모듈, 즉 패키지 컴파일을 방해하며, 특히 모듈 초기화 시점에 상대 임포트가 사용될 때 더욱 그렇습니다.\u003c/p\u003e\n\u003cp\u003e더 나아가, 현재 존재하는 대부분의 확장 모듈은 서브 인터프리터 지원 및/또는 인터프리터 재로드에 문제가 있으며, 현재 인프라로 이러한 기능을 지원하는 것이 가능하더라도 쉽거나 효율적이지 않습니다. 이러한 문제를 해결하는 것이 PEP 3121의 목표였지만, 표준 라이브러리의 일부를 포함한 많은 확장 모듈은 Python 3로 포팅할 때 최소한의 노력을 기울여 이러한 문제가 해결되지 않은 채로 남았습니다. 이 PEP는 이전 버전과의 호환성을 유지하여 부담을 줄이고 확장 모듈 개발자가 포팅 시 이러한 문제를 고려할 충분한 시간을 제공해야 합니다.\u003c/p\u003e\n\u003ch2\u003e현재 프로세스 (The current process)\u003c/h2\u003e\n\u003cp\u003e현재 확장 및 내장 모듈은 공유 라이브러리의 파일 이름을 따서 명명된 \"PyInit_modulename\"이라는 초기화 함수를 내보냅니다. 이 함수는 임포트 메커니즘에 의해 실행되며 완전히 초기화된 모듈 객체를 반환해야 합니다. 이 함수는 인수를 받지 않으므로 임포트 컨텍스트를 알 수 있는 방법이 없습니다.\u003c/p\u003e\n\u003cp\u003e실행 중에 모듈 초기화 함수는 \u003ccode\u003ePyModuleDef\u003c/code\u003e 객체를 기반으로 모듈 객체를 생성합니다. 그런 다음 모듈 딕셔너리에 속성을 추가하고, 타입을 생성하는 등으로 모듈을 계속 초기화합니다.\u003c/p\u003e\n\u003cp\u003e내부적으로 공유 라이브러리 로더는 마지막으로 로드된 모듈의 완전한 모듈 이름을 기록해 두고, 해당 이름과 일치하는 모듈이 생성되면 이 전역 변수를 사용하여 모듈 객체의 완전한 이름을 결정합니다. 이는 모듈 초기화 함수가 먼저 자체 모듈 객체를 생성한다는 가정에 의존하므로 완전히 안전하지 않지만, 실제로는 일반적으로 이 가정이 유지됩니다.\u003c/p\u003e\n\u003ch2\u003e제안 (The proposal)\u003c/h2\u003e\n\u003cp\u003e초기화 함수 (\u003ccode\u003ePyInit_modulename\u003c/code\u003e)는 \u003ccode\u003ePyModuleDef\u003c/code\u003e 객체에 대한 포인터를 반환할 수 있도록 허용됩니다. 임포트 메커니즘은 모듈 객체를 구성하는 역할을 담당하며, 초기화의 관련 단계에서 (아래 설명된 대로) \u003ccode\u003ePyModuleDef\u003c/code\u003e에 제공된 훅을 호출합니다.\u003c/p\u003e\n\u003cp\u003e이 다단계 초기화는 추가적인 가능성입니다. 완전히 초기화된 모듈 객체를 반환하는 현재 방식인 단일 단계 초기화는 계속 허용되므로, 기존 코드는 바이너리 호환성을 포함하여 변경 없이 작동할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyModuleDef\u003c/code\u003e 구조체는 PEP 384의 \u003ccode\u003ePyType_Spec\u003c/code\u003e과 유사하게 슬롯(slots) 목록을 포함하도록 변경될 것입니다. 바이너리 호환성을 유지하고 새로운 구조체 도입을 피하기 위해 (\u003ccode\u003em_reload\u003c/code\u003e의 현재 사용되지 않는 포인터가 슬롯을 담도록 변경됩니다. 이는 추가 지원 함수와 모듈별 저장소를 도입할 필요를 방지합니다). 구조체는 다음과 같이 정의됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct {\n    int slot;\n    void *value;\n} PyModuleDef_Slot;\n\ntypedef struct PyModuleDef {\n    PyModuleDef_Base m_base;\n    const char* m_name;\n    const char* m_doc;\n    Py_ssize_t m_size;\n    PyMethodDef *m_methods;\n    PyModuleDef_Slot *m_slots; /* 'inquiry m_reload;'에서 변경됨 */\n    traverseproc m_traverse;\n    inquiry m_clear;\n    freefunc m_free;\n} PyModuleDef;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003em_slots\u003c/code\u003e 멤버는 \u003ccode\u003eNULL\u003c/code\u003e이거나, ID가 0으로 설정된 슬롯(\u003ccode\u003e{0, NULL}\u003c/code\u003e)으로 끝나는 \u003ccode\u003ePyModuleDef_Slot\u003c/code\u003e 구조체 배열을 가리켜야 합니다.\u003c/p\u003e\n\u003cp\u003e슬롯을 지정하려면 고유한 슬롯 ID를 제공해야 합니다. 새로운 Python 버전은 새로운 슬롯 ID를 도입할 수 있지만, 슬롯 ID는 재활용되지 않습니다. 슬롯은 사용되지 않게 될 수 있지만, Python 3.x 전체에서 계속 지원됩니다.\u003c/p\u003e\n\u003cp\u003e슬롯의 \u003ccode\u003evalue\u003c/code\u003e 포인터는 슬롯 문서에서 달리 지정되지 않는 한 \u003ccode\u003eNULL\u003c/code\u003e이 아닐 수 있습니다.\u003c/p\u003e\n\u003cp\u003e현재 사용 가능한 슬롯은 다음과 같으며, 나중에 설명됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePy_mod_create\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePy_mod_exec\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e알 수 없는 슬롯 ID는 \u003ccode\u003eSystemError\u003c/code\u003e와 함께 임포트를 실패하게 합니다.\u003c/p\u003e\n\u003cp\u003e다단계 초기화를 사용할 때 \u003ccode\u003ePyModuleDef\u003c/code\u003e의 \u003ccode\u003em_name\u003c/code\u003e 필드는 임포트 중에 사용되지 않습니다. 모듈 이름은 \u003ccode\u003eModuleSpec\u003c/code\u003e에서 가져옵니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyInit_*\u003c/code\u003e에서 반환되기 전에 \u003ccode\u003ePyModuleDef\u003c/code\u003e 객체는 새로 추가된 \u003ccode\u003ePyModuleDef_Init\u003c/code\u003e 함수를 사용하여 초기화되어야 합니다. 이 함수는 객체 타입 (특정 컴파일러에서는 정적으로 수행할 수 없음), 참조 카운트, 내부 관리 데이터 (\u003ccode\u003em_index\u003c/code\u003e)를 설정합니다. 예를 들어, 확장 모듈 \"example\"은 다음과 같이 내보내집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estatic PyModuleDef example_def = {...}\n\nPyMODINIT_FUNC PyInit_example(void) {\n    return PyModuleDef_Init(\u0026#x26;example_def);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ePyModuleDef\u003c/code\u003e 객체는 해당 객체로부터 생성된 모듈의 수명 동안 사용 가능해야 합니다. 일반적으로 정적으로 선언될 것입니다.\u003c/p\u003e\n\u003ch2\u003e의사 코드 개요 (Pseudo-code Overview)\u003c/h2\u003e\n\u003cp\u003e수정된 임포터가 어떻게 작동할지에 대한 개요입니다. 로깅이나 오류 및 유효하지 않은 상태 처리와 같은 세부 사항은 생략되었으며, C 코드는 간결한 Python과 유사한 구문으로 제공됩니다.\u003c/p\u003e\n\u003cp\u003e임포터를 호출하는 프레임워크는 PEP 451에 설명되어 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e(원문의 의사 코드 예시는 너무 길어 여기에 모두 번역하지 않습니다. 핵심은 \u003ccode\u003eBuiltinImporter\u003c/code\u003e와 \u003ccode\u003eExtensionFileLoader\u003c/code\u003e가 \u003ccode\u003ecreate_module\u003c/code\u003e과 \u003ccode\u003eexec_module\u003c/code\u003e을 구현하고, \u003ccode\u003ePyModule_FromDefAndSpec\u003c/code\u003e 함수가 \u003ccode\u003ePyModuleDef\u003c/code\u003e와 \u003ccode\u003eModuleSpec\u003c/code\u003e을 받아 모듈을 생성하며, \u003ccode\u003ePyModule_ExecDef\u003c/code\u003e 함수가 모듈의 실행 슬롯을 처리한다는 것입니다.)\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003e모듈 생성 단계 (Module Creation Phase)\u003c/h2\u003e\n\u003cp\u003e모듈 객체 생성, 즉 \u003ccode\u003eExecutionLoader.create_module\u003c/code\u003e의 구현은 \u003ccode\u003ePy_mod_create\u003c/code\u003e 슬롯에 의해 제어됩니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ePy_mod_create\u003c/code\u003e 슬롯\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ePy_mod_create\u003c/code\u003e 슬롯은 사용자 정의 모듈 서브클래스를 지원하는 데 사용됩니다. \u003ccode\u003evalue\u003c/code\u003e 포인터는 다음 시그니처를 가진 함수를 가리켜야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003ePyObject* (*PyModuleCreateFunction)(PyObject *spec, PyModuleDef *def)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 PEP 451에 정의된 \u003ccode\u003eModuleSpec\u003c/code\u003e 인스턴스와 \u003ccode\u003ePyModuleDef\u003c/code\u003e 구조체를 받습니다. 새 모듈 객체를 반환하거나, 오류를 설정하고 \u003ccode\u003eNULL\u003c/code\u003e을 반환해야 합니다.\u003c/p\u003e\n\u003cp\u003e이 함수는 새 모듈에 PEP 451에 지정된 임포트 관련 속성(예: \u003ccode\u003e__name__\u003c/code\u003e 또는 \u003ccode\u003e__loader__\u003c/code\u003e)을 설정할 책임이 없습니다.\u003c/p\u003e\n\u003cp\u003e반환된 객체가 \u003ccode\u003etypes.ModuleType\u003c/code\u003e의 인스턴스여야 한다는 요구 사항은 없습니다. 속성 설정 및 가져오기(최소한 임포트 관련 속성 포함)를 지원하는 한 모든 타입을 사용할 수 있습니다. 그러나 \u003ccode\u003eModuleType\u003c/code\u003e 인스턴스만 모듈별 기능(예: 모듈별 상태 및 실행 슬롯 처리)을 지원합니다. \u003ccode\u003eModuleType\u003c/code\u003e 서브클래스 이외의 것이 반환되면 실행 슬롯을 정의할 수 없으며, 정의될 경우 \u003ccode\u003eSystemError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003cp\u003e이 함수가 호출될 때 모듈의 \u003ccode\u003esys.modules\u003c/code\u003e 항목이 아직 채워지지 않는다는 점에 유의하십시오. 동일한 모듈을 다시 임포트하려고 시도하면 (전이적으로라도) 무한 루프가 발생할 수 있습니다. 확장 모듈 개발자는 \u003ccode\u003ePy_mod_create\u003c/code\u003e를 최소한으로 유지하고, 특히 사용자 코드를 호출하지 않도록 조언됩니다.\u003c/p\u003e\n\u003cp\u003e여러 \u003ccode\u003ePy_mod_create\u003c/code\u003e 슬롯은 지정할 수 없습니다. 지정될 경우 임포트가 \u003ccode\u003eSystemError\u003c/code\u003e와 함께 실패합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePy_mod_create\u003c/code\u003e가 지정되지 않으면 임포트 메커니즘은 \u003ccode\u003ePyModule_New\u003c/code\u003e를 사용하여 일반 모듈 객체를 생성합니다. 이름은 \u003ccode\u003espec\u003c/code\u003e에서 가져옵니다.\u003c/p\u003e\n\u003ch3\u003e생성 후 단계 (Post-creation steps)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ePy_mod_create\u003c/code\u003e 함수가 \u003ccode\u003etypes.ModuleType\u003c/code\u003e 또는 서브클래스의 인스턴스를 반환하거나 (\u003ccode\u003ePy_mod_create\u003c/code\u003e 슬롯이 없는 경우), 임포트 메커니즘은 \u003ccode\u003ePyModuleDef\u003c/code\u003e를 모듈과 연결합니다. 이로 인해 \u003ccode\u003ePyModuleDef\u003c/code\u003e는 실행 단계, \u003ccode\u003ePyModule_GetDef\u003c/code\u003e 함수 및 가비지 컬렉션 루틴(traverse, clear, free)에서 접근 가능해집니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePy_mod_create\u003c/code\u003e 함수가 모듈 서브클래스를 반환하지 않는 경우, \u003ccode\u003em_size\u003c/code\u003e는 0이어야 하고 \u003ccode\u003em_traverse\u003c/code\u003e, \u003ccode\u003em_clear\u003c/code\u003e, \u003ccode\u003em_free\u003c/code\u003e는 모두 \u003ccode\u003eNULL\u003c/code\u003e이어야 합니다. 그렇지 않으면 \u003ccode\u003eSystemError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003cp\u003e또한, \u003ccode\u003ePyModuleDef\u003c/code\u003e에 지정된 초기 속성은 타입에 관계없이 모듈 객체에 설정됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDocstring은 \u003ccode\u003em_doc\u003c/code\u003e이 \u003ccode\u003eNULL\u003c/code\u003e이 아니면 설정됩니다.\u003c/li\u003e\n\u003cli\u003e모듈의 함수는 \u003ccode\u003em_methods\u003c/code\u003e가 있으면 초기화됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e모듈 실행 단계 (Module Execution Phase)\u003c/h2\u003e\n\u003cp\u003e모듈 실행, 즉 \u003ccode\u003eExecutionLoader.exec_module\u003c/code\u003e의 구현은 \"실행 슬롯\"에 의해 제어됩니다. 이 PEP는 \u003ccode\u003ePy_mod_exec\u003c/code\u003e 하나만 추가하지만, 향후 다른 슬롯이 추가될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e실행 단계는 모듈 객체와 연결된 \u003ccode\u003ePyModuleDef\u003c/code\u003e에서 수행됩니다. \u003ccode\u003ePyModule_Type\u003c/code\u003e의 서브클래스가 아닌 객체 (PyModule_GetDef가 실패하는 경우)의 경우 실행 단계는 건너뜁니다.\u003c/p\u003e\n\u003cp\u003e실행 슬롯은 여러 번 지정될 수 있으며, 슬롯 배열에 나타나는 순서대로 처리됩니다. 기본 임포트 메커니즘을 사용할 때, 이들은 PEP 451에 지정된 임포트 관련 속성(예: \u003ccode\u003e__name__\u003c/code\u003e 또는 \u003ccode\u003e__loader__\u003c/code\u003e)이 설정되고 모듈이 \u003ccode\u003esys.modules\u003c/code\u003e에 추가된 후에 처리됩니다.\u003c/p\u003e\n\u003ch3\u003e실행 전 단계 (Pre-Execution steps)\u003c/h3\u003e\n\u003cp\u003e실행 슬롯을 처리하기 전에 모듈에 대한 모듈별 상태가 할당됩니다. 이 시점부터 모듈별 상태는 \u003ccode\u003ePyModule_GetState\u003c/code\u003e를 통해 접근할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ePy_mod_exec\u003c/code\u003e 슬롯\u003c/h3\u003e\n\u003cp\u003e이 슬롯의 항목은 다음 시그니처를 가진 함수를 가리켜야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint (*PyModuleExecFunction)(PyObject* module)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 모듈을 초기화하기 위해 호출됩니다. 일반적으로 이는 모듈의 초기 속성을 설정하는 것을 의미합니다. \"module\" 인수는 초기화할 모듈 객체를 받습니다.\u003c/p\u003e\n\u003cp\u003e함수는 성공 시 0을 반환해야 하며, 오류 시 예외를 설정하고 -1을 반환해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyModuleExec\u003c/code\u003e가 \u003ccode\u003esys.modules\u003c/code\u003e의 모듈 항목을 대체하면, 모든 실행 슬롯이 처리된 후 새 객체가 임포트립(importlib) 메커니즘에 의해 사용되고 반환될 것입니다. 이는 임포트 메커니즘 자체의 기능입니다. 슬롯 자체는 모두 생성 단계에서 반환된 모듈을 사용하여 처리됩니다. 실행 단계 동안 \u003ccode\u003esys.modules\u003c/code\u003e는 조회되지 않습니다. (확장 모듈의 경우 사용자 정의 모듈 객체를 사용하려면 \u003ccode\u003ePy_mod_create\u003c/code\u003e를 구현하는 것이 일반적으로 더 나은 해결책입니다.)\u003c/p\u003e\n\u003ch2\u003e레거시 초기화 (Legacy Init)\u003c/h2\u003e\n\u003cp\u003e이전 버전과의 호환성을 유지하는 단일 단계 초기화는 계속 지원됩니다. 이 방식에서는 \u003ccode\u003ePyInit\u003c/code\u003e 함수가 \u003ccode\u003ePyModuleDef\u003c/code\u003e 객체 대신 완전히 초기화된 모듈을 반환합니다. 이 경우 \u003ccode\u003ePyInit\u003c/code\u003e 훅은 생성 단계를 구현하며, 실행 단계는 아무것도 하지 않습니다(no-op).\u003c/p\u003e\n\u003cp\u003e이전 버전의 Python에서 변경 없이 작동해야 하는 모듈은 단일 단계 초기화를 고수해야 합니다. 왜냐하면 다단계 초기화가 제공하는 이점은 이전 버전으로 백포팅할 수 없기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e(원문의 예시 코드는 C 코드이므로 번역하지 않고 생략합니다. 핵심은 \u003ccode\u003ePy_mod_exec\u003c/code\u003e 매크로의 존재 여부에 따라 다단계 초기화를 지원하거나 단일 단계 초기화로 폴백하는 방식을 보여줍니다.)\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003e내장 모듈 (Built-In modules)\u003c/h2\u003e\n\u003cp\u003e어떤 확장 모듈이든 실행 파일에 링크하고 \u003ccode\u003einittab\u003c/code\u003e에 포함시켜 (런타임에 \u003ccode\u003ePyImport_AppendInittab\u003c/code\u003e을 사용하거나, 설정 시 \u003ccode\u003efreeze\u003c/code\u003e와 같은 도구를 사용하여) 내장 모듈로 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 가능성을 유지하기 위해 이 PEP에서 도입된 확장 모듈 로딩의 모든 변경 사항은 내장 모듈에도 적용될 것입니다. 유일한 예외는 아래에서 설명할 비(非) ASCII 모듈 이름입니다.\u003c/p\u003e\n\u003ch2\u003e서브 인터프리터 및 인터프리터 재로드 (Subinterpreters and Interpreter Reloading)\u003c/h2\u003e\n\u003cp\u003e새로운 초기화 방식을 사용하는 확장 모듈은 Python 문서에 언급된 문제를 피하면서 서브 인터프리터 및 여러 \u003ccode\u003ePy_Initialize\u003c/code\u003e / \u003ccode\u003ePy_Finalize\u003c/code\u003e 사이클을 올바르게 지원할 것으로 예상됩니다. 이 메커니즘은 이를 쉽게 만들도록 설계되었지만, 확장 모듈 개발자 측에서는 여전히 주의가 필요합니다. 사용자 정의 함수, 메서드 또는 인스턴스가 다른 인터프리터로 유출되어서는 안 됩니다. 이를 달성하기 위해 모든 모듈 수준 상태는 모듈 딕셔너리 또는 \u003ccode\u003ePyModule_GetState\u003c/code\u003e로 접근 가능한 모듈 객체의 저장소에 보관되어야 합니다. 간단한 규칙은 다음과 같습니다: 변경 가능한 또는 사용자 설정 가능한 클래스 속성이 없는 내장 타입을 제외하고는 어떤 정적 데이터도 정의하지 마십시오.\u003c/p\u003e\n\u003ch2\u003e다단계 초기화와 호환되지 않는 함수 (Functions incompatible with multi-phase initialization)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ePyModule_Create\u003c/code\u003e 함수는 \u003ccode\u003enon-NULL m_slots\u003c/code\u003e 포인터를 가진 \u003ccode\u003ePyModuleDef\u003c/code\u003e 구조체에 사용될 때 실패합니다. 이 함수는 다단계 초기화에 필요한 \u003ccode\u003eModuleSpec\u003c/code\u003e 객체에 접근할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyState_FindModule\u003c/code\u003e 함수는 \u003ccode\u003eNULL\u003c/code\u003e을 반환하고, \u003ccode\u003ePyState_AddModule\u003c/code\u003e 및 \u003ccode\u003ePyState_RemoveModule\u003c/code\u003e도 \u003ccode\u003enon-NULL m_slots\u003c/code\u003e를 가진 모듈에서 실패할 것입니다. \u003ccode\u003ePyState\u003c/code\u003e 등록은 동일한 \u003ccode\u003ePyModuleDef\u003c/code\u003e에서 여러 모듈 객체가 생성될 수 있기 때문에 비활성화됩니다.\u003c/p\u003e\n\u003ch2\u003e모듈 상태 및 C-레벨 콜백 (Module state and C-level callbacks)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ePyState_FindModule\u003c/code\u003e를 사용할 수 없기 때문에 모듈 수준 상태(모듈 수준에서 정의된 함수, 클래스 또는 예외 포함)에 접근해야 하는 모든 함수는 모듈 객체(또는 필요한 특정 객체)에 대한 참조를 직접 또는 간접적으로 받아야 합니다. 이는 현재 두 가지 상황에서 어렵습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e클래스의 메서드는 클래스에 대한 참조를 받지만, 클래스의 모듈에 대한 참조는 받지 않습니다.\u003c/li\u003e\n\u003cli\u003eC-레벨 콜백을 사용하는 라이브러리는 콜백 등록 시 사용자 정의 데이터를 받을 수 없는 한 어렵습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 경우를 수정하는 것은 이 PEP의 범위를 벗어나지만, 새로운 메커니즘이 모든 모듈에 유용하려면 필요할 것입니다. 적절한 수정 사항은 \u003ccode\u003eimport-sig\u003c/code\u003e 메일링 리스트에서 논의되었습니다 [5, cite: 1].\u003c/p\u003e\n\u003cp\u003e일반적인 규칙으로, \u003ccode\u003ePyState_FindModule\u003c/code\u003e에 의존하는 모듈은 현재 새로운 메커니즘으로 포팅하기에 좋은 후보가 아닙니다.\u003c/p\u003e\n\u003ch2\u003e새로운 함수 (New Functions)\u003c/h2\u003e\n\u003cp\u003e모듈 생성 단계를 구현하는 새로운 함수와 매크로가 추가될 것입니다. 이들은 \u003ccode\u003ePyModule_Create\u003c/code\u003e 및 \u003ccode\u003ePyModule_Create2\u003c/code\u003e와 유사하지만, 추가적인 \u003ccode\u003eModuleSpec\u003c/code\u003e 인수를 취하고 \u003ccode\u003enon-NULL\u003c/code\u003e 슬롯을 가진 모듈 정의를 처리합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyObject * PyModule_FromDefAndSpec(PyModuleDef *def, PyObject *spec)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject * PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e모듈 실행 단계를 구현하는 새로운 함수가 추가될 것입니다. 이 함수는 모듈별 상태를 할당하고 (이미 할당되지 않은 경우) 항상 실행 슬롯을 처리합니다. 임포트 메커니즘은 모듈이 재로드되지 않는 한 모듈이 실행될 때 이 메서드를 호출합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyAPI_FUNC(int) PyModule_ExecDef(PyObject *module, PyModuleDef *def)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ePyModuleDef\u003c/code\u003e 객체를 초기화하는 또 다른 함수가 도입될 것입니다. 이 멱등(idempotent) 함수는 타입, 참조 카운트 및 모듈 인덱스를 채웁니다. 인수를 \u003ccode\u003ePyObject*\u003c/code\u003e로 캐스팅하여 반환하므로 \u003ccode\u003ePyInit\u003c/code\u003e 함수에서 직접 반환할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyObject * PyModuleDef_Init(PyModuleDef *);\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한, 모듈에 Docstring과 메서드를 설정하기 위한 두 가지 헬퍼 함수가 추가될 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eint PyModule_SetDocString(PyObject *, const char *)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint PyModule_AddFunctions(PyObject *, PyMethodDef *)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e내보내기 훅 이름 (Export Hook Name)\u003c/h2\u003e\n\u003cp\u003e이식 가능한 C 식별자는 ASCII로 제한되므로, 모듈 이름은 \u003ccode\u003ePyInit\u003c/code\u003e 훅 이름을 형성하기 위해 인코딩되어야 합니다.\u003c/p\u003e\n\u003cp\u003eASCII 모듈 이름의 경우 임포트 훅은 \u003ccode\u003ePyInit_\u0026#x3C;modulename\u003e\u003c/code\u003e으로 명명됩니다. 여기서 \u003ccode\u003e\u0026#x3C;modulename\u003e\u003c/code\u003e은 모듈의 이름입니다.\u003c/p\u003e\n\u003cp\u003e비(非) ASCII 문자를 포함하는 모듈 이름의 경우 임포트 훅은 \u003ccode\u003ePyInitU_\u0026#x3C;encodedname\u003e\u003c/code\u003e으로 명명됩니다. 여기서 이름은 CPython의 \"punycode\" 인코딩 (소문자 접미사가 있는 Punycode)을 사용하여 인코딩되며, 하이픈 (\"-\")은 밑줄 (\"_\")로 대체됩니다.\u003c/p\u003e\n\u003cp\u003ePython에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef export_hook_name(name):\n    try:\n        suffix = b'_' + name.encode('ascii')\n    except UnicodeEncodeError:\n        suffix = b'U_' + name.encode('punycode').replace(b'-', b'_')\n    return b'PyInit' + suffix\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cp\u003e| 모듈 이름 | 초기화 훅 이름      |\n| :---------- | :------------------- |\n| spam        | \u003ccode\u003ePyInit_spam\u003c/code\u003e        |\n| lančmít     | \u003ccode\u003ePyInitU_lanmt_2sa6t\u003c/code\u003e |\n| スパム      | \u003ccode\u003ePyInitU_zck5b2b\u003c/code\u003e    |\u003c/p\u003e\n\u003cp\u003e비(非) ASCII 이름을 가진 모듈의 경우 단일 단계 초기화는 지원되지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP의 초기 구현에서는 비(非) ASCII 이름을 가진 내장 모듈은 지원되지 않을 것입니다.\u003c/p\u003e\n\u003ch2\u003e모듈 재로드 (Module Reloading)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eimportlib.reload()\u003c/code\u003e를 사용하여 확장 모듈을 재로드하는 것은 임포트 관련 속성을 다시 설정하는 것을 제외하고는 계속해서 아무런 효과가 없을 것입니다.\u003c/p\u003e\n\u003cp\u003e공유 라이브러리 로딩의 제한(POSIX의 \u003ccode\u003edlopen\u003c/code\u003e과 Windows의 \u003ccode\u003eLoadModuleEx\u003c/code\u003e 모두)으로 인해, 디스크에서 변경된 라이브러리를 일반적으로 다시 로드할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e모듈의 새 버전을 시도하는 것 외에 재로드의 사용 사례는 드물기 때문에 모든 모듈 개발자가 재로드를 염두에 두어야 할 필요는 없습니다. 재로드와 유사한 기능이 필요한 경우, 개발자는 이를 위한 전용 함수를 내보낼 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e하나의 라이브러리에 여러 모듈 (Multiple modules in one library)\u003c/h2\u003e\n\u003cp\u003e하나의 공유 라이브러리에 여러 Python 모듈을 지원하려면, 라이브러리는 라이브러리 파일 이름에 해당하는 것 외에 추가적인 \u003ccode\u003ePyInit*\u003c/code\u003e 심볼을 내보낼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 메커니즘은 현재 추가 모듈을 로드하는 데만 사용될 수 있으며, 모듈을 찾는 데는 사용될 수 없다는 점에 유의하십시오. (이는 이 PEP에서 수정하려 하지 않는 로더 메커니즘의 한계입니다.) 적절한 파인더가 없는 문제를 해결하기 위해 다음과 같은 코드를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport importlib.machinery\nimport importlib.util\n\nloader = importlib.machinery.ExtensionFileLoader(name, path)\nspec = importlib.util.spec_from_loader(name, loader)\nmodule = importlib.util.module_from_spec(spec)\nloader.exec_module(module)\nreturn module\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e심볼릭 링크(symbolic links)를 지원하는 플랫폼에서는 이를 사용하여 하나의 라이브러리를 여러 이름으로 설치하여, 모든 내보내진 모듈을 일반 임포트 메커니즘에 노출할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003eAPI 변경 및 추가 요약 (Summary of API Changes and Additions)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e새로운 함수:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyModule_FromDefAndSpec\u003c/code\u003e (매크로)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyModule_FromDefAndSpec2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyModule_ExecDef\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyModule_SetDocString\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyModule_AddFunctions\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyModuleDef_Init\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e새로운 매크로:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePy_mod_create\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePy_mod_exec\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e새로운 타입:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyModuleDef_Type\u003c/code\u003e이 노출될 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e새로운 구조체:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyModuleDef_Slot\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e기타 변경 사항:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyModuleDef.m_reload\u003c/code\u003e가 \u003ccode\u003ePyModuleDef.m_slots\u003c/code\u003e로 변경됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBuiltinImporter\u003c/code\u003e 및 \u003ccode\u003eExtensionFileLoader\u003c/code\u003e는 이제 \u003ccode\u003ecreate_module\u003c/code\u003e 및 \u003ccode\u003eexec_module\u003c/code\u003e을 구현할 것입니다.\u003c/li\u003e\n\u003cli\u003e내부 \u003ccode\u003e_imp\u003c/code\u003e 모듈은 이전 버전과 호환되지 않는 변경 사항이 있을 것입니다: \u003ccode\u003ecreate_builtin\u003c/code\u003e, \u003ccode\u003ecreate_dynamic\u003c/code\u003e, \u003ccode\u003eexec_dynamic\u003c/code\u003e이 추가될 것이며, \u003ccode\u003einit_builtin\u003c/code\u003e, \u003ccode\u003eload_dynamic\u003c/code\u003e은 제거될 것입니다.\u003c/li\u003e\n\u003cli\u003e문서화되지 않은 함수 \u003ccode\u003eimp.load_dynamic\u003c/code\u003e 및 \u003ccode\u003eimp.init_builtin\u003c/code\u003e은 이전 버전과 호환되는 심(shim)으로 대체될 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e이전 버전과의 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e기존 모듈은 새 버전의 Python과 소스 및 바이너리 호환성을 계속 유지할 것입니다. 다단계 초기화를 사용하는 모듈은 이 PEP를 구현하지 않는 Python 버전과 호환되지 않을 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003einit_builtin\u003c/code\u003e 및 \u003ccode\u003eload_dynamic\u003c/code\u003e 함수는 \u003ccode\u003e_imp\u003c/code\u003e 모듈에서 제거될 것입니다 (그러나 \u003ccode\u003eimp\u003c/code\u003e 모듈에서는 제거되지 않습니다).\u003c/p\u003e\n\u003cp\u003e모든 변경된 로더 (\u003ccode\u003eBuiltinImporter\u003c/code\u003e 및 \u003ccode\u003eExtensionFileLoader\u003c/code\u003e)는 이전 버전과 호환성을 유지할 것입니다; \u003ccode\u003eload_module\u003c/code\u003e 메서드는 심으로 대체될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePython/import.c\u003c/code\u003e 및 \u003ccode\u003ePython/importdl.c\u003c/code\u003e의 내부 함수는 제거될 것입니다. (구체적으로는 \u003ccode\u003e_PyImport_GetDynLoadFunc\u003c/code\u003e, \u003ccode\u003e_PyImport_GetDynLoadWindows\u003c/code\u003e, \u003ccode\u003e_PyImport_LoadDynamicModule\u003c/code\u003e입니다.)\u003c/p\u003e\n\u003ch2\u003e가능한 향후 확장 (Possible Future Extensions)\u003c/h2\u003e\n\u003cp\u003ePEP 384의 \u003ccode\u003ePyType_Slot\u003c/code\u003e에서 영감을 받은 슬롯 메커니즘은 향후 확장을 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003e일부 확장 모듈은 많은 상수를 내보냅니다. 예를 들어 \u003ccode\u003e_ssl\u003c/code\u003e은 다음과 같은 형태의 긴 호출 목록을 가지고 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003ePyModule_AddIntConstant(m, \"SSL_ERROR_ZERO_RETURN\", PY_SSL_ERROR_ZERO_RETURN);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 \u003ccode\u003ePyMethodDef\u003c/code\u003e와 유사한 선언적 목록으로 변환하면 상용구(boilerplate)를 줄이고, 종종 누락되는 무료 오류 검사를 제공할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e문자열 상수(String constants) 및 타입도 유사하게 처리될 수 있습니다. (타입의 기본값이 아닌 기본(non-default bases)은 정적으로 이식 가능하게 지정될 수 없다는 점에 유의하십시오. 이 경우 슬롯이 추가되기 전에 실행되는 \u003ccode\u003ePy_mod_exec\u003c/code\u003e 함수가 필요합니다. 하지만 무료 오류 검사는 여전히 유용할 것입니다.)\u003c/p\u003e\n\u003cp\u003e또 다른 가능성은 모듈이 Python의 \u003ccode\u003e-m\u003c/code\u003e 스위치에 주어질 때 실행되는 \"main\" 함수를 제공하는 것입니다. 이를 위해서는 \u003ccode\u003erunpy\u003c/code\u003e 모듈이 PEP 451에서 도입된 \u003ccode\u003eModuleSpec\u003c/code\u003e 기반 로딩을 활용하도록 수정되어야 합니다. 또한, 원래 정의되지 않은 슬롯에 따라 모듈을 설정하기 위한 메커니즘을 추가해야 할 것입니다.\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e진행 중인 구현은 GitHub 저장소에서 볼 수 있으며, 패치셋은에 있습니다.\u003c/p\u003e\n\u003ch2\u003e이전 접근 방식 (Previous Approaches)\u003c/h2\u003e\n\u003cp\u003eStefan Behnel의 초기 프로토 PEP는 모듈 클래스를 생성하는 \"PyInit_modulename\" 훅을 가지고 있었고, 그 \u003ccode\u003e__init__\u003c/code\u003e가 모듈을 생성하기 위해 호출되었을 것입니다. 이 제안은 (당시에는 존재하지 않았던) PEP 451에 해당하지 않았는데, PEP 451에서는 모듈 생성과 초기화가 별개의 단계로 나뉘어 있습니다. 또한 기존 모듈 객체로 확장을 로드하는 것을 지원하지 않았습니다.\u003c/p\u003e\n\u003cp\u003eAlyssa (Nick) Coghlan은 \"Create\" 및 \"Exec\" 훅을 제안하고 프로토타입 구현을 작성했습니다. 이때 PEP 451은 아직 구현되지 않았으므로 프로토타입은 \u003ccode\u003eModuleSpec\u003c/code\u003e을 사용하지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP의 원래 버전은 Create 및 Exec 훅을 사용했으며, Exec 훅을 사용하여 임의의 미리 구성된 객체로 로드하는 것을 허용했습니다. 이 제안은 확장 모듈 초기화를 Python 모듈이 초기화되는 방식에 더 가깝게 만들었지만, 나중에 이것이 중요한 목표가 아니라는 것이 인식되었습니다. 현재 PEP는 더 간단한 해결책을 설명합니다.\u003c/p\u003e\n\u003cp\u003e추가적인 반복에서는 \u003ccode\u003ePyInit\u003c/code\u003e가 기존 방식에 사용되고 \u003ccode\u003ePyModuleExport\u003c/code\u003e가 다단계 방식에 사용되는 \u003ccode\u003ePyInit\u003c/code\u003e에 대한 대안으로 \"PyModuleExport\" 훅을 사용했습니다. 그러나 모듈 이름을 기반으로 훅 이름을 결정할 수 없으면 \u003ccode\u003efreeze\u003c/code\u003e와 같은 도구에 의한 \u003ccode\u003ePyImport_Inittab\u003c/code\u003e의 자동 생성이 복잡해졌습니다. 정의를 내보내는 데 완전히 적절하지 않더라도 \u003ccode\u003ePyInit\u003c/code\u003e 훅 이름만 유지하는 것이 훨씬 더 간단한 해결책을 낳았습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2353,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 489 - Multi-phase extension module initialization\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:35:12+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/489/\",\"postId\":\"2025-09-26-pep-0489-multi-phase-extension-module-initialization\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/488/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 488 - Elimination of PYO files\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 489 - Multi-phase extension module initialization\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/490/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 490 - Chain exceptions at C level\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>