<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d6cea809dcbae606.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-0395f68b8cc78a20.js" async=""></script><script src="/_next/static/chunks/23-706b53707bbf0661.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-467e37449c5a68fc.js" async=""></script><script src="/_next/static/chunks/app/layout-b44b076173de406f.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2648<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 492 - Coroutines with async and await syntax</h1><div class="page__meta"><time dateTime="2025-09-26 22:37:54+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0492/">PEP 492 - Coroutines with async and await syntax</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 09-Apr-2015</p>
</blockquote>
<h2>PEP 492 – <code>async</code> 및 <code>await</code> 구문을 사용한 코루틴</h2>
<p><strong>저자:</strong> Yury Selivanov
<strong>상태:</strong> Final
<strong>유형:</strong> Standards Track
<strong>생성일:</strong> 2015년 4월 9일
<strong>Python 버전:</strong> 3.5</p>
<h3>초록 (Abstract)</h3>
<p>인터넷의 성장과 전반적인 연결성 증가는 반응성(responsive)과 확장성(scalable) 있는 코드에 대한 필요성을 비례적으로 증가시켰습니다. 이 제안은 명시적인 비동기(asynchronous), 동시성(concurrent) Python 코드를 더 쉽게 작성하고 Pythonic하게 만들어서 이러한 요구에 부응하는 것을 목표로 합니다.</p>
<p>이 PEP는 코루틴(coroutines)을 Python의 적절한 독립 개념으로 만들고 새로운 지원 구문을 도입할 것을 제안합니다. 궁극적인 목표는 Python에서 비동기 프로그래밍에 대한 공통적이고 쉽게 접근할 수 있는 사고 모델을 확립하고 이를 동기 프로그래밍에 최대한 가깝게 만드는 것입니다.</p>
<p>이 PEP는 비동기 작업이 <code>stdlib</code> 모듈 <code>asyncio.events.AbstractEventLoop</code>와 유사한 이벤트 루프(Event Loop)에 의해 스케줄링되고 조정된다고 가정합니다. 이 PEP는 특정 이벤트 루프 구현에 얽매이지 않지만, <code>yield</code>를 스케줄러에 대한 신호(signal)로 사용하여 이벤트(예: I/O)가 완료될 때까지 코루틴이 대기할 것임을 나타내는 종류의 코루틴에만 관련됩니다.</p>
<p>이 제안의 변경 사항은 빠르게 성장하는 비동기 프로그래밍 분야에서 Python이 관련성을 유지하고 경쟁력을 갖추는 데 도움이 될 것으로 예상됩니다. 많은 다른 언어들도 유사한 기능을 채택했거나 채택할 계획이기 때문입니다.</p>
<h3>API 설계 및 구현 수정 (API Design and Implementation Revisions)</h3>
<p>Python 3.5 초기 베타 릴리스에 대한 피드백 결과, 이 PEP를 지원하는 객체 모델이 재설계되어 네이티브 코루틴(native coroutines)을 제너레이터(generators)와 더 명확하게 분리했습니다. 이제 네이티브 코루틴은 새로운 종류의 제너레이터가 아닌, 완전히 별개의 고유한 타입입니다. 이 변경은 주로 Tornado 웹 서버에 네이티브 코루틴 지원을 통합하려는 시도에서 발생한 문제들 때문에 구현되었습니다.</p>
<p>CPython 3.5.2에서는 <code>__aiter__</code> 프로토콜이 업데이트되었습니다. 3.5.2 이전에는 <code>__aiter__</code>가 비동기 이터레이터(asynchronous iterator)로 확인되는 awaitable을 반환해야 했습니다. 3.5.2부터 <code>__aiter__</code>는 비동기 이터레이터를 직접 반환해야 합니다. 3.5.2에서 이전 프로토콜을 사용하면 <code>PendingDeprecationWarning</code>이 발생합니다. CPython 3.6에서는 이전 <code>__aiter__</code> 프로토콜이 <code>DeprecationWarning</code>과 함께 계속 지원됩니다. CPython 3.7에서는 이전 <code>__aiter__</code> 프로토콜이 더 이상 지원되지 않으며, <code>__aiter__</code>가 비동기 이터레이터 이외의 것을 반환하면 <code>RuntimeError</code>가 발생합니다.</p>
<h3>근거 및 목표 (Rationale and Goals)</h3>
<p>현재 Python은 PEP 342를 통해 제너레이터(generators)를 이용한 코루틴 구현을 지원하며, PEP 380에 도입된 <code>yield from</code> 구문을 통해 더욱 강화되었습니다. 하지만 이 접근 방식에는 몇 가지 단점이 있습니다:</p>
<ul>
<li>코루틴과 일반 제너레이터가 동일한 구문을 공유하기 때문에 혼동하기 쉽습니다. 특히 새로운 개발자에게는 더욱 그렇습니다.</li>
<li>함수가 코루틴인지 여부는 본문에 <code>yield</code> 또는 <code>yield from</code> 문이 있는지 여부로 결정되는데, 이는 리팩토링(refactoring) 중에 이러한 문이 함수 본문에 나타나거나 사라질 때 명확하지 않은 오류로 이어질 수 있습니다.</li>
<li>비동기 호출 지원은 <code>yield</code>가 문법적으로 허용되는 표현식으로 제한되어 <code>with</code> 및 <code>for</code> 문과 같은 구문 기능의 유용성을 제한합니다.</li>
</ul>
<p>이 제안은 코루틴을 Python 언어의 네이티브(native) 기능으로 만들고, 제너레이터와 명확하게 분리합니다. 이는 제너레이터/코루틴의 모호성을 제거하고, 특정 라이브러리에 의존하지 않고 코루틴을 안정적으로 정의할 수 있게 합니다. 또한 린터(linters)와 IDE가 정적 코드 분석 및 리팩토링을 개선할 수 있도록 합니다.</p>
<p>네이티브 코루틴과 관련 새 구문 기능을 통해 컨텍스트 관리자(context manager) 및 이터레이션(iteration) 프로토콜을 비동기적으로 정의할 수 있습니다. 이 제안에서 나중에 보여주듯이, 새로운 <code>async with</code> 문을 사용하면 Python 프로그램이 런타임 컨텍스트(runtime context)에 진입하고 종료할 때 비동기 호출을 수행할 수 있으며, 새로운 <code>async for</code> 문을 사용하면 이터레이터(iterators)에서 비동기 호출을 수행할 수 있습니다.</p>
<h3>명세 (Specification)</h3>
<p>이 제안은 Python의 코루틴 지원을 강화하기 위한 새로운 구문과 의미론을 소개합니다.</p>
<p>이 명세는 Python의 코루틴 구현(PEP 342 및 PEP 380)에 대한 지식을 전제로 합니다. 여기서 제안된 구문 변경에 대한 동기는 <code>asyncio</code> 프레임워크(PEP 3156)와 "Cofunctions" 제안(PEP 3152, 현재 이 명세에 찬성하여 거부됨)에서 비롯됩니다.</p>
<p>이 문서의 이 시점부터 우리는 새로운 구문을 사용하여 선언된 함수를 지칭하기 위해 <strong>네이티브 코루틴(native coroutine)</strong> 이라는 단어를 사용합니다. 제너레이터 구문에 기반한 코루틴을 지칭할 필요가 있을 때는 <strong>제너레이터 기반 코루틴(generator-based coroutine)</strong> 이 사용됩니다. 두 정의 모두 적용 가능한 맥락에서는 <strong>코루틴(coroutine)</strong> 이 사용됩니다.</p>
<h4>새로운 코루틴 선언 구문 (New Coroutine Declaration Syntax)</h4>
<p>네이티브 코루틴을 선언하는 데 다음의 새로운 구문이 사용됩니다:</p>
<pre><code class="language-python">async def read_data(db):
    pass
</code></pre>
<p>코루틴의 주요 특징은 다음과 같습니다:</p>
<ul>
<li><code>async def</code> 함수는 <code>await</code> 표현식을 포함하지 않더라도 항상 코루틴입니다.</li>
<li><code>async</code> 함수 내에 <code>yield</code> 또는 <code>yield from</code> 표현식이 있는 것은 <code>SyntaxError</code>입니다.</li>
<li>내부적으로 두 개의 새로운 코드 객체 플래그가 도입되었습니다:
<ul>
<li><code>CO_COROUTINE</code>은 네이티브 코루틴(새 구문으로 정의됨)을 표시하는 데 사용됩니다.</li>
<li><code>CO_ITERABLE_COROUTINE</code>은 제너레이터 기반 코루틴을 네이티브 코루틴과 호환되게 만드는 데 사용됩니다(<code>types.coroutine()</code> 함수에 의해 설정됨).</li>
</ul>
</li>
<li>일반 제너레이터는 호출될 때 제너레이터 객체를 반환하는 것과 유사하게, 코루틴은 코루틴 객체를 반환합니다.</li>
<li><code>StopIteration</code> 예외는 코루틴 밖으로 전파되지 않으며, <code>RuntimeError</code>로 대체됩니다. 일반 제너레이터의 경우 이러한 동작은 <code>__future__</code> import를 필요로 합니다 (PEP 479 참조).</li>
<li>네이티브 코루틴이 가비지 컬렉션될 때, 한 번도 <code>await</code>되지 않았다면 <code>RuntimeWarning</code>이 발생합니다 (디버깅 기능 참조).</li>
</ul>
<h4><code>types.coroutine()</code></h4>
<p><code>types</code> 모듈에 새로운 함수 <code>coroutine(fn)</code>이 추가됩니다. 이 함수는 <code>asyncio</code>의 기존 제너레이터 기반 코루틴과 이 PEP에 의해 도입된 네이티브 코루틴 간의 상호 운용성을 허용합니다:</p>
<pre><code class="language-python">@types.coroutine
def process_data(db):
    data = yield from read_data(db)
    # ...
</code></pre>
<p>이 함수는 제너레이터 함수의 코드 객체에 <code>CO_ITERABLE_COROUTINE</code> 플래그를 적용하여 코루틴 객체를 반환하도록 만듭니다. <code>fn</code>이 제너레이터 함수가 아닌 경우, 래핑됩니다. 제너레이터를 반환하는 경우, awaitable 프록시 객체로 래핑됩니다 (awaitable 객체 정의 참조). <code>CO_COROUTINE</code> 플래그는 <code>types.coroutine()</code>에 의해 적용되지 않아 새로운 구문으로 정의된 네이티브 코루틴과 제너레이터 기반 코루틴을 분리할 수 있도록 합니다.</p>
<h4><code>await</code> 표현식 (Await Expression)</h4>
<p>코루틴 실행 결과를 얻기 위해 다음의 새로운 <code>await</code> 표현식이 사용됩니다:</p>
<pre><code class="language-python">async def read_data(db):
    data = await db.fetch('SELECT ...')
    # ...
</code></pre>
<p><code>await</code>는 <code>yield from</code>과 유사하게 <code>db.fetch</code> awaitable이 완료되고 결과 <code>data</code>를 반환할 때까지 <code>read_data</code> 코루틴의 실행을 일시 중단합니다. 이는 인수의 유효성을 검사하는 추가 단계와 함께 <code>yield from</code> 구현을 사용합니다. <code>await</code>는 다음 중 하나인 awaitable만 허용합니다:</p>
<ul>
<li>네이티브 코루틴 함수에서 반환된 네이티브 코루틴 객체.</li>
<li><code>types.coroutine()</code>으로 데코레이트된 함수에서 반환된 제너레이터 기반 코루틴 객체.</li>
<li>이터레이터(iterator)를 반환하는 <code>__await__</code> 메서드를 가진 객체.</li>
</ul>
<p><code>yield from</code> 호출 체인은 항상 <code>yield</code>로 끝납니다. 이는 Futures가 구현되는 근본적인 메커니즘입니다. 내부적으로 코루틴은 특별한 종류의 제너레이터이므로, 모든 <code>await</code>는 <code>await</code> 호출 체인의 어딘가에서 <code>yield</code>에 의해 일시 중단됩니다 (자세한 설명은 PEP 3156 참조).</p>
<p>코루틴에 이 동작을 활성화하기 위해 <code>__await__</code>라는 새로운 매직 메서드가 추가됩니다. 예를 들어 <code>asyncio</code>에서 <code>Future</code> 객체를 <code>await</code> 문에서 사용할 수 있도록 하려면 <code>asyncio.Future</code> 클래스에 <code>__await__ = __iter__</code> 줄을 추가하는 것만으로 충분합니다. 이 PEP의 나머지 부분에서 <code>__await__</code> 메서드를 가진 객체를 <code>Future-like objects</code>라고 부릅니다.</p>
<p><code>__await__</code>가 이터레이터가 아닌 다른 것을 반환하면 <code>TypeError</code>가 발생합니다. CPython C API로 정의된 객체는 <code>__await__</code> 메서드와 유사하게 이터레이터를 반환하는 <code>tp_as_async.am_await</code> 함수를 가질 수 있습니다. <code>async def</code> 함수 외부에서 <code>await</code>를 사용하는 것은 <code>SyntaxError</code>입니다 ( <code>def</code> 함수 외부에서 <code>yield</code>를 사용하는 것이 <code>SyntaxError</code>인 것과 같습니다). awaitable 객체가 아닌 다른 것을 <code>await</code> 표현식에 전달하는 것은 <code>TypeError</code>입니다.</p>
<p><strong>업데이트된 연산자 우선순위 표 (Updated operator precedence table)</strong></p>
<p><code>await</code> 키워드는 다음과 같이 정의됩니다:</p>
<pre><code>power ::= await [" **" u_expr]
await ::= ["await"] primary
</code></pre>
<p>여기서 "primary"는 언어의 가장 강력하게 바인딩된 연산을 나타냅니다. <code>await</code> 연산자의 우선순위는 <code>[]</code>, <code>()</code>, <code>.</code>보다 낮지만 <code>** </code> 연산자보다 높도록 결정되었습니다.</p>
<p><strong><code>await</code> 표현식의 예시 (Examples of “await” expressions)</strong></p>
<p>유효한 구문 예시:</p>
<pre><code class="language-python">if await fut: pass
pair = await fut, 'spam'
with await fut, open(): pass
await foo()['spam'].baz()()
return await coro()
res = await coro() ** 2
func(a1=await coro(), a2=0)
await foo() + await bar()
-await foo()
</code></pre>
<p>유효하지 않은 구문 예시 (수정 제안과 함께):</p>
<pre><code class="language-python"># Expression           Should be written as
# await await coro()   await (await coro())
# await -coro()        await (-coro())
</code></pre>
<h4>비동기 컨텍스트 관리자 및 <code>async with</code> (Asynchronous Context Managers and “async with”)</h4>
<p>비동기 컨텍스트 관리자는 <code>enter</code> 및 <code>exit</code> 메서드에서 실행을 일시 중단할 수 있는 컨텍스트 관리자입니다. 이를 가능하게 하기 위해 비동기 컨텍스트 관리자를 위한 새로운 프로토콜이 제안됩니다. <code>__aenter__</code> 및 <code>__aexit__</code>라는 두 가지 새로운 매직 메서드가 추가됩니다. 둘 다 awaitable을 반환해야 합니다.</p>
<p>비동기 컨텍스트 관리자의 예시:</p>
<pre><code class="language-python">class AsyncContextManager:
    async def __aenter__(self):
        await log('entering context')
    async def __aexit__(self, exc_type, exc, tb):
        await log('exiting context')
</code></pre>
<p>** 새 구문 (New Syntax)**</p>
<p>비동기 컨텍스트 관리자를 위한 새로운 문장이 제안됩니다:</p>
<pre><code class="language-python">async with EXPR as VAR:
    BLOCK
</code></pre>
<p>이는 의미론적으로 다음과 동일합니다:</p>
<pre><code class="language-python">mgr = (EXPR)
aexit = type(mgr).__aexit__
aenter = type(mgr).__aenter__
VAR = await aenter(mgr)
try:
    BLOCK
except:
    if not await aexit(mgr, *sys.exc_info()):
        raise
else:
    await aexit(mgr, None, None, None)
</code></pre>
<p>일반 <code>with</code> 문과 마찬가지로, 단일 <code>async with</code> 문에서 여러 컨텍스트 관리자를 지정할 수 있습니다. <code>__aenter__</code> 및 <code>__aexit__</code> 메서드가 없는 일반 컨텍스트 관리자를 <code>async with</code>에 전달하는 것은 오류입니다. <code>async def</code> 함수 외부에서 <code>async with</code>를 사용하는 것은 <code>SyntaxError</code>입니다.</p>
<h4>비동기 이터레이터 및 <code>async for</code> (Asynchronous Iterators and “async for”)</h4>
<p>비동기 이터러블(asynchronous iterable)은 <code>iter</code> 구현에서 비동기 코드를 호출할 수 있으며, 비동기 이터레이터는 <code>next</code> 메서드에서 비동기 코드를 호출할 수 있습니다. 비동기 이터레이션을 지원하려면:</p>
<ul>
<li>객체는 비동기 이터레이터 객체를 반환하는 <code>__aiter__</code> 메서드를 구현해야 합니다 (또는 CPython C API로 정의된 경우 <code>tp_as_async.am_aiter</code> 슬롯).</li>
<li>비동기 이터레이터 객체는 awaitable을 반환하는 <code>__anext__</code> 메서드를 구현해야 합니다 (또는 CPython C API로 정의된 경우 <code>tp_as_async.am_anext</code> 슬롯).</li>
<li>이터레이션을 중지하려면 <code>__anext__</code>는 <code>StopAsyncIteration</code> 예외를 발생시켜야 합니다.</li>
</ul>
<p>비동기 이터러블의 예시:</p>
<pre><code class="language-python">class AsyncIterable:
    def __aiter__(self):
        return self
    async def __anext__(self):
        data = await self.fetch_data()
        if data:
            return data
        else:
            raise StopAsyncIteration
    async def fetch_data(self):
        # ...
</code></pre>
<p><strong>새 구문 (New Syntax)</strong></p>
<p>비동기 이터레이터를 통해 반복하기 위한 새로운 문장이 제안됩니다:</p>
<pre><code class="language-python">async for TARGET in ITER:
    BLOCK
else:
    BLOCK2
</code></pre>
<p>이는 의미론적으로 다음과 동일합니다:</p>
<pre><code class="language-python">iter = (ITER)
iter = type(iter).__aiter__(iter)
running = True
while running:
    try:
        TARGET = await type(iter).__anext__(iter)
    except StopAsyncIteration:
        running = False
    else:
        BLOCK
else:
    BLOCK2
</code></pre>
<p><code>__aiter__</code> 메서드가 없는 일반 이터러블을 <code>async for</code>에 전달하는 것은 <code>TypeError</code>입니다. <code>async def</code> 함수 외부에서 <code>async for</code>를 사용하는 것은 <code>SyntaxError</code>입니다. 일반 <code>for</code> 문과 마찬가지로 <code>async for</code>는 선택적 <code>else</code> 절을 가집니다.</p>
<p><strong>왜 <code>StopAsyncIteration</code>인가? (Why StopAsyncIteration?)</strong></p>
<p>코루틴은 내부적으로 여전히 제너레이터에 기반합니다. PEP 479 이전에는 <code>def g1(): yield from fut; return 'spam'</code>과 <code>def g2(): yield from fut; raise StopIteration('spam')</code> 사이에 근본적인 차이가 없었습니다. PEP 479가 승인되어 코루틴에 기본적으로 활성화되었기 때문에, <code>async def a1(): await fut; raise StopIteration('spam')</code>과 같은 예시에서는 <code>StopIteration</code>이 <code>RuntimeError</code>로 래핑됩니다.</p>
<p>외부 코드에 이터레이션이 종료되었음을 알리는 유일한 방법은 <code>StopIteration</code> 이외의 다른 예외를 발생시키는 것입니다. 따라서 새로운 내장 예외 클래스 <code>StopAsyncIteration</code>이 추가되었습니다. 더욱이, PEP 479의 의미론에 따라 코루틴에서 발생한 모든 <code>StopIteration</code> 예외는 <code>RuntimeError</code>로 래핑됩니다.</p>
<h4>코루틴 객체 (Coroutine objects)</h4>
<p>이 섹션은 <code>CO_COROUTINE</code> 플래그가 있는 네이티브 코루틴, 즉 새로운 <code>async def</code> 구문으로 정의된 코루틴에만 적용됩니다. <code>asyncio</code>의 기존 <strong>제너레이터 기반 코루틴</strong> 의 동작은 변경되지 않습니다. 코루틴과 제너레이터가 별개의 개념으로 다루어지도록 많은 노력이 기울여졌습니다:</p>
<ul>
<li>네이티브 코루틴 객체는 <code>__iter__</code> 및 <code>__next__</code> 메서드를 구현하지 않습니다. 따라서 <code>iter()</code>, <code>list()</code>, <code>tuple()</code> 및 다른 내장 함수를 통해 반복하거나 전달할 수 없습니다. 또한 <code>for..in</code> 루프에서 사용할 수 없습니다.</li>
<li>네이티브 코루틴 객체에 <code>__iter__</code> 또는 <code>__next__</code>를 사용하려고 시도하면 <code>TypeError</code>가 발생합니다.</li>
<li>일반 제너레이터는 네이티브 코루틴에서 <code>yield from</code>을 사용할 수 없습니다. 그렇게 하면 <code>TypeError</code>가 발생합니다.</li>
<li>제너레이터 기반 코루틴(<code>asyncio</code> 코드는 <code>@asyncio.coroutine</code>으로 데코레이트되어야 함)은 네이티브 코루틴 객체에서 <code>yield from</code>을 사용할 수 있습니다.</li>
<li><code>inspect.isgenerator()</code> 및 <code>inspect.isgeneratorfunction()</code>은 네이티브 코루틴 객체 및 네이티브 코루틴 함수에 대해 <code>False</code>를 반환합니다.</li>
</ul>
<p><strong>코루틴 객체 메서드 (Coroutine object methods)</strong></p>
<p>코루틴은 내부적으로 제너레이터에 기반하므로 구현을 공유합니다. 제너레이터 객체와 마찬가지로 코루틴은 <code>throw()</code>, <code>send()</code>, <code>close()</code> 메서드를 가집니다. <code>StopIteration</code> 및 <code>GeneratorExit</code>는 코루틴에 대해 동일한 역할을 수행합니다 (비록 PEP 479가 코루틴에 기본적으로 활성화되어 있지만). <code>throw()</code>, <code>send()</code> 메서드는 <code>Future-like objects</code>에 값을 푸시하고 오류를 발생시키는 데 사용됩니다.</p>
<h4>디버깅 기능 (Debugging Features)</h4>
<p>초보적인 실수는 코루틴에서 <code>yield from</code>을 사용하는 것을 잊는 것입니다:</p>
<pre><code class="language-python">@asyncio.coroutine
def useful():
    asyncio.sleep(1) # 'yield from' 없이는 아무것도 하지 않습니다.
</code></pre>
<p>이러한 종류의 실수를 디버깅하기 위해 <code>asyncio</code>에는 특별한 디버그 모드가 있습니다. 이 모드에서 <code>@coroutine</code> 데코레이터는 모든 함수를 소멸자(destructor)로 경고를 기록하는 특수 객체로 래핑합니다. 래핑된 제너레이터가 가비지 컬렉션될 때마다, 데코레이터 함수가 정확히 어디에 정의되었는지, 컬렉션된 위치의 스택 트레이스(stack trace) 등에 대한 정보를 담은 자세한 로깅 메시지가 생성됩니다. 래퍼(wrapper) 객체는 또한 제너레이터에 대한 자세한 정보와 함께 편리한 <code>__repr__</code> 함수를 제공합니다.</p>
<p>이러한 디버그 기능을 활성화하는 방법이 문제입니다. 디버그 기능은 프로덕션 모드에서는 아무런 작동을 하지 않아야 하므로, <code>@coroutine</code> 데코레이터는 OS 환경 변수 <code>PYTHONASYNCIODEBUG</code>를 기반으로 래핑 여부를 결정합니다. 이 방식으로 <code>asyncio</code> 자체 함수가 계측된 <code>asyncio</code> 프로그램을 실행할 수 있습니다. <code>EventLoop.set_debug</code>는 다른 디버그 기능이며, <code>@coroutine</code> 데코레이터의 동작에는 영향을 미치지 않습니다.</p>
<p>이 제안을 통해 코루틴은 제너레이터와 구별되는 네이티브 개념이 됩니다. 한 번도 <code>await</code>되지 않은 코루틴에 대해 <code>RuntimeWarning</code>이 발생하는 것 외에도, <code>sys</code> 모듈에 두 개의 새로운 함수를 추가할 것이 제안됩니다: <code>set_coroutine_wrapper</code> 및 <code>get_coroutine_wrapper</code>. 이는 <code>asyncio</code> 및 다른 프레임워크(예: 코루틴이 정확히 어디에서 생성되었는지 표시하거나, 가비지 컬렉션된 위치의 더 자세한 스택 트레이스 표시)에서 고급 디버깅 기능을 활성화하기 위함입니다.</p>
<h4>새로운 표준 라이브러리 함수 (New Standard Library Functions)</h4>
<ul>
<li><code>types.coroutine(gen)</code>: 자세한 내용은 <code>types.coroutine()</code> 섹션 참조.</li>
<li><code>inspect.iscoroutine(obj)</code>: <code>obj</code>가 네이티브 코루틴 객체이면 <code>True</code>를 반환.</li>
<li><code>inspect.iscoroutinefunction(obj)</code>: <code>obj</code>가 네이티브 코루틴 함수이면 <code>True</code>를 반환.</li>
<li><code>inspect.isawaitable(obj)</code>: <code>obj</code>가 awaitable이면 <code>True</code>를 반환.</li>
<li><code>inspect.getcoroutinestate(coro)</code>: 네이티브 코루틴 객체의 현재 상태를 반환 (<code>inspect.getfgeneratorstate(gen)</code>를 미러링).</li>
<li><code>inspect.getcoroutinelocals(coro)</code>: 네이티브 코루틴 객체의 로컬 변수와 해당 값의 매핑을 반환 (<code>inspect.getgeneratorlocals(gen)</code>를 미러링).</li>
<li><code>sys.set_coroutine_wrapper(wrapper)</code>: 네이티브 코루틴 객체 생성을 가로챌 수 있도록 합니다. <code>wrapper</code>는 하나의 인자(코루틴 객체)를 받는 호출 가능 객체이거나 <code>None</code>이어야 합니다. <code>None</code>은 래퍼를 재설정합니다. 두 번 호출되면 새 래퍼가 이전 래퍼를 대체합니다. 이 함수는 스레드별(thread-specific)입니다.</li>
<li><code>sys.get_coroutine_wrapper()</code>: 현재 래퍼 객체를 반환합니다. 래퍼가 설정되지 않은 경우 <code>None</code>을 반환합니다. 이 함수는 스레드별입니다.</li>
</ul>
<h4>새로운 추상 기본 클래스 (New Abstract Base Classes)</h4>
<p>기존 프레임워크(예: Tornado) 및 컴파일러(예: Cython)와의 더 나은 통합을 허용하기 위해 두 개의 새로운 추상 기본 클래스(ABC)가 추가됩니다:</p>
<ul>
<li><code>collections.abc.Awaitable</code>: <code>__await__</code> 메서드를 구현하는 <code>Future-like classes</code>를 위한 ABC.</li>
<li><code>collections.abc.Coroutine</code>: <code>send(value)</code>, <code>throw(type, exc, tb)</code>, <code>close()</code>, <code>__await__()</code> 메서드를 구현하는 코루틴 객체를 위한 ABC.</li>
</ul>
<p><code>CO_ITERABLE_COROUTINE</code> 플래그가 있는 제너레이터 기반 코루틴은 <code>__await__</code> 메서드를 구현하지 않으므로, <code>collections.abc.Coroutine</code> 및 <code>collections.abc.Awaitable</code> ABC의 인스턴스가 아닙니다:</p>
<pre><code class="language-python">@types.coroutine
def gencoro():
    yield
assert not isinstance(gencoro(), collections.abc.Coroutine)
# 하지만:
assert inspect.isawaitable(gencoro())
</code></pre>
<p>객체가 비동기 이터레이션을 지원하는지 쉽게 테스트할 수 있도록 두 개의 ABC가 더 추가됩니다:</p>
<ul>
<li><code>collections.abc.AsyncIterable</code>: <code>__aiter__</code> 메서드를 테스트합니다.</li>
<li><code>collections.abc.AsyncIterator</code>: <code>__aiter__</code> 및 <code>__anext__</code> 메서드를 테스트합니다.</li>
</ul>
<h4>용어 설명 (Glossary)</h4>
<ul>
<li><strong>Native coroutine function (네이티브 코루틴 함수):</strong> <code>async def</code>로 선언된 코루틴 함수. <code>await</code> 및 <code>return value</code>를 사용합니다.</li>
<li><strong>Native coroutine (네이티브 코루틴):</strong> 네이티브 코루틴 함수에서 반환됩니다.</li>
<li><strong>Generator-based coroutine function (제너레이터 기반 코루틴 함수):</strong> 제너레이터 구문에 기반한 코루틴. <code>@asyncio.coroutine</code>으로 데코레이트된 함수가 가장 일반적인 예시입니다.</li>
<li><strong>Generator-based coroutine (제너레이터 기반 코루틴):</strong> 제너레이터 기반 코루틴 함수에서 반환됩니다.</li>
<li><strong>Coroutine (코루틴):</strong> 네이티브 코루틴 또는 제너레이터 기반 코루틴.</li>
<li><strong>Coroutine object (코루틴 객체):</strong> 네이티브 코루틴 객체 또는 제너레이터 기반 코루틴 객체.</li>
<li><strong>Future-like object (퓨처 유사 객체):</strong> <code>__await__</code> 메서드를 가진 객체, 또는 <code>tp_as_async->am_await</code> 함수를 가진 C 객체로 이터레이터를 반환합니다. 코루틴의 <code>await</code> 표현식에 의해 소비될 수 있습니다. 퓨처 유사 객체를 기다리는 코루틴은 퓨처 유사 객체의 <code>__await__</code>가 완료되고 결과를 반환할 때까지 일시 중단됩니다.</li>
<li><strong>Awaitable (어웨이터블):</strong> 퓨처 유사 객체 또는 코루틴 객체.</li>
<li><strong>Asynchronous context manager (비동기 컨텍스트 관리자):</strong> <code>__aenter__</code> 및 <code>__aexit__</code> 메서드를 가지며 <code>async with</code>와 함께 사용할 수 있습니다.</li>
<li><strong>Asynchronous iterable (비동기 이터러블):</strong> 비동기 이터레이터 객체를 반환해야 하는 <code>__aiter__</code> 메서드를 가진 객체. <code>async for</code>와 함께 사용할 수 있습니다.</li>
<li><strong>Asynchronous iterator (비동기 이터레이터):</strong> <code>__anext__</code> 메서드를 가집니다.</li>
</ul>
<h4>전환 계획 (Transition Plan)</h4>
<p><code>async</code> 및 <code>await</code> 키워드와의 하위 호환성 문제를 피하기 위해 <code>tokenizer.c</code>를 다음과 같이 수정하기로 결정했습니다:</p>
<ul>
<li><code>async def NAME</code> 토큰 조합을 인식합니다.</li>
<li><code>async def</code> 블록을 토큰화하는 동안, <code>'async'</code> <code>NAME</code> 토큰을 <code>ASYNC</code>로, <code>'await'</code> <code>NAME</code> 토큰을 <code>AWAIT</code>로 대체합니다.</li>
<li><code>def</code> 블록을 토큰화하는 동안, <code>'async'</code> 및 <code>'await'</code> <code>NAME</code> 토큰을 그대로 반환합니다.</li>
</ul>
<p>이 접근 방식은 새로운 구문 기능(모두 <code>async</code> 함수에서만 사용 가능)과 기존 코드의 원활한 조합을 허용합니다.</p>
<pre><code class="language-python">class Spam:
    async = 42
    async def ham():
        print(getattr(Spam, 'async')) # 코루틴이 실행되어 '42'를 출력합니다.
</code></pre>
<h4>하위 호환성 (Backwards Compatibility)</h4>
<p>이 제안은 100% 하위 호환성을 유지합니다.</p>
<p><strong>asyncio</strong></p>
<p><code>asyncio</code> 모듈은 코루틴 및 새로운 문과 함께 작동하도록 조정되고 테스트되었습니다. 하위 호환성은 100% 유지됩니다. 즉, 모든 기존 코드는 그대로 작동합니다.</p>
<p>필요한 변경 사항은 주로 다음과 같습니다:</p>
<ul>
<li><code>@asyncio.coroutine</code> 데코레이터를 새로운 <code>types.coroutine()</code> 함수를 사용하도록 수정합니다.</li>
<li><code>asyncio.Future</code> 클래스에 <code>__await__ = __iter__</code> 줄을 추가합니다.</li>
<li><code>async()</code> 함수의 별칭으로 <code>ensure_future()</code>를 추가합니다.</li>
<li><code>async()</code> 함수를 Deprecate합니다.</li>
</ul>
<p><strong>asyncio 마이그레이션 전략 (asyncio migration strategy)</strong></p>
<p>일반 제너레이터는 네이티브 코루틴 객체에서 <code>yield from</code>을 사용할 수 없으므로(자세한 내용은 제너레이터와의 차이점 섹션 참조), 새로운 구문을 사용하기 전에 모든 제너레이터 기반 코루틴이 <code>@asyncio.coroutine</code>으로 데코레이트되었는지 확인하는 것이 좋습니다.</p>
<h4>문법 업데이트 (Grammar Updates)</h4>
<p>문법 변경은 상당히 미미합니다:</p>
<pre><code>decorated: decorators (classdef | funcdef | async_funcdef)
async_funcdef: ASYNC funcdef
compound_stmt: (if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt)
async_stmt: ASYNC (funcdef | with_stmt | for_stmt)
power: atom_expr ['**' factor]
atom_expr: [AWAIT] atom trailer*
</code></pre>
<h4>폐지 계획 (Deprecation Plans)</h4>
<p><code>async</code> 및 <code>await</code> 이름은 CPython 3.5 및 3.6에서 소프트하게 폐지됩니다. 3.7에서는 이들을 적절한 키워드로 전환할 것입니다. 3.7 이전에 <code>async</code> 및 <code>await</code>를 적절한 키워드로 만들면 사람들이 코드를 Python 3으로 포팅하기 더 어려워질 수 있습니다.</p>
<h4>설계 고려 사항 (Design Considerations)</h4>
<p><strong>왜 <code>async</code>와 <code>await</code> 키워드인가 (Why “async” and “await” keywords)</strong></p>
<p><code>async/await</code>는 프로그래밍 언어에서 새로운 개념이 아닙니다.</p>
<ul>
<li>C#은 오래 전부터 이 기능을 가지고 있습니다.</li>
<li>ECMAScript 7에 <code>async/await</code>를 추가하려는 제안이 있습니다.</li>
<li>Facebook의 Hack/HHVM.</li>
<li>Google의 Dart 언어.</li>
<li>Scala.</li>
<li>C++에 <code>async/await</code>를 추가하려는 제안이 있습니다.</li>
<li>그리고 다른 많은 덜 인기 있는 언어들에도 존재합니다.</li>
</ul>
<p>이는 일부 사용자들이 이미 <code>async/await</code> 경험이 있고, 한 프로젝트에서 여러 언어(예: Python과 ECMAScript 7)를 함께 사용하는 것을 더 쉽게 만들기 때문에 큰 이점입니다.</p>
<p><strong>왜 <code>async</code> 키워드가 중요한가 (Importance of “async” keyword)</strong></p>
<p><code>await</code> 표현식만 구현하고 최소한 하나의 <code>await</code>를 가진 모든 함수를 코루틴으로 처리하는 것도 가능하지만, 이 접근 방식은 API 설계, 코드 리팩토링 및 장기적인 지원을 더 어렵게 만듭니다.</p>
<p>Python에 <code>await</code> 키워드만 있다고 가정해 봅시다:</p>
<pre><code class="language-python">def useful():
    # ...
    await log(...)
    # ...

def important():
    await useful()
</code></pre>
<p>만약 <code>useful()</code> 함수가 리팩토링되어 누군가 그 안의 모든 <code>await</code> 표현식을 제거한다면, 그것은 일반 Python 함수가 될 것이고, <code>important()</code>를 포함하여 그 함수에 의존하는 모든 코드가 망가질 것입니다. 이 문제를 완화하려면 <code>@asyncio.coroutine</code>과 유사한 데코레이터를 도입해야 합니다.</p>
<p><strong>왜 <code>async def</code>인가 (Why “async def”)</strong></p>
<p>일부 사람들에게는 <code>async name(): pass</code>와 같은 간단한 구문이 <code>async def name(): pass</code>보다 더 매력적으로 보일 수 있습니다. 분명히 타이핑하기 더 쉽습니다. 그러나 다른 한편으로는 <code>async def</code>, <code>async with</code>, <code>async for</code> 사이의 대칭을 깨뜨립니다. 여기서 <code>async</code>는 문장이 비동기임을 나타내는 수식어(modifier)입니다. 또한 기존 문법과 더 일관성이 있습니다.</p>
<p><strong>왜 매직 메서드는 "a"로 시작하는가 (Why magic methods start with “a”)</strong></p>
<p>새로운 비동기 매직 메서드 <code>__aiter__</code>, <code>__anext__</code>, <code>__aenter__</code>, <code>__aexit__</code>는 모두 동일한 접두사 "a"로 시작합니다. 대안 제안은 "async" 접두사를 사용하여 <code>__anext__</code>를 <code>__async_next__</code>로 만드는 것이었습니다. 그러나 새로운 매직 메서드를 <code>__radd__</code> 및 <code>__iadd__</code>와 같은 기존 메서드와 일치시키기 위해 더 짧은 버전을 사용하기로 결정했습니다.</p>
<p><strong>왜 기존 매직 이름을 재사용하지 않는가 (Why not reuse existing magic names)</strong></p>
<p>새로운 비동기 이터레이터 및 컨텍스트 관리자에 대한 대안 아이디어는 선언에 <code>async</code> 키워드를 추가하여 기존 매직 메서드를 재사용하는 것이었습니다:</p>
<pre><code class="language-python">class CM:
    async def __enter__(self): # __aenter__ 대신
        # ...
</code></pre>
<p>이 접근 방식에는 다음과 같은 단점이 있습니다:</p>
<ul>
<li><code>with</code> 및 <code>async with</code> 문 모두에서 작동하는 객체를 생성할 수 없습니다.</li>
<li>Python &#x3C;= 3.4에서는 <code>__enter__</code> 및/또는 <code>__exit__</code>에서 <code>Future-like objects</code>를 반환하는 것을 금지하지 않으므로 하위 호환성을 깨뜨릴 수 있습니다.</li>
<li>이 제안의 주요 목적 중 하나는 네이티브 코루틴을 가능한 한 간단하고 오류 방지(foolproof)로 만드는 것이므로, 프로토콜을 명확하게 분리하는 것이 중요합니다.</li>
</ul>
<p><strong>왜 기존 <code>for</code> 및 <code>with</code> 문을 재사용하지 않는가 (Why not reuse existing “for” and “with” statements)</strong></p>
<p>기존 제너레이터 기반 코루틴과 이 제안의 비전은 사용자가 코드가 언제 일시 중단될 수 있는지 쉽게 파악할 수 있도록 하는 것입니다. 기존 <code>for</code> 및 <code>with</code> 문이 비동기 이터레이터 및 컨텍스트 관리자를 인식하도록 만들면 필연적으로 암시적인 일시 중단 지점(suspend points)이 생성되어 코드를 추론하기 더 어려워질 것입니다.</p>
<h3>성능 (Performance)</h3>
<p><strong>전반적인 영향 (Overall Impact)</strong></p>
<p>이 제안은 관찰 가능한 성능 영향을 도입하지 않습니다.</p>
<h3>구현 (Implementation)</h3>
<p>PEP 492는 2015년 5월 5일 Guido에 의해 승인되었습니다. 구현은 이슈 24017에서 추적되었으며, 2015년 5월 11일에 커밋되었습니다.</p>
<p><strong>주요 변경 사항 및 새로운 프로토콜 목록 (List of high-level changes and new protocols)</strong></p>
<ul>
<li>코루틴 정의를 위한 새 구문: <code>async def</code> 및 새 키워드 <code>await</code>.</li>
<li><code>Future-like objects</code>를 위한 새 <code>__await__</code> 메서드, <code>PyTypeObject</code>의 새 <code>tp_as_async.am_await</code> 슬롯.</li>
<li>비동기 컨텍스트 관리자를 위한 새 구문: <code>async with</code> 및 <code>__aenter__</code>, <code>__aexit__</code> 메서드와 관련된 프로토콜.</li>
<li>비동기 이터레이션을 위한 새 구문: <code>async for</code> 및 <code>__aiter__</code>, <code>__anext__</code> 메서드, 새 내장 예외 <code>StopAsyncIteration</code>과 관련된 프로토콜.</li>
<li><code>PyTypeObject</code>의 새 <code>tp_as_async.am_aiter</code> 및 <code>tp_as_async.am_anext</code> 슬롯.</li>
<li>새로운 AST 노드: <code>AsyncFunctionDef</code>, <code>AsyncFor</code>, <code>AsyncWith</code>, <code>Await</code>.</li>
<li>새로운 함수: <code>sys.set_coroutine_wrapper(callback)</code>, <code>sys.get_coroutine_wrapper()</code>, <code>types.coroutine(gen)</code>, <code>inspect.iscoroutinefunction(func)</code>, <code>inspect.iscoroutine(obj)</code>, <code>inspect.isawaitable(obj)</code>, <code>inspect.getcoroutinestate(coro)</code>, <code>inspect.getcoroutinelocals(coro)</code>.</li>
<li>코드 객체를 위한 새 <code>CO_COROUTINE</code> 및 <code>CO_ITERABLE_COROUTINE</code> 비트 플래그.</li>
<li>새로운 ABC: <code>collections.abc.Awaitable</code>, <code>collections.abc.Coroutine</code>, <code>collections.abc.AsyncIterable</code>, <code>collections.abc.AsyncIterator</code>.</li>
<li>C API 변경: 새 <code>PyCoro_Type</code> (Python에 <code>types.CoroutineType</code>으로 노출) 및 <code>PyCoroObject</code>. <code>PyCoro_CheckExact(*o)</code>로 <code>o</code>가 네이티브 코루틴인지 테스트.</li>
</ul>
<p>이 변경 사항 및 새로운 요소 목록이 짧지는 않지만, 대부분의 사용자가 이러한 기능을 직접 사용하지 않을 것이라는 점을 이해하는 것이 중요합니다. 이는 프레임워크와 라이브러리에서 사용되어 <code>async def</code>, <code>await</code>, <code>async for</code>, <code>async with</code> 구문을 통해 사용자에게 편리하고 모호하지 않은 API를 제공하기 위한 것입니다.</p>
<p><strong>작동 예시 (Working example)</strong></p>
<p>이 PEP에서 제안된 모든 개념은 구현되었으며 테스트할 수 있습니다.</p>
<pre><code class="language-python">import asyncio

async def echo_server():
    print('Serving on localhost:8000')
    await asyncio.start_server(handle_connection, 'localhost', 8000)

async def handle_connection(reader, writer):
    print('New connection...')
    while True:
        data = await reader.read(8192)
        if not data:
            break
        print('Sending {:.10}... back'.format(repr(data)))
        writer.write(data)

loop = asyncio.get_event_loop()
loop.run_until_complete(echo_server())
try:
    loop.run_forever()
finally:
    loop.close()
</code></pre>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/491/">[Deferred] PEP 491 - The Wheel Binary Package Format 1.9</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 492 - Coroutines with async and await syntax</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/493/">[Final] PEP 493 - HTTPS verification migration tools for Python 2.7</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d6cea809dcbae606.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-b44b076173de406f.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/492\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d6cea809dcbae606.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"sXH0w-Ur4uCLT-31_N3TA\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/492/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/492\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"492\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/492\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"default\"]\ne:T9d67,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0492/\"\u003ePEP 492 - Coroutines with async and await syntax\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 09-Apr-2015\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 492 – \u003ccode\u003easync\u003c/code\u003e 및 \u003ccode\u003eawait\u003c/code\u003e 구문을 사용한 코루틴\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e저자:\u003c/strong\u003e Yury Selivanov\n\u003cstrong\u003e상태:\u003c/strong\u003e Final\n\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track\n\u003cstrong\u003e생성일:\u003c/strong\u003e 2015년 4월 9일\n\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.5\u003c/p\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e인터넷의 성장과 전반적인 연결성 증가는 반응성(responsive)과 확장성(scalable) 있는 코드에 대한 필요성을 비례적으로 증가시켰습니다. 이 제안은 명시적인 비동기(asynchronous), 동시성(concurrent) Python 코드를 더 쉽게 작성하고 Pythonic하게 만들어서 이러한 요구에 부응하는 것을 목표로 합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 코루틴(coroutines)을 Python의 적절한 독립 개념으로 만들고 새로운 지원 구문을 도입할 것을 제안합니다. 궁극적인 목표는 Python에서 비동기 프로그래밍에 대한 공통적이고 쉽게 접근할 수 있는 사고 모델을 확립하고 이를 동기 프로그래밍에 최대한 가깝게 만드는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 비동기 작업이 \u003ccode\u003estdlib\u003c/code\u003e 모듈 \u003ccode\u003easyncio.events.AbstractEventLoop\u003c/code\u003e와 유사한 이벤트 루프(Event Loop)에 의해 스케줄링되고 조정된다고 가정합니다. 이 PEP는 특정 이벤트 루프 구현에 얽매이지 않지만, \u003ccode\u003eyield\u003c/code\u003e를 스케줄러에 대한 신호(signal)로 사용하여 이벤트(예: I/O)가 완료될 때까지 코루틴이 대기할 것임을 나타내는 종류의 코루틴에만 관련됩니다.\u003c/p\u003e\n\u003cp\u003e이 제안의 변경 사항은 빠르게 성장하는 비동기 프로그래밍 분야에서 Python이 관련성을 유지하고 경쟁력을 갖추는 데 도움이 될 것으로 예상됩니다. 많은 다른 언어들도 유사한 기능을 채택했거나 채택할 계획이기 때문입니다.\u003c/p\u003e\n\u003ch3\u003eAPI 설계 및 구현 수정 (API Design and Implementation Revisions)\u003c/h3\u003e\n\u003cp\u003ePython 3.5 초기 베타 릴리스에 대한 피드백 결과, 이 PEP를 지원하는 객체 모델이 재설계되어 네이티브 코루틴(native coroutines)을 제너레이터(generators)와 더 명확하게 분리했습니다. 이제 네이티브 코루틴은 새로운 종류의 제너레이터가 아닌, 완전히 별개의 고유한 타입입니다. 이 변경은 주로 Tornado 웹 서버에 네이티브 코루틴 지원을 통합하려는 시도에서 발생한 문제들 때문에 구현되었습니다.\u003c/p\u003e\n\u003cp\u003eCPython 3.5.2에서는 \u003ccode\u003e__aiter__\u003c/code\u003e 프로토콜이 업데이트되었습니다. 3.5.2 이전에는 \u003ccode\u003e__aiter__\u003c/code\u003e가 비동기 이터레이터(asynchronous iterator)로 확인되는 awaitable을 반환해야 했습니다. 3.5.2부터 \u003ccode\u003e__aiter__\u003c/code\u003e는 비동기 이터레이터를 직접 반환해야 합니다. 3.5.2에서 이전 프로토콜을 사용하면 \u003ccode\u003ePendingDeprecationWarning\u003c/code\u003e이 발생합니다. CPython 3.6에서는 이전 \u003ccode\u003e__aiter__\u003c/code\u003e 프로토콜이 \u003ccode\u003eDeprecationWarning\u003c/code\u003e과 함께 계속 지원됩니다. CPython 3.7에서는 이전 \u003ccode\u003e__aiter__\u003c/code\u003e 프로토콜이 더 이상 지원되지 않으며, \u003ccode\u003e__aiter__\u003c/code\u003e가 비동기 이터레이터 이외의 것을 반환하면 \u003ccode\u003eRuntimeError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003ch3\u003e근거 및 목표 (Rationale and Goals)\u003c/h3\u003e\n\u003cp\u003e현재 Python은 PEP 342를 통해 제너레이터(generators)를 이용한 코루틴 구현을 지원하며, PEP 380에 도입된 \u003ccode\u003eyield from\u003c/code\u003e 구문을 통해 더욱 강화되었습니다. 하지만 이 접근 방식에는 몇 가지 단점이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e코루틴과 일반 제너레이터가 동일한 구문을 공유하기 때문에 혼동하기 쉽습니다. 특히 새로운 개발자에게는 더욱 그렇습니다.\u003c/li\u003e\n\u003cli\u003e함수가 코루틴인지 여부는 본문에 \u003ccode\u003eyield\u003c/code\u003e 또는 \u003ccode\u003eyield from\u003c/code\u003e 문이 있는지 여부로 결정되는데, 이는 리팩토링(refactoring) 중에 이러한 문이 함수 본문에 나타나거나 사라질 때 명확하지 않은 오류로 이어질 수 있습니다.\u003c/li\u003e\n\u003cli\u003e비동기 호출 지원은 \u003ccode\u003eyield\u003c/code\u003e가 문법적으로 허용되는 표현식으로 제한되어 \u003ccode\u003ewith\u003c/code\u003e 및 \u003ccode\u003efor\u003c/code\u003e 문과 같은 구문 기능의 유용성을 제한합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 제안은 코루틴을 Python 언어의 네이티브(native) 기능으로 만들고, 제너레이터와 명확하게 분리합니다. 이는 제너레이터/코루틴의 모호성을 제거하고, 특정 라이브러리에 의존하지 않고 코루틴을 안정적으로 정의할 수 있게 합니다. 또한 린터(linters)와 IDE가 정적 코드 분석 및 리팩토링을 개선할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e네이티브 코루틴과 관련 새 구문 기능을 통해 컨텍스트 관리자(context manager) 및 이터레이션(iteration) 프로토콜을 비동기적으로 정의할 수 있습니다. 이 제안에서 나중에 보여주듯이, 새로운 \u003ccode\u003easync with\u003c/code\u003e 문을 사용하면 Python 프로그램이 런타임 컨텍스트(runtime context)에 진입하고 종료할 때 비동기 호출을 수행할 수 있으며, 새로운 \u003ccode\u003easync for\u003c/code\u003e 문을 사용하면 이터레이터(iterators)에서 비동기 호출을 수행할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003cp\u003e이 제안은 Python의 코루틴 지원을 강화하기 위한 새로운 구문과 의미론을 소개합니다.\u003c/p\u003e\n\u003cp\u003e이 명세는 Python의 코루틴 구현(PEP 342 및 PEP 380)에 대한 지식을 전제로 합니다. 여기서 제안된 구문 변경에 대한 동기는 \u003ccode\u003easyncio\u003c/code\u003e 프레임워크(PEP 3156)와 \"Cofunctions\" 제안(PEP 3152, 현재 이 명세에 찬성하여 거부됨)에서 비롯됩니다.\u003c/p\u003e\n\u003cp\u003e이 문서의 이 시점부터 우리는 새로운 구문을 사용하여 선언된 함수를 지칭하기 위해 \u003cstrong\u003e네이티브 코루틴(native coroutine)\u003c/strong\u003e 이라는 단어를 사용합니다. 제너레이터 구문에 기반한 코루틴을 지칭할 필요가 있을 때는 \u003cstrong\u003e제너레이터 기반 코루틴(generator-based coroutine)\u003c/strong\u003e 이 사용됩니다. 두 정의 모두 적용 가능한 맥락에서는 \u003cstrong\u003e코루틴(coroutine)\u003c/strong\u003e 이 사용됩니다.\u003c/p\u003e\n\u003ch4\u003e새로운 코루틴 선언 구문 (New Coroutine Declaration Syntax)\u003c/h4\u003e\n\u003cp\u003e네이티브 코루틴을 선언하는 데 다음의 새로운 구문이 사용됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def read_data(db):\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코루틴의 주요 특징은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003easync def\u003c/code\u003e 함수는 \u003ccode\u003eawait\u003c/code\u003e 표현식을 포함하지 않더라도 항상 코루틴입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easync\u003c/code\u003e 함수 내에 \u003ccode\u003eyield\u003c/code\u003e 또는 \u003ccode\u003eyield from\u003c/code\u003e 표현식이 있는 것은 \u003ccode\u003eSyntaxError\u003c/code\u003e입니다.\u003c/li\u003e\n\u003cli\u003e내부적으로 두 개의 새로운 코드 객체 플래그가 도입되었습니다:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCO_COROUTINE\u003c/code\u003e은 네이티브 코루틴(새 구문으로 정의됨)을 표시하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCO_ITERABLE_COROUTINE\u003c/code\u003e은 제너레이터 기반 코루틴을 네이티브 코루틴과 호환되게 만드는 데 사용됩니다(\u003ccode\u003etypes.coroutine()\u003c/code\u003e 함수에 의해 설정됨).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e일반 제너레이터는 호출될 때 제너레이터 객체를 반환하는 것과 유사하게, 코루틴은 코루틴 객체를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStopIteration\u003c/code\u003e 예외는 코루틴 밖으로 전파되지 않으며, \u003ccode\u003eRuntimeError\u003c/code\u003e로 대체됩니다. 일반 제너레이터의 경우 이러한 동작은 \u003ccode\u003e__future__\u003c/code\u003e import를 필요로 합니다 (PEP 479 참조).\u003c/li\u003e\n\u003cli\u003e네이티브 코루틴이 가비지 컬렉션될 때, 한 번도 \u003ccode\u003eawait\u003c/code\u003e되지 않았다면 \u003ccode\u003eRuntimeWarning\u003c/code\u003e이 발생합니다 (디버깅 기능 참조).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003ccode\u003etypes.coroutine()\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003etypes\u003c/code\u003e 모듈에 새로운 함수 \u003ccode\u003ecoroutine(fn)\u003c/code\u003e이 추가됩니다. 이 함수는 \u003ccode\u003easyncio\u003c/code\u003e의 기존 제너레이터 기반 코루틴과 이 PEP에 의해 도입된 네이티브 코루틴 간의 상호 운용성을 허용합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@types.coroutine\ndef process_data(db):\n    data = yield from read_data(db)\n    # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 제너레이터 함수의 코드 객체에 \u003ccode\u003eCO_ITERABLE_COROUTINE\u003c/code\u003e 플래그를 적용하여 코루틴 객체를 반환하도록 만듭니다. \u003ccode\u003efn\u003c/code\u003e이 제너레이터 함수가 아닌 경우, 래핑됩니다. 제너레이터를 반환하는 경우, awaitable 프록시 객체로 래핑됩니다 (awaitable 객체 정의 참조). \u003ccode\u003eCO_COROUTINE\u003c/code\u003e 플래그는 \u003ccode\u003etypes.coroutine()\u003c/code\u003e에 의해 적용되지 않아 새로운 구문으로 정의된 네이티브 코루틴과 제너레이터 기반 코루틴을 분리할 수 있도록 합니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eawait\u003c/code\u003e 표현식 (Await Expression)\u003c/h4\u003e\n\u003cp\u003e코루틴 실행 결과를 얻기 위해 다음의 새로운 \u003ccode\u003eawait\u003c/code\u003e 표현식이 사용됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def read_data(db):\n    data = await db.fetch('SELECT ...')\n    # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e는 \u003ccode\u003eyield from\u003c/code\u003e과 유사하게 \u003ccode\u003edb.fetch\u003c/code\u003e awaitable이 완료되고 결과 \u003ccode\u003edata\u003c/code\u003e를 반환할 때까지 \u003ccode\u003eread_data\u003c/code\u003e 코루틴의 실행을 일시 중단합니다. 이는 인수의 유효성을 검사하는 추가 단계와 함께 \u003ccode\u003eyield from\u003c/code\u003e 구현을 사용합니다. \u003ccode\u003eawait\u003c/code\u003e는 다음 중 하나인 awaitable만 허용합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e네이티브 코루틴 함수에서 반환된 네이티브 코루틴 객체.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etypes.coroutine()\u003c/code\u003e으로 데코레이트된 함수에서 반환된 제너레이터 기반 코루틴 객체.\u003c/li\u003e\n\u003cli\u003e이터레이터(iterator)를 반환하는 \u003ccode\u003e__await__\u003c/code\u003e 메서드를 가진 객체.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eyield from\u003c/code\u003e 호출 체인은 항상 \u003ccode\u003eyield\u003c/code\u003e로 끝납니다. 이는 Futures가 구현되는 근본적인 메커니즘입니다. 내부적으로 코루틴은 특별한 종류의 제너레이터이므로, 모든 \u003ccode\u003eawait\u003c/code\u003e는 \u003ccode\u003eawait\u003c/code\u003e 호출 체인의 어딘가에서 \u003ccode\u003eyield\u003c/code\u003e에 의해 일시 중단됩니다 (자세한 설명은 PEP 3156 참조).\u003c/p\u003e\n\u003cp\u003e코루틴에 이 동작을 활성화하기 위해 \u003ccode\u003e__await__\u003c/code\u003e라는 새로운 매직 메서드가 추가됩니다. 예를 들어 \u003ccode\u003easyncio\u003c/code\u003e에서 \u003ccode\u003eFuture\u003c/code\u003e 객체를 \u003ccode\u003eawait\u003c/code\u003e 문에서 사용할 수 있도록 하려면 \u003ccode\u003easyncio.Future\u003c/code\u003e 클래스에 \u003ccode\u003e__await__ = __iter__\u003c/code\u003e 줄을 추가하는 것만으로 충분합니다. 이 PEP의 나머지 부분에서 \u003ccode\u003e__await__\u003c/code\u003e 메서드를 가진 객체를 \u003ccode\u003eFuture-like objects\u003c/code\u003e라고 부릅니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__await__\u003c/code\u003e가 이터레이터가 아닌 다른 것을 반환하면 \u003ccode\u003eTypeError\u003c/code\u003e가 발생합니다. CPython C API로 정의된 객체는 \u003ccode\u003e__await__\u003c/code\u003e 메서드와 유사하게 이터레이터를 반환하는 \u003ccode\u003etp_as_async.am_await\u003c/code\u003e 함수를 가질 수 있습니다. \u003ccode\u003easync def\u003c/code\u003e 함수 외부에서 \u003ccode\u003eawait\u003c/code\u003e를 사용하는 것은 \u003ccode\u003eSyntaxError\u003c/code\u003e입니다 ( \u003ccode\u003edef\u003c/code\u003e 함수 외부에서 \u003ccode\u003eyield\u003c/code\u003e를 사용하는 것이 \u003ccode\u003eSyntaxError\u003c/code\u003e인 것과 같습니다). awaitable 객체가 아닌 다른 것을 \u003ccode\u003eawait\u003c/code\u003e 표현식에 전달하는 것은 \u003ccode\u003eTypeError\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e업데이트된 연산자 우선순위 표 (Updated operator precedence table)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e 키워드는 다음과 같이 정의됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epower ::= await [\" **\" u_expr]\nawait ::= [\"await\"] primary\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \"primary\"는 언어의 가장 강력하게 바인딩된 연산을 나타냅니다. \u003ccode\u003eawait\u003c/code\u003e 연산자의 우선순위는 \u003ccode\u003e[]\u003c/code\u003e, \u003ccode\u003e()\u003c/code\u003e, \u003ccode\u003e.\u003c/code\u003e보다 낮지만 \u003ccode\u003e** \u003c/code\u003e 연산자보다 높도록 결정되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eawait\u003c/code\u003e 표현식의 예시 (Examples of “await” expressions)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e유효한 구문 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif await fut: pass\npair = await fut, 'spam'\nwith await fut, open(): pass\nawait foo()['spam'].baz()()\nreturn await coro()\nres = await coro() ** 2\nfunc(a1=await coro(), a2=0)\nawait foo() + await bar()\n-await foo()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e유효하지 않은 구문 예시 (수정 제안과 함께):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# Expression           Should be written as\n# await await coro()   await (await coro())\n# await -coro()        await (-coro())\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e비동기 컨텍스트 관리자 및 \u003ccode\u003easync with\u003c/code\u003e (Asynchronous Context Managers and “async with”)\u003c/h4\u003e\n\u003cp\u003e비동기 컨텍스트 관리자는 \u003ccode\u003eenter\u003c/code\u003e 및 \u003ccode\u003eexit\u003c/code\u003e 메서드에서 실행을 일시 중단할 수 있는 컨텍스트 관리자입니다. 이를 가능하게 하기 위해 비동기 컨텍스트 관리자를 위한 새로운 프로토콜이 제안됩니다. \u003ccode\u003e__aenter__\u003c/code\u003e 및 \u003ccode\u003e__aexit__\u003c/code\u003e라는 두 가지 새로운 매직 메서드가 추가됩니다. 둘 다 awaitable을 반환해야 합니다.\u003c/p\u003e\n\u003cp\u003e비동기 컨텍스트 관리자의 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass AsyncContextManager:\n    async def __aenter__(self):\n        await log('entering context')\n    async def __aexit__(self, exc_type, exc, tb):\n        await log('exiting context')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e** 새 구문 (New Syntax)**\u003c/p\u003e\n\u003cp\u003e비동기 컨텍스트 관리자를 위한 새로운 문장이 제안됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync with EXPR as VAR:\n    BLOCK\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 의미론적으로 다음과 동일합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003emgr = (EXPR)\naexit = type(mgr).__aexit__\naenter = type(mgr).__aenter__\nVAR = await aenter(mgr)\ntry:\n    BLOCK\nexcept:\n    if not await aexit(mgr, *sys.exc_info()):\n        raise\nelse:\n    await aexit(mgr, None, None, None)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e일반 \u003ccode\u003ewith\u003c/code\u003e 문과 마찬가지로, 단일 \u003ccode\u003easync with\u003c/code\u003e 문에서 여러 컨텍스트 관리자를 지정할 수 있습니다. \u003ccode\u003e__aenter__\u003c/code\u003e 및 \u003ccode\u003e__aexit__\u003c/code\u003e 메서드가 없는 일반 컨텍스트 관리자를 \u003ccode\u003easync with\u003c/code\u003e에 전달하는 것은 오류입니다. \u003ccode\u003easync def\u003c/code\u003e 함수 외부에서 \u003ccode\u003easync with\u003c/code\u003e를 사용하는 것은 \u003ccode\u003eSyntaxError\u003c/code\u003e입니다.\u003c/p\u003e\n\u003ch4\u003e비동기 이터레이터 및 \u003ccode\u003easync for\u003c/code\u003e (Asynchronous Iterators and “async for”)\u003c/h4\u003e\n\u003cp\u003e비동기 이터러블(asynchronous iterable)은 \u003ccode\u003eiter\u003c/code\u003e 구현에서 비동기 코드를 호출할 수 있으며, 비동기 이터레이터는 \u003ccode\u003enext\u003c/code\u003e 메서드에서 비동기 코드를 호출할 수 있습니다. 비동기 이터레이션을 지원하려면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e객체는 비동기 이터레이터 객체를 반환하는 \u003ccode\u003e__aiter__\u003c/code\u003e 메서드를 구현해야 합니다 (또는 CPython C API로 정의된 경우 \u003ccode\u003etp_as_async.am_aiter\u003c/code\u003e 슬롯).\u003c/li\u003e\n\u003cli\u003e비동기 이터레이터 객체는 awaitable을 반환하는 \u003ccode\u003e__anext__\u003c/code\u003e 메서드를 구현해야 합니다 (또는 CPython C API로 정의된 경우 \u003ccode\u003etp_as_async.am_anext\u003c/code\u003e 슬롯).\u003c/li\u003e\n\u003cli\u003e이터레이션을 중지하려면 \u003ccode\u003e__anext__\u003c/code\u003e는 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e 예외를 발생시켜야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e비동기 이터러블의 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass AsyncIterable:\n    def __aiter__(self):\n        return self\n    async def __anext__(self):\n        data = await self.fetch_data()\n        if data:\n            return data\n        else:\n            raise StopAsyncIteration\n    async def fetch_data(self):\n        # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e새 구문 (New Syntax)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e비동기 이터레이터를 통해 반복하기 위한 새로운 문장이 제안됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync for TARGET in ITER:\n    BLOCK\nelse:\n    BLOCK2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 의미론적으로 다음과 동일합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eiter = (ITER)\niter = type(iter).__aiter__(iter)\nrunning = True\nwhile running:\n    try:\n        TARGET = await type(iter).__anext__(iter)\n    except StopAsyncIteration:\n        running = False\n    else:\n        BLOCK\nelse:\n    BLOCK2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e__aiter__\u003c/code\u003e 메서드가 없는 일반 이터러블을 \u003ccode\u003easync for\u003c/code\u003e에 전달하는 것은 \u003ccode\u003eTypeError\u003c/code\u003e입니다. \u003ccode\u003easync def\u003c/code\u003e 함수 외부에서 \u003ccode\u003easync for\u003c/code\u003e를 사용하는 것은 \u003ccode\u003eSyntaxError\u003c/code\u003e입니다. 일반 \u003ccode\u003efor\u003c/code\u003e 문과 마찬가지로 \u003ccode\u003easync for\u003c/code\u003e는 선택적 \u003ccode\u003eelse\u003c/code\u003e 절을 가집니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e왜 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e인가? (Why StopAsyncIteration?)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e코루틴은 내부적으로 여전히 제너레이터에 기반합니다. PEP 479 이전에는 \u003ccode\u003edef g1(): yield from fut; return 'spam'\u003c/code\u003e과 \u003ccode\u003edef g2(): yield from fut; raise StopIteration('spam')\u003c/code\u003e 사이에 근본적인 차이가 없었습니다. PEP 479가 승인되어 코루틴에 기본적으로 활성화되었기 때문에, \u003ccode\u003easync def a1(): await fut; raise StopIteration('spam')\u003c/code\u003e과 같은 예시에서는 \u003ccode\u003eStopIteration\u003c/code\u003e이 \u003ccode\u003eRuntimeError\u003c/code\u003e로 래핑됩니다.\u003c/p\u003e\n\u003cp\u003e외부 코드에 이터레이션이 종료되었음을 알리는 유일한 방법은 \u003ccode\u003eStopIteration\u003c/code\u003e 이외의 다른 예외를 발생시키는 것입니다. 따라서 새로운 내장 예외 클래스 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e이 추가되었습니다. 더욱이, PEP 479의 의미론에 따라 코루틴에서 발생한 모든 \u003ccode\u003eStopIteration\u003c/code\u003e 예외는 \u003ccode\u003eRuntimeError\u003c/code\u003e로 래핑됩니다.\u003c/p\u003e\n\u003ch4\u003e코루틴 객체 (Coroutine objects)\u003c/h4\u003e\n\u003cp\u003e이 섹션은 \u003ccode\u003eCO_COROUTINE\u003c/code\u003e 플래그가 있는 네이티브 코루틴, 즉 새로운 \u003ccode\u003easync def\u003c/code\u003e 구문으로 정의된 코루틴에만 적용됩니다. \u003ccode\u003easyncio\u003c/code\u003e의 기존 \u003cstrong\u003e제너레이터 기반 코루틴\u003c/strong\u003e 의 동작은 변경되지 않습니다. 코루틴과 제너레이터가 별개의 개념으로 다루어지도록 많은 노력이 기울여졌습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e네이티브 코루틴 객체는 \u003ccode\u003e__iter__\u003c/code\u003e 및 \u003ccode\u003e__next__\u003c/code\u003e 메서드를 구현하지 않습니다. 따라서 \u003ccode\u003eiter()\u003c/code\u003e, \u003ccode\u003elist()\u003c/code\u003e, \u003ccode\u003etuple()\u003c/code\u003e 및 다른 내장 함수를 통해 반복하거나 전달할 수 없습니다. 또한 \u003ccode\u003efor..in\u003c/code\u003e 루프에서 사용할 수 없습니다.\u003c/li\u003e\n\u003cli\u003e네이티브 코루틴 객체에 \u003ccode\u003e__iter__\u003c/code\u003e 또는 \u003ccode\u003e__next__\u003c/code\u003e를 사용하려고 시도하면 \u003ccode\u003eTypeError\u003c/code\u003e가 발생합니다.\u003c/li\u003e\n\u003cli\u003e일반 제너레이터는 네이티브 코루틴에서 \u003ccode\u003eyield from\u003c/code\u003e을 사용할 수 없습니다. 그렇게 하면 \u003ccode\u003eTypeError\u003c/code\u003e가 발생합니다.\u003c/li\u003e\n\u003cli\u003e제너레이터 기반 코루틴(\u003ccode\u003easyncio\u003c/code\u003e 코드는 \u003ccode\u003e@asyncio.coroutine\u003c/code\u003e으로 데코레이트되어야 함)은 네이티브 코루틴 객체에서 \u003ccode\u003eyield from\u003c/code\u003e을 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einspect.isgenerator()\u003c/code\u003e 및 \u003ccode\u003einspect.isgeneratorfunction()\u003c/code\u003e은 네이티브 코루틴 객체 및 네이티브 코루틴 함수에 대해 \u003ccode\u003eFalse\u003c/code\u003e를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e코루틴 객체 메서드 (Coroutine object methods)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e코루틴은 내부적으로 제너레이터에 기반하므로 구현을 공유합니다. 제너레이터 객체와 마찬가지로 코루틴은 \u003ccode\u003ethrow()\u003c/code\u003e, \u003ccode\u003esend()\u003c/code\u003e, \u003ccode\u003eclose()\u003c/code\u003e 메서드를 가집니다. \u003ccode\u003eStopIteration\u003c/code\u003e 및 \u003ccode\u003eGeneratorExit\u003c/code\u003e는 코루틴에 대해 동일한 역할을 수행합니다 (비록 PEP 479가 코루틴에 기본적으로 활성화되어 있지만). \u003ccode\u003ethrow()\u003c/code\u003e, \u003ccode\u003esend()\u003c/code\u003e 메서드는 \u003ccode\u003eFuture-like objects\u003c/code\u003e에 값을 푸시하고 오류를 발생시키는 데 사용됩니다.\u003c/p\u003e\n\u003ch4\u003e디버깅 기능 (Debugging Features)\u003c/h4\u003e\n\u003cp\u003e초보적인 실수는 코루틴에서 \u003ccode\u003eyield from\u003c/code\u003e을 사용하는 것을 잊는 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@asyncio.coroutine\ndef useful():\n    asyncio.sleep(1) # 'yield from' 없이는 아무것도 하지 않습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 종류의 실수를 디버깅하기 위해 \u003ccode\u003easyncio\u003c/code\u003e에는 특별한 디버그 모드가 있습니다. 이 모드에서 \u003ccode\u003e@coroutine\u003c/code\u003e 데코레이터는 모든 함수를 소멸자(destructor)로 경고를 기록하는 특수 객체로 래핑합니다. 래핑된 제너레이터가 가비지 컬렉션될 때마다, 데코레이터 함수가 정확히 어디에 정의되었는지, 컬렉션된 위치의 스택 트레이스(stack trace) 등에 대한 정보를 담은 자세한 로깅 메시지가 생성됩니다. 래퍼(wrapper) 객체는 또한 제너레이터에 대한 자세한 정보와 함께 편리한 \u003ccode\u003e__repr__\u003c/code\u003e 함수를 제공합니다.\u003c/p\u003e\n\u003cp\u003e이러한 디버그 기능을 활성화하는 방법이 문제입니다. 디버그 기능은 프로덕션 모드에서는 아무런 작동을 하지 않아야 하므로, \u003ccode\u003e@coroutine\u003c/code\u003e 데코레이터는 OS 환경 변수 \u003ccode\u003ePYTHONASYNCIODEBUG\u003c/code\u003e를 기반으로 래핑 여부를 결정합니다. 이 방식으로 \u003ccode\u003easyncio\u003c/code\u003e 자체 함수가 계측된 \u003ccode\u003easyncio\u003c/code\u003e 프로그램을 실행할 수 있습니다. \u003ccode\u003eEventLoop.set_debug\u003c/code\u003e는 다른 디버그 기능이며, \u003ccode\u003e@coroutine\u003c/code\u003e 데코레이터의 동작에는 영향을 미치지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 제안을 통해 코루틴은 제너레이터와 구별되는 네이티브 개념이 됩니다. 한 번도 \u003ccode\u003eawait\u003c/code\u003e되지 않은 코루틴에 대해 \u003ccode\u003eRuntimeWarning\u003c/code\u003e이 발생하는 것 외에도, \u003ccode\u003esys\u003c/code\u003e 모듈에 두 개의 새로운 함수를 추가할 것이 제안됩니다: \u003ccode\u003eset_coroutine_wrapper\u003c/code\u003e 및 \u003ccode\u003eget_coroutine_wrapper\u003c/code\u003e. 이는 \u003ccode\u003easyncio\u003c/code\u003e 및 다른 프레임워크(예: 코루틴이 정확히 어디에서 생성되었는지 표시하거나, 가비지 컬렉션된 위치의 더 자세한 스택 트레이스 표시)에서 고급 디버깅 기능을 활성화하기 위함입니다.\u003c/p\u003e\n\u003ch4\u003e새로운 표준 라이브러리 함수 (New Standard Library Functions)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etypes.coroutine(gen)\u003c/code\u003e: 자세한 내용은 \u003ccode\u003etypes.coroutine()\u003c/code\u003e 섹션 참조.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einspect.iscoroutine(obj)\u003c/code\u003e: \u003ccode\u003eobj\u003c/code\u003e가 네이티브 코루틴 객체이면 \u003ccode\u003eTrue\u003c/code\u003e를 반환.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einspect.iscoroutinefunction(obj)\u003c/code\u003e: \u003ccode\u003eobj\u003c/code\u003e가 네이티브 코루틴 함수이면 \u003ccode\u003eTrue\u003c/code\u003e를 반환.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einspect.isawaitable(obj)\u003c/code\u003e: \u003ccode\u003eobj\u003c/code\u003e가 awaitable이면 \u003ccode\u003eTrue\u003c/code\u003e를 반환.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einspect.getcoroutinestate(coro)\u003c/code\u003e: 네이티브 코루틴 객체의 현재 상태를 반환 (\u003ccode\u003einspect.getfgeneratorstate(gen)\u003c/code\u003e를 미러링).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einspect.getcoroutinelocals(coro)\u003c/code\u003e: 네이티브 코루틴 객체의 로컬 변수와 해당 값의 매핑을 반환 (\u003ccode\u003einspect.getgeneratorlocals(gen)\u003c/code\u003e를 미러링).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.set_coroutine_wrapper(wrapper)\u003c/code\u003e: 네이티브 코루틴 객체 생성을 가로챌 수 있도록 합니다. \u003ccode\u003ewrapper\u003c/code\u003e는 하나의 인자(코루틴 객체)를 받는 호출 가능 객체이거나 \u003ccode\u003eNone\u003c/code\u003e이어야 합니다. \u003ccode\u003eNone\u003c/code\u003e은 래퍼를 재설정합니다. 두 번 호출되면 새 래퍼가 이전 래퍼를 대체합니다. 이 함수는 스레드별(thread-specific)입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.get_coroutine_wrapper()\u003c/code\u003e: 현재 래퍼 객체를 반환합니다. 래퍼가 설정되지 않은 경우 \u003ccode\u003eNone\u003c/code\u003e을 반환합니다. 이 함수는 스레드별입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e새로운 추상 기본 클래스 (New Abstract Base Classes)\u003c/h4\u003e\n\u003cp\u003e기존 프레임워크(예: Tornado) 및 컴파일러(예: Cython)와의 더 나은 통합을 허용하기 위해 두 개의 새로운 추상 기본 클래스(ABC)가 추가됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecollections.abc.Awaitable\u003c/code\u003e: \u003ccode\u003e__await__\u003c/code\u003e 메서드를 구현하는 \u003ccode\u003eFuture-like classes\u003c/code\u003e를 위한 ABC.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecollections.abc.Coroutine\u003c/code\u003e: \u003ccode\u003esend(value)\u003c/code\u003e, \u003ccode\u003ethrow(type, exc, tb)\u003c/code\u003e, \u003ccode\u003eclose()\u003c/code\u003e, \u003ccode\u003e__await__()\u003c/code\u003e 메서드를 구현하는 코루틴 객체를 위한 ABC.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eCO_ITERABLE_COROUTINE\u003c/code\u003e 플래그가 있는 제너레이터 기반 코루틴은 \u003ccode\u003e__await__\u003c/code\u003e 메서드를 구현하지 않으므로, \u003ccode\u003ecollections.abc.Coroutine\u003c/code\u003e 및 \u003ccode\u003ecollections.abc.Awaitable\u003c/code\u003e ABC의 인스턴스가 아닙니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@types.coroutine\ndef gencoro():\n    yield\nassert not isinstance(gencoro(), collections.abc.Coroutine)\n# 하지만:\nassert inspect.isawaitable(gencoro())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e객체가 비동기 이터레이션을 지원하는지 쉽게 테스트할 수 있도록 두 개의 ABC가 더 추가됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecollections.abc.AsyncIterable\u003c/code\u003e: \u003ccode\u003e__aiter__\u003c/code\u003e 메서드를 테스트합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecollections.abc.AsyncIterator\u003c/code\u003e: \u003ccode\u003e__aiter__\u003c/code\u003e 및 \u003ccode\u003e__anext__\u003c/code\u003e 메서드를 테스트합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e용어 설명 (Glossary)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNative coroutine function (네이티브 코루틴 함수):\u003c/strong\u003e \u003ccode\u003easync def\u003c/code\u003e로 선언된 코루틴 함수. \u003ccode\u003eawait\u003c/code\u003e 및 \u003ccode\u003ereturn value\u003c/code\u003e를 사용합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNative coroutine (네이티브 코루틴):\u003c/strong\u003e 네이티브 코루틴 함수에서 반환됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGenerator-based coroutine function (제너레이터 기반 코루틴 함수):\u003c/strong\u003e 제너레이터 구문에 기반한 코루틴. \u003ccode\u003e@asyncio.coroutine\u003c/code\u003e으로 데코레이트된 함수가 가장 일반적인 예시입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGenerator-based coroutine (제너레이터 기반 코루틴):\u003c/strong\u003e 제너레이터 기반 코루틴 함수에서 반환됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCoroutine (코루틴):\u003c/strong\u003e 네이티브 코루틴 또는 제너레이터 기반 코루틴.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCoroutine object (코루틴 객체):\u003c/strong\u003e 네이티브 코루틴 객체 또는 제너레이터 기반 코루틴 객체.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFuture-like object (퓨처 유사 객체):\u003c/strong\u003e \u003ccode\u003e__await__\u003c/code\u003e 메서드를 가진 객체, 또는 \u003ccode\u003etp_as_async-\u003eam_await\u003c/code\u003e 함수를 가진 C 객체로 이터레이터를 반환합니다. 코루틴의 \u003ccode\u003eawait\u003c/code\u003e 표현식에 의해 소비될 수 있습니다. 퓨처 유사 객체를 기다리는 코루틴은 퓨처 유사 객체의 \u003ccode\u003e__await__\u003c/code\u003e가 완료되고 결과를 반환할 때까지 일시 중단됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAwaitable (어웨이터블):\u003c/strong\u003e 퓨처 유사 객체 또는 코루틴 객체.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAsynchronous context manager (비동기 컨텍스트 관리자):\u003c/strong\u003e \u003ccode\u003e__aenter__\u003c/code\u003e 및 \u003ccode\u003e__aexit__\u003c/code\u003e 메서드를 가지며 \u003ccode\u003easync with\u003c/code\u003e와 함께 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAsynchronous iterable (비동기 이터러블):\u003c/strong\u003e 비동기 이터레이터 객체를 반환해야 하는 \u003ccode\u003e__aiter__\u003c/code\u003e 메서드를 가진 객체. \u003ccode\u003easync for\u003c/code\u003e와 함께 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAsynchronous iterator (비동기 이터레이터):\u003c/strong\u003e \u003ccode\u003e__anext__\u003c/code\u003e 메서드를 가집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e전환 계획 (Transition Plan)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003easync\u003c/code\u003e 및 \u003ccode\u003eawait\u003c/code\u003e 키워드와의 하위 호환성 문제를 피하기 위해 \u003ccode\u003etokenizer.c\u003c/code\u003e를 다음과 같이 수정하기로 결정했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003easync def NAME\u003c/code\u003e 토큰 조합을 인식합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easync def\u003c/code\u003e 블록을 토큰화하는 동안, \u003ccode\u003e'async'\u003c/code\u003e \u003ccode\u003eNAME\u003c/code\u003e 토큰을 \u003ccode\u003eASYNC\u003c/code\u003e로, \u003ccode\u003e'await'\u003c/code\u003e \u003ccode\u003eNAME\u003c/code\u003e 토큰을 \u003ccode\u003eAWAIT\u003c/code\u003e로 대체합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edef\u003c/code\u003e 블록을 토큰화하는 동안, \u003ccode\u003e'async'\u003c/code\u003e 및 \u003ccode\u003e'await'\u003c/code\u003e \u003ccode\u003eNAME\u003c/code\u003e 토큰을 그대로 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 접근 방식은 새로운 구문 기능(모두 \u003ccode\u003easync\u003c/code\u003e 함수에서만 사용 가능)과 기존 코드의 원활한 조합을 허용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Spam:\n    async = 42\n    async def ham():\n        print(getattr(Spam, 'async')) # 코루틴이 실행되어 '42'를 출력합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e하위 호환성 (Backwards Compatibility)\u003c/h4\u003e\n\u003cp\u003e이 제안은 100% 하위 호환성을 유지합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003easyncio\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003easyncio\u003c/code\u003e 모듈은 코루틴 및 새로운 문과 함께 작동하도록 조정되고 테스트되었습니다. 하위 호환성은 100% 유지됩니다. 즉, 모든 기존 코드는 그대로 작동합니다.\u003c/p\u003e\n\u003cp\u003e필요한 변경 사항은 주로 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e@asyncio.coroutine\u003c/code\u003e 데코레이터를 새로운 \u003ccode\u003etypes.coroutine()\u003c/code\u003e 함수를 사용하도록 수정합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easyncio.Future\u003c/code\u003e 클래스에 \u003ccode\u003e__await__ = __iter__\u003c/code\u003e 줄을 추가합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easync()\u003c/code\u003e 함수의 별칭으로 \u003ccode\u003eensure_future()\u003c/code\u003e를 추가합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easync()\u003c/code\u003e 함수를 Deprecate합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003easyncio 마이그레이션 전략 (asyncio migration strategy)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e일반 제너레이터는 네이티브 코루틴 객체에서 \u003ccode\u003eyield from\u003c/code\u003e을 사용할 수 없으므로(자세한 내용은 제너레이터와의 차이점 섹션 참조), 새로운 구문을 사용하기 전에 모든 제너레이터 기반 코루틴이 \u003ccode\u003e@asyncio.coroutine\u003c/code\u003e으로 데코레이트되었는지 확인하는 것이 좋습니다.\u003c/p\u003e\n\u003ch4\u003e문법 업데이트 (Grammar Updates)\u003c/h4\u003e\n\u003cp\u003e문법 변경은 상당히 미미합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edecorated: decorators (classdef | funcdef | async_funcdef)\nasync_funcdef: ASYNC funcdef\ncompound_stmt: (if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt)\nasync_stmt: ASYNC (funcdef | with_stmt | for_stmt)\npower: atom_expr ['**' factor]\natom_expr: [AWAIT] atom trailer*\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e폐지 계획 (Deprecation Plans)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003easync\u003c/code\u003e 및 \u003ccode\u003eawait\u003c/code\u003e 이름은 CPython 3.5 및 3.6에서 소프트하게 폐지됩니다. 3.7에서는 이들을 적절한 키워드로 전환할 것입니다. 3.7 이전에 \u003ccode\u003easync\u003c/code\u003e 및 \u003ccode\u003eawait\u003c/code\u003e를 적절한 키워드로 만들면 사람들이 코드를 Python 3으로 포팅하기 더 어려워질 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e설계 고려 사항 (Design Considerations)\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e왜 \u003ccode\u003easync\u003c/code\u003e와 \u003ccode\u003eawait\u003c/code\u003e 키워드인가 (Why “async” and “await” keywords)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003easync/await\u003c/code\u003e는 프로그래밍 언어에서 새로운 개념이 아닙니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC#은 오래 전부터 이 기능을 가지고 있습니다.\u003c/li\u003e\n\u003cli\u003eECMAScript 7에 \u003ccode\u003easync/await\u003c/code\u003e를 추가하려는 제안이 있습니다.\u003c/li\u003e\n\u003cli\u003eFacebook의 Hack/HHVM.\u003c/li\u003e\n\u003cli\u003eGoogle의 Dart 언어.\u003c/li\u003e\n\u003cli\u003eScala.\u003c/li\u003e\n\u003cli\u003eC++에 \u003ccode\u003easync/await\u003c/code\u003e를 추가하려는 제안이 있습니다.\u003c/li\u003e\n\u003cli\u003e그리고 다른 많은 덜 인기 있는 언어들에도 존재합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 일부 사용자들이 이미 \u003ccode\u003easync/await\u003c/code\u003e 경험이 있고, 한 프로젝트에서 여러 언어(예: Python과 ECMAScript 7)를 함께 사용하는 것을 더 쉽게 만들기 때문에 큰 이점입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e왜 \u003ccode\u003easync\u003c/code\u003e 키워드가 중요한가 (Importance of “async” keyword)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e 표현식만 구현하고 최소한 하나의 \u003ccode\u003eawait\u003c/code\u003e를 가진 모든 함수를 코루틴으로 처리하는 것도 가능하지만, 이 접근 방식은 API 설계, 코드 리팩토링 및 장기적인 지원을 더 어렵게 만듭니다.\u003c/p\u003e\n\u003cp\u003ePython에 \u003ccode\u003eawait\u003c/code\u003e 키워드만 있다고 가정해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef useful():\n    # ...\n    await log(...)\n    # ...\n\ndef important():\n    await useful()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 \u003ccode\u003euseful()\u003c/code\u003e 함수가 리팩토링되어 누군가 그 안의 모든 \u003ccode\u003eawait\u003c/code\u003e 표현식을 제거한다면, 그것은 일반 Python 함수가 될 것이고, \u003ccode\u003eimportant()\u003c/code\u003e를 포함하여 그 함수에 의존하는 모든 코드가 망가질 것입니다. 이 문제를 완화하려면 \u003ccode\u003e@asyncio.coroutine\u003c/code\u003e과 유사한 데코레이터를 도입해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e왜 \u003ccode\u003easync def\u003c/code\u003e인가 (Why “async def”)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e일부 사람들에게는 \u003ccode\u003easync name(): pass\u003c/code\u003e와 같은 간단한 구문이 \u003ccode\u003easync def name(): pass\u003c/code\u003e보다 더 매력적으로 보일 수 있습니다. 분명히 타이핑하기 더 쉽습니다. 그러나 다른 한편으로는 \u003ccode\u003easync def\u003c/code\u003e, \u003ccode\u003easync with\u003c/code\u003e, \u003ccode\u003easync for\u003c/code\u003e 사이의 대칭을 깨뜨립니다. 여기서 \u003ccode\u003easync\u003c/code\u003e는 문장이 비동기임을 나타내는 수식어(modifier)입니다. 또한 기존 문법과 더 일관성이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e왜 매직 메서드는 \"a\"로 시작하는가 (Why magic methods start with “a”)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e새로운 비동기 매직 메서드 \u003ccode\u003e__aiter__\u003c/code\u003e, \u003ccode\u003e__anext__\u003c/code\u003e, \u003ccode\u003e__aenter__\u003c/code\u003e, \u003ccode\u003e__aexit__\u003c/code\u003e는 모두 동일한 접두사 \"a\"로 시작합니다. 대안 제안은 \"async\" 접두사를 사용하여 \u003ccode\u003e__anext__\u003c/code\u003e를 \u003ccode\u003e__async_next__\u003c/code\u003e로 만드는 것이었습니다. 그러나 새로운 매직 메서드를 \u003ccode\u003e__radd__\u003c/code\u003e 및 \u003ccode\u003e__iadd__\u003c/code\u003e와 같은 기존 메서드와 일치시키기 위해 더 짧은 버전을 사용하기로 결정했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e왜 기존 매직 이름을 재사용하지 않는가 (Why not reuse existing magic names)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e새로운 비동기 이터레이터 및 컨텍스트 관리자에 대한 대안 아이디어는 선언에 \u003ccode\u003easync\u003c/code\u003e 키워드를 추가하여 기존 매직 메서드를 재사용하는 것이었습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass CM:\n    async def __enter__(self): # __aenter__ 대신\n        # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 접근 방식에는 다음과 같은 단점이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ewith\u003c/code\u003e 및 \u003ccode\u003easync with\u003c/code\u003e 문 모두에서 작동하는 객체를 생성할 수 없습니다.\u003c/li\u003e\n\u003cli\u003ePython \u0026#x3C;= 3.4에서는 \u003ccode\u003e__enter__\u003c/code\u003e 및/또는 \u003ccode\u003e__exit__\u003c/code\u003e에서 \u003ccode\u003eFuture-like objects\u003c/code\u003e를 반환하는 것을 금지하지 않으므로 하위 호환성을 깨뜨릴 수 있습니다.\u003c/li\u003e\n\u003cli\u003e이 제안의 주요 목적 중 하나는 네이티브 코루틴을 가능한 한 간단하고 오류 방지(foolproof)로 만드는 것이므로, 프로토콜을 명확하게 분리하는 것이 중요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e왜 기존 \u003ccode\u003efor\u003c/code\u003e 및 \u003ccode\u003ewith\u003c/code\u003e 문을 재사용하지 않는가 (Why not reuse existing “for” and “with” statements)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e기존 제너레이터 기반 코루틴과 이 제안의 비전은 사용자가 코드가 언제 일시 중단될 수 있는지 쉽게 파악할 수 있도록 하는 것입니다. 기존 \u003ccode\u003efor\u003c/code\u003e 및 \u003ccode\u003ewith\u003c/code\u003e 문이 비동기 이터레이터 및 컨텍스트 관리자를 인식하도록 만들면 필연적으로 암시적인 일시 중단 지점(suspend points)이 생성되어 코드를 추론하기 더 어려워질 것입니다.\u003c/p\u003e\n\u003ch3\u003e성능 (Performance)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e전반적인 영향 (Overall Impact)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e이 제안은 관찰 가능한 성능 영향을 도입하지 않습니다.\u003c/p\u003e\n\u003ch3\u003e구현 (Implementation)\u003c/h3\u003e\n\u003cp\u003ePEP 492는 2015년 5월 5일 Guido에 의해 승인되었습니다. 구현은 이슈 24017에서 추적되었으며, 2015년 5월 11일에 커밋되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e주요 변경 사항 및 새로운 프로토콜 목록 (List of high-level changes and new protocols)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e코루틴 정의를 위한 새 구문: \u003ccode\u003easync def\u003c/code\u003e 및 새 키워드 \u003ccode\u003eawait\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFuture-like objects\u003c/code\u003e를 위한 새 \u003ccode\u003e__await__\u003c/code\u003e 메서드, \u003ccode\u003ePyTypeObject\u003c/code\u003e의 새 \u003ccode\u003etp_as_async.am_await\u003c/code\u003e 슬롯.\u003c/li\u003e\n\u003cli\u003e비동기 컨텍스트 관리자를 위한 새 구문: \u003ccode\u003easync with\u003c/code\u003e 및 \u003ccode\u003e__aenter__\u003c/code\u003e, \u003ccode\u003e__aexit__\u003c/code\u003e 메서드와 관련된 프로토콜.\u003c/li\u003e\n\u003cli\u003e비동기 이터레이션을 위한 새 구문: \u003ccode\u003easync for\u003c/code\u003e 및 \u003ccode\u003e__aiter__\u003c/code\u003e, \u003ccode\u003e__anext__\u003c/code\u003e 메서드, 새 내장 예외 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e과 관련된 프로토콜.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyTypeObject\u003c/code\u003e의 새 \u003ccode\u003etp_as_async.am_aiter\u003c/code\u003e 및 \u003ccode\u003etp_as_async.am_anext\u003c/code\u003e 슬롯.\u003c/li\u003e\n\u003cli\u003e새로운 AST 노드: \u003ccode\u003eAsyncFunctionDef\u003c/code\u003e, \u003ccode\u003eAsyncFor\u003c/code\u003e, \u003ccode\u003eAsyncWith\u003c/code\u003e, \u003ccode\u003eAwait\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e새로운 함수: \u003ccode\u003esys.set_coroutine_wrapper(callback)\u003c/code\u003e, \u003ccode\u003esys.get_coroutine_wrapper()\u003c/code\u003e, \u003ccode\u003etypes.coroutine(gen)\u003c/code\u003e, \u003ccode\u003einspect.iscoroutinefunction(func)\u003c/code\u003e, \u003ccode\u003einspect.iscoroutine(obj)\u003c/code\u003e, \u003ccode\u003einspect.isawaitable(obj)\u003c/code\u003e, \u003ccode\u003einspect.getcoroutinestate(coro)\u003c/code\u003e, \u003ccode\u003einspect.getcoroutinelocals(coro)\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e코드 객체를 위한 새 \u003ccode\u003eCO_COROUTINE\u003c/code\u003e 및 \u003ccode\u003eCO_ITERABLE_COROUTINE\u003c/code\u003e 비트 플래그.\u003c/li\u003e\n\u003cli\u003e새로운 ABC: \u003ccode\u003ecollections.abc.Awaitable\u003c/code\u003e, \u003ccode\u003ecollections.abc.Coroutine\u003c/code\u003e, \u003ccode\u003ecollections.abc.AsyncIterable\u003c/code\u003e, \u003ccode\u003ecollections.abc.AsyncIterator\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eC API 변경: 새 \u003ccode\u003ePyCoro_Type\u003c/code\u003e (Python에 \u003ccode\u003etypes.CoroutineType\u003c/code\u003e으로 노출) 및 \u003ccode\u003ePyCoroObject\u003c/code\u003e. \u003ccode\u003ePyCoro_CheckExact(*o)\u003c/code\u003e로 \u003ccode\u003eo\u003c/code\u003e가 네이티브 코루틴인지 테스트.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 변경 사항 및 새로운 요소 목록이 짧지는 않지만, 대부분의 사용자가 이러한 기능을 직접 사용하지 않을 것이라는 점을 이해하는 것이 중요합니다. 이는 프레임워크와 라이브러리에서 사용되어 \u003ccode\u003easync def\u003c/code\u003e, \u003ccode\u003eawait\u003c/code\u003e, \u003ccode\u003easync for\u003c/code\u003e, \u003ccode\u003easync with\u003c/code\u003e 구문을 통해 사용자에게 편리하고 모호하지 않은 API를 제공하기 위한 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e작동 예시 (Working example)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e이 PEP에서 제안된 모든 개념은 구현되었으며 테스트할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport asyncio\n\nasync def echo_server():\n    print('Serving on localhost:8000')\n    await asyncio.start_server(handle_connection, 'localhost', 8000)\n\nasync def handle_connection(reader, writer):\n    print('New connection...')\n    while True:\n        data = await reader.read(8192)\n        if not data:\n            break\n        print('Sending {:.10}... back'.format(repr(data)))\n        writer.write(data)\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(echo_server())\ntry:\n    loop.run_forever()\nfinally:\n    loop.close()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2648,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 492 - Coroutines with async and await syntax\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:37:54+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/492/\",\"postId\":\"2025-09-26-pep-0492-coroutines-with-async-and-await-syntax\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/491/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Deferred] PEP 491 - The Wheel Binary Package Format 1.9\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 492 - Coroutines with async and await syntax\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/493/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 493 - HTTPS verification migration tools for Python 2.7\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>