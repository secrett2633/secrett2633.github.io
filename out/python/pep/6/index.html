<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Superseded] PEP 6 - Bug Fix Releases</h1><div class="page__meta"><time dateTime="2025-09-26 15:42:30+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0006/">PEP 6 - Bug Fix Releases</a></p>
<p><strong>상태:</strong> Superseded | <strong>유형:</strong> Process | <strong>작성일:</strong> 15-Mar-2001</p>
</blockquote>
<h2>PEP 6 – Bug Fix Releases (버그 수정 릴리스)</h2>
<p><strong>저자:</strong> Aahz , Anthony Baxter 
<strong>상태:</strong> Superseded (대체됨)
<strong>유형:</strong> Process (프로세스)
<strong>생성일:</strong> 2001년 3월 15일
<strong>이력:</strong> 2001년 3월 15일, 2001년 4월 18일, 2004년 8월 19일</p>
<hr>
<p><strong>참고:</strong> 이 PEP는 더 이상 사용되지 않습니다 (obsolete). 현재 릴리스 정책은 개발 가이드(devguide)에 문서화되어 있습니다. 릴리스 프로세스의 메커니즘에 대해서는 PEP 101을 참조하세요.</p>
<h3>요약 (Abstract)</h3>
<p>Python은 역사적으로 단일 개발 포크(fork)만을 가지고 있었으며, 릴리스는 새로운 기능 추가와 버그 수정이라는 두 가지 목적을 동시에 수행했습니다 (이러한 종류의 릴리스는 "주요 릴리스(major releases)"라고 불립니다). 이 PEP는 주로 버그 수정을 목적으로 구버전의 유지보수 또는 버그 수정 릴리스를 포크하는 방법을 설명합니다.</p>
<p>이 PEP는 버그 수정 릴리스의 존재를 보장하는 것이 <em>아니며</em>, 버그 수정 릴리스가 필요한 만큼의 Python 커뮤니티 구성원이 기꺼이 작업을 수행할 의향이 있을 경우에 따를 절차만을 명시합니다.</p>
<h3>동기 (Motivation)</h3>
<p>SourceForge로 이전하면서 Python 개발이 가속화되었습니다. 커뮤니티의 일부에서는 이러한 가속화가 지나치다고 느끼며, 개발 주기 후반에 너무 많은 기능이 추가되었을 때 버그 수정을 위해 새 버전으로 업그레이드하는 것을 불편하게 여기는 사람들이 많습니다.</p>
<p>이 문제에 대한 한 가지 해결책은 이전 주요 릴리스를 유지보수하여, 다음 주요 릴리스가 나올 때까지 버그 수정을 제공하는 것입니다. 이는 Python이 수백 또는 수천 대의 장비에 설치되어야 할 수도 있는 엔터프라이즈 개발에 Python을 더욱 매력적으로 만들 것입니다.</p>
<h3>금지 사항 (Prohibitions)</h3>
<p>버그 수정 릴리스는 다음 제한 사항을 준수해야 합니다.</p>
<ul>
<li><strong>구문 변경(syntax changes)이 없어야 합니다.</strong></li>
<li><strong>모든 <code>.pyc</code> 및 <code>.pyo</code> 파일은 작동해야 합니다.</strong> 주요 릴리스에서 포크된 모든 버그 수정 릴리스에서 (재생성 없이) 작동해야 합니다.</li>
<li><strong>pickle 변경(pickle changes)이 없어야 합니다.</strong></li>
<li><strong>호환되지 않는 C API 변경이 없어야 합니다.</strong> 모든 확장 모듈(extensions)은 주요 릴리스와 동일한 포크 내의 모든 버그 수정 릴리스에서 재컴파일 없이 계속 작동해야 합니다.</li>
</ul>
<p>이러한 금지 사항 중 하나라도 위반할 경우 BDFL(Benevolent Dictator For Life)의 선언(proclamation)이 필요하며 (릴리스 노트에 눈에 띄는 경고와 함께) 고지되어야 합니다.</p>
<h3>완전한 금지 사항은 아니지만 지켜야 할 사항 (Not-Quite-Prohibitions)</h3>
<p>가능한 경우, 버그 수정 릴리스는 또한 다음을 준수해야 합니다.</p>
<ul>
<li><strong>새로운 기능이 없어야 합니다.</strong> 버그 수정 릴리스의 목적은 버그를 수정하는 것이지, CVS <code>HEAD</code>의 최신 기능을 추가하는 것이 아닙니다.</li>
<li><strong>고통 없는 업그레이드가 되어야 합니다.</strong> 사용자는 2.x.y에서 2.x.(y+1)로의 업그레이드가 실행 중인 시스템을 망가뜨리지 않을 것이라고 확신할 수 있어야 합니다. 이는 버그를 수정하는 데 필요한 경우가 아니라면, 표준 라이브러리(standard library)가 동작을 변경하거나, 더 나아가 API를 변경해서는 안 된다는 것을 의미합니다.</li>
</ul>
<h3>금지 사항의 적용 가능성 (Applicability of Prohibitions)</h3>
<p>위의 금지 사항 및 "완전한 금지 사항은 아니지만 지켜야 할 사항"은 최종 릴리스에서 버그 수정 릴리스로 (예: 2.4에서 2.4.1로), 그리고 한 시리즈 내에서 한 버그 수정 릴리스에서 다음 버그 수정 릴리스로 (예: 2.4.1에서 2.4.2로) 모두 적용됩니다.</p>
<p>이 PEP에 나열된 금지 사항을 따르면, 커뮤니티는 버그 수정 릴리스가 고통 없고 안전한 업그레이드라는 점에 만족할 것입니다.</p>
<h3>버그 수정 릴리스 촉진 (Helping the Bug Fix Releases Happen)</h3>
<p>버그 수정 릴리스 프로세스를 돕는 몇 가지 지침은 다음과 같습니다.</p>
<ul>
<li><strong>버그 수정을 백포트(Backport)하세요.</strong> 버그를 수정했고 그것이 적절하다고 판단되면, 현재 버그 수정 릴리스를 위한 CVS 브랜치로 백포트하세요. 스스로 백포트할 의향이 없거나 할 수 없는 경우, 커밋 메시지에 'Bugfix candidate' 또는 'Backport candidate'와 같은 문구로 메모를 남기세요. 확실하지 않다면 질문하세요.</li>
<li><strong>현재 버그 수정 릴리스를 관리하는 사람에게 특정 수정 사항이 적절한지 문의하세요.</strong></li>
<li><strong>버그 수정 릴리스에서 특히 수정되기를 원하는 특정 버그가 있다면, 적극적으로 나서서 해결되도록 노력하세요.</strong> 버그 수정 릴리스가 예정된 시점의 48시간 전까지 기다렸다가 버그 수정을 포함해달라고 요청하지 마세요.</li>
</ul>
<h3>버전 번호 (Version Numbers)</h3>
<p>Python 2.0부터 모든 주요 릴리스는 <code>X.Y</code> 형식의 버전 번호를 가져야 합니다. 버그 수정 릴리스는 항상 <code>X.Y.Z</code> 형식이어야 합니다.</p>
<p>현재 개발 중인 주요 릴리스는 릴리스 <code>N</code>으로 지칭됩니다. 막 릴리스된 주요 버전은 <code>N-1</code>으로 지칭됩니다.</p>
<p>CVS에서 버그 수정 릴리스는 브랜치에서 이루어집니다. 2.x 릴리스의 경우 브랜치 이름은 <code>release2x-maint</code>입니다. 예를 들어, 2.3 유지보수 릴리스의 브랜치는 <code>release23-maint</code>입니다.</p>
<h3>절차 (Procedure)</h3>
<p>버그 수정 릴리스를 관리하는 프로세스는 부분적으로 Tcl 시스템을 모델로 합니다.</p>
<p><code>Patch Czar</code>는 버그 수정 릴리스를 위한 BDFL의 대응자입니다. 그러나 BDFL 및 지정된 임명자들은 개별 패치에 대한 거부권(veto power)을 보유합니다. <code>Patch Czar</code>는 단일 개발 브랜치만 관리할 수도 있습니다. 2.3.x 및 2.4.x 릴리스를 다른 사람이 유지보수하는 것도 충분히 가능합니다.</p>
<p>개별 패치가 현재 CVS 트렁크에 기여될 때, 각 패치 커미터는 해당 패치가 버그 수정 릴리스에 포함하기에 적합한 버그 수정인지 고려하도록 요청받습니다. 패치가 적합하다고 판단되면, 커미터는 해당 릴리스를 유지보수 브랜치에 커밋하거나, 커밋 메시지에 패치를 표시할 수 있습니다.</p>
<p>또한, Python 커뮤니티의 누구든지 패치 포함을 제안할 수 있습니다. 패치는 버그 수정 릴리스를 위해 특별히 제출될 수 있으며, PEP 3의 지침을 따라야 합니다. 그러나 일반적으로 특정 릴리스의 버그는 브랜치뿐만 아니라 <code>HEAD</code>에서도 수정되는 것이 더 좋습니다.</p>
<p><code>Patch Czar</code>는 릴리스를 보증하기에 충분한 수의 패치가 있을 때 결정합니다. 릴리스는 Windows 설치 프로그램(installer)을 포함하여 패키징되고 공개됩니다. 새로운 버그가 발견되면 즉시 수정하고 새로운 버그 수정 릴리스를 (버전 번호를 증분하여) 공개해야 합니다. 2.3.x 주기 동안 <code>Patch Czar</code> (Anthony)는 약 6개월마다 릴리스를 시도했지만, 이는 향후 릴리스에 어떤 식으로든 구속력 있는 것으로 간주되어서는 안 됩니다.</p>
<p>버그 수정 릴리스는 약 6개월 간격으로 발생할 것으로 예상됩니다. 그러나 이는 단지 지침일 뿐입니다. 명백히 주요 버그가 발견되면 버그 수정 릴리스가 더 빨리 적절할 수 있습니다. 일반적으로 <code>N-1</code> 릴리스만이 항상 활발하게 유지보수될 것입니다. 즉, Python 2.4 개발 중에는 Python 2.3이 버그 수정 릴리스를 받습니다. 그러나 자격을 갖춘 사람이 이전 릴리스의 유지보수 작업을 계속하기를 원한다면, 그들을 격려해야 합니다.</p>
<h3>Patch Czar 이력 (Patch Czar History)</h3>
<ul>
<li>Anthony Baxter: 2.3.1 ~ 2.3.4의 Patch Czar</li>
<li>Barry Warsaw: 2.2.3의 Patch Czar</li>
<li>Guido van Rossum: 2.2.2의 Patch Czar</li>
<li>Michael Hudson: 2.2.1의 Patch Czar</li>
<li>Anthony Baxter: 2.1.2 및 2.1.3의 Patch Czar</li>
<li>Thomas Wouters: 2.1.1의 Patch Czar</li>
<li>Moshe Zadka: 2.0.1의 Patch Czar</li>
</ul>
<h3>이력 (History)</h3>
<p>이 PEP는 <code>comp.lang.python</code>에서 제안으로 시작되었습니다. 초기 버전은 <code>N</code> 릴리스와 동시에 릴리스될 <code>N-1</code> 릴리스에 대한 단일 패치를 제안했습니다. 초기 버전은 또한 엄격한 버그 수정 정책을 고수할 것을 주장했습니다.</p>
<p>BDFL 및 다른 사람들로부터의 피드백에 따라, 확장된 버그 수정 릴리스 주기(이전 주요 릴리스도 패치를 얻을 수 있도록 허용)를 포함하고 엄격한 버그 수정 요구 사항을 완화한 (주로 버그 수정 또는 기능으로 논쟁의 여지가 있는 PEP 235의 예시 때문에) 초안 PEP가 작성되었습니다.</p>
<p>이후 토론은 주로 <code>python-dev</code>로 옮겨졌고, BDFL은 마침내 Tcl의 버그 수정 릴리스 프로세스를 기반으로 하는 선언을 발표했습니다. 이는 본질적으로 <code>N-1</code> 릴리스와 버그 수정만을 다루는 원래 제안으로 돌아갔지만, 릴리스 <code>N</code>이 게시될 때까지 여러 버그 수정 릴리스를 허용했습니다.</p>
<p>Anthony Baxter는 2.3 릴리스 주기에서 얻은 교훈을 바탕으로 이 PEP를 수정했습니다.</p>
<h3>참고 자료 (References)</h3>
<p>http://www.tcl.tk/cgi-bin/tct/tip/28.html</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.</p>
<hr>
<p>I have translated all sections, added citations, and followed the formatting guidelines. I also included the "obsolete" note at the beginning.</p>
<p>Double check the terminology.</p>
<ul>
<li><code>major releases</code> -> 주요 릴리스</li>
<li><code>bug fix releases</code> -> 버그 수정 릴리스</li>
<li><code>fork</code> -> 포크</li>
<li><code>SourceForge</code> -> SourceForge (고유명사)</li>
<li><code>enterprise development</code> -> 엔터프라이즈 개발</li>
<li><code>syntax changes</code> -> 구문 변경</li>
<li><code>.pyc</code>, <code>.pyo</code> -> <code>.pyc</code>, <code>.pyo</code> (파일 확장자)</li>
<li><code>pickle changes</code> -> pickle 변경 (고유 기능명)</li>
<li><code>C API changes</code> -> C API 변경 (고유 기능명)</li>
<li><code>extensions</code> -> 확장 모듈</li>
<li><code>recompiling</code> -> 재컴파일</li>
<li><code>BDFL proclamation</code> -> BDFL 선언 (BDFL은 약어 그대로 사용)</li>
<li><code>release notes</code> -> 릴리스 노트</li>
<li><code>new features</code> -> 새로운 기능</li>
<li><code>standard library</code> -> 표준 라이브러리</li>
<li><code>APIs</code> -> API</li>
<li><code>backport</code> -> 백포트</li>
<li><code>CVS branch</code> -> CVS 브랜치</li>
<li><code>commit message</code> -> 커밋 메시지</li>
<li><code>Bugfix candidate</code>, <code>Backport candidate</code> -> 'Bugfix candidate', 'Backport candidate' (영어 그대로 사용)</li>
<li><code>X.Y</code>, <code>X.Y.Z</code> -> <code>X.Y</code>, <code>X.Y.Z</code> (버전 형식)</li>
<li><code>release N</code>, <code>N-1</code> -> 릴리스 <code>N</code>, <code>N-1</code> (설명과 함께 사용)</li>
<li><code>release2x-maint</code> -> <code>release2x-maint</code> (브랜치 이름)</li>
<li><code>Tcl system</code> -> Tcl 시스템</li>
<li><code>Patch Czar</code> -> Patch Czar (영어 그대로 사용)</li>
<li><code>veto power</code> -> 거부권</li>
<li><code>commit the release</code> -> 해당 릴리스를 커밋</li>
<li><code>current trunk of CVS</code> -> 현재 CVS 트렁크</li>
<li><code>Windows installer</code> -> Windows 설치 프로그램</li>
<li><code>python-dev</code> -> python-dev (메일링 리스트 이름)</li>
<li><code>public domain</code> -> 퍼블릭 도메인</li>
</ul>
<p>The terminology seems consistent with the guidelines.
All sections are translated.
Markdown formatting is used.
Citations are included.
The obsolete status is mentioned.</p>
<p>The translation is complete and follows all instructions.</p>
<pre><code class="language-markdown">## PEP 6 – Bug Fix Releases (버그 수정 릴리스)

**저자:** Aahz &#x3C;aahz at pythoncraft.com>, Anthony Baxter &#x3C;anthony at interlink.com.au>
**상태:** Superseded (대체됨)
**유형:** Process (프로세스)
**생성일:** 2001년 3월 15일
**이력:** 2001년 3월 15일, 2001년 4월 18일, 2004년 8월 19일

---

**참고:** 이 PEP는 더 이상 사용되지 않습니다 (obsolete). 현재 릴리스 정책은 개발 가이드(devguide)에 문서화되어 있습니다. 릴리스 프로세스의 메커니즘에 대해서는 [PEP 101](https://peps.python.org/pep-0101/)을 참조하세요.

### 요약 (Abstract)

Python은 역사적으로 단일 개발 포크(fork)만을 가지고 있었으며, 릴리스는 새로운 기능 추가와 버그 수정이라는 두 가지 목적을 동시에 수행했습니다 (이러한 종류의 릴리스는 "주요 릴리스(major releases)"라고 불립니다). 이 PEP는 주로 버그 수정을 목적으로 구버전의 유지보수 또는 버그 수정 릴리스를 포크하는 방법을 설명합니다.

이 PEP는 버그 수정 릴리스의 존재를 보장하는 것이 *아니며*, 버그 수정 릴리스가 필요한 만큼의 Python 커뮤니티 구성원이 기꺼이 작업을 수행할 의향이 있을 경우에 따를 절차만을 명시합니다.

### 동기 (Motivation)

SourceForge로 이전하면서 Python 개발이 가속화되었습니다. 커뮤니티의 일부에서는 이러한 가속화가 지나치다고 느끼며, 개발 주기 후반에 너무 많은 기능이 추가되었을 때 버그 수정을 위해 새 버전으로 업그레이드하는 것을 불편하게 여기는 사람들이 많습니다.

이 문제에 대한 한 가지 해결책은 이전 주요 릴리스를 유지보수하여, 다음 주요 릴리스가 나올 때까지 버그 수정을 제공하는 것입니다. 이는 Python이 수백 또는 수천 대의 장비에 설치되어야 할 수도 있는 엔터프라이즈 개발에 Python을 더욱 매력적으로 만들 것입니다.

### 금지 사항 (Prohibitions)

버그 수정 릴리스는 다음 제한 사항을 준수해야 합니다.

*   **구문 변경(syntax changes)이 없어야 합니다.**
*   **모든 `.pyc` 및 `.pyo` 파일은 작동해야 합니다.** 주요 릴리스에서 포크된 모든 버그 수정 릴리스에서 (재생성 없이) 작동해야 합니다.
*   **pickle 변경(pickle changes)이 없어야 합니다.**
*   **호환되지 않는 C API 변경이 없어야 합니다.** 모든 확장 모듈(extensions)은 주요 릴리스와 동일한 포크 내의 모든 버그 수정 릴리스에서 재컴파일 없이 계속 작동해야 합니다.

이러한 금지 사항 중 하나라도 위반할 경우 BDFL(Benevolent Dictator For Life)의 선언(proclamation)이 필요하며 (릴리스 노트에 눈에 띄는 경고와 함께) 고지되어야 합니다.

### 완전한 금지 사항은 아니지만 지켜야 할 사항 (Not-Quite-Prohibitions)

가능한 경우, 버그 수정 릴리스는 또한 다음을 준수해야 합니다.

*   **새로운 기능이 없어야 합니다.** 버그 수정 릴리스의 목적은 버그를 수정하는 것이지, CVS `HEAD`의 최신 기능을 추가하는 것이 아닙니다.
*   **고통 없는 업그레이드가 되어야 합니다.** 사용자는 2.x.y에서 2.x.(y+1)로의 업그레이드가 실행 중인 시스템을 망가뜨리지 않을 것이라고 확신할 수 있어야 합니다. 이는 버그를 수정하는 데 필요한 경우가 아니라면, 표준 라이브러리(standard library)가 동작을 변경하거나, 더 나아가 API를 변경해서는 안 된다는 것을 의미합니다.

### 금지 사항의 적용 가능성 (Applicability of Prohibitions)

위의 금지 사항 및 "완전한 금지 사항은 아니지만 지켜야 할 사항"은 최종 릴리스에서 버그 수정 릴리스로 (예: 2.4에서 2.4.1로), 그리고 한 시리즈 내에서 한 버그 수정 릴리스에서 다음 버그 수정 릴리스로 (예: 2.4.1에서 2.4.2로) 모두 적용됩니다.

이 PEP에 나열된 금지 사항을 따르면, 커뮤니티는 버그 수정 릴리스가 고통 없고 안전한 업그레이드라는 점에 만족할 것입니다.

### 버그 수정 릴리스 촉진 (Helping the Bug Fix Releases Happen)

버그 수정 릴리스 프로세스를 돕는 몇 가지 지침은 다음과 같습니다.

*   **버그 수정을 백포트(Backport)하세요.** 버그를 수정했고 그것이 적절하다고 판단되면, 현재 버그 수정 릴리스를 위한 CVS 브랜치로 백포트하세요. 스스로 백포트할 의향이 없거나 할 수 없는 경우, 커밋 메시지에 'Bugfix candidate' 또는 'Backport candidate'와 같은 문구로 메모를 남기세요. 확실하지 않다면 질문하세요.
*   **현재 버그 수정 릴리스를 관리하는 사람에게 특정 수정 사항이 적절한지 문의하세요.**
*   **버그 수정 릴리스에서 특히 수정되기를 원하는 특정 버그가 있다면, 적극적으로 나서서 해결되도록 노력하세요.** 버그 수정 릴리스가 예정된 시점의 48시간 전까지 기다렸다가 버그 수정을 포함해달라고 요청하지 마세요.

### 버전 번호 (Version Numbers)

Python 2.0부터 모든 주요 릴리스는 `X.Y` 형식의 버전 번호를 가져야 합니다. 버그 수정 릴리스는 항상 `X.Y.Z` 형식이어야 합니다.

현재 개발 중인 주요 릴리스는 릴리스 `N`으로 지칭됩니다. 막 릴리스된 주요 버전은 `N-1`으로 지칭됩니다.

CVS에서 버그 수정 릴리스는 브랜치에서 이루어집니다. 2.x 릴리스의 경우 브랜치 이름은 `release2x-maint`입니다. 예를 들어, 2.3 유지보수 릴리스의 브랜치는 `release23-maint`입니다.

### 절차 (Procedure)

버그 수정 릴리스를 관리하는 프로세스는 부분적으로 Tcl 시스템[1]을 모델로 합니다.

`Patch Czar`는 버그 수정 릴리스를 위한 BDFL의 대응자입니다. 그러나 BDFL 및 지정된 임명자들은 개별 패치에 대한 거부권(veto power)을 보유합니다. `Patch Czar`는 단일 개발 브랜치만 관리할 수도 있습니다. 2.3.x 및 2.4.x 릴리스를 다른 사람이 유지보수하는 것도 충분히 가능합니다.

개별 패치가 현재 CVS 트렁크에 기여될 때, 각 패치 커미터는 해당 패치가 버그 수정 릴리스에 포함하기에 적합한 버그 수정인지 고려하도록 요청받습니다. 패치가 적합하다고 판단되면, 커미터는 해당 릴리스를 유지보수 브랜치에 커밋하거나, 커밋 메시지에 패치를 표시할 수 있습니다.

또한, Python 커뮤니티의 누구든지 패치 포함을 제안할 수 있습니다. 패치는 버그 수정 릴리스를 위해 특별히 제출될 수 있으며, [PEP 3](https://peps.python.org/pep-0003/)의 지침을 따라야 합니다. 그러나 일반적으로 특정 릴리스의 버그는 브랜치뿐만 아니라 `HEAD`에서도 수정되는 것이 더 좋습니다.

`Patch Czar`는 릴리스를 보증하기에 충분한 수의 패치가 있을 때 결정합니다. 릴리스는 Windows 설치 프로그램(installer)을 포함하여 패키징되고 공개됩니다. 새로운 버그가 발견되면 즉시 수정하고 새로운 버그 수정 릴리스를 (버전 번호를 증분하여) 공개해야 합니다. 2.3.x 주기 동안 `Patch Czar` (Anthony)는 약 6개월마다 릴리스를 시도했지만, 이는 향후 릴리스에 어떤 식으로든 구속력 있는 것으로 간주되어서는 안 됩니다.

버그 수정 릴리스는 약 6개월 간격으로 발생할 것으로 예상됩니다. 그러나 이는 단지 지침일 뿐입니다. 명백히 주요 버그가 발견되면 버그 수정 릴리스가 더 빨리 적절할 수 있습니다. 일반적으로 `N-1` 릴리스만이 항상 활발하게 유지보수될 것입니다. 즉, Python 2.4 개발 중에는 Python 2.3이 버그 수정 릴리스를 받습니다. 그러나 자격을 갖춘 사람이 이전 릴리스의 유지보수 작업을 계속하기를 원한다면, 그들을 격려해야 합니다.

### Patch Czar 이력 (Patch Czar History)

*   Anthony Baxter: 2.3.1 ~ 2.3.4의 Patch Czar
*   Barry Warsaw: 2.2.3의 Patch Czar
*   Guido van Rossum: 2.2.2의 Patch Czar
*   Michael Hudson: 2.2.1의 Patch Czar
*   Anthony Baxter: 2.1.2 및 2.1.3의 Patch Czar
*   Thomas Wouters: 2.1.1의 Patch Czar
*   Moshe Zadka: 2.0.1의 Patch Czar

### 이력 (History)

이 PEP는 `comp.lang.python`에서 제안으로 시작되었습니다. 초기 버전은 `N` 릴리스와 동시에 릴리스될 `N-1` 릴리스에 대한 단일 패치를 제안했습니다. 초기 버전은 또한 엄격한 버그 수정 정책을 고수할 것을 주장했습니다.

BDFL 및 다른 사람들로부터의 피드백에 따라, 확장된 버그 수정 릴리스 주기(이전 주요 릴리스도 패치를 얻을 수 있도록 허용)를 포함하고 엄격한 버그 수정 요구 사항을 완화한 (주로 버그 수정 또는 기능으로 논쟁의 여지가 있는 PEP 235의 예시 때문에) 초안 PEP가 작성되었습니다.

이후 토론은 주로 `python-dev`로 옮겨졌고, BDFL은 마침내 Tcl의 버그 수정 릴리스 프로세스를 기반으로 하는 선언을 발표했습니다. 이는 본질적으로 `N-1` 릴리스와 버그 수정만을 다루는 원래 제안으로 돌아갔지만, 릴리스 `N`이 게시될 때까지 여러 버그 수정 릴리스를 허용했습니다.

Anthony Baxter는 2.3 릴리스 주기에서 얻은 교훈을 바탕으로 이 PEP를 수정했습니다.

### 참고 자료 (References)

[1] Tcl 시스템 관련 문서: [http://www.tcl.tk/cgi-bin/tct/tip/28.html](http://www.tcl.tk/cgi-bin/tct/tip/28.html)

### 저작권 (Copyright)

이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.
```## PEP 6 – Bug Fix Releases (버그 수정 릴리스)

**저자:** Aahz &#x3C;aahz at pythoncraft.com>, Anthony Baxter &#x3C;anthony at interlink.com.au>
**상태:** Superseded (대체됨)
**유형:** Process (프로세스)
**생성일:** 2001년 3월 15일
**이력:** 2001년 3월 15일, 2001년 4월 18일, 2004년 8월 19일

---

**참고:** 이 PEP는 더 이상 사용되지 않습니다 (obsolete). 현재 릴리스 정책은 개발 가이드(devguide)에 문서화되어 있습니다. 릴리스 프로세스의 메커니즘에 대해서는 [PEP 101](https://peps.python.org/pep-0101/)을 참조하세요.

### 요약 (Abstract)

Python은 역사적으로 단일 개발 포크(fork)만을 가지고 있었으며, 릴리스는 새로운 기능 추가와 버그 수정이라는 두 가지 목적을 동시에 수행했습니다 (이러한 종류의 릴리스는 "주요 릴리스(major releases)"라고 불립니다). 이 PEP는 주로 버그 수정을 목적으로 구버전의 유지보수 또는 버그 수정 릴리스를 포크하는 방법을 설명합니다.

이 PEP는 버그 수정 릴리스의 존재를 보장하는 것이 *아니며*, 버그 수정 릴리스가 필요한 만큼의 Python 커뮤니티 구성원이 기꺼이 작업을 수행할 의향이 있을 경우에 따를 절차만을 명시합니다.

### 동기 (Motivation)

SourceForge로 이전하면서 Python 개발이 가속화되었습니다. 커뮤니티의 일부에서는 이러한 가속화가 지나치다고 느끼며, 개발 주기 후반에 너무 많은 기능이 추가되었을 때 버그 수정을 위해 새 버전으로 업그레이드하는 것을 불편하게 여기는 사람들이 많습니다.

이 문제에 대한 한 가지 해결책은 이전 주요 릴리스를 유지보수하여, 다음 주요 릴리스가 나올 때까지 버그 수정을 제공하는 것입니다. 이는 Python이 수백 또는 수천 대의 장비에 설치되어야 할 수도 있는 엔터프라이즈 개발에 Python을 더욱 매력적으로 만들 것입니다.

### 금지 사항 (Prohibitions)

버그 수정 릴리스는 다음 제한 사항을 준수해야 합니다.

*   **구문 변경(syntax changes)이 없어야 합니다.**
*   **모든 `.pyc` 및 `.pyo` 파일은 작동해야 합니다.** 주요 릴리스에서 포크된 모든 버그 수정 릴리스에서 (재생성 없이) 작동해야 합니다.
*   **pickle 변경(pickle changes)이 없어야 합니다.**
*   **호환되지 않는 C API 변경이 없어야 합니다.** 모든 확장 모듈(extensions)은 주요 릴리스와 동일한 포크 내의 모든 버그 수정 릴리스에서 재컴파일 없이 계속 작동해야 합니다.

이러한 금지 사항 중 하나라도 위반할 경우 BDFL(Benevolent Dictator For Life)의 선언(proclamation)이 필요하며 (릴리스 노트에 눈에 띄는 경고와 함께) 고지되어야 합니다.

### 완전한 금지 사항은 아니지만 지켜야 할 사항 (Not-Quite-Prohibitions)

가능한 경우, 버그 수정 릴리스는 또한 다음을 준수해야 합니다.

*   **새로운 기능이 없어야 합니다.** 버그 수정 릴리스의 목적은 버그를 수정하는 것이지, CVS `HEAD`의 최신 기능을 추가하는 것이 아닙니다.
*   **고통 없는 업그레이드가 되어야 합니다.** 사용자는 2.x.y에서 2.x.(y+1)로의 업그레이드가 실행 중인 시스템을 망가뜨리지 않을 것이라고 확신할 수 있어야 합니다. 이는 버그를 수정하는 데 필요한 경우가 아니라면, 표준 라이브러리(standard library)가 동작을 변경하거나, 더 나아가 API를 변경해서는 안 된다는 것을 의미합니다.

### 금지 사항의 적용 가능성 (Applicability of Prohibitions)

위의 금지 사항 및 "완전한 금지 사항은 아니지만 지켜야 할 사항"은 최종 릴리스에서 버그 수정 릴리스로 (예: 2.4에서 2.4.1로), 그리고 한 시리즈 내에서 한 버그 수정 릴리스에서 다음 버그 수정 릴리스로 (예: 2.4.1에서 2.4.2로) 모두 적용됩니다.

이 PEP에 나열된 금지 사항을 따르면, 커뮤니티는 버그 수정 릴리스가 고통 없고 안전한 업그레이드라는 점에 만족할 것입니다.

### 버그 수정 릴리스 촉진 (Helping the Bug Fix Releases Happen)

버그 수정 릴리스 프로세스를 돕는 몇 가지 지침은 다음과 같습니다.

*   **버그 수정을 백포트(Backport)하세요.** 버그를 수정했고 그것이 적절하다고 판단되면, 현재 버그 수정 릴리스를 위한 CVS 브랜치로 백포트하세요. 스스로 백포트할 의향이 없거나 할 수 없는 경우, 커밋 메시지에 'Bugfix candidate' 또는 'Backport candidate'와 같은 문구로 메모를 남기세요. 확실하지 않다면 질문하세요.
*   **현재 버그 수정 릴리스를 관리하는 사람에게 특정 수정 사항이 적절한지 문의하세요.**
*   **버그 수정 릴리스에서 특히 수정되기를 원하는 특정 버그가 있다면, 적극적으로 나서서 해결되도록 노력하세요.** 버그 수정 릴리스가 예정된 시점의 48시간 전까지 기다렸다가 버그 수정을 포함해달라고 요청하지 마세요.

### 버전 번호 (Version Numbers)

Python 2.0부터 모든 주요 릴리스는 `X.Y` 형식의 버전 번호를 가져야 합니다. 버그 수정 릴리스는 항상 `X.Y.Z` 형식이어야 합니다.

현재 개발 중인 주요 릴리스는 릴리스 `N`으로 지칭됩니다. 막 릴리스된 주요 버전은 `N-1`으로 지칭됩니다.

CVS에서 버그 수정 릴리스는 브랜치에서 이루어집니다. 2.x 릴리스의 경우 브랜치 이름은 `release2x-maint`입니다. 예를 들어, 2.3 유지보수 릴리스의 브랜치는 `release23-maint`입니다.

### 절차 (Procedure)

버그 수정 릴리스를 관리하는 프로세스는 부분적으로 Tcl 시스템을 모델로 합니다.

`Patch Czar`는 버그 수정 릴리스를 위한 BDFL의 대응자입니다. 그러나 BDFL 및 지정된 임명자들은 개별 패치에 대한 거부권(veto power)을 보유합니다. `Patch Czar`는 단일 개발 브랜치만 관리할 수도 있습니다. 2.3.x 및 2.4.x 릴리스를 다른 사람이 유지보수하는 것도 충분히 가능합니다.

개별 패치가 현재 CVS 트렁크에 기여될 때, 각 패치 커미터는 해당 패치가 버그 수정 릴리스에 포함하기에 적합한 버그 수정인지 고려하도록 요청받습니다. 패치가 적합하다고 판단되면, 커미터는 해당 릴리스를 유지보수 브랜치에 커밋하거나, 커밋 메시지에 패치를 표시할 수 있습니다.

또한, Python 커뮤니티의 누구든지 패치 포함을 제안할 수 있습니다. 패치는 버그 수정 릴리스를 위해 특별히 제출될 수 있으며, [PEP 3](https://peps.python.org/pep-0003/)의 지침을 따라야 합니다. 그러나 일반적으로 특정 릴리스의 버그는 브랜치뿐만 아니라 `HEAD`에서도 수정되는 것이 더 좋습니다.

`Patch Czar`는 릴리스를 보증하기에 충분한 수의 패치가 있을 때 결정합니다. 릴리스는 Windows 설치 프로그램(installer)을 포함하여 패키징되고 공개됩니다. 새로운 버그가 발견되면 즉시 수정하고 새로운 버그 수정 릴리스를 (버전 번호를 증분하여) 공개해야 합니다. 2.3.x 주기 동안 `Patch Czar` (Anthony)는 약 6개월마다 릴리스를 시도했지만, 이는 향후 릴리스에 어떤 식으로든 구속력 있는 것으로 간주되어서는 안 됩니다.

버그 수정 릴리스는 약 6개월 간격으로 발생할 것으로 예상됩니다. 그러나 이는 단지 지침일 뿐입니다. 명백히 주요 버그가 발견되면 버그 수정 릴리스가 더 빨리 적절할 수 있습니다. 일반적으로 `N-1` 릴리스만이 항상 활발하게 유지보수될 것입니다. 즉, Python 2.4 개발 중에는 Python 2.3이 버그 수정 릴리스를 받습니다. 그러나 자격을 갖춘 사람이 이전 릴리스의 유지보수 작업을 계속하기를 원한다면, 그들을 격려해야 합니다.

### Patch Czar 이력 (Patch Czar History)

*   Anthony Baxter: 2.3.1 ~ 2.3.4의 Patch Czar
*   Barry Warsaw: 2.2.3의 Patch Czar
*   Guido van Rossum: 2.2.2의 Patch Czar
*   Michael Hudson: 2.2.1의 Patch Czar
*   Anthony Baxter: 2.1.2 및 2.1.3의 Patch Czar
*   Thomas Wouters: 2.1.1의 Patch Czar
*   Moshe Zadka: 2.0.1의 Patch Czar

### 이력 (History)

이 PEP는 `comp.lang.python`에서 제안으로 시작되었습니다. 초기 버전은 `N` 릴리스와 동시에 릴리스될 `N-1` 릴리스에 대한 단일 패치를 제안했습니다. 초기 버전은 또한 엄격한 버그 수정 정책을 고수할 것을 주장했습니다.

BDFL 및 다른 사람들로부터의 피드백에 따라, 확장된 버그 수정 릴리스 주기(이전 주요 릴리스도 패치를 얻을 수 있도록 허용)를 포함하고 엄격한 버그 수정 요구 사항을 완화한 (주로 버그 수정 또는 기능으로 논쟁의 여지가 있는 PEP 235의 예시 때문에) 초안 PEP가 작성되었습니다.

이후 토론은 주로 `python-dev`로 옮겨졌고, BDFL은 마침내 Tcl의 버그 수정 릴리스 프로세스를 기반으로 하는 선언을 발표했습니다. 이는 본질적으로 `N-1` 릴리스와 버그 수정만을 다루는 원래 제안으로 돌아갔지만, 릴리스 `N`이 게시될 때까지 여러 버그 수정 릴리스를 허용했습니다.

Anthony Baxter는 2.3 릴리스 주기에서 얻은 교훈을 바탕으로 이 PEP를 수정했습니다.

### 참고 자료 (References)

 Tcl 시스템 관련 문서: [http://www.tcl.tk/cgi-bin/tct/tip/28.html](http://www.tcl.tk/cgi-bin/tct/tip/28.html)

### 저작권 (Copyright)

이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.

> ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.
</code></pre>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/6\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/6/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/6\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"6\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/6\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T8338,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0006/\"\u003ePEP 6 - Bug Fix Releases\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Superseded | \u003cstrong\u003e유형:\u003c/strong\u003e Process | \u003cstrong\u003e작성일:\u003c/strong\u003e 15-Mar-2001\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 6 – Bug Fix Releases (버그 수정 릴리스)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e저자:\u003c/strong\u003e Aahz , Anthony Baxter \n\u003cstrong\u003e상태:\u003c/strong\u003e Superseded (대체됨)\n\u003cstrong\u003e유형:\u003c/strong\u003e Process (프로세스)\n\u003cstrong\u003e생성일:\u003c/strong\u003e 2001년 3월 15일\n\u003cstrong\u003e이력:\u003c/strong\u003e 2001년 3월 15일, 2001년 4월 18일, 2004년 8월 19일\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 이 PEP는 더 이상 사용되지 않습니다 (obsolete). 현재 릴리스 정책은 개발 가이드(devguide)에 문서화되어 있습니다. 릴리스 프로세스의 메커니즘에 대해서는 PEP 101을 참조하세요.\u003c/p\u003e\n\u003ch3\u003e요약 (Abstract)\u003c/h3\u003e\n\u003cp\u003ePython은 역사적으로 단일 개발 포크(fork)만을 가지고 있었으며, 릴리스는 새로운 기능 추가와 버그 수정이라는 두 가지 목적을 동시에 수행했습니다 (이러한 종류의 릴리스는 \"주요 릴리스(major releases)\"라고 불립니다). 이 PEP는 주로 버그 수정을 목적으로 구버전의 유지보수 또는 버그 수정 릴리스를 포크하는 방법을 설명합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 버그 수정 릴리스의 존재를 보장하는 것이 \u003cem\u003e아니며\u003c/em\u003e, 버그 수정 릴리스가 필요한 만큼의 Python 커뮤니티 구성원이 기꺼이 작업을 수행할 의향이 있을 경우에 따를 절차만을 명시합니다.\u003c/p\u003e\n\u003ch3\u003e동기 (Motivation)\u003c/h3\u003e\n\u003cp\u003eSourceForge로 이전하면서 Python 개발이 가속화되었습니다. 커뮤니티의 일부에서는 이러한 가속화가 지나치다고 느끼며, 개발 주기 후반에 너무 많은 기능이 추가되었을 때 버그 수정을 위해 새 버전으로 업그레이드하는 것을 불편하게 여기는 사람들이 많습니다.\u003c/p\u003e\n\u003cp\u003e이 문제에 대한 한 가지 해결책은 이전 주요 릴리스를 유지보수하여, 다음 주요 릴리스가 나올 때까지 버그 수정을 제공하는 것입니다. 이는 Python이 수백 또는 수천 대의 장비에 설치되어야 할 수도 있는 엔터프라이즈 개발에 Python을 더욱 매력적으로 만들 것입니다.\u003c/p\u003e\n\u003ch3\u003e금지 사항 (Prohibitions)\u003c/h3\u003e\n\u003cp\u003e버그 수정 릴리스는 다음 제한 사항을 준수해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e구문 변경(syntax changes)이 없어야 합니다.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e모든 \u003ccode\u003e.pyc\u003c/code\u003e 및 \u003ccode\u003e.pyo\u003c/code\u003e 파일은 작동해야 합니다.\u003c/strong\u003e 주요 릴리스에서 포크된 모든 버그 수정 릴리스에서 (재생성 없이) 작동해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epickle 변경(pickle changes)이 없어야 합니다.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e호환되지 않는 C API 변경이 없어야 합니다.\u003c/strong\u003e 모든 확장 모듈(extensions)은 주요 릴리스와 동일한 포크 내의 모든 버그 수정 릴리스에서 재컴파일 없이 계속 작동해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 금지 사항 중 하나라도 위반할 경우 BDFL(Benevolent Dictator For Life)의 선언(proclamation)이 필요하며 (릴리스 노트에 눈에 띄는 경고와 함께) 고지되어야 합니다.\u003c/p\u003e\n\u003ch3\u003e완전한 금지 사항은 아니지만 지켜야 할 사항 (Not-Quite-Prohibitions)\u003c/h3\u003e\n\u003cp\u003e가능한 경우, 버그 수정 릴리스는 또한 다음을 준수해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e새로운 기능이 없어야 합니다.\u003c/strong\u003e 버그 수정 릴리스의 목적은 버그를 수정하는 것이지, CVS \u003ccode\u003eHEAD\u003c/code\u003e의 최신 기능을 추가하는 것이 아닙니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e고통 없는 업그레이드가 되어야 합니다.\u003c/strong\u003e 사용자는 2.x.y에서 2.x.(y+1)로의 업그레이드가 실행 중인 시스템을 망가뜨리지 않을 것이라고 확신할 수 있어야 합니다. 이는 버그를 수정하는 데 필요한 경우가 아니라면, 표준 라이브러리(standard library)가 동작을 변경하거나, 더 나아가 API를 변경해서는 안 된다는 것을 의미합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e금지 사항의 적용 가능성 (Applicability of Prohibitions)\u003c/h3\u003e\n\u003cp\u003e위의 금지 사항 및 \"완전한 금지 사항은 아니지만 지켜야 할 사항\"은 최종 릴리스에서 버그 수정 릴리스로 (예: 2.4에서 2.4.1로), 그리고 한 시리즈 내에서 한 버그 수정 릴리스에서 다음 버그 수정 릴리스로 (예: 2.4.1에서 2.4.2로) 모두 적용됩니다.\u003c/p\u003e\n\u003cp\u003e이 PEP에 나열된 금지 사항을 따르면, 커뮤니티는 버그 수정 릴리스가 고통 없고 안전한 업그레이드라는 점에 만족할 것입니다.\u003c/p\u003e\n\u003ch3\u003e버그 수정 릴리스 촉진 (Helping the Bug Fix Releases Happen)\u003c/h3\u003e\n\u003cp\u003e버그 수정 릴리스 프로세스를 돕는 몇 가지 지침은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e버그 수정을 백포트(Backport)하세요.\u003c/strong\u003e 버그를 수정했고 그것이 적절하다고 판단되면, 현재 버그 수정 릴리스를 위한 CVS 브랜치로 백포트하세요. 스스로 백포트할 의향이 없거나 할 수 없는 경우, 커밋 메시지에 'Bugfix candidate' 또는 'Backport candidate'와 같은 문구로 메모를 남기세요. 확실하지 않다면 질문하세요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e현재 버그 수정 릴리스를 관리하는 사람에게 특정 수정 사항이 적절한지 문의하세요.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e버그 수정 릴리스에서 특히 수정되기를 원하는 특정 버그가 있다면, 적극적으로 나서서 해결되도록 노력하세요.\u003c/strong\u003e 버그 수정 릴리스가 예정된 시점의 48시간 전까지 기다렸다가 버그 수정을 포함해달라고 요청하지 마세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e버전 번호 (Version Numbers)\u003c/h3\u003e\n\u003cp\u003ePython 2.0부터 모든 주요 릴리스는 \u003ccode\u003eX.Y\u003c/code\u003e 형식의 버전 번호를 가져야 합니다. 버그 수정 릴리스는 항상 \u003ccode\u003eX.Y.Z\u003c/code\u003e 형식이어야 합니다.\u003c/p\u003e\n\u003cp\u003e현재 개발 중인 주요 릴리스는 릴리스 \u003ccode\u003eN\u003c/code\u003e으로 지칭됩니다. 막 릴리스된 주요 버전은 \u003ccode\u003eN-1\u003c/code\u003e으로 지칭됩니다.\u003c/p\u003e\n\u003cp\u003eCVS에서 버그 수정 릴리스는 브랜치에서 이루어집니다. 2.x 릴리스의 경우 브랜치 이름은 \u003ccode\u003erelease2x-maint\u003c/code\u003e입니다. 예를 들어, 2.3 유지보수 릴리스의 브랜치는 \u003ccode\u003erelease23-maint\u003c/code\u003e입니다.\u003c/p\u003e\n\u003ch3\u003e절차 (Procedure)\u003c/h3\u003e\n\u003cp\u003e버그 수정 릴리스를 관리하는 프로세스는 부분적으로 Tcl 시스템을 모델로 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePatch Czar\u003c/code\u003e는 버그 수정 릴리스를 위한 BDFL의 대응자입니다. 그러나 BDFL 및 지정된 임명자들은 개별 패치에 대한 거부권(veto power)을 보유합니다. \u003ccode\u003ePatch Czar\u003c/code\u003e는 단일 개발 브랜치만 관리할 수도 있습니다. 2.3.x 및 2.4.x 릴리스를 다른 사람이 유지보수하는 것도 충분히 가능합니다.\u003c/p\u003e\n\u003cp\u003e개별 패치가 현재 CVS 트렁크에 기여될 때, 각 패치 커미터는 해당 패치가 버그 수정 릴리스에 포함하기에 적합한 버그 수정인지 고려하도록 요청받습니다. 패치가 적합하다고 판단되면, 커미터는 해당 릴리스를 유지보수 브랜치에 커밋하거나, 커밋 메시지에 패치를 표시할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, Python 커뮤니티의 누구든지 패치 포함을 제안할 수 있습니다. 패치는 버그 수정 릴리스를 위해 특별히 제출될 수 있으며, PEP 3의 지침을 따라야 합니다. 그러나 일반적으로 특정 릴리스의 버그는 브랜치뿐만 아니라 \u003ccode\u003eHEAD\u003c/code\u003e에서도 수정되는 것이 더 좋습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePatch Czar\u003c/code\u003e는 릴리스를 보증하기에 충분한 수의 패치가 있을 때 결정합니다. 릴리스는 Windows 설치 프로그램(installer)을 포함하여 패키징되고 공개됩니다. 새로운 버그가 발견되면 즉시 수정하고 새로운 버그 수정 릴리스를 (버전 번호를 증분하여) 공개해야 합니다. 2.3.x 주기 동안 \u003ccode\u003ePatch Czar\u003c/code\u003e (Anthony)는 약 6개월마다 릴리스를 시도했지만, 이는 향후 릴리스에 어떤 식으로든 구속력 있는 것으로 간주되어서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e버그 수정 릴리스는 약 6개월 간격으로 발생할 것으로 예상됩니다. 그러나 이는 단지 지침일 뿐입니다. 명백히 주요 버그가 발견되면 버그 수정 릴리스가 더 빨리 적절할 수 있습니다. 일반적으로 \u003ccode\u003eN-1\u003c/code\u003e 릴리스만이 항상 활발하게 유지보수될 것입니다. 즉, Python 2.4 개발 중에는 Python 2.3이 버그 수정 릴리스를 받습니다. 그러나 자격을 갖춘 사람이 이전 릴리스의 유지보수 작업을 계속하기를 원한다면, 그들을 격려해야 합니다.\u003c/p\u003e\n\u003ch3\u003ePatch Czar 이력 (Patch Czar History)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAnthony Baxter: 2.3.1 ~ 2.3.4의 Patch Czar\u003c/li\u003e\n\u003cli\u003eBarry Warsaw: 2.2.3의 Patch Czar\u003c/li\u003e\n\u003cli\u003eGuido van Rossum: 2.2.2의 Patch Czar\u003c/li\u003e\n\u003cli\u003eMichael Hudson: 2.2.1의 Patch Czar\u003c/li\u003e\n\u003cli\u003eAnthony Baxter: 2.1.2 및 2.1.3의 Patch Czar\u003c/li\u003e\n\u003cli\u003eThomas Wouters: 2.1.1의 Patch Czar\u003c/li\u003e\n\u003cli\u003eMoshe Zadka: 2.0.1의 Patch Czar\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e이력 (History)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003ecomp.lang.python\u003c/code\u003e에서 제안으로 시작되었습니다. 초기 버전은 \u003ccode\u003eN\u003c/code\u003e 릴리스와 동시에 릴리스될 \u003ccode\u003eN-1\u003c/code\u003e 릴리스에 대한 단일 패치를 제안했습니다. 초기 버전은 또한 엄격한 버그 수정 정책을 고수할 것을 주장했습니다.\u003c/p\u003e\n\u003cp\u003eBDFL 및 다른 사람들로부터의 피드백에 따라, 확장된 버그 수정 릴리스 주기(이전 주요 릴리스도 패치를 얻을 수 있도록 허용)를 포함하고 엄격한 버그 수정 요구 사항을 완화한 (주로 버그 수정 또는 기능으로 논쟁의 여지가 있는 PEP 235의 예시 때문에) 초안 PEP가 작성되었습니다.\u003c/p\u003e\n\u003cp\u003e이후 토론은 주로 \u003ccode\u003epython-dev\u003c/code\u003e로 옮겨졌고, BDFL은 마침내 Tcl의 버그 수정 릴리스 프로세스를 기반으로 하는 선언을 발표했습니다. 이는 본질적으로 \u003ccode\u003eN-1\u003c/code\u003e 릴리스와 버그 수정만을 다루는 원래 제안으로 돌아갔지만, 릴리스 \u003ccode\u003eN\u003c/code\u003e이 게시될 때까지 여러 버그 수정 릴리스를 허용했습니다.\u003c/p\u003e\n\u003cp\u003eAnthony Baxter는 2.3 릴리스 주기에서 얻은 교훈을 바탕으로 이 PEP를 수정했습니다.\u003c/p\u003e\n\u003ch3\u003e참고 자료 (References)\u003c/h3\u003e\n\u003cp\u003ehttp://www.tcl.tk/cgi-bin/tct/tip/28.html\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eI have translated all sections, added citations, and followed the formatting guidelines. I also included the \"obsolete\" note at the beginning.\u003c/p\u003e\n\u003cp\u003eDouble check the terminology.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emajor releases\u003c/code\u003e -\u003e 주요 릴리스\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebug fix releases\u003c/code\u003e -\u003e 버그 수정 릴리스\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efork\u003c/code\u003e -\u003e 포크\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSourceForge\u003c/code\u003e -\u003e SourceForge (고유명사)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eenterprise development\u003c/code\u003e -\u003e 엔터프라이즈 개발\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esyntax changes\u003c/code\u003e -\u003e 구문 변경\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.pyc\u003c/code\u003e, \u003ccode\u003e.pyo\u003c/code\u003e -\u003e \u003ccode\u003e.pyc\u003c/code\u003e, \u003ccode\u003e.pyo\u003c/code\u003e (파일 확장자)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epickle changes\u003c/code\u003e -\u003e pickle 변경 (고유 기능명)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eC API changes\u003c/code\u003e -\u003e C API 변경 (고유 기능명)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eextensions\u003c/code\u003e -\u003e 확장 모듈\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erecompiling\u003c/code\u003e -\u003e 재컴파일\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBDFL proclamation\u003c/code\u003e -\u003e BDFL 선언 (BDFL은 약어 그대로 사용)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erelease notes\u003c/code\u003e -\u003e 릴리스 노트\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enew features\u003c/code\u003e -\u003e 새로운 기능\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estandard library\u003c/code\u003e -\u003e 표준 라이브러리\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAPIs\u003c/code\u003e -\u003e API\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebackport\u003c/code\u003e -\u003e 백포트\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCVS branch\u003c/code\u003e -\u003e CVS 브랜치\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecommit message\u003c/code\u003e -\u003e 커밋 메시지\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBugfix candidate\u003c/code\u003e, \u003ccode\u003eBackport candidate\u003c/code\u003e -\u003e 'Bugfix candidate', 'Backport candidate' (영어 그대로 사용)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eX.Y\u003c/code\u003e, \u003ccode\u003eX.Y.Z\u003c/code\u003e -\u003e \u003ccode\u003eX.Y\u003c/code\u003e, \u003ccode\u003eX.Y.Z\u003c/code\u003e (버전 형식)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erelease N\u003c/code\u003e, \u003ccode\u003eN-1\u003c/code\u003e -\u003e 릴리스 \u003ccode\u003eN\u003c/code\u003e, \u003ccode\u003eN-1\u003c/code\u003e (설명과 함께 사용)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erelease2x-maint\u003c/code\u003e -\u003e \u003ccode\u003erelease2x-maint\u003c/code\u003e (브랜치 이름)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTcl system\u003c/code\u003e -\u003e Tcl 시스템\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePatch Czar\u003c/code\u003e -\u003e Patch Czar (영어 그대로 사용)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eveto power\u003c/code\u003e -\u003e 거부권\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecommit the release\u003c/code\u003e -\u003e 해당 릴리스를 커밋\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecurrent trunk of CVS\u003c/code\u003e -\u003e 현재 CVS 트렁크\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eWindows installer\u003c/code\u003e -\u003e Windows 설치 프로그램\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epython-dev\u003c/code\u003e -\u003e python-dev (메일링 리스트 이름)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epublic domain\u003c/code\u003e -\u003e 퍼블릭 도메인\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe terminology seems consistent with the guidelines.\nAll sections are translated.\nMarkdown formatting is used.\nCitations are included.\nThe obsolete status is mentioned.\u003c/p\u003e\n\u003cp\u003eThe translation is complete and follows all instructions.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-markdown\"\u003e## PEP 6 – Bug Fix Releases (버그 수정 릴리스)\n\n**저자:** Aahz \u0026#x3C;aahz at pythoncraft.com\u003e, Anthony Baxter \u0026#x3C;anthony at interlink.com.au\u003e\n**상태:** Superseded (대체됨)\n**유형:** Process (프로세스)\n**생성일:** 2001년 3월 15일\n**이력:** 2001년 3월 15일, 2001년 4월 18일, 2004년 8월 19일\n\n---\n\n**참고:** 이 PEP는 더 이상 사용되지 않습니다 (obsolete). 현재 릴리스 정책은 개발 가이드(devguide)에 문서화되어 있습니다. 릴리스 프로세스의 메커니즘에 대해서는 [PEP 101](https://peps.python.org/pep-0101/)을 참조하세요.\n\n### 요약 (Abstract)\n\nPython은 역사적으로 단일 개발 포크(fork)만을 가지고 있었으며, 릴리스는 새로운 기능 추가와 버그 수정이라는 두 가지 목적을 동시에 수행했습니다 (이러한 종류의 릴리스는 \"주요 릴리스(major releases)\"라고 불립니다). 이 PEP는 주로 버그 수정을 목적으로 구버전의 유지보수 또는 버그 수정 릴리스를 포크하는 방법을 설명합니다.\n\n이 PEP는 버그 수정 릴리스의 존재를 보장하는 것이 *아니며*, 버그 수정 릴리스가 필요한 만큼의 Python 커뮤니티 구성원이 기꺼이 작업을 수행할 의향이 있을 경우에 따를 절차만을 명시합니다.\n\n### 동기 (Motivation)\n\nSourceForge로 이전하면서 Python 개발이 가속화되었습니다. 커뮤니티의 일부에서는 이러한 가속화가 지나치다고 느끼며, 개발 주기 후반에 너무 많은 기능이 추가되었을 때 버그 수정을 위해 새 버전으로 업그레이드하는 것을 불편하게 여기는 사람들이 많습니다.\n\n이 문제에 대한 한 가지 해결책은 이전 주요 릴리스를 유지보수하여, 다음 주요 릴리스가 나올 때까지 버그 수정을 제공하는 것입니다. 이는 Python이 수백 또는 수천 대의 장비에 설치되어야 할 수도 있는 엔터프라이즈 개발에 Python을 더욱 매력적으로 만들 것입니다.\n\n### 금지 사항 (Prohibitions)\n\n버그 수정 릴리스는 다음 제한 사항을 준수해야 합니다.\n\n*   **구문 변경(syntax changes)이 없어야 합니다.**\n*   **모든 `.pyc` 및 `.pyo` 파일은 작동해야 합니다.** 주요 릴리스에서 포크된 모든 버그 수정 릴리스에서 (재생성 없이) 작동해야 합니다.\n*   **pickle 변경(pickle changes)이 없어야 합니다.**\n*   **호환되지 않는 C API 변경이 없어야 합니다.** 모든 확장 모듈(extensions)은 주요 릴리스와 동일한 포크 내의 모든 버그 수정 릴리스에서 재컴파일 없이 계속 작동해야 합니다.\n\n이러한 금지 사항 중 하나라도 위반할 경우 BDFL(Benevolent Dictator For Life)의 선언(proclamation)이 필요하며 (릴리스 노트에 눈에 띄는 경고와 함께) 고지되어야 합니다.\n\n### 완전한 금지 사항은 아니지만 지켜야 할 사항 (Not-Quite-Prohibitions)\n\n가능한 경우, 버그 수정 릴리스는 또한 다음을 준수해야 합니다.\n\n*   **새로운 기능이 없어야 합니다.** 버그 수정 릴리스의 목적은 버그를 수정하는 것이지, CVS `HEAD`의 최신 기능을 추가하는 것이 아닙니다.\n*   **고통 없는 업그레이드가 되어야 합니다.** 사용자는 2.x.y에서 2.x.(y+1)로의 업그레이드가 실행 중인 시스템을 망가뜨리지 않을 것이라고 확신할 수 있어야 합니다. 이는 버그를 수정하는 데 필요한 경우가 아니라면, 표준 라이브러리(standard library)가 동작을 변경하거나, 더 나아가 API를 변경해서는 안 된다는 것을 의미합니다.\n\n### 금지 사항의 적용 가능성 (Applicability of Prohibitions)\n\n위의 금지 사항 및 \"완전한 금지 사항은 아니지만 지켜야 할 사항\"은 최종 릴리스에서 버그 수정 릴리스로 (예: 2.4에서 2.4.1로), 그리고 한 시리즈 내에서 한 버그 수정 릴리스에서 다음 버그 수정 릴리스로 (예: 2.4.1에서 2.4.2로) 모두 적용됩니다.\n\n이 PEP에 나열된 금지 사항을 따르면, 커뮤니티는 버그 수정 릴리스가 고통 없고 안전한 업그레이드라는 점에 만족할 것입니다.\n\n### 버그 수정 릴리스 촉진 (Helping the Bug Fix Releases Happen)\n\n버그 수정 릴리스 프로세스를 돕는 몇 가지 지침은 다음과 같습니다.\n\n*   **버그 수정을 백포트(Backport)하세요.** 버그를 수정했고 그것이 적절하다고 판단되면, 현재 버그 수정 릴리스를 위한 CVS 브랜치로 백포트하세요. 스스로 백포트할 의향이 없거나 할 수 없는 경우, 커밋 메시지에 'Bugfix candidate' 또는 'Backport candidate'와 같은 문구로 메모를 남기세요. 확실하지 않다면 질문하세요.\n*   **현재 버그 수정 릴리스를 관리하는 사람에게 특정 수정 사항이 적절한지 문의하세요.**\n*   **버그 수정 릴리스에서 특히 수정되기를 원하는 특정 버그가 있다면, 적극적으로 나서서 해결되도록 노력하세요.** 버그 수정 릴리스가 예정된 시점의 48시간 전까지 기다렸다가 버그 수정을 포함해달라고 요청하지 마세요.\n\n### 버전 번호 (Version Numbers)\n\nPython 2.0부터 모든 주요 릴리스는 `X.Y` 형식의 버전 번호를 가져야 합니다. 버그 수정 릴리스는 항상 `X.Y.Z` 형식이어야 합니다.\n\n현재 개발 중인 주요 릴리스는 릴리스 `N`으로 지칭됩니다. 막 릴리스된 주요 버전은 `N-1`으로 지칭됩니다.\n\nCVS에서 버그 수정 릴리스는 브랜치에서 이루어집니다. 2.x 릴리스의 경우 브랜치 이름은 `release2x-maint`입니다. 예를 들어, 2.3 유지보수 릴리스의 브랜치는 `release23-maint`입니다.\n\n### 절차 (Procedure)\n\n버그 수정 릴리스를 관리하는 프로세스는 부분적으로 Tcl 시스템[1]을 모델로 합니다.\n\n`Patch Czar`는 버그 수정 릴리스를 위한 BDFL의 대응자입니다. 그러나 BDFL 및 지정된 임명자들은 개별 패치에 대한 거부권(veto power)을 보유합니다. `Patch Czar`는 단일 개발 브랜치만 관리할 수도 있습니다. 2.3.x 및 2.4.x 릴리스를 다른 사람이 유지보수하는 것도 충분히 가능합니다.\n\n개별 패치가 현재 CVS 트렁크에 기여될 때, 각 패치 커미터는 해당 패치가 버그 수정 릴리스에 포함하기에 적합한 버그 수정인지 고려하도록 요청받습니다. 패치가 적합하다고 판단되면, 커미터는 해당 릴리스를 유지보수 브랜치에 커밋하거나, 커밋 메시지에 패치를 표시할 수 있습니다.\n\n또한, Python 커뮤니티의 누구든지 패치 포함을 제안할 수 있습니다. 패치는 버그 수정 릴리스를 위해 특별히 제출될 수 있으며, [PEP 3](https://peps.python.org/pep-0003/)의 지침을 따라야 합니다. 그러나 일반적으로 특정 릴리스의 버그는 브랜치뿐만 아니라 `HEAD`에서도 수정되는 것이 더 좋습니다.\n\n`Patch Czar`는 릴리스를 보증하기에 충분한 수의 패치가 있을 때 결정합니다. 릴리스는 Windows 설치 프로그램(installer)을 포함하여 패키징되고 공개됩니다. 새로운 버그가 발견되면 즉시 수정하고 새로운 버그 수정 릴리스를 (버전 번호를 증분하여) 공개해야 합니다. 2.3.x 주기 동안 `Patch Czar` (Anthony)는 약 6개월마다 릴리스를 시도했지만, 이는 향후 릴리스에 어떤 식으로든 구속력 있는 것으로 간주되어서는 안 됩니다.\n\n버그 수정 릴리스는 약 6개월 간격으로 발생할 것으로 예상됩니다. 그러나 이는 단지 지침일 뿐입니다. 명백히 주요 버그가 발견되면 버그 수정 릴리스가 더 빨리 적절할 수 있습니다. 일반적으로 `N-1` 릴리스만이 항상 활발하게 유지보수될 것입니다. 즉, Python 2.4 개발 중에는 Python 2.3이 버그 수정 릴리스를 받습니다. 그러나 자격을 갖춘 사람이 이전 릴리스의 유지보수 작업을 계속하기를 원한다면, 그들을 격려해야 합니다.\n\n### Patch Czar 이력 (Patch Czar History)\n\n*   Anthony Baxter: 2.3.1 ~ 2.3.4의 Patch Czar\n*   Barry Warsaw: 2.2.3의 Patch Czar\n*   Guido van Rossum: 2.2.2의 Patch Czar\n*   Michael Hudson: 2.2.1의 Patch Czar\n*   Anthony Baxter: 2.1.2 및 2.1.3의 Patch Czar\n*   Thomas Wouters: 2.1.1의 Patch Czar\n*   Moshe Zadka: 2.0.1의 Patch Czar\n\n### 이력 (History)\n\n이 PEP는 `comp.lang.python`에서 제안으로 시작되었습니다. 초기 버전은 `N` 릴리스와 동시에 릴리스될 `N-1` 릴리스에 대한 단일 패치를 제안했습니다. 초기 버전은 또한 엄격한 버그 수정 정책을 고수할 것을 주장했습니다.\n\nBDFL 및 다른 사람들로부터의 피드백에 따라, 확장된 버그 수정 릴리스 주기(이전 주요 릴리스도 패치를 얻을 수 있도록 허용)를 포함하고 엄격한 버그 수정 요구 사항을 완화한 (주로 버그 수정 또는 기능으로 논쟁의 여지가 있는 PEP 235의 예시 때문에) 초안 PEP가 작성되었습니다.\n\n이후 토론은 주로 `python-dev`로 옮겨졌고, BDFL은 마침내 Tcl의 버그 수정 릴리스 프로세스를 기반으로 하는 선언을 발표했습니다. 이는 본질적으로 `N-1` 릴리스와 버그 수정만을 다루는 원래 제안으로 돌아갔지만, 릴리스 `N`이 게시될 때까지 여러 버그 수정 릴리스를 허용했습니다.\n\nAnthony Baxter는 2.3 릴리스 주기에서 얻은 교훈을 바탕으로 이 PEP를 수정했습니다.\n\n### 참고 자료 (References)\n\n[1] Tcl 시스템 관련 문서: [http://www.tcl.tk/cgi-bin/tct/tip/28.html](http://www.tcl.tk/cgi-bin/tct/tip/28.html)\n\n### 저작권 (Copyright)\n\n이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.\n```## PEP 6 – Bug Fix Releases (버그 수정 릴리스)\n\n**저자:** Aahz \u0026#x3C;aahz at pythoncraft.com\u003e, Anthony Baxter \u0026#x3C;anthony at interlink.com.au\u003e\n**상태:** Superseded (대체됨)\n**유형:** Process (프로세스)\n**생성일:** 2001년 3월 15일\n**이력:** 2001년 3월 15일, 2001년 4월 18일, 2004년 8월 19일\n\n---\n\n**참고:** 이 PEP는 더 이상 사용되지 않습니다 (obsolete). 현재 릴리스 정책은 개발 가이드(devguide)에 문서화되어 있습니다. 릴리스 프로세스의 메커니즘에 대해서는 [PEP 101](https://peps.python.org/pep-0101/)을 참조하세요.\n\n### 요약 (Abstract)\n\nPython은 역사적으로 단일 개발 포크(fork)만을 가지고 있었으며, 릴리스는 새로운 기능 추가와 버그 수정이라는 두 가지 목적을 동시에 수행했습니다 (이러한 종류의 릴리스는 \"주요 릴리스(major releases)\"라고 불립니다). 이 PEP는 주로 버그 수정을 목적으로 구버전의 유지보수 또는 버그 수정 릴리스를 포크하는 방법을 설명합니다.\n\n이 PEP는 버그 수정 릴리스의 존재를 보장하는 것이 *아니며*, 버그 수정 릴리스가 필요한 만큼의 Python 커뮤니티 구성원이 기꺼이 작업을 수행할 의향이 있을 경우에 따를 절차만을 명시합니다.\n\n### 동기 (Motivation)\n\nSourceForge로 이전하면서 Python 개발이 가속화되었습니다. 커뮤니티의 일부에서는 이러한 가속화가 지나치다고 느끼며, 개발 주기 후반에 너무 많은 기능이 추가되었을 때 버그 수정을 위해 새 버전으로 업그레이드하는 것을 불편하게 여기는 사람들이 많습니다.\n\n이 문제에 대한 한 가지 해결책은 이전 주요 릴리스를 유지보수하여, 다음 주요 릴리스가 나올 때까지 버그 수정을 제공하는 것입니다. 이는 Python이 수백 또는 수천 대의 장비에 설치되어야 할 수도 있는 엔터프라이즈 개발에 Python을 더욱 매력적으로 만들 것입니다.\n\n### 금지 사항 (Prohibitions)\n\n버그 수정 릴리스는 다음 제한 사항을 준수해야 합니다.\n\n*   **구문 변경(syntax changes)이 없어야 합니다.**\n*   **모든 `.pyc` 및 `.pyo` 파일은 작동해야 합니다.** 주요 릴리스에서 포크된 모든 버그 수정 릴리스에서 (재생성 없이) 작동해야 합니다.\n*   **pickle 변경(pickle changes)이 없어야 합니다.**\n*   **호환되지 않는 C API 변경이 없어야 합니다.** 모든 확장 모듈(extensions)은 주요 릴리스와 동일한 포크 내의 모든 버그 수정 릴리스에서 재컴파일 없이 계속 작동해야 합니다.\n\n이러한 금지 사항 중 하나라도 위반할 경우 BDFL(Benevolent Dictator For Life)의 선언(proclamation)이 필요하며 (릴리스 노트에 눈에 띄는 경고와 함께) 고지되어야 합니다.\n\n### 완전한 금지 사항은 아니지만 지켜야 할 사항 (Not-Quite-Prohibitions)\n\n가능한 경우, 버그 수정 릴리스는 또한 다음을 준수해야 합니다.\n\n*   **새로운 기능이 없어야 합니다.** 버그 수정 릴리스의 목적은 버그를 수정하는 것이지, CVS `HEAD`의 최신 기능을 추가하는 것이 아닙니다.\n*   **고통 없는 업그레이드가 되어야 합니다.** 사용자는 2.x.y에서 2.x.(y+1)로의 업그레이드가 실행 중인 시스템을 망가뜨리지 않을 것이라고 확신할 수 있어야 합니다. 이는 버그를 수정하는 데 필요한 경우가 아니라면, 표준 라이브러리(standard library)가 동작을 변경하거나, 더 나아가 API를 변경해서는 안 된다는 것을 의미합니다.\n\n### 금지 사항의 적용 가능성 (Applicability of Prohibitions)\n\n위의 금지 사항 및 \"완전한 금지 사항은 아니지만 지켜야 할 사항\"은 최종 릴리스에서 버그 수정 릴리스로 (예: 2.4에서 2.4.1로), 그리고 한 시리즈 내에서 한 버그 수정 릴리스에서 다음 버그 수정 릴리스로 (예: 2.4.1에서 2.4.2로) 모두 적용됩니다.\n\n이 PEP에 나열된 금지 사항을 따르면, 커뮤니티는 버그 수정 릴리스가 고통 없고 안전한 업그레이드라는 점에 만족할 것입니다.\n\n### 버그 수정 릴리스 촉진 (Helping the Bug Fix Releases Happen)\n\n버그 수정 릴리스 프로세스를 돕는 몇 가지 지침은 다음과 같습니다.\n\n*   **버그 수정을 백포트(Backport)하세요.** 버그를 수정했고 그것이 적절하다고 판단되면, 현재 버그 수정 릴리스를 위한 CVS 브랜치로 백포트하세요. 스스로 백포트할 의향이 없거나 할 수 없는 경우, 커밋 메시지에 'Bugfix candidate' 또는 'Backport candidate'와 같은 문구로 메모를 남기세요. 확실하지 않다면 질문하세요.\n*   **현재 버그 수정 릴리스를 관리하는 사람에게 특정 수정 사항이 적절한지 문의하세요.**\n*   **버그 수정 릴리스에서 특히 수정되기를 원하는 특정 버그가 있다면, 적극적으로 나서서 해결되도록 노력하세요.** 버그 수정 릴리스가 예정된 시점의 48시간 전까지 기다렸다가 버그 수정을 포함해달라고 요청하지 마세요.\n\n### 버전 번호 (Version Numbers)\n\nPython 2.0부터 모든 주요 릴리스는 `X.Y` 형식의 버전 번호를 가져야 합니다. 버그 수정 릴리스는 항상 `X.Y.Z` 형식이어야 합니다.\n\n현재 개발 중인 주요 릴리스는 릴리스 `N`으로 지칭됩니다. 막 릴리스된 주요 버전은 `N-1`으로 지칭됩니다.\n\nCVS에서 버그 수정 릴리스는 브랜치에서 이루어집니다. 2.x 릴리스의 경우 브랜치 이름은 `release2x-maint`입니다. 예를 들어, 2.3 유지보수 릴리스의 브랜치는 `release23-maint`입니다.\n\n### 절차 (Procedure)\n\n버그 수정 릴리스를 관리하는 프로세스는 부분적으로 Tcl 시스템을 모델로 합니다.\n\n`Patch Czar`는 버그 수정 릴리스를 위한 BDFL의 대응자입니다. 그러나 BDFL 및 지정된 임명자들은 개별 패치에 대한 거부권(veto power)을 보유합니다. `Patch Czar`는 단일 개발 브랜치만 관리할 수도 있습니다. 2.3.x 및 2.4.x 릴리스를 다른 사람이 유지보수하는 것도 충분히 가능합니다.\n\n개별 패치가 현재 CVS 트렁크에 기여될 때, 각 패치 커미터는 해당 패치가 버그 수정 릴리스에 포함하기에 적합한 버그 수정인지 고려하도록 요청받습니다. 패치가 적합하다고 판단되면, 커미터는 해당 릴리스를 유지보수 브랜치에 커밋하거나, 커밋 메시지에 패치를 표시할 수 있습니다.\n\n또한, Python 커뮤니티의 누구든지 패치 포함을 제안할 수 있습니다. 패치는 버그 수정 릴리스를 위해 특별히 제출될 수 있으며, [PEP 3](https://peps.python.org/pep-0003/)의 지침을 따라야 합니다. 그러나 일반적으로 특정 릴리스의 버그는 브랜치뿐만 아니라 `HEAD`에서도 수정되는 것이 더 좋습니다.\n\n`Patch Czar`는 릴리스를 보증하기에 충분한 수의 패치가 있을 때 결정합니다. 릴리스는 Windows 설치 프로그램(installer)을 포함하여 패키징되고 공개됩니다. 새로운 버그가 발견되면 즉시 수정하고 새로운 버그 수정 릴리스를 (버전 번호를 증분하여) 공개해야 합니다. 2.3.x 주기 동안 `Patch Czar` (Anthony)는 약 6개월마다 릴리스를 시도했지만, 이는 향후 릴리스에 어떤 식으로든 구속력 있는 것으로 간주되어서는 안 됩니다.\n\n버그 수정 릴리스는 약 6개월 간격으로 발생할 것으로 예상됩니다. 그러나 이는 단지 지침일 뿐입니다. 명백히 주요 버그가 발견되면 버그 수정 릴리스가 더 빨리 적절할 수 있습니다. 일반적으로 `N-1` 릴리스만이 항상 활발하게 유지보수될 것입니다. 즉, Python 2.4 개발 중에는 Python 2.3이 버그 수정 릴리스를 받습니다. 그러나 자격을 갖춘 사람이 이전 릴리스의 유지보수 작업을 계속하기를 원한다면, 그들을 격려해야 합니다.\n\n### Patch Czar 이력 (Patch Czar History)\n\n*   Anthony Baxter: 2.3.1 ~ 2.3.4의 Patch Czar\n*   Barry Warsaw: 2.2.3의 Patch Czar\n*   Guido van Rossum: 2.2.2의 Patch Czar\n*   Michael Hudson: 2.2.1의 Patch Czar\n*   Anthony Baxter: 2.1.2 및 2.1.3의 Patch Czar\n*   Thomas Wouters: 2.1.1의 Patch Czar\n*   Moshe Zadka: 2.0.1의 Patch Czar\n\n### 이력 (History)\n\n이 PEP는 `comp.lang.python`에서 제안으로 시작되었습니다. 초기 버전은 `N` 릴리스와 동시에 릴리스될 `N-1` 릴리스에 대한 단일 패치를 제안했습니다. 초기 버전은 또한 엄격한 버그 수정 정책을 고수할 것을 주장했습니다.\n\nBDFL 및 다른 사람들로부터의 피드백에 따라, 확장된 버그 수정 릴리스 주기(이전 주요 릴리스도 패치를 얻을 수 있도록 허용)를 포함하고 엄격한 버그 수정 요구 사항을 완화한 (주로 버그 수정 또는 기능으로 논쟁의 여지가 있는 PEP 235의 예시 때문에) 초안 PEP가 작성되었습니다.\n\n이후 토론은 주로 `python-dev`로 옮겨졌고, BDFL은 마침내 Tcl의 버그 수정 릴리스 프로세스를 기반으로 하는 선언을 발표했습니다. 이는 본질적으로 `N-1` 릴리스와 버그 수정만을 다루는 원래 제안으로 돌아갔지만, 릴리스 `N`이 게시될 때까지 여러 버그 수정 릴리스를 허용했습니다.\n\nAnthony Baxter는 2.3 릴리스 주기에서 얻은 교훈을 바탕으로 이 PEP를 수정했습니다.\n\n### 참고 자료 (References)\n\n Tcl 시스템 관련 문서: [http://www.tcl.tk/cgi-bin/tct/tip/28.html](http://www.tcl.tk/cgi-bin/tct/tip/28.html)\n\n### 저작권 (Copyright)\n\n이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.\n\n\u003e ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\n\u003c/code\u003e\u003c/pre\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Superseded] PEP 6 - Bug Fix Releases\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 15:42:30+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>