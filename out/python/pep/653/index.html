<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-287dd7aad5349a53.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1599<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Draft] PEP 653 - Precise Semantics for Pattern Matching</h1><div class="page__meta"><time dateTime="2025-09-27 09:52:27+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0653/">PEP 653 - Precise Semantics for Pattern Matching</a></p>
<p><strong>상태:</strong> Draft | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 09-Feb-2021</p>
</blockquote>
<h1>PEP 653 – 패턴 매칭을 위한 정밀한 의미론</h1>
<p><strong>저자</strong>: Mark Shannon
<strong>상태</strong>: Draft (초안)
<strong>유형</strong>: Standards Track (표준 트랙)
<strong>생성일</strong>: 2021년 2월 9일
<strong>개정 이력</strong>: 2021년 2월 18일</p>
<hr>
<h2>요약 (Abstract)</h2>
<p>이 PEP는 PEP 634의 일반적인 개념을 존중하면서도, 더 정밀하고, 이해하기 쉬우며, 더 빠른 패턴 매칭 의미론을 제안합니다.</p>
<p>객체 모델은 PEP 634의 <code>__match_args__</code> 속성 외에 <code>__match_container__</code> 및 <code>__match_class__</code>라는 두 개의 특수 (던더) 속성으로 확장되어 패턴 매칭을 지원합니다. 이 두 가지 새로운 속성은 정수여야 하며, <code>__match_args__</code>는 고유한 문자열의 튜플이어야 합니다.</p>
<p>이 PEP를 통해:</p>
<ul>
<li>패턴 매칭의 의미론이 더욱 명확해져, 패턴을 추론하기 쉬워집니다.</li>
<li>패턴 매칭을 더 효율적으로 구현할 수 있습니다.</li>
<li>클래스가 어떤 패턴과 매칭될지 더 세밀하게 제어할 수 있게 되어 복잡한 클래스에서도 패턴 매칭이 더욱 유용해집니다.</li>
</ul>
<h2>동기 (Motivation)</h2>
<p>PEP 634에 설명된 파이썬의 패턴 매칭은 Python 3.10에 추가될 예정입니다. 아쉽게도 PEP 634는 의미론에 대해 충분히 정밀하지 않으며, 클래스가 패턴과 어떻게 매칭될지에 대한 충분한 제어를 허용하지 않습니다.</p>
<h3>정밀한 의미론 (Precise semantics)</h3>
<p>PEP 634는 '정의되지 않은 동작(undefined behavior)'에 대한 섹션을 명시적으로 포함하고 있습니다. C와 같은 언어에서는 많은 양의 정의되지 않은 동작이 허용될 수 있지만, 파이썬에서는 이를 최소화해야 합니다. 파이썬의 패턴 매칭은 표현력이나 성능 손실 없이 더 정밀하게 정의될 수 있습니다.</p>
<h3>클래스 매칭에 대한 향상된 제어 (Improved control over class matching)</h3>
<p>PEP 634는 클래스가 시퀀스(sequence) 또는 매핑(mapping)인지 여부를 <code>collections.abc</code>에 위임합니다. 모든 시퀀스로 간주될 수 있는 클래스가 <code>collections.abc.Sequence</code>의 서브클래스로 등록되는 것은 아닙니다. 이 PEP는 <code>collections.abc.Sequence</code>의 모든 메커니즘을 사용하지 않고도 시퀀스 패턴과 매칭될 수 있도록 합니다.</p>
<p>PEP 634는 일부 내장 클래스에 "self" 매치라는 특별한 형태의 매칭 권한을 부여합니다. 예를 들어, <code>list(x)</code> 패턴은 리스트와 매칭되고 리스트를 <code>x</code>에 할당합니다. 클래스가 어떤 종류의 패턴과 매칭될지 선택할 수 있도록 함으로써 다른 클래스도 이 형태를 사용할 수 있습니다.</p>
<p>예를 들어, <code>sympy</code>를 사용하여 다음과 같이 작성하고 싶을 수 있습니다:</p>
<pre><code class="language-python"># a*a == a**2
case Mul(args=[Symbol(a), Symbol(b)]) if a == b:
    return Pow(a, 2)
</code></pre>
<p>이는 <code>sympy</code> 클래스 <code>Symbol</code>이 "self" 매칭을 해야 함을 의미합니다. <code>sympy</code>가 PEP 634로 이 패턴을 지원하는 것은 가능하지만 다소 까다롭습니다. 이 PEP를 사용하면 매우 쉽게 구현할 수 있습니다.</p>
<h3>견고성 (Robustness)</h3>
<p>이 PEP를 사용하면 패턴 매칭 중 속성 접근이 잘 정의되고 확정적(deterministic)이 됩니다. 이는 객체 관계형 매퍼(object-relational mappers)와 같이 숨겨진 부작용이 있는 객체를 매칭할 때 패턴 매칭의 오류 발생 가능성을 줄여줍니다. 객체는 자체적인 분해(deconstruction)에 대해 더 많은 제어권을 가지게 되며, 이는 속성 접근에 부작용이 있을 경우 의도하지 않은 결과를 방지하는 데 도움이 될 수 있습니다.</p>
<p>PEP 634는 값이 어떤 패턴과 매칭될 수 있는지 결정할 때 <code>collections.abc</code> 모듈에 의존하며, 필요한 경우 암묵적으로 이를 임포트합니다. 이 PEP는 그러한 임포트로 인한 예상치 못한 임포트 오류 및 오해의 소지가 있는 감사(audit) 이벤트를 제거할 것입니다.</p>
<h3>효율적인 구현 (Efficient implementation)</h3>
<p>이 PEP에서 제안하는 의미론은 부분적으로 정밀한 의미론을 가지고 있고 부분적으로 객체 모델을 사용하기 때문에 효율적인 구현을 가능하게 할 것입니다.</p>
<p>정밀한 의미론을 통해 어떤 코드 변환이 올바른지 추론할 수 있으므로 최적화를 효과적으로 적용할 수 있습니다.</p>
<p>객체 모델은 파이썬의 핵심 부분이므로, 구현체들은 이미 특수 속성(<code>special attribute</code>) 조회를 효율적으로 처리합니다. 특수 속성을 조회하는 것은 추상 베이스 클래스에 대한 서브클래스 테스트를 수행하는 것보다 훨씬 빠릅니다.</p>
<h2>근거 (Rationale)</h2>
<p>객체 모델과 특수 메서드(special methods)는 파이썬 언어의 핵심입니다. 결과적으로 구현체들은 이를 잘 지원합니다. 패턴 매칭에 특수 속성을 사용하면 패턴 매칭을 나머지 구현과 잘 통합되는 방식으로 구현할 수 있으므로 유지 관리가 더 쉽고 성능이 더 좋을 가능성이 있습니다.</p>
<p><code>match</code> 문은 일련의 패턴 매칭을 수행합니다. 일반적으로 패턴을 매칭하는 데는 세 가지 부분이 있습니다:</p>
<ol>
<li>이 값이 이 종류의 패턴과 매칭될 수 있는가?</li>
<li>분해될 때, 이 값이 이 특정 패턴과 매칭되는가?</li>
<li>가드(guard)가 참인가?</li>
</ol>
<p>값이 특정 종류의 패턴과 매칭될 수 있는지 확인하기 위해 <code>__match_container__</code> 및 <code>__match_class__</code> 속성을 추가합니다. 이를 통해 값의 종류를 효율적으로 결정할 수 있습니다.</p>
<h2>명세 (Specification)</h2>
<h3>객체 모델에 대한 추가 사항 (Additions to the object model)</h3>
<p><code>__match_container__</code> 및 <code>__match_class__</code> 속성이 <code>object</code>에 추가될 것입니다. <code>__match_container__</code>는 매핑(mapping) 또는 시퀀스(sequence) 패턴과 매칭되기를 원하는 클래스에 의해 오버라이드(override)되어야 합니다. <code>__match_class__</code>는 클래스 패턴을 매칭할 때 기본 동작을 변경하고자 하는 클래스에 의해 오버라이드되어야 합니다.</p>
<p><code>__match_container__</code>는 정수여야 하며 다음 중 정확히 하나여야 합니다:</p>
<ul>
<li><code>0</code></li>
<li><code>MATCH_SEQUENCE = 1</code></li>
<li><code>MATCH_MAPPING = 2</code></li>
</ul>
<p><code>MATCH_SEQUENCE</code>는 클래스의 인스턴스가 시퀀스 패턴과 매칭될 수 있음을 나타내는 데 사용됩니다.
<code>MATCH_MAPPING</code>은 클래스의 인스턴스가 매핑 패턴과 매칭될 수 있음을 나타내는 데 사용됩니다.</p>
<p><code>__match_class__</code>는 정수여야 하며 다음 중 정확히 하나여야 합니다:</p>
<ul>
<li><code>0</code></li>
<li><code>MATCH_SELF = 8</code></li>
</ul>
<p><code>MATCH_SELF</code>는 단일 위치 인자(positional argument) 클래스 패턴의 경우, 피사체(subject)가 분해되지 않고 사용될 것임을 나타내는 데 사용됩니다.</p>
<p><strong>참고</strong>: 이 문서의 나머지 부분에서는 위의 값들을 이름으로만 참조할 것입니다. 파이썬과 C 모두를 위한 심볼릭 상수(symbolic constants)가 제공될 것이며, 이 값들은 절대 변경되지 않을 것입니다.</p>
<p><code>object</code>는 특수 속성에 대해 다음 값을 가집니다:</p>
<pre><code class="language-python">__match_container__ = 0
__match_class__ = 0
__match_args__ = ()
</code></pre>
<p>이러한 특수 속성은 일반적인 방식으로 상속됩니다.</p>
<p><code>__match_args__</code>가 오버라이드되면, 고유한 문자열의 튜플을 포함해야 합니다. 비어 있을 수도 있습니다.</p>
<p><strong>참고</strong>: <code>__match_args__</code>는 PEP 634에 명시된 대로 <code>dataclasses</code> 및 <code>named tuples</code>에 대해 자동으로 생성됩니다.</p>
<p>패턴 매칭 구현은 이러한 속성 중 어느 것도 명세대로 동작하는지 확인할 필요가 없습니다. <code>__match_container__</code>, <code>__match_class__</code> 또는 <code>__match_args__</code>의 값이 명세대로가 아닐 경우, 구현은 어떤 예외도 발생시키거나 잘못된 패턴과 매칭될 수 있습니다. 물론, 구현체들은 이러한 속성을 확인하고 효율적으로 수행할 수 있다면 의미 있는 오류 메시지를 제공할 수 있습니다.</p>
<h3>매칭 프로세스의 의미론 (Semantics of the matching process)</h3>
<p>다음에서, <code>$var</code> 형태의 모든 변수는 임시 변수이며 파이썬 프로그램에는 보이지 않습니다. 이들은 인트로스펙션(introspection)을 통해 보일 수 있지만, 이는 구현 세부 사항이므로 의존해서는 안 됩니다. 의사(pseudo) 문장 <code>FAIL</code>은 이 패턴에 대한 매칭이 실패했으며 다음 패턴으로 넘어가야 함을 나타내는 데 사용됩니다. 제어가 <code>FAIL</code>에 도달하지 않고 번역의 끝에 도달하면, 매칭된 것이며, 이후의 패턴은 무시됩니다.</p>
<p><code>$ALL_CAPS</code> 형태의 변수는 구문 요소를 담고 있는 메타 변수(meta-variable)이며, 일반 변수가 아닙니다. 따라서 <code>$VARS = $items</code>는 <code>$items</code>를 <code>$VARS</code>에 할당하는 것이 아니라, <code>$items</code>를 <code>$VARS</code>가 담고 있는 변수들로 언패킹(unpacking)하는 것입니다. 예를 들어, 추상 구문 <code>case [$VARS]:</code>와 구체적인 구문 <code>case [a, b]:</code>에서 <code>$VARS</code>는 변수 <code>(a, b)</code>를 담고 있는 것이지, 그 변수들의 값을 담고 있는 것이 아닙니다.</p>
<p>의사 함수 <code>QUOTE</code>는 변수를 받아 그 변수의 이름을 반환합니다. 예를 들어, 메타 변수 <code>$VAR</code>이 변수 <code>foo</code>를 담고 있다면 <code>QUOTE($VAR) == "foo"</code>입니다.</p>
<p>아래 나열된 모든 추가 코드는 원본 소스에 없는 것이며, PEP 626에 따라 라인 이벤트(line events)를 발생시키지 않습니다.</p>
<h4>서문 (Preamble)</h4>
<p>어떤 패턴도 매칭되기 전에, 매칭될 표현식이 평가됩니다:</p>
<pre><code class="language-python">match expr:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">$value = expr
</code></pre>
<h4>캡처 패턴 (Capture patterns)</h4>
<p>캡처 패턴은 항상 매칭됩니다. 따라서 피할 수 없는(irrefutable) 매치:</p>
<pre><code class="language-python">case capture_var:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">capture_var = $value
</code></pre>
<h4>와일드카드 패턴 (Wildcard patterns)</h4>
<p>와일드카드 패턴은 항상 매칭됩니다:</p>
<pre><code class="language-python">case _:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python"># 코드 없음 -- 자동으로 매칭됨
</code></pre>
<h4>리터럴 패턴 (Literal Patterns)</h4>
<p>리터럴 패턴:</p>
<pre><code class="language-python">case LITERAL:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">if $value != LITERAL: FAIL
</code></pre>
<p>단, 리터럴이 <code>None</code>, <code>True</code>, <code>False</code> 중 하나일 때는 다음으로 번역됩니다:</p>
<pre><code class="language-python">if $value is not LITERAL: FAIL
</code></pre>
<h4>값 패턴 (Value Patterns)</h4>
<p>값 패턴:</p>
<pre><code class="language-python">case value.pattern:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">if $value != value.pattern: FAIL
</code></pre>
<h4>시퀀스 패턴 (Sequence Patterns)</h4>
<p>스타 패턴(<code>*</code>)을 포함하지 않는 패턴:</p>
<pre><code class="language-python">case [$VARS]:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">$kind = type($value).__match_container__
if $kind != MATCH_SEQUENCE: FAIL
if len($value) != len($VARS): FAIL
$VARS = $value
</code></pre>
<p>예시:</p>
<pre><code class="language-python">case [a, b] if a is b:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">$kind = type($value).__match_container__
if $kind != MATCH_SEQUENCE: FAIL
if len($value) != 2: FAIL
a, b = $value
if not a is b: FAIL
</code></pre>
<p>스타 패턴을 포함하는 패턴:</p>
<pre><code class="language-python">case [$VARS]
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">$kind = type($value).__match_container__
if $kind != MATCH_SEQUENCE: FAIL
if len($value) &#x3C; len($VARS): FAIL
$VARS = $value # $VARS에는 스타 표현식이 포함됩니다.
</code></pre>
<p>예시:</p>
<pre><code class="language-python">case [a, *b, c]:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">$kind = type($value).__match_container__
if $kind != MATCH_SEQUENCE: FAIL
if len($value) &#x3C; 2: FAIL
a, *b, c = $value
</code></pre>
<h4>매핑 패턴 (Mapping Patterns)</h4>
<p>더블 스타 패턴(<code>**</code>)을 포함하지 않는 패턴:</p>
<pre><code class="language-python">case {$KEYWORD_PATTERNS}:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">$sentinel = object()
$kind = type($value).__match_container__
if $kind != MATCH_MAPPING: FAIL
# $KEYWORD_PATTERNS는 이름들을 변수들에 매핑하는 메타 변수입니다.
for $KEYWORD in $KEYWORD_PATTERNS:
    $tmp = $value.get(QUOTE($KEYWORD), $sentinel)
    if $tmp is $sentinel: FAIL
    $KEYWORD_PATTERNS[$KEYWORD] = $tmp
</code></pre>
<p>예시:</p>
<pre><code class="language-python">case {"x": x, "y": y} if x > 2:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">$kind = type($value).__match_container__
if $kind != MATCH_MAPPING: FAIL
$tmp = $value.get("x", $sentinel)
if $tmp is $sentinel: FAIL
x = $tmp
$tmp = $value.get("y", $sentinel)
if $tmp is $sentinel: FAIL
y = $tmp
if not x > 2: FAIL
</code></pre>
<p>더블 스타 패턴을 포함하는 패턴:</p>
<pre><code class="language-python">case {$KEYWORD_PATTERNS, **$DOUBLE_STARRED_PATTERN}:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">$kind = type($value).__match_container__
if $kind != MATCH_MAPPING: FAIL
# $KEYWORD_PATTERNS는 이름들을 변수들에 매핑하는 메타 변수입니다.
$tmp = dict($value)
if not $tmp.keys() >= $KEYWORD_PATTERNS.keys(): FAIL:
for $KEYWORD in $KEYWORD_PATTERNS:
    $KEYWORD_PATTERNS[$KEYWORD] = $tmp.pop(QUOTE($KEYWORD))
$DOUBLE_STARRED_PATTERN = $tmp
</code></pre>
<p>예시:</p>
<pre><code class="language-python">case {"x": x, "y": y, **z}:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">$kind = type($value).__match_container__
if $kind != MATCH_MAPPING: FAIL
$tmp = dict($value)
if not $tmp.keys() >= {"x", "y"}: FAIL
x = $tmp.pop("x")
y = $tmp.pop("y")
z = $tmp
</code></pre>
<h4>클래스 패턴 (Class Patterns)</h4>
<p>인자 없는 클래스 패턴:</p>
<pre><code class="language-python">case ClsName():
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">if not isinstance($value, ClsName): FAIL
</code></pre>
<p>단일 위치 패턴(single positional pattern)을 가진 클래스 패턴:</p>
<pre><code class="language-python">case ClsName($VAR):
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">$kind = type($value).__match_class__
if $kind == MATCH_SELF:
    if not isinstance($value, ClsName): FAIL
    $VAR = $value
else:
    # 다른 위치 전용 클래스 패턴과 동일
</code></pre>
<p>위치 전용 클래스 패턴 (Positional-only class pattern):</p>
<pre><code class="language-python">case ClsName($VARS):
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">if not isinstance($value, ClsName): FAIL
$attrs = ClsName.__match_args__
if len($attrs) &#x3C; len($VARS): raise TypeError(...)
try:
    for i, $VAR in enumerate($VARS):
        $VAR = getattr($value, $attrs[i])
except AttributeError:
    FAIL
</code></pre>
<p>예시:</p>
<pre><code class="language-python">match ClsName(x, y):
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">if not isinstance($value, ClsName): FAIL
$attrs = ClsName.__match_args__
if len($attrs) &#x3C; 2: FAIL
try:
    x = getattr($value, $attrs[0])
    y = getattr($value, $attrs[1])
except AttributeError:
    FAIL
</code></pre>
<p>모든 키워드 패턴(keyword patterns)을 가진 클래스 패턴:</p>
<pre><code class="language-python">case ClsName($KEYWORD_PATTERNS):
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">if not isinstance($value, ClsName): FAIL
try:
    for $KEYWORD in $KEYWORD_PATTERNS:
        $tmp = getattr($value, QUOTE($KEYWORD))
        $KEYWORD_PATTERNS[$KEYWORD] = $tmp
except AttributeError:
    FAIL
</code></pre>
<p>예시:</p>
<pre><code class="language-python">match ClsName(a=x, b=y):
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">if not isinstance($value, ClsName): FAIL
try:
    x = $value.a
    y = $value.b
except AttributeError:
    FAIL
</code></pre>
<p>위치 및 키워드 패턴을 가진 클래스 패턴:</p>
<pre><code class="language-python">case ClsName($VARS, $KEYWORD_PATTERNS):
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">if not isinstance($value, ClsName): FAIL
$attrs = ClsName.__match_args__
if len($attrs) &#x3C; len($VARS): raise TypeError(...)
$pos_attrs = $attrs[:len($VARS)]
try:
    for i, $VAR in enumerate($VARS):
        $VAR = getattr($value, $attrs[i])
    for $KEYWORD in $KEYWORD_PATTERNS:
        $name = QUOTE($KEYWORD)
        if $name in $pos_attrs: raise TypeError(...)
        $KEYWORD_PATTERNS[$KEYWORD] = getattr($value, $name)
except AttributeError:
    FAIL
</code></pre>
<p>예시:</p>
<pre><code class="language-python">match ClsName(x, a=y):
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">if not isinstance($value, ClsName): FAIL
$attrs = ClsName.__match_args__
if len($attrs) &#x3C; 1: raise TypeError(...)
$positional_names = $attrs[:1]
try:
    x = getattr($value, $attrs[0])
    if "a" in $positional_names: raise TypeError(...)
    y = $value.a
except AttributeError:
    FAIL
</code></pre>
<h4>중첩 패턴 (Nested patterns)</h4>
<p>위의 명세는 패턴이 중첩되지 않는다고 가정합니다. 중첩 패턴의 경우, 임시 캡처 패턴을 도입하여 위의 번역이 재귀적으로 적용됩니다.</p>
<p>예를 들어, 다음 패턴:</p>
<pre><code class="language-python">case [int(), str()]:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">$kind = type($value).__match_container__
if $kind != MATCH_SEQUENCE: FAIL
if len($value) != 2: FAIL
$value_0, $value_1 = $value
#이제 임시 값에 대해 매칭
if not isinstance($value_0, int): FAIL
if not isinstance($value_1, str): FAIL
</code></pre>
<h4>가드 (Guards)</h4>
<p>가드는 나머지 번역 다음에 테스트로 번역됩니다:</p>
<pre><code class="language-python">case pattern if guard:
</code></pre>
<p>다음으로 번역됩니다:</p>
<pre><code class="language-python">[pattern에 대한 번역]
if not guard: FAIL
</code></pre>
<h4>비준수 특수 속성 (Non-conforming special attributes)</h4>
<p>모든 클래스는 <code>__match_container__</code>, <code>__match_class__</code>, <code>__match_args__</code>의 값이 명세를 따르도록 해야 합니다. 따라서 구현체는 다음이 참이라고 가정할 수 있습니다 (확인 없이):</p>
<ul>
<li><code>__match_container__ == 0</code> 또는 <code>__match_container__ == MATCH_SEQUENCE</code> 또는 <code>__match_container__ == MATCH_MAPPING</code></li>
<li><code>__match_class__ == 0</code> 또는 <code>__match_class__ == MATCH_SELF</code></li>
</ul>
<p>그리고 <code>__match_args__</code>는 고유한 문자열의 튜플입니다.</p>
<h3>표준 라이브러리 클래스를 위한 특수 속성 값 (Values of the special attributes for classes in the standard library)</h3>
<p>코어 내장 컨테이너 클래스의 경우 <code>__match_container__</code>는 다음과 같습니다:</p>
<ul>
<li><code>list</code>: <code>MATCH_SEQUENCE</code></li>
<li><code>tuple</code>: <code>MATCH_SEQUENCE</code></li>
<li><code>dict</code>: <code>MATCH_MAPPING</code></li>
<li><code>bytearray</code>: <code>0</code></li>
<li><code>bytes</code>: <code>0</code></li>
<li><code>str</code>: <code>0</code></li>
</ul>
<p>Named tuple은 <code>__match_container__</code>가 <code>MATCH_SEQUENCE</code>로 설정됩니다.</p>
<p><code>issubclass(cls, collections.abc.Mapping)</code>이 참인 다른 모든 표준 라이브러리 클래스는 <code>__match_container__</code>가 <code>MATCH_MAPPING</code>으로 설정됩니다. <code>issubclass(cls, collections.abc.Sequence)</code>이 참인 다른 모든 표준 라이브러리 클래스는 <code>__match_container__</code>가 <code>MATCH_SEQUENCE</code>로 설정됩니다.</p>
<p>다음 내장 클래스에 대해 <code>__match_class__</code>는 <code>MATCH_SELF</code>로 설정됩니다:</p>
<ul>
<li><code>bool</code></li>
<li><code>bytearray</code></li>
<li><code>bytes</code></li>
<li><code>float</code></li>
<li><code>frozenset</code></li>
<li><code>int</code></li>
<li><code>set</code></li>
<li><code>str</code></li>
<li><code>list</code></li>
<li><code>tuple</code></li>
<li><code>dict</code></li>
</ul>
<h3>합법적인 최적화 (Legal optimizations)</h3>
<p>위의 의미론은 구현에 많은 불필요한 노력과 복사를 수반합니다. 그러나 순진한 구현에 의미론 보존 변환(semantic preserving transformations)을 적용하여 위의 의미론을 효율적으로 구현하는 것이 가능합니다.</p>
<p>매칭을 수행할 때, 구현체는 다음 함수와 메서드를 순수(pure)하다고 처리할 수 있습니다:</p>
<p><code>MATCH_SEQUENCE</code>를 지원하는 모든 클래스의 경우:</p>
<ul>
<li><code>cls.__len__()</code></li>
<li><code>cls.__getitem__()</code></li>
</ul>
<p><code>MATCH_MAPPING</code>을 지원하는 모든 클래스의 경우:</p>
<ul>
<li><code>cls.get()</code> (두 인자 형태만 해당)</li>
</ul>
<p>구현체는 다음 가정을 할 수 있습니다:</p>
<ul>
<li><code>isinstance(obj, cls)</code>는 <code>issubclass(type(obj), cls)</code>로 자유롭게 대체될 수 있으며 그 반대도 마찬가지입니다.</li>
<li><code>isinstance(obj, cls)</code>는 모든 <code>(obj, cls)</code> 쌍에 대해 항상 동일한 결과를 반환하므로 반복 호출은 생략될 수 있습니다.</li>
<li><code>__match_container__</code>, <code>__match_class__</code> 또는 <code>__match_args__</code>를 읽는 것은 순수(pure) 작업이며 캐시될 수 있습니다.</li>
<li>시퀀스, 즉 <code>__match_container__ == MATCH_SEQUENCE</code>가 0이 아닌 모든 클래스는 이터레이션(iteration), 서브스크립팅(subscripting) 또는 <code>len()</code> 호출에 의해 수정되지 않습니다. 결과적으로, 불변 시퀀스(immutable sequence)에 적용될 때 동등한 경우 이러한 작업들은 서로 자유롭게 대체될 수 있습니다.</li>
<li>매핑, 즉 <code>__match_container__ == MATCH_MAPPING</code>이 0이 아닌 모든 클래스는 <code>get()</code> 메서드의 두 번째 인자를 캡처하지 않을 것입니다. 따라서 <code>$sentinel</code> 값은 자유롭게 재사용될 수 있습니다.</li>
</ul>
<p>사실, 구현체들은 이러한 가정을 하도록 권장됩니다. 이는 상당한 성능 향상을 가져올 가능성이 높기 때문입니다.</p>
<h3>보안 영향 (Security Implications)</h3>
<p>없음.</p>
<h3>구현 (Implementation)</h3>
<p>명세에서 따르는 순진한 구현(naive implementation)은 그리 효율적이지 않을 것입니다. 다행히도, 성능을 향상시키는 데 사용될 수 있는 합리적으로 간단한 변환들이 있습니다. 성능은 3.10 릴리스 시점에는 PEP 634의 구현(작성 시점 기준)과 비슷해야 합니다. 추가 성능 개선은 3.11 릴리스를 기다려야 할 수도 있습니다.</p>
<h4>가능한 최적화 (Possible optimizations)</h4>
<p>다음은 명세의 일부가 아니라, 개발자가 효율적인 구현을 만드는 데 도움이 되는 가이드라인입니다.</p>
<h5>평가를 레인(lane)으로 분할 (Splitting evaluation into lanes)</h5>
<p>각 패턴을 매칭하는 첫 번째 단계는 종류(kind)를 확인하는 것이므로, 종류에 대한 모든 확인을 매치 시작 부분의 단일 다방향 분기(multi-way branch)로 결합할 수 있습니다. 그런 다음 케이스 목록은 여러 "레인"으로 복제될 수 있으며, 각 레인은 하나의 종류에 해당합니다. 그런 다음 각 레인에서 매칭할 수 없는 케이스를 제거하는 것은 사소합니다. 종류에 따라 각 레인에 대해 다른 최적화 전략이 가능합니다. 매치 절의 본문은 복제될 필요가 없고, 패턴만 복제하면 됩니다.</p>
<h5>시퀀스 패턴 (Sequence patterns)</h5>
<p>이것이 아마도 최적화하기 가장 복잡하고 성능 면에서 가장 이득이 많을 것입니다. 각 패턴은 특정 길이 범위, 종종 단일 길이만 매칭할 수 있으므로, 테스트 순서는 시퀀스에 대한 명시적인 반복으로 다시 작성될 수 있으며, 해당 시퀀스 길이에 적용되는 패턴만 매칭하려고 시도합니다.</p>
<p>예를 들어:</p>
<pre><code class="language-python">case []: A
case [x]: B
case [x, y]: C
case other: D
</code></pre>
<p>대략 다음과 같이 컴파일될 수 있습니다:</p>
<pre><code class="language-python"># 레인 선택
$i = iter($value)
for $0 in $i: break
else: A; goto done
for $1 in $i: break
else: x = $0; B; goto done
for $2 in $i: del $0, $1, $2; break
else: x = $0; y = $1; C; goto done
other = $value; D
done:
</code></pre>
<h5>매핑 패턴 (Mapping patterns)</h5>
<p>여기서 가장 좋은 전략은 매핑의 크기와 존재하는 키를 기반으로 결정 트리(decision tree)를 형성하는 것입니다. 키의 존재 여부를 반복적으로 테스트하는 것은 의미가 없습니다. 예를 들어:</p>
<pre><code class="language-python">match obj:
    case {a:x, b:y}: W
    case {a:x, c:y}: X
    case {a:x, b:_, c:y}: Y
    case other: Z
</code></pre>
<p>케이스 X를 확인할 때 키 "a"가 없으면 Y에 대해 다시 확인할 필요가 없습니다.</p>
<p>매핑 레인은 대략 다음과 같이 구현될 수 있습니다:</p>
<pre><code class="language-python"># 레인 선택
if len($value) == 2:
    if "a" in $value:
        if "b" in $value:
            x = $value["a"]
            y = $value["b"]
            goto W
        if "c" in $value:
            x = $value["a"]
            y = $value["c"]
            goto X
elif len($value) == 3:
    if "a" in $value and "b" in $value:
        x = $value["a"]
        y = $value["c"]
        goto Y
other = $value
goto Z
</code></pre>
<h3>이 PEP와 PEP 634의 차이점 요약 (Summary of differences between this PEP and PEP 634)</h3>
<p>의미론의 변경 사항은 다음과 같이 요약할 수 있습니다:</p>
<ul>
<li><code>__match_args__</code>가 단순히 시퀀스가 아닌 문자열의 튜플이어야 합니다. 이는 <code>__match_args__</code>가 불변(immutable)이라고 가정할 수 있으므로 패턴 매칭을 좀 더 견고하고 최적화 가능하게 만듭니다.</li>
<li>매칭될 수 있는 컨테이너 패턴의 종류를 선택하는 데 <code>issubclass(cls, collections.abc.Mapping)</code> 및 <code>issubclass(cls, collections.abc.Sequence)</code> 대신 <code>cls.__match_container__</code>를 사용합니다.</li>
<li>필요한 경우 <code>__match_class__ = 0</code>으로 설정하여 클래스가 분해(deconstruction)에서 완전히 제외될 수 있도록 합니다.</li>
<li>패턴 매칭 시 동작은 더 정밀하게 정의되지만, 그 외에는 변경되지 않습니다.</li>
</ul>
<p>구문에는 변경 사항이 없습니다. PEP 636 튜토리얼에 제공된 모든 예제는 현재와 동일하게 작동해야 합니다.</p>
<h3>기각된 아이디어 (Rejected Ideas)</h3>
<h4>인스턴스 딕셔너리의 속성 사용 (Using attributes from the instance's dictionary)</h4>
<p>이 PEP의 초기 버전은 <code>__match_class__</code>가 기본값일 때 클래스 패턴을 매칭할 때 인스턴스 딕셔너리의 속성만 사용했습니다. 의도는 바운드 메서드(bound-methods) 및 기타 합성 속성(synthetic attributes)을 캡처하는 것을 피하는 것이었습니다. 그러나 이는 프로퍼티(properties)도 무시된다는 것을 의미했습니다.</p>
<p>다음 클래스의 경우:</p>
<pre><code class="language-python">class C:
    def __init__(self):
        self.a = "a"
    @property
    def p(self): ...
    def m(self): ...
</code></pre>
<p>이상적으로는 "a"와 "p" 속성은 매칭하지만 "m"은 매칭하지 않기를 원합니다. 그러나 이를 수행할 일반적인 방법이 없으므로, 이 PEP는 이제 PEP 634의 의미론을 따릅니다.</p>
<h4>패턴이 아닌 피사체에서 <code>__match_args__</code> 조회 (Lookup of <strong>match_args</strong> on the subject not the pattern)</h4>
<p>이 PEP의 초기 버전은 패턴에 지정된 클래스가 아니라 피사체(subject)의 클래스에서 <code>__match_args__</code>를 조회했습니다. 이는 몇 가지 이유로 기각되었습니다:</p>
<ul>
<li>패턴에 지정된 클래스를 사용하는 것이 최적화에 더 적합하고 더 나은 성능을 제공할 수 있습니다.</li>
<li>패턴에 지정된 클래스를 사용하는 것이 일부 경우에 더 나은 오류 보고를 제공할 잠재력이 있습니다.</li>
<li>두 접근 방식 모두 완벽하지 않으며, 둘 다 이상한 코너 케이스가 있습니다. 현상 유지는 혼란을 최소화합니다.</li>
</ul>
<h4><code>__match_class__</code>와 <code>__match_container__</code>를 단일 값으로 결합 (Combining <strong>match_class</strong> and <strong>match_container</strong> into a single value)</h4>
<p>이 PEP의 초기 버전은 <code>__match_class__</code>와 <code>__match_container__</code>를 <code>__match_kind__</code>라는 단일 값으로 결합했습니다. 단일 값을 사용하는 것이 성능 면에서 작은 이점이 있지만, 클래스 매칭 동작을 오버라이드할 때 컨테이너 매칭에 의도하지 않은 변경을 초래할 가능성이 높으며 그 반대도 마찬가지입니다.</p>
<h3>연기된 아이디어 (Deferred Ideas)</h3>
<p>이 PEP의 원본 버전에는 <code>MATCH_POSITIONAL</code> 매치 종류와 클래스가 매칭에 대한 완전한 제어를 허용하는 특수 메서드 <code>__deconstruct__</code>가 포함되어 있었습니다. 이는 <code>sympy</code>와 같은 라이브러리에 중요합니다.</p>
<p>예를 들어, <code>sympy</code>를 사용하여 다음과 같이 작성하고 싶을 수 있습니다:</p>
<pre><code class="language-python"># sin(x)**2 + cos(x)**2 == 1
case Add(Pow(sin(a), 2), Pow(cos(b), 2)) if a == b:
    return 1
</code></pre>
<p><code>sympy</code>가 현재 패턴 매칭으로 위치 패턴을 지원하는 것은 가능하지만, 까다롭습니다. 이러한 추가 기능이 있으면 쉽게 구현할 수 있습니다.</p>
<p>이 아이디어는 3.11을 위한 향후 PEP에 포함될 예정입니다. 그러나 3.10 개발 주기에서는 그러한 변경을 하기에는 너무 늦습니다.</p>
<h4>모든 클래스 매치를 거부하는 별도의 값 (Having a separate value to reject all class matches)</h4>
<p>이 PEP의 초기 버전에는 <code>__match_class__</code>에 대한 별개의 값이 있었는데, 이를 통해 클래스는 분해(deconstruction)를 요구했을 모든 클래스 패턴을 매칭하지 않을 수 있었습니다. 그러나 <code>MATCH_POSITIONAL</code>이 도입되면 이는 중복될 것이며, 극히 드문 경우를 위해 명세를 복잡하게 만듭니다.</p>
<h3>코드 예시 (Code examples)</h3>
<pre><code class="language-python"># 예시 1
class Symbol:
    __match_class__ = MATCH_SELF

# 예시 2 (위에서 번역됨)
case [a, b] if a is b:
    # ...

# 예시 3 (위에서 번역됨)
case [a, *b, c]:
    # ...

# 예시 4 (위에서 번역됨)
case {"x": x, "y": y} if x > 2:
    # ...

# 예시 5 (위에서 번역됨)
case {"x": x, "y": y, **z}:
    # ...

# 예시 6 (위에서 번역됨)
match ClsName(x, y):
    # ...

# 예시 7 (위에서 번역됨)
match ClsName(a=x, b=y):
    # ...

# 예시 8 (위에서 번역됨)
match ClsName(x, a=y):
    # ...

# 예시 9 (Deferred Ideas 섹션에서 언급)
class Basic:
    __match_class__ = MATCH_POSITIONAL
    def __deconstruct__(self):
        return self._args
</code></pre>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되거나 CC0-1.0-Universal 라이선스 중 더 관대한 조건에 따릅니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-287dd7aad5349a53.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/653\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"UDStqnFgkjod-k9ijxbnd\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/653/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/653\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"653\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/653\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T8643,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0653/\"\u003ePEP 653 - Precise Semantics for Pattern Matching\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Draft | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 09-Feb-2021\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 653 – 패턴 매칭을 위한 정밀한 의미론\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e저자\u003c/strong\u003e: Mark Shannon\n\u003cstrong\u003e상태\u003c/strong\u003e: Draft (초안)\n\u003cstrong\u003e유형\u003c/strong\u003e: Standards Track (표준 트랙)\n\u003cstrong\u003e생성일\u003c/strong\u003e: 2021년 2월 9일\n\u003cstrong\u003e개정 이력\u003c/strong\u003e: 2021년 2월 18일\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 PEP 634의 일반적인 개념을 존중하면서도, 더 정밀하고, 이해하기 쉬우며, 더 빠른 패턴 매칭 의미론을 제안합니다.\u003c/p\u003e\n\u003cp\u003e객체 모델은 PEP 634의 \u003ccode\u003e__match_args__\u003c/code\u003e 속성 외에 \u003ccode\u003e__match_container__\u003c/code\u003e 및 \u003ccode\u003e__match_class__\u003c/code\u003e라는 두 개의 특수 (던더) 속성으로 확장되어 패턴 매칭을 지원합니다. 이 두 가지 새로운 속성은 정수여야 하며, \u003ccode\u003e__match_args__\u003c/code\u003e는 고유한 문자열의 튜플이어야 합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP를 통해:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e패턴 매칭의 의미론이 더욱 명확해져, 패턴을 추론하기 쉬워집니다.\u003c/li\u003e\n\u003cli\u003e패턴 매칭을 더 효율적으로 구현할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e클래스가 어떤 패턴과 매칭될지 더 세밀하게 제어할 수 있게 되어 복잡한 클래스에서도 패턴 매칭이 더욱 유용해집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePEP 634에 설명된 파이썬의 패턴 매칭은 Python 3.10에 추가될 예정입니다. 아쉽게도 PEP 634는 의미론에 대해 충분히 정밀하지 않으며, 클래스가 패턴과 어떻게 매칭될지에 대한 충분한 제어를 허용하지 않습니다.\u003c/p\u003e\n\u003ch3\u003e정밀한 의미론 (Precise semantics)\u003c/h3\u003e\n\u003cp\u003ePEP 634는 '정의되지 않은 동작(undefined behavior)'에 대한 섹션을 명시적으로 포함하고 있습니다. C와 같은 언어에서는 많은 양의 정의되지 않은 동작이 허용될 수 있지만, 파이썬에서는 이를 최소화해야 합니다. 파이썬의 패턴 매칭은 표현력이나 성능 손실 없이 더 정밀하게 정의될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e클래스 매칭에 대한 향상된 제어 (Improved control over class matching)\u003c/h3\u003e\n\u003cp\u003ePEP 634는 클래스가 시퀀스(sequence) 또는 매핑(mapping)인지 여부를 \u003ccode\u003ecollections.abc\u003c/code\u003e에 위임합니다. 모든 시퀀스로 간주될 수 있는 클래스가 \u003ccode\u003ecollections.abc.Sequence\u003c/code\u003e의 서브클래스로 등록되는 것은 아닙니다. 이 PEP는 \u003ccode\u003ecollections.abc.Sequence\u003c/code\u003e의 모든 메커니즘을 사용하지 않고도 시퀀스 패턴과 매칭될 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003ePEP 634는 일부 내장 클래스에 \"self\" 매치라는 특별한 형태의 매칭 권한을 부여합니다. 예를 들어, \u003ccode\u003elist(x)\u003c/code\u003e 패턴은 리스트와 매칭되고 리스트를 \u003ccode\u003ex\u003c/code\u003e에 할당합니다. 클래스가 어떤 종류의 패턴과 매칭될지 선택할 수 있도록 함으로써 다른 클래스도 이 형태를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003esympy\u003c/code\u003e를 사용하여 다음과 같이 작성하고 싶을 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# a*a == a**2\ncase Mul(args=[Symbol(a), Symbol(b)]) if a == b:\n    return Pow(a, 2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 \u003ccode\u003esympy\u003c/code\u003e 클래스 \u003ccode\u003eSymbol\u003c/code\u003e이 \"self\" 매칭을 해야 함을 의미합니다. \u003ccode\u003esympy\u003c/code\u003e가 PEP 634로 이 패턴을 지원하는 것은 가능하지만 다소 까다롭습니다. 이 PEP를 사용하면 매우 쉽게 구현할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e견고성 (Robustness)\u003c/h3\u003e\n\u003cp\u003e이 PEP를 사용하면 패턴 매칭 중 속성 접근이 잘 정의되고 확정적(deterministic)이 됩니다. 이는 객체 관계형 매퍼(object-relational mappers)와 같이 숨겨진 부작용이 있는 객체를 매칭할 때 패턴 매칭의 오류 발생 가능성을 줄여줍니다. 객체는 자체적인 분해(deconstruction)에 대해 더 많은 제어권을 가지게 되며, 이는 속성 접근에 부작용이 있을 경우 의도하지 않은 결과를 방지하는 데 도움이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePEP 634는 값이 어떤 패턴과 매칭될 수 있는지 결정할 때 \u003ccode\u003ecollections.abc\u003c/code\u003e 모듈에 의존하며, 필요한 경우 암묵적으로 이를 임포트합니다. 이 PEP는 그러한 임포트로 인한 예상치 못한 임포트 오류 및 오해의 소지가 있는 감사(audit) 이벤트를 제거할 것입니다.\u003c/p\u003e\n\u003ch3\u003e효율적인 구현 (Efficient implementation)\u003c/h3\u003e\n\u003cp\u003e이 PEP에서 제안하는 의미론은 부분적으로 정밀한 의미론을 가지고 있고 부분적으로 객체 모델을 사용하기 때문에 효율적인 구현을 가능하게 할 것입니다.\u003c/p\u003e\n\u003cp\u003e정밀한 의미론을 통해 어떤 코드 변환이 올바른지 추론할 수 있으므로 최적화를 효과적으로 적용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e객체 모델은 파이썬의 핵심 부분이므로, 구현체들은 이미 특수 속성(\u003ccode\u003especial attribute\u003c/code\u003e) 조회를 효율적으로 처리합니다. 특수 속성을 조회하는 것은 추상 베이스 클래스에 대한 서브클래스 테스트를 수행하는 것보다 훨씬 빠릅니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e객체 모델과 특수 메서드(special methods)는 파이썬 언어의 핵심입니다. 결과적으로 구현체들은 이를 잘 지원합니다. 패턴 매칭에 특수 속성을 사용하면 패턴 매칭을 나머지 구현과 잘 통합되는 방식으로 구현할 수 있으므로 유지 관리가 더 쉽고 성능이 더 좋을 가능성이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ematch\u003c/code\u003e 문은 일련의 패턴 매칭을 수행합니다. 일반적으로 패턴을 매칭하는 데는 세 가지 부분이 있습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e이 값이 이 종류의 패턴과 매칭될 수 있는가?\u003c/li\u003e\n\u003cli\u003e분해될 때, 이 값이 이 특정 패턴과 매칭되는가?\u003c/li\u003e\n\u003cli\u003e가드(guard)가 참인가?\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e값이 특정 종류의 패턴과 매칭될 수 있는지 확인하기 위해 \u003ccode\u003e__match_container__\u003c/code\u003e 및 \u003ccode\u003e__match_class__\u003c/code\u003e 속성을 추가합니다. 이를 통해 값의 종류를 효율적으로 결정할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003ch3\u003e객체 모델에 대한 추가 사항 (Additions to the object model)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e__match_container__\u003c/code\u003e 및 \u003ccode\u003e__match_class__\u003c/code\u003e 속성이 \u003ccode\u003eobject\u003c/code\u003e에 추가될 것입니다. \u003ccode\u003e__match_container__\u003c/code\u003e는 매핑(mapping) 또는 시퀀스(sequence) 패턴과 매칭되기를 원하는 클래스에 의해 오버라이드(override)되어야 합니다. \u003ccode\u003e__match_class__\u003c/code\u003e는 클래스 패턴을 매칭할 때 기본 동작을 변경하고자 하는 클래스에 의해 오버라이드되어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__match_container__\u003c/code\u003e는 정수여야 하며 다음 중 정확히 하나여야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMATCH_SEQUENCE = 1\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMATCH_MAPPING = 2\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eMATCH_SEQUENCE\u003c/code\u003e는 클래스의 인스턴스가 시퀀스 패턴과 매칭될 수 있음을 나타내는 데 사용됩니다.\n\u003ccode\u003eMATCH_MAPPING\u003c/code\u003e은 클래스의 인스턴스가 매핑 패턴과 매칭될 수 있음을 나타내는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__match_class__\u003c/code\u003e는 정수여야 하며 다음 중 정확히 하나여야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMATCH_SELF = 8\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eMATCH_SELF\u003c/code\u003e는 단일 위치 인자(positional argument) 클래스 패턴의 경우, 피사체(subject)가 분해되지 않고 사용될 것임을 나타내는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고\u003c/strong\u003e: 이 문서의 나머지 부분에서는 위의 값들을 이름으로만 참조할 것입니다. 파이썬과 C 모두를 위한 심볼릭 상수(symbolic constants)가 제공될 것이며, 이 값들은 절대 변경되지 않을 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eobject\u003c/code\u003e는 특수 속성에 대해 다음 값을 가집니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e__match_container__ = 0\n__match_class__ = 0\n__match_args__ = ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 특수 속성은 일반적인 방식으로 상속됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__match_args__\u003c/code\u003e가 오버라이드되면, 고유한 문자열의 튜플을 포함해야 합니다. 비어 있을 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고\u003c/strong\u003e: \u003ccode\u003e__match_args__\u003c/code\u003e는 PEP 634에 명시된 대로 \u003ccode\u003edataclasses\u003c/code\u003e 및 \u003ccode\u003enamed tuples\u003c/code\u003e에 대해 자동으로 생성됩니다.\u003c/p\u003e\n\u003cp\u003e패턴 매칭 구현은 이러한 속성 중 어느 것도 명세대로 동작하는지 확인할 필요가 없습니다. \u003ccode\u003e__match_container__\u003c/code\u003e, \u003ccode\u003e__match_class__\u003c/code\u003e 또는 \u003ccode\u003e__match_args__\u003c/code\u003e의 값이 명세대로가 아닐 경우, 구현은 어떤 예외도 발생시키거나 잘못된 패턴과 매칭될 수 있습니다. 물론, 구현체들은 이러한 속성을 확인하고 효율적으로 수행할 수 있다면 의미 있는 오류 메시지를 제공할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e매칭 프로세스의 의미론 (Semantics of the matching process)\u003c/h3\u003e\n\u003cp\u003e다음에서, \u003ccode\u003e$var\u003c/code\u003e 형태의 모든 변수는 임시 변수이며 파이썬 프로그램에는 보이지 않습니다. 이들은 인트로스펙션(introspection)을 통해 보일 수 있지만, 이는 구현 세부 사항이므로 의존해서는 안 됩니다. 의사(pseudo) 문장 \u003ccode\u003eFAIL\u003c/code\u003e은 이 패턴에 대한 매칭이 실패했으며 다음 패턴으로 넘어가야 함을 나타내는 데 사용됩니다. 제어가 \u003ccode\u003eFAIL\u003c/code\u003e에 도달하지 않고 번역의 끝에 도달하면, 매칭된 것이며, 이후의 패턴은 무시됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$ALL_CAPS\u003c/code\u003e 형태의 변수는 구문 요소를 담고 있는 메타 변수(meta-variable)이며, 일반 변수가 아닙니다. 따라서 \u003ccode\u003e$VARS = $items\u003c/code\u003e는 \u003ccode\u003e$items\u003c/code\u003e를 \u003ccode\u003e$VARS\u003c/code\u003e에 할당하는 것이 아니라, \u003ccode\u003e$items\u003c/code\u003e를 \u003ccode\u003e$VARS\u003c/code\u003e가 담고 있는 변수들로 언패킹(unpacking)하는 것입니다. 예를 들어, 추상 구문 \u003ccode\u003ecase [$VARS]:\u003c/code\u003e와 구체적인 구문 \u003ccode\u003ecase [a, b]:\u003c/code\u003e에서 \u003ccode\u003e$VARS\u003c/code\u003e는 변수 \u003ccode\u003e(a, b)\u003c/code\u003e를 담고 있는 것이지, 그 변수들의 값을 담고 있는 것이 아닙니다.\u003c/p\u003e\n\u003cp\u003e의사 함수 \u003ccode\u003eQUOTE\u003c/code\u003e는 변수를 받아 그 변수의 이름을 반환합니다. 예를 들어, 메타 변수 \u003ccode\u003e$VAR\u003c/code\u003e이 변수 \u003ccode\u003efoo\u003c/code\u003e를 담고 있다면 \u003ccode\u003eQUOTE($VAR) == \"foo\"\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e아래 나열된 모든 추가 코드는 원본 소스에 없는 것이며, PEP 626에 따라 라인 이벤트(line events)를 발생시키지 않습니다.\u003c/p\u003e\n\u003ch4\u003e서문 (Preamble)\u003c/h4\u003e\n\u003cp\u003e어떤 패턴도 매칭되기 전에, 매칭될 표현식이 평가됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ematch expr:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e$value = expr\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e캡처 패턴 (Capture patterns)\u003c/h4\u003e\n\u003cp\u003e캡처 패턴은 항상 매칭됩니다. 따라서 피할 수 없는(irrefutable) 매치:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase capture_var:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecapture_var = $value\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e와일드카드 패턴 (Wildcard patterns)\u003c/h4\u003e\n\u003cp\u003e와일드카드 패턴은 항상 매칭됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase _:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 코드 없음 -- 자동으로 매칭됨\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e리터럴 패턴 (Literal Patterns)\u003c/h4\u003e\n\u003cp\u003e리터럴 패턴:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase LITERAL:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif $value != LITERAL: FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e단, 리터럴이 \u003ccode\u003eNone\u003c/code\u003e, \u003ccode\u003eTrue\u003c/code\u003e, \u003ccode\u003eFalse\u003c/code\u003e 중 하나일 때는 다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif $value is not LITERAL: FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e값 패턴 (Value Patterns)\u003c/h4\u003e\n\u003cp\u003e값 패턴:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase value.pattern:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif $value != value.pattern: FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e시퀀스 패턴 (Sequence Patterns)\u003c/h4\u003e\n\u003cp\u003e스타 패턴(\u003ccode\u003e*\u003c/code\u003e)을 포함하지 않는 패턴:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase [$VARS]:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e$kind = type($value).__match_container__\nif $kind != MATCH_SEQUENCE: FAIL\nif len($value) != len($VARS): FAIL\n$VARS = $value\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase [a, b] if a is b:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e$kind = type($value).__match_container__\nif $kind != MATCH_SEQUENCE: FAIL\nif len($value) != 2: FAIL\na, b = $value\nif not a is b: FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e스타 패턴을 포함하는 패턴:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase [$VARS]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e$kind = type($value).__match_container__\nif $kind != MATCH_SEQUENCE: FAIL\nif len($value) \u0026#x3C; len($VARS): FAIL\n$VARS = $value # $VARS에는 스타 표현식이 포함됩니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase [a, *b, c]:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e$kind = type($value).__match_container__\nif $kind != MATCH_SEQUENCE: FAIL\nif len($value) \u0026#x3C; 2: FAIL\na, *b, c = $value\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e매핑 패턴 (Mapping Patterns)\u003c/h4\u003e\n\u003cp\u003e더블 스타 패턴(\u003ccode\u003e**\u003c/code\u003e)을 포함하지 않는 패턴:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase {$KEYWORD_PATTERNS}:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e$sentinel = object()\n$kind = type($value).__match_container__\nif $kind != MATCH_MAPPING: FAIL\n# $KEYWORD_PATTERNS는 이름들을 변수들에 매핑하는 메타 변수입니다.\nfor $KEYWORD in $KEYWORD_PATTERNS:\n    $tmp = $value.get(QUOTE($KEYWORD), $sentinel)\n    if $tmp is $sentinel: FAIL\n    $KEYWORD_PATTERNS[$KEYWORD] = $tmp\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase {\"x\": x, \"y\": y} if x \u003e 2:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e$kind = type($value).__match_container__\nif $kind != MATCH_MAPPING: FAIL\n$tmp = $value.get(\"x\", $sentinel)\nif $tmp is $sentinel: FAIL\nx = $tmp\n$tmp = $value.get(\"y\", $sentinel)\nif $tmp is $sentinel: FAIL\ny = $tmp\nif not x \u003e 2: FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e더블 스타 패턴을 포함하는 패턴:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase {$KEYWORD_PATTERNS, **$DOUBLE_STARRED_PATTERN}:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e$kind = type($value).__match_container__\nif $kind != MATCH_MAPPING: FAIL\n# $KEYWORD_PATTERNS는 이름들을 변수들에 매핑하는 메타 변수입니다.\n$tmp = dict($value)\nif not $tmp.keys() \u003e= $KEYWORD_PATTERNS.keys(): FAIL:\nfor $KEYWORD in $KEYWORD_PATTERNS:\n    $KEYWORD_PATTERNS[$KEYWORD] = $tmp.pop(QUOTE($KEYWORD))\n$DOUBLE_STARRED_PATTERN = $tmp\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase {\"x\": x, \"y\": y, **z}:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e$kind = type($value).__match_container__\nif $kind != MATCH_MAPPING: FAIL\n$tmp = dict($value)\nif not $tmp.keys() \u003e= {\"x\", \"y\"}: FAIL\nx = $tmp.pop(\"x\")\ny = $tmp.pop(\"y\")\nz = $tmp\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e클래스 패턴 (Class Patterns)\u003c/h4\u003e\n\u003cp\u003e인자 없는 클래스 패턴:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase ClsName():\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif not isinstance($value, ClsName): FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e단일 위치 패턴(single positional pattern)을 가진 클래스 패턴:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase ClsName($VAR):\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e$kind = type($value).__match_class__\nif $kind == MATCH_SELF:\n    if not isinstance($value, ClsName): FAIL\n    $VAR = $value\nelse:\n    # 다른 위치 전용 클래스 패턴과 동일\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위치 전용 클래스 패턴 (Positional-only class pattern):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase ClsName($VARS):\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif not isinstance($value, ClsName): FAIL\n$attrs = ClsName.__match_args__\nif len($attrs) \u0026#x3C; len($VARS): raise TypeError(...)\ntry:\n    for i, $VAR in enumerate($VARS):\n        $VAR = getattr($value, $attrs[i])\nexcept AttributeError:\n    FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ematch ClsName(x, y):\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif not isinstance($value, ClsName): FAIL\n$attrs = ClsName.__match_args__\nif len($attrs) \u0026#x3C; 2: FAIL\ntry:\n    x = getattr($value, $attrs[0])\n    y = getattr($value, $attrs[1])\nexcept AttributeError:\n    FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 키워드 패턴(keyword patterns)을 가진 클래스 패턴:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase ClsName($KEYWORD_PATTERNS):\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif not isinstance($value, ClsName): FAIL\ntry:\n    for $KEYWORD in $KEYWORD_PATTERNS:\n        $tmp = getattr($value, QUOTE($KEYWORD))\n        $KEYWORD_PATTERNS[$KEYWORD] = $tmp\nexcept AttributeError:\n    FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ematch ClsName(a=x, b=y):\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif not isinstance($value, ClsName): FAIL\ntry:\n    x = $value.a\n    y = $value.b\nexcept AttributeError:\n    FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위치 및 키워드 패턴을 가진 클래스 패턴:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase ClsName($VARS, $KEYWORD_PATTERNS):\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif not isinstance($value, ClsName): FAIL\n$attrs = ClsName.__match_args__\nif len($attrs) \u0026#x3C; len($VARS): raise TypeError(...)\n$pos_attrs = $attrs[:len($VARS)]\ntry:\n    for i, $VAR in enumerate($VARS):\n        $VAR = getattr($value, $attrs[i])\n    for $KEYWORD in $KEYWORD_PATTERNS:\n        $name = QUOTE($KEYWORD)\n        if $name in $pos_attrs: raise TypeError(...)\n        $KEYWORD_PATTERNS[$KEYWORD] = getattr($value, $name)\nexcept AttributeError:\n    FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ematch ClsName(x, a=y):\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif not isinstance($value, ClsName): FAIL\n$attrs = ClsName.__match_args__\nif len($attrs) \u0026#x3C; 1: raise TypeError(...)\n$positional_names = $attrs[:1]\ntry:\n    x = getattr($value, $attrs[0])\n    if \"a\" in $positional_names: raise TypeError(...)\n    y = $value.a\nexcept AttributeError:\n    FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e중첩 패턴 (Nested patterns)\u003c/h4\u003e\n\u003cp\u003e위의 명세는 패턴이 중첩되지 않는다고 가정합니다. 중첩 패턴의 경우, 임시 캡처 패턴을 도입하여 위의 번역이 재귀적으로 적용됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 다음 패턴:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase [int(), str()]:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e$kind = type($value).__match_container__\nif $kind != MATCH_SEQUENCE: FAIL\nif len($value) != 2: FAIL\n$value_0, $value_1 = $value\n#이제 임시 값에 대해 매칭\nif not isinstance($value_0, int): FAIL\nif not isinstance($value_1, str): FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e가드 (Guards)\u003c/h4\u003e\n\u003cp\u003e가드는 나머지 번역 다음에 테스트로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase pattern if guard:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 번역됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e[pattern에 대한 번역]\nif not guard: FAIL\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e비준수 특수 속성 (Non-conforming special attributes)\u003c/h4\u003e\n\u003cp\u003e모든 클래스는 \u003ccode\u003e__match_container__\u003c/code\u003e, \u003ccode\u003e__match_class__\u003c/code\u003e, \u003ccode\u003e__match_args__\u003c/code\u003e의 값이 명세를 따르도록 해야 합니다. 따라서 구현체는 다음이 참이라고 가정할 수 있습니다 (확인 없이):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__match_container__ == 0\u003c/code\u003e 또는 \u003ccode\u003e__match_container__ == MATCH_SEQUENCE\u003c/code\u003e 또는 \u003ccode\u003e__match_container__ == MATCH_MAPPING\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__match_class__ == 0\u003c/code\u003e 또는 \u003ccode\u003e__match_class__ == MATCH_SELF\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그리고 \u003ccode\u003e__match_args__\u003c/code\u003e는 고유한 문자열의 튜플입니다.\u003c/p\u003e\n\u003ch3\u003e표준 라이브러리 클래스를 위한 특수 속성 값 (Values of the special attributes for classes in the standard library)\u003c/h3\u003e\n\u003cp\u003e코어 내장 컨테이너 클래스의 경우 \u003ccode\u003e__match_container__\u003c/code\u003e는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elist\u003c/code\u003e: \u003ccode\u003eMATCH_SEQUENCE\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etuple\u003c/code\u003e: \u003ccode\u003eMATCH_SEQUENCE\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edict\u003c/code\u003e: \u003ccode\u003eMATCH_MAPPING\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebytearray\u003c/code\u003e: \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebytes\u003c/code\u003e: \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estr\u003c/code\u003e: \u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNamed tuple은 \u003ccode\u003e__match_container__\u003c/code\u003e가 \u003ccode\u003eMATCH_SEQUENCE\u003c/code\u003e로 설정됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eissubclass(cls, collections.abc.Mapping)\u003c/code\u003e이 참인 다른 모든 표준 라이브러리 클래스는 \u003ccode\u003e__match_container__\u003c/code\u003e가 \u003ccode\u003eMATCH_MAPPING\u003c/code\u003e으로 설정됩니다. \u003ccode\u003eissubclass(cls, collections.abc.Sequence)\u003c/code\u003e이 참인 다른 모든 표준 라이브러리 클래스는 \u003ccode\u003e__match_container__\u003c/code\u003e가 \u003ccode\u003eMATCH_SEQUENCE\u003c/code\u003e로 설정됩니다.\u003c/p\u003e\n\u003cp\u003e다음 내장 클래스에 대해 \u003ccode\u003e__match_class__\u003c/code\u003e는 \u003ccode\u003eMATCH_SELF\u003c/code\u003e로 설정됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebool\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebytearray\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebytes\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efloat\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efrozenset\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eset\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estr\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elist\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etuple\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edict\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e합법적인 최적화 (Legal optimizations)\u003c/h3\u003e\n\u003cp\u003e위의 의미론은 구현에 많은 불필요한 노력과 복사를 수반합니다. 그러나 순진한 구현에 의미론 보존 변환(semantic preserving transformations)을 적용하여 위의 의미론을 효율적으로 구현하는 것이 가능합니다.\u003c/p\u003e\n\u003cp\u003e매칭을 수행할 때, 구현체는 다음 함수와 메서드를 순수(pure)하다고 처리할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eMATCH_SEQUENCE\u003c/code\u003e를 지원하는 모든 클래스의 경우:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecls.__len__()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecls.__getitem__()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eMATCH_MAPPING\u003c/code\u003e을 지원하는 모든 클래스의 경우:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecls.get()\u003c/code\u003e (두 인자 형태만 해당)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e구현체는 다음 가정을 할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eisinstance(obj, cls)\u003c/code\u003e는 \u003ccode\u003eissubclass(type(obj), cls)\u003c/code\u003e로 자유롭게 대체될 수 있으며 그 반대도 마찬가지입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eisinstance(obj, cls)\u003c/code\u003e는 모든 \u003ccode\u003e(obj, cls)\u003c/code\u003e 쌍에 대해 항상 동일한 결과를 반환하므로 반복 호출은 생략될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__match_container__\u003c/code\u003e, \u003ccode\u003e__match_class__\u003c/code\u003e 또는 \u003ccode\u003e__match_args__\u003c/code\u003e를 읽는 것은 순수(pure) 작업이며 캐시될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e시퀀스, 즉 \u003ccode\u003e__match_container__ == MATCH_SEQUENCE\u003c/code\u003e가 0이 아닌 모든 클래스는 이터레이션(iteration), 서브스크립팅(subscripting) 또는 \u003ccode\u003elen()\u003c/code\u003e 호출에 의해 수정되지 않습니다. 결과적으로, 불변 시퀀스(immutable sequence)에 적용될 때 동등한 경우 이러한 작업들은 서로 자유롭게 대체될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e매핑, 즉 \u003ccode\u003e__match_container__ == MATCH_MAPPING\u003c/code\u003e이 0이 아닌 모든 클래스는 \u003ccode\u003eget()\u003c/code\u003e 메서드의 두 번째 인자를 캡처하지 않을 것입니다. 따라서 \u003ccode\u003e$sentinel\u003c/code\u003e 값은 자유롭게 재사용될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e사실, 구현체들은 이러한 가정을 하도록 권장됩니다. 이는 상당한 성능 향상을 가져올 가능성이 높기 때문입니다.\u003c/p\u003e\n\u003ch3\u003e보안 영향 (Security Implications)\u003c/h3\u003e\n\u003cp\u003e없음.\u003c/p\u003e\n\u003ch3\u003e구현 (Implementation)\u003c/h3\u003e\n\u003cp\u003e명세에서 따르는 순진한 구현(naive implementation)은 그리 효율적이지 않을 것입니다. 다행히도, 성능을 향상시키는 데 사용될 수 있는 합리적으로 간단한 변환들이 있습니다. 성능은 3.10 릴리스 시점에는 PEP 634의 구현(작성 시점 기준)과 비슷해야 합니다. 추가 성능 개선은 3.11 릴리스를 기다려야 할 수도 있습니다.\u003c/p\u003e\n\u003ch4\u003e가능한 최적화 (Possible optimizations)\u003c/h4\u003e\n\u003cp\u003e다음은 명세의 일부가 아니라, 개발자가 효율적인 구현을 만드는 데 도움이 되는 가이드라인입니다.\u003c/p\u003e\n\u003ch5\u003e평가를 레인(lane)으로 분할 (Splitting evaluation into lanes)\u003c/h5\u003e\n\u003cp\u003e각 패턴을 매칭하는 첫 번째 단계는 종류(kind)를 확인하는 것이므로, 종류에 대한 모든 확인을 매치 시작 부분의 단일 다방향 분기(multi-way branch)로 결합할 수 있습니다. 그런 다음 케이스 목록은 여러 \"레인\"으로 복제될 수 있으며, 각 레인은 하나의 종류에 해당합니다. 그런 다음 각 레인에서 매칭할 수 없는 케이스를 제거하는 것은 사소합니다. 종류에 따라 각 레인에 대해 다른 최적화 전략이 가능합니다. 매치 절의 본문은 복제될 필요가 없고, 패턴만 복제하면 됩니다.\u003c/p\u003e\n\u003ch5\u003e시퀀스 패턴 (Sequence patterns)\u003c/h5\u003e\n\u003cp\u003e이것이 아마도 최적화하기 가장 복잡하고 성능 면에서 가장 이득이 많을 것입니다. 각 패턴은 특정 길이 범위, 종종 단일 길이만 매칭할 수 있으므로, 테스트 순서는 시퀀스에 대한 명시적인 반복으로 다시 작성될 수 있으며, 해당 시퀀스 길이에 적용되는 패턴만 매칭하려고 시도합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase []: A\ncase [x]: B\ncase [x, y]: C\ncase other: D\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e대략 다음과 같이 컴파일될 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 레인 선택\n$i = iter($value)\nfor $0 in $i: break\nelse: A; goto done\nfor $1 in $i: break\nelse: x = $0; B; goto done\nfor $2 in $i: del $0, $1, $2; break\nelse: x = $0; y = $1; C; goto done\nother = $value; D\ndone:\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e매핑 패턴 (Mapping patterns)\u003c/h5\u003e\n\u003cp\u003e여기서 가장 좋은 전략은 매핑의 크기와 존재하는 키를 기반으로 결정 트리(decision tree)를 형성하는 것입니다. 키의 존재 여부를 반복적으로 테스트하는 것은 의미가 없습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ematch obj:\n    case {a:x, b:y}: W\n    case {a:x, c:y}: X\n    case {a:x, b:_, c:y}: Y\n    case other: Z\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e케이스 X를 확인할 때 키 \"a\"가 없으면 Y에 대해 다시 확인할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e매핑 레인은 대략 다음과 같이 구현될 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 레인 선택\nif len($value) == 2:\n    if \"a\" in $value:\n        if \"b\" in $value:\n            x = $value[\"a\"]\n            y = $value[\"b\"]\n            goto W\n        if \"c\" in $value:\n            x = $value[\"a\"]\n            y = $value[\"c\"]\n            goto X\nelif len($value) == 3:\n    if \"a\" in $value and \"b\" in $value:\n        x = $value[\"a\"]\n        y = $value[\"c\"]\n        goto Y\nother = $value\ngoto Z\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e이 PEP와 PEP 634의 차이점 요약 (Summary of differences between this PEP and PEP 634)\u003c/h3\u003e\n\u003cp\u003e의미론의 변경 사항은 다음과 같이 요약할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__match_args__\u003c/code\u003e가 단순히 시퀀스가 아닌 문자열의 튜플이어야 합니다. 이는 \u003ccode\u003e__match_args__\u003c/code\u003e가 불변(immutable)이라고 가정할 수 있으므로 패턴 매칭을 좀 더 견고하고 최적화 가능하게 만듭니다.\u003c/li\u003e\n\u003cli\u003e매칭될 수 있는 컨테이너 패턴의 종류를 선택하는 데 \u003ccode\u003eissubclass(cls, collections.abc.Mapping)\u003c/code\u003e 및 \u003ccode\u003eissubclass(cls, collections.abc.Sequence)\u003c/code\u003e 대신 \u003ccode\u003ecls.__match_container__\u003c/code\u003e를 사용합니다.\u003c/li\u003e\n\u003cli\u003e필요한 경우 \u003ccode\u003e__match_class__ = 0\u003c/code\u003e으로 설정하여 클래스가 분해(deconstruction)에서 완전히 제외될 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003e패턴 매칭 시 동작은 더 정밀하게 정의되지만, 그 외에는 변경되지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e구문에는 변경 사항이 없습니다. PEP 636 튜토리얼에 제공된 모든 예제는 현재와 동일하게 작동해야 합니다.\u003c/p\u003e\n\u003ch3\u003e기각된 아이디어 (Rejected Ideas)\u003c/h3\u003e\n\u003ch4\u003e인스턴스 딕셔너리의 속성 사용 (Using attributes from the instance's dictionary)\u003c/h4\u003e\n\u003cp\u003e이 PEP의 초기 버전은 \u003ccode\u003e__match_class__\u003c/code\u003e가 기본값일 때 클래스 패턴을 매칭할 때 인스턴스 딕셔너리의 속성만 사용했습니다. 의도는 바운드 메서드(bound-methods) 및 기타 합성 속성(synthetic attributes)을 캡처하는 것을 피하는 것이었습니다. 그러나 이는 프로퍼티(properties)도 무시된다는 것을 의미했습니다.\u003c/p\u003e\n\u003cp\u003e다음 클래스의 경우:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass C:\n    def __init__(self):\n        self.a = \"a\"\n    @property\n    def p(self): ...\n    def m(self): ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이상적으로는 \"a\"와 \"p\" 속성은 매칭하지만 \"m\"은 매칭하지 않기를 원합니다. 그러나 이를 수행할 일반적인 방법이 없으므로, 이 PEP는 이제 PEP 634의 의미론을 따릅니다.\u003c/p\u003e\n\u003ch4\u003e패턴이 아닌 피사체에서 \u003ccode\u003e__match_args__\u003c/code\u003e 조회 (Lookup of \u003cstrong\u003ematch_args\u003c/strong\u003e on the subject not the pattern)\u003c/h4\u003e\n\u003cp\u003e이 PEP의 초기 버전은 패턴에 지정된 클래스가 아니라 피사체(subject)의 클래스에서 \u003ccode\u003e__match_args__\u003c/code\u003e를 조회했습니다. 이는 몇 가지 이유로 기각되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e패턴에 지정된 클래스를 사용하는 것이 최적화에 더 적합하고 더 나은 성능을 제공할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e패턴에 지정된 클래스를 사용하는 것이 일부 경우에 더 나은 오류 보고를 제공할 잠재력이 있습니다.\u003c/li\u003e\n\u003cli\u003e두 접근 방식 모두 완벽하지 않으며, 둘 다 이상한 코너 케이스가 있습니다. 현상 유지는 혼란을 최소화합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003ccode\u003e__match_class__\u003c/code\u003e와 \u003ccode\u003e__match_container__\u003c/code\u003e를 단일 값으로 결합 (Combining \u003cstrong\u003ematch_class\u003c/strong\u003e and \u003cstrong\u003ematch_container\u003c/strong\u003e into a single value)\u003c/h4\u003e\n\u003cp\u003e이 PEP의 초기 버전은 \u003ccode\u003e__match_class__\u003c/code\u003e와 \u003ccode\u003e__match_container__\u003c/code\u003e를 \u003ccode\u003e__match_kind__\u003c/code\u003e라는 단일 값으로 결합했습니다. 단일 값을 사용하는 것이 성능 면에서 작은 이점이 있지만, 클래스 매칭 동작을 오버라이드할 때 컨테이너 매칭에 의도하지 않은 변경을 초래할 가능성이 높으며 그 반대도 마찬가지입니다.\u003c/p\u003e\n\u003ch3\u003e연기된 아이디어 (Deferred Ideas)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 원본 버전에는 \u003ccode\u003eMATCH_POSITIONAL\u003c/code\u003e 매치 종류와 클래스가 매칭에 대한 완전한 제어를 허용하는 특수 메서드 \u003ccode\u003e__deconstruct__\u003c/code\u003e가 포함되어 있었습니다. 이는 \u003ccode\u003esympy\u003c/code\u003e와 같은 라이브러리에 중요합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003esympy\u003c/code\u003e를 사용하여 다음과 같이 작성하고 싶을 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# sin(x)**2 + cos(x)**2 == 1\ncase Add(Pow(sin(a), 2), Pow(cos(b), 2)) if a == b:\n    return 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esympy\u003c/code\u003e가 현재 패턴 매칭으로 위치 패턴을 지원하는 것은 가능하지만, 까다롭습니다. 이러한 추가 기능이 있으면 쉽게 구현할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 아이디어는 3.11을 위한 향후 PEP에 포함될 예정입니다. 그러나 3.10 개발 주기에서는 그러한 변경을 하기에는 너무 늦습니다.\u003c/p\u003e\n\u003ch4\u003e모든 클래스 매치를 거부하는 별도의 값 (Having a separate value to reject all class matches)\u003c/h4\u003e\n\u003cp\u003e이 PEP의 초기 버전에는 \u003ccode\u003e__match_class__\u003c/code\u003e에 대한 별개의 값이 있었는데, 이를 통해 클래스는 분해(deconstruction)를 요구했을 모든 클래스 패턴을 매칭하지 않을 수 있었습니다. 그러나 \u003ccode\u003eMATCH_POSITIONAL\u003c/code\u003e이 도입되면 이는 중복될 것이며, 극히 드문 경우를 위해 명세를 복잡하게 만듭니다.\u003c/p\u003e\n\u003ch3\u003e코드 예시 (Code examples)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 예시 1\nclass Symbol:\n    __match_class__ = MATCH_SELF\n\n# 예시 2 (위에서 번역됨)\ncase [a, b] if a is b:\n    # ...\n\n# 예시 3 (위에서 번역됨)\ncase [a, *b, c]:\n    # ...\n\n# 예시 4 (위에서 번역됨)\ncase {\"x\": x, \"y\": y} if x \u003e 2:\n    # ...\n\n# 예시 5 (위에서 번역됨)\ncase {\"x\": x, \"y\": y, **z}:\n    # ...\n\n# 예시 6 (위에서 번역됨)\nmatch ClsName(x, y):\n    # ...\n\n# 예시 7 (위에서 번역됨)\nmatch ClsName(a=x, b=y):\n    # ...\n\n# 예시 8 (위에서 번역됨)\nmatch ClsName(x, a=y):\n    # ...\n\n# 예시 9 (Deferred Ideas 섹션에서 언급)\nclass Basic:\n    __match_class__ = MATCH_POSITIONAL\n    def __deconstruct__(self):\n        return self._args\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되거나 CC0-1.0-Universal 라이선스 중 더 관대한 조건에 따릅니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1599,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Draft] PEP 653 - Precise Semantics for Pattern Matching\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 09:52:27+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>