<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d6cea809dcbae606.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-0395f68b8cc78a20.js" async=""></script><script src="/_next/static/chunks/23-706b53707bbf0661.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-467e37449c5a68fc.js" async=""></script><script src="/_next/static/chunks/app/layout-b44b076173de406f.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2648<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 516 - Build system abstraction for pip/conda etc</h1><div class="page__meta"><time dateTime="2025-09-26 23:11:03+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0516/">PEP 516 - Build system abstraction for pip/conda etc</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 26-Oct-2015</p>
</blockquote>
<h1>PEP 516 – pip/conda 등을 위한 빌드 시스템 추상화</h1>
<h2>요약 (Abstract)</h2>
<p>이 PEP는 <code>pip</code> 및 기타 배포 또는 설치 도구들이 Python 소스 트리(개발자 트리 또는 소스 배포판(sdist))와 작업할 때 사용할 프로그래밍 인터페이스를 명세합니다. 이 프로그래밍 인터페이스는 <code>pip</code>을 현재 <code>setuptools</code>에 대한 강력한 의존성에서 분리할 수 있게 하는데, 이는 다음 두 가지 주요 이유 때문입니다:</p>
<ol>
<li><code>setuptools</code>처럼 보일 필요 없이 훨씬 사용하기 쉬운 새로운 빌드 시스템을 가능하게 합니다.</li>
<li><code>setuptools</code>가 <code>pip</code>을 손상시키지 않고 사용자 인터페이스를 변경할 수 있도록 하여, 더 느슨한 결합을 제공합니다.</li>
</ol>
<p><code>pip</code>이 빌드 시스템 자체를 설치할 수 있도록 하는 이 인터페이스는 패키지의 빌드 시점 요구사항(build time requirements)을 설치하는 것도 가능하게 하는데, 이는 <code>pip</code>이 <code>easy-install</code>의 설치 구성 요소와 완전히 동등한 기능을 갖추는 데 중요한 단계입니다.</p>
<p>PEP 426은 아직 초안(draft)이므로 해당 메타데이터 형식을 사용할 수 없습니다. 하지만 PEP 427 <code>wheel</code>은 널리 사용되고 잘 명세되어 있으므로, 배포 의존성 및 일반 프로젝트 메타데이터를 지정하기 위해 해당 <code>METADATA</code> 형식을 채택했습니다. PEP 508은 의존성을 설명하는 자체 포함된 언어를 제공하며, 이 언어를 얇은 JSON 스키마로 캡슐화하여 부트스트랩 의존성(bootstrap dependencies)을 설명합니다.</p>
<p>PEP 314에 명세된 Python <code>sdist</code> 또한 소스 트리이므로, 이 PEP는 <code>sdist</code>의 정의를 업데이트합니다.</p>
<h2>PEP 거절 (PEP Rejection)</h2>
<p>이 PEP에서 제안된 CLI(Command Line Interface) 기반 접근 방식은 PEP 517에서 제안된 Python API 기반 접근 방식이 선호되어 거절되었습니다. 격리된 서브프로세스로 실행되는 빌드 백엔드(build backends)와 통신하는 데 사용되는 특정 CLI는 프론트엔드 개발 도구 구현의 세부 사항으로 간주될 것입니다.</p>
<h2>동기 (Motivation)</h2>
<p>Python 패키징 생태계에서는 빌드 시스템과 <code>pip</code> 간의 현재의 고착(lock-in)에 대한 상당한 불만이 누적되어 있습니다. 이러한 고착을 해소하는 것은 <code>pip</code>, <code>setuptools</code>, 그리고 <code>flit</code>과 같은 다른 빌드 시스템 모두에게 더 좋습니다.</p>
<h2>명세 (Specification)</h2>
<h3>개요 (Overview)</h3>
<p>빌드 도구는 소스 트리의 루트 디렉토리에서 <code>pypa.json</code> 파일을 읽어서 찾습니다. 이 파일은 빌드 도구를 가져오는 방법과 도구를 호출하기 위해 실행할 명령어의 이름을 설명합니다. 모든 도구는 <code>pip</code>이 <code>setuptools</code>의 <code>setup.py</code> 인터페이스를 기존에 사용하던 방식을 모델로 한 단일 명령줄 인터페이스를 준수해야 합니다.</p>
<h3><code>pypa.json</code></h3>
<p><code>pypa.json</code> 파일은 <code>pip</code> 및 소스 트리를 빌드하려는 다른 도구들이 구성을 조회하는 중립적인 구성 파일 역할을 합니다. Python 소스 트리에 <code>pypa.json</code> 파일이 없으면 <code>setuptools</code> 또는 <code>setuptools</code> 호환 빌드 시스템을 의미합니다.</p>
<p>JSON 스키마는 다음과 같습니다. 추가 키는 무시되며, 이는 <code>pypa.json</code>이 다른 관련 도구의 구성 파일로 사용될 수 있도록 허용합니다. 이 경우 선택된 키는 <code>tools</code> 아래에 네임스페이스로 지정되어야 합니다:</p>
<pre><code class="language-json">{"tools": {"flit": ["Flits content here"]}}
</code></pre>
<ul>
<li><code>schema</code>: 스키마의 버전입니다. 이 PEP는 버전 "1"을 정의합니다. 생략 시 "1"이 기본값입니다. 파일을 읽는 모든 도구는 인식할 수 없는 스키마 버전에 대해 오류를 발생시켜야 합니다.</li>
<li><code>bootstrap_requires</code>: 빌드 도구를 실행하기 전에 설치해야 하는 PEP 508 의존성 명세의 선택적 목록입니다. 예를 들어, <code>flit</code>을 사용하는 경우 요구사항은 다음과 같을 수 있습니다: <code>["flit"]</code></li>
<li><code>build_command</code>: 필수 키입니다. 실행할 명령어를 설명하는 Python 포맷 문자열의 목록입니다. 예를 들어, <code>flit</code>을 사용하는 경우 빌드 명령어는 <code>["flit"]</code>일 수 있습니다. 만약 <code>fred</code>라는 실행 가능한 모듈인 명령어를 사용하는 경우: <code>["{PYTHON}", "-m", "fred"]</code></li>
</ul>
<h3>프로세스 인터페이스 (Process interface)</h3>
<p>실행할 명령어는 간단한 Python 포맷 문자열로 정의됩니다. 이는 전용 스크립트를 가진 빌드 시스템과 "<code>python -m somemodule</code>"을 사용하여 호출되는 빌드 시스템을 모두 허용합니다.</p>
<p>프로세스는 소스 트리의 루트를 현재 작업 디렉토리로 설정하여 실행됩니다. 실행 시, 프로세스는 <code>stdin</code>에서 읽어서는 안 됩니다. <code>pip</code>은 현재 <code>stdin</code>을 자체 <code>stdin</code>에 연결하여 빌드 시스템을 실행하지만, <code>stdout</code>과 <code>stderr</code>는 리디렉션되고 사용자(user)와의 통신은 불가능합니다.</p>
<p>일반적인 프로세스와 마찬가지로 0이 아닌 종료 상태는 오류를 나타냅니다.</p>
<h3>사용 가능한 포맷 변수 (Available format variables)</h3>
<ul>
<li><code>PYTHON</code>: 사용 중인 Python 인터프리터입니다. 이는 단순히 Python 진입점(entry points)인 것을 호출할 수 있도록 하는 데 중요합니다. 예: <code>{PYTHON} -m foo</code></li>
</ul>
<h3>사용 가능한 환경 변수 (Available environment variables)</h3>
<p>이 변수들은 빌드 시스템의 호출자(caller)에 의해 설정되며 항상 사용할 수 있습니다.</p>
<ul>
<li><code>PATH</code>: 표준 시스템 경로입니다.</li>
<li><code>PYTHON</code>: 포맷 변수와 동일합니다.</li>
<li><code>PYTHONPATH</code>: 일반적인 Python 메커니즘에 따라 <code>sys.path</code>를 제어하는 데 사용됩니다.</li>
</ul>
<h3>서브커맨드 (Subcommands)</h3>
<p>빌드 시스템이 지원해야 하는 몇 가지 개별 서브커맨드가 있습니다. 아래 예시는 설명을 위해 <code>flit</code>의 <code>build_command</code>를 사용합니다.</p>
<ul>
<li><code>build_requires</code>: 빌드 요구사항을 쿼리합니다. 빌드 요구사항은 PEP 508 의존성 명세 목록으로 구성된 <code>build_requires</code>라는 하나의 키를 가진 UTF-8 인코딩 JSON 문서로 반환됩니다. 추가 키는 무시해야 합니다. <code>build_requires</code> 명령어는 빌드 환경을 설정하지 않고 실행되는 유일한 명령어입니다.
예시: <code>flit build_requires</code></li>
<li><code>metadata</code>: 프로젝트 메타데이터를 쿼리합니다. 메타데이터만 <code>stdout</code>으로 UTF-8 인코딩으로 출력되어야 합니다. <code>pip</code>은 다른 패키지를 다운로드하고 설치해야 할지 결정하기 위해 <code>metadata</code>를 한 번만 실행합니다. 메타데이터는 PEP 427에 따른 <code>wheel METADATA</code> 파일로 출력됩니다.
<code>metadata</code> 명령어로 생성된 메타데이터와 생성된 <code>wheel</code>에 포함된 메타데이터는 동일해야 합니다.
예시: <code>flit metadata</code></li>
<li><code>wheel -d OUTPUT_DIR</code>: 프로젝트의 <code>wheel</code>을 빌드하기 위해 실행할 명령어입니다. <code>OUTPUT_DIR</code>은 <code>wheel</code>이 출력될 기존 디렉토리를 가리킵니다. <code>stdout</code> 및 <code>stderr</code>는 의미론적 의미가 없습니다. 하나의 파일만 출력되어야 합니다. 만약 더 많은 파일이 출력되면 <code>pip</code>은 임의의 파일을 선택하여 사용합니다.
예시: <code>flit wheel -d /tmp/pip-build_1234</code></li>
<li><code>develop [--prefix PREFIX]</code>: 프로젝트의 제자리(in-place) '개발' 설치를 수행하기 위한 명령어입니다. <code>stdout</code> 및 <code>stderr</code>는 의미론적 의미가 없습니다.
모든 빌드 시스템이 <code>develop</code> 설치를 수행할 수 있는 것은 아닙니다. 빌드 시스템이 <code>develop</code> 설치를 수행할 수 없는 경우 실행 시 오류를 발생시켜야 합니다. 이렇게 하면 <code>pip install -e foo</code>와 같은 작업이 실패하게 됩니다.
<code>prefix</code> 옵션은 설치를 위한 대체 <code>prefix</code>를 정의하는 데 사용됩니다. <code>setuptools</code>에는 <code>--root</code> 및 <code>--user</code> 옵션이 있지만, <code>--prefix</code>를 사용하여 동일하게 수행할 수 있으며, <code>--root</code> 또는 <code>--user</code> 옵션을 허용하는 <code>pip</code> 또는 다른 도구는 적절히 변환해야 합니다.
<code>root</code> 옵션은 명령어가 작동해야 하는 대체 루트를 정의하는 데 사용됩니다.
예를 들어: <code>flit develop --root /tmp/ --prefix /usr/local</code> 은 사용 중인 Python 환경이 <code>sys.prefix</code>가 <code>/usr/</code>라고 보고하여 <code>/tmp/usr/bin/</code>을 사용하게 되더라도 <code>/tmp/usr/local/bin</code> 내에 스크립트를 설치해야 합니다. 패키지 파일 등에도 유사한 로직이 적용됩니다.</li>
</ul>
<h3>빌드 환경 (The build environment)</h3>
<p><code>build_requires</code> 명령어를 제외하고, 모든 명령어는 빌드 환경 내에서 실행됩니다. 특정 구현은 요구되지 않지만, 빌드 환경은 다음 요구사항을 달성해야 합니다.</p>
<ul>
<li>프로젝트의 <code>build_requires</code>에 명시된 모든 의존성은 <code>$PYTHON</code> 내에서 임포트(import)할 수 있어야 합니다.</li>
<li>빌드에 필요한 패키지에서 제공하는 모든 명령줄 스크립트는 <code>$PATH</code>에 존재해야 합니다.</li>
</ul>
<p>이는 빌드 시스템이 <code>build_requires</code>로 선언되지 않았거나 Python 표준 라이브러리에 없는 어떠한 Python 패키지에 대한 접근도 가정할 수 없다는 것을 의미합니다.</p>
<h3>밀봉된 빌드 (Hermetic builds)</h3>
<p>이 명세는 빌드가 밀봉(hermetic)되어야 하는지 여부를 규정하지 않습니다. <code>setuptools</code>와 같은 기존 빌드 도구는 빌드 시점 요구사항(예: <code>setuptools_scm</code>)의 설치된 버전을 사용하며, 버전 충돌이나 누락된 의존성 시에만 다른 버전을 설치합니다. 그러나 항상 빌드를 격리하고 지정된 의존성만 사용하는 것이 더 나은 일관성을 생성할 수 있습니다.</p>
<p>그러나, 사용자가 일부 패키지 의존성을 충족하는 빌드 요구사항의 잘못된 버전을 강제로 피하는 방법과 같은 미묘한 문제가 있습니다. 미래의 PEP에서 이 문제를 다룰 수 있지만, 현재 범위에는 포함되지 않습니다. 이는 빌드 시스템과 빌드를 수행해야 하는 것들 간의 조정을 위해 필요한 메타데이터에 영향을 미치지 않으므로 PEP 자료가 아닙니다.</p>
<h3>업그레이드 (Upgrades)</h3>
<p><code>pypa.json</code>은 호환성 요구 없이 미래 변경을 허용하도록 버전이 지정됩니다.</p>
<p>새로운 PEP에서 스키마를 업그레이드하는 순서는 다음과 같습니다:</p>
<ol>
<li>업데이트된 스키마를 정의하는 새로운 PEP를 발행합니다. 스키마가 완전히 하위 호환되지 않는 경우 새로운 버전 번호를 정의해야 합니다.</li>
<li>컨슈머(예: <code>pip</code>)는 새로운 스키마 버전에 대한 지원을 구현합니다.</li>
<li>패키지 작성자는 새로운 스키마 버전에 대한 지원을 도입한 <code>pip</code> 버전(및 잠재적으로 다른 컨슈머)에 대한 의존성을 도입해도 괜찮을 때 새로운 스키마를 선택합니다.</li>
</ol>
<p>이 PEP의 초기 배포도 동일한 과정을 거칠 것입니다. <code>setuptools</code> 심(shim) 없이 이 PEP를 사용할 수 있는 기능의 전파는 주로 이를 지원하는 <code>pip</code>의 첫 번째 버전의 채택률에 따라 결정될 것입니다.</p>
<h3><code>sdist</code>의 정적 메타데이터 (Static metadata in sdists)</h3>
<p>이 PEP는 <code>sdist</code>의 정적 메타데이터를 신뢰할 수 없는 현재의 문제를 다루지 않습니다. 이는 소스 트리에서 사용되는 빌드 시스템을 식별하고 사용하는 것과는 별개의 문제입니다.</p>
<h3>컴파일러 옵션 처리 (Handling of compiler options)</h3>
<p>다른 컴파일러 옵션의 처리는 이 명세의 범위를 벗어납니다.</p>
<p><code>pip</code>은 현재 <code>setuptools</code>를 실행할 때 명령줄에 사용자 제공 문자열을 추가하여 컴파일러 옵션을 처리합니다. 이 접근 방식은 이 PEP에서 정의된 빌드 시스템 인터페이스와 함께 작동하기에 충분하지만, 전역적으로 지정된 옵션은 다른 빌드 시스템이 발전함에 따라 전역적으로 작동하지 않게 됩니다. 이 문제는 <code>pip</code>(또는 <code>conda</code> 또는 다른 설치 프로그램)에서 상호 운용성에 영향을 미치지 않고 해결할 수 있습니다.</p>
<p>장기적으로 <code>wheel</code>은 한 컴파일러 또는 옵션으로 빌드된 <code>wheel</code>과 다른 <code>wheel</code> 간의 차이를 표현할 수 있어야 하며, 이는 PEP 자료입니다.</p>
<h2>예시 (Examples)</h2>
<p><code>flit</code>을 사용하기 위한 <code>pypa.json</code> 예시:</p>
<pre><code class="language-json">{"bootstrap_requires": ["flit"], "build_command": "flit"}
</code></pre>
<p><code>pip</code>이 이를 읽으면 <code>flit</code>을 사용하기 전에 <code>flit</code>이 포함된 환경을 준비할 것입니다.</p>
<p><code>flit</code>은 현재 <code>setup-requires</code> 지원이 없으므로, <code>flit build_requires</code>는 다음과 같은 상수 문자열을 출력할 것입니다:</p>
<pre><code class="language-json">{"build_requires": []}
</code></pre>
<p><code>flit metadata</code>는 <code>flit.ini</code>를 쿼리하고 메타데이터를 <code>wheel METADATA</code> 파일로 마샬링하여 <code>stdout</code>으로 출력할 것입니다.</p>
<p><code>flit wheel</code>은 <code>wheel</code>을 출력할 위치를 알려주는 <code>-d</code> 매개변수를 받아야 합니다 (<code>pip</code>에 필요합니다).</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>오래된 <code>pip</code> 버전은 대체 빌드 시스템을 처리할 수 없을 것입니다. 이는 현상 유지와 다르지 않으며, 개별 빌드 시스템 프로젝트는 <code>setup.py</code> 심(shim)을 포함할지 여부를 결정할 수 있습니다.</p>
<p><code>wheel</code>을 생성하고 <code>develop</code> 설치를 수행할 수 있는 모든 기존 빌드 시스템은 이 추상화 하에서 실행될 수 있어야 하며, <code>PyPI</code>에 특정 어댑터를 구축하고 게시하기만 하면 됩니다.</p>
<p><code>pypa.json</code> 파일이 없는 경우, <code>pip</code>과 같은 도구는 <code>setuptools</code> 빌드 시스템을 가정하고 <code>setuptools</code> 명령어를 직접 사용해야 합니다.</p>
<h3>네트워크 효과 (Network effects)</h3>
<p><code>setuptools</code>와 호환되지 않는 빌드 시스템을 채택하는 프로젝트(즉, <code>setup.py</code>가 없거나, <code>setup.py</code>가 기존 도구가 사용하려는 명령어를 허용하지 않는 경우)는 기존 도구에 의해 설치될 수 없을 것입니다.</p>
<p>이러한 프로젝트가 다른 프로젝트에 의해 사용될 경우, 이 효과는 계단식으로 발생할 것입니다.</p>
<p>특히 <code>pip</code>이 현재 <code>setup-requires</code>를 처리하지 않기 때문에, <code>setuptools</code>와 호환되지 않는 빌드 시스템을 채택하고 (A) 두 번째 프로젝트 (B)가 <code>pypa.json</code>으로 전환하지 않은 상태에서 <code>setup-requirement</code>로 사용되는 모든 프로젝트 (A)는 어떤 <code>pip</code> 버전에서도 B를 설치할 수 없게 만들 것입니다. 이는 B의 <code>setup.py</code>가 <code>pip</code>에 의해 '<code>setup.py egg_info</code>'가 실행될 때 <code>easy-install</code>을 트리거하고, 그것이 A를 설치하려다 실패할 것이기 때문입니다.</p>
<p>따라서 현재 <code>setup-requires</code>로 사용되는 도구는 <code>setuptools</code> 심을 유지하거나, 소비자를 찾아 <code>pypa.json</code> 사용으로 미리 업그레이드하도록 하는 것을 권장합니다. 현실적으로 이는 불가능하므로, <code>pbr</code>, <code>setuptools_scm</code>과 같은 프로젝트와 <code>numpy</code>와 같은 프로젝트 모두에 대해 <code>setuptools</code> 심을 무기한으로 유지하는 것이 좋습니다.</p>
<h3><code>setuptools</code> 심 (setuptools shim)</h3>
<p><code>setup.py</code>처럼 보이고 내부적으로 <code>pypa.json</code>을 사용하여 빌드를 구동하는 일반적인 <code>setuptools</code> 심을 작성하는 것이 가능할 것입니다. 이는 <code>pip</code>이 시스템을 사용하는 데 필요하지 않지만, 패키지 작성자가 새 기능을 사용하면서도 이전 <code>pip</code> 버전과의 호환성을 유지할 수 있도록 할 것입니다.</p>
<h2>근거 (Rationale)</h2>
<p>이 PEP는 <code>distutils-sig</code>의 긴 메일링 리스트 스레드에서 시작되었습니다. 그 후 온라인 회의가 열려 사람들이 가지고 있던 모든 입장을 디버깅했습니다. 회의록은 목록에 게시되었습니다.</p>
<p>이 명세는 거기서 도달한 합의를 PEP 형식으로 번역한 것이며, 남아있는 사소한 질문에 대한 몇 가지 임의의 선택이 포함되어 있습니다.</p>
<p>설계의 기본 휴리스틱은 추상화에 엄격하게 묶이지 않은 개발을 요구하지 않고 추상화를 도입하는 데 중점을 두는 것이었습니다. 개선과의 격차가 작거나 기존 인터페이스를 사용하는 비용이 매우 높은 경우, 개선을 의존성으로 받아들였지만, 그렇지 않은 경우 미래의 반복으로 미루었습니다.</p>
<p>새로운 명세를 정의하는 대신 <code>wheel METADATA</code> 파일을 선택한 이유는 <code>pip</code>이 이미 <code>METADATA</code> 파일에 필요한 모든 데이터를 인코딩하는 <code>wheel .dist-info</code> 디렉토리를 처리할 수 있기 때문입니다. PEP 426은 아직 초안이므로 사용할 수 없으며, 새로운 메타데이터 형식을 정의하는 것은 별개의 문제입니다. 디스크에 디렉토리를 사용하는 것은 인터페이스에 어떠한 가치도 추가하지 않을 것입니다 (<code>setuptools CLI</code>의 제한으로 인해 <code>pip</code>이 현재 그렇게 해야 합니다).</p>
<p><code>develop</code>을 명령어로 사용하는 이유는 '<code>setuptools develop</code>'이 하는 일의 상호 운용성을 명세하는 PEP가 없기 때문입니다. 따라서 <code>pip</code>이 '<code>develop</code>' 단계를 수행할 책임을 맡기 전에 이를 정의해야 할 것입니다. 일단 그렇게 되면 이 PEP의 후속 PEP를 발행할 수 있을 것입니다.</p>
<p>Python API 대신 명령줄 API를 사용하는 것은 다소 논란의 여지가 있습니다. 근본적으로 모든 것이 작동하도록 만들 수 있으며, <code>pip</code> 유지보수자는 현재 <code>pip</code>에서 성숙하고 견고한 프로세스 기반 인터페이스를 유지하는 것을 강력히 지지해왔습니다.</p>
<p>파일 형식으로 JSON을 선택한 것은 여러 제약 조건 간의 타협입니다. 첫째, <code>YAML</code> 인터프리터나 다른 마찰이 적은 구조화된 파일 형식에 대한 <code>stdlib</code>가 없습니다. 둘째, <code>INIParser</code>는 여러 이유로 좋지 않은 형식인데, 주로 구조가 매우 최소한이기 때문입니다. 하지만 <code>pip</code>의 유지보수자들은 <code>INIParser</code>를 좋아하지 않습니다. JSON은 <code>stdlib</code>에 있으며, 미래에 원하는 모든 것을 내장 DSL 없이도 포함할 수 있는 충분한 구조를 가지고 있습니다.</p>
<p>Donald는 새로운 것을 발명하는 대신 <code>setup.cfg</code>와 기존 <code>setuptools</code> 명령줄을 사용할 것을 제안했습니다. 이는 덜 가시적인 변경으로 상호 운용성을 허용할 수 있지만, <code>pip</code> 측면에서는 거의 동일한 엔지니어링 작업이 필요합니다. (<code>setup.cfg</code>에서 새 키를 찾고, 빌드를 실행할 비설치 환경을 구현하는 것) 그리고 다른 빌드 시스템 작성자들이 <code>setuptools</code>와 비슷하지만 다르게 작동하는 것을 제공하여 사용자들을 혼란스럽게 하고 싶지 않다는 바람은 <code>pip</code>이 사용자 정의 빌드 도구를 호출하는 방법을 배우는 것보다 더 큰 문제로 보입니다.</p>
<p><code>metadata</code> 및 <code>wheel</code> 명령어는 일관된 메타데이터를 가져야 합니다. 이는 <code>pip</code>이 메타데이터를 읽고 그에 따라 행동한 다음, 결과 <code>wheel</code>이 호환되지 않는 요구사항을 가질 수 있는 레이스 컨디션(race condition)을 피하기 위함입니다. 이 레이스 컨디션은 현재 PEP 426 환경 마커를 사용하는 패키지에서 환경 마커를 지원하지 않는 이전 <code>pip</code> 버전과 함께 작동하기 위해 악용됩니다. 이 PEP에서는 해당 악용이 필요하지 않습니다. <code>setuptools</code> 심이 사용되거나 (이전 <code>pip</code> 버전의 경우) 환경 마커를 지원하는 <code>pip</code>이 사용되기 때문입니다. <code>setuptools</code> 심은 이전 <code>pip</code> 버전이 요구하는 차이점을 악용하는 것을 처리할 수 있습니다.</p>
<p><code>sdist</code> 동사(verb)를 갖는 것에 대해 논의했습니다. 주된 동기는 빌드 시스템이 <code>pip</code>이 빌드할 수 있는 <code>sdist</code>를 생성할 수 있도록 하는 것이었지만, 이는 순환적입니다. 이 PEP의 전체 요점은 <code>pip</code>이 <code>setuptools</code>의 구현을 요구하지 않고도 이러한 <code>sdist</code> 또는 VCS 소스 트리를 안정적으로 사용할 수 있도록 하는 것입니다. 기존 소스 트리에서 새로운 <code>sdist</code>를 생성하는 것은 <code>pip</code>이 현재 수행하는 작업이 아니며, 소스에서 빌드하는 과정의 일부로 이를 수행하는 PR이 있지만 논란의 여지가 있고 합의가 부족합니다. 모든 빌드 시스템에 요구사항을 부과하기보다는, 이를 YAGNI(You Aren't Gonna Need It)로 취급하고, 필요한 경우 인터페이스의 미래 버전에 이러한 동사를 추가할 것입니다. <code>sdist</code>에 대한 기존 PEP 314 요구사항은 여전히 적용되며, <code>distutils</code> 또는 <code>setuptools</code> 사용자는 <code>setup.py sdist</code>를 사용하여 <code>sdist</code>를 생성할 수 있습니다. 다른 도구는 PEP 314와 호환되는 <code>sdist</code>를 생성해야 합니다. <code>pip</code> 자체는 PEP 314 호환성을 요구하지 않습니다. <code>sdist</code>의 메타데이터를 사용하지 않으며, 디스크 또는 버전 관리의 소스 트리처럼 취급됩니다.</p>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/515/">[Final] PEP 515 - Underscores in Numeric Literals</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Rejected] PEP 516 - Build system abstraction for pip/conda etc</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/517/">[Final] PEP 517 - A build-system independent format for source trees</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d6cea809dcbae606.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-b44b076173de406f.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/516\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d6cea809dcbae606.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"sXH0w-Ur4uCLT-31_N3TA\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/516/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/516\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"516\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/516\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"default\"]\ne:T609f,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0516/\"\u003ePEP 516 - Build system abstraction for pip/conda etc\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 26-Oct-2015\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 516 – pip/conda 등을 위한 빌드 시스템 추상화\u003c/h1\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003epip\u003c/code\u003e 및 기타 배포 또는 설치 도구들이 Python 소스 트리(개발자 트리 또는 소스 배포판(sdist))와 작업할 때 사용할 프로그래밍 인터페이스를 명세합니다. 이 프로그래밍 인터페이스는 \u003ccode\u003epip\u003c/code\u003e을 현재 \u003ccode\u003esetuptools\u003c/code\u003e에 대한 강력한 의존성에서 분리할 수 있게 하는데, 이는 다음 두 가지 주요 이유 때문입니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003esetuptools\u003c/code\u003e처럼 보일 필요 없이 훨씬 사용하기 쉬운 새로운 빌드 시스템을 가능하게 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esetuptools\u003c/code\u003e가 \u003ccode\u003epip\u003c/code\u003e을 손상시키지 않고 사용자 인터페이스를 변경할 수 있도록 하여, 더 느슨한 결합을 제공합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ccode\u003epip\u003c/code\u003e이 빌드 시스템 자체를 설치할 수 있도록 하는 이 인터페이스는 패키지의 빌드 시점 요구사항(build time requirements)을 설치하는 것도 가능하게 하는데, 이는 \u003ccode\u003epip\u003c/code\u003e이 \u003ccode\u003eeasy-install\u003c/code\u003e의 설치 구성 요소와 완전히 동등한 기능을 갖추는 데 중요한 단계입니다.\u003c/p\u003e\n\u003cp\u003ePEP 426은 아직 초안(draft)이므로 해당 메타데이터 형식을 사용할 수 없습니다. 하지만 PEP 427 \u003ccode\u003ewheel\u003c/code\u003e은 널리 사용되고 잘 명세되어 있으므로, 배포 의존성 및 일반 프로젝트 메타데이터를 지정하기 위해 해당 \u003ccode\u003eMETADATA\u003c/code\u003e 형식을 채택했습니다. PEP 508은 의존성을 설명하는 자체 포함된 언어를 제공하며, 이 언어를 얇은 JSON 스키마로 캡슐화하여 부트스트랩 의존성(bootstrap dependencies)을 설명합니다.\u003c/p\u003e\n\u003cp\u003ePEP 314에 명세된 Python \u003ccode\u003esdist\u003c/code\u003e 또한 소스 트리이므로, 이 PEP는 \u003ccode\u003esdist\u003c/code\u003e의 정의를 업데이트합니다.\u003c/p\u003e\n\u003ch2\u003ePEP 거절 (PEP Rejection)\u003c/h2\u003e\n\u003cp\u003e이 PEP에서 제안된 CLI(Command Line Interface) 기반 접근 방식은 PEP 517에서 제안된 Python API 기반 접근 방식이 선호되어 거절되었습니다. 격리된 서브프로세스로 실행되는 빌드 백엔드(build backends)와 통신하는 데 사용되는 특정 CLI는 프론트엔드 개발 도구 구현의 세부 사항으로 간주될 것입니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePython 패키징 생태계에서는 빌드 시스템과 \u003ccode\u003epip\u003c/code\u003e 간의 현재의 고착(lock-in)에 대한 상당한 불만이 누적되어 있습니다. 이러한 고착을 해소하는 것은 \u003ccode\u003epip\u003c/code\u003e, \u003ccode\u003esetuptools\u003c/code\u003e, 그리고 \u003ccode\u003eflit\u003c/code\u003e과 같은 다른 빌드 시스템 모두에게 더 좋습니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003ch3\u003e개요 (Overview)\u003c/h3\u003e\n\u003cp\u003e빌드 도구는 소스 트리의 루트 디렉토리에서 \u003ccode\u003epypa.json\u003c/code\u003e 파일을 읽어서 찾습니다. 이 파일은 빌드 도구를 가져오는 방법과 도구를 호출하기 위해 실행할 명령어의 이름을 설명합니다. 모든 도구는 \u003ccode\u003epip\u003c/code\u003e이 \u003ccode\u003esetuptools\u003c/code\u003e의 \u003ccode\u003esetup.py\u003c/code\u003e 인터페이스를 기존에 사용하던 방식을 모델로 한 단일 명령줄 인터페이스를 준수해야 합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003epypa.json\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epypa.json\u003c/code\u003e 파일은 \u003ccode\u003epip\u003c/code\u003e 및 소스 트리를 빌드하려는 다른 도구들이 구성을 조회하는 중립적인 구성 파일 역할을 합니다. Python 소스 트리에 \u003ccode\u003epypa.json\u003c/code\u003e 파일이 없으면 \u003ccode\u003esetuptools\u003c/code\u003e 또는 \u003ccode\u003esetuptools\u003c/code\u003e 호환 빌드 시스템을 의미합니다.\u003c/p\u003e\n\u003cp\u003eJSON 스키마는 다음과 같습니다. 추가 키는 무시되며, 이는 \u003ccode\u003epypa.json\u003c/code\u003e이 다른 관련 도구의 구성 파일로 사용될 수 있도록 허용합니다. 이 경우 선택된 키는 \u003ccode\u003etools\u003c/code\u003e 아래에 네임스페이스로 지정되어야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\"tools\": {\"flit\": [\"Flits content here\"]}}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eschema\u003c/code\u003e: 스키마의 버전입니다. 이 PEP는 버전 \"1\"을 정의합니다. 생략 시 \"1\"이 기본값입니다. 파일을 읽는 모든 도구는 인식할 수 없는 스키마 버전에 대해 오류를 발생시켜야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebootstrap_requires\u003c/code\u003e: 빌드 도구를 실행하기 전에 설치해야 하는 PEP 508 의존성 명세의 선택적 목록입니다. 예를 들어, \u003ccode\u003eflit\u003c/code\u003e을 사용하는 경우 요구사항은 다음과 같을 수 있습니다: \u003ccode\u003e[\"flit\"]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebuild_command\u003c/code\u003e: 필수 키입니다. 실행할 명령어를 설명하는 Python 포맷 문자열의 목록입니다. 예를 들어, \u003ccode\u003eflit\u003c/code\u003e을 사용하는 경우 빌드 명령어는 \u003ccode\u003e[\"flit\"]\u003c/code\u003e일 수 있습니다. 만약 \u003ccode\u003efred\u003c/code\u003e라는 실행 가능한 모듈인 명령어를 사용하는 경우: \u003ccode\u003e[\"{PYTHON}\", \"-m\", \"fred\"]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e프로세스 인터페이스 (Process interface)\u003c/h3\u003e\n\u003cp\u003e실행할 명령어는 간단한 Python 포맷 문자열로 정의됩니다. 이는 전용 스크립트를 가진 빌드 시스템과 \"\u003ccode\u003epython -m somemodule\u003c/code\u003e\"을 사용하여 호출되는 빌드 시스템을 모두 허용합니다.\u003c/p\u003e\n\u003cp\u003e프로세스는 소스 트리의 루트를 현재 작업 디렉토리로 설정하여 실행됩니다. 실행 시, 프로세스는 \u003ccode\u003estdin\u003c/code\u003e에서 읽어서는 안 됩니다. \u003ccode\u003epip\u003c/code\u003e은 현재 \u003ccode\u003estdin\u003c/code\u003e을 자체 \u003ccode\u003estdin\u003c/code\u003e에 연결하여 빌드 시스템을 실행하지만, \u003ccode\u003estdout\u003c/code\u003e과 \u003ccode\u003estderr\u003c/code\u003e는 리디렉션되고 사용자(user)와의 통신은 불가능합니다.\u003c/p\u003e\n\u003cp\u003e일반적인 프로세스와 마찬가지로 0이 아닌 종료 상태는 오류를 나타냅니다.\u003c/p\u003e\n\u003ch3\u003e사용 가능한 포맷 변수 (Available format variables)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePYTHON\u003c/code\u003e: 사용 중인 Python 인터프리터입니다. 이는 단순히 Python 진입점(entry points)인 것을 호출할 수 있도록 하는 데 중요합니다. 예: \u003ccode\u003e{PYTHON} -m foo\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e사용 가능한 환경 변수 (Available environment variables)\u003c/h3\u003e\n\u003cp\u003e이 변수들은 빌드 시스템의 호출자(caller)에 의해 설정되며 항상 사용할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePATH\u003c/code\u003e: 표준 시스템 경로입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePYTHON\u003c/code\u003e: 포맷 변수와 동일합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePYTHONPATH\u003c/code\u003e: 일반적인 Python 메커니즘에 따라 \u003ccode\u003esys.path\u003c/code\u003e를 제어하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e서브커맨드 (Subcommands)\u003c/h3\u003e\n\u003cp\u003e빌드 시스템이 지원해야 하는 몇 가지 개별 서브커맨드가 있습니다. 아래 예시는 설명을 위해 \u003ccode\u003eflit\u003c/code\u003e의 \u003ccode\u003ebuild_command\u003c/code\u003e를 사용합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebuild_requires\u003c/code\u003e: 빌드 요구사항을 쿼리합니다. 빌드 요구사항은 PEP 508 의존성 명세 목록으로 구성된 \u003ccode\u003ebuild_requires\u003c/code\u003e라는 하나의 키를 가진 UTF-8 인코딩 JSON 문서로 반환됩니다. 추가 키는 무시해야 합니다. \u003ccode\u003ebuild_requires\u003c/code\u003e 명령어는 빌드 환경을 설정하지 않고 실행되는 유일한 명령어입니다.\n예시: \u003ccode\u003eflit build_requires\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emetadata\u003c/code\u003e: 프로젝트 메타데이터를 쿼리합니다. 메타데이터만 \u003ccode\u003estdout\u003c/code\u003e으로 UTF-8 인코딩으로 출력되어야 합니다. \u003ccode\u003epip\u003c/code\u003e은 다른 패키지를 다운로드하고 설치해야 할지 결정하기 위해 \u003ccode\u003emetadata\u003c/code\u003e를 한 번만 실행합니다. 메타데이터는 PEP 427에 따른 \u003ccode\u003ewheel METADATA\u003c/code\u003e 파일로 출력됩니다.\n\u003ccode\u003emetadata\u003c/code\u003e 명령어로 생성된 메타데이터와 생성된 \u003ccode\u003ewheel\u003c/code\u003e에 포함된 메타데이터는 동일해야 합니다.\n예시: \u003ccode\u003eflit metadata\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewheel -d OUTPUT_DIR\u003c/code\u003e: 프로젝트의 \u003ccode\u003ewheel\u003c/code\u003e을 빌드하기 위해 실행할 명령어입니다. \u003ccode\u003eOUTPUT_DIR\u003c/code\u003e은 \u003ccode\u003ewheel\u003c/code\u003e이 출력될 기존 디렉토리를 가리킵니다. \u003ccode\u003estdout\u003c/code\u003e 및 \u003ccode\u003estderr\u003c/code\u003e는 의미론적 의미가 없습니다. 하나의 파일만 출력되어야 합니다. 만약 더 많은 파일이 출력되면 \u003ccode\u003epip\u003c/code\u003e은 임의의 파일을 선택하여 사용합니다.\n예시: \u003ccode\u003eflit wheel -d /tmp/pip-build_1234\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edevelop [--prefix PREFIX]\u003c/code\u003e: 프로젝트의 제자리(in-place) '개발' 설치를 수행하기 위한 명령어입니다. \u003ccode\u003estdout\u003c/code\u003e 및 \u003ccode\u003estderr\u003c/code\u003e는 의미론적 의미가 없습니다.\n모든 빌드 시스템이 \u003ccode\u003edevelop\u003c/code\u003e 설치를 수행할 수 있는 것은 아닙니다. 빌드 시스템이 \u003ccode\u003edevelop\u003c/code\u003e 설치를 수행할 수 없는 경우 실행 시 오류를 발생시켜야 합니다. 이렇게 하면 \u003ccode\u003epip install -e foo\u003c/code\u003e와 같은 작업이 실패하게 됩니다.\n\u003ccode\u003eprefix\u003c/code\u003e 옵션은 설치를 위한 대체 \u003ccode\u003eprefix\u003c/code\u003e를 정의하는 데 사용됩니다. \u003ccode\u003esetuptools\u003c/code\u003e에는 \u003ccode\u003e--root\u003c/code\u003e 및 \u003ccode\u003e--user\u003c/code\u003e 옵션이 있지만, \u003ccode\u003e--prefix\u003c/code\u003e를 사용하여 동일하게 수행할 수 있으며, \u003ccode\u003e--root\u003c/code\u003e 또는 \u003ccode\u003e--user\u003c/code\u003e 옵션을 허용하는 \u003ccode\u003epip\u003c/code\u003e 또는 다른 도구는 적절히 변환해야 합니다.\n\u003ccode\u003eroot\u003c/code\u003e 옵션은 명령어가 작동해야 하는 대체 루트를 정의하는 데 사용됩니다.\n예를 들어: \u003ccode\u003eflit develop --root /tmp/ --prefix /usr/local\u003c/code\u003e 은 사용 중인 Python 환경이 \u003ccode\u003esys.prefix\u003c/code\u003e가 \u003ccode\u003e/usr/\u003c/code\u003e라고 보고하여 \u003ccode\u003e/tmp/usr/bin/\u003c/code\u003e을 사용하게 되더라도 \u003ccode\u003e/tmp/usr/local/bin\u003c/code\u003e 내에 스크립트를 설치해야 합니다. 패키지 파일 등에도 유사한 로직이 적용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e빌드 환경 (The build environment)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ebuild_requires\u003c/code\u003e 명령어를 제외하고, 모든 명령어는 빌드 환경 내에서 실행됩니다. 특정 구현은 요구되지 않지만, 빌드 환경은 다음 요구사항을 달성해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프로젝트의 \u003ccode\u003ebuild_requires\u003c/code\u003e에 명시된 모든 의존성은 \u003ccode\u003e$PYTHON\u003c/code\u003e 내에서 임포트(import)할 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e빌드에 필요한 패키지에서 제공하는 모든 명령줄 스크립트는 \u003ccode\u003e$PATH\u003c/code\u003e에 존재해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 빌드 시스템이 \u003ccode\u003ebuild_requires\u003c/code\u003e로 선언되지 않았거나 Python 표준 라이브러리에 없는 어떠한 Python 패키지에 대한 접근도 가정할 수 없다는 것을 의미합니다.\u003c/p\u003e\n\u003ch3\u003e밀봉된 빌드 (Hermetic builds)\u003c/h3\u003e\n\u003cp\u003e이 명세는 빌드가 밀봉(hermetic)되어야 하는지 여부를 규정하지 않습니다. \u003ccode\u003esetuptools\u003c/code\u003e와 같은 기존 빌드 도구는 빌드 시점 요구사항(예: \u003ccode\u003esetuptools_scm\u003c/code\u003e)의 설치된 버전을 사용하며, 버전 충돌이나 누락된 의존성 시에만 다른 버전을 설치합니다. 그러나 항상 빌드를 격리하고 지정된 의존성만 사용하는 것이 더 나은 일관성을 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나, 사용자가 일부 패키지 의존성을 충족하는 빌드 요구사항의 잘못된 버전을 강제로 피하는 방법과 같은 미묘한 문제가 있습니다. 미래의 PEP에서 이 문제를 다룰 수 있지만, 현재 범위에는 포함되지 않습니다. 이는 빌드 시스템과 빌드를 수행해야 하는 것들 간의 조정을 위해 필요한 메타데이터에 영향을 미치지 않으므로 PEP 자료가 아닙니다.\u003c/p\u003e\n\u003ch3\u003e업그레이드 (Upgrades)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epypa.json\u003c/code\u003e은 호환성 요구 없이 미래 변경을 허용하도록 버전이 지정됩니다.\u003c/p\u003e\n\u003cp\u003e새로운 PEP에서 스키마를 업그레이드하는 순서는 다음과 같습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e업데이트된 스키마를 정의하는 새로운 PEP를 발행합니다. 스키마가 완전히 하위 호환되지 않는 경우 새로운 버전 번호를 정의해야 합니다.\u003c/li\u003e\n\u003cli\u003e컨슈머(예: \u003ccode\u003epip\u003c/code\u003e)는 새로운 스키마 버전에 대한 지원을 구현합니다.\u003c/li\u003e\n\u003cli\u003e패키지 작성자는 새로운 스키마 버전에 대한 지원을 도입한 \u003ccode\u003epip\u003c/code\u003e 버전(및 잠재적으로 다른 컨슈머)에 대한 의존성을 도입해도 괜찮을 때 새로운 스키마를 선택합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 PEP의 초기 배포도 동일한 과정을 거칠 것입니다. \u003ccode\u003esetuptools\u003c/code\u003e 심(shim) 없이 이 PEP를 사용할 수 있는 기능의 전파는 주로 이를 지원하는 \u003ccode\u003epip\u003c/code\u003e의 첫 번째 버전의 채택률에 따라 결정될 것입니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003esdist\u003c/code\u003e의 정적 메타데이터 (Static metadata in sdists)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003esdist\u003c/code\u003e의 정적 메타데이터를 신뢰할 수 없는 현재의 문제를 다루지 않습니다. 이는 소스 트리에서 사용되는 빌드 시스템을 식별하고 사용하는 것과는 별개의 문제입니다.\u003c/p\u003e\n\u003ch3\u003e컴파일러 옵션 처리 (Handling of compiler options)\u003c/h3\u003e\n\u003cp\u003e다른 컴파일러 옵션의 처리는 이 명세의 범위를 벗어납니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epip\u003c/code\u003e은 현재 \u003ccode\u003esetuptools\u003c/code\u003e를 실행할 때 명령줄에 사용자 제공 문자열을 추가하여 컴파일러 옵션을 처리합니다. 이 접근 방식은 이 PEP에서 정의된 빌드 시스템 인터페이스와 함께 작동하기에 충분하지만, 전역적으로 지정된 옵션은 다른 빌드 시스템이 발전함에 따라 전역적으로 작동하지 않게 됩니다. 이 문제는 \u003ccode\u003epip\u003c/code\u003e(또는 \u003ccode\u003econda\u003c/code\u003e 또는 다른 설치 프로그램)에서 상호 운용성에 영향을 미치지 않고 해결할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e장기적으로 \u003ccode\u003ewheel\u003c/code\u003e은 한 컴파일러 또는 옵션으로 빌드된 \u003ccode\u003ewheel\u003c/code\u003e과 다른 \u003ccode\u003ewheel\u003c/code\u003e 간의 차이를 표현할 수 있어야 하며, 이는 PEP 자료입니다.\u003c/p\u003e\n\u003ch2\u003e예시 (Examples)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eflit\u003c/code\u003e을 사용하기 위한 \u003ccode\u003epypa.json\u003c/code\u003e 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\"bootstrap_requires\": [\"flit\"], \"build_command\": \"flit\"}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epip\u003c/code\u003e이 이를 읽으면 \u003ccode\u003eflit\u003c/code\u003e을 사용하기 전에 \u003ccode\u003eflit\u003c/code\u003e이 포함된 환경을 준비할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eflit\u003c/code\u003e은 현재 \u003ccode\u003esetup-requires\u003c/code\u003e 지원이 없으므로, \u003ccode\u003eflit build_requires\u003c/code\u003e는 다음과 같은 상수 문자열을 출력할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\"build_requires\": []}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eflit metadata\u003c/code\u003e는 \u003ccode\u003eflit.ini\u003c/code\u003e를 쿼리하고 메타데이터를 \u003ccode\u003ewheel METADATA\u003c/code\u003e 파일로 마샬링하여 \u003ccode\u003estdout\u003c/code\u003e으로 출력할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eflit wheel\u003c/code\u003e은 \u003ccode\u003ewheel\u003c/code\u003e을 출력할 위치를 알려주는 \u003ccode\u003e-d\u003c/code\u003e 매개변수를 받아야 합니다 (\u003ccode\u003epip\u003c/code\u003e에 필요합니다).\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e오래된 \u003ccode\u003epip\u003c/code\u003e 버전은 대체 빌드 시스템을 처리할 수 없을 것입니다. 이는 현상 유지와 다르지 않으며, 개별 빌드 시스템 프로젝트는 \u003ccode\u003esetup.py\u003c/code\u003e 심(shim)을 포함할지 여부를 결정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewheel\u003c/code\u003e을 생성하고 \u003ccode\u003edevelop\u003c/code\u003e 설치를 수행할 수 있는 모든 기존 빌드 시스템은 이 추상화 하에서 실행될 수 있어야 하며, \u003ccode\u003ePyPI\u003c/code\u003e에 특정 어댑터를 구축하고 게시하기만 하면 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epypa.json\u003c/code\u003e 파일이 없는 경우, \u003ccode\u003epip\u003c/code\u003e과 같은 도구는 \u003ccode\u003esetuptools\u003c/code\u003e 빌드 시스템을 가정하고 \u003ccode\u003esetuptools\u003c/code\u003e 명령어를 직접 사용해야 합니다.\u003c/p\u003e\n\u003ch3\u003e네트워크 효과 (Network effects)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esetuptools\u003c/code\u003e와 호환되지 않는 빌드 시스템을 채택하는 프로젝트(즉, \u003ccode\u003esetup.py\u003c/code\u003e가 없거나, \u003ccode\u003esetup.py\u003c/code\u003e가 기존 도구가 사용하려는 명령어를 허용하지 않는 경우)는 기존 도구에 의해 설치될 수 없을 것입니다.\u003c/p\u003e\n\u003cp\u003e이러한 프로젝트가 다른 프로젝트에 의해 사용될 경우, 이 효과는 계단식으로 발생할 것입니다.\u003c/p\u003e\n\u003cp\u003e특히 \u003ccode\u003epip\u003c/code\u003e이 현재 \u003ccode\u003esetup-requires\u003c/code\u003e를 처리하지 않기 때문에, \u003ccode\u003esetuptools\u003c/code\u003e와 호환되지 않는 빌드 시스템을 채택하고 (A) 두 번째 프로젝트 (B)가 \u003ccode\u003epypa.json\u003c/code\u003e으로 전환하지 않은 상태에서 \u003ccode\u003esetup-requirement\u003c/code\u003e로 사용되는 모든 프로젝트 (A)는 어떤 \u003ccode\u003epip\u003c/code\u003e 버전에서도 B를 설치할 수 없게 만들 것입니다. 이는 B의 \u003ccode\u003esetup.py\u003c/code\u003e가 \u003ccode\u003epip\u003c/code\u003e에 의해 '\u003ccode\u003esetup.py egg_info\u003c/code\u003e'가 실행될 때 \u003ccode\u003eeasy-install\u003c/code\u003e을 트리거하고, 그것이 A를 설치하려다 실패할 것이기 때문입니다.\u003c/p\u003e\n\u003cp\u003e따라서 현재 \u003ccode\u003esetup-requires\u003c/code\u003e로 사용되는 도구는 \u003ccode\u003esetuptools\u003c/code\u003e 심을 유지하거나, 소비자를 찾아 \u003ccode\u003epypa.json\u003c/code\u003e 사용으로 미리 업그레이드하도록 하는 것을 권장합니다. 현실적으로 이는 불가능하므로, \u003ccode\u003epbr\u003c/code\u003e, \u003ccode\u003esetuptools_scm\u003c/code\u003e과 같은 프로젝트와 \u003ccode\u003enumpy\u003c/code\u003e와 같은 프로젝트 모두에 대해 \u003ccode\u003esetuptools\u003c/code\u003e 심을 무기한으로 유지하는 것이 좋습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003esetuptools\u003c/code\u003e 심 (setuptools shim)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esetup.py\u003c/code\u003e처럼 보이고 내부적으로 \u003ccode\u003epypa.json\u003c/code\u003e을 사용하여 빌드를 구동하는 일반적인 \u003ccode\u003esetuptools\u003c/code\u003e 심을 작성하는 것이 가능할 것입니다. 이는 \u003ccode\u003epip\u003c/code\u003e이 시스템을 사용하는 데 필요하지 않지만, 패키지 작성자가 새 기능을 사용하면서도 이전 \u003ccode\u003epip\u003c/code\u003e 버전과의 호환성을 유지할 수 있도록 할 것입니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003edistutils-sig\u003c/code\u003e의 긴 메일링 리스트 스레드에서 시작되었습니다. 그 후 온라인 회의가 열려 사람들이 가지고 있던 모든 입장을 디버깅했습니다. 회의록은 목록에 게시되었습니다.\u003c/p\u003e\n\u003cp\u003e이 명세는 거기서 도달한 합의를 PEP 형식으로 번역한 것이며, 남아있는 사소한 질문에 대한 몇 가지 임의의 선택이 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e설계의 기본 휴리스틱은 추상화에 엄격하게 묶이지 않은 개발을 요구하지 않고 추상화를 도입하는 데 중점을 두는 것이었습니다. 개선과의 격차가 작거나 기존 인터페이스를 사용하는 비용이 매우 높은 경우, 개선을 의존성으로 받아들였지만, 그렇지 않은 경우 미래의 반복으로 미루었습니다.\u003c/p\u003e\n\u003cp\u003e새로운 명세를 정의하는 대신 \u003ccode\u003ewheel METADATA\u003c/code\u003e 파일을 선택한 이유는 \u003ccode\u003epip\u003c/code\u003e이 이미 \u003ccode\u003eMETADATA\u003c/code\u003e 파일에 필요한 모든 데이터를 인코딩하는 \u003ccode\u003ewheel .dist-info\u003c/code\u003e 디렉토리를 처리할 수 있기 때문입니다. PEP 426은 아직 초안이므로 사용할 수 없으며, 새로운 메타데이터 형식을 정의하는 것은 별개의 문제입니다. 디스크에 디렉토리를 사용하는 것은 인터페이스에 어떠한 가치도 추가하지 않을 것입니다 (\u003ccode\u003esetuptools CLI\u003c/code\u003e의 제한으로 인해 \u003ccode\u003epip\u003c/code\u003e이 현재 그렇게 해야 합니다).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edevelop\u003c/code\u003e을 명령어로 사용하는 이유는 '\u003ccode\u003esetuptools develop\u003c/code\u003e'이 하는 일의 상호 운용성을 명세하는 PEP가 없기 때문입니다. 따라서 \u003ccode\u003epip\u003c/code\u003e이 '\u003ccode\u003edevelop\u003c/code\u003e' 단계를 수행할 책임을 맡기 전에 이를 정의해야 할 것입니다. 일단 그렇게 되면 이 PEP의 후속 PEP를 발행할 수 있을 것입니다.\u003c/p\u003e\n\u003cp\u003ePython API 대신 명령줄 API를 사용하는 것은 다소 논란의 여지가 있습니다. 근본적으로 모든 것이 작동하도록 만들 수 있으며, \u003ccode\u003epip\u003c/code\u003e 유지보수자는 현재 \u003ccode\u003epip\u003c/code\u003e에서 성숙하고 견고한 프로세스 기반 인터페이스를 유지하는 것을 강력히 지지해왔습니다.\u003c/p\u003e\n\u003cp\u003e파일 형식으로 JSON을 선택한 것은 여러 제약 조건 간의 타협입니다. 첫째, \u003ccode\u003eYAML\u003c/code\u003e 인터프리터나 다른 마찰이 적은 구조화된 파일 형식에 대한 \u003ccode\u003estdlib\u003c/code\u003e가 없습니다. 둘째, \u003ccode\u003eINIParser\u003c/code\u003e는 여러 이유로 좋지 않은 형식인데, 주로 구조가 매우 최소한이기 때문입니다. 하지만 \u003ccode\u003epip\u003c/code\u003e의 유지보수자들은 \u003ccode\u003eINIParser\u003c/code\u003e를 좋아하지 않습니다. JSON은 \u003ccode\u003estdlib\u003c/code\u003e에 있으며, 미래에 원하는 모든 것을 내장 DSL 없이도 포함할 수 있는 충분한 구조를 가지고 있습니다.\u003c/p\u003e\n\u003cp\u003eDonald는 새로운 것을 발명하는 대신 \u003ccode\u003esetup.cfg\u003c/code\u003e와 기존 \u003ccode\u003esetuptools\u003c/code\u003e 명령줄을 사용할 것을 제안했습니다. 이는 덜 가시적인 변경으로 상호 운용성을 허용할 수 있지만, \u003ccode\u003epip\u003c/code\u003e 측면에서는 거의 동일한 엔지니어링 작업이 필요합니다. (\u003ccode\u003esetup.cfg\u003c/code\u003e에서 새 키를 찾고, 빌드를 실행할 비설치 환경을 구현하는 것) 그리고 다른 빌드 시스템 작성자들이 \u003ccode\u003esetuptools\u003c/code\u003e와 비슷하지만 다르게 작동하는 것을 제공하여 사용자들을 혼란스럽게 하고 싶지 않다는 바람은 \u003ccode\u003epip\u003c/code\u003e이 사용자 정의 빌드 도구를 호출하는 방법을 배우는 것보다 더 큰 문제로 보입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emetadata\u003c/code\u003e 및 \u003ccode\u003ewheel\u003c/code\u003e 명령어는 일관된 메타데이터를 가져야 합니다. 이는 \u003ccode\u003epip\u003c/code\u003e이 메타데이터를 읽고 그에 따라 행동한 다음, 결과 \u003ccode\u003ewheel\u003c/code\u003e이 호환되지 않는 요구사항을 가질 수 있는 레이스 컨디션(race condition)을 피하기 위함입니다. 이 레이스 컨디션은 현재 PEP 426 환경 마커를 사용하는 패키지에서 환경 마커를 지원하지 않는 이전 \u003ccode\u003epip\u003c/code\u003e 버전과 함께 작동하기 위해 악용됩니다. 이 PEP에서는 해당 악용이 필요하지 않습니다. \u003ccode\u003esetuptools\u003c/code\u003e 심이 사용되거나 (이전 \u003ccode\u003epip\u003c/code\u003e 버전의 경우) 환경 마커를 지원하는 \u003ccode\u003epip\u003c/code\u003e이 사용되기 때문입니다. \u003ccode\u003esetuptools\u003c/code\u003e 심은 이전 \u003ccode\u003epip\u003c/code\u003e 버전이 요구하는 차이점을 악용하는 것을 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esdist\u003c/code\u003e 동사(verb)를 갖는 것에 대해 논의했습니다. 주된 동기는 빌드 시스템이 \u003ccode\u003epip\u003c/code\u003e이 빌드할 수 있는 \u003ccode\u003esdist\u003c/code\u003e를 생성할 수 있도록 하는 것이었지만, 이는 순환적입니다. 이 PEP의 전체 요점은 \u003ccode\u003epip\u003c/code\u003e이 \u003ccode\u003esetuptools\u003c/code\u003e의 구현을 요구하지 않고도 이러한 \u003ccode\u003esdist\u003c/code\u003e 또는 VCS 소스 트리를 안정적으로 사용할 수 있도록 하는 것입니다. 기존 소스 트리에서 새로운 \u003ccode\u003esdist\u003c/code\u003e를 생성하는 것은 \u003ccode\u003epip\u003c/code\u003e이 현재 수행하는 작업이 아니며, 소스에서 빌드하는 과정의 일부로 이를 수행하는 PR이 있지만 논란의 여지가 있고 합의가 부족합니다. 모든 빌드 시스템에 요구사항을 부과하기보다는, 이를 YAGNI(You Aren't Gonna Need It)로 취급하고, 필요한 경우 인터페이스의 미래 버전에 이러한 동사를 추가할 것입니다. \u003ccode\u003esdist\u003c/code\u003e에 대한 기존 PEP 314 요구사항은 여전히 적용되며, \u003ccode\u003edistutils\u003c/code\u003e 또는 \u003ccode\u003esetuptools\u003c/code\u003e 사용자는 \u003ccode\u003esetup.py sdist\u003c/code\u003e를 사용하여 \u003ccode\u003esdist\u003c/code\u003e를 생성할 수 있습니다. 다른 도구는 PEP 314와 호환되는 \u003ccode\u003esdist\u003c/code\u003e를 생성해야 합니다. \u003ccode\u003epip\u003c/code\u003e 자체는 PEP 314 호환성을 요구하지 않습니다. \u003ccode\u003esdist\u003c/code\u003e의 메타데이터를 사용하지 않으며, 디스크 또는 버전 관리의 소스 트리처럼 취급됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2648,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 516 - Build system abstraction for pip/conda etc\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:11:03+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/516/\",\"postId\":\"2025-09-26-pep-0516-build-system-abstraction-for-pipconda-etc\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/515/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 515 - Underscores in Numeric Literals\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Rejected] PEP 516 - Build system abstraction for pip/conda etc\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/517/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 517 - A build-system independent format for source trees\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>