<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/da5e1dc2b9a7c5bb.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-aecaf5ac7a84facf.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-e3ea38185bb36cd2.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Deferred] PEP 505 - None-aware operators</h1><div class="page__meta"><time dateTime="2025-09-26 22:52:11+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0505/">PEP 505 - None-aware operators</a></p>
<p><strong>상태:</strong> Deferred | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 18-Sep-2015</p>
</blockquote>
<ul>
<li><strong>작성자:</strong> Mark E. Haase, Steve Dower</li>
<li><strong>상태:</strong> Deferred (보류됨)</li>
<li><strong>유형:</strong> Standards Track</li>
<li><strong>생성일:</strong> 2015년 9월 18일</li>
<li><strong>Python 버전:</strong> 3.8</li>
</ul>
<hr>
<h2>개요 (Abstract)</h2>
<p>C#, Dart, Perl, Swift, PHP(버전 7부터), 그리고 ECMAScript(JavaScript)의 드래프트 제안과 같은 여러 현대 프로그래밍 언어에는 "null-coalescing" 또는 "null-aware" 연산자가 존재합니다. 이러한 연산자들은 <code>null</code> 참조와 관련된 일반적인 패턴에 대한 문법적 설탕(syntactic sugar)을 제공합니다.</p>
<p>일반적으로:</p>
<ul>
<li><strong>Null-coalescing 연산자</strong>는 이항 연산자로, 왼쪽 피연산자가 <code>null</code>이 아니면 왼쪽 피연산자를 반환하고, 그렇지 않으면 오른쪽 피연산자를 반환합니다.</li>
<li><strong>Null-aware 멤버 접근 연산자</strong>는 인스턴스가 <code>null</code>이 아닌 경우에만 인스턴스 멤버에 접근하며, 그렇지 않으면 <code>null</code>을 반환합니다. (이것은 "안전한 탐색(safe navigation)" 연산자라고도 불립니다.)</li>
<li><strong>Null-aware 인덱스 접근 연산자</strong>는 컬렉션이 <code>null</code>이 아닌 경우에만 컬렉션의 요소에 접근하며, 그렇지 않으면 <code>null</code>을 반환합니다. (이것도 "안전한 탐색" 연산자의 한 유형입니다.)</li>
</ul>
<p>이 PEP는 위에서 언급된 정의와 다른 언어들의 구현을 바탕으로 Python에 세 가지 <code>None</code>-인식 연산자를 제안합니다. 구체적으로 다음과 같습니다:</p>
<ol>
<li><strong><code>None</code> 코얼레싱 이항 연산자 <code>??</code></strong>: 왼쪽 피연산자가 <code>None</code>이 아닌 값으로 평가되면 왼쪽 피연산자를 반환하고, 그렇지 않으면 오른쪽 피연산자를 평가하여 반환합니다.</li>
<li><strong><code>None</code> 코얼레싱 할당 연산자 <code>??=</code></strong>: 증강 할당(augmented assignment) 연산자로 포함됩니다.</li>
<li><strong><code>None</code>-인식 속성 접근 연산자 <code>?.</code></strong> ("maybe dot"): 왼쪽 피연산자가 <code>None</code>이 아닌 값으로 평가될 경우에만 전체 표현식을 평가합니다.</li>
<li><strong><code>None</code>-인식 인덱싱 연산자 <code>?[]</code></strong> ("maybe subscript"): 왼쪽 피연산자가 <code>None</code>이 아닌 값으로 평가될 경우에만 전체 표현식을 평가합니다.</li>
</ol>
<p>제안된 문법 변경 및 사용 예시는 아래 섹션에서 더 자세히 다룹니다.</p>
<h2>구문 및 의미론 (Syntax and Semantics)</h2>
<h3><code>None</code>의 특수성 (Specialness of <code>None</code>)</h3>
<p><code>None</code> 객체는 "값이 없음"을 나타냅니다. 이 연산자들의 목적상, "값이 없음"은 표현식의 나머지 부분도 "값이 없음"을 의미하며 평가되어서는 안 된다는 것을 나타냅니다.</p>
<p>이전에 거부된 제안은 부울(Boolean) 컨텍스트에서 <code>False</code>로 평가되는 모든 값을 "값이 없음"으로 취급하는 것이었습니다. 그러나 이 연산자들의 목적은 "<code>False</code>" 상태보다는 "값이 없음" 상태를 전파하는 것입니다.</p>
<p>일부에서는 이로 인해 <code>None</code>이 특별해진다고 주장하지만, PEP는 <code>None</code>이 이미 특별하며, 이 연산자들에서 <code>None</code>을 테스트와 결과 모두로 사용하는 것이 기존 의미론을 어떤 식으로든 변경하지 않는다고 주장합니다.</p>
<p>대체 접근 방식에 대한 논의는 "거부된 아이디어" 섹션을 참조하십시오.</p>
<h3>문법 변경 (Grammar changes)</h3>
<p>Python 문법의 다음 규칙들이 다음과 같이 업데이트됩니다:</p>
<pre><code>augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&#x26;=' | '|=' | '^=' | '&#x3C;&#x3C;=' | '>>=' | '**=' | '//=' | '??=')
power: coalesce ['**' factor]
coalesce: atom_expr ['??' factor]
atom_expr: ['await'] atom trailer*
trailer: ('(' [arglist] ')' | '[' subscriptlist ']' | '?[' subscriptlist ']' | '.' NAME | '?.' NAME)
</code></pre>
<h4>코얼레싱 규칙 (<code>??</code> 연산자)</h4>
<p><code>coalesce</code> 규칙은 <code>??</code> 이항 연산자를 제공합니다. 대부분의 이항 연산자와 달리, <code>??</code> 연산자는 왼쪽 피연산자가 <code>None</code>으로 결정될 때까지 오른쪽 피연산자를 평가하지 않습니다.</p>
<p><code>??</code> 연산자는 다른 이항 연산자보다 더 강하게 바인딩됩니다. 이는 대부분의 기존 구현이 <code>None</code> 값을 전파하지 않고 <code>TypeError</code>를 발생시키기 때문입니다. 잠재적으로 <code>None</code>이 될 수 있는 표현식은 추가적인 괄호 없이 기본값으로 대체될 수 있습니다.</p>
<p><code>??</code> 연산자가 있을 때 연산자 우선순위를 평가하는 몇 가지 예시는 다음과 같습니다:</p>
<pre><code class="language-python">a, b = None, None
def c(): return None
def ex(): raise Exception()

# 괄호의 암묵적인 배치 예시
(a ?? 2 ** b ?? 3) == a ?? (2 ** (b ?? 3))
(a * b ?? c // d) == a * (b ?? c) // d
(a ?? True and b ?? False) == (a ?? True) and (b ?? False)
(c() ?? c() ?? True) == True
(True ?? ex()) == True
(c ?? ex)() == c() # c가 None이면 ex()를 평가하지 않고, None이 아니면 c() 호출
</code></pre>
<p>특히 <code>a ?? 2 ** b ?? 3</code>과 같은 경우, 다른 방식으로 부분 표현식에 괄호를 치면 <code>TypeError</code>가 발생할 수 있습니다. <code>int.__pow__</code>는 <code>None</code>으로 호출될 수 없기 때문입니다 (<code>??</code> 연산자가 사용되었다는 사실 자체가 <code>a</code> 또는 <code>b</code>가 <code>None</code>일 수 있음을 암시합니다). 그러나 평소와 같이 괄호는 필수는 아니지만 가독성 향상에 도움이 된다면 추가해야 합니다.</p>
<p><code>??</code> 연산자에 대한 증강 할당 <code>??=</code>도 추가됩니다. 증강 코얼레싱 할당은 현재 값이 <code>None</code>인 경우에만 이름을 재바인딩합니다. 대상 이름이 이미 값을 가지고 있다면, 오른쪽 피연산자는 평가되지 않습니다. 예를 들어:</p>
<pre><code class="language-python">a = None
b = ''
c = 0

a ??= 'value'
b ??= undefined_name # b는 ''이므로 undefined_name은 평가되지 않음
c ??= shutil.rmtree('/') # c는 0이므로 shutil.rmtree('/')는 평가되지 않음

assert a == 'value'
assert b == ''
assert c == 0 # and any(os.scandir('/'))
</code></pre>
<h4><code>maybe-dot</code> (<code>?.</code>) 및 <code>maybe-subscript</code> (<code>?[]</code>) 연산자</h4>
<p><code>maybe-dot</code> (<code>?.</code>) 및 <code>maybe-subscript</code> (<code>?[]</code>) 연산자는 <code>atom</code>에 대한 <code>trailer</code>로 추가되어, 일반 연산자와 동일한 모든 위치에서 사용될 수 있습니다. 여기에는 할당 대상의 일부로도 포함됩니다. 기존 평가 규칙은 문법에 직접 포함되어 있지 않으므로, 필요한 변경 사항을 아래에 명시합니다.</p>
<p><code>atom</code>은 항상 성공적으로 평가된다고 가정합니다. 각 <code>trailer</code>는 왼쪽에서 오른쪽으로 평가되며, 자체 매개변수(인자, 인덱스 또는 속성 이름)를 적용하여 다음 <code>trailer</code>의 값을 생성합니다. 마지막으로, <code>await</code>가 존재하면 적용됩니다.</p>
<p>예를 들어, <code>await a.b(c).d[e]</code>는 현재 <code>['await', 'a', '.b', '(c)', '.d', '[e]']</code>로 파싱되고 다음과 같이 평가됩니다:</p>
<pre><code class="language-python">_v = a
_v = _v.b
_v = _v(c)
_v = _v.d
_v = _v[e]
await _v
</code></pre>
<p><code>None</code>-인식 연산자가 있을 때, 왼쪽에서 오른쪽으로의 평가는 단락(short-circuited)될 수 있습니다. 예를 들어, <code>await a?.b(c).d?[e]</code>는 다음과 같이 평가됩니다:</p>
<pre><code class="language-python">_v = a
if _v is not None:
    _v = _v.b
    _v = _v(c)
    _v = _v.d
    if _v is not None:
        _v = _v[e]
await _v
</code></pre>
<p><strong>참고:</strong> <code>await</code>는 <code>await None</code>을 시도하는 경우와 마찬가지로 이 컨텍스트에서 거의 확실히 실패할 것입니다. 이 PEP는 <code>None</code>-인식 <code>await</code> 키워드를 추가할 것을 제안하지 않으며, 단지 <code>atom_expr</code> 문법 규칙에 해당 키워드가 포함되어 있어 명세의 완전성을 위해 이 예시에 포함시킨 것입니다.</p>
<p>괄호로 묶인 표현식은 <code>atom</code> 규칙(위에는 표시되지 않음)에 의해 처리되며, 이는 위의 변환에서 단락 동작을 암묵적으로 종료합니다. 예를 들어, <code>(a?.b ?? c).d?.e</code>는 다음과 같이 평가됩니다:</p>
<pre><code class="language-python"># a?.b
_v = a
if _v is not None:
    _v = _v.b
# ... ?? c
if _v is None:
    _v = c
# (...).d?.e
_v = _v.d
if _v is not None:
    _v = _v.e
</code></pre>
<p>할당 대상(assignment target)으로 사용될 때, <code>None</code>-인식 연산은 "로드(load)" 컨텍스트에서만 사용될 수 있습니다. 즉, <code>a?.b = 1</code> 및 <code>a?[b] = 1</code>은 <code>SyntaxError</code>를 발생시킵니다. 표현식 앞부분에서의 사용(<code>a?.b.c = 1</code>)은 허용되지만, 코얼레싱 연산과 결합되지 않으면 유용하지 않을 가능성이 높습니다:</p>
<pre><code class="language-python">(a?.b ?? d).c = 1
</code></pre>
<h3>표현식 읽기 (Reading expressions)</h3>
<p><code>maybe-dot</code> (<code>?.</code>) 및 <code>maybe-subscript</code> (<code>?[]</code>) 연산자를 포함하는 표현식은 이 연산자들의 일반 버전과 동일하게 읽고 해석되어야 합니다. "정상적인" 경우, <code>a?.b?[c]</code>와 <code>a.b[c]</code>와 같은 표현식의 최종 결과는 동일할 것입니다. 우리가 현재 "a.b"를 "a에 속성 b가 있다면 읽고, 그렇지 않으면 AttributeError를 발생시킨다"라고 읽지 않는 것처럼, <code>a?.b</code>를 "a가 <code>None</code>이 아니면 a에서 속성 b를 읽는다"라고 읽을 필요는 없습니다 (듣는 사람이 특정 동작을 알아야 하는 컨텍스트가 아니라면).</p>
<p><code>??</code> 연산자를 사용하는 코얼레싱 표현식의 경우, 표현식은 "<code>None</code>이면 ... 또는" 또는 "<code>...</code>와 코얼레싱된다"로 읽어야 합니다. 예를 들어, <code>a.get_value() ?? 100</code>이라는 표현식은 "<code>a.get_value</code>를 호출하거나 <code>None</code>이면 100" 또는 "<code>a.get_value</code>와 100을 코얼레싱한다"로 읽을 수 있습니다.</p>
<p><strong>참고:</strong> 구어로 코드를 읽는 것은 항상 정보 손실이 있으므로, 이 연산자들을 명확하게 말하는 방법을 정의하려는 시도는 하지 않습니다. 이러한 제안은 새로운 문법 추가의 의미에 대한 맥락을 제공하기 위한 것입니다.</p>
<h2>예시 (Examples)</h2>
<p>이 섹션에서는 일반적인 <code>None</code> 패턴의 몇 가지 예시를 제시하고, <code>None</code>-인식 연산자를 사용하도록 변환했을 때 어떤 모습이 될지 보여줍니다.</p>
<h3>표준 라이브러리 (Standard Library)</h3>
<p><code>find-pep505.py</code> 스크립트를 사용하여 Python 3.7 표준 라이브러리를 분석한 결과, 최대 678개의 코드 스니펫이 <code>None</code>-인식 연산자 중 하나를 사용하여 대체될 수 있음을 발견했습니다:</p>
<pre><code>$ find /usr/lib/python3.7 -name '*.py' | xargs python3.7 find-pep505.py
&#x3C;snip>
Total None-coalescing `if` blocks: 449
Total [possible] None-coalescing `or`: 120
Total None-coalescing ternaries: 27
Total Safe navigation `and`: 13
Total Safe navigation `if` blocks: 61
Total Safe navigation ternaries: 8
</code></pre>
<p>아래는 새 연산자를 사용하도록 변환하기 전후의 몇 가지 예시입니다.</p>
<p><code>bisect.py</code>에서:
<strong>이전:</strong></p>
<pre><code class="language-python">def insort_right(a, x, lo=0, hi=None):
    # ...
    if hi is None:
        hi = len(a)
    # ...
</code></pre>
<p><code>??=</code> 증강 할당문을 사용하도록 업데이트 후:
<strong>이후:</strong></p>
<pre><code class="language-python">def insort_right(a, x, lo=0, hi=None):
    # ...
    hi ??= len(a)
    # ...
</code></pre>
<p><code>calendar.py</code>에서:
<strong>이전:</strong></p>
<pre><code class="language-python">encoding = options.encoding
if encoding is None:
    encoding = sys.getdefaultencoding()
optdict = dict(encoding=encoding, css=options.css)
</code></pre>
<p><code>??</code> 연산자를 사용하도록 업데이트 후:
<strong>이후:</strong></p>
<pre><code class="language-python">optdict = dict(encoding=options.encoding ?? sys.getdefaultencoding(), css=options.css)
</code></pre>
<p><code>email/generator.py</code>에서 (여기서 <code>or</code>를 <code>??</code>로 대체할 방법이 없다는 점을 중요하게 주목하십시오):
<strong>이전:</strong></p>
<pre><code class="language-python">mangle_from_ = True if policy is None else policy.mangle_from_
</code></pre>
<p>업데이트 후:
<strong>이후:</strong></p>
<pre><code> mangle = True if policy is None else policy.mangle_from_
 # after update
 mangle_from_ = policy?.mangle_from_ ?? True
</code></pre>
<p><strong>이후 (오류 수정):</strong></p>
<pre><code class="language-python">mangle_from_ = policy?.mangle_from_ ?? True
</code></pre>
<p><code>asyncio/subprocess.py</code>에서:
<strong>이전:</strong></p>
<pre><code class="language-python">def pipe_data_received(self, fd, data):
    if fd == 1:
        reader = self.stdout
    elif fd == 2:
        reader = self.stderr
    else:
        reader = None
    if reader is not None:
        reader.feed_data(data)
</code></pre>
<p><code>?.</code> 연산자를 사용하도록 업데이트 후:
<strong>이후:</strong></p>
<pre><code class="language-python">def pipe_data_received(self, fd, data):
    if fd == 1:
        reader = self.stdout
    elif fd == 2:
        reader = self.stderr
    else:
        reader = None
    reader?.feed_data(data)
</code></pre>
<p><code>asyncio/tasks.py</code>에서:
<strong>이전:</strong></p>
<pre><code class="language-python">try:
    await waiter
finally:
    if timeout_handle is not None:
        timeout_handle.cancel()
</code></pre>
<p><code>?.</code> 연산자를 사용하도록 업데이트 후:
<strong>이후:</strong></p>
<pre><code class="language-python">try:
    await waiter
finally:
    timeout_handle?.cancel()
</code></pre>
<p><code>ctypes/_aix.py</code>에서:
<strong>이전:</strong></p>
<pre><code class="language-python">if libpaths is None:
    libpaths = []
else:
    libpaths = libpaths.split(":")
</code></pre>
<p>업데이트 후:
<strong>이후:</strong></p>
<pre><code class="language-python">libpaths = libpaths?.split(":") ?? []
</code></pre>
<p><code>os.py</code>에서:
<strong>이전:</strong></p>
<pre><code class="language-python">if entry.is_dir():
    dirs.append(name)
    if entries is not None:
        entries.append(entry)
    else:
        nondirs.append(name)
</code></pre>
<p><code>?.</code> 연산자를 사용하도록 업데이트 후:</p>
<pre><code class="language-python">if entry.is_dir():
    dirs.append(name)
    entries?.append(entry)
else:
    nondirs.append(name)
</code></pre>
<p><code>importlib/abc.py</code>에서:
<strong>이전 (부분 업데이트 전):</strong></p>
<pre><code class="language-python">def find_module(self, fullname, path):
    if not hasattr(self, 'find_spec'):
        return None
    found = self.find_spec(fullname, path)
    return found.loader if found is not None else None
</code></pre>
<p>부분 업데이트 후:</p>
<pre><code class="language-python">def find_module(self, fullname, path):
    if not hasattr(self, 'find_spec'):
        return None
    return self.find_spec(fullname, path)?.loader
</code></pre>
<p>광범위하게 업데이트 후 (과하다고 볼 수도 있지만, 스타일 가이드에서 결정할 부분입니다):</p>
<pre><code class="language-python">def find_module(self, fullname, path):
    return getattr(self, 'find_spec', None)?.__call__(fullname, path)?.loader
</code></pre>
<p><code>dis.py</code>에서:
<strong>이전:</strong></p>
<pre><code class="language-python">def _get_const_info(const_index, const_list):
    argval = const_index
    if const_list is not None:
        argval = const_list[const_index]
    return argval, repr(argval)
</code></pre>
<p><code>?[]</code> 및 <code>??</code> 연산자를 사용하도록 업데이트 후:
<strong>이후:</strong></p>
<pre><code class="language-python">def _get_const_info(const_index, const_list):
    argval = const_list?[const_index] ?? const_index
    return argval, repr(argval)
</code></pre>
<h3><code>jsonify</code> 예시</h3>
<p>이 예시는 Flask 프레임워크를 프런트엔드로 사용하는 Python 웹 크롤러에서 가져온 것입니다. 이 함수는 SQL 데이터베이스에서 웹 사이트 정보를 검색하고 HTTP 클라이언트에 보낼 JSON 형식으로 지정합니다.</p>
<p><code>first_seen</code>과 <code>last_seen</code>은 데이터베이스에서 <code>null</code>이 허용되며, JSON 응답에서도 <code>null</code>이 허용됩니다. JSON은 <code>datetime</code>을 나타내는 기본 방법이 없으므로, 서버의 계약은 <code>null</code>이 아닌 모든 날짜를 ISO-8601 문자열로 표현한다고 명시합니다.</p>
<p><code>first_seen</code> 및 <code>last_seen</code> 속성의 정확한 의미를 알지 못하면, 해당 속성에 안전하게 또는 성능적으로 여러 번 접근할 수 있는지 알 수 없습니다.</p>
<p><strong>이전 (조건부 표현식 사용):</strong></p>
<pre><code class="language-python">class SiteView(FlaskView):
    @route('/site/&#x3C;id_>', methods=['GET'])
    def get_site(self, id_):
        site = db.query('site_table').find(id_)
        return jsonify(
            first_seen=site.first_seen.isoformat() if site.first_seen is not None else None,
            id=site.id,
            is_active=site.is_active,
            last_seen=site.last_seen.isoformat() if site.last_seen is not None else None,
            url=site.url.rstrip('/')
        )
</code></pre>
<p>이 코드를 수정하는 한 가지 방법은 각 조건부 표현식을 명시적인 값 할당과 전체 <code>if</code>/<code>else</code> 블록으로 대체하는 것입니다:</p>
<p><strong>이전 (if/else 블록으로 확장):</strong></p>
<pre><code class="language-python">class SiteView(FlaskView):
    @route('/site/&#x3C;id_>', methods=['GET'])
    def get_site(self, id_):
        site = db.query('site_table').find(id_)
        first_seen_dt = site.first_seen
        if first_seen_dt is None:
            first_seen = None
        else:
            first_seen = first_seen_dt.isoformat()
        last_seen_dt = site.last_seen
        if last_seen_dt is None:
            last_seen = None
        else:
            last_seen = last_seen_dt.isoformat()
        return jsonify(
            first_seen=first_seen,
            id=site.id,
            is_active=site.is_active,
            last_seen=last_seen,
            url=site.url.rstrip('/')
        )
</code></pre>
<p>이는 10줄의 코드를 추가하고 함수에 4개의 새로운 코드 경로를 만들어, 외견상 복잡성을 크게 증가시킵니다. <code>None</code>-인식 속성 연산자를 사용하여 다시 작성하면 의도가 더 명확해지면서 코드가 짧아집니다:</p>
<p><strong>이후 (<code>None</code>-인식 연산자 사용):</strong></p>
<pre><code class="language-python">class SiteView(FlaskView):
    @route('/site/&#x3C;id_>', methods=['GET'])
    def get_site(self, id_):
        site = db.query('site_table').find(id_)
        return jsonify(
            first_seen=site.first_seen?.isoformat(),
            id=site.id,
            is_active=site.is_active,
            last_seen=site.last_seen?.isoformat(),
            url=site.url.rstrip('/')
        )
</code></pre>
<h3><code>Grab</code> 예시</h3>
<p>다음 예시는 Grab이라는 Python 스크래핑 라이브러리에서 가져온 것입니다.</p>
<p><strong>이전 (<code>if/else</code> 블록 사용):</strong></p>
<pre><code class="language-python">class BaseUploadObject(object):
    def find_content_type(self, filename):
        ctype, encoding = mimetypes.guess_type(filename)
        if ctype is None:
            return 'application/octet-stream'
        else:
            return ctype

class UploadContent(BaseUploadObject):
    def __init__(self, content, filename=None, content_type=None):
        self.content = content
        if filename is None:
            self.filename = self.get_random_filename()
        else:
            self.filename = filename
        if content_type is None:
            self.content_type = self.find_content_type(self.filename)
        else:
            self.content_type = content_type

class UploadFile(BaseUploadObject):
    def __init__(self, path, filename=None, content_type=None):
        self.path = path
        if filename is None:
            self.filename = os.path.split(path)[1]
        else:
            self.filename = filename
        if content_type is None:
            self.content_type = self.find_content_type(self.filename)
        else:
            self.content_type = content_type
</code></pre>
<p>이 예시에는 기본값을 제공해야 하는 여러 좋은 예시가 포함되어 있습니다. 조건부 표현식을 사용하도록 다시 작성하면 전체 코드 줄 수는 줄어들지만, 반드시 가독성이 향상되는 것은 아닙니다:</p>
<p><strong>이전 (조건부 표현식 사용):</strong></p>
<pre><code class="language-python">class BaseUploadObject(object):
    def find_content_type(self, filename):
        ctype, encoding = mimetypes.guess_type(filename)
        return 'application/octet-stream' if ctype is None else ctype

class UploadContent(BaseUploadObject):
    def __init__(self, content, filename=None, content_type=None):
        self.content = content
        self.filename = (self.get_random_filename() if filename is None else filename)
        self.content_type = (self.find_content_type(self.filename) if content_type is None else content_type)

class UploadFile(BaseUploadObject):
    def __init__(self, path, filename=None, content_type=None):
        self.path = path
        self.filename = (os.path.split(path)[1] if filename is None else filename)
        self.content_type = (self.find_content_type(self.filename) if content_type is None else content_type)
</code></pre>
<p>첫 번째 삼항 표현식은 깔끔하지만, 피연산자의 직관적인 순서를 뒤바꿉니다. 즉, 값이 있으면 <code>ctype</code>을 반환하고, 아니면 문자열 리터럴을 대체로 사용해야 합니다. 다른 삼항 표현식은 직관적이지 않고 너무 길어서 줄 바꿈을 해야 합니다. 전반적인 가독성은 향상되지 않고 악화되었습니다.</p>
<p><code>None</code> 코얼레싱 연산자를 사용하여 다시 작성하면 다음과 같습니다:</p>
<p><strong>이후 (<code>None</code> 코얼레싱 연산자 사용):</strong></p>
<pre><code class="language-python">class BaseUploadObject(object):
    def find_content_type(self, filename):
        ctype, encoding = mimetypes.guess_type(filename)
        return ctype ?? 'application/octet-stream'

class UploadContent(BaseUploadObject):
    def __init__(self, content, filename=None, content_type=None):
        self.content = content
        self.filename = filename ?? self.get_random_filename()
        self.content_type = content_type ?? self.find_content_type(self.filename)

class UploadFile(BaseUploadObject):
    def __init__(self, path, filename=None, content_type=None):
        self.path = path
        self.filename = filename ?? os.path.split(path)[1]
        self.content_type = content_type ?? self.find_content_type(self.filename)
</code></pre>
<p>이 구문은 피연산자의 순서가 직관적입니다. 예를 들어 <code>find_content_type</code>에서는 선호되는 값 <code>ctype</code>이 대체 값보다 먼저 나타납니다. 구문의 간결성은 코드 줄 수를 줄이고 시각적으로 분석할 코드를 줄이며, 왼쪽에서 오른쪽, 위에서 아래로 읽는 것이 실행 흐름을 더 정확하게 따르게 합니다.</p>
<h2>거부된 아이디어 (Rejected Ideas)</h2>
<p>이 섹션의 처음 세 가지 아이디어는 <code>None</code>을 특별하게 취급하는 것에 대한 자주 제안되는 대안입니다. 이러한 아이디어들이 왜 거부되었는지에 대한 더 자세한 배경은 PEP 531 및 PEP 532와 관련 논의를 참조하십시오.</p>
<h3>값 없음 프로토콜 (No-Value Protocol)</h3>
<p>이 연산자들은 값이 "값이 없음"을 나타내는 시기를 나타내는 프로토콜을 정의함으로써 사용자 정의 타입으로 일반화될 수 있었습니다. 이러한 프로토콜은 값이 유효한 값으로 취급되어야 할 때 <code>True</code>를 반환하고, 값이 값 없음으로 취급되어야 할 때 <code>False</code>를 반환하는 dunder 메서드 <code>__has_value__(self)</code>일 수 있습니다.</p>
<p>이 일반화를 통해 <code>object</code>는 다음과 동등한 dunder 메서드를 구현할 것입니다:</p>
<pre><code class="language-python">def __has_value__(self):
    return True
</code></pre>
<p><code>NoneType</code>은 다음과 동등한 dunder 메서드를 구현할 것입니다:</p>
<pre><code class="language-python">def __has_value__(self):
    return False
</code></pre>
<p>명세 섹션에서 <code>x is None</code>의 모든 사용은 <code>not x.__has_value__()</code>로 대체될 것입니다.</p>
<p>이 일반화를 통해 도메인별 "값 없음" 객체가 <code>None</code>과 동일하게 코얼레싱될 수 있습니다. 예를 들어, <code>pyasn1</code> 패키지에는 ASN.1 <code>null</code>을 나타내는 <code>Null</code>이라는 타입이 있습니다:</p>
<pre><code class="language-python">>>> from pyasn1.type import univ
>>> univ.Null() ?? univ.Integer(123)
Integer(123)
</code></pre>
<p>유사하게, <code>math.nan</code> 및 <code>NotImplemented</code>와 같은 값들도 "값이 없음"을 나타내는 것으로 취급될 수 있습니다.</p>
<p>그러나 이러한 값들의 "값 없음" 속성은 도메인별이므로 언어에 의해 값으로 취급되어야 합니다. 예를 들어, <code>math.nan.imag</code>는 잘 정의되어 있습니다(0.0입니다). 따라서 <code>math.nan?.imag</code>를 단락하여 <code>math.nan</code>을 반환하는 것은 잘못될 것입니다.</p>
<p><code>None</code>은 이미 언어에 의해 "값이 없음"을 나타내는 값으로 정의되어 있으며, 현재 명세는 미래에 프로토콜로 전환하는 것을 배제하지 않으므로 (내장 객체 변경은 호환되지 않겠지만), 이 아이디어는 현재 거부됩니다.</p>
<h3>부울 인식 연산자 (Boolean-aware operators)</h3>
<p>이 제안은 "값 없음 프로토콜"을 추가하는 것과 근본적으로 동일하며, 위의 논의가 그대로 적용됩니다.</p>
<p><code>??</code> 연산자와 유사한 동작은 <code>or</code> 표현식으로 달성할 수 있지만, <code>or</code>는 왼쪽 피연산자가 <code>None</code>인지 여부가 아니라 <code>false-y</code>인지 확인합니다. 이 접근 방식은 언어 변경이 적게 필요하므로 매력적이지만, 근본적인 문제를 올바르게 해결하지 못합니다.</p>
<p>확인이 <code>None</code>이 아닌 참(truthiness)에 대한 것이라고 가정하면 <code>??</code> 연산자는 더 이상 필요하지 않습니다. 그러나 이 확인을 <code>?.</code> 및 <code>?[]</code> 연산자에 적용하면 완벽하게 유효한 작업이 방지됩니다.</p>
<p><code>get_log_list()</code>가 현재 로그 메시지를 포함하는 리스트(잠재적으로 비어 있음)를 반환하거나 로깅이 활성화되지 않은 경우 <code>None</code>을 반환할 수 있는 다음 예시를 고려하십시오:</p>
<pre><code class="language-python">lst = get_log_list()
lst?.append('A log message')
</code></pre>
<p>만약 <code>?.</code>이 <code>None</code>이 아닌 참 값을 확인하고 로그가 어떤 항목으로도 초기화되지 않았다면, 어떤 항목도 추가되지 않을 것입니다. 이는 항목을 추가하려는 코드의 명백한 의도를 위반합니다. <code>append</code> 메서드는 빈 리스트에서도 사용 가능하며, 다른 모든 리스트 메서드도 마찬가지입니다. 리스트가 현재 비어 있다는 이유로 이러한 멤버를 사용해서는 안 된다고 가정할 이유가 없습니다.</p>
<p>또한, 표현식을 대체할 합리적인 결과가 없습니다. 일반적인 <code>lst.append</code>는 <code>None</code>을 반환하지만, 이 아이디어에서는 <code>lst?.append</code>가 <code>lst</code>의 값에 따라 <code>[]</code> 또는 <code>None</code>을 반환할 수 있습니다. 이전 섹션의 예시와 마찬가지로, 이것은 이치에 맞지 않습니다.</p>
<p><code>None</code>이 아닌 참(truthiness)을 확인하면 겉보기에 유효한 표현식이 의도대로 실행되지 않으므로, 이 아이디어는 거부됩니다.</p>
<h3>예외 인식 연산자 (Exception-aware operators)</h3>
<p><code>None</code>이 발생했을 때 표현식을 단락시키는 이유는 일반적으로 발생할 <code>AttributeError</code> 또는 <code>TypeError</code>를 피하기 위함이라고 주장할 수 있습니다. <code>None</code>을 테스트하는 대안으로, <code>?.</code> 및 <code>?[]</code> 연산자는 대신 작업으로 인해 발생한 <code>AttributeError</code> 및 <code>TypeError</code>를 처리하고 표현식의 나머지 부분을 건너뛸 수 있습니다.</p>
<p>이는 <code>a?.b.c?.d.e</code>와 유사한 변환을 생성합니다:</p>
<pre><code class="language-python">_v = a
try:
    _v = _v.b
except AttributeError:
    pass
else:
    _v = _v.c
    try:
        _v = _v.d
    except AttributeError:
        pass
    else:
        _v = _v.e
</code></pre>
<p>열린 질문 중 하나는 예외가 처리될 때 표현식으로 어떤 값이 반환되어야 하는가입니다. 위의 예시는 단순히 부분적인 결과를 남기지만, 이는 기본값으로 대체하는 데 도움이 되지 않습니다. 다른 대안은 결과를 <code>None</code>으로 강제하는 것인데, 이는 <code>None</code>이 결과로 충분히 특별하면서도 테스트로는 충분히 특별하지 않은 이유에 대한 질문을 제기합니다.</p>
<p>둘째, 이 접근 방식은 표현식의 일부로 암묵적으로 실행되는 코드 내의 오류를 숨깁니다. <code>?.</code>의 경우, 속성 또는 <code>__getattr__</code> 구현 내의 모든 <code>AttributeError</code>가 숨겨질 것이며, <code>?[]</code> 및 <code>__getitem__</code> 구현도 마찬가지입니다.</p>
<p>유사하게, <code>{}.ietms()</code>와 같은 간단한 타이핑 오류도 눈에 띄지 않을 수 있습니다.</p>
<p><code>getattr</code> 내장 함수와 <code>dict</code>가 확립한 <code>.get(key, default)</code> 메서드 패턴 형태의 이러한 종류의 오류 처리에 대한 기존 관습은 이미 이러한 동작을 명시적으로 사용할 수 있음을 보여줍니다.</p>
<p>이 접근 방식은 코드의 오류를 숨기므로 거부됩니다.</p>
<h3><code>None</code>-인식 함수 호출 (<code>None</code>-aware Function Call <code>?()</code>)</h3>
<p><code>None</code>-인식 구문은 속성 및 인덱스 접근에 적용되므로, 함수 호출 구문에도 적용되어야 하는지 묻는 것이 자연스러워 보입니다. <code>foo?()</code>와 같이 작성될 수 있으며, <code>foo</code>가 <code>None</code>이 아닌 경우에만 호출됩니다.</p>
<p>이는 제안된 연산자들이 부분적으로 채워진 계층적 데이터 구조의 탐색을 돕기 위한 것이지, 임의의 클래스 계층 구조의 탐색을 위한 것이 아니라는 전제 하에 보류되었습니다. 이는 이미 이 구문을 제공하는 다른 주류 언어 중 어느 것도 선택적 함수 호출에 대한 유사한 구문을 지원할 가치가 있다고 생각하지 않는다는 사실에 반영됩니다.</p>
<p>C#에서 사용되는 것과 유사한 해결 방법은 <code>maybe_none?.__call__(arguments)</code>를 작성하는 것입니다. 호출 가능 객체가 <code>None</code>이면 표현식은 평가되지 않습니다. (C#의 해당 기능은 호출 가능 타입에서 <code>?.Invoke()</code>를 사용합니다.)</p>
<h3>단항 후위 연산자 (<code>?</code> Unary Postfix Operator)</h3>
<p><code>None</code>-인식 동작을 일반화하고 도입되는 새 연산자의 수를 제한하기 위해 <code>?</code>로 표기되는 단항 후위 연산자가 제안되었습니다. 이 아이디어는 <code>?</code>가 <code>self</code>를 반환하는 dunder 메서드를 오버라이드할 수 있는 특별한 객체를 반환할 수 있다는 것입니다. 예를 들어, <code>foo?</code>는 <code>foo</code>가 <code>None</code>이 아니면 <code>foo</code>로 평가되고, 그렇지 않으면 <code>NoneQuestion</code>의 인스턴스로 평가됩니다.</p>
<pre><code class="language-python">class NoneQuestion():
    def __call__(self, *args, **kwargs):
        return self
    def __getattr__(self, name):
        return self
    def __getitem__(self, key):
        return self
</code></pre>
<p>이 새로운 연산자와 새로운 타입으로, <code>foo?.bar[baz]</code>와 같은 표현식은 <code>foo</code>가 <code>None</code>이면 <code>NoneQuestion</code>으로 평가됩니다. 이것은 훌륭한 일반화이지만, 대부분의 기존 코드가 <code>NoneQuestion</code>이 무엇인지 알지 못하므로 실제로 사용하기 어렵습니다.</p>
<p>위에서 언급된 동기 부여 예시 중 하나로 돌아가서 다음을 고려해 보십시오:</p>
<pre><code class="language-python">>>> import json
>>> created = None
>>> json.dumps({'created': created?.isoformat()})
</code></pre>
<p>JSON 직렬 변환기는 <code>NoneQuestion</code>을 직렬화하는 방법을 알지 못하며, 다른 API도 마찬가지입니다. 이 제안은 실제로 표준 라이브러리 및 모든 서드 파티 라이브러리 전반에 걸쳐 많은 특수 로직을 요구합니다.</p>
<p>동시에, <code>?</code> 연산자는 다른 어떤 연산자와도 결합될 수 있다는 점에서 너무 일반적일 수도 있습니다. 다음 표현식들은 무엇을 의미해야 할까요?:</p>
<pre><code class="language-python">>>> x? + 1
>>> x? -= 1
>>> x? == 1
>>> ~x?
</code></pre>
<p>이러한 일반화의 정도는 유용하지 않습니다. 여기서 실제로 제안된 연산자들은 일반적인 코드 패턴을 더 쉽게 작성할 것으로 예상되는 몇 가지 연산자로 의도적으로 제한됩니다.</p>
<h3>내장 <code>maybe</code> (Built-in <code>maybe</code>)</h3>
<p>Haskell에는 <code>Maybe</code>라는 개념이 있으며, 이는 특별한 키워드(<code>null</code> 등)나 특별한 인스턴스(<code>None</code> 등)에 의존하지 않고 선택적 값의 아이디어를 캡슐화합니다. Haskell에서 <code>Maybe</code>의 목적은 "무언가(something)"와 "아무것도 아님(nothing)"을 별도로 처리하는 것을 피하는 것입니다.</p>
<p><code>pymaybe</code>라는 Python 패키지는 대략적인 근사치를 제공합니다. 문서는 다음 예시를 보여줍니다:</p>
<pre><code class="language-python">>>> maybe('VALUE').lower()
'value'
>>> maybe(None).invalid().method().or_else('unknown')
'unknown'
</code></pre>
<p><code>maybe()</code> 함수는 <code>Something</code> 인스턴스 또는 <code>Nothing</code> 인스턴스를 반환합니다. 이전 섹션에서 설명한 단항 후위 연산자와 유사하게, <code>Nothing</code>은 누락된 값에 대한 체이닝을 허용하기 위해 dunder 메서드를 오버라이드합니다.</p>
<p><code>or_else()</code>는 <code>pymaybe</code>의 래퍼에서 기본 값을 검색하기 위해 결국 필요합니다. 또한, <code>pymaybe</code>는 어떤 평가도 단락시키지 않습니다. <code>pymaybe</code>가 몇 가지 강점을 가지고 있고 그 자체로 유용할 수 있지만, 이는 또한 코얼레싱의 순수 Python 구현이 언어에 내장된 지원만큼 강력하지 않은 이유를 보여줍니다.</p>
<p>이 시나리오를 가능하게 하기 위해 내장 <code>maybe</code> 타입을 추가하는 아이디어는 거부됩니다.</p>
<h3>단순 조건부 표현식 사용 (Just use a conditional expression)</h3>
<p>기본값을 초기화하는 또 다른 일반적인 방법은 삼항 연산자를 사용하는 것입니다. 인기 있는 <code>Requests</code> 패키지의 발췌문은 다음과 같습니다:</p>
<p><strong>이전 (조건부 표현식 사용):</strong></p>
<pre><code class="language-python">data = [] if data is None else data
files = [] if files is None else files
headers = {} if headers is None else headers
params = {} if params is None else params
hooks = {} if hooks is None else hooks
</code></pre>
<p>이 특정 형식은 피연산자를 직관적이지 않은 순서로 배치하는 바람직하지 않은 효과를 가집니다. 즉, 뇌는 "가능하면 <code>data</code>를 사용하고, 아니면 <code>[]</code>를 대체로 사용한다"고 생각하지만, 코드는 대체 값을 선호하는 값 앞에 둡니다.</p>
<p>이 패키지의 작성자는 대신 다음과 같이 작성할 수 있었습니다:</p>
<p><strong>이전 (더 직관적인 조건부 표현식):</strong></p>
<pre><code class="language-python">data = data if data is not None else []
files = files if files is not None else []
headers = headers if headers is not None else {}
params = params if params is not None else {}
hooks = hooks if hooks is not None else {}
</code></pre>
<p>이 피연산자 순서는 더 직관적이지만, 4개의 추가 문자("<code>not</code>")가 필요합니다. 또한 식별자의 반복을 강조합니다: <code>data if data</code>, <code>files if files</code> 등.</p>
<p><code>None</code> 코얼레싱 연산자를 사용하여 작성하면 예시는 다음과 같이 읽힙니다:</p>
<p><strong>이후 (<code>None</code> 코얼레싱 연산자 사용):</strong></p>
<pre><code class="language-python">data = data ?? []
files = files ?? []
headers = headers ?? {}
params = params ?? {}
hooks = hooks ?? {}
</code></pre>
<p>이 구문은 피연산자의 직관적인 순서를 가집니다. <code>find_content_type</code>에서와 같이 선호하는 값이 대체 값보다 먼저 나타납니다. 구문의 간결성은 코드 줄 수를 줄이고 시각적으로 분석할 코드를 줄이며, 왼쪽에서 오른쪽, 위에서 아래로 읽는 것이 실행 흐름을 더 정확하게 따르게 합니다.</p>
<h2>참고 자료 (References)</h2>
<ul>
<li>C# Reference: Operators.</li>
<li>A Tour of the Dart Language: Operators.</li>
<li>Proposal: Nullish Coalescing for JavaScript.</li>
<li>Proposal: Optional Chaining for JavaScript.</li>
<li>Associated scripts.</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 있습니다.</p>
<p><strong>소스:</strong> <code>https://github.com/python/peps/blob/main/peps/pep-0505.rst</code>
<strong>마지막 수정:</strong> 2025-02-01 08:55:40 GMT
이 구문은 피연산자의 직관적인 순서를 가집니다. <code>find_content_type</code>에서와 같이 선호하는 값이 대체 값보다 먼저 나타납니다. 구문의 간결성은 코드 줄 수를 줄이고 시각적으로 분석할 코드를 줄이며, 왼쪽에서 오른쪽, 위에서 아래로 읽는 것이 실행 흐름을 더 정확하게 따르게 합니다.</p>
<h2>참고 자료 (References)</h2>
<ul>
<li>C# Reference: Operators.</li>
<li>A Tour of the Dart Language: Operators.</li>
<li>Proposal: Nullish Coalescing for JavaScript.</li>
<li>Proposal: Optional Chaining for JavaScript.</li>
<li>Associated scripts.</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 있습니다.</p>
<p><strong>소스:</strong> <code>https://github.com/python/peps/blob/main/peps/pep-0505.rst</code>
<strong>마지막 수정:</strong> 2025-02-01 08:55:40 GMT</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-aecaf5ac7a84facf.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-e3ea38185bb36cd2.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/505\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"x02Anhkwgp1He7ftuyAhh\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/505/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/505\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"505\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/505\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:Ta325,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0505/\"\u003ePEP 505 - None-aware operators\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Deferred | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 18-Sep-2015\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Mark E. Haase, Steve Dower\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Deferred (보류됨)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2015년 9월 18일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.8\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003eC#, Dart, Perl, Swift, PHP(버전 7부터), 그리고 ECMAScript(JavaScript)의 드래프트 제안과 같은 여러 현대 프로그래밍 언어에는 \"null-coalescing\" 또는 \"null-aware\" 연산자가 존재합니다. 이러한 연산자들은 \u003ccode\u003enull\u003c/code\u003e 참조와 관련된 일반적인 패턴에 대한 문법적 설탕(syntactic sugar)을 제공합니다.\u003c/p\u003e\n\u003cp\u003e일반적으로:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNull-coalescing 연산자\u003c/strong\u003e는 이항 연산자로, 왼쪽 피연산자가 \u003ccode\u003enull\u003c/code\u003e이 아니면 왼쪽 피연산자를 반환하고, 그렇지 않으면 오른쪽 피연산자를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNull-aware 멤버 접근 연산자\u003c/strong\u003e는 인스턴스가 \u003ccode\u003enull\u003c/code\u003e이 아닌 경우에만 인스턴스 멤버에 접근하며, 그렇지 않으면 \u003ccode\u003enull\u003c/code\u003e을 반환합니다. (이것은 \"안전한 탐색(safe navigation)\" 연산자라고도 불립니다.)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNull-aware 인덱스 접근 연산자\u003c/strong\u003e는 컬렉션이 \u003ccode\u003enull\u003c/code\u003e이 아닌 경우에만 컬렉션의 요소에 접근하며, 그렇지 않으면 \u003ccode\u003enull\u003c/code\u003e을 반환합니다. (이것도 \"안전한 탐색\" 연산자의 한 유형입니다.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 PEP는 위에서 언급된 정의와 다른 언어들의 구현을 바탕으로 Python에 세 가지 \u003ccode\u003eNone\u003c/code\u003e-인식 연산자를 제안합니다. 구체적으로 다음과 같습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eNone\u003c/code\u003e 코얼레싱 이항 연산자 \u003ccode\u003e??\u003c/code\u003e\u003c/strong\u003e: 왼쪽 피연산자가 \u003ccode\u003eNone\u003c/code\u003e이 아닌 값으로 평가되면 왼쪽 피연산자를 반환하고, 그렇지 않으면 오른쪽 피연산자를 평가하여 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eNone\u003c/code\u003e 코얼레싱 할당 연산자 \u003ccode\u003e??=\u003c/code\u003e\u003c/strong\u003e: 증강 할당(augmented assignment) 연산자로 포함됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eNone\u003c/code\u003e-인식 속성 접근 연산자 \u003ccode\u003e?.\u003c/code\u003e\u003c/strong\u003e (\"maybe dot\"): 왼쪽 피연산자가 \u003ccode\u003eNone\u003c/code\u003e이 아닌 값으로 평가될 경우에만 전체 표현식을 평가합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eNone\u003c/code\u003e-인식 인덱싱 연산자 \u003ccode\u003e?[]\u003c/code\u003e\u003c/strong\u003e (\"maybe subscript\"): 왼쪽 피연산자가 \u003ccode\u003eNone\u003c/code\u003e이 아닌 값으로 평가될 경우에만 전체 표현식을 평가합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e제안된 문법 변경 및 사용 예시는 아래 섹션에서 더 자세히 다룹니다.\u003c/p\u003e\n\u003ch2\u003e구문 및 의미론 (Syntax and Semantics)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003eNone\u003c/code\u003e의 특수성 (Specialness of \u003ccode\u003eNone\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eNone\u003c/code\u003e 객체는 \"값이 없음\"을 나타냅니다. 이 연산자들의 목적상, \"값이 없음\"은 표현식의 나머지 부분도 \"값이 없음\"을 의미하며 평가되어서는 안 된다는 것을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e이전에 거부된 제안은 부울(Boolean) 컨텍스트에서 \u003ccode\u003eFalse\u003c/code\u003e로 평가되는 모든 값을 \"값이 없음\"으로 취급하는 것이었습니다. 그러나 이 연산자들의 목적은 \"\u003ccode\u003eFalse\u003c/code\u003e\" 상태보다는 \"값이 없음\" 상태를 전파하는 것입니다.\u003c/p\u003e\n\u003cp\u003e일부에서는 이로 인해 \u003ccode\u003eNone\u003c/code\u003e이 특별해진다고 주장하지만, PEP는 \u003ccode\u003eNone\u003c/code\u003e이 이미 특별하며, 이 연산자들에서 \u003ccode\u003eNone\u003c/code\u003e을 테스트와 결과 모두로 사용하는 것이 기존 의미론을 어떤 식으로든 변경하지 않는다고 주장합니다.\u003c/p\u003e\n\u003cp\u003e대체 접근 방식에 대한 논의는 \"거부된 아이디어\" 섹션을 참조하십시오.\u003c/p\u003e\n\u003ch3\u003e문법 변경 (Grammar changes)\u003c/h3\u003e\n\u003cp\u003ePython 문법의 다음 규칙들이 다음과 같이 업데이트됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaugassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '\u0026#x26;=' | '|=' | '^=' | '\u0026#x3C;\u0026#x3C;=' | '\u003e\u003e=' | '**=' | '//=' | '??=')\r\npower: coalesce ['**' factor]\r\ncoalesce: atom_expr ['??' factor]\r\natom_expr: ['await'] atom trailer*\r\ntrailer: ('(' [arglist] ')' | '[' subscriptlist ']' | '?[' subscriptlist ']' | '.' NAME | '?.' NAME)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e코얼레싱 규칙 (\u003ccode\u003e??\u003c/code\u003e 연산자)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ecoalesce\u003c/code\u003e 규칙은 \u003ccode\u003e??\u003c/code\u003e 이항 연산자를 제공합니다. 대부분의 이항 연산자와 달리, \u003ccode\u003e??\u003c/code\u003e 연산자는 왼쪽 피연산자가 \u003ccode\u003eNone\u003c/code\u003e으로 결정될 때까지 오른쪽 피연산자를 평가하지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e??\u003c/code\u003e 연산자는 다른 이항 연산자보다 더 강하게 바인딩됩니다. 이는 대부분의 기존 구현이 \u003ccode\u003eNone\u003c/code\u003e 값을 전파하지 않고 \u003ccode\u003eTypeError\u003c/code\u003e를 발생시키기 때문입니다. 잠재적으로 \u003ccode\u003eNone\u003c/code\u003e이 될 수 있는 표현식은 추가적인 괄호 없이 기본값으로 대체될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e??\u003c/code\u003e 연산자가 있을 때 연산자 우선순위를 평가하는 몇 가지 예시는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ea, b = None, None\r\ndef c(): return None\r\ndef ex(): raise Exception()\r\n\r\n# 괄호의 암묵적인 배치 예시\r\n(a ?? 2 ** b ?? 3) == a ?? (2 ** (b ?? 3))\r\n(a * b ?? c // d) == a * (b ?? c) // d\r\n(a ?? True and b ?? False) == (a ?? True) and (b ?? False)\r\n(c() ?? c() ?? True) == True\r\n(True ?? ex()) == True\r\n(c ?? ex)() == c() # c가 None이면 ex()를 평가하지 않고, None이 아니면 c() 호출\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e특히 \u003ccode\u003ea ?? 2 ** b ?? 3\u003c/code\u003e과 같은 경우, 다른 방식으로 부분 표현식에 괄호를 치면 \u003ccode\u003eTypeError\u003c/code\u003e가 발생할 수 있습니다. \u003ccode\u003eint.__pow__\u003c/code\u003e는 \u003ccode\u003eNone\u003c/code\u003e으로 호출될 수 없기 때문입니다 (\u003ccode\u003e??\u003c/code\u003e 연산자가 사용되었다는 사실 자체가 \u003ccode\u003ea\u003c/code\u003e 또는 \u003ccode\u003eb\u003c/code\u003e가 \u003ccode\u003eNone\u003c/code\u003e일 수 있음을 암시합니다). 그러나 평소와 같이 괄호는 필수는 아니지만 가독성 향상에 도움이 된다면 추가해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e??\u003c/code\u003e 연산자에 대한 증강 할당 \u003ccode\u003e??=\u003c/code\u003e도 추가됩니다. 증강 코얼레싱 할당은 현재 값이 \u003ccode\u003eNone\u003c/code\u003e인 경우에만 이름을 재바인딩합니다. 대상 이름이 이미 값을 가지고 있다면, 오른쪽 피연산자는 평가되지 않습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ea = None\r\nb = ''\r\nc = 0\r\n\r\na ??= 'value'\r\nb ??= undefined_name # b는 ''이므로 undefined_name은 평가되지 않음\r\nc ??= shutil.rmtree('/') # c는 0이므로 shutil.rmtree('/')는 평가되지 않음\r\n\r\nassert a == 'value'\r\nassert b == ''\r\nassert c == 0 # and any(os.scandir('/'))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003ccode\u003emaybe-dot\u003c/code\u003e (\u003ccode\u003e?.\u003c/code\u003e) 및 \u003ccode\u003emaybe-subscript\u003c/code\u003e (\u003ccode\u003e?[]\u003c/code\u003e) 연산자\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003emaybe-dot\u003c/code\u003e (\u003ccode\u003e?.\u003c/code\u003e) 및 \u003ccode\u003emaybe-subscript\u003c/code\u003e (\u003ccode\u003e?[]\u003c/code\u003e) 연산자는 \u003ccode\u003eatom\u003c/code\u003e에 대한 \u003ccode\u003etrailer\u003c/code\u003e로 추가되어, 일반 연산자와 동일한 모든 위치에서 사용될 수 있습니다. 여기에는 할당 대상의 일부로도 포함됩니다. 기존 평가 규칙은 문법에 직접 포함되어 있지 않으므로, 필요한 변경 사항을 아래에 명시합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eatom\u003c/code\u003e은 항상 성공적으로 평가된다고 가정합니다. 각 \u003ccode\u003etrailer\u003c/code\u003e는 왼쪽에서 오른쪽으로 평가되며, 자체 매개변수(인자, 인덱스 또는 속성 이름)를 적용하여 다음 \u003ccode\u003etrailer\u003c/code\u003e의 값을 생성합니다. 마지막으로, \u003ccode\u003eawait\u003c/code\u003e가 존재하면 적용됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003eawait a.b(c).d[e]\u003c/code\u003e는 현재 \u003ccode\u003e['await', 'a', '.b', '(c)', '.d', '[e]']\u003c/code\u003e로 파싱되고 다음과 같이 평가됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_v = a\r\n_v = _v.b\r\n_v = _v(c)\r\n_v = _v.d\r\n_v = _v[e]\r\nawait _v\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eNone\u003c/code\u003e-인식 연산자가 있을 때, 왼쪽에서 오른쪽으로의 평가는 단락(short-circuited)될 수 있습니다. 예를 들어, \u003ccode\u003eawait a?.b(c).d?[e]\u003c/code\u003e는 다음과 같이 평가됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_v = a\r\nif _v is not None:\r\n    _v = _v.b\r\n    _v = _v(c)\r\n    _v = _v.d\r\n    if _v is not None:\r\n        _v = _v[e]\r\nawait _v\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e \u003ccode\u003eawait\u003c/code\u003e는 \u003ccode\u003eawait None\u003c/code\u003e을 시도하는 경우와 마찬가지로 이 컨텍스트에서 거의 확실히 실패할 것입니다. 이 PEP는 \u003ccode\u003eNone\u003c/code\u003e-인식 \u003ccode\u003eawait\u003c/code\u003e 키워드를 추가할 것을 제안하지 않으며, 단지 \u003ccode\u003eatom_expr\u003c/code\u003e 문법 규칙에 해당 키워드가 포함되어 있어 명세의 완전성을 위해 이 예시에 포함시킨 것입니다.\u003c/p\u003e\n\u003cp\u003e괄호로 묶인 표현식은 \u003ccode\u003eatom\u003c/code\u003e 규칙(위에는 표시되지 않음)에 의해 처리되며, 이는 위의 변환에서 단락 동작을 암묵적으로 종료합니다. 예를 들어, \u003ccode\u003e(a?.b ?? c).d?.e\u003c/code\u003e는 다음과 같이 평가됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# a?.b\r\n_v = a\r\nif _v is not None:\r\n    _v = _v.b\r\n# ... ?? c\r\nif _v is None:\r\n    _v = c\r\n# (...).d?.e\r\n_v = _v.d\r\nif _v is not None:\r\n    _v = _v.e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e할당 대상(assignment target)으로 사용될 때, \u003ccode\u003eNone\u003c/code\u003e-인식 연산은 \"로드(load)\" 컨텍스트에서만 사용될 수 있습니다. 즉, \u003ccode\u003ea?.b = 1\u003c/code\u003e 및 \u003ccode\u003ea?[b] = 1\u003c/code\u003e은 \u003ccode\u003eSyntaxError\u003c/code\u003e를 발생시킵니다. 표현식 앞부분에서의 사용(\u003ccode\u003ea?.b.c = 1\u003c/code\u003e)은 허용되지만, 코얼레싱 연산과 결합되지 않으면 유용하지 않을 가능성이 높습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e(a?.b ?? d).c = 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e표현식 읽기 (Reading expressions)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003emaybe-dot\u003c/code\u003e (\u003ccode\u003e?.\u003c/code\u003e) 및 \u003ccode\u003emaybe-subscript\u003c/code\u003e (\u003ccode\u003e?[]\u003c/code\u003e) 연산자를 포함하는 표현식은 이 연산자들의 일반 버전과 동일하게 읽고 해석되어야 합니다. \"정상적인\" 경우, \u003ccode\u003ea?.b?[c]\u003c/code\u003e와 \u003ccode\u003ea.b[c]\u003c/code\u003e와 같은 표현식의 최종 결과는 동일할 것입니다. 우리가 현재 \"a.b\"를 \"a에 속성 b가 있다면 읽고, 그렇지 않으면 AttributeError를 발생시킨다\"라고 읽지 않는 것처럼, \u003ccode\u003ea?.b\u003c/code\u003e를 \"a가 \u003ccode\u003eNone\u003c/code\u003e이 아니면 a에서 속성 b를 읽는다\"라고 읽을 필요는 없습니다 (듣는 사람이 특정 동작을 알아야 하는 컨텍스트가 아니라면).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e??\u003c/code\u003e 연산자를 사용하는 코얼레싱 표현식의 경우, 표현식은 \"\u003ccode\u003eNone\u003c/code\u003e이면 ... 또는\" 또는 \"\u003ccode\u003e...\u003c/code\u003e와 코얼레싱된다\"로 읽어야 합니다. 예를 들어, \u003ccode\u003ea.get_value() ?? 100\u003c/code\u003e이라는 표현식은 \"\u003ccode\u003ea.get_value\u003c/code\u003e를 호출하거나 \u003ccode\u003eNone\u003c/code\u003e이면 100\" 또는 \"\u003ccode\u003ea.get_value\u003c/code\u003e와 100을 코얼레싱한다\"로 읽을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 구어로 코드를 읽는 것은 항상 정보 손실이 있으므로, 이 연산자들을 명확하게 말하는 방법을 정의하려는 시도는 하지 않습니다. 이러한 제안은 새로운 문법 추가의 의미에 대한 맥락을 제공하기 위한 것입니다.\u003c/p\u003e\n\u003ch2\u003e예시 (Examples)\u003c/h2\u003e\n\u003cp\u003e이 섹션에서는 일반적인 \u003ccode\u003eNone\u003c/code\u003e 패턴의 몇 가지 예시를 제시하고, \u003ccode\u003eNone\u003c/code\u003e-인식 연산자를 사용하도록 변환했을 때 어떤 모습이 될지 보여줍니다.\u003c/p\u003e\n\u003ch3\u003e표준 라이브러리 (Standard Library)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003efind-pep505.py\u003c/code\u003e 스크립트를 사용하여 Python 3.7 표준 라이브러리를 분석한 결과, 최대 678개의 코드 스니펫이 \u003ccode\u003eNone\u003c/code\u003e-인식 연산자 중 하나를 사용하여 대체될 수 있음을 발견했습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ find /usr/lib/python3.7 -name '*.py' | xargs python3.7 find-pep505.py\r\n\u0026#x3C;snip\u003e\r\nTotal None-coalescing `if` blocks: 449\r\nTotal [possible] None-coalescing `or`: 120\r\nTotal None-coalescing ternaries: 27\r\nTotal Safe navigation `and`: 13\r\nTotal Safe navigation `if` blocks: 61\r\nTotal Safe navigation ternaries: 8\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래는 새 연산자를 사용하도록 변환하기 전후의 몇 가지 예시입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebisect.py\u003c/code\u003e에서:\r\n\u003cstrong\u003e이전:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef insort_right(a, x, lo=0, hi=None):\r\n    # ...\r\n    if hi is None:\r\n        hi = len(a)\r\n    # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e??=\u003c/code\u003e 증강 할당문을 사용하도록 업데이트 후:\r\n\u003cstrong\u003e이후:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef insort_right(a, x, lo=0, hi=None):\r\n    # ...\r\n    hi ??= len(a)\r\n    # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecalendar.py\u003c/code\u003e에서:\r\n\u003cstrong\u003e이전:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eencoding = options.encoding\r\nif encoding is None:\r\n    encoding = sys.getdefaultencoding()\r\noptdict = dict(encoding=encoding, css=options.css)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e??\u003c/code\u003e 연산자를 사용하도록 업데이트 후:\r\n\u003cstrong\u003e이후:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eoptdict = dict(encoding=options.encoding ?? sys.getdefaultencoding(), css=options.css)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eemail/generator.py\u003c/code\u003e에서 (여기서 \u003ccode\u003eor\u003c/code\u003e를 \u003ccode\u003e??\u003c/code\u003e로 대체할 방법이 없다는 점을 중요하게 주목하십시오):\r\n\u003cstrong\u003e이전:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003emangle_from_ = True if policy is None else policy.mangle_from_\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e업데이트 후:\r\n\u003cstrong\u003e이후:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e mangle = True if policy is None else policy.mangle_from_\r\n # after update\r\n mangle_from_ = policy?.mangle_from_ ?? True\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e이후 (오류 수정):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003emangle_from_ = policy?.mangle_from_ ?? True\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003easyncio/subprocess.py\u003c/code\u003e에서:\r\n\u003cstrong\u003e이전:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef pipe_data_received(self, fd, data):\r\n    if fd == 1:\r\n        reader = self.stdout\r\n    elif fd == 2:\r\n        reader = self.stderr\r\n    else:\r\n        reader = None\r\n    if reader is not None:\r\n        reader.feed_data(data)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e?.\u003c/code\u003e 연산자를 사용하도록 업데이트 후:\r\n\u003cstrong\u003e이후:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef pipe_data_received(self, fd, data):\r\n    if fd == 1:\r\n        reader = self.stdout\r\n    elif fd == 2:\r\n        reader = self.stderr\r\n    else:\r\n        reader = None\r\n    reader?.feed_data(data)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003easyncio/tasks.py\u003c/code\u003e에서:\r\n\u003cstrong\u003e이전:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\r\n    await waiter\r\nfinally:\r\n    if timeout_handle is not None:\r\n        timeout_handle.cancel()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e?.\u003c/code\u003e 연산자를 사용하도록 업데이트 후:\r\n\u003cstrong\u003e이후:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\r\n    await waiter\r\nfinally:\r\n    timeout_handle?.cancel()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ectypes/_aix.py\u003c/code\u003e에서:\r\n\u003cstrong\u003e이전:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif libpaths is None:\r\n    libpaths = []\r\nelse:\r\n    libpaths = libpaths.split(\":\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e업데이트 후:\r\n\u003cstrong\u003e이후:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elibpaths = libpaths?.split(\":\") ?? []\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eos.py\u003c/code\u003e에서:\r\n\u003cstrong\u003e이전:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif entry.is_dir():\r\n    dirs.append(name)\r\n    if entries is not None:\r\n        entries.append(entry)\r\n    else:\r\n        nondirs.append(name)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e?.\u003c/code\u003e 연산자를 사용하도록 업데이트 후:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif entry.is_dir():\r\n    dirs.append(name)\r\n    entries?.append(entry)\r\nelse:\r\n    nondirs.append(name)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eimportlib/abc.py\u003c/code\u003e에서:\r\n\u003cstrong\u003e이전 (부분 업데이트 전):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef find_module(self, fullname, path):\r\n    if not hasattr(self, 'find_spec'):\r\n        return None\r\n    found = self.find_spec(fullname, path)\r\n    return found.loader if found is not None else None\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e부분 업데이트 후:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef find_module(self, fullname, path):\r\n    if not hasattr(self, 'find_spec'):\r\n        return None\r\n    return self.find_spec(fullname, path)?.loader\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e광범위하게 업데이트 후 (과하다고 볼 수도 있지만, 스타일 가이드에서 결정할 부분입니다):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef find_module(self, fullname, path):\r\n    return getattr(self, 'find_spec', None)?.__call__(fullname, path)?.loader\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edis.py\u003c/code\u003e에서:\r\n\u003cstrong\u003e이전:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef _get_const_info(const_index, const_list):\r\n    argval = const_index\r\n    if const_list is not None:\r\n        argval = const_list[const_index]\r\n    return argval, repr(argval)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e?[]\u003c/code\u003e 및 \u003ccode\u003e??\u003c/code\u003e 연산자를 사용하도록 업데이트 후:\r\n\u003cstrong\u003e이후:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef _get_const_info(const_index, const_list):\r\n    argval = const_list?[const_index] ?? const_index\r\n    return argval, repr(argval)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003ccode\u003ejsonify\u003c/code\u003e 예시\u003c/h3\u003e\n\u003cp\u003e이 예시는 Flask 프레임워크를 프런트엔드로 사용하는 Python 웹 크롤러에서 가져온 것입니다. 이 함수는 SQL 데이터베이스에서 웹 사이트 정보를 검색하고 HTTP 클라이언트에 보낼 JSON 형식으로 지정합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efirst_seen\u003c/code\u003e과 \u003ccode\u003elast_seen\u003c/code\u003e은 데이터베이스에서 \u003ccode\u003enull\u003c/code\u003e이 허용되며, JSON 응답에서도 \u003ccode\u003enull\u003c/code\u003e이 허용됩니다. JSON은 \u003ccode\u003edatetime\u003c/code\u003e을 나타내는 기본 방법이 없으므로, 서버의 계약은 \u003ccode\u003enull\u003c/code\u003e이 아닌 모든 날짜를 ISO-8601 문자열로 표현한다고 명시합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efirst_seen\u003c/code\u003e 및 \u003ccode\u003elast_seen\u003c/code\u003e 속성의 정확한 의미를 알지 못하면, 해당 속성에 안전하게 또는 성능적으로 여러 번 접근할 수 있는지 알 수 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이전 (조건부 표현식 사용):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass SiteView(FlaskView):\r\n    @route('/site/\u0026#x3C;id_\u003e', methods=['GET'])\r\n    def get_site(self, id_):\r\n        site = db.query('site_table').find(id_)\r\n        return jsonify(\r\n            first_seen=site.first_seen.isoformat() if site.first_seen is not None else None,\r\n            id=site.id,\r\n            is_active=site.is_active,\r\n            last_seen=site.last_seen.isoformat() if site.last_seen is not None else None,\r\n            url=site.url.rstrip('/')\r\n        )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드를 수정하는 한 가지 방법은 각 조건부 표현식을 명시적인 값 할당과 전체 \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e 블록으로 대체하는 것입니다:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이전 (if/else 블록으로 확장):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass SiteView(FlaskView):\r\n    @route('/site/\u0026#x3C;id_\u003e', methods=['GET'])\r\n    def get_site(self, id_):\r\n        site = db.query('site_table').find(id_)\r\n        first_seen_dt = site.first_seen\r\n        if first_seen_dt is None:\r\n            first_seen = None\r\n        else:\r\n            first_seen = first_seen_dt.isoformat()\r\n        last_seen_dt = site.last_seen\r\n        if last_seen_dt is None:\r\n            last_seen = None\r\n        else:\r\n            last_seen = last_seen_dt.isoformat()\r\n        return jsonify(\r\n            first_seen=first_seen,\r\n            id=site.id,\r\n            is_active=site.is_active,\r\n            last_seen=last_seen,\r\n            url=site.url.rstrip('/')\r\n        )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 10줄의 코드를 추가하고 함수에 4개의 새로운 코드 경로를 만들어, 외견상 복잡성을 크게 증가시킵니다. \u003ccode\u003eNone\u003c/code\u003e-인식 속성 연산자를 사용하여 다시 작성하면 의도가 더 명확해지면서 코드가 짧아집니다:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이후 (\u003ccode\u003eNone\u003c/code\u003e-인식 연산자 사용):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass SiteView(FlaskView):\r\n    @route('/site/\u0026#x3C;id_\u003e', methods=['GET'])\r\n    def get_site(self, id_):\r\n        site = db.query('site_table').find(id_)\r\n        return jsonify(\r\n            first_seen=site.first_seen?.isoformat(),\r\n            id=site.id,\r\n            is_active=site.is_active,\r\n            last_seen=site.last_seen?.isoformat(),\r\n            url=site.url.rstrip('/')\r\n        )\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003ccode\u003eGrab\u003c/code\u003e 예시\u003c/h3\u003e\n\u003cp\u003e다음 예시는 Grab이라는 Python 스크래핑 라이브러리에서 가져온 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이전 (\u003ccode\u003eif/else\u003c/code\u003e 블록 사용):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass BaseUploadObject(object):\r\n    def find_content_type(self, filename):\r\n        ctype, encoding = mimetypes.guess_type(filename)\r\n        if ctype is None:\r\n            return 'application/octet-stream'\r\n        else:\r\n            return ctype\r\n\r\nclass UploadContent(BaseUploadObject):\r\n    def __init__(self, content, filename=None, content_type=None):\r\n        self.content = content\r\n        if filename is None:\r\n            self.filename = self.get_random_filename()\r\n        else:\r\n            self.filename = filename\r\n        if content_type is None:\r\n            self.content_type = self.find_content_type(self.filename)\r\n        else:\r\n            self.content_type = content_type\r\n\r\nclass UploadFile(BaseUploadObject):\r\n    def __init__(self, path, filename=None, content_type=None):\r\n        self.path = path\r\n        if filename is None:\r\n            self.filename = os.path.split(path)[1]\r\n        else:\r\n            self.filename = filename\r\n        if content_type is None:\r\n            self.content_type = self.find_content_type(self.filename)\r\n        else:\r\n            self.content_type = content_type\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에는 기본값을 제공해야 하는 여러 좋은 예시가 포함되어 있습니다. 조건부 표현식을 사용하도록 다시 작성하면 전체 코드 줄 수는 줄어들지만, 반드시 가독성이 향상되는 것은 아닙니다:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이전 (조건부 표현식 사용):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass BaseUploadObject(object):\r\n    def find_content_type(self, filename):\r\n        ctype, encoding = mimetypes.guess_type(filename)\r\n        return 'application/octet-stream' if ctype is None else ctype\r\n\r\nclass UploadContent(BaseUploadObject):\r\n    def __init__(self, content, filename=None, content_type=None):\r\n        self.content = content\r\n        self.filename = (self.get_random_filename() if filename is None else filename)\r\n        self.content_type = (self.find_content_type(self.filename) if content_type is None else content_type)\r\n\r\nclass UploadFile(BaseUploadObject):\r\n    def __init__(self, path, filename=None, content_type=None):\r\n        self.path = path\r\n        self.filename = (os.path.split(path)[1] if filename is None else filename)\r\n        self.content_type = (self.find_content_type(self.filename) if content_type is None else content_type)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 삼항 표현식은 깔끔하지만, 피연산자의 직관적인 순서를 뒤바꿉니다. 즉, 값이 있으면 \u003ccode\u003ectype\u003c/code\u003e을 반환하고, 아니면 문자열 리터럴을 대체로 사용해야 합니다. 다른 삼항 표현식은 직관적이지 않고 너무 길어서 줄 바꿈을 해야 합니다. 전반적인 가독성은 향상되지 않고 악화되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eNone\u003c/code\u003e 코얼레싱 연산자를 사용하여 다시 작성하면 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이후 (\u003ccode\u003eNone\u003c/code\u003e 코얼레싱 연산자 사용):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass BaseUploadObject(object):\r\n    def find_content_type(self, filename):\r\n        ctype, encoding = mimetypes.guess_type(filename)\r\n        return ctype ?? 'application/octet-stream'\r\n\r\nclass UploadContent(BaseUploadObject):\r\n    def __init__(self, content, filename=None, content_type=None):\r\n        self.content = content\r\n        self.filename = filename ?? self.get_random_filename()\r\n        self.content_type = content_type ?? self.find_content_type(self.filename)\r\n\r\nclass UploadFile(BaseUploadObject):\r\n    def __init__(self, path, filename=None, content_type=None):\r\n        self.path = path\r\n        self.filename = filename ?? os.path.split(path)[1]\r\n        self.content_type = content_type ?? self.find_content_type(self.filename)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 구문은 피연산자의 순서가 직관적입니다. 예를 들어 \u003ccode\u003efind_content_type\u003c/code\u003e에서는 선호되는 값 \u003ccode\u003ectype\u003c/code\u003e이 대체 값보다 먼저 나타납니다. 구문의 간결성은 코드 줄 수를 줄이고 시각적으로 분석할 코드를 줄이며, 왼쪽에서 오른쪽, 위에서 아래로 읽는 것이 실행 흐름을 더 정확하게 따르게 합니다.\u003c/p\u003e\n\u003ch2\u003e거부된 아이디어 (Rejected Ideas)\u003c/h2\u003e\n\u003cp\u003e이 섹션의 처음 세 가지 아이디어는 \u003ccode\u003eNone\u003c/code\u003e을 특별하게 취급하는 것에 대한 자주 제안되는 대안입니다. 이러한 아이디어들이 왜 거부되었는지에 대한 더 자세한 배경은 PEP 531 및 PEP 532와 관련 논의를 참조하십시오.\u003c/p\u003e\n\u003ch3\u003e값 없음 프로토콜 (No-Value Protocol)\u003c/h3\u003e\n\u003cp\u003e이 연산자들은 값이 \"값이 없음\"을 나타내는 시기를 나타내는 프로토콜을 정의함으로써 사용자 정의 타입으로 일반화될 수 있었습니다. 이러한 프로토콜은 값이 유효한 값으로 취급되어야 할 때 \u003ccode\u003eTrue\u003c/code\u003e를 반환하고, 값이 값 없음으로 취급되어야 할 때 \u003ccode\u003eFalse\u003c/code\u003e를 반환하는 dunder 메서드 \u003ccode\u003e__has_value__(self)\u003c/code\u003e일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 일반화를 통해 \u003ccode\u003eobject\u003c/code\u003e는 다음과 동등한 dunder 메서드를 구현할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef __has_value__(self):\r\n    return True\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eNoneType\u003c/code\u003e은 다음과 동등한 dunder 메서드를 구현할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef __has_value__(self):\r\n    return False\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e명세 섹션에서 \u003ccode\u003ex is None\u003c/code\u003e의 모든 사용은 \u003ccode\u003enot x.__has_value__()\u003c/code\u003e로 대체될 것입니다.\u003c/p\u003e\n\u003cp\u003e이 일반화를 통해 도메인별 \"값 없음\" 객체가 \u003ccode\u003eNone\u003c/code\u003e과 동일하게 코얼레싱될 수 있습니다. 예를 들어, \u003ccode\u003epyasn1\u003c/code\u003e 패키지에는 ASN.1 \u003ccode\u003enull\u003c/code\u003e을 나타내는 \u003ccode\u003eNull\u003c/code\u003e이라는 타입이 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e from pyasn1.type import univ\r\n\u003e\u003e\u003e univ.Null() ?? univ.Integer(123)\r\nInteger(123)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e유사하게, \u003ccode\u003emath.nan\u003c/code\u003e 및 \u003ccode\u003eNotImplemented\u003c/code\u003e와 같은 값들도 \"값이 없음\"을 나타내는 것으로 취급될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 이러한 값들의 \"값 없음\" 속성은 도메인별이므로 언어에 의해 값으로 취급되어야 합니다. 예를 들어, \u003ccode\u003emath.nan.imag\u003c/code\u003e는 잘 정의되어 있습니다(0.0입니다). 따라서 \u003ccode\u003emath.nan?.imag\u003c/code\u003e를 단락하여 \u003ccode\u003emath.nan\u003c/code\u003e을 반환하는 것은 잘못될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eNone\u003c/code\u003e은 이미 언어에 의해 \"값이 없음\"을 나타내는 값으로 정의되어 있으며, 현재 명세는 미래에 프로토콜로 전환하는 것을 배제하지 않으므로 (내장 객체 변경은 호환되지 않겠지만), 이 아이디어는 현재 거부됩니다.\u003c/p\u003e\n\u003ch3\u003e부울 인식 연산자 (Boolean-aware operators)\u003c/h3\u003e\n\u003cp\u003e이 제안은 \"값 없음 프로토콜\"을 추가하는 것과 근본적으로 동일하며, 위의 논의가 그대로 적용됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e??\u003c/code\u003e 연산자와 유사한 동작은 \u003ccode\u003eor\u003c/code\u003e 표현식으로 달성할 수 있지만, \u003ccode\u003eor\u003c/code\u003e는 왼쪽 피연산자가 \u003ccode\u003eNone\u003c/code\u003e인지 여부가 아니라 \u003ccode\u003efalse-y\u003c/code\u003e인지 확인합니다. 이 접근 방식은 언어 변경이 적게 필요하므로 매력적이지만, 근본적인 문제를 올바르게 해결하지 못합니다.\u003c/p\u003e\n\u003cp\u003e확인이 \u003ccode\u003eNone\u003c/code\u003e이 아닌 참(truthiness)에 대한 것이라고 가정하면 \u003ccode\u003e??\u003c/code\u003e 연산자는 더 이상 필요하지 않습니다. 그러나 이 확인을 \u003ccode\u003e?.\u003c/code\u003e 및 \u003ccode\u003e?[]\u003c/code\u003e 연산자에 적용하면 완벽하게 유효한 작업이 방지됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eget_log_list()\u003c/code\u003e가 현재 로그 메시지를 포함하는 리스트(잠재적으로 비어 있음)를 반환하거나 로깅이 활성화되지 않은 경우 \u003ccode\u003eNone\u003c/code\u003e을 반환할 수 있는 다음 예시를 고려하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elst = get_log_list()\r\nlst?.append('A log message')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 \u003ccode\u003e?.\u003c/code\u003e이 \u003ccode\u003eNone\u003c/code\u003e이 아닌 참 값을 확인하고 로그가 어떤 항목으로도 초기화되지 않았다면, 어떤 항목도 추가되지 않을 것입니다. 이는 항목을 추가하려는 코드의 명백한 의도를 위반합니다. \u003ccode\u003eappend\u003c/code\u003e 메서드는 빈 리스트에서도 사용 가능하며, 다른 모든 리스트 메서드도 마찬가지입니다. 리스트가 현재 비어 있다는 이유로 이러한 멤버를 사용해서는 안 된다고 가정할 이유가 없습니다.\u003c/p\u003e\n\u003cp\u003e또한, 표현식을 대체할 합리적인 결과가 없습니다. 일반적인 \u003ccode\u003elst.append\u003c/code\u003e는 \u003ccode\u003eNone\u003c/code\u003e을 반환하지만, 이 아이디어에서는 \u003ccode\u003elst?.append\u003c/code\u003e가 \u003ccode\u003elst\u003c/code\u003e의 값에 따라 \u003ccode\u003e[]\u003c/code\u003e 또는 \u003ccode\u003eNone\u003c/code\u003e을 반환할 수 있습니다. 이전 섹션의 예시와 마찬가지로, 이것은 이치에 맞지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eNone\u003c/code\u003e이 아닌 참(truthiness)을 확인하면 겉보기에 유효한 표현식이 의도대로 실행되지 않으므로, 이 아이디어는 거부됩니다.\u003c/p\u003e\n\u003ch3\u003e예외 인식 연산자 (Exception-aware operators)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eNone\u003c/code\u003e이 발생했을 때 표현식을 단락시키는 이유는 일반적으로 발생할 \u003ccode\u003eAttributeError\u003c/code\u003e 또는 \u003ccode\u003eTypeError\u003c/code\u003e를 피하기 위함이라고 주장할 수 있습니다. \u003ccode\u003eNone\u003c/code\u003e을 테스트하는 대안으로, \u003ccode\u003e?.\u003c/code\u003e 및 \u003ccode\u003e?[]\u003c/code\u003e 연산자는 대신 작업으로 인해 발생한 \u003ccode\u003eAttributeError\u003c/code\u003e 및 \u003ccode\u003eTypeError\u003c/code\u003e를 처리하고 표현식의 나머지 부분을 건너뛸 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이는 \u003ccode\u003ea?.b.c?.d.e\u003c/code\u003e와 유사한 변환을 생성합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_v = a\r\ntry:\r\n    _v = _v.b\r\nexcept AttributeError:\r\n    pass\r\nelse:\r\n    _v = _v.c\r\n    try:\r\n        _v = _v.d\r\n    except AttributeError:\r\n        pass\r\n    else:\r\n        _v = _v.e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e열린 질문 중 하나는 예외가 처리될 때 표현식으로 어떤 값이 반환되어야 하는가입니다. 위의 예시는 단순히 부분적인 결과를 남기지만, 이는 기본값으로 대체하는 데 도움이 되지 않습니다. 다른 대안은 결과를 \u003ccode\u003eNone\u003c/code\u003e으로 강제하는 것인데, 이는 \u003ccode\u003eNone\u003c/code\u003e이 결과로 충분히 특별하면서도 테스트로는 충분히 특별하지 않은 이유에 대한 질문을 제기합니다.\u003c/p\u003e\n\u003cp\u003e둘째, 이 접근 방식은 표현식의 일부로 암묵적으로 실행되는 코드 내의 오류를 숨깁니다. \u003ccode\u003e?.\u003c/code\u003e의 경우, 속성 또는 \u003ccode\u003e__getattr__\u003c/code\u003e 구현 내의 모든 \u003ccode\u003eAttributeError\u003c/code\u003e가 숨겨질 것이며, \u003ccode\u003e?[]\u003c/code\u003e 및 \u003ccode\u003e__getitem__\u003c/code\u003e 구현도 마찬가지입니다.\u003c/p\u003e\n\u003cp\u003e유사하게, \u003ccode\u003e{}.ietms()\u003c/code\u003e와 같은 간단한 타이핑 오류도 눈에 띄지 않을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egetattr\u003c/code\u003e 내장 함수와 \u003ccode\u003edict\u003c/code\u003e가 확립한 \u003ccode\u003e.get(key, default)\u003c/code\u003e 메서드 패턴 형태의 이러한 종류의 오류 처리에 대한 기존 관습은 이미 이러한 동작을 명시적으로 사용할 수 있음을 보여줍니다.\u003c/p\u003e\n\u003cp\u003e이 접근 방식은 코드의 오류를 숨기므로 거부됩니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eNone\u003c/code\u003e-인식 함수 호출 (\u003ccode\u003eNone\u003c/code\u003e-aware Function Call \u003ccode\u003e?()\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eNone\u003c/code\u003e-인식 구문은 속성 및 인덱스 접근에 적용되므로, 함수 호출 구문에도 적용되어야 하는지 묻는 것이 자연스러워 보입니다. \u003ccode\u003efoo?()\u003c/code\u003e와 같이 작성될 수 있으며, \u003ccode\u003efoo\u003c/code\u003e가 \u003ccode\u003eNone\u003c/code\u003e이 아닌 경우에만 호출됩니다.\u003c/p\u003e\n\u003cp\u003e이는 제안된 연산자들이 부분적으로 채워진 계층적 데이터 구조의 탐색을 돕기 위한 것이지, 임의의 클래스 계층 구조의 탐색을 위한 것이 아니라는 전제 하에 보류되었습니다. 이는 이미 이 구문을 제공하는 다른 주류 언어 중 어느 것도 선택적 함수 호출에 대한 유사한 구문을 지원할 가치가 있다고 생각하지 않는다는 사실에 반영됩니다.\u003c/p\u003e\n\u003cp\u003eC#에서 사용되는 것과 유사한 해결 방법은 \u003ccode\u003emaybe_none?.__call__(arguments)\u003c/code\u003e를 작성하는 것입니다. 호출 가능 객체가 \u003ccode\u003eNone\u003c/code\u003e이면 표현식은 평가되지 않습니다. (C#의 해당 기능은 호출 가능 타입에서 \u003ccode\u003e?.Invoke()\u003c/code\u003e를 사용합니다.)\u003c/p\u003e\n\u003ch3\u003e단항 후위 연산자 (\u003ccode\u003e?\u003c/code\u003e Unary Postfix Operator)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eNone\u003c/code\u003e-인식 동작을 일반화하고 도입되는 새 연산자의 수를 제한하기 위해 \u003ccode\u003e?\u003c/code\u003e로 표기되는 단항 후위 연산자가 제안되었습니다. 이 아이디어는 \u003ccode\u003e?\u003c/code\u003e가 \u003ccode\u003eself\u003c/code\u003e를 반환하는 dunder 메서드를 오버라이드할 수 있는 특별한 객체를 반환할 수 있다는 것입니다. 예를 들어, \u003ccode\u003efoo?\u003c/code\u003e는 \u003ccode\u003efoo\u003c/code\u003e가 \u003ccode\u003eNone\u003c/code\u003e이 아니면 \u003ccode\u003efoo\u003c/code\u003e로 평가되고, 그렇지 않으면 \u003ccode\u003eNoneQuestion\u003c/code\u003e의 인스턴스로 평가됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass NoneQuestion():\r\n    def __call__(self, *args, **kwargs):\r\n        return self\r\n    def __getattr__(self, name):\r\n        return self\r\n    def __getitem__(self, key):\r\n        return self\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 새로운 연산자와 새로운 타입으로, \u003ccode\u003efoo?.bar[baz]\u003c/code\u003e와 같은 표현식은 \u003ccode\u003efoo\u003c/code\u003e가 \u003ccode\u003eNone\u003c/code\u003e이면 \u003ccode\u003eNoneQuestion\u003c/code\u003e으로 평가됩니다. 이것은 훌륭한 일반화이지만, 대부분의 기존 코드가 \u003ccode\u003eNoneQuestion\u003c/code\u003e이 무엇인지 알지 못하므로 실제로 사용하기 어렵습니다.\u003c/p\u003e\n\u003cp\u003e위에서 언급된 동기 부여 예시 중 하나로 돌아가서 다음을 고려해 보십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e import json\r\n\u003e\u003e\u003e created = None\r\n\u003e\u003e\u003e json.dumps({'created': created?.isoformat()})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJSON 직렬 변환기는 \u003ccode\u003eNoneQuestion\u003c/code\u003e을 직렬화하는 방법을 알지 못하며, 다른 API도 마찬가지입니다. 이 제안은 실제로 표준 라이브러리 및 모든 서드 파티 라이브러리 전반에 걸쳐 많은 특수 로직을 요구합니다.\u003c/p\u003e\n\u003cp\u003e동시에, \u003ccode\u003e?\u003c/code\u003e 연산자는 다른 어떤 연산자와도 결합될 수 있다는 점에서 너무 일반적일 수도 있습니다. 다음 표현식들은 무엇을 의미해야 할까요?:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e x? + 1\r\n\u003e\u003e\u003e x? -= 1\r\n\u003e\u003e\u003e x? == 1\r\n\u003e\u003e\u003e ~x?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 일반화의 정도는 유용하지 않습니다. 여기서 실제로 제안된 연산자들은 일반적인 코드 패턴을 더 쉽게 작성할 것으로 예상되는 몇 가지 연산자로 의도적으로 제한됩니다.\u003c/p\u003e\n\u003ch3\u003e내장 \u003ccode\u003emaybe\u003c/code\u003e (Built-in \u003ccode\u003emaybe\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003eHaskell에는 \u003ccode\u003eMaybe\u003c/code\u003e라는 개념이 있으며, 이는 특별한 키워드(\u003ccode\u003enull\u003c/code\u003e 등)나 특별한 인스턴스(\u003ccode\u003eNone\u003c/code\u003e 등)에 의존하지 않고 선택적 값의 아이디어를 캡슐화합니다. Haskell에서 \u003ccode\u003eMaybe\u003c/code\u003e의 목적은 \"무언가(something)\"와 \"아무것도 아님(nothing)\"을 별도로 처리하는 것을 피하는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epymaybe\u003c/code\u003e라는 Python 패키지는 대략적인 근사치를 제공합니다. 문서는 다음 예시를 보여줍니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e maybe('VALUE').lower()\r\n'value'\r\n\u003e\u003e\u003e maybe(None).invalid().method().or_else('unknown')\r\n'unknown'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003emaybe()\u003c/code\u003e 함수는 \u003ccode\u003eSomething\u003c/code\u003e 인스턴스 또는 \u003ccode\u003eNothing\u003c/code\u003e 인스턴스를 반환합니다. 이전 섹션에서 설명한 단항 후위 연산자와 유사하게, \u003ccode\u003eNothing\u003c/code\u003e은 누락된 값에 대한 체이닝을 허용하기 위해 dunder 메서드를 오버라이드합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eor_else()\u003c/code\u003e는 \u003ccode\u003epymaybe\u003c/code\u003e의 래퍼에서 기본 값을 검색하기 위해 결국 필요합니다. 또한, \u003ccode\u003epymaybe\u003c/code\u003e는 어떤 평가도 단락시키지 않습니다. \u003ccode\u003epymaybe\u003c/code\u003e가 몇 가지 강점을 가지고 있고 그 자체로 유용할 수 있지만, 이는 또한 코얼레싱의 순수 Python 구현이 언어에 내장된 지원만큼 강력하지 않은 이유를 보여줍니다.\u003c/p\u003e\n\u003cp\u003e이 시나리오를 가능하게 하기 위해 내장 \u003ccode\u003emaybe\u003c/code\u003e 타입을 추가하는 아이디어는 거부됩니다.\u003c/p\u003e\n\u003ch3\u003e단순 조건부 표현식 사용 (Just use a conditional expression)\u003c/h3\u003e\n\u003cp\u003e기본값을 초기화하는 또 다른 일반적인 방법은 삼항 연산자를 사용하는 것입니다. 인기 있는 \u003ccode\u003eRequests\u003c/code\u003e 패키지의 발췌문은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이전 (조건부 표현식 사용):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edata = [] if data is None else data\r\nfiles = [] if files is None else files\r\nheaders = {} if headers is None else headers\r\nparams = {} if params is None else params\r\nhooks = {} if hooks is None else hooks\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 특정 형식은 피연산자를 직관적이지 않은 순서로 배치하는 바람직하지 않은 효과를 가집니다. 즉, 뇌는 \"가능하면 \u003ccode\u003edata\u003c/code\u003e를 사용하고, 아니면 \u003ccode\u003e[]\u003c/code\u003e를 대체로 사용한다\"고 생각하지만, 코드는 대체 값을 선호하는 값 앞에 둡니다.\u003c/p\u003e\n\u003cp\u003e이 패키지의 작성자는 대신 다음과 같이 작성할 수 있었습니다:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이전 (더 직관적인 조건부 표현식):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edata = data if data is not None else []\r\nfiles = files if files is not None else []\r\nheaders = headers if headers is not None else {}\r\nparams = params if params is not None else {}\r\nhooks = hooks if hooks is not None else {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 피연산자 순서는 더 직관적이지만, 4개의 추가 문자(\"\u003ccode\u003enot\u003c/code\u003e\")가 필요합니다. 또한 식별자의 반복을 강조합니다: \u003ccode\u003edata if data\u003c/code\u003e, \u003ccode\u003efiles if files\u003c/code\u003e 등.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eNone\u003c/code\u003e 코얼레싱 연산자를 사용하여 작성하면 예시는 다음과 같이 읽힙니다:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이후 (\u003ccode\u003eNone\u003c/code\u003e 코얼레싱 연산자 사용):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edata = data ?? []\r\nfiles = files ?? []\r\nheaders = headers ?? {}\r\nparams = params ?? {}\r\nhooks = hooks ?? {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 구문은 피연산자의 직관적인 순서를 가집니다. \u003ccode\u003efind_content_type\u003c/code\u003e에서와 같이 선호하는 값이 대체 값보다 먼저 나타납니다. 구문의 간결성은 코드 줄 수를 줄이고 시각적으로 분석할 코드를 줄이며, 왼쪽에서 오른쪽, 위에서 아래로 읽는 것이 실행 흐름을 더 정확하게 따르게 합니다.\u003c/p\u003e\n\u003ch2\u003e참고 자료 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eC# Reference: Operators.\u003c/li\u003e\n\u003cli\u003eA Tour of the Dart Language: Operators.\u003c/li\u003e\n\u003cli\u003eProposal: Nullish Coalescing for JavaScript.\u003c/li\u003e\n\u003cli\u003eProposal: Optional Chaining for JavaScript.\u003c/li\u003e\n\u003cli\u003eAssociated scripts.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e소스:\u003c/strong\u003e \u003ccode\u003ehttps://github.com/python/peps/blob/main/peps/pep-0505.rst\u003c/code\u003e\r\n\u003cstrong\u003e마지막 수정:\u003c/strong\u003e 2025-02-01 08:55:40 GMT\r\n이 구문은 피연산자의 직관적인 순서를 가집니다. \u003ccode\u003efind_content_type\u003c/code\u003e에서와 같이 선호하는 값이 대체 값보다 먼저 나타납니다. 구문의 간결성은 코드 줄 수를 줄이고 시각적으로 분석할 코드를 줄이며, 왼쪽에서 오른쪽, 위에서 아래로 읽는 것이 실행 흐름을 더 정확하게 따르게 합니다.\u003c/p\u003e\n\u003ch2\u003e참고 자료 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eC# Reference: Operators.\u003c/li\u003e\n\u003cli\u003eA Tour of the Dart Language: Operators.\u003c/li\u003e\n\u003cli\u003eProposal: Nullish Coalescing for JavaScript.\u003c/li\u003e\n\u003cli\u003eProposal: Optional Chaining for JavaScript.\u003c/li\u003e\n\u003cli\u003eAssociated scripts.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e소스:\u003c/strong\u003e \u003ccode\u003ehttps://github.com/python/peps/blob/main/peps/pep-0505.rst\u003c/code\u003e\r\n\u003cstrong\u003e마지막 수정:\u003c/strong\u003e 2025-02-01 08:55:40 GMT\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Deferred] PEP 505 - None-aware operators\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:52:11+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>