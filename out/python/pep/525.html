<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ddc331716d5e47a2.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-0395f68b8cc78a20.js" async=""></script><script src="/_next/static/chunks/23-7d3f7f0b78aa2fd3.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-467e37449c5a68fc.js" async=""></script><script src="/_next/static/chunks/app/layout-b0a450f8e4964582.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-1f60377561abdb46.js" async=""></script><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY" as="script"/><title>[Final] PEP 525 - Asynchronous Generators - secrett2633&#x27;s blog</title><meta name="description" content="Python Enhancement Proposal 525: &#x27;Asynchronous Generators&#x27;에 대한 한국어 번역입니다."/><meta name="author" content="secrett2633"/><link rel="manifest" href="/manifest.json" crossorigin="use-credentials"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/python/pep/525"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="[Final] PEP 525 - Asynchronous Generators"/><meta property="og:description" content="Python Enhancement Proposal 525: &#x27;Asynchronous Generators&#x27;에 대한 한국어 번역입니다."/><meta property="og:url" content="https://blog.secrett2633.cloud/python/pep/525"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2025-09-26T14:17:46.000Z"/><meta property="article:modified_time" content="2025-09-26T14:17:46.000Z"/><meta property="article:author" content="secrett2633"/><meta property="article:section" content="Python"/><meta property="article:tag" content="Python"/><meta property="article:tag" content="PEP"/><meta property="article:tag" content="Translation"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:creator" content="@secrett2633"/><meta name="twitter:title" content="[Final] PEP 525 - Asynchronous Generators"/><meta name="twitter:description" content="Python Enhancement Proposal 525: &#x27;Asynchronous Generators&#x27;에 대한 한국어 번역입니다."/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><link rel="dns-prefetch" href="https://www.googletagmanager.com"/><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"/><link rel="dns-prefetch" href="https://giscus.app"/><link rel="preconnect" href="https://giscus.app" crossorigin="anonymous"/><meta http-equiv="X-Content-Type-Options" content="nosniff"/><meta name="referrer" content="strict-origin-when-cross-origin"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"WebSite","name":"secrett2633's blog","url":"https://blog.secrett2633.cloud","description":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트","inLanguage":"ko","publisher":{"@type":"Person","name":"secrett2633","url":"https://blog.secrett2633.cloud"}}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"Person","name":"secrett2633","url":"https://blog.secrett2633.cloud","sameAs":["https://github.com/secrett2633"]}</script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><a href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:z-50 focus:p-4 focus:bg-white focus:text-blue-600">본문으로 건너뛰기</a><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav" aria-label="메인 네비게이션"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button" aria-label="검색"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main id="main-content" class="initial-content"><!--$--><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Final] PEP 525 - Asynchronous Generators","description":"Python Enhancement Proposal 525: 'Asynchronous Generators'에 대한 한국어 번역입니다.","url":"https://blog.secrett2633.cloud/python/pep/525","datePublished":"2025-09-26T14:17:46.000Z","dateModified":"2025-09-26T14:17:46.000Z","author":{"@type":"Person","name":"secrett2633","url":"https://blog.secrett2633.cloud"},"publisher":{"@type":"Person","name":"secrett2633","url":"https://blog.secrett2633.cloud"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.secrett2633.cloud/python/pep/525"},"image":"https://blog.secrett2633.cloud/og-default.png","isAccessibleForFree":true,"inLanguage":"ko","wordCount":1905,"articleSection":"Python","keywords":"Python, PEP, Translation"}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"홈","item":"https://blog.secrett2633.cloud/"},{"@type":"ListItem","position":2,"name":"[Final] PEP 525 - Asynchronous Generators","item":"https://blog.secrett2633.cloud/python/pep/525"}]}</script><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4" aria-label="카테고리 네비게이션"><div><p class="font-medium text-gray-900 mb-2">Backend</p><ul class="space-y-1 ml-4"><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/backend/django">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/backend/logging">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><p class="font-medium text-gray-900 mb-2">Python</p><ul class="space-y-1 ml-4"><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/python/pep">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><p class="font-medium text-gray-900 mb-2">AI/ML</p><ul class="space-y-1 ml-4"><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/ai/llm">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/ai/review">Review<!-- --> (<!-- -->2728<!-- -->)</a></li></ul></div><div><p class="font-medium text-gray-900 mb-2">DevOps</p><ul class="space-y-1 ml-4"><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/nginx">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/docker">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/safeline">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/jenkins">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/github-actions">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/aws">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><p class="font-medium text-gray-900 mb-2">etc</p><ul class="space-y-1 ml-4"><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/etc/me">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/etc/chrome-extension">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><div class="flex-1"><nav aria-label="breadcrumb" class="text-sm text-gray-500 mb-4"><ol class="flex flex-wrap items-center gap-1"><li><a class="hover:text-gray-700" href="/">홈</a></li><li class="flex items-center gap-1"><span aria-hidden="true">/</span><span class="text-gray-900" aria-current="page">[Final] PEP 525 - Asynchronous Generators</span></li></ol></nav><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 525 - Asynchronous Generators</h1><div class="page__meta"><time dateTime="2025-09-26 23:17:46+0900">2025년 9월 26일</time><time class="ml-4" dateTime="2025-09-26T14:17:46.000Z">수정: <!-- -->2025년 9월 26일</time></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0525/" target="_blank" rel="noopener noreferrer">PEP 525 - Asynchronous Generators</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 28-Jul-2016</p>
</blockquote>
<h2 id="pep-525-비동기-제너레이터-asynchronous-generators"><a href="#pep-525-비동기-제너레이터-asynchronous-generators">PEP 525 – 비동기 제너레이터 (Asynchronous Generators)</a></h2>
<h3 id="개요-abstract"><a href="#개요-abstract">개요 (Abstract)</a></h3>
<p>PEP 492는 Python 3.5에 네이티브 코루틴(native coroutines)과 <code>async</code>/<code>await</code> 문법에 대한 지원을 도입했습니다. 이 PEP 525는 비동기 제너레이터(asynchronous generators) 지원을 추가하여 Python의 비동기 기능을 확장할 것을 제안합니다.</p>
<h3 id="배경-및-목표-rationale-and-goals"><a href="#배경-및-목표-rationale-and-goals">배경 및 목표 (Rationale and Goals)</a></h3>
<p>PEP 255에서 도입된 일반 제너레이터(regular generators)는 복잡한 데이터 생산자를 우아하게 작성하고 이를 이터레이터(iterator)처럼 동작하게 하는 방법을 제공했습니다.</p>
<p>하지만 현재 비동기 이터레이션 프로토콜(<code>async for</code>)에는 이와 동등한 개념이 없습니다. 이로 인해 비동기 데이터 생산자를 작성하는 것이 불필요하게 복잡해지는데, <code>async for</code> 문에서 사용하려면 <code>__aiter__</code>와 <code>__anext__</code>를 구현하는 클래스를 정의해야 하기 때문입니다.</p>
<p>본 제안에 PEP 255의 목표와 배경을 비동기 실행 사례에 적용하면 그대로 유효합니다.</p>
<p>성능은 이 제안의 추가적인 강점입니다. 참조 구현(reference implementation) 테스트 결과, 비동기 제너레이터는 비동기 이터레이터(asynchronous iterator)로 구현된 동일한 기능보다 2배 더 빠릅니다.</p>
<p>코드 품질 개선의 예시로, 다음은 주어진 딜레이(delay)로 숫자를 출력하는 클래스입니다.</p>
<pre><code class="language-python">class Ticker:
    """Yield numbers from 0 to `to` every `delay` seconds."""
    def __init__(self, delay, to):
        self.delay = delay
        self.i = 0
        self.to = to

    def __aiter__(self):
        return self

    async def __anext__(self):
        i = self.i
        if i >= self.to:
            raise StopAsyncIteration
        self.i += 1
        if i:
            await asyncio.sleep(self.delay)
        return i
</code></pre>
<p>동일한 기능을 훨씬 간단한 비동기 제너레이터로 구현할 수 있습니다.</p>
<pre><code class="language-python">async def ticker(delay, to):
    """Yield numbers from 0 to `to` every `delay` seconds."""
    for i in range(to):
        yield i
        await asyncio.sleep(delay)
</code></pre>
<h3 id="사양-specification"><a href="#사양-specification">사양 (Specification)</a></h3>
<p>이 제안은 Python에 비동기 제너레이터 개념을 도입합니다.
이 사양은 Python의 제너레이터와 코루틴(PEP 342, PEP 380, PEP 492) 구현에 대한 지식을 전제로 합니다.</p>
<h4 id="비동기-제너레이터-asynchronous-generators"><a href="#비동기-제너레이터-asynchronous-generators">비동기 제너레이터 (Asynchronous Generators)</a></h4>
<p>Python 제너레이터는 하나 이상의 <code>yield</code> 표현식을 포함하는 모든 함수입니다.</p>
<pre><code class="language-python">def func(): # 일반 함수
    return

def genfunc(): # 제너레이터 함수
    yield
</code></pre>
<p>비동기 제너레이터를 정의하기 위해 동일한 접근 방식을 사용할 것을 제안합니다.</p>
<pre><code class="language-python">async def coro(): # 코루틴 함수
    await smth()

async def asyncgen(): # 비동기 제너레이터 함수
    await smth()
    yield 42
</code></pre>
<p>비동기 제너레이터 함수를 호출한 결과는 PEP 492에 정의된 비동기 이터레이션 프로토콜(asynchronous iteration protocol)을 구현하는 비동기 제너레이터 객체입니다.</p>
<p>비동기 제너레이터에 비어있지 않은 <code>return</code> 문이 있는 경우 <code>SyntaxError</code>가 발생합니다.</p>
<h4 id="비동기-이터레이션-프로토콜-지원-support-for-asynchronous-iteration-protocol"><a href="#비동기-이터레이션-프로토콜-지원-support-for-asynchronous-iteration-protocol">비동기 이터레이션 프로토콜 지원 (Support for Asynchronous Iteration Protocol)</a></h4>
<p>이 프로토콜은 두 가지 특별한 메서드를 구현해야 합니다.</p>
<ul>
<li>비동기 이터레이터(asynchronous iterator)를 반환하는 <code>__aiter__</code> 메서드.</li>
<li>값을 "yield"하기 위해 <code>StopIteration</code> 예외를 사용하고, 이터레이션의 끝을 알리기 위해 <code>StopAsyncIteration</code> 예외를 사용하는 <code>awaitable</code> 객체를 반환하는 <code>__anext__</code> 메서드.</li>
</ul>
<p>비동기 제너레이터는 이 두 메서드를 모두 정의합니다. 간단한 비동기 제너레이터를 수동으로 이터레이션해봅시다.</p>
<pre><code class="language-python">async def genfunc():
    yield 1
    yield 2

gen = genfunc()
assert gen.__aiter__() is gen
assert await gen.__anext__() == 1
assert await gen.__anext__() == 2
await gen.__anext__() # 이 줄은 StopAsyncIteration을 발생시킵니다.
</code></pre>
<h4 id="종료-finalization"><a href="#종료-finalization">종료 (Finalization)</a></h4>
<p>PEP 492는 코루틴을 실행하기 위해 이벤트 루프(event loop) 또는 스케줄러(scheduler)를 필요로 합니다. 비동기 제너레이터는 코루틴에서 사용하도록 설계되었으므로, 실행 및 종료(finalize)하기 위해서도 이벤트 루프가 필요합니다.</p>
<p>비동기 제너레이터는 <code>try..finally</code> 블록과 <code>async with</code>를 가질 수 있습니다. 부분적으로만 이터레이션되고 가비지 컬렉션(garbage collected) 되더라도 제너레이터가 안전하게 종료될 수 있도록 보장하는 것이 중요합니다. 예를 들어:</p>
<pre><code class="language-python">async def square_series(con, to):
    async with con.transaction():
        cursor = con.cursor(
            'SELECT generate_series(0, $1) AS i', to)
        async for row in cursor:
            yield row['i'] ** 2

async for i in square_series(con, 1000):
    if i == 100:
        break
</code></pre>
<p>위 코드는 <code>async with</code>를 사용하여 트랜잭션(transaction) 내에서 데이터베이스 커서(cursor)를 이터레이션하는 비동기 제너레이터를 정의합니다. 이 제너레이터는 <code>async for</code>를 통해 이터레이션되며, 특정 시점에서 이터레이션이 중단됩니다.</p>
<p><code>square_series()</code> 제너레이터는 가비지 컬렉션될 것이며, 제너레이터를 비동기적으로 닫는 메커니즘이 없으면 Python 인터프리터는 아무것도 할 수 없습니다.</p>
<p>이 문제를 해결하기 위해 다음을 제안합니다.</p>
<ul>
<li>
<p>비동기 제너레이터에 특별한 <code>awaitable</code>을 반환하는 <code>aclose</code> 메서드를 구현합니다. 이 메서드를 <code>await</code>하면 정지된 제너레이터에 <code>GeneratorExit</code> 예외를 발생시키고, <code>GeneratorExit</code> 또는 <code>StopAsyncIteration</code>이 발생할 때까지 이터레이션합니다.
이는 일반 Python 제너레이터에 <code>close()</code> 메서드가 하는 일과 매우 유사하지만, <code>aclose()</code>를 실행하려면 이벤트 루프가 필요하다는 점이 다릅니다.</p>
</li>
<li>
<p>비동기 제너레이터가 <code>finally</code> 블록에서 <code>yield</code> 표현식을 실행할 때 <code>RuntimeError</code>를 발생시킵니다 (그러나 <code>await</code>를 사용하는 것은 괜찮습니다).</p>
<pre><code class="language-python">async def gen():
    try:
        yield
    finally:
        await asyncio.sleep(1) # 'await' 사용 가능.
        yield # 'yield' 사용 불가,
              # 이 줄은 RuntimeError를 발생시킵니다.
</code></pre>
</li>
<li>
<p><code>sys</code> 모듈에 <code>set_asyncgen_hooks()</code> 및 <code>get_asyncgen_hooks()</code> 두 가지 새로운 메서드를 추가합니다.</p>
<p><code>sys.set_asyncgen_hooks()</code>의 아이디어는 이벤트 루프가 비동기 제너레이터의 이터레이션 및 종료를 가로챌 수 있도록 하여, 최종 사용자가 종료 문제에 신경 쓸 필요 없이 모든 것이 작동하도록 하는 것입니다.</p>
<p><code>sys.set_asyncgen_hooks()</code>는 두 가지 인수를 허용합니다.</p>
<ul>
<li><code>firstiter</code>: 비동기 제너레이터가 처음 이터레이션될 때 호출될 호출 가능 객체(callable).</li>
<li><code>finalizer</code>: 비동기 제너레이터가 가비지 컬렉션되기 직전에 호출될 호출 가능 객체.</li>
</ul>
<p>비동기 제너레이터가 처음 이터레이션될 때, 현재 <code>finalizer</code>에 대한 참조를 저장합니다.
비동기 제너레이터가 가비지 컬렉션되기 직전에 캐시된 <code>finalizer</code>를 호출합니다. <code>finalizer</code>는 이터레이션이 시작될 때 활성화된 루프와 함께 <code>aclose()</code> 호출을 스케줄링할 것이라고 가정합니다.</p>
<p>예를 들어, <code>asyncio</code>가 비동기 제너레이터의 안전한 종료를 허용하도록 수정되는 방법은 다음과 같습니다.</p>
<pre><code class="language-python"># asyncio/base_events.py
class BaseEventLoop:
    def run_forever(self):
        ...
        old_hooks = sys.get_asyncgen_hooks()
        sys.set_asyncgen_hooks(finalizer=self._finalize_asyncgen)
        try:
            ...
        finally:
            sys.set_asyncgen_hooks(*old_hooks)
        ...

    def _finalize_asyncgen(self, gen):
        self.create_task(gen.aclose())
</code></pre>
<p>두 번째 인수 <code>firstiter</code>는 이벤트 루프가 자체 제어하에 인스턴스화된 비동기 제너레이터의 약한 집합(weak set)을 유지 관리할 수 있도록 합니다. 이를 통해 모든 열려있는 제너레이터를 안전하게 종료하고 이벤트 루프를 닫는 "종료(shutdown)" 메커니즘을 구현할 수 있습니다.</p>
<p><code>sys.set_asyncgen_hooks()</code>는 스레드별(thread-specific)이므로, 여러 이벤트 루프가 병렬 스레드에서 안전하게 사용할 수 있습니다.</p>
<p><code>sys.get_asyncgen_hooks()</code>는 <code>firstiter</code> 및 <code>finalizer</code> 필드를 가진 namedtuple과 유사한 구조를 반환합니다.</p>
</li>
</ul>
<h4 id="asyncio"><a href="#asyncio"><code>asyncio</code></a></h4>
<p><code>asyncio</code> 이벤트 루프는 <code>sys.set_asyncgen_hooks()</code> API를 사용하여 스케줄링된 모든 비동기 제너레이터의 약한 집합을 유지하고, 제너레이터가 가비지 컬렉션될 시점에 <code>aclose()</code> 코루틴 메서드를 스케줄링합니다.</p>
<p><code>asyncio</code> 프로그램이 스케줄링된 모든 비동기 제너레이터를 안정적으로 종료할 수 있도록 하기 위해, 새로운 이벤트 루프 코루틴 메서드 <code>loop.shutdown_asyncgens()</code>를 추가할 것을 제안합니다. 이 메서드는 현재 열려있는 모든 비동기 제너레이터를 <code>aclose()</code> 호출로 닫도록 스케줄링합니다.</p>
<p><code>loop.shutdown_asyncgens()</code> 메서드를 호출한 후, 이벤트 루프는 새로운 비동기 제너레이터가 처음 이터레이션될 때마다 경고를 발생시킬 것입니다. 이는 모든 비동기 제너레이터를 종료하도록 요청한 후에는 프로그램이 새로운 비동기 제너레이터를 이터레이션하는 코드를 실행해서는 안 된다는 아이디어입니다.</p>
<p><code>shutdown_asyncgens</code> 코루틴을 사용하는 예시입니다.</p>
<pre><code class="language-python">try:
    loop.run_forever()
finally:
    loop.run_until_complete(loop.shutdown_asyncgens())
    loop.close()
</code></pre>
<h4 id="비동기-제너레이터-객체-asynchronous-generator-object"><a href="#비동기-제너레이터-객체-asynchronous-generator-object">비동기 제너레이터 객체 (Asynchronous Generator Object)</a></h4>
<p>이 객체는 표준 Python 제너레이터 객체를 모델로 합니다. 본질적으로 비동기 제너레이터의 동작은 동기 제너레이터의 동작을 복제하도록 설계되었으며, 유일한 차이점은 API가 비동기라는 점입니다.</p>
<p>다음 메서드와 속성이 정의됩니다.</p>
<ul>
<li>
<p><code>agen.__aiter__()</code>: <code>agen</code>을 반환합니다.</p>
</li>
<li>
<p><code>agen.__anext__()</code>: <code>await</code>될 때 하나의 비동기 제너레이터 이터레이션을 수행하는 <code>awaitable</code>을 반환합니다.</p>
</li>
<li>
<p><code>agen.asend(val)</code>: <code>val</code> 객체를 <code>agen</code> 제너레이터로 푸시하는 <code>awaitable</code>을 반환합니다. <code>agen</code>이 아직 이터레이션되지 않은 경우, <code>val</code>은 <code>None</code>이어야 합니다.</p>
<p>예시:</p>
<pre><code class="language-python">async def gen():
    await asyncio.sleep(0.1)
    v = yield 42
    print(v)
    await asyncio.sleep(0.2)

g = gen()
await g.asend(None) # 0.1초 동안 sleep 후 42를 반환합니다.
await g.asend('hello') # 'hello'를 출력하고
                       # StopAsyncIteration을 발생시킵니다.
                       # (0.2초 동안 sleep 후)
</code></pre>
</li>
<li>
<p><code>agen.athrow(typ, [val, [tb]])</code>: 예외를 <code>agen</code> 제너레이터로 던지는 <code>awaitable</code>을 반환합니다.</p>
<p>예시:</p>
<pre><code class="language-python">async def gen():
    try:
        await asyncio.sleep(0.1)
        yield 'hello'
    except ZeroDivisionError:
        await asyncio.sleep(0.2)
        yield 'world'

g = gen()
v = await g.asend(None)
print(v) # 0.1초 동안 sleep 후 'hello'를 출력합니다.
v = await g.athrow(ZeroDivisionError)
print(v) # 0.2초 동안 sleep 후 'world'를 출력합니다.
</code></pre>
</li>
<li>
<p><code>agen.aclose()</code>: <code>GeneratorExit</code> 예외를 제너레이터로 던지는 <code>awaitable</code>을 반환합니다. <code>awaitable</code>은 <code>agen</code>이 예외를 처리했다면 <code>yield</code>된 값을 반환할 수 있고, 그렇지 않으면 <code>agen</code>이 닫히고 예외는 호출자(caller)에게 다시 전파됩니다.</p>
</li>
<li>
<p><code>agen.__name__</code> 및 <code>agen.__qualname__</code>: 읽고 쓸 수 있는 이름 및 정규화된 이름(qualified name) 속성입니다.</p>
</li>
<li>
<p><code>agen.ag_await</code>: <code>agen</code>이 현재 <code>await</code>하고 있는 객체 또는 <code>None</code>입니다. 이는 제너레이터의 <code>gi_yieldfrom</code> 및 코루틴의 <code>cr_await</code>와 유사합니다.</p>
</li>
<li>
<p><code>agen.ag_frame</code>, <code>agen.ag_running</code>, <code>agen.ag_code</code>: 표준 제너레이터의 유사한 속성과 동일한 방식으로 정의됩니다.</p>
</li>
</ul>
<p><code>StopIteration</code>과 <code>StopAsyncIteration</code>은 비동기 제너레이터 밖으로 전파되지 않으며, <code>RuntimeError</code>로 대체됩니다.</p>
<h4 id="구현-세부-정보-implementation-details"><a href="#구현-세부-정보-implementation-details">구현 세부 정보 (Implementation Details)</a></h4>
<p>비동기 제너레이터 객체(<code>PyAsyncGenObject</code>)는 <code>PyGenObject</code>와 구조 레이아웃을 공유합니다. 또한, 참조 구현은 세 가지 새로운 객체를 도입합니다.</p>
<ul>
<li><code>PyAsyncGenASend</code>: <code>__anext__</code> 및 <code>asend()</code> 메서드를 구현하는 <code>awaitable</code> 객체입니다.</li>
<li><code>PyAsyncGenAThrow</code>: <code>athrow()</code> 및 <code>aclose()</code> 메서드를 구현하는 <code>awaitable</code> 객체입니다.</li>
<li><code>_PyAsyncGenWrappedValue</code>: 비동기 제너레이터에서 직접 <code>yield</code>된 모든 객체는 암시적으로 이 구조로 묶입니다. 이를 통해 제너레이터 구현은 일반 이터레이션 프로토콜을 사용하여 <code>yield</code>된 객체와 비동기 이터레이션 프로토콜을 사용하여 <code>yield</code>된 객체를 분리할 수 있습니다.</li>
</ul>
<p><code>PyAsyncGenASend</code>와 <code>PyAsyncGenAThrow</code>는 <code>awaitable</code> 객체이며(<code>__await__</code> 메서드가 <code>self</code>를 반환함), 코루틴과 유사한 객체입니다(<code>__iter__</code>, <code>__next__</code>, <code>send()</code>, <code>throw()</code> 메서드를 구현함). 본질적으로 이들은 비동기 제너레이터가 어떻게 이터레이션되는지를 제어합니다.</p>
<h5 id="pyasyncgenasend-및-pyasyncgenathrow"><a href="#pyasyncgenasend-및-pyasyncgenathrow"><code>PyAsyncGenASend</code> 및 <code>PyAsyncGenAThrow</code></a></h5>
<p><code>PyAsyncGenASend</code>는 <code>__anext__</code> 및 <code>asend()</code> 메서드를 구동하고 비동기 이터레이션 프로토콜을 구현하는 코루틴과 유사한 객체입니다.
<code>agen.asend(val)</code> 및 <code>agen.__anext__()</code>는 <code>PyAsyncGenASend</code> 인스턴스(부모 <code>agen</code> 객체에 대한 참조를 유지)를 반환합니다.</p>
<p>데이터 흐름은 다음과 같이 정의됩니다.</p>
<ul>
<li><code>PyAsyncGenASend.send(val)</code>이 처음 호출되면, <code>val</code>은 부모 <code>agen</code> 객체로 푸시됩니다(<code>PyGenObject</code>의 기존 기능을 사용).</li>
<li><code>PyAsyncGenASend</code> 객체에 대한 후속 이터레이션은 <code>None</code>을 <code>agen</code>으로 푸시합니다.</li>
<li><code>_PyAsyncGenWrappedValue</code> 객체가 <code>yield</code>되면, 언박싱(unboxed)되고, 래핑되지 않은(unwrapped) 값을 인수로 하는 <code>StopIteration</code> 예외가 발생합니다.</li>
<li><code>PyAsyncGenASend.throw(*exc)</code>가 처음 호출되면, <code>*exc</code>가 부모 <code>agen</code> 객체로 던져집니다.</li>
<li><code>PyAsyncGenASend</code> 객체에 대한 후속 이터레이션은 <code>None</code>을 <code>agen</code>으로 푸시합니다.</li>
<li><code>_PyAsyncGenWrappedValue</code> 객체가 <code>yield</code>되면, 언박싱되고, 래핑되지 않은 값을 인수로 하는 <code>StopIteration</code> 예외가 발생합니다.</li>
<li>비동기 제너레이터의 <code>return</code> 문은 <code>StopAsyncIteration</code> 예외를 발생시키며, 이는 <code>PyAsyncGenASend.send()</code> 및 <code>PyAsyncGenASend.throw()</code> 메서드를 통해 전파됩니다.</li>
</ul>
<p><code>PyAsyncGenAThrow</code>는 <code>PyAsyncGenASend</code>와 매우 유사합니다. 유일한 차이점은 <code>PyAsyncGenAThrow.send()</code>가 처음 호출될 때 부모 <code>agen</code> 객체에 예외를 던진다는 것입니다(값을 푸시하는 대신).</p>
<h4 id="새로운-표준-라이브러리-함수-및-타입-new-standard-library-functions-and-types"><a href="#새로운-표준-라이브러리-함수-및-타입-new-standard-library-functions-and-types">새로운 표준 라이브러리 함수 및 타입 (New Standard Library Functions and Types)</a></h4>
<ul>
<li><code>types.AsyncGeneratorType</code> – 비동기 제너레이터 객체의 타입입니다.</li>
<li><code>sys.set_asyncgen_hooks()</code> 및 <code>sys.get_asyncgen_hooks()</code> 메서드는 이벤트 루프에서 비동기 제너레이터의 종료자(finalizers) 및 이터레이션 가로채기(interceptors)를 설정하는 데 사용됩니다.</li>
<li><code>inspect.isasyncgen()</code> 및 <code>inspect.isasyncgenfunction()</code> 인트로스펙션(introspection) 함수.</li>
<li><code>asyncio</code> 이벤트 루프의 새로운 메서드: <code>loop.shutdown_asyncgens()</code>.</li>
<li>새로운 <code>collections.abc.AsyncGenerator</code> 추상 기본 클래스(abstract base class).</li>
</ul>
<h4 id="하위-호환성-backwards-compatibility"><a href="#하위-호환성-backwards-compatibility">하위 호환성 (Backwards Compatibility)</a></h4>
<p>이 제안은 완벽하게 하위 호환됩니다.
Python 3.5에서는 <code>yield</code> 표현식이 포함된 <code>async def</code> 함수를 정의하는 것이 <code>SyntaxError</code>이므로, 3.6에서 비동기 제너레이터를 도입하는 것은 안전합니다.</p>
<h4 id="성능-performance"><a href="#성능-performance">성능 (Performance)</a></h4>
<h5 id="일반-제너레이터-regular-generators"><a href="#일반-제너레이터-regular-generators">일반 제너레이터 (Regular Generators)</a></h5>
<p>일반 제너레이터에는 성능 저하가 없습니다. 다음 마이크로 벤치마크는 CPython에서 비동기 제너레이터 유무에 관계없이 동일한 속도로 실행됩니다.</p>
<pre><code class="language-python">def gen():
    i = 0
    while i &#x3C; 100000000:
        yield i
        i += 1
list(gen())
</code></pre>
<h5 id="비동기-이터레이터-대비-개선점-improvements-over-asynchronous-iterators"><a href="#비동기-이터레이터-대비-개선점-improvements-over-asynchronous-iterators">비동기 이터레이터 대비 개선점 (Improvements over asynchronous iterators)</a></h5>
<p>다음 마이크로 벤치마크는 비동기 제너레이터가 순수 Python으로 구현된 비동기 이터레이터보다 약 2.3배 빠름을 보여줍니다.</p>
<pre><code class="language-python">N = 10 ** 7

async def agen():
    for i in range(N):
        yield i

class AIter:
    def __init__(self):
        self.i = 0
    def __aiter__(self):
        return self
    async def __anext__(self):
        i = self.i
        if i >= N:
            raise StopAsyncIteration
        self.i += 1
        return i
</code></pre>
<h3 id="설계-고려-사항-design-considerations"><a href="#설계-고려-사항-design-considerations">설계 고려 사항 (Design Considerations)</a></h3>
<h4 id="aiter-및-anext-내장-함수-aiter-and-anext-builtins"><a href="#aiter-및-anext-내장-함수-aiter-and-anext-builtins"><code>aiter()</code> 및 <code>anext()</code> 내장 함수 (aiter() and anext() builtins)</a></h4>
<p>원래 PEP 492는 <code>__aiter__</code>를 <code>awaitable</code> 객체를 반환해야 하는 메서드로 정의하여 비동기 이터레이터를 생성하도록 했습니다.
그러나 CPython 3.5.2에서 <code>__aiter__</code>는 비동기 이터레이터를 직접 반환하도록 재정의되었습니다. 하위 호환성을 깨는 것을 피하기 위해, Python 3.6에서는 두 가지 방식 모두를 지원하며, <code>__aiter__</code>가 여전히 <code>awaitable</code>을 반환할 수 있지만 <code>DeprecationWarning</code>이 발행되도록 결정되었습니다.</p>
<p>Python 3.6에서 <code>__aiter__</code>의 이러한 이중적인 특성 때문에 <code>aiter()</code> 내장 함수의 동기 구현을 추가할 수 없습니다. 따라서 Python 3.7까지 기다릴 것을 제안합니다.</p>
<h4 id="비동기-리스트딕셔너리세트-컴프리헨션-asynchronous-listdictset-comprehensions"><a href="#비동기-리스트딕셔너리세트-컴프리헨션-asynchronous-listdictset-comprehensions">비동기 리스트/딕셔너리/세트 컴프리헨션 (Asynchronous list/dict/set comprehensions)</a></h4>
<p>비동기 컴프리헨션(comprehensions)의 문법은 비동기 제너레이터 메커니즘과 관련이 없으며, 별도의 PEP에서 고려되어야 합니다.</p>
<h4 id="비동기-yield-from-asynchronous-yield-from"><a href="#비동기-yield-from-asynchronous-yield-from">비동기 <code>yield from</code> (Asynchronous yield from)</a></h4>
<p>비동기 제너레이터에 <code>yield from</code> 지원을 구현하는 것이 이론적으로 가능하지만, 제너레이터 구현을 심각하게 재설계해야 합니다.
<code>yield from</code>은 비동기 제너레이터에 덜 중요합니다. 코루틴 위에 다른 코루틴 프로토콜을 구현하는 메커니즘을 제공할 필요가 없기 때문입니다. 비동기 제너레이터를 구성하기 위해 간단한 <code>async for</code> 루프를 사용할 수 있습니다.</p>
<pre><code class="language-python">async def g1():
    yield 1
    yield 2

async def g2():
    async for v in g1():
        yield v
</code></pre>
<h4 id="asend-및-athrow-메서드가-필요한-이유-why-the-asend-and-athrow-methods-are-necessary"><a href="#asend-및-athrow-메서드가-필요한-이유-why-the-asend-and-athrow-methods-are-necessary"><code>asend()</code> 및 <code>athrow()</code> 메서드가 필요한 이유 (Why the asend() and athrow() methods are necessary)</a></h4>
<p>이 메서드들은 <code>contextlib.contextmanager</code>와 유사한 개념을 비동기 제너레이터를 사용하여 구현할 수 있게 합니다. 예를 들어, 제안된 설계로 다음 패턴을 구현할 수 있습니다.</p>
<pre><code class="language-python">@async_context_manager
async def ctx():
    await open()
    try:
        yield
    finally:
        await close()

async with ctx():
    await ...
</code></pre>
<p>또 다른 이유는 <code>__anext__</code> 객체에서 반환된 객체를 사용하여 비동기 제너레이터로 데이터를 푸시하고 예외를 던지는 것이 가능하지만, 이를 올바르게 수행하기는 어렵다는 것입니다. 명시적인 <code>asend()</code> 및 <code>athrow()</code>를 추가하면 이를 안전하게 수행할 수 있는 길을 열어줄 것입니다.</p>
<p>구현 측면에서 <code>asend()</code>는 <code>__anext__</code>의 약간 더 일반적인 버전이며, <code>athrow()</code>는 <code>aclose()</code>와 매우 유사합니다. 따라서 비동기 제너레이터에 이러한 메서드를 정의해도 추가적인 복잡성은 발생하지 않습니다.</p>
<h3 id="예시-example"><a href="#예시-example">예시 (Example)</a></h3>
<p>현재 참조 구현을 사용한 작동 예시 (0부터 9까지의 숫자를 1초 간격으로 출력합니다):</p>
<pre><code class="language-python">async def ticker(delay, to):
    for i in range(to):
        yield i
        await asyncio.sleep(delay)

async def run():
    async for i in ticker(1, 10):
        print(i)

import asyncio
loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(run())
finally:
    loop.close()
</code></pre>
<h3 id="승인-acceptance"><a href="#승인-acceptance">승인 (Acceptance)</a></h3>
<p>PEP 525는 2016년 9월 6일 Guido에 의해 승인되었습니다.</p>
<h3 id="구현-implementation"><a href="#구현-implementation">구현 (Implementation)</a></h3>
<p>구현은 이슈 28003에서 추적됩니다. 참조 구현 Git 저장소는에서 확인할 수 있습니다.</p>
<h3 id="참고-자료-references"><a href="#참고-자료-references">참고 자료 (References)</a></h3>
<p><a href="https://github.com/1st1/cpython/tree/async_gen" target="_blank" rel="noopener noreferrer">https://github.com/1st1/cpython/tree/async_gen</a>
<a href="https://mail.python.org/pipermail/python-dev/2016-September/146267.html" target="_blank" rel="noopener noreferrer">https://mail.python.org/pipermail/python-dev/2016-September/146267.html</a>
<a href="http://bugs.python.org/issue28003" target="_blank" rel="noopener noreferrer">http://bugs.python.org/issue28003</a></p>
<h3 id="감사-acknowledgments"><a href="#감사-acknowledgments">감사 (Acknowledgments)</a></h3>
<p>이 PEP에 대한 피드백, 코드 검토 및 토론에 대해 Guido van Rossum, Victor Stinner, Elvis Pranskevichus, Nathaniel Smith, Łukasz Langa, Andrew Svetlov 및 기타 여러 사람들에게 감사드립니다.</p>
<h3 id="저작권-copyright"><a href="#저작권-copyright">저작권 (Copyright)</a></h3>
<p>이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.</p>
<blockquote>
<p>⚠️ ** 알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><span class="text-sm font-medium text-gray-900 mb-2 block">태그</span><a class="page__taxonomy-item" href="/tags/Python">#<!-- -->Python</a><a class="page__taxonomy-item" href="/tags/PEP">#<!-- -->PEP</a><a class="page__taxonomy-item" href="/tags/Translation">#<!-- -->Translation</a></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/524">[Final] PEP 524 - Make os.urandom() blocking on Linux</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 525 - Asynchronous Generators</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/526">[Final] PEP 526 - Syntax for Variable Annotations</a></li></ul></section></article></div></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© <!-- -->2026<!-- --> secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/ddc331716d5e47a2.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-b0a450f8e4964582.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-1f60377561abdb46.js\"],\"\"]\nb:I[4080,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-b0a450f8e4964582.js\"],\"\"]\nd:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/525\",\"c\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ddc331716d5e47a2.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"WcxaIiCPz9cbpnkGvOjOK\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/525\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/525\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"525\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/525\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"link\",null,{\"rel\":\"dns-prefetch\",\"href\":\"https://www.googletagmanager.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://www.googletagmanager.com\",\"crossOrigin\":\"anonymous\"}],[\"$\",\"link\",null,{\"rel\":\"dns-prefetch\",\"href\":\"https://giscus.app\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://giscus.app\",\"crossOrigin\":\"anonymous\"}],[\"$\",\"meta\",null,{\"httpEquiv\":\"X-Content-Type-Options\",\"content\":\"nosniff\"}],[\"$\",\"meta\",null,{\"name\":\"referrer\",\"content\":\"strict-origin-when-cross-origin\"}],[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"WebSite\\\",\\\"name\\\":\\\"secrett2633's blog\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud\\\",\\\"description\\\":\\\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\\\",\\\"inLanguage\\\":\\\"ko\\\",\\\"publisher\\\":{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"secrett2633\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud\\\"}}\"}}],[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"secrett2633\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud\\\",\\\"sameAs\\\":[\\\"https://github.com/secrett2633\\\"]}\"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#main-content\",\"className\":\"sr-only focus:not-sr-only focus:absolute focus:z-50 focus:p-4 focus:bg-white focus:text-blue-600\",\"children\":\"본문으로 건너뛰기\"}],[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"id\":\"main-content\",\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":[\"© \",2026,\" secrett2633. All rights reserved.\"]}]}]}]}]]}],[\"$\",\"$Lb\",null,{\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\",\"strategy\":\"afterInteractive\"}],[\"$\",\"$Lb\",null,{\"id\":\"gtag-init\",\"strategy\":\"afterInteractive\",\"children\":\"window.dataLayer = window.dataLayer || [];\\n            function gtag(){dataLayer.push(arguments);}\\n            gtag('js', new Date());\\n            gtag('config', 'G-NE2W3CFPNY');\"}]]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"role\":\"status\",\"aria-label\":\"로딩 중\",\"children\":[[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}],[\"$\",\"span\",null,{\"className\":\"sr-only\",\"children\":\"로딩 중...\"}]]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]]\n"])</script><script>self.__next_f.push([1,"10:I[646,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-1f60377561abdb46.js\"],\"default\"]\nf:T6fcc,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0525/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ePEP 525 - Asynchronous Generators\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 28-Jul-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"pep-525-비동기-제너레이터-asynchronous-generators\"\u003e\u003ca href=\"#pep-525-비동기-제너레이터-asynchronous-generators\"\u003ePEP 525 – 비동기 제너레이터 (Asynchronous Generators)\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"개요-abstract\"\u003e\u003ca href=\"#개요-abstract\"\u003e개요 (Abstract)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003ePEP 492는 Python 3.5에 네이티브 코루틴(native coroutines)과 \u003ccode\u003easync\u003c/code\u003e/\u003ccode\u003eawait\u003c/code\u003e 문법에 대한 지원을 도입했습니다. 이 PEP 525는 비동기 제너레이터(asynchronous generators) 지원을 추가하여 Python의 비동기 기능을 확장할 것을 제안합니다.\u003c/p\u003e\n\u003ch3 id=\"배경-및-목표-rationale-and-goals\"\u003e\u003ca href=\"#배경-및-목표-rationale-and-goals\"\u003e배경 및 목표 (Rationale and Goals)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003ePEP 255에서 도입된 일반 제너레이터(regular generators)는 복잡한 데이터 생산자를 우아하게 작성하고 이를 이터레이터(iterator)처럼 동작하게 하는 방법을 제공했습니다.\u003c/p\u003e\n\u003cp\u003e하지만 현재 비동기 이터레이션 프로토콜(\u003ccode\u003easync for\u003c/code\u003e)에는 이와 동등한 개념이 없습니다. 이로 인해 비동기 데이터 생산자를 작성하는 것이 불필요하게 복잡해지는데, \u003ccode\u003easync for\u003c/code\u003e 문에서 사용하려면 \u003ccode\u003e__aiter__\u003c/code\u003e와 \u003ccode\u003e__anext__\u003c/code\u003e를 구현하는 클래스를 정의해야 하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e본 제안에 PEP 255의 목표와 배경을 비동기 실행 사례에 적용하면 그대로 유효합니다.\u003c/p\u003e\n\u003cp\u003e성능은 이 제안의 추가적인 강점입니다. 참조 구현(reference implementation) 테스트 결과, 비동기 제너레이터는 비동기 이터레이터(asynchronous iterator)로 구현된 동일한 기능보다 2배 더 빠릅니다.\u003c/p\u003e\n\u003cp\u003e코드 품질 개선의 예시로, 다음은 주어진 딜레이(delay)로 숫자를 출력하는 클래스입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Ticker:\n    \"\"\"Yield numbers from 0 to `to` every `delay` seconds.\"\"\"\n    def __init__(self, delay, to):\n        self.delay = delay\n        self.i = 0\n        self.to = to\n\n    def __aiter__(self):\n        return self\n\n    async def __anext__(self):\n        i = self.i\n        if i \u003e= self.to:\n            raise StopAsyncIteration\n        self.i += 1\n        if i:\n            await asyncio.sleep(self.delay)\n        return i\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e동일한 기능을 훨씬 간단한 비동기 제너레이터로 구현할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def ticker(delay, to):\n    \"\"\"Yield numbers from 0 to `to` every `delay` seconds.\"\"\"\n    for i in range(to):\n        yield i\n        await asyncio.sleep(delay)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"사양-specification\"\u003e\u003ca href=\"#사양-specification\"\u003e사양 (Specification)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e이 제안은 Python에 비동기 제너레이터 개념을 도입합니다.\n이 사양은 Python의 제너레이터와 코루틴(PEP 342, PEP 380, PEP 492) 구현에 대한 지식을 전제로 합니다.\u003c/p\u003e\n\u003ch4 id=\"비동기-제너레이터-asynchronous-generators\"\u003e\u003ca href=\"#비동기-제너레이터-asynchronous-generators\"\u003e비동기 제너레이터 (Asynchronous Generators)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003ePython 제너레이터는 하나 이상의 \u003ccode\u003eyield\u003c/code\u003e 표현식을 포함하는 모든 함수입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef func(): # 일반 함수\n    return\n\ndef genfunc(): # 제너레이터 함수\n    yield\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e비동기 제너레이터를 정의하기 위해 동일한 접근 방식을 사용할 것을 제안합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def coro(): # 코루틴 함수\n    await smth()\n\nasync def asyncgen(): # 비동기 제너레이터 함수\n    await smth()\n    yield 42\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e비동기 제너레이터 함수를 호출한 결과는 PEP 492에 정의된 비동기 이터레이션 프로토콜(asynchronous iteration protocol)을 구현하는 비동기 제너레이터 객체입니다.\u003c/p\u003e\n\u003cp\u003e비동기 제너레이터에 비어있지 않은 \u003ccode\u003ereturn\u003c/code\u003e 문이 있는 경우 \u003ccode\u003eSyntaxError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003ch4 id=\"비동기-이터레이션-프로토콜-지원-support-for-asynchronous-iteration-protocol\"\u003e\u003ca href=\"#비동기-이터레이션-프로토콜-지원-support-for-asynchronous-iteration-protocol\"\u003e비동기 이터레이션 프로토콜 지원 (Support for Asynchronous Iteration Protocol)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e이 프로토콜은 두 가지 특별한 메서드를 구현해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e비동기 이터레이터(asynchronous iterator)를 반환하는 \u003ccode\u003e__aiter__\u003c/code\u003e 메서드.\u003c/li\u003e\n\u003cli\u003e값을 \"yield\"하기 위해 \u003ccode\u003eStopIteration\u003c/code\u003e 예외를 사용하고, 이터레이션의 끝을 알리기 위해 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e 예외를 사용하는 \u003ccode\u003eawaitable\u003c/code\u003e 객체를 반환하는 \u003ccode\u003e__anext__\u003c/code\u003e 메서드.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e비동기 제너레이터는 이 두 메서드를 모두 정의합니다. 간단한 비동기 제너레이터를 수동으로 이터레이션해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def genfunc():\n    yield 1\n    yield 2\n\ngen = genfunc()\nassert gen.__aiter__() is gen\nassert await gen.__anext__() == 1\nassert await gen.__anext__() == 2\nawait gen.__anext__() # 이 줄은 StopAsyncIteration을 발생시킵니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"종료-finalization\"\u003e\u003ca href=\"#종료-finalization\"\u003e종료 (Finalization)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003ePEP 492는 코루틴을 실행하기 위해 이벤트 루프(event loop) 또는 스케줄러(scheduler)를 필요로 합니다. 비동기 제너레이터는 코루틴에서 사용하도록 설계되었으므로, 실행 및 종료(finalize)하기 위해서도 이벤트 루프가 필요합니다.\u003c/p\u003e\n\u003cp\u003e비동기 제너레이터는 \u003ccode\u003etry..finally\u003c/code\u003e 블록과 \u003ccode\u003easync with\u003c/code\u003e를 가질 수 있습니다. 부분적으로만 이터레이션되고 가비지 컬렉션(garbage collected) 되더라도 제너레이터가 안전하게 종료될 수 있도록 보장하는 것이 중요합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def square_series(con, to):\n    async with con.transaction():\n        cursor = con.cursor(\n            'SELECT generate_series(0, $1) AS i', to)\n        async for row in cursor:\n            yield row['i'] ** 2\n\nasync for i in square_series(con, 1000):\n    if i == 100:\n        break\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 \u003ccode\u003easync with\u003c/code\u003e를 사용하여 트랜잭션(transaction) 내에서 데이터베이스 커서(cursor)를 이터레이션하는 비동기 제너레이터를 정의합니다. 이 제너레이터는 \u003ccode\u003easync for\u003c/code\u003e를 통해 이터레이션되며, 특정 시점에서 이터레이션이 중단됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esquare_series()\u003c/code\u003e 제너레이터는 가비지 컬렉션될 것이며, 제너레이터를 비동기적으로 닫는 메커니즘이 없으면 Python 인터프리터는 아무것도 할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e이 문제를 해결하기 위해 다음을 제안합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e비동기 제너레이터에 특별한 \u003ccode\u003eawaitable\u003c/code\u003e을 반환하는 \u003ccode\u003eaclose\u003c/code\u003e 메서드를 구현합니다. 이 메서드를 \u003ccode\u003eawait\u003c/code\u003e하면 정지된 제너레이터에 \u003ccode\u003eGeneratorExit\u003c/code\u003e 예외를 발생시키고, \u003ccode\u003eGeneratorExit\u003c/code\u003e 또는 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e이 발생할 때까지 이터레이션합니다.\n이는 일반 Python 제너레이터에 \u003ccode\u003eclose()\u003c/code\u003e 메서드가 하는 일과 매우 유사하지만, \u003ccode\u003eaclose()\u003c/code\u003e를 실행하려면 이벤트 루프가 필요하다는 점이 다릅니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e비동기 제너레이터가 \u003ccode\u003efinally\u003c/code\u003e 블록에서 \u003ccode\u003eyield\u003c/code\u003e 표현식을 실행할 때 \u003ccode\u003eRuntimeError\u003c/code\u003e를 발생시킵니다 (그러나 \u003ccode\u003eawait\u003c/code\u003e를 사용하는 것은 괜찮습니다).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def gen():\n    try:\n        yield\n    finally:\n        await asyncio.sleep(1) # 'await' 사용 가능.\n        yield # 'yield' 사용 불가,\n              # 이 줄은 RuntimeError를 발생시킵니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003esys\u003c/code\u003e 모듈에 \u003ccode\u003eset_asyncgen_hooks()\u003c/code\u003e 및 \u003ccode\u003eget_asyncgen_hooks()\u003c/code\u003e 두 가지 새로운 메서드를 추가합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esys.set_asyncgen_hooks()\u003c/code\u003e의 아이디어는 이벤트 루프가 비동기 제너레이터의 이터레이션 및 종료를 가로챌 수 있도록 하여, 최종 사용자가 종료 문제에 신경 쓸 필요 없이 모든 것이 작동하도록 하는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esys.set_asyncgen_hooks()\u003c/code\u003e는 두 가지 인수를 허용합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efirstiter\u003c/code\u003e: 비동기 제너레이터가 처음 이터레이션될 때 호출될 호출 가능 객체(callable).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efinalizer\u003c/code\u003e: 비동기 제너레이터가 가비지 컬렉션되기 직전에 호출될 호출 가능 객체.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e비동기 제너레이터가 처음 이터레이션될 때, 현재 \u003ccode\u003efinalizer\u003c/code\u003e에 대한 참조를 저장합니다.\n비동기 제너레이터가 가비지 컬렉션되기 직전에 캐시된 \u003ccode\u003efinalizer\u003c/code\u003e를 호출합니다. \u003ccode\u003efinalizer\u003c/code\u003e는 이터레이션이 시작될 때 활성화된 루프와 함께 \u003ccode\u003eaclose()\u003c/code\u003e 호출을 스케줄링할 것이라고 가정합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003easyncio\u003c/code\u003e가 비동기 제너레이터의 안전한 종료를 허용하도록 수정되는 방법은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# asyncio/base_events.py\nclass BaseEventLoop:\n    def run_forever(self):\n        ...\n        old_hooks = sys.get_asyncgen_hooks()\n        sys.set_asyncgen_hooks(finalizer=self._finalize_asyncgen)\n        try:\n            ...\n        finally:\n            sys.set_asyncgen_hooks(*old_hooks)\n        ...\n\n    def _finalize_asyncgen(self, gen):\n        self.create_task(gen.aclose())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 번째 인수 \u003ccode\u003efirstiter\u003c/code\u003e는 이벤트 루프가 자체 제어하에 인스턴스화된 비동기 제너레이터의 약한 집합(weak set)을 유지 관리할 수 있도록 합니다. 이를 통해 모든 열려있는 제너레이터를 안전하게 종료하고 이벤트 루프를 닫는 \"종료(shutdown)\" 메커니즘을 구현할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esys.set_asyncgen_hooks()\u003c/code\u003e는 스레드별(thread-specific)이므로, 여러 이벤트 루프가 병렬 스레드에서 안전하게 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esys.get_asyncgen_hooks()\u003c/code\u003e는 \u003ccode\u003efirstiter\u003c/code\u003e 및 \u003ccode\u003efinalizer\u003c/code\u003e 필드를 가진 namedtuple과 유사한 구조를 반환합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"asyncio\"\u003e\u003ca href=\"#asyncio\"\u003e\u003ccode\u003easyncio\u003c/code\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003easyncio\u003c/code\u003e 이벤트 루프는 \u003ccode\u003esys.set_asyncgen_hooks()\u003c/code\u003e API를 사용하여 스케줄링된 모든 비동기 제너레이터의 약한 집합을 유지하고, 제너레이터가 가비지 컬렉션될 시점에 \u003ccode\u003eaclose()\u003c/code\u003e 코루틴 메서드를 스케줄링합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003easyncio\u003c/code\u003e 프로그램이 스케줄링된 모든 비동기 제너레이터를 안정적으로 종료할 수 있도록 하기 위해, 새로운 이벤트 루프 코루틴 메서드 \u003ccode\u003eloop.shutdown_asyncgens()\u003c/code\u003e를 추가할 것을 제안합니다. 이 메서드는 현재 열려있는 모든 비동기 제너레이터를 \u003ccode\u003eaclose()\u003c/code\u003e 호출로 닫도록 스케줄링합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eloop.shutdown_asyncgens()\u003c/code\u003e 메서드를 호출한 후, 이벤트 루프는 새로운 비동기 제너레이터가 처음 이터레이션될 때마다 경고를 발생시킬 것입니다. 이는 모든 비동기 제너레이터를 종료하도록 요청한 후에는 프로그램이 새로운 비동기 제너레이터를 이터레이션하는 코드를 실행해서는 안 된다는 아이디어입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eshutdown_asyncgens\u003c/code\u003e 코루틴을 사용하는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\n    loop.run_forever()\nfinally:\n    loop.run_until_complete(loop.shutdown_asyncgens())\n    loop.close()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"비동기-제너레이터-객체-asynchronous-generator-object\"\u003e\u003ca href=\"#비동기-제너레이터-객체-asynchronous-generator-object\"\u003e비동기 제너레이터 객체 (Asynchronous Generator Object)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e이 객체는 표준 Python 제너레이터 객체를 모델로 합니다. 본질적으로 비동기 제너레이터의 동작은 동기 제너레이터의 동작을 복제하도록 설계되었으며, 유일한 차이점은 API가 비동기라는 점입니다.\u003c/p\u003e\n\u003cp\u003e다음 메서드와 속성이 정의됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.__aiter__()\u003c/code\u003e: \u003ccode\u003eagen\u003c/code\u003e을 반환합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.__anext__()\u003c/code\u003e: \u003ccode\u003eawait\u003c/code\u003e될 때 하나의 비동기 제너레이터 이터레이션을 수행하는 \u003ccode\u003eawaitable\u003c/code\u003e을 반환합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.asend(val)\u003c/code\u003e: \u003ccode\u003eval\u003c/code\u003e 객체를 \u003ccode\u003eagen\u003c/code\u003e 제너레이터로 푸시하는 \u003ccode\u003eawaitable\u003c/code\u003e을 반환합니다. \u003ccode\u003eagen\u003c/code\u003e이 아직 이터레이션되지 않은 경우, \u003ccode\u003eval\u003c/code\u003e은 \u003ccode\u003eNone\u003c/code\u003e이어야 합니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def gen():\n    await asyncio.sleep(0.1)\n    v = yield 42\n    print(v)\n    await asyncio.sleep(0.2)\n\ng = gen()\nawait g.asend(None) # 0.1초 동안 sleep 후 42를 반환합니다.\nawait g.asend('hello') # 'hello'를 출력하고\n                       # StopAsyncIteration을 발생시킵니다.\n                       # (0.2초 동안 sleep 후)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.athrow(typ, [val, [tb]])\u003c/code\u003e: 예외를 \u003ccode\u003eagen\u003c/code\u003e 제너레이터로 던지는 \u003ccode\u003eawaitable\u003c/code\u003e을 반환합니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def gen():\n    try:\n        await asyncio.sleep(0.1)\n        yield 'hello'\n    except ZeroDivisionError:\n        await asyncio.sleep(0.2)\n        yield 'world'\n\ng = gen()\nv = await g.asend(None)\nprint(v) # 0.1초 동안 sleep 후 'hello'를 출력합니다.\nv = await g.athrow(ZeroDivisionError)\nprint(v) # 0.2초 동안 sleep 후 'world'를 출력합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.aclose()\u003c/code\u003e: \u003ccode\u003eGeneratorExit\u003c/code\u003e 예외를 제너레이터로 던지는 \u003ccode\u003eawaitable\u003c/code\u003e을 반환합니다. \u003ccode\u003eawaitable\u003c/code\u003e은 \u003ccode\u003eagen\u003c/code\u003e이 예외를 처리했다면 \u003ccode\u003eyield\u003c/code\u003e된 값을 반환할 수 있고, 그렇지 않으면 \u003ccode\u003eagen\u003c/code\u003e이 닫히고 예외는 호출자(caller)에게 다시 전파됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.__name__\u003c/code\u003e 및 \u003ccode\u003eagen.__qualname__\u003c/code\u003e: 읽고 쓸 수 있는 이름 및 정규화된 이름(qualified name) 속성입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.ag_await\u003c/code\u003e: \u003ccode\u003eagen\u003c/code\u003e이 현재 \u003ccode\u003eawait\u003c/code\u003e하고 있는 객체 또는 \u003ccode\u003eNone\u003c/code\u003e입니다. 이는 제너레이터의 \u003ccode\u003egi_yieldfrom\u003c/code\u003e 및 코루틴의 \u003ccode\u003ecr_await\u003c/code\u003e와 유사합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.ag_frame\u003c/code\u003e, \u003ccode\u003eagen.ag_running\u003c/code\u003e, \u003ccode\u003eagen.ag_code\u003c/code\u003e: 표준 제너레이터의 유사한 속성과 동일한 방식으로 정의됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eStopIteration\u003c/code\u003e과 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e은 비동기 제너레이터 밖으로 전파되지 않으며, \u003ccode\u003eRuntimeError\u003c/code\u003e로 대체됩니다.\u003c/p\u003e\n\u003ch4 id=\"구현-세부-정보-implementation-details\"\u003e\u003ca href=\"#구현-세부-정보-implementation-details\"\u003e구현 세부 정보 (Implementation Details)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e비동기 제너레이터 객체(\u003ccode\u003ePyAsyncGenObject\u003c/code\u003e)는 \u003ccode\u003ePyGenObject\u003c/code\u003e와 구조 레이아웃을 공유합니다. 또한, 참조 구현은 세 가지 새로운 객체를 도입합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e: \u003ccode\u003e__anext__\u003c/code\u003e 및 \u003ccode\u003easend()\u003c/code\u003e 메서드를 구현하는 \u003ccode\u003eawaitable\u003c/code\u003e 객체입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenAThrow\u003c/code\u003e: \u003ccode\u003eathrow()\u003c/code\u003e 및 \u003ccode\u003eaclose()\u003c/code\u003e 메서드를 구현하는 \u003ccode\u003eawaitable\u003c/code\u003e 객체입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_PyAsyncGenWrappedValue\u003c/code\u003e: 비동기 제너레이터에서 직접 \u003ccode\u003eyield\u003c/code\u003e된 모든 객체는 암시적으로 이 구조로 묶입니다. 이를 통해 제너레이터 구현은 일반 이터레이션 프로토콜을 사용하여 \u003ccode\u003eyield\u003c/code\u003e된 객체와 비동기 이터레이션 프로토콜을 사용하여 \u003ccode\u003eyield\u003c/code\u003e된 객체를 분리할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e와 \u003ccode\u003ePyAsyncGenAThrow\u003c/code\u003e는 \u003ccode\u003eawaitable\u003c/code\u003e 객체이며(\u003ccode\u003e__await__\u003c/code\u003e 메서드가 \u003ccode\u003eself\u003c/code\u003e를 반환함), 코루틴과 유사한 객체입니다(\u003ccode\u003e__iter__\u003c/code\u003e, \u003ccode\u003e__next__\u003c/code\u003e, \u003ccode\u003esend()\u003c/code\u003e, \u003ccode\u003ethrow()\u003c/code\u003e 메서드를 구현함). 본질적으로 이들은 비동기 제너레이터가 어떻게 이터레이션되는지를 제어합니다.\u003c/p\u003e\n\u003ch5 id=\"pyasyncgenasend-및-pyasyncgenathrow\"\u003e\u003ca href=\"#pyasyncgenasend-및-pyasyncgenathrow\"\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e 및 \u003ccode\u003ePyAsyncGenAThrow\u003c/code\u003e\u003c/a\u003e\u003c/h5\u003e\n\u003cp\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e는 \u003ccode\u003e__anext__\u003c/code\u003e 및 \u003ccode\u003easend()\u003c/code\u003e 메서드를 구동하고 비동기 이터레이션 프로토콜을 구현하는 코루틴과 유사한 객체입니다.\n\u003ccode\u003eagen.asend(val)\u003c/code\u003e 및 \u003ccode\u003eagen.__anext__()\u003c/code\u003e는 \u003ccode\u003ePyAsyncGenASend\u003c/code\u003e 인스턴스(부모 \u003ccode\u003eagen\u003c/code\u003e 객체에 대한 참조를 유지)를 반환합니다.\u003c/p\u003e\n\u003cp\u003e데이터 흐름은 다음과 같이 정의됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenASend.send(val)\u003c/code\u003e이 처음 호출되면, \u003ccode\u003eval\u003c/code\u003e은 부모 \u003ccode\u003eagen\u003c/code\u003e 객체로 푸시됩니다(\u003ccode\u003ePyGenObject\u003c/code\u003e의 기존 기능을 사용).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e 객체에 대한 후속 이터레이션은 \u003ccode\u003eNone\u003c/code\u003e을 \u003ccode\u003eagen\u003c/code\u003e으로 푸시합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_PyAsyncGenWrappedValue\u003c/code\u003e 객체가 \u003ccode\u003eyield\u003c/code\u003e되면, 언박싱(unboxed)되고, 래핑되지 않은(unwrapped) 값을 인수로 하는 \u003ccode\u003eStopIteration\u003c/code\u003e 예외가 발생합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenASend.throw(*exc)\u003c/code\u003e가 처음 호출되면, \u003ccode\u003e*exc\u003c/code\u003e가 부모 \u003ccode\u003eagen\u003c/code\u003e 객체로 던져집니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e 객체에 대한 후속 이터레이션은 \u003ccode\u003eNone\u003c/code\u003e을 \u003ccode\u003eagen\u003c/code\u003e으로 푸시합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_PyAsyncGenWrappedValue\u003c/code\u003e 객체가 \u003ccode\u003eyield\u003c/code\u003e되면, 언박싱되고, 래핑되지 않은 값을 인수로 하는 \u003ccode\u003eStopIteration\u003c/code\u003e 예외가 발생합니다.\u003c/li\u003e\n\u003cli\u003e비동기 제너레이터의 \u003ccode\u003ereturn\u003c/code\u003e 문은 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e 예외를 발생시키며, 이는 \u003ccode\u003ePyAsyncGenASend.send()\u003c/code\u003e 및 \u003ccode\u003ePyAsyncGenASend.throw()\u003c/code\u003e 메서드를 통해 전파됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ePyAsyncGenAThrow\u003c/code\u003e는 \u003ccode\u003ePyAsyncGenASend\u003c/code\u003e와 매우 유사합니다. 유일한 차이점은 \u003ccode\u003ePyAsyncGenAThrow.send()\u003c/code\u003e가 처음 호출될 때 부모 \u003ccode\u003eagen\u003c/code\u003e 객체에 예외를 던진다는 것입니다(값을 푸시하는 대신).\u003c/p\u003e\n\u003ch4 id=\"새로운-표준-라이브러리-함수-및-타입-new-standard-library-functions-and-types\"\u003e\u003ca href=\"#새로운-표준-라이브러리-함수-및-타입-new-standard-library-functions-and-types\"\u003e새로운 표준 라이브러리 함수 및 타입 (New Standard Library Functions and Types)\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etypes.AsyncGeneratorType\u003c/code\u003e – 비동기 제너레이터 객체의 타입입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.set_asyncgen_hooks()\u003c/code\u003e 및 \u003ccode\u003esys.get_asyncgen_hooks()\u003c/code\u003e 메서드는 이벤트 루프에서 비동기 제너레이터의 종료자(finalizers) 및 이터레이션 가로채기(interceptors)를 설정하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einspect.isasyncgen()\u003c/code\u003e 및 \u003ccode\u003einspect.isasyncgenfunction()\u003c/code\u003e 인트로스펙션(introspection) 함수.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easyncio\u003c/code\u003e 이벤트 루프의 새로운 메서드: \u003ccode\u003eloop.shutdown_asyncgens()\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e새로운 \u003ccode\u003ecollections.abc.AsyncGenerator\u003c/code\u003e 추상 기본 클래스(abstract base class).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"하위-호환성-backwards-compatibility\"\u003e\u003ca href=\"#하위-호환성-backwards-compatibility\"\u003e하위 호환성 (Backwards Compatibility)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e이 제안은 완벽하게 하위 호환됩니다.\nPython 3.5에서는 \u003ccode\u003eyield\u003c/code\u003e 표현식이 포함된 \u003ccode\u003easync def\u003c/code\u003e 함수를 정의하는 것이 \u003ccode\u003eSyntaxError\u003c/code\u003e이므로, 3.6에서 비동기 제너레이터를 도입하는 것은 안전합니다.\u003c/p\u003e\n\u003ch4 id=\"성능-performance\"\u003e\u003ca href=\"#성능-performance\"\u003e성능 (Performance)\u003c/a\u003e\u003c/h4\u003e\n\u003ch5 id=\"일반-제너레이터-regular-generators\"\u003e\u003ca href=\"#일반-제너레이터-regular-generators\"\u003e일반 제너레이터 (Regular Generators)\u003c/a\u003e\u003c/h5\u003e\n\u003cp\u003e일반 제너레이터에는 성능 저하가 없습니다. 다음 마이크로 벤치마크는 CPython에서 비동기 제너레이터 유무에 관계없이 동일한 속도로 실행됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef gen():\n    i = 0\n    while i \u0026#x3C; 100000000:\n        yield i\n        i += 1\nlist(gen())\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5 id=\"비동기-이터레이터-대비-개선점-improvements-over-asynchronous-iterators\"\u003e\u003ca href=\"#비동기-이터레이터-대비-개선점-improvements-over-asynchronous-iterators\"\u003e비동기 이터레이터 대비 개선점 (Improvements over asynchronous iterators)\u003c/a\u003e\u003c/h5\u003e\n\u003cp\u003e다음 마이크로 벤치마크는 비동기 제너레이터가 순수 Python으로 구현된 비동기 이터레이터보다 약 2.3배 빠름을 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eN = 10 ** 7\n\nasync def agen():\n    for i in range(N):\n        yield i\n\nclass AIter:\n    def __init__(self):\n        self.i = 0\n    def __aiter__(self):\n        return self\n    async def __anext__(self):\n        i = self.i\n        if i \u003e= N:\n            raise StopAsyncIteration\n        self.i += 1\n        return i\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"설계-고려-사항-design-considerations\"\u003e\u003ca href=\"#설계-고려-사항-design-considerations\"\u003e설계 고려 사항 (Design Considerations)\u003c/a\u003e\u003c/h3\u003e\n\u003ch4 id=\"aiter-및-anext-내장-함수-aiter-and-anext-builtins\"\u003e\u003ca href=\"#aiter-및-anext-내장-함수-aiter-and-anext-builtins\"\u003e\u003ccode\u003eaiter()\u003c/code\u003e 및 \u003ccode\u003eanext()\u003c/code\u003e 내장 함수 (aiter() and anext() builtins)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e원래 PEP 492는 \u003ccode\u003e__aiter__\u003c/code\u003e를 \u003ccode\u003eawaitable\u003c/code\u003e 객체를 반환해야 하는 메서드로 정의하여 비동기 이터레이터를 생성하도록 했습니다.\n그러나 CPython 3.5.2에서 \u003ccode\u003e__aiter__\u003c/code\u003e는 비동기 이터레이터를 직접 반환하도록 재정의되었습니다. 하위 호환성을 깨는 것을 피하기 위해, Python 3.6에서는 두 가지 방식 모두를 지원하며, \u003ccode\u003e__aiter__\u003c/code\u003e가 여전히 \u003ccode\u003eawaitable\u003c/code\u003e을 반환할 수 있지만 \u003ccode\u003eDeprecationWarning\u003c/code\u003e이 발행되도록 결정되었습니다.\u003c/p\u003e\n\u003cp\u003ePython 3.6에서 \u003ccode\u003e__aiter__\u003c/code\u003e의 이러한 이중적인 특성 때문에 \u003ccode\u003eaiter()\u003c/code\u003e 내장 함수의 동기 구현을 추가할 수 없습니다. 따라서 Python 3.7까지 기다릴 것을 제안합니다.\u003c/p\u003e\n\u003ch4 id=\"비동기-리스트딕셔너리세트-컴프리헨션-asynchronous-listdictset-comprehensions\"\u003e\u003ca href=\"#비동기-리스트딕셔너리세트-컴프리헨션-asynchronous-listdictset-comprehensions\"\u003e비동기 리스트/딕셔너리/세트 컴프리헨션 (Asynchronous list/dict/set comprehensions)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e비동기 컴프리헨션(comprehensions)의 문법은 비동기 제너레이터 메커니즘과 관련이 없으며, 별도의 PEP에서 고려되어야 합니다.\u003c/p\u003e\n\u003ch4 id=\"비동기-yield-from-asynchronous-yield-from\"\u003e\u003ca href=\"#비동기-yield-from-asynchronous-yield-from\"\u003e비동기 \u003ccode\u003eyield from\u003c/code\u003e (Asynchronous yield from)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e비동기 제너레이터에 \u003ccode\u003eyield from\u003c/code\u003e 지원을 구현하는 것이 이론적으로 가능하지만, 제너레이터 구현을 심각하게 재설계해야 합니다.\n\u003ccode\u003eyield from\u003c/code\u003e은 비동기 제너레이터에 덜 중요합니다. 코루틴 위에 다른 코루틴 프로토콜을 구현하는 메커니즘을 제공할 필요가 없기 때문입니다. 비동기 제너레이터를 구성하기 위해 간단한 \u003ccode\u003easync for\u003c/code\u003e 루프를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def g1():\n    yield 1\n    yield 2\n\nasync def g2():\n    async for v in g1():\n        yield v\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"asend-및-athrow-메서드가-필요한-이유-why-the-asend-and-athrow-methods-are-necessary\"\u003e\u003ca href=\"#asend-및-athrow-메서드가-필요한-이유-why-the-asend-and-athrow-methods-are-necessary\"\u003e\u003ccode\u003easend()\u003c/code\u003e 및 \u003ccode\u003eathrow()\u003c/code\u003e 메서드가 필요한 이유 (Why the asend() and athrow() methods are necessary)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e이 메서드들은 \u003ccode\u003econtextlib.contextmanager\u003c/code\u003e와 유사한 개념을 비동기 제너레이터를 사용하여 구현할 수 있게 합니다. 예를 들어, 제안된 설계로 다음 패턴을 구현할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@async_context_manager\nasync def ctx():\n    await open()\n    try:\n        yield\n    finally:\n        await close()\n\nasync with ctx():\n    await ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또 다른 이유는 \u003ccode\u003e__anext__\u003c/code\u003e 객체에서 반환된 객체를 사용하여 비동기 제너레이터로 데이터를 푸시하고 예외를 던지는 것이 가능하지만, 이를 올바르게 수행하기는 어렵다는 것입니다. 명시적인 \u003ccode\u003easend()\u003c/code\u003e 및 \u003ccode\u003eathrow()\u003c/code\u003e를 추가하면 이를 안전하게 수행할 수 있는 길을 열어줄 것입니다.\u003c/p\u003e\n\u003cp\u003e구현 측면에서 \u003ccode\u003easend()\u003c/code\u003e는 \u003ccode\u003e__anext__\u003c/code\u003e의 약간 더 일반적인 버전이며, \u003ccode\u003eathrow()\u003c/code\u003e는 \u003ccode\u003eaclose()\u003c/code\u003e와 매우 유사합니다. 따라서 비동기 제너레이터에 이러한 메서드를 정의해도 추가적인 복잡성은 발생하지 않습니다.\u003c/p\u003e\n\u003ch3 id=\"예시-example\"\u003e\u003ca href=\"#예시-example\"\u003e예시 (Example)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e현재 참조 구현을 사용한 작동 예시 (0부터 9까지의 숫자를 1초 간격으로 출력합니다):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def ticker(delay, to):\n    for i in range(to):\n        yield i\n        await asyncio.sleep(delay)\n\nasync def run():\n    async for i in ticker(1, 10):\n        print(i)\n\nimport asyncio\nloop = asyncio.get_event_loop()\ntry:\n    loop.run_until_complete(run())\nfinally:\n    loop.close()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"승인-acceptance\"\u003e\u003ca href=\"#승인-acceptance\"\u003e승인 (Acceptance)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003ePEP 525는 2016년 9월 6일 Guido에 의해 승인되었습니다.\u003c/p\u003e\n\u003ch3 id=\"구현-implementation\"\u003e\u003ca href=\"#구현-implementation\"\u003e구현 (Implementation)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e구현은 이슈 28003에서 추적됩니다. 참조 구현 Git 저장소는에서 확인할 수 있습니다.\u003c/p\u003e\n\u003ch3 id=\"참고-자료-references\"\u003e\u003ca href=\"#참고-자료-references\"\u003e참고 자료 (References)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/1st1/cpython/tree/async_gen\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://github.com/1st1/cpython/tree/async_gen\u003c/a\u003e\n\u003ca href=\"https://mail.python.org/pipermail/python-dev/2016-September/146267.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://mail.python.org/pipermail/python-dev/2016-September/146267.html\u003c/a\u003e\n\u003ca href=\"http://bugs.python.org/issue28003\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttp://bugs.python.org/issue28003\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"감사-acknowledgments\"\u003e\u003ca href=\"#감사-acknowledgments\"\u003e감사 (Acknowledgments)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e이 PEP에 대한 피드백, 코드 검토 및 토론에 대해 Guido van Rossum, Victor Stinner, Elvis Pranskevichus, Nathaniel Smith, Łukasz Langa, Andrew Svetlov 및 기타 여러 사람들에게 감사드립니다.\u003c/p\u003e\n\u003ch3 id=\"저작권-copyright\"\u003e\u003ca href=\"#저작권-copyright\"\u003e저작권 (Copyright)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ ** 알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"BlogPosting\\\",\\\"headline\\\":\\\"[Final] PEP 525 - Asynchronous Generators\\\",\\\"description\\\":\\\"Python Enhancement Proposal 525: 'Asynchronous Generators'에 대한 한국어 번역입니다.\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud/python/pep/525\\\",\\\"datePublished\\\":\\\"2025-09-26T14:17:46.000Z\\\",\\\"dateModified\\\":\\\"2025-09-26T14:17:46.000Z\\\",\\\"author\\\":{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"secrett2633\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud\\\"},\\\"publisher\\\":{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"secrett2633\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud\\\"},\\\"mainEntityOfPage\\\":{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://blog.secrett2633.cloud/python/pep/525\\\"},\\\"image\\\":\\\"https://blog.secrett2633.cloud/og-default.png\\\",\\\"isAccessibleForFree\\\":true,\\\"inLanguage\\\":\\\"ko\\\",\\\"wordCount\\\":1905,\\\"articleSection\\\":\\\"Python\\\",\\\"keywords\\\":\\\"Python, PEP, Translation\\\"}\"}}],[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"BreadcrumbList\\\",\\\"itemListElement\\\":[{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":1,\\\"name\\\":\\\"홈\\\",\\\"item\\\":\\\"https://blog.secrett2633.cloud/\\\"},{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":2,\\\"name\\\":\\\"[Final] PEP 525 - Asynchronous Generators\\\",\\\"item\\\":\\\"https://blog.secrett2633.cloud/python/pep/525\\\"}]}\"}}],[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"aria-label\":\"카테고리 네비게이션\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"p\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/backend/django\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/backend/logging\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"p\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/python/pep\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"p\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/ai/llm\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/ai/review\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2728,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"p\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/nginx\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/docker\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/safeline\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/jenkins\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/github-actions\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/aws\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"p\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/etc/me\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/etc/chrome-extension\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"div\",null,{\"className\":\"flex-1\",\"children\":[[\"$\",\"nav\",null,{\"aria-label\":\"breadcrumb\",\"className\":\"text-sm text-gray-500 mb-4\",\"children\":[\"$\",\"ol\",null,{\"className\":\"flex flex-wrap items-center gap-1\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"hover:text-gray-700\",\"children\":\"홈\"}]}],[[\"$\",\"li\",\"/python/pep/525\",{\"className\":\"flex items-center gap-1\",\"children\":[[\"$\",\"span\",null,{\"aria-hidden\":\"true\",\"children\":\"/\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-900\",\"aria-current\":\"page\",\"children\":\"[Final] PEP 525 - Asynchronous Generators\"}]]}]]]}]}],[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 525 - Asynchronous Generators\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:17:46+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"time\",null,{\"className\":\"ml-4\",\"dateTime\":\"2025-09-26T14:17:46.000Z\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$f\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2 block\",\"children\":\"태그\"}],[[\"$\",\"$La\",\"Python\",{\"href\":\"/tags/Python\",\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"$La\",\"PEP\",{\"href\":\"/tags/PEP\",\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"$La\",\"Translation\",{\"href\":\"/tags/Translation\",\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$L10\",null,{\"postPermalink\":\"/python/pep/525\",\"postId\":\"2025-09-26-pep-0525-asynchronous-generators\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/524\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 524 - Make os.urandom() blocking on Linux\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 525 - Asynchronous Generators\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/526\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 526 - Syntax for Variable Annotations\"}]]}]]}]]}]]}]]}]]}]]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"[Final] PEP 525 - Asynchronous Generators - secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Python Enhancement Proposal 525: 'Asynchronous Generators'에 대한 한국어 번역입니다.\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"link\",\"5\",{\"rel\":\"manifest\",\"href\":\"/manifest.json\",\"crossOrigin\":\"use-credentials\"}],[\"$\",\"meta\",\"6\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"7\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"9\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"10\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"11\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/python/pep/525\"}],[\"$\",\"meta\",\"12\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:title\",\"content\":\"[Final] PEP 525 - Asynchronous Generators\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:description\",\"content\":\"Python Enhancement Proposal 525: 'Asynchronous Generators'에 대한 한국어 번역입니다.\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/python/pep/525\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"17\",{\"property\":\"article:published_time\",\"content\":\"2025-09-26T14:17:46.000Z\"}],[\"$\",\"meta\",\"18\",{\"property\":\"article:modified_time\",\"content\":\"2025-09-26T14:17:46.000Z\"}],[\"$\",\"meta\",\"19\",{\"property\":\"article:author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"20\",{\"property\":\"article:section\",\"content\":\"Python\"}],[\"$\",\"meta\",\"21\",{\"property\":\"article:tag\",\"content\":\"Python\"}],[\"$\",\"meta\",\"22\",{\"property\":\"article:tag\",\"content\":\"PEP\"}],[\"$\",\"meta\",\"23\",{\"property\":\"article:tag\",\"content\":\"Translation\"}],[\"$\",\"meta\",\"24\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"25\",{\"name\":\"twitter:creator\",\"content\":\"@secrett2633\"}],[\"$\",\"meta\",\"26\",{\"name\":\"twitter:title\",\"content\":\"[Final] PEP 525 - Asynchronous Generators\"}],[\"$\",\"meta\",\"27\",{\"name\":\"twitter:description\",\"content\":\"Python Enhancement Proposal 525: 'Asynchronous Generators'에 대한 한국어 번역입니다.\"}],[\"$\",\"link\",\"28\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"29\",{\"name\":\"next-size-adjust\"}]]\n"])</script><script>self.__next_f.push([1,"4:null\n"])</script></body></html>