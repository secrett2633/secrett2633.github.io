<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Draft] PEP 467 - Minor API improvements for binary sequences</h1><div class="page__meta"><time dateTime="2025-09-26 22:14:25+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0467/">PEP 467 - Minor API improvements for binary sequences</a></p>
<p><strong>상태:</strong> Draft | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 30-Mar-2014</p>
</blockquote>
<h2>PEP 467 – 바이너리 시퀀스를 위한 사소한 API 개선 (Minor API improvements for binary sequences)</h2>
<h3>개요 (Abstract)</h3>
<p>이 PEP는 <code>bytes</code> 및 <code>bytearray</code> 타입의 API에 작은 조정을 제안하여 바이너리 도메인(binary domain) 내에서 작업하는 것을 더 쉽게 만드는 것을 목표로 합니다. 주요 제안 내용은 다음과 같습니다:</p>
<ul>
<li><code>fromsize</code> 대체 생성자 추가</li>
<li><code>fromint</code> 대체 생성자 추가</li>
<li><code>getbyte</code> 바이트 검색 메서드 추가</li>
<li><code>iterbytes</code> 대체 이터레이터 추가</li>
</ul>
<p>마지막 두 가지(<code>getbyte</code> 및 <code>iterbytes</code>)는 <code>memoryview</code>에도 추가될 예정입니다.</p>
<h3>배경 (Rationale)</h3>
<p>Python 3 언어 사양의 초기 개발 과정에서, 임의의 바이너리 데이터를 위한 핵심 <code>bytes</code> 타입은 현재 <code>bytearray</code>라고 불리는 가변 타입으로 시작되었습니다. Python 3 시리즈 전반에 걸쳐 바이너리 도메인에서 작동하는 다른 측면들도 발전해 왔으며, 예를 들어 PEP 461이 있습니다.</p>
<h3>동기 (Motivation)</h3>
<p>Python 3와 <code>str</code> 및 <code>bytes</code>의 분리 이후, 프로그래밍의 작지만 중요한 영역인 와이어 포맷(wire format) 프로토콜은 다루기 다소 어려워졌고 훨씬 더 고통스러워졌습니다. 이 프로그래밍 영역은 바이너리 데이터와 ASCII 호환 텍스트 세그먼트(ASCII-encoded text)의 혼합으로 특징지어집니다. 새로운 생성자, 메서드 및 이터레이터의 추가는 새로운 와이어 포맷 코드를 작성하고 기존 코드를 업데이트하는 데 도움이 될 것입니다. 일반적인 사용 사례로는 dbf 및 pdf 파일 형식, 이메일 형식, FTP 및 HTTP 통신 등이 있습니다.</p>
<h3>제안 내용 (Proposals)</h3>
<h4>1. "개수 및 바이트 초기화 시퀀스" 생성자 명시적 추가 (Addition of explicit “count and byte initialised sequence” constructors)</h4>
<p>기본 생성자(예: <code>bytes(1) -> b'\x00'</code>)를 통해 0으로 채워진 <code>bytes</code> 유사 객체를 생성하는 권장되지 않는 동작을 대체하기 위해, 이 PEP는 <code>bytes</code>와 <code>bytearray</code> 모두에 <code>fromsize</code>라는 명시적인 대체 생성자를 클래스 메서드로 추가할 것을 제안합니다. 첫 번째 인수는 개수(<code>count</code>)이며, 두 번째 인수는 사용할 채움 바이트(<code>fill byte</code>)이고 기본값은 <code>\x00</code>입니다.</p>
<p>예시:</p>
<pre><code class="language-python">>>> bytes.fromsize(3)
b'\x00\x00\x00'
>>> bytearray.fromsize(3)
bytearray(b'\x00\x00\x00')
>>> bytes.fromsize(5, b'\x0a')
b'\x0a\x0a\x0a\x0a\x0a'
>>> bytearray.fromsize(5, fill=b'\x0a')
bytearray(b'\x0a\x0a\x0a\x0a\x0a')
</code></pre>
<p><code>fromsize</code>는 단일 정수가 전달될 때 현재 생성자가 작동하는 방식과 동일하게 동작하지만, 필요할 경우 0이 아닌 채움 값을 허용합니다.</p>
<h4>2. "단일 바이트" 생성자 명시적 추가 (Addition of explicit “single byte” constructors)</h4>
<p>텍스트 <code>chr</code> 함수의 바이너리 대응물로서, 이 PEP는 <code>bytes</code>와 <code>bytearray</code> 모두에 <code>fromint</code>라는 명시적인 대체 생성자를 클래스 메서드로 추가할 것을 제안합니다.</p>
<p>예시:</p>
<pre><code class="language-python">>>> bytes.fromint(65)
b'A'
>>> bytearray.fromint(65)
bytearray(b'A')
</code></pre>
<p>이 메서드들은 0에서 255 (포함) 범위의 정수만 허용합니다.
범위를 벗어나는 값이나 잘못된 타입이 전달될 경우 <code>ValueError</code> 또는 <code>TypeError</code>가 발생합니다.</p>
<p><code>ord</code> 빌트인 함수의 문서는 <code>bytes.fromint</code>가 바이너리 데이터의 주된 역 연산(primary inverse operation)이며, <code>chr</code>은 텍스트 데이터의 역 연산임을 명시적으로 기록하도록 업데이트될 것입니다. <code>bytearray.fromint</code>도 존재함이 언급될 것입니다.</p>
<p>동작상 <code>bytes.fromint(x)</code>는 현재 <code>bytes([x])</code>와 동일하며 (<code>bytearray</code>도 마찬가지), 새로운 표기법은 발견하기 쉽고 읽기 쉬울 것으로 예상됩니다 (특히 바이너리 시퀀스 타입의 인덱싱 연산과 함께 사용될 때). 별도의 메서드로서, 이 새로운 표기법은 <code>map</code>과 같은 고차 함수(higher order functions)와 더 잘 작동할 것입니다.</p>
<p>이 새로운 메서드들은 임의로 큰 정수를 임의로 긴 <code>bytes</code> 객체로 변환할 수 있는 기존 <code>int.to_bytes</code> 변환 메서드와 동일한 수준의 일반적인 정수 지원을 의도적으로 제공하지 않습니다. 단일 바이트에 맞는 양의 정수만 허용하는 제한은 바이트 순서 정보가 필요 없고 음수를 처리할 필요가 없음을 의미합니다. 새로운 메서드 문서는 임의의 정수 처리가 필요한 사용 사례에 대해 <code>int.to_bytes</code>를 참조하도록 안내할 것입니다.</p>
<h4>3. 단일 바이트를 검색하는 <code>getbyte</code> 메서드 추가 (Addition of “getbyte” method to retrieve a single byte)</h4>
<p>이 PEP는 <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code>에 항상 <code>bytes</code> 객체를 반환하는 <code>getbyte</code> 메서드를 추가할 것을 제안합니다.</p>
<p>예시:</p>
<pre><code class="language-python">>>> b'abc'.getbyte(0)
b'a'
</code></pre>
<p>존재하지 않는 인덱스를 요청하면 <code>IndexError</code>가 발생합니다.</p>
<h4>4. <code>bytes</code> 객체를 생성하는 최적화된 이터레이터 메서드 추가 (Addition of optimised iterator methods that produce bytes objects)</h4>
<p>이 PEP는 <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code>에 정수 대신 길이가 1인 <code>bytes</code> 객체를 생성하는 최적화된 <code>iterbytes</code> 메서드를 추가할 것을 제안합니다.</p>
<p>예시:</p>
<pre><code class="language-python">for x in data.iterbytes(): # x는 정수 대신 길이가 1인 `bytes` 객체
    # ...

>>> tuple(b"ABC".iterbytes())
(b'A', b'B', b'C')
</code></pre>
<h3>설계 논의 (Design discussion)</h3>
<h4>0으로 초기화된 시퀀스를 생성하기 위해 시퀀스 반복에 의존하지 않는 이유 (Why not rely on sequence repetition to create zero-initialised sequences?)</h4>
<p>0으로 초기화된 시퀀스는 시퀀스 반복을 통해 생성할 수 있습니다.</p>
<pre><code class="language-python">>>> b'\x00' * 3
b'\x00\x00\x00'
>>> bytearray(b'\x00') * 3
bytearray(b'\x00\x00\x00')
</code></pre>
<p>그러나 <code>bytearray</code> 타입이 처음 설계될 때도 마찬가지였으며, 타입 생성자에 명시적인 지원을 추가하기로 결정되었습니다. 그 후 변경 불가능한 <code>bytes</code> 타입은 PEP 3137에서 도입될 때 그 기능을 상속받았습니다. 이 PEP는 원래의 설계 결정을 재검토하는 것이 아니라, 사용자들이 바이너리 시퀀스 생성자의 현재 동작을 때때로 혼란스러워하기 때문에 표기법을 변경하는 것입니다. 특히, <code>bytes(x)</code> (여기서 <code>x</code>는 정수)가 이 PEP의 <code>bytes.fromint(x)</code> 제안처럼 동작해야 한다는 합리적인 주장이 있습니다. 두 동작을 별도의 클래스 메서드로 제공함으로써 이러한 모호성을 피합니다.</p>
<h4>현재 해결 방법 (Current Workarounds)</h4>
<p>거의 10년이 지난 후에도 바이트 이터레이션(byte iteration)을 위한 최선의 해결책에 대한 합의는 없는 것으로 보입니다.</p>
<h4>원래 제안되었던 빌트인 함수 생략 (Omitting the originally proposed builtin function)</h4>
<p>스티어링 위원회(Steering Council)에 제출되었을 때, 이 PEP는 <code>bytes.fromint</code>와 동일한 동작을 하는 <code>bchr</code> 빌트인 함수를 도입할 것을 제안하여 Python 2의 <code>ord</code> / <code>chr</code> / <code>unichr</code> 트리오를 다른 명명 체계(<code>ord</code> / <code>bchr</code> / <code>chr</code>)로 재현했습니다. SC는 동일한 작업을 수행하는 두 가지 방법을 제공할 만큼 이 기능이 충분히 자주 필요하다고 생각하지 않았으며, 특히 그중 하나가 새로운 빌트인 함수일 때는 더욱 그렇다고 지적했습니다. 따라서 이 제안 부분은 <code>bytes.fromint</code> 대체 생성자와 중복되므로 삭제되었습니다. 이 메서드를 자주 사용하는 개발자는 대신 자신만의 <code>bchr = bytes.fromint</code> 별칭을 정의할 수 있습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/467\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/467/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/467\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"467\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/467\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T2516,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0467/\"\u003ePEP 467 - Minor API improvements for binary sequences\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Draft | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 30-Mar-2014\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 467 – 바이너리 시퀀스를 위한 사소한 API 개선 (Minor API improvements for binary sequences)\u003c/h2\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003ebytes\u003c/code\u003e 및 \u003ccode\u003ebytearray\u003c/code\u003e 타입의 API에 작은 조정을 제안하여 바이너리 도메인(binary domain) 내에서 작업하는 것을 더 쉽게 만드는 것을 목표로 합니다. 주요 제안 내용은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efromsize\u003c/code\u003e 대체 생성자 추가\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efromint\u003c/code\u003e 대체 생성자 추가\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egetbyte\u003c/code\u003e 바이트 검색 메서드 추가\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eiterbytes\u003c/code\u003e 대체 이터레이터 추가\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e마지막 두 가지(\u003ccode\u003egetbyte\u003c/code\u003e 및 \u003ccode\u003eiterbytes\u003c/code\u003e)는 \u003ccode\u003ememoryview\u003c/code\u003e에도 추가될 예정입니다.\u003c/p\u003e\n\u003ch3\u003e배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003ePython 3 언어 사양의 초기 개발 과정에서, 임의의 바이너리 데이터를 위한 핵심 \u003ccode\u003ebytes\u003c/code\u003e 타입은 현재 \u003ccode\u003ebytearray\u003c/code\u003e라고 불리는 가변 타입으로 시작되었습니다. Python 3 시리즈 전반에 걸쳐 바이너리 도메인에서 작동하는 다른 측면들도 발전해 왔으며, 예를 들어 PEP 461이 있습니다.\u003c/p\u003e\n\u003ch3\u003e동기 (Motivation)\u003c/h3\u003e\n\u003cp\u003ePython 3와 \u003ccode\u003estr\u003c/code\u003e 및 \u003ccode\u003ebytes\u003c/code\u003e의 분리 이후, 프로그래밍의 작지만 중요한 영역인 와이어 포맷(wire format) 프로토콜은 다루기 다소 어려워졌고 훨씬 더 고통스러워졌습니다. 이 프로그래밍 영역은 바이너리 데이터와 ASCII 호환 텍스트 세그먼트(ASCII-encoded text)의 혼합으로 특징지어집니다. 새로운 생성자, 메서드 및 이터레이터의 추가는 새로운 와이어 포맷 코드를 작성하고 기존 코드를 업데이트하는 데 도움이 될 것입니다. 일반적인 사용 사례로는 dbf 및 pdf 파일 형식, 이메일 형식, FTP 및 HTTP 통신 등이 있습니다.\u003c/p\u003e\n\u003ch3\u003e제안 내용 (Proposals)\u003c/h3\u003e\n\u003ch4\u003e1. \"개수 및 바이트 초기화 시퀀스\" 생성자 명시적 추가 (Addition of explicit “count and byte initialised sequence” constructors)\u003c/h4\u003e\n\u003cp\u003e기본 생성자(예: \u003ccode\u003ebytes(1) -\u003e b'\\x00'\u003c/code\u003e)를 통해 0으로 채워진 \u003ccode\u003ebytes\u003c/code\u003e 유사 객체를 생성하는 권장되지 않는 동작을 대체하기 위해, 이 PEP는 \u003ccode\u003ebytes\u003c/code\u003e와 \u003ccode\u003ebytearray\u003c/code\u003e 모두에 \u003ccode\u003efromsize\u003c/code\u003e라는 명시적인 대체 생성자를 클래스 메서드로 추가할 것을 제안합니다. 첫 번째 인수는 개수(\u003ccode\u003ecount\u003c/code\u003e)이며, 두 번째 인수는 사용할 채움 바이트(\u003ccode\u003efill byte\u003c/code\u003e)이고 기본값은 \u003ccode\u003e\\x00\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e bytes.fromsize(3)\nb'\\x00\\x00\\x00'\n\u003e\u003e\u003e bytearray.fromsize(3)\nbytearray(b'\\x00\\x00\\x00')\n\u003e\u003e\u003e bytes.fromsize(5, b'\\x0a')\nb'\\x0a\\x0a\\x0a\\x0a\\x0a'\n\u003e\u003e\u003e bytearray.fromsize(5, fill=b'\\x0a')\nbytearray(b'\\x0a\\x0a\\x0a\\x0a\\x0a')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efromsize\u003c/code\u003e는 단일 정수가 전달될 때 현재 생성자가 작동하는 방식과 동일하게 동작하지만, 필요할 경우 0이 아닌 채움 값을 허용합니다.\u003c/p\u003e\n\u003ch4\u003e2. \"단일 바이트\" 생성자 명시적 추가 (Addition of explicit “single byte” constructors)\u003c/h4\u003e\n\u003cp\u003e텍스트 \u003ccode\u003echr\u003c/code\u003e 함수의 바이너리 대응물로서, 이 PEP는 \u003ccode\u003ebytes\u003c/code\u003e와 \u003ccode\u003ebytearray\u003c/code\u003e 모두에 \u003ccode\u003efromint\u003c/code\u003e라는 명시적인 대체 생성자를 클래스 메서드로 추가할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e bytes.fromint(65)\nb'A'\n\u003e\u003e\u003e bytearray.fromint(65)\nbytearray(b'A')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 메서드들은 0에서 255 (포함) 범위의 정수만 허용합니다.\n범위를 벗어나는 값이나 잘못된 타입이 전달될 경우 \u003ccode\u003eValueError\u003c/code\u003e 또는 \u003ccode\u003eTypeError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eord\u003c/code\u003e 빌트인 함수의 문서는 \u003ccode\u003ebytes.fromint\u003c/code\u003e가 바이너리 데이터의 주된 역 연산(primary inverse operation)이며, \u003ccode\u003echr\u003c/code\u003e은 텍스트 데이터의 역 연산임을 명시적으로 기록하도록 업데이트될 것입니다. \u003ccode\u003ebytearray.fromint\u003c/code\u003e도 존재함이 언급될 것입니다.\u003c/p\u003e\n\u003cp\u003e동작상 \u003ccode\u003ebytes.fromint(x)\u003c/code\u003e는 현재 \u003ccode\u003ebytes([x])\u003c/code\u003e와 동일하며 (\u003ccode\u003ebytearray\u003c/code\u003e도 마찬가지), 새로운 표기법은 발견하기 쉽고 읽기 쉬울 것으로 예상됩니다 (특히 바이너리 시퀀스 타입의 인덱싱 연산과 함께 사용될 때). 별도의 메서드로서, 이 새로운 표기법은 \u003ccode\u003emap\u003c/code\u003e과 같은 고차 함수(higher order functions)와 더 잘 작동할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 새로운 메서드들은 임의로 큰 정수를 임의로 긴 \u003ccode\u003ebytes\u003c/code\u003e 객체로 변환할 수 있는 기존 \u003ccode\u003eint.to_bytes\u003c/code\u003e 변환 메서드와 동일한 수준의 일반적인 정수 지원을 의도적으로 제공하지 않습니다. 단일 바이트에 맞는 양의 정수만 허용하는 제한은 바이트 순서 정보가 필요 없고 음수를 처리할 필요가 없음을 의미합니다. 새로운 메서드 문서는 임의의 정수 처리가 필요한 사용 사례에 대해 \u003ccode\u003eint.to_bytes\u003c/code\u003e를 참조하도록 안내할 것입니다.\u003c/p\u003e\n\u003ch4\u003e3. 단일 바이트를 검색하는 \u003ccode\u003egetbyte\u003c/code\u003e 메서드 추가 (Addition of “getbyte” method to retrieve a single byte)\u003c/h4\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003ebytes\u003c/code\u003e, \u003ccode\u003ebytearray\u003c/code\u003e, \u003ccode\u003ememoryview\u003c/code\u003e에 항상 \u003ccode\u003ebytes\u003c/code\u003e 객체를 반환하는 \u003ccode\u003egetbyte\u003c/code\u003e 메서드를 추가할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e b'abc'.getbyte(0)\nb'a'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e존재하지 않는 인덱스를 요청하면 \u003ccode\u003eIndexError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003ch4\u003e4. \u003ccode\u003ebytes\u003c/code\u003e 객체를 생성하는 최적화된 이터레이터 메서드 추가 (Addition of optimised iterator methods that produce bytes objects)\u003c/h4\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003ebytes\u003c/code\u003e, \u003ccode\u003ebytearray\u003c/code\u003e, \u003ccode\u003ememoryview\u003c/code\u003e에 정수 대신 길이가 1인 \u003ccode\u003ebytes\u003c/code\u003e 객체를 생성하는 최적화된 \u003ccode\u003eiterbytes\u003c/code\u003e 메서드를 추가할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor x in data.iterbytes(): # x는 정수 대신 길이가 1인 `bytes` 객체\n    # ...\n\n\u003e\u003e\u003e tuple(b\"ABC\".iterbytes())\n(b'A', b'B', b'C')\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e설계 논의 (Design discussion)\u003c/h3\u003e\n\u003ch4\u003e0으로 초기화된 시퀀스를 생성하기 위해 시퀀스 반복에 의존하지 않는 이유 (Why not rely on sequence repetition to create zero-initialised sequences?)\u003c/h4\u003e\n\u003cp\u003e0으로 초기화된 시퀀스는 시퀀스 반복을 통해 생성할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e b'\\x00' * 3\nb'\\x00\\x00\\x00'\n\u003e\u003e\u003e bytearray(b'\\x00') * 3\nbytearray(b'\\x00\\x00\\x00')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 \u003ccode\u003ebytearray\u003c/code\u003e 타입이 처음 설계될 때도 마찬가지였으며, 타입 생성자에 명시적인 지원을 추가하기로 결정되었습니다. 그 후 변경 불가능한 \u003ccode\u003ebytes\u003c/code\u003e 타입은 PEP 3137에서 도입될 때 그 기능을 상속받았습니다. 이 PEP는 원래의 설계 결정을 재검토하는 것이 아니라, 사용자들이 바이너리 시퀀스 생성자의 현재 동작을 때때로 혼란스러워하기 때문에 표기법을 변경하는 것입니다. 특히, \u003ccode\u003ebytes(x)\u003c/code\u003e (여기서 \u003ccode\u003ex\u003c/code\u003e는 정수)가 이 PEP의 \u003ccode\u003ebytes.fromint(x)\u003c/code\u003e 제안처럼 동작해야 한다는 합리적인 주장이 있습니다. 두 동작을 별도의 클래스 메서드로 제공함으로써 이러한 모호성을 피합니다.\u003c/p\u003e\n\u003ch4\u003e현재 해결 방법 (Current Workarounds)\u003c/h4\u003e\n\u003cp\u003e거의 10년이 지난 후에도 바이트 이터레이션(byte iteration)을 위한 최선의 해결책에 대한 합의는 없는 것으로 보입니다.\u003c/p\u003e\n\u003ch4\u003e원래 제안되었던 빌트인 함수 생략 (Omitting the originally proposed builtin function)\u003c/h4\u003e\n\u003cp\u003e스티어링 위원회(Steering Council)에 제출되었을 때, 이 PEP는 \u003ccode\u003ebytes.fromint\u003c/code\u003e와 동일한 동작을 하는 \u003ccode\u003ebchr\u003c/code\u003e 빌트인 함수를 도입할 것을 제안하여 Python 2의 \u003ccode\u003eord\u003c/code\u003e / \u003ccode\u003echr\u003c/code\u003e / \u003ccode\u003eunichr\u003c/code\u003e 트리오를 다른 명명 체계(\u003ccode\u003eord\u003c/code\u003e / \u003ccode\u003ebchr\u003c/code\u003e / \u003ccode\u003echr\u003c/code\u003e)로 재현했습니다. SC는 동일한 작업을 수행하는 두 가지 방법을 제공할 만큼 이 기능이 충분히 자주 필요하다고 생각하지 않았으며, 특히 그중 하나가 새로운 빌트인 함수일 때는 더욱 그렇다고 지적했습니다. 따라서 이 제안 부분은 \u003ccode\u003ebytes.fromint\u003c/code\u003e 대체 생성자와 중복되므로 삭제되었습니다. 이 메서드를 자주 사용하는 개발자는 대신 자신만의 \u003ccode\u003ebchr = bytes.fromint\u003c/code\u003e 별칭을 정의할 수 있습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Draft] PEP 467 - Minor API improvements for binary sequences\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:14:25+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>