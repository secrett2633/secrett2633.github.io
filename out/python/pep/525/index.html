<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-19cfc001fdac3337.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1098<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 525 - Asynchronous Generators</h1><div class="page__meta"><time dateTime="2025-09-26 23:17:46+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0525/">PEP 525 - Asynchronous Generators</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 28-Jul-2016</p>
</blockquote>
<h2>PEP 525 – 비동기 제너레이터 (Asynchronous Generators)</h2>
<h3>개요 (Abstract)</h3>
<p>PEP 492는 Python 3.5에 네이티브 코루틴(native coroutines)과 <code>async</code>/<code>await</code> 문법에 대한 지원을 도입했습니다. 이 PEP 525는 비동기 제너레이터(asynchronous generators) 지원을 추가하여 Python의 비동기 기능을 확장할 것을 제안합니다.</p>
<h3>배경 및 목표 (Rationale and Goals)</h3>
<p>PEP 255에서 도입된 일반 제너레이터(regular generators)는 복잡한 데이터 생산자를 우아하게 작성하고 이를 이터레이터(iterator)처럼 동작하게 하는 방법을 제공했습니다.</p>
<p>하지만 현재 비동기 이터레이션 프로토콜(<code>async for</code>)에는 이와 동등한 개념이 없습니다. 이로 인해 비동기 데이터 생산자를 작성하는 것이 불필요하게 복잡해지는데, <code>async for</code> 문에서 사용하려면 <code>__aiter__</code>와 <code>__anext__</code>를 구현하는 클래스를 정의해야 하기 때문입니다.</p>
<p>본 제안에 PEP 255의 목표와 배경을 비동기 실행 사례에 적용하면 그대로 유효합니다.</p>
<p>성능은 이 제안의 추가적인 강점입니다. 참조 구현(reference implementation) 테스트 결과, 비동기 제너레이터는 비동기 이터레이터(asynchronous iterator)로 구현된 동일한 기능보다 2배 더 빠릅니다.</p>
<p>코드 품질 개선의 예시로, 다음은 주어진 딜레이(delay)로 숫자를 출력하는 클래스입니다.</p>
<pre><code class="language-python">class Ticker:
    """Yield numbers from 0 to `to` every `delay` seconds."""
    def __init__(self, delay, to):
        self.delay = delay
        self.i = 0
        self.to = to

    def __aiter__(self):
        return self

    async def __anext__(self):
        i = self.i
        if i >= self.to:
            raise StopAsyncIteration
        self.i += 1
        if i:
            await asyncio.sleep(self.delay)
        return i
</code></pre>
<p>동일한 기능을 훨씬 간단한 비동기 제너레이터로 구현할 수 있습니다.</p>
<pre><code class="language-python">async def ticker(delay, to):
    """Yield numbers from 0 to `to` every `delay` seconds."""
    for i in range(to):
        yield i
        await asyncio.sleep(delay)
</code></pre>
<h3>사양 (Specification)</h3>
<p>이 제안은 Python에 비동기 제너레이터 개념을 도입합니다.
이 사양은 Python의 제너레이터와 코루틴(PEP 342, PEP 380, PEP 492) 구현에 대한 지식을 전제로 합니다.</p>
<h4>비동기 제너레이터 (Asynchronous Generators)</h4>
<p>Python 제너레이터는 하나 이상의 <code>yield</code> 표현식을 포함하는 모든 함수입니다.</p>
<pre><code class="language-python">def func(): # 일반 함수
    return

def genfunc(): # 제너레이터 함수
    yield
</code></pre>
<p>비동기 제너레이터를 정의하기 위해 동일한 접근 방식을 사용할 것을 제안합니다.</p>
<pre><code class="language-python">async def coro(): # 코루틴 함수
    await smth()

async def asyncgen(): # 비동기 제너레이터 함수
    await smth()
    yield 42
</code></pre>
<p>비동기 제너레이터 함수를 호출한 결과는 PEP 492에 정의된 비동기 이터레이션 프로토콜(asynchronous iteration protocol)을 구현하는 비동기 제너레이터 객체입니다.</p>
<p>비동기 제너레이터에 비어있지 않은 <code>return</code> 문이 있는 경우 <code>SyntaxError</code>가 발생합니다.</p>
<h4>비동기 이터레이션 프로토콜 지원 (Support for Asynchronous Iteration Protocol)</h4>
<p>이 프로토콜은 두 가지 특별한 메서드를 구현해야 합니다.</p>
<ul>
<li>비동기 이터레이터(asynchronous iterator)를 반환하는 <code>__aiter__</code> 메서드.</li>
<li>값을 "yield"하기 위해 <code>StopIteration</code> 예외를 사용하고, 이터레이션의 끝을 알리기 위해 <code>StopAsyncIteration</code> 예외를 사용하는 <code>awaitable</code> 객체를 반환하는 <code>__anext__</code> 메서드.</li>
</ul>
<p>비동기 제너레이터는 이 두 메서드를 모두 정의합니다. 간단한 비동기 제너레이터를 수동으로 이터레이션해봅시다.</p>
<pre><code class="language-python">async def genfunc():
    yield 1
    yield 2

gen = genfunc()
assert gen.__aiter__() is gen
assert await gen.__anext__() == 1
assert await gen.__anext__() == 2
await gen.__anext__() # 이 줄은 StopAsyncIteration을 발생시킵니다.
</code></pre>
<h4>종료 (Finalization)</h4>
<p>PEP 492는 코루틴을 실행하기 위해 이벤트 루프(event loop) 또는 스케줄러(scheduler)를 필요로 합니다. 비동기 제너레이터는 코루틴에서 사용하도록 설계되었으므로, 실행 및 종료(finalize)하기 위해서도 이벤트 루프가 필요합니다.</p>
<p>비동기 제너레이터는 <code>try..finally</code> 블록과 <code>async with</code>를 가질 수 있습니다. 부분적으로만 이터레이션되고 가비지 컬렉션(garbage collected) 되더라도 제너레이터가 안전하게 종료될 수 있도록 보장하는 것이 중요합니다. 예를 들어:</p>
<pre><code class="language-python">async def square_series(con, to):
    async with con.transaction():
        cursor = con.cursor(
            'SELECT generate_series(0, $1) AS i', to)
        async for row in cursor:
            yield row['i'] ** 2

async for i in square_series(con, 1000):
    if i == 100:
        break
</code></pre>
<p>위 코드는 <code>async with</code>를 사용하여 트랜잭션(transaction) 내에서 데이터베이스 커서(cursor)를 이터레이션하는 비동기 제너레이터를 정의합니다. 이 제너레이터는 <code>async for</code>를 통해 이터레이션되며, 특정 시점에서 이터레이션이 중단됩니다.</p>
<p><code>square_series()</code> 제너레이터는 가비지 컬렉션될 것이며, 제너레이터를 비동기적으로 닫는 메커니즘이 없으면 Python 인터프리터는 아무것도 할 수 없습니다.</p>
<p>이 문제를 해결하기 위해 다음을 제안합니다.</p>
<ul>
<li>
<p>비동기 제너레이터에 특별한 <code>awaitable</code>을 반환하는 <code>aclose</code> 메서드를 구현합니다. 이 메서드를 <code>await</code>하면 정지된 제너레이터에 <code>GeneratorExit</code> 예외를 발생시키고, <code>GeneratorExit</code> 또는 <code>StopAsyncIteration</code>이 발생할 때까지 이터레이션합니다.
이는 일반 Python 제너레이터에 <code>close()</code> 메서드가 하는 일과 매우 유사하지만, <code>aclose()</code>를 실행하려면 이벤트 루프가 필요하다는 점이 다릅니다.</p>
</li>
<li>
<p>비동기 제너레이터가 <code>finally</code> 블록에서 <code>yield</code> 표현식을 실행할 때 <code>RuntimeError</code>를 발생시킵니다 (그러나 <code>await</code>를 사용하는 것은 괜찮습니다).</p>
<pre><code class="language-python">async def gen():
    try:
        yield
    finally:
        await asyncio.sleep(1) # 'await' 사용 가능.
        yield # 'yield' 사용 불가,
              # 이 줄은 RuntimeError를 발생시킵니다.
</code></pre>
</li>
<li>
<p><code>sys</code> 모듈에 <code>set_asyncgen_hooks()</code> 및 <code>get_asyncgen_hooks()</code> 두 가지 새로운 메서드를 추가합니다.</p>
<p><code>sys.set_asyncgen_hooks()</code>의 아이디어는 이벤트 루프가 비동기 제너레이터의 이터레이션 및 종료를 가로챌 수 있도록 하여, 최종 사용자가 종료 문제에 신경 쓸 필요 없이 모든 것이 작동하도록 하는 것입니다.</p>
<p><code>sys.set_asyncgen_hooks()</code>는 두 가지 인수를 허용합니다.</p>
<ul>
<li><code>firstiter</code>: 비동기 제너레이터가 처음 이터레이션될 때 호출될 호출 가능 객체(callable).</li>
<li><code>finalizer</code>: 비동기 제너레이터가 가비지 컬렉션되기 직전에 호출될 호출 가능 객체.</li>
</ul>
<p>비동기 제너레이터가 처음 이터레이션될 때, 현재 <code>finalizer</code>에 대한 참조를 저장합니다.
비동기 제너레이터가 가비지 컬렉션되기 직전에 캐시된 <code>finalizer</code>를 호출합니다. <code>finalizer</code>는 이터레이션이 시작될 때 활성화된 루프와 함께 <code>aclose()</code> 호출을 스케줄링할 것이라고 가정합니다.</p>
<p>예를 들어, <code>asyncio</code>가 비동기 제너레이터의 안전한 종료를 허용하도록 수정되는 방법은 다음과 같습니다.</p>
<pre><code class="language-python"># asyncio/base_events.py
class BaseEventLoop:
    def run_forever(self):
        ...
        old_hooks = sys.get_asyncgen_hooks()
        sys.set_asyncgen_hooks(finalizer=self._finalize_asyncgen)
        try:
            ...
        finally:
            sys.set_asyncgen_hooks(*old_hooks)
        ...

    def _finalize_asyncgen(self, gen):
        self.create_task(gen.aclose())
</code></pre>
<p>두 번째 인수 <code>firstiter</code>는 이벤트 루프가 자체 제어하에 인스턴스화된 비동기 제너레이터의 약한 집합(weak set)을 유지 관리할 수 있도록 합니다. 이를 통해 모든 열려있는 제너레이터를 안전하게 종료하고 이벤트 루프를 닫는 "종료(shutdown)" 메커니즘을 구현할 수 있습니다.</p>
<p><code>sys.set_asyncgen_hooks()</code>는 스레드별(thread-specific)이므로, 여러 이벤트 루프가 병렬 스레드에서 안전하게 사용할 수 있습니다.</p>
<p><code>sys.get_asyncgen_hooks()</code>는 <code>firstiter</code> 및 <code>finalizer</code> 필드를 가진 namedtuple과 유사한 구조를 반환합니다.</p>
</li>
</ul>
<h4><code>asyncio</code></h4>
<p><code>asyncio</code> 이벤트 루프는 <code>sys.set_asyncgen_hooks()</code> API를 사용하여 스케줄링된 모든 비동기 제너레이터의 약한 집합을 유지하고, 제너레이터가 가비지 컬렉션될 시점에 <code>aclose()</code> 코루틴 메서드를 스케줄링합니다.</p>
<p><code>asyncio</code> 프로그램이 스케줄링된 모든 비동기 제너레이터를 안정적으로 종료할 수 있도록 하기 위해, 새로운 이벤트 루프 코루틴 메서드 <code>loop.shutdown_asyncgens()</code>를 추가할 것을 제안합니다. 이 메서드는 현재 열려있는 모든 비동기 제너레이터를 <code>aclose()</code> 호출로 닫도록 스케줄링합니다.</p>
<p><code>loop.shutdown_asyncgens()</code> 메서드를 호출한 후, 이벤트 루프는 새로운 비동기 제너레이터가 처음 이터레이션될 때마다 경고를 발생시킬 것입니다. 이는 모든 비동기 제너레이터를 종료하도록 요청한 후에는 프로그램이 새로운 비동기 제너레이터를 이터레이션하는 코드를 실행해서는 안 된다는 아이디어입니다.</p>
<p><code>shutdown_asyncgens</code> 코루틴을 사용하는 예시입니다.</p>
<pre><code class="language-python">try:
    loop.run_forever()
finally:
    loop.run_until_complete(loop.shutdown_asyncgens())
    loop.close()
</code></pre>
<h4>비동기 제너레이터 객체 (Asynchronous Generator Object)</h4>
<p>이 객체는 표준 Python 제너레이터 객체를 모델로 합니다. 본질적으로 비동기 제너레이터의 동작은 동기 제너레이터의 동작을 복제하도록 설계되었으며, 유일한 차이점은 API가 비동기라는 점입니다.</p>
<p>다음 메서드와 속성이 정의됩니다.</p>
<ul>
<li>
<p><code>agen.__aiter__()</code>: <code>agen</code>을 반환합니다.</p>
</li>
<li>
<p><code>agen.__anext__()</code>: <code>await</code>될 때 하나의 비동기 제너레이터 이터레이션을 수행하는 <code>awaitable</code>을 반환합니다.</p>
</li>
<li>
<p><code>agen.asend(val)</code>: <code>val</code> 객체를 <code>agen</code> 제너레이터로 푸시하는 <code>awaitable</code>을 반환합니다. <code>agen</code>이 아직 이터레이션되지 않은 경우, <code>val</code>은 <code>None</code>이어야 합니다.</p>
<p>예시:</p>
<pre><code class="language-python">async def gen():
    await asyncio.sleep(0.1)
    v = yield 42
    print(v)
    await asyncio.sleep(0.2)

g = gen()
await g.asend(None) # 0.1초 동안 sleep 후 42를 반환합니다.
await g.asend('hello') # 'hello'를 출력하고
                       # StopAsyncIteration을 발생시킵니다.
                       # (0.2초 동안 sleep 후)
</code></pre>
</li>
<li>
<p><code>agen.athrow(typ, [val, [tb]])</code>: 예외를 <code>agen</code> 제너레이터로 던지는 <code>awaitable</code>을 반환합니다.</p>
<p>예시:</p>
<pre><code class="language-python">async def gen():
    try:
        await asyncio.sleep(0.1)
        yield 'hello'
    except ZeroDivisionError:
        await asyncio.sleep(0.2)
        yield 'world'

g = gen()
v = await g.asend(None)
print(v) # 0.1초 동안 sleep 후 'hello'를 출력합니다.
v = await g.athrow(ZeroDivisionError)
print(v) # 0.2초 동안 sleep 후 'world'를 출력합니다.
</code></pre>
</li>
<li>
<p><code>agen.aclose()</code>: <code>GeneratorExit</code> 예외를 제너레이터로 던지는 <code>awaitable</code>을 반환합니다. <code>awaitable</code>은 <code>agen</code>이 예외를 처리했다면 <code>yield</code>된 값을 반환할 수 있고, 그렇지 않으면 <code>agen</code>이 닫히고 예외는 호출자(caller)에게 다시 전파됩니다.</p>
</li>
<li>
<p><code>agen.__name__</code> 및 <code>agen.__qualname__</code>: 읽고 쓸 수 있는 이름 및 정규화된 이름(qualified name) 속성입니다.</p>
</li>
<li>
<p><code>agen.ag_await</code>: <code>agen</code>이 현재 <code>await</code>하고 있는 객체 또는 <code>None</code>입니다. 이는 제너레이터의 <code>gi_yieldfrom</code> 및 코루틴의 <code>cr_await</code>와 유사합니다.</p>
</li>
<li>
<p><code>agen.ag_frame</code>, <code>agen.ag_running</code>, <code>agen.ag_code</code>: 표준 제너레이터의 유사한 속성과 동일한 방식으로 정의됩니다.</p>
</li>
</ul>
<p><code>StopIteration</code>과 <code>StopAsyncIteration</code>은 비동기 제너레이터 밖으로 전파되지 않으며, <code>RuntimeError</code>로 대체됩니다.</p>
<h4>구현 세부 정보 (Implementation Details)</h4>
<p>비동기 제너레이터 객체(<code>PyAsyncGenObject</code>)는 <code>PyGenObject</code>와 구조 레이아웃을 공유합니다. 또한, 참조 구현은 세 가지 새로운 객체를 도입합니다.</p>
<ul>
<li><code>PyAsyncGenASend</code>: <code>__anext__</code> 및 <code>asend()</code> 메서드를 구현하는 <code>awaitable</code> 객체입니다.</li>
<li><code>PyAsyncGenAThrow</code>: <code>athrow()</code> 및 <code>aclose()</code> 메서드를 구현하는 <code>awaitable</code> 객체입니다.</li>
<li><code>_PyAsyncGenWrappedValue</code>: 비동기 제너레이터에서 직접 <code>yield</code>된 모든 객체는 암시적으로 이 구조로 묶입니다. 이를 통해 제너레이터 구현은 일반 이터레이션 프로토콜을 사용하여 <code>yield</code>된 객체와 비동기 이터레이션 프로토콜을 사용하여 <code>yield</code>된 객체를 분리할 수 있습니다.</li>
</ul>
<p><code>PyAsyncGenASend</code>와 <code>PyAsyncGenAThrow</code>는 <code>awaitable</code> 객체이며(<code>__await__</code> 메서드가 <code>self</code>를 반환함), 코루틴과 유사한 객체입니다(<code>__iter__</code>, <code>__next__</code>, <code>send()</code>, <code>throw()</code> 메서드를 구현함). 본질적으로 이들은 비동기 제너레이터가 어떻게 이터레이션되는지를 제어합니다.</p>
<h5><code>PyAsyncGenASend</code> 및 <code>PyAsyncGenAThrow</code></h5>
<p><code>PyAsyncGenASend</code>는 <code>__anext__</code> 및 <code>asend()</code> 메서드를 구동하고 비동기 이터레이션 프로토콜을 구현하는 코루틴과 유사한 객체입니다.
<code>agen.asend(val)</code> 및 <code>agen.__anext__()</code>는 <code>PyAsyncGenASend</code> 인스턴스(부모 <code>agen</code> 객체에 대한 참조를 유지)를 반환합니다.</p>
<p>데이터 흐름은 다음과 같이 정의됩니다.</p>
<ul>
<li><code>PyAsyncGenASend.send(val)</code>이 처음 호출되면, <code>val</code>은 부모 <code>agen</code> 객체로 푸시됩니다(<code>PyGenObject</code>의 기존 기능을 사용).</li>
<li><code>PyAsyncGenASend</code> 객체에 대한 후속 이터레이션은 <code>None</code>을 <code>agen</code>으로 푸시합니다.</li>
<li><code>_PyAsyncGenWrappedValue</code> 객체가 <code>yield</code>되면, 언박싱(unboxed)되고, 래핑되지 않은(unwrapped) 값을 인수로 하는 <code>StopIteration</code> 예외가 발생합니다.</li>
<li><code>PyAsyncGenASend.throw(*exc)</code>가 처음 호출되면, <code>*exc</code>가 부모 <code>agen</code> 객체로 던져집니다.</li>
<li><code>PyAsyncGenASend</code> 객체에 대한 후속 이터레이션은 <code>None</code>을 <code>agen</code>으로 푸시합니다.</li>
<li><code>_PyAsyncGenWrappedValue</code> 객체가 <code>yield</code>되면, 언박싱되고, 래핑되지 않은 값을 인수로 하는 <code>StopIteration</code> 예외가 발생합니다.</li>
<li>비동기 제너레이터의 <code>return</code> 문은 <code>StopAsyncIteration</code> 예외를 발생시키며, 이는 <code>PyAsyncGenASend.send()</code> 및 <code>PyAsyncGenASend.throw()</code> 메서드를 통해 전파됩니다.</li>
</ul>
<p><code>PyAsyncGenAThrow</code>는 <code>PyAsyncGenASend</code>와 매우 유사합니다. 유일한 차이점은 <code>PyAsyncGenAThrow.send()</code>가 처음 호출될 때 부모 <code>agen</code> 객체에 예외를 던진다는 것입니다(값을 푸시하는 대신).</p>
<h4>새로운 표준 라이브러리 함수 및 타입 (New Standard Library Functions and Types)</h4>
<ul>
<li><code>types.AsyncGeneratorType</code> – 비동기 제너레이터 객체의 타입입니다.</li>
<li><code>sys.set_asyncgen_hooks()</code> 및 <code>sys.get_asyncgen_hooks()</code> 메서드는 이벤트 루프에서 비동기 제너레이터의 종료자(finalizers) 및 이터레이션 가로채기(interceptors)를 설정하는 데 사용됩니다.</li>
<li><code>inspect.isasyncgen()</code> 및 <code>inspect.isasyncgenfunction()</code> 인트로스펙션(introspection) 함수.</li>
<li><code>asyncio</code> 이벤트 루프의 새로운 메서드: <code>loop.shutdown_asyncgens()</code>.</li>
<li>새로운 <code>collections.abc.AsyncGenerator</code> 추상 기본 클래스(abstract base class).</li>
</ul>
<h4>하위 호환성 (Backwards Compatibility)</h4>
<p>이 제안은 완벽하게 하위 호환됩니다.
Python 3.5에서는 <code>yield</code> 표현식이 포함된 <code>async def</code> 함수를 정의하는 것이 <code>SyntaxError</code>이므로, 3.6에서 비동기 제너레이터를 도입하는 것은 안전합니다.</p>
<h4>성능 (Performance)</h4>
<h5>일반 제너레이터 (Regular Generators)</h5>
<p>일반 제너레이터에는 성능 저하가 없습니다. 다음 마이크로 벤치마크는 CPython에서 비동기 제너레이터 유무에 관계없이 동일한 속도로 실행됩니다.</p>
<pre><code class="language-python">def gen():
    i = 0
    while i &#x3C; 100000000:
        yield i
        i += 1
list(gen())
</code></pre>
<h5>비동기 이터레이터 대비 개선점 (Improvements over asynchronous iterators)</h5>
<p>다음 마이크로 벤치마크는 비동기 제너레이터가 순수 Python으로 구현된 비동기 이터레이터보다 약 2.3배 빠름을 보여줍니다.</p>
<pre><code class="language-python">N = 10 ** 7

async def agen():
    for i in range(N):
        yield i

class AIter:
    def __init__(self):
        self.i = 0
    def __aiter__(self):
        return self
    async def __anext__(self):
        i = self.i
        if i >= N:
            raise StopAsyncIteration
        self.i += 1
        return i
</code></pre>
<h3>설계 고려 사항 (Design Considerations)</h3>
<h4><code>aiter()</code> 및 <code>anext()</code> 내장 함수 (aiter() and anext() builtins)</h4>
<p>원래 PEP 492는 <code>__aiter__</code>를 <code>awaitable</code> 객체를 반환해야 하는 메서드로 정의하여 비동기 이터레이터를 생성하도록 했습니다.
그러나 CPython 3.5.2에서 <code>__aiter__</code>는 비동기 이터레이터를 직접 반환하도록 재정의되었습니다. 하위 호환성을 깨는 것을 피하기 위해, Python 3.6에서는 두 가지 방식 모두를 지원하며, <code>__aiter__</code>가 여전히 <code>awaitable</code>을 반환할 수 있지만 <code>DeprecationWarning</code>이 발행되도록 결정되었습니다.</p>
<p>Python 3.6에서 <code>__aiter__</code>의 이러한 이중적인 특성 때문에 <code>aiter()</code> 내장 함수의 동기 구현을 추가할 수 없습니다. 따라서 Python 3.7까지 기다릴 것을 제안합니다.</p>
<h4>비동기 리스트/딕셔너리/세트 컴프리헨션 (Asynchronous list/dict/set comprehensions)</h4>
<p>비동기 컴프리헨션(comprehensions)의 문법은 비동기 제너레이터 메커니즘과 관련이 없으며, 별도의 PEP에서 고려되어야 합니다.</p>
<h4>비동기 <code>yield from</code> (Asynchronous yield from)</h4>
<p>비동기 제너레이터에 <code>yield from</code> 지원을 구현하는 것이 이론적으로 가능하지만, 제너레이터 구현을 심각하게 재설계해야 합니다.
<code>yield from</code>은 비동기 제너레이터에 덜 중요합니다. 코루틴 위에 다른 코루틴 프로토콜을 구현하는 메커니즘을 제공할 필요가 없기 때문입니다. 비동기 제너레이터를 구성하기 위해 간단한 <code>async for</code> 루프를 사용할 수 있습니다.</p>
<pre><code class="language-python">async def g1():
    yield 1
    yield 2

async def g2():
    async for v in g1():
        yield v
</code></pre>
<h4><code>asend()</code> 및 <code>athrow()</code> 메서드가 필요한 이유 (Why the asend() and athrow() methods are necessary)</h4>
<p>이 메서드들은 <code>contextlib.contextmanager</code>와 유사한 개념을 비동기 제너레이터를 사용하여 구현할 수 있게 합니다. 예를 들어, 제안된 설계로 다음 패턴을 구현할 수 있습니다.</p>
<pre><code class="language-python">@async_context_manager
async def ctx():
    await open()
    try:
        yield
    finally:
        await close()

async with ctx():
    await ...
</code></pre>
<p>또 다른 이유는 <code>__anext__</code> 객체에서 반환된 객체를 사용하여 비동기 제너레이터로 데이터를 푸시하고 예외를 던지는 것이 가능하지만, 이를 올바르게 수행하기는 어렵다는 것입니다. 명시적인 <code>asend()</code> 및 <code>athrow()</code>를 추가하면 이를 안전하게 수행할 수 있는 길을 열어줄 것입니다.</p>
<p>구현 측면에서 <code>asend()</code>는 <code>__anext__</code>의 약간 더 일반적인 버전이며, <code>athrow()</code>는 <code>aclose()</code>와 매우 유사합니다. 따라서 비동기 제너레이터에 이러한 메서드를 정의해도 추가적인 복잡성은 발생하지 않습니다.</p>
<h3>예시 (Example)</h3>
<p>현재 참조 구현을 사용한 작동 예시 (0부터 9까지의 숫자를 1초 간격으로 출력합니다):</p>
<pre><code class="language-python">async def ticker(delay, to):
    for i in range(to):
        yield i
        await asyncio.sleep(delay)

async def run():
    async for i in ticker(1, 10):
        print(i)

import asyncio
loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(run())
finally:
    loop.close()
</code></pre>
<h3>승인 (Acceptance)</h3>
<p>PEP 525는 2016년 9월 6일 Guido에 의해 승인되었습니다.</p>
<h3>구현 (Implementation)</h3>
<p>구현은 이슈 28003에서 추적됩니다. 참조 구현 Git 저장소는에서 확인할 수 있습니다.</p>
<h3>참고 자료 (References)</h3>
<p>https://github.com/1st1/cpython/tree/async_gen
https://mail.python.org/pipermail/python-dev/2016-September/146267.html
http://bugs.python.org/issue28003</p>
<h3>감사 (Acknowledgments)</h3>
<p>이 PEP에 대한 피드백, 코드 검토 및 토론에 대해 Guido van Rossum, Victor Stinner, Elvis Pranskevichus, Nathaniel Smith, Łukasz Langa, Andrew Svetlov 및 기타 여러 사람들에게 감사드립니다.</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-19cfc001fdac3337.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/525\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"FeyCvJug7In7AgUZlfHUx\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/525/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/525\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"525\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/525\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T63b6,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0525/\"\u003ePEP 525 - Asynchronous Generators\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 28-Jul-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 525 – 비동기 제너레이터 (Asynchronous Generators)\u003c/h2\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003ePEP 492는 Python 3.5에 네이티브 코루틴(native coroutines)과 \u003ccode\u003easync\u003c/code\u003e/\u003ccode\u003eawait\u003c/code\u003e 문법에 대한 지원을 도입했습니다. 이 PEP 525는 비동기 제너레이터(asynchronous generators) 지원을 추가하여 Python의 비동기 기능을 확장할 것을 제안합니다.\u003c/p\u003e\n\u003ch3\u003e배경 및 목표 (Rationale and Goals)\u003c/h3\u003e\n\u003cp\u003ePEP 255에서 도입된 일반 제너레이터(regular generators)는 복잡한 데이터 생산자를 우아하게 작성하고 이를 이터레이터(iterator)처럼 동작하게 하는 방법을 제공했습니다.\u003c/p\u003e\n\u003cp\u003e하지만 현재 비동기 이터레이션 프로토콜(\u003ccode\u003easync for\u003c/code\u003e)에는 이와 동등한 개념이 없습니다. 이로 인해 비동기 데이터 생산자를 작성하는 것이 불필요하게 복잡해지는데, \u003ccode\u003easync for\u003c/code\u003e 문에서 사용하려면 \u003ccode\u003e__aiter__\u003c/code\u003e와 \u003ccode\u003e__anext__\u003c/code\u003e를 구현하는 클래스를 정의해야 하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e본 제안에 PEP 255의 목표와 배경을 비동기 실행 사례에 적용하면 그대로 유효합니다.\u003c/p\u003e\n\u003cp\u003e성능은 이 제안의 추가적인 강점입니다. 참조 구현(reference implementation) 테스트 결과, 비동기 제너레이터는 비동기 이터레이터(asynchronous iterator)로 구현된 동일한 기능보다 2배 더 빠릅니다.\u003c/p\u003e\n\u003cp\u003e코드 품질 개선의 예시로, 다음은 주어진 딜레이(delay)로 숫자를 출력하는 클래스입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Ticker:\r\n    \"\"\"Yield numbers from 0 to `to` every `delay` seconds.\"\"\"\r\n    def __init__(self, delay, to):\r\n        self.delay = delay\r\n        self.i = 0\r\n        self.to = to\r\n\r\n    def __aiter__(self):\r\n        return self\r\n\r\n    async def __anext__(self):\r\n        i = self.i\r\n        if i \u003e= self.to:\r\n            raise StopAsyncIteration\r\n        self.i += 1\r\n        if i:\r\n            await asyncio.sleep(self.delay)\r\n        return i\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e동일한 기능을 훨씬 간단한 비동기 제너레이터로 구현할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def ticker(delay, to):\r\n    \"\"\"Yield numbers from 0 to `to` every `delay` seconds.\"\"\"\r\n    for i in range(to):\r\n        yield i\r\n        await asyncio.sleep(delay)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e사양 (Specification)\u003c/h3\u003e\n\u003cp\u003e이 제안은 Python에 비동기 제너레이터 개념을 도입합니다.\r\n이 사양은 Python의 제너레이터와 코루틴(PEP 342, PEP 380, PEP 492) 구현에 대한 지식을 전제로 합니다.\u003c/p\u003e\n\u003ch4\u003e비동기 제너레이터 (Asynchronous Generators)\u003c/h4\u003e\n\u003cp\u003ePython 제너레이터는 하나 이상의 \u003ccode\u003eyield\u003c/code\u003e 표현식을 포함하는 모든 함수입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef func(): # 일반 함수\r\n    return\r\n\r\ndef genfunc(): # 제너레이터 함수\r\n    yield\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e비동기 제너레이터를 정의하기 위해 동일한 접근 방식을 사용할 것을 제안합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def coro(): # 코루틴 함수\r\n    await smth()\r\n\r\nasync def asyncgen(): # 비동기 제너레이터 함수\r\n    await smth()\r\n    yield 42\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e비동기 제너레이터 함수를 호출한 결과는 PEP 492에 정의된 비동기 이터레이션 프로토콜(asynchronous iteration protocol)을 구현하는 비동기 제너레이터 객체입니다.\u003c/p\u003e\n\u003cp\u003e비동기 제너레이터에 비어있지 않은 \u003ccode\u003ereturn\u003c/code\u003e 문이 있는 경우 \u003ccode\u003eSyntaxError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003ch4\u003e비동기 이터레이션 프로토콜 지원 (Support for Asynchronous Iteration Protocol)\u003c/h4\u003e\n\u003cp\u003e이 프로토콜은 두 가지 특별한 메서드를 구현해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e비동기 이터레이터(asynchronous iterator)를 반환하는 \u003ccode\u003e__aiter__\u003c/code\u003e 메서드.\u003c/li\u003e\n\u003cli\u003e값을 \"yield\"하기 위해 \u003ccode\u003eStopIteration\u003c/code\u003e 예외를 사용하고, 이터레이션의 끝을 알리기 위해 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e 예외를 사용하는 \u003ccode\u003eawaitable\u003c/code\u003e 객체를 반환하는 \u003ccode\u003e__anext__\u003c/code\u003e 메서드.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e비동기 제너레이터는 이 두 메서드를 모두 정의합니다. 간단한 비동기 제너레이터를 수동으로 이터레이션해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def genfunc():\r\n    yield 1\r\n    yield 2\r\n\r\ngen = genfunc()\r\nassert gen.__aiter__() is gen\r\nassert await gen.__anext__() == 1\r\nassert await gen.__anext__() == 2\r\nawait gen.__anext__() # 이 줄은 StopAsyncIteration을 발생시킵니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e종료 (Finalization)\u003c/h4\u003e\n\u003cp\u003ePEP 492는 코루틴을 실행하기 위해 이벤트 루프(event loop) 또는 스케줄러(scheduler)를 필요로 합니다. 비동기 제너레이터는 코루틴에서 사용하도록 설계되었으므로, 실행 및 종료(finalize)하기 위해서도 이벤트 루프가 필요합니다.\u003c/p\u003e\n\u003cp\u003e비동기 제너레이터는 \u003ccode\u003etry..finally\u003c/code\u003e 블록과 \u003ccode\u003easync with\u003c/code\u003e를 가질 수 있습니다. 부분적으로만 이터레이션되고 가비지 컬렉션(garbage collected) 되더라도 제너레이터가 안전하게 종료될 수 있도록 보장하는 것이 중요합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def square_series(con, to):\r\n    async with con.transaction():\r\n        cursor = con.cursor(\r\n            'SELECT generate_series(0, $1) AS i', to)\r\n        async for row in cursor:\r\n            yield row['i'] ** 2\r\n\r\nasync for i in square_series(con, 1000):\r\n    if i == 100:\r\n        break\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 \u003ccode\u003easync with\u003c/code\u003e를 사용하여 트랜잭션(transaction) 내에서 데이터베이스 커서(cursor)를 이터레이션하는 비동기 제너레이터를 정의합니다. 이 제너레이터는 \u003ccode\u003easync for\u003c/code\u003e를 통해 이터레이션되며, 특정 시점에서 이터레이션이 중단됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esquare_series()\u003c/code\u003e 제너레이터는 가비지 컬렉션될 것이며, 제너레이터를 비동기적으로 닫는 메커니즘이 없으면 Python 인터프리터는 아무것도 할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e이 문제를 해결하기 위해 다음을 제안합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e비동기 제너레이터에 특별한 \u003ccode\u003eawaitable\u003c/code\u003e을 반환하는 \u003ccode\u003eaclose\u003c/code\u003e 메서드를 구현합니다. 이 메서드를 \u003ccode\u003eawait\u003c/code\u003e하면 정지된 제너레이터에 \u003ccode\u003eGeneratorExit\u003c/code\u003e 예외를 발생시키고, \u003ccode\u003eGeneratorExit\u003c/code\u003e 또는 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e이 발생할 때까지 이터레이션합니다.\r\n이는 일반 Python 제너레이터에 \u003ccode\u003eclose()\u003c/code\u003e 메서드가 하는 일과 매우 유사하지만, \u003ccode\u003eaclose()\u003c/code\u003e를 실행하려면 이벤트 루프가 필요하다는 점이 다릅니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e비동기 제너레이터가 \u003ccode\u003efinally\u003c/code\u003e 블록에서 \u003ccode\u003eyield\u003c/code\u003e 표현식을 실행할 때 \u003ccode\u003eRuntimeError\u003c/code\u003e를 발생시킵니다 (그러나 \u003ccode\u003eawait\u003c/code\u003e를 사용하는 것은 괜찮습니다).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def gen():\r\n    try:\r\n        yield\r\n    finally:\r\n        await asyncio.sleep(1) # 'await' 사용 가능.\r\n        yield # 'yield' 사용 불가,\r\n              # 이 줄은 RuntimeError를 발생시킵니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003esys\u003c/code\u003e 모듈에 \u003ccode\u003eset_asyncgen_hooks()\u003c/code\u003e 및 \u003ccode\u003eget_asyncgen_hooks()\u003c/code\u003e 두 가지 새로운 메서드를 추가합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esys.set_asyncgen_hooks()\u003c/code\u003e의 아이디어는 이벤트 루프가 비동기 제너레이터의 이터레이션 및 종료를 가로챌 수 있도록 하여, 최종 사용자가 종료 문제에 신경 쓸 필요 없이 모든 것이 작동하도록 하는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esys.set_asyncgen_hooks()\u003c/code\u003e는 두 가지 인수를 허용합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efirstiter\u003c/code\u003e: 비동기 제너레이터가 처음 이터레이션될 때 호출될 호출 가능 객체(callable).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efinalizer\u003c/code\u003e: 비동기 제너레이터가 가비지 컬렉션되기 직전에 호출될 호출 가능 객체.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e비동기 제너레이터가 처음 이터레이션될 때, 현재 \u003ccode\u003efinalizer\u003c/code\u003e에 대한 참조를 저장합니다.\r\n비동기 제너레이터가 가비지 컬렉션되기 직전에 캐시된 \u003ccode\u003efinalizer\u003c/code\u003e를 호출합니다. \u003ccode\u003efinalizer\u003c/code\u003e는 이터레이션이 시작될 때 활성화된 루프와 함께 \u003ccode\u003eaclose()\u003c/code\u003e 호출을 스케줄링할 것이라고 가정합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003easyncio\u003c/code\u003e가 비동기 제너레이터의 안전한 종료를 허용하도록 수정되는 방법은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# asyncio/base_events.py\r\nclass BaseEventLoop:\r\n    def run_forever(self):\r\n        ...\r\n        old_hooks = sys.get_asyncgen_hooks()\r\n        sys.set_asyncgen_hooks(finalizer=self._finalize_asyncgen)\r\n        try:\r\n            ...\r\n        finally:\r\n            sys.set_asyncgen_hooks(*old_hooks)\r\n        ...\r\n\r\n    def _finalize_asyncgen(self, gen):\r\n        self.create_task(gen.aclose())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 번째 인수 \u003ccode\u003efirstiter\u003c/code\u003e는 이벤트 루프가 자체 제어하에 인스턴스화된 비동기 제너레이터의 약한 집합(weak set)을 유지 관리할 수 있도록 합니다. 이를 통해 모든 열려있는 제너레이터를 안전하게 종료하고 이벤트 루프를 닫는 \"종료(shutdown)\" 메커니즘을 구현할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esys.set_asyncgen_hooks()\u003c/code\u003e는 스레드별(thread-specific)이므로, 여러 이벤트 루프가 병렬 스레드에서 안전하게 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esys.get_asyncgen_hooks()\u003c/code\u003e는 \u003ccode\u003efirstiter\u003c/code\u003e 및 \u003ccode\u003efinalizer\u003c/code\u003e 필드를 가진 namedtuple과 유사한 구조를 반환합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003ccode\u003easyncio\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003easyncio\u003c/code\u003e 이벤트 루프는 \u003ccode\u003esys.set_asyncgen_hooks()\u003c/code\u003e API를 사용하여 스케줄링된 모든 비동기 제너레이터의 약한 집합을 유지하고, 제너레이터가 가비지 컬렉션될 시점에 \u003ccode\u003eaclose()\u003c/code\u003e 코루틴 메서드를 스케줄링합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003easyncio\u003c/code\u003e 프로그램이 스케줄링된 모든 비동기 제너레이터를 안정적으로 종료할 수 있도록 하기 위해, 새로운 이벤트 루프 코루틴 메서드 \u003ccode\u003eloop.shutdown_asyncgens()\u003c/code\u003e를 추가할 것을 제안합니다. 이 메서드는 현재 열려있는 모든 비동기 제너레이터를 \u003ccode\u003eaclose()\u003c/code\u003e 호출로 닫도록 스케줄링합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eloop.shutdown_asyncgens()\u003c/code\u003e 메서드를 호출한 후, 이벤트 루프는 새로운 비동기 제너레이터가 처음 이터레이션될 때마다 경고를 발생시킬 것입니다. 이는 모든 비동기 제너레이터를 종료하도록 요청한 후에는 프로그램이 새로운 비동기 제너레이터를 이터레이션하는 코드를 실행해서는 안 된다는 아이디어입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eshutdown_asyncgens\u003c/code\u003e 코루틴을 사용하는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\r\n    loop.run_forever()\r\nfinally:\r\n    loop.run_until_complete(loop.shutdown_asyncgens())\r\n    loop.close()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e비동기 제너레이터 객체 (Asynchronous Generator Object)\u003c/h4\u003e\n\u003cp\u003e이 객체는 표준 Python 제너레이터 객체를 모델로 합니다. 본질적으로 비동기 제너레이터의 동작은 동기 제너레이터의 동작을 복제하도록 설계되었으며, 유일한 차이점은 API가 비동기라는 점입니다.\u003c/p\u003e\n\u003cp\u003e다음 메서드와 속성이 정의됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.__aiter__()\u003c/code\u003e: \u003ccode\u003eagen\u003c/code\u003e을 반환합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.__anext__()\u003c/code\u003e: \u003ccode\u003eawait\u003c/code\u003e될 때 하나의 비동기 제너레이터 이터레이션을 수행하는 \u003ccode\u003eawaitable\u003c/code\u003e을 반환합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.asend(val)\u003c/code\u003e: \u003ccode\u003eval\u003c/code\u003e 객체를 \u003ccode\u003eagen\u003c/code\u003e 제너레이터로 푸시하는 \u003ccode\u003eawaitable\u003c/code\u003e을 반환합니다. \u003ccode\u003eagen\u003c/code\u003e이 아직 이터레이션되지 않은 경우, \u003ccode\u003eval\u003c/code\u003e은 \u003ccode\u003eNone\u003c/code\u003e이어야 합니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def gen():\r\n    await asyncio.sleep(0.1)\r\n    v = yield 42\r\n    print(v)\r\n    await asyncio.sleep(0.2)\r\n\r\ng = gen()\r\nawait g.asend(None) # 0.1초 동안 sleep 후 42를 반환합니다.\r\nawait g.asend('hello') # 'hello'를 출력하고\r\n                       # StopAsyncIteration을 발생시킵니다.\r\n                       # (0.2초 동안 sleep 후)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.athrow(typ, [val, [tb]])\u003c/code\u003e: 예외를 \u003ccode\u003eagen\u003c/code\u003e 제너레이터로 던지는 \u003ccode\u003eawaitable\u003c/code\u003e을 반환합니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def gen():\r\n    try:\r\n        await asyncio.sleep(0.1)\r\n        yield 'hello'\r\n    except ZeroDivisionError:\r\n        await asyncio.sleep(0.2)\r\n        yield 'world'\r\n\r\ng = gen()\r\nv = await g.asend(None)\r\nprint(v) # 0.1초 동안 sleep 후 'hello'를 출력합니다.\r\nv = await g.athrow(ZeroDivisionError)\r\nprint(v) # 0.2초 동안 sleep 후 'world'를 출력합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.aclose()\u003c/code\u003e: \u003ccode\u003eGeneratorExit\u003c/code\u003e 예외를 제너레이터로 던지는 \u003ccode\u003eawaitable\u003c/code\u003e을 반환합니다. \u003ccode\u003eawaitable\u003c/code\u003e은 \u003ccode\u003eagen\u003c/code\u003e이 예외를 처리했다면 \u003ccode\u003eyield\u003c/code\u003e된 값을 반환할 수 있고, 그렇지 않으면 \u003ccode\u003eagen\u003c/code\u003e이 닫히고 예외는 호출자(caller)에게 다시 전파됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.__name__\u003c/code\u003e 및 \u003ccode\u003eagen.__qualname__\u003c/code\u003e: 읽고 쓸 수 있는 이름 및 정규화된 이름(qualified name) 속성입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.ag_await\u003c/code\u003e: \u003ccode\u003eagen\u003c/code\u003e이 현재 \u003ccode\u003eawait\u003c/code\u003e하고 있는 객체 또는 \u003ccode\u003eNone\u003c/code\u003e입니다. 이는 제너레이터의 \u003ccode\u003egi_yieldfrom\u003c/code\u003e 및 코루틴의 \u003ccode\u003ecr_await\u003c/code\u003e와 유사합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eagen.ag_frame\u003c/code\u003e, \u003ccode\u003eagen.ag_running\u003c/code\u003e, \u003ccode\u003eagen.ag_code\u003c/code\u003e: 표준 제너레이터의 유사한 속성과 동일한 방식으로 정의됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eStopIteration\u003c/code\u003e과 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e은 비동기 제너레이터 밖으로 전파되지 않으며, \u003ccode\u003eRuntimeError\u003c/code\u003e로 대체됩니다.\u003c/p\u003e\n\u003ch4\u003e구현 세부 정보 (Implementation Details)\u003c/h4\u003e\n\u003cp\u003e비동기 제너레이터 객체(\u003ccode\u003ePyAsyncGenObject\u003c/code\u003e)는 \u003ccode\u003ePyGenObject\u003c/code\u003e와 구조 레이아웃을 공유합니다. 또한, 참조 구현은 세 가지 새로운 객체를 도입합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e: \u003ccode\u003e__anext__\u003c/code\u003e 및 \u003ccode\u003easend()\u003c/code\u003e 메서드를 구현하는 \u003ccode\u003eawaitable\u003c/code\u003e 객체입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenAThrow\u003c/code\u003e: \u003ccode\u003eathrow()\u003c/code\u003e 및 \u003ccode\u003eaclose()\u003c/code\u003e 메서드를 구현하는 \u003ccode\u003eawaitable\u003c/code\u003e 객체입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_PyAsyncGenWrappedValue\u003c/code\u003e: 비동기 제너레이터에서 직접 \u003ccode\u003eyield\u003c/code\u003e된 모든 객체는 암시적으로 이 구조로 묶입니다. 이를 통해 제너레이터 구현은 일반 이터레이션 프로토콜을 사용하여 \u003ccode\u003eyield\u003c/code\u003e된 객체와 비동기 이터레이션 프로토콜을 사용하여 \u003ccode\u003eyield\u003c/code\u003e된 객체를 분리할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e와 \u003ccode\u003ePyAsyncGenAThrow\u003c/code\u003e는 \u003ccode\u003eawaitable\u003c/code\u003e 객체이며(\u003ccode\u003e__await__\u003c/code\u003e 메서드가 \u003ccode\u003eself\u003c/code\u003e를 반환함), 코루틴과 유사한 객체입니다(\u003ccode\u003e__iter__\u003c/code\u003e, \u003ccode\u003e__next__\u003c/code\u003e, \u003ccode\u003esend()\u003c/code\u003e, \u003ccode\u003ethrow()\u003c/code\u003e 메서드를 구현함). 본질적으로 이들은 비동기 제너레이터가 어떻게 이터레이션되는지를 제어합니다.\u003c/p\u003e\n\u003ch5\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e 및 \u003ccode\u003ePyAsyncGenAThrow\u003c/code\u003e\u003c/h5\u003e\n\u003cp\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e는 \u003ccode\u003e__anext__\u003c/code\u003e 및 \u003ccode\u003easend()\u003c/code\u003e 메서드를 구동하고 비동기 이터레이션 프로토콜을 구현하는 코루틴과 유사한 객체입니다.\r\n\u003ccode\u003eagen.asend(val)\u003c/code\u003e 및 \u003ccode\u003eagen.__anext__()\u003c/code\u003e는 \u003ccode\u003ePyAsyncGenASend\u003c/code\u003e 인스턴스(부모 \u003ccode\u003eagen\u003c/code\u003e 객체에 대한 참조를 유지)를 반환합니다.\u003c/p\u003e\n\u003cp\u003e데이터 흐름은 다음과 같이 정의됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenASend.send(val)\u003c/code\u003e이 처음 호출되면, \u003ccode\u003eval\u003c/code\u003e은 부모 \u003ccode\u003eagen\u003c/code\u003e 객체로 푸시됩니다(\u003ccode\u003ePyGenObject\u003c/code\u003e의 기존 기능을 사용).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e 객체에 대한 후속 이터레이션은 \u003ccode\u003eNone\u003c/code\u003e을 \u003ccode\u003eagen\u003c/code\u003e으로 푸시합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_PyAsyncGenWrappedValue\u003c/code\u003e 객체가 \u003ccode\u003eyield\u003c/code\u003e되면, 언박싱(unboxed)되고, 래핑되지 않은(unwrapped) 값을 인수로 하는 \u003ccode\u003eStopIteration\u003c/code\u003e 예외가 발생합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenASend.throw(*exc)\u003c/code\u003e가 처음 호출되면, \u003ccode\u003e*exc\u003c/code\u003e가 부모 \u003ccode\u003eagen\u003c/code\u003e 객체로 던져집니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyAsyncGenASend\u003c/code\u003e 객체에 대한 후속 이터레이션은 \u003ccode\u003eNone\u003c/code\u003e을 \u003ccode\u003eagen\u003c/code\u003e으로 푸시합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_PyAsyncGenWrappedValue\u003c/code\u003e 객체가 \u003ccode\u003eyield\u003c/code\u003e되면, 언박싱되고, 래핑되지 않은 값을 인수로 하는 \u003ccode\u003eStopIteration\u003c/code\u003e 예외가 발생합니다.\u003c/li\u003e\n\u003cli\u003e비동기 제너레이터의 \u003ccode\u003ereturn\u003c/code\u003e 문은 \u003ccode\u003eStopAsyncIteration\u003c/code\u003e 예외를 발생시키며, 이는 \u003ccode\u003ePyAsyncGenASend.send()\u003c/code\u003e 및 \u003ccode\u003ePyAsyncGenASend.throw()\u003c/code\u003e 메서드를 통해 전파됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ePyAsyncGenAThrow\u003c/code\u003e는 \u003ccode\u003ePyAsyncGenASend\u003c/code\u003e와 매우 유사합니다. 유일한 차이점은 \u003ccode\u003ePyAsyncGenAThrow.send()\u003c/code\u003e가 처음 호출될 때 부모 \u003ccode\u003eagen\u003c/code\u003e 객체에 예외를 던진다는 것입니다(값을 푸시하는 대신).\u003c/p\u003e\n\u003ch4\u003e새로운 표준 라이브러리 함수 및 타입 (New Standard Library Functions and Types)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etypes.AsyncGeneratorType\u003c/code\u003e – 비동기 제너레이터 객체의 타입입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.set_asyncgen_hooks()\u003c/code\u003e 및 \u003ccode\u003esys.get_asyncgen_hooks()\u003c/code\u003e 메서드는 이벤트 루프에서 비동기 제너레이터의 종료자(finalizers) 및 이터레이션 가로채기(interceptors)를 설정하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einspect.isasyncgen()\u003c/code\u003e 및 \u003ccode\u003einspect.isasyncgenfunction()\u003c/code\u003e 인트로스펙션(introspection) 함수.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easyncio\u003c/code\u003e 이벤트 루프의 새로운 메서드: \u003ccode\u003eloop.shutdown_asyncgens()\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e새로운 \u003ccode\u003ecollections.abc.AsyncGenerator\u003c/code\u003e 추상 기본 클래스(abstract base class).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e하위 호환성 (Backwards Compatibility)\u003c/h4\u003e\n\u003cp\u003e이 제안은 완벽하게 하위 호환됩니다.\r\nPython 3.5에서는 \u003ccode\u003eyield\u003c/code\u003e 표현식이 포함된 \u003ccode\u003easync def\u003c/code\u003e 함수를 정의하는 것이 \u003ccode\u003eSyntaxError\u003c/code\u003e이므로, 3.6에서 비동기 제너레이터를 도입하는 것은 안전합니다.\u003c/p\u003e\n\u003ch4\u003e성능 (Performance)\u003c/h4\u003e\n\u003ch5\u003e일반 제너레이터 (Regular Generators)\u003c/h5\u003e\n\u003cp\u003e일반 제너레이터에는 성능 저하가 없습니다. 다음 마이크로 벤치마크는 CPython에서 비동기 제너레이터 유무에 관계없이 동일한 속도로 실행됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef gen():\r\n    i = 0\r\n    while i \u0026#x3C; 100000000:\r\n        yield i\r\n        i += 1\r\nlist(gen())\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch5\u003e비동기 이터레이터 대비 개선점 (Improvements over asynchronous iterators)\u003c/h5\u003e\n\u003cp\u003e다음 마이크로 벤치마크는 비동기 제너레이터가 순수 Python으로 구현된 비동기 이터레이터보다 약 2.3배 빠름을 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eN = 10 ** 7\r\n\r\nasync def agen():\r\n    for i in range(N):\r\n        yield i\r\n\r\nclass AIter:\r\n    def __init__(self):\r\n        self.i = 0\r\n    def __aiter__(self):\r\n        return self\r\n    async def __anext__(self):\r\n        i = self.i\r\n        if i \u003e= N:\r\n            raise StopAsyncIteration\r\n        self.i += 1\r\n        return i\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e설계 고려 사항 (Design Considerations)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003eaiter()\u003c/code\u003e 및 \u003ccode\u003eanext()\u003c/code\u003e 내장 함수 (aiter() and anext() builtins)\u003c/h4\u003e\n\u003cp\u003e원래 PEP 492는 \u003ccode\u003e__aiter__\u003c/code\u003e를 \u003ccode\u003eawaitable\u003c/code\u003e 객체를 반환해야 하는 메서드로 정의하여 비동기 이터레이터를 생성하도록 했습니다.\r\n그러나 CPython 3.5.2에서 \u003ccode\u003e__aiter__\u003c/code\u003e는 비동기 이터레이터를 직접 반환하도록 재정의되었습니다. 하위 호환성을 깨는 것을 피하기 위해, Python 3.6에서는 두 가지 방식 모두를 지원하며, \u003ccode\u003e__aiter__\u003c/code\u003e가 여전히 \u003ccode\u003eawaitable\u003c/code\u003e을 반환할 수 있지만 \u003ccode\u003eDeprecationWarning\u003c/code\u003e이 발행되도록 결정되었습니다.\u003c/p\u003e\n\u003cp\u003ePython 3.6에서 \u003ccode\u003e__aiter__\u003c/code\u003e의 이러한 이중적인 특성 때문에 \u003ccode\u003eaiter()\u003c/code\u003e 내장 함수의 동기 구현을 추가할 수 없습니다. 따라서 Python 3.7까지 기다릴 것을 제안합니다.\u003c/p\u003e\n\u003ch4\u003e비동기 리스트/딕셔너리/세트 컴프리헨션 (Asynchronous list/dict/set comprehensions)\u003c/h4\u003e\n\u003cp\u003e비동기 컴프리헨션(comprehensions)의 문법은 비동기 제너레이터 메커니즘과 관련이 없으며, 별도의 PEP에서 고려되어야 합니다.\u003c/p\u003e\n\u003ch4\u003e비동기 \u003ccode\u003eyield from\u003c/code\u003e (Asynchronous yield from)\u003c/h4\u003e\n\u003cp\u003e비동기 제너레이터에 \u003ccode\u003eyield from\u003c/code\u003e 지원을 구현하는 것이 이론적으로 가능하지만, 제너레이터 구현을 심각하게 재설계해야 합니다.\r\n\u003ccode\u003eyield from\u003c/code\u003e은 비동기 제너레이터에 덜 중요합니다. 코루틴 위에 다른 코루틴 프로토콜을 구현하는 메커니즘을 제공할 필요가 없기 때문입니다. 비동기 제너레이터를 구성하기 위해 간단한 \u003ccode\u003easync for\u003c/code\u003e 루프를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def g1():\r\n    yield 1\r\n    yield 2\r\n\r\nasync def g2():\r\n    async for v in g1():\r\n        yield v\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003ccode\u003easend()\u003c/code\u003e 및 \u003ccode\u003eathrow()\u003c/code\u003e 메서드가 필요한 이유 (Why the asend() and athrow() methods are necessary)\u003c/h4\u003e\n\u003cp\u003e이 메서드들은 \u003ccode\u003econtextlib.contextmanager\u003c/code\u003e와 유사한 개념을 비동기 제너레이터를 사용하여 구현할 수 있게 합니다. 예를 들어, 제안된 설계로 다음 패턴을 구현할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@async_context_manager\r\nasync def ctx():\r\n    await open()\r\n    try:\r\n        yield\r\n    finally:\r\n        await close()\r\n\r\nasync with ctx():\r\n    await ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또 다른 이유는 \u003ccode\u003e__anext__\u003c/code\u003e 객체에서 반환된 객체를 사용하여 비동기 제너레이터로 데이터를 푸시하고 예외를 던지는 것이 가능하지만, 이를 올바르게 수행하기는 어렵다는 것입니다. 명시적인 \u003ccode\u003easend()\u003c/code\u003e 및 \u003ccode\u003eathrow()\u003c/code\u003e를 추가하면 이를 안전하게 수행할 수 있는 길을 열어줄 것입니다.\u003c/p\u003e\n\u003cp\u003e구현 측면에서 \u003ccode\u003easend()\u003c/code\u003e는 \u003ccode\u003e__anext__\u003c/code\u003e의 약간 더 일반적인 버전이며, \u003ccode\u003eathrow()\u003c/code\u003e는 \u003ccode\u003eaclose()\u003c/code\u003e와 매우 유사합니다. 따라서 비동기 제너레이터에 이러한 메서드를 정의해도 추가적인 복잡성은 발생하지 않습니다.\u003c/p\u003e\n\u003ch3\u003e예시 (Example)\u003c/h3\u003e\n\u003cp\u003e현재 참조 구현을 사용한 작동 예시 (0부터 9까지의 숫자를 1초 간격으로 출력합니다):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def ticker(delay, to):\r\n    for i in range(to):\r\n        yield i\r\n        await asyncio.sleep(delay)\r\n\r\nasync def run():\r\n    async for i in ticker(1, 10):\r\n        print(i)\r\n\r\nimport asyncio\r\nloop = asyncio.get_event_loop()\r\ntry:\r\n    loop.run_until_complete(run())\r\nfinally:\r\n    loop.close()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e승인 (Acceptance)\u003c/h3\u003e\n\u003cp\u003ePEP 525는 2016년 9월 6일 Guido에 의해 승인되었습니다.\u003c/p\u003e\n\u003ch3\u003e구현 (Implementation)\u003c/h3\u003e\n\u003cp\u003e구현은 이슈 28003에서 추적됩니다. 참조 구현 Git 저장소는에서 확인할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e참고 자료 (References)\u003c/h3\u003e\n\u003cp\u003ehttps://github.com/1st1/cpython/tree/async_gen\r\nhttps://mail.python.org/pipermail/python-dev/2016-September/146267.html\r\nhttp://bugs.python.org/issue28003\u003c/p\u003e\n\u003ch3\u003e감사 (Acknowledgments)\u003c/h3\u003e\n\u003cp\u003e이 PEP에 대한 피드백, 코드 검토 및 토론에 대해 Guido van Rossum, Victor Stinner, Elvis Pranskevichus, Nathaniel Smith, Łukasz Langa, Andrew Svetlov 및 기타 여러 사람들에게 감사드립니다.\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1098,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 525 - Asynchronous Generators\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:17:46+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>