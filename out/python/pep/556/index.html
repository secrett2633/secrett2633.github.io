<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/d6cea809dcbae606.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-61c2b369a48bb953.js"/><script src="/_next/static/chunks/fd9d1056-0395f68b8cc78a20.js" async=""></script><script src="/_next/static/chunks/23-706b53707bbf0661.js" async=""></script><script src="/_next/static/chunks/main-app-cf4c503f60a850f8.js" async=""></script><script src="/_next/static/chunks/231-467e37449c5a68fc.js" async=""></script><script src="/_next/static/chunks/app/layout-135ad156a55a8fe5.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-a0fe0cc578429896.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2672<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Deferred] PEP 556 - Threaded garbage collection</h1><div class="page__meta"><time dateTime="2025-09-26 23:41:31+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0556/">PEP 556 - Threaded garbage collection</a></p>
<p><strong>상태:</strong> Deferred | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 08-Sep-2017</p>
</blockquote>
<h1>PEP 556 – Threaded garbage collection</h1>
<ul>
<li><strong>작성자:</strong> Antoine Pitrou</li>
<li><strong>상태:</strong> 연기됨 (Deferred)</li>
<li><strong>유형:</strong> 표준 트랙 (Standards Track)</li>
<li><strong>생성일:</strong> 2017년 9월 8일</li>
<li><strong>Python 버전:</strong> 3.7</li>
</ul>
<h2>연기 공지 (Deferral Notice)</h2>
<p>이 PEP는 현재 활발히 작업 중이지 않습니다. 미래에 다시 논의될 수 있습니다. 주요 미완료 단계는 다음과 같습니다:</p>
<ul>
<li>구현을 다듬고, 필요한 경우 테스트 스위트를 조정합니다.</li>
<li>스레드 방식의 가비지 컬렉션(GC) 설정이 기존 코드에 예상치 못한 방식으로 문제를 일으키지 않는지 확인합니다 (예상되는 영향으로는 참조 사이클(reference cycle)에 있는 객체의 수명 연장이 포함됩니다).</li>
</ul>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 CPython의 순환 가비지 컬렉터(cyclic garbage collector, GC)를 위한 새로운 선택적 동작 모드를 제안합니다. 이 모드에서는 암묵적인(즉, 기회주의적인) 컬렉션이 동기적으로(synchronously) 실행되는 대신 전용 스레드에서 발생합니다.</p>
<h2>용어 (Terminology)</h2>
<ul>
<li><strong>암묵적 GC 실행 (Implicit GC run / Implicit collection):</strong> 새로운 할당이 요청될 때마다 할당 통계를 기반으로 계산된 특정 휴리스틱(heuristic)에 따라 기회주의적으로 트리거되는 GC 실행을 의미합니다. 이 휴리스틱의 세부 사항은 이 PEP의 변경 제안 범위에 포함되지 않습니다.</li>
<li><strong>명시적 GC 실행 (Explicit GC run / Explicit collection):</strong> <code>gc.collect()</code>와 같은 API 호출을 통해 프로그램적으로 요청되는 GC 실행을 의미합니다.</li>
<li><strong>스레드 방식 (Threaded):</strong> GC 실행이 애플리케이션 코드의 순차적 실행과 별개로 전용 스레드에서 발생한다는 사실을 나타냅니다. 이는 "동시적(concurrent)"을 의미하지 않습니다 (GIL(Global Interpreter Lock)은 여전히 전용 GC 스레드를 포함한 Python 스레드 간의 실행을 직렬화합니다). 또한 "병렬적(parallel)"을 의미하지도 않습니다 (GC는 GC 실행의 wall-clock latency를 줄이기 위해 작업을 여러 스레드에 동시에 분산할 수 없습니다).</li>
</ul>
<h2>배경 (Rationale)</h2>
<p>GC의 동작 모드는 항상 암묵적 컬렉션을 동기적으로 수행하는 것이었습니다. 즉, 앞서 언급된 휴리스틱이 활성화될 때마다 현재 스레드의 애플리케이션 코드 실행이 중단되고, 죽은 참조 사이클(dead reference cycles)을 회수하기 위해 GC가 시작됩니다.</p>
<p>문제는 GC가 죽은 참조 사이클과 그에 딸린 보조 객체를 회수하는 과정에서 <code>__del__</code> 메서드 및 <code>weakref</code> 콜백과 같은 임의의 파이널라이제이션(finalization) 코드를 실행할 수 있다는 점입니다. Python은 점점 더 정교한 목적으로 사용되고 있으며, 분산 시스템에서 객체 손실이 다른 (논리적 또는 물리적) 노드에 통지를 요구하는 등 파이널라이제이션 코드가 복잡한 작업을 수행하는 경우가 점점 흔해지고 있습니다.</p>
<p>일관된 내부 상태 및/또는 동기화 프리미티브(synchronization primitives) 획득에 의존할 수 있는 파이널라이제이션 코드를 실행하기 위해 임의의 지점에서 애플리케이션 코드를 중단하는 것은, 가장 노련한 전문가조차 제대로 해결하기 어려운 재진입(reentrancy) 문제를 야기합니다.</p>
<p>이 PEP는 겉으로는 비슷해 보이지만, 동일 스레드 내 재진입(same-thread reentrancy)이 다중 스레드 동기화(multi-thread synchronization)보다 근본적으로 더 어려운 문제라는 관찰에 기반합니다. 각 개발자나 라이브러리 작성자가 개별적으로 극도로 어려운 재진입 문제로 씨름하게 하는 대신, 이 PEP는 잘 알려진 다중 스레드 동기화 관행만으로 충분한 별도의 스레드에서 GC가 실행되도록 허용하는 것을 제안합니다.</p>
<h2>제안 (Proposal)</h2>
<p>이 PEP에 따라 GC는 두 가지 동작 모드를 가집니다:</p>
<ul>
<li><strong>"serial" (직렬):</strong> 기본이자 레거시(legacy) 모드입니다. 암묵적 GC 실행이 (앞서 언급된 할당 휴리스틱에 따라) 필요하다고 감지하는 스레드에서 즉시 수행됩니다.</li>
<li><strong>"threaded" (스레드 방식):</strong> 런타임에 프로세스별로 명시적으로 활성화될 수 있습니다. 암묵적 GC 실행은 할당 휴리스틱이 트리거될 때마다 예약되지만, 전용 백그라운드 스레드에서 실행됩니다.</li>
</ul>
<p>"serial" 모드에서 파이널라이제이션 콜백의 정교한 사용을 괴롭히던 어려운 재진입 문제는 "threaded" 모드에서는 비교적 쉬운 다중 스레드 동기화 문제가 됩니다.</p>
<p>GC는 전통적으로 <code>gc.collect</code> Python API 및 <code>PyGC_Collect</code> C API를 사용하여 명시적 GC 실행도 허용합니다. 이 두 API의 가시적 의미는 변경되지 않습니다. 호출될 때 즉시 GC 실행을 수행하며, GC 실행이 완료될 때만 반환됩니다.</p>
<h3>새로운 공개 API (New public APIs)</h3>
<p><code>gc</code> 모듈에 두 가지 새로운 Python API가 추가됩니다:</p>
<ul>
<li><code>gc.set_mode(mode)</code>: 현재 동작 모드를 설정합니다 ("serial" 또는 "threaded"). "serial"로 설정하고 현재 모드가 "threaded"인 경우, 이 함수는 GC 스레드가 종료될 때까지 기다립니다.</li>
<li><code>gc.get_mode()</code>: 현재 동작 모드를 반환합니다.</li>
</ul>
<p>동작 모드를 자유롭게 전환하는 것이 허용됩니다.</p>
<h3>의도된 사용 (Intended use)</h3>
<p>이 전환이 프로세스 단위(per-process)로 적용되며 모든 파이널라이제이션 콜백의 의미론에 영향을 미치므로, 애플리케이션 코드 시작 부분(및/또는 <code>multiprocessing</code>을 사용하는 경우 자식 프로세스의 초기화 함수에서)에 설정하는 것이 권장됩니다. 라이브러리 함수는 <code>gc.enable</code> 또는 <code>gc.disable</code>을 호출하지 않아야 하는 것처럼 이 설정을 변경하지 않는 것이 좋지만, 그렇게 하는 것을 막지는 않습니다.</p>
<h3>비목표 (Non-goals)</h3>
<p>이 PEP는 다른 종류의 비동기 코드 실행(예: <code>signal</code> 모듈에 등록된 시그널 핸들러)과 관련된 재진입 문제를 다루지 않습니다. 작성자는 고통스러운 재진입 문제의 압도적인 대다수가 파이널라이저(finalizers)와 함께 발생한다고 믿습니다. 대부분의 경우 시그널 핸들러는 단일 플래그를 설정하거나 메인 프로그램이 알아차릴 수 있도록 파일 디스크립터(file descriptor)를 깨울 수 있습니다. 예외를 발생시키는 시그널 핸들러의 경우, 스레드 내에서 실행되어야 합니다.</p>
<p>이 PEP는 또한 일반적인 참조 카운팅(reference counting)의 일부로 호출될 때, 즉 가시적 참조가 해제되어 객체의 참조 카운트가 0이 될 때 발생하는 파이널라이제이션 콜백의 실행을 변경하지 않습니다. 이러한 실행은 코드의 결정론적인 지점에서 발생하므로 일반적으로 문제가 되지 않습니다.</p>
<h2>논의 (Discussion)</h2>
<h3>기본 모드 (Default mode)</h3>
<p>기본 모드를 단순히 "threaded"로 변경해야 하는지에 대한 의문이 있을 수 있습니다. 다중 스레드 애플리케이션의 경우 문제가 되지 않을 것입니다. 이러한 애플리케이션은 이미 임의의 스레드에서 파이널라이제이션 핸들러가 실행될 준비가 되어 있어야 합니다. 그러나 단일 스레드 애플리케이션에서는 현재 파이널라이저가 항상 메인 스레드에서 호출된다는 것이 보장됩니다. 이 속성을 깨뜨리는 것은 미묘한 동작 변경이나 버그를 유발할 수 있으며, 예를 들어 파이널라이저가 일부 스레드 로컬 값에 의존하는 경우에 그렇습니다.</p>
<p>또 다른 문제는 프로그램이 동시성을 위해 <code>fork()</code>를 사용할 때 발생합니다. 단일 스레드 프로그램에서 <code>fork()</code>를 호출하는 것은 안전하지만, 프로그램이 다중 스레드인 경우에는 (적어도) 불안정합니다.</p>
<h3>명시적 컬렉션 (Explicit collections)</h3>
<p>명시적 컬렉션도 백그라운드 스레드에 위임해야 하는지 물을 수 있습니다. 대답은 별로 중요하지 않다는 것입니다. <code>gc.collect</code> 및 <code>PyGC_Collect</code>는 실제로 컬렉션이 끝날 때까지 기다리므로 (이 속성을 깨뜨리면 호환성이 깨짐), 실제 작업을 백그라운드 스레드에 위임해도 명시적 컬렉션을 요청하는 스레드와의 동기화를 쉽게 할 수는 없습니다.</p>
<p>결론적으로, 이 PEP는 위 의사 코드에 기반하여 구현하기에 더 간단해 보이는 동작을 선택합니다.</p>
<h3>메모리 사용량에 미치는 영향 (Impact on memory use)</h3>
<p>"threaded" 모드는 기본 "serial" 모드에 비해 암묵적 컬렉션에 약간의 지연을 초래합니다. 이는 특정 애플리케이션의 메모리 프로파일을 변경할 수 있습니다. 실제 사용 시 얼마나 많은지는 측정해야 하지만, 영향이 미미하고 견딜 만할 것으로 예상합니다. 첫째, 암묵적 컬렉션은 효과가 결정론적인 가시적 동작으로 이어지지 않는 휴리스틱에 기반하기 때문입니다. 둘째, GC는 참조 사이클을 처리하는 반면, 많은 객체는 마지막 가시적 참조가 사라질 때 즉시 회수되기 때문입니다.</p>
<h3>CPU 소비량에 미치는 영향 (Impact on CPU consumption)</h3>
<p>위 의사 코드에 따르면 "threaded" 모드에서 각 암묵적 컬렉션 요청에 대해 두 번의 잠금(lock) 작업이 추가됩니다. 하나는 요청을 하는 스레드에서(release 호출), 다른 하나는 GC 스레드에서(acquire 호출) 발생합니다. 또한, 현재 모드와 관계없이 각 실제 컬렉션 주변에 두 번의 잠금 작업이 더 추가됩니다.</p>
<p>현대 시스템에서 이러한 잠금 작업의 비용은 컬렉션 자체 동안 포인터 체인을 크롤링하는 실제 비용("pointer chasing"은 예측 및 슈퍼스칼라 실행에 적합하지 않아 현대 CPU에서 가장 어려운 작업 부하 중 하나)에 비해 매우 작을 것으로 예상됩니다.</p>
<p>최악의 경우 미니 벤치마크에 대한 실제 측정은 안심할 수 있는 상한선을 제공하는 데 도움이 될 수 있습니다.</p>
<h3>GC 일시 정지에 미치는 영향 (Impact on GC pauses)</h3>
<p>이 PEP는 GC 일시 정지(GC pauses) 자체에 직접적으로 초점을 맞추지 않지만, 암묵적 컬렉션 중 어느 시점에서 GIL을 해제하는 것이 (예를 들어 순수 Python 파이널라이저를 실행함으로써) 그 사이에 애플리케이션 코드가 실행되도록 허용하여 일부 애플리케이션에서 가시적인 GC 일시 정지 시간을 줄일 수 있는 실질적인 가능성이 있습니다.</p>
<p>이 PEP가 수락된다면, 미래 작업에서는 컬렉션 중에 GIL을 추측적으로 해제하여 이 잠재력을 더 잘 실현하려고 시도할 수 있지만, 이것이 얼마나 실현 가능한지는 불분명합니다.</p>
<h2>미해결 문제 (Open issues)</h2>
<ul>
<li><code>gc.set_mode</code>는 여러 동시 호출로부터 보호되어야 합니다. 또한 GC 실행 중 (즉, 파이널라이저에서) 호출될 때 예외를 발생시켜야 합니다.</li>
<li>종료 시에는 어떻게 될까요? <code>_PyGC_Fini()</code>가 호출될 때까지 GC 스레드가 실행될까요?</li>
</ul>
<h2>구현 (Implementation)</h2>
<p>작성자의 GitHub 포크의 <code>threaded_gc</code> 브랜치에 초안 구현이 제공됩니다.</p>
<h2>참고 자료 (References)</h2>
<p>https://peps.python.org/pep-0556/
https://github.com/pitrou/cpython/tree/threaded_gc
https://github.com/pitrou/cpython/</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/555/">[Withdrawn] PEP 555 - Context-local variables (contextvars)</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Deferred] PEP 556 - Threaded garbage collection</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/557/">[Final] PEP 557 - Data Classes</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-61c2b369a48bb953.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/d6cea809dcbae606.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-135ad156a55a8fe5.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-a0fe0cc578429896.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/556\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d6cea809dcbae606.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"Z3C0dl-eqDisnYDXzkst9\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/556/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/556\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"556\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/556\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"e:I[646,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-a0fe0cc578429896.js\"],\"default\"]\nd:T32c8,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0556/\"\u003ePEP 556 - Threaded garbage collection\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Deferred | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 08-Sep-2017\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 556 – Threaded garbage collection\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Antoine Pitrou\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 연기됨 (Deferred)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e 표준 트랙 (Standards Track)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2017년 9월 8일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.7\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e연기 공지 (Deferral Notice)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 현재 활발히 작업 중이지 않습니다. 미래에 다시 논의될 수 있습니다. 주요 미완료 단계는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e구현을 다듬고, 필요한 경우 테스트 스위트를 조정합니다.\u003c/li\u003e\n\u003cli\u003e스레드 방식의 가비지 컬렉션(GC) 설정이 기존 코드에 예상치 못한 방식으로 문제를 일으키지 않는지 확인합니다 (예상되는 영향으로는 참조 사이클(reference cycle)에 있는 객체의 수명 연장이 포함됩니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 CPython의 순환 가비지 컬렉터(cyclic garbage collector, GC)를 위한 새로운 선택적 동작 모드를 제안합니다. 이 모드에서는 암묵적인(즉, 기회주의적인) 컬렉션이 동기적으로(synchronously) 실행되는 대신 전용 스레드에서 발생합니다.\u003c/p\u003e\n\u003ch2\u003e용어 (Terminology)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e암묵적 GC 실행 (Implicit GC run / Implicit collection):\u003c/strong\u003e 새로운 할당이 요청될 때마다 할당 통계를 기반으로 계산된 특정 휴리스틱(heuristic)에 따라 기회주의적으로 트리거되는 GC 실행을 의미합니다. 이 휴리스틱의 세부 사항은 이 PEP의 변경 제안 범위에 포함되지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e명시적 GC 실행 (Explicit GC run / Explicit collection):\u003c/strong\u003e \u003ccode\u003egc.collect()\u003c/code\u003e와 같은 API 호출을 통해 프로그램적으로 요청되는 GC 실행을 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e스레드 방식 (Threaded):\u003c/strong\u003e GC 실행이 애플리케이션 코드의 순차적 실행과 별개로 전용 스레드에서 발생한다는 사실을 나타냅니다. 이는 \"동시적(concurrent)\"을 의미하지 않습니다 (GIL(Global Interpreter Lock)은 여전히 전용 GC 스레드를 포함한 Python 스레드 간의 실행을 직렬화합니다). 또한 \"병렬적(parallel)\"을 의미하지도 않습니다 (GC는 GC 실행의 wall-clock latency를 줄이기 위해 작업을 여러 스레드에 동시에 분산할 수 없습니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003eGC의 동작 모드는 항상 암묵적 컬렉션을 동기적으로 수행하는 것이었습니다. 즉, 앞서 언급된 휴리스틱이 활성화될 때마다 현재 스레드의 애플리케이션 코드 실행이 중단되고, 죽은 참조 사이클(dead reference cycles)을 회수하기 위해 GC가 시작됩니다.\u003c/p\u003e\n\u003cp\u003e문제는 GC가 죽은 참조 사이클과 그에 딸린 보조 객체를 회수하는 과정에서 \u003ccode\u003e__del__\u003c/code\u003e 메서드 및 \u003ccode\u003eweakref\u003c/code\u003e 콜백과 같은 임의의 파이널라이제이션(finalization) 코드를 실행할 수 있다는 점입니다. Python은 점점 더 정교한 목적으로 사용되고 있으며, 분산 시스템에서 객체 손실이 다른 (논리적 또는 물리적) 노드에 통지를 요구하는 등 파이널라이제이션 코드가 복잡한 작업을 수행하는 경우가 점점 흔해지고 있습니다.\u003c/p\u003e\n\u003cp\u003e일관된 내부 상태 및/또는 동기화 프리미티브(synchronization primitives) 획득에 의존할 수 있는 파이널라이제이션 코드를 실행하기 위해 임의의 지점에서 애플리케이션 코드를 중단하는 것은, 가장 노련한 전문가조차 제대로 해결하기 어려운 재진입(reentrancy) 문제를 야기합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 겉으로는 비슷해 보이지만, 동일 스레드 내 재진입(same-thread reentrancy)이 다중 스레드 동기화(multi-thread synchronization)보다 근본적으로 더 어려운 문제라는 관찰에 기반합니다. 각 개발자나 라이브러리 작성자가 개별적으로 극도로 어려운 재진입 문제로 씨름하게 하는 대신, 이 PEP는 잘 알려진 다중 스레드 동기화 관행만으로 충분한 별도의 스레드에서 GC가 실행되도록 허용하는 것을 제안합니다.\u003c/p\u003e\n\u003ch2\u003e제안 (Proposal)\u003c/h2\u003e\n\u003cp\u003e이 PEP에 따라 GC는 두 가지 동작 모드를 가집니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\"serial\" (직렬):\u003c/strong\u003e 기본이자 레거시(legacy) 모드입니다. 암묵적 GC 실행이 (앞서 언급된 할당 휴리스틱에 따라) 필요하다고 감지하는 스레드에서 즉시 수행됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\"threaded\" (스레드 방식):\u003c/strong\u003e 런타임에 프로세스별로 명시적으로 활성화될 수 있습니다. 암묵적 GC 실행은 할당 휴리스틱이 트리거될 때마다 예약되지만, 전용 백그라운드 스레드에서 실행됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\"serial\" 모드에서 파이널라이제이션 콜백의 정교한 사용을 괴롭히던 어려운 재진입 문제는 \"threaded\" 모드에서는 비교적 쉬운 다중 스레드 동기화 문제가 됩니다.\u003c/p\u003e\n\u003cp\u003eGC는 전통적으로 \u003ccode\u003egc.collect\u003c/code\u003e Python API 및 \u003ccode\u003ePyGC_Collect\u003c/code\u003e C API를 사용하여 명시적 GC 실행도 허용합니다. 이 두 API의 가시적 의미는 변경되지 않습니다. 호출될 때 즉시 GC 실행을 수행하며, GC 실행이 완료될 때만 반환됩니다.\u003c/p\u003e\n\u003ch3\u003e새로운 공개 API (New public APIs)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003egc\u003c/code\u003e 모듈에 두 가지 새로운 Python API가 추가됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egc.set_mode(mode)\u003c/code\u003e: 현재 동작 모드를 설정합니다 (\"serial\" 또는 \"threaded\"). \"serial\"로 설정하고 현재 모드가 \"threaded\"인 경우, 이 함수는 GC 스레드가 종료될 때까지 기다립니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egc.get_mode()\u003c/code\u003e: 현재 동작 모드를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e동작 모드를 자유롭게 전환하는 것이 허용됩니다.\u003c/p\u003e\n\u003ch3\u003e의도된 사용 (Intended use)\u003c/h3\u003e\n\u003cp\u003e이 전환이 프로세스 단위(per-process)로 적용되며 모든 파이널라이제이션 콜백의 의미론에 영향을 미치므로, 애플리케이션 코드 시작 부분(및/또는 \u003ccode\u003emultiprocessing\u003c/code\u003e을 사용하는 경우 자식 프로세스의 초기화 함수에서)에 설정하는 것이 권장됩니다. 라이브러리 함수는 \u003ccode\u003egc.enable\u003c/code\u003e 또는 \u003ccode\u003egc.disable\u003c/code\u003e을 호출하지 않아야 하는 것처럼 이 설정을 변경하지 않는 것이 좋지만, 그렇게 하는 것을 막지는 않습니다.\u003c/p\u003e\n\u003ch3\u003e비목표 (Non-goals)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 다른 종류의 비동기 코드 실행(예: \u003ccode\u003esignal\u003c/code\u003e 모듈에 등록된 시그널 핸들러)과 관련된 재진입 문제를 다루지 않습니다. 작성자는 고통스러운 재진입 문제의 압도적인 대다수가 파이널라이저(finalizers)와 함께 발생한다고 믿습니다. 대부분의 경우 시그널 핸들러는 단일 플래그를 설정하거나 메인 프로그램이 알아차릴 수 있도록 파일 디스크립터(file descriptor)를 깨울 수 있습니다. 예외를 발생시키는 시그널 핸들러의 경우, 스레드 내에서 실행되어야 합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 또한 일반적인 참조 카운팅(reference counting)의 일부로 호출될 때, 즉 가시적 참조가 해제되어 객체의 참조 카운트가 0이 될 때 발생하는 파이널라이제이션 콜백의 실행을 변경하지 않습니다. 이러한 실행은 코드의 결정론적인 지점에서 발생하므로 일반적으로 문제가 되지 않습니다.\u003c/p\u003e\n\u003ch2\u003e논의 (Discussion)\u003c/h2\u003e\n\u003ch3\u003e기본 모드 (Default mode)\u003c/h3\u003e\n\u003cp\u003e기본 모드를 단순히 \"threaded\"로 변경해야 하는지에 대한 의문이 있을 수 있습니다. 다중 스레드 애플리케이션의 경우 문제가 되지 않을 것입니다. 이러한 애플리케이션은 이미 임의의 스레드에서 파이널라이제이션 핸들러가 실행될 준비가 되어 있어야 합니다. 그러나 단일 스레드 애플리케이션에서는 현재 파이널라이저가 항상 메인 스레드에서 호출된다는 것이 보장됩니다. 이 속성을 깨뜨리는 것은 미묘한 동작 변경이나 버그를 유발할 수 있으며, 예를 들어 파이널라이저가 일부 스레드 로컬 값에 의존하는 경우에 그렇습니다.\u003c/p\u003e\n\u003cp\u003e또 다른 문제는 프로그램이 동시성을 위해 \u003ccode\u003efork()\u003c/code\u003e를 사용할 때 발생합니다. 단일 스레드 프로그램에서 \u003ccode\u003efork()\u003c/code\u003e를 호출하는 것은 안전하지만, 프로그램이 다중 스레드인 경우에는 (적어도) 불안정합니다.\u003c/p\u003e\n\u003ch3\u003e명시적 컬렉션 (Explicit collections)\u003c/h3\u003e\n\u003cp\u003e명시적 컬렉션도 백그라운드 스레드에 위임해야 하는지 물을 수 있습니다. 대답은 별로 중요하지 않다는 것입니다. \u003ccode\u003egc.collect\u003c/code\u003e 및 \u003ccode\u003ePyGC_Collect\u003c/code\u003e는 실제로 컬렉션이 끝날 때까지 기다리므로 (이 속성을 깨뜨리면 호환성이 깨짐), 실제 작업을 백그라운드 스레드에 위임해도 명시적 컬렉션을 요청하는 스레드와의 동기화를 쉽게 할 수는 없습니다.\u003c/p\u003e\n\u003cp\u003e결론적으로, 이 PEP는 위 의사 코드에 기반하여 구현하기에 더 간단해 보이는 동작을 선택합니다.\u003c/p\u003e\n\u003ch3\u003e메모리 사용량에 미치는 영향 (Impact on memory use)\u003c/h3\u003e\n\u003cp\u003e\"threaded\" 모드는 기본 \"serial\" 모드에 비해 암묵적 컬렉션에 약간의 지연을 초래합니다. 이는 특정 애플리케이션의 메모리 프로파일을 변경할 수 있습니다. 실제 사용 시 얼마나 많은지는 측정해야 하지만, 영향이 미미하고 견딜 만할 것으로 예상합니다. 첫째, 암묵적 컬렉션은 효과가 결정론적인 가시적 동작으로 이어지지 않는 휴리스틱에 기반하기 때문입니다. 둘째, GC는 참조 사이클을 처리하는 반면, 많은 객체는 마지막 가시적 참조가 사라질 때 즉시 회수되기 때문입니다.\u003c/p\u003e\n\u003ch3\u003eCPU 소비량에 미치는 영향 (Impact on CPU consumption)\u003c/h3\u003e\n\u003cp\u003e위 의사 코드에 따르면 \"threaded\" 모드에서 각 암묵적 컬렉션 요청에 대해 두 번의 잠금(lock) 작업이 추가됩니다. 하나는 요청을 하는 스레드에서(release 호출), 다른 하나는 GC 스레드에서(acquire 호출) 발생합니다. 또한, 현재 모드와 관계없이 각 실제 컬렉션 주변에 두 번의 잠금 작업이 더 추가됩니다.\u003c/p\u003e\n\u003cp\u003e현대 시스템에서 이러한 잠금 작업의 비용은 컬렉션 자체 동안 포인터 체인을 크롤링하는 실제 비용(\"pointer chasing\"은 예측 및 슈퍼스칼라 실행에 적합하지 않아 현대 CPU에서 가장 어려운 작업 부하 중 하나)에 비해 매우 작을 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e최악의 경우 미니 벤치마크에 대한 실제 측정은 안심할 수 있는 상한선을 제공하는 데 도움이 될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003eGC 일시 정지에 미치는 영향 (Impact on GC pauses)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 GC 일시 정지(GC pauses) 자체에 직접적으로 초점을 맞추지 않지만, 암묵적 컬렉션 중 어느 시점에서 GIL을 해제하는 것이 (예를 들어 순수 Python 파이널라이저를 실행함으로써) 그 사이에 애플리케이션 코드가 실행되도록 허용하여 일부 애플리케이션에서 가시적인 GC 일시 정지 시간을 줄일 수 있는 실질적인 가능성이 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP가 수락된다면, 미래 작업에서는 컬렉션 중에 GIL을 추측적으로 해제하여 이 잠재력을 더 잘 실현하려고 시도할 수 있지만, 이것이 얼마나 실현 가능한지는 불분명합니다.\u003c/p\u003e\n\u003ch2\u003e미해결 문제 (Open issues)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egc.set_mode\u003c/code\u003e는 여러 동시 호출로부터 보호되어야 합니다. 또한 GC 실행 중 (즉, 파이널라이저에서) 호출될 때 예외를 발생시켜야 합니다.\u003c/li\u003e\n\u003cli\u003e종료 시에는 어떻게 될까요? \u003ccode\u003e_PyGC_Fini()\u003c/code\u003e가 호출될 때까지 GC 스레드가 실행될까요?\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e작성자의 GitHub 포크의 \u003ccode\u003ethreaded_gc\u003c/code\u003e 브랜치에 초안 구현이 제공됩니다.\u003c/p\u003e\n\u003ch2\u003e참고 자료 (References)\u003c/h2\u003e\n\u003cp\u003ehttps://peps.python.org/pep-0556/\r\nhttps://github.com/pitrou/cpython/tree/threaded_gc\r\nhttps://github.com/pitrou/cpython/\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2672,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Deferred] PEP 556 - Threaded garbage collection\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:41:31+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Le\",null,{\"postPermalink\":\"/python/pep/556/\",\"postId\":\"2025-09-26-pep-0556-threaded-garbage-collection\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/555/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Withdrawn] PEP 555 - Context-local variables (contextvars)\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Deferred] PEP 556 - Threaded garbage collection\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/557/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 557 - Data Classes\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>