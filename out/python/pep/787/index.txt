3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-467e37449c5a68fc.js","185","static/chunks/app/layout-e359f205e3380aec.js"],"default"]
7:I[231,["231","static/chunks/231-467e37449c5a68fc.js","931","static/chunks/app/page-90c91ef098171651.js"],""]
4:["slug","python/pep/787","c"]
0:["vlNzklkFwxZlDtaCTE3RF",[[["",{"children":[["slug","python/pep/787","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"787\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/787","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/d6cea809dcbae606.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
a:I[646,["231","static/chunks/231-467e37449c5a68fc.js","877","static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js"],"default"]
9:Tc003,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0787/">PEP 787 - Safer subprocess usage using t-strings</a></p>
<p><strong>상태:</strong> Deferred | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 13-Apr-2025</p>
</blockquote>
<h1>PEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용</h1>
<ul>
<li><strong>저자</strong> : Nick Humrich, Alyssa Coghlan</li>
<li><strong>상태</strong> : Deffered (연기됨)</li>
<li><strong>Python 버전</strong> : 3.15</li>
<li><strong>생성일</strong> : 2025년 4월 13일</li>
</ul>
<h2>개요 (Abstract)</h2>
<p>PEP 750에서 f-string의 일반화된 형태로 <code>template string (t-string)</code>이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 <code>subprocess</code> 및 <code>shlex</code> 모듈을 확장하여 <code>t-string</code>을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 <code>t-string</code> 기능의 참조 구현 역할도 합니다.</p>
<h2>PEP 연기 (PEP Deferral)</h2>
<p>초기 초안 논의 과정에서, <code>t-string</code>이 <code>shell=True</code>와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.</p>
<p>이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 <code>t-string</code> 기반의 <code>subprocess</code> 호출 라이브러리를 개발할 계획입니다.</p>
<h2>동기 (Motivation)</h2>
<p>PEP 750의 <code>template string (t-string)</code>은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. <code>t-string</code>의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.</p>
<p>예시:</p>
<pre><code class="language-python"># f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)
os.system(f"echo {message_from_user}")
# f-string 사용 시 역시 안전하지 않음
subprocess.run(f"echo {message_from_user}", shell=True)
# f-string 사용 시 실패
subprocess.run(f"echo {message_from_user}")

# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:
subprocess.run(t"echo {message_from_user}", shell=True)
# t-string 사용 시 모든 플랫폼에서 안전:
subprocess.run(t"echo {message_from_user}")
# t-string 없이 모든 플랫폼에서 안전 (더 장황함):
subprocess.run(["echo", str(message_from_user)])
</code></pre>
<p>현재 개발자들은 편의성(<code>f-string</code> 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. <code>subprocess</code> 모듈에 기본 <code>t-string</code> 지원을 추가함으로써, 이 PEP는 <code>t-string</code>의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.</p>
<h2>근거 (Rationale)</h2>
<p><code>subprocess</code> 모듈이 <code>t-string</code> 지원에 이상적인 후보인 이유는 다음과 같습니다.</p>
<ul>
<li>셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.</li>
<li><code>subprocess</code> 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.</li>
<li><code>t-string</code>과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.</li>
<li>이것은 개발자들이 즉시 이해하고 활용할 수 있는 <code>t-string</code>의 실용적인 쇼케이스 역할을 합니다.</li>
</ul>
<p><code>subprocess</code>를 확장하여 <code>t-string</code>을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 <code>f-string</code>을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.</p>
<h2>명세 (Specification)</h2>
<p>이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.</p>
<ol>
<li><code>shlex</code> 모듈에 안전한 셸 명령 구성을 위한 새로운 <code>sh()</code> 렌더러 함수 추가</li>
<li><code>subprocess</code> 모듈의 핵심 함수, 특히 <code>subprocess.Popen</code>, <code>subprocess.run()</code> 및 <code>command</code> 인수를 받는 다른 관련 함수에 <code>t-string</code> 지원 추가</li>
</ol>
<h3><code>shlex</code>에 셸 이스케이프를 위한 렌더러 추가</h3>
<p>참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 <code>shlex</code> 모듈에 추가될 것입니다. 이 렌더러는 <code>sh</code>라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 <code>shlex.quote</code>를 호출하는 것과 동일하게 작동합니다.</p>
<p>따라서 다음 코드는:</p>
<pre><code class="language-python">os.system(shlex.sh(t"cat {myfile}"))
</code></pre>
<p>다음과 동일하게 동작합니다.</p>
<pre><code class="language-python">os.system("cat " + shlex.quote(myfile))
</code></pre>
<p><code>shlex.sh</code>의 추가는 <code>subprocess</code> 문서에서 <code>shell=True</code> 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, <code>os.system()</code> 문서에서 상위 수준의 <code>subprocess</code> API를 참조하는 것도 변경하지 않습니다.</p>
<p><code>t-string</code> 프로세서 구현은 다음과 같습니다.</p>
<pre><code class="language-python">from string.templatelib import Template, Interpolation
from shlex import quote, join # shlex.quote와 shlex.join을 가정

def sh(template: Template) -> str:
    parts: list[str] = []
    for item in template:
        if isinstance(item, Interpolation):
            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.
            parts.append(quote(str(item.value)))
        else:
            parts.append(item)
    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.
    return join(parts)
</code></pre>
<p>이를 통해 셸 사용을 위한 <code>t-string</code>의 명시적인 이스케이프가 가능합니다.</p>
<pre><code class="language-python">import shlex
import os

filename = "my file with spaces.txt" # 사용자 입력이라고 가정

# 안전한 POSIX 호환 셸 명령 구성
command = shlex.sh(t"cat {filename}")
os.system(command) # cat "my file with spaces.txt" 와 동일하게 실행
</code></pre>
<h3><code>subprocess</code> 모듈 변경 사항</h3>
<p><code>shlex</code> 모듈에 렌더러와 <code>template string</code>이 추가됨에 따라, <code>subprocess</code> 모듈은 <code>Popen</code>에 <code>template string</code>을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. <code>Popen</code>은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.</p>
<p>결과적으로, <code>subprocess.run()</code>과 같은 <code>subprocess.Popen</code>의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( <code>shell=False</code>의 경우 모든 시스템에서, <code>shell=True</code>의 경우 POSIX 시스템에서).</p>
<p>예를 들어:</p>
<pre><code class="language-python">subprocess.run(t"cat {myfile}", shell=True)
</code></pre>
<p>위 코드는 이 PEP에서 제공하는 <code>shlex.sh</code> 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 <code>subprocess.run</code> 호출 내에서 <code>shlex</code>를 사용하는 것은 중복됩니다.</p>
<pre><code class="language-python">subprocess.run(shlex.sh(t"cat {myfile}"), shell=True)
</code></pre>
<p><code>run</code> 함수가 모든 템플릿 리터럴을 <code>shlex.sh</code>를 통해 자동으로 렌더링하기 때문입니다.</p>
<p><code>subprocess.Popen</code>이 <code>shell=True</code> 없이 호출될 때도 <code>t-string</code> 지원은 <code>subprocess</code>에 더 인체공학적인 구문을 제공합니다. 예를 들어:</p>
<pre><code class="language-python">subprocess.run(t"cat {myfile} --flag {value}")
</code></pre>
<p>위 코드는 다음과 동일합니다.</p>
<pre><code class="language-python">subprocess.run(["cat", myfile, "--flag", value])
</code></pre>
<p>또는 더 정확하게는:</p>
<pre><code class="language-python">subprocess.run(shlex.split(shlex.sh(t"cat {myfile} --flag {value}")))
</code></pre>
<p>이는 먼저 위에서 설명한 <code>shlex.sh</code> 렌더러를 사용한 다음, 그 결과에 대해 <code>shlex.split</code>을 사용함으로써 이루어집니다.</p>
<p><code>subprocess.Popen._execute_child</code> 내부의 구현은 <code>t-string</code>을 확인할 것입니다.</p>
<pre><code class="language-python">from string.templatelib import Template

if isinstance(args, Template):
    import shlex
    if shell:
        args = shlex.sh(args)
    else:
        args = shlex.split(shlex.sh(args))
</code></pre>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. <code>subprocess</code> 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.</p>
<h2>보안 영향 (Security Implications)</h2>
<p>이 PEP는 셸 명령과 함께 <code>f-string</code>을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.</p>
<p>그러나 <code>shell=True</code>가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. <code>cmd.exe</code> 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 <code>shlex.quote()</code>가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.</p>
<h2>교육 방법 (How to Teach This)</h2>
<p>이 기능은 <code>t-string</code>의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.</p>
<ol>
<li>
<p>명령 주입 문제와 <code>f-string</code>이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.</p>
</li>
<li>
<p>전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.</p>
</li>
<li>
<p>명시적인 셸 이스케이프를 위한 <code>shlex.sh</code> 렌더러를 소개합니다.</p>
<pre><code class="language-python"># 안전하지 않음:
os.system(f"cat {filename}") # 잠재적인 명령 주입!

# shlex.sh 사용 시 안전:
os.system(shlex.sh(t"cat {filename}")) # 셸을 위한 명시적 이스케이프
</code></pre>
</li>
<li>
<p><code>subprocess</code> 모듈의 기본 <code>t-string</code> 지원을 소개합니다.</p>
<pre><code class="language-python"># 안전하지 않음:
subprocess.run(f"cat {filename}", shell=True) # 잠재적인 명령 주입!

# 안전하지만 장황함:
subprocess.run(["cat", filename])

# t-string 사용 시 안전하고 읽기 쉬움:
subprocess.run(t"cat {filename}", shell=True) # filename을 자동으로 이스케이프
subprocess.run(t"cat {filename}") # 자동으로 리스트 형태로 변환
</code></pre>
</li>
</ol>
<p>구현은 <code>shlex</code> 및 <code>subprocess</code> 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.</p>
<h3>비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기</h3>
<p><code>shlex.quote()</code>는 정규식 문자 세트 <code>[\w@%+=:,./-]</code>를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.</p>
<p>예를 들어, <code>subprocess.run(f"echo {shlex.quote(sys.argv[1])}", shell=True)</code>를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.</p>
<p>그러나 Python에서 <code>cmd.exe</code> (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.</p>
<p>이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.</p>
<p>I have translated and structured the content as requested. I have also added citations for every sentence derived from the browsed URL.</p>
<pre><code class="language-markdown"># PEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용

*   **저자** : Nick Humrich, Alyssa Coghlan
*   **상태** : Deferred (연기됨)
*   **Python 버전** : 3.15
*   **생성일** : 2025년 4월 13일

## 개요 (Abstract)

PEP 750에서 f-string의 일반화된 형태로 `template string (t-string)`이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 `subprocess` 및 `shlex` 모듈을 확장하여 `t-string`을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 `t-string` 기능의 참조 구현 역할도 합니다.

## PEP 연기 (PEP Deferral)

초기 초안 논의 과정에서, `t-string`이 `shell=True`와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.

이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 `t-string` 기반의 `subprocess` 호출 라이브러리를 개발할 계획입니다.

## 동기 (Motivation)

PEP 750의 `template string (t-string)`은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. `t-string`의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.

예시:

```python
# f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)
os.system(f"echo {message_from_user}")
# f-string 사용 시 역시 안전하지 않음
subprocess.run(f"echo {message_from_user}", shell=True)
# f-string 사용 시 실패
subprocess.run(f"echo {message_from_user}")

# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:
subprocess.run(t"echo {message_from_user}", shell=True)
# t-string 사용 시 모든 플랫폼에서 안전:
subprocess.run(t"echo {message_from_user}")
# t-string 없이 모든 플랫폼에서 안전 (더 장황함):
subprocess.run(["echo", str(message_from_user)])
</code></pre>
<p>현재 개발자들은 편의성(<code>f-string</code> 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. <code>subprocess</code> 모듈에 기본 <code>t-string</code> 지원을 추가함으로써, 이 PEP는 <code>t-string</code>의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.</p>
<h2>근거 (Rationale)</h2>
<p><code>subprocess</code> 모듈이 <code>t-string</code> 지원에 이상적인 후보인 이유는 다음과 같습니다.</p>
<ul>
<li>셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.</li>
<li><code>subprocess</code> 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.</li>
<li><code>t-string</code>과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.</li>
<li>이것은 개발자들이 즉시 이해하고 활용할 수 있는 <code>t-string</code>의 실용적인 쇼케이스 역할을 합니다.</li>
</ul>
<p><code>subprocess</code>를 확장하여 <code>t-string</code>을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 <code>f-string</code>을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.</p>
<h2>명세 (Specification)</h2>
<p>이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.</p>
<ol>
<li><code>shlex</code> 모듈에 안전한 셸 명령 구성을 위한 새로운 <code>sh()</code> 렌더러 함수 추가</li>
<li><code>subprocess</code> 모듈의 핵심 함수, 특히 <code>subprocess.Popen</code>, <code>subprocess.run()</code> 및 <code>command</code> 인수를 받는 다른 관련 함수에 <code>t-string</code> 지원 추가</li>
</ol>
<h3><code>shlex</code>에 셸 이스케이프를 위한 렌더러 추가</h3>
<p>참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 <code>shlex</code> 모듈에 추가될 것입니다. 이 렌더러는 <code>sh</code>라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 <code>shlex.quote</code>를 호출하는 것과 동일하게 작동합니다.</p>
<p>따라서 다음 코드는:</p>
<pre><code class="language-python">os.system(shlex.sh(t"cat {myfile}"))
</code></pre>
<p>다음과 동일하게 동작합니다.</p>
<pre><code class="language-python">os.system("cat " + shlex.quote(myfile))
</code></pre>
<p><code>shlex.sh</code>의 추가는 <code>subprocess</code> 문서에서 <code>shell=True</code> 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, <code>os.system()</code> 문서에서 상위 수준의 <code>subprocess</code> API를 참조하는 것도 변경하지 않습니다.</p>
<p><code>t-string</code> 프로세서 구현은 다음과 같습니다.</p>
<pre><code class="language-python">from string.templatelib import Template, Interpolation
from shlex import quote, join # shlex.quote와 shlex.join을 가정

def sh(template: Template) -> str:
    parts: list[str] = []
    for item in template:
        if isinstance(item, Interpolation):
            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.
            parts.append(quote(str(item.value)))
        else:
            parts.append(item)
    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.
    return join(parts)
</code></pre>
<p>이를 통해 셸 사용을 위한 <code>t-string</code>의 명시적인 이스케이프가 가능합니다.</p>
<pre><code class="language-python">import shlex
import os

filename = "my file with spaces.txt" # 사용자 입력이라고 가정

# 안전한 POSIX-compliant 셸 명령 구성
command = shlex.sh(t"cat {filename}")
os.system(command) # cat "my file with spaces.txt" 와 동일하게 실행
</code></pre>
<h3><code>subprocess</code> 모듈 변경 사항</h3>
<p><code>shlex</code> 모듈에 렌더러와 <code>template string</code>이 추가됨에 따라, <code>subprocess</code> 모듈은 <code>Popen</code>에 <code>template string</code>을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. <code>Popen</code>은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.</p>
<p>결과적으로, <code>subprocess.run()</code>과 같은 <code>subprocess.Popen</code>의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( <code>shell=False</code>의 경우 모든 시스템에서, <code>shell=True</code>의 경우 POSIX 시스템에서).</p>
<p>예를 들어:</p>
<pre><code class="language-python">subprocess.run(t"cat {myfile}", shell=True)
</code></pre>
<p>위 코드는 이 PEP에서 제공하는 <code>shlex.sh</code> 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 <code>subprocess.run</code> 호출 내에서 <code>shlex</code>를 사용하는 것은 중복됩니다.</p>
<pre><code class="language-python">subprocess.run(shlex.sh(t"cat {myfile}"), shell=True)
</code></pre>
<p><code>run</code> 함수가 모든 템플릿 리터럴을 <code>shlex.sh</code>를 통해 자동으로 렌더링하기 때문입니다.</p>
<p><code>subprocess.Popen</code>이 <code>shell=True</code> 없이 호출될 때도 <code>t-string</code> 지원은 <code>subprocess</code>에 더 인체공학적인 구문을 제공합니다. 예를 들어:</p>
<pre><code class="language-python">subprocess.run(t"cat {myfile} --flag {value}")
</code></pre>
<p>위 코드는 다음과 동일합니다.</p>
<pre><code class="language-python">subprocess.run(["cat", myfile, "--flag", value])
</code></pre>
<p>또는 더 정확하게는:</p>
<pre><code class="language-python">subprocess.run(shlex.split(shlex.sh(t"cat {myfile} --flag {value}")))
</code></pre>
<p>이는 먼저 위에서 설명한 <code>shlex.sh</code> 렌더러를 사용한 다음, 그 결과에 대해 <code>shlex.split</code>을 사용함으로써 이루어집니다.</p>
<p><code>subprocess.Popen._execute_child</code> 내부의 구현은 <code>t-string</code>을 확인할 것입니다.</p>
<pre><code class="language-python">from string.templatelib import Template

if isinstance(args, Template):
    import shlex
    if shell:
        args = shlex.sh(args)
    else:
        args = shlex.split(shlex.sh(args))
</code></pre>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. <code>subprocess</code> 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.</p>
<h2>보안 영향 (Security Implications)</h2>
<p>이 PEP는 셸 명령과 함께 <code>f-string</code>을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.</p>
<p>그러나 <code>shell=True</code>가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. <code>cmd.exe</code> 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 <code>shlex.quote()</code>가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.</p>
<h2>교육 방법 (How to Teach This)</h2>
<p>이 기능은 <code>t-string</code>의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.</p>
<ol>
<li>
<p>명령 주입 문제와 <code>f-string</code>이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.</p>
</li>
<li>
<p>전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.</p>
</li>
<li>
<p>명시적인 셸 이스케이프를 위한 <code>shlex.sh</code> 렌더러를 소개합니다.</p>
<pre><code class="language-python"># 안전하지 않음:
os.system(f"cat {filename}") # 잠재적인 명령 주입!

# shlex.sh 사용 시 안전:
os.system(shlex.sh(t"cat {filename}")) # 셸을 위한 명시적 이스케이프
</code></pre>
</li>
<li>
<p><code>subprocess</code> 모듈의 기본 <code>t-string</code> 지원을 소개합니다.</p>
<pre><code class="language-python"># 안전하지 않음:
subprocess.run(f"cat {filename}", shell=True) # 잠재적인 명령 주입!

# 안전하지만 장황함:
subprocess.run(["cat", filename])

# t-string 사용 시 안전하고 읽기 쉬움:
subprocess.run(t"cat {filename}", shell=True) # filename을 자동으로 이스케이프
subprocess.run(t"cat {filename}") # 자동으로 리스트 형태로 변환
</code></pre>
</li>
</ol>
<p>구현은 <code>shlex</code> 및 <code>subprocess</code> 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.</p>
<h3>비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기</h3>
<p><code>shlex.quote()</code>는 정규식 문자 세트 <code>[\w@%+=:,./-]</code>를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.</p>
<p>예를 들어, <code>subprocess.run(f"echo {shlex.quote(sys.argv[1])}", shell=True)</code>를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.</p>
<p>그러나 Python에서 <code>cmd.exe</code> (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.</p>
<p>이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.</p>
<pre><code># PEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용

*   **저자** : Nick Humrich, Alyssa Coghlan
*   **상태** : Deferred (연기됨)
*   **Python 버전** : 3.15
*   **생성일** : 2025년 4월 13일

## 개요 (Abstract)

PEP 750에서 f-string의 일반화된 형태로 `template string (t-string)`이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 `subprocess` 및 `shlex` 모듈을 확장하여 `t-string`을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 `t-string` 기능의 참조 구현 역할도 합니다.

## PEP 연기 (PEP Deferral)

초기 초안 논의 과정에서, `t-string`이 `shell=True`와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.

이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 `t-string` 기반의 `subprocess` 호출 라이브러리를 개발할 계획입니다.

## 동기 (Motivation)

PEP 750의 `template string (t-string)`은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. `t-string`의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.

예시:

```python
# f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)
os.system(f"echo {message_from_user}")
# f-string 사용 시 역시 안전하지 않음
subprocess.run(f"echo {message_from_user}", shell=True)
# f-string 사용 시 실패
subprocess.run(f"echo {message_from_user}")

# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:
subprocess.run(t"echo {message_from_user}", shell=True)
# t-string 사용 시 모든 플랫폼에서 안전:
subprocess.run(t"echo {message_from_user}")
# t-string 없이 모든 플랫폼에서 안전 (더 장황함):
subprocess.run(["echo", str(message_from_user)])
```

현재 개발자들은 편의성(`f-string` 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. `subprocess` 모듈에 기본 `t-string` 지원을 추가함으로써, 이 PEP는 `t-string`의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.

## 근거 (Rationale)

`subprocess` 모듈이 `t-string` 지원에 이상적인 후보인 이유는 다음과 같습니다.

*   셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.
*   `subprocess` 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.
*   `t-string`과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.
*   이것은 개발자들이 즉시 이해하고 활용할 수 있는 `t-string`의 실용적인 쇼케이스 역할을 합니다.

`subprocess`를 확장하여 `t-string`을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 `f-string`을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.

## 명세 (Specification)

이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.

1.  `shlex` 모듈에 안전한 셸 명령 구성을 위한 새로운 `sh()` 렌더러 함수 추가
2.  `subprocess` 모듈의 핵심 함수, 특히 `subprocess.Popen`, `subprocess.run()` 및 `command` 인수를 받는 다른 관련 함수에 `t-string` 지원 추가

### `shlex`에 셸 이스케이프를 위한 렌더러 추가

참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 `shlex` 모듈에 추가될 것입니다. 이 렌더러는 `sh`라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 `shlex.quote`를 호출하는 것과 동일하게 작동합니다.

따라서 다음 코드는:

```python
os.system(shlex.sh(t"cat {myfile}"))
```

다음과 동일하게 동작합니다.

```python
os.system("cat " + shlex.quote(myfile))
```

`shlex.sh`의 추가는 `subprocess` 문서에서 `shell=True` 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, `os.system()` 문서에서 상위 수준의 `subprocess` API를 참조하는 것도 변경하지 않습니다.

`t-string` 프로세서 구현은 다음과 같습니다.

```python
from string.templatelib import Template, Interpolation
from shlex import quote, join # shlex.quote와 shlex.join을 가정

def sh(template: Template) -> str:
    parts: list[str] = []
    for item in template:
        if isinstance(item, Interpolation):
            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.
            parts.append(quote(str(item.value)))
        else:
            parts.append(item)
    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.
    return join(parts)
```

이를 통해 셸 사용을 위한 `t-string`의 명시적인 이스케이프가 가능합니다.

```python
import shlex
import os

filename = "my file with spaces.txt" # 사용자 입력이라고 가정

# 안전한 POSIX-compliant 셸 명령 구성
command = shlex.sh(t"cat {filename}")
os.system(command) # cat "my file with spaces.txt" 와 동일하게 실행
```

### `subprocess` 모듈 변경 사항

`shlex` 모듈에 렌더러와 `template string`이 추가됨에 따라, `subprocess` 모듈은 `Popen`에 `template string`을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. `Popen`은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.

결과적으로, `subprocess.run()`과 같은 `subprocess.Popen`의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( `shell=False`의 경우 모든 시스템에서, `shell=True`의 경우 POSIX 시스템에서).

예를 들어:

```python
subprocess.run(t"cat {myfile}", shell=True)
```

위 코드는 이 PEP에서 제공하는 `shlex.sh` 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 `subprocess.run` 호출 내에서 `shlex`를 사용하는 것은 중복됩니다.

```python
subprocess.run(shlex.sh(t"cat {myfile}"), shell=True)
```

`run` 함수가 모든 템플릿 리터럴을 `shlex.sh`를 통해 자동으로 렌더링하기 때문입니다.

`subprocess.Popen`이 `shell=True` 없이 호출될 때도 `t-string` 지원은 `subprocess`에 더 인체공학적인 구문을 제공합니다. 예를 들어:

```python
subprocess.run(t"cat {myfile} --flag {value}")
```

위 코드는 다음과 동일합니다.

```python
subprocess.run(["cat", myfile, "--flag", value])
```

또는 더 정확하게는:

```python
subprocess.run(shlex.split(shlex.sh(t"cat {myfile} --flag {value}")))
```

이는 먼저 위에서 설명한 `shlex.sh` 렌더러를 사용한 다음, 그 결과에 대해 `shlex.split`을 사용함으로써 이루어집니다.

`subprocess.Popen._execute_child` 내부의 구현은 `t-string`을 확인할 것입니다.

```python
from string.templatelib import Template

if isinstance(args, Template):
    import shlex
    if shell:
        args = shlex.sh(args)
    else:
        args = shlex.split(shlex.sh(args))
```

## 하위 호환성 (Backwards Compatibility)

이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. `subprocess` 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.

## 보안 영향 (Security Implications)

이 PEP는 셸 명령과 함께 `f-string`을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.

그러나 `shell=True`가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. `cmd.exe` 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 `shlex.quote()`가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.

## 교육 방법 (How to Teach This)

이 기능은 `t-string`의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.

1.  명령 주입 문제와 `f-string`이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.
2.  전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.
3.  명시적인 셸 이스케이프를 위한 `shlex.sh` 렌더러를 소개합니다.

    ```python
    # 안전하지 않음:
    os.system(f"cat {filename}") # 잠재적인 명령 주입!

    # shlex.sh 사용 시 안전:
    os.system(shlex.sh(t"cat {filename}")) # 셸을 위한 명시적 이스케이프
    ```

4.  `subprocess` 모듈의 기본 `t-string` 지원을 소개합니다.

    ```python
    # 안전하지 않음:
    subprocess.run(f"cat {filename}", shell=True) # 잠재적인 명령 주입!

    # 안전하지만 장황함:
    subprocess.run(["cat", filename])

    # t-string 사용 시 안전하고 읽기 쉬움:
    subprocess.run(t"cat {filename}", shell=True) # filename을 자동으로 이스케이프
    subprocess.run(t"cat {filename}") # 자동으로 리스트 형태로 변환
    ```

구현은 `shlex` 및 `subprocess` 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.

### 비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기

`shlex.quote()`는 정규식 문자 세트 `[\w@%+=:,./-]`를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.

예를 들어, `subprocess.run(f"echo {shlex.quote(sys.argv[1])}", shell=True)`를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.

그러나 Python에서 `cmd.exe` (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.

이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.

## 저작권 (Copyright)

이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.
```# PEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용

*   **저자** : Nick Humrich, Alyssa Coghlan
*   **상태** : Deferred (연기됨)
*   **Python 버전** : 3.15
*   **생성일** : 2025년 4월 13일

## 개요 (Abstract)

PEP 750에서 f-string의 일반화된 형태로 `template string (t-string)`이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 `subprocess` 및 `shlex` 모듈을 확장하여 `t-string`을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 `t-string` 기능의 참조 구현 역할도 합니다.

## PEP 연기 (PEP Deferral)

초기 초안 논의 과정에서, `t-string`이 `shell=True`와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.

이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 `t-string` 기반의 `subprocess` 호출 라이브러리를 개발할 계획입니다.

## 동기 (Motivation)

PEP 750의 `template string (t-string)`은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. `t-string`의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.

예시:

```python
# f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)
os.system(f"echo {message_from_user}")
# f-string 사용 시 역시 안전하지 않음
subprocess.run(f"echo {message_from_user}", shell=True)
# f-string 사용 시 실패
subprocess.run(f"echo {message_from_user}")

# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:
subprocess.run(t"echo {message_from_user}", shell=True)
# t-string 사용 시 모든 플랫폼에서 안전:
subprocess.run(t"echo {message_from_user}")
# t-string 없이 모든 플랫폼에서 안전 (더 장황함):
subprocess.run(["echo", str(message_from_user)])
```

현재 개발자들은 편의성(`f-string` 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. `subprocess` 모듈에 기본 `t-string` 지원을 추가함으로써, 이 PEP는 `t-string`의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.

## 근거 (Rationale)

`subprocess` 모듈이 `t-string` 지원에 이상적인 후보인 이유는 다음과 같습니다.

*   셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.
*   `subprocess` 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.
*   `t-string`과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.
*   이것은 개발자들이 즉시 이해하고 활용할 수 있는 `t-string`의 실용적인 쇼케이스 역할을 합니다.

`subprocess`를 확장하여 `t-string`을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 `f-string`을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.

## 명세 (Specification)

이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.

1.  `shlex` 모듈에 안전한 셸 명령 구성을 위한 새로운 `sh()` 렌더러 함수 추가
2.  `subprocess` 모듈의 핵심 함수, 특히 `subprocess.Popen`, `subprocess.run()` 및 `command` 인수를 받는 다른 관련 함수에 `t-string` 지원 추가

### `shlex`에 셸 이스케이프를 위한 렌더러 추가

참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 `shlex` 모듈에 추가될 것입니다. 이 렌더러는 `sh`라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 `shlex.quote`를 호출하는 것과 동일하게 작동합니다.

따라서 다음 코드는:

```python
os.system(shlex.sh(t"cat {myfile}"))
```

다음과 동일하게 동작합니다.

```python
os.system("cat " + shlex.quote(myfile))
```

`shlex.sh`의 추가는 `subprocess` 문서에서 `shell=True` 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, `os.system()` 문서에서 상위 수준의 `subprocess` API를 참조하는 것도 변경하지 않습니다.

`t-string` 프로세서 구현은 다음과 같습니다.

```python
from string.templatelib import Template, Interpolation
from shlex import quote, join # shlex.quote와 shlex.join을 가정

def sh(template: Template) -> str:
    parts: list[str] = []
    for item in template:
        if isinstance(item, Interpolation):
            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.
            parts.append(quote(str(item.value)))
        else:
            parts.append(item)
    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.
    return join(parts)
```

이를 통해 셸 사용을 위한 `t-string`의 명시적인 이스케이프가 가능합니다.

```python
import shlex
import os

filename = "my file with spaces.txt" # 사용자 입력이라고 가정

# 안전한 POSIX-compliant 셸 명령 구성
command = shlex.sh(t"cat {filename}")
os.system(command) # cat "my file with spaces.txt" 와 동일하게 실행
```

### `subprocess` 모듈 변경 사항

`shlex` 모듈에 렌더러와 `template string`이 추가됨에 따라, `subprocess` 모듈은 `Popen`에 `template string`을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. `Popen`은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.

결과적으로, `subprocess.run()`과 같은 `subprocess.Popen`의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( `shell=False`의 경우 모든 시스템에서, `shell=True`의 경우 POSIX 시스템에서).

예를 들어:

```python
subprocess.run(t"cat {myfile}", shell=True)
```

위 코드는 이 PEP에서 제공하는 `shlex.sh` 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 `subprocess.run` 호출 내에서 `shlex`를 사용하는 것은 중복됩니다.

```python
subprocess.run(shlex.sh(t"cat {myfile}"), shell=True)
```

`run` 함수가 모든 템플릿 리터럴을 `shlex.sh`를 통해 자동으로 렌더링하기 때문입니다.

`subprocess.Popen`이 `shell=True` 없이 호출될 때도 `t-string` 지원은 `subprocess`에 더 인체공학적인 구문을 제공합니다. 예를 들어:

```python
subprocess.run(t"cat {myfile} --flag {value}")
```

위 코드는 다음과 동일합니다.

```python
subprocess.run(["cat", myfile, "--flag", value])
```

또는 더 정확하게는:

```python
subprocess.run(shlex.split(shlex.sh(t"cat {myfile} --flag {value}")))
```

이는 먼저 위에서 설명한 `shlex.sh` 렌더러를 사용한 다음, 그 결과에 대해 `shlex.split`을 사용함으로써 이루어집니다.

`subprocess.Popen._execute_child` 내부의 구현은 `t-string`을 확인할 것입니다.

```python
from string.templatelib import Template

if isinstance(args, Template):
    import shlex
    if shell:
        args = shlex.sh(args)
    else:
        args = shlex.split(shlex.sh(args))
```

## 하위 호환성 (Backwards Compatibility)

이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. `subprocess` 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.

## 보안 영향 (Security Implications)

이 PEP는 셸 명령과 함께 `f-string`을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.

그러나 `shell=True`가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. `cmd.exe` 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 `shlex.quote()`가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.

## 교육 방법 (How to Teach This)

이 기능은 `t-string`의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.

1.  명령 주입 문제와 `f-string`이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.
2.  전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.
3.  명시적인 셸 이스케이프를 위한 `shlex.sh` 렌더러를 소개합니다.

    ```python
    # 안전하지 않음:
    os.system(f"cat {filename}") # 잠재적인 명령 주입!

    # shlex.sh 사용 시 안전:
    os.system(shlex.sh(t"cat {filename}")) # 셸을 위한 명시적 이스케이프
    ```

4.  `subprocess` 모듈의 기본 `t-string` 지원을 소개합니다.

    ```python
    # 안전하지 않음:
    subprocess.run(f"cat {filename}", shell=True) # 잠재적인 명령 주입!

    # 안전하지만 장황함:
    subprocess.run(["cat", filename])

    # t-string 사용 시 안전하고 읽기 쉬움:
    subprocess.run(t"cat {filename}", shell=True) # filename을 자동으로 이스케이프
    subprocess.run(t"cat {filename}") # 자동으로 리스트 형태로 변환
    ```

구현은 `shlex` 및 `subprocess` 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.

### 비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기

`shlex.quote()`는 정규식 문자 세트 `[\w@%+=:,./-]`를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.

예를 들어, `subprocess.run(f"echo {shlex.quote(sys.argv[1])}", shell=True)`를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.

그러나 Python에서 `cmd.exe` (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.

이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.

## 저작권 (Copyright)

이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.


> ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.
</code></pre>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",2420,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Deferred] PEP 787 - Safer subprocess usage using t-strings"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-27 14:00:15+0900","children":"2025년 9월 27일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 27일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}],["$","$La",null,{"postPermalink":"/python/pep/787/","postId":"2025-09-27-pep-0787-safer-subprocess-usage-using-t-strings"}],["$","section",null,{"className":"mt-12 border-t border-gray-200 pt-8","children":[["$","h3",null,{"className":"text-base font-semibold text-gray-900 mb-4","children":["Python"," 의 다른글"]}],["$","ul",null,{"className":"space-y-2 text-sm","children":[["$","li",null,{"className":"text-gray-500","children":["이전글"," ",["$","$L7",null,{"href":"/python/pep/785/","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Draft] PEP 785 - New methods for easier handling ofExceptionGroups"}]]}],["$","li",null,{"className":"text-gray-900 font-semibold","children":["현재글 : ","[Deferred] PEP 787 - Safer subprocess usage using t-strings"]}],["$","li",null,{"className":"text-gray-500","children":["다음글"," ",["$","$L7",null,{"href":"/python/pep/788/","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Draft] PEP 788 - PyInterpreterRef: Interpreter References in the C API"}]]}]]}]]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://blog.secrett2633.cloud/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://blog.secrett2633.cloud/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","22",{"name":"next-size-adjust"}]]
1:null
