<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-1a135130af3e1cae.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1318<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Deferred] PEP 787 - Safer subprocess usage using t-strings</h1><div class="page__meta"><time dateTime="2025-09-27 14:00:15+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0787/">PEP 787 - Safer subprocess usage using t-strings</a></p>
<p><strong>상태:</strong> Deferred | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 13-Apr-2025</p>
</blockquote>
<h1>PEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용</h1>
<ul>
<li><strong>저자</strong>: Nick Humrich, Alyssa Coghlan</li>
<li><strong>상태</strong>: Deffered (연기됨)</li>
<li><strong>Python 버전</strong>: 3.15</li>
<li><strong>생성일</strong>: 2025년 4월 13일</li>
</ul>
<h2>개요 (Abstract)</h2>
<p>PEP 750에서 f-string의 일반화된 형태로 <code>template string (t-string)</code>이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 <code>subprocess</code> 및 <code>shlex</code> 모듈을 확장하여 <code>t-string</code>을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 <code>t-string</code> 기능의 참조 구현 역할도 합니다.</p>
<h2>PEP 연기 (PEP Deferral)</h2>
<p>초기 초안 논의 과정에서, <code>t-string</code>이 <code>shell=True</code>와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.</p>
<p>이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 <code>t-string</code> 기반의 <code>subprocess</code> 호출 라이브러리를 개발할 계획입니다.</p>
<h2>동기 (Motivation)</h2>
<p>PEP 750의 <code>template string (t-string)</code>은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. <code>t-string</code>의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.</p>
<p>예시:</p>
<pre><code class="language-python"># f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)
os.system(f"echo {message_from_user}")
# f-string 사용 시 역시 안전하지 않음
subprocess.run(f"echo {message_from_user}", shell=True)
# f-string 사용 시 실패
subprocess.run(f"echo {message_from_user}")

# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:
subprocess.run(t"echo {message_from_user}", shell=True)
# t-string 사용 시 모든 플랫폼에서 안전:
subprocess.run(t"echo {message_from_user}")
# t-string 없이 모든 플랫폼에서 안전 (더 장황함):
subprocess.run(["echo", str(message_from_user)])
</code></pre>
<p>현재 개발자들은 편의성(<code>f-string</code> 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. <code>subprocess</code> 모듈에 기본 <code>t-string</code> 지원을 추가함으로써, 이 PEP는 <code>t-string</code>의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.</p>
<h2>근거 (Rationale)</h2>
<p><code>subprocess</code> 모듈이 <code>t-string</code> 지원에 이상적인 후보인 이유는 다음과 같습니다.</p>
<ul>
<li>셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.</li>
<li><code>subprocess</code> 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.</li>
<li><code>t-string</code>과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.</li>
<li>이것은 개발자들이 즉시 이해하고 활용할 수 있는 <code>t-string</code>의 실용적인 쇼케이스 역할을 합니다.</li>
</ul>
<p><code>subprocess</code>를 확장하여 <code>t-string</code>을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 <code>f-string</code>을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.</p>
<h2>명세 (Specification)</h2>
<p>이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.</p>
<ol>
<li><code>shlex</code> 모듈에 안전한 셸 명령 구성을 위한 새로운 <code>sh()</code> 렌더러 함수 추가</li>
<li><code>subprocess</code> 모듈의 핵심 함수, 특히 <code>subprocess.Popen</code>, <code>subprocess.run()</code> 및 <code>command</code> 인수를 받는 다른 관련 함수에 <code>t-string</code> 지원 추가</li>
</ol>
<h3><code>shlex</code>에 셸 이스케이프를 위한 렌더러 추가</h3>
<p>참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 <code>shlex</code> 모듈에 추가될 것입니다. 이 렌더러는 <code>sh</code>라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 <code>shlex.quote</code>를 호출하는 것과 동일하게 작동합니다.</p>
<p>따라서 다음 코드는:</p>
<pre><code class="language-python">os.system(shlex.sh(t"cat {myfile}"))
</code></pre>
<p>다음과 동일하게 동작합니다.</p>
<pre><code class="language-python">os.system("cat " + shlex.quote(myfile))
</code></pre>
<p><code>shlex.sh</code>의 추가는 <code>subprocess</code> 문서에서 <code>shell=True</code> 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, <code>os.system()</code> 문서에서 상위 수준의 <code>subprocess</code> API를 참조하는 것도 변경하지 않습니다.</p>
<p><code>t-string</code> 프로세서 구현은 다음과 같습니다.</p>
<pre><code class="language-python">from string.templatelib import Template, Interpolation
from shlex import quote, join # shlex.quote와 shlex.join을 가정

def sh(template: Template) -> str:
    parts: list[str] = []
    for item in template:
        if isinstance(item, Interpolation):
            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.
            parts.append(quote(str(item.value)))
        else:
            parts.append(item)
    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.
    return join(parts)
</code></pre>
<p>이를 통해 셸 사용을 위한 <code>t-string</code>의 명시적인 이스케이프가 가능합니다.</p>
<pre><code class="language-python">import shlex
import os

filename = "my file with spaces.txt" # 사용자 입력이라고 가정

# 안전한 POSIX 호환 셸 명령 구성
command = shlex.sh(t"cat {filename}")
os.system(command) # cat "my file with spaces.txt" 와 동일하게 실행
</code></pre>
<h3><code>subprocess</code> 모듈 변경 사항</h3>
<p><code>shlex</code> 모듈에 렌더러와 <code>template string</code>이 추가됨에 따라, <code>subprocess</code> 모듈은 <code>Popen</code>에 <code>template string</code>을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. <code>Popen</code>은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.</p>
<p>결과적으로, <code>subprocess.run()</code>과 같은 <code>subprocess.Popen</code>의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( <code>shell=False</code>의 경우 모든 시스템에서, <code>shell=True</code>의 경우 POSIX 시스템에서).</p>
<p>예를 들어:</p>
<pre><code class="language-python">subprocess.run(t"cat {myfile}", shell=True)
</code></pre>
<p>위 코드는 이 PEP에서 제공하는 <code>shlex.sh</code> 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 <code>subprocess.run</code> 호출 내에서 <code>shlex</code>를 사용하는 것은 중복됩니다.</p>
<pre><code class="language-python">subprocess.run(shlex.sh(t"cat {myfile}"), shell=True)
</code></pre>
<p><code>run</code> 함수가 모든 템플릿 리터럴을 <code>shlex.sh</code>를 통해 자동으로 렌더링하기 때문입니다.</p>
<p><code>subprocess.Popen</code>이 <code>shell=True</code> 없이 호출될 때도 <code>t-string</code> 지원은 <code>subprocess</code>에 더 인체공학적인 구문을 제공합니다. 예를 들어:</p>
<pre><code class="language-python">subprocess.run(t"cat {myfile} --flag {value}")
</code></pre>
<p>위 코드는 다음과 동일합니다.</p>
<pre><code class="language-python">subprocess.run(["cat", myfile, "--flag", value])
</code></pre>
<p>또는 더 정확하게는:</p>
<pre><code class="language-python">subprocess.run(shlex.split(shlex.sh(t"cat {myfile} --flag {value}")))
</code></pre>
<p>이는 먼저 위에서 설명한 <code>shlex.sh</code> 렌더러를 사용한 다음, 그 결과에 대해 <code>shlex.split</code>을 사용함으로써 이루어집니다.</p>
<p><code>subprocess.Popen._execute_child</code> 내부의 구현은 <code>t-string</code>을 확인할 것입니다.</p>
<pre><code class="language-python">from string.templatelib import Template

if isinstance(args, Template):
    import shlex
    if shell:
        args = shlex.sh(args)
    else:
        args = shlex.split(shlex.sh(args))
</code></pre>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. <code>subprocess</code> 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.</p>
<h2>보안 영향 (Security Implications)</h2>
<p>이 PEP는 셸 명령과 함께 <code>f-string</code>을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.</p>
<p>그러나 <code>shell=True</code>가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. <code>cmd.exe</code> 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 <code>shlex.quote()</code>가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.</p>
<h2>교육 방법 (How to Teach This)</h2>
<p>이 기능은 <code>t-string</code>의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.</p>
<ol>
<li>
<p>명령 주입 문제와 <code>f-string</code>이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.</p>
</li>
<li>
<p>전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.</p>
</li>
<li>
<p>명시적인 셸 이스케이프를 위한 <code>shlex.sh</code> 렌더러를 소개합니다.</p>
<pre><code class="language-python"># 안전하지 않음:
os.system(f"cat {filename}") # 잠재적인 명령 주입!

# shlex.sh 사용 시 안전:
os.system(shlex.sh(t"cat {filename}")) # 셸을 위한 명시적 이스케이프
</code></pre>
</li>
<li>
<p><code>subprocess</code> 모듈의 기본 <code>t-string</code> 지원을 소개합니다.</p>
<pre><code class="language-python"># 안전하지 않음:
subprocess.run(f"cat {filename}", shell=True) # 잠재적인 명령 주입!

# 안전하지만 장황함:
subprocess.run(["cat", filename])

# t-string 사용 시 안전하고 읽기 쉬움:
subprocess.run(t"cat {filename}", shell=True) # filename을 자동으로 이스케이프
subprocess.run(t"cat {filename}") # 자동으로 리스트 형태로 변환
</code></pre>
</li>
</ol>
<p>구현은 <code>shlex</code> 및 <code>subprocess</code> 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.</p>
<h3>비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기</h3>
<p><code>shlex.quote()</code>는 정규식 문자 세트 <code>[\w@%+=:,./-]</code>를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.</p>
<p>예를 들어, <code>subprocess.run(f"echo {shlex.quote(sys.argv[1])}", shell=True)</code>를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.</p>
<p>그러나 Python에서 <code>cmd.exe</code> (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.</p>
<p>이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.</p>
<p>I have translated and structured the content as requested. I have also added citations for every sentence derived from the browsed URL.</p>
<pre><code class="language-markdown"># PEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용

*   **저자**: Nick Humrich, Alyssa Coghlan
*   **상태**: Deferred (연기됨)
*   **Python 버전**: 3.15
*   **생성일**: 2025년 4월 13일

## 개요 (Abstract)

PEP 750에서 f-string의 일반화된 형태로 `template string (t-string)`이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 `subprocess` 및 `shlex` 모듈을 확장하여 `t-string`을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 `t-string` 기능의 참조 구현 역할도 합니다.

## PEP 연기 (PEP Deferral)

초기 초안 논의 과정에서, `t-string`이 `shell=True`와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.

이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 `t-string` 기반의 `subprocess` 호출 라이브러리를 개발할 계획입니다.

## 동기 (Motivation)

PEP 750의 `template string (t-string)`은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. `t-string`의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.

예시:

```python
# f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)
os.system(f"echo {message_from_user}")
# f-string 사용 시 역시 안전하지 않음
subprocess.run(f"echo {message_from_user}", shell=True)
# f-string 사용 시 실패
subprocess.run(f"echo {message_from_user}")

# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:
subprocess.run(t"echo {message_from_user}", shell=True)
# t-string 사용 시 모든 플랫폼에서 안전:
subprocess.run(t"echo {message_from_user}")
# t-string 없이 모든 플랫폼에서 안전 (더 장황함):
subprocess.run(["echo", str(message_from_user)])
</code></pre>
<p>현재 개발자들은 편의성(<code>f-string</code> 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. <code>subprocess</code> 모듈에 기본 <code>t-string</code> 지원을 추가함으로써, 이 PEP는 <code>t-string</code>의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.</p>
<h2>근거 (Rationale)</h2>
<p><code>subprocess</code> 모듈이 <code>t-string</code> 지원에 이상적인 후보인 이유는 다음과 같습니다.</p>
<ul>
<li>셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.</li>
<li><code>subprocess</code> 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.</li>
<li><code>t-string</code>과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.</li>
<li>이것은 개발자들이 즉시 이해하고 활용할 수 있는 <code>t-string</code>의 실용적인 쇼케이스 역할을 합니다.</li>
</ul>
<p><code>subprocess</code>를 확장하여 <code>t-string</code>을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 <code>f-string</code>을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.</p>
<h2>명세 (Specification)</h2>
<p>이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.</p>
<ol>
<li><code>shlex</code> 모듈에 안전한 셸 명령 구성을 위한 새로운 <code>sh()</code> 렌더러 함수 추가</li>
<li><code>subprocess</code> 모듈의 핵심 함수, 특히 <code>subprocess.Popen</code>, <code>subprocess.run()</code> 및 <code>command</code> 인수를 받는 다른 관련 함수에 <code>t-string</code> 지원 추가</li>
</ol>
<h3><code>shlex</code>에 셸 이스케이프를 위한 렌더러 추가</h3>
<p>참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 <code>shlex</code> 모듈에 추가될 것입니다. 이 렌더러는 <code>sh</code>라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 <code>shlex.quote</code>를 호출하는 것과 동일하게 작동합니다.</p>
<p>따라서 다음 코드는:</p>
<pre><code class="language-python">os.system(shlex.sh(t"cat {myfile}"))
</code></pre>
<p>다음과 동일하게 동작합니다.</p>
<pre><code class="language-python">os.system("cat " + shlex.quote(myfile))
</code></pre>
<p><code>shlex.sh</code>의 추가는 <code>subprocess</code> 문서에서 <code>shell=True</code> 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, <code>os.system()</code> 문서에서 상위 수준의 <code>subprocess</code> API를 참조하는 것도 변경하지 않습니다.</p>
<p><code>t-string</code> 프로세서 구현은 다음과 같습니다.</p>
<pre><code class="language-python">from string.templatelib import Template, Interpolation
from shlex import quote, join # shlex.quote와 shlex.join을 가정

def sh(template: Template) -> str:
    parts: list[str] = []
    for item in template:
        if isinstance(item, Interpolation):
            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.
            parts.append(quote(str(item.value)))
        else:
            parts.append(item)
    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.
    return join(parts)
</code></pre>
<p>이를 통해 셸 사용을 위한 <code>t-string</code>의 명시적인 이스케이프가 가능합니다.</p>
<pre><code class="language-python">import shlex
import os

filename = "my file with spaces.txt" # 사용자 입력이라고 가정

# 안전한 POSIX-compliant 셸 명령 구성
command = shlex.sh(t"cat {filename}")
os.system(command) # cat "my file with spaces.txt" 와 동일하게 실행
</code></pre>
<h3><code>subprocess</code> 모듈 변경 사항</h3>
<p><code>shlex</code> 모듈에 렌더러와 <code>template string</code>이 추가됨에 따라, <code>subprocess</code> 모듈은 <code>Popen</code>에 <code>template string</code>을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. <code>Popen</code>은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.</p>
<p>결과적으로, <code>subprocess.run()</code>과 같은 <code>subprocess.Popen</code>의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( <code>shell=False</code>의 경우 모든 시스템에서, <code>shell=True</code>의 경우 POSIX 시스템에서).</p>
<p>예를 들어:</p>
<pre><code class="language-python">subprocess.run(t"cat {myfile}", shell=True)
</code></pre>
<p>위 코드는 이 PEP에서 제공하는 <code>shlex.sh</code> 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 <code>subprocess.run</code> 호출 내에서 <code>shlex</code>를 사용하는 것은 중복됩니다.</p>
<pre><code class="language-python">subprocess.run(shlex.sh(t"cat {myfile}"), shell=True)
</code></pre>
<p><code>run</code> 함수가 모든 템플릿 리터럴을 <code>shlex.sh</code>를 통해 자동으로 렌더링하기 때문입니다.</p>
<p><code>subprocess.Popen</code>이 <code>shell=True</code> 없이 호출될 때도 <code>t-string</code> 지원은 <code>subprocess</code>에 더 인체공학적인 구문을 제공합니다. 예를 들어:</p>
<pre><code class="language-python">subprocess.run(t"cat {myfile} --flag {value}")
</code></pre>
<p>위 코드는 다음과 동일합니다.</p>
<pre><code class="language-python">subprocess.run(["cat", myfile, "--flag", value])
</code></pre>
<p>또는 더 정확하게는:</p>
<pre><code class="language-python">subprocess.run(shlex.split(shlex.sh(t"cat {myfile} --flag {value}")))
</code></pre>
<p>이는 먼저 위에서 설명한 <code>shlex.sh</code> 렌더러를 사용한 다음, 그 결과에 대해 <code>shlex.split</code>을 사용함으로써 이루어집니다.</p>
<p><code>subprocess.Popen._execute_child</code> 내부의 구현은 <code>t-string</code>을 확인할 것입니다.</p>
<pre><code class="language-python">from string.templatelib import Template

if isinstance(args, Template):
    import shlex
    if shell:
        args = shlex.sh(args)
    else:
        args = shlex.split(shlex.sh(args))
</code></pre>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. <code>subprocess</code> 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.</p>
<h2>보안 영향 (Security Implications)</h2>
<p>이 PEP는 셸 명령과 함께 <code>f-string</code>을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.</p>
<p>그러나 <code>shell=True</code>가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. <code>cmd.exe</code> 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 <code>shlex.quote()</code>가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.</p>
<h2>교육 방법 (How to Teach This)</h2>
<p>이 기능은 <code>t-string</code>의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.</p>
<ol>
<li>
<p>명령 주입 문제와 <code>f-string</code>이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.</p>
</li>
<li>
<p>전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.</p>
</li>
<li>
<p>명시적인 셸 이스케이프를 위한 <code>shlex.sh</code> 렌더러를 소개합니다.</p>
<pre><code class="language-python"># 안전하지 않음:
os.system(f"cat {filename}") # 잠재적인 명령 주입!

# shlex.sh 사용 시 안전:
os.system(shlex.sh(t"cat {filename}")) # 셸을 위한 명시적 이스케이프
</code></pre>
</li>
<li>
<p><code>subprocess</code> 모듈의 기본 <code>t-string</code> 지원을 소개합니다.</p>
<pre><code class="language-python"># 안전하지 않음:
subprocess.run(f"cat {filename}", shell=True) # 잠재적인 명령 주입!

# 안전하지만 장황함:
subprocess.run(["cat", filename])

# t-string 사용 시 안전하고 읽기 쉬움:
subprocess.run(t"cat {filename}", shell=True) # filename을 자동으로 이스케이프
subprocess.run(t"cat {filename}") # 자동으로 리스트 형태로 변환
</code></pre>
</li>
</ol>
<p>구현은 <code>shlex</code> 및 <code>subprocess</code> 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.</p>
<h3>비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기</h3>
<p><code>shlex.quote()</code>는 정규식 문자 세트 <code>[\w@%+=:,./-]</code>를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.</p>
<p>예를 들어, <code>subprocess.run(f"echo {shlex.quote(sys.argv[1])}", shell=True)</code>를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.</p>
<p>그러나 Python에서 <code>cmd.exe</code> (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.</p>
<p>이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.</p>
<pre><code># PEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용

*   **저자**: Nick Humrich, Alyssa Coghlan
*   **상태**: Deferred (연기됨)
*   **Python 버전**: 3.15
*   **생성일**: 2025년 4월 13일

## 개요 (Abstract)

PEP 750에서 f-string의 일반화된 형태로 `template string (t-string)`이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 `subprocess` 및 `shlex` 모듈을 확장하여 `t-string`을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 `t-string` 기능의 참조 구현 역할도 합니다.

## PEP 연기 (PEP Deferral)

초기 초안 논의 과정에서, `t-string`이 `shell=True`와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.

이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 `t-string` 기반의 `subprocess` 호출 라이브러리를 개발할 계획입니다.

## 동기 (Motivation)

PEP 750의 `template string (t-string)`은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. `t-string`의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.

예시:

```python
# f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)
os.system(f"echo {message_from_user}")
# f-string 사용 시 역시 안전하지 않음
subprocess.run(f"echo {message_from_user}", shell=True)
# f-string 사용 시 실패
subprocess.run(f"echo {message_from_user}")

# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:
subprocess.run(t"echo {message_from_user}", shell=True)
# t-string 사용 시 모든 플랫폼에서 안전:
subprocess.run(t"echo {message_from_user}")
# t-string 없이 모든 플랫폼에서 안전 (더 장황함):
subprocess.run(["echo", str(message_from_user)])
```

현재 개발자들은 편의성(`f-string` 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. `subprocess` 모듈에 기본 `t-string` 지원을 추가함으로써, 이 PEP는 `t-string`의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.

## 근거 (Rationale)

`subprocess` 모듈이 `t-string` 지원에 이상적인 후보인 이유는 다음과 같습니다.

*   셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.
*   `subprocess` 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.
*   `t-string`과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.
*   이것은 개발자들이 즉시 이해하고 활용할 수 있는 `t-string`의 실용적인 쇼케이스 역할을 합니다.

`subprocess`를 확장하여 `t-string`을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 `f-string`을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.

## 명세 (Specification)

이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.

1.  `shlex` 모듈에 안전한 셸 명령 구성을 위한 새로운 `sh()` 렌더러 함수 추가
2.  `subprocess` 모듈의 핵심 함수, 특히 `subprocess.Popen`, `subprocess.run()` 및 `command` 인수를 받는 다른 관련 함수에 `t-string` 지원 추가

### `shlex`에 셸 이스케이프를 위한 렌더러 추가

참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 `shlex` 모듈에 추가될 것입니다. 이 렌더러는 `sh`라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 `shlex.quote`를 호출하는 것과 동일하게 작동합니다.

따라서 다음 코드는:

```python
os.system(shlex.sh(t"cat {myfile}"))
```

다음과 동일하게 동작합니다.

```python
os.system("cat " + shlex.quote(myfile))
```

`shlex.sh`의 추가는 `subprocess` 문서에서 `shell=True` 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, `os.system()` 문서에서 상위 수준의 `subprocess` API를 참조하는 것도 변경하지 않습니다.

`t-string` 프로세서 구현은 다음과 같습니다.

```python
from string.templatelib import Template, Interpolation
from shlex import quote, join # shlex.quote와 shlex.join을 가정

def sh(template: Template) -> str:
    parts: list[str] = []
    for item in template:
        if isinstance(item, Interpolation):
            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.
            parts.append(quote(str(item.value)))
        else:
            parts.append(item)
    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.
    return join(parts)
```

이를 통해 셸 사용을 위한 `t-string`의 명시적인 이스케이프가 가능합니다.

```python
import shlex
import os

filename = "my file with spaces.txt" # 사용자 입력이라고 가정

# 안전한 POSIX-compliant 셸 명령 구성
command = shlex.sh(t"cat {filename}")
os.system(command) # cat "my file with spaces.txt" 와 동일하게 실행
```

### `subprocess` 모듈 변경 사항

`shlex` 모듈에 렌더러와 `template string`이 추가됨에 따라, `subprocess` 모듈은 `Popen`에 `template string`을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. `Popen`은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.

결과적으로, `subprocess.run()`과 같은 `subprocess.Popen`의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( `shell=False`의 경우 모든 시스템에서, `shell=True`의 경우 POSIX 시스템에서).

예를 들어:

```python
subprocess.run(t"cat {myfile}", shell=True)
```

위 코드는 이 PEP에서 제공하는 `shlex.sh` 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 `subprocess.run` 호출 내에서 `shlex`를 사용하는 것은 중복됩니다.

```python
subprocess.run(shlex.sh(t"cat {myfile}"), shell=True)
```

`run` 함수가 모든 템플릿 리터럴을 `shlex.sh`를 통해 자동으로 렌더링하기 때문입니다.

`subprocess.Popen`이 `shell=True` 없이 호출될 때도 `t-string` 지원은 `subprocess`에 더 인체공학적인 구문을 제공합니다. 예를 들어:

```python
subprocess.run(t"cat {myfile} --flag {value}")
```

위 코드는 다음과 동일합니다.

```python
subprocess.run(["cat", myfile, "--flag", value])
```

또는 더 정확하게는:

```python
subprocess.run(shlex.split(shlex.sh(t"cat {myfile} --flag {value}")))
```

이는 먼저 위에서 설명한 `shlex.sh` 렌더러를 사용한 다음, 그 결과에 대해 `shlex.split`을 사용함으로써 이루어집니다.

`subprocess.Popen._execute_child` 내부의 구현은 `t-string`을 확인할 것입니다.

```python
from string.templatelib import Template

if isinstance(args, Template):
    import shlex
    if shell:
        args = shlex.sh(args)
    else:
        args = shlex.split(shlex.sh(args))
```

## 하위 호환성 (Backwards Compatibility)

이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. `subprocess` 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.

## 보안 영향 (Security Implications)

이 PEP는 셸 명령과 함께 `f-string`을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.

그러나 `shell=True`가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. `cmd.exe` 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 `shlex.quote()`가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.

## 교육 방법 (How to Teach This)

이 기능은 `t-string`의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.

1.  명령 주입 문제와 `f-string`이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.
2.  전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.
3.  명시적인 셸 이스케이프를 위한 `shlex.sh` 렌더러를 소개합니다.

    ```python
    # 안전하지 않음:
    os.system(f"cat {filename}") # 잠재적인 명령 주입!

    # shlex.sh 사용 시 안전:
    os.system(shlex.sh(t"cat {filename}")) # 셸을 위한 명시적 이스케이프
    ```

4.  `subprocess` 모듈의 기본 `t-string` 지원을 소개합니다.

    ```python
    # 안전하지 않음:
    subprocess.run(f"cat {filename}", shell=True) # 잠재적인 명령 주입!

    # 안전하지만 장황함:
    subprocess.run(["cat", filename])

    # t-string 사용 시 안전하고 읽기 쉬움:
    subprocess.run(t"cat {filename}", shell=True) # filename을 자동으로 이스케이프
    subprocess.run(t"cat {filename}") # 자동으로 리스트 형태로 변환
    ```

구현은 `shlex` 및 `subprocess` 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.

### 비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기

`shlex.quote()`는 정규식 문자 세트 `[\w@%+=:,./-]`를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.

예를 들어, `subprocess.run(f"echo {shlex.quote(sys.argv[1])}", shell=True)`를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.

그러나 Python에서 `cmd.exe` (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.

이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.

## 저작권 (Copyright)

이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.
```# PEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용

*   **저자**: Nick Humrich, Alyssa Coghlan
*   **상태**: Deferred (연기됨)
*   **Python 버전**: 3.15
*   **생성일**: 2025년 4월 13일

## 개요 (Abstract)

PEP 750에서 f-string의 일반화된 형태로 `template string (t-string)`이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 `subprocess` 및 `shlex` 모듈을 확장하여 `t-string`을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 `t-string` 기능의 참조 구현 역할도 합니다.

## PEP 연기 (PEP Deferral)

초기 초안 논의 과정에서, `t-string`이 `shell=True`와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.

이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 `t-string` 기반의 `subprocess` 호출 라이브러리를 개발할 계획입니다.

## 동기 (Motivation)

PEP 750의 `template string (t-string)`은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. `t-string`의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.

예시:

```python
# f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)
os.system(f"echo {message_from_user}")
# f-string 사용 시 역시 안전하지 않음
subprocess.run(f"echo {message_from_user}", shell=True)
# f-string 사용 시 실패
subprocess.run(f"echo {message_from_user}")

# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:
subprocess.run(t"echo {message_from_user}", shell=True)
# t-string 사용 시 모든 플랫폼에서 안전:
subprocess.run(t"echo {message_from_user}")
# t-string 없이 모든 플랫폼에서 안전 (더 장황함):
subprocess.run(["echo", str(message_from_user)])
```

현재 개발자들은 편의성(`f-string` 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. `subprocess` 모듈에 기본 `t-string` 지원을 추가함으로써, 이 PEP는 `t-string`의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.

## 근거 (Rationale)

`subprocess` 모듈이 `t-string` 지원에 이상적인 후보인 이유는 다음과 같습니다.

*   셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.
*   `subprocess` 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.
*   `t-string`과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.
*   이것은 개발자들이 즉시 이해하고 활용할 수 있는 `t-string`의 실용적인 쇼케이스 역할을 합니다.

`subprocess`를 확장하여 `t-string`을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 `f-string`을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.

## 명세 (Specification)

이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.

1.  `shlex` 모듈에 안전한 셸 명령 구성을 위한 새로운 `sh()` 렌더러 함수 추가
2.  `subprocess` 모듈의 핵심 함수, 특히 `subprocess.Popen`, `subprocess.run()` 및 `command` 인수를 받는 다른 관련 함수에 `t-string` 지원 추가

### `shlex`에 셸 이스케이프를 위한 렌더러 추가

참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 `shlex` 모듈에 추가될 것입니다. 이 렌더러는 `sh`라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 `shlex.quote`를 호출하는 것과 동일하게 작동합니다.

따라서 다음 코드는:

```python
os.system(shlex.sh(t"cat {myfile}"))
```

다음과 동일하게 동작합니다.

```python
os.system("cat " + shlex.quote(myfile))
```

`shlex.sh`의 추가는 `subprocess` 문서에서 `shell=True` 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, `os.system()` 문서에서 상위 수준의 `subprocess` API를 참조하는 것도 변경하지 않습니다.

`t-string` 프로세서 구현은 다음과 같습니다.

```python
from string.templatelib import Template, Interpolation
from shlex import quote, join # shlex.quote와 shlex.join을 가정

def sh(template: Template) -> str:
    parts: list[str] = []
    for item in template:
        if isinstance(item, Interpolation):
            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.
            parts.append(quote(str(item.value)))
        else:
            parts.append(item)
    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.
    return join(parts)
```

이를 통해 셸 사용을 위한 `t-string`의 명시적인 이스케이프가 가능합니다.

```python
import shlex
import os

filename = "my file with spaces.txt" # 사용자 입력이라고 가정

# 안전한 POSIX-compliant 셸 명령 구성
command = shlex.sh(t"cat {filename}")
os.system(command) # cat "my file with spaces.txt" 와 동일하게 실행
```

### `subprocess` 모듈 변경 사항

`shlex` 모듈에 렌더러와 `template string`이 추가됨에 따라, `subprocess` 모듈은 `Popen`에 `template string`을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. `Popen`은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.

결과적으로, `subprocess.run()`과 같은 `subprocess.Popen`의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( `shell=False`의 경우 모든 시스템에서, `shell=True`의 경우 POSIX 시스템에서).

예를 들어:

```python
subprocess.run(t"cat {myfile}", shell=True)
```

위 코드는 이 PEP에서 제공하는 `shlex.sh` 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 `subprocess.run` 호출 내에서 `shlex`를 사용하는 것은 중복됩니다.

```python
subprocess.run(shlex.sh(t"cat {myfile}"), shell=True)
```

`run` 함수가 모든 템플릿 리터럴을 `shlex.sh`를 통해 자동으로 렌더링하기 때문입니다.

`subprocess.Popen`이 `shell=True` 없이 호출될 때도 `t-string` 지원은 `subprocess`에 더 인체공학적인 구문을 제공합니다. 예를 들어:

```python
subprocess.run(t"cat {myfile} --flag {value}")
```

위 코드는 다음과 동일합니다.

```python
subprocess.run(["cat", myfile, "--flag", value])
```

또는 더 정확하게는:

```python
subprocess.run(shlex.split(shlex.sh(t"cat {myfile} --flag {value}")))
```

이는 먼저 위에서 설명한 `shlex.sh` 렌더러를 사용한 다음, 그 결과에 대해 `shlex.split`을 사용함으로써 이루어집니다.

`subprocess.Popen._execute_child` 내부의 구현은 `t-string`을 확인할 것입니다.

```python
from string.templatelib import Template

if isinstance(args, Template):
    import shlex
    if shell:
        args = shlex.sh(args)
    else:
        args = shlex.split(shlex.sh(args))
```

## 하위 호환성 (Backwards Compatibility)

이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. `subprocess` 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.

## 보안 영향 (Security Implications)

이 PEP는 셸 명령과 함께 `f-string`을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.

그러나 `shell=True`가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. `cmd.exe` 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 `shlex.quote()`가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.

## 교육 방법 (How to Teach This)

이 기능은 `t-string`의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.

1.  명령 주입 문제와 `f-string`이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.
2.  전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.
3.  명시적인 셸 이스케이프를 위한 `shlex.sh` 렌더러를 소개합니다.

    ```python
    # 안전하지 않음:
    os.system(f"cat {filename}") # 잠재적인 명령 주입!

    # shlex.sh 사용 시 안전:
    os.system(shlex.sh(t"cat {filename}")) # 셸을 위한 명시적 이스케이프
    ```

4.  `subprocess` 모듈의 기본 `t-string` 지원을 소개합니다.

    ```python
    # 안전하지 않음:
    subprocess.run(f"cat {filename}", shell=True) # 잠재적인 명령 주입!

    # 안전하지만 장황함:
    subprocess.run(["cat", filename])

    # t-string 사용 시 안전하고 읽기 쉬움:
    subprocess.run(t"cat {filename}", shell=True) # filename을 자동으로 이스케이프
    subprocess.run(t"cat {filename}") # 자동으로 리스트 형태로 변환
    ```

구현은 `shlex` 및 `subprocess` 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.

### 비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기

`shlex.quote()`는 정규식 문자 세트 `[\w@%+=:,./-]`를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.

예를 들어, `subprocess.run(f"echo {shlex.quote(sys.argv[1])}", shell=True)`를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.

그러나 Python에서 `cmd.exe` (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.

이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.

## 저작권 (Copyright)

이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.


> ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.
</code></pre>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-1a135130af3e1cae.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/787\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"8N6icDw00Cy0kKVlExSq2\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/787/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/787\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"787\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/787\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:Tc221,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0787/\"\u003ePEP 787 - Safer subprocess usage using t-strings\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Deferred | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 13-Apr-2025\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e저자\u003c/strong\u003e: Nick Humrich, Alyssa Coghlan\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태\u003c/strong\u003e: Deffered (연기됨)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전\u003c/strong\u003e: 3.15\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일\u003c/strong\u003e: 2025년 4월 13일\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003ePEP 750에서 f-string의 일반화된 형태로 \u003ccode\u003etemplate string (t-string)\u003c/code\u003e이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 \u003ccode\u003esubprocess\u003c/code\u003e 및 \u003ccode\u003eshlex\u003c/code\u003e 모듈을 확장하여 \u003ccode\u003et-string\u003c/code\u003e을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 \u003ccode\u003et-string\u003c/code\u003e 기능의 참조 구현 역할도 합니다.\u003c/p\u003e\n\u003ch2\u003ePEP 연기 (PEP Deferral)\u003c/h2\u003e\n\u003cp\u003e초기 초안 논의 과정에서, \u003ccode\u003et-string\u003c/code\u003e이 \u003ccode\u003eshell=True\u003c/code\u003e와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.\u003c/p\u003e\n\u003cp\u003e이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 \u003ccode\u003et-string\u003c/code\u003e 기반의 \u003ccode\u003esubprocess\u003c/code\u003e 호출 라이브러리를 개발할 계획입니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePEP 750의 \u003ccode\u003etemplate string (t-string)\u003c/code\u003e은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. \u003ccode\u003et-string\u003c/code\u003e의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)\r\nos.system(f\"echo {message_from_user}\")\r\n# f-string 사용 시 역시 안전하지 않음\r\nsubprocess.run(f\"echo {message_from_user}\", shell=True)\r\n# f-string 사용 시 실패\r\nsubprocess.run(f\"echo {message_from_user}\")\r\n\r\n# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:\r\nsubprocess.run(t\"echo {message_from_user}\", shell=True)\r\n# t-string 사용 시 모든 플랫폼에서 안전:\r\nsubprocess.run(t\"echo {message_from_user}\")\r\n# t-string 없이 모든 플랫폼에서 안전 (더 장황함):\r\nsubprocess.run([\"echo\", str(message_from_user)])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 개발자들은 편의성(\u003ccode\u003ef-string\u003c/code\u003e 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. \u003ccode\u003esubprocess\u003c/code\u003e 모듈에 기본 \u003ccode\u003et-string\u003c/code\u003e 지원을 추가함으로써, 이 PEP는 \u003ccode\u003et-string\u003c/code\u003e의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈이 \u003ccode\u003et-string\u003c/code\u003e 지원에 이상적인 후보인 이유는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003et-string\u003c/code\u003e과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.\u003c/li\u003e\n\u003cli\u003e이것은 개발자들이 즉시 이해하고 활용할 수 있는 \u003ccode\u003et-string\u003c/code\u003e의 실용적인 쇼케이스 역할을 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003esubprocess\u003c/code\u003e를 확장하여 \u003ccode\u003et-string\u003c/code\u003e을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 \u003ccode\u003ef-string\u003c/code\u003e을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eshlex\u003c/code\u003e 모듈에 안전한 셸 명령 구성을 위한 새로운 \u003ccode\u003esh()\u003c/code\u003e 렌더러 함수 추가\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈의 핵심 함수, 특히 \u003ccode\u003esubprocess.Popen\u003c/code\u003e, \u003ccode\u003esubprocess.run()\u003c/code\u003e 및 \u003ccode\u003ecommand\u003c/code\u003e 인수를 받는 다른 관련 함수에 \u003ccode\u003et-string\u003c/code\u003e 지원 추가\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003ccode\u003eshlex\u003c/code\u003e에 셸 이스케이프를 위한 렌더러 추가\u003c/h3\u003e\n\u003cp\u003e참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 \u003ccode\u003eshlex\u003c/code\u003e 모듈에 추가될 것입니다. 이 렌더러는 \u003ccode\u003esh\u003c/code\u003e라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 \u003ccode\u003eshlex.quote\u003c/code\u003e를 호출하는 것과 동일하게 작동합니다.\u003c/p\u003e\n\u003cp\u003e따라서 다음 코드는:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eos.system(shlex.sh(t\"cat {myfile}\"))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 동일하게 동작합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eos.system(\"cat \" + shlex.quote(myfile))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eshlex.sh\u003c/code\u003e의 추가는 \u003ccode\u003esubprocess\u003c/code\u003e 문서에서 \u003ccode\u003eshell=True\u003c/code\u003e 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, \u003ccode\u003eos.system()\u003c/code\u003e 문서에서 상위 수준의 \u003ccode\u003esubprocess\u003c/code\u003e API를 참조하는 것도 변경하지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003et-string\u003c/code\u003e 프로세서 구현은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom string.templatelib import Template, Interpolation\r\nfrom shlex import quote, join # shlex.quote와 shlex.join을 가정\r\n\r\ndef sh(template: Template) -\u003e str:\r\n    parts: list[str] = []\r\n    for item in template:\r\n        if isinstance(item, Interpolation):\r\n            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.\r\n            parts.append(quote(str(item.value)))\r\n        else:\r\n            parts.append(item)\r\n    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.\r\n    return join(parts)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 통해 셸 사용을 위한 \u003ccode\u003et-string\u003c/code\u003e의 명시적인 이스케이프가 가능합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport shlex\r\nimport os\r\n\r\nfilename = \"my file with spaces.txt\" # 사용자 입력이라고 가정\r\n\r\n# 안전한 POSIX 호환 셸 명령 구성\r\ncommand = shlex.sh(t\"cat {filename}\")\r\nos.system(command) # cat \"my file with spaces.txt\" 와 동일하게 실행\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈 변경 사항\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eshlex\u003c/code\u003e 모듈에 렌더러와 \u003ccode\u003etemplate string\u003c/code\u003e이 추가됨에 따라, \u003ccode\u003esubprocess\u003c/code\u003e 모듈은 \u003ccode\u003ePopen\u003c/code\u003e에 \u003ccode\u003etemplate string\u003c/code\u003e을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. \u003ccode\u003ePopen\u003c/code\u003e은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.\u003c/p\u003e\n\u003cp\u003e결과적으로, \u003ccode\u003esubprocess.run()\u003c/code\u003e과 같은 \u003ccode\u003esubprocess.Popen\u003c/code\u003e의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( \u003ccode\u003eshell=False\u003c/code\u003e의 경우 모든 시스템에서, \u003ccode\u003eshell=True\u003c/code\u003e의 경우 POSIX 시스템에서).\u003c/p\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esubprocess.run(t\"cat {myfile}\", shell=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 이 PEP에서 제공하는 \u003ccode\u003eshlex.sh\u003c/code\u003e 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 \u003ccode\u003esubprocess.run\u003c/code\u003e 호출 내에서 \u003ccode\u003eshlex\u003c/code\u003e를 사용하는 것은 중복됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esubprocess.run(shlex.sh(t\"cat {myfile}\"), shell=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003erun\u003c/code\u003e 함수가 모든 템플릿 리터럴을 \u003ccode\u003eshlex.sh\u003c/code\u003e를 통해 자동으로 렌더링하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esubprocess.Popen\u003c/code\u003e이 \u003ccode\u003eshell=True\u003c/code\u003e 없이 호출될 때도 \u003ccode\u003et-string\u003c/code\u003e 지원은 \u003ccode\u003esubprocess\u003c/code\u003e에 더 인체공학적인 구문을 제공합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esubprocess.run(t\"cat {myfile} --flag {value}\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 다음과 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esubprocess.run([\"cat\", myfile, \"--flag\", value])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 더 정확하게는:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esubprocess.run(shlex.split(shlex.sh(t\"cat {myfile} --flag {value}\")))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 먼저 위에서 설명한 \u003ccode\u003eshlex.sh\u003c/code\u003e 렌더러를 사용한 다음, 그 결과에 대해 \u003ccode\u003eshlex.split\u003c/code\u003e을 사용함으로써 이루어집니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esubprocess.Popen._execute_child\u003c/code\u003e 내부의 구현은 \u003ccode\u003et-string\u003c/code\u003e을 확인할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom string.templatelib import Template\r\n\r\nif isinstance(args, Template):\r\n    import shlex\r\n    if shell:\r\n        args = shlex.sh(args)\r\n    else:\r\n        args = shlex.split(shlex.sh(args))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. \u003ccode\u003esubprocess\u003c/code\u003e 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.\u003c/p\u003e\n\u003ch2\u003e보안 영향 (Security Implications)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 셸 명령과 함께 \u003ccode\u003ef-string\u003c/code\u003e을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e그러나 \u003ccode\u003eshell=True\u003c/code\u003e가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. \u003ccode\u003ecmd.exe\u003c/code\u003e 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 \u003ccode\u003eshlex.quote()\u003c/code\u003e가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.\u003c/p\u003e\n\u003ch2\u003e교육 방법 (How to Teach This)\u003c/h2\u003e\n\u003cp\u003e이 기능은 \u003ccode\u003et-string\u003c/code\u003e의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e명령 주입 문제와 \u003ccode\u003ef-string\u003c/code\u003e이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e명시적인 셸 이스케이프를 위한 \u003ccode\u003eshlex.sh\u003c/code\u003e 렌더러를 소개합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 안전하지 않음:\r\nos.system(f\"cat {filename}\") # 잠재적인 명령 주입!\r\n\r\n# shlex.sh 사용 시 안전:\r\nos.system(shlex.sh(t\"cat {filename}\")) # 셸을 위한 명시적 이스케이프\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈의 기본 \u003ccode\u003et-string\u003c/code\u003e 지원을 소개합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 안전하지 않음:\r\nsubprocess.run(f\"cat {filename}\", shell=True) # 잠재적인 명령 주입!\r\n\r\n# 안전하지만 장황함:\r\nsubprocess.run([\"cat\", filename])\r\n\r\n# t-string 사용 시 안전하고 읽기 쉬움:\r\nsubprocess.run(t\"cat {filename}\", shell=True) # filename을 자동으로 이스케이프\r\nsubprocess.run(t\"cat {filename}\") # 자동으로 리스트 형태로 변환\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e구현은 \u003ccode\u003eshlex\u003c/code\u003e 및 \u003ccode\u003esubprocess\u003c/code\u003e 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.\u003c/p\u003e\n\u003ch3\u003e비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eshlex.quote()\u003c/code\u003e는 정규식 문자 세트 \u003ccode\u003e[\\w@%+=:,./-]\u003c/code\u003e를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003esubprocess.run(f\"echo {shlex.quote(sys.argv[1])}\", shell=True)\u003c/code\u003e를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.\u003c/p\u003e\n\u003cp\u003e그러나 Python에서 \u003ccode\u003ecmd.exe\u003c/code\u003e (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.\u003c/p\u003e\n\u003cp\u003e이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.\u003c/p\u003e\n\u003cp\u003eI have translated and structured the content as requested. I have also added citations for every sentence derived from the browsed URL.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-markdown\"\u003e# PEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용\r\n\r\n*   **저자**: Nick Humrich, Alyssa Coghlan\r\n*   **상태**: Deferred (연기됨)\r\n*   **Python 버전**: 3.15\r\n*   **생성일**: 2025년 4월 13일\r\n\r\n## 개요 (Abstract)\r\n\r\nPEP 750에서 f-string의 일반화된 형태로 `template string (t-string)`이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 `subprocess` 및 `shlex` 모듈을 확장하여 `t-string`을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 `t-string` 기능의 참조 구현 역할도 합니다.\r\n\r\n## PEP 연기 (PEP Deferral)\r\n\r\n초기 초안 논의 과정에서, `t-string`이 `shell=True`와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.\r\n\r\n이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 `t-string` 기반의 `subprocess` 호출 라이브러리를 개발할 계획입니다.\r\n\r\n## 동기 (Motivation)\r\n\r\nPEP 750의 `template string (t-string)`은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. `t-string`의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.\r\n\r\n예시:\r\n\r\n```python\r\n# f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)\r\nos.system(f\"echo {message_from_user}\")\r\n# f-string 사용 시 역시 안전하지 않음\r\nsubprocess.run(f\"echo {message_from_user}\", shell=True)\r\n# f-string 사용 시 실패\r\nsubprocess.run(f\"echo {message_from_user}\")\r\n\r\n# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:\r\nsubprocess.run(t\"echo {message_from_user}\", shell=True)\r\n# t-string 사용 시 모든 플랫폼에서 안전:\r\nsubprocess.run(t\"echo {message_from_user}\")\r\n# t-string 없이 모든 플랫폼에서 안전 (더 장황함):\r\nsubprocess.run([\"echo\", str(message_from_user)])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 개발자들은 편의성(\u003ccode\u003ef-string\u003c/code\u003e 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. \u003ccode\u003esubprocess\u003c/code\u003e 모듈에 기본 \u003ccode\u003et-string\u003c/code\u003e 지원을 추가함으로써, 이 PEP는 \u003ccode\u003et-string\u003c/code\u003e의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈이 \u003ccode\u003et-string\u003c/code\u003e 지원에 이상적인 후보인 이유는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003et-string\u003c/code\u003e과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.\u003c/li\u003e\n\u003cli\u003e이것은 개발자들이 즉시 이해하고 활용할 수 있는 \u003ccode\u003et-string\u003c/code\u003e의 실용적인 쇼케이스 역할을 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003esubprocess\u003c/code\u003e를 확장하여 \u003ccode\u003et-string\u003c/code\u003e을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 \u003ccode\u003ef-string\u003c/code\u003e을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eshlex\u003c/code\u003e 모듈에 안전한 셸 명령 구성을 위한 새로운 \u003ccode\u003esh()\u003c/code\u003e 렌더러 함수 추가\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈의 핵심 함수, 특히 \u003ccode\u003esubprocess.Popen\u003c/code\u003e, \u003ccode\u003esubprocess.run()\u003c/code\u003e 및 \u003ccode\u003ecommand\u003c/code\u003e 인수를 받는 다른 관련 함수에 \u003ccode\u003et-string\u003c/code\u003e 지원 추가\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003ccode\u003eshlex\u003c/code\u003e에 셸 이스케이프를 위한 렌더러 추가\u003c/h3\u003e\n\u003cp\u003e참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 \u003ccode\u003eshlex\u003c/code\u003e 모듈에 추가될 것입니다. 이 렌더러는 \u003ccode\u003esh\u003c/code\u003e라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 \u003ccode\u003eshlex.quote\u003c/code\u003e를 호출하는 것과 동일하게 작동합니다.\u003c/p\u003e\n\u003cp\u003e따라서 다음 코드는:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eos.system(shlex.sh(t\"cat {myfile}\"))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 동일하게 동작합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eos.system(\"cat \" + shlex.quote(myfile))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eshlex.sh\u003c/code\u003e의 추가는 \u003ccode\u003esubprocess\u003c/code\u003e 문서에서 \u003ccode\u003eshell=True\u003c/code\u003e 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, \u003ccode\u003eos.system()\u003c/code\u003e 문서에서 상위 수준의 \u003ccode\u003esubprocess\u003c/code\u003e API를 참조하는 것도 변경하지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003et-string\u003c/code\u003e 프로세서 구현은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom string.templatelib import Template, Interpolation\r\nfrom shlex import quote, join # shlex.quote와 shlex.join을 가정\r\n\r\ndef sh(template: Template) -\u003e str:\r\n    parts: list[str] = []\r\n    for item in template:\r\n        if isinstance(item, Interpolation):\r\n            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.\r\n            parts.append(quote(str(item.value)))\r\n        else:\r\n            parts.append(item)\r\n    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.\r\n    return join(parts)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 통해 셸 사용을 위한 \u003ccode\u003et-string\u003c/code\u003e의 명시적인 이스케이프가 가능합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport shlex\r\nimport os\r\n\r\nfilename = \"my file with spaces.txt\" # 사용자 입력이라고 가정\r\n\r\n# 안전한 POSIX-compliant 셸 명령 구성\r\ncommand = shlex.sh(t\"cat {filename}\")\r\nos.system(command) # cat \"my file with spaces.txt\" 와 동일하게 실행\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈 변경 사항\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eshlex\u003c/code\u003e 모듈에 렌더러와 \u003ccode\u003etemplate string\u003c/code\u003e이 추가됨에 따라, \u003ccode\u003esubprocess\u003c/code\u003e 모듈은 \u003ccode\u003ePopen\u003c/code\u003e에 \u003ccode\u003etemplate string\u003c/code\u003e을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. \u003ccode\u003ePopen\u003c/code\u003e은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.\u003c/p\u003e\n\u003cp\u003e결과적으로, \u003ccode\u003esubprocess.run()\u003c/code\u003e과 같은 \u003ccode\u003esubprocess.Popen\u003c/code\u003e의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( \u003ccode\u003eshell=False\u003c/code\u003e의 경우 모든 시스템에서, \u003ccode\u003eshell=True\u003c/code\u003e의 경우 POSIX 시스템에서).\u003c/p\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esubprocess.run(t\"cat {myfile}\", shell=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 이 PEP에서 제공하는 \u003ccode\u003eshlex.sh\u003c/code\u003e 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 \u003ccode\u003esubprocess.run\u003c/code\u003e 호출 내에서 \u003ccode\u003eshlex\u003c/code\u003e를 사용하는 것은 중복됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esubprocess.run(shlex.sh(t\"cat {myfile}\"), shell=True)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003erun\u003c/code\u003e 함수가 모든 템플릿 리터럴을 \u003ccode\u003eshlex.sh\u003c/code\u003e를 통해 자동으로 렌더링하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esubprocess.Popen\u003c/code\u003e이 \u003ccode\u003eshell=True\u003c/code\u003e 없이 호출될 때도 \u003ccode\u003et-string\u003c/code\u003e 지원은 \u003ccode\u003esubprocess\u003c/code\u003e에 더 인체공학적인 구문을 제공합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esubprocess.run(t\"cat {myfile} --flag {value}\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 다음과 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esubprocess.run([\"cat\", myfile, \"--flag\", value])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 더 정확하게는:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esubprocess.run(shlex.split(shlex.sh(t\"cat {myfile} --flag {value}\")))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 먼저 위에서 설명한 \u003ccode\u003eshlex.sh\u003c/code\u003e 렌더러를 사용한 다음, 그 결과에 대해 \u003ccode\u003eshlex.split\u003c/code\u003e을 사용함으로써 이루어집니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esubprocess.Popen._execute_child\u003c/code\u003e 내부의 구현은 \u003ccode\u003et-string\u003c/code\u003e을 확인할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom string.templatelib import Template\r\n\r\nif isinstance(args, Template):\r\n    import shlex\r\n    if shell:\r\n        args = shlex.sh(args)\r\n    else:\r\n        args = shlex.split(shlex.sh(args))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. \u003ccode\u003esubprocess\u003c/code\u003e 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.\u003c/p\u003e\n\u003ch2\u003e보안 영향 (Security Implications)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 셸 명령과 함께 \u003ccode\u003ef-string\u003c/code\u003e을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e그러나 \u003ccode\u003eshell=True\u003c/code\u003e가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. \u003ccode\u003ecmd.exe\u003c/code\u003e 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 \u003ccode\u003eshlex.quote()\u003c/code\u003e가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.\u003c/p\u003e\n\u003ch2\u003e교육 방법 (How to Teach This)\u003c/h2\u003e\n\u003cp\u003e이 기능은 \u003ccode\u003et-string\u003c/code\u003e의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e명령 주입 문제와 \u003ccode\u003ef-string\u003c/code\u003e이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e명시적인 셸 이스케이프를 위한 \u003ccode\u003eshlex.sh\u003c/code\u003e 렌더러를 소개합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 안전하지 않음:\r\nos.system(f\"cat {filename}\") # 잠재적인 명령 주입!\r\n\r\n# shlex.sh 사용 시 안전:\r\nos.system(shlex.sh(t\"cat {filename}\")) # 셸을 위한 명시적 이스케이프\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈의 기본 \u003ccode\u003et-string\u003c/code\u003e 지원을 소개합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 안전하지 않음:\r\nsubprocess.run(f\"cat {filename}\", shell=True) # 잠재적인 명령 주입!\r\n\r\n# 안전하지만 장황함:\r\nsubprocess.run([\"cat\", filename])\r\n\r\n# t-string 사용 시 안전하고 읽기 쉬움:\r\nsubprocess.run(t\"cat {filename}\", shell=True) # filename을 자동으로 이스케이프\r\nsubprocess.run(t\"cat {filename}\") # 자동으로 리스트 형태로 변환\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e구현은 \u003ccode\u003eshlex\u003c/code\u003e 및 \u003ccode\u003esubprocess\u003c/code\u003e 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.\u003c/p\u003e\n\u003ch3\u003e비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eshlex.quote()\u003c/code\u003e는 정규식 문자 세트 \u003ccode\u003e[\\w@%+=:,./-]\u003c/code\u003e를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003esubprocess.run(f\"echo {shlex.quote(sys.argv[1])}\", shell=True)\u003c/code\u003e를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.\u003c/p\u003e\n\u003cp\u003e그러나 Python에서 \u003ccode\u003ecmd.exe\u003c/code\u003e (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.\u003c/p\u003e\n\u003cp\u003e이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# PEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용\r\n\r\n*   **저자**: Nick Humrich, Alyssa Coghlan\r\n*   **상태**: Deferred (연기됨)\r\n*   **Python 버전**: 3.15\r\n*   **생성일**: 2025년 4월 13일\r\n\r\n## 개요 (Abstract)\r\n\r\nPEP 750에서 f-string의 일반화된 형태로 `template string (t-string)`이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 `subprocess` 및 `shlex` 모듈을 확장하여 `t-string`을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 `t-string` 기능의 참조 구현 역할도 합니다.\r\n\r\n## PEP 연기 (PEP Deferral)\r\n\r\n초기 초안 논의 과정에서, `t-string`이 `shell=True`와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.\r\n\r\n이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 `t-string` 기반의 `subprocess` 호출 라이브러리를 개발할 계획입니다.\r\n\r\n## 동기 (Motivation)\r\n\r\nPEP 750의 `template string (t-string)`은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. `t-string`의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.\r\n\r\n예시:\r\n\r\n```python\r\n# f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)\r\nos.system(f\"echo {message_from_user}\")\r\n# f-string 사용 시 역시 안전하지 않음\r\nsubprocess.run(f\"echo {message_from_user}\", shell=True)\r\n# f-string 사용 시 실패\r\nsubprocess.run(f\"echo {message_from_user}\")\r\n\r\n# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:\r\nsubprocess.run(t\"echo {message_from_user}\", shell=True)\r\n# t-string 사용 시 모든 플랫폼에서 안전:\r\nsubprocess.run(t\"echo {message_from_user}\")\r\n# t-string 없이 모든 플랫폼에서 안전 (더 장황함):\r\nsubprocess.run([\"echo\", str(message_from_user)])\r\n```\r\n\r\n현재 개발자들은 편의성(`f-string` 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. `subprocess` 모듈에 기본 `t-string` 지원을 추가함으로써, 이 PEP는 `t-string`의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.\r\n\r\n## 근거 (Rationale)\r\n\r\n`subprocess` 모듈이 `t-string` 지원에 이상적인 후보인 이유는 다음과 같습니다.\r\n\r\n*   셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.\r\n*   `subprocess` 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.\r\n*   `t-string`과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.\r\n*   이것은 개발자들이 즉시 이해하고 활용할 수 있는 `t-string`의 실용적인 쇼케이스 역할을 합니다.\r\n\r\n`subprocess`를 확장하여 `t-string`을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 `f-string`을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.\r\n\r\n## 명세 (Specification)\r\n\r\n이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.\r\n\r\n1.  `shlex` 모듈에 안전한 셸 명령 구성을 위한 새로운 `sh()` 렌더러 함수 추가\r\n2.  `subprocess` 모듈의 핵심 함수, 특히 `subprocess.Popen`, `subprocess.run()` 및 `command` 인수를 받는 다른 관련 함수에 `t-string` 지원 추가\r\n\r\n### `shlex`에 셸 이스케이프를 위한 렌더러 추가\r\n\r\n참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 `shlex` 모듈에 추가될 것입니다. 이 렌더러는 `sh`라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 `shlex.quote`를 호출하는 것과 동일하게 작동합니다.\r\n\r\n따라서 다음 코드는:\r\n\r\n```python\r\nos.system(shlex.sh(t\"cat {myfile}\"))\r\n```\r\n\r\n다음과 동일하게 동작합니다.\r\n\r\n```python\r\nos.system(\"cat \" + shlex.quote(myfile))\r\n```\r\n\r\n`shlex.sh`의 추가는 `subprocess` 문서에서 `shell=True` 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, `os.system()` 문서에서 상위 수준의 `subprocess` API를 참조하는 것도 변경하지 않습니다.\r\n\r\n`t-string` 프로세서 구현은 다음과 같습니다.\r\n\r\n```python\r\nfrom string.templatelib import Template, Interpolation\r\nfrom shlex import quote, join # shlex.quote와 shlex.join을 가정\r\n\r\ndef sh(template: Template) -\u003e str:\r\n    parts: list[str] = []\r\n    for item in template:\r\n        if isinstance(item, Interpolation):\r\n            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.\r\n            parts.append(quote(str(item.value)))\r\n        else:\r\n            parts.append(item)\r\n    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.\r\n    return join(parts)\r\n```\r\n\r\n이를 통해 셸 사용을 위한 `t-string`의 명시적인 이스케이프가 가능합니다.\r\n\r\n```python\r\nimport shlex\r\nimport os\r\n\r\nfilename = \"my file with spaces.txt\" # 사용자 입력이라고 가정\r\n\r\n# 안전한 POSIX-compliant 셸 명령 구성\r\ncommand = shlex.sh(t\"cat {filename}\")\r\nos.system(command) # cat \"my file with spaces.txt\" 와 동일하게 실행\r\n```\r\n\r\n### `subprocess` 모듈 변경 사항\r\n\r\n`shlex` 모듈에 렌더러와 `template string`이 추가됨에 따라, `subprocess` 모듈은 `Popen`에 `template string`을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. `Popen`은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.\r\n\r\n결과적으로, `subprocess.run()`과 같은 `subprocess.Popen`의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( `shell=False`의 경우 모든 시스템에서, `shell=True`의 경우 POSIX 시스템에서).\r\n\r\n예를 들어:\r\n\r\n```python\r\nsubprocess.run(t\"cat {myfile}\", shell=True)\r\n```\r\n\r\n위 코드는 이 PEP에서 제공하는 `shlex.sh` 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 `subprocess.run` 호출 내에서 `shlex`를 사용하는 것은 중복됩니다.\r\n\r\n```python\r\nsubprocess.run(shlex.sh(t\"cat {myfile}\"), shell=True)\r\n```\r\n\r\n`run` 함수가 모든 템플릿 리터럴을 `shlex.sh`를 통해 자동으로 렌더링하기 때문입니다.\r\n\r\n`subprocess.Popen`이 `shell=True` 없이 호출될 때도 `t-string` 지원은 `subprocess`에 더 인체공학적인 구문을 제공합니다. 예를 들어:\r\n\r\n```python\r\nsubprocess.run(t\"cat {myfile} --flag {value}\")\r\n```\r\n\r\n위 코드는 다음과 동일합니다.\r\n\r\n```python\r\nsubprocess.run([\"cat\", myfile, \"--flag\", value])\r\n```\r\n\r\n또는 더 정확하게는:\r\n\r\n```python\r\nsubprocess.run(shlex.split(shlex.sh(t\"cat {myfile} --flag {value}\")))\r\n```\r\n\r\n이는 먼저 위에서 설명한 `shlex.sh` 렌더러를 사용한 다음, 그 결과에 대해 `shlex.split`을 사용함으로써 이루어집니다.\r\n\r\n`subprocess.Popen._execute_child` 내부의 구현은 `t-string`을 확인할 것입니다.\r\n\r\n```python\r\nfrom string.templatelib import Template\r\n\r\nif isinstance(args, Template):\r\n    import shlex\r\n    if shell:\r\n        args = shlex.sh(args)\r\n    else:\r\n        args = shlex.split(shlex.sh(args))\r\n```\r\n\r\n## 하위 호환성 (Backwards Compatibility)\r\n\r\n이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. `subprocess` 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.\r\n\r\n## 보안 영향 (Security Implications)\r\n\r\n이 PEP는 셸 명령과 함께 `f-string`을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.\r\n\r\n그러나 `shell=True`가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. `cmd.exe` 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 `shlex.quote()`가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.\r\n\r\n## 교육 방법 (How to Teach This)\r\n\r\n이 기능은 `t-string`의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.\r\n\r\n1.  명령 주입 문제와 `f-string`이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.\r\n2.  전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.\r\n3.  명시적인 셸 이스케이프를 위한 `shlex.sh` 렌더러를 소개합니다.\r\n\r\n    ```python\r\n    # 안전하지 않음:\r\n    os.system(f\"cat {filename}\") # 잠재적인 명령 주입!\r\n\r\n    # shlex.sh 사용 시 안전:\r\n    os.system(shlex.sh(t\"cat {filename}\")) # 셸을 위한 명시적 이스케이프\r\n    ```\r\n\r\n4.  `subprocess` 모듈의 기본 `t-string` 지원을 소개합니다.\r\n\r\n    ```python\r\n    # 안전하지 않음:\r\n    subprocess.run(f\"cat {filename}\", shell=True) # 잠재적인 명령 주입!\r\n\r\n    # 안전하지만 장황함:\r\n    subprocess.run([\"cat\", filename])\r\n\r\n    # t-string 사용 시 안전하고 읽기 쉬움:\r\n    subprocess.run(t\"cat {filename}\", shell=True) # filename을 자동으로 이스케이프\r\n    subprocess.run(t\"cat {filename}\") # 자동으로 리스트 형태로 변환\r\n    ```\r\n\r\n구현은 `shlex` 및 `subprocess` 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.\r\n\r\n### 비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기\r\n\r\n`shlex.quote()`는 정규식 문자 세트 `[\\w@%+=:,./-]`를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.\r\n\r\n예를 들어, `subprocess.run(f\"echo {shlex.quote(sys.argv[1])}\", shell=True)`를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.\r\n\r\n그러나 Python에서 `cmd.exe` (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.\r\n\r\n이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.\r\n\r\n## 저작권 (Copyright)\r\n\r\n이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.\r\n```# PEP 787 – t-string을 사용한 더 안전한 서브프로세스 활용\r\n\r\n*   **저자**: Nick Humrich, Alyssa Coghlan\r\n*   **상태**: Deferred (연기됨)\r\n*   **Python 버전**: 3.15\r\n*   **생성일**: 2025년 4월 13일\r\n\r\n## 개요 (Abstract)\r\n\r\nPEP 750에서 f-string의 일반화된 형태로 `template string (t-string)`이 도입되어 다양한 컨텍스트에서 안전하게 문자열 보간(interpolation)을 처리할 수 있게 되었습니다. 이 PEP는 `subprocess` 및 `shlex` 모듈을 확장하여 `t-string`을 기본으로 지원함으로써, 보간된 값으로 셸 명령을 더 안전하고 인체공학적으로 실행할 수 있도록 제안합니다. 또한, API 인체공학을 개선하기 위한 `t-string` 기능의 참조 구현 역할도 합니다.\r\n\r\n## PEP 연기 (PEP Deferral)\r\n\r\n초기 초안 논의 과정에서, `t-string`이 `shell=True`와 유사한 수준의 구문적 편의성을 제공하면서도, 사용자 입력 텍스트가 전체 시스템 셸에 접근할 때 발생하는 보안 및 크로스 플랫폼 호환성 문제를 피할 수 있는 잠재적인 기회를 제공한다는 점이 명확해졌습니다.\r\n\r\n이에 따라, PEP 저자들은 Python 3.15를 위한 제안서의 수정된 초안을 준비하기 전에, Python 3.14 베타 기간(및 그 이후) 동안 실험적인 `t-string` 기반의 `subprocess` 호출 라이브러리를 개발할 계획입니다.\r\n\r\n## 동기 (Motivation)\r\n\r\nPEP 750의 `template string (t-string)`은 안전성과 유연성을 제공함에도 불구하고, 표준 라이브러리 내에 실제 적용을 보여주는 구체적인 소비자 구현(consumer implementation)이 부족합니다. `t-string`의 가장 설득력 있는 사용 사례 중 하나는 철회된 PEP 501에서도 언급되었듯이, 더 안전한 셸 명령 실행입니다.\r\n\r\n예시:\r\n\r\n```python\r\n# f-string 사용 시 안전하지 않음: (커맨드 인젝션 위험)\r\nos.system(f\"echo {message_from_user}\")\r\n# f-string 사용 시 역시 안전하지 않음\r\nsubprocess.run(f\"echo {message_from_user}\", shell=True)\r\n# f-string 사용 시 실패\r\nsubprocess.run(f\"echo {message_from_user}\")\r\n\r\n# t-string과 POSIX 호환 셸 쿼팅(quoting) 사용 시 안전:\r\nsubprocess.run(t\"echo {message_from_user}\", shell=True)\r\n# t-string 사용 시 모든 플랫폼에서 안전:\r\nsubprocess.run(t\"echo {message_from_user}\")\r\n# t-string 없이 모든 플랫폼에서 안전 (더 장황함):\r\nsubprocess.run([\"echo\", str(message_from_user)])\r\n```\r\n\r\n현재 개발자들은 편의성(`f-string` 사용 시 잠재적인 보안 위험)과 안전성(더 장황한 리스트 기반 API 사용) 사이에서 선택해야 합니다. `subprocess` 모듈에 기본 `t-string` 지원을 추가함으로써, 이 PEP는 `t-string`의 가치를 보여주는 소비자 참조 구현을 제공하며, 일반적인 보안 문제를 해결합니다.\r\n\r\n## 근거 (Rationale)\r\n\r\n`subprocess` 모듈이 `t-string` 지원에 이상적인 후보인 이유는 다음과 같습니다.\r\n\r\n*   셸 명령의 명령 주입(Command Injection) 취약점은 잘 알려진 보안 위험입니다.\r\n*   `subprocess` 모듈은 이미 문자열 및 리스트 기반의 명령 지정을 모두 지원합니다.\r\n*   `t-string`과 적절한 셸 이스케이프(escaping) 사이에는 자연스러운 매핑이 있어 편의성과 안전성을 모두 제공합니다.\r\n*   이것은 개발자들이 즉시 이해하고 활용할 수 있는 `t-string`의 실용적인 쇼케이스 역할을 합니다.\r\n\r\n`subprocess`를 확장하여 `t-string`을 기본으로 처리하게 함으로써, 많은 개발자들이 잠재적으로 안전하지 않은 `f-string`을 사용하게 만들었던 편의성을 희생하지 않고도 안전한 코드를 더 쉽게 작성할 수 있도록 합니다.\r\n\r\n## 명세 (Specification)\r\n\r\n이 PEP는 표준 라이브러리에 두 가지 주요 추가 사항을 제안합니다.\r\n\r\n1.  `shlex` 모듈에 안전한 셸 명령 구성을 위한 새로운 `sh()` 렌더러 함수 추가\r\n2.  `subprocess` 모듈의 핵심 함수, 특히 `subprocess.Popen`, `subprocess.run()` 및 `command` 인수를 받는 다른 관련 함수에 `t-string` 지원 추가\r\n\r\n### `shlex`에 셸 이스케이프를 위한 렌더러 추가\r\n\r\n참조 구현으로서, 안전한 POSIX 셸 이스케이프를 위한 렌더러가 `shlex` 모듈에 추가될 것입니다. 이 렌더러는 `sh`라고 불리며, 템플릿 리터럴의 각 필드 값에 대해 `shlex.quote`를 호출하는 것과 동일하게 작동합니다.\r\n\r\n따라서 다음 코드는:\r\n\r\n```python\r\nos.system(shlex.sh(t\"cat {myfile}\"))\r\n```\r\n\r\n다음과 동일하게 동작합니다.\r\n\r\n```python\r\nos.system(\"cat \" + shlex.quote(myfile))\r\n```\r\n\r\n`shlex.sh`의 추가는 `subprocess` 문서에서 `shell=True` 사용을 피하는 것이 가장 좋다는 기존 권고 사항을 변경하지 않으며, `os.system()` 문서에서 상위 수준의 `subprocess` API를 참조하는 것도 변경하지 않습니다.\r\n\r\n`t-string` 프로세서 구현은 다음과 같습니다.\r\n\r\n```python\r\nfrom string.templatelib import Template, Interpolation\r\nfrom shlex import quote, join # shlex.quote와 shlex.join을 가정\r\n\r\ndef sh(template: Template) -\u003e str:\r\n    parts: list[str] = []\r\n    for item in template:\r\n        if isinstance(item, Interpolation):\r\n            # shlex.sh 구현이므로 shlex.quote를 직접 사용할 수 있습니다.\r\n            parts.append(quote(str(item.value)))\r\n        else:\r\n            parts.append(item)\r\n    # shlex.sh 구현이므로 `join`은 shlex.join을 참조합니다.\r\n    return join(parts)\r\n```\r\n\r\n이를 통해 셸 사용을 위한 `t-string`의 명시적인 이스케이프가 가능합니다.\r\n\r\n```python\r\nimport shlex\r\nimport os\r\n\r\nfilename = \"my file with spaces.txt\" # 사용자 입력이라고 가정\r\n\r\n# 안전한 POSIX-compliant 셸 명령 구성\r\ncommand = shlex.sh(t\"cat {filename}\")\r\nos.system(command) # cat \"my file with spaces.txt\" 와 동일하게 실행\r\n```\r\n\r\n### `subprocess` 모듈 변경 사항\r\n\r\n`shlex` 모듈에 렌더러와 `template string`이 추가됨에 따라, `subprocess` 모듈은 `Popen`에 `template string`을 추가 입력 유형으로 받을 수 있도록 변경될 수 있습니다. `Popen`은 이미 시퀀스(sequence) 또는 문자열을 받으며, 각각 다른 동작을 합니다.\r\n\r\n결과적으로, `subprocess.run()`과 같은 `subprocess.Popen`의 모든 상위 수준 함수는 안전한 방식으로 문자열을 받을 수 있게 됩니다 ( `shell=False`의 경우 모든 시스템에서, `shell=True`의 경우 POSIX 시스템에서).\r\n\r\n예를 들어:\r\n\r\n```python\r\nsubprocess.run(t\"cat {myfile}\", shell=True)\r\n```\r\n\r\n위 코드는 이 PEP에서 제공하는 `shlex.sh` 렌더러를 자동으로 사용합니다. 따라서, 다음과 같이 `subprocess.run` 호출 내에서 `shlex`를 사용하는 것은 중복됩니다.\r\n\r\n```python\r\nsubprocess.run(shlex.sh(t\"cat {myfile}\"), shell=True)\r\n```\r\n\r\n`run` 함수가 모든 템플릿 리터럴을 `shlex.sh`를 통해 자동으로 렌더링하기 때문입니다.\r\n\r\n`subprocess.Popen`이 `shell=True` 없이 호출될 때도 `t-string` 지원은 `subprocess`에 더 인체공학적인 구문을 제공합니다. 예를 들어:\r\n\r\n```python\r\nsubprocess.run(t\"cat {myfile} --flag {value}\")\r\n```\r\n\r\n위 코드는 다음과 동일합니다.\r\n\r\n```python\r\nsubprocess.run([\"cat\", myfile, \"--flag\", value])\r\n```\r\n\r\n또는 더 정확하게는:\r\n\r\n```python\r\nsubprocess.run(shlex.split(shlex.sh(t\"cat {myfile} --flag {value}\")))\r\n```\r\n\r\n이는 먼저 위에서 설명한 `shlex.sh` 렌더러를 사용한 다음, 그 결과에 대해 `shlex.split`을 사용함으로써 이루어집니다.\r\n\r\n`subprocess.Popen._execute_child` 내부의 구현은 `t-string`을 확인할 것입니다.\r\n\r\n```python\r\nfrom string.templatelib import Template\r\n\r\nif isinstance(args, Template):\r\n    import shlex\r\n    if shell:\r\n        args = shlex.sh(args)\r\n    else:\r\n        args = shlex.split(shlex.sh(args))\r\n```\r\n\r\n## 하위 호환성 (Backwards Compatibility)\r\n\r\n이 변경 사항은 기존 동작을 변경하지 않고 새로운 기능만 추가하므로, 완벽하게 하위 호환됩니다. `subprocess` 모듈은 현재와 동일한 방식으로 문자열과 리스트를 계속 처리할 것입니다.\r\n\r\n## 보안 영향 (Security Implications)\r\n\r\n이 PEP는 셸 명령과 함께 `f-string`을 사용하는 것에 대한 더 안전한 대안을 제공함으로써 보안을 개선하도록 명시적으로 설계되었습니다. 컨텍스트(셸 또는 비-셸)에 따라 적절한 이스케이프를 자동으로 적용하여 명령 주입 취약점을 방지하는 데 도움이 됩니다.\r\n\r\n그러나 `shell=True`가 사용될 때는 안전성이 POSIX 호환 셸로 제한된다는 점을 알아두어야 합니다. `cmd.exe` 또는 PowerShell이 셸로 사용될 수 있는 Windows 시스템에서는 `shlex.quote()`가 제공하는 이스케이프 메커니즘이 모든 형태의 명령 주입을 방지하기에 충분하지 않습니다.\r\n\r\n## 교육 방법 (How to Teach This)\r\n\r\n이 기능은 `t-string`의 실용적인 가치를 보여주는 자연스러운 확장으로 가르칠 수 있습니다.\r\n\r\n1.  명령 주입 문제와 `f-string`이 셸 명령과 함께 사용될 때 위험한 이유를 소개합니다.\r\n2.  전통적인 해결책(리스트 기반 명령, 수동 이스케이프)을 보여줍니다.\r\n3.  명시적인 셸 이스케이프를 위한 `shlex.sh` 렌더러를 소개합니다.\r\n\r\n    ```python\r\n    # 안전하지 않음:\r\n    os.system(f\"cat {filename}\") # 잠재적인 명령 주입!\r\n\r\n    # shlex.sh 사용 시 안전:\r\n    os.system(shlex.sh(t\"cat {filename}\")) # 셸을 위한 명시적 이스케이프\r\n    ```\r\n\r\n4.  `subprocess` 모듈의 기본 `t-string` 지원을 소개합니다.\r\n\r\n    ```python\r\n    # 안전하지 않음:\r\n    subprocess.run(f\"cat {filename}\", shell=True) # 잠재적인 명령 주입!\r\n\r\n    # 안전하지만 장황함:\r\n    subprocess.run([\"cat\", filename])\r\n\r\n    # t-string 사용 시 안전하고 읽기 쉬움:\r\n    subprocess.run(t\"cat {filename}\", shell=True) # filename을 자동으로 이스케이프\r\n    subprocess.run(t\"cat {filename}\") # 자동으로 리스트 형태로 변환\r\n    ```\r\n\r\n구현은 `shlex` 및 `subprocess` 모듈 문서에 명확한 예제와 보안 권고 사항과 함께 추가되어야 합니다.\r\n\r\n### 비-POSIX 셸에 대한 이스케이프 렌더링 지원 연기\r\n\r\n`shlex.quote()`는 정규식 문자 세트 `[\\w@%+=:,./-]`를 안전하다고 분류하고, 다른 모든 문자는 안전하지 않은 것으로 간주하여 해당 문자를 포함하는 문자열에 쿼팅(quoting)을 요구합니다. 사용되는 쿼팅 메커니즘은 POSIX 셸의 문자열 쿼팅 방식에 특화되어 있으므로, POSIX 셸 문자열 쿼팅 규칙을 따르지 않는 셸을 실행할 때는 신뢰할 수 없습니다.\r\n\r\n예를 들어, `subprocess.run(f\"echo {shlex.quote(sys.argv[1])}\", shell=True)`를 POSIX 쿼팅 규칙을 따르는 셸에서 실행하면 안전합니다.\r\n\r\n그러나 Python에서 `cmd.exe` (또는 Powershell)를 호출하는 셸을 실행할 때는 여전히 안전하지 않습니다.\r\n\r\n이러한 표준 라이브러리 제한을 해결하는 것은 이 PEP의 범위를 벗어납니다.\r\n\r\n## 저작권 (Copyright)\r\n\r\n이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 공개됩니다.\r\n\r\n\r\n\u003e ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\n\u003c/code\u003e\u003c/pre\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1318,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Deferred] PEP 787 - Safer subprocess usage using t-strings\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 14:00:15+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>