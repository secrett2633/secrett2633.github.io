3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-f9f5ec6d66d9670a.js","185","static/chunks/app/layout-b06e577e11976c7d.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","931","static/chunks/app/page-ca12a0ad24cce7b7.js"],""]
4:["slug","python/pep/634","c"]
0:["FglYEKp77LCCxCyk0Fxk6",[[["",{"children":[["slug","python/pep/634","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"634\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/634","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e975486d410ad4e9.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T4721,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0634/">PEP 634 - Structural Pattern Matching: Specification</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 12-Sep-2020</p>
</blockquote>
<h2>개요</h2>
<p>이 문서는 Python 3.10에 도입된 <code>match</code> 문의 핵심 기능인 구조적 패턴 매칭(Structural Pattern Matching)에 대한 기술 명세를 제공합니다. PEP 634는 이전의 PEP 622를 세 부분으로 나눈 것 중 하나로, 패턴 매칭의 <em>구현 및 동작 방식</em>에 초점을 맞춥니다. 동기 및 합리적인 이유에 대해서는 PEP 635를, 개념 및 사용법에 대한 자세한 소개는 PEP 636 튜토리얼을 참조하는 것이 좋습니다.</p>
<h2>추상 (Abstract)</h2>
<p>이 PEP는 <code>match</code> 문에 대한 기술 명세를 제공합니다. 이는 PEP 622를 대체하며, PEP 622는 다음 세 부분으로 나뉘었습니다.</p>
<ul>
<li>PEP 634: 명세 (Specification)</li>
<li>PEP 635: 동기 및 합리적인 이유 (Motivation and Rationale)</li>
<li>PEP 636: 튜토리얼 (Tutorial)</li>
</ul>
<p>이 PEP는 의도적으로 설명이 배제되어 있으며, 동기 및 설계 선택에 대한 모든 설명은 PEP 635에 있습니다. 처음 접하는 독자는 개념, 구문 및 패턴의 의미론에 대한 부드러운 소개를 제공하는 PEP 636부터 시작하는 것이 좋습니다.</p>
<h2>구문 및 의미론 (Syntax and Semantics)</h2>
<p>전체 문법은 부록 A를 참조하세요.</p>
<h3>개요 및 용어 (Overview and Terminology)</h3>
<p>패턴 매칭 과정은 <code>case</code> 다음에 오는 <code>패턴 (pattern)</code>과 <code>match</code> 다음에 오는 <code>subject 값 (subject value)</code>을 입력으로 받습니다. 이 과정을 설명하는 문구로는 "패턴이 subject 값과 매치된다" 또는 "우리는 패턴을 subject 값에 매치시킨다" 등이 있습니다.</p>
<p>패턴 매칭의 주요 결과는 <code>성공 (success)</code> 또는 <code>실패 (failure)</code>입니다. 성공의 경우, "패턴이 성공한다", "매치가 성공한다", 또는 "패턴이 subject 값에 매치된다"고 말할 수 있습니다.</p>
<p>많은 경우 패턴은 하위 패턴(subpatterns)을 포함하며, 성공 또는 실패는 해당 하위 패턴을 값에 (예: OR 패턴의 경우) 또는 값의 일부에 (예: 시퀀스 패턴의 경우) 매치시키는 성공 또는 실패에 따라 결정됩니다. 이 과정은 일반적으로 전체 결과가 결정될 때까지 하위 패턴을 왼쪽에서 오른쪽으로 처리합니다. 예를 들어, OR 패턴은 첫 번째로 성공하는 하위 패턴에서 성공하는 반면, 시퀀스 패턴은 첫 번째로 실패하는 하위 패턴에서 실패합니다.</p>
<p>패턴 매칭의 부수적인 결과는 하나 이상의 이름 바인딩(name bindings)일 수 있습니다. "패턴이 값을 이름에 바인딩한다"고 말할 수 있습니다. 첫 번째 성공까지 시도된 하위 패턴의 경우, 성공한 하위 패턴으로 인한 바인딩만 유효합니다. 첫 번째 실패까지 시도하는 경우, 바인딩이 병합됩니다. 이 경우에 적용되는 몇 가지 추가 규칙은 아래에서 설명합니다.</p>
<h3><code>match</code> 문 (The Match Statement)</h3>
<p><code>match</code> 문의 구문은 다음과 같습니다.</p>
<pre><code class="language-python">match_stmt: "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT
subject_expr:
    | star_named_expression ',' star_named_expressions?
    | named_expression
case_block: "case" patterns [guard] ':' block
guard: 'if' named_expression
</code></pre>
<p><code>match</code>와 <code>case</code> 키워드는 <code>소프트 키워드 (soft keywords)</code>입니다. 즉, 다른 문법적 맥락에서는 예약어가 아닙니다. 이는 <code>match</code> 문 또는 <code>case</code> 블록의 일부일 때만 키워드로 인식되며, 다른 모든 맥락에서는 변수 또는 인자 이름으로 사용할 수 있음을 의미합니다.</p>
<h4><code>match</code> 의미론 (Match Semantics)</h4>
<p><code>match</code> 문은 먼저 subject 표현식을 평가합니다. 쉼표가 있는 경우 표준 규칙을 사용하여 튜플이 생성됩니다.</p>
<p>결과 subject 값은 이를 성공적으로 매치하고 (있는 경우) guard 조건이 "truthy"인 첫 번째 <code>case</code> 블록을 선택하는 데 사용됩니다. 해당하는 <code>case</code> 블록이 없으면 <code>match</code> 문이 완료됩니다. 그렇지 않으면 선택된 <code>case</code> 블록의 블록이 실행됩니다. 복합 문 내부에 중첩된 블록을 실행하는 일반적인 규칙(예: <code>if</code> 문)이 적용됩니다.</p>
<p>성공적인 패턴 매치 중에 생성된 이름 바인딩은 실행된 블록 이후에도 유지되며 <code>match</code> 문 이후에 사용할 수 있습니다.</p>
<p>실패한 패턴 매치 중에도 일부 하위 패턴은 성공할 수 있습니다. 예를 들어, <code>(0, x, 1)</code> 패턴을 <code>[0, 1, 2]</code> 값과 매치할 때, 리스트 요소가 왼쪽에서 오른쪽으로 매치된다면 하위 패턴 <code>x</code>는 성공할 수 있습니다. 구현은 이러한 부분 매치에 대한 영구적인 바인딩을 만들지 여부를 선택할 수 있습니다. <code>match</code> 문을 포함하는 사용자 코드는 실패한 매치에 의해 바인딩이 생성된다는 것에 의존해서는 안 되며, 또한 변수가 실패한 매치에 의해 변경되지 않는다고 가정해서도 안 됩니다. 이 동작 부분은 의도적으로 지정되지 않아 다양한 구현이 최적화를 추가할 수 있도록 하고, 이 기능의 확장성을 제한할 수 있는 의미론적 제약을 도입하는 것을 방지합니다.</p>
<p>정확한 패턴 바인딩 규칙은 패턴 유형에 따라 다르며 아래에 명시됩니다.</p>
<h3>가드 (Guards)</h3>
<p><code>case</code> 블록에 가드가 있는 경우, <code>case</code> 블록의 패턴이 성공하면 가드 내의 표현식이 평가됩니다. 이때 예외가 발생하면 예외는 위로 전파됩니다. 그렇지 않고 조건이 "truthy"이면 <code>case</code> 블록이 선택됩니다. "falsy"이면 <code>case</code> 블록은 선택되지 않습니다.</p>
<p>가드는 표현식이므로 부작용(side effects)을 가질 수 있습니다. 가드 평가는 첫 번째 <code>case</code> 블록부터 마지막 <code>case</code> 블록까지 하나씩 진행되어야 하며, 패턴이 모두 성공하지 않는 <code>case</code> 블록은 건너뛰어야 합니다. (즉, 해당 패턴이 성공하는지 여부를 결정하는 것이 순서에 상관없이 발생할 수 있더라도, 가드 평가는 순서대로 발생해야 합니다.) <code>case</code> 블록이 선택되면 가드 평가는 중지되어야 합니다.</p>
<h3>반박할 수 없는 <code>case</code> 블록 (Irrefutable case blocks)</h3>
<p>패턴이 구문만으로 항상 성공할 것이라고 증명할 수 있으면 <code>반박할 수 없는 (irrefutable)</code> 것으로 간주됩니다. 특히 <code>캡처 패턴 (capture patterns)</code> 및 <code>와일드카드 패턴 (wildcard patterns)</code>은 반박할 수 없으며, 왼쪽이 반박할 수 없는 AS 패턴, 적어도 하나의 반박할 수 없는 패턴을 포함하는 OR 패턴, 그리고 괄호로 묶인 반박할 수 없는 패턴도 마찬가지입니다.</p>
<p>가드가 없고 패턴이 반박할 수 없는 경우 <code>case</code> 블록은 반박할 수 없는 것으로 간주됩니다.</p>
<p><code>match</code> 문은 최대 하나의 반박할 수 없는 <code>case</code> 블록을 가질 수 있으며, 이는 반드시 마지막에 와야 합니다.</p>
<h3>패턴 (Patterns)</h3>
<p>패턴의 최상위 구문은 다음과 같습니다.</p>
<pre><code class="language-python">patterns: open_sequence_pattern | pattern
pattern: as_pattern | or_pattern
as_pattern: or_pattern 'as' capture_pattern
or_pattern: '|'.closed_pattern+
closed_pattern:
    | literal_pattern
    | capture_pattern
    | wildcard_pattern
    | value_pattern
    | group_pattern
    | sequence_pattern
    | mapping_pattern
    | class_pattern
</code></pre>
<h4>AS 패턴 (AS Patterns)</h4>
<p>구문: <code>as_pattern: or_pattern 'as' capture_pattern</code></p>
<p>AS 패턴은 <code>as</code> 키워드의 왼쪽에 있는 OR 패턴을 subject에 매치시킵니다. 실패하면 AS 패턴도 실패합니다. 그렇지 않으면 AS 패턴은 subject를 <code>as</code> 키워드의 오른쪽에 있는 이름에 바인딩하고 성공합니다.</p>
<h4>OR 패턴 (OR Patterns)</h4>
<p>구문: <code>or_pattern: '|'.closed_pattern+</code></p>
<p>두 개 이상의 패턴이 수직 막대(<code>|</code>)로 구분된 경우 이를 OR 패턴이라고 합니다. 단일 <code>closed pattern</code>은 그 자체입니다.</p>
<p>마지막 하위 패턴만 반박할 수 있습니다. 각 하위 패턴은 동일한 이름 집합을 바인딩해야 합니다.</p>
<p>OR 패턴은 성공하는 하위 패턴이 나올 때까지 각 하위 패턴을 순서대로 subject에 매치시킵니다. 그런 다음 OR 패턴은 성공한 것으로 간주됩니다. 하위 패턴 중 어느 것도 성공하지 못하면 OR 패턴은 실패합니다.</p>
<h4>리터럴 패턴 (Literal Patterns)</h4>
<p>리터럴 패턴은 subject 값이 리터럴에 의해 표현된 값과 비교하여 같으면 성공합니다.</p>
<ul>
<li>숫자와 문자열은 <code>==</code> 연산자를 사용하여 비교됩니다.</li>
<li>싱글톤 리터럴 <code>None</code>, <code>True</code>, <code>False</code>는 <code>is</code> 연산자를 사용하여 비교됩니다.</li>
</ul>
<p>F-string은 지원되지 않습니다.</p>
<h4>캡처 패턴 (Capture Patterns)</h4>
<p>구문: <code>capture_pattern: !"_" NAME</code></p>
<p>단일 밑줄(<code>_</code>)은 캡처 패턴이 아닙니다. 이는 와일드카드 패턴으로 취급됩니다.</p>
<p>캡처 패턴은 항상 성공합니다. PEP 572의 walrus 연산자(<code>:=</code>)에 설정된 이름 바인딩 스코프 규칙을 사용하여 subject 값을 이름에 바인딩합니다.</p>
<p>주어진 패턴 내에서, 주어진 이름은 한 번만 바인딩될 수 있습니다.</p>
<h4>와일드카드 패턴 (Wildcard Pattern)</h4>
<p>구문: <code>wildcard_pattern: "_"</code></p>
<p>와일드카드 패턴은 항상 성공합니다. 어떤 이름도 바인딩하지 않습니다.</p>
<h4>값 패턴 (Value Patterns)</h4>
<p>구문: <code>value_pattern: attr</code></p>
<p>패턴의 점으로 구분된 이름은 표준 Python 이름 해석 규칙을 사용하여 찾아집니다. 그러나 동일한 값 패턴이 동일한 <code>match</code> 문에서 여러 번 나타나는 경우, 인터프리터는 첫 번째로 찾은 값을 캐시하고 재사용할 수 있습니다.</p>
<p>찾아진 값이 subject 값과 비교하여 같으면(<code>==</code> 연산자 사용) 패턴이 성공합니다.</p>
<h4>그룹 패턴 (Group Patterns)</h4>
<p>구문: <code>group_pattern: '(' pattern ')'</code></p>
<p>괄호로 묶인 패턴은 추가적인 구문을 가지지 않습니다. 사용자가 의도된 그룹화를 강조하기 위해 패턴 주위에 괄호를 추가할 수 있도록 합니다.</p>
<h4>시퀀스 패턴 (Sequence Patterns)</h4>
<p>구문:</p>
<pre><code class="language-python">sequence_pattern:
    | '[' [maybe_sequence_pattern] ']'
    | '(' [open_sequence_pattern] ')'
</code></pre>
<p><code>[...]</code>를 사용하는 시퀀스 패턴과 <code>(...)</code>를 사용하는 시퀀스 패턴, 그리고 <code>open sequence pattern</code> 사이에 의미론적 차이는 없습니다.</p>
<p>시퀀스 패턴은 최대 하나의 <code>스타 하위 패턴 (star subpattern)</code>을 포함할 수 있으며, 이는 어떤 위치에도 올 수 있습니다. 스타 하위 패턴이 없으면 고정 길이 시퀀스 패턴이고, 그렇지 않으면 가변 길이 시퀀스 패턴입니다.</p>
<p>시퀀스 패턴이 성공하려면 subject는 시퀀스여야 합니다. <code>str</code>, <code>bytes</code>, <code>bytearray</code>는 일반적으로 시퀀스로 간주되지만, 위 목록에는 포함되지 않으며 시퀀스 패턴과 매치되지 않습니다.</p>
<p>고정 길이 시퀀스 패턴은 subject 시퀀스의 길이가 하위 패턴의 수와 같지 않으면 실패합니다. 가변 길이 시퀀스 패턴은 subject 시퀀스의 길이가 비스타 하위 패턴의 수보다 적으면 실패합니다.</p>
<h4>매핑 패턴 (Mapping Patterns)</h4>
<p>구문:</p>
<pre><code class="language-python">mapping_pattern: '{' [items_pattern] '}'
key_value_pattern:
    | (literal_pattern | value_pattern) ':' pattern
    | double_star_pattern
double_star_pattern: '**' capture_pattern
</code></pre>
<p>매핑 패턴은 최대 하나의 <code>더블 스타 패턴 (double star pattern)</code>을 포함할 수 있으며, 이는 반드시 마지막에 와야 합니다. 매핑 패턴은 중복된 키 값을 포함할 수 없습니다.</p>
<p>매핑 패턴이 성공하려면 subject는 매핑(mapping)이어야 합니다. <code>dict</code> 및 <code>mappingproxy</code>와 같은 표준 라이브러리 클래스는 <code>Py_TPFLAGS_MAPPING</code> 비트가 설정됩니다.</p>
<p>매핑 패턴은 매핑 패턴에 주어진 모든 키가 subject 매핑에 존재하고, 각 키에 대한 패턴이 subject 매핑의 해당 항목과 매치될 때 성공합니다. 키는 항상 <code>==</code> 연산자로 비교됩니다. <code>'**' NAME</code> 형식이 있는 경우, 해당 이름은 subject 매핑에서 나머지 키-값 쌍을 포함하는 <code>dict</code>에 바인딩됩니다.</p>
<p>키-값 쌍은 subject의 <code>get()</code> 메서드의 두 인자 형식을 사용하여 매치됩니다. 결과적으로 매치되는 키-값 쌍은 매핑에 이미 존재해야 하며, <code>__missing__</code> 또는 <code>__getitem__</code>에 의해 즉시 생성되지 않아야 합니다.</p>
<h4>클래스 패턴 (Class Patterns)</h4>
<p>구문:</p>
<pre><code class="language-python">class_pattern:
    | name_or_attr '(' [pattern_arguments ','?] ')'
pattern_arguments:
    | positional_patterns [',' keyword_patterns]
    | keyword_patterns
</code></pre>
<p>클래스 패턴은 동일한 키워드를 여러 번 반복할 수 없습니다. <code>name_or_attr</code>이 내장 <code>type</code>의 인스턴스가 아니면 <code>TypeError</code>가 발생합니다.</p>
<p>클래스 패턴은 subject가 <code>name_or_attr</code>의 인스턴스가 아니면 실패합니다. 이는 <code>isinstance()</code>를 사용하여 테스트됩니다. 인자가 없으면 <code>isinstance()</code> 검사가 성공할 때 패턴이 성공합니다.</p>
<p>위치 패턴이 있는 경우, 해당 패턴은 <code>name_or_attr</code>에 지정된 클래스의 <code>__match_args__</code> 속성을 사용하여 키워드 패턴으로 변환됩니다.</p>
<p><code>bool</code>, <code>bytearray</code>, <code>bytes</code>, <code>dict</code>, <code>float</code>, <code>frozenset</code>, <code>int</code>, <code>list</code>, <code>set</code>, <code>str</code>, <code>tuple</code>과 같은 일부 내장 유형의 경우 위치 하위 패턴 처리가 다릅니다.</p>
<h2>부작용 및 정의되지 않은 동작 (Side Effects and Undefined Behavior)</h2>
<p>매칭 과정에 의해 명시적으로 생성되는 유일한 부작용은 이름의 바인딩입니다. 그러나 이 과정은 subject 및 그 구성 요소에 대한 속성 접근, 인스턴스 검사, <code>len()</code>, 동등성(<code>==</code>) 및 항목 접근에 의존합니다. 또한 값 패턴과 클래스 패턴의 클래스 이름을 평가합니다. 이러한 작업 중 어느 것도 일반적으로 부작용을 일으키지는 않지만, 이론적으로는 발생할 수 있습니다. 이 제안은 어떤 메서드가 호출되는지 또는 몇 번 호출되는지에 대한 어떠한 명세도 의도적으로 제외합니다. 따라서 이 동작은 정의되지 않았으며 사용자 코드는 이에 의존해서는 안 됩니다.</p>
<p>또 다른 정의되지 않은 동작은 (동일한 <code>case</code> 블록 내에서) 실패하는 다른 패턴이 뒤따르는 캡처 패턴에 의한 변수 바인딩입니다. 이는 구현 전략에 따라 더 빨리 또는 더 늦게 발생할 수 있으며, 유일한 제약은 캡처 변수가 명시적으로 사용하는 가드가 평가되기 전에 설정되어야 한다는 것입니다.</p>
<h2>표준 라이브러리 (The Standard Library)</h2>
<p>패턴 매칭 사용을 용이하게 하기 위해 표준 라이브러리에 몇 가지 변경 사항이 적용될 것입니다.</p>
<p><code>namedtuple</code> 및 <code>dataclass</code>는 자동 생성된 <code>__match_args__</code>를 갖게 됩니다. <code>dataclass</code>의 경우, 생성된 <code>__match_args__</code>의 속성 순서는 생성된 <code>__init__()</code> 메서드의 해당 인자 순서와 동일할 것입니다. <code>init=False</code>인 필드는 <code>__match_args__</code>에서 제외됩니다.</p>
<p>또한, 기존 표준 라이브러리 클래스를 검토하고 유익하다고 판단되는 경우 <code>__match_args__</code>를 추가하기 위한 체계적인 노력이 이루어질 것입니다.</p>
<h2>부록 A – 전체 문법 (Appendix A – Full Grammar)</h2>
<p><code>match_stmt</code>의 전체 문법은 PEP 원문에 상세히 기술되어 있습니다. <code>match</code> 및 <code>case</code>는 다른 문법적 맥락에서는 예약어가 아닌 소프트 키워드입니다.</p>
<hr>
<p>이 문서는 PEP 634 – Structural Pattern Matching: Specification의 내용을 바탕으로 번역 및 정리되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1637,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 634 - Structural Pattern Matching: Specification"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-27 01:25:49+0900","children":"2025년 9월 27일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 27일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://blog.secrett2633.site/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://blog.secrett2633.site/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","22",{"name":"next-size-adjust"}]]
1:null
