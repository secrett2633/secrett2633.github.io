<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Withdrawn] PEP 650 - Specifying Installer Requirements for Python Projects</h1><div class="page__meta"><time dateTime="2025-09-27 01:40:48+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0650/">PEP 650 - Specifying Installer Requirements for Python Projects</a></p>
<p><strong>상태:</strong> Withdrawn | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 16-Jul-2020</p>
</blockquote>
<h2>PEP 650 – Python 프로젝트를 위한 설치 프로그램 요구사항 명세 (Withdrawn)</h2>
<p><strong>작성자:</strong> Vikram Jayanthi, Dustin Ingram, Brett Cannon
<strong>토론:</strong> Discourse 스레드
<strong>상태:</strong> 철회됨 (Withdrawn)
<strong>유형:</strong> 표준 트랙 (Standards Track)
<strong>주제:</strong> 패키징 (Packaging)
<strong>생성일:</strong> 2020년 7월 16일
<strong>이력:</strong> 2021년 1월 14일</p>
<hr>
<h3>초록 (Abstract)</h3>
<p>현재 Python 패키지 설치 프로그램들은 서로 완전히 상호 운용되지 않습니다. <code>pip</code>이 가장 널리 사용되는 사실상의 표준이지만, Poetry나 Pipenv 같은 다른 설치 프로그램들도 특정 워크플로우에 최적화된 고유한 기능을 제공하여 인기가 많습니다.</p>
<p>다양한 설치 프로그램 옵션이 특정 요구사항을 가진 최종 사용자에게는 좋지만, 이들 간의 상호 운용성 부족은 모든 잠재적 설치 프로그램을 지원하기 어렵게 만듭니다. 특히, 종속성을 선언하는 표준화된 요구사항 파일이 없기 때문에, 각 도구는 해당 형식으로 지정된 종속성을 설치하기 위해 명시적으로 사용되어야 합니다. 그렇지 않으면 도구는 요구사항 파일을 내보내야 하는데, 이는 설치 프로그램에 대한 잠재적인 정보 손실과 개발자 워크플로우의 추가적인 내보내기 단계를 초래합니다.</p>
<p>호환 가능한 설치 프로그램을 호출하는 데 사용할 수 있는 표준화된 API를 제공함으로써, 우리는 다양한 설치 프로그램과 그들의 록 파일(lock file) 간의 개별적인 문제, 고유한 요구사항 및 비호환성을 해결할 필요 없이 이 문제를 해결할 수 있습니다.</p>
<p>이 사양을 구현하는 설치 프로그램은 균일한 방식으로 호출될 수 있으며, 사용자는 마치 직접 호출하는 것처럼 원하는 설치 프로그램을 사용할 수 있습니다.</p>
<h3>용어 (Terminology)</h3>
<ul>
<li><strong>Installer interface (설치 프로그램 인터페이스):</strong> 설치 프로그램 백엔드와 범용 설치 프로그램이 상호 작용하는 인터페이스입니다.</li>
<li><strong>Universal installer (범용 설치 프로그램):</strong> 설치 프로그램 인터페이스의 선택적 호출 메서드를 호출하여 설치 프로그램 백엔드를 호출할 수 있는 설치 프로그램입니다. 이는 PEP 517의 <code>build</code> 프로젝트처럼 설치 프로그램 프런트엔드로도 생각할 수 있습니다.</li>
<li><strong>Installer backend (설치 프로그램 백엔드):</strong> 설치 프로그램 인터페이스를 구현하여 범용 설치 프로그램에 의해 호출될 수 있는 설치 프로그램입니다. 설치 프로그램 백엔드는 범용 설치 프로그램일 수도 있지만 필수는 아닙니다. PEP 517과 비교하면 <code>Flit</code>에 해당합니다. 설치 프로그램 백엔드는 기반 설치 프로그램(backing installer)을 감싸는 래퍼(wrapper) 패키지일 수 있습니다. 예를 들어, Poetry는 이 API를 지원하지 않기로 선택할 수 있지만, 패키지는 Poetry를 사용하여 설치를 수행하는 데 적절하게 Poetry를 호출하는 래퍼 역할을 할 수 있습니다.</li>
<li><strong>Dependency group (종속성 그룹):</strong> 어떤 목적을 위해 동시에 설치해야 하는 관련 종속성 집합입니다. 예를 들어, "test" 종속성 그룹에는 테스트 스위트를 실행하는 데 필요한 종속성이 포함될 수 있습니다. 종속성 그룹을 지정하는 방법은 설치 프로그램 백엔드에 달려 있습니다.</li>
</ul>
<h3>동기 (Motivation)</h3>
<p>이 사양은 지정된 인터페이스를 구현하는 설치 프로그램 백엔드를 누구나 호출하고 상호 작용할 수 있도록 하여, 기존 도구별 설치 프로세스 위에 보편적으로 지원되는 계층을 가능하게 합니다.</p>
<p>이는 결과적으로 이 사양을 구현하는 모든 설치 프로그램이 단일 범용 설치 프로그램을 지원하는 환경에서 사용될 수 있도록 합니다.</p>
<p>아래에서는 Python 커뮤니티의 이해관계자와 Python 패키지 설치 프로그램과 상호 작용하는 모든 사람에게 적용할 수 있는 다양한 사용 사례를 식별합니다. 개발자나 기업의 경우, 이 PEP는 Python 패키지 설치 프로그램의 기능과 유연성을 증가시킬 것입니다.</p>
<h4>제공자 (Providers)</h4>
<p>제공자는 Python 패키징 및 Python 패키지 설치 프로그램과 상호 작용하는 서비스 또는 소프트웨어 도구를 제공하는 당사자(조직, 사람, 커뮤니티 등)입니다. 두 가지 유형의 제공자가 고려됩니다.</p>
<ul>
<li>
<p><strong>플랫폼/인프라 제공자 (Platform/Infrastructure Providers):</strong> 클라우드 환경, 애플리케이션 호스팅 등 플랫폼 제공자와 인프라 서비스 제공자는 사용자가 Python 종속성을 설치할 수 있도록 패키지 설치 프로그램을 지원해야 합니다. 대부분 <code>pip</code>만 지원하지만, 다른 Python 설치 프로그램에 대한 사용자 요구도 있습니다. 대부분의 제공자는 소프트웨어 또는 서비스에 추가되는 복잡성과 그에 필요한 리소스 때문에 두 개 이상의 설치 프로그램을 유지 관리하는 것을 원하지 않습니다. 이 사양을 통해 제공자 지원 범용 설치 프로그램은 제공자 플랫폼이 해당 백엔드에 대한 특정 지식이 없더라도 사용자가 원하는 설치 프로그램 백엔드를 호출할 수 있습니다. 이는 Poetry가 이 PEP가 제안한 설치 프로그램 백엔드 API를 구현한다면(또는 다른 패키지가 Poetry를 래핑하여 API를 제공한다면), 플랫폼 제공자가 Poetry를 암묵적으로 지원할 것이라는 의미입니다.</p>
</li>
<li>
<p><strong>IDE 제공자 (IDE Providers):</strong> 통합 개발 환경(IDE)은 Python 패키지 설치 및 관리와 상호 작용할 수 있습니다. 대부분 <code>pip</code>만 Python 패키지 설치 프로그램으로 지원하며, 사용자는 다른 패키지 설치 프로그램을 사용하여 종속성을 설치하기 위한 해결 방법을 찾아야 합니다. PaaS 및 IaaS 제공자와 유사하게, IDE 제공자는 N개의 다른 Python 설치 프로그램을 지원하는 것을 원하지 않습니다. 대신, 설치 프로그램 인터페이스(설치 프로그램 백엔드)를 구현하는 사람들은 IDE가 범용 설치 프로그램 역할을 함으로써 호출될 수 있습니다.</p>
</li>
</ul>
<h4>개발자 (Developers)</h4>
<p>개발자는 Python 패키지 설치 프로그램과 Python 패키지를 코딩하고 사용하는 팀, 사람 또는 커뮤니티입니다. 세 가지 유형의 개발자가 고려됩니다.</p>
<ul>
<li>
<p><strong>PaaS 및 IaaS 제공자를 사용하는 개발자 (Developers using PaaS &#x26; IaaS providers):</strong> 대부분의 PaaS 및 IaaS 제공자는 하나의 Python 패키지 설치 프로그램인 <code>pip</code>만 지원합니다. (예외로는 <code>pip</code>과 <code>Pipenv</code>를 모두 지원하는 Heroku의 Python 빌드팩이 있습니다.) 이는 개발자가 이러한 제공자와 작업할 때 사용할 수 있는 설치 프로그램을 제한하며, 이는 애플리케이션이나 워크플로우에 최적이지 않을 수 있습니다. 이 PEP를 채택하여 설치 프로그램 백엔드가 되는 설치 프로그램은 사용자가 제공자가 범용 설치 프로그램을 사용하는 한, 어떤 Python 패키지 설치 프로그램을 사용해야 하는지 걱정할 필요 없이 타사 플랫폼/인프라를 사용할 수 있도록 합니다.</p>
</li>
<li>
<p><strong>IDE를 사용하는 개발자 (Developers using IDEs):</strong> 대부분의 IDE는 <code>pip</code> 또는 몇 가지 Python 패키지 설치 프로그램만 지원합니다. 결과적으로, 개발자는 지원되지 않는 패키지 설치 프로그램을 사용하는 경우 종속성을 설치하기 위해 해결 방법이나 임시방편적인 방법을 사용해야 합니다. IDE가 범용 설치 프로그램을 사용/제공한다면, 개발자가 원하는 설치 프로그램 백엔드를 사용하여 종속성을 설치할 수 있게 되어, IDE의 워크플로우에 더 밀접하게 통합하기 위해 종속성을 설치하는 데 필요한 추가 작업을 없앨 수 있습니다.</p>
</li>
<li>
<p><strong>다른 개발자와 협업하는 개발자 (Developers working with other developers):</strong> 개발자는 다른 개발자와 협업할 때 자신이 선택한 설치 프로그램을 사용하고 싶어 하지만, 현재는 종속성 설치의 호환성을 위해 설치 프로그램 선택을 동기화해야 합니다. 모든 선호 설치 프로그램이 대신 지정된 인터페이스를 구현한다면, 설치 프로그램의 상호 사용이 가능해져 개발자가 협업자의 선호도와 관계없이 설치 프로그램을 선택할 수 있습니다.</p>
</li>
</ul>
<h4>업그레이더 및 패키지 인프라 제공자 (Upgraders &#x26; Package Infrastructure Providers)</h4>
<p>Dependabot, PyUP 등 CI/CD의 패키지 업그레이더 및 패키지 인프라는 현재 몇 가지 설치 프로그램을 지원합니다. 이들은 <code>requirements.txt</code> 또는 <code>poetry.lock</code>과 같은 설치 프로그램별 종속성 파일을 관련 패키지 정보(업그레이드, 다운그레이드 또는 새 해시)로 직접 파싱하고 편집하여 작동합니다. 플랫폼 및 IDE 제공자와 유사하게, 이러한 제공자들은 N개의 다른 파일 유형을 지원해야 하므로 N개의 다른 Python 패키지 설치 프로그램을 지원하는 것을 원하지 않습니다.</p>
<p>현재 이러한 서비스/봇은 각 패키지 설치 프로그램에 대해 개별적으로 지원을 구현해야 합니다. 필연적으로 가장 인기 있는 설치 프로그램이 먼저 지원되며, 덜 인기 있는 도구는 종종 전혀 지원되지 않습니다. 이 사양을 구현함으로써 이러한 서비스/봇은 모든 (준수하는) 설치 프로그램을 지원할 수 있으므로, 사용자는 원하는 도구를 선택할 수 있습니다. 이는 플랫폼과 IDE가 더 이상 "승자"를 조기에 선택할 필요가 없으므로 해당 분야의 혁신을 더욱 촉진할 것입니다.</p>
<h4>오픈 소스 커뮤니티 (Open Source Community)</h4>
<p>설치 프로그램 요구사항을 명시하고 이 PEP를 채택하면 Python 패키지 설치 프로그램과 사람들의 워크플로우 간의 마찰이 줄어들 것입니다. 결과적으로 Python 패키지 설치 프로그램과 PaaS 또는 IDE와 같은 타사 인프라/기술 간의 마찰도 줄어들 것입니다. 전반적으로 Python 패키지 설치가 더 간단하고 상호 운용성이 높아지면서 Python 프로젝트의 개발, 배포 및 유지 관리가 더 쉬워질 것입니다.</p>
<p>설치 프로그램에 대한 요구사항을 명시하고 인터페이스를 생성하면 설치 프로그램 주변의 혁신 속도를 높일 수도 있습니다. 이는 설치 프로그램이 나머지 생태계가 동일하게 따를 필요 없이 고유한 기능을 실험하고 추가할 수 있도록 할 것입니다. 새로운 설치 프로그램에 대한 지원은 추가하는 기능과 종속성을 작성하는 형식에 관계없이 더 쉬워지고 가능성이 높아지며, 이를 위해 필요한 개발자 시간과 리소스를 줄일 수 있습니다.</p>
<h3>명세 (Specification)</h3>
<p>PEP 517이 빌드 시스템을 지정하는 방식과 유사하게, 설치 시스템 정보는 <code>pyproject.toml</code> 파일의 <code>[install-system]</code> 테이블에 저장됩니다.</p>
<p><code>[install-system]</code> 테이블은 설치 시스템 관련 데이터 및 정보를 저장하는 데 사용됩니다. 이 테이블에는 <code>requires</code>와 <code>install-backend</code>라는 여러 필수 키가 있습니다. <code>requires</code> 키는 설치 프로그램 백엔드가 실행하는 데 필요한 최소 요구사항을 담고 있으며, 이는 범용 설치 프로그램에 의해 설치될 것입니다. <code>install-backend</code> 키는 설치 백엔드의 진입점(entry point) 이름을 담고 있습니다. 이는 범용 설치 프로그램이 설치 프로그램 백엔드 자체(설치 프로그램 백엔드 자체가 설치할 요구사항이 아님)를 실행하는 데 필요한 요구사항을 설치하고 설치 프로그램 백엔드를 호출할 수 있도록 합니다.</p>
<p>필수 키 중 하나라도 누락되거나 비어 있으면 범용 설치 프로그램은 오류를 발생시켜야 합니다 (<code>SHOULD</code> raise an error).</p>
<p>이 인터페이스와 상호 작용하는 모든 패키지 이름은 PEP 508의 "Python 소프트웨어 패키지 종속성 명세" 형식을 따르는 것으로 가정합니다.</p>
<p><code>install-system</code> 테이블의 예시:</p>
<pre><code class="language-toml">#pyproject.toml
[install-system]
#Eg : pipenv
requires = ["pipenv"]
install-backend = "pipenv.api:main"
</code></pre>
<h4>설치 프로그램 요구사항: (Installer Requirements:)</h4>
<p><code>requires</code> 키로 지정된 요구사항은 PEP 517이 지정한 제약 조건 내에 있어야 합니다. 특히 종속성 순환은 허용되지 않으며, 순환이 감지되면 범용 설치 프로그램은 종속성 설치를 거부해야 합니다 (<code>SHOULD</code> refuse to install).</p>
<h4>추가 매개변수 또는 도구별 데이터 (Additional parameters or tool specific data)</h4>
<p>추가 매개변수 또는 도구(설치 프로그램 백엔드) 데이터도 <code>pyproject.toml</code> 파일에 저장될 수 있습니다. 이는 PEP 518에 지정된 대로 "tool.*" 테이블에 있을 것입니다. 예를 들어, 설치 프로그램 백엔드가 Poetry이고 여러 종속성 그룹을 지정하려면 <code>tool.poetry</code> 테이블은 다음과 같을 수 있습니다.</p>
<pre><code class="language-toml">[tool.poetry.dev-dependencies]
dependencies = "dev"
[tool.poetry.deploy]
dependencies = "deploy"
</code></pre>
<p>데이터는 설치 프로그램 백엔드가 적절하다고 판단하는 다른 방식으로도 저장될 수 있습니다 (예: 별도의 구성 파일).</p>
<h4>설치 프로그램 인터페이스: (Installer interface:)</h4>
<p>설치 프로그램 인터페이스에는 필수 <code>mandatory hooks</code>와 선택적 <code>optional hooks</code>이 포함됩니다. 규격을 준수하는 설치 프로그램 백엔드는 필수 <code>hooks</code>를 구현해야 하고(<code>MUST</code>), 선택적 <code>hooks</code>는 구현할 수도 있습니다(<code>MAY</code>). 범용 설치 프로그램은 자체적으로 설치 프로그램 백엔드 <code>hooks</code>를 구현하여 범용 설치 프로그램이자 설치 프로그램 백엔드 역할을 할 수 있지만, 필수는 아닙니다.</p>
<p>모든 <code>hook</code>는 <code>**kwargs</code> 임의 매개변수를 받는데, 이는 설치 프로그램 백엔드가 아직 지정되지 않은 추가 정보를 필요로 할 수 있도록 하여 하위 호환성을 허용합니다. 예상치 못한 매개변수가 설치 프로그램 백엔드로 전달되면 무시해야 합니다.</p>
<p>다음 정보는 PEP 517의 해당 섹션과 유사합니다. <code>hook</code>는 키워드 인수를 사용하여 호출될 수 있으므로, 이를 구현하는 설치 프로그램 백엔드는 해당 서명이 위 인수의 순서와 이름 모두와 일치하는지 확인해야 합니다.</p>
<p>모든 <code>hook</code>는 임의의 정보성 텍스트를 <code>stdout</code> 및 <code>stderr</code>로 출력할 수 있습니다 (<code>MAY</code> print). <code>stdin</code>에서 읽어서는 안 되며 (<code>MUST NOT</code>), 범용 설치 프로그램은 <code>hook</code>를 호출하기 전에 <code>stdin</code>을 닫을 수 있습니다 (<code>MAY</code> close).</p>
<p>범용 설치 프로그램은 백엔드의 <code>stdout</code> 및/또는 <code>stderr</code>를 캡처할 수 있습니다. 백엔드가 출력 스트림이 터미널/콘솔이 아님을 감지하면 (예: <code>sys.stdout.isatty()</code>가 아님), 해당 스트림에 기록하는 모든 출력이 UTF-8로 인코딩되도록 해야 합니다 (<code>SHOULD</code> ensure). 범용 설치 프로그램은 캡처된 출력이 유효한 UTF-8이 아니더라도 실패해서는 안 되지만 (<code>MUST NOT</code> fail), 이 경우 모든 정보를 보존하지 못할 수 있습니다 (예: Python에서 <code>replace</code> 오류 핸들러를 사용하여 디코딩할 수 있음). 출력 스트림이 터미널인 경우, 설치 프로그램 백엔드는 터미널에서 실행되는 모든 프로그램과 마찬가지로 출력을 정확하게 표시할 책임이 있습니다.</p>
<p><code>hook</code>가 예외를 발생시키거나 프로세스가 종료되면 이는 오류를 나타냅니다.</p>
<h5>필수 Hooks (Mandatory hooks):</h5>
<ul>
<li>
<p><code>invoke_install</code>
종속성을 설치합니다:</p>
<pre><code class="language-python">def invoke_install(
    path: Union[str, bytes, PathLike[str]],
    *,
    dependency_group: str = None,
    **kwargs
) -> int:
    ...
</code></pre>
<ul>
<li><code>path</code>: 설치 프로그램 백엔드가 호출되어야 하는 절대 경로입니다 (예: <code>pyproject.toml</code>이 있는 디렉터리).</li>
<li><code>dependency_group</code>: 설치 프로그램 백엔드가 설치해야 하는 종속성 그룹을 지정하는 선택적 플래그입니다. 종속성 그룹이 존재하지 않으면 설치는 오류를 발생시킬 것입니다. 종속성 그룹이 설치 프로그램 백엔드에서 지원되는 경우 <code>get_dependency_groups()</code>를 호출하여 모든 종속성 그룹을 찾을 수 있습니다.</li>
<li><code>**kwargs</code>: 설치 프로그램 백엔드가 필요할 수 있는 임의의 매개변수이며, 아직 지정되지 않은 것들을 포함하여 하위 호환성을 허용합니다.</li>
<li><code>Returns</code>: 종료 코드(<code>int</code>). 성공 시 0, 실패 시 양의 정수입니다.</li>
</ul>
<p>범용 설치 프로그램은 종료 코드를 사용하여 설치 성공 여부를 판단하고 자체적으로 종료 코드를 반환해야 합니다 (<code>SHOULD</code> return).</p>
</li>
</ul>
<h5>선택적 Hooks (Optional hooks):</h5>
<ul>
<li>
<p><code>invoke_uninstall</code>
지정된 종속성을 제거합니다:</p>
<pre><code class="language-python">def invoke_uninstall(
    path: Union[str, bytes, PathLike[str]],
    *,
    dependency_group: str = None,
    **kwargs
) -> int:
    ...
</code></pre>
<ul>
<li><code>path</code>: 설치 프로그램 백엔드가 호출되어야 하는 절대 경로입니다 (예: <code>pyproject.toml</code>이 있는 디렉터리).</li>
<li><code>dependency_group</code>: 설치 프로그램 백엔드가 제거해야 하는 종속성 그룹을 지정하는 선택적 플래그입니다.</li>
<li><code>**kwargs</code>: 설치 프로그램 백엔드가 필요할 수 있는 임의의 매개변수이며, 아직 지정되지 않은 것들을 포함하여 하위 호환성을 허용합니다.</li>
<li><code>Returns</code>: 종료 코드(<code>int</code>). 성공 시 0, 실패 시 양의 정수입니다.</li>
</ul>
<p>범용 설치 프로그램은 범용 설치 프로그램 자체가 호출된 것과 동일한 경로에서 설치 프로그램 백엔드를 호출해야 합니다 (<code>MUST</code> invoke).</p>
<p>범용 설치 프로그램은 종료 코드를 사용하여 제거 성공 여부를 판단하고 자체적으로 종료 코드를 반환해야 합니다 (<code>SHOULD</code> return).</p>
</li>
<li>
<p><code>get_dependencies_to_install</code>
<code>invoke_install(...)</code>에 의해 설치될 종속성을 반환합니다. 이를 통해 패키지 업그레이더(예: Dependabot)는 종속성 파일을 파싱하지 않고도 설치하려는 종속성을 검색할 수 있습니다.</p>
<pre><code class="language-python">def get_dependencies_to_install(
    path: Union[str, bytes, PathLike[str]],
    *,
    dependency_group: str = None,
    **kwargs
) -> Sequence[str]:
    ...
</code></pre>
<ul>
<li><code>path</code>: 설치 프로그램 백엔드가 호출되어야 하는 절대 경로입니다 (예: <code>pyproject.toml</code>이 있는 디렉터리).</li>
<li><code>dependency_group</code>: 해당 종속성 그룹에 대해 <code>invoke_install(...)</code>이 설치할 종속성을 가져올 종속성 그룹을 지정합니다.</li>
<li><code>**kwargs</code>: 설치 프로그램 백엔드가 필요할 수 있는 임의의 매개변수이며, 아직 지정되지 않은 것들을 포함하여 하위 호환성을 허용합니다.</li>
<li><code>Returns</code>: 설치할 종속성 목록 (PEP 508 문자열)입니다.</li>
</ul>
<p>그룹이 지정된 경우, 설치 프로그램 백엔드는 제공된 종속성 그룹에 해당하는 종속성을 반환해야 합니다 (<code>MUST</code> return). 지정된 그룹이 존재하지 않거나 종속성 그룹이 설치 프로그램 백엔드에서 지원되지 않는 경우, 설치 프로그램 백엔드는 오류를 발생시켜야 합니다 (<code>MUST</code> raise an error).</p>
<p>그룹이 지정되지 않고 설치 프로그램 백엔드가 기본/미지정 그룹의 개념을 제공하는 경우, 설치 프로그램 백엔드는 기본/미지정 그룹에 대한 종속성을 반환할 수 있지만 (<code>MAY</code> return), 그렇지 않으면 오류를 발생시켜야 합니다 (<code>MUST</code> raise an error).</p>
</li>
<li>
<p><code>get_dependency_groups</code>
설치 가능한 종속성 그룹을 반환합니다. 이를 통해 범용 설치 프로그램은 설치 프로그램 백엔드가 알고 있는 모든 종속성 그룹을 열거할 수 있습니다.</p>
<pre><code class="language-python">def get_dependency_groups(
    path: Union[str, bytes, PathLike[str]],
    **kwargs
) -> AbstractSet[str]:
    ...
</code></pre>
<ul>
<li><code>path</code>: 설치 프로그램 백엔드가 호출되어야 하는 절대 경로입니다 (예: <code>pyproject.toml</code>이 있는 디렉터리).</li>
<li><code>**kwargs</code>: 설치 프로그램 백엔드가 필요할 수 있는 임의의 매개변수이며, 아직 지정되지 않은 것들을 포함하여 하위 호환성을 허용합니다.</li>
<li><code>Returns</code>: 알려진 종속성 그룹의 집합 (<code>set</code>)이며, 문자열입니다. 빈 집합은 종속성 그룹이 없음을 나타냅니다.</li>
</ul>
</li>
<li>
<p><code>update_dependencies</code>
입력된 패키지 목록을 기반으로 종속성 파일을 출력합니다.</p>
<pre><code class="language-python">def update_dependencies(
    path: Union[str, bytes, PathLike[str]],
    dependency_specifiers: Iterable[str],
    *,
    dependency_group=None,
    **kwargs
) -> int:
    ...
</code></pre>
<ul>
<li><code>path</code>: 설치 프로그램 백엔드가 호출되어야 하는 절대 경로입니다 (예: <code>pyproject.toml</code>이 있는 디렉터리).</li>
<li><code>dependency_specifiers</code>: 예를 들어 <code>["requests==2.8.1", ...]</code>와 같이 업데이트되는 PEP 508 문자열 형태의 종속성 이터러블(iterable)입니다. 특정 종속성 그룹에 대한 선택 사항입니다.</li>
<li><code>dependency_group</code>: 패키지 목록이 속한 종속성 그룹입니다.</li>
<li><code>**kwargs</code>: 설치 프로그램 백엔드가 필요할 수 있는 임의의 매개변수이며, 아직 지정되지 않은 것들을 포함하여 하위 호환성을 허용합니다.</li>
<li><code>Returns</code>: 종료 코드(<code>int</code>). 성공 시 0, 실패 시 양의 정수입니다.</li>
</ul>
</li>
</ul>
<h3>예시 (Example)</h3>
<p><code>pip</code>과 <code>requirements</code> 파일을 종속성 그룹에 사용하는 설치 프로그램 백엔드를 구현한다고 가정해 봅시다. 구현은 (매우 대략적으로) 다음과 같을 수 있습니다.</p>
<pre><code class="language-python">import subprocess
import sys

def invoke_install(path, *, dependency_group=None, **kwargs):
    try:
        return subprocess.run(
            [
                sys.executable,
                "-m",
                "pip",
                "install",
                "-r",
                dependency_group or "requirements.txt",
            ],
            cwd=path,
        ).returncode
    except subprocess.CalledProcessError as e:
        return e.returncode
</code></pre>
<p>이 패키지의 이름을 <code>pep650pip</code>이라고 한다면, <code>pyproject.toml</code>에 다음과 같이 지정할 수 있습니다.</p>
<pre><code class="language-toml">[install-system]
#Eg : pipenv
requires = ["pep650pip", "pip"]
install-backend = "pep650pip:main"
</code></pre>
<h3>이론적 근거 (Rationale)</h3>
<p>모든 <code>hook</code>가 <code>**kwargs</code>를 받는 것은 하위 호환성을 허용하고, <code>hook</code>에서 요구하지 않는 추가 정보를 사용자에게 제공해야 하는 도구별 설치 프로그램 백엔드 기능을 허용하기 위함입니다.</p>
<p>설치 프로그램 백엔드는 Python 패키지여야 하지만, 호출될 때 무엇을 하는지는 해당 도구의 구현 세부 사항입니다. 예를 들어, 설치 프로그램 백엔드는 플랫폼 패키지 관리자(예: <code>apt</code>)의 래퍼 역할을 할 수 있습니다.</p>
<p>이 인터페이스는 설치 프로그램 백엔드가 어떻게 작동해야 하는지에 대해 어떤 식으로든 지정하려고 하지 않습니다. 이는 설치 프로그램 백엔드가 자체적인 방식으로 혁신하고 문제를 해결할 수 있도록 하기 위함입니다. 이는 또한 이 PEP가 OS 패키징에 대한 입장을 취하지 않음을 의미하며, 이는 설치 프로그램 백엔드의 영역입니다.</p>
<p>API를 Python으로 정의한다는 것은 결국 일부 Python 코드가 실행되어야 함을 의미합니다. 그러나 이는 비-Python 설치 프로그램 백엔드(예: <code>mamba</code>)가 사용되는 것을 배제하지 않는데, 이러한 백엔드는 Python 코드에서 서브프로세스로 실행될 수 있기 때문입니다.</p>
<h3>하위 호환성 (Backwards Compatibility)</h3>
<p>이 PEP는 범용 설치 프로그램에 새로운 기능을 추가할 뿐이므로 기존 코드 및 기능에는 영향을 미치지 않습니다. 모든 기존 설치 프로그램은 기존 기능 및 사용 사례를 유지해야 하므로, 하위 호환성 문제가 없습니다. 이 새로운 기능을 활용하려는 코드만이 기존 코드를 변경할 동기를 가질 것입니다.</p>
<h3>보안 관련 사항 (Security Implications)</h3>
<p>표준화된 설치 프로그램 사양의 추가로 악의적인 사용자가 어떤 것에 대한 능력이나 접근 권한을 더 쉽게 얻는 것은 없습니다. 이 PEP에 지정된 인터페이스를 통해 범용 설치 프로그램이 호출할 수 있는 설치 프로그램은 사용자에 의해 명시적으로 선언될 것입니다. 사용자가 악의적인 설치 프로그램을 선택했다면, 범용 설치 프로그램으로 호출하는 것은 사용자가 설치 프로그램을 직접 호출하는 것과 다르지 않습니다. 악의적인 설치 프로그램이 설치 프로그램 백엔드라고 해서 추가적인 권한이나 능력을 얻는 것은 아닙니다.</p>
<h3>거부된 아이디어 (Rejected Ideas)</h3>
<h4>표준화된 록 파일 (A standardized lock file)</h4>
<p>표준화된 록 파일은 설치 프로그램 요구사항을 명시하는 것과 동일한 많은 문제를 해결할 수 있을 것입니다. 예를 들어, PaaS/IaaS가 생성한 설치 프로그램과 관계없이 표준화된 록 파일을 읽을 수 있는 단일 설치 프로그램만 지원할 수 있도록 할 것입니다. 표준화된 록 파일의 문제는 Python 패키지 설치 프로그램 간의 요구사항 차이와 록 파일을 통한 재현 가능한 환경 생성(주요 이점 중 하나)에 대한 근본적인 문제입니다.</p>
<p>설치 프로그램 간의 종속성 파일에 저장되는 요구사항과 정보는 상당히 다르며 설치 프로그램 기능에 따라 달라집니다. 예를 들어, Poetry와 같은 Python 패키지 설치 프로그램은 모든 Python 버전 및 플랫폼에 대한 정보를 요구하고 적절한 해시를 계산하는 반면, <code>pip</code>은 그렇지 않습니다. 또한 <code>pip</code>은 자체 기능 범위 밖이므로 동일한 환경을 재현(정확히 동일한 종속성을 설치)하는 것을 보장할 수 없습니다. 이는 표준화된 록 파일을 구현하기 어렵게 만들고 록 파일이 도구별로 되는 것이 더 적절해 보입니다.</p>
<h4>설치 프로그램 백엔드가 가상 환경 생성을 지원하도록 함 (Have installer backends support creating virtual environments)</h4>
<p>설치 프로그램 백엔드가 가상 환경 및 그 안에 설치하는 방법에 대한 개념을 가질 가능성이 매우 높기 때문에, 가상 환경 생성도 지원하도록 하는 것이 잠시 고려되었습니다. 그러나 결국 이는 직교적인(orthogonal) 아이디어로 간주되었습니다.</p>
<h3>열린 문제 (Open Issues)</h3>
<h4><code>dependency_group</code> 인수가 이터러블을 받아야 하는가? (Should the dependency_group argument take an iterable?)</h4>
<p>이는 단일 호출에서 겹치지 않는 종속성 그룹을 지정할 수 있도록 할 것입니다. 예를 들어, 독립적인 종속성을 가지지만 개발자가 개발 중에 동시에 설치하기를 원할 수 있는 "docs" 및 "test" 그룹과 같습니다.</p>
<h4>설치 프로그램 백엔드는 프로세스 내에서 실행되는가? (Is the installer backend executed in-process?)</h4>
<p>설치 프로그램 백엔드가 프로세스 내에서 실행되면, 라이브 Python 환경에서 적절한 정보를 질의할 수 있으므로 설치할/설치될 환경을 아는 것이 크게 단순화됩니다.</p>
<p>프로세스 외부에서 실행하면 설치될 환경과 설치 프로그램 백엔드(및 잠재적으로 범용 설치 프로그램) 간의 충돌 가능성을 최소화할 수 있습니다.</p>
<h4>제안된 인터페이스의 결과가 다른 부분으로 전달되도록 강제해야 하는가? (Enforce that results from the proposed interface feed into other parts?)</h4>
<p>예를 들어, <code>get_dependencies_to_install()</code> 및 <code>get_dependency_groups()</code>의 결과는 <code>invoke_install()</code>로 전달될 수 있습니다. 이는 제안된 인터페이스의 다양한 부분 결과 간의 불일치를 방지하지만, 인터페이스의 더 많은 부분을 선택 사항이 아닌 필수로 만듭니다.</p>
<h4>실패 조건에 대해 종료 코드 대신 예외를 발생시키는가? (Raising exceptions instead of exit codes for failure conditions)</h4>
<p>API가 종료 코드를 반환하는 대신 예외를 발생시켜야 한다는 제안이 있었습니다. 이 PEP를 현재 설치 프로그램을 설치 프로그램 백엔드로 변환하는 데 도움이 되는 것으로 본다면, 종료 코드에 의존하는 것이 합리적입니다. 또한 API에 특정 반환 값이 없으므로 종료 코드를 전달하는 것이 함수의 반환 값과 충돌하지 않는다는 점도 있습니다.</p>
<p>오류 발생 시 예외를 발생시키는 것과 비교해 보세요. 이는 오류 발생에 대한 보다 구조화된 접근 방식을 제공할 수 있지만, 오류를 캡처하려면 인터페이스의 일부로 예외 유형을 지정해야 합니다.</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 조건으로 제공됩니다.</p>
<hr>
<p><strong>출처:</strong> https://peps.python.org/pep-0650/
<strong>최종 수정일:</strong> 2025-02-01 08:55:40 GMT</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/650\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/650/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/650\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"650\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/650\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T810b,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0650/\"\u003ePEP 650 - Specifying Installer Requirements for Python Projects\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Withdrawn | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 16-Jul-2020\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 650 – Python 프로젝트를 위한 설치 프로그램 요구사항 명세 (Withdrawn)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Vikram Jayanthi, Dustin Ingram, Brett Cannon\n\u003cstrong\u003e토론:\u003c/strong\u003e Discourse 스레드\n\u003cstrong\u003e상태:\u003c/strong\u003e 철회됨 (Withdrawn)\n\u003cstrong\u003e유형:\u003c/strong\u003e 표준 트랙 (Standards Track)\n\u003cstrong\u003e주제:\u003c/strong\u003e 패키징 (Packaging)\n\u003cstrong\u003e생성일:\u003c/strong\u003e 2020년 7월 16일\n\u003cstrong\u003e이력:\u003c/strong\u003e 2021년 1월 14일\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e현재 Python 패키지 설치 프로그램들은 서로 완전히 상호 운용되지 않습니다. \u003ccode\u003epip\u003c/code\u003e이 가장 널리 사용되는 사실상의 표준이지만, Poetry나 Pipenv 같은 다른 설치 프로그램들도 특정 워크플로우에 최적화된 고유한 기능을 제공하여 인기가 많습니다.\u003c/p\u003e\n\u003cp\u003e다양한 설치 프로그램 옵션이 특정 요구사항을 가진 최종 사용자에게는 좋지만, 이들 간의 상호 운용성 부족은 모든 잠재적 설치 프로그램을 지원하기 어렵게 만듭니다. 특히, 종속성을 선언하는 표준화된 요구사항 파일이 없기 때문에, 각 도구는 해당 형식으로 지정된 종속성을 설치하기 위해 명시적으로 사용되어야 합니다. 그렇지 않으면 도구는 요구사항 파일을 내보내야 하는데, 이는 설치 프로그램에 대한 잠재적인 정보 손실과 개발자 워크플로우의 추가적인 내보내기 단계를 초래합니다.\u003c/p\u003e\n\u003cp\u003e호환 가능한 설치 프로그램을 호출하는 데 사용할 수 있는 표준화된 API를 제공함으로써, 우리는 다양한 설치 프로그램과 그들의 록 파일(lock file) 간의 개별적인 문제, 고유한 요구사항 및 비호환성을 해결할 필요 없이 이 문제를 해결할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 사양을 구현하는 설치 프로그램은 균일한 방식으로 호출될 수 있으며, 사용자는 마치 직접 호출하는 것처럼 원하는 설치 프로그램을 사용할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e용어 (Terminology)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eInstaller interface (설치 프로그램 인터페이스):\u003c/strong\u003e 설치 프로그램 백엔드와 범용 설치 프로그램이 상호 작용하는 인터페이스입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUniversal installer (범용 설치 프로그램):\u003c/strong\u003e 설치 프로그램 인터페이스의 선택적 호출 메서드를 호출하여 설치 프로그램 백엔드를 호출할 수 있는 설치 프로그램입니다. 이는 PEP 517의 \u003ccode\u003ebuild\u003c/code\u003e 프로젝트처럼 설치 프로그램 프런트엔드로도 생각할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInstaller backend (설치 프로그램 백엔드):\u003c/strong\u003e 설치 프로그램 인터페이스를 구현하여 범용 설치 프로그램에 의해 호출될 수 있는 설치 프로그램입니다. 설치 프로그램 백엔드는 범용 설치 프로그램일 수도 있지만 필수는 아닙니다. PEP 517과 비교하면 \u003ccode\u003eFlit\u003c/code\u003e에 해당합니다. 설치 프로그램 백엔드는 기반 설치 프로그램(backing installer)을 감싸는 래퍼(wrapper) 패키지일 수 있습니다. 예를 들어, Poetry는 이 API를 지원하지 않기로 선택할 수 있지만, 패키지는 Poetry를 사용하여 설치를 수행하는 데 적절하게 Poetry를 호출하는 래퍼 역할을 할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDependency group (종속성 그룹):\u003c/strong\u003e 어떤 목적을 위해 동시에 설치해야 하는 관련 종속성 집합입니다. 예를 들어, \"test\" 종속성 그룹에는 테스트 스위트를 실행하는 데 필요한 종속성이 포함될 수 있습니다. 종속성 그룹을 지정하는 방법은 설치 프로그램 백엔드에 달려 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e동기 (Motivation)\u003c/h3\u003e\n\u003cp\u003e이 사양은 지정된 인터페이스를 구현하는 설치 프로그램 백엔드를 누구나 호출하고 상호 작용할 수 있도록 하여, 기존 도구별 설치 프로세스 위에 보편적으로 지원되는 계층을 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003e이는 결과적으로 이 사양을 구현하는 모든 설치 프로그램이 단일 범용 설치 프로그램을 지원하는 환경에서 사용될 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e아래에서는 Python 커뮤니티의 이해관계자와 Python 패키지 설치 프로그램과 상호 작용하는 모든 사람에게 적용할 수 있는 다양한 사용 사례를 식별합니다. 개발자나 기업의 경우, 이 PEP는 Python 패키지 설치 프로그램의 기능과 유연성을 증가시킬 것입니다.\u003c/p\u003e\n\u003ch4\u003e제공자 (Providers)\u003c/h4\u003e\n\u003cp\u003e제공자는 Python 패키징 및 Python 패키지 설치 프로그램과 상호 작용하는 서비스 또는 소프트웨어 도구를 제공하는 당사자(조직, 사람, 커뮤니티 등)입니다. 두 가지 유형의 제공자가 고려됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e플랫폼/인프라 제공자 (Platform/Infrastructure Providers):\u003c/strong\u003e 클라우드 환경, 애플리케이션 호스팅 등 플랫폼 제공자와 인프라 서비스 제공자는 사용자가 Python 종속성을 설치할 수 있도록 패키지 설치 프로그램을 지원해야 합니다. 대부분 \u003ccode\u003epip\u003c/code\u003e만 지원하지만, 다른 Python 설치 프로그램에 대한 사용자 요구도 있습니다. 대부분의 제공자는 소프트웨어 또는 서비스에 추가되는 복잡성과 그에 필요한 리소스 때문에 두 개 이상의 설치 프로그램을 유지 관리하는 것을 원하지 않습니다. 이 사양을 통해 제공자 지원 범용 설치 프로그램은 제공자 플랫폼이 해당 백엔드에 대한 특정 지식이 없더라도 사용자가 원하는 설치 프로그램 백엔드를 호출할 수 있습니다. 이는 Poetry가 이 PEP가 제안한 설치 프로그램 백엔드 API를 구현한다면(또는 다른 패키지가 Poetry를 래핑하여 API를 제공한다면), 플랫폼 제공자가 Poetry를 암묵적으로 지원할 것이라는 의미입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIDE 제공자 (IDE Providers):\u003c/strong\u003e 통합 개발 환경(IDE)은 Python 패키지 설치 및 관리와 상호 작용할 수 있습니다. 대부분 \u003ccode\u003epip\u003c/code\u003e만 Python 패키지 설치 프로그램으로 지원하며, 사용자는 다른 패키지 설치 프로그램을 사용하여 종속성을 설치하기 위한 해결 방법을 찾아야 합니다. PaaS 및 IaaS 제공자와 유사하게, IDE 제공자는 N개의 다른 Python 설치 프로그램을 지원하는 것을 원하지 않습니다. 대신, 설치 프로그램 인터페이스(설치 프로그램 백엔드)를 구현하는 사람들은 IDE가 범용 설치 프로그램 역할을 함으로써 호출될 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e개발자 (Developers)\u003c/h4\u003e\n\u003cp\u003e개발자는 Python 패키지 설치 프로그램과 Python 패키지를 코딩하고 사용하는 팀, 사람 또는 커뮤니티입니다. 세 가지 유형의 개발자가 고려됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePaaS 및 IaaS 제공자를 사용하는 개발자 (Developers using PaaS \u0026#x26; IaaS providers):\u003c/strong\u003e 대부분의 PaaS 및 IaaS 제공자는 하나의 Python 패키지 설치 프로그램인 \u003ccode\u003epip\u003c/code\u003e만 지원합니다. (예외로는 \u003ccode\u003epip\u003c/code\u003e과 \u003ccode\u003ePipenv\u003c/code\u003e를 모두 지원하는 Heroku의 Python 빌드팩이 있습니다.) 이는 개발자가 이러한 제공자와 작업할 때 사용할 수 있는 설치 프로그램을 제한하며, 이는 애플리케이션이나 워크플로우에 최적이지 않을 수 있습니다. 이 PEP를 채택하여 설치 프로그램 백엔드가 되는 설치 프로그램은 사용자가 제공자가 범용 설치 프로그램을 사용하는 한, 어떤 Python 패키지 설치 프로그램을 사용해야 하는지 걱정할 필요 없이 타사 플랫폼/인프라를 사용할 수 있도록 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIDE를 사용하는 개발자 (Developers using IDEs):\u003c/strong\u003e 대부분의 IDE는 \u003ccode\u003epip\u003c/code\u003e 또는 몇 가지 Python 패키지 설치 프로그램만 지원합니다. 결과적으로, 개발자는 지원되지 않는 패키지 설치 프로그램을 사용하는 경우 종속성을 설치하기 위해 해결 방법이나 임시방편적인 방법을 사용해야 합니다. IDE가 범용 설치 프로그램을 사용/제공한다면, 개발자가 원하는 설치 프로그램 백엔드를 사용하여 종속성을 설치할 수 있게 되어, IDE의 워크플로우에 더 밀접하게 통합하기 위해 종속성을 설치하는 데 필요한 추가 작업을 없앨 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e다른 개발자와 협업하는 개발자 (Developers working with other developers):\u003c/strong\u003e 개발자는 다른 개발자와 협업할 때 자신이 선택한 설치 프로그램을 사용하고 싶어 하지만, 현재는 종속성 설치의 호환성을 위해 설치 프로그램 선택을 동기화해야 합니다. 모든 선호 설치 프로그램이 대신 지정된 인터페이스를 구현한다면, 설치 프로그램의 상호 사용이 가능해져 개발자가 협업자의 선호도와 관계없이 설치 프로그램을 선택할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e업그레이더 및 패키지 인프라 제공자 (Upgraders \u0026#x26; Package Infrastructure Providers)\u003c/h4\u003e\n\u003cp\u003eDependabot, PyUP 등 CI/CD의 패키지 업그레이더 및 패키지 인프라는 현재 몇 가지 설치 프로그램을 지원합니다. 이들은 \u003ccode\u003erequirements.txt\u003c/code\u003e 또는 \u003ccode\u003epoetry.lock\u003c/code\u003e과 같은 설치 프로그램별 종속성 파일을 관련 패키지 정보(업그레이드, 다운그레이드 또는 새 해시)로 직접 파싱하고 편집하여 작동합니다. 플랫폼 및 IDE 제공자와 유사하게, 이러한 제공자들은 N개의 다른 파일 유형을 지원해야 하므로 N개의 다른 Python 패키지 설치 프로그램을 지원하는 것을 원하지 않습니다.\u003c/p\u003e\n\u003cp\u003e현재 이러한 서비스/봇은 각 패키지 설치 프로그램에 대해 개별적으로 지원을 구현해야 합니다. 필연적으로 가장 인기 있는 설치 프로그램이 먼저 지원되며, 덜 인기 있는 도구는 종종 전혀 지원되지 않습니다. 이 사양을 구현함으로써 이러한 서비스/봇은 모든 (준수하는) 설치 프로그램을 지원할 수 있으므로, 사용자는 원하는 도구를 선택할 수 있습니다. 이는 플랫폼과 IDE가 더 이상 \"승자\"를 조기에 선택할 필요가 없으므로 해당 분야의 혁신을 더욱 촉진할 것입니다.\u003c/p\u003e\n\u003ch4\u003e오픈 소스 커뮤니티 (Open Source Community)\u003c/h4\u003e\n\u003cp\u003e설치 프로그램 요구사항을 명시하고 이 PEP를 채택하면 Python 패키지 설치 프로그램과 사람들의 워크플로우 간의 마찰이 줄어들 것입니다. 결과적으로 Python 패키지 설치 프로그램과 PaaS 또는 IDE와 같은 타사 인프라/기술 간의 마찰도 줄어들 것입니다. 전반적으로 Python 패키지 설치가 더 간단하고 상호 운용성이 높아지면서 Python 프로젝트의 개발, 배포 및 유지 관리가 더 쉬워질 것입니다.\u003c/p\u003e\n\u003cp\u003e설치 프로그램에 대한 요구사항을 명시하고 인터페이스를 생성하면 설치 프로그램 주변의 혁신 속도를 높일 수도 있습니다. 이는 설치 프로그램이 나머지 생태계가 동일하게 따를 필요 없이 고유한 기능을 실험하고 추가할 수 있도록 할 것입니다. 새로운 설치 프로그램에 대한 지원은 추가하는 기능과 종속성을 작성하는 형식에 관계없이 더 쉬워지고 가능성이 높아지며, 이를 위해 필요한 개발자 시간과 리소스를 줄일 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003cp\u003ePEP 517이 빌드 시스템을 지정하는 방식과 유사하게, 설치 시스템 정보는 \u003ccode\u003epyproject.toml\u003c/code\u003e 파일의 \u003ccode\u003e[install-system]\u003c/code\u003e 테이블에 저장됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e[install-system]\u003c/code\u003e 테이블은 설치 시스템 관련 데이터 및 정보를 저장하는 데 사용됩니다. 이 테이블에는 \u003ccode\u003erequires\u003c/code\u003e와 \u003ccode\u003einstall-backend\u003c/code\u003e라는 여러 필수 키가 있습니다. \u003ccode\u003erequires\u003c/code\u003e 키는 설치 프로그램 백엔드가 실행하는 데 필요한 최소 요구사항을 담고 있으며, 이는 범용 설치 프로그램에 의해 설치될 것입니다. \u003ccode\u003einstall-backend\u003c/code\u003e 키는 설치 백엔드의 진입점(entry point) 이름을 담고 있습니다. 이는 범용 설치 프로그램이 설치 프로그램 백엔드 자체(설치 프로그램 백엔드 자체가 설치할 요구사항이 아님)를 실행하는 데 필요한 요구사항을 설치하고 설치 프로그램 백엔드를 호출할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e필수 키 중 하나라도 누락되거나 비어 있으면 범용 설치 프로그램은 오류를 발생시켜야 합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e raise an error).\u003c/p\u003e\n\u003cp\u003e이 인터페이스와 상호 작용하는 모든 패키지 이름은 PEP 508의 \"Python 소프트웨어 패키지 종속성 명세\" 형식을 따르는 것으로 가정합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003einstall-system\u003c/code\u003e 테이블의 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e#pyproject.toml\n[install-system]\n#Eg : pipenv\nrequires = [\"pipenv\"]\ninstall-backend = \"pipenv.api:main\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e설치 프로그램 요구사항: (Installer Requirements:)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003erequires\u003c/code\u003e 키로 지정된 요구사항은 PEP 517이 지정한 제약 조건 내에 있어야 합니다. 특히 종속성 순환은 허용되지 않으며, 순환이 감지되면 범용 설치 프로그램은 종속성 설치를 거부해야 합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e refuse to install).\u003c/p\u003e\n\u003ch4\u003e추가 매개변수 또는 도구별 데이터 (Additional parameters or tool specific data)\u003c/h4\u003e\n\u003cp\u003e추가 매개변수 또는 도구(설치 프로그램 백엔드) 데이터도 \u003ccode\u003epyproject.toml\u003c/code\u003e 파일에 저장될 수 있습니다. 이는 PEP 518에 지정된 대로 \"tool.*\" 테이블에 있을 것입니다. 예를 들어, 설치 프로그램 백엔드가 Poetry이고 여러 종속성 그룹을 지정하려면 \u003ccode\u003etool.poetry\u003c/code\u003e 테이블은 다음과 같을 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e[tool.poetry.dev-dependencies]\ndependencies = \"dev\"\n[tool.poetry.deploy]\ndependencies = \"deploy\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데이터는 설치 프로그램 백엔드가 적절하다고 판단하는 다른 방식으로도 저장될 수 있습니다 (예: 별도의 구성 파일).\u003c/p\u003e\n\u003ch4\u003e설치 프로그램 인터페이스: (Installer interface:)\u003c/h4\u003e\n\u003cp\u003e설치 프로그램 인터페이스에는 필수 \u003ccode\u003emandatory hooks\u003c/code\u003e와 선택적 \u003ccode\u003eoptional hooks\u003c/code\u003e이 포함됩니다. 규격을 준수하는 설치 프로그램 백엔드는 필수 \u003ccode\u003ehooks\u003c/code\u003e를 구현해야 하고(\u003ccode\u003eMUST\u003c/code\u003e), 선택적 \u003ccode\u003ehooks\u003c/code\u003e는 구현할 수도 있습니다(\u003ccode\u003eMAY\u003c/code\u003e). 범용 설치 프로그램은 자체적으로 설치 프로그램 백엔드 \u003ccode\u003ehooks\u003c/code\u003e를 구현하여 범용 설치 프로그램이자 설치 프로그램 백엔드 역할을 할 수 있지만, 필수는 아닙니다.\u003c/p\u003e\n\u003cp\u003e모든 \u003ccode\u003ehook\u003c/code\u003e는 \u003ccode\u003e**kwargs\u003c/code\u003e 임의 매개변수를 받는데, 이는 설치 프로그램 백엔드가 아직 지정되지 않은 추가 정보를 필요로 할 수 있도록 하여 하위 호환성을 허용합니다. 예상치 못한 매개변수가 설치 프로그램 백엔드로 전달되면 무시해야 합니다.\u003c/p\u003e\n\u003cp\u003e다음 정보는 PEP 517의 해당 섹션과 유사합니다. \u003ccode\u003ehook\u003c/code\u003e는 키워드 인수를 사용하여 호출될 수 있으므로, 이를 구현하는 설치 프로그램 백엔드는 해당 서명이 위 인수의 순서와 이름 모두와 일치하는지 확인해야 합니다.\u003c/p\u003e\n\u003cp\u003e모든 \u003ccode\u003ehook\u003c/code\u003e는 임의의 정보성 텍스트를 \u003ccode\u003estdout\u003c/code\u003e 및 \u003ccode\u003estderr\u003c/code\u003e로 출력할 수 있습니다 (\u003ccode\u003eMAY\u003c/code\u003e print). \u003ccode\u003estdin\u003c/code\u003e에서 읽어서는 안 되며 (\u003ccode\u003eMUST NOT\u003c/code\u003e), 범용 설치 프로그램은 \u003ccode\u003ehook\u003c/code\u003e를 호출하기 전에 \u003ccode\u003estdin\u003c/code\u003e을 닫을 수 있습니다 (\u003ccode\u003eMAY\u003c/code\u003e close).\u003c/p\u003e\n\u003cp\u003e범용 설치 프로그램은 백엔드의 \u003ccode\u003estdout\u003c/code\u003e 및/또는 \u003ccode\u003estderr\u003c/code\u003e를 캡처할 수 있습니다. 백엔드가 출력 스트림이 터미널/콘솔이 아님을 감지하면 (예: \u003ccode\u003esys.stdout.isatty()\u003c/code\u003e가 아님), 해당 스트림에 기록하는 모든 출력이 UTF-8로 인코딩되도록 해야 합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e ensure). 범용 설치 프로그램은 캡처된 출력이 유효한 UTF-8이 아니더라도 실패해서는 안 되지만 (\u003ccode\u003eMUST NOT\u003c/code\u003e fail), 이 경우 모든 정보를 보존하지 못할 수 있습니다 (예: Python에서 \u003ccode\u003ereplace\u003c/code\u003e 오류 핸들러를 사용하여 디코딩할 수 있음). 출력 스트림이 터미널인 경우, 설치 프로그램 백엔드는 터미널에서 실행되는 모든 프로그램과 마찬가지로 출력을 정확하게 표시할 책임이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehook\u003c/code\u003e가 예외를 발생시키거나 프로세스가 종료되면 이는 오류를 나타냅니다.\u003c/p\u003e\n\u003ch5\u003e필수 Hooks (Mandatory hooks):\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003einvoke_install\u003c/code\u003e\n종속성을 설치합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef invoke_install(\n    path: Union[str, bytes, PathLike[str]],\n    *,\n    dependency_group: str = None,\n    **kwargs\n) -\u003e int:\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epath\u003c/code\u003e: 설치 프로그램 백엔드가 호출되어야 하는 절대 경로입니다 (예: \u003ccode\u003epyproject.toml\u003c/code\u003e이 있는 디렉터리).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edependency_group\u003c/code\u003e: 설치 프로그램 백엔드가 설치해야 하는 종속성 그룹을 지정하는 선택적 플래그입니다. 종속성 그룹이 존재하지 않으면 설치는 오류를 발생시킬 것입니다. 종속성 그룹이 설치 프로그램 백엔드에서 지원되는 경우 \u003ccode\u003eget_dependency_groups()\u003c/code\u003e를 호출하여 모든 종속성 그룹을 찾을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e**kwargs\u003c/code\u003e: 설치 프로그램 백엔드가 필요할 수 있는 임의의 매개변수이며, 아직 지정되지 않은 것들을 포함하여 하위 호환성을 허용합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReturns\u003c/code\u003e: 종료 코드(\u003ccode\u003eint\u003c/code\u003e). 성공 시 0, 실패 시 양의 정수입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e범용 설치 프로그램은 종료 코드를 사용하여 설치 성공 여부를 판단하고 자체적으로 종료 코드를 반환해야 합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e return).\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5\u003e선택적 Hooks (Optional hooks):\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003einvoke_uninstall\u003c/code\u003e\n지정된 종속성을 제거합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef invoke_uninstall(\n    path: Union[str, bytes, PathLike[str]],\n    *,\n    dependency_group: str = None,\n    **kwargs\n) -\u003e int:\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epath\u003c/code\u003e: 설치 프로그램 백엔드가 호출되어야 하는 절대 경로입니다 (예: \u003ccode\u003epyproject.toml\u003c/code\u003e이 있는 디렉터리).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edependency_group\u003c/code\u003e: 설치 프로그램 백엔드가 제거해야 하는 종속성 그룹을 지정하는 선택적 플래그입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e**kwargs\u003c/code\u003e: 설치 프로그램 백엔드가 필요할 수 있는 임의의 매개변수이며, 아직 지정되지 않은 것들을 포함하여 하위 호환성을 허용합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReturns\u003c/code\u003e: 종료 코드(\u003ccode\u003eint\u003c/code\u003e). 성공 시 0, 실패 시 양의 정수입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e범용 설치 프로그램은 범용 설치 프로그램 자체가 호출된 것과 동일한 경로에서 설치 프로그램 백엔드를 호출해야 합니다 (\u003ccode\u003eMUST\u003c/code\u003e invoke).\u003c/p\u003e\n\u003cp\u003e범용 설치 프로그램은 종료 코드를 사용하여 제거 성공 여부를 판단하고 자체적으로 종료 코드를 반환해야 합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e return).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eget_dependencies_to_install\u003c/code\u003e\n\u003ccode\u003einvoke_install(...)\u003c/code\u003e에 의해 설치될 종속성을 반환합니다. 이를 통해 패키지 업그레이더(예: Dependabot)는 종속성 파일을 파싱하지 않고도 설치하려는 종속성을 검색할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef get_dependencies_to_install(\n    path: Union[str, bytes, PathLike[str]],\n    *,\n    dependency_group: str = None,\n    **kwargs\n) -\u003e Sequence[str]:\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epath\u003c/code\u003e: 설치 프로그램 백엔드가 호출되어야 하는 절대 경로입니다 (예: \u003ccode\u003epyproject.toml\u003c/code\u003e이 있는 디렉터리).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edependency_group\u003c/code\u003e: 해당 종속성 그룹에 대해 \u003ccode\u003einvoke_install(...)\u003c/code\u003e이 설치할 종속성을 가져올 종속성 그룹을 지정합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e**kwargs\u003c/code\u003e: 설치 프로그램 백엔드가 필요할 수 있는 임의의 매개변수이며, 아직 지정되지 않은 것들을 포함하여 하위 호환성을 허용합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReturns\u003c/code\u003e: 설치할 종속성 목록 (PEP 508 문자열)입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그룹이 지정된 경우, 설치 프로그램 백엔드는 제공된 종속성 그룹에 해당하는 종속성을 반환해야 합니다 (\u003ccode\u003eMUST\u003c/code\u003e return). 지정된 그룹이 존재하지 않거나 종속성 그룹이 설치 프로그램 백엔드에서 지원되지 않는 경우, 설치 프로그램 백엔드는 오류를 발생시켜야 합니다 (\u003ccode\u003eMUST\u003c/code\u003e raise an error).\u003c/p\u003e\n\u003cp\u003e그룹이 지정되지 않고 설치 프로그램 백엔드가 기본/미지정 그룹의 개념을 제공하는 경우, 설치 프로그램 백엔드는 기본/미지정 그룹에 대한 종속성을 반환할 수 있지만 (\u003ccode\u003eMAY\u003c/code\u003e return), 그렇지 않으면 오류를 발생시켜야 합니다 (\u003ccode\u003eMUST\u003c/code\u003e raise an error).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eget_dependency_groups\u003c/code\u003e\n설치 가능한 종속성 그룹을 반환합니다. 이를 통해 범용 설치 프로그램은 설치 프로그램 백엔드가 알고 있는 모든 종속성 그룹을 열거할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef get_dependency_groups(\n    path: Union[str, bytes, PathLike[str]],\n    **kwargs\n) -\u003e AbstractSet[str]:\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epath\u003c/code\u003e: 설치 프로그램 백엔드가 호출되어야 하는 절대 경로입니다 (예: \u003ccode\u003epyproject.toml\u003c/code\u003e이 있는 디렉터리).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e**kwargs\u003c/code\u003e: 설치 프로그램 백엔드가 필요할 수 있는 임의의 매개변수이며, 아직 지정되지 않은 것들을 포함하여 하위 호환성을 허용합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReturns\u003c/code\u003e: 알려진 종속성 그룹의 집합 (\u003ccode\u003eset\u003c/code\u003e)이며, 문자열입니다. 빈 집합은 종속성 그룹이 없음을 나타냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eupdate_dependencies\u003c/code\u003e\n입력된 패키지 목록을 기반으로 종속성 파일을 출력합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef update_dependencies(\n    path: Union[str, bytes, PathLike[str]],\n    dependency_specifiers: Iterable[str],\n    *,\n    dependency_group=None,\n    **kwargs\n) -\u003e int:\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epath\u003c/code\u003e: 설치 프로그램 백엔드가 호출되어야 하는 절대 경로입니다 (예: \u003ccode\u003epyproject.toml\u003c/code\u003e이 있는 디렉터리).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edependency_specifiers\u003c/code\u003e: 예를 들어 \u003ccode\u003e[\"requests==2.8.1\", ...]\u003c/code\u003e와 같이 업데이트되는 PEP 508 문자열 형태의 종속성 이터러블(iterable)입니다. 특정 종속성 그룹에 대한 선택 사항입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edependency_group\u003c/code\u003e: 패키지 목록이 속한 종속성 그룹입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e**kwargs\u003c/code\u003e: 설치 프로그램 백엔드가 필요할 수 있는 임의의 매개변수이며, 아직 지정되지 않은 것들을 포함하여 하위 호환성을 허용합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReturns\u003c/code\u003e: 종료 코드(\u003ccode\u003eint\u003c/code\u003e). 성공 시 0, 실패 시 양의 정수입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e예시 (Example)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epip\u003c/code\u003e과 \u003ccode\u003erequirements\u003c/code\u003e 파일을 종속성 그룹에 사용하는 설치 프로그램 백엔드를 구현한다고 가정해 봅시다. 구현은 (매우 대략적으로) 다음과 같을 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport subprocess\nimport sys\n\ndef invoke_install(path, *, dependency_group=None, **kwargs):\n    try:\n        return subprocess.run(\n            [\n                sys.executable,\n                \"-m\",\n                \"pip\",\n                \"install\",\n                \"-r\",\n                dependency_group or \"requirements.txt\",\n            ],\n            cwd=path,\n        ).returncode\n    except subprocess.CalledProcessError as e:\n        return e.returncode\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 패키지의 이름을 \u003ccode\u003epep650pip\u003c/code\u003e이라고 한다면, \u003ccode\u003epyproject.toml\u003c/code\u003e에 다음과 같이 지정할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e[install-system]\n#Eg : pipenv\nrequires = [\"pep650pip\", \"pip\"]\ninstall-backend = \"pep650pip:main\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e이론적 근거 (Rationale)\u003c/h3\u003e\n\u003cp\u003e모든 \u003ccode\u003ehook\u003c/code\u003e가 \u003ccode\u003e**kwargs\u003c/code\u003e를 받는 것은 하위 호환성을 허용하고, \u003ccode\u003ehook\u003c/code\u003e에서 요구하지 않는 추가 정보를 사용자에게 제공해야 하는 도구별 설치 프로그램 백엔드 기능을 허용하기 위함입니다.\u003c/p\u003e\n\u003cp\u003e설치 프로그램 백엔드는 Python 패키지여야 하지만, 호출될 때 무엇을 하는지는 해당 도구의 구현 세부 사항입니다. 예를 들어, 설치 프로그램 백엔드는 플랫폼 패키지 관리자(예: \u003ccode\u003eapt\u003c/code\u003e)의 래퍼 역할을 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 인터페이스는 설치 프로그램 백엔드가 어떻게 작동해야 하는지에 대해 어떤 식으로든 지정하려고 하지 않습니다. 이는 설치 프로그램 백엔드가 자체적인 방식으로 혁신하고 문제를 해결할 수 있도록 하기 위함입니다. 이는 또한 이 PEP가 OS 패키징에 대한 입장을 취하지 않음을 의미하며, 이는 설치 프로그램 백엔드의 영역입니다.\u003c/p\u003e\n\u003cp\u003eAPI를 Python으로 정의한다는 것은 결국 일부 Python 코드가 실행되어야 함을 의미합니다. 그러나 이는 비-Python 설치 프로그램 백엔드(예: \u003ccode\u003emamba\u003c/code\u003e)가 사용되는 것을 배제하지 않는데, 이러한 백엔드는 Python 코드에서 서브프로세스로 실행될 수 있기 때문입니다.\u003c/p\u003e\n\u003ch3\u003e하위 호환성 (Backwards Compatibility)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 범용 설치 프로그램에 새로운 기능을 추가할 뿐이므로 기존 코드 및 기능에는 영향을 미치지 않습니다. 모든 기존 설치 프로그램은 기존 기능 및 사용 사례를 유지해야 하므로, 하위 호환성 문제가 없습니다. 이 새로운 기능을 활용하려는 코드만이 기존 코드를 변경할 동기를 가질 것입니다.\u003c/p\u003e\n\u003ch3\u003e보안 관련 사항 (Security Implications)\u003c/h3\u003e\n\u003cp\u003e표준화된 설치 프로그램 사양의 추가로 악의적인 사용자가 어떤 것에 대한 능력이나 접근 권한을 더 쉽게 얻는 것은 없습니다. 이 PEP에 지정된 인터페이스를 통해 범용 설치 프로그램이 호출할 수 있는 설치 프로그램은 사용자에 의해 명시적으로 선언될 것입니다. 사용자가 악의적인 설치 프로그램을 선택했다면, 범용 설치 프로그램으로 호출하는 것은 사용자가 설치 프로그램을 직접 호출하는 것과 다르지 않습니다. 악의적인 설치 프로그램이 설치 프로그램 백엔드라고 해서 추가적인 권한이나 능력을 얻는 것은 아닙니다.\u003c/p\u003e\n\u003ch3\u003e거부된 아이디어 (Rejected Ideas)\u003c/h3\u003e\n\u003ch4\u003e표준화된 록 파일 (A standardized lock file)\u003c/h4\u003e\n\u003cp\u003e표준화된 록 파일은 설치 프로그램 요구사항을 명시하는 것과 동일한 많은 문제를 해결할 수 있을 것입니다. 예를 들어, PaaS/IaaS가 생성한 설치 프로그램과 관계없이 표준화된 록 파일을 읽을 수 있는 단일 설치 프로그램만 지원할 수 있도록 할 것입니다. 표준화된 록 파일의 문제는 Python 패키지 설치 프로그램 간의 요구사항 차이와 록 파일을 통한 재현 가능한 환경 생성(주요 이점 중 하나)에 대한 근본적인 문제입니다.\u003c/p\u003e\n\u003cp\u003e설치 프로그램 간의 종속성 파일에 저장되는 요구사항과 정보는 상당히 다르며 설치 프로그램 기능에 따라 달라집니다. 예를 들어, Poetry와 같은 Python 패키지 설치 프로그램은 모든 Python 버전 및 플랫폼에 대한 정보를 요구하고 적절한 해시를 계산하는 반면, \u003ccode\u003epip\u003c/code\u003e은 그렇지 않습니다. 또한 \u003ccode\u003epip\u003c/code\u003e은 자체 기능 범위 밖이므로 동일한 환경을 재현(정확히 동일한 종속성을 설치)하는 것을 보장할 수 없습니다. 이는 표준화된 록 파일을 구현하기 어렵게 만들고 록 파일이 도구별로 되는 것이 더 적절해 보입니다.\u003c/p\u003e\n\u003ch4\u003e설치 프로그램 백엔드가 가상 환경 생성을 지원하도록 함 (Have installer backends support creating virtual environments)\u003c/h4\u003e\n\u003cp\u003e설치 프로그램 백엔드가 가상 환경 및 그 안에 설치하는 방법에 대한 개념을 가질 가능성이 매우 높기 때문에, 가상 환경 생성도 지원하도록 하는 것이 잠시 고려되었습니다. 그러나 결국 이는 직교적인(orthogonal) 아이디어로 간주되었습니다.\u003c/p\u003e\n\u003ch3\u003e열린 문제 (Open Issues)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003edependency_group\u003c/code\u003e 인수가 이터러블을 받아야 하는가? (Should the dependency_group argument take an iterable?)\u003c/h4\u003e\n\u003cp\u003e이는 단일 호출에서 겹치지 않는 종속성 그룹을 지정할 수 있도록 할 것입니다. 예를 들어, 독립적인 종속성을 가지지만 개발자가 개발 중에 동시에 설치하기를 원할 수 있는 \"docs\" 및 \"test\" 그룹과 같습니다.\u003c/p\u003e\n\u003ch4\u003e설치 프로그램 백엔드는 프로세스 내에서 실행되는가? (Is the installer backend executed in-process?)\u003c/h4\u003e\n\u003cp\u003e설치 프로그램 백엔드가 프로세스 내에서 실행되면, 라이브 Python 환경에서 적절한 정보를 질의할 수 있으므로 설치할/설치될 환경을 아는 것이 크게 단순화됩니다.\u003c/p\u003e\n\u003cp\u003e프로세스 외부에서 실행하면 설치될 환경과 설치 프로그램 백엔드(및 잠재적으로 범용 설치 프로그램) 간의 충돌 가능성을 최소화할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e제안된 인터페이스의 결과가 다른 부분으로 전달되도록 강제해야 하는가? (Enforce that results from the proposed interface feed into other parts?)\u003c/h4\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003eget_dependencies_to_install()\u003c/code\u003e 및 \u003ccode\u003eget_dependency_groups()\u003c/code\u003e의 결과는 \u003ccode\u003einvoke_install()\u003c/code\u003e로 전달될 수 있습니다. 이는 제안된 인터페이스의 다양한 부분 결과 간의 불일치를 방지하지만, 인터페이스의 더 많은 부분을 선택 사항이 아닌 필수로 만듭니다.\u003c/p\u003e\n\u003ch4\u003e실패 조건에 대해 종료 코드 대신 예외를 발생시키는가? (Raising exceptions instead of exit codes for failure conditions)\u003c/h4\u003e\n\u003cp\u003eAPI가 종료 코드를 반환하는 대신 예외를 발생시켜야 한다는 제안이 있었습니다. 이 PEP를 현재 설치 프로그램을 설치 프로그램 백엔드로 변환하는 데 도움이 되는 것으로 본다면, 종료 코드에 의존하는 것이 합리적입니다. 또한 API에 특정 반환 값이 없으므로 종료 코드를 전달하는 것이 함수의 반환 값과 충돌하지 않는다는 점도 있습니다.\u003c/p\u003e\n\u003cp\u003e오류 발생 시 예외를 발생시키는 것과 비교해 보세요. 이는 오류 발생에 대한 보다 구조화된 접근 방식을 제공할 수 있지만, 오류를 캡처하려면 인터페이스의 일부로 예외 유형을 지정해야 합니다.\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 조건으로 제공됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e출처:\u003c/strong\u003e https://peps.python.org/pep-0650/\n\u003cstrong\u003e최종 수정일:\u003c/strong\u003e 2025-02-01 08:55:40 GMT\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Withdrawn] PEP 650 - Specifying Installer Requirements for Python Projects\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 01:40:48+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>