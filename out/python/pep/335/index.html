<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-19cfc001fdac3337.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1098<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 335 - Overloadable Boolean Operators</h1><div class="page__meta"><time dateTime="2025-09-27 00:55:17+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0335/">PEP 335 - Overloadable Boolean Operators</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 29-Aug-2004</p>
</blockquote>
<p>PEP 335: 오버로딩 가능한 불리언 연산자 (Overloadable Boolean Operators)</p>
<p><em>본 문서는 거부(Rejected)된 제안입니다.</em></p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 객체가 불리언 연산자 <code>and</code>, <code>or</code>, <code>not</code>에 대해 자신만의 의미를 정의할 수 있도록 확장하는 방안을 제안하며, 효율적인 구현 전략을 제시합니다. 이 구현의 프로토타입은 다운로드 가능합니다.</p>
<h2>배경 (Background)</h2>
<p>현재 Python은 불리언 연산자 <code>and</code>, <code>or</code>, <code>not</code>에 해당하는 <code>__xxx__</code> 특수 메서드를 제공하지 않습니다. <code>and</code>와 <code>or</code>의 경우, 가장 유력한 이유는 이 연산자들이 단락 평가(short-circuiting semantics)를 갖기 때문입니다. 즉, 첫 번째 피연산자만으로 결과가 결정될 수 있으면 두 번째 피연산자는 평가되지 않습니다. 따라서 이러한 연산자에 대한 특수 메서드를 제공하는 일반적인 기술은 작동하지 않을 것입니다.</p>
<p>그러나 <code>not</code>의 경우에는 이러한 어려움이 없으며, 이 연산자에 대한 특수 메서드를 제공하는 것은 간단합니다. 따라서 이 제안의 나머지 부분은 주로 <code>and</code>와 <code>or</code>를 오버로딩(overload)하는 방법을 제공하는 데 중점을 둘 것입니다.</p>
<h2>동기 (Motivation)</h2>
<p>Python 연산자에 대해 사용자 정의 의미를 제공하는 것이 자연스러운 애플리케이션이 많으며, 이 중 일부에서는 불리언 연산자가 사용자 정의에서 제외되는 것이 불편할 수 있습니다. 예를 들면 다음과 같습니다:</p>
<ul>
<li><strong>NumPy</strong>: 거의 모든 연산자가 배열(array)에 정의되어 해당 요소들 간에 적절한 연산을 수행하고 결과 배열을 반환합니다. 일관성을 위해 두 배열 간의 불리언 연산은 불리언 배열을 반환할 것으로 예상되지만, 현재는 이것이 불가능합니다.
<ul>
<li>이러한 종류의 확장에 대한 선례가 있습니다. 비교 연산자는 원래 불리언 결과만 반환하도록 제한되었으나, NumPy 배열의 비교가 불리언 배열을 반환할 수 있도록 풍부한 비교(rich comparisons)가 추가되었습니다.</li>
</ul>
</li>
<li><strong>기호 대수 시스템 (Symbolic algebra system)</strong>: Python 표현식이 평가되어 표현식의 구조에 해당하는 객체 트리를 구성하는 환경.</li>
<li><strong>관계형 데이터베이스 인터페이스 (Relational database interface)</strong>: Python 표현식을 사용하여 SQL 쿼리를 구성하는 경우.</li>
</ul>
<p>자주 제안되는 해결책은 <code>and</code>, <code>or</code>, <code>not</code> 대신 비트와이즈 연산자 <code>&#x26;</code>, <code>|</code>, <code>~</code>를 사용하는 것이지만, 여기에는 몇 가지 단점이 있습니다:</p>
<ul>
<li>다른 연산자와의 우선순위(precedence)가 다르며, 다른 목적으로 이미 사용되고 있을 수 있습니다.</li>
<li>사용자가 표현하려는 것에 대해 가장 명확한 구문이 아닌 다른 것을 사용하도록 강제하는 것은 미학적으로 좋지 않습니다. 특히 예시 3과 같은 경우, 불리언 연산이 SQL 쿼리의 주류임을 고려할 때 더욱 심각할 수 있습니다.</li>
<li>비트와이즈 연산자는 <code>a &#x3C; b &#x3C; c</code>와 같이 암시적인 <code>and</code> 연산을 포함하는 체인 비교(chained comparisons) 문제에 대한 해결책을 제공하지 않습니다. 이러한 표현식은 현재 NumPy 배열과 같이 비교 결과가 일반적인 불리언 의미를 갖는 것으로 처리될 수 없는 데이터 타입에서는 전혀 사용할 수 없습니다. 이를 <code>(a &#x3C; b) &#x26; (b &#x3C; c)</code>와 같이 확장해야 하며, 상당한 명확성을 잃게 됩니다.</li>
</ul>
<h2>근거 (Rationale)</h2>
<p>불리언 연산자를 사용자 정의할 수 있도록 허용하는 문제에 대한 성공적인 해결책의 요구 사항은 다음과 같습니다:</p>
<ol>
<li><strong>기본 경우 (사용자 정의가 없는 경우)</strong>: 기존의 단락 평가 의미론(short-circuiting semantics)이 보존되어야 합니다.</li>
<li><strong>기본 경우 (속도)</strong>: 기본 경우에 눈에 띄는 속도 손실이 없어야 합니다.</li>
<li><strong>사용자 정의 메커니즘</strong>: 사용자 정의 메커니즘은 객체가 재량에 따라 단락 평가 또는 비단락 평가 의미론을 제공할 수 있도록 허용해야 합니다.</li>
</ol>
<p>이전에 제안되었던 한 가지 분명한 전략은 첫 번째 인자와 두 번째 인자를 평가하기 위한 함수를 특수 메서드에 전달하는 것입니다. 이는 요구 사항 1과 3을 충족하지만, 불리언 연산마다 함수 객체를 구성하고 잠재적으로 Python 함수 호출을 발생시키는 오버헤드가 발생하므로 요구 사항 2는 충족하지 못합니다. 따라서 이 문서에서는 더 이상 고려되지 않습니다.</p>
<p>다음 섹션에서는 세 가지 요구 사항을 모두 해결하는 전략을 제안합니다. 이 전략의 프로토타입 구현은 다운로드 가능합니다.</p>
<h2>사양 (Specification)</h2>
<h3>특수 메서드 (Special Methods)</h3>
<p>Python 수준에서 객체는 다음 특수 메서드를 정의할 수 있습니다.</p>
<ul>
<li>
<p><strong>단항 (Unary)</strong></p>
<ul>
<li><code>__not__(self)</code>
<ul>
<li><code>__not__</code> 메서드가 정의되어 있다면 <code>not</code> 연산자를 구현합니다. 정의되어 있지 않거나 <code>NotImplemented</code>를 반환하면 기존 의미론이 사용됩니다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>이항, 1단계 (Binary, phase 1)</strong></p>
<ul>
<li><code>__and1__(self)</code></li>
<li><code>__or1__(self)</code>
<ul>
<li>단락 평가를 허용하기 위해 <code>and</code> 및 <code>or</code> 연산자의 처리는 두 단계로 나뉩니다. 1단계는 첫 번째 피연산자가 평가된 후, 두 번째 피연산자 이전에 발생합니다. 첫 번째 피연산자가 관련 1단계 메서드를 정의하면, 첫 번째 피연산자를 인자로 호출합니다. 해당 메서드가 두 번째 피연산자가 필요 없이 결과를 결정할 수 있다면, 결과를 반환하고 추가 처리는 건너뜁니다.</li>
<li>1단계 메서드가 두 번째 피연산자가 필요하다고 결정하면 특수 값 <code>NeedOtherOperand</code>를 반환합니다. 이는 두 번째 피연산자의 평가와 관련 2단계 메서드의 호출을 트리거합니다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>이항, 2단계 (Binary, phase 2)</strong></p>
<ul>
<li><code>__and2__(self, other)</code></li>
<li><code>__or2__(self, other)</code></li>
<li><code>__rand2__(self, other)</code></li>
<li><code>__ror2__(self, other)</code>
<ul>
<li>2단계 동안, <code>__and2__/__rand2__</code> 및 <code>__or2__/__ror2__</code> 메서드 쌍은 다른 이항 연산자와 동일하게 작동합니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>어떤 단계에서든 관련 특수 메서드가 발견되지 않거나 <code>NotImplemented</code>를 반환하면 기존 의미론으로 폴백(fallback)됩니다.</p>
<p>특별한 경우로, 첫 번째 피연산자가 2단계 메서드를 정의했지만 해당 1단계 메서드를 정의하지 않은 경우, 두 번째 피연산자는 항상 평가되고 2단계 메서드가 호출됩니다. 이는 단락 평가 의미론을 원하지 않는 객체가 단순히 2단계 메서드를 구현하고 1단계를 무시할 수 있도록 합니다.</p>
<h3>바이트코드 (Bytecodes)</h3>
<p>이 패치는 네 가지 새로운 바이트코드인 <code>LOGICAL_AND_1</code>, <code>LOGICAL_AND_2</code>, <code>LOGICAL_OR_1</code>, <code>LOGICAL_OR_2</code>를 추가합니다. 예를 들어, <code>and</code> 표현식에 대해 생성된 바이트코드는 다음과 같습니다:</p>
<pre><code class="language-python">. . .
evaluate first operand
LOGICAL_AND_1
L
evaluate second operand
LOGICAL_AND_2
L:
. . .
</code></pre>
<ul>
<li><code>LOGICAL_AND_1</code> 바이트코드는 1단계 처리를 수행합니다. 두 번째 피연산자가 필요하다고 결정하면 첫 번째 피연산자를 스택에 남겨두고 다음 코드를 계속 실행합니다. 그렇지 않으면 첫 번째 피연산자를 팝(pop)하고 결과를 푸시(push)한 다음 <code>L</code>로 분기(branch)합니다.</li>
<li><code>LOGICAL_AND_2</code> 바이트코드는 2단계 처리를 수행하며, 두 피연산자를 모두 팝하고 결과를 푸시합니다.</li>
</ul>
<h3>타입 슬롯 (Type Slots)</h3>
<p>C 수준에서 새로운 특수 메서드는 타입 객체에 다섯 가지 새로운 슬롯으로 나타납니다. 패치에서는 이들이 <code>tp_as_number</code> 하위 구조체에 추가되는데, 이는 단항 및 이항 연산자를 다루는 기존 코드를 활용할 수 있도록 하기 위함입니다. 이들의 존재는 새로운 타입 플래그 <code>Py_TPFLAGS_HAVE_BOOLEAN_OVERLOAD</code>로 알려집니다.</p>
<p>새로운 타입 슬롯은 다음과 같습니다:</p>
<ul>
<li><code>unaryfunc nb_logical_not;</code></li>
<li><code>unaryfunc nb_logical_and_1;</code></li>
<li><code>unaryfunc nb_logical_or_1;</code></li>
<li><code>binaryfunc nb_logical_and_2;</code></li>
<li><code>binaryfunc nb_logical_or_2;</code></li>
</ul>
<h3>Python/C API 함수 (Python/C API Functions)</h3>
<p>새로운 연산에 해당하는 다섯 가지 새로운 Python/C API 함수도 있습니다:</p>
<ul>
<li><code>PyObject *PyObject_LogicalNot(PyObject *);</code></li>
<li><code>PyObject *PyObject_LogicalAnd1(PyObject *);</code></li>
<li><code>PyObject *PyObject_LogicalOr1(PyObject *);</code></li>
<li><code>PyObject *PyObject_LogicalAnd2(PyObject *, PyObject *);</code></li>
<li><code>PyObject *PyObject_LogicalOr2(PyObject *, PyObject *);</code></li>
</ul>
<h2>대안 및 최적화 (Alternatives and Optimisations)</h2>
<p>이 섹션에서는 제안의 몇 가지 가능한 변형과 불리언 표현식에 대해 생성된 바이트코드 시퀀스를 최적화하는 방법에 대해 설명하고 있습니다.</p>
<h3>특수 메서드 집합 축소 (Reduced special method set)</h3>
<p>이 제안의 완전한 버전은 타입이 자체적으로 사용자 정의 단락 평가 동작을 정의할 수 있는 메커니ズム를 포함합니다. 그러나 여기에서 제시된 주요 사용 사례를 해결하는 데 완전한 메커니즘은 필요하지 않으며, 2단계 메서드만 포함하는 간소화된 버전을 정의하는 것도 가능합니다. 그러면 <code>__and2__</code>, <code>__rand2__</code>, <code>__or2__</code>, <code>__ror2__</code>, <code>__not__</code>의 5가지 새로운 특수 메서드와 3개의 관련 타입 슬롯 및 3개의 API 함수만 존재하게 됩니다.</p>
<p>이 간소화된 버전은 나중에 필요하다면 완전한 버전으로 확장될 수 있습니다.</p>
<h3>추가 바이트코드 (Additional bytecodes)</h3>
<p>여기에서 정의된 대로, 불리언 표현식의 결과에 따라 분기하는 코드에 대한 바이트코드 시퀀스는 현재보다 약간 더 길어질 것입니다. 예를 들어, Python 2.7에서 <code>if a and b:</code> 구문은 다음과 같은 바이트코드를 생성합니다:</p>
<pre><code class="language-python">LOAD_GLOBAL a
POP_JUMP_IF_FALSE false_branch
LOAD_GLOBAL b
POP_JUMP_IF_FALSE false_branch
&#x3C;code for statement1>
JUMP_FORWARD end_branch
false_branch:
&#x3C;code for statement2>
end_branch:
</code></pre>
<p>이 제안에 따르면, 이는 다음과 같이 될 것입니다:</p>
<pre><code class="language-python">LOAD_GLOBAL a
LOGICAL_AND_1
test
LOAD_GLOBAL b
LOGICAL_AND_2
test:
POP_JUMP_IF_FALSE false_branch
&#x3C;code for statement1>
JUMP_FORWARD end_branch
false_branch:
&#x3C;code for statement2>
end_branch:
</code></pre>
<p>이는 단락 평가의 경우에 하나의 추가 바이트코드를, 비단락 평가의 경우에 두 개의 추가 바이트코드를 실행하는 것을 포함합니다.</p>
<p>그러나 논리 연산을 결과 테스트 및 분기와 결합하는 추가 바이트코드를 도입함으로써, 이는 원래와 동일한 수의 바이트코드로 줄어들 수 있습니다:</p>
<pre><code class="language-python">LOAD_GLOBAL a
AND1_JUMP true_branch, false_branch
LOAD_GLOBAL b
AND2_JUMP_IF_FALSE false_branch
true_branch:
&#x3C;code for statement1>
JUMP_FORWARD end_branch
false_branch:
&#x3C;code for statement2>
end_branch:
</code></pre>
<p>여기서 <code>AND1_JUMP</code>는 위에서 설명한 대로 1단계 처리를 수행한 다음 결과를 검사합니다. 결과가 있으면 스택에서 팝되고, 그 진리 값(truth value)이 테스트되어 두 위치 중 하나로 분기됩니다.</p>
<p>그렇지 않으면 첫 번째 피연산자가 스택에 남아 있고 실행은 다음 바이트코드로 계속됩니다. <code>AND2_JUMP_IF_FALSE</code> 바이트코드는 2단계 처리를 수행하고 결과를 팝한 다음 결과가 거짓으로 테스트되면 분기합니다.</p>
<p><code>or</code> 연산자의 경우, 해당 <code>OR1_JUMP</code> 및 <code>OR2_JUMP_IF_TRUE</code> 바이트코드가 있을 것입니다.</p>
<p>만약 1단계 메서드가 없는 간소화된 버전이 사용된다면, <code>and</code>의 경우 첫 번째 피연산자가 거짓일 때만, <code>or</code>의 경우 첫 번째 피연산자가 참일 때만 조기 종료가 발생할 수 있습니다. 결과적으로 두 개의 타겟을 갖는 <code>AND1_JUMP</code> 및 <code>OR1_JUMP</code> 바이트코드는 <code>AND1_JUMP_IF_FALSE</code> 및 <code>OR1_JUMP_IF_TRUE</code>로 대체될 수 있으며, 이들은 하나의 타겟만 갖는 일반적인 분기 명령입니다.</p>
<h3><code>not</code>의 최적화 (Optimisation of 'not')</h3>
<p>최근 버전의 Python은 부정된 불리언 표현식에 대한 분기를 분기 방향을 뒤집는 방식으로 구현하여 <code>UNARY_NOT</code> opcode를 절약하는 간단한 최적화를 구현합니다.</p>
<p>엄격하게 보면, <code>not</code> 연산자가 일반적인 것과 상당히 다른 결과를 생성하도록 오버라이딩될 수 있으므로 이 최적화는 더 이상 수행되어서는 안 됩니다. 그러나 일반적인 사용 사례에서는 사용자 정의된 불리언 연산을 포함하는 표현식이 분기(branching)에 사용될 것으로 예상되지 않습니다. 결과는 다른 방식으로 사용될 가능성이 훨씬 높습니다.</p>
<p>따라서 컴파일러가 불리언 컨텍스트에 직접 나타나는 모든 표현식을 단순화하기 위해 불리언 대수(boolean algebra)의 법칙을 사용하는 것을 허용하도록 지정해도 큰 해는 없을 것입니다. 이것이 불편하다면, 결과를 항상 임시 이름에 먼저 할당할 수 있습니다.</p>
<p>이렇게 하면 기존의 <code>not</code> 최적화가 유지될 수 있으며, 드 모르간의 법칙(De Morgan's laws)을 사용하여 표현식 내에서 더 깊게 확장하는 것과 같은 향후 확장도 가능하게 됩니다.</p>
<h2>사용 예시 (Usage Examples)</h2>
<h3>예시 1: NumPy 배열 (NumPy Arrays)</h3>
<p>이 예시는 <code>and</code>, <code>or</code>, <code>not</code> 연산자를 적용하여 불리언 배열을 생성할 수 있는 NumPy 배열의 하위 클래스를 만듭니다.</p>
<pre><code class="language-python">from numpy import array, ndarray

class BArray(ndarray):
    def __str__(self):
        return "barray(%s)" % ndarray.__str__(self)

    def __and2__(self, other):
        # 비트와이즈 AND를 사용하여 요소별 AND 연산을 수행합니다.
        # 이 예시에서는 __and2__에 대한 로직이 잘못되어 있습니다.
        # 실제로는 (self &#x26; other)가 아닌, 각 요소에 대한 논리 AND를 구현해야 합니다.
        # PEP 제안의 의도에 따라 재구성하면,
        # (self != 0) &#x26; (other != 0) 과 같은 형태가 될 수 있습니다.
        # 하지만 예시 코드에서는 단순하게 비트와이즈 AND를 사용했습니다.
        # 이는 PEP 335의 목적을 완전히 반영하지 않을 수 있습니다.
        return (self &#x26; other) # 예시에서는 비트와이즈 &#x26;를 사용

    def __or2__(self, other):
        # 마찬가지로, 이 예시에서는 __or2__에 대한 로직이 잘못되어 있습니다.
        # 실제로는 각 요소에 대한 논리 OR을 구현해야 합니다.
        return (self | other) # 예시에서는 비트와이즈 |를 사용

    def __not__(self):
        # 각 요소에 대해 논리 NOT 연산을 수행합니다.
        # 0이 아닌 값은 True, 0은 False로 간주하여 반전합니다.
        return (self == 0)

def barray(*args, **kwds):
    return array(*args, **kwds).view(type = BArray)

a0 = barray([0, 1, 2, 4])
a1 = barray([1, 2, 3, 4])
a2 = barray([5, 6, 3, 4])
a3 = barray([5, 1, 2, 4])

print("a0:", a0)
print("a1:", a1)
print("a2:", a2)
print("a3:", a3)
print("not a0:", not a0) # __not__ 메서드 호출
print("a0 == a1 and a2 == a3:", a0 == a1 and a2 == a3) # __and2__ 메서드 호출
print("a0 == a1 or a2 == a3:", a0 == a1 or a2 == a3)   # __or2__ 메서드 호출
</code></pre>
<h4>예시 1 출력 (Example 1 Output)</h4>
<pre><code>a0: barray([0 1 2 4])
a1: barray([1 2 3 4])
a2: barray([5 6 3 4])
a3: barray([5 1 2 4])
not a0: barray([ True False False False])
a0 == a1 and a2 == a3: barray([False False False True])
a0 == a1 or a2 == a3: barray([False False False True])
</code></pre>
<h3>예시 2: 데이터베이스 쿼리 (Database Queries)</h3>
<p>이 예시는 <code>and</code> 및 <code>or</code> 연산자를 사용하여 쿼리를 구성할 수 있는 데이터베이스 쿼리용 DSL(Domain Specific Language) 생성을 시연합니다.</p>
<pre><code class="language-python">class SQLNode(object):
    def __and2__(self, other):
        return SQLBinop("and", self, other)
    def __rand2__(self, other):
        return SQLBinop("and", other, self)
    def __eq__(self, other):
        return SQLBinop("=", self, other)

class Table(SQLNode):
    def __init__(self, name):
        self.__tablename__ = name
    def __getattr__(self, name):
        return SQLAttr(self, name)
    def __sql__(self):
        return self.__tablename__

class SQLBinop(SQLNode):
    def __init__(self, op, opnd1, opnd2):
        self.op = op.upper()
        self.opnd1 = opnd1
        self.opnd2 = opnd2
    def __sql__(self):
        return "(%s %s %s)" % (sql(self.opnd1), self.op, sql(self.opnd2))

class SQLAttr(SQLNode):
    def __init__(self, table, name):
        self.table = table
        self.name = name
    def __sql__(self):
        return "%s.%s" % (sql(self.table), self.name)

class SQLSelect(SQLNode):
    def __init__(self, targets):
        self.targets = targets
        self.where_clause = None
    def where(self, expr):
        self.where_clause = expr
        return self
    def __sql__(self):
        result = "SELECT %s" % ", ".join([sql(target) for target in self.targets])
        if self.where_clause:
            result = "%s WHERE %s" % (result, sql(self.where_clause))
        return result

def sql(expr):
    if isinstance(expr, SQLNode):
        return expr.__sql__()
    elif isinstance(expr, str):
        return "'%s'" % expr.replace("'", "''")
    else:
        return str(expr)

def select(*targets):
    return SQLSelect(targets)

#-----------------------------------------------------------------
dishes = Table("dishes")
customers = Table("customers")
orders = Table("orders")

query = select(customers.name, dishes.price, orders.amount).where(
    customers.cust_id == orders.cust_id and
    orders.dish_id == dishes.dish_id and
    dishes.name == "Spam, Eggs, Sausages and Spam"
)

print(repr(query))
print(sql(query))
</code></pre>
<h4>예시 2 출력 (Example 2 Output)</h4>
<pre><code>&#x3C;__main__.SQLSelect object at 0x1cc830>
SELECT customers.name, dishes.price, orders.amount WHERE (((customers.cust_id = orders.cust_id) AND (orders.dish_id = dishes.dish_id)) AND (dishes.name = 'Spam, Eggs, Sausages and Spam'))
</code></pre>
<h2>거부 공지 (Rejection Notice)</h2>
<p>이 PEP는 거부되었습니다. 자세한 내용은 다음 링크를 참조하십시오: <a href="https://mail.python.org/pipermail/python-dev/2012-March/117510.html">https://mail.python.org/pipermail/python-dev/2012-March/117510.html</a></p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)에 있습니다.</p>
<pre><code>The user wants a Korean translation and summary of PEP 335. I have already browsed the URL and obtained the content. Now I need to process this content according to the guidelines:

1.  **Professionalism:** Use accurate Python terminology.
2.  **Term Handling:**
    *   Use common Korean terms where available.
    *   For ambiguous or more familiar English terms, use English or 병기 (both English and Korean).
    *   Do NOT translate keywords or variable names in code.
3.  **Readability:** Use Markdown.
4.  **Accuracy:** Translate all original content into Markdown.

I will go section by section and translate the content, applying the guidelines.

**Plan:**
- Start with the PEP title and rejection notice.
- Translate Abstract.
- Translate Background.
- Translate Motivation, including the examples and workarounds.
- Translate Rationale.
- Translate Specification, covering Special Methods, Bytecodes, Type Slots, and Python/C API Functions.
- Translate Alternatives and Optimisations, including Reduced special method set, Additional bytecodes, and Optimisation of 'not'.
- Translate Usage Examples, including both NumPy Arrays and Database Queries, with their code and output.
- Conclude with the Copyright notice.
- Ensure all sentences derived from the browsed content have citations `[cite: 1]`.

Let's start translating.

---
**Initial thought on specific terms:**
- "Overloadable Boolean Operators" -> "오버로딩 가능한 불리언 연산자"
- "Rejected" -> "거부됨" or "거부(Rejected)"
- "Abstract" -> "개요"
- "Background" -> "배경"
- "Motivation" -> "동기"
- "Rationale" -> "근거"
- "Specification" -> "사양"
- "Special Methods" -> "특수 메서드"
- "Bytecodes" -> "바이트코드"
- "Type Slots" -> "타입 슬롯"
- "Python/C API Functions" -> "Python/C API 함수"
- "Alternatives and Optimisations" -> "대안 및 최적화"
- "Usage Examples" -> "사용 예시"
- "Short-circuiting semantics" -> "단락 평가 의미론" or "단락 평가 (short-circuiting semantics)"
- "NumPy Arrays" -> "NumPy 배열"
- "Relational database interface" -> "관계형 데이터베이스 인터페이스"
- "Bitwise operators" -> "비트와이즈 연산자"
- "Chained comparisons" -> "체인 비교 (chained comparisons)"
- "__and1__", "__or1__", "__and2__", "__or2__", "__rand2__", "__ror2__", "__not__" should remain as is, as they are code/keyword-like.
- `NotImplemented` also remains as is.
- `NeedOtherOperand` also remains as is.
- Bytecode names (`LOGICAL_AND_1`, `LOGICAL_AND_2`, etc.) remain as is.
- C-level type slots (`nb_logical_not`, etc.) remain as is.
- Python/C API functions (`PyObject_LogicalNot`, etc.) remain as is.
- "Precedence" -> "우선순위"
- "Domain Specific Language (DSL)" -> "DSL (Domain Specific Language)"

I will carefully go through the document and apply these.```
The user wants a Korean translation and summary of PEP 335. I have already browsed the URL and obtained the content. Now I need to process this content according to the guidelines:

1.  **Professionalism:** Use accurate Python terminology.
2.  **Term Handling:**
    *   Use common Korean terms where available.
    *   For ambiguous or more familiar English terms, use English or 병기 (both English and Korean).
    *   Do NOT translate keywords or variable names in code.
3.  **Readability:** Use Markdown.
4.  **Accuracy:** Translate all original content into Markdown.

I will go section by section and translate the content, applying the guidelines.

**Plan:**
- Start with the PEP title and rejection notice.
- Translate Abstract.
- Translate Background.
- Translate Motivation, including the examples and workarounds.
- Translate Rationale.
- Translate Specification, covering Special Methods, Bytecodes, Type Slots, and Python/C API Functions.
- Translate Alternatives and Optimisations, including Reduced special method set, Additional bytecodes, and Optimisation of 'not'.
- Translate Usage Examples, including both NumPy Arrays and Database Queries, with their code and output.
- Conclude with the Copyright notice.
- Ensure all sentences derived from the browsed content have citations `[cite: 1]`.

Let's start translating.

---
**Initial thought on specific terms:**
- "Overloadable Boolean Operators" -> "오버로딩 가능한 불리언 연산자"
- "Rejected" -> "거부됨" or "거부(Rejected)"
- "Abstract" -> "개요"
- "Background" -> "배경"
- "Motivation" -> "동기"
- "Rationale" -> "근거"
- "Specification" -> "사양"
- "Special Methods" -> "특수 메서드"
- "Bytecodes" -> "바이트코드"
- "Type Slots" -> "타입 슬롯"
- "Python/C API Functions" -> "Python/C API 함수"
- "Alternatives and Optimisations" -> "대안 및 최적화"
- "Usage Examples" -> "사용 예시"
- "Short-circuiting semantics" -> "단락 평가 의미론" or "단락 평가 (short-circuiting semantics)"
- "NumPy Arrays" -> "NumPy 배열"
- "Relational database interface" -> "관계형 데이터베이스 인터페이스"
- "Bitwise operators" -> "비트와이즈 연산자"
- "Chained comparisons" -> "체인 비교 (chained comparisons)"
- "__and1__", "__or1__", "__and2__", "__or2__", "__rand2__", "__ror2__", "__not__" should remain as is, as they are code/keyword-like.
- `NotImplemented` also remains as is.
- `NeedOtherOperand` also remains as is.
- Bytecode names (`LOGICAL_AND_1`, `LOGICAL_AND_2`, etc.) remain as is.
- C-level type slots (`nb_logical_not`, etc.) remain as is.
- Python/C API functions (`PyObject_LogicalNot`, etc.) remain as is.
- "Precedence" -> "우선순위"
- "Domain Specific Language (DSL)" -> "DSL (Domain Specific Language)"

I will carefully go through the document and apply these.

> ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.
</code></pre>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-19cfc001fdac3337.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/335\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"FeyCvJug7In7AgUZlfHUx\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/335/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/335\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"335\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/335\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T6a83,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0335/\"\u003ePEP 335 - Overloadable Boolean Operators\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 29-Aug-2004\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 335: 오버로딩 가능한 불리언 연산자 (Overloadable Boolean Operators)\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e본 문서는 거부(Rejected)된 제안입니다.\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 객체가 불리언 연산자 \u003ccode\u003eand\u003c/code\u003e, \u003ccode\u003eor\u003c/code\u003e, \u003ccode\u003enot\u003c/code\u003e에 대해 자신만의 의미를 정의할 수 있도록 확장하는 방안을 제안하며, 효율적인 구현 전략을 제시합니다. 이 구현의 프로토타입은 다운로드 가능합니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Background)\u003c/h2\u003e\n\u003cp\u003e현재 Python은 불리언 연산자 \u003ccode\u003eand\u003c/code\u003e, \u003ccode\u003eor\u003c/code\u003e, \u003ccode\u003enot\u003c/code\u003e에 해당하는 \u003ccode\u003e__xxx__\u003c/code\u003e 특수 메서드를 제공하지 않습니다. \u003ccode\u003eand\u003c/code\u003e와 \u003ccode\u003eor\u003c/code\u003e의 경우, 가장 유력한 이유는 이 연산자들이 단락 평가(short-circuiting semantics)를 갖기 때문입니다. 즉, 첫 번째 피연산자만으로 결과가 결정될 수 있으면 두 번째 피연산자는 평가되지 않습니다. 따라서 이러한 연산자에 대한 특수 메서드를 제공하는 일반적인 기술은 작동하지 않을 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 \u003ccode\u003enot\u003c/code\u003e의 경우에는 이러한 어려움이 없으며, 이 연산자에 대한 특수 메서드를 제공하는 것은 간단합니다. 따라서 이 제안의 나머지 부분은 주로 \u003ccode\u003eand\u003c/code\u003e와 \u003ccode\u003eor\u003c/code\u003e를 오버로딩(overload)하는 방법을 제공하는 데 중점을 둘 것입니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePython 연산자에 대해 사용자 정의 의미를 제공하는 것이 자연스러운 애플리케이션이 많으며, 이 중 일부에서는 불리언 연산자가 사용자 정의에서 제외되는 것이 불편할 수 있습니다. 예를 들면 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNumPy\u003c/strong\u003e: 거의 모든 연산자가 배열(array)에 정의되어 해당 요소들 간에 적절한 연산을 수행하고 결과 배열을 반환합니다. 일관성을 위해 두 배열 간의 불리언 연산은 불리언 배열을 반환할 것으로 예상되지만, 현재는 이것이 불가능합니다.\n\u003cul\u003e\n\u003cli\u003e이러한 종류의 확장에 대한 선례가 있습니다. 비교 연산자는 원래 불리언 결과만 반환하도록 제한되었으나, NumPy 배열의 비교가 불리언 배열을 반환할 수 있도록 풍부한 비교(rich comparisons)가 추가되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e기호 대수 시스템 (Symbolic algebra system)\u003c/strong\u003e: Python 표현식이 평가되어 표현식의 구조에 해당하는 객체 트리를 구성하는 환경.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e관계형 데이터베이스 인터페이스 (Relational database interface)\u003c/strong\u003e: Python 표현식을 사용하여 SQL 쿼리를 구성하는 경우.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e자주 제안되는 해결책은 \u003ccode\u003eand\u003c/code\u003e, \u003ccode\u003eor\u003c/code\u003e, \u003ccode\u003enot\u003c/code\u003e 대신 비트와이즈 연산자 \u003ccode\u003e\u0026#x26;\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e, \u003ccode\u003e~\u003c/code\u003e를 사용하는 것이지만, 여기에는 몇 가지 단점이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e다른 연산자와의 우선순위(precedence)가 다르며, 다른 목적으로 이미 사용되고 있을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e사용자가 표현하려는 것에 대해 가장 명확한 구문이 아닌 다른 것을 사용하도록 강제하는 것은 미학적으로 좋지 않습니다. 특히 예시 3과 같은 경우, 불리언 연산이 SQL 쿼리의 주류임을 고려할 때 더욱 심각할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e비트와이즈 연산자는 \u003ccode\u003ea \u0026#x3C; b \u0026#x3C; c\u003c/code\u003e와 같이 암시적인 \u003ccode\u003eand\u003c/code\u003e 연산을 포함하는 체인 비교(chained comparisons) 문제에 대한 해결책을 제공하지 않습니다. 이러한 표현식은 현재 NumPy 배열과 같이 비교 결과가 일반적인 불리언 의미를 갖는 것으로 처리될 수 없는 데이터 타입에서는 전혀 사용할 수 없습니다. 이를 \u003ccode\u003e(a \u0026#x3C; b) \u0026#x26; (b \u0026#x3C; c)\u003c/code\u003e와 같이 확장해야 하며, 상당한 명확성을 잃게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e불리언 연산자를 사용자 정의할 수 있도록 허용하는 문제에 대한 성공적인 해결책의 요구 사항은 다음과 같습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e기본 경우 (사용자 정의가 없는 경우)\u003c/strong\u003e: 기존의 단락 평가 의미론(short-circuiting semantics)이 보존되어야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e기본 경우 (속도)\u003c/strong\u003e: 기본 경우에 눈에 띄는 속도 손실이 없어야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e사용자 정의 메커니즘\u003c/strong\u003e: 사용자 정의 메커니즘은 객체가 재량에 따라 단락 평가 또는 비단락 평가 의미론을 제공할 수 있도록 허용해야 합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이전에 제안되었던 한 가지 분명한 전략은 첫 번째 인자와 두 번째 인자를 평가하기 위한 함수를 특수 메서드에 전달하는 것입니다. 이는 요구 사항 1과 3을 충족하지만, 불리언 연산마다 함수 객체를 구성하고 잠재적으로 Python 함수 호출을 발생시키는 오버헤드가 발생하므로 요구 사항 2는 충족하지 못합니다. 따라서 이 문서에서는 더 이상 고려되지 않습니다.\u003c/p\u003e\n\u003cp\u003e다음 섹션에서는 세 가지 요구 사항을 모두 해결하는 전략을 제안합니다. 이 전략의 프로토타입 구현은 다운로드 가능합니다.\u003c/p\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003ch3\u003e특수 메서드 (Special Methods)\u003c/h3\u003e\n\u003cp\u003ePython 수준에서 객체는 다음 특수 메서드를 정의할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e단항 (Unary)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__not__(self)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__not__\u003c/code\u003e 메서드가 정의되어 있다면 \u003ccode\u003enot\u003c/code\u003e 연산자를 구현합니다. 정의되어 있지 않거나 \u003ccode\u003eNotImplemented\u003c/code\u003e를 반환하면 기존 의미론이 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e이항, 1단계 (Binary, phase 1)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__and1__(self)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__or1__(self)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e단락 평가를 허용하기 위해 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e 연산자의 처리는 두 단계로 나뉩니다. 1단계는 첫 번째 피연산자가 평가된 후, 두 번째 피연산자 이전에 발생합니다. 첫 번째 피연산자가 관련 1단계 메서드를 정의하면, 첫 번째 피연산자를 인자로 호출합니다. 해당 메서드가 두 번째 피연산자가 필요 없이 결과를 결정할 수 있다면, 결과를 반환하고 추가 처리는 건너뜁니다.\u003c/li\u003e\n\u003cli\u003e1단계 메서드가 두 번째 피연산자가 필요하다고 결정하면 특수 값 \u003ccode\u003eNeedOtherOperand\u003c/code\u003e를 반환합니다. 이는 두 번째 피연산자의 평가와 관련 2단계 메서드의 호출을 트리거합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e이항, 2단계 (Binary, phase 2)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__and2__(self, other)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__or2__(self, other)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__rand2__(self, other)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__ror2__(self, other)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e2단계 동안, \u003ccode\u003e__and2__/__rand2__\u003c/code\u003e 및 \u003ccode\u003e__or2__/__ror2__\u003c/code\u003e 메서드 쌍은 다른 이항 연산자와 동일하게 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e어떤 단계에서든 관련 특수 메서드가 발견되지 않거나 \u003ccode\u003eNotImplemented\u003c/code\u003e를 반환하면 기존 의미론으로 폴백(fallback)됩니다.\u003c/p\u003e\n\u003cp\u003e특별한 경우로, 첫 번째 피연산자가 2단계 메서드를 정의했지만 해당 1단계 메서드를 정의하지 않은 경우, 두 번째 피연산자는 항상 평가되고 2단계 메서드가 호출됩니다. 이는 단락 평가 의미론을 원하지 않는 객체가 단순히 2단계 메서드를 구현하고 1단계를 무시할 수 있도록 합니다.\u003c/p\u003e\n\u003ch3\u003e바이트코드 (Bytecodes)\u003c/h3\u003e\n\u003cp\u003e이 패치는 네 가지 새로운 바이트코드인 \u003ccode\u003eLOGICAL_AND_1\u003c/code\u003e, \u003ccode\u003eLOGICAL_AND_2\u003c/code\u003e, \u003ccode\u003eLOGICAL_OR_1\u003c/code\u003e, \u003ccode\u003eLOGICAL_OR_2\u003c/code\u003e를 추가합니다. 예를 들어, \u003ccode\u003eand\u003c/code\u003e 표현식에 대해 생성된 바이트코드는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e. . .\r\nevaluate first operand\r\nLOGICAL_AND_1\r\nL\r\nevaluate second operand\r\nLOGICAL_AND_2\r\nL:\r\n. . .\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLOGICAL_AND_1\u003c/code\u003e 바이트코드는 1단계 처리를 수행합니다. 두 번째 피연산자가 필요하다고 결정하면 첫 번째 피연산자를 스택에 남겨두고 다음 코드를 계속 실행합니다. 그렇지 않으면 첫 번째 피연산자를 팝(pop)하고 결과를 푸시(push)한 다음 \u003ccode\u003eL\u003c/code\u003e로 분기(branch)합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLOGICAL_AND_2\u003c/code\u003e 바이트코드는 2단계 처리를 수행하며, 두 피연산자를 모두 팝하고 결과를 푸시합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e타입 슬롯 (Type Slots)\u003c/h3\u003e\n\u003cp\u003eC 수준에서 새로운 특수 메서드는 타입 객체에 다섯 가지 새로운 슬롯으로 나타납니다. 패치에서는 이들이 \u003ccode\u003etp_as_number\u003c/code\u003e 하위 구조체에 추가되는데, 이는 단항 및 이항 연산자를 다루는 기존 코드를 활용할 수 있도록 하기 위함입니다. 이들의 존재는 새로운 타입 플래그 \u003ccode\u003ePy_TPFLAGS_HAVE_BOOLEAN_OVERLOAD\u003c/code\u003e로 알려집니다.\u003c/p\u003e\n\u003cp\u003e새로운 타입 슬롯은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eunaryfunc nb_logical_not;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunaryfunc nb_logical_and_1;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunaryfunc nb_logical_or_1;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebinaryfunc nb_logical_and_2;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebinaryfunc nb_logical_or_2;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ePython/C API 함수 (Python/C API Functions)\u003c/h3\u003e\n\u003cp\u003e새로운 연산에 해당하는 다섯 가지 새로운 Python/C API 함수도 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyObject *PyObject_LogicalNot(PyObject *);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject *PyObject_LogicalAnd1(PyObject *);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject *PyObject_LogicalOr1(PyObject *);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject *PyObject_LogicalAnd2(PyObject *, PyObject *);\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject *PyObject_LogicalOr2(PyObject *, PyObject *);\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e대안 및 최적화 (Alternatives and Optimisations)\u003c/h2\u003e\n\u003cp\u003e이 섹션에서는 제안의 몇 가지 가능한 변형과 불리언 표현식에 대해 생성된 바이트코드 시퀀스를 최적화하는 방법에 대해 설명하고 있습니다.\u003c/p\u003e\n\u003ch3\u003e특수 메서드 집합 축소 (Reduced special method set)\u003c/h3\u003e\n\u003cp\u003e이 제안의 완전한 버전은 타입이 자체적으로 사용자 정의 단락 평가 동작을 정의할 수 있는 메커니ズム를 포함합니다. 그러나 여기에서 제시된 주요 사용 사례를 해결하는 데 완전한 메커니즘은 필요하지 않으며, 2단계 메서드만 포함하는 간소화된 버전을 정의하는 것도 가능합니다. 그러면 \u003ccode\u003e__and2__\u003c/code\u003e, \u003ccode\u003e__rand2__\u003c/code\u003e, \u003ccode\u003e__or2__\u003c/code\u003e, \u003ccode\u003e__ror2__\u003c/code\u003e, \u003ccode\u003e__not__\u003c/code\u003e의 5가지 새로운 특수 메서드와 3개의 관련 타입 슬롯 및 3개의 API 함수만 존재하게 됩니다.\u003c/p\u003e\n\u003cp\u003e이 간소화된 버전은 나중에 필요하다면 완전한 버전으로 확장될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e추가 바이트코드 (Additional bytecodes)\u003c/h3\u003e\n\u003cp\u003e여기에서 정의된 대로, 불리언 표현식의 결과에 따라 분기하는 코드에 대한 바이트코드 시퀀스는 현재보다 약간 더 길어질 것입니다. 예를 들어, Python 2.7에서 \u003ccode\u003eif a and b:\u003c/code\u003e 구문은 다음과 같은 바이트코드를 생성합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eLOAD_GLOBAL a\r\nPOP_JUMP_IF_FALSE false_branch\r\nLOAD_GLOBAL b\r\nPOP_JUMP_IF_FALSE false_branch\r\n\u0026#x3C;code for statement1\u003e\r\nJUMP_FORWARD end_branch\r\nfalse_branch:\r\n\u0026#x3C;code for statement2\u003e\r\nend_branch:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 제안에 따르면, 이는 다음과 같이 될 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eLOAD_GLOBAL a\r\nLOGICAL_AND_1\r\ntest\r\nLOAD_GLOBAL b\r\nLOGICAL_AND_2\r\ntest:\r\nPOP_JUMP_IF_FALSE false_branch\r\n\u0026#x3C;code for statement1\u003e\r\nJUMP_FORWARD end_branch\r\nfalse_branch:\r\n\u0026#x3C;code for statement2\u003e\r\nend_branch:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 단락 평가의 경우에 하나의 추가 바이트코드를, 비단락 평가의 경우에 두 개의 추가 바이트코드를 실행하는 것을 포함합니다.\u003c/p\u003e\n\u003cp\u003e그러나 논리 연산을 결과 테스트 및 분기와 결합하는 추가 바이트코드를 도입함으로써, 이는 원래와 동일한 수의 바이트코드로 줄어들 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eLOAD_GLOBAL a\r\nAND1_JUMP true_branch, false_branch\r\nLOAD_GLOBAL b\r\nAND2_JUMP_IF_FALSE false_branch\r\ntrue_branch:\r\n\u0026#x3C;code for statement1\u003e\r\nJUMP_FORWARD end_branch\r\nfalse_branch:\r\n\u0026#x3C;code for statement2\u003e\r\nend_branch:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003eAND1_JUMP\u003c/code\u003e는 위에서 설명한 대로 1단계 처리를 수행한 다음 결과를 검사합니다. 결과가 있으면 스택에서 팝되고, 그 진리 값(truth value)이 테스트되어 두 위치 중 하나로 분기됩니다.\u003c/p\u003e\n\u003cp\u003e그렇지 않으면 첫 번째 피연산자가 스택에 남아 있고 실행은 다음 바이트코드로 계속됩니다. \u003ccode\u003eAND2_JUMP_IF_FALSE\u003c/code\u003e 바이트코드는 2단계 처리를 수행하고 결과를 팝한 다음 결과가 거짓으로 테스트되면 분기합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eor\u003c/code\u003e 연산자의 경우, 해당 \u003ccode\u003eOR1_JUMP\u003c/code\u003e 및 \u003ccode\u003eOR2_JUMP_IF_TRUE\u003c/code\u003e 바이트코드가 있을 것입니다.\u003c/p\u003e\n\u003cp\u003e만약 1단계 메서드가 없는 간소화된 버전이 사용된다면, \u003ccode\u003eand\u003c/code\u003e의 경우 첫 번째 피연산자가 거짓일 때만, \u003ccode\u003eor\u003c/code\u003e의 경우 첫 번째 피연산자가 참일 때만 조기 종료가 발생할 수 있습니다. 결과적으로 두 개의 타겟을 갖는 \u003ccode\u003eAND1_JUMP\u003c/code\u003e 및 \u003ccode\u003eOR1_JUMP\u003c/code\u003e 바이트코드는 \u003ccode\u003eAND1_JUMP_IF_FALSE\u003c/code\u003e 및 \u003ccode\u003eOR1_JUMP_IF_TRUE\u003c/code\u003e로 대체될 수 있으며, 이들은 하나의 타겟만 갖는 일반적인 분기 명령입니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003enot\u003c/code\u003e의 최적화 (Optimisation of 'not')\u003c/h3\u003e\n\u003cp\u003e최근 버전의 Python은 부정된 불리언 표현식에 대한 분기를 분기 방향을 뒤집는 방식으로 구현하여 \u003ccode\u003eUNARY_NOT\u003c/code\u003e opcode를 절약하는 간단한 최적화를 구현합니다.\u003c/p\u003e\n\u003cp\u003e엄격하게 보면, \u003ccode\u003enot\u003c/code\u003e 연산자가 일반적인 것과 상당히 다른 결과를 생성하도록 오버라이딩될 수 있으므로 이 최적화는 더 이상 수행되어서는 안 됩니다. 그러나 일반적인 사용 사례에서는 사용자 정의된 불리언 연산을 포함하는 표현식이 분기(branching)에 사용될 것으로 예상되지 않습니다. 결과는 다른 방식으로 사용될 가능성이 훨씬 높습니다.\u003c/p\u003e\n\u003cp\u003e따라서 컴파일러가 불리언 컨텍스트에 직접 나타나는 모든 표현식을 단순화하기 위해 불리언 대수(boolean algebra)의 법칙을 사용하는 것을 허용하도록 지정해도 큰 해는 없을 것입니다. 이것이 불편하다면, 결과를 항상 임시 이름에 먼저 할당할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이렇게 하면 기존의 \u003ccode\u003enot\u003c/code\u003e 최적화가 유지될 수 있으며, 드 모르간의 법칙(De Morgan's laws)을 사용하여 표현식 내에서 더 깊게 확장하는 것과 같은 향후 확장도 가능하게 됩니다.\u003c/p\u003e\n\u003ch2\u003e사용 예시 (Usage Examples)\u003c/h2\u003e\n\u003ch3\u003e예시 1: NumPy 배열 (NumPy Arrays)\u003c/h3\u003e\n\u003cp\u003e이 예시는 \u003ccode\u003eand\u003c/code\u003e, \u003ccode\u003eor\u003c/code\u003e, \u003ccode\u003enot\u003c/code\u003e 연산자를 적용하여 불리언 배열을 생성할 수 있는 NumPy 배열의 하위 클래스를 만듭니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom numpy import array, ndarray\r\n\r\nclass BArray(ndarray):\r\n    def __str__(self):\r\n        return \"barray(%s)\" % ndarray.__str__(self)\r\n\r\n    def __and2__(self, other):\r\n        # 비트와이즈 AND를 사용하여 요소별 AND 연산을 수행합니다.\r\n        # 이 예시에서는 __and2__에 대한 로직이 잘못되어 있습니다.\r\n        # 실제로는 (self \u0026#x26; other)가 아닌, 각 요소에 대한 논리 AND를 구현해야 합니다.\r\n        # PEP 제안의 의도에 따라 재구성하면,\r\n        # (self != 0) \u0026#x26; (other != 0) 과 같은 형태가 될 수 있습니다.\r\n        # 하지만 예시 코드에서는 단순하게 비트와이즈 AND를 사용했습니다.\r\n        # 이는 PEP 335의 목적을 완전히 반영하지 않을 수 있습니다.\r\n        return (self \u0026#x26; other) # 예시에서는 비트와이즈 \u0026#x26;를 사용\r\n\r\n    def __or2__(self, other):\r\n        # 마찬가지로, 이 예시에서는 __or2__에 대한 로직이 잘못되어 있습니다.\r\n        # 실제로는 각 요소에 대한 논리 OR을 구현해야 합니다.\r\n        return (self | other) # 예시에서는 비트와이즈 |를 사용\r\n\r\n    def __not__(self):\r\n        # 각 요소에 대해 논리 NOT 연산을 수행합니다.\r\n        # 0이 아닌 값은 True, 0은 False로 간주하여 반전합니다.\r\n        return (self == 0)\r\n\r\ndef barray(*args, **kwds):\r\n    return array(*args, **kwds).view(type = BArray)\r\n\r\na0 = barray([0, 1, 2, 4])\r\na1 = barray([1, 2, 3, 4])\r\na2 = barray([5, 6, 3, 4])\r\na3 = barray([5, 1, 2, 4])\r\n\r\nprint(\"a0:\", a0)\r\nprint(\"a1:\", a1)\r\nprint(\"a2:\", a2)\r\nprint(\"a3:\", a3)\r\nprint(\"not a0:\", not a0) # __not__ 메서드 호출\r\nprint(\"a0 == a1 and a2 == a3:\", a0 == a1 and a2 == a3) # __and2__ 메서드 호출\r\nprint(\"a0 == a1 or a2 == a3:\", a0 == a1 or a2 == a3)   # __or2__ 메서드 호출\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e예시 1 출력 (Example 1 Output)\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003ea0: barray([0 1 2 4])\r\na1: barray([1 2 3 4])\r\na2: barray([5 6 3 4])\r\na3: barray([5 1 2 4])\r\nnot a0: barray([ True False False False])\r\na0 == a1 and a2 == a3: barray([False False False True])\r\na0 == a1 or a2 == a3: barray([False False False True])\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e예시 2: 데이터베이스 쿼리 (Database Queries)\u003c/h3\u003e\n\u003cp\u003e이 예시는 \u003ccode\u003eand\u003c/code\u003e 및 \u003ccode\u003eor\u003c/code\u003e 연산자를 사용하여 쿼리를 구성할 수 있는 데이터베이스 쿼리용 DSL(Domain Specific Language) 생성을 시연합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass SQLNode(object):\r\n    def __and2__(self, other):\r\n        return SQLBinop(\"and\", self, other)\r\n    def __rand2__(self, other):\r\n        return SQLBinop(\"and\", other, self)\r\n    def __eq__(self, other):\r\n        return SQLBinop(\"=\", self, other)\r\n\r\nclass Table(SQLNode):\r\n    def __init__(self, name):\r\n        self.__tablename__ = name\r\n    def __getattr__(self, name):\r\n        return SQLAttr(self, name)\r\n    def __sql__(self):\r\n        return self.__tablename__\r\n\r\nclass SQLBinop(SQLNode):\r\n    def __init__(self, op, opnd1, opnd2):\r\n        self.op = op.upper()\r\n        self.opnd1 = opnd1\r\n        self.opnd2 = opnd2\r\n    def __sql__(self):\r\n        return \"(%s %s %s)\" % (sql(self.opnd1), self.op, sql(self.opnd2))\r\n\r\nclass SQLAttr(SQLNode):\r\n    def __init__(self, table, name):\r\n        self.table = table\r\n        self.name = name\r\n    def __sql__(self):\r\n        return \"%s.%s\" % (sql(self.table), self.name)\r\n\r\nclass SQLSelect(SQLNode):\r\n    def __init__(self, targets):\r\n        self.targets = targets\r\n        self.where_clause = None\r\n    def where(self, expr):\r\n        self.where_clause = expr\r\n        return self\r\n    def __sql__(self):\r\n        result = \"SELECT %s\" % \", \".join([sql(target) for target in self.targets])\r\n        if self.where_clause:\r\n            result = \"%s WHERE %s\" % (result, sql(self.where_clause))\r\n        return result\r\n\r\ndef sql(expr):\r\n    if isinstance(expr, SQLNode):\r\n        return expr.__sql__()\r\n    elif isinstance(expr, str):\r\n        return \"'%s'\" % expr.replace(\"'\", \"''\")\r\n    else:\r\n        return str(expr)\r\n\r\ndef select(*targets):\r\n    return SQLSelect(targets)\r\n\r\n#-----------------------------------------------------------------\r\ndishes = Table(\"dishes\")\r\ncustomers = Table(\"customers\")\r\norders = Table(\"orders\")\r\n\r\nquery = select(customers.name, dishes.price, orders.amount).where(\r\n    customers.cust_id == orders.cust_id and\r\n    orders.dish_id == dishes.dish_id and\r\n    dishes.name == \"Spam, Eggs, Sausages and Spam\"\r\n)\r\n\r\nprint(repr(query))\r\nprint(sql(query))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e예시 2 출력 (Example 2 Output)\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;__main__.SQLSelect object at 0x1cc830\u003e\r\nSELECT customers.name, dishes.price, orders.amount WHERE (((customers.cust_id = orders.cust_id) AND (orders.dish_id = dishes.dish_id)) AND (dishes.name = 'Spam, Eggs, Sausages and Spam'))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e거부 공지 (Rejection Notice)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 거부되었습니다. 자세한 내용은 다음 링크를 참조하십시오: \u003ca href=\"https://mail.python.org/pipermail/python-dev/2012-March/117510.html\"\u003ehttps://mail.python.org/pipermail/python-dev/2012-March/117510.html\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eThe user wants a Korean translation and summary of PEP 335. I have already browsed the URL and obtained the content. Now I need to process this content according to the guidelines:\r\n\r\n1.  **Professionalism:** Use accurate Python terminology.\r\n2.  **Term Handling:**\r\n    *   Use common Korean terms where available.\r\n    *   For ambiguous or more familiar English terms, use English or 병기 (both English and Korean).\r\n    *   Do NOT translate keywords or variable names in code.\r\n3.  **Readability:** Use Markdown.\r\n4.  **Accuracy:** Translate all original content into Markdown.\r\n\r\nI will go section by section and translate the content, applying the guidelines.\r\n\r\n**Plan:**\r\n- Start with the PEP title and rejection notice.\r\n- Translate Abstract.\r\n- Translate Background.\r\n- Translate Motivation, including the examples and workarounds.\r\n- Translate Rationale.\r\n- Translate Specification, covering Special Methods, Bytecodes, Type Slots, and Python/C API Functions.\r\n- Translate Alternatives and Optimisations, including Reduced special method set, Additional bytecodes, and Optimisation of 'not'.\r\n- Translate Usage Examples, including both NumPy Arrays and Database Queries, with their code and output.\r\n- Conclude with the Copyright notice.\r\n- Ensure all sentences derived from the browsed content have citations `[cite: 1]`.\r\n\r\nLet's start translating.\r\n\r\n---\r\n**Initial thought on specific terms:**\r\n- \"Overloadable Boolean Operators\" -\u003e \"오버로딩 가능한 불리언 연산자\"\r\n- \"Rejected\" -\u003e \"거부됨\" or \"거부(Rejected)\"\r\n- \"Abstract\" -\u003e \"개요\"\r\n- \"Background\" -\u003e \"배경\"\r\n- \"Motivation\" -\u003e \"동기\"\r\n- \"Rationale\" -\u003e \"근거\"\r\n- \"Specification\" -\u003e \"사양\"\r\n- \"Special Methods\" -\u003e \"특수 메서드\"\r\n- \"Bytecodes\" -\u003e \"바이트코드\"\r\n- \"Type Slots\" -\u003e \"타입 슬롯\"\r\n- \"Python/C API Functions\" -\u003e \"Python/C API 함수\"\r\n- \"Alternatives and Optimisations\" -\u003e \"대안 및 최적화\"\r\n- \"Usage Examples\" -\u003e \"사용 예시\"\r\n- \"Short-circuiting semantics\" -\u003e \"단락 평가 의미론\" or \"단락 평가 (short-circuiting semantics)\"\r\n- \"NumPy Arrays\" -\u003e \"NumPy 배열\"\r\n- \"Relational database interface\" -\u003e \"관계형 데이터베이스 인터페이스\"\r\n- \"Bitwise operators\" -\u003e \"비트와이즈 연산자\"\r\n- \"Chained comparisons\" -\u003e \"체인 비교 (chained comparisons)\"\r\n- \"__and1__\", \"__or1__\", \"__and2__\", \"__or2__\", \"__rand2__\", \"__ror2__\", \"__not__\" should remain as is, as they are code/keyword-like.\r\n- `NotImplemented` also remains as is.\r\n- `NeedOtherOperand` also remains as is.\r\n- Bytecode names (`LOGICAL_AND_1`, `LOGICAL_AND_2`, etc.) remain as is.\r\n- C-level type slots (`nb_logical_not`, etc.) remain as is.\r\n- Python/C API functions (`PyObject_LogicalNot`, etc.) remain as is.\r\n- \"Precedence\" -\u003e \"우선순위\"\r\n- \"Domain Specific Language (DSL)\" -\u003e \"DSL (Domain Specific Language)\"\r\n\r\nI will carefully go through the document and apply these.```\r\nThe user wants a Korean translation and summary of PEP 335. I have already browsed the URL and obtained the content. Now I need to process this content according to the guidelines:\r\n\r\n1.  **Professionalism:** Use accurate Python terminology.\r\n2.  **Term Handling:**\r\n    *   Use common Korean terms where available.\r\n    *   For ambiguous or more familiar English terms, use English or 병기 (both English and Korean).\r\n    *   Do NOT translate keywords or variable names in code.\r\n3.  **Readability:** Use Markdown.\r\n4.  **Accuracy:** Translate all original content into Markdown.\r\n\r\nI will go section by section and translate the content, applying the guidelines.\r\n\r\n**Plan:**\r\n- Start with the PEP title and rejection notice.\r\n- Translate Abstract.\r\n- Translate Background.\r\n- Translate Motivation, including the examples and workarounds.\r\n- Translate Rationale.\r\n- Translate Specification, covering Special Methods, Bytecodes, Type Slots, and Python/C API Functions.\r\n- Translate Alternatives and Optimisations, including Reduced special method set, Additional bytecodes, and Optimisation of 'not'.\r\n- Translate Usage Examples, including both NumPy Arrays and Database Queries, with their code and output.\r\n- Conclude with the Copyright notice.\r\n- Ensure all sentences derived from the browsed content have citations `[cite: 1]`.\r\n\r\nLet's start translating.\r\n\r\n---\r\n**Initial thought on specific terms:**\r\n- \"Overloadable Boolean Operators\" -\u003e \"오버로딩 가능한 불리언 연산자\"\r\n- \"Rejected\" -\u003e \"거부됨\" or \"거부(Rejected)\"\r\n- \"Abstract\" -\u003e \"개요\"\r\n- \"Background\" -\u003e \"배경\"\r\n- \"Motivation\" -\u003e \"동기\"\r\n- \"Rationale\" -\u003e \"근거\"\r\n- \"Specification\" -\u003e \"사양\"\r\n- \"Special Methods\" -\u003e \"특수 메서드\"\r\n- \"Bytecodes\" -\u003e \"바이트코드\"\r\n- \"Type Slots\" -\u003e \"타입 슬롯\"\r\n- \"Python/C API Functions\" -\u003e \"Python/C API 함수\"\r\n- \"Alternatives and Optimisations\" -\u003e \"대안 및 최적화\"\r\n- \"Usage Examples\" -\u003e \"사용 예시\"\r\n- \"Short-circuiting semantics\" -\u003e \"단락 평가 의미론\" or \"단락 평가 (short-circuiting semantics)\"\r\n- \"NumPy Arrays\" -\u003e \"NumPy 배열\"\r\n- \"Relational database interface\" -\u003e \"관계형 데이터베이스 인터페이스\"\r\n- \"Bitwise operators\" -\u003e \"비트와이즈 연산자\"\r\n- \"Chained comparisons\" -\u003e \"체인 비교 (chained comparisons)\"\r\n- \"__and1__\", \"__or1__\", \"__and2__\", \"__or2__\", \"__rand2__\", \"__ror2__\", \"__not__\" should remain as is, as they are code/keyword-like.\r\n- `NotImplemented` also remains as is.\r\n- `NeedOtherOperand` also remains as is.\r\n- Bytecode names (`LOGICAL_AND_1`, `LOGICAL_AND_2`, etc.) remain as is.\r\n- C-level type slots (`nb_logical_not`, etc.) remain as is.\r\n- Python/C API functions (`PyObject_LogicalNot`, etc.) remain as is.\r\n- \"Precedence\" -\u003e \"우선순위\"\r\n- \"Domain Specific Language (DSL)\" -\u003e \"DSL (Domain Specific Language)\"\r\n\r\nI will carefully go through the document and apply these.\r\n\r\n\u003e ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\n\u003c/code\u003e\u003c/pre\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1098,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 335 - Overloadable Boolean Operators\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 00:55:17+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>