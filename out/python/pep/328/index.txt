3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-aecaf5ac7a84facf.js","185","static/chunks/app/layout-c3e2e457f12fb6f6.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","931","static/chunks/app/page-e3ea38185bb36cd2.js"],""]
4:["slug","python/pep/328","c"]
0:["x02Anhkwgp1He7ftuyAhh",[[["",{"children":[["slug","python/pep/328","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"328\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/328","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/da5e1dc2b9a7c5bb.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T718b,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0328/">PEP 328 - Imports: Multi-Line and Absolute/Relative</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 21-Dec-2003</p>
</blockquote>
<h1>PEP 328 – 임포트: 여러 줄 및 절대/상대 경로 (Imports: Multi-Line and Absolute/Relative)</h1>
<ul>
<li><strong>작성자:</strong> Aahz</li>
<li><strong>상태:</strong> Final (최종)</li>
<li><strong>유형:</strong> Standards Track (표준 트랙)</li>
<li><strong>생성일:</strong> 2003년 12월 21일</li>
<li><strong>Python 버전:</strong> 2.4, 2.5, 2.6</li>
<li><strong>배포 이력:</strong> 2004년 3월 8일</li>
</ul>
<h2>요약 (Abstract)</h2>
<p><code>import</code> 문에는 두 가지 주요 문제점이 있었습니다:</p>
<ol>
<li><strong>긴 <code>import</code> 문:</strong> 파이썬 스타일 가이드에 맞춰 작성하기 어렵고, 여러 가지 편법을 사용해야 했습니다.</li>
<li><strong>패키지 내 모호성:</strong> 패키지 내부에서 <code>import foo</code>가 해당 패키지 내의 모듈을 참조하는지, 아니면 패키지 외부에 있는 다른 모듈을 참조하는지 명확하지 않았습니다. 즉, 로컬 모듈이나 패키지가 <code>sys.path</code>에 직접 있는 다른 모듈을 가릴 수 있었습니다.</li>
</ol>
<p>첫 번째 문제 해결을 위해, 여러 이름을 괄호로 묶어 파이썬의 표준 여러 줄 값 처리 메커니즘을 <code>import</code> 문에도 적용할 수 있도록 제안되었습니다.</p>
<p>두 번째 문제 해결을 위해, 모든 <code>import</code> 문은 기본적으로 절대 경로(기본적으로 <code>sys.path</code>만 검색)로 처리하고, 패키지 내 상대 경로 임포트를 위한 특별한 구문(선행 점)을 사용하도록 제안되었습니다.</p>
<h2>타임라인 (Timeline)</h2>
<ul>
<li><strong>Python 2.5:</strong> 새로운 절대 경로 임포트 동작을 <code>from __future__ import absolute_import</code>를 통해 활성화할 수 있었습니다. 상대 경로 임포트는 자유롭게 사용할 수 있었습니다.</li>
<li><strong>Python 2.6:</strong> 패키지 내부(intra-package) 임포트로 해석되는 모든 <code>import</code> 문(상대 경로 임포트 구문을 사용하지 않은 <code>from &#x3C;> import</code> 포함)은 <code>DeprecationWarning</code>을 발생시켰습니다.</li>
</ul>
<h2>괄호 사용 근거 (Rationale for Parentheses)</h2>
<p>이전에는 하나의 모듈이나 패키지에서 많은 이름을 임포트해야 할 때 다음과 같은 불편한 선택지 중 하나를 골라야 했습니다:</p>
<ul>
<li>역슬래시(<code>\</code>)를 사용하여 긴 한 줄로 작성하는 방법:
<pre><code class="language-python">from Tkinter import Tk, Frame, Button, Entry, Canvas, Text, \
LEFT, DISABLED, NORMAL, RIDGE, END
</code></pre>
</li>
<li>여러 개의 <code>import</code> 문을 사용하는 방법:
<pre><code class="language-python">from Tkinter import Tk, Frame, Button, Entry, Canvas, Text
from Tkinter import LEFT, DISABLED, NORMAL, RIDGE, END
</code></pre>
(<code>import *</code>는 좋은 선택지가 아닙니다.)</li>
</ul>
<p>대신, 파이썬의 표준 그룹화 메커니즘인 괄호를 사용하여 <code>import</code> 문을 다음과 같이 작성할 수 있도록 제안되었습니다:</p>
<pre><code class="language-python">from Tkinter import (Tk, Frame, Button, Entry, Canvas, Text,
LEFT, DISABLED, NORMAL, RIDGE, END)
</code></pre>
<p>이 제안의 일부는 처음부터 BDFL(Benevolent Dictator For Life, 귀도 반 로섬)의 승인을 받았습니다. 괄호 지원은 Python 2.4에 추가되었습니다.</p>
<h2>절대 경로 임포트 근거 (Rationale for Absolute Imports)</h2>
<p>Python 2.4 및 그 이전 버전에서는 패키지 내부에 있는 모듈을 읽을 때 <code>import foo</code>가 최상위 모듈을 참조하는지 아니면 패키지 내의 다른 모듈을 참조하는지 명확하지 않았습니다. 파이썬 라이브러리가 확장됨에 따라, 점점 더 많은 기존 패키지 내부 모듈이 우연히 표준 라이브러리 모듈을 가리는 문제가 발생했습니다. 특히 패키지 내부에서는 어떤 모듈을 의도하는지 지정할 방법이 없어 어려운 문제였습니다.</p>
<p>이러한 모호성을 해결하기 위해 <code>foo</code>는 항상 <code>sys.path</code>에서 접근 가능한 모듈 또는 패키지로 간주하도록 제안되었습니다. 이를 **절대 경로 임포트 (absolute import)**라고 합니다.</p>
<p><code>python-dev</code> 커뮤니티는 절대 경로 임포트를 기본값으로 선택했습니다. 이는 절대 경로 임포트가 더 일반적인 사용 사례이며, 패키지 계층 구조에서 상위 부분의 이름을 변경하거나 한 패키지를 다른 패키지 안으로 이동할 때 어려움이 따르더라도, 상대 경로(패키지 내부) 임포트의 모든 기능을 제공할 수 있기 때문입니다.</p>
<p>이는 의미론의 변경을 나타내므로, Python 2.5와 2.6에서는 <code>from __future__ import absolute_import</code>를 통해 절대 경로 임포트를 선택적으로 사용할 수 있었습니다. 이 제안의 일부는 처음부터 BDFL의 승인을 받았습니다.</p>
<h2>상대 경로 임포트 근거 (Rationale for Relative Imports)</h2>
<p>절대 경로 임포트로의 전환과 함께, 상대 경로 임포트를 아예 허용해야 하는지에 대한 의문이 제기되었습니다. 몇 가지 사용 사례가 제시되었는데, 그중 가장 중요한 것은 하위 패키지를 수정하지 않고도 대규모 패키지의 구조를 재배치할 수 있어야 한다는 것이었습니다. 또한, 패키지 내부의 모듈은 상대 경로 임포트 없이는 자신을 쉽게 임포트할 수 없었습니다.</p>
<p>귀도 반 로섬은 상대 경로 임포트의 아이디어를 승인했지만, 구문(syntax)에 대해서는 많은 의견 불일치가 있었습니다. 상대 경로 임포트는 특정 이름을 나열하여 임포트해야 한다는 데에는 동의하는 것으로 보였습니다 (즉, <code>import foo</code>와 같은 단순한 형태는 항상 절대 경로 임포트가 됩니다).</p>
<h3>제안되었던 구문들</h3>
<p>여러 구문들이 경쟁했습니다:</p>
<ul>
<li>
<p><strong>귀도의 제안:</strong></p>
<pre><code class="language-python">from .foo import bar
from ...foo import bar
</code></pre>
<p>이 두 가지 형태는 여러 의미론이 제안되었습니다. 각 점이 한 레벨을 나타내는 방식이 있었으나, 점을 세는 것이 어렵다는 불만이 많았습니다. 한 레벨의 상대 경로 임포트만 허용하는 옵션도 있었으나, 많은 기능이 누락되었고, 사람들은 한 점 형태에서도 점이 빠지는 것에 대해 여전히 불평했습니다. 마지막 옵션은 상대 모듈 및 패키지를 찾는 알고리즘을 정의하는 것이었는데, 이에 대한 반대는 "명시적인 것이 암시적인 것보다 낫다 (Explicit is better than implicit)"는 것이었습니다.</p>
</li>
<li>
<p><strong>다른 구분 기호:</strong> "-" 또는 "^"와 같은 다른 구두점을 구분 기호로 사용하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong>"*" 사용:</strong></p>
<pre><code class="language-python">from *.foo import bar
</code></pre>
<p>와 같이 "*"를 사용하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong><code>__pkg__</code> 또는 <code>__parent__</code> 사용:</strong></p>
<pre><code class="language-python">from __pkg__.__pkg__ import
from .__parent__.__parent__ import
</code></pre>
<p>이러한 형태는 많은 사람(귀도 포함)이 보기 흉하다고 생각했지만, 명확하고 명시적이었습니다. 전반적으로 더 짧은 <code>__pkg__</code>를 선호하는 사람이 많았습니다.</p>
</li>
<li>
<p><strong>형제 모듈 참조만 허용:</strong> 현재 디렉토리의 형제 모듈만 참조할 수 있도록 하자는 제안도 있었습니다.</p>
<pre><code class="language-python">from .spam import eggs
import .spam.eggs
</code></pre>
</li>
<li>
<p><strong>인덱스화된 부모 허용:</strong></p>
<pre><code class="language-python">from -2.spam import eggs
</code></pre>
<p>와 같이 인덱스를 사용하여 부모 모듈을 참조하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong><code>import</code> 구문 재작성:</strong> <code>from ... import</code> 대신 완전히 새로운 <code>import</code> 구문을 제안하는 사람들도 있었습니다.</p>
<pre><code class="language-python">from MODULE import NAMES as RENAME searching HOW
import NAMES as RENAME from MODULE searching HOW [from NAMES] [in WHERE] import ...
</code></pre>
<p>그러나 이는 Python 2.5에 구현하기에는 너무 큰 변경이었고, 상대 경로 임포트의 필요성이 매우 중요했기 때문에 즉각적인 해결책이 필요했습니다. 또한, 이 제안된 구문에는 여러 미해결 질문이 있었습니다.</p>
</li>
</ul>
<h2>귀도의 결정 (Guido's Decision)</h2>
<p>귀도는 상대 경로 임포트가 **선행 점(leading dots)**을 사용할 것이라고 선언했습니다.</p>
<ul>
<li><strong>하나의 선행 점 (<code>.</code>):</strong> 현재 패키지에서 시작하는 상대 경로 임포트를 나타냅니다.</li>
<li><strong>두 개 이상의 선행 점 (<code>..</code>, <code>...</code> 등):</strong> 첫 번째 점 이후의 점 하나당 한 레벨씩 현재 패키지의 부모를 가리키는 상대 경로 임포트를 나타냅니다.</li>
</ul>
<h3>예시 패키지 레이아웃:</h3>
<pre><code>package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
        moduleY.py
    subpackage2/
        __init__.py
        moduleZ.py
        moduleA.py
</code></pre>
<p>현재 파일이 <code>moduleX.py</code> 또는 <code>subpackage1/__init__.py</code>라고 가정했을 때, 새로운 구문의 올바른 사용법은 다음과 같습니다:</p>
<pre><code class="language-python">from .moduleY import spam # 현재 패키지(subpackage1) 내 moduleY에서 spam 임포트
from .moduleY import spam as ham # 현재 패키지(subpackage1) 내 moduleY에서 spam을 ham으로 임포트
from . import moduleY # 현재 패키지(subpackage1) 내 moduleY 자체를 임포트

from ..subpackage1 import moduleY # 부모 패키지(package)의 subpackage1에서 moduleY 임포트
from ..subpackage2.moduleZ import eggs # 부모 패키지(package)의 subpackage2 내 moduleZ에서 eggs 임포트
from ..moduleA import foo # 부모 패키지(package)의 moduleA에서 foo 임포트 (이 경우 moduleA는 package/__init__.py와 같은 레벨에 있어야 함)

from ...package import bar # 조부모 패키지(package)의 package에서 bar 임포트 (이는 'package'가 상위 패키지의 하위 모듈이 될 때만 가능)
from ...sys import path # 시스템 모듈인 sys를 임포트하는 예시 (권장되지 않음, "미친 짓"이라고 귀도가 언급함)
</code></pre>
<p><strong>주의:</strong> 마지막 예시는 문법적으로 유효하지만, 권장되지 않습니다 (귀도는 "미친 짓"이라는 표현을 사용했습니다).</p>
<p>상대 경로 임포트는 항상 <code>from &#x3C;> import</code> 형식을 사용해야 합니다. <code>import &#x3C;></code>는 항상 절대 경로 임포트입니다. 물론, 절대 경로 임포트도 선행 점을 생략하여 <code>from &#x3C;> import</code>를 사용할 수 있습니다.</p>
<p><code>import .foo</code>가 금지되는 이유는 <code>import XXX.YYY.ZZZ</code> 이후에는 <code>XXX.YYY.ZZZ</code>를 표현식에서 사용할 수 있지만, <code>.moduleY</code>는 표현식에서 사용할 수 없기 때문입니다.</p>
<h2>상대 경로 임포트와 <code>__name__</code> (Relative Imports and <strong>name</strong>)</h2>
<p>상대 경로 임포트는 모듈의 <code>__name__</code> 속성을 사용하여 패키지 계층 구조 내에서 해당 모듈의 위치를 결정합니다. 만약 모듈의 이름이 패키지 정보를 포함하지 않는 경우 (예: <code>'__main__'</code>으로 설정된 경우), 상대 경로 임포트는 파일 시스템상의 실제 위치와 관계없이 해당 모듈이 최상위 모듈인 것처럼 해석됩니다.</p>
<h2>상대 경로 임포트와 <code>sys.modules</code>의 간접 엔트리 (Relative Imports and Indirection Entries in sys.modules)</h2>
<p>패키지가 도입되었을 때 <code>sys.modules</code>에 간접 엔트리(indirection entry) 개념이 생겨났습니다. 패키지 내 모듈에 대한 <code>sys.modules</code> 엔트리의 값이 <code>None</code>일 때, 이는 해당 모듈이 실제로는 최상위 모듈을 참조한다는 것을 나타냈습니다. 예를 들어, <code>'Sound.Effects.string'</code>이 <code>sys.modules</code>에서 <code>None</code> 값을 가질 수 있었는데, 이는 해당 이름으로 해석되는 모든 임포트가 실제로는 최상위 <code>'string'</code> 모듈을 임포트하는 것을 의미했습니다.</p>
<p>이것은 상대 경로 임포트가 절대 경로 임포트로 해석될 때의 최적화를 도입했지만, 이 PEP는 절대 경로 임포트와 상대 경로 임포트 사이에 매우 명확한 구분을 두기 때문에 이 최적화는 더 이상 필요하지 않습니다. 절대/상대 경로 임포트가 유일한 임포트 의미론이 되면 <code>sys.modules</code>의 간접 엔트리는 더 이상 지원되지 않을 것입니다.</p>
<h2>참조 (References)</h2>
<p>더 많은 배경 정보를 위해 다음 <code>python-dev</code> 스레드를 참고하십시오:</p>
<ul>
<li>
<p>Re: Christmas Wishlist</p>
</li>
<li>
<p>Re: Python-Dev Digest, Vol 5, Issue 57</p>
</li>
<li>
<p>Relative import</p>
</li>
<li>
<p>Another Strategy for Relative Import</p>
</li>
<li>
<p>https://mail.python.org/pipermail/python-dev/2004-March/043739.html</p>
</li>
<li>
<p>https://www.python.org/doc/essays/packages/</p>
</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<hr>
<p>URL: https://peps.python.org/pep-0328/
URL: https://mail.python.org/pipermail/python-dev/2004-March/043739.html
URL: https://www.python.org/doc/essays/packages/Based on the content of PEP 328, I have translated and summarized it for Korean Python developers.
The translation includes explanations of the proposal, its background, and its impact on Python usage, adhering to the specified guidelines for professionalism, terminology, readability, and accuracy.</p>
<hr>
<h1>PEP 328 – 임포트: 여러 줄 및 절대/상대 경로 (Imports: Multi-Line and Absolute/Relative)</h1>
<ul>
<li><strong>작성자:</strong> Aahz</li>
<li><strong>상태:</strong> Final (최종)</li>
<li><strong>유형:</strong> Standards Track (표준 트랙)</li>
<li><strong>생성일:</strong> 2003년 12월 21일</li>
<li><strong>Python 버전:</strong> 2.4, 2.5, 2.6</li>
<li><strong>배포 이력:</strong> 2004년 3월 8일</li>
</ul>
<h2>요약 (Abstract)</h2>
<p><code>import</code> 문에는 두 가지 주요 문제점이 있었습니다:</p>
<ol>
<li><strong>긴 <code>import</code> 문:</strong> 파이썬 스타일 가이드에 맞춰 작성하기 어렵고, 여러 가지 편법을 사용해야 했습니다.</li>
<li><strong>패키지 내 모호성:</strong> 패키지 내부에서 <code>import foo</code>가 해당 패키지 내의 모듈을 참조하는지, 아니면 패키지 외부에 있는 다른 모듈을 참조하는지 명확하지 않았습니다. 즉, 로컬 모듈이나 패키지가 <code>sys.path</code>에 직접 있는 다른 모듈을 가릴 수 있었습니다.</li>
</ol>
<p>첫 번째 문제 해결을 위해, 여러 이름을 괄호로 묶어 파이썬의 표준 여러 줄 값 처리 메커니즘을 <code>import</code> 문에도 적용할 수 있도록 제안되었습니다.</p>
<p>두 번째 문제 해결을 위해, 모든 <code>import</code> 문은 기본적으로 절대 경로(기본적으로 <code>sys.path</code>만 검색)로 처리하고, 패키지 내 상대 경로 임포트를 위한 특별한 구문(선행 점)을 사용하도록 제안되었습니다.</p>
<h2>타임라인 (Timeline)</h2>
<ul>
<li><strong>Python 2.5:</strong> 새로운 절대 경로 임포트 동작을 <code>from __future__ import absolute_import</code>를 통해 활성화할 수 있었습니다. 상대 경로 임포트는 자유롭게 사용할 수 있었습니다.</li>
<li><strong>Python 2.6:</strong> 패키지 내부(intra-package) 임포트로 해석되는 모든 <code>import</code> 문(상대 경로 임포트 구문을 사용하지 않은 <code>from &#x3C;> import</code> 포함)은 <code>DeprecationWarning</code>을 발생시켰습니다.</li>
</ul>
<h2>괄호 사용 근거 (Rationale for Parentheses)</h2>
<p>이전에는 하나의 모듈이나 패키지에서 많은 이름을 임포트해야 할 때 다음과 같은 불편한 선택지 중 하나를 골라야 했습니다:</p>
<ul>
<li>역슬래시(<code>\</code>)를 사용하여 긴 한 줄로 작성하는 방법:
<pre><code class="language-python">from Tkinter import Tk, Frame, Button, Entry, Canvas, Text, \
LEFT, DISABLED, NORMAL, RIDGE, END
</code></pre>
</li>
<li>여러 개의 <code>import</code> 문을 사용하는 방법:
<pre><code class="language-python">from Tkinter import Tk, Frame, Button, Entry, Canvas, Text
from Tkinter import LEFT, DISABLED, NORMAL, RIDGE, END
</code></pre>
(<code>import *</code>는 좋은 선택지가 아닙니다.)</li>
</ul>
<p>대신, 파이썬의 표준 그룹화 메커니즘인 괄호를 사용하여 <code>import</code> 문을 다음과 같이 작성할 수 있도록 제안되었습니다:</p>
<pre><code class="language-python">from Tkinter import (Tk, Frame, Button, Entry, Canvas, Text,
LEFT, DISABLED, NORMAL, RIDGE, END)
</code></pre>
<p>이 제안의 일부는 처음부터 BDFL(Benevolent Dictator For Life, 귀도 반 로섬)의 승인을 받았습니다. 괄호 지원은 Python 2.4에 추가되었습니다.</p>
<h2>절대 경로 임포트 근거 (Rationale for Absolute Imports)</h2>
<p>Python 2.4 및 그 이전 버전에서는 패키지 내부에 있는 모듈을 읽을 때 <code>import foo</code>가 최상위 모듈을 참조하는지 아니면 패키지 내의 다른 모듈을 참조하는지 명확하지 않았습니다. 파이썬 라이브러리가 확장됨에 따라, 점점 더 많은 기존 패키지 내부 모듈이 우연히 표준 라이브러리 모듈을 가리는 문제가 발생했습니다. 특히 패키지 내부에서는 어떤 모듈을 의도하는지 지정할 방법이 없어 어려운 문제였습니다.</p>
<p>이러한 모호성을 해결하기 위해 <code>foo</code>는 항상 <code>sys.path</code>에서 접근 가능한 모듈 또는 패키지로 간주하도록 제안되었습니다. 이를 **절대 경로 임포트 (absolute import)**라고 합니다.</p>
<p><code>python-dev</code> 커뮤니티는 절대 경로 임포트를 기본값으로 선택했습니다. 이는 절대 경로 임포트가 더 일반적인 사용 사례이며, 패키지 계층 구조에서 상위 부분의 이름을 변경하거나 한 패키지를 다른 패키지 안으로 이동할 때 어려움이 따르더라도, 상대 경로(패키지 내부) 임포트의 모든 기능을 제공할 수 있기 때문입니다.</p>
<p>이는 의미론의 변경을 나타내므로, Python 2.5와 2.6에서는 <code>from __future__ import absolute_import</code>를 통해 절대 경로 임포트를 선택적으로 사용할 수 있었습니다. 이 제안의 일부는 처음부터 BDFL의 승인을 받았습니다.</p>
<h2>상대 경로 임포트 근거 (Rationale for Relative Imports)</h2>
<p>절대 경로 임포트로의 전환과 함께, 상대 경로 임포트를 아예 허용해야 하는지에 대한 의문이 제기되었습니다. 몇 가지 사용 사례가 제시되었는데, 그중 가장 중요한 것은 하위 패키지를 수정하지 않고도 대규모 패키지의 구조를 재배치할 수 있어야 한다는 것이었습니다. 또한, 패키지 내부의 모듈은 상대 경로 임포트 없이는 자신을 쉽게 임포트할 수 없었습니다.</p>
<p>귀도 반 로섬은 상대 경로 임포트의 아이디어를 승인했지만, 구문(syntax)에 대해서는 많은 의견 불일치가 있었습니다. 상대 경로 임포트는 특정 이름을 나열하여 임포트해야 한다는 데에는 동의하는 것으로 보였습니다 (즉, <code>import foo</code>와 같은 단순한 형태는 항상 절대 경로 임포트가 됩니다).</p>
<h3>제안되었던 구문들</h3>
<p>여러 구문들이 경쟁했습니다:</p>
<ul>
<li>
<p><strong>귀도의 제안:</strong></p>
<pre><code class="language-python">from .foo import bar
from ...foo import bar
</code></pre>
<p>이 두 가지 형태는 여러 의미론이 제안되었습니다. 각 점이 한 레벨을 나타내는 방식이 있었으나, 점을 세는 것이 어렵다는 불만이 많았습니다. 한 레벨의 상대 경로 임포트만 허용하는 옵션도 있었으나, 많은 기능이 누락되었고, 사람들은 한 점 형태에서도 점이 빠지는 것에 대해 여전히 불평했습니다. 마지막 옵션은 상대 모듈 및 패키지를 찾는 알고리즘을 정의하는 것이었는데, 이에 대한 반대는 "명시적인 것이 암시적인 것보다 낫다 (Explicit is better than implicit)"는 것이었습니다.</p>
</li>
<li>
<p><strong>다른 구분 기호:</strong> "-" 또는 "^"와 같은 다른 구두점을 구분 기호로 사용하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong>"*" 사용:</strong></p>
<pre><code class="language-python">from *.foo import bar
</code></pre>
<p>와 같이 "*"를 사용하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong><code>__pkg__</code> 또는 <code>__parent__</code> 사용:</strong></p>
<pre><code class="language-python">from __pkg__.__pkg__ import
from .__parent__.__parent__ import
</code></pre>
<p>이러한 형태는 많은 사람(귀도 포함)이 보기 흉하다고 생각했지만, 명확하고 명시적이었습니다. 전반적으로 더 짧은 <code>__pkg__</code>를 선호하는 사람이 많았습니다.</p>
</li>
<li>
<p><strong>형제 모듈 참조만 허용:</strong> 현재 디렉토리의 형제 모듈만 참조할 수 있도록 하자는 제안도 있었습니다.</p>
<pre><code class="language-python">from .spam import eggs
import .spam.eggs
</code></pre>
</li>
<li>
<p><strong>인덱스화된 부모 허용:</strong></p>
<pre><code class="language-python">from -2.spam import eggs
</code></pre>
<p>와 같이 인덱스를 사용하여 부모 모듈을 참조하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong><code>import</code> 구문 재작성:</strong> <code>from ... import</code> 대신 완전히 새로운 <code>import</code> 구문을 제안하는 사람들도 있었습니다.</p>
<pre><code class="language-python">from MODULE import NAMES as RENAME searching HOW
import NAMES as RENAME from MODULE searching HOW [from NAMES] [in WHERE] import ...
</code></pre>
<p>그러나 이는 Python 2.5에 구현하기에는 너무 큰 변경이었고, 상대 경로 임포트의 필요성이 매우 중요했기 때문에 즉각적인 해결책이 필요했습니다. 또한, 이 제안된 구문에는 여러 미해결 질문이 있었습니다.</p>
</li>
</ul>
<h2>귀도의 결정 (Guido's Decision)</h2>
<p>귀도는 상대 경로 임포트가 **선행 점(leading dots)**을 사용할 것이라고 선언했습니다.</p>
<ul>
<li><strong>하나의 선행 점 (<code>.</code>):</strong> 현재 패키지에서 시작하는 상대 경로 임포트를 나타냅니다.</li>
<li><strong>두 개 이상의 선행 점 (<code>..</code>, <code>...</code> 등):</strong> 첫 번째 점 이후의 점 하나당 한 레벨씩 현재 패키지의 부모를 가리키는 상대 경로 임포트를 나타냅니다.</li>
</ul>
<h3>예시 패키지 레이아웃:</h3>
<pre><code>package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
        moduleY.py
    subpackage2/
        __init__.py
        moduleZ.py
        moduleA.py
</code></pre>
<p>현재 파일이 <code>moduleX.py</code> 또는 <code>subpackage1/__init__.py</code>라고 가정했을 때, 새로운 구문의 올바른 사용법은 다음과 같습니다:</p>
<pre><code class="language-python">from .moduleY import spam # 현재 패키지(subpackage1) 내 moduleY에서 spam 임포트
from .moduleY import spam as ham # 현재 패키지(subpackage1) 내 moduleY에서 spam을 ham으로 임포트
from . import moduleY # 현재 패키지(subpackage1) 내 moduleY 자체를 임포트

from ..subpackage1 import moduleY # 부모 패키지(package)의 subpackage1에서 moduleY 임포트
from ..subpackage2.moduleZ import eggs # 부모 패키지(package)의 subpackage2 내 moduleZ에서 eggs 임포트
from ..moduleA import foo # 부모 패키지(package)의 moduleA에서 foo 임포트 (이 경우 moduleA는 package/__init__.py와 같은 레벨에 있어야 함)

from ...package import bar # 조부모 패키지(package)의 package에서 bar 임포트 (이는 'package'가 상위 패키지의 하위 모듈이 될 때만 가능)
from ...sys import path # 시스템 모듈인 sys를 임포트하는 예시 (권장되지 않음, "미친 짓"이라고 귀도가 언급함)
</code></pre>
<p><strong>주의:</strong> 마지막 예시는 문법적으로 유효하지만, 권장되지 않습니다 (귀도는 "미친 짓"이라는 표현을 사용했습니다).</p>
<p>상대 경로 임포트는 항상 <code>from &#x3C;> import</code> 형식을 사용해야 합니다. <code>import &#x3C;></code>는 항상 절대 경로 임포트입니다. 물론, 절대 경로 임포트도 선행 점을 생략하여 <code>from &#x3C;> import</code>를 사용할 수 있습니다.</p>
<p><code>import .foo</code>가 금지되는 이유는 <code>import XXX.YYY.ZZZ</code> 이후에는 <code>XXX.YYY.ZZZ</code>를 표현식에서 사용할 수 있지만, <code>.moduleY</code>는 표현식에서 사용할 수 없기 때문입니다.</p>
<h2>상대 경로 임포트와 <code>__name__</code> (Relative Imports and <strong>name</strong>)</h2>
<p>상대 경로 임포트는 모듈의 <code>__name__</code> 속성을 사용하여 패키지 계층 구조 내에서 해당 모듈의 위치를 결정합니다. 만약 모듈의 이름이 패키지 정보를 포함하지 않는 경우 (예: <code>'__main__'</code>으로 설정된 경우), 상대 경로 임포트는 파일 시스템상의 실제 위치와 관계없이 해당 모듈이 최상위 모듈인 것처럼 해석됩니다.</p>
<h2>상대 경로 임포트와 <code>sys.modules</code>의 간접 엔트리 (Relative Imports and Indirection Entries in sys.modules)</h2>
<p>패키지가 도입되었을 때 <code>sys.modules</code>에 간접 엔트리(indirection entry) 개념이 생겨났습니다. 패키지 내 모듈에 대한 <code>sys.modules</code> 엔트리의 값이 <code>None</code>일 때, 이는 해당 모듈이 실제로는 최상위 모듈을 참조한다는 것을 나타냈습니다. 예를 들어, <code>'Sound.Effects.string'</code>이 <code>sys.modules</code>에서 <code>None</code> 값을 가질 수 있었는데, 이는 해당 이름으로 해석되는 모든 임포트가 실제로는 최상위 <code>'string'</code> 모듈을 임포트하는 것을 의미했습니다.</p>
<p>이것은 상대 경로 임포트가 절대 경로 임포트로 해석될 때의 최적화를 도입했지만, 이 PEP는 절대 경로 임포트와 상대 경로 임포트 사이에 매우 명확한 구분을 두기 때문에 이 최적화는 더 이상 필요하지 않습니다. 절대/상대 경로 임포트가 유일한 임포트 의미론이 되면 <code>sys.modules</code>의 간접 엔트리는 더 이상 지원되지 않을 것입니다.</p>
<h2>참조 (References)</h2>
<p>더 많은 배경 정보를 위해 다음 <code>python-dev</code> 스레드를 참고하십시오:</p>
<ul>
<li>
<p>Re: Christmas Wishlist</p>
</li>
<li>
<p>Re: Python-Dev Digest, Vol 5, Issue 57</p>
</li>
<li>
<p>Relative import</p>
</li>
<li>
<p>Another Strategy for Relative Import</p>
</li>
<li>
<p>https://peps.python.org/pep-0328/</p>
</li>
<li>
<p>https://mail.python.org/pipermail/python-dev/2004-March/043739.html</p>
</li>
<li>
<p>https://www.python.org/doc/essays/packages/</p>
</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1025,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 328 - Imports: Multi-Line and Absolute/Relative"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 18:36:33+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}]]
1:null
