<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/773b243a13a00265.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/app/layout-fa159ef0265a0843.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2215<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 328 - Imports: Multi-Line and Absolute/Relative</h1><div class="page__meta"><time dateTime="2025-09-26 18:36:33+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0328/">PEP 328 - Imports: Multi-Line and Absolute/Relative</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 21-Dec-2003</p>
</blockquote>
<h1>PEP 328 – 임포트: 여러 줄 및 절대/상대 경로 (Imports: Multi-Line and Absolute/Relative)</h1>
<ul>
<li><strong>작성자:</strong> Aahz</li>
<li><strong>상태:</strong> Final (최종)</li>
<li><strong>유형:</strong> Standards Track (표준 트랙)</li>
<li><strong>생성일:</strong> 2003년 12월 21일</li>
<li><strong>Python 버전:</strong> 2.4, 2.5, 2.6</li>
<li><strong>배포 이력:</strong> 2004년 3월 8일</li>
</ul>
<h2>요약 (Abstract)</h2>
<p><code>import</code> 문에는 두 가지 주요 문제점이 있었습니다:</p>
<ol>
<li><strong>긴 <code>import</code> 문:</strong> 파이썬 스타일 가이드에 맞춰 작성하기 어렵고, 여러 가지 편법을 사용해야 했습니다.</li>
<li><strong>패키지 내 모호성:</strong> 패키지 내부에서 <code>import foo</code>가 해당 패키지 내의 모듈을 참조하는지, 아니면 패키지 외부에 있는 다른 모듈을 참조하는지 명확하지 않았습니다. 즉, 로컬 모듈이나 패키지가 <code>sys.path</code>에 직접 있는 다른 모듈을 가릴 수 있었습니다.</li>
</ol>
<p>첫 번째 문제 해결을 위해, 여러 이름을 괄호로 묶어 파이썬의 표준 여러 줄 값 처리 메커니즘을 <code>import</code> 문에도 적용할 수 있도록 제안되었습니다.</p>
<p>두 번째 문제 해결을 위해, 모든 <code>import</code> 문은 기본적으로 절대 경로(기본적으로 <code>sys.path</code>만 검색)로 처리하고, 패키지 내 상대 경로 임포트를 위한 특별한 구문(선행 점)을 사용하도록 제안되었습니다.</p>
<h2>타임라인 (Timeline)</h2>
<ul>
<li><strong>Python 2.5:</strong> 새로운 절대 경로 임포트 동작을 <code>from __future__ import absolute_import</code>를 통해 활성화할 수 있었습니다. 상대 경로 임포트는 자유롭게 사용할 수 있었습니다.</li>
<li><strong>Python 2.6:</strong> 패키지 내부(intra-package) 임포트로 해석되는 모든 <code>import</code> 문(상대 경로 임포트 구문을 사용하지 않은 <code>from &#x3C;> import</code> 포함)은 <code>DeprecationWarning</code>을 발생시켰습니다.</li>
</ul>
<h2>괄호 사용 근거 (Rationale for Parentheses)</h2>
<p>이전에는 하나의 모듈이나 패키지에서 많은 이름을 임포트해야 할 때 다음과 같은 불편한 선택지 중 하나를 골라야 했습니다:</p>
<ul>
<li>역슬래시(<code>\</code>)를 사용하여 긴 한 줄로 작성하는 방법:
<pre><code class="language-python">from Tkinter import Tk, Frame, Button, Entry, Canvas, Text, \
LEFT, DISABLED, NORMAL, RIDGE, END
</code></pre>
</li>
<li>여러 개의 <code>import</code> 문을 사용하는 방법:
<pre><code class="language-python">from Tkinter import Tk, Frame, Button, Entry, Canvas, Text
from Tkinter import LEFT, DISABLED, NORMAL, RIDGE, END
</code></pre>
(<code>import *</code>는 좋은 선택지가 아닙니다.)</li>
</ul>
<p>대신, 파이썬의 표준 그룹화 메커니즘인 괄호를 사용하여 <code>import</code> 문을 다음과 같이 작성할 수 있도록 제안되었습니다:</p>
<pre><code class="language-python">from Tkinter import (Tk, Frame, Button, Entry, Canvas, Text,
LEFT, DISABLED, NORMAL, RIDGE, END)
</code></pre>
<p>이 제안의 일부는 처음부터 BDFL(Benevolent Dictator For Life, 귀도 반 로섬)의 승인을 받았습니다. 괄호 지원은 Python 2.4에 추가되었습니다.</p>
<h2>절대 경로 임포트 근거 (Rationale for Absolute Imports)</h2>
<p>Python 2.4 및 그 이전 버전에서는 패키지 내부에 있는 모듈을 읽을 때 <code>import foo</code>가 최상위 모듈을 참조하는지 아니면 패키지 내의 다른 모듈을 참조하는지 명확하지 않았습니다. 파이썬 라이브러리가 확장됨에 따라, 점점 더 많은 기존 패키지 내부 모듈이 우연히 표준 라이브러리 모듈을 가리는 문제가 발생했습니다. 특히 패키지 내부에서는 어떤 모듈을 의도하는지 지정할 방법이 없어 어려운 문제였습니다.</p>
<p>이러한 모호성을 해결하기 위해 <code>foo</code>는 항상 <code>sys.path</code>에서 접근 가능한 모듈 또는 패키지로 간주하도록 제안되었습니다. 이를 <strong>절대 경로 임포트 (absolute import)</strong> 라고 합니다.</p>
<p><code>python-dev</code> 커뮤니티는 절대 경로 임포트를 기본값으로 선택했습니다. 이는 절대 경로 임포트가 더 일반적인 사용 사례이며, 패키지 계층 구조에서 상위 부분의 이름을 변경하거나 한 패키지를 다른 패키지 안으로 이동할 때 어려움이 따르더라도, 상대 경로(패키지 내부) 임포트의 모든 기능을 제공할 수 있기 때문입니다.</p>
<p>이는 의미론의 변경을 나타내므로, Python 2.5와 2.6에서는 <code>from __future__ import absolute_import</code>를 통해 절대 경로 임포트를 선택적으로 사용할 수 있었습니다. 이 제안의 일부는 처음부터 BDFL의 승인을 받았습니다.</p>
<h2>상대 경로 임포트 근거 (Rationale for Relative Imports)</h2>
<p>절대 경로 임포트로의 전환과 함께, 상대 경로 임포트를 아예 허용해야 하는지에 대한 의문이 제기되었습니다. 몇 가지 사용 사례가 제시되었는데, 그중 가장 중요한 것은 하위 패키지를 수정하지 않고도 대규모 패키지의 구조를 재배치할 수 있어야 한다는 것이었습니다. 또한, 패키지 내부의 모듈은 상대 경로 임포트 없이는 자신을 쉽게 임포트할 수 없었습니다.</p>
<p>귀도 반 로섬은 상대 경로 임포트의 아이디어를 승인했지만, 구문(syntax)에 대해서는 많은 의견 불일치가 있었습니다. 상대 경로 임포트는 특정 이름을 나열하여 임포트해야 한다는 데에는 동의하는 것으로 보였습니다 (즉, <code>import foo</code>와 같은 단순한 형태는 항상 절대 경로 임포트가 됩니다).</p>
<h3>제안되었던 구문들</h3>
<p>여러 구문들이 경쟁했습니다:</p>
<ul>
<li>
<p><strong>귀도의 제안:</strong></p>
<pre><code class="language-python">from .foo import bar
from ...foo import bar
</code></pre>
<p>이 두 가지 형태는 여러 의미론이 제안되었습니다. 각 점이 한 레벨을 나타내는 방식이 있었으나, 점을 세는 것이 어렵다는 불만이 많았습니다. 한 레벨의 상대 경로 임포트만 허용하는 옵션도 있었으나, 많은 기능이 누락되었고, 사람들은 한 점 형태에서도 점이 빠지는 것에 대해 여전히 불평했습니다. 마지막 옵션은 상대 모듈 및 패키지를 찾는 알고리즘을 정의하는 것이었는데, 이에 대한 반대는 "명시적인 것이 암시적인 것보다 낫다 (Explicit is better than implicit)"는 것이었습니다.</p>
</li>
<li>
<p><strong>다른 구분 기호:</strong> "-" 또는 "^"와 같은 다른 구두점을 구분 기호로 사용하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong>"*" 사용:</strong></p>
<pre><code class="language-python">from *.foo import bar
</code></pre>
<p>와 같이 "*"를 사용하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong><code>__pkg__</code> 또는 <code>__parent__</code> 사용:</strong></p>
<pre><code class="language-python">from __pkg__.__pkg__ import
from .__parent__.__parent__ import
</code></pre>
<p>이러한 형태는 많은 사람(귀도 포함)이 보기 흉하다고 생각했지만, 명확하고 명시적이었습니다. 전반적으로 더 짧은 <code>__pkg__</code>를 선호하는 사람이 많았습니다.</p>
</li>
<li>
<p><strong>형제 모듈 참조만 허용:</strong> 현재 디렉토리의 형제 모듈만 참조할 수 있도록 하자는 제안도 있었습니다.</p>
<pre><code class="language-python">from .spam import eggs
import .spam.eggs
</code></pre>
</li>
<li>
<p><strong>인덱스화된 부모 허용:</strong></p>
<pre><code class="language-python">from -2.spam import eggs
</code></pre>
<p>와 같이 인덱스를 사용하여 부모 모듈을 참조하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong><code>import</code> 구문 재작성:</strong> <code>from ... import</code> 대신 완전히 새로운 <code>import</code> 구문을 제안하는 사람들도 있었습니다.</p>
<pre><code class="language-python">from MODULE import NAMES as RENAME searching HOW
import NAMES as RENAME from MODULE searching HOW [from NAMES] [in WHERE] import ...
</code></pre>
<p>그러나 이는 Python 2.5에 구현하기에는 너무 큰 변경이었고, 상대 경로 임포트의 필요성이 매우 중요했기 때문에 즉각적인 해결책이 필요했습니다. 또한, 이 제안된 구문에는 여러 미해결 질문이 있었습니다.</p>
</li>
</ul>
<h2>귀도의 결정 (Guido's Decision)</h2>
<p>귀도는 상대 경로 임포트가 <strong>선행 점(leading dots)</strong> 을 사용할 것이라고 선언했습니다.</p>
<ul>
<li><strong>하나의 선행 점 (<code>.</code>):</strong> 현재 패키지에서 시작하는 상대 경로 임포트를 나타냅니다.</li>
<li><strong>두 개 이상의 선행 점 (<code>..</code>, <code>...</code> 등):</strong> 첫 번째 점 이후의 점 하나당 한 레벨씩 현재 패키지의 부모를 가리키는 상대 경로 임포트를 나타냅니다.</li>
</ul>
<h3>예시 패키지 레이아웃:</h3>
<pre><code>package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
        moduleY.py
    subpackage2/
        __init__.py
        moduleZ.py
        moduleA.py
</code></pre>
<p>현재 파일이 <code>moduleX.py</code> 또는 <code>subpackage1/__init__.py</code>라고 가정했을 때, 새로운 구문의 올바른 사용법은 다음과 같습니다:</p>
<pre><code class="language-python">from .moduleY import spam # 현재 패키지(subpackage1) 내 moduleY에서 spam 임포트
from .moduleY import spam as ham # 현재 패키지(subpackage1) 내 moduleY에서 spam을 ham으로 임포트
from . import moduleY # 현재 패키지(subpackage1) 내 moduleY 자체를 임포트

from ..subpackage1 import moduleY # 부모 패키지(package)의 subpackage1에서 moduleY 임포트
from ..subpackage2.moduleZ import eggs # 부모 패키지(package)의 subpackage2 내 moduleZ에서 eggs 임포트
from ..moduleA import foo # 부모 패키지(package)의 moduleA에서 foo 임포트 (이 경우 moduleA는 package/__init__.py와 같은 레벨에 있어야 함)

from ...package import bar # 조부모 패키지(package)의 package에서 bar 임포트 (이는 'package'가 상위 패키지의 하위 모듈이 될 때만 가능)
from ...sys import path # 시스템 모듈인 sys를 임포트하는 예시 (권장되지 않음, "미친 짓"이라고 귀도가 언급함)
</code></pre>
<p><strong>주의:</strong> 마지막 예시는 문법적으로 유효하지만, 권장되지 않습니다 (귀도는 "미친 짓"이라는 표현을 사용했습니다).</p>
<p>상대 경로 임포트는 항상 <code>from &#x3C;> import</code> 형식을 사용해야 합니다. <code>import &#x3C;></code>는 항상 절대 경로 임포트입니다. 물론, 절대 경로 임포트도 선행 점을 생략하여 <code>from &#x3C;> import</code>를 사용할 수 있습니다.</p>
<p><code>import .foo</code>가 금지되는 이유는 <code>import XXX.YYY.ZZZ</code> 이후에는 <code>XXX.YYY.ZZZ</code>를 표현식에서 사용할 수 있지만, <code>.moduleY</code>는 표현식에서 사용할 수 없기 때문입니다.</p>
<h2>상대 경로 임포트와 <code>__name__</code> (Relative Imports and <strong>name</strong>)</h2>
<p>상대 경로 임포트는 모듈의 <code>__name__</code> 속성을 사용하여 패키지 계층 구조 내에서 해당 모듈의 위치를 결정합니다. 만약 모듈의 이름이 패키지 정보를 포함하지 않는 경우 (예: <code>'__main__'</code>으로 설정된 경우), 상대 경로 임포트는 파일 시스템상의 실제 위치와 관계없이 해당 모듈이 최상위 모듈인 것처럼 해석됩니다.</p>
<h2>상대 경로 임포트와 <code>sys.modules</code>의 간접 엔트리 (Relative Imports and Indirection Entries in sys.modules)</h2>
<p>패키지가 도입되었을 때 <code>sys.modules</code>에 간접 엔트리(indirection entry) 개념이 생겨났습니다. 패키지 내 모듈에 대한 <code>sys.modules</code> 엔트리의 값이 <code>None</code>일 때, 이는 해당 모듈이 실제로는 최상위 모듈을 참조한다는 것을 나타냈습니다. 예를 들어, <code>'Sound.Effects.string'</code>이 <code>sys.modules</code>에서 <code>None</code> 값을 가질 수 있었는데, 이는 해당 이름으로 해석되는 모든 임포트가 실제로는 최상위 <code>'string'</code> 모듈을 임포트하는 것을 의미했습니다.</p>
<p>이것은 상대 경로 임포트가 절대 경로 임포트로 해석될 때의 최적화를 도입했지만, 이 PEP는 절대 경로 임포트와 상대 경로 임포트 사이에 매우 명확한 구분을 두기 때문에 이 최적화는 더 이상 필요하지 않습니다. 절대/상대 경로 임포트가 유일한 임포트 의미론이 되면 <code>sys.modules</code>의 간접 엔트리는 더 이상 지원되지 않을 것입니다.</p>
<h2>참조 (References)</h2>
<p>더 많은 배경 정보를 위해 다음 <code>python-dev</code> 스레드를 참고하십시오:</p>
<ul>
<li>
<p>Re: Christmas Wishlist</p>
</li>
<li>
<p>Re: Python-Dev Digest, Vol 5, Issue 57</p>
</li>
<li>
<p>Relative import</p>
</li>
<li>
<p>Another Strategy for Relative Import</p>
</li>
<li>
<p>https://mail.python.org/pipermail/python-dev/2004-March/043739.html</p>
</li>
<li>
<p>https://www.python.org/doc/essays/packages/</p>
</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<hr>
<p>URL: https://peps.python.org/pep-0328/
URL: https://mail.python.org/pipermail/python-dev/2004-March/043739.html
URL: https://www.python.org/doc/essays/packages/Based on the content of PEP 328, I have translated and summarized it for Korean Python developers.
The translation includes explanations of the proposal, its background, and its impact on Python usage, adhering to the specified guidelines for professionalism, terminology, readability, and accuracy.</p>
<hr>
<h1>PEP 328 – 임포트: 여러 줄 및 절대/상대 경로 (Imports: Multi-Line and Absolute/Relative)</h1>
<ul>
<li><strong>작성자:</strong> Aahz</li>
<li><strong>상태:</strong> Final (최종)</li>
<li><strong>유형:</strong> Standards Track (표준 트랙)</li>
<li><strong>생성일:</strong> 2003년 12월 21일</li>
<li><strong>Python 버전:</strong> 2.4, 2.5, 2.6</li>
<li><strong>배포 이력:</strong> 2004년 3월 8일</li>
</ul>
<h2>요약 (Abstract)</h2>
<p><code>import</code> 문에는 두 가지 주요 문제점이 있었습니다:</p>
<ol>
<li><strong>긴 <code>import</code> 문:</strong> 파이썬 스타일 가이드에 맞춰 작성하기 어렵고, 여러 가지 편법을 사용해야 했습니다.</li>
<li><strong>패키지 내 모호성:</strong> 패키지 내부에서 <code>import foo</code>가 해당 패키지 내의 모듈을 참조하는지, 아니면 패키지 외부에 있는 다른 모듈을 참조하는지 명확하지 않았습니다. 즉, 로컬 모듈이나 패키지가 <code>sys.path</code>에 직접 있는 다른 모듈을 가릴 수 있었습니다.</li>
</ol>
<p>첫 번째 문제 해결을 위해, 여러 이름을 괄호로 묶어 파이썬의 표준 여러 줄 값 처리 메커니즘을 <code>import</code> 문에도 적용할 수 있도록 제안되었습니다.</p>
<p>두 번째 문제 해결을 위해, 모든 <code>import</code> 문은 기본적으로 절대 경로(기본적으로 <code>sys.path</code>만 검색)로 처리하고, 패키지 내 상대 경로 임포트를 위한 특별한 구문(선행 점)을 사용하도록 제안되었습니다.</p>
<h2>타임라인 (Timeline)</h2>
<ul>
<li><strong>Python 2.5:</strong> 새로운 절대 경로 임포트 동작을 <code>from __future__ import absolute_import</code>를 통해 활성화할 수 있었습니다. 상대 경로 임포트는 자유롭게 사용할 수 있었습니다.</li>
<li><strong>Python 2.6:</strong> 패키지 내부(intra-package) 임포트로 해석되는 모든 <code>import</code> 문(상대 경로 임포트 구문을 사용하지 않은 <code>from &#x3C;> import</code> 포함)은 <code>DeprecationWarning</code>을 발생시켰습니다.</li>
</ul>
<h2>괄호 사용 근거 (Rationale for Parentheses)</h2>
<p>이전에는 하나의 모듈이나 패키지에서 많은 이름을 임포트해야 할 때 다음과 같은 불편한 선택지 중 하나를 골라야 했습니다:</p>
<ul>
<li>역슬래시(<code>\</code>)를 사용하여 긴 한 줄로 작성하는 방법:
<pre><code class="language-python">from Tkinter import Tk, Frame, Button, Entry, Canvas, Text, \
LEFT, DISABLED, NORMAL, RIDGE, END
</code></pre>
</li>
<li>여러 개의 <code>import</code> 문을 사용하는 방법:
<pre><code class="language-python">from Tkinter import Tk, Frame, Button, Entry, Canvas, Text
from Tkinter import LEFT, DISABLED, NORMAL, RIDGE, END
</code></pre>
(<code>import *</code>는 좋은 선택지가 아닙니다.)</li>
</ul>
<p>대신, 파이썬의 표준 그룹화 메커니즘인 괄호를 사용하여 <code>import</code> 문을 다음과 같이 작성할 수 있도록 제안되었습니다:</p>
<pre><code class="language-python">from Tkinter import (Tk, Frame, Button, Entry, Canvas, Text,
LEFT, DISABLED, NORMAL, RIDGE, END)
</code></pre>
<p>이 제안의 일부는 처음부터 BDFL(Benevolent Dictator For Life, 귀도 반 로섬)의 승인을 받았습니다. 괄호 지원은 Python 2.4에 추가되었습니다.</p>
<h2>절대 경로 임포트 근거 (Rationale for Absolute Imports)</h2>
<p>Python 2.4 및 그 이전 버전에서는 패키지 내부에 있는 모듈을 읽을 때 <code>import foo</code>가 최상위 모듈을 참조하는지 아니면 패키지 내의 다른 모듈을 참조하는지 명확하지 않았습니다. 파이썬 라이브러리가 확장됨에 따라, 점점 더 많은 기존 패키지 내부 모듈이 우연히 표준 라이브러리 모듈을 가리는 문제가 발생했습니다. 특히 패키지 내부에서는 어떤 모듈을 의도하는지 지정할 방법이 없어 어려운 문제였습니다.</p>
<p>이러한 모호성을 해결하기 위해 <code>foo</code>는 항상 <code>sys.path</code>에서 접근 가능한 모듈 또는 패키지로 간주하도록 제안되었습니다. 이를 <strong>절대 경로 임포트 (absolute import)</strong> 라고 합니다.</p>
<p><code>python-dev</code> 커뮤니티는 절대 경로 임포트를 기본값으로 선택했습니다. 이는 절대 경로 임포트가 더 일반적인 사용 사례이며, 패키지 계층 구조에서 상위 부분의 이름을 변경하거나 한 패키지를 다른 패키지 안으로 이동할 때 어려움이 따르더라도, 상대 경로(패키지 내부) 임포트의 모든 기능을 제공할 수 있기 때문입니다.</p>
<p>이는 의미론의 변경을 나타내므로, Python 2.5와 2.6에서는 <code>from __future__ import absolute_import</code>를 통해 절대 경로 임포트를 선택적으로 사용할 수 있었습니다. 이 제안의 일부는 처음부터 BDFL의 승인을 받았습니다.</p>
<h2>상대 경로 임포트 근거 (Rationale for Relative Imports)</h2>
<p>절대 경로 임포트로의 전환과 함께, 상대 경로 임포트를 아예 허용해야 하는지에 대한 의문이 제기되었습니다. 몇 가지 사용 사례가 제시되었는데, 그중 가장 중요한 것은 하위 패키지를 수정하지 않고도 대규모 패키지의 구조를 재배치할 수 있어야 한다는 것이었습니다. 또한, 패키지 내부의 모듈은 상대 경로 임포트 없이는 자신을 쉽게 임포트할 수 없었습니다.</p>
<p>귀도 반 로섬은 상대 경로 임포트의 아이디어를 승인했지만, 구문(syntax)에 대해서는 많은 의견 불일치가 있었습니다. 상대 경로 임포트는 특정 이름을 나열하여 임포트해야 한다는 데에는 동의하는 것으로 보였습니다 (즉, <code>import foo</code>와 같은 단순한 형태는 항상 절대 경로 임포트가 됩니다).</p>
<h3>제안되었던 구문들</h3>
<p>여러 구문들이 경쟁했습니다:</p>
<ul>
<li>
<p><strong>귀도의 제안:</strong></p>
<pre><code class="language-python">from .foo import bar
from ...foo import bar
</code></pre>
<p>이 두 가지 형태는 여러 의미론이 제안되었습니다. 각 점이 한 레벨을 나타내는 방식이 있었으나, 점을 세는 것이 어렵다는 불만이 많았습니다. 한 레벨의 상대 경로 임포트만 허용하는 옵션도 있었으나, 많은 기능이 누락되었고, 사람들은 한 점 형태에서도 점이 빠지는 것에 대해 여전히 불평했습니다. 마지막 옵션은 상대 모듈 및 패키지를 찾는 알고리즘을 정의하는 것이었는데, 이에 대한 반대는 "명시적인 것이 암시적인 것보다 낫다 (Explicit is better than implicit)"는 것이었습니다.</p>
</li>
<li>
<p><strong>다른 구분 기호:</strong> "-" 또는 "^"와 같은 다른 구두점을 구분 기호로 사용하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong>"*" 사용:</strong></p>
<pre><code class="language-python">from *.foo import bar
</code></pre>
<p>와 같이 "*"를 사용하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong><code>__pkg__</code> 또는 <code>__parent__</code> 사용:</strong></p>
<pre><code class="language-python">from __pkg__.__pkg__ import
from .__parent__.__parent__ import
</code></pre>
<p>이러한 형태는 많은 사람(귀도 포함)이 보기 흉하다고 생각했지만, 명확하고 명시적이었습니다. 전반적으로 더 짧은 <code>__pkg__</code>를 선호하는 사람이 많았습니다.</p>
</li>
<li>
<p><strong>형제 모듈 참조만 허용:</strong> 현재 디렉토리의 형제 모듈만 참조할 수 있도록 하자는 제안도 있었습니다.</p>
<pre><code class="language-python">from .spam import eggs
import .spam.eggs
</code></pre>
</li>
<li>
<p><strong>인덱스화된 부모 허용:</strong></p>
<pre><code class="language-python">from -2.spam import eggs
</code></pre>
<p>와 같이 인덱스를 사용하여 부모 모듈을 참조하자는 제안도 있었습니다.</p>
</li>
<li>
<p><strong><code>import</code> 구문 재작성:</strong> <code>from ... import</code> 대신 완전히 새로운 <code>import</code> 구문을 제안하는 사람들도 있었습니다.</p>
<pre><code class="language-python">from MODULE import NAMES as RENAME searching HOW
import NAMES as RENAME from MODULE searching HOW [from NAMES] [in WHERE] import ...
</code></pre>
<p>그러나 이는 Python 2.5에 구현하기에는 너무 큰 변경이었고, 상대 경로 임포트의 필요성이 매우 중요했기 때문에 즉각적인 해결책이 필요했습니다. 또한, 이 제안된 구문에는 여러 미해결 질문이 있었습니다.</p>
</li>
</ul>
<h2>귀도의 결정 (Guido's Decision)</h2>
<p>귀도는 상대 경로 임포트가 <strong>선행 점(leading dots)</strong> 을 사용할 것이라고 선언했습니다.</p>
<ul>
<li><strong>하나의 선행 점 (<code>.</code>):</strong> 현재 패키지에서 시작하는 상대 경로 임포트를 나타냅니다.</li>
<li><strong>두 개 이상의 선행 점 (<code>..</code>, <code>...</code> 등):</strong> 첫 번째 점 이후의 점 하나당 한 레벨씩 현재 패키지의 부모를 가리키는 상대 경로 임포트를 나타냅니다.</li>
</ul>
<h3>예시 패키지 레이아웃:</h3>
<pre><code>package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
        moduleY.py
    subpackage2/
        __init__.py
        moduleZ.py
        moduleA.py
</code></pre>
<p>현재 파일이 <code>moduleX.py</code> 또는 <code>subpackage1/__init__.py</code>라고 가정했을 때, 새로운 구문의 올바른 사용법은 다음과 같습니다:</p>
<pre><code class="language-python">from .moduleY import spam # 현재 패키지(subpackage1) 내 moduleY에서 spam 임포트
from .moduleY import spam as ham # 현재 패키지(subpackage1) 내 moduleY에서 spam을 ham으로 임포트
from . import moduleY # 현재 패키지(subpackage1) 내 moduleY 자체를 임포트

from ..subpackage1 import moduleY # 부모 패키지(package)의 subpackage1에서 moduleY 임포트
from ..subpackage2.moduleZ import eggs # 부모 패키지(package)의 subpackage2 내 moduleZ에서 eggs 임포트
from ..moduleA import foo # 부모 패키지(package)의 moduleA에서 foo 임포트 (이 경우 moduleA는 package/__init__.py와 같은 레벨에 있어야 함)

from ...package import bar # 조부모 패키지(package)의 package에서 bar 임포트 (이는 'package'가 상위 패키지의 하위 모듈이 될 때만 가능)
from ...sys import path # 시스템 모듈인 sys를 임포트하는 예시 (권장되지 않음, "미친 짓"이라고 귀도가 언급함)
</code></pre>
<p><strong>주의:</strong> 마지막 예시는 문법적으로 유효하지만, 권장되지 않습니다 (귀도는 "미친 짓"이라는 표현을 사용했습니다).</p>
<p>상대 경로 임포트는 항상 <code>from &#x3C;> import</code> 형식을 사용해야 합니다. <code>import &#x3C;></code>는 항상 절대 경로 임포트입니다. 물론, 절대 경로 임포트도 선행 점을 생략하여 <code>from &#x3C;> import</code>를 사용할 수 있습니다.</p>
<p><code>import .foo</code>가 금지되는 이유는 <code>import XXX.YYY.ZZZ</code> 이후에는 <code>XXX.YYY.ZZZ</code>를 표현식에서 사용할 수 있지만, <code>.moduleY</code>는 표현식에서 사용할 수 없기 때문입니다.</p>
<h2>상대 경로 임포트와 <code>__name__</code> (Relative Imports and <strong>name</strong>)</h2>
<p>상대 경로 임포트는 모듈의 <code>__name__</code> 속성을 사용하여 패키지 계층 구조 내에서 해당 모듈의 위치를 결정합니다. 만약 모듈의 이름이 패키지 정보를 포함하지 않는 경우 (예: <code>'__main__'</code>으로 설정된 경우), 상대 경로 임포트는 파일 시스템상의 실제 위치와 관계없이 해당 모듈이 최상위 모듈인 것처럼 해석됩니다.</p>
<h2>상대 경로 임포트와 <code>sys.modules</code>의 간접 엔트리 (Relative Imports and Indirection Entries in sys.modules)</h2>
<p>패키지가 도입되었을 때 <code>sys.modules</code>에 간접 엔트리(indirection entry) 개념이 생겨났습니다. 패키지 내 모듈에 대한 <code>sys.modules</code> 엔트리의 값이 <code>None</code>일 때, 이는 해당 모듈이 실제로는 최상위 모듈을 참조한다는 것을 나타냈습니다. 예를 들어, <code>'Sound.Effects.string'</code>이 <code>sys.modules</code>에서 <code>None</code> 값을 가질 수 있었는데, 이는 해당 이름으로 해석되는 모든 임포트가 실제로는 최상위 <code>'string'</code> 모듈을 임포트하는 것을 의미했습니다.</p>
<p>이것은 상대 경로 임포트가 절대 경로 임포트로 해석될 때의 최적화를 도입했지만, 이 PEP는 절대 경로 임포트와 상대 경로 임포트 사이에 매우 명확한 구분을 두기 때문에 이 최적화는 더 이상 필요하지 않습니다. 절대/상대 경로 임포트가 유일한 임포트 의미론이 되면 <code>sys.modules</code>의 간접 엔트리는 더 이상 지원되지 않을 것입니다.</p>
<h2>참조 (References)</h2>
<p>더 많은 배경 정보를 위해 다음 <code>python-dev</code> 스레드를 참고하십시오:</p>
<ul>
<li>
<p>Re: Christmas Wishlist</p>
</li>
<li>
<p>Re: Python-Dev Digest, Vol 5, Issue 57</p>
</li>
<li>
<p>Relative import</p>
</li>
<li>
<p>Another Strategy for Relative Import</p>
</li>
<li>
<p>https://peps.python.org/pep-0328/</p>
</li>
<li>
<p>https://mail.python.org/pipermail/python-dev/2004-March/043739.html</p>
</li>
<li>
<p>https://www.python.org/doc/essays/packages/</p>
</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/327/">[Final] PEP 327 - Decimal Data Type</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 328 - Imports: Multi-Line and Absolute/Relative</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/330/">[Rejected] PEP 330 - Python Bytecode Verification</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/773b243a13a00265.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"185\",\"static/chunks/app/layout-fa159ef0265a0843.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/328\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/773b243a13a00265.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"q5uHuVDyt3FPCtp0uxl7W\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/328/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/328\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"328\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/328\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"default\"]\ne:T718e,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0328/\"\u003ePEP 328 - Imports: Multi-Line and Absolute/Relative\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 21-Dec-2003\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 328 – 임포트: 여러 줄 및 절대/상대 경로 (Imports: Multi-Line and Absolute/Relative)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Aahz\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final (최종)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track (표준 트랙)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2003년 12월 21일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 2.4, 2.5, 2.6\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e배포 이력:\u003c/strong\u003e 2004년 3월 8일\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eimport\u003c/code\u003e 문에는 두 가지 주요 문제점이 있었습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e긴 \u003ccode\u003eimport\u003c/code\u003e 문:\u003c/strong\u003e 파이썬 스타일 가이드에 맞춰 작성하기 어렵고, 여러 가지 편법을 사용해야 했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e패키지 내 모호성:\u003c/strong\u003e 패키지 내부에서 \u003ccode\u003eimport foo\u003c/code\u003e가 해당 패키지 내의 모듈을 참조하는지, 아니면 패키지 외부에 있는 다른 모듈을 참조하는지 명확하지 않았습니다. 즉, 로컬 모듈이나 패키지가 \u003ccode\u003esys.path\u003c/code\u003e에 직접 있는 다른 모듈을 가릴 수 있었습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e첫 번째 문제 해결을 위해, 여러 이름을 괄호로 묶어 파이썬의 표준 여러 줄 값 처리 메커니즘을 \u003ccode\u003eimport\u003c/code\u003e 문에도 적용할 수 있도록 제안되었습니다.\u003c/p\u003e\n\u003cp\u003e두 번째 문제 해결을 위해, 모든 \u003ccode\u003eimport\u003c/code\u003e 문은 기본적으로 절대 경로(기본적으로 \u003ccode\u003esys.path\u003c/code\u003e만 검색)로 처리하고, 패키지 내 상대 경로 임포트를 위한 특별한 구문(선행 점)을 사용하도록 제안되었습니다.\u003c/p\u003e\n\u003ch2\u003e타임라인 (Timeline)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePython 2.5:\u003c/strong\u003e 새로운 절대 경로 임포트 동작을 \u003ccode\u003efrom __future__ import absolute_import\u003c/code\u003e를 통해 활성화할 수 있었습니다. 상대 경로 임포트는 자유롭게 사용할 수 있었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 2.6:\u003c/strong\u003e 패키지 내부(intra-package) 임포트로 해석되는 모든 \u003ccode\u003eimport\u003c/code\u003e 문(상대 경로 임포트 구문을 사용하지 않은 \u003ccode\u003efrom \u0026#x3C;\u003e import\u003c/code\u003e 포함)은 \u003ccode\u003eDeprecationWarning\u003c/code\u003e을 발생시켰습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e괄호 사용 근거 (Rationale for Parentheses)\u003c/h2\u003e\n\u003cp\u003e이전에는 하나의 모듈이나 패키지에서 많은 이름을 임포트해야 할 때 다음과 같은 불편한 선택지 중 하나를 골라야 했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e역슬래시(\u003ccode\u003e\\\u003c/code\u003e)를 사용하여 긴 한 줄로 작성하는 방법:\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom Tkinter import Tk, Frame, Button, Entry, Canvas, Text, \\\nLEFT, DISABLED, NORMAL, RIDGE, END\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e여러 개의 \u003ccode\u003eimport\u003c/code\u003e 문을 사용하는 방법:\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom Tkinter import Tk, Frame, Button, Entry, Canvas, Text\nfrom Tkinter import LEFT, DISABLED, NORMAL, RIDGE, END\n\u003c/code\u003e\u003c/pre\u003e\n(\u003ccode\u003eimport *\u003c/code\u003e는 좋은 선택지가 아닙니다.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e대신, 파이썬의 표준 그룹화 메커니즘인 괄호를 사용하여 \u003ccode\u003eimport\u003c/code\u003e 문을 다음과 같이 작성할 수 있도록 제안되었습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom Tkinter import (Tk, Frame, Button, Entry, Canvas, Text,\nLEFT, DISABLED, NORMAL, RIDGE, END)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 제안의 일부는 처음부터 BDFL(Benevolent Dictator For Life, 귀도 반 로섬)의 승인을 받았습니다. 괄호 지원은 Python 2.4에 추가되었습니다.\u003c/p\u003e\n\u003ch2\u003e절대 경로 임포트 근거 (Rationale for Absolute Imports)\u003c/h2\u003e\n\u003cp\u003ePython 2.4 및 그 이전 버전에서는 패키지 내부에 있는 모듈을 읽을 때 \u003ccode\u003eimport foo\u003c/code\u003e가 최상위 모듈을 참조하는지 아니면 패키지 내의 다른 모듈을 참조하는지 명확하지 않았습니다. 파이썬 라이브러리가 확장됨에 따라, 점점 더 많은 기존 패키지 내부 모듈이 우연히 표준 라이브러리 모듈을 가리는 문제가 발생했습니다. 특히 패키지 내부에서는 어떤 모듈을 의도하는지 지정할 방법이 없어 어려운 문제였습니다.\u003c/p\u003e\n\u003cp\u003e이러한 모호성을 해결하기 위해 \u003ccode\u003efoo\u003c/code\u003e는 항상 \u003ccode\u003esys.path\u003c/code\u003e에서 접근 가능한 모듈 또는 패키지로 간주하도록 제안되었습니다. 이를 \u003cstrong\u003e절대 경로 임포트 (absolute import)\u003c/strong\u003e 라고 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epython-dev\u003c/code\u003e 커뮤니티는 절대 경로 임포트를 기본값으로 선택했습니다. 이는 절대 경로 임포트가 더 일반적인 사용 사례이며, 패키지 계층 구조에서 상위 부분의 이름을 변경하거나 한 패키지를 다른 패키지 안으로 이동할 때 어려움이 따르더라도, 상대 경로(패키지 내부) 임포트의 모든 기능을 제공할 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이는 의미론의 변경을 나타내므로, Python 2.5와 2.6에서는 \u003ccode\u003efrom __future__ import absolute_import\u003c/code\u003e를 통해 절대 경로 임포트를 선택적으로 사용할 수 있었습니다. 이 제안의 일부는 처음부터 BDFL의 승인을 받았습니다.\u003c/p\u003e\n\u003ch2\u003e상대 경로 임포트 근거 (Rationale for Relative Imports)\u003c/h2\u003e\n\u003cp\u003e절대 경로 임포트로의 전환과 함께, 상대 경로 임포트를 아예 허용해야 하는지에 대한 의문이 제기되었습니다. 몇 가지 사용 사례가 제시되었는데, 그중 가장 중요한 것은 하위 패키지를 수정하지 않고도 대규모 패키지의 구조를 재배치할 수 있어야 한다는 것이었습니다. 또한, 패키지 내부의 모듈은 상대 경로 임포트 없이는 자신을 쉽게 임포트할 수 없었습니다.\u003c/p\u003e\n\u003cp\u003e귀도 반 로섬은 상대 경로 임포트의 아이디어를 승인했지만, 구문(syntax)에 대해서는 많은 의견 불일치가 있었습니다. 상대 경로 임포트는 특정 이름을 나열하여 임포트해야 한다는 데에는 동의하는 것으로 보였습니다 (즉, \u003ccode\u003eimport foo\u003c/code\u003e와 같은 단순한 형태는 항상 절대 경로 임포트가 됩니다).\u003c/p\u003e\n\u003ch3\u003e제안되었던 구문들\u003c/h3\u003e\n\u003cp\u003e여러 구문들이 경쟁했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e귀도의 제안:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom .foo import bar\nfrom ...foo import bar\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 두 가지 형태는 여러 의미론이 제안되었습니다. 각 점이 한 레벨을 나타내는 방식이 있었으나, 점을 세는 것이 어렵다는 불만이 많았습니다. 한 레벨의 상대 경로 임포트만 허용하는 옵션도 있었으나, 많은 기능이 누락되었고, 사람들은 한 점 형태에서도 점이 빠지는 것에 대해 여전히 불평했습니다. 마지막 옵션은 상대 모듈 및 패키지를 찾는 알고리즘을 정의하는 것이었는데, 이에 대한 반대는 \"명시적인 것이 암시적인 것보다 낫다 (Explicit is better than implicit)\"는 것이었습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e다른 구분 기호:\u003c/strong\u003e \"-\" 또는 \"^\"와 같은 다른 구두점을 구분 기호로 사용하자는 제안도 있었습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\"*\" 사용:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom *.foo import bar\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e와 같이 \"*\"를 사용하자는 제안도 있었습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e__pkg__\u003c/code\u003e 또는 \u003ccode\u003e__parent__\u003c/code\u003e 사용:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom __pkg__.__pkg__ import\nfrom .__parent__.__parent__ import\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 형태는 많은 사람(귀도 포함)이 보기 흉하다고 생각했지만, 명확하고 명시적이었습니다. 전반적으로 더 짧은 \u003ccode\u003e__pkg__\u003c/code\u003e를 선호하는 사람이 많았습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e형제 모듈 참조만 허용:\u003c/strong\u003e 현재 디렉토리의 형제 모듈만 참조할 수 있도록 하자는 제안도 있었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom .spam import eggs\nimport .spam.eggs\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e인덱스화된 부모 허용:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom -2.spam import eggs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e와 같이 인덱스를 사용하여 부모 모듈을 참조하자는 제안도 있었습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eimport\u003c/code\u003e 구문 재작성:\u003c/strong\u003e \u003ccode\u003efrom ... import\u003c/code\u003e 대신 완전히 새로운 \u003ccode\u003eimport\u003c/code\u003e 구문을 제안하는 사람들도 있었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom MODULE import NAMES as RENAME searching HOW\nimport NAMES as RENAME from MODULE searching HOW [from NAMES] [in WHERE] import ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 이는 Python 2.5에 구현하기에는 너무 큰 변경이었고, 상대 경로 임포트의 필요성이 매우 중요했기 때문에 즉각적인 해결책이 필요했습니다. 또한, 이 제안된 구문에는 여러 미해결 질문이 있었습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e귀도의 결정 (Guido's Decision)\u003c/h2\u003e\n\u003cp\u003e귀도는 상대 경로 임포트가 \u003cstrong\u003e선행 점(leading dots)\u003c/strong\u003e 을 사용할 것이라고 선언했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e하나의 선행 점 (\u003ccode\u003e.\u003c/code\u003e):\u003c/strong\u003e 현재 패키지에서 시작하는 상대 경로 임포트를 나타냅니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e두 개 이상의 선행 점 (\u003ccode\u003e..\u003c/code\u003e, \u003ccode\u003e...\u003c/code\u003e 등):\u003c/strong\u003e 첫 번째 점 이후의 점 하나당 한 레벨씩 현재 패키지의 부모를 가리키는 상대 경로 임포트를 나타냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e예시 패키지 레이아웃:\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003epackage/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n        moduleY.py\n    subpackage2/\n        __init__.py\n        moduleZ.py\n        moduleA.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 파일이 \u003ccode\u003emoduleX.py\u003c/code\u003e 또는 \u003ccode\u003esubpackage1/__init__.py\u003c/code\u003e라고 가정했을 때, 새로운 구문의 올바른 사용법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom .moduleY import spam # 현재 패키지(subpackage1) 내 moduleY에서 spam 임포트\nfrom .moduleY import spam as ham # 현재 패키지(subpackage1) 내 moduleY에서 spam을 ham으로 임포트\nfrom . import moduleY # 현재 패키지(subpackage1) 내 moduleY 자체를 임포트\n\nfrom ..subpackage1 import moduleY # 부모 패키지(package)의 subpackage1에서 moduleY 임포트\nfrom ..subpackage2.moduleZ import eggs # 부모 패키지(package)의 subpackage2 내 moduleZ에서 eggs 임포트\nfrom ..moduleA import foo # 부모 패키지(package)의 moduleA에서 foo 임포트 (이 경우 moduleA는 package/__init__.py와 같은 레벨에 있어야 함)\n\nfrom ...package import bar # 조부모 패키지(package)의 package에서 bar 임포트 (이는 'package'가 상위 패키지의 하위 모듈이 될 때만 가능)\nfrom ...sys import path # 시스템 모듈인 sys를 임포트하는 예시 (권장되지 않음, \"미친 짓\"이라고 귀도가 언급함)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e주의:\u003c/strong\u003e 마지막 예시는 문법적으로 유효하지만, 권장되지 않습니다 (귀도는 \"미친 짓\"이라는 표현을 사용했습니다).\u003c/p\u003e\n\u003cp\u003e상대 경로 임포트는 항상 \u003ccode\u003efrom \u0026#x3C;\u003e import\u003c/code\u003e 형식을 사용해야 합니다. \u003ccode\u003eimport \u0026#x3C;\u003e\u003c/code\u003e는 항상 절대 경로 임포트입니다. 물론, 절대 경로 임포트도 선행 점을 생략하여 \u003ccode\u003efrom \u0026#x3C;\u003e import\u003c/code\u003e를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimport .foo\u003c/code\u003e가 금지되는 이유는 \u003ccode\u003eimport XXX.YYY.ZZZ\u003c/code\u003e 이후에는 \u003ccode\u003eXXX.YYY.ZZZ\u003c/code\u003e를 표현식에서 사용할 수 있지만, \u003ccode\u003e.moduleY\u003c/code\u003e는 표현식에서 사용할 수 없기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e상대 경로 임포트와 \u003ccode\u003e__name__\u003c/code\u003e (Relative Imports and \u003cstrong\u003ename\u003c/strong\u003e)\u003c/h2\u003e\n\u003cp\u003e상대 경로 임포트는 모듈의 \u003ccode\u003e__name__\u003c/code\u003e 속성을 사용하여 패키지 계층 구조 내에서 해당 모듈의 위치를 결정합니다. 만약 모듈의 이름이 패키지 정보를 포함하지 않는 경우 (예: \u003ccode\u003e'__main__'\u003c/code\u003e으로 설정된 경우), 상대 경로 임포트는 파일 시스템상의 실제 위치와 관계없이 해당 모듈이 최상위 모듈인 것처럼 해석됩니다.\u003c/p\u003e\n\u003ch2\u003e상대 경로 임포트와 \u003ccode\u003esys.modules\u003c/code\u003e의 간접 엔트리 (Relative Imports and Indirection Entries in sys.modules)\u003c/h2\u003e\n\u003cp\u003e패키지가 도입되었을 때 \u003ccode\u003esys.modules\u003c/code\u003e에 간접 엔트리(indirection entry) 개념이 생겨났습니다. 패키지 내 모듈에 대한 \u003ccode\u003esys.modules\u003c/code\u003e 엔트리의 값이 \u003ccode\u003eNone\u003c/code\u003e일 때, 이는 해당 모듈이 실제로는 최상위 모듈을 참조한다는 것을 나타냈습니다. 예를 들어, \u003ccode\u003e'Sound.Effects.string'\u003c/code\u003e이 \u003ccode\u003esys.modules\u003c/code\u003e에서 \u003ccode\u003eNone\u003c/code\u003e 값을 가질 수 있었는데, 이는 해당 이름으로 해석되는 모든 임포트가 실제로는 최상위 \u003ccode\u003e'string'\u003c/code\u003e 모듈을 임포트하는 것을 의미했습니다.\u003c/p\u003e\n\u003cp\u003e이것은 상대 경로 임포트가 절대 경로 임포트로 해석될 때의 최적화를 도입했지만, 이 PEP는 절대 경로 임포트와 상대 경로 임포트 사이에 매우 명확한 구분을 두기 때문에 이 최적화는 더 이상 필요하지 않습니다. 절대/상대 경로 임포트가 유일한 임포트 의미론이 되면 \u003ccode\u003esys.modules\u003c/code\u003e의 간접 엔트리는 더 이상 지원되지 않을 것입니다.\u003c/p\u003e\n\u003ch2\u003e참조 (References)\u003c/h2\u003e\n\u003cp\u003e더 많은 배경 정보를 위해 다음 \u003ccode\u003epython-dev\u003c/code\u003e 스레드를 참고하십시오:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eRe: Christmas Wishlist\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRe: Python-Dev Digest, Vol 5, Issue 57\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRelative import\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAnother Strategy for Relative Import\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ehttps://mail.python.org/pipermail/python-dev/2004-March/043739.html\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ehttps://www.python.org/doc/essays/packages/\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eURL: https://peps.python.org/pep-0328/\nURL: https://mail.python.org/pipermail/python-dev/2004-March/043739.html\nURL: https://www.python.org/doc/essays/packages/Based on the content of PEP 328, I have translated and summarized it for Korean Python developers.\nThe translation includes explanations of the proposal, its background, and its impact on Python usage, adhering to the specified guidelines for professionalism, terminology, readability, and accuracy.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1\u003ePEP 328 – 임포트: 여러 줄 및 절대/상대 경로 (Imports: Multi-Line and Absolute/Relative)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Aahz\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final (최종)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track (표준 트랙)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2003년 12월 21일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 2.4, 2.5, 2.6\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e배포 이력:\u003c/strong\u003e 2004년 3월 8일\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eimport\u003c/code\u003e 문에는 두 가지 주요 문제점이 있었습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e긴 \u003ccode\u003eimport\u003c/code\u003e 문:\u003c/strong\u003e 파이썬 스타일 가이드에 맞춰 작성하기 어렵고, 여러 가지 편법을 사용해야 했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e패키지 내 모호성:\u003c/strong\u003e 패키지 내부에서 \u003ccode\u003eimport foo\u003c/code\u003e가 해당 패키지 내의 모듈을 참조하는지, 아니면 패키지 외부에 있는 다른 모듈을 참조하는지 명확하지 않았습니다. 즉, 로컬 모듈이나 패키지가 \u003ccode\u003esys.path\u003c/code\u003e에 직접 있는 다른 모듈을 가릴 수 있었습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e첫 번째 문제 해결을 위해, 여러 이름을 괄호로 묶어 파이썬의 표준 여러 줄 값 처리 메커니즘을 \u003ccode\u003eimport\u003c/code\u003e 문에도 적용할 수 있도록 제안되었습니다.\u003c/p\u003e\n\u003cp\u003e두 번째 문제 해결을 위해, 모든 \u003ccode\u003eimport\u003c/code\u003e 문은 기본적으로 절대 경로(기본적으로 \u003ccode\u003esys.path\u003c/code\u003e만 검색)로 처리하고, 패키지 내 상대 경로 임포트를 위한 특별한 구문(선행 점)을 사용하도록 제안되었습니다.\u003c/p\u003e\n\u003ch2\u003e타임라인 (Timeline)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePython 2.5:\u003c/strong\u003e 새로운 절대 경로 임포트 동작을 \u003ccode\u003efrom __future__ import absolute_import\u003c/code\u003e를 통해 활성화할 수 있었습니다. 상대 경로 임포트는 자유롭게 사용할 수 있었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 2.6:\u003c/strong\u003e 패키지 내부(intra-package) 임포트로 해석되는 모든 \u003ccode\u003eimport\u003c/code\u003e 문(상대 경로 임포트 구문을 사용하지 않은 \u003ccode\u003efrom \u0026#x3C;\u003e import\u003c/code\u003e 포함)은 \u003ccode\u003eDeprecationWarning\u003c/code\u003e을 발생시켰습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e괄호 사용 근거 (Rationale for Parentheses)\u003c/h2\u003e\n\u003cp\u003e이전에는 하나의 모듈이나 패키지에서 많은 이름을 임포트해야 할 때 다음과 같은 불편한 선택지 중 하나를 골라야 했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e역슬래시(\u003ccode\u003e\\\u003c/code\u003e)를 사용하여 긴 한 줄로 작성하는 방법:\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom Tkinter import Tk, Frame, Button, Entry, Canvas, Text, \\\nLEFT, DISABLED, NORMAL, RIDGE, END\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e여러 개의 \u003ccode\u003eimport\u003c/code\u003e 문을 사용하는 방법:\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom Tkinter import Tk, Frame, Button, Entry, Canvas, Text\nfrom Tkinter import LEFT, DISABLED, NORMAL, RIDGE, END\n\u003c/code\u003e\u003c/pre\u003e\n(\u003ccode\u003eimport *\u003c/code\u003e는 좋은 선택지가 아닙니다.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e대신, 파이썬의 표준 그룹화 메커니즘인 괄호를 사용하여 \u003ccode\u003eimport\u003c/code\u003e 문을 다음과 같이 작성할 수 있도록 제안되었습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom Tkinter import (Tk, Frame, Button, Entry, Canvas, Text,\nLEFT, DISABLED, NORMAL, RIDGE, END)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 제안의 일부는 처음부터 BDFL(Benevolent Dictator For Life, 귀도 반 로섬)의 승인을 받았습니다. 괄호 지원은 Python 2.4에 추가되었습니다.\u003c/p\u003e\n\u003ch2\u003e절대 경로 임포트 근거 (Rationale for Absolute Imports)\u003c/h2\u003e\n\u003cp\u003ePython 2.4 및 그 이전 버전에서는 패키지 내부에 있는 모듈을 읽을 때 \u003ccode\u003eimport foo\u003c/code\u003e가 최상위 모듈을 참조하는지 아니면 패키지 내의 다른 모듈을 참조하는지 명확하지 않았습니다. 파이썬 라이브러리가 확장됨에 따라, 점점 더 많은 기존 패키지 내부 모듈이 우연히 표준 라이브러리 모듈을 가리는 문제가 발생했습니다. 특히 패키지 내부에서는 어떤 모듈을 의도하는지 지정할 방법이 없어 어려운 문제였습니다.\u003c/p\u003e\n\u003cp\u003e이러한 모호성을 해결하기 위해 \u003ccode\u003efoo\u003c/code\u003e는 항상 \u003ccode\u003esys.path\u003c/code\u003e에서 접근 가능한 모듈 또는 패키지로 간주하도록 제안되었습니다. 이를 \u003cstrong\u003e절대 경로 임포트 (absolute import)\u003c/strong\u003e 라고 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epython-dev\u003c/code\u003e 커뮤니티는 절대 경로 임포트를 기본값으로 선택했습니다. 이는 절대 경로 임포트가 더 일반적인 사용 사례이며, 패키지 계층 구조에서 상위 부분의 이름을 변경하거나 한 패키지를 다른 패키지 안으로 이동할 때 어려움이 따르더라도, 상대 경로(패키지 내부) 임포트의 모든 기능을 제공할 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이는 의미론의 변경을 나타내므로, Python 2.5와 2.6에서는 \u003ccode\u003efrom __future__ import absolute_import\u003c/code\u003e를 통해 절대 경로 임포트를 선택적으로 사용할 수 있었습니다. 이 제안의 일부는 처음부터 BDFL의 승인을 받았습니다.\u003c/p\u003e\n\u003ch2\u003e상대 경로 임포트 근거 (Rationale for Relative Imports)\u003c/h2\u003e\n\u003cp\u003e절대 경로 임포트로의 전환과 함께, 상대 경로 임포트를 아예 허용해야 하는지에 대한 의문이 제기되었습니다. 몇 가지 사용 사례가 제시되었는데, 그중 가장 중요한 것은 하위 패키지를 수정하지 않고도 대규모 패키지의 구조를 재배치할 수 있어야 한다는 것이었습니다. 또한, 패키지 내부의 모듈은 상대 경로 임포트 없이는 자신을 쉽게 임포트할 수 없었습니다.\u003c/p\u003e\n\u003cp\u003e귀도 반 로섬은 상대 경로 임포트의 아이디어를 승인했지만, 구문(syntax)에 대해서는 많은 의견 불일치가 있었습니다. 상대 경로 임포트는 특정 이름을 나열하여 임포트해야 한다는 데에는 동의하는 것으로 보였습니다 (즉, \u003ccode\u003eimport foo\u003c/code\u003e와 같은 단순한 형태는 항상 절대 경로 임포트가 됩니다).\u003c/p\u003e\n\u003ch3\u003e제안되었던 구문들\u003c/h3\u003e\n\u003cp\u003e여러 구문들이 경쟁했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e귀도의 제안:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom .foo import bar\nfrom ...foo import bar\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 두 가지 형태는 여러 의미론이 제안되었습니다. 각 점이 한 레벨을 나타내는 방식이 있었으나, 점을 세는 것이 어렵다는 불만이 많았습니다. 한 레벨의 상대 경로 임포트만 허용하는 옵션도 있었으나, 많은 기능이 누락되었고, 사람들은 한 점 형태에서도 점이 빠지는 것에 대해 여전히 불평했습니다. 마지막 옵션은 상대 모듈 및 패키지를 찾는 알고리즘을 정의하는 것이었는데, 이에 대한 반대는 \"명시적인 것이 암시적인 것보다 낫다 (Explicit is better than implicit)\"는 것이었습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e다른 구분 기호:\u003c/strong\u003e \"-\" 또는 \"^\"와 같은 다른 구두점을 구분 기호로 사용하자는 제안도 있었습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\"*\" 사용:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom *.foo import bar\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e와 같이 \"*\"를 사용하자는 제안도 있었습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e__pkg__\u003c/code\u003e 또는 \u003ccode\u003e__parent__\u003c/code\u003e 사용:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom __pkg__.__pkg__ import\nfrom .__parent__.__parent__ import\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 형태는 많은 사람(귀도 포함)이 보기 흉하다고 생각했지만, 명확하고 명시적이었습니다. 전반적으로 더 짧은 \u003ccode\u003e__pkg__\u003c/code\u003e를 선호하는 사람이 많았습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e형제 모듈 참조만 허용:\u003c/strong\u003e 현재 디렉토리의 형제 모듈만 참조할 수 있도록 하자는 제안도 있었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom .spam import eggs\nimport .spam.eggs\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e인덱스화된 부모 허용:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom -2.spam import eggs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e와 같이 인덱스를 사용하여 부모 모듈을 참조하자는 제안도 있었습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eimport\u003c/code\u003e 구문 재작성:\u003c/strong\u003e \u003ccode\u003efrom ... import\u003c/code\u003e 대신 완전히 새로운 \u003ccode\u003eimport\u003c/code\u003e 구문을 제안하는 사람들도 있었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom MODULE import NAMES as RENAME searching HOW\nimport NAMES as RENAME from MODULE searching HOW [from NAMES] [in WHERE] import ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 이는 Python 2.5에 구현하기에는 너무 큰 변경이었고, 상대 경로 임포트의 필요성이 매우 중요했기 때문에 즉각적인 해결책이 필요했습니다. 또한, 이 제안된 구문에는 여러 미해결 질문이 있었습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e귀도의 결정 (Guido's Decision)\u003c/h2\u003e\n\u003cp\u003e귀도는 상대 경로 임포트가 \u003cstrong\u003e선행 점(leading dots)\u003c/strong\u003e 을 사용할 것이라고 선언했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e하나의 선행 점 (\u003ccode\u003e.\u003c/code\u003e):\u003c/strong\u003e 현재 패키지에서 시작하는 상대 경로 임포트를 나타냅니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e두 개 이상의 선행 점 (\u003ccode\u003e..\u003c/code\u003e, \u003ccode\u003e...\u003c/code\u003e 등):\u003c/strong\u003e 첫 번째 점 이후의 점 하나당 한 레벨씩 현재 패키지의 부모를 가리키는 상대 경로 임포트를 나타냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e예시 패키지 레이아웃:\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003epackage/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n        moduleY.py\n    subpackage2/\n        __init__.py\n        moduleZ.py\n        moduleA.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 파일이 \u003ccode\u003emoduleX.py\u003c/code\u003e 또는 \u003ccode\u003esubpackage1/__init__.py\u003c/code\u003e라고 가정했을 때, 새로운 구문의 올바른 사용법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom .moduleY import spam # 현재 패키지(subpackage1) 내 moduleY에서 spam 임포트\nfrom .moduleY import spam as ham # 현재 패키지(subpackage1) 내 moduleY에서 spam을 ham으로 임포트\nfrom . import moduleY # 현재 패키지(subpackage1) 내 moduleY 자체를 임포트\n\nfrom ..subpackage1 import moduleY # 부모 패키지(package)의 subpackage1에서 moduleY 임포트\nfrom ..subpackage2.moduleZ import eggs # 부모 패키지(package)의 subpackage2 내 moduleZ에서 eggs 임포트\nfrom ..moduleA import foo # 부모 패키지(package)의 moduleA에서 foo 임포트 (이 경우 moduleA는 package/__init__.py와 같은 레벨에 있어야 함)\n\nfrom ...package import bar # 조부모 패키지(package)의 package에서 bar 임포트 (이는 'package'가 상위 패키지의 하위 모듈이 될 때만 가능)\nfrom ...sys import path # 시스템 모듈인 sys를 임포트하는 예시 (권장되지 않음, \"미친 짓\"이라고 귀도가 언급함)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e주의:\u003c/strong\u003e 마지막 예시는 문법적으로 유효하지만, 권장되지 않습니다 (귀도는 \"미친 짓\"이라는 표현을 사용했습니다).\u003c/p\u003e\n\u003cp\u003e상대 경로 임포트는 항상 \u003ccode\u003efrom \u0026#x3C;\u003e import\u003c/code\u003e 형식을 사용해야 합니다. \u003ccode\u003eimport \u0026#x3C;\u003e\u003c/code\u003e는 항상 절대 경로 임포트입니다. 물론, 절대 경로 임포트도 선행 점을 생략하여 \u003ccode\u003efrom \u0026#x3C;\u003e import\u003c/code\u003e를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimport .foo\u003c/code\u003e가 금지되는 이유는 \u003ccode\u003eimport XXX.YYY.ZZZ\u003c/code\u003e 이후에는 \u003ccode\u003eXXX.YYY.ZZZ\u003c/code\u003e를 표현식에서 사용할 수 있지만, \u003ccode\u003e.moduleY\u003c/code\u003e는 표현식에서 사용할 수 없기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e상대 경로 임포트와 \u003ccode\u003e__name__\u003c/code\u003e (Relative Imports and \u003cstrong\u003ename\u003c/strong\u003e)\u003c/h2\u003e\n\u003cp\u003e상대 경로 임포트는 모듈의 \u003ccode\u003e__name__\u003c/code\u003e 속성을 사용하여 패키지 계층 구조 내에서 해당 모듈의 위치를 결정합니다. 만약 모듈의 이름이 패키지 정보를 포함하지 않는 경우 (예: \u003ccode\u003e'__main__'\u003c/code\u003e으로 설정된 경우), 상대 경로 임포트는 파일 시스템상의 실제 위치와 관계없이 해당 모듈이 최상위 모듈인 것처럼 해석됩니다.\u003c/p\u003e\n\u003ch2\u003e상대 경로 임포트와 \u003ccode\u003esys.modules\u003c/code\u003e의 간접 엔트리 (Relative Imports and Indirection Entries in sys.modules)\u003c/h2\u003e\n\u003cp\u003e패키지가 도입되었을 때 \u003ccode\u003esys.modules\u003c/code\u003e에 간접 엔트리(indirection entry) 개념이 생겨났습니다. 패키지 내 모듈에 대한 \u003ccode\u003esys.modules\u003c/code\u003e 엔트리의 값이 \u003ccode\u003eNone\u003c/code\u003e일 때, 이는 해당 모듈이 실제로는 최상위 모듈을 참조한다는 것을 나타냈습니다. 예를 들어, \u003ccode\u003e'Sound.Effects.string'\u003c/code\u003e이 \u003ccode\u003esys.modules\u003c/code\u003e에서 \u003ccode\u003eNone\u003c/code\u003e 값을 가질 수 있었는데, 이는 해당 이름으로 해석되는 모든 임포트가 실제로는 최상위 \u003ccode\u003e'string'\u003c/code\u003e 모듈을 임포트하는 것을 의미했습니다.\u003c/p\u003e\n\u003cp\u003e이것은 상대 경로 임포트가 절대 경로 임포트로 해석될 때의 최적화를 도입했지만, 이 PEP는 절대 경로 임포트와 상대 경로 임포트 사이에 매우 명확한 구분을 두기 때문에 이 최적화는 더 이상 필요하지 않습니다. 절대/상대 경로 임포트가 유일한 임포트 의미론이 되면 \u003ccode\u003esys.modules\u003c/code\u003e의 간접 엔트리는 더 이상 지원되지 않을 것입니다.\u003c/p\u003e\n\u003ch2\u003e참조 (References)\u003c/h2\u003e\n\u003cp\u003e더 많은 배경 정보를 위해 다음 \u003ccode\u003epython-dev\u003c/code\u003e 스레드를 참고하십시오:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eRe: Christmas Wishlist\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRe: Python-Dev Digest, Vol 5, Issue 57\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRelative import\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAnother Strategy for Relative Import\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ehttps://peps.python.org/pep-0328/\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ehttps://mail.python.org/pipermail/python-dev/2004-March/043739.html\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ehttps://www.python.org/doc/essays/packages/\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2215,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 328 - Imports: Multi-Line and Absolute/Relative\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 18:36:33+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/328/\",\"postId\":\"2025-09-26-pep-0328-imports-multi-line-and-absoluterelative\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/327/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 327 - Decimal Data Type\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 328 - Imports: Multi-Line and Absolute/Relative\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/330/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 330 - Python Bytecode Verification\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>