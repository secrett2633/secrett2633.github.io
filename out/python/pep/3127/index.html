<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 3127 - Integer Literal Support and Syntax</h1><div class="page__meta"><time dateTime="2025-09-27 14:30:46+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-3127/">PEP 3127 - Integer Literal Support and Syntax</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 14-Mar-2007</p>
</blockquote>
<h2>PEP 3127 – 정수 리터럴 지원 및 구문</h2>
<p>이 문서는 Python 3.0에 도입된 정수 리터럴(Integer Literal) 처리 방식의 변경 사항에 대한 Python Enhancement Proposal (PEP) 3127의 번역 및 요약입니다. 이 PEP는 정수 리터럴의 구문과 관련된 혼란을 줄이고 이진수(binary) 지원을 추가하는 것을 목표로 합니다.</p>
<h3>초록 (Abstract)</h3>
<p>이 PEP는 다양한 기수(radices, bases)에서 정수의 문자열 리터럴 표현 처리 방식을 합리화하기 위해 Python 코어에 대한 변경을 제안합니다. 이러한 변경 사항은 Python 3.0을 대상으로 하지만, 하위 호환 가능한 부분은 Python 2.6에도 추가되어 모든 유효한 Python 3.0 정수 리터럴이 Python 2.6에서도 유효하도록 합니다.</p>
<p>주요 제안 내용은 다음과 같습니다.</p>
<ul>
<li>8진수(octal) 리터럴은 더 이상 "0" 대신 선행 "0o" 또는 "0O"로 지정되어야 합니다.</li>
<li>이진수(binary) 리터럴은 선행 "0b" 또는 "0B"를 통해 지원됩니다.</li>
<li>문자열 포매팅에서도 이진수 지원이 고려됩니다.</li>
</ul>
<h3>동기 (Motivation)</h3>
<p>이 PEP는 두 가지 다른 문제에 의해 동기가 부여되었습니다.</p>
<ol>
<li><strong>기본 8진수 표현의 혼란</strong>: C-like 언어에 익숙하지 않은 사람들에게 정수의 기본 8진수 표현은 조용히 혼란을 줍니다. 예를 들어, <code>013</code>은 Python 언어 자체에서 '십진수 11'을 의미하며, 대부분의 사람이 <code>013</code>에 할당하는 '십진수 13'이라는 의미가 아닙니다. 이로 인해 의도치 않게 잘못된 값을 가진 정수 객체를 생성하기가 매우 쉽습니다.</li>
<li><strong>이진수 지원 요구</strong>: 일부 Python 사용자들이 언어 내에서 이진수 지원에 대한 강한 요구를 가지고 있습니다.</li>
</ol>
<h3>명세 (Specification)</h3>
<h4>문법 명세 (Grammar specification)</h4>
<p>Python 2.6의 경우, 변경되거나 새로 추가될 토큰(token) 정의는 다음과 같습니다.</p>
<pre><code>integer ::= decimalinteger | octinteger | hexinteger | bininteger | oldoctinteger
octinteger ::= "0" ("o" | "O") octdigit+
bininteger ::= "0" ("b" | "B") bindigit+
oldoctinteger ::= "0" octdigit+
bindigit ::= "0" | "1"
</code></pre>
<p>Python 3.0의 경우, <code>oldoctinteger</code>는 지원되지 않으며, 리터럴이 선행 "0" 다음에 숫자가 오는 경우 예외가 발생합니다.</p>
<p>두 버전 모두 <code>PyLong_FromString</code> 함수와 문법 변경이 필요하며, <code>grammar.txt</code> 및 참조 매뉴얼의 정수 리터럴 섹션과 같은 문서도 변경되어야 합니다.</p>
<h4><code>int()</code> 명세 (<code>int()</code> specification)</h4>
<p><code>int(s, 0)</code>도 새 문법 정의와 일치하도록 변경됩니다. 이는 문법 변경에 필요한 <code>PyLong_FromString</code>의 변경을 통해 자동으로 이루어져야 합니다. 또한, <code>int()</code>의 문서도 <code>int(s)</code>가 <code>int(s, 10)</code>과 동일하게 작동하며, <code>int(s, 0)</code> 설명에서 "guess"라는 단어가 제거되어야 함을 설명하도록 변경됩니다.</p>
<h4><code>long()</code> 명세 (<code>long()</code> specification)</h4>
<p>Python 2.6의 경우, <code>long()</code> 구현과 문서도 새 문법을 반영하도록 변경되어야 합니다.</p>
<h4>토크나이저 예외 처리 (Tokenizer exception handling)</h4>
<p>잘못된 토큰에 선행 "0"이 포함된 경우, 예외 오류 메시지는 현재의 "SyntaxError: invalid token"보다 더 유익해야 합니다. 이는 십진수(decimal)는 선행 0을 가질 수 없으며, 8진수는 선행 0 뒤에 "o"가 필요하다는 것을 설명해야 합니다.</p>
<h4><code>int()</code> 예외 처리 (<code>int()</code> exception handling)</h4>
<p><code>int()</code>를 문자열과 함께 호출할 때 발생하는 <code>ValueError</code>는 오류 메시지에 최소한 명시적으로 기수(base)를 포함해야 합니다. 예를 들어:</p>
<pre><code>ValueError: invalid literal for base 8 int(): 09
</code></pre>
<h4><code>oct()</code> 함수 (<code>oct()</code> function)</h4>
<p><code>oct()</code> 함수는 8진수 앞에 <code>0o</code>를 출력하도록 업데이트되어야 합니다 (3.0 및 2.6 호환 모드).</p>
<h4>출력 포매팅 (Output formatting)</h4>
<p>Python 3.0에서 문자열 <code>%</code> 연산자의 <code>o</code> 옵션에 대한 대체 구문은 <code>0</code> 대신 <code>0o</code>를 추가하도록 업데이트되어야 합니다. Python 2.6에서는 대체 8진수 포매팅이 계속해서 <code>0</code>만 추가합니다. Python 2.6과 3.0 모두에서 <code>%</code> 연산자는 이진수 출력을 지원하지 않습니다. 이는 PEP 3101 (<code>str.format</code>)에서 이미 이진수 출력이 지원되며, 이것이 권장되는 문자열 포매팅 방법이기 때문입니다.</p>
<h4>2.6에서 3.0으로의 전환 (Transition from 2.6 to 3.0)</h4>
<p><code>2to3</code> 변환기는 모든 8진수 문자열 리터럴에 <code>o</code>를 삽입해야 합니다. Python 2.6의 <code>Py3K</code> 호환 옵션은 <code>oldoctinteger</code> 리터럴을 사용하려는 시도에 예외를 발생시켜야 합니다.</p>
<h3>근거 (Rationale)</h3>
<h4>배경 (Background)</h4>
<p>이 문제에 대한 대부분의 논의는 Python-3000 메일링 리스트에서 2007년 3월 14일부터 시작되었습니다. 이는 숫자의 문자열 앞에 "0"을 붙이는 것이 숫자 문자열의 의미를 완전히 바꾼다는 사실에 일반적인 사람이 완전히 혼란스러워할 것이라는 관찰에서 비롯되었습니다.</p>
<p>역사적인 이유로, Python의 정수 문자열 표현은 다양한 기수에서 문자열 포매팅 및 토큰 리터럴에 대해 C 언어에서 많은 부분을 차용했습니다. 사용 사례를 통해 8진수를 지정하는 역사적인 방법이 혼란스러웠으며, 이진수 리터럴에 대한 추가 지원이 필요하다는 것이 밝혀졌습니다.</p>
<p>이 제안서는 다음과 같은 특징과 관련하여 정수의 문자열 표현에 대해 논의합니다.</p>
<ul>
<li>일반 모듈 컴파일, <code>eval()</code>, <code>int(token, 0)</code>에 사용되는 리터럴 정수 토큰. (<code>int(token)</code> 및 <code>int(token, 2-36)</code>은 이 제안으로 수정되지 않습니다.)</li>
<li>Python 2.6에서는 <code>long()</code>이 <code>int()</code>와 동일하게 처리됩니다.</li>
<li><code>%</code> 문자열 연산자 또는 새로운 PEP 3101 고급 문자열 포매팅 방법을 통한 정수의 문자열 포매팅.</li>
</ul>
<p>다음과 같은 가정이 있습니다.</p>
<ul>
<li>모든 기능은 일관성을 위해 동일한 지원 기수 세트를 가져야 합니다.</li>
<li>Python 소스 코드 구문과 <code>int(mystring, 0)</code>은 계속해서 동일한 동작을 공유해야 합니다.</li>
</ul>
<h4>오래된 8진수 구문 제거 (Removal of old octal syntax)</h4>
<p>이 PEP는 Python 3.0 (및 Python 2.6의 Python 3.0 미리보기 모드)에서 선행 0을 사용하여 8진수를 지정하는 기능이 언어에서 제거될 것을 제안하며, 선행 "0" 바로 뒤에 다른 숫자가 오는 경우 <code>SyntaxError</code>가 발생합니다.</p>
<p>현재 논의 중 <code>eval('010') == 8</code>은 새로운 사용자에게 혼란을 주기 때문에 더 이상 참이 되어서는 안 된다는 점에 거의 만장일치로 동의했습니다. <code>eval('0010') == 10</code>이 참이 되어야 한다는 제안도 있었지만, 이는 다른 컴퓨터 언어에서의 사용 방식과 너무 일관성이 없어서 실수가 발생할 가능성이 높기 때문에 훨씬 더 논쟁의 여지가 있습니다.</p>
<p>C/C++, Java, Perl, JavaScript를 포함한 거의 모든 인기 있는 컴퓨터 언어는 선행 0이 있는 숫자 시퀀스를 8진수로 취급합니다. 그러나 대부분의 비컴퓨터 세계에서는 십진수를 거의 독점적으로 사용합니다. 많은 사람들이 비십진수 기수와 마주했을 때 당황하고 혼란스러워한다는 수많은 증거가 있습니다.</p>
<p>하지만 대부분의 경우, 사람들은 십진수 앞에 불필요한 0을 붙이지 않습니다. 유일한 예외는 숫자 열을 맞추려고 할 때입니다. 그러나 PEP 8은 Python 코드 정렬을 위해 공백을 사용하는 것을 명시적으로 권장하지 않으므로, 동일한 목적으로 선행 0을 사용하는 것에도 같은 주장이 적용될 것이라고 추측할 수 있습니다.</p>
<p>결론적으로, 컴퓨터 사용에 완전히 새로운 사람이 십진수에 선행 0을 사용하는 경우, Python은 세 가지 옵션을 가질 수 있습니다.
a. 현재처럼 조용히 잘못된 처리를 합니다.
b. 이것이 유효한 구문이 아니라는 것을 즉시 알려줍니다. (예외 메시지가 더 친절해야 하지만, 이는 다른 PEP의 주제입니다.)
c. 컴퓨터가 "0"으로 시작하는 여러 자리 십진수 정수를 받아들인다고 계속 생각하게 합니다.</p>
<p>일부 사람들은 (c)가 올바른 답이라고 열정적으로 믿습니다. 그러나 새로운 사용자가 나중에 AJAX 애플리케이션을 작성할 때 문제가 발생할 수 있습니다. 따라서 Python은 새로운 사용자에게 선행 0을 허용하지 않는다는 것을 즉시 설명함으로써 문제를 해결할 수 있습니다 (합리적인 메시지와 함께!).</p>
<h4>지원되는 기수 (Supported radices)</h4>
<p>이 PEP는 Python 언어에서 지원되는 기수가 2 (이진), 8 (8진), 10 (십진), 16 (16진)이 될 것을 제안합니다.</p>
<p>오래된 8진수 구문이 언어에서 제거되어야 한다는 데 동의하면, 다음 질문은 "8진수로 숫자를 지정하고 표시할 방법이 실제로 필요한가?"입니다. 이 질문은 "언어가 어떤 기수를 지원해야 하는가?"로 이어집니다. <code>int()</code> 생성자는 2에서 36까지의 명시적인 기수 값을 허용하지만, 모든 기수를 지원하자는 아이디어는 빠르게 거부되었고, 실제 지원을 받은 유일한 기수는 십진수, 16진수, 8진수, 그리고 이진수였습니다.</p>
<p>인간은 끊임없이 다른 숫자 기수를 사용합니다. 예를 들어 "오후 12시 30분"은 12, 60, 2와 같은 세 가지 기수로 구성된 양적 정보를 전달합니다. 그러나 비컴퓨터 숫자 정보는 주로 이름(오전, 오후) 또는 십진 표기법을 통해 전달됩니다. 아라비아 숫자 체계가 인간의 인지에 잘 맞는다는 연구 결과도 있습니다.</p>
<p>ENIAC과 같은 초기 현대 컴퓨터조차도 이진수로 작동하는 컴퓨터가 있었음에도 불구하고 십진수로 계산했습니다. "이진화 십진수" (BCD)에서 작동하도록 설계된 명령어를 가진 PC를 포함한 많은 컴퓨터에서 십진수 컴퓨터 작동이 중요했습니다. BCD는 각 십진수에 4비트를 할당하는 표현 방식입니다. BCD는 반올림이 인간이 하는 방식과 정확히 동일하게 발생하므로, 계산 및 저장 효율성 측면에서 이진수가 우수함에도 불구하고 금융과 같은 분야에서 여전히 사용됩니다.</p>
<p>컴퓨터 하드웨어가 효율적인 계산 및 데이터 저장을 위해 일반적으로 이진수를 사용하지 않았다면, 정수의 문자열 표현은 항상 십진수였을 것입니다. 그러나 프로그래머와 하드웨어 엔지니어는 종종 컴퓨터처럼 생각해야 하므로, Python이 인간이 이해할 수 있는 형태로 이진 데이터를 통신할 수 있는 능력을 갖는 것이 중요합니다.</p>
<p>이진 데이터 표기법이 인간이 인지적으로 쉽게 처리할 수 있어야 한다는 요구 사항은 기호당 정수 비트(bits)를 포함해야 하며, 그 외에는 표준 십진 표기법 (위치는 거듭제곱을 나타내고, 더 큰 값은 왼쪽에 있으며, 알파벳에 너무 많은 기호가 없어야 함 등)을 매우 밀접하게 따라야 한다는 것을 의미합니다.</p>
<p>이러한 이진 데이터 표기법에 대한 "최적의 지점"은 아라비아 숫자 알파벳에서 선택된 단일 기호에 가능한 가장 큰 정수 비트 수를 담는 8진수입니다. 사실, PDP8 및 8080/Z80과 같은 일부 컴퓨터 아키텍처는 명령의 비트 필드를 3비트 그룹으로 배열하고 명령어 세트를 설명하기 위해 8진수 표현을 사용하는 방식으로 8진수를 기반으로 정의되었습니다. 오늘날에도 유닉스 파일 권한 마스크(Unix file permission masks)와 같이 필드당 3비트로 구성된 비트 팩(bit-packed) 구조 때문에 8진수는 중요합니다.</p>
<p>그러나 8진수는 더 큰 숫자에 사용될 때 단점이 있습니다. 기호당 비트 수는 정수이지만 그 자체가 2의 거듭제곱이 아닙니다. 이러한 한계(대부분의 컴퓨터의 워드 크기가 2의 거듭제곱이라는 점을 고려할 때)로 인해 16진수가 8진수보다 더 인기를 얻게 되었습니다. 16진수는 십진수보다 60% 더 큰 알파벳을 필요로 함에도 불구하고 각 기호가 4비트를 포함하기 때문입니다.</p>
<p>유닉스 파일 권한 마스크와 같은 일부 숫자는 8진수로 표현될 때 인간이 쉽게 디코딩할 수 있지만, 16진수로는 디코딩하기 어렵습니다. 반면 다른 숫자는 16진수로 인간이 다루기 훨씬 쉽습니다. 불행히도, 16진수나 8진수로 잘 전달되지 않는 이진수도 컴퓨터에 사용됩니다. 이러한 숫자가 매우 유용한 한 가지 예는 하드웨어 레지스터를 읽고 쓸 때입니다.</p>
<p>Python이 이진 정보를 인간에게 전달하는 능력이 소수의 기술 인구에게만 유용하더라도, 바로 그 인구층에 Python 코어 팀의 대부분이 포함되어 있으므로, 이러한 표기법 중 가장 유용성이 낮은 순수 이진수조차도 Python 커뮤니티 내에서 열렬한 지지자가 많고, 강력한 반대자는 거의 없습니다.</p>
<h4>지원되는 기수를 위한 구문 (Syntax for supported radices)</h4>
<p>이 제안은 8진수의 경우 대문자 또는 소문자 "o"가 포함된 "0o" 접두사를, 이진수의 경우 대문자 또는 소문자 "b"가 포함된 "0b" 접두사를 사용할 것을 제안합니다.</p>
<p>대문자를 지원하지 않는 것에 대한 강력한 지지가 있었지만, 복소수의 'j', 지수의 'e', 원시 문자열(raw string)의 'r' (몇 가지만 예로 들자면)이 이미 대문자를 지원하므로 이는 다른 PEP의 별도 주제입니다.</p>
<p>다양한 기수를 구분하는 구문은 Python-3000 논의에서 많은 주목을 받았습니다. 이 구문에는 다음과 같은 여러 (때로는 상충되는) 요구 사항과 "있으면 좋은 점"이 있습니다.</p>
<ul>
<li>입력 구문과 출력 (<code>%</code> 문자열 연산자 등) 구문 모두에서 다른 언어 및 이전 버전의 Python과 합리적으로 호환되어야 합니다.</li>
<li>일반적인 관찰자에게 가능한 한 명확해야 합니다.</li>
<li>다른 기수로 포매팅된 정수를 시각적으로 쉽게 구별할 수 있어야 합니다.</li>
</ul>
<p>제안된 구문에는 <code>16r100</code> (16진수 256)과 같은 임의의 기수 접두사와 <code>100h</code> 어셈블러 스타일 접미사와 유사한 기수 접미사가 포함되었습니다. 문자 "O"를 8진수에 사용할 수 있는지에 대한 논쟁은 격렬했습니다. 일부 글꼴에서는 대문자 "O"가 숫자 0과 매우 유사하게 보이기 때문입니다. "oCtal"의 두 번째 글자인 "c" 또는 "ocTal"의 "t", "biNary"의 "n"을 "heXadecimal"의 "x"와 함께 사용하자는 제안도 있었습니다.</p>
<p><code>%</code> 문자열 연산자의 경우 "o"는 이미 8진수를 나타내는 데 사용되고 있었습니다. 이진수 포매팅은 <code>%</code> 연산자에 추가되지 않습니다. PEP 3101 (고급 문자열 포매팅)이 이미 이진수를 지원하며, <code>%</code> 포매팅은 미래에 사용되지 않을 예정이기 때문입니다.</p>
<p>결론적으로, 대문자 "O"는 숫자 0처럼 보일 수 있고 대문자 "B"는 숫자 8처럼 보일 수 있으므로, 이러한 접두사는 소문자여야 하지만, 원시 문자열의 'r'처럼 이는 선호도 또는 스타일 가이드 문제가 될 수 있다고 결정되었습니다.</p>
<h3>미해결 과제 (Open Issues)</h3>
<p>논의에서는 16진수의 'x', 원시 문자열의 'r', 지수의 'e', 복소수의 'j'와 같은 모든 숫자 및 문자열 특수 수정자에 소문자를 사용해야 한다고 제안되었습니다. 이는 별도의 PEP에 대한 문제입니다.</p>
<p>이 PEP는 입력에 대한 대문자 또는 소문자에 대해 입장을 취하지 않으며, 다른 문자에 대한 입력 구문 분석에서 대문자가 제거되지 않는다면, 일관성을 위해 8진수와 이진수에 추가되어야 한다고만 언급합니다. (대소문자 문제에 대한 PEP는 아직 없으므로, 이 가정하에 변경 사항을 문서화합니다.)</p>
<p>출력 포매팅은 다른 이야기일 수 있습니다. 출력 포맷 문자열에서 대소문자 구분을 위한 선례가 이미 충분히 있으며, 이진수 또는 8진수 출력에 대해 대문자 'B' 또는 'O' 문자를 지원하기 위한 <code>%</code> 문자열 연산자의 "대체 형식"에 유효한 사용 사례가 있다는 합의가 필요합니다. 현재 PEP 3101은 이러한 대체 기능을 지원하지 않으며, <code>hex()</code> 함수는 프로그래머가 'x' 문자의 대소문자를 지정하도록 허용하지 않습니다.</p>
<p>Python 3.0에서 <code>0123</code>이 리터럴 십진수로 허용되어야 한다는 강력한 의견이 여전히 있습니다. 이것이 올바른 방향이라면, 추가 PEP에서 쉽게 다룰 수 있습니다. 이 제안은 근거에서 다룬 이유로 <code>0123</code>이 유효한 8진수가 아니도록 하는 첫 번째 단계만 수행합니다.</p>
<ul>
<li><code>2to3</code> 변환기에 2.6 호환 변경만 수행하는 옵션이 있거나 있어야 할까요? 이것이 2.6 릴리스 전에 2.6 라이브러리 코드에 실행되어야 할까요?</li>
<li><code>hex()</code> 및 <code>oct()</code>와 일치하는 <code>bin()</code> 함수가 추가되어야 할까요?</li>
<li>고급 문자열 포매팅이 있을 때 <code>hex()</code>가 정말 유용할까요?</li>
</ul>
<h3>참조 (References)</h3>
<p>GNU libc manual printf integer format conversions (http://www.gnu.org/software/libc/manual/html_node/Integer-Conversions.html)
Python string formatting operations (http://docs.python.org/library/stdtypes.html#string-formatting-operations)
The Representation of Numbers, Jiajie Zhang and Donald A. Norman (http://acad88.sahs.uth.tmc.edu/research/publications/Number-Representation.pdf)
ENIAC page at Wikipedia (http://en.wikipedia.org/wiki/ENIAC)
BCD page at Wikipedia (http://en.wikipedia.org/wiki/Binary-coded_decimal)</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/3127\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"SAPzS3zi9tsG5MkeKvxIA\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/3127/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/3127\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"3127\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/3127\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T4e01,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-3127/\"\u003ePEP 3127 - Integer Literal Support and Syntax\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 14-Mar-2007\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 3127 – 정수 리터럴 지원 및 구문\u003c/h2\u003e\n\u003cp\u003e이 문서는 Python 3.0에 도입된 정수 리터럴(Integer Literal) 처리 방식의 변경 사항에 대한 Python Enhancement Proposal (PEP) 3127의 번역 및 요약입니다. 이 PEP는 정수 리터럴의 구문과 관련된 혼란을 줄이고 이진수(binary) 지원을 추가하는 것을 목표로 합니다.\u003c/p\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 다양한 기수(radices, bases)에서 정수의 문자열 리터럴 표현 처리 방식을 합리화하기 위해 Python 코어에 대한 변경을 제안합니다. 이러한 변경 사항은 Python 3.0을 대상으로 하지만, 하위 호환 가능한 부분은 Python 2.6에도 추가되어 모든 유효한 Python 3.0 정수 리터럴이 Python 2.6에서도 유효하도록 합니다.\u003c/p\u003e\n\u003cp\u003e주요 제안 내용은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e8진수(octal) 리터럴은 더 이상 \"0\" 대신 선행 \"0o\" 또는 \"0O\"로 지정되어야 합니다.\u003c/li\u003e\n\u003cli\u003e이진수(binary) 리터럴은 선행 \"0b\" 또는 \"0B\"를 통해 지원됩니다.\u003c/li\u003e\n\u003cli\u003e문자열 포매팅에서도 이진수 지원이 고려됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e동기 (Motivation)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 두 가지 다른 문제에 의해 동기가 부여되었습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e기본 8진수 표현의 혼란\u003c/strong\u003e: C-like 언어에 익숙하지 않은 사람들에게 정수의 기본 8진수 표현은 조용히 혼란을 줍니다. 예를 들어, \u003ccode\u003e013\u003c/code\u003e은 Python 언어 자체에서 '십진수 11'을 의미하며, 대부분의 사람이 \u003ccode\u003e013\u003c/code\u003e에 할당하는 '십진수 13'이라는 의미가 아닙니다. 이로 인해 의도치 않게 잘못된 값을 가진 정수 객체를 생성하기가 매우 쉽습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e이진수 지원 요구\u003c/strong\u003e: 일부 Python 사용자들이 언어 내에서 이진수 지원에 대한 강한 요구를 가지고 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003ch4\u003e문법 명세 (Grammar specification)\u003c/h4\u003e\n\u003cp\u003ePython 2.6의 경우, 변경되거나 새로 추가될 토큰(token) 정의는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einteger ::= decimalinteger | octinteger | hexinteger | bininteger | oldoctinteger\r\noctinteger ::= \"0\" (\"o\" | \"O\") octdigit+\r\nbininteger ::= \"0\" (\"b\" | \"B\") bindigit+\r\noldoctinteger ::= \"0\" octdigit+\r\nbindigit ::= \"0\" | \"1\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 3.0의 경우, \u003ccode\u003eoldoctinteger\u003c/code\u003e는 지원되지 않으며, 리터럴이 선행 \"0\" 다음에 숫자가 오는 경우 예외가 발생합니다.\u003c/p\u003e\n\u003cp\u003e두 버전 모두 \u003ccode\u003ePyLong_FromString\u003c/code\u003e 함수와 문법 변경이 필요하며, \u003ccode\u003egrammar.txt\u003c/code\u003e 및 참조 매뉴얼의 정수 리터럴 섹션과 같은 문서도 변경되어야 합니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eint()\u003c/code\u003e 명세 (\u003ccode\u003eint()\u003c/code\u003e specification)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eint(s, 0)\u003c/code\u003e도 새 문법 정의와 일치하도록 변경됩니다. 이는 문법 변경에 필요한 \u003ccode\u003ePyLong_FromString\u003c/code\u003e의 변경을 통해 자동으로 이루어져야 합니다. 또한, \u003ccode\u003eint()\u003c/code\u003e의 문서도 \u003ccode\u003eint(s)\u003c/code\u003e가 \u003ccode\u003eint(s, 10)\u003c/code\u003e과 동일하게 작동하며, \u003ccode\u003eint(s, 0)\u003c/code\u003e 설명에서 \"guess\"라는 단어가 제거되어야 함을 설명하도록 변경됩니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003elong()\u003c/code\u003e 명세 (\u003ccode\u003elong()\u003c/code\u003e specification)\u003c/h4\u003e\n\u003cp\u003ePython 2.6의 경우, \u003ccode\u003elong()\u003c/code\u003e 구현과 문서도 새 문법을 반영하도록 변경되어야 합니다.\u003c/p\u003e\n\u003ch4\u003e토크나이저 예외 처리 (Tokenizer exception handling)\u003c/h4\u003e\n\u003cp\u003e잘못된 토큰에 선행 \"0\"이 포함된 경우, 예외 오류 메시지는 현재의 \"SyntaxError: invalid token\"보다 더 유익해야 합니다. 이는 십진수(decimal)는 선행 0을 가질 수 없으며, 8진수는 선행 0 뒤에 \"o\"가 필요하다는 것을 설명해야 합니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eint()\u003c/code\u003e 예외 처리 (\u003ccode\u003eint()\u003c/code\u003e exception handling)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eint()\u003c/code\u003e를 문자열과 함께 호출할 때 발생하는 \u003ccode\u003eValueError\u003c/code\u003e는 오류 메시지에 최소한 명시적으로 기수(base)를 포함해야 합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eValueError: invalid literal for base 8 int(): 09\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003ccode\u003eoct()\u003c/code\u003e 함수 (\u003ccode\u003eoct()\u003c/code\u003e function)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eoct()\u003c/code\u003e 함수는 8진수 앞에 \u003ccode\u003e0o\u003c/code\u003e를 출력하도록 업데이트되어야 합니다 (3.0 및 2.6 호환 모드).\u003c/p\u003e\n\u003ch4\u003e출력 포매팅 (Output formatting)\u003c/h4\u003e\n\u003cp\u003ePython 3.0에서 문자열 \u003ccode\u003e%\u003c/code\u003e 연산자의 \u003ccode\u003eo\u003c/code\u003e 옵션에 대한 대체 구문은 \u003ccode\u003e0\u003c/code\u003e 대신 \u003ccode\u003e0o\u003c/code\u003e를 추가하도록 업데이트되어야 합니다. Python 2.6에서는 대체 8진수 포매팅이 계속해서 \u003ccode\u003e0\u003c/code\u003e만 추가합니다. Python 2.6과 3.0 모두에서 \u003ccode\u003e%\u003c/code\u003e 연산자는 이진수 출력을 지원하지 않습니다. 이는 PEP 3101 (\u003ccode\u003estr.format\u003c/code\u003e)에서 이미 이진수 출력이 지원되며, 이것이 권장되는 문자열 포매팅 방법이기 때문입니다.\u003c/p\u003e\n\u003ch4\u003e2.6에서 3.0으로의 전환 (Transition from 2.6 to 3.0)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003e2to3\u003c/code\u003e 변환기는 모든 8진수 문자열 리터럴에 \u003ccode\u003eo\u003c/code\u003e를 삽입해야 합니다. Python 2.6의 \u003ccode\u003ePy3K\u003c/code\u003e 호환 옵션은 \u003ccode\u003eoldoctinteger\u003c/code\u003e 리터럴을 사용하려는 시도에 예외를 발생시켜야 합니다.\u003c/p\u003e\n\u003ch3\u003e근거 (Rationale)\u003c/h3\u003e\n\u003ch4\u003e배경 (Background)\u003c/h4\u003e\n\u003cp\u003e이 문제에 대한 대부분의 논의는 Python-3000 메일링 리스트에서 2007년 3월 14일부터 시작되었습니다. 이는 숫자의 문자열 앞에 \"0\"을 붙이는 것이 숫자 문자열의 의미를 완전히 바꾼다는 사실에 일반적인 사람이 완전히 혼란스러워할 것이라는 관찰에서 비롯되었습니다.\u003c/p\u003e\n\u003cp\u003e역사적인 이유로, Python의 정수 문자열 표현은 다양한 기수에서 문자열 포매팅 및 토큰 리터럴에 대해 C 언어에서 많은 부분을 차용했습니다. 사용 사례를 통해 8진수를 지정하는 역사적인 방법이 혼란스러웠으며, 이진수 리터럴에 대한 추가 지원이 필요하다는 것이 밝혀졌습니다.\u003c/p\u003e\n\u003cp\u003e이 제안서는 다음과 같은 특징과 관련하여 정수의 문자열 표현에 대해 논의합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일반 모듈 컴파일, \u003ccode\u003eeval()\u003c/code\u003e, \u003ccode\u003eint(token, 0)\u003c/code\u003e에 사용되는 리터럴 정수 토큰. (\u003ccode\u003eint(token)\u003c/code\u003e 및 \u003ccode\u003eint(token, 2-36)\u003c/code\u003e은 이 제안으로 수정되지 않습니다.)\u003c/li\u003e\n\u003cli\u003ePython 2.6에서는 \u003ccode\u003elong()\u003c/code\u003e이 \u003ccode\u003eint()\u003c/code\u003e와 동일하게 처리됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e%\u003c/code\u003e 문자열 연산자 또는 새로운 PEP 3101 고급 문자열 포매팅 방법을 통한 정수의 문자열 포매팅.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음과 같은 가정이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모든 기능은 일관성을 위해 동일한 지원 기수 세트를 가져야 합니다.\u003c/li\u003e\n\u003cli\u003ePython 소스 코드 구문과 \u003ccode\u003eint(mystring, 0)\u003c/code\u003e은 계속해서 동일한 동작을 공유해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e오래된 8진수 구문 제거 (Removal of old octal syntax)\u003c/h4\u003e\n\u003cp\u003e이 PEP는 Python 3.0 (및 Python 2.6의 Python 3.0 미리보기 모드)에서 선행 0을 사용하여 8진수를 지정하는 기능이 언어에서 제거될 것을 제안하며, 선행 \"0\" 바로 뒤에 다른 숫자가 오는 경우 \u003ccode\u003eSyntaxError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003cp\u003e현재 논의 중 \u003ccode\u003eeval('010') == 8\u003c/code\u003e은 새로운 사용자에게 혼란을 주기 때문에 더 이상 참이 되어서는 안 된다는 점에 거의 만장일치로 동의했습니다. \u003ccode\u003eeval('0010') == 10\u003c/code\u003e이 참이 되어야 한다는 제안도 있었지만, 이는 다른 컴퓨터 언어에서의 사용 방식과 너무 일관성이 없어서 실수가 발생할 가능성이 높기 때문에 훨씬 더 논쟁의 여지가 있습니다.\u003c/p\u003e\n\u003cp\u003eC/C++, Java, Perl, JavaScript를 포함한 거의 모든 인기 있는 컴퓨터 언어는 선행 0이 있는 숫자 시퀀스를 8진수로 취급합니다. 그러나 대부분의 비컴퓨터 세계에서는 십진수를 거의 독점적으로 사용합니다. 많은 사람들이 비십진수 기수와 마주했을 때 당황하고 혼란스러워한다는 수많은 증거가 있습니다.\u003c/p\u003e\n\u003cp\u003e하지만 대부분의 경우, 사람들은 십진수 앞에 불필요한 0을 붙이지 않습니다. 유일한 예외는 숫자 열을 맞추려고 할 때입니다. 그러나 PEP 8은 Python 코드 정렬을 위해 공백을 사용하는 것을 명시적으로 권장하지 않으므로, 동일한 목적으로 선행 0을 사용하는 것에도 같은 주장이 적용될 것이라고 추측할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e결론적으로, 컴퓨터 사용에 완전히 새로운 사람이 십진수에 선행 0을 사용하는 경우, Python은 세 가지 옵션을 가질 수 있습니다.\r\na. 현재처럼 조용히 잘못된 처리를 합니다.\r\nb. 이것이 유효한 구문이 아니라는 것을 즉시 알려줍니다. (예외 메시지가 더 친절해야 하지만, 이는 다른 PEP의 주제입니다.)\r\nc. 컴퓨터가 \"0\"으로 시작하는 여러 자리 십진수 정수를 받아들인다고 계속 생각하게 합니다.\u003c/p\u003e\n\u003cp\u003e일부 사람들은 (c)가 올바른 답이라고 열정적으로 믿습니다. 그러나 새로운 사용자가 나중에 AJAX 애플리케이션을 작성할 때 문제가 발생할 수 있습니다. 따라서 Python은 새로운 사용자에게 선행 0을 허용하지 않는다는 것을 즉시 설명함으로써 문제를 해결할 수 있습니다 (합리적인 메시지와 함께!).\u003c/p\u003e\n\u003ch4\u003e지원되는 기수 (Supported radices)\u003c/h4\u003e\n\u003cp\u003e이 PEP는 Python 언어에서 지원되는 기수가 2 (이진), 8 (8진), 10 (십진), 16 (16진)이 될 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e오래된 8진수 구문이 언어에서 제거되어야 한다는 데 동의하면, 다음 질문은 \"8진수로 숫자를 지정하고 표시할 방법이 실제로 필요한가?\"입니다. 이 질문은 \"언어가 어떤 기수를 지원해야 하는가?\"로 이어집니다. \u003ccode\u003eint()\u003c/code\u003e 생성자는 2에서 36까지의 명시적인 기수 값을 허용하지만, 모든 기수를 지원하자는 아이디어는 빠르게 거부되었고, 실제 지원을 받은 유일한 기수는 십진수, 16진수, 8진수, 그리고 이진수였습니다.\u003c/p\u003e\n\u003cp\u003e인간은 끊임없이 다른 숫자 기수를 사용합니다. 예를 들어 \"오후 12시 30분\"은 12, 60, 2와 같은 세 가지 기수로 구성된 양적 정보를 전달합니다. 그러나 비컴퓨터 숫자 정보는 주로 이름(오전, 오후) 또는 십진 표기법을 통해 전달됩니다. 아라비아 숫자 체계가 인간의 인지에 잘 맞는다는 연구 결과도 있습니다.\u003c/p\u003e\n\u003cp\u003eENIAC과 같은 초기 현대 컴퓨터조차도 이진수로 작동하는 컴퓨터가 있었음에도 불구하고 십진수로 계산했습니다. \"이진화 십진수\" (BCD)에서 작동하도록 설계된 명령어를 가진 PC를 포함한 많은 컴퓨터에서 십진수 컴퓨터 작동이 중요했습니다. BCD는 각 십진수에 4비트를 할당하는 표현 방식입니다. BCD는 반올림이 인간이 하는 방식과 정확히 동일하게 발생하므로, 계산 및 저장 효율성 측면에서 이진수가 우수함에도 불구하고 금융과 같은 분야에서 여전히 사용됩니다.\u003c/p\u003e\n\u003cp\u003e컴퓨터 하드웨어가 효율적인 계산 및 데이터 저장을 위해 일반적으로 이진수를 사용하지 않았다면, 정수의 문자열 표현은 항상 십진수였을 것입니다. 그러나 프로그래머와 하드웨어 엔지니어는 종종 컴퓨터처럼 생각해야 하므로, Python이 인간이 이해할 수 있는 형태로 이진 데이터를 통신할 수 있는 능력을 갖는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e이진 데이터 표기법이 인간이 인지적으로 쉽게 처리할 수 있어야 한다는 요구 사항은 기호당 정수 비트(bits)를 포함해야 하며, 그 외에는 표준 십진 표기법 (위치는 거듭제곱을 나타내고, 더 큰 값은 왼쪽에 있으며, 알파벳에 너무 많은 기호가 없어야 함 등)을 매우 밀접하게 따라야 한다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e이러한 이진 데이터 표기법에 대한 \"최적의 지점\"은 아라비아 숫자 알파벳에서 선택된 단일 기호에 가능한 가장 큰 정수 비트 수를 담는 8진수입니다. 사실, PDP8 및 8080/Z80과 같은 일부 컴퓨터 아키텍처는 명령의 비트 필드를 3비트 그룹으로 배열하고 명령어 세트를 설명하기 위해 8진수 표현을 사용하는 방식으로 8진수를 기반으로 정의되었습니다. 오늘날에도 유닉스 파일 권한 마스크(Unix file permission masks)와 같이 필드당 3비트로 구성된 비트 팩(bit-packed) 구조 때문에 8진수는 중요합니다.\u003c/p\u003e\n\u003cp\u003e그러나 8진수는 더 큰 숫자에 사용될 때 단점이 있습니다. 기호당 비트 수는 정수이지만 그 자체가 2의 거듭제곱이 아닙니다. 이러한 한계(대부분의 컴퓨터의 워드 크기가 2의 거듭제곱이라는 점을 고려할 때)로 인해 16진수가 8진수보다 더 인기를 얻게 되었습니다. 16진수는 십진수보다 60% 더 큰 알파벳을 필요로 함에도 불구하고 각 기호가 4비트를 포함하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e유닉스 파일 권한 마스크와 같은 일부 숫자는 8진수로 표현될 때 인간이 쉽게 디코딩할 수 있지만, 16진수로는 디코딩하기 어렵습니다. 반면 다른 숫자는 16진수로 인간이 다루기 훨씬 쉽습니다. 불행히도, 16진수나 8진수로 잘 전달되지 않는 이진수도 컴퓨터에 사용됩니다. 이러한 숫자가 매우 유용한 한 가지 예는 하드웨어 레지스터를 읽고 쓸 때입니다.\u003c/p\u003e\n\u003cp\u003ePython이 이진 정보를 인간에게 전달하는 능력이 소수의 기술 인구에게만 유용하더라도, 바로 그 인구층에 Python 코어 팀의 대부분이 포함되어 있으므로, 이러한 표기법 중 가장 유용성이 낮은 순수 이진수조차도 Python 커뮤니티 내에서 열렬한 지지자가 많고, 강력한 반대자는 거의 없습니다.\u003c/p\u003e\n\u003ch4\u003e지원되는 기수를 위한 구문 (Syntax for supported radices)\u003c/h4\u003e\n\u003cp\u003e이 제안은 8진수의 경우 대문자 또는 소문자 \"o\"가 포함된 \"0o\" 접두사를, 이진수의 경우 대문자 또는 소문자 \"b\"가 포함된 \"0b\" 접두사를 사용할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e대문자를 지원하지 않는 것에 대한 강력한 지지가 있었지만, 복소수의 'j', 지수의 'e', 원시 문자열(raw string)의 'r' (몇 가지만 예로 들자면)이 이미 대문자를 지원하므로 이는 다른 PEP의 별도 주제입니다.\u003c/p\u003e\n\u003cp\u003e다양한 기수를 구분하는 구문은 Python-3000 논의에서 많은 주목을 받았습니다. 이 구문에는 다음과 같은 여러 (때로는 상충되는) 요구 사항과 \"있으면 좋은 점\"이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e입력 구문과 출력 (\u003ccode\u003e%\u003c/code\u003e 문자열 연산자 등) 구문 모두에서 다른 언어 및 이전 버전의 Python과 합리적으로 호환되어야 합니다.\u003c/li\u003e\n\u003cli\u003e일반적인 관찰자에게 가능한 한 명확해야 합니다.\u003c/li\u003e\n\u003cli\u003e다른 기수로 포매팅된 정수를 시각적으로 쉽게 구별할 수 있어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e제안된 구문에는 \u003ccode\u003e16r100\u003c/code\u003e (16진수 256)과 같은 임의의 기수 접두사와 \u003ccode\u003e100h\u003c/code\u003e 어셈블러 스타일 접미사와 유사한 기수 접미사가 포함되었습니다. 문자 \"O\"를 8진수에 사용할 수 있는지에 대한 논쟁은 격렬했습니다. 일부 글꼴에서는 대문자 \"O\"가 숫자 0과 매우 유사하게 보이기 때문입니다. \"oCtal\"의 두 번째 글자인 \"c\" 또는 \"ocTal\"의 \"t\", \"biNary\"의 \"n\"을 \"heXadecimal\"의 \"x\"와 함께 사용하자는 제안도 있었습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e%\u003c/code\u003e 문자열 연산자의 경우 \"o\"는 이미 8진수를 나타내는 데 사용되고 있었습니다. 이진수 포매팅은 \u003ccode\u003e%\u003c/code\u003e 연산자에 추가되지 않습니다. PEP 3101 (고급 문자열 포매팅)이 이미 이진수를 지원하며, \u003ccode\u003e%\u003c/code\u003e 포매팅은 미래에 사용되지 않을 예정이기 때문입니다.\u003c/p\u003e\n\u003cp\u003e결론적으로, 대문자 \"O\"는 숫자 0처럼 보일 수 있고 대문자 \"B\"는 숫자 8처럼 보일 수 있으므로, 이러한 접두사는 소문자여야 하지만, 원시 문자열의 'r'처럼 이는 선호도 또는 스타일 가이드 문제가 될 수 있다고 결정되었습니다.\u003c/p\u003e\n\u003ch3\u003e미해결 과제 (Open Issues)\u003c/h3\u003e\n\u003cp\u003e논의에서는 16진수의 'x', 원시 문자열의 'r', 지수의 'e', 복소수의 'j'와 같은 모든 숫자 및 문자열 특수 수정자에 소문자를 사용해야 한다고 제안되었습니다. 이는 별도의 PEP에 대한 문제입니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 입력에 대한 대문자 또는 소문자에 대해 입장을 취하지 않으며, 다른 문자에 대한 입력 구문 분석에서 대문자가 제거되지 않는다면, 일관성을 위해 8진수와 이진수에 추가되어야 한다고만 언급합니다. (대소문자 문제에 대한 PEP는 아직 없으므로, 이 가정하에 변경 사항을 문서화합니다.)\u003c/p\u003e\n\u003cp\u003e출력 포매팅은 다른 이야기일 수 있습니다. 출력 포맷 문자열에서 대소문자 구분을 위한 선례가 이미 충분히 있으며, 이진수 또는 8진수 출력에 대해 대문자 'B' 또는 'O' 문자를 지원하기 위한 \u003ccode\u003e%\u003c/code\u003e 문자열 연산자의 \"대체 형식\"에 유효한 사용 사례가 있다는 합의가 필요합니다. 현재 PEP 3101은 이러한 대체 기능을 지원하지 않으며, \u003ccode\u003ehex()\u003c/code\u003e 함수는 프로그래머가 'x' 문자의 대소문자를 지정하도록 허용하지 않습니다.\u003c/p\u003e\n\u003cp\u003ePython 3.0에서 \u003ccode\u003e0123\u003c/code\u003e이 리터럴 십진수로 허용되어야 한다는 강력한 의견이 여전히 있습니다. 이것이 올바른 방향이라면, 추가 PEP에서 쉽게 다룰 수 있습니다. 이 제안은 근거에서 다룬 이유로 \u003ccode\u003e0123\u003c/code\u003e이 유효한 8진수가 아니도록 하는 첫 번째 단계만 수행합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e2to3\u003c/code\u003e 변환기에 2.6 호환 변경만 수행하는 옵션이 있거나 있어야 할까요? 이것이 2.6 릴리스 전에 2.6 라이브러리 코드에 실행되어야 할까요?\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehex()\u003c/code\u003e 및 \u003ccode\u003eoct()\u003c/code\u003e와 일치하는 \u003ccode\u003ebin()\u003c/code\u003e 함수가 추가되어야 할까요?\u003c/li\u003e\n\u003cli\u003e고급 문자열 포매팅이 있을 때 \u003ccode\u003ehex()\u003c/code\u003e가 정말 유용할까요?\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e참조 (References)\u003c/h3\u003e\n\u003cp\u003eGNU libc manual printf integer format conversions (http://www.gnu.org/software/libc/manual/html_node/Integer-Conversions.html)\r\nPython string formatting operations (http://docs.python.org/library/stdtypes.html#string-formatting-operations)\r\nThe Representation of Numbers, Jiajie Zhang and Donald A. Norman (http://acad88.sahs.uth.tmc.edu/research/publications/Number-Representation.pdf)\r\nENIAC page at Wikipedia (http://en.wikipedia.org/wiki/ENIAC)\r\nBCD page at Wikipedia (http://en.wikipedia.org/wiki/Binary-coded_decimal)\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 3127 - Integer Literal Support and Syntax\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 14:30:46+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>