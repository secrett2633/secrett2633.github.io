3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-ad5f81b531af48c1.js","185","static/chunks/app/layout-c3e2e457f12fb6f6.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","931","static/chunks/app/page-51594f997fc19690.js"],""]
4:["slug","python/pep/483","c"]
0:["ogGio3genoY6eym-8SYbg",[[["",{"children":[["slug","python/pep/483","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"483\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/483","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/edf391eeca43d999.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T5d1e,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0483/">PEP 483 - The Theory of Type Hints</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Informational | <strong>작성일:</strong> 19-Dec-2014</p>
</blockquote>
<h2>PEP 483 – 타입 힌트의 이론 (The Theory of Type Hints)</h2>
<h3>개요 (Abstract)</h3>
<p>이 PEP는 PEP 484에서 참조되는 타입 이론을 설명합니다.</p>
<h3>서론 (Introduction)</h3>
<p>이 문서는 Python 3.5를 위한 새로운 타입 힌트 제안의 이론적 배경을 제시합니다. 아직 많은 세부 사항이 확정되어야 하므로 완전한 제안이나 명세는 아니지만, 더 자세한 명세를 논의하기 어렵게 만드는 이론적 기반을 제공합니다. 타입 이론의 기본 개념을 상기하는 것으로 시작하여, 점진적 타이핑(gradual typing)을 설명하고, 일반적인 규칙을 제시하며, 어노테이션(annotations)에 사용될 수 있는 새로운 특별한 타입(예: <code>Union</code>)을 정의합니다. 마지막으로 제네릭 타입(generic types)에 대한 접근 방식과 타입 힌트의 실용적인 측면을 정의합니다.</p>
<h3>표기 규칙 (Notational conventions)</h3>
<ul>
<li><code>t1</code>, <code>t2</code> 등과 <code>u1</code>, <code>u2</code> 등은 타입을 나타냅니다.</li>
<li><code>T</code>, <code>U</code> 등은 <code>TypeVar()</code>로 정의되는 타입 변수(type variables)입니다.</li>
<li>PEP 8 규칙에 따라 객체, <code>class</code> 문으로 정의된 클래스 및 인스턴스가 표기됩니다.</li>
<li>이 PEP의 맥락에서 타입에 적용되는 <code>==</code> 기호는 두 표현식이 동일한 타입을 나타냄을 의미합니다.</li>
<li>PEP 484는 타입(타입 체커를 위한 개념)과 클래스(런타임 개념)를 구분하지만, 이 PEP는 타입 체커 구현의 유연성을 위해 불필요하게 엄격한 구분을 피합니다.</li>
</ul>
<h3>배경 (Background)</h3>
<p>문헌에는 타입 개념에 대한 다양한 정의가 있습니다. 여기서는 타입을 값들의 집합과 이 값들에 적용할 수 있는 함수들의 집합으로 가정합니다.</p>
<p>특정 타입을 정의하는 방법은 여러 가지가 있습니다.</p>
<ul>
<li><strong>모든 값을 명시적으로 나열하여 정의:</strong> 예: <code>True</code>와 <code>False</code>는 <code>bool</code> 타입을 형성합니다.</li>
<li><strong>타입 변수와 함께 사용할 수 있는 함수를 지정하여 정의:</strong> 예: <code>__len__</code> 메서드를 가진 모든 객체는 <code>Sized</code> 타입을 형성합니다. <code>[1, 2, 3]</code>과 <code>'abc'</code> 모두 <code>len</code> 함수를 호출할 수 있으므로 이 타입에 속합니다.</li>
<li><strong>간단한 클래스 정의:</strong> 예: <code>class UserID(int): pass</code> 와 같이 클래스를 정의하면, 이 클래스의 모든 인스턴스 또한 하나의 타입을 형성합니다.</li>
</ul>
<p>사용자가 타입 체커가 이해할 수 있는 형태로 타입을 정의할 수 있는 것이 중요합니다. 이 PEP의 목표는 PEP 3107 구문을 사용하여 변수 및 함수의 타입 어노테이션을 위한 체계적인 타입 정의 방식을 제안하는 것입니다. 이러한 어노테이션은 다양한 종류의 버그를 방지하고, 문서화 목적으로, 또는 프로그램 실행 속도를 높이는 데 사용될 수 있습니다. 여기서는 정적 타입 체커(static type checker)를 사용하여 버그를 방지하는 데 중점을 둡니다.</p>
<h3>서브타입 관계 (Subtype relationships)</h3>
<p>정적 타입 체커에 있어 중요한 개념은 서브타입(subtype) 관계입니다. 이는 <code>first_var</code>가 <code>first_type</code>이고 <code>second_var</code>가 <code>second_type</code>일 때, <code>first_var = second_var</code> 할당이 안전한지 여부에서 발생합니다.</p>
<p>안전하다고 볼 수 있는 강력한 기준은 다음과 같습니다.</p>
<ol>
<li><code>second_type</code>의 모든 값이 <code>first_type</code>의 값 집합에도 포함됩니다.</li>
<li><code>first_type</code>의 모든 함수가 <code>second_type</code>의 함수 집합에도 포함됩니다.</li>
</ol>
<p>이 정의에 따르면:</p>
<ul>
<li>모든 타입은 자기 자신의 서브타입입니다.</li>
<li>서브타이핑 과정에서 값 집합은 작아지고, 함수 집합은 커집니다.</li>
</ul>
<p><strong>직관적인 예시:</strong> 모든 <code>Dog</code>는 <code>Animal</code>이며, <code>Dog</code>는 <code>bark</code>와 같은 더 많은 함수를 가집니다. 따라서 <code>Dog</code>는 <code>Animal</code>의 서브타입입니다. 반대로 <code>Animal</code>은 <code>Dog</code>의 서브타입이 아닙니다.</p>
<p><strong>더 형식적인 예시:</strong> <code>int</code>는 <code>float</code>의 서브타입입니다. 모든 정수는 실수이며, 정수는 비트 시프트 <code>&#x3C;&#x3C;</code>, <code>>></code>와 같은 더 많은 연산을 지원합니다.</p>
<p><strong>까다로운 예시:</strong> <code>List[int]</code> (정수만 포함하는 리스트 타입)는 <code>List[float]</code> (실수만 포함하는 리스트 타입)의 서브타입이 아닙니다. 첫 번째 서브타이핑 조건은 만족하지만, 실수를 추가하는 작업은 <code>List[float]</code>에서만 가능하므로 두 번째 조건이 실패합니다.</p>
<p>타입 체커에 서브타입 정보를 선언하는 두 가지 일반적인 접근 방식이 있습니다.</p>
<ul>
<li><strong>명목적 서브타이핑 (Nominal subtyping):</strong> 타입 트리가 클래스 트리를 기반으로 합니다. 즉, <code>UserID</code>는 <code>int</code>의 서브타입으로 간주됩니다. 파이썬에서는 호환되지 않는 방식으로 속성을 오버라이드할 수 있으므로, 이 접근 방식은 타입 체커의 제어 하에 사용되어야 합니다.
<pre><code class="language-python">class Base:
    answer = '42' # type: str
class Derived(Base):
    answer = 5 # should be marked as error by type checker
</code></pre>
</li>
<li><strong>구조적 서브타이핑 (Structural subtyping):</strong> 서브타입 관계가 선언된 메서드로부터 추론됩니다. 즉, <code>UserID</code>와 <code>int</code>는 동일한 타입으로 간주될 수 있습니다. 이 방식이 더 유연하다고 여겨집니다.</li>
</ul>
<h3>점진적 타이핑 요약 (Summary of gradual typing)</h3>
<p>점진적 타이핑(Gradual typing)은 프로그램의 일부에만 어노테이션을 달아 동적 타이핑과 정적 타이핑의 장점을 모두 활용할 수 있도록 합니다.</p>
<p>새로운 관계인 <code>is-consistent-with</code>를 정의하는데, 이는 <code>is-subtype-of</code>와 유사하지만, 새로운 타입 <code>Any</code>가 포함될 때 전이적(transitive)이지 않습니다. <code>a_value</code>의 타입이 <code>a_variable</code>의 타입과 일치(consistent)하면 <code>a_value</code>를 <code>a_variable</code>에 할당하는 것은 허용됩니다. (<code>is-consistent-with</code> 관계는 대칭적이지 않습니다.) <code>is-consistent-with</code> 관계는 세 가지 규칙으로 정의됩니다.</p>
<ol>
<li>타입 <code>t1</code>이 타입 <code>t2</code>의 서브타입이면, <code>t1</code>은 <code>t2</code>와 일치합니다.</li>
<li><code>Any</code>는 모든 타입과 일치합니다. (하지만 <code>Any</code>가 모든 타입의 서브타입인 것은 아닙니다.)</li>
<li>모든 타입은 <code>Any</code>와 일치합니다. (하지만 모든 타입이 <code>Any</code>의 서브타입인 것은 아닙니다.)</li>
</ol>
<p><code>Any</code>는 모든 값과 모든 메서드를 가진 타입으로 간주될 수 있습니다. 이는 타입 계층 구조의 상단(모든 값을 가짐)과 하단(모든 메서드를 가짐)에 부분적으로 <code>Any</code>를 위치시킵니다. <code>object</code>와 대조적으로, <code>object</code>는 대부분의 타입과 일치하지 않습니다. 즉, 인자를 어노테이션할 때 <code>Any</code>와 <code>object</code> 모두 "어떤 타입이든 허용됨"을 의미하지만, <code>Any</code>만 어떤 타입이 예상되든 전달될 수 있습니다 (본질적으로 <code>Any</code>는 동적 타이핑으로의 폴백(fallback)을 선언하고 정적 체커의 불평을 침묵시킵니다).</p>
<p><strong>예시:</strong>
<code>Employee</code> 클래스와 그 서브클래스 <code>Manager</code>가 있다고 가정합니다.</p>
<pre><code class="language-python">class Employee: ...
class Manager(Employee): ...

worker: Employee = Employee() # worker 변수는 Employee 타입으로 선언
worker = Manager() # OK (규칙 1: Manager는 Employee의 서브타입)

boss: Manager = Manager()
# boss = Employee() # 정적 검사 실패 (Employee는 Manager의 서브타입이 아님)

something: Any = some_func() # something 변수는 Any 타입으로 선언
worker = something # OK (규칙 2: Any는 모든 타입과 일치)

something = worker # OK (규칙 3: 모든 타입은 Any와 일치)
</code></pre>
<h3>타입과 클래스 (Types vs. Classes)</h3>
<p>파이썬에서 클래스는 <code>class</code> 문으로 정의되고 <code>type(obj)</code> 내장 함수에 의해 반환되는 객체 팩토리입니다. 클래스는 동적이고 런타임 개념입니다.
타입 개념은 위에서 설명되었으며, 변수 및 함수의 타입 어노테이션에 나타나고, 아래 설명된 구성 요소를 사용하여 구성될 수 있으며, 정적 타입 체커에서 사용됩니다.</p>
<p>모든 클래스는 타입입니다. 그러나 주어진 타입의 의미를 정확하게 나타내는 클래스를 구현하는 것은 까다롭고 오류 발생 가능성이 높으며, PEP 484의 목표가 아닙니다. PEP 484에 설명된 정적 타입은 런타임 클래스와 혼동되어서는 안 됩니다.
<strong>예시:</strong></p>
<ul>
<li><code>int</code>는 클래스이자 타입입니다.</li>
<li><code>UserID</code>는 클래스이자 타입입니다.</li>
<li><code>Union[str, int]</code>는 타입이지만, 적절한 클래스는 아닙니다.
<pre><code class="language-python">class MyUnion(Union[str, int]): ... # TypeError 발생
Union[str, int]() # TypeError 발생
</code></pre>
</li>
</ul>
<p><code>typing</code> 인터페이스는 클래스로 구현됩니다. 즉, 런타임에 <code>Generic[T].__bases__</code> 등을 평가할 수 있습니다. 그러나 클래스와 타입 간의 구분을 강조하기 위해 다음 일반 규칙이 적용됩니다.</p>
<ul>
<li>아래에 정의된 타입(예: <code>Any</code>, <code>Union</code> 등)은 인스턴스화할 수 없으며, 시도하면 <code>TypeError</code>가 발생합니다. (단, <code>Generic</code>의 비추상 서브클래스는 가능합니다.)</li>
<li><code>Generic</code> 및 그로부터 파생된 클래스를 제외하고는 아래에 정의된 타입을 서브클래싱할 수 없습니다.</li>
<li><code>isinstance</code> 또는 <code>issubclass</code>에 나타나면 <code>TypeError</code>가 발생합니다 (매개변수화되지 않은 제네릭 제외).</li>
</ul>
<h3>기본 구성 요소 (Fundamental building blocks)</h3>
<ul>
<li><strong><code>Any</code></strong> : 모든 타입은 <code>Any</code>와 일치하며, <code>Any</code> 또한 모든 타입과 일치합니다.</li>
<li><strong><code>Union[t1, t2, …]</code></strong> : <code>t1</code> 등의 최소한 하나 이상의 서브타입인 타입들이 이 <code>Union</code>의 서브타입이 됩니다.
<ul>
<li>인수의 순서는 중요하지 않습니다.</li>
<li>중첩된 <code>Union</code>은 평탄화됩니다.</li>
<li><code>ti</code>와 <code>tj</code>가 서브타입 관계에 있다면, 덜 구체적인(less specific) 타입이 남습니다.</li>
<li><code>Union[t1]</code>은 <code>t1</code>을 반환합니다.</li>
<li><code>Union[]</code>은 허용되지 않습니다.</li>
<li><code>Union[..., object, ...]</code>은 <code>object</code>를 반환합니다.</li>
</ul>
</li>
<li><strong><code>Optional[t1]</code></strong> : <code>Union[t1, None]</code>의 별칭입니다.</li>
<li><strong><code>Tuple[t1, t2, …, tn]</code></strong> : 항목들이 <code>t1</code> 등의 인스턴스인 튜플입니다.
<ul>
<li>길이가 같고 각 <code>ui</code>가 <code>ti</code>의 서브타입이면 <code>Tuple[u1, ..., um]</code>은 <code>Tuple[t1, ..., tn]</code>의 서브타입입니다.</li>
<li>빈 튜플은 <code>Tuple[()]</code>로 표기합니다.</li>
<li>가변 길이의 동종 튜플 타입은 <code>Tuple[t1, ...]</code>으로 작성할 수 있습니다.</li>
</ul>
</li>
<li><strong><code>Callable[[t1, t2, …, tn], tr]</code></strong> : 위치 인자 타입이 <code>t1</code> 등이고 반환 타입이 <code>tr</code>인 함수입니다.
<ul>
<li>인자 목록은 비어 있을 수 있습니다 (<code>n==0</code>).</li>
<li>선택적(optional) 인자나 키워드 인자를 나타낼 방법은 없지만, <code>Callable[..., tr]</code> (리터럴 생략 부호)를 사용하여 인자 목록이 완전히 검사되지 않음을 나타낼 수 있습니다.</li>
</ul>
</li>
<li><strong><code>Intersection[t1, t2, …]</code> (제안 예정):</strong> <code>t1</code> 등의 각 타입의 서브타입인 타입들이 이 <code>Intersection</code>의 서브타입이 됩니다.</li>
</ul>
<h3>제네릭 타입 (Generic types)</h3>
<p>위에서 정의된 기본 구성 요소들은 제네릭 방식으로 새로운 타입을 구성할 수 있게 합니다. 제네릭 타입 생성자(generic type constructor)는 타입을 인자로 받아 타입을 "반환"하는 것과 유사한 의미를 가집니다.</p>
<p><strong>컨테이너 클래스:</strong> <code>list</code> 또는 <code>dict</code>와 같은 컨테이너 클래스는 일반적으로 특정 타입의 값만 포함합니다. 따라서 다음과 같이 타입 어노테이션을 달 수 있습니다.</p>
<pre><code class="language-python">users: list[UserID] = []
users.append(UserID(42)) # OK
# users.append('Some guy') # 타입 체커에 의해 거부되어야 함
</code></pre>
<p>이러한 상황에서 타입 어노테이션을 허용하기 위해, 내장 컨테이너 및 컨테이너 추상 베이스 클래스는 타입 매개변수(type parameters)로 확장되어 제네릭 타입 생성자처럼 동작합니다. 제네릭 타입 생성자처럼 동작하는 클래스를 제네릭 타입(generic types)이라고 합니다.</p>
<pre><code class="language-python">from typing import Iterable
class Task: ...
def work(todo_list: Iterable[Task]) -> None: ...
</code></pre>
<p>여기서 <code>Iterable</code>은 <code>Task</code>라는 구체적인 타입을 받아 <code>Iterable[Task]</code>라는 구체적인 타입을 반환하는 제네릭 타입입니다.</p>
<p><strong>제네릭 함수:</strong> 타입 변수(type variables)를 사용하여 제네릭 함수의 타입 어노테이션을 허용합니다.</p>
<pre><code class="language-python">def take_first(seq: Sequence[T]) -> T: # 제네릭 함수
    return seq[0]

accumulator: int = 0
accumulator += take_first([1, 2, 3]) # 안전함, T는 int로 추론됨
# accumulator += take_first((2.7, 3.5)) # 안전하지 않음
</code></pre>
<h3>타입 변수 (Type variables)</h3>
<p>타입 변수는 타입 어노테이션에서 광범위하게 사용됩니다. 타입 체커의 타입 추론(type inference) 내부 메커니즘도 일반적으로 타입 변수를 기반으로 합니다.</p>
<ul>
<li>
<p><code>X = TypeVar('X')</code>: 고유한 타입 변수를 선언합니다. 이름은 변수 이름과 일치해야 합니다. 기본적으로 타입 변수는 모든 가능한 타입을 범위로 가집니다.</p>
<pre><code class="language-python">T = TypeVar('T')
def do_nothing(one_arg: T, other_arg: T) -> None: pass
do_nothing(1, 2) # OK, T는 int
do_nothing('abc', UserID(42)) # OK, T는 object
</code></pre>
</li>
<li>
<p><code>Y = TypeVar('Y', t1, t2, ...)</code>: <code>t1</code> 등으로 제한된 타입 변수입니다. <code>Union[t1, t2, ...]</code>와 유사하게 동작합니다. 제약이 있는 타입 변수는 <code>t1</code> 등 제약 내에서만 범위를 가지며, 제약의 서브클래스는 <code>t1</code> 등 중에서 가장 파생된 베이스 클래스로 대체됩니다.</p>
<pre><code class="language-python">AnyStr = TypeVar('AnyStr', str, bytes)
def longest(first: AnyStr, second: AnyStr) -> AnyStr:
    return first if len(first) >= len(second) else second

result = longest('a', 'abc') # result의 추론된 타입은 str
# result = longest('a', b'abc') # 정적 타입 검사 실패
</code></pre>
<p>이 예시에서 <code>longest()</code>의 두 인수는 모두 동일한 타입(<code>str</code> 또는 <code>bytes</code>)이어야 하며, 공통 <code>str</code> 서브클래스의 인스턴스라 할지라도 반환 타입은 여전히 <code>str</code>입니다.</p>
</li>
</ul>
<h3>제네릭 타입 정의 및 사용 (Defining and using generic types)</h3>
<p>사용자는 <code>Generic</code>이라는 특별한 구성 요소를 사용하여 자신의 클래스를 제네릭 타입으로 선언할 수 있습니다. <code>class MyGeneric(Generic[X, Y, ...]): ...</code> 정의는 타입 변수 <code>X</code>, <code>Y</code> 등을 통해 <code>MyGeneric</code>이라는 제네릭 타입을 정의합니다. <code>MyGeneric</code> 자체는 매개변수화(parameterizable)될 수 있습니다.</p>
<pre><code class="language-python">class CustomQueue(Generic[T]):
    def put(self, task: T) -> None: ...
    def get(self) -> T: ...

def communicate(queue: CustomQueue[str]) -> Optional[str]: ...
</code></pre>
<p>제네릭 타입에서 파생된 클래스는 제네릭이 됩니다. 클래스는 여러 제네릭 타입을 서브클래싱할 수 있습니다. 그러나 제네릭에 의해 반환된 특정 타입에서 파생된 클래스는 제네릭이 아닙니다.</p>
<p>타입 변수가 생략된 상태로 타입 어노테이션에 제네릭 타입이 나타나면 <code>Any</code>로 가정됩니다. 이러한 형태는 동적 타이핑으로의 폴백으로 사용될 수 있으며 <code>issubclass</code> 및 <code>isinstance</code>와 함께 사용이 허용됩니다. 모든 인스턴스의 타입 정보는 런타임에 지워집니다.</p>
<h3>공변성 (Covariance) 및 반변성 (Contravariance)</h3>
<p><code>t2</code>가 <code>t1</code>의 서브타입일 때, 제네릭 타입 생성자 <code>GenType</code>은 다음과 같이 불립니다.</p>
<ul>
<li><strong>공변 (Covariant):</strong> 모든 <code>t1</code>, <code>t2</code>에 대해 <code>GenType[t2]</code>가 <code>GenType[t1]</code>의 서브타입인 경우.</li>
<li><strong>반변 (Contravariant):</strong> 모든 <code>t1</code>, <code>t2</code>에 대해 <code>GenType[t1]</code>이 <code>GenType[t2]</code>의 서브타입인 경우.</li>
<li><strong>불변 (Invariant):</strong> 위 두 가지 모두 해당하지 않는 경우.</li>
</ul>
<p><strong>실제 예시:</strong></p>
<ul>
<li><strong><code>Union</code></strong> 은 모든 인자에서 공변적으로 동작합니다.</li>
<li><strong><code>FrozenSet[T]</code></strong> 는 공변입니다. <code>int</code>는 <code>float</code>의 서브타입이고, <code>FrozenSet[int]</code>의 값 집합은 <code>FrozenSet[float]</code>의 값 집합의 명확한 부분집합이기 때문에 <code>FrozenSet[int]</code>는 <code>FrozenSet[float]</code>의 서브타입입니다.</li>
<li><strong><code>List[T]</code></strong> 는 불변입니다. <code>List[int]</code>의 값 집합이 <code>List[float]</code>의 값 집합의 부분집합이더라도, <code>List[int]</code>에는 <code>int</code>만 추가할 수 있기 때문에 <code>List[int]</code>는 <code>List[float]</code>의 서브타입이 아닙니다. 이는 가변(mutable) 타입에서 전형적인 상황입니다.</li>
<li><strong><code>Callable</code></strong> 타입은 반환 타입에는 공변이지만, 인자에는 반변입니다.
<ul>
<li><code>Callable[[], int]</code>는 <code>Callable[[], float]</code>의 서브타입입니다.</li>
<li><code>Callable[[float], None]</code>는 <code>Callable[[int], None]</code>의 서브타입입니다.
즉, <code>Manager</code>에 대한 급여를 계산할 수 있는 함수가 예상되는 상황에서 <code>Employee</code>에 대한 급여를 계산할 수 있는 <code>Callable[[Employee], Decimal]</code>도 허용됩니다.</li>
</ul>
</li>
</ul>
<p>사용자 정의 제네릭 타입에 대한 공변성/반변성은 매개변수로 사용되는 타입 변수의 정의에서 <code>covariant=True</code> 또는 <code>contravariant=True</code> 특수 키워드를 사용하여 선언할 수 있습니다. 타입은 기본적으로 불변입니다.</p>
<pre><code class="language-python">T_co = TypeVar('T_co', covariant=True)
class Box(Generic[T_co]): # 이 타입은 공변으로 선언됨
    def __init__(self, content: T_co) -> None:
        self._content = content
    def get_content(self) -> T_co:
        return self._content

T_contra = TypeVar('T_contra', contravariant=True)
class Sink(Generic[T_contra]): # 이 타입은 반변으로 선언됨
    def send_to_nowhere(self, data: T_contra) -> None:
        # ...
</code></pre>
<p>분산은 타입 변수의 속성이 아니라 제네릭 타입의 속성입니다.</p>
<h3>실용적인 측면 (Pragmatics)</h3>
<p>몇 가지 사항은 이론과 무관하지만 실제 사용을 더 편리하게 만듭니다.</p>
<ul>
<li>타입이 예상되는 곳에 <code>None</code> 대신 <code>type(None)</code>을 사용할 수 있습니다. 예: <code>Union[t1, None] == Union[t1, type(None)]</code>.</li>
<li><strong>타입 별칭 (Type aliases):</strong>
<pre><code class="language-python">Point = Tuple[float, float]
def distance(point: Point) -> float: ...
</code></pre>
</li>
<li><strong>문자열을 통한 전방 참조 (Forward references):</strong>
<pre><code class="language-python">class MyComparable:
    def compare(self, other: 'MyComparable') -> int: ...
</code></pre>
</li>
<li><strong>제약되지 않은(unconstrained), 제약된(constrained), 또는 바운드된(bounded) <code>TypeVar</code> 선언:</strong> <code>TypeVar('T', bound=complex)</code>와 같이 사용할 수 있습니다.</li>
<li><strong>주석 내 타입 선언 (Type declaration in comments):</strong>
<pre><code class="language-python">lst = [] # type: Sequence[int]
</code></pre>
</li>
<li><strong><code>cast(T, obj)</code> 사용:</strong> <code>zork = cast(Any, frobozz())</code>와 같이 사용할 수 있습니다.</li>
<li>오버로딩(overloading) 및 스텁 모듈(stub modules)과 같은 다른 사항은 PEP 484를 참조하십시오.</li>
</ul>
<h3><code>typing.py</code>에 미리 정의된 제네릭 타입 및 프로토콜 (Predefined generic types and Protocols in typing.py)</h3>
<p><code>typing.py</code> 모듈에서 제공되는 타입들은 다음과 같습니다.</p>
<ul>
<li><code>collections.abc</code>의 모든 것 (단, <code>Set</code>은 <code>AbstractSet</code>으로 이름 변경).</li>
<li><code>Dict</code>, <code>List</code>, <code>Set</code>, <code>FrozenSet</code> 등.</li>
<li><code>re.Pattern[AnyStr]</code>, <code>re.Match[AnyStr]</code>.</li>
<li><code>io.IO[AnyStr]</code>, <code>io.TextIO ~ io.IO[str]</code>, <code>io.BinaryIO ~ io.IO[bytes]</code>.</li>
</ul>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1962,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 483 - The Theory of Type Hints"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 22:28:39+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}],["$","section",null,{"className":"mt-12 border-t border-gray-200 pt-8","children":[["$","h3",null,{"className":"text-base font-semibold text-gray-900 mb-4","children":["Python"," 의 다른글"]}],["$","ul",null,{"className":"space-y-2 text-sm","children":[["$","li",null,{"className":"text-gray-500","children":["이전글"," ",["$","$L7",null,{"href":"/python/pep/482/","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Final] PEP 482 - Literature Overview for Type Hints"}]]}],["$","li",null,{"className":"text-gray-900 font-semibold","children":["현재글 : ","[Final] PEP 483 - The Theory of Type Hints"]}],["$","li",null,{"className":"text-gray-500","children":["다음글"," ",["$","$L7",null,{"href":"/python/pep/484/","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Final] PEP 484 - Type Hints"}]]}]]}]]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://blog.secrett2633.site/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://blog.secrett2633.site/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}]]
1:null
