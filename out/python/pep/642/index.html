<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/d6cea809dcbae606.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-61c2b369a48bb953.js"/><script src="/_next/static/chunks/fd9d1056-0395f68b8cc78a20.js" async=""></script><script src="/_next/static/chunks/23-706b53707bbf0661.js" async=""></script><script src="/_next/static/chunks/main-app-cf4c503f60a850f8.js" async=""></script><script src="/_next/static/chunks/231-467e37449c5a68fc.js" async=""></script><script src="/_next/static/chunks/app/layout-3497e95e26431168.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-a0fe0cc578429896.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2626<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 642 - Explicit Pattern Syntax for Structural Pattern Matching</h1><div class="page__meta"><time dateTime="2025-09-27 01:33:04+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0642/">PEP 642 - Explicit Pattern Syntax for Structural Pattern Matching</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 26-Sep-2020</p>
</blockquote>
<h2>PEP 642: 구조적 패턴 매칭을 위한 명시적 패턴 구문</h2>
<h3>초록 (Abstract)</h3>
<p>이 PEP는 PEP 634의 구조적 패턴 매칭(structural pattern matching)에 대한 대체 구문 제안을 다룹니다. 이 제안은 모든 캡처 패턴(capture patterns)과 값 제약(value constraints)에 명시적인 접두사를 요구합니다. 또한, 제안된 매핑 패턴(mapping pattern) 구문과 더 밀접하게 일치하는 인스턴스 속성 패턴(instance attribute patterns)을 위한 새로운 전용 구문을 제안합니다.</p>
<p>결과적으로 PEP 634의 구문보다 더 장황하지만, 기존 방식보다는 훨씬 간결합니다.</p>
<p>예를 들어, 다음 <code>match</code> 문은 2개의 항목 시퀀스, "host"와 "port" 키를 가진 매핑, "host"와 "port" 속성을 가진 객체, 또는 "host:port" 문자열에서 "host"와 "port" 세부 정보를 추출합니다. 후자의 세 경우 "port"는 선택 사항으로 간주합니다.</p>
<pre><code class="language-python">port = DEFAULT_PORT
match expr:
    case [as host, as port]:
        pass
    case {"host" as host, "port" as port}:
        pass
    case {"host" as host}:
        pass
    case object{.host as host, .port as port}:
        pass
    case object{.host as host}:
        pass
    case str{} as addr:
        host, __, optional_port = addr.partition(":")
        if optional_port:
            port = optional_port
    case __ as m:
        raise TypeError(f"Unknown address format: {m!r:.200}")
port = int(port)
</code></pre>
<p>이 PEP는 패턴 유형을 다음과 같이 분류할 것을 제안합니다.</p>
<ul>
<li><strong>와일드카드 패턴 (wildcard pattern):</strong> <code>__</code></li>
<li><strong>그룹 패턴 (group patterns):</strong> <code>(PTRN)</code></li>
<li><strong>값 제약 패턴 (value constraint patterns):</strong>
<ul>
<li>동등성 제약 (equality constraints): <code>== EXPR</code></li>
<li>동일성 제약 (identity constraints): <code>is EXPR</code></li>
</ul>
</li>
<li><strong>구조적 제약 패턴 (structural constraint patterns):</strong>
<ul>
<li>시퀀스 제약 패턴 (sequence constraint patterns): <code>[PTRN, as NAME, PTRN as NAME]</code></li>
<li>매핑 제약 패턴 (mapping constraint patterns): <code>{EXPR: PTRN, EXPR as NAME}</code></li>
<li>인스턴스 속성 제약 패턴 (instance attribute constraint patterns): <code>CLS{.NAME, .NAME: PTRN, .NAME == EXPR, .NAME as NAME}</code></li>
<li>클래스 정의 제약 패턴 (class defined constraint patterns): <code>CLS(PTRN, PTRN, **{.NAME, .NAME: PTRN, .NAME == EXPR, .NAME as NAME})</code></li>
</ul>
</li>
<li><strong>OR 패턴 (OR patterns):</strong> <code>PTRN | PTRN | PTRN</code></li>
<li><strong>AS 패턴 (AS patterns):</strong> <code>PTRN as NAME</code> (패턴 생략 시 <code>__</code> 의미)</li>
</ul>
<p>이 접근 방식의 목표는 다음과 같습니다.</p>
<ul>
<li>이름, 속성 조회, 리터럴 값 처리의 최적 기본 옵션을 미리 결정할 필요 없이, 패턴 매칭의 초기 형태를 개발 및 출시할 수 있도록 합니다.</li>
<li>패턴 매칭이 추상 구문 트리(Abstract Syntax Tree, AST) 수준에서 명시적으로 정의되도록 하여, 의미론(semantics)과 표면 구문(surface syntax) 사양을 명확하게 분리합니다.</li>
<li>"덕 타이핑(ducktyping)"을 위한 명확하고 간결한 구문을 정의하여, 일반 표현식에서도 동일한 객체에서 여러 속성을 더 쉽게 검색하는 방법으로 채택될 수 있습니다.</li>
</ul>
<h3>다른 PEP와의 관계 (Relationship with other PEPs)</h3>
<p>이 PEP는 PEP 634에 의존하면서도 경쟁합니다. PEP 642의 저자는 <code>match</code> 문이 학습 과정에 추가적인 복잡성을 더하더라도 언어에 가치 있는 추가가 될 것이라는 점에는 동의하지만, "단순 이름(simple name) vs. 리터럴 또는 속성 조회"가 패턴 매칭에서 이름 바인딩(name binding)과 값 조회(value lookup) 작업 간의 적절한 구문적 구별을 제공한다는 생각에는 동의하지 않습니다.</p>
<p>이 PEP는 PEP 640의 정신(이름 바인딩을 건너뛰기 위한 와일드카드 패턴이 <code>match</code> 패턴뿐만 아니라 모든 곳에서 지원되어야 한다는 것)에는 동의하지만, 와일드카드 구문으로 <code>?</code> 대신 <code>__</code>를 제안합니다.</p>
<h3>동기 (Motivation)</h3>
<p>원래 PEP 622 (이후 PEP 634, PEP 635, PEP 636으로 분할됨)는 구문 설계에 명시되지 않은 필수적인 가정을 포함했습니다: 일반 표현식이나 기존 할당 대상 구문이 <code>match</code> 패턴에 사용되는 구문의 적절한 기반을 제공하지 못한다는 것입니다. PEP 642의 저자는 이러한 가정을 재검토하고, 할당 대상 구문을 기반으로 한 패턴 매칭 구문이 내재된 모순 없이 가능하다는 것을 보여주려 했습니다.</p>
<p>그러나 검토 과정에서 PEP 634의 구문 제안에 대한 의구심을 불러일으킬 만큼 중요한 모순들이 제기되었습니다. 이에 따라 이 PEP의 목표는 완전히 역전되었습니다. 즉, 할당과 패턴 매칭 간의 유사성을 강조하기보다는, 할당 대상 구문이 전혀 재사용되지 않도록 하여 기존 경험을 바탕으로 새로운 구조에 대해 잘못된 추론을 할 가능성을 줄이는 데 중점을 두게 되었습니다.</p>
<p>최종적으로, 이 PEP의 저자는 PEP 20의 "명시적인 것이 암시적인 것보다 낫다(Explicit is better than implicit).", "특별한 경우는 규칙을 깰 만큼 특별하지 않다(Special cases aren't special enough to break the rules).", "모호함에 직면했을 때, 추측하려는 유혹을 거부하라(In the face of ambiguity, refuse the temptation to guess)."라는 원칙을 깊이 고민했습니다. 명시적인 구문으로 시작하면 나중에 구문 단축키를 추가할 수 있지만, 약칭 형태만으로 시작하면 미래 릴리스에서 이러한 결정을 재검토할 방법이 없기 때문입니다.</p>
<h3>명세 (Specification)</h3>
<p>이 PEP는 PEP 634의 전체적인 <code>match</code>/<code>case</code> 문 구조와 의미론을 유지하지만, 사용자 의도가 패턴 매칭 컨텍스트에서 추론될 필요 없이 구체적인 구문에서 명시적으로 지정되도록 여러 변경 사항을 제안합니다.</p>
<p>제안된 추상 구문 트리(Abstract Syntax Tree, AST)에서도 의미론은 항상 명시적이며, 추론이 필요하지 않습니다.</p>
<h4>The Match Statement</h4>
<p><code>match</code> 문은 <code>match</code> 키워드 뒤에 주어(subject) 표현식이 오고, 콜론(<code>:</code>)과 들여쓰기된 <code>case</code> 블록들이 이어지는 구조입니다.</p>
<pre><code>match_stmt: "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT
</code></pre>
<p><code>case</code> 블록은 <code>case</code> 키워드 뒤에 패턴이 오고, 선택적으로 <code>if</code> 가드(guard)가 붙은 후 콜론(<code>:</code>)과 블록이 이어집니다.</p>
<pre><code>case_block: "case" (guarded_pattern | open_pattern) ':' block
guarded_pattern: closed_pattern 'if' named_expression
</code></pre>
<p>PEP 634와 마찬가지로, <code>match</code>와 <code>case</code>는 소프트 키워드(soft keywords)입니다. 즉, 다른 문법 컨텍스트에서는 예약어가 아니며, 변수나 인자 이름으로 사용될 수 있습니다.</p>
<p>PEP 634와 달리, 이 PEP에서는 패턴이 추상 구문 트리에서 새로운 종류의 노드로 명시적으로 정의됩니다. 이는 표면 구문이 기존 표현식 노드와 공유되더라도, 파서(parser)가 별개의 추상 노드를 방출한다는 의미입니다.</p>
<h4>Match Semantics (매치 의미론)</h4>
<p>이 PEP는 PEP 634에서 제안된 전반적인 패턴 매칭 의미론을 대부분 유지합니다.</p>
<p>패턴에 대한 제안된 구문은 크게 변경되었으며, 아래에서 자세히 설명합니다. 또한, <code>__match_args__</code>를 <code>None</code>으로 설정하는 모든 유형에 적용되도록 하여 내장 유형에 대한 특별한 경우 처리를 없애기 위해 클래스 정의 제약(class defined constraints, PEP 634의 클래스 패턴)의 의미론에 일부 변경 사항이 제안되었습니다.</p>
<h4>Guards (가드)</h4>
<p>이 PEP는 PEP 634에서 제안된 가드 절(guard clause) 의미론을 유지합니다. 그러나, 가드 절이 있을 경우 <code>case</code> 패턴이 <code>closed pattern</code>이어야 한다는 요구 사항을 추가하여 구문이 약간 변경되었습니다. 이는 패턴이 끝나고 가드 절이 시작되는 지점을 독자가 더 명확하게 이해할 수 있도록 합니다.</p>
<h4>Irrefutable case blocks (반박 불가능한 case 블록)</h4>
<p>이 PEP에서는 <code>capture pattern</code>이 <code>AS pattern</code>과 별개의 개념으로 더 이상 존재하지 않으므로, 반박 불가능한 <code>case</code> 블록의 정의가 PEP 634와 비교하여 약간 변경됩니다.</p>
<ul>
<li>와일드카드 패턴은 반박 불가능합니다.</li>
<li>좌변이 반박 불가능한 AS 패턴은 반박 불가능합니다.</li>
<li>적어도 하나의 반박 불가능한 패턴을 포함하는 OR 패턴은 반박 불가능합니다.</li>
<li>괄호로 묶인 반박 불가능한 패턴은 반박 불가능합니다.</li>
<li><code>case</code> 블록은 가드가 없고 그 패턴이 반박 불가능하면 반박 불가능한 것으로 간주됩니다.</li>
<li><code>match</code> 문은 최대 하나의 반박 불가능한 <code>case</code> 블록을 가질 수 있으며, 이는 마지막에 와야 합니다.</li>
</ul>
<h4>Patterns (패턴)</h4>
<p>패턴의 최상위 표면 구문은 다음과 같습니다.</p>
<pre><code>open_pattern: # Pattern may use multiple tokens with no closing delimiter
    | as_pattern
    | or_pattern
as_pattern: [closed_pattern] pattern_as_clause
or_pattern: '|'.simple_pattern+
simple_pattern: # Subnode where "as" and "or" patterns must be parenthesised
    | closed_pattern
    | value_constraint
closed_pattern: # Require a single token or a closing delimiter in pattern
    | wildcard_pattern
    | group_pattern
    | structural_constraint
</code></pre>
<p><code>open pattern</code>의 사용은 최상위 <code>case</code> 절과 <code>group pattern</code> 내에서 괄호로 묶였을 때로 제한됩니다.</p>
<p>패턴의 추상 구문은 어떤 요소가 서브패턴(subpatterns)이고 어떤 요소가 서브표현식(subexpressions) 또는 식별자(identifiers)인지 명시적으로 나타냅니다.</p>
<h5>AS Patterns (AS 패턴)</h5>
<p><code>AS pattern</code>은 <code>as</code> 키워드 왼쪽에 있는 <code>closed pattern</code>을 주어(subject)와 매치합니다. 매치에 실패하면 <code>AS pattern</code>도 실패합니다. 성공하면 <code>AS pattern</code>은 주어를 <code>as</code> 키워드 오른쪽에 있는 이름에 바인딩하고 성공합니다.</p>
<p>패턴이 주어지지 않으면 와일드카드 패턴(<code>__</code>)이 암시됩니다. 혼동을 피하기 위해 이중 밑줄(<code>__</code>)은 캡처 대상(capture target)으로 허용되지 않습니다.</p>
<h5>OR Patterns (OR 패턴)</h5>
<p>두 개 이상의 패턴이 수직 막대(<code>|</code>)로 구분되면 이를 <code>OR pattern</code>이라고 합니다. <code>OR pattern</code>은 각 서브패턴을 순서대로 주어에 매치하여 성공하는 첫 번째 서브패턴에서 성공으로 간주됩니다. 모든 서브패턴이 실패하면 <code>OR pattern</code>도 실패합니다.</p>
<h5>Value constraints (값 제약)</h5>
<p><code>value constraint</code>는 PEP 634의 <code>literal patterns</code>과 <code>value patterns</code>를 대체합니다.</p>
<ul>
<li><strong>동등성 제약 (Equality constraints):</strong> <code>== EXPR</code> 형식으로 작성되며, 주어 값이 주어진 <code>EXPR</code>과 동등한지 확인합니다.</li>
<li><strong>동일성 제약 (Identity constraints):</strong> <code>is EXPR</code> 형식으로 작성되며, 주어 값이 <code>EXPR</code>과 정확히 같은 객체인지 확인합니다.</li>
</ul>
<p>비교될 표현식은 대부분 단일 토큰(예: 이름, 문자열, 숫자, 내장 상수) 또는 닫는 구분자로 끝나야 하는 표현식으로 제한됩니다.</p>
<h5>Wildcard Pattern (와일드카드 패턴)</h5>
<p>와일드카드 패턴은 <code>__</code>로 작성되며 항상 성공합니다. PEP 634와 마찬가지로 어떤 이름도 바인딩하지 않습니다. PEP 634가 다른 언어와의 일관성을 위해 단일 밑줄(<code>_</code>)을 와일드카드 패턴으로 선택한 반면, 이 PEP는 이중 밑줄(<code>__</code>)을 선택합니다. <code>__</code>는 전체 언어에 걸쳐 일관성을 유지할 수 있는 더 명확한 경로를 가지고 있기 때문입니다.</p>
<h5>Group Patterns (그룹 패턴)</h5>
<p><code>group pattern</code>은 괄호 <code>()</code>로 <code>open pattern</code>을 묶는 형태입니다. 추가적인 구문이 없으며, 추상 구문 트리에는 표현되지 않습니다. 이는 사용자가 의도된 그룹화를 강조하거나 문법이 <code>closed pattern</code>을 요구할 때 <code>open pattern</code>을 중첩할 수 있도록 합니다.</p>
<h5>Structural constraints (구조적 제약)</h5>
<p><code>structural constraint</code>는 복합 객체에 대한 단언(assertion)을 만들고 그로부터 값을 추출하는 데 사용되는 패턴입니다. 이러한 패턴은 중첩된 <code>AS pattern</code>을 사용하거나 패턴 정의에 포함된 <code>pattern_as_clause</code> 요소를 통해 여러 값을 바인딩할 수 있습니다.</p>
<ul>
<li><strong>Sequence constraints (시퀀스 제약):</strong> <code>[]</code> 대괄호를 사용하여 시퀀스 내의 항목을 확인하고 선택적으로 추출할 수 있습니다. <code>collections.abc.Sequence</code>의 인스턴스가 아니거나 <code>str</code>, <code>bytes</code>, <code>bytearray</code> 인스턴스인 경우 실패합니다.</li>
<li><strong>Mapping constraints (매핑 제약):</strong> <code>{}</code> 중괄호를 사용하여 시퀀스 내의 키와 값을 확인하고 값을 선택적으로 추출할 수 있습니다. <code>collections.abc.Mapping</code>의 인스턴스가 아닌 경우 실패합니다.</li>
<li><strong>Instance attribute constraints (인스턴스 속성 제약):</strong> <code>CLS{.NAME, ...}</code> 형식으로 작성되며, 인스턴스의 타입을 확인하고 속성을 선택적으로 추출할 수 있습니다. <code>isinstance()</code>를 사용하여 <code>name_or_attr</code>의 인스턴스인지 확인합니다.</li>
<li><strong>Class defined constraints (클래스 정의 제약):</strong> <code>name_or_attr()</code> 또는 <code>name_or_attr(positional_patterns, **{attrs_constraint_elements})</code> 형식으로 작성됩니다. 클래스에 공통 속성 시퀀스를 지정하고, 매번 속성 이름을 지정할 필요 없이 위치 기반으로 확인할 수 있도록 합니다. <code>__match_args__</code> 속성을 정의하는 유형만 클래스 정의 패턴에서 사용할 수 있습니다.</li>
</ul>
<h3>설계 논의 (Design Discussion)</h3>
<h4>패턴 매칭에서 단순 이름의 명시적 한정자 요구 (Requiring explicit qualification of simple names in match patterns)</h4>
<p>이 PEP의 첫 번째 버전은 PEP 634의 기본 전제, 즉 이터러블 언패킹(iterable unpacking) 구문이 패턴 매칭을 위한 새로운 구문을 정의하는 데 좋은 기반이 될 것이라는 점을 받아들였습니다. 그러나 검토 과정에서 이 핵심 가정에서 직접적으로 발생하는 두 가지 주요하고 한 가지 사소한 모호성 문제가 강조되었습니다.</p>
<p>세 번째 개정안은 이러한 문제를 해결하기 위해 이터러블 언패킹 구문과의 일치를 포기하고, 변수 조회를 제외한 모든 단순 이름 사용에 선행 시그널(sigil) 또는 키워드를 사용하여 한정할 것을 요구했습니다.</p>
<ul>
<li><code>as NAME</code>: 지역 변수 바인딩</li>
<li><code>.NAME</code>: 속성 조회</li>
<li><code>== NAME</code>: 변수 조회</li>
<li><code>is NAME</code>: 변수 조회</li>
<li>다른 모든 사용: 변수 조회</li>
</ul>
<p>이 접근 방식의 주요 장점은 패턴 내에서 단순 이름의 해석을 지역적인 활동으로 만든다는 것입니다. 선행 <code>as</code>는 이름 바인딩을, 선행 <code>.</code>은 속성 조회를 나타내며, 그 외의 모든 것은 변수 조회입니다.</p>
<h4>추측하려는 유혹에 저항하기 (Resisting the temptation to guess)</h4>
<p>PEP 635는 다른 언어에서 패턴 매칭이 사용되는 방식을 살펴보고, 파이썬에서 패턴 매칭이 어떻게 사용될지에 대한 그럴듯한 예측을 하려고 시도했습니다. 이 PEP는 이러한 예측이 타당하다고 보지만, 미리 추측할 필요는 없다고 주장합니다. 대신, <code>as</code>, <code>==</code>, <code>is</code>와 같은 접두사 마커를 사용하여 사용자가 의도를 명시적으로 밝히도록 요구하는 더 명시적인 구문으로 시작하고, 몇 년 후 파이썬에서 패턴 매칭이 실제로 어떻게 사용되는지에 따라 상황을 재평가할 것을 제안합니다.</p>
<h4>로컬 변수의 속성 조회 캐싱과의 상호작용 (Interaction with caching of attribute lookups in local variables)</h4>
<p>이 PEP와 PEP 634의 주요 변경 사항 중 하나는 동등성 제약 조회에 <code>== EXPR</code>를 사용하는 것입니다. PEP 634의 값 및 캡처 패턴 구문은 마커 접두사를 생략하므로, 로컬 변수를 사용하여 속성 조회를 대체하는 리팩토링 시 의미론적 동등성이 깨지는 문제가 발생할 수 있습니다. 이 PEP는 <code>== name</code>을 사용하여 결과를 값 제약으로 강제 해석하고, <code>as name</code>을 사용하여 이름 바인딩을 지정함으로써 이러한 리팩토링 시에도 원래의 의미론이 유지되도록 합니다.</p>
<h4>값 제약 접두사로 기존 비교 연산자 사용 (Using existing comparison operators as the value constraint prefix)</h4>
<p>초기 버전에서는 <code>?</code>를 동등성 제약 접두사로, <code>?is</code>를 동일성 제약 접두사로 제안했으나, Steven D'Aprano는 기존 비교 연산자(<code>==</code> 및 <code>is</code>)를 대신 사용할 것을 제안했습니다. 이 PEP는 이 아이디어를 채택하여 새로운 기호를 도입하는 대신 기존 연산자를 활용합니다.</p>
<h4>와일드카드 패턴 마커로 <code>__</code> 사용 (Using __ as the wildcard pattern marker)</h4>
<p>PEP 635는 와일드카드 패턴 마커로 <code>?</code>를 도입하는 것이 좋지 않다고 주장했습니다. PEP 634에서 <code>_</code>를 와일드카드 패턴으로 선택한 것 역시 국제화(i18n) 관련 사용 사례 등으로 인해 파이썬의 다른 부분과의 일관성을 유지하기 어렵다는 문제가 제기되었습니다.</p>
<p>이 PEP는 <code>__</code>를 와일드카드 패턴 마커로 제안합니다. <code>__</code>는 현재 파이썬 코드에서 "이 값이 필요하지 않음"을 나타내는 대안으로 사용될 수 있으며, <code>_</code>와 달리 다른 사용 사례가 부족하므로, 향후 <code>__</code>를 파이썬의 모든 곳에서 "이름 바인딩 건너뛰기"를 의미하는 일반적인 하드 키워드(hard keyword)로 만들 수 있는 그럴듯한 경로를 제공합니다. 또한, <code>__</code>로 시작하는 이름은 이미 언어 내부적으로 예약되어 있다는 점도 이러한 접근 방식과 일치합니다.</p>
<h4>추상 구문 트리에서 패턴을 명시적으로 표현 (Representing patterns explicitly in the Abstract Syntax Tree)</h4>
<p>PEP 634는 <code>match</code> 문이 AST에서 어떻게 표현되어야 하는지 명시적으로 논의하지 않았습니다. 그 결과, PEP 634의 참조 구현은 패턴을 표현식 노드로 나타내는 중대한 설계 결함을 포함했습니다.</p>
<p>이 PEP는 AST에 새로운 명시적인 "pattern" 노드를 정의합니다. 이를 통해 패턴과 허용되는 서브노드를 AST 자체에 명시적으로 정의할 수 있으며, 새로운 기능을 구현하는 코드를 더 명확하게 만들고, C 컴파일러가 코드 생성기가 패턴을 처리하는지 표현식을 처리하는지 추적하는 데 더 많은 도움을 제공할 수 있도록 합니다.</p>
<h4>시퀀스 패턴 변경 (Changes to sequence patterns)</h4>
<p>이 PEP는 PEP 634와 비교하여 시퀀스 패턴에 한 가지 주목할 만한 변경 사항을 적용합니다.</p>
<ul>
<li>오직 대괄호 <code>[]</code> 형태의 시퀀스 패턴만 지원됩니다. 열린 형태(구분자 없음)나 튜플 스타일(괄호 <code>()</code>를 구분자로 사용) 시퀀스 패턴은 지원되지 않습니다.</li>
</ul>
<p>이는 이터러블 언패킹 구문과의 일관성을 위해 원래 구문 제안에 포함되었던 구문 유연성을 더 이상 유지할 필요가 없다는 판단에 따른 것입니다.</p>
<h4>매핑 패턴 변경 (Changes to mapping patterns)</h4>
<p>이 PEP는 PEP 634와 비교하여 매핑 패턴에 두 가지 주목할 만한 변경 사항을 적용합니다.</p>
<ul>
<li>값 캡처는 <code>KEY as NAME</code>으로 작성됩니다.</li>
<li>더 넓은 범위의 키가 허용됩니다: 리터럴과 속성 참조뿐만 아니라 모든 "closed expression"이 허용됩니다.</li>
</ul>
<p>첫 번째 변경 사항은 서브표현식이나 패턴의 오른쪽에 대상 이름이 있는 모든 바인딩 작업이 <code>as</code> 키워드를 사용하도록 보장하는 일환입니다. 두 번째 변경 사항은 기존 표현식 처리 메커니즘을 재사용하여 파서와 코드 생성기 코드를 단순화하기 위한 것입니다.</p>
<h4>클래스 패턴 변경 (Changes to class patterns)</h4>
<p>이 PEP는 PEP 634와 비교하여 클래스 패턴에 여러 가지 주목할 만한 변경 사항을 적용합니다.</p>
<ul>
<li>클래스 인스턴스화와의 구문적 일치는 오해의 소지가 있고 도움이 되지 않는 것으로 판단되어 폐기되었습니다. 대신, 매핑 패턴에서 영감을 받은 새로운 전용 구문이 도입되었습니다.</li>
<li>어떤 클래스에도 작동하는 단순한 덕 타이핑(ducktyping)을 위한 새로운 전용 구문이 도입되었습니다.</li>
<li>다양한 내장 및 표준 라이브러리 유형에 대한 특별한 경우 처리는 <code>__match_args__</code> 속성이 <code>None</code>으로 설정되어 있는지 확인하는 일반적인 검사로 보완됩니다.</li>
</ul>
<p>이러한 변경 사항은 <code>as</code> 키워드를 사용하여 바인딩 작업을 명시하고, 패턴 내에서 단순 이름 사용에 접두사를 의무화하여 의도를 명확히 하는 데 중점을 둡니다. 또한, 클래스 패턴이 속성 일치에 초점을 맞추도록 하여 클래스 인스턴스화와의 혼동을 피하고, 파이썬에서 흔히 사용되는 덕 타이핑 검사를 더 쉽게 구현할 수 있도록 합니다.</p>
<h3>보류된 아이디어 (Deferred Ideas)</h3>
<p>이 PEP는 미래에 고려할 수 있는 몇 가지 아이디어를 제시합니다.</p>
<ul>
<li><strong>추론된 값 제약 (Inferred value constraints):</strong> 현재 이 PEP는 추론된 동등성 및 동일성 제약을 미래에 추가할 가능성을 배제하지 않습니다.</li>
<li><strong>일부 필수 괄호 선택 사항화 (Making some required parentheses optional):</strong> 현재 PEP는 잠재적인 모호함에 직면했을 때 괄호를 필수로 요구하는 경향이 있지만, 나중에 제한을 완화하는 것은 하위 호환 가능한 변경이므로 개별 사례별로 검토할 수 있습니다.</li>
<li><strong>복소수 리터럴을 <code>closed expression</code>으로 허용 (Accepting complex literals as closed expressions):</strong> 현재 복소수 리터럴은 괄호로 묶어야 사용 가능하지만, 파서 수준에서 직접 처리하는 방법이 논의 중입니다.</li>
<li><strong>패턴 매칭에서 부정 제약 허용 (Allowing negated constraints in match patterns):</strong> <code>!= expr</code> 또는 <code>is not expr</code>와 같은 부정 제약을 허용하는 것이 논의되었으나, 충분히 자주 사용될지는 불분명하여 보류되었습니다.</li>
<li><strong>패턴 매칭에서 멤버십 확인 허용 (Allowing membership checks in match patterns):</strong> <code>in container</code>와 같은 멤버십 확인 구문을 패턴 매칭에 추가하는 것이 제안되었으나, 별도의 제안으로 연기되었습니다. 이는 <code>match</code> 문이 언어에 가치 있는 추가가 되는 데 필수적이지 않기 때문입니다.</li>
<li><strong>인스턴스 속성 제약에 대한 기본 타입 추론 (Inferring a default type for instance attribute constraints):</strong> <code>object{.ATTR}</code>에서 <code>object</code>를 생략하고 <code>{.ATTR}</code>로 작성할 수 있도록 하는 아이디어가 논의되었으나, 매핑 패턴과 인스턴스 속성 패턴을 시각적으로 구분하기 어렵게 만들 수 있어 보류되었습니다.</li>
<li><strong>시퀀스 패턴의 특별한 경우 피하기 (Avoiding special cases in sequence patterns):</strong> <code>str</code>, <code>bytes</code>, <code>bytearray</code>가 시퀀스 패턴에 절대 매치되지 않도록 특별 처리하는 것을 <code>collections.abc.AtomicSequence</code>와 같은 새로운 추상 베이스 클래스를 정의하여 제거하는 방안이 논의되었습니다.</li>
<li><strong>인스턴스에서 여러 속성을 검색하는 표현식 구문 (Expression syntax to retrieve multiple attributes from an instance):</strong> <code>host, port = obj{.host, .port}</code>와 같이 단일 표현식으로 객체에서 여러 속성을 검색하는 일반적인 구문의 기초로 인스턴스 속성 패턴 구문을 사용할 수 있다는 아이디어가 언급되었습니다.</li>
</ul>
<h3>거부된 아이디어 (Rejected Ideas)</h3>
<p>이 PEP에서 거부된 아이디어는 다음과 같습니다.</p>
<ul>
<li><strong>값 제약 및 매핑 패턴 키에서 허용되는 표현식 제한 (Restricting permitted expressions in value constraints and mapping pattern keys):</strong> PEP 634와 같이 값 제약 및 매핑 패턴 키에서 속성 조회 및 상수 리터럴만 허용하는 것을 제한하는 것에 대한 명확한 런타임 이점이 없으므로, 이 PEP는 모든 종류의 <code>primary expression</code>과 높은 우선순위의 단항 연산자(<code>+</code>, <code>-</code>, <code>~</code>)를 허용합니다.</li>
<li><strong>매핑 패턴 키에 제약 접두사 마커 사용 의무화 (Requiring the use of constraint prefix markers for mapping pattern keys):</strong> 초기 제안에서는 매핑 패턴 키에 값 제약처럼 <code>==</code>와 같은 접두사를 요구했으나, 구문적으로 노이즈가 많고 표현식의 위치만으로도 충분한 정보가 전달되므로 생략되었습니다.</li>
<li><strong>매핑 값 제약에서 키/값 구분자 생략 허용 (Allowing the key/value separator to be omitted for mapping value constraints):</strong> <code>case {0 == 0}:</code>과 같이 컴파일러는 의도를 알 수 있지만, 사람이 읽기에는 "0 == 0"이라는 자명한 비교 연산으로 보일 수 있는 모호한 구문이 될 수 있으므로, 키/값 구분자(<code>:</code>)를 포함하는 것이 더 명확하다고 판단하여 허용되지 않았습니다.</li>
</ul>
<h3>참조 구현 (Reference Implementation)</h3>
<p>이 PEP에 대한 참조 구현 초안은 PEP 634의 참조 구현에서 파생되었습니다.</p>
<h3>변경 사항 요약 (Summary of changes relative to PEP 634)</h3>
<p>PEP 634와 비교하여 이 PEP는 다음과 같은 주요 변경 사항을 적용합니다.</p>
<ul>
<li>패턴에 <code>expr</code> 유형을 재사용하는 대신, AST에 새로운 <code>pattern</code> 유형을 정의합니다.</li>
<li><code>_</code> (단일 밑줄)에서 <code>__</code> (이중 밑줄)로 와일드카드 패턴이 변경되고, AST에 전용 <code>MatchAlways</code> 노드를 갖습니다.</li>
<li>의도 모호성으로 인해 <code>value patterns</code> 및 <code>literal patterns</code>가 제거됩니다.</li>
<li>새로운 표현식 범주인 "closed expressions"가 도입됩니다.</li>
<li>새로운 패턴 유형인 "value constraint patterns"가 도입되고, <code>==</code> 및 <code>is</code>를 접두사 마커로 사용합니다.</li>
<li>의도 모호성으로 인해 <code>capture patterns</code>가 제거됩니다. 모든 캡처 작업은 <code>as</code> 키워드를 사용하며 <code>MatchAs</code> 또는 <code>MatchRestOfSequence</code> 노드로 표현됩니다.</li>
<li>AS 패턴의 간결성을 위해 <code>as NAME</code>은 <code>__ as NAME</code>과 동일한 의미로 허용됩니다.</li>
<li>시퀀스 패턴은 대괄호 <code>[]</code> 사용을 필수로 변경합니다.</li>
<li>매핑 패턴은 키로 임의의 <code>closed expression</code>을 허용합니다.</li>
<li>매핑 패턴의 간결성을 위해 <code>KEY : __ as NAME</code>을 <code>KEY as NAME</code>으로 단축할 수 있습니다.</li>
<li>클래스 패턴은 속성 매칭에 개별 키워드 인자 구문을 더 이상 사용하지 않고, 매핑 패턴 구문의 변형과 함께 이중 별표 구문을 사용합니다.</li>
<li>클래스 패턴은 <code>__match_args__</code>가 <code>None</code>으로 설정된 모든 클래스를 단일 위치 패턴을 받아 전체 객체와 매치하는 것으로 처리합니다.</li>
<li>덕 타이핑을 위한 전용 구문이 추가됩니다 (<code>MatchAttrs</code> 노드).</li>
</ul>
<hr>
<p>이 PEP 642는 최종적으로 거부되었지만, 구조적 패턴 매칭 구문의 설계 과정에서 발생할 수 있는 모호성과 이를 해결하기 위한 명시성 원칙의 중요성을 잘 보여줍니다. 실제 파이썬 3.10에 도입된 패턴 매칭은 PEP 634의 구문을 기반으로 하고 있습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/641/">[Rejected] PEP 641 - Using an underscore in the version portion of Python 3.10 compatibility tags</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Rejected] PEP 642 - Explicit Pattern Syntax for Structural Pattern Matching</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/643/">[Final] PEP 643 - Metadata for Package Source Distributions</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-61c2b369a48bb953.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/d6cea809dcbae606.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-3497e95e26431168.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-a0fe0cc578429896.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/642\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d6cea809dcbae606.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"uXVO9cTH_KJHTsIHFmRuq\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/642/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/642\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"642\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/642\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"e:I[646,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-a0fe0cc578429896.js\"],\"default\"]\nd:T79bb,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0642/\"\u003ePEP 642 - Explicit Pattern Syntax for Structural Pattern Matching\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 26-Sep-2020\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 642: 구조적 패턴 매칭을 위한 명시적 패턴 구문\u003c/h2\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 PEP 634의 구조적 패턴 매칭(structural pattern matching)에 대한 대체 구문 제안을 다룹니다. 이 제안은 모든 캡처 패턴(capture patterns)과 값 제약(value constraints)에 명시적인 접두사를 요구합니다. 또한, 제안된 매핑 패턴(mapping pattern) 구문과 더 밀접하게 일치하는 인스턴스 속성 패턴(instance attribute patterns)을 위한 새로운 전용 구문을 제안합니다.\u003c/p\u003e\n\u003cp\u003e결과적으로 PEP 634의 구문보다 더 장황하지만, 기존 방식보다는 훨씬 간결합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 다음 \u003ccode\u003ematch\u003c/code\u003e 문은 2개의 항목 시퀀스, \"host\"와 \"port\" 키를 가진 매핑, \"host\"와 \"port\" 속성을 가진 객체, 또는 \"host:port\" 문자열에서 \"host\"와 \"port\" 세부 정보를 추출합니다. 후자의 세 경우 \"port\"는 선택 사항으로 간주합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eport = DEFAULT_PORT\r\nmatch expr:\r\n    case [as host, as port]:\r\n        pass\r\n    case {\"host\" as host, \"port\" as port}:\r\n        pass\r\n    case {\"host\" as host}:\r\n        pass\r\n    case object{.host as host, .port as port}:\r\n        pass\r\n    case object{.host as host}:\r\n        pass\r\n    case str{} as addr:\r\n        host, __, optional_port = addr.partition(\":\")\r\n        if optional_port:\r\n            port = optional_port\r\n    case __ as m:\r\n        raise TypeError(f\"Unknown address format: {m!r:.200}\")\r\nport = int(port)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 PEP는 패턴 유형을 다음과 같이 분류할 것을 제안합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e와일드카드 패턴 (wildcard pattern):\u003c/strong\u003e \u003ccode\u003e__\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e그룹 패턴 (group patterns):\u003c/strong\u003e \u003ccode\u003e(PTRN)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e값 제약 패턴 (value constraint patterns):\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e동등성 제약 (equality constraints): \u003ccode\u003e== EXPR\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e동일성 제약 (identity constraints): \u003ccode\u003eis EXPR\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e구조적 제약 패턴 (structural constraint patterns):\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e시퀀스 제약 패턴 (sequence constraint patterns): \u003ccode\u003e[PTRN, as NAME, PTRN as NAME]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e매핑 제약 패턴 (mapping constraint patterns): \u003ccode\u003e{EXPR: PTRN, EXPR as NAME}\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e인스턴스 속성 제약 패턴 (instance attribute constraint patterns): \u003ccode\u003eCLS{.NAME, .NAME: PTRN, .NAME == EXPR, .NAME as NAME}\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e클래스 정의 제약 패턴 (class defined constraint patterns): \u003ccode\u003eCLS(PTRN, PTRN, **{.NAME, .NAME: PTRN, .NAME == EXPR, .NAME as NAME})\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOR 패턴 (OR patterns):\u003c/strong\u003e \u003ccode\u003ePTRN | PTRN | PTRN\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAS 패턴 (AS patterns):\u003c/strong\u003e \u003ccode\u003ePTRN as NAME\u003c/code\u003e (패턴 생략 시 \u003ccode\u003e__\u003c/code\u003e 의미)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 접근 방식의 목표는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이름, 속성 조회, 리터럴 값 처리의 최적 기본 옵션을 미리 결정할 필요 없이, 패턴 매칭의 초기 형태를 개발 및 출시할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003e패턴 매칭이 추상 구문 트리(Abstract Syntax Tree, AST) 수준에서 명시적으로 정의되도록 하여, 의미론(semantics)과 표면 구문(surface syntax) 사양을 명확하게 분리합니다.\u003c/li\u003e\n\u003cli\u003e\"덕 타이핑(ducktyping)\"을 위한 명확하고 간결한 구문을 정의하여, 일반 표현식에서도 동일한 객체에서 여러 속성을 더 쉽게 검색하는 방법으로 채택될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e다른 PEP와의 관계 (Relationship with other PEPs)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 PEP 634에 의존하면서도 경쟁합니다. PEP 642의 저자는 \u003ccode\u003ematch\u003c/code\u003e 문이 학습 과정에 추가적인 복잡성을 더하더라도 언어에 가치 있는 추가가 될 것이라는 점에는 동의하지만, \"단순 이름(simple name) vs. 리터럴 또는 속성 조회\"가 패턴 매칭에서 이름 바인딩(name binding)과 값 조회(value lookup) 작업 간의 적절한 구문적 구별을 제공한다는 생각에는 동의하지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 PEP 640의 정신(이름 바인딩을 건너뛰기 위한 와일드카드 패턴이 \u003ccode\u003ematch\u003c/code\u003e 패턴뿐만 아니라 모든 곳에서 지원되어야 한다는 것)에는 동의하지만, 와일드카드 구문으로 \u003ccode\u003e?\u003c/code\u003e 대신 \u003ccode\u003e__\u003c/code\u003e를 제안합니다.\u003c/p\u003e\n\u003ch3\u003e동기 (Motivation)\u003c/h3\u003e\n\u003cp\u003e원래 PEP 622 (이후 PEP 634, PEP 635, PEP 636으로 분할됨)는 구문 설계에 명시되지 않은 필수적인 가정을 포함했습니다: 일반 표현식이나 기존 할당 대상 구문이 \u003ccode\u003ematch\u003c/code\u003e 패턴에 사용되는 구문의 적절한 기반을 제공하지 못한다는 것입니다. PEP 642의 저자는 이러한 가정을 재검토하고, 할당 대상 구문을 기반으로 한 패턴 매칭 구문이 내재된 모순 없이 가능하다는 것을 보여주려 했습니다.\u003c/p\u003e\n\u003cp\u003e그러나 검토 과정에서 PEP 634의 구문 제안에 대한 의구심을 불러일으킬 만큼 중요한 모순들이 제기되었습니다. 이에 따라 이 PEP의 목표는 완전히 역전되었습니다. 즉, 할당과 패턴 매칭 간의 유사성을 강조하기보다는, 할당 대상 구문이 전혀 재사용되지 않도록 하여 기존 경험을 바탕으로 새로운 구조에 대해 잘못된 추론을 할 가능성을 줄이는 데 중점을 두게 되었습니다.\u003c/p\u003e\n\u003cp\u003e최종적으로, 이 PEP의 저자는 PEP 20의 \"명시적인 것이 암시적인 것보다 낫다(Explicit is better than implicit).\", \"특별한 경우는 규칙을 깰 만큼 특별하지 않다(Special cases aren't special enough to break the rules).\", \"모호함에 직면했을 때, 추측하려는 유혹을 거부하라(In the face of ambiguity, refuse the temptation to guess).\"라는 원칙을 깊이 고민했습니다. 명시적인 구문으로 시작하면 나중에 구문 단축키를 추가할 수 있지만, 약칭 형태만으로 시작하면 미래 릴리스에서 이러한 결정을 재검토할 방법이 없기 때문입니다.\u003c/p\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 PEP 634의 전체적인 \u003ccode\u003ematch\u003c/code\u003e/\u003ccode\u003ecase\u003c/code\u003e 문 구조와 의미론을 유지하지만, 사용자 의도가 패턴 매칭 컨텍스트에서 추론될 필요 없이 구체적인 구문에서 명시적으로 지정되도록 여러 변경 사항을 제안합니다.\u003c/p\u003e\n\u003cp\u003e제안된 추상 구문 트리(Abstract Syntax Tree, AST)에서도 의미론은 항상 명시적이며, 추론이 필요하지 않습니다.\u003c/p\u003e\n\u003ch4\u003eThe Match Statement\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ematch\u003c/code\u003e 문은 \u003ccode\u003ematch\u003c/code\u003e 키워드 뒤에 주어(subject) 표현식이 오고, 콜론(\u003ccode\u003e:\u003c/code\u003e)과 들여쓰기된 \u003ccode\u003ecase\u003c/code\u003e 블록들이 이어지는 구조입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ematch_stmt: \"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecase\u003c/code\u003e 블록은 \u003ccode\u003ecase\u003c/code\u003e 키워드 뒤에 패턴이 오고, 선택적으로 \u003ccode\u003eif\u003c/code\u003e 가드(guard)가 붙은 후 콜론(\u003ccode\u003e:\u003c/code\u003e)과 블록이 이어집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecase_block: \"case\" (guarded_pattern | open_pattern) ':' block\r\nguarded_pattern: closed_pattern 'if' named_expression\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePEP 634와 마찬가지로, \u003ccode\u003ematch\u003c/code\u003e와 \u003ccode\u003ecase\u003c/code\u003e는 소프트 키워드(soft keywords)입니다. 즉, 다른 문법 컨텍스트에서는 예약어가 아니며, 변수나 인자 이름으로 사용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePEP 634와 달리, 이 PEP에서는 패턴이 추상 구문 트리에서 새로운 종류의 노드로 명시적으로 정의됩니다. 이는 표면 구문이 기존 표현식 노드와 공유되더라도, 파서(parser)가 별개의 추상 노드를 방출한다는 의미입니다.\u003c/p\u003e\n\u003ch4\u003eMatch Semantics (매치 의미론)\u003c/h4\u003e\n\u003cp\u003e이 PEP는 PEP 634에서 제안된 전반적인 패턴 매칭 의미론을 대부분 유지합니다.\u003c/p\u003e\n\u003cp\u003e패턴에 대한 제안된 구문은 크게 변경되었으며, 아래에서 자세히 설명합니다. 또한, \u003ccode\u003e__match_args__\u003c/code\u003e를 \u003ccode\u003eNone\u003c/code\u003e으로 설정하는 모든 유형에 적용되도록 하여 내장 유형에 대한 특별한 경우 처리를 없애기 위해 클래스 정의 제약(class defined constraints, PEP 634의 클래스 패턴)의 의미론에 일부 변경 사항이 제안되었습니다.\u003c/p\u003e\n\u003ch4\u003eGuards (가드)\u003c/h4\u003e\n\u003cp\u003e이 PEP는 PEP 634에서 제안된 가드 절(guard clause) 의미론을 유지합니다. 그러나, 가드 절이 있을 경우 \u003ccode\u003ecase\u003c/code\u003e 패턴이 \u003ccode\u003eclosed pattern\u003c/code\u003e이어야 한다는 요구 사항을 추가하여 구문이 약간 변경되었습니다. 이는 패턴이 끝나고 가드 절이 시작되는 지점을 독자가 더 명확하게 이해할 수 있도록 합니다.\u003c/p\u003e\n\u003ch4\u003eIrrefutable case blocks (반박 불가능한 case 블록)\u003c/h4\u003e\n\u003cp\u003e이 PEP에서는 \u003ccode\u003ecapture pattern\u003c/code\u003e이 \u003ccode\u003eAS pattern\u003c/code\u003e과 별개의 개념으로 더 이상 존재하지 않으므로, 반박 불가능한 \u003ccode\u003ecase\u003c/code\u003e 블록의 정의가 PEP 634와 비교하여 약간 변경됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e와일드카드 패턴은 반박 불가능합니다.\u003c/li\u003e\n\u003cli\u003e좌변이 반박 불가능한 AS 패턴은 반박 불가능합니다.\u003c/li\u003e\n\u003cli\u003e적어도 하나의 반박 불가능한 패턴을 포함하는 OR 패턴은 반박 불가능합니다.\u003c/li\u003e\n\u003cli\u003e괄호로 묶인 반박 불가능한 패턴은 반박 불가능합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecase\u003c/code\u003e 블록은 가드가 없고 그 패턴이 반박 불가능하면 반박 불가능한 것으로 간주됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ematch\u003c/code\u003e 문은 최대 하나의 반박 불가능한 \u003ccode\u003ecase\u003c/code\u003e 블록을 가질 수 있으며, 이는 마지막에 와야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003ePatterns (패턴)\u003c/h4\u003e\n\u003cp\u003e패턴의 최상위 표면 구문은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eopen_pattern: # Pattern may use multiple tokens with no closing delimiter\r\n    | as_pattern\r\n    | or_pattern\r\nas_pattern: [closed_pattern] pattern_as_clause\r\nor_pattern: '|'.simple_pattern+\r\nsimple_pattern: # Subnode where \"as\" and \"or\" patterns must be parenthesised\r\n    | closed_pattern\r\n    | value_constraint\r\nclosed_pattern: # Require a single token or a closing delimiter in pattern\r\n    | wildcard_pattern\r\n    | group_pattern\r\n    | structural_constraint\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eopen pattern\u003c/code\u003e의 사용은 최상위 \u003ccode\u003ecase\u003c/code\u003e 절과 \u003ccode\u003egroup pattern\u003c/code\u003e 내에서 괄호로 묶였을 때로 제한됩니다.\u003c/p\u003e\n\u003cp\u003e패턴의 추상 구문은 어떤 요소가 서브패턴(subpatterns)이고 어떤 요소가 서브표현식(subexpressions) 또는 식별자(identifiers)인지 명시적으로 나타냅니다.\u003c/p\u003e\n\u003ch5\u003eAS Patterns (AS 패턴)\u003c/h5\u003e\n\u003cp\u003e\u003ccode\u003eAS pattern\u003c/code\u003e은 \u003ccode\u003eas\u003c/code\u003e 키워드 왼쪽에 있는 \u003ccode\u003eclosed pattern\u003c/code\u003e을 주어(subject)와 매치합니다. 매치에 실패하면 \u003ccode\u003eAS pattern\u003c/code\u003e도 실패합니다. 성공하면 \u003ccode\u003eAS pattern\u003c/code\u003e은 주어를 \u003ccode\u003eas\u003c/code\u003e 키워드 오른쪽에 있는 이름에 바인딩하고 성공합니다.\u003c/p\u003e\n\u003cp\u003e패턴이 주어지지 않으면 와일드카드 패턴(\u003ccode\u003e__\u003c/code\u003e)이 암시됩니다. 혼동을 피하기 위해 이중 밑줄(\u003ccode\u003e__\u003c/code\u003e)은 캡처 대상(capture target)으로 허용되지 않습니다.\u003c/p\u003e\n\u003ch5\u003eOR Patterns (OR 패턴)\u003c/h5\u003e\n\u003cp\u003e두 개 이상의 패턴이 수직 막대(\u003ccode\u003e|\u003c/code\u003e)로 구분되면 이를 \u003ccode\u003eOR pattern\u003c/code\u003e이라고 합니다. \u003ccode\u003eOR pattern\u003c/code\u003e은 각 서브패턴을 순서대로 주어에 매치하여 성공하는 첫 번째 서브패턴에서 성공으로 간주됩니다. 모든 서브패턴이 실패하면 \u003ccode\u003eOR pattern\u003c/code\u003e도 실패합니다.\u003c/p\u003e\n\u003ch5\u003eValue constraints (값 제약)\u003c/h5\u003e\n\u003cp\u003e\u003ccode\u003evalue constraint\u003c/code\u003e는 PEP 634의 \u003ccode\u003eliteral patterns\u003c/code\u003e과 \u003ccode\u003evalue patterns\u003c/code\u003e를 대체합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e동등성 제약 (Equality constraints):\u003c/strong\u003e \u003ccode\u003e== EXPR\u003c/code\u003e 형식으로 작성되며, 주어 값이 주어진 \u003ccode\u003eEXPR\u003c/code\u003e과 동등한지 확인합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e동일성 제약 (Identity constraints):\u003c/strong\u003e \u003ccode\u003eis EXPR\u003c/code\u003e 형식으로 작성되며, 주어 값이 \u003ccode\u003eEXPR\u003c/code\u003e과 정확히 같은 객체인지 확인합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e비교될 표현식은 대부분 단일 토큰(예: 이름, 문자열, 숫자, 내장 상수) 또는 닫는 구분자로 끝나야 하는 표현식으로 제한됩니다.\u003c/p\u003e\n\u003ch5\u003eWildcard Pattern (와일드카드 패턴)\u003c/h5\u003e\n\u003cp\u003e와일드카드 패턴은 \u003ccode\u003e__\u003c/code\u003e로 작성되며 항상 성공합니다. PEP 634와 마찬가지로 어떤 이름도 바인딩하지 않습니다. PEP 634가 다른 언어와의 일관성을 위해 단일 밑줄(\u003ccode\u003e_\u003c/code\u003e)을 와일드카드 패턴으로 선택한 반면, 이 PEP는 이중 밑줄(\u003ccode\u003e__\u003c/code\u003e)을 선택합니다. \u003ccode\u003e__\u003c/code\u003e는 전체 언어에 걸쳐 일관성을 유지할 수 있는 더 명확한 경로를 가지고 있기 때문입니다.\u003c/p\u003e\n\u003ch5\u003eGroup Patterns (그룹 패턴)\u003c/h5\u003e\n\u003cp\u003e\u003ccode\u003egroup pattern\u003c/code\u003e은 괄호 \u003ccode\u003e()\u003c/code\u003e로 \u003ccode\u003eopen pattern\u003c/code\u003e을 묶는 형태입니다. 추가적인 구문이 없으며, 추상 구문 트리에는 표현되지 않습니다. 이는 사용자가 의도된 그룹화를 강조하거나 문법이 \u003ccode\u003eclosed pattern\u003c/code\u003e을 요구할 때 \u003ccode\u003eopen pattern\u003c/code\u003e을 중첩할 수 있도록 합니다.\u003c/p\u003e\n\u003ch5\u003eStructural constraints (구조적 제약)\u003c/h5\u003e\n\u003cp\u003e\u003ccode\u003estructural constraint\u003c/code\u003e는 복합 객체에 대한 단언(assertion)을 만들고 그로부터 값을 추출하는 데 사용되는 패턴입니다. 이러한 패턴은 중첩된 \u003ccode\u003eAS pattern\u003c/code\u003e을 사용하거나 패턴 정의에 포함된 \u003ccode\u003epattern_as_clause\u003c/code\u003e 요소를 통해 여러 값을 바인딩할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSequence constraints (시퀀스 제약):\u003c/strong\u003e \u003ccode\u003e[]\u003c/code\u003e 대괄호를 사용하여 시퀀스 내의 항목을 확인하고 선택적으로 추출할 수 있습니다. \u003ccode\u003ecollections.abc.Sequence\u003c/code\u003e의 인스턴스가 아니거나 \u003ccode\u003estr\u003c/code\u003e, \u003ccode\u003ebytes\u003c/code\u003e, \u003ccode\u003ebytearray\u003c/code\u003e 인스턴스인 경우 실패합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMapping constraints (매핑 제약):\u003c/strong\u003e \u003ccode\u003e{}\u003c/code\u003e 중괄호를 사용하여 시퀀스 내의 키와 값을 확인하고 값을 선택적으로 추출할 수 있습니다. \u003ccode\u003ecollections.abc.Mapping\u003c/code\u003e의 인스턴스가 아닌 경우 실패합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInstance attribute constraints (인스턴스 속성 제약):\u003c/strong\u003e \u003ccode\u003eCLS{.NAME, ...}\u003c/code\u003e 형식으로 작성되며, 인스턴스의 타입을 확인하고 속성을 선택적으로 추출할 수 있습니다. \u003ccode\u003eisinstance()\u003c/code\u003e를 사용하여 \u003ccode\u003ename_or_attr\u003c/code\u003e의 인스턴스인지 확인합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eClass defined constraints (클래스 정의 제약):\u003c/strong\u003e \u003ccode\u003ename_or_attr()\u003c/code\u003e 또는 \u003ccode\u003ename_or_attr(positional_patterns, **{attrs_constraint_elements})\u003c/code\u003e 형식으로 작성됩니다. 클래스에 공통 속성 시퀀스를 지정하고, 매번 속성 이름을 지정할 필요 없이 위치 기반으로 확인할 수 있도록 합니다. \u003ccode\u003e__match_args__\u003c/code\u003e 속성을 정의하는 유형만 클래스 정의 패턴에서 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e설계 논의 (Design Discussion)\u003c/h3\u003e\n\u003ch4\u003e패턴 매칭에서 단순 이름의 명시적 한정자 요구 (Requiring explicit qualification of simple names in match patterns)\u003c/h4\u003e\n\u003cp\u003e이 PEP의 첫 번째 버전은 PEP 634의 기본 전제, 즉 이터러블 언패킹(iterable unpacking) 구문이 패턴 매칭을 위한 새로운 구문을 정의하는 데 좋은 기반이 될 것이라는 점을 받아들였습니다. 그러나 검토 과정에서 이 핵심 가정에서 직접적으로 발생하는 두 가지 주요하고 한 가지 사소한 모호성 문제가 강조되었습니다.\u003c/p\u003e\n\u003cp\u003e세 번째 개정안은 이러한 문제를 해결하기 위해 이터러블 언패킹 구문과의 일치를 포기하고, 변수 조회를 제외한 모든 단순 이름 사용에 선행 시그널(sigil) 또는 키워드를 사용하여 한정할 것을 요구했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eas NAME\u003c/code\u003e: 지역 변수 바인딩\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.NAME\u003c/code\u003e: 속성 조회\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e== NAME\u003c/code\u003e: 변수 조회\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eis NAME\u003c/code\u003e: 변수 조회\u003c/li\u003e\n\u003cli\u003e다른 모든 사용: 변수 조회\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 접근 방식의 주요 장점은 패턴 내에서 단순 이름의 해석을 지역적인 활동으로 만든다는 것입니다. 선행 \u003ccode\u003eas\u003c/code\u003e는 이름 바인딩을, 선행 \u003ccode\u003e.\u003c/code\u003e은 속성 조회를 나타내며, 그 외의 모든 것은 변수 조회입니다.\u003c/p\u003e\n\u003ch4\u003e추측하려는 유혹에 저항하기 (Resisting the temptation to guess)\u003c/h4\u003e\n\u003cp\u003ePEP 635는 다른 언어에서 패턴 매칭이 사용되는 방식을 살펴보고, 파이썬에서 패턴 매칭이 어떻게 사용될지에 대한 그럴듯한 예측을 하려고 시도했습니다. 이 PEP는 이러한 예측이 타당하다고 보지만, 미리 추측할 필요는 없다고 주장합니다. 대신, \u003ccode\u003eas\u003c/code\u003e, \u003ccode\u003e==\u003c/code\u003e, \u003ccode\u003eis\u003c/code\u003e와 같은 접두사 마커를 사용하여 사용자가 의도를 명시적으로 밝히도록 요구하는 더 명시적인 구문으로 시작하고, 몇 년 후 파이썬에서 패턴 매칭이 실제로 어떻게 사용되는지에 따라 상황을 재평가할 것을 제안합니다.\u003c/p\u003e\n\u003ch4\u003e로컬 변수의 속성 조회 캐싱과의 상호작용 (Interaction with caching of attribute lookups in local variables)\u003c/h4\u003e\n\u003cp\u003e이 PEP와 PEP 634의 주요 변경 사항 중 하나는 동등성 제약 조회에 \u003ccode\u003e== EXPR\u003c/code\u003e를 사용하는 것입니다. PEP 634의 값 및 캡처 패턴 구문은 마커 접두사를 생략하므로, 로컬 변수를 사용하여 속성 조회를 대체하는 리팩토링 시 의미론적 동등성이 깨지는 문제가 발생할 수 있습니다. 이 PEP는 \u003ccode\u003e== name\u003c/code\u003e을 사용하여 결과를 값 제약으로 강제 해석하고, \u003ccode\u003eas name\u003c/code\u003e을 사용하여 이름 바인딩을 지정함으로써 이러한 리팩토링 시에도 원래의 의미론이 유지되도록 합니다.\u003c/p\u003e\n\u003ch4\u003e값 제약 접두사로 기존 비교 연산자 사용 (Using existing comparison operators as the value constraint prefix)\u003c/h4\u003e\n\u003cp\u003e초기 버전에서는 \u003ccode\u003e?\u003c/code\u003e를 동등성 제약 접두사로, \u003ccode\u003e?is\u003c/code\u003e를 동일성 제약 접두사로 제안했으나, Steven D'Aprano는 기존 비교 연산자(\u003ccode\u003e==\u003c/code\u003e 및 \u003ccode\u003eis\u003c/code\u003e)를 대신 사용할 것을 제안했습니다. 이 PEP는 이 아이디어를 채택하여 새로운 기호를 도입하는 대신 기존 연산자를 활용합니다.\u003c/p\u003e\n\u003ch4\u003e와일드카드 패턴 마커로 \u003ccode\u003e__\u003c/code\u003e 사용 (Using __ as the wildcard pattern marker)\u003c/h4\u003e\n\u003cp\u003ePEP 635는 와일드카드 패턴 마커로 \u003ccode\u003e?\u003c/code\u003e를 도입하는 것이 좋지 않다고 주장했습니다. PEP 634에서 \u003ccode\u003e_\u003c/code\u003e를 와일드카드 패턴으로 선택한 것 역시 국제화(i18n) 관련 사용 사례 등으로 인해 파이썬의 다른 부분과의 일관성을 유지하기 어렵다는 문제가 제기되었습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003e__\u003c/code\u003e를 와일드카드 패턴 마커로 제안합니다. \u003ccode\u003e__\u003c/code\u003e는 현재 파이썬 코드에서 \"이 값이 필요하지 않음\"을 나타내는 대안으로 사용될 수 있으며, \u003ccode\u003e_\u003c/code\u003e와 달리 다른 사용 사례가 부족하므로, 향후 \u003ccode\u003e__\u003c/code\u003e를 파이썬의 모든 곳에서 \"이름 바인딩 건너뛰기\"를 의미하는 일반적인 하드 키워드(hard keyword)로 만들 수 있는 그럴듯한 경로를 제공합니다. 또한, \u003ccode\u003e__\u003c/code\u003e로 시작하는 이름은 이미 언어 내부적으로 예약되어 있다는 점도 이러한 접근 방식과 일치합니다.\u003c/p\u003e\n\u003ch4\u003e추상 구문 트리에서 패턴을 명시적으로 표현 (Representing patterns explicitly in the Abstract Syntax Tree)\u003c/h4\u003e\n\u003cp\u003ePEP 634는 \u003ccode\u003ematch\u003c/code\u003e 문이 AST에서 어떻게 표현되어야 하는지 명시적으로 논의하지 않았습니다. 그 결과, PEP 634의 참조 구현은 패턴을 표현식 노드로 나타내는 중대한 설계 결함을 포함했습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 AST에 새로운 명시적인 \"pattern\" 노드를 정의합니다. 이를 통해 패턴과 허용되는 서브노드를 AST 자체에 명시적으로 정의할 수 있으며, 새로운 기능을 구현하는 코드를 더 명확하게 만들고, C 컴파일러가 코드 생성기가 패턴을 처리하는지 표현식을 처리하는지 추적하는 데 더 많은 도움을 제공할 수 있도록 합니다.\u003c/p\u003e\n\u003ch4\u003e시퀀스 패턴 변경 (Changes to sequence patterns)\u003c/h4\u003e\n\u003cp\u003e이 PEP는 PEP 634와 비교하여 시퀀스 패턴에 한 가지 주목할 만한 변경 사항을 적용합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e오직 대괄호 \u003ccode\u003e[]\u003c/code\u003e 형태의 시퀀스 패턴만 지원됩니다. 열린 형태(구분자 없음)나 튜플 스타일(괄호 \u003ccode\u003e()\u003c/code\u003e를 구분자로 사용) 시퀀스 패턴은 지원되지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 이터러블 언패킹 구문과의 일관성을 위해 원래 구문 제안에 포함되었던 구문 유연성을 더 이상 유지할 필요가 없다는 판단에 따른 것입니다.\u003c/p\u003e\n\u003ch4\u003e매핑 패턴 변경 (Changes to mapping patterns)\u003c/h4\u003e\n\u003cp\u003e이 PEP는 PEP 634와 비교하여 매핑 패턴에 두 가지 주목할 만한 변경 사항을 적용합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e값 캡처는 \u003ccode\u003eKEY as NAME\u003c/code\u003e으로 작성됩니다.\u003c/li\u003e\n\u003cli\u003e더 넓은 범위의 키가 허용됩니다: 리터럴과 속성 참조뿐만 아니라 모든 \"closed expression\"이 허용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e첫 번째 변경 사항은 서브표현식이나 패턴의 오른쪽에 대상 이름이 있는 모든 바인딩 작업이 \u003ccode\u003eas\u003c/code\u003e 키워드를 사용하도록 보장하는 일환입니다. 두 번째 변경 사항은 기존 표현식 처리 메커니즘을 재사용하여 파서와 코드 생성기 코드를 단순화하기 위한 것입니다.\u003c/p\u003e\n\u003ch4\u003e클래스 패턴 변경 (Changes to class patterns)\u003c/h4\u003e\n\u003cp\u003e이 PEP는 PEP 634와 비교하여 클래스 패턴에 여러 가지 주목할 만한 변경 사항을 적용합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e클래스 인스턴스화와의 구문적 일치는 오해의 소지가 있고 도움이 되지 않는 것으로 판단되어 폐기되었습니다. 대신, 매핑 패턴에서 영감을 받은 새로운 전용 구문이 도입되었습니다.\u003c/li\u003e\n\u003cli\u003e어떤 클래스에도 작동하는 단순한 덕 타이핑(ducktyping)을 위한 새로운 전용 구문이 도입되었습니다.\u003c/li\u003e\n\u003cli\u003e다양한 내장 및 표준 라이브러리 유형에 대한 특별한 경우 처리는 \u003ccode\u003e__match_args__\u003c/code\u003e 속성이 \u003ccode\u003eNone\u003c/code\u003e으로 설정되어 있는지 확인하는 일반적인 검사로 보완됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 변경 사항은 \u003ccode\u003eas\u003c/code\u003e 키워드를 사용하여 바인딩 작업을 명시하고, 패턴 내에서 단순 이름 사용에 접두사를 의무화하여 의도를 명확히 하는 데 중점을 둡니다. 또한, 클래스 패턴이 속성 일치에 초점을 맞추도록 하여 클래스 인스턴스화와의 혼동을 피하고, 파이썬에서 흔히 사용되는 덕 타이핑 검사를 더 쉽게 구현할 수 있도록 합니다.\u003c/p\u003e\n\u003ch3\u003e보류된 아이디어 (Deferred Ideas)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 미래에 고려할 수 있는 몇 가지 아이디어를 제시합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e추론된 값 제약 (Inferred value constraints):\u003c/strong\u003e 현재 이 PEP는 추론된 동등성 및 동일성 제약을 미래에 추가할 가능성을 배제하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e일부 필수 괄호 선택 사항화 (Making some required parentheses optional):\u003c/strong\u003e 현재 PEP는 잠재적인 모호함에 직면했을 때 괄호를 필수로 요구하는 경향이 있지만, 나중에 제한을 완화하는 것은 하위 호환 가능한 변경이므로 개별 사례별로 검토할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e복소수 리터럴을 \u003ccode\u003eclosed expression\u003c/code\u003e으로 허용 (Accepting complex literals as closed expressions):\u003c/strong\u003e 현재 복소수 리터럴은 괄호로 묶어야 사용 가능하지만, 파서 수준에서 직접 처리하는 방법이 논의 중입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e패턴 매칭에서 부정 제약 허용 (Allowing negated constraints in match patterns):\u003c/strong\u003e \u003ccode\u003e!= expr\u003c/code\u003e 또는 \u003ccode\u003eis not expr\u003c/code\u003e와 같은 부정 제약을 허용하는 것이 논의되었으나, 충분히 자주 사용될지는 불분명하여 보류되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e패턴 매칭에서 멤버십 확인 허용 (Allowing membership checks in match patterns):\u003c/strong\u003e \u003ccode\u003ein container\u003c/code\u003e와 같은 멤버십 확인 구문을 패턴 매칭에 추가하는 것이 제안되었으나, 별도의 제안으로 연기되었습니다. 이는 \u003ccode\u003ematch\u003c/code\u003e 문이 언어에 가치 있는 추가가 되는 데 필수적이지 않기 때문입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e인스턴스 속성 제약에 대한 기본 타입 추론 (Inferring a default type for instance attribute constraints):\u003c/strong\u003e \u003ccode\u003eobject{.ATTR}\u003c/code\u003e에서 \u003ccode\u003eobject\u003c/code\u003e를 생략하고 \u003ccode\u003e{.ATTR}\u003c/code\u003e로 작성할 수 있도록 하는 아이디어가 논의되었으나, 매핑 패턴과 인스턴스 속성 패턴을 시각적으로 구분하기 어렵게 만들 수 있어 보류되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e시퀀스 패턴의 특별한 경우 피하기 (Avoiding special cases in sequence patterns):\u003c/strong\u003e \u003ccode\u003estr\u003c/code\u003e, \u003ccode\u003ebytes\u003c/code\u003e, \u003ccode\u003ebytearray\u003c/code\u003e가 시퀀스 패턴에 절대 매치되지 않도록 특별 처리하는 것을 \u003ccode\u003ecollections.abc.AtomicSequence\u003c/code\u003e와 같은 새로운 추상 베이스 클래스를 정의하여 제거하는 방안이 논의되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e인스턴스에서 여러 속성을 검색하는 표현식 구문 (Expression syntax to retrieve multiple attributes from an instance):\u003c/strong\u003e \u003ccode\u003ehost, port = obj{.host, .port}\u003c/code\u003e와 같이 단일 표현식으로 객체에서 여러 속성을 검색하는 일반적인 구문의 기초로 인스턴스 속성 패턴 구문을 사용할 수 있다는 아이디어가 언급되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e거부된 아이디어 (Rejected Ideas)\u003c/h3\u003e\n\u003cp\u003e이 PEP에서 거부된 아이디어는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e값 제약 및 매핑 패턴 키에서 허용되는 표현식 제한 (Restricting permitted expressions in value constraints and mapping pattern keys):\u003c/strong\u003e PEP 634와 같이 값 제약 및 매핑 패턴 키에서 속성 조회 및 상수 리터럴만 허용하는 것을 제한하는 것에 대한 명확한 런타임 이점이 없으므로, 이 PEP는 모든 종류의 \u003ccode\u003eprimary expression\u003c/code\u003e과 높은 우선순위의 단항 연산자(\u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e~\u003c/code\u003e)를 허용합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e매핑 패턴 키에 제약 접두사 마커 사용 의무화 (Requiring the use of constraint prefix markers for mapping pattern keys):\u003c/strong\u003e 초기 제안에서는 매핑 패턴 키에 값 제약처럼 \u003ccode\u003e==\u003c/code\u003e와 같은 접두사를 요구했으나, 구문적으로 노이즈가 많고 표현식의 위치만으로도 충분한 정보가 전달되므로 생략되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e매핑 값 제약에서 키/값 구분자 생략 허용 (Allowing the key/value separator to be omitted for mapping value constraints):\u003c/strong\u003e \u003ccode\u003ecase {0 == 0}:\u003c/code\u003e과 같이 컴파일러는 의도를 알 수 있지만, 사람이 읽기에는 \"0 == 0\"이라는 자명한 비교 연산으로 보일 수 있는 모호한 구문이 될 수 있으므로, 키/값 구분자(\u003ccode\u003e:\u003c/code\u003e)를 포함하는 것이 더 명확하다고 판단하여 허용되지 않았습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e참조 구현 (Reference Implementation)\u003c/h3\u003e\n\u003cp\u003e이 PEP에 대한 참조 구현 초안은 PEP 634의 참조 구현에서 파생되었습니다.\u003c/p\u003e\n\u003ch3\u003e변경 사항 요약 (Summary of changes relative to PEP 634)\u003c/h3\u003e\n\u003cp\u003ePEP 634와 비교하여 이 PEP는 다음과 같은 주요 변경 사항을 적용합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e패턴에 \u003ccode\u003eexpr\u003c/code\u003e 유형을 재사용하는 대신, AST에 새로운 \u003ccode\u003epattern\u003c/code\u003e 유형을 정의합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_\u003c/code\u003e (단일 밑줄)에서 \u003ccode\u003e__\u003c/code\u003e (이중 밑줄)로 와일드카드 패턴이 변경되고, AST에 전용 \u003ccode\u003eMatchAlways\u003c/code\u003e 노드를 갖습니다.\u003c/li\u003e\n\u003cli\u003e의도 모호성으로 인해 \u003ccode\u003evalue patterns\u003c/code\u003e 및 \u003ccode\u003eliteral patterns\u003c/code\u003e가 제거됩니다.\u003c/li\u003e\n\u003cli\u003e새로운 표현식 범주인 \"closed expressions\"가 도입됩니다.\u003c/li\u003e\n\u003cli\u003e새로운 패턴 유형인 \"value constraint patterns\"가 도입되고, \u003ccode\u003e==\u003c/code\u003e 및 \u003ccode\u003eis\u003c/code\u003e를 접두사 마커로 사용합니다.\u003c/li\u003e\n\u003cli\u003e의도 모호성으로 인해 \u003ccode\u003ecapture patterns\u003c/code\u003e가 제거됩니다. 모든 캡처 작업은 \u003ccode\u003eas\u003c/code\u003e 키워드를 사용하며 \u003ccode\u003eMatchAs\u003c/code\u003e 또는 \u003ccode\u003eMatchRestOfSequence\u003c/code\u003e 노드로 표현됩니다.\u003c/li\u003e\n\u003cli\u003eAS 패턴의 간결성을 위해 \u003ccode\u003eas NAME\u003c/code\u003e은 \u003ccode\u003e__ as NAME\u003c/code\u003e과 동일한 의미로 허용됩니다.\u003c/li\u003e\n\u003cli\u003e시퀀스 패턴은 대괄호 \u003ccode\u003e[]\u003c/code\u003e 사용을 필수로 변경합니다.\u003c/li\u003e\n\u003cli\u003e매핑 패턴은 키로 임의의 \u003ccode\u003eclosed expression\u003c/code\u003e을 허용합니다.\u003c/li\u003e\n\u003cli\u003e매핑 패턴의 간결성을 위해 \u003ccode\u003eKEY : __ as NAME\u003c/code\u003e을 \u003ccode\u003eKEY as NAME\u003c/code\u003e으로 단축할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e클래스 패턴은 속성 매칭에 개별 키워드 인자 구문을 더 이상 사용하지 않고, 매핑 패턴 구문의 변형과 함께 이중 별표 구문을 사용합니다.\u003c/li\u003e\n\u003cli\u003e클래스 패턴은 \u003ccode\u003e__match_args__\u003c/code\u003e가 \u003ccode\u003eNone\u003c/code\u003e으로 설정된 모든 클래스를 단일 위치 패턴을 받아 전체 객체와 매치하는 것으로 처리합니다.\u003c/li\u003e\n\u003cli\u003e덕 타이핑을 위한 전용 구문이 추가됩니다 (\u003ccode\u003eMatchAttrs\u003c/code\u003e 노드).\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e이 PEP 642는 최종적으로 거부되었지만, 구조적 패턴 매칭 구문의 설계 과정에서 발생할 수 있는 모호성과 이를 해결하기 위한 명시성 원칙의 중요성을 잘 보여줍니다. 실제 파이썬 3.10에 도입된 패턴 매칭은 PEP 634의 구문을 기반으로 하고 있습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2626,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 642 - Explicit Pattern Syntax for Structural Pattern Matching\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 01:33:04+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Le\",null,{\"postPermalink\":\"/python/pep/642/\",\"postId\":\"2025-09-27-pep-0642-explicit-pattern-syntax-for-structural-pattern-matching\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/641/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 641 - Using an underscore in the version portion of Python 3.10 compatibility tags\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Rejected] PEP 642 - Explicit Pattern Syntax for Structural Pattern Matching\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/643/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 643 - Metadata for Package Source Distributions\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>