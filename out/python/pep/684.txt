3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-467e37449c5a68fc.js","185","static/chunks/app/layout-b0a450f8e4964582.js"],"default"]
7:I[231,["231","static/chunks/231-467e37449c5a68fc.js","877","static/chunks/app/%5B...slug%5D/page-1f60377561abdb46.js"],""]
8:I[4080,["231","static/chunks/231-467e37449c5a68fc.js","185","static/chunks/app/layout-b0a450f8e4964582.js"],""]
4:["slug","python/pep/684","c"]
0:["WcxaIiCPz9cbpnkGvOjOK",[[["",{"children":[["slug","python/pep/684","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"684\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/684","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","link",null,{"rel":"dns-prefetch","href":"https://www.googletagmanager.com"}],["$","link",null,{"rel":"preconnect","href":"https://www.googletagmanager.com","crossOrigin":"anonymous"}],["$","link",null,{"rel":"dns-prefetch","href":"https://giscus.app"}],["$","link",null,{"rel":"preconnect","href":"https://giscus.app","crossOrigin":"anonymous"}],["$","meta",null,{"httpEquiv":"X-Content-Type-Options","content":"nosniff"}],["$","meta",null,{"name":"referrer","content":"strict-origin-when-cross-origin"}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"WebSite\",\"name\":\"secrett2633's blog\",\"url\":\"https://blog.secrett2633.cloud\",\"description\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\",\"inLanguage\":\"ko\",\"publisher\":{\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\"}}"}}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\",\"sameAs\":[\"https://github.com/secrett2633\"]}"}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":[["$","a",null,{"href":"#main-content","className":"sr-only focus:not-sr-only focus:absolute focus:z-50 focus:p-4 focus:bg-white focus:text-blue-600","children":"본문으로 건너뛰기"}],["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"id":"main-content","className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":["© ",2026," secrett2633. All rights reserved."]}]}]}]}]]}],["$","$L8",null,{"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY","strategy":"afterInteractive"}],["$","$L8",null,{"id":"gtag-init","strategy":"afterInteractive","children":"window.dataLayer = window.dataLayer || [];\n            function gtag(){dataLayer.push(arguments);}\n            gtag('js', new Date());\n            gtag('config', 'G-NE2W3CFPNY');"}]]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","role":"status","aria-label":"로딩 중","children":[["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}],["$","span",null,{"className":"sr-only","children":"로딩 중..."}]]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ddc331716d5e47a2.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L9"]]]]]
b:I[646,["231","static/chunks/231-467e37449c5a68fc.js","877","static/chunks/app/%5B...slug%5D/page-1f60377561abdb46.js"],"default"]
a:T6191,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0684/" target="_blank" rel="noopener noreferrer">PEP 684 - A Per-Interpreter GIL</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 08-Mar-2022</p>
</blockquote>
<h1 id="pep-684-인터프리터별-gil-a-per-interpreter-gil"><a href="#pep-684-인터프리터별-gil-a-per-interpreter-gil">PEP 684 – 인터프리터별 GIL (A Per-Interpreter GIL)</a></h1>
<ul>
<li><strong>작성자</strong> : Eric Snow</li>
<li><strong>상태</strong> : Final (최종)</li>
<li><strong>유형</strong> : Standards Track (표준 트랙)</li>
<li><strong>Python 버전</strong> : 3.12</li>
<li><strong>생성일</strong> : 2022년 3월 8일</li>
</ul>
<h2 id="개요-abstract"><a href="#개요-abstract">개요 (Abstract)</a></h2>
<p>Python 1.5 (1997년) 이후로 CPython 사용자들은 동일 프로세스 내에서 여러 인터프리터를 실행할 수 있었지만, 이 인터프리터들은 상당한 양의 전역 상태(global state)를 공유했습니다. 이는 버그의 원인이 되며, 이 기능의 사용이 증가함에 따라 그 영향도 커지고 있습니다. 또한, 충분한 격리가 이루어진다면 인터프리터들이 더 이상 GIL을 공유하지 않아 진정한 멀티 코어 병렬 처리가 가능해질 것입니다. 이 제안에 설명된 변경 사항들은 이러한 수준의 인터프리터 격리를 가능하게 할 것입니다.</p>
<h2 id="상위-수준-요약-high-level-summary"><a href="#상위-수준-요약-high-level-summary">상위 수준 요약 (High-Level Summary)</a></h2>
<p>이 제안은 CPython을 다음과 같이 변경합니다.</p>
<ul>
<li>충분한 격리가 이루어지면 인터프리터 간의 GIL 공유를 중단합니다.</li>
<li>격리 설정에 대한 몇 가지 새로운 인터프리터 설정 옵션을 추가합니다.</li>
<li>호환되지 않는 확장 모듈이 문제를 일으키는 것을 방지합니다.</li>
</ul>
<h3 id="gil-the-gil"><a href="#gil-the-gil">GIL (The GIL)</a></h3>
<p>GIL은 CPython 런타임 상태의 대부분에 대한 동시 접근을 보호합니다. 따라서 GIL로 보호되는 모든 전역 상태는 GIL이 인터프리터별로 분리되기 전에 각 인터프리터로 이동되어야 합니다. 일부 경우에는 잠금(locks)이나 "불멸 객체(immortal objects)"와 같은 다른 메커니즘을 사용하여 스레드 안전한 공유를 보장할 수 있습니다.</p>
<h3 id="cpython-런타임-상태-cpython-runtime-state"><a href="#cpython-런타임-상태-cpython-runtime-state">CPython 런타임 상태 (CPython Runtime State)</a></h3>
<p>인터프리터를 제대로 격리하려면 CPython 런타임 상태의 대부분이 <code>PyInterpreterState</code> 구조체에 저장되어야 합니다. 현재는 일부만 저장되어 있고, 나머지는 C 전역 변수 또는 <code>_PyRuntimeState</code>에 있습니다. 이 대부분의 상태는 이동되어야 합니다. 이는 전역 변수의 내부 사용을 크게 줄이고 런타임 상태를 <code>_PyRuntimeState</code>와 <code>PyInterpreterState</code>로 통합하려는 오랜 노력과 직접적으로 일치합니다.</p>
<h3 id="기타-격리-고려-사항-other-isolation-considerations"><a href="#기타-격리-고려-사항-other-isolation-considerations">기타 격리 고려 사항 (Other Isolation Considerations)</a></h3>
<p>CPython의 인터프리터는 몇 가지 예외를 제외하고는 서로 엄격하게 격리되어야 합니다. 대부분은 이미 격리되어 있으며, 각 인터프리터는 자신만의 모듈, 클래스, 함수, 변수 복사본을 가집니다.</p>
<p>그러나 일부 프로세스 전역 리소스(예: 메모리, 파일 디스크립터, 환경 변수)는 여전히 공유됩니다. 이를 변경할 계획은 없습니다. 또한, 버그나 다중 인터프리터를 고려하지 않은 구현으로 인해 격리가 불완전한 경우도 있습니다. 여기에는 CPython 런타임, 표준 라이브러리(stdlib), 그리고 전역 변수에 의존하는 확장 모듈이 포함됩니다.</p>
<h3 id="불멸-객체에-대한-의존성-depending-on-immortal-objects"><a href="#불멸-객체에-대한-의존성-depending-on-immortal-objects">불멸 객체에 대한 의존성 (Depending on Immortal Objects)</a></h3>
<p>PEP 683은 불멸 객체(Immortal Objects)를 CPython의 내부 기능으로 도입합니다. 불멸 객체를 통해 모든 인터프리터 간에 변경 불가능한 전역 객체를 공유할 수 있습니다. 결과적으로 이 PEP는 공개 C-API에 노출된 다양한 객체들을 다룰 필요가 없으며, 내장 정적 타입(builtin static types)에 대한 문제도 단순화합니다.</p>
<h2 id="동기-motivation"><a href="#동기-motivation">동기 (Motivation)</a></h2>
<p>이 제안이 해결하고자 하는 근본적인 문제는 CPython 런타임에서 (Python 코드에 대한) 진정한 멀티 코어 병렬 처리의 부족입니다. GIL이 그 원인입니다. 격리된 인터프리터는 특정 동시성 모델을 지원하는 효과적인 메커니즘이기도 합니다. PEP 554에서 더 자세히 논의됩니다.</p>
<h3 id="간접적인-이점-indirect-benefits"><a href="#간접적인-이점-indirect-benefits">간접적인 이점 (Indirect Benefits)</a></h3>
<p>인터프리터별 GIL에 필요한 대부분의 노력은 다음과 같은 이점을 제공하며, 이는 어쨌든 수행할 가치가 있는 작업입니다.</p>
<ul>
<li>다중 인터프리터 동작을 더욱 신뢰할 수 있게 만듭니다.</li>
<li>그동안 우선순위가 아니었던 오랜 런타임 버그들을 수정하게 만들었습니다.</li>
<li>이전에 알려지지 않았던 런타임 버그들을 노출하고 수정하도록 영감을 주었습니다.</li>
<li>더 깔끔한 런타임 초기화(PEP 432, PEP 587)를 이끌었습니다.</li>
<li>더 깔끔하고 완전한 런타임 종료를 이끌었습니다.</li>
<li>C-API의 구조적 계층화(예: <code>Include/internal</code>)를 가져왔습니다.</li>
<li>다른 CPython 관련 프로젝트(예: 성능 개선, pre-fork 애플리케이션 배포, 확장 모듈 격리, CPython 임베딩)에도 이점을 제공합니다.</li>
</ul>
<h3 id="다중-인터프리터의-기존-사용-existing-use-of-multiple-interpreters"><a href="#다중-인터프리터의-기존-사용-existing-use-of-multiple-interpreters">다중 인터프리터의 기존 사용 (Existing Use of Multiple Interpreters)</a></h3>
<p>다중 인터프리터를 위한 C-API는 수년 동안 사용되어 왔습니다. 최근까지 이 기능은 널리 알려지거나 광범위하게 사용되지 않았지만(mod_wsgi 제외), 지난 몇 년 동안 사용이 증가하고 있습니다. 현재 이 기능을 사용하는 공개 프로젝트로는 mod_wsgi, OpenStack, Ceph, JEP, Kodi 등이 있습니다. PEP 554가 채택되면 다중 인터프리터 사용은 상당히 증가할 것으로 예상됩니다.</p>
<h3 id="pep-554-stdlib의-다중-인터프리터-multiple-interpreters-in-the-stdlib"><a href="#pep-554-stdlib의-다중-인터프리터-multiple-interpreters-in-the-stdlib">PEP 554 (Stdlib의 다중 인터프리터) (Multiple Interpreters in the Stdlib)</a></h3>
<p>PEP 554는 사용자가 Python 코드에서 다중 인터프리터에 접근할 수 있도록 최소한의 표준 라이브러리 모듈을 제공하는 것에 중점을 둡니다. 이 PEP는 GIL과 관련된 변경을 제안하지 않지만, 이 모듈의 사용자들은 인터프리터별 GIL의 이점을 누릴 수 있으므로 PEP 554의 매력이 더욱 커집니다.</p>
<h2 id="근거-rationale"><a href="#근거-rationale">근거 (Rationale)</a></h2>
<p>2014년 초기 조사에서 멀티 코어 Python을 위한 다양한 가능한 해결책들이 탐색되었지만, 각각 간단한 해결책 없이 단점을 가지고 있었습니다.</p>
<ul>
<li><strong>확장 모듈에서 GIL 해제</strong> : Python 코드에는 도움이 되지 않습니다.</li>
<li><strong>다른 Python 구현 (예: Jython, IronPython)</strong> : CPython이 커뮤니티를 지배합니다.</li>
<li><strong>GIL 제거 (예: gilectomy, "no-gil")</strong> : 당시에는 너무 많은 기술적 위험이 있었습니다.</li>
<li><strong>Trent Nelson의 "PyParallel" 프로젝트</strong> : 불완전했으며, 당시 Windows 전용이었습니다.</li>
<li><strong>multiprocessing</strong> : 효과적으로 만들기에는 너무 많은 작업이 필요하고, 특정 상황(대규모, Windows)에서 높은 패널티가 따릅니다.</li>
<li><strong>다른 병렬 처리 도구 (예: dask, ray, MPI)</strong> : 런타임/stdlib에는 적합하지 않습니다.</li>
<li><strong>멀티 코어를 포기 (예: async, 아무것도 하지 않음)</strong> : 이는 결국 좋지 않은 결과를 낳을 뿐입니다.</li>
</ul>
<p>2014년에도 격리된 인터프리터를 사용하는 해결책은 기술적 위험이 높지 않고 대부분의 작업이 어쨌든 수행할 가치가 있다는 것이 상당히 분명했습니다. (단점은 해야 할 작업의 양이었습니다.)</p>
<h2 id="명세-specification"><a href="#명세-specification">명세 (Specification)</a></h2>
<p>이 제안은 다음과 같은 변경 사항을 포함하며, 순서대로 진행되어야 합니다.</p>
<ol>
<li>전역 런타임 상태(객체 포함)를 <code>_PyRuntimeState</code>로 통합합니다.</li>
<li>거의 모든 상태를 <code>PyInterpreterState</code>로 이동합니다.</li>
<li>마지막으로, GIL을 <code>PyInterpreterState</code>로 이동합니다.</li>
<li>기타 나머지 작업: C-API 업데이트, 확장 모듈 제한 구현, 인기 확장 모듈 유지 관리자와 협력하여 다중 인터프리터 지원을 돕습니다.</li>
</ol>
<h3 id="인터프리터별-상태-per-interpreter-state"><a href="#인터프리터별-상태-per-interpreter-state">인터프리터별 상태 (Per-Interpreter State)</a></h3>
<p>다음 런타임 상태는 <code>PyInterpreterState</code>로 이동됩니다.</p>
<ul>
<li>안전하게 공유할 수 없는(완전히 변경 불가능한) 모든 전역 객체</li>
<li>GIL</li>
<li>현재 GIL로 보호되는 대부분의 변경 가능한 데이터</li>
<li>다른 인터프리터별 잠금으로 보호되는 변경 가능한 데이터</li>
<li>다른 인터프리터에서 독립적으로 사용될 수 있는 변경 가능한 데이터 (다단계 초기화를 포함하는 확장 모듈에도 적용)</li>
<li>아래에 명시적으로 제외되지 않은 모든 다른 변경 가능한 데이터</li>
</ul>
<p>또한, GC, 경고, <code>atexit</code> 훅(hooks)을 포함한 전역 상태의 일부는 이미 인터프리터로 이동되었습니다.</p>
<p>다음 런타임 상태는 이동되지 않습니다.</p>
<ul>
<li>안전하게 공유 가능한 전역 객체 (있다면)</li>
<li>변경 불가능한 데이터 (대부분 <code>const</code>)</li>
<li>사실상 변경 불가능한 데이터 (예: 초기화 후 변경되지 않는 상태, 문자열 해시)</li>
<li>메인 스레드에서만 변경이 보장되는 모든 데이터 (예: CPython의 <code>main()</code>에서만 사용되는 상태, REPL 상태, 런타임 초기화 중에만 수정되는 데이터)</li>
<li>(GIL 외의) 다른 전역 잠금으로 보호되는 변경 가능한 데이터</li>
<li>원자 변수(atomic variables)의 전역 상태</li>
<li>(합리적으로) 원자 변수로 변경될 수 있는 변경 가능한 전역 상태</li>
</ul>
<h3 id="메모리-할당자-memory-allocators"><a href="#메모리-할당자-memory-allocators">메모리 할당자 (Memory Allocators)</a></h3>
<p>이는 인터프리터를 격리하는 작업에서 가장 민감한 부분 중 하나입니다. 가장 간단한 해결책은 내부 "작은 블록(small block)" 할당자의 전역 상태를 <code>PyInterpreterState</code>로 이동하는 것입니다.</p>
<p>CPython은 "raw", "mem", "object" 세 가지 할당자 도메인을 가진 메모리 관리 C-API를 제공합니다. 이들은 현재 런타임 전역이며 모든 인터프리터에 의해 공유됩니다. "mem" 및 "object" 할당자는 스레드 안전하지 않을 수 있으며 현재 스레드 안전성을 위해 GIL에 의존할 수 있습니다.</p>
<p>궁극적으로 다음의 가장 간단한 옵션을 선택할 것입니다.</p>
<ul>
<li>할당자를 전역 런타임 상태에 유지합니다.</li>
<li>스레드 안전해야 한다고 요구합니다.</li>
<li>기본 객체 할당자("작은 블록" 할당자)의 상태를 <code>PyInterpreterState</code>로 이동합니다.</li>
</ul>
<h3 id="c-api"><a href="#c-api">C-API</a></h3>
<p>다음 API는 공개될 것입니다.</p>
<ul>
<li><code>PyInterpreterConfig</code> (구조체)</li>
<li><code>PyInterpreterConfig_INIT</code> (매크로)</li>
<li><code>PyInterpreterConfig_LEGACY_INIT</code> (매크로)</li>
<li><code>PyThreadState * Py_NewInterpreterFromConfig(PyInterpreterConfig *)</code></li>
</ul>
<p><code>PyInterpreterConfig</code>에 두 가지 새로운 필드가 추가됩니다.</p>
<ul>
<li><code>int own_gil</code>: 이 값이 참(1)이면 새 인터프리터는 자체 "전역" 인터프리터 잠금을 가집니다. 이는 새 인터프리터가 다른 인터프리터의 방해 없이 실행될 수 있음을 의미하며, 멀티 코어의 완전한 사용을 효과적으로 가능하게 합니다. 이 값이 거짓(0)이면 새 인터프리터는 메인 인터프리터의 잠금을 사용하며, 이는 CPython의 레거시(3.12 이전) 동작입니다.</li>
<li><code>int strict_extensions_compat</code>: <code>PyInterpreterState.strict_extension_compat</code>의 초기 값으로 사용됩니다.</li>
</ul>
<p><code>PyInterpreterConfig_INIT</code>는 격리된 인터프리터를 얻는 데 사용되며, <code>own_gil</code>은 <code>true</code>로 설정됩니다. <code>PyInterpreterConfig_LEGACY_INIT</code>는 기존 동작을 유지하며 <code>own_gil</code>은 <code>false</code>로 설정됩니다.</p>
<h3 id="확장-모듈-제한-restricting-extension-modules"><a href="#확장-모듈-제한-restricting-extension-modules">확장 모듈 제한 (Restricting Extension Modules)</a></h3>
<p>확장 모듈은 전역 변수에 상태가 저장될 때 런타임과 동일한 많은 문제를 가집니다. PEP 630은 격리를 지원하고 여러 인터프리터에서 동시에 안전하게 실행하기 위해 확장 모듈이 수행해야 하는 모든 세부 사항을 다룹니다.</p>
<p>확장 모듈이 다단계 초기화(multi-phase init, PEP 489 참조)를 구현하면 다중 인터프리터와 호환되는 것으로 간주됩니다. 그렇지 않은 모든 확장 모듈은 비호환으로 간주됩니다.</p>
<p>비호환 확장 모듈이 임포트되고 현재 <code>PyInterpreterState.strict_extension_compat</code> 값이 <code>true</code>이면 임포트 시스템은 <code>ImportError</code>를 발생시킵니다. 메인 인터프리터에서는 이 값이 <code>false</code>로 초기화되므로 임포트 실패가 발생하지 않습니다.</p>
<h3 id="확장-모듈-호환성-extension-module-compatibility"><a href="#확장-모듈-호환성-extension-module-compatibility">확장 모듈 호환성 (Extension Module Compatibility)</a></h3>
<p>많은 확장 모듈은 변경 없이도 다중 인터프리터(및 인터프리터별 GIL)에서 잘 작동하지만, 명시적으로 지원을 표시하지 않으면 임포트 시스템이 실패할 수 있습니다. 이를 해결하기 위해 <code>importlib.util.allow_all_extensions()</code>라는 컨텍스트 관리자를 추가하여 다중 인터프리터 지원 검사를 일시적으로 비활성화할 것입니다.</p>
<h3 id="확장-모듈-스레드-안전성-extension-module-thread-safety"><a href="#확장-모듈-스레드-안전성-extension-module-thread-safety">확장 모듈 스레드 안전성 (Extension Module Thread Safety)</a></h3>
<p>모듈이 다중 인터프리터 사용을 지원한다는 것은, 인터프리터들이 GIL을 공유하지 않더라도 작동한다는 것을 의미합니다. 한 가지 주의할 점은 모듈이 내부 전역 상태가 스레드 안전하지 않은 라이브러리에 링크될 때입니다. 공유 GIL이 있을 때는 이 상태가 보호되지만, GIL이 없을 때는 그러한 모듈이 잠금(lock)을 사용하여 해당 상태의 모든 사용을 감싸야 합니다.</p>
<p>현재, "다중 인터프리터 지원"과 "인터프리터별 GIL 지원"이 충분히 동일한지 명확하지 않습니다. 따라서 추가적인 조치가 필요할 수 있습니다. 잠정적인 해결책으로, 확장 모듈이 인터프리터별 GIL 하에 임포트될 수 있음을 나타내는 <code>PyModuleDef</code> 슬롯(slot)을 추가하는 것을 고려하고 있습니다.</p>
<h2 id="문서화-documentation"><a href="#문서화-documentation">문서화 (Documentation)</a></h2>
<ul>
<li>C-API: <code>Doc/c-api/init.rst</code>의 "Sub-interpreter support" 섹션에서 업데이트된 API와 인터프리터별 GIL의 결과를 상세히 설명할 것입니다.</li>
<li><code>importlib</code>: <code>ExtensionFileLoader</code> 항목은 서브 인터프리터에서 임포트가 실패할 수 있음을 명시하고, <code>importlib.util.allow_all_extensions()</code>에 대한 새로운 항목이 추가될 것입니다.</li>
</ul>
<h2 id="영향-impact"><a href="#영향-impact">영향 (Impact)</a></h2>
<h3 id="하위-호환성-backwards-compatibility"><a href="#하위-호환성-backwards-compatibility">하위 호환성 (Backwards Compatibility)</a></h3>
<p>이 제안으로 인해 변경될 의도적인 동작이나 API는 두 가지 예외를 제외하고는 없습니다.</p>
<ul>
<li>일부 확장 모듈은 특정 서브 인터프리터에서 임포트가 실패할 것입니다.</li>
<li>현재 스레드 안전하지 않은 "mem" 및 "object" 할당자는 다중 인터프리터와 함께 사용될 때 데이터 경쟁(data races)에 취약해질 수 있습니다.</li>
</ul>
<p>기존 인터프리터 관리 C-API는 현재 동작을 유지하며, 새로운 동작은 새로운 API를 통해 노출됩니다.</p>
<h3 id="확장-모듈-extension-modules"><a href="#확장-모듈-extension-modules">확장 모듈 (Extension Modules)</a></h3>
<p>가장 일반적인 Python 사용 시나리오(메인 인터프리터 단독 실행)에서는 이 제안이 확장 모듈에 미치는 영향은 없습니다. 기존 <code>Py_NewInterpreter()</code>를 사용하여 생성된 다중 인터프리터에서도 동작에는 변화가 없습니다.</p>
<p>일부 확장 모듈은 전역 변수에 모듈 상태를 유지하거나 링크된 라이브러리의 내부 상태로 인해 이미 다중 인터프리터에서 오작동하는 경우가 있습니다. 제안된 API를 적절한 설정으로 사용하여 다중 인터프리터를 생성하는 경우, 비호환 확장 모듈의 동작이 변경될 것입니다. 이러한 확장을 임포트하면 (메인 인터프리터 외부에서는) 실패할 것입니다.</p>
<p>또한, 일부 확장 모듈은 스레드 안전하지 않은 내부 전역 상태를 가진 라이브러리에 링크됩니다. 이러한 모듈은 해당 상태의 직접 또는 간접적인 사용을 잠금으로 감싸야 할 것입니다.</p>
<h3 id="확장-모듈-유지-관리자-extension-module-maintainers"><a href="#확장-모듈-유지-관리자-extension-module-maintainers">확장 모듈 유지 관리자 (Extension Module Maintainers)</a></h3>
<p>인터프리터별 GIL은 다중 인터프리터 사용의 증가를 촉진할 가능성이 높습니다. 일부 대규모 확장 모듈의 유지 관리자들은 이러한 증가로 인한 부담에 대해 우려를 표명했습니다. 다중 인터프리터 지원을 추가하는 것은 일부 확장 모듈에 상당한 작업을 요구할 수 있습니다.</p>
<p>확장 유지 관리자는 다중 인터프리터 사용에 대한 지원을 추가하지 않을 자유가 있지만, 기능의 인기가 높아지면 사용자들이 그러한 지원을 점점 더 요구할 것입니다.</p>
<h3 id="대체-python-구현-alternate-python-implementations"><a href="#대체-python-구현-alternate-python-implementations">대체 Python 구현 (Alternate Python Implementations)</a></h3>
<p>다른 Python 구현은 동일 프로세스 내에서 다중 인터프리터 지원을 제공할 의무는 없습니다.</p>
<h3 id="보안-영향-security-implications"><a href="#보안-영향-security-implications">보안 영향 (Security Implications)</a></h3>
<p>이 제안으로 인한 알려진 보안 영향은 없습니다.</p>
<h3 id="유지-보수성-maintainability"><a href="#유지-보수성-maintainability">유지 보수성 (Maintainability)</a></h3>
<p>이 제안은 CPython의 유지 보수성을 향상시키는 여러 개선 사항을 이미 촉진했으며, 이는 계속될 것으로 예상됩니다. 또한, 기존 런타임 결함이 노출되어 수정되었으며, 다중 인터프리터 사용이 증가함에 따라 이러한 경향은 계속될 것입니다. 전반적으로 유지 보수성에 긍정적인 영향을 미칠 것으로 예상됩니다.</p>
<h3 id="성능-performance"><a href="#성능-performance">성능 (Performance)</a></h3>
<p>전역 변수를 통합하는 작업은 이미 CPython의 성능(속도 향상 및 메모리 사용량 감소)에 여러 개선 사항을 제공했으며, 이는 계속될 것입니다. 인터프리터별 GIL 자체의 성능 이점은 아직 탐색되지 않았지만, CPython을 느리게 만들 것으로 예상되지는 않습니다. 그리고 분명히, Python 코드에서 다양한 멀티 코어 병렬 처리를 가능하게 할 것입니다.</p>
<h2 id="교육-방법-how-to-teach-this"><a href="#교육-방법-how-to-teach-this">교육 방법 (How to Teach This)</a></h2>
<p>PEP 554와 달리, 이 기능은 C-API의 특정 사용자층을 위한 고급 기능입니다. API의 세부 사항이나 직접적인 적용 방법을 가르칠 필요는 없습니다.</p>
<p>다만, 교육이 필요하다면 다음과 같이 요약할 수 있습니다.</p>
<p>"Py_NewInterpreter() 외에도, Py_NewInterpreterFromConfig()를 사용하여 인터프리터를 생성할 수 있습니다. 전달하는 설정은 해당 인터프리터가 어떻게 동작하기를 원하는지 나타냅니다."</p>
<p>또한, 격리된 인터프리터를 생성하는 확장 모듈의 유지 관리자는 사용자에게 인터프리터별 GIL의 결과를 설명해야 할 것입니다.</p>
<h2 id="추가-컨텍스트-extra-context"><a href="#추가-컨텍스트-extra-context">추가 컨텍스트 (Extra Context)</a></h2>
<h3 id="전역-객체-공유-sharing-global-objects"><a href="#전역-객체-공유-sharing-global-objects">전역 객체 공유 (Sharing Global Objects)</a></h3>
<p>일부 전역 객체는 인터프리터 간에 공유됩니다. 이는 구현 세부 사항이지만, 불멸 객체(PEP 683)를 통해 변경 불가능한 전역 객체를 공유함으로써 추가적인 복잡성과 성능 저하를 피할 수 있습니다.</p>
<h3 id="c-api에-노출된-객체-objects-exposed-in-the-c-api"><a href="#c-api에-노출된-객체-objects-exposed-in-the-c-api">C-API에 노출된 객체 (Objects Exposed in the C-API)</a></h3>
<p>C-API는 모든 내장 타입(builtin types), 내장 예외(builtin exceptions) 및 내장 싱글톤(builtin singletons)을 노출합니다. 불멸 객체가 도입되면서 이는 더 이상 문제가 되지 않습니다.</p>
<h3 id="런타임-전역-상태-통합-consolidating-runtime-global-state"><a href="#런타임-전역-상태-통합-consolidating-runtime-global-state">런타임 전역 상태 통합 (Consolidating Runtime Global State)</a></h3>
<p>CPython의 전역 상태를 <code>_PyRuntimeState</code> 구조체로 통합하려는 활발한 노력이 진행 중입니다. 이 프로젝트는 C 전역 변수에서 상태를 이동하는 것을 목표로 합니다.</p>
<p><strong>통합의 이점 (Benefits to Consolidation)</strong></p>
<ul>
<li>C 전역 변수의 수를 크게 줄입니다.</li>
<li>불안정하거나 깨진 런타임 상태에 주의를 기울이게 합니다.</li>
<li>런타임 상태 사용 방식의 일관성을 촉진합니다.</li>
<li>CPython의 런타임 상태를 더 쉽게 발견/식별할 수 있습니다.</li>
<li>런타임 상태를 일관된 방식으로 정적으로 할당하기 쉽게 만듭니다.</li>
<li>런타임 상태에 대한 더 나은 메모리 지역성(locality)을 제공합니다.</li>
</ul>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BlogPosting\",\"headline\":\"[Final] PEP 684 - A Per-Interpreter GIL\",\"description\":\"Python Enhancement Proposal 684: 'A Per-Interpreter GIL'에 대한 한국어 번역입니다.\",\"url\":\"https://blog.secrett2633.cloud/python/pep/684\",\"datePublished\":\"2025-09-27T01:11:59.000Z\",\"dateModified\":\"2025-09-27T01:11:59.000Z\",\"author\":{\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\"},\"publisher\":{\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\"},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://blog.secrett2633.cloud/python/pep/684\"},\"image\":\"https://blog.secrett2633.cloud/og-default.png\",\"isAccessibleForFree\":true,\"inLanguage\":\"ko\",\"wordCount\":1865,\"articleSection\":\"Python\",\"keywords\":\"Python, PEP, Translation\"}"}}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BreadcrumbList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"홈\",\"item\":\"https://blog.secrett2633.cloud/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"[Final] PEP 684 - A Per-Interpreter GIL\",\"item\":\"https://blog.secrett2633.cloud/python/pep/684\"}]}"}}],["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","aria-label":"카테고리 네비게이션","children":[["$","div","Backend",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","$L7",null,{"href":"/backend/django","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","$L7",null,{"href":"/backend/logging","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","$L7",null,{"href":"/python/pep","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","$L7",null,{"href":"/ai/llm","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","$L7",null,{"href":"/ai/review","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",2728,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","$L7",null,{"href":"/devops/nginx","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","$L7",null,{"href":"/devops/docker","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","$L7",null,{"href":"/devops/safeline","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","$L7",null,{"href":"/devops/jenkins","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","$L7",null,{"href":"/devops/github-actions","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","$L7",null,{"href":"/devops/aws","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","$L7",null,{"href":"/etc/me","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","$L7",null,{"href":"/etc/chrome-extension","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","div",null,{"className":"flex-1","children":[["$","nav",null,{"aria-label":"breadcrumb","className":"text-sm text-gray-500 mb-4","children":["$","ol",null,{"className":"flex flex-wrap items-center gap-1","children":[["$","li",null,{"children":["$","$L7",null,{"href":"/","className":"hover:text-gray-700","children":"홈"}]}],[["$","li","/python/pep/684",{"className":"flex items-center gap-1","children":[["$","span",null,{"aria-hidden":"true","children":"/"}],["$","span",null,{"className":"text-gray-900","aria-current":"page","children":"[Final] PEP 684 - A Per-Interpreter GIL"}]]}]]]}]}],["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 684 - A Per-Interpreter GIL"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-27 10:11:59+0900","children":"2025년 9월 27일"}],["$","time",null,{"className":"ml-4","dateTime":"2025-09-27T01:11:59.000Z","children":["수정: ","2025년 9월 27일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$a"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","span",null,{"className":"text-sm font-medium text-gray-900 mb-2 block","children":"태그"}],[["$","$L7","Python",{"href":"/tags/Python","className":"page__taxonomy-item","children":["#","Python"]}],["$","$L7","PEP",{"href":"/tags/PEP","className":"page__taxonomy-item","children":["#","PEP"]}],["$","$L7","Translation",{"href":"/tags/Translation","className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}],["$","$Lb",null,{"postPermalink":"/python/pep/684","postId":"2025-09-27-pep-0684-a-per-interpreter-gil"}],["$","section",null,{"className":"mt-12 border-t border-gray-200 pt-8","children":[["$","h3",null,{"className":"text-base font-semibold text-gray-900 mb-4","children":["Python"," 의 다른글"]}],["$","ul",null,{"className":"space-y-2 text-sm","children":[["$","li",null,{"className":"text-gray-500","children":["이전글"," ",["$","$L7",null,{"href":"/python/pep/683","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Final] PEP 683 - Immortal Objects, Using a Fixed Refcount"}]]}],["$","li",null,{"className":"text-gray-900 font-semibold","children":["현재글 : ","[Final] PEP 684 - A Per-Interpreter GIL"]}],["$","li",null,{"className":"text-gray-500","children":["다음글"," ",["$","$L7",null,{"href":"/python/pep/685","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Final] PEP 685 - Comparison of extra names for optional distribution dependencies"}]]}]]}]]}]]}]]}]]}]]
9:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"[Final] PEP 684 - A Per-Interpreter GIL - secrett2633's blog"}],["$","meta","3",{"name":"description","content":"Python Enhancement Proposal 684: 'A Per-Interpreter GIL'에 대한 한국어 번역입니다."}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","link","5",{"rel":"manifest","href":"/manifest.json","crossOrigin":"use-credentials"}],["$","meta","6",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","7",{"name":"creator","content":"secrett2633"}],["$","meta","8",{"name":"publisher","content":"secrett2633"}],["$","meta","9",{"name":"robots","content":"index, follow"}],["$","meta","10",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","11",{"rel":"canonical","href":"https://blog.secrett2633.cloud/python/pep/684"}],["$","meta","12",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","13",{"property":"og:title","content":"[Final] PEP 684 - A Per-Interpreter GIL"}],["$","meta","14",{"property":"og:description","content":"Python Enhancement Proposal 684: 'A Per-Interpreter GIL'에 대한 한국어 번역입니다."}],["$","meta","15",{"property":"og:url","content":"https://blog.secrett2633.cloud/python/pep/684"}],["$","meta","16",{"property":"og:type","content":"article"}],["$","meta","17",{"property":"article:published_time","content":"2025-09-27T01:11:59.000Z"}],["$","meta","18",{"property":"article:modified_time","content":"2025-09-27T01:11:59.000Z"}],["$","meta","19",{"property":"article:author","content":"secrett2633"}],["$","meta","20",{"property":"article:section","content":"Python"}],["$","meta","21",{"property":"article:tag","content":"Python"}],["$","meta","22",{"property":"article:tag","content":"PEP"}],["$","meta","23",{"property":"article:tag","content":"Translation"}],["$","meta","24",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","25",{"name":"twitter:creator","content":"@secrett2633"}],["$","meta","26",{"name":"twitter:title","content":"[Final] PEP 684 - A Per-Interpreter GIL"}],["$","meta","27",{"name":"twitter:description","content":"Python Enhancement Proposal 684: 'A Per-Interpreter GIL'에 대한 한국어 번역입니다."}],["$","link","28",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","29",{"name":"next-size-adjust"}]]
1:null
