<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/da5e1dc2b9a7c5bb.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-aecaf5ac7a84facf.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-e3ea38185bb36cd2.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Superseded] PEP 433 - Easier suppression of file descriptor inheritance</h1><div class="page__meta"><time dateTime="2025-09-26 21:45:26+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0433/">PEP 433 - Easier suppression of file descriptor inheritance</a></p>
<p><strong>상태:</strong> Superseded | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 10-Jan-2013</p>
</blockquote>
<h1>PEP 433 – 파일 디스크립터 상속을 더 쉽게 억제하기 (Easier suppression of file descriptor inheritance)</h1>
<ul>
<li><strong>작성자</strong>: Victor Stinner </li>
<li><strong>상태</strong>: Superseded (폐기됨 - PEP 446으로 대체됨)</li>
<li><strong>유형</strong>: Standards Track</li>
<li><strong>생성일</strong>: 2013년 1월 10일</li>
<li><strong>Python 버전</strong>: 3.4</li>
<li><strong>대체</strong>: PEP 446</li>
</ul>
<h2>목차</h2>
<ul>
<li><a href="#%EC%9A%94%EC%95%BD-abstract">요약 (Abstract)</a></li>
<li><a href="#%EB%B0%B0%EA%B2%BD-rationale">배경 (Rationale)</a>
<ul>
<li><a href="#python-33%EC%97%90%EC%84%9C%EC%9D%98-%ED%98%84%ED%99%A9">Python 3.3에서의 현황</a></li>
<li><a href="#%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0-%EC%83%81%EC%86%8D-%EB%AC%B8%EC%A0%9C">파일 디스크립터 상속 문제</a>
<ul>
<li><a href="#%EB%B3%B4%EC%95%88-security">보안 (Security)</a></li>
<li><a href="#%EC%9B%90%EC%9E%90%EC%84%B1-atomicity">원자성 (Atomicity)</a></li>
<li><a href="#%EC%9D%B4%EC%8B%9D%EC%84%B1-portability">이식성 (Portability)</a></li>
</ul>
</li>
<li><a href="#%EB%B2%94%EC%9C%84-scope">범위 (Scope)</a></li>
</ul>
</li>
<li><a href="#%EC%A0%9C%EC%95%88-proposal">제안 (Proposal)</a></li>
<li><a href="#%EB%8C%80%EC%95%88-alternatives">대안 (Alternatives)</a>
<ul>
<li><a href="#%EC%83%81%EC%86%8D%EC%9D%B4-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%99%9C%EC%84%B1%ED%99%94%EB%90%98%EA%B3%A0-%EA%B8%B0%EB%B3%B8%EA%B0%92%EC%9D%80-%EC%84%A4%EC%A0%95-%EB%B6%88%EA%B0%80%EB%8A%A5">상속이 기본적으로 활성화되고, 기본값은 설정 불가능</a></li>
<li><a href="#%EC%83%81%EC%86%8D%EC%9D%B4-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%99%9C%EC%84%B1%ED%99%94%EB%90%98%EA%B3%A0-%EA%B8%B0%EB%B3%B8%EA%B0%92%EC%9D%80-true%EB%A1%9C%EB%A7%8C-%EC%84%A4%EC%A0%95-%EA%B0%80%EB%8A%A5">상속이 기본적으로 활성화되고, 기본값은 <code>True</code>로만 설정 가능</a></li>
<li><a href="#%EC%83%81%EC%86%8D%EC%9D%84-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94">상속을 기본적으로 비활성화</a></li>
<li><a href="#fork-%EC%9D%B4%ED%9B%84-%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0-%EB%8B%AB%EA%B8%B0"><code>fork()</code> 이후 파일 디스크립터 닫기</a></li>
<li><a href="#open-%EB%AA%A8%EB%93%9C%EC%97%90-e-%ED%94%8C%EB%9E%98%EA%B7%B8-%EC%B6%94%EA%B0%80"><code>open()</code>: 모드에 "e" 플래그 추가</a></li>
<li><a href="#%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%9D%B4%EB%A6%84%EC%97%90-%EB%8C%80%ED%95%9C-%EB%85%BC%EC%9D%98">새로운 매개변수 이름에 대한 논의</a></li>
</ul>
</li>
<li><a href="#%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0-%EC%83%81%EC%86%8D%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98">파일 디스크립터 상속을 사용하는 애플리케이션</a></li>
<li><a href="#%EC%84%B1%EB%8A%A5-performances">성능 (Performances)</a></li>
<li><a href="#%EA%B5%AC%ED%98%84-implementation">구현 (Implementation)</a>
<ul>
<li><code>os.get_cloexec(fd)</code></li>
<li><code>os.set_cloexec(fd, cloexec=True)</code></li>
<li><code>open()</code></li>
<li><code>os.dup()</code></li>
<li><code>os.dup2()</code></li>
<li><code>os.pipe()</code></li>
<li><code>socket.socket()</code></li>
<li><code>socket.socketpair()</code></li>
<li><code>socket.socket.accept()</code></li>
</ul>
</li>
<li><a href="#%ED%95%98%EC%9C%84-%ED%98%B8%ED%99%98%EC%84%B1-backward-compatibility">하위 호환성 (Backward compatibility)</a></li>
<li><a href="#%EB%B6%80%EB%A1%9D-%EC%9A%B4%EC%98%81-%EC%B2%B4%EC%A0%9C-%EC%A7%80%EC%9B%90-appendix-operating-system-support">부록: 운영 체제 지원 (Appendix: Operating system support)</a>
<ul>
<li><a href="#windows">Windows</a></li>
<li><code>ioctl</code></li>
<li><code>fcntl</code></li>
<li><a href="#%EC%9B%90%EC%9E%90%EC%A0%81-%ED%94%8C%EB%9E%98%EA%B7%B8-atomic-flags">원자적 플래그 (Atomic flags)</a></li>
</ul>
</li>
<li><a href="#%EB%A7%81%ED%81%AC-links">링크 (Links)</a></li>
<li><a href="#%EA%B0%81%EC%A3%BC-footnotes">각주 (Footnotes)</a></li>
<li><a href="#%EC%A0%80%EC%9E%91%EA%B6%8C-copyright">저작권 (Copyright)</a></li>
</ul>
<h2>요약 (Abstract)</h2>
<p>이 PEP는 파일 디스크립터 (File Descriptor)를 생성하는 함수에 새로운 선택적 <code>cloexec</code> 매개변수를 추가하고, 이 매개변수의 기본값을 변경하는 다양한 방법을 도입하며, 다음과 같은 네 가지 새로운 함수를 추가할 것을 제안합니다.</p>
<ul>
<li><code>os.get_cloexec(fd)</code></li>
<li><code>os.set_cloexec(fd, cloexec=True)</code></li>
<li><code>sys.getdefaultcloexec()</code></li>
<li><code>sys.setdefaultcloexec(cloexec)</code></li>
</ul>
<h2>배경 (Rationale)</h2>
<p>파일 디스크립터는 <code>close-on-exec</code> 플래그를 가지고 있으며, 이 플래그는 파일 디스크립터가 상속될지 여부를 나타냅니다.</p>
<p>UNIX 시스템에서 <code>close-on-exec</code> 플래그가 설정되면, 파일 디스크립터는 자식 프로세스의 실행 시 닫히므로 상속되지 않습니다. 그렇지 않으면 파일 디스크립터는 자식 프로세스에 의해 상속됩니다.</p>
<p>Windows 시스템에서 <code>close-on-exec</code> 플래그가 설정되면 파일 디스크립터는 상속되지 않습니다. <code>close-on-exec</code> 플래그가 해제되고 <code>CreateProcess()</code> 함수가 <code>bInheritHandles</code> 매개변수를 <code>TRUE</code>로 설정하여 호출될 경우 (예를 들어 <code>subprocess.Popen</code>이 <code>close_fds=False</code>로 생성될 때), 파일 디스크립터는 자식 프로세스에 의해 상속됩니다. Windows에는 "close-on-exec" 플래그는 없지만, 그와 반대되는 값을 가진 상속 플래그가 있습니다. 예를 들어, <code>close-on-exec</code> 플래그를 설정하는 것은 핸들(handle)의 <code>HANDLE_FLAG_INHERIT</code> 플래그를 해제하는 것을 의미합니다.</p>
<h3>Python 3.3에서의 현황</h3>
<p>UNIX에서는 Python 3.2부터 <code>subprocess</code> 모듈이 기본적으로 파일 디스크립터 2번(stderr)보다 큰 모든 파일 디스크립터를 닫습니다. [cite: 1,  각주 1] 부모 프로세스에 의해 생성된 모든 파일 디스크립터는 자식 프로세스에서 자동으로 닫힙니다.</p>
<p><code>xmlrpc.server.SimpleXMLRPCServer</code>는 리스닝 소켓 (listening socket)의 <code>close-on-exec</code> 플래그를 설정하지만, 부모 클래스인 <code>socketserver.TCPServer</code>는 이 플래그를 설정하지 않습니다.</p>
<p><code>os.spawn*()</code> 및 <code>os.exec*()</code> 계열 함수와 <code>exec()</code> 또는 <code>fork()</code> + <code>exec()</code>를 호출하는 서드파티 모듈을 통해 서브프로세스를 생성하거나 새 프로그램을 실행할 때 파일 디스크립터가 닫히지 않는 다른 경우가 있습니다. 이 경우, 파일 디스크립터는 부모 프로세스와 자식 프로세스 간에 공유되는데, 이는 일반적으로 예상치 못한 동작이며 다양한 문제를 야기합니다.</p>
<p>이 PEP는 Python 3.2에서 <code>subprocess</code> 모듈의 변경으로 시작된 작업을 계속하여, <code>subprocess</code>를 사용하는 코드뿐만 아니라 모든 코드에서 이 문제를 해결할 것을 제안합니다.</p>
<h3>파일 디스크립터 상속 문제</h3>
<p>부모 프로세스에서 파일 디스크립터를 닫아도 관련 리소스 (파일, 소켓 등)는 자식 프로세스에서 여전히 열려 있기 때문에 닫히지 않습니다.</p>
<p><code>TCPServer</code>의 리스닝 소켓은 <code>exec()</code> 시 닫히지 않습니다. 이로 인해 자식 프로세스가 새 클라이언트로부터 연결을 받을 수 있으며, 만약 부모 프로세스가 리스닝 소켓을 닫고 동일한 주소에 새 리스닝 소켓을 생성하려고 하면 "address already in use" (주소가 이미 사용 중) 오류가 발생할 수 있습니다.</p>
<p>파일 디스크립터를 닫지 않으면 리소스 고갈로 이어질 수 있습니다. 부모가 모든 파일을 닫아도, 자식 프로세스에 파일이 여전히 열려 있기 때문에 "too many files" (파일이 너무 많음) 오류로 인해 새 파일 디스크립터 생성이 실패할 수 있습니다.</p>
<p>관련된 문제들은 다음과 같습니다.</p>
<ul>
<li>Issue #2320: <code>subprocess</code>에서 <code>stdin</code>을 사용하는 경합 조건 (Race condition) (2008)</li>
<li>Issue #3006: <code>subprocess.Popen</code>이 닫힌 후에도 소켓이 열려 있음 (2008)</li>
<li>Issue #7213: <code>subprocess</code>가 <code>Popen</code> 인스턴스 간에 열린 파일 디스크립터를 누출하여 중단 발생 (2009)</li>
<li>Issue #12786: <code>stdin</code>이 닫힐 때 <code>subprocess.wait()</code>가 중단됨 (2011)</li>
</ul>
<h4>보안 (Security)</h4>
<p>파일 디스크립터 누출은 중대한 보안 취약점입니다. 신뢰할 수 없는 자식 프로세스가 암호와 같은 민감한 데이터를 읽거나 누출된 파일 디스크립터를 통해 부모 프로세스를 제어할 수 있습니다. 예를 들어, <code>chroot</code>를 탈출하는 알려진 취약점입니다.</p>
<p>CERT 권고 사항: FIO42-C. 더 이상 필요하지 않은 파일은 올바르게 닫히도록 해야 합니다.</p>
<p>취약점 사례:</p>
<ul>
<li>OpenSSH Security Advisory: <code>portable-keysign-rand-helper.adv</code> (2011년 4월)</li>
<li>CWE-403: 의도하지 않은 제어 영역으로의 파일 디스크립터 노출 (2008)</li>
<li><code>mod_php</code>를 통한 Apache <code>https</code> 하이재킹 (2003년 12월)</li>
<li>Apache: <code>APR_FOPEN_NOCLEANUP</code>이 설정되지 않은 경우 <code>Apr</code>는 <code>FD_CLOEXEC</code>을 설정해야 함 (2009년 수정됨)</li>
<li>PHP: <code>system()</code> (및 유사 함수)는 Apache에 의해 열린 핸들을 정리하지 않음 (2013년 1월 기준 미수정)</li>
</ul>
<h4>원자성 (Atomicity)</h4>
<p>멀티스레드 애플리케이션에서 <code>fcntl()</code>을 사용하여 <code>close-on-exec</code> 플래그를 설정하는 것은 안전하지 않습니다. 만약 파일 디스크립터 생성과 <code>fcntl(fd, F_SETFD, new_flags)</code> 호출 사이에 스레드가 <code>fork()</code> 및 <code>exec()</code>를 호출한다면, 파일 디스크립터는 자식 프로세스에 의해 상속될 것입니다. 최신 운영 체제는 파일 디스크립터 생성 중에 플래그를 설정하는 함수를 제공하여 경합 조건 (race condition)을 방지합니다.</p>
<h4>이식성 (Portability)</h4>
<p>Python 3.2는 <code>socket.SOCK_CLOEXEC</code> 플래그를 추가했고, Python 3.3은 <code>os.O_CLOEXEC</code> 플래그와 <code>os.pipe2()</code> 함수를 추가했습니다. Python 3.3에서는 파일 열기, 파이프 또는 소켓 생성 시 <code>close-on-exec</code> 플래그를 원자적으로 (atomically) 설정하는 것이 이미 가능합니다.</p>
<p>문제는 이러한 플래그와 함수들이 이식성이 없다는 것입니다. 즉, 최신 버전의 운영 체제에서만 지원됩니다. <code>O_CLOEXEC</code> 및 <code>SOCK_CLOEXEC</code> 플래그는 오래된 Linux 버전에서는 무시되므로, <code>fcntl(fd, F_GETFD)</code>를 사용하여 <code>FD_CLOEXEC</code> 플래그를 확인해야 합니다. 커널이 <code>O_CLOEXEC</code> 또는 <code>SOCK_CLOEXEC</code> 플래그를 무시하는 경우, <code>close-on-exec</code> 플래그를 설정하기 위해 <code>fcntl(fd, F_SETFD, flags)</code> 호출이 필요합니다.</p>
<p>참고: OpenBSD 5.2 이전 버전은 <code>fork()</code>가 <code>exec()</code> 전에 사용되면 <code>close-on-exec</code> 플래그가 설정된 파일 디스크립터를 닫지 않지만, <code>exec()</code>가 <code>fork()</code> 없이 호출되면 올바르게 작동합니다.</p>
<h3>범위 (Scope)</h3>
<p>애플리케이션은 <code>fork()</code> 이후에도 파일 디스크립터를 명시적으로 닫아야 합니다. <code>close-on-exec</code> 플래그는 <code>exec()</code> 이후, 즉 <code>fork()</code> + <code>exec()</code> 이후에만 파일 디스크립터를 닫습니다.</p>
<p>이 PEP는 Python 표준 라이브러리 또는 표준 라이브러리를 사용하는 모듈에 의해 생성된 파일 디스크립터의 <code>close-on-exec</code> 플래그만 변경합니다. 표준 라이브러리를 사용하지 않는 서드파티 모듈은 이 PEP에 따르도록 수정되어야 합니다. 예를 들어, 새로운 <code>os.set_cloexec()</code> 함수를 사용할 수 있습니다.</p>
<p>참고: <code>exec()</code> 없는 <code>fork()</code>의 가능한 해결책은 "Close file descriptors after fork" 섹션을 참조하십시오.</p>
<h2>제안 (Proposal)</h2>
<p>파일 디스크립터를 생성하는 함수에 새로운 선택적 <code>cloexec</code> 매개변수를 추가하고, 이 매개변수의 기본값을 변경하는 다양한 방법을 추가합니다.</p>
<p>다음과 같은 새로운 함수를 추가합니다.</p>
<ul>
<li><code>os.get_cloexec(fd:int) -> bool</code>: 파일 디스크립터의 <code>close-on-exec</code> 플래그를 가져옵니다. 모든 플랫폼에서 사용 가능하지 않을 수 있습니다.</li>
<li><code>os.set_cloexec(fd:int, cloexec:bool=True)</code>: 파일 디스크립터에 <code>close-on-exec</code> 플래그를 설정하거나 해제합니다. 모든 플랫폼에서 사용 가능하지 않을 수 있습니다.</li>
<li><code>sys.getdefaultcloexec() -> bool</code>: <code>cloexec</code> 매개변수의 현재 기본값을 가져옵니다.</li>
<li><code>sys.setdefaultcloexec(cloexec: bool)</code>: <code>cloexec</code> 매개변수의 기본값을 설정합니다.</li>
</ul>
<p>다음 함수들에 새로운 선택적 <code>cloexec</code> 매개변수를 추가합니다.</p>
<ul>
<li><code>asyncore.dispatcher.create_socket()</code></li>
<li><code>io.FileIO</code></li>
<li><code>io.open()</code></li>
<li><code>open()</code></li>
<li><code>os.dup()</code></li>
<li><code>os.dup2()</code></li>
<li><code>os.fdopen()</code></li>
<li><code>os.open()</code></li>
<li><code>os.openpty()</code></li>
<li><code>os.pipe()</code></li>
<li><code>select.devpoll()</code></li>
<li><code>select.epoll()</code></li>
<li><code>select.kqueue()</code></li>
<li><code>socket.socket()</code></li>
<li><code>socket.socket.accept()</code></li>
<li><code>socket.socket.dup()</code></li>
<li><code>socket.socket.fromfd</code></li>
<li><code>socket.socketpair()</code></li>
</ul>
<p><code>cloexec</code> 매개변수의 기본값은 <code>sys.getdefaultcloexec()</code>입니다.</p>
<p>기본적으로 <code>close-on-exec</code> 플래그를 설정하기 위해 새로운 명령줄 옵션 <code>-e</code>와 환경 변수 <code>PYTHONCLOEXEC</code>를 추가합니다.</p>
<p><code>subprocess</code> 모듈은 <code>pass_fds</code> 매개변수에 나열된 파일 디스크립터의 <code>close-on-exec</code> 플래그를 해제합니다.</p>
<p>표준 라이브러리에서 파일 디스크립터를 생성하는 모든 함수는 <code>cloexec</code> 매개변수의 기본값인 <code>sys.getdefaultcloexec()</code>를 따라야 합니다.</p>
<p>파일 디스크립터 0 (<code>stdin</code>), 1 (<code>stdout</code>), 2 (<code>stderr</code>)는 상속될 것으로 예상되지만, Python은 이들을 다르게 처리하지 않습니다. 표준 스트림을 대체하기 위해 <code>os.dup2()</code>가 사용될 경우, <code>cloexec=False</code>를 명시적으로 지정해야 합니다.</p>
<p>제안의 단점:</p>
<ul>
<li>새로 생성된 파일 디스크립터에서 <code>close-on-exec</code> 플래그가 설정될지 여부를 소스 코드만으로는 알 수 없게 됩니다.</li>
<li>파일 디스크립터의 상속이 중요한 경우, <code>cloexec</code> 매개변수를 명시적으로 지정해야 하며, 그렇지 않으면 라이브러리나 애플리케이션이 <code>cloexec</code> 매개변수의 기본값에 따라 다르게 작동할 수 있습니다.</li>
</ul>
<h2>대안 (Alternatives)</h2>
<h3>상속이 기본적으로 활성화되고, 기본값은 설정 불가능</h3>
<p>파일 디스크립터를 생성하는 함수에 새로운 선택적 <code>cloexec</code> 매개변수를 추가합니다. <code>cloexec</code> 매개변수의 기본값은 <code>False</code>이며, 이 기본값은 변경할 수 없습니다. 파일 디스크립터 상속이 기본적으로 활성화되는 것은 POSIX 및 Windows의 기본 동작과도 일치합니다. 이 대안은 가장 보수적인 옵션입니다.</p>
<p>이 옵션은 "배경" 섹션에 나열된 문제를 해결하지 못하며, 단지 문제를 해결하기 위한 도우미를 제공할 뿐입니다. 이러한 모든 문제를 해결하기 위해 애플리케이션에서 사용되는 각 모듈에서 파일 디스크립터를 생성하는 모든 함수를 수정하여 <code>cloexec=True</code>를 설정해야 합니다.</p>
<h3>상속이 기본적으로 활성화되고, 기본값은 <code>True</code>로만 설정 가능</h3>
<p>이 대안은 제안을 기반으로 합니다. 유일한 차이점은 <code>sys.setdefaultcloexec()</code>가 어떤 인수도 받지 않고, <code>cloexec</code> 매개변수의 기본값을 <code>True</code>로만 설정할 수 있다는 것입니다.</p>
<h3>상속을 기본적으로 비활성화</h3>
<p>이 대안은 제안을 기반으로 합니다. 유일한 차이점은 <code>cloexec</code> 매개변수의 기본값이 <code>True</code>라는 것입니다 (기존 <code>False</code> 대신).</p>
<p>자식 프로세스에 의해 파일이 상속되어야 하는 경우, <code>cloexec=False</code> 매개변수를 사용할 수 있습니다.</p>
<p>기본적으로 <code>close-on-exec</code> 플래그를 설정하는 것의 장점:</p>
<ul>
<li><code>exec</code> 시 FD (파일 디스크립터) 상속으로 인해 발생하는 문제로 고통받는 프로그램 (Inherited file descriptors issues 및 Security 참조)이 상속에 의존하는 프로그램 (Applications using inheritance of file descriptors 참조)보다 훨씬 많습니다.</li>
</ul>
<p>기본적으로 <code>close-on-exec</code> 플래그를 설정하는 것의 단점:</p>
<ul>
<li>"최소 놀람의 원칙" (principle of least surprise)을 위반합니다. <code>os</code> 모듈을 사용하는 개발자들은 Python이 POSIX 표준을 따르고 <code>close-on-exec</code> 플래그가 기본적으로 설정되지 않을 것이라고 예상할 수 있습니다. <code>os</code> 모듈은 시스템 호출 (C 표준 라이브러리의 함수)에 대한 얇은 래퍼 (thin wrapper)로 작성되었습니다. <code>close-on-exec</code> 플래그를 설정하는 원자적 플래그가 지원되지 않는 경우 (Appendix: Operating system support 참조), 단일 Python 함수 호출이 2개 또는 3개의 시스템 호출을 할 수 있습니다 (Performances 섹션 참조). 추가적인 시스템 호출이 있다면 Python을 느리게 할 수 있습니다 (Performances 참조).</li>
</ul>
<p>하위 호환성: 파일 디스크립터 상속에 의존하는 프로그램은 소수에 불과하며, 일반적으로 하나 또는 몇 개의 파일 디스크립터만 전달합니다. 이러한 프로그램들은 <code>EBADF</code> 오류로 즉시 실패할 것이고, <code>cloexec=False</code> 매개변수를 추가하거나 <code>os.set_cloexec(fd, False)</code>를 사용하여 쉽게 수정할 수 있을 것입니다.</p>
<p><code>subprocess</code> 모듈은 <code>Popen</code> 생성자의 <code>pass_fds</code> 매개변수에 나열된 파일 디스크립터의 <code>close-on-exec</code> 플래그를 해제하도록 어차피 변경될 것입니다. 따라서 이러한 프로그램들이 <code>subprocess</code> 모듈을 사용하는 경우 어떤 수정도 필요하지 않을 수 있습니다.</p>
<h3><code>fork()</code> 이후 파일 디스크립터 닫기</h3>
<p>이 PEP는 <code>exec()</code> 없이 <code>fork()</code>를 사용하는 애플리케이션의 문제를 해결하지 않습니다. Python은 <code>fork</code> 이후 호출될 콜백 (callback)을 등록하는 일반적인 프로세스가 필요하며, Issue #16500: <code>atfork</code> 모듈 추가를 참조하십시오. 이러한 레지스트리는 <code>fork()</code> 직후 파일 디스크립터를 닫는 데 사용될 수 있습니다.</p>
<p>단점:</p>
<ul>
<li>Windows에서는 <code>fork()</code>가 존재하지 않으므로 Windows에서는 이 문제가 해결되지 않습니다.</li>
<li>이 대안은 <code>fork()</code> 없이 <code>exec()</code>를 사용하는 프로그램의 문제를 해결하지 못합니다.</li>
<li>서드파티 모듈은 C 함수 <code>fork()</code>를 직접 호출할 수 있으며, 이 경우 "atfork" 콜백이 호출되지 않습니다.</li>
<li>파일 디스크립터를 생성하는 모든 함수는 콜백을 등록해야 하며, 파일이 닫힐 때 콜백을 등록 해제해야 합니다. 또는 열린 모든 파일 디스크립터 목록이 유지되어야 합니다.</li>
<li>파일 디스크립터를 자동으로 닫는 것은 Python보다는 운영 체제가 더 적합한 곳입니다. 예를 들어, 파일을 닫는 것과 파일을 닫는 콜백을 등록 해제하는 것 사이의 경합 조건을 피하기는 쉽지 않습니다.</li>
</ul>
<h3><code>open()</code>: 모드에 "e" 플래그 추가</h3>
<p>새로운 "e" 모드는 <code>close-on-exec</code> 플래그를 (최선을 다해) 설정할 것입니다.</p>
<p>이 대안은 <code>open()</code>에 대한 문제만 해결합니다. <code>socket.socket()</code> 및 <code>os.pipe()</code>에는 예를 들어 <code>mode</code> 매개변수가 없습니다.</p>
<p>GNU libc는 버전 2.7부터 <code>fopen()</code>에 "e" 플래그를 지원합니다. 이는 <code>O_CLOEXEC</code>가 사용 가능하면 사용하고, 그렇지 않으면 <code>fcntl(fd, F_SETFD, FD_CLOEXEC)</code>를 사용합니다. Visual Studio에서는 <code>fopen()</code>이 <code>O_NOINHERIT</code>를 사용하는 "N" 플래그를 허용합니다.</p>
<h3>새로운 매개변수 이름에 대한 논의</h3>
<ul>
<li><code>inherit</code>, <code>inherited</code>: Windows 정의에 더 가깝습니다.</li>
<li><code>sensitive</code>, <code>sterile</code>: "자손을 생산하지 않는다"는 의미입니다.</li>
</ul>
<h2>파일 디스크립터 상속을 사용하는 애플리케이션</h2>
<p>대부분의 개발자는 파일 디스크립터가 기본적으로 상속된다는 사실을 알지 못합니다. 대부분의 프로그램은 파일 디스크립터 상속에 의존하지 않습니다. 예를 들어, <code>subprocess.Popen</code>은 Python 3.2에서 자식 프로세스에서 기본적으로 2번보다 큰 모든 파일 디스크립터를 닫도록 변경되었습니다. 아직 이 동작 변경에 대해 불평한 사용자는 없습니다.</p>
<p><code>fork</code>를 사용하는 네트워크 서버는 클라이언트 소켓을 자식 프로세스로 전달하고 싶을 수 있습니다. 예를 들어, UNIX에서 CGI 서버는 <code>dup2()</code>를 사용하여 파일 디스크립터 0 (<code>stdin</code>) 및 1 (<code>stdout</code>)을 통해 클라이언트 소켓을 전달합니다.</p>
<p>TCP 포트 1024 미만의 포트에서 소켓을 리스닝하거나 암호와 같은 민감한 데이터를 포함하는 파일을 읽는 것과 같은 제한된 리소스에 접근하기 위한 일반적인 관행은 다음과 같습니다. 루트 사용자 (root user)로 시작하여 파일 디스크립터를 생성하고, 자식 프로세스를 생성한 다음, 권한을 포기하고 (예: 현재 사용자 변경), 파일 디스크립터를 자식 프로세스로 전달한 후 부모 프로세스를 종료합니다.</p>
<p>이러한 사용 사례에서는 보안이 매우 중요합니다. 다른 파일 디스크립터를 누출하는 것은 심각한 보안 취약점이 될 것입니다 (Security 참조). 루트 프로세스는 종료하지 않고 자식 프로세스를 모니터링할 수 있으며, 이전 자식 프로세스가 충돌하면 새로운 자식 프로세스를 재시작하고 동일한 파일 디스크립터를 전달할 수 있습니다.</p>
<p>명령줄 옵션을 사용하여 부모 프로세스로부터 파일 디스크립터를 가져오는 프로그램의 예:</p>
<ul>
<li><code>gpg</code>: <code>--status-fd &#x3C;fd></code>, <code>--logger-fd &#x3C;fd></code> 등</li>
<li><code>openssl</code>: <code>-pass fd:&#x3C;fd></code></li>
<li><code>qemu</code>: <code>-add-fd &#x3C;fd></code></li>
<li><code>valgrind</code>: <code>--log-fd=&#x3C;fd></code>, <code>--input-fd=&#x3C;fd></code> 등</li>
<li><code>xterm</code>: <code>-S &#x3C;fd></code></li>
</ul>
<p>Linux에서는 <code>/dev/fd/&#x3C;fd></code> 파일 이름을 사용하여 파일 이름을 예상하는 프로그램에 파일 디스크립터를 전달하는 것이 가능합니다.</p>
<h2>성능 (Performances)</h2>
<p><code>close-on-exec</code> 플래그를 설정하는 것은 새 파일 디스크립터 생성마다 추가적인 시스템 호출 (syscall)을 요구할 수 있습니다. 추가 시스템 호출의 수는 플래그를 설정하는 데 사용되는 방법에 따라 달라집니다.</p>
<ul>
<li><code>O_NOINHERIT</code>: 추가 시스템 호출 없음</li>
<li><code>O_CLOEXEC</code>: 하나의 추가 시스템 호출이 발생하지만, 플래그 지원 여부를 확인하기 위해 첫 파일 디스크립터 생성 시에만 발생합니다. 만약 플래그가 지원되지 않으면, Python은 다음 방법으로 폴백(fallback)해야 합니다.</li>
<li><code>ioctl(fd, FIOCLEX)</code>: 파일 디스크립터당 하나의 추가 시스템 호출</li>
<li><code>fcntl(fd, F_SETFD, flags)</code>: 파일 디스크립터당 두 개의 추가 시스템 호출이 발생하며, 하나는 이전 플래그를 가져오는 데, 다른 하나는 새 플래그를 설정하는 데 사용됩니다.</li>
</ul>
<p>Linux에서 <code>close-on-exec</code> 플래그를 설정하는 것은 성능에 미치는 오버헤드가 낮습니다. Linux 3.6에서 <code>bench_cloexec.py</code>의 벤치마크 결과:</p>
<ul>
<li><code>close-on-exec</code> 플래그 미설정: 7.8 us</li>
<li><code>O_CLOEXEC</code>: 1% 느림 (7.9 us)</li>
<li><code>ioctl()</code>: 3% 느림 (8.0 us)</li>
<li><code>fcntl()</code>: 3% 느림 (8.0 us)</li>
</ul>
<h2>구현 (Implementation)</h2>
<h3><code>os.get_cloexec(fd)</code></h3>
<p>파일 디스크립터의 <code>close-on-exec</code> 플래그를 가져옵니다.</p>
<p>의사 코드:</p>
<pre><code class="language-python">if os.name == 'nt':
    def get_cloexec(fd):
        handle = _winapi._get_osfhandle(fd)
        flags = _winapi.GetHandleInformation(handle)
        return not(flags &#x26; _winapi.HANDLE_FLAG_INHERIT)
else:
    try:
        import fcntl
    except ImportError:
        pass
    else:
        def get_cloexec(fd):
            flags = fcntl.fcntl(fd, fcntl.F_GETFD)
            return bool(flags &#x26; fcntl.FD_CLOEXEC)
</code></pre>
<h3><code>os.set_cloexec(fd, cloexec=True)</code></h3>
<p>파일 디스크립터에 <code>close-on-exec</code> 플래그를 설정하거나 해제합니다. 이 플래그는 파일 디스크립터 생성 이후에 설정되므로 원자적 (atomic)이지 않습니다.</p>
<p>의사 코드:</p>
<pre><code class="language-python">if os.name == 'nt':
    def set_cloexec(fd, cloexec=True):
        handle = _winapi._get_osfhandle(fd)
        mask = _winapi.HANDLE_FLAG_INHERIT
        if cloexec:
            flags = 0
        else:
            flags = mask
        _winapi.SetHandleInformation(handle, mask, flags)
else:
    fnctl = None
    ioctl = None
    try:
        import ioctl
    except ImportError:
        try:
            import fcntl
        except ImportError:
            pass
    if ioctl is not None and hasattr('FIOCLEX', ioctl):
        def set_cloexec(fd, cloexec=True):
            if cloexec:
                ioctl.ioctl(fd, ioctl.FIOCLEX)
            else:
                ioctl.ioctl(fd, ioctl.FIONCLEX)
    elif fnctl is not None:
        def set_cloexec(fd, cloexec=True):
            flags = fcntl.fcntl(fd, fcntl.F_GETFD)
            if cloexec:
                flags |= FD_CLOEXEC
            else:
                flags &#x26;= ~FD_CLOEXEC
            fcntl.fcntl(fd, fcntl.F_SETFD, flags)
</code></pre>
<p><code>fcntl</code>보다 <code>ioctl</code>이 선호되는데, <code>ioctl</code>은 단일 시스템 호출만 필요한 반면 <code>fcntl</code>은 두 개의 시스템 호출이 필요하기 때문입니다.</p>
<p>참고: <code>fcntl(fd, F_SETFD, flags)</code>는 하나의 플래그 (<code>FD_CLOEXEC</code>)만 지원하므로 <code>fcntl(fd, F_GETFD)</code>를 피할 수 있습니다. 하지만 미래에 다른 플래그를 삭제할 수도 있으므로, 두 함수 호출을 유지하는 것이 더 안전합니다.</p>
<p>참고: GNU libc의 <code>fopen()</code> 함수는 <code>fcntl(fd, F_SETFD, flags)</code>가 실패하더라도 오류를 무시합니다.</p>
<h3><code>open()</code></h3>
<ul>
<li>Windows: <code>open()</code> with <code>O_NOINHERIT</code> flag [원자적]</li>
<li><code>open()</code> with <code>O_CLOEXEC</code> flag [원자적]</li>
<li><code>open()</code> + <code>os.set_cloexec(fd, True)</code> [최선 노력 (best-effort)]</li>
</ul>
<h3><code>os.dup()</code></h3>
<ul>
<li>Windows: <code>DuplicateHandle()</code> [원자적]</li>
<li><code>fcntl(fd, F_DUPFD_CLOEXEC)</code> [원자적]</li>
<li><code>dup()</code> + <code>os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>
<h3><code>os.dup2()</code></h3>
<ul>
<li><code>fcntl(fd, F_DUP2FD_CLOEXEC, fd2)</code> [원자적]</li>
<li><code>dup3()</code> with <code>O_CLOEXEC</code> flag [원자적]</li>
<li><code>dup2()</code> + <code>os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>
<h3><code>os.pipe()</code></h3>
<ul>
<li>Windows: <code>CreatePipe()</code> with <code>SECURITY_ATTRIBUTES.bInheritHandle=TRUE</code>, or <code>_pipe()</code> with <code>O_NOINHERIT</code> flag [원자적]</li>
<li><code>pipe2()</code> with <code>O_CLOEXEC</code> flag [원자적]</li>
<li><code>pipe()</code> + <code>os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>
<h3><code>socket.socket()</code></h3>
<ul>
<li>Windows: <code>WSASocket()</code> with <code>WSA_FLAG_NO_HANDLE_INHERIT</code> flag [원자적]</li>
<li><code>socket()</code> with <code>SOCK_CLOEXEC</code> flag [원자적]</li>
<li><code>socket()</code> + <code>os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>
<h3><code>socket.socketpair()</code></h3>
<ul>
<li><code>socketpair()</code> with <code>SOCK_CLOEXEC</code> flag [원자적]</li>
<li><code>socketpair()</code> + <code>os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>
<h3><code>socket.socket.accept()</code></h3>
<ul>
<li><code>accept4()</code> with <code>SOCK_CLOEXEC</code> flag [원자적]</li>
<li><code>accept()</code> + <code>os.set_cloexec(fd, True)</code> [최선 노력]</li>
</ul>
<h2>하위 호환성 (Backward compatibility)</h2>
<p>하위 호환성을 깨는 변경 사항은 없습니다. 기본 동작은 변경되지 않으며, <code>close-on-exec</code> 플래그는 기본적으로 설정되지 않습니다.</p>
<h2>부록: 운영 체제 지원 (Appendix: Operating system support)</h2>
<h3>Windows</h3>
<p>Windows에는 "자식 프로세스에서 상속하지 않음"을 의미하는 <code>O_NOINHERIT</code> 플래그가 있습니다. 예를 들어, <code>open()</code> 및 <code>_pipe()</code>에서 지원됩니다. 이 플래그는 <code>SetHandleInformation(fd, HANDLE_FLAG_INHERIT, 0)</code>을 사용하여 해제할 수 있습니다.</p>
<p><code>CreateProcess()</code>는 <code>bInheritHandles</code> 매개변수를 가지고 있습니다. 이 값이 <code>FALSE</code>이면 핸들은 상속되지 않습니다. <code>TRUE</code>이면 <code>HANDLE_FLAG_INHERIT</code> 플래그가 설정된 핸들이 상속됩니다. <code>subprocess.Popen</code>은 <code>close_fds</code> 옵션을 사용하여 <code>bInheritHandles</code>를 정의합니다.</p>
<h3><code>ioctl</code></h3>
<p>함수:</p>
<ul>
<li><code>ioctl(fd, FIOCLEX, 0)</code>: <code>close-on-exec</code> 플래그 설정</li>
<li><code>ioctl(fd, FIONCLEX, 0)</code>: <code>close-on-exec</code> 플래그 해제</li>
</ul>
<p>가용성: Linux, Mac OS X, QNX, NetBSD, OpenBSD, FreeBSD.</p>
<h3><code>fcntl</code></h3>
<p>함수:</p>
<ul>
<li><code>flags = fcntl(fd, F_GETFD); fcntl(fd, F_SETFD, flags | FD_CLOEXEC)</code>: <code>close-on-exec</code> 플래그 설정</li>
<li><code>flags = fcntl(fd, F_GETFD); fcntl(fd, F_SETFD, flags &#x26; ~FD_CLOEXEC)</code>: <code>close-on-exec</code> 플래그 해제</li>
</ul>
<p>가용성: AIX, Digital UNIX, FreeBSD, HP-UX, IRIX, Linux, Mac OS X, OpenBSD, Solaris, SunOS, Unicos.</p>
<h3>원자적 플래그 (Atomic flags)</h3>
<p>새로운 플래그:</p>
<ul>
<li><code>O_CLOEXEC</code>: Linux (2.6.23), FreeBSD (8.3), OpenBSD 5.0, Solaris 11, QNX, BeOS, 다음 NetBSD 릴리스 (6.1?)에서 사용 가능합니다. 이 플래그는 POSIX.1-2008의 일부입니다.</li>
<li><code>socket()</code> 및 <code>socketpair()</code>를 위한 <code>SOCK_CLOEXEC</code> 플래그: Linux 2.6.27, OpenBSD 5.2, NetBSD 6.0에서 사용 가능합니다.</li>
<li><code>WSASocket()</code>를 위한 <code>WSA_FLAG_NO_HANDLE_INHERIT</code> 플래그: Windows 7 SP1, Windows Server 2008 R2 SP1 및 이후 버전에서 지원됩니다.</li>
<li><code>fcntl()</code>: <code>F_DUPFD_CLOEXEC</code> 플래그: Linux 2.6.24, OpenBSD 5.0, FreeBSD 9.1, NetBSD 6.0, Solaris 11에서 사용 가능합니다. 이 플래그는 POSIX.1-2008의 일부입니다.</li>
<li><code>fcntl()</code>: <code>F_DUP2FD_CLOEXEC</code> 플래그: FreeBSD 9.1 및 Solaris 11에서 사용 가능합니다.</li>
<li><code>recvmsg()</code>: <code>MSG_CMSG_CLOEXEC</code>: Linux 2.6.23, NetBSD 6.0에서 사용 가능합니다.</li>
</ul>
<p>Linux 2.6.23 이전 버전에서는 <code>O_CLOEXEC</code> 플래그가 단순히 무시됩니다. 따라서 <code>fcntl()</code>을 호출하여 플래그가 지원되는지 확인해야 합니다. 작동하지 않으면 <code>ioctl()</code> 또는 <code>fcntl()</code>을 사용하여 플래그를 설정해야 합니다.</p>
<p>Linux 2.6.27 이전 버전에서는 <code>SOCK_CLOEXEC</code> 플래그가 소켓 유형에 설정되면 <code>socket()</code> 또는 <code>socketpair()</code>가 실패하고 <code>errno</code>가 <code>EINVAL</code>로 설정됩니다.</p>
<p>Windows XPS3에서는 <code>WSA_FLAG_NO_HANDLE_INHERIT</code> 플래그를 사용하면 <code>WSASocket()</code>이 <code>WSAEPROTOTYPE</code> 오류를 반환합니다.</p>
<p>새로운 함수:</p>
<ul>
<li><code>dup3()</code>: Linux 2.6.27 (및 glibc 2.9)에서 사용 가능합니다.</li>
<li><code>pipe2()</code>: Linux 2.6.27 (및 glibc 2.9)에서 사용 가능합니다.</li>
<li><code>accept4()</code>: Linux 2.6.28 (및 glibc 2.10)에서 사용 가능합니다.</li>
</ul>
<p>Linux 2.6.28 이전 버전에서 <code>accept4()</code>를 호출하면 <code>accept4()</code>는 -1 (실패)을 반환하고 <code>errno</code>는 <code>ENOSYS</code>로 설정됩니다.</p>
<h2>링크 (Links)</h2>
<ul>
<li>Secure File Descriptor Handling (Ulrich Drepper, 2008)</li>
<li>Tornado 프로젝트의 <code>win32_support.py</code>: <code>SetHandleInformation(fd, HANDLE_FLAG_INHERIT, 1)</code>을 사용하여 <code>fcntl(fd, F_SETFD, FD_CLOEXEC)</code> 에뮬레이션</li>
<li>LKML: [PATCH] <code>nextfd(2)</code></li>
</ul>
<p>Python 이슈:</p>
<ul>
<li>#10115: 소켓 생성 시 플래그의 원자적 설정을 위한 <code>accept4()</code> 지원</li>
<li>#12105: <code>open()</code>이 <code>O_CLOEXEC</code>와 같은 플래그를 설정할 수 없음</li>
<li>#12107: <code>FD_CLOEXEC</code> 플래그 없이 생성된 TCP 리스닝 소켓</li>
<li>#16500: <code>atfork</code> 모듈 추가</li>
<li>#16850: <code>open()</code>에 "e" 모드 추가: <code>close-and-exec</code> (<code>O_CLOEXEC</code>) / <code>O_NOINHERIT</code></li>
<li>#16860: <code>tempfile</code> 모듈에서 <code>O_CLOEXEC</code> 사용</li>
<li>#17036: PEP 433 구현</li>
<li>#16946: <code>subprocess</code>: <code>_close_open_fd_range_safe()</code>는 <code>O_CLOEXEC</code>가 정의되어 있어도 Linux &#x3C; 2.6.23에서 <code>close-on-exec</code> 플래그를 설정하지 않음</li>
<li>#17070: PEP 433: 새로운 <code>cloexec</code>를 사용하여 보안 개선 및 버그 방지</li>
</ul>
<p>다른 언어:</p>
<ul>
<li>Perl은 새로 생성된 파일 디스크립터의 번호가 <code>$SYSTEM_FD_MAX</code> (<code>$^F</code>)보다 큰 경우 <code>close-on-exec</code> 플래그를 설정합니다. Perl 1부터 존재했습니다.</li>
<li>Ruby: <code>FD_CLOEXEC</code> for all <code>fds</code> (0, 1, 2 제외) 설정. <code>Kernel::open</code>에 <code>O_CLOEXEC</code> 플래그 누락: 커밋은 나중에 되돌려졌습니다.</li>
<li>OCaml: PR#5256: <code>Unix.open_process*</code>를 사용하여 열린 프로세스는 모든 열린 파일 디스크립터 (소켓 포함)를 상속합니다. OCaml에는 <code>Unix.set_close_on_exec</code> 함수가 있습니다.</li>
</ul>
<h2>각주 (Footnotes)</h2>
<p>UNIX에서 Python 3.2부터 <code>subprocess.Popen()</code>은 기본적으로 모든 파일 디스크립터를 닫습니다 (<code>close_fds=True</code>). 이는 3번을 포함하여 <code>local_max_fd</code> (NetBSD에서는 <code>fcntl(0, F_MAXFD)</code>, 그 외에는 <code>sysconf(_SC_OPEN_MAX)</code>) 미만까지의 파일 디스크립터를 닫습니다. 만약 오류 파이프의 디스크립터가 3보다 작으면 <code>ValueError</code>가 발생합니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 공개 도메인으로 지정되었습니다.</p>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-aecaf5ac7a84facf.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-e3ea38185bb36cd2.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/433\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"x02Anhkwgp1He7ftuyAhh\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/433/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/433\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"433\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/433\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T9781,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0433/\"\u003ePEP 433 - Easier suppression of file descriptor inheritance\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Superseded | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 10-Jan-2013\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 433 – 파일 디스크립터 상속을 더 쉽게 억제하기 (Easier suppression of file descriptor inheritance)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자\u003c/strong\u003e: Victor Stinner \u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태\u003c/strong\u003e: Superseded (폐기됨 - PEP 446으로 대체됨)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형\u003c/strong\u003e: Standards Track\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일\u003c/strong\u003e: 2013년 1월 10일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전\u003c/strong\u003e: 3.4\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e대체\u003c/strong\u003e: PEP 446\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e목차\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%EC%9A%94%EC%95%BD-abstract\"\u003e요약 (Abstract)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EB%B0%B0%EA%B2%BD-rationale\"\u003e배경 (Rationale)\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#python-33%EC%97%90%EC%84%9C%EC%9D%98-%ED%98%84%ED%99%A9\"\u003ePython 3.3에서의 현황\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0-%EC%83%81%EC%86%8D-%EB%AC%B8%EC%A0%9C\"\u003e파일 디스크립터 상속 문제\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%EB%B3%B4%EC%95%88-security\"\u003e보안 (Security)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%9B%90%EC%9E%90%EC%84%B1-atomicity\"\u003e원자성 (Atomicity)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%9D%B4%EC%8B%9D%EC%84%B1-portability\"\u003e이식성 (Portability)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EB%B2%94%EC%9C%84-scope\"\u003e범위 (Scope)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%A0%9C%EC%95%88-proposal\"\u003e제안 (Proposal)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EB%8C%80%EC%95%88-alternatives\"\u003e대안 (Alternatives)\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%EC%83%81%EC%86%8D%EC%9D%B4-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%99%9C%EC%84%B1%ED%99%94%EB%90%98%EA%B3%A0-%EA%B8%B0%EB%B3%B8%EA%B0%92%EC%9D%80-%EC%84%A4%EC%A0%95-%EB%B6%88%EA%B0%80%EB%8A%A5\"\u003e상속이 기본적으로 활성화되고, 기본값은 설정 불가능\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%83%81%EC%86%8D%EC%9D%B4-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%99%9C%EC%84%B1%ED%99%94%EB%90%98%EA%B3%A0-%EA%B8%B0%EB%B3%B8%EA%B0%92%EC%9D%80-true%EB%A1%9C%EB%A7%8C-%EC%84%A4%EC%A0%95-%EA%B0%80%EB%8A%A5\"\u003e상속이 기본적으로 활성화되고, 기본값은 \u003ccode\u003eTrue\u003c/code\u003e로만 설정 가능\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%83%81%EC%86%8D%EC%9D%84-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%B9%84%ED%99%9C%EC%84%B1%ED%99%94\"\u003e상속을 기본적으로 비활성화\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#fork-%EC%9D%B4%ED%9B%84-%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0-%EB%8B%AB%EA%B8%B0\"\u003e\u003ccode\u003efork()\u003c/code\u003e 이후 파일 디스크립터 닫기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#open-%EB%AA%A8%EB%93%9C%EC%97%90-e-%ED%94%8C%EB%9E%98%EA%B7%B8-%EC%B6%94%EA%B0%80\"\u003e\u003ccode\u003eopen()\u003c/code\u003e: 모드에 \"e\" 플래그 추가\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%9D%B4%EB%A6%84%EC%97%90-%EB%8C%80%ED%95%9C-%EB%85%BC%EC%9D%98\"\u003e새로운 매개변수 이름에 대한 논의\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0-%EC%83%81%EC%86%8D%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\"\u003e파일 디스크립터 상속을 사용하는 애플리케이션\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%84%B1%EB%8A%A5-performances\"\u003e성능 (Performances)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EA%B5%AC%ED%98%84-implementation\"\u003e구현 (Implementation)\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eos.get_cloexec(fd)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.set_cloexec(fd, cloexec=True)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eopen()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.dup()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.dup2()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.pipe()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket.socket()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket.socketpair()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket.socket.accept()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%ED%95%98%EC%9C%84-%ED%98%B8%ED%99%98%EC%84%B1-backward-compatibility\"\u003e하위 호환성 (Backward compatibility)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EB%B6%80%EB%A1%9D-%EC%9A%B4%EC%98%81-%EC%B2%B4%EC%A0%9C-%EC%A7%80%EC%9B%90-appendix-operating-system-support\"\u003e부록: 운영 체제 지원 (Appendix: Operating system support)\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#windows\"\u003eWindows\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eioctl\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efcntl\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%9B%90%EC%9E%90%EC%A0%81-%ED%94%8C%EB%9E%98%EA%B7%B8-atomic-flags\"\u003e원자적 플래그 (Atomic flags)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EB%A7%81%ED%81%AC-links\"\u003e링크 (Links)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EA%B0%81%EC%A3%BC-footnotes\"\u003e각주 (Footnotes)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%EC%A0%80%EC%9E%91%EA%B6%8C-copyright\"\u003e저작권 (Copyright)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 파일 디스크립터 (File Descriptor)를 생성하는 함수에 새로운 선택적 \u003ccode\u003ecloexec\u003c/code\u003e 매개변수를 추가하고, 이 매개변수의 기본값을 변경하는 다양한 방법을 도입하며, 다음과 같은 네 가지 새로운 함수를 추가할 것을 제안합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eos.get_cloexec(fd)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.set_cloexec(fd, cloexec=True)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.getdefaultcloexec()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.setdefaultcloexec(cloexec)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003e파일 디스크립터는 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 가지고 있으며, 이 플래그는 파일 디스크립터가 상속될지 여부를 나타냅니다.\u003c/p\u003e\n\u003cp\u003eUNIX 시스템에서 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그가 설정되면, 파일 디스크립터는 자식 프로세스의 실행 시 닫히므로 상속되지 않습니다. 그렇지 않으면 파일 디스크립터는 자식 프로세스에 의해 상속됩니다.\u003c/p\u003e\n\u003cp\u003eWindows 시스템에서 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그가 설정되면 파일 디스크립터는 상속되지 않습니다. \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그가 해제되고 \u003ccode\u003eCreateProcess()\u003c/code\u003e 함수가 \u003ccode\u003ebInheritHandles\u003c/code\u003e 매개변수를 \u003ccode\u003eTRUE\u003c/code\u003e로 설정하여 호출될 경우 (예를 들어 \u003ccode\u003esubprocess.Popen\u003c/code\u003e이 \u003ccode\u003eclose_fds=False\u003c/code\u003e로 생성될 때), 파일 디스크립터는 자식 프로세스에 의해 상속됩니다. Windows에는 \"close-on-exec\" 플래그는 없지만, 그와 반대되는 값을 가진 상속 플래그가 있습니다. 예를 들어, \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하는 것은 핸들(handle)의 \u003ccode\u003eHANDLE_FLAG_INHERIT\u003c/code\u003e 플래그를 해제하는 것을 의미합니다.\u003c/p\u003e\n\u003ch3\u003ePython 3.3에서의 현황\u003c/h3\u003e\n\u003cp\u003eUNIX에서는 Python 3.2부터 \u003ccode\u003esubprocess\u003c/code\u003e 모듈이 기본적으로 파일 디스크립터 2번(stderr)보다 큰 모든 파일 디스크립터를 닫습니다. [cite: 1,  각주 1] 부모 프로세스에 의해 생성된 모든 파일 디스크립터는 자식 프로세스에서 자동으로 닫힙니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003exmlrpc.server.SimpleXMLRPCServer\u003c/code\u003e는 리스닝 소켓 (listening socket)의 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하지만, 부모 클래스인 \u003ccode\u003esocketserver.TCPServer\u003c/code\u003e는 이 플래그를 설정하지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eos.spawn*()\u003c/code\u003e 및 \u003ccode\u003eos.exec*()\u003c/code\u003e 계열 함수와 \u003ccode\u003eexec()\u003c/code\u003e 또는 \u003ccode\u003efork()\u003c/code\u003e + \u003ccode\u003eexec()\u003c/code\u003e를 호출하는 서드파티 모듈을 통해 서브프로세스를 생성하거나 새 프로그램을 실행할 때 파일 디스크립터가 닫히지 않는 다른 경우가 있습니다. 이 경우, 파일 디스크립터는 부모 프로세스와 자식 프로세스 간에 공유되는데, 이는 일반적으로 예상치 못한 동작이며 다양한 문제를 야기합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 Python 3.2에서 \u003ccode\u003esubprocess\u003c/code\u003e 모듈의 변경으로 시작된 작업을 계속하여, \u003ccode\u003esubprocess\u003c/code\u003e를 사용하는 코드뿐만 아니라 모든 코드에서 이 문제를 해결할 것을 제안합니다.\u003c/p\u003e\n\u003ch3\u003e파일 디스크립터 상속 문제\u003c/h3\u003e\n\u003cp\u003e부모 프로세스에서 파일 디스크립터를 닫아도 관련 리소스 (파일, 소켓 등)는 자식 프로세스에서 여전히 열려 있기 때문에 닫히지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTCPServer\u003c/code\u003e의 리스닝 소켓은 \u003ccode\u003eexec()\u003c/code\u003e 시 닫히지 않습니다. 이로 인해 자식 프로세스가 새 클라이언트로부터 연결을 받을 수 있으며, 만약 부모 프로세스가 리스닝 소켓을 닫고 동일한 주소에 새 리스닝 소켓을 생성하려고 하면 \"address already in use\" (주소가 이미 사용 중) 오류가 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e파일 디스크립터를 닫지 않으면 리소스 고갈로 이어질 수 있습니다. 부모가 모든 파일을 닫아도, 자식 프로세스에 파일이 여전히 열려 있기 때문에 \"too many files\" (파일이 너무 많음) 오류로 인해 새 파일 디스크립터 생성이 실패할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e관련된 문제들은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIssue #2320: \u003ccode\u003esubprocess\u003c/code\u003e에서 \u003ccode\u003estdin\u003c/code\u003e을 사용하는 경합 조건 (Race condition) (2008)\u003c/li\u003e\n\u003cli\u003eIssue #3006: \u003ccode\u003esubprocess.Popen\u003c/code\u003e이 닫힌 후에도 소켓이 열려 있음 (2008)\u003c/li\u003e\n\u003cli\u003eIssue #7213: \u003ccode\u003esubprocess\u003c/code\u003e가 \u003ccode\u003ePopen\u003c/code\u003e 인스턴스 간에 열린 파일 디스크립터를 누출하여 중단 발생 (2009)\u003c/li\u003e\n\u003cli\u003eIssue #12786: \u003ccode\u003estdin\u003c/code\u003e이 닫힐 때 \u003ccode\u003esubprocess.wait()\u003c/code\u003e가 중단됨 (2011)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e보안 (Security)\u003c/h4\u003e\n\u003cp\u003e파일 디스크립터 누출은 중대한 보안 취약점입니다. 신뢰할 수 없는 자식 프로세스가 암호와 같은 민감한 데이터를 읽거나 누출된 파일 디스크립터를 통해 부모 프로세스를 제어할 수 있습니다. 예를 들어, \u003ccode\u003echroot\u003c/code\u003e를 탈출하는 알려진 취약점입니다.\u003c/p\u003e\n\u003cp\u003eCERT 권고 사항: FIO42-C. 더 이상 필요하지 않은 파일은 올바르게 닫히도록 해야 합니다.\u003c/p\u003e\n\u003cp\u003e취약점 사례:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOpenSSH Security Advisory: \u003ccode\u003eportable-keysign-rand-helper.adv\u003c/code\u003e (2011년 4월)\u003c/li\u003e\n\u003cli\u003eCWE-403: 의도하지 않은 제어 영역으로의 파일 디스크립터 노출 (2008)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emod_php\u003c/code\u003e를 통한 Apache \u003ccode\u003ehttps\u003c/code\u003e 하이재킹 (2003년 12월)\u003c/li\u003e\n\u003cli\u003eApache: \u003ccode\u003eAPR_FOPEN_NOCLEANUP\u003c/code\u003e이 설정되지 않은 경우 \u003ccode\u003eApr\u003c/code\u003e는 \u003ccode\u003eFD_CLOEXEC\u003c/code\u003e을 설정해야 함 (2009년 수정됨)\u003c/li\u003e\n\u003cli\u003ePHP: \u003ccode\u003esystem()\u003c/code\u003e (및 유사 함수)는 Apache에 의해 열린 핸들을 정리하지 않음 (2013년 1월 기준 미수정)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e원자성 (Atomicity)\u003c/h4\u003e\n\u003cp\u003e멀티스레드 애플리케이션에서 \u003ccode\u003efcntl()\u003c/code\u003e을 사용하여 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하는 것은 안전하지 않습니다. 만약 파일 디스크립터 생성과 \u003ccode\u003efcntl(fd, F_SETFD, new_flags)\u003c/code\u003e 호출 사이에 스레드가 \u003ccode\u003efork()\u003c/code\u003e 및 \u003ccode\u003eexec()\u003c/code\u003e를 호출한다면, 파일 디스크립터는 자식 프로세스에 의해 상속될 것입니다. 최신 운영 체제는 파일 디스크립터 생성 중에 플래그를 설정하는 함수를 제공하여 경합 조건 (race condition)을 방지합니다.\u003c/p\u003e\n\u003ch4\u003e이식성 (Portability)\u003c/h4\u003e\n\u003cp\u003ePython 3.2는 \u003ccode\u003esocket.SOCK_CLOEXEC\u003c/code\u003e 플래그를 추가했고, Python 3.3은 \u003ccode\u003eos.O_CLOEXEC\u003c/code\u003e 플래그와 \u003ccode\u003eos.pipe2()\u003c/code\u003e 함수를 추가했습니다. Python 3.3에서는 파일 열기, 파이프 또는 소켓 생성 시 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 원자적으로 (atomically) 설정하는 것이 이미 가능합니다.\u003c/p\u003e\n\u003cp\u003e문제는 이러한 플래그와 함수들이 이식성이 없다는 것입니다. 즉, 최신 버전의 운영 체제에서만 지원됩니다. \u003ccode\u003eO_CLOEXEC\u003c/code\u003e 및 \u003ccode\u003eSOCK_CLOEXEC\u003c/code\u003e 플래그는 오래된 Linux 버전에서는 무시되므로, \u003ccode\u003efcntl(fd, F_GETFD)\u003c/code\u003e를 사용하여 \u003ccode\u003eFD_CLOEXEC\u003c/code\u003e 플래그를 확인해야 합니다. 커널이 \u003ccode\u003eO_CLOEXEC\u003c/code\u003e 또는 \u003ccode\u003eSOCK_CLOEXEC\u003c/code\u003e 플래그를 무시하는 경우, \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하기 위해 \u003ccode\u003efcntl(fd, F_SETFD, flags)\u003c/code\u003e 호출이 필요합니다.\u003c/p\u003e\n\u003cp\u003e참고: OpenBSD 5.2 이전 버전은 \u003ccode\u003efork()\u003c/code\u003e가 \u003ccode\u003eexec()\u003c/code\u003e 전에 사용되면 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그가 설정된 파일 디스크립터를 닫지 않지만, \u003ccode\u003eexec()\u003c/code\u003e가 \u003ccode\u003efork()\u003c/code\u003e 없이 호출되면 올바르게 작동합니다.\u003c/p\u003e\n\u003ch3\u003e범위 (Scope)\u003c/h3\u003e\n\u003cp\u003e애플리케이션은 \u003ccode\u003efork()\u003c/code\u003e 이후에도 파일 디스크립터를 명시적으로 닫아야 합니다. \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그는 \u003ccode\u003eexec()\u003c/code\u003e 이후, 즉 \u003ccode\u003efork()\u003c/code\u003e + \u003ccode\u003eexec()\u003c/code\u003e 이후에만 파일 디스크립터를 닫습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 Python 표준 라이브러리 또는 표준 라이브러리를 사용하는 모듈에 의해 생성된 파일 디스크립터의 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그만 변경합니다. 표준 라이브러리를 사용하지 않는 서드파티 모듈은 이 PEP에 따르도록 수정되어야 합니다. 예를 들어, 새로운 \u003ccode\u003eos.set_cloexec()\u003c/code\u003e 함수를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e참고: \u003ccode\u003eexec()\u003c/code\u003e 없는 \u003ccode\u003efork()\u003c/code\u003e의 가능한 해결책은 \"Close file descriptors after fork\" 섹션을 참조하십시오.\u003c/p\u003e\n\u003ch2\u003e제안 (Proposal)\u003c/h2\u003e\n\u003cp\u003e파일 디스크립터를 생성하는 함수에 새로운 선택적 \u003ccode\u003ecloexec\u003c/code\u003e 매개변수를 추가하고, 이 매개변수의 기본값을 변경하는 다양한 방법을 추가합니다.\u003c/p\u003e\n\u003cp\u003e다음과 같은 새로운 함수를 추가합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eos.get_cloexec(fd:int) -\u003e bool\u003c/code\u003e: 파일 디스크립터의 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 가져옵니다. 모든 플랫폼에서 사용 가능하지 않을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.set_cloexec(fd:int, cloexec:bool=True)\u003c/code\u003e: 파일 디스크립터에 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하거나 해제합니다. 모든 플랫폼에서 사용 가능하지 않을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.getdefaultcloexec() -\u003e bool\u003c/code\u003e: \u003ccode\u003ecloexec\u003c/code\u003e 매개변수의 현재 기본값을 가져옵니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.setdefaultcloexec(cloexec: bool)\u003c/code\u003e: \u003ccode\u003ecloexec\u003c/code\u003e 매개변수의 기본값을 설정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 함수들에 새로운 선택적 \u003ccode\u003ecloexec\u003c/code\u003e 매개변수를 추가합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003easyncore.dispatcher.create_socket()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eio.FileIO\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eio.open()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eopen()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.dup()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.dup2()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.fdopen()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.open()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.openpty()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.pipe()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eselect.devpoll()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eselect.epoll()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eselect.kqueue()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket.socket()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket.socket.accept()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket.socket.dup()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket.socket.fromfd\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket.socketpair()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ecloexec\u003c/code\u003e 매개변수의 기본값은 \u003ccode\u003esys.getdefaultcloexec()\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하기 위해 새로운 명령줄 옵션 \u003ccode\u003e-e\u003c/code\u003e와 환경 변수 \u003ccode\u003ePYTHONCLOEXEC\u003c/code\u003e를 추가합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈은 \u003ccode\u003epass_fds\u003c/code\u003e 매개변수에 나열된 파일 디스크립터의 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 해제합니다.\u003c/p\u003e\n\u003cp\u003e표준 라이브러리에서 파일 디스크립터를 생성하는 모든 함수는 \u003ccode\u003ecloexec\u003c/code\u003e 매개변수의 기본값인 \u003ccode\u003esys.getdefaultcloexec()\u003c/code\u003e를 따라야 합니다.\u003c/p\u003e\n\u003cp\u003e파일 디스크립터 0 (\u003ccode\u003estdin\u003c/code\u003e), 1 (\u003ccode\u003estdout\u003c/code\u003e), 2 (\u003ccode\u003estderr\u003c/code\u003e)는 상속될 것으로 예상되지만, Python은 이들을 다르게 처리하지 않습니다. 표준 스트림을 대체하기 위해 \u003ccode\u003eos.dup2()\u003c/code\u003e가 사용될 경우, \u003ccode\u003ecloexec=False\u003c/code\u003e를 명시적으로 지정해야 합니다.\u003c/p\u003e\n\u003cp\u003e제안의 단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e새로 생성된 파일 디스크립터에서 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그가 설정될지 여부를 소스 코드만으로는 알 수 없게 됩니다.\u003c/li\u003e\n\u003cli\u003e파일 디스크립터의 상속이 중요한 경우, \u003ccode\u003ecloexec\u003c/code\u003e 매개변수를 명시적으로 지정해야 하며, 그렇지 않으면 라이브러리나 애플리케이션이 \u003ccode\u003ecloexec\u003c/code\u003e 매개변수의 기본값에 따라 다르게 작동할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e대안 (Alternatives)\u003c/h2\u003e\n\u003ch3\u003e상속이 기본적으로 활성화되고, 기본값은 설정 불가능\u003c/h3\u003e\n\u003cp\u003e파일 디스크립터를 생성하는 함수에 새로운 선택적 \u003ccode\u003ecloexec\u003c/code\u003e 매개변수를 추가합니다. \u003ccode\u003ecloexec\u003c/code\u003e 매개변수의 기본값은 \u003ccode\u003eFalse\u003c/code\u003e이며, 이 기본값은 변경할 수 없습니다. 파일 디스크립터 상속이 기본적으로 활성화되는 것은 POSIX 및 Windows의 기본 동작과도 일치합니다. 이 대안은 가장 보수적인 옵션입니다.\u003c/p\u003e\n\u003cp\u003e이 옵션은 \"배경\" 섹션에 나열된 문제를 해결하지 못하며, 단지 문제를 해결하기 위한 도우미를 제공할 뿐입니다. 이러한 모든 문제를 해결하기 위해 애플리케이션에서 사용되는 각 모듈에서 파일 디스크립터를 생성하는 모든 함수를 수정하여 \u003ccode\u003ecloexec=True\u003c/code\u003e를 설정해야 합니다.\u003c/p\u003e\n\u003ch3\u003e상속이 기본적으로 활성화되고, 기본값은 \u003ccode\u003eTrue\u003c/code\u003e로만 설정 가능\u003c/h3\u003e\n\u003cp\u003e이 대안은 제안을 기반으로 합니다. 유일한 차이점은 \u003ccode\u003esys.setdefaultcloexec()\u003c/code\u003e가 어떤 인수도 받지 않고, \u003ccode\u003ecloexec\u003c/code\u003e 매개변수의 기본값을 \u003ccode\u003eTrue\u003c/code\u003e로만 설정할 수 있다는 것입니다.\u003c/p\u003e\n\u003ch3\u003e상속을 기본적으로 비활성화\u003c/h3\u003e\n\u003cp\u003e이 대안은 제안을 기반으로 합니다. 유일한 차이점은 \u003ccode\u003ecloexec\u003c/code\u003e 매개변수의 기본값이 \u003ccode\u003eTrue\u003c/code\u003e라는 것입니다 (기존 \u003ccode\u003eFalse\u003c/code\u003e 대신).\u003c/p\u003e\n\u003cp\u003e자식 프로세스에 의해 파일이 상속되어야 하는 경우, \u003ccode\u003ecloexec=False\u003c/code\u003e 매개변수를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하는 것의 장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eexec\u003c/code\u003e 시 FD (파일 디스크립터) 상속으로 인해 발생하는 문제로 고통받는 프로그램 (Inherited file descriptors issues 및 Security 참조)이 상속에 의존하는 프로그램 (Applications using inheritance of file descriptors 참조)보다 훨씬 많습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e기본적으로 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하는 것의 단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\"최소 놀람의 원칙\" (principle of least surprise)을 위반합니다. \u003ccode\u003eos\u003c/code\u003e 모듈을 사용하는 개발자들은 Python이 POSIX 표준을 따르고 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그가 기본적으로 설정되지 않을 것이라고 예상할 수 있습니다. \u003ccode\u003eos\u003c/code\u003e 모듈은 시스템 호출 (C 표준 라이브러리의 함수)에 대한 얇은 래퍼 (thin wrapper)로 작성되었습니다. \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하는 원자적 플래그가 지원되지 않는 경우 (Appendix: Operating system support 참조), 단일 Python 함수 호출이 2개 또는 3개의 시스템 호출을 할 수 있습니다 (Performances 섹션 참조). 추가적인 시스템 호출이 있다면 Python을 느리게 할 수 있습니다 (Performances 참조).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e하위 호환성: 파일 디스크립터 상속에 의존하는 프로그램은 소수에 불과하며, 일반적으로 하나 또는 몇 개의 파일 디스크립터만 전달합니다. 이러한 프로그램들은 \u003ccode\u003eEBADF\u003c/code\u003e 오류로 즉시 실패할 것이고, \u003ccode\u003ecloexec=False\u003c/code\u003e 매개변수를 추가하거나 \u003ccode\u003eos.set_cloexec(fd, False)\u003c/code\u003e를 사용하여 쉽게 수정할 수 있을 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esubprocess\u003c/code\u003e 모듈은 \u003ccode\u003ePopen\u003c/code\u003e 생성자의 \u003ccode\u003epass_fds\u003c/code\u003e 매개변수에 나열된 파일 디스크립터의 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 해제하도록 어차피 변경될 것입니다. 따라서 이러한 프로그램들이 \u003ccode\u003esubprocess\u003c/code\u003e 모듈을 사용하는 경우 어떤 수정도 필요하지 않을 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003efork()\u003c/code\u003e 이후 파일 디스크립터 닫기\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003eexec()\u003c/code\u003e 없이 \u003ccode\u003efork()\u003c/code\u003e를 사용하는 애플리케이션의 문제를 해결하지 않습니다. Python은 \u003ccode\u003efork\u003c/code\u003e 이후 호출될 콜백 (callback)을 등록하는 일반적인 프로세스가 필요하며, Issue #16500: \u003ccode\u003eatfork\u003c/code\u003e 모듈 추가를 참조하십시오. 이러한 레지스트리는 \u003ccode\u003efork()\u003c/code\u003e 직후 파일 디스크립터를 닫는 데 사용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWindows에서는 \u003ccode\u003efork()\u003c/code\u003e가 존재하지 않으므로 Windows에서는 이 문제가 해결되지 않습니다.\u003c/li\u003e\n\u003cli\u003e이 대안은 \u003ccode\u003efork()\u003c/code\u003e 없이 \u003ccode\u003eexec()\u003c/code\u003e를 사용하는 프로그램의 문제를 해결하지 못합니다.\u003c/li\u003e\n\u003cli\u003e서드파티 모듈은 C 함수 \u003ccode\u003efork()\u003c/code\u003e를 직접 호출할 수 있으며, 이 경우 \"atfork\" 콜백이 호출되지 않습니다.\u003c/li\u003e\n\u003cli\u003e파일 디스크립터를 생성하는 모든 함수는 콜백을 등록해야 하며, 파일이 닫힐 때 콜백을 등록 해제해야 합니다. 또는 열린 모든 파일 디스크립터 목록이 유지되어야 합니다.\u003c/li\u003e\n\u003cli\u003e파일 디스크립터를 자동으로 닫는 것은 Python보다는 운영 체제가 더 적합한 곳입니다. 예를 들어, 파일을 닫는 것과 파일을 닫는 콜백을 등록 해제하는 것 사이의 경합 조건을 피하기는 쉽지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003eopen()\u003c/code\u003e: 모드에 \"e\" 플래그 추가\u003c/h3\u003e\n\u003cp\u003e새로운 \"e\" 모드는 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 (최선을 다해) 설정할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 대안은 \u003ccode\u003eopen()\u003c/code\u003e에 대한 문제만 해결합니다. \u003ccode\u003esocket.socket()\u003c/code\u003e 및 \u003ccode\u003eos.pipe()\u003c/code\u003e에는 예를 들어 \u003ccode\u003emode\u003c/code\u003e 매개변수가 없습니다.\u003c/p\u003e\n\u003cp\u003eGNU libc는 버전 2.7부터 \u003ccode\u003efopen()\u003c/code\u003e에 \"e\" 플래그를 지원합니다. 이는 \u003ccode\u003eO_CLOEXEC\u003c/code\u003e가 사용 가능하면 사용하고, 그렇지 않으면 \u003ccode\u003efcntl(fd, F_SETFD, FD_CLOEXEC)\u003c/code\u003e를 사용합니다. Visual Studio에서는 \u003ccode\u003efopen()\u003c/code\u003e이 \u003ccode\u003eO_NOINHERIT\u003c/code\u003e를 사용하는 \"N\" 플래그를 허용합니다.\u003c/p\u003e\n\u003ch3\u003e새로운 매개변수 이름에 대한 논의\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einherit\u003c/code\u003e, \u003ccode\u003einherited\u003c/code\u003e: Windows 정의에 더 가깝습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esensitive\u003c/code\u003e, \u003ccode\u003esterile\u003c/code\u003e: \"자손을 생산하지 않는다\"는 의미입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e파일 디스크립터 상속을 사용하는 애플리케이션\u003c/h2\u003e\n\u003cp\u003e대부분의 개발자는 파일 디스크립터가 기본적으로 상속된다는 사실을 알지 못합니다. 대부분의 프로그램은 파일 디스크립터 상속에 의존하지 않습니다. 예를 들어, \u003ccode\u003esubprocess.Popen\u003c/code\u003e은 Python 3.2에서 자식 프로세스에서 기본적으로 2번보다 큰 모든 파일 디스크립터를 닫도록 변경되었습니다. 아직 이 동작 변경에 대해 불평한 사용자는 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efork\u003c/code\u003e를 사용하는 네트워크 서버는 클라이언트 소켓을 자식 프로세스로 전달하고 싶을 수 있습니다. 예를 들어, UNIX에서 CGI 서버는 \u003ccode\u003edup2()\u003c/code\u003e를 사용하여 파일 디스크립터 0 (\u003ccode\u003estdin\u003c/code\u003e) 및 1 (\u003ccode\u003estdout\u003c/code\u003e)을 통해 클라이언트 소켓을 전달합니다.\u003c/p\u003e\n\u003cp\u003eTCP 포트 1024 미만의 포트에서 소켓을 리스닝하거나 암호와 같은 민감한 데이터를 포함하는 파일을 읽는 것과 같은 제한된 리소스에 접근하기 위한 일반적인 관행은 다음과 같습니다. 루트 사용자 (root user)로 시작하여 파일 디스크립터를 생성하고, 자식 프로세스를 생성한 다음, 권한을 포기하고 (예: 현재 사용자 변경), 파일 디스크립터를 자식 프로세스로 전달한 후 부모 프로세스를 종료합니다.\u003c/p\u003e\n\u003cp\u003e이러한 사용 사례에서는 보안이 매우 중요합니다. 다른 파일 디스크립터를 누출하는 것은 심각한 보안 취약점이 될 것입니다 (Security 참조). 루트 프로세스는 종료하지 않고 자식 프로세스를 모니터링할 수 있으며, 이전 자식 프로세스가 충돌하면 새로운 자식 프로세스를 재시작하고 동일한 파일 디스크립터를 전달할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e명령줄 옵션을 사용하여 부모 프로세스로부터 파일 디스크립터를 가져오는 프로그램의 예:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egpg\u003c/code\u003e: \u003ccode\u003e--status-fd \u0026#x3C;fd\u003e\u003c/code\u003e, \u003ccode\u003e--logger-fd \u0026#x3C;fd\u003e\u003c/code\u003e 등\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eopenssl\u003c/code\u003e: \u003ccode\u003e-pass fd:\u0026#x3C;fd\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eqemu\u003c/code\u003e: \u003ccode\u003e-add-fd \u0026#x3C;fd\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalgrind\u003c/code\u003e: \u003ccode\u003e--log-fd=\u0026#x3C;fd\u003e\u003c/code\u003e, \u003ccode\u003e--input-fd=\u0026#x3C;fd\u003e\u003c/code\u003e 등\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exterm\u003c/code\u003e: \u003ccode\u003e-S \u0026#x3C;fd\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLinux에서는 \u003ccode\u003e/dev/fd/\u0026#x3C;fd\u003e\u003c/code\u003e 파일 이름을 사용하여 파일 이름을 예상하는 프로그램에 파일 디스크립터를 전달하는 것이 가능합니다.\u003c/p\u003e\n\u003ch2\u003e성능 (Performances)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하는 것은 새 파일 디스크립터 생성마다 추가적인 시스템 호출 (syscall)을 요구할 수 있습니다. 추가 시스템 호출의 수는 플래그를 설정하는 데 사용되는 방법에 따라 달라집니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eO_NOINHERIT\u003c/code\u003e: 추가 시스템 호출 없음\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eO_CLOEXEC\u003c/code\u003e: 하나의 추가 시스템 호출이 발생하지만, 플래그 지원 여부를 확인하기 위해 첫 파일 디스크립터 생성 시에만 발생합니다. 만약 플래그가 지원되지 않으면, Python은 다음 방법으로 폴백(fallback)해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eioctl(fd, FIOCLEX)\u003c/code\u003e: 파일 디스크립터당 하나의 추가 시스템 호출\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efcntl(fd, F_SETFD, flags)\u003c/code\u003e: 파일 디스크립터당 두 개의 추가 시스템 호출이 발생하며, 하나는 이전 플래그를 가져오는 데, 다른 하나는 새 플래그를 설정하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLinux에서 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하는 것은 성능에 미치는 오버헤드가 낮습니다. Linux 3.6에서 \u003ccode\u003ebench_cloexec.py\u003c/code\u003e의 벤치마크 결과:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그 미설정: 7.8 us\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eO_CLOEXEC\u003c/code\u003e: 1% 느림 (7.9 us)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eioctl()\u003c/code\u003e: 3% 느림 (8.0 us)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efcntl()\u003c/code\u003e: 3% 느림 (8.0 us)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003eos.get_cloexec(fd)\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e파일 디스크립터의 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 가져옵니다.\u003c/p\u003e\n\u003cp\u003e의사 코드:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif os.name == 'nt':\r\n    def get_cloexec(fd):\r\n        handle = _winapi._get_osfhandle(fd)\r\n        flags = _winapi.GetHandleInformation(handle)\r\n        return not(flags \u0026#x26; _winapi.HANDLE_FLAG_INHERIT)\r\nelse:\r\n    try:\r\n        import fcntl\r\n    except ImportError:\r\n        pass\r\n    else:\r\n        def get_cloexec(fd):\r\n            flags = fcntl.fcntl(fd, fcntl.F_GETFD)\r\n            return bool(flags \u0026#x26; fcntl.FD_CLOEXEC)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003ccode\u003eos.set_cloexec(fd, cloexec=True)\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e파일 디스크립터에 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하거나 해제합니다. 이 플래그는 파일 디스크립터 생성 이후에 설정되므로 원자적 (atomic)이지 않습니다.\u003c/p\u003e\n\u003cp\u003e의사 코드:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif os.name == 'nt':\r\n    def set_cloexec(fd, cloexec=True):\r\n        handle = _winapi._get_osfhandle(fd)\r\n        mask = _winapi.HANDLE_FLAG_INHERIT\r\n        if cloexec:\r\n            flags = 0\r\n        else:\r\n            flags = mask\r\n        _winapi.SetHandleInformation(handle, mask, flags)\r\nelse:\r\n    fnctl = None\r\n    ioctl = None\r\n    try:\r\n        import ioctl\r\n    except ImportError:\r\n        try:\r\n            import fcntl\r\n        except ImportError:\r\n            pass\r\n    if ioctl is not None and hasattr('FIOCLEX', ioctl):\r\n        def set_cloexec(fd, cloexec=True):\r\n            if cloexec:\r\n                ioctl.ioctl(fd, ioctl.FIOCLEX)\r\n            else:\r\n                ioctl.ioctl(fd, ioctl.FIONCLEX)\r\n    elif fnctl is not None:\r\n        def set_cloexec(fd, cloexec=True):\r\n            flags = fcntl.fcntl(fd, fcntl.F_GETFD)\r\n            if cloexec:\r\n                flags |= FD_CLOEXEC\r\n            else:\r\n                flags \u0026#x26;= ~FD_CLOEXEC\r\n            fcntl.fcntl(fd, fcntl.F_SETFD, flags)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efcntl\u003c/code\u003e보다 \u003ccode\u003eioctl\u003c/code\u003e이 선호되는데, \u003ccode\u003eioctl\u003c/code\u003e은 단일 시스템 호출만 필요한 반면 \u003ccode\u003efcntl\u003c/code\u003e은 두 개의 시스템 호출이 필요하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e참고: \u003ccode\u003efcntl(fd, F_SETFD, flags)\u003c/code\u003e는 하나의 플래그 (\u003ccode\u003eFD_CLOEXEC\u003c/code\u003e)만 지원하므로 \u003ccode\u003efcntl(fd, F_GETFD)\u003c/code\u003e를 피할 수 있습니다. 하지만 미래에 다른 플래그를 삭제할 수도 있으므로, 두 함수 호출을 유지하는 것이 더 안전합니다.\u003c/p\u003e\n\u003cp\u003e참고: GNU libc의 \u003ccode\u003efopen()\u003c/code\u003e 함수는 \u003ccode\u003efcntl(fd, F_SETFD, flags)\u003c/code\u003e가 실패하더라도 오류를 무시합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eopen()\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eWindows: \u003ccode\u003eopen()\u003c/code\u003e with \u003ccode\u003eO_NOINHERIT\u003c/code\u003e flag [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eopen()\u003c/code\u003e with \u003ccode\u003eO_CLOEXEC\u003c/code\u003e flag [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eopen()\u003c/code\u003e + \u003ccode\u003eos.set_cloexec(fd, True)\u003c/code\u003e [최선 노력 (best-effort)]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003eos.dup()\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eWindows: \u003ccode\u003eDuplicateHandle()\u003c/code\u003e [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efcntl(fd, F_DUPFD_CLOEXEC)\u003c/code\u003e [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edup()\u003c/code\u003e + \u003ccode\u003eos.set_cloexec(fd, True)\u003c/code\u003e [최선 노력]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003eos.dup2()\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efcntl(fd, F_DUP2FD_CLOEXEC, fd2)\u003c/code\u003e [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edup3()\u003c/code\u003e with \u003ccode\u003eO_CLOEXEC\u003c/code\u003e flag [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edup2()\u003c/code\u003e + \u003ccode\u003eos.set_cloexec(fd, True)\u003c/code\u003e [최선 노력]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003eos.pipe()\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eWindows: \u003ccode\u003eCreatePipe()\u003c/code\u003e with \u003ccode\u003eSECURITY_ATTRIBUTES.bInheritHandle=TRUE\u003c/code\u003e, or \u003ccode\u003e_pipe()\u003c/code\u003e with \u003ccode\u003eO_NOINHERIT\u003c/code\u003e flag [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epipe2()\u003c/code\u003e with \u003ccode\u003eO_CLOEXEC\u003c/code\u003e flag [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epipe()\u003c/code\u003e + \u003ccode\u003eos.set_cloexec(fd, True)\u003c/code\u003e [최선 노력]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003esocket.socket()\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eWindows: \u003ccode\u003eWSASocket()\u003c/code\u003e with \u003ccode\u003eWSA_FLAG_NO_HANDLE_INHERIT\u003c/code\u003e flag [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket()\u003c/code\u003e with \u003ccode\u003eSOCK_CLOEXEC\u003c/code\u003e flag [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket()\u003c/code\u003e + \u003ccode\u003eos.set_cloexec(fd, True)\u003c/code\u003e [최선 노력]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003esocket.socketpair()\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esocketpair()\u003c/code\u003e with \u003ccode\u003eSOCK_CLOEXEC\u003c/code\u003e flag [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocketpair()\u003c/code\u003e + \u003ccode\u003eos.set_cloexec(fd, True)\u003c/code\u003e [최선 노력]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003esocket.socket.accept()\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eaccept4()\u003c/code\u003e with \u003ccode\u003eSOCK_CLOEXEC\u003c/code\u003e flag [원자적]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaccept()\u003c/code\u003e + \u003ccode\u003eos.set_cloexec(fd, True)\u003c/code\u003e [최선 노력]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e하위 호환성 (Backward compatibility)\u003c/h2\u003e\n\u003cp\u003e하위 호환성을 깨는 변경 사항은 없습니다. 기본 동작은 변경되지 않으며, \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그는 기본적으로 설정되지 않습니다.\u003c/p\u003e\n\u003ch2\u003e부록: 운영 체제 지원 (Appendix: Operating system support)\u003c/h2\u003e\n\u003ch3\u003eWindows\u003c/h3\u003e\n\u003cp\u003eWindows에는 \"자식 프로세스에서 상속하지 않음\"을 의미하는 \u003ccode\u003eO_NOINHERIT\u003c/code\u003e 플래그가 있습니다. 예를 들어, \u003ccode\u003eopen()\u003c/code\u003e 및 \u003ccode\u003e_pipe()\u003c/code\u003e에서 지원됩니다. 이 플래그는 \u003ccode\u003eSetHandleInformation(fd, HANDLE_FLAG_INHERIT, 0)\u003c/code\u003e을 사용하여 해제할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCreateProcess()\u003c/code\u003e는 \u003ccode\u003ebInheritHandles\u003c/code\u003e 매개변수를 가지고 있습니다. 이 값이 \u003ccode\u003eFALSE\u003c/code\u003e이면 핸들은 상속되지 않습니다. \u003ccode\u003eTRUE\u003c/code\u003e이면 \u003ccode\u003eHANDLE_FLAG_INHERIT\u003c/code\u003e 플래그가 설정된 핸들이 상속됩니다. \u003ccode\u003esubprocess.Popen\u003c/code\u003e은 \u003ccode\u003eclose_fds\u003c/code\u003e 옵션을 사용하여 \u003ccode\u003ebInheritHandles\u003c/code\u003e를 정의합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eioctl\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e함수:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eioctl(fd, FIOCLEX, 0)\u003c/code\u003e: \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그 설정\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eioctl(fd, FIONCLEX, 0)\u003c/code\u003e: \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그 해제\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e가용성: Linux, Mac OS X, QNX, NetBSD, OpenBSD, FreeBSD.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003efcntl\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e함수:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eflags = fcntl(fd, F_GETFD); fcntl(fd, F_SETFD, flags | FD_CLOEXEC)\u003c/code\u003e: \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그 설정\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eflags = fcntl(fd, F_GETFD); fcntl(fd, F_SETFD, flags \u0026#x26; ~FD_CLOEXEC)\u003c/code\u003e: \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그 해제\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e가용성: AIX, Digital UNIX, FreeBSD, HP-UX, IRIX, Linux, Mac OS X, OpenBSD, Solaris, SunOS, Unicos.\u003c/p\u003e\n\u003ch3\u003e원자적 플래그 (Atomic flags)\u003c/h3\u003e\n\u003cp\u003e새로운 플래그:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eO_CLOEXEC\u003c/code\u003e: Linux (2.6.23), FreeBSD (8.3), OpenBSD 5.0, Solaris 11, QNX, BeOS, 다음 NetBSD 릴리스 (6.1?)에서 사용 가능합니다. 이 플래그는 POSIX.1-2008의 일부입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esocket()\u003c/code\u003e 및 \u003ccode\u003esocketpair()\u003c/code\u003e를 위한 \u003ccode\u003eSOCK_CLOEXEC\u003c/code\u003e 플래그: Linux 2.6.27, OpenBSD 5.2, NetBSD 6.0에서 사용 가능합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eWSASocket()\u003c/code\u003e를 위한 \u003ccode\u003eWSA_FLAG_NO_HANDLE_INHERIT\u003c/code\u003e 플래그: Windows 7 SP1, Windows Server 2008 R2 SP1 및 이후 버전에서 지원됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efcntl()\u003c/code\u003e: \u003ccode\u003eF_DUPFD_CLOEXEC\u003c/code\u003e 플래그: Linux 2.6.24, OpenBSD 5.0, FreeBSD 9.1, NetBSD 6.0, Solaris 11에서 사용 가능합니다. 이 플래그는 POSIX.1-2008의 일부입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efcntl()\u003c/code\u003e: \u003ccode\u003eF_DUP2FD_CLOEXEC\u003c/code\u003e 플래그: FreeBSD 9.1 및 Solaris 11에서 사용 가능합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erecvmsg()\u003c/code\u003e: \u003ccode\u003eMSG_CMSG_CLOEXEC\u003c/code\u003e: Linux 2.6.23, NetBSD 6.0에서 사용 가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLinux 2.6.23 이전 버전에서는 \u003ccode\u003eO_CLOEXEC\u003c/code\u003e 플래그가 단순히 무시됩니다. 따라서 \u003ccode\u003efcntl()\u003c/code\u003e을 호출하여 플래그가 지원되는지 확인해야 합니다. 작동하지 않으면 \u003ccode\u003eioctl()\u003c/code\u003e 또는 \u003ccode\u003efcntl()\u003c/code\u003e을 사용하여 플래그를 설정해야 합니다.\u003c/p\u003e\n\u003cp\u003eLinux 2.6.27 이전 버전에서는 \u003ccode\u003eSOCK_CLOEXEC\u003c/code\u003e 플래그가 소켓 유형에 설정되면 \u003ccode\u003esocket()\u003c/code\u003e 또는 \u003ccode\u003esocketpair()\u003c/code\u003e가 실패하고 \u003ccode\u003eerrno\u003c/code\u003e가 \u003ccode\u003eEINVAL\u003c/code\u003e로 설정됩니다.\u003c/p\u003e\n\u003cp\u003eWindows XPS3에서는 \u003ccode\u003eWSA_FLAG_NO_HANDLE_INHERIT\u003c/code\u003e 플래그를 사용하면 \u003ccode\u003eWSASocket()\u003c/code\u003e이 \u003ccode\u003eWSAEPROTOTYPE\u003c/code\u003e 오류를 반환합니다.\u003c/p\u003e\n\u003cp\u003e새로운 함수:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edup3()\u003c/code\u003e: Linux 2.6.27 (및 glibc 2.9)에서 사용 가능합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epipe2()\u003c/code\u003e: Linux 2.6.27 (및 glibc 2.9)에서 사용 가능합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaccept4()\u003c/code\u003e: Linux 2.6.28 (및 glibc 2.10)에서 사용 가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLinux 2.6.28 이전 버전에서 \u003ccode\u003eaccept4()\u003c/code\u003e를 호출하면 \u003ccode\u003eaccept4()\u003c/code\u003e는 -1 (실패)을 반환하고 \u003ccode\u003eerrno\u003c/code\u003e는 \u003ccode\u003eENOSYS\u003c/code\u003e로 설정됩니다.\u003c/p\u003e\n\u003ch2\u003e링크 (Links)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSecure File Descriptor Handling (Ulrich Drepper, 2008)\u003c/li\u003e\n\u003cli\u003eTornado 프로젝트의 \u003ccode\u003ewin32_support.py\u003c/code\u003e: \u003ccode\u003eSetHandleInformation(fd, HANDLE_FLAG_INHERIT, 1)\u003c/code\u003e을 사용하여 \u003ccode\u003efcntl(fd, F_SETFD, FD_CLOEXEC)\u003c/code\u003e 에뮬레이션\u003c/li\u003e\n\u003cli\u003eLKML: [PATCH] \u003ccode\u003enextfd(2)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePython 이슈:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e#10115: 소켓 생성 시 플래그의 원자적 설정을 위한 \u003ccode\u003eaccept4()\u003c/code\u003e 지원\u003c/li\u003e\n\u003cli\u003e#12105: \u003ccode\u003eopen()\u003c/code\u003e이 \u003ccode\u003eO_CLOEXEC\u003c/code\u003e와 같은 플래그를 설정할 수 없음\u003c/li\u003e\n\u003cli\u003e#12107: \u003ccode\u003eFD_CLOEXEC\u003c/code\u003e 플래그 없이 생성된 TCP 리스닝 소켓\u003c/li\u003e\n\u003cli\u003e#16500: \u003ccode\u003eatfork\u003c/code\u003e 모듈 추가\u003c/li\u003e\n\u003cli\u003e#16850: \u003ccode\u003eopen()\u003c/code\u003e에 \"e\" 모드 추가: \u003ccode\u003eclose-and-exec\u003c/code\u003e (\u003ccode\u003eO_CLOEXEC\u003c/code\u003e) / \u003ccode\u003eO_NOINHERIT\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e#16860: \u003ccode\u003etempfile\u003c/code\u003e 모듈에서 \u003ccode\u003eO_CLOEXEC\u003c/code\u003e 사용\u003c/li\u003e\n\u003cli\u003e#17036: PEP 433 구현\u003c/li\u003e\n\u003cli\u003e#16946: \u003ccode\u003esubprocess\u003c/code\u003e: \u003ccode\u003e_close_open_fd_range_safe()\u003c/code\u003e는 \u003ccode\u003eO_CLOEXEC\u003c/code\u003e가 정의되어 있어도 Linux \u0026#x3C; 2.6.23에서 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정하지 않음\u003c/li\u003e\n\u003cli\u003e#17070: PEP 433: 새로운 \u003ccode\u003ecloexec\u003c/code\u003e를 사용하여 보안 개선 및 버그 방지\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다른 언어:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePerl은 새로 생성된 파일 디스크립터의 번호가 \u003ccode\u003e$SYSTEM_FD_MAX\u003c/code\u003e (\u003ccode\u003e$^F\u003c/code\u003e)보다 큰 경우 \u003ccode\u003eclose-on-exec\u003c/code\u003e 플래그를 설정합니다. Perl 1부터 존재했습니다.\u003c/li\u003e\n\u003cli\u003eRuby: \u003ccode\u003eFD_CLOEXEC\u003c/code\u003e for all \u003ccode\u003efds\u003c/code\u003e (0, 1, 2 제외) 설정. \u003ccode\u003eKernel::open\u003c/code\u003e에 \u003ccode\u003eO_CLOEXEC\u003c/code\u003e 플래그 누락: 커밋은 나중에 되돌려졌습니다.\u003c/li\u003e\n\u003cli\u003eOCaml: PR#5256: \u003ccode\u003eUnix.open_process*\u003c/code\u003e를 사용하여 열린 프로세스는 모든 열린 파일 디스크립터 (소켓 포함)를 상속합니다. OCaml에는 \u003ccode\u003eUnix.set_close_on_exec\u003c/code\u003e 함수가 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e각주 (Footnotes)\u003c/h2\u003e\n\u003cp\u003eUNIX에서 Python 3.2부터 \u003ccode\u003esubprocess.Popen()\u003c/code\u003e은 기본적으로 모든 파일 디스크립터를 닫습니다 (\u003ccode\u003eclose_fds=True\u003c/code\u003e). 이는 3번을 포함하여 \u003ccode\u003elocal_max_fd\u003c/code\u003e (NetBSD에서는 \u003ccode\u003efcntl(0, F_MAXFD)\u003c/code\u003e, 그 외에는 \u003ccode\u003esysconf(_SC_OPEN_MAX)\u003c/code\u003e) 미만까지의 파일 디스크립터를 닫습니다. 만약 오류 파이프의 디스크립터가 3보다 작으면 \u003ccode\u003eValueError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 공개 도메인으로 지정되었습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Superseded] PEP 433 - Easier suppression of file descriptor inheritance\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 21:45:26+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>