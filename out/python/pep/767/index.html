<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Draft] PEP 767 - Annotating Read-Only Attributes</h1><div class="page__meta"><time dateTime="2025-09-27 13:49:33+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0767/">PEP 767 - Annotating Read-Only Attributes</a></p>
<p><strong>상태:</strong> Draft | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 18-Nov-2024</p>
</blockquote>
<hr>
<h1>PEP 767: 읽기 전용 속성 어노테이션</h1>
<h2>초록 (Abstract)</h2>
<p>PEP 705에서 <code>typing.ReadOnly</code> 타입 한정자(type qualifier)를 도입하여 <code>typing.TypedDict</code> 항목을 읽기 전용으로 정의할 수 있게 했습니다.</p>
<p>이 PEP는 클래스와 프로토콜(protocol) 속성 어노테이션(annotation)에서 <code>ReadOnly</code>를 사용하여 속성을 읽기 전용으로 표시하는 간결한 방법을 제안합니다.</p>
<p>PEP 705와 마찬가지로, 이 제안은 런타임(runtime)에 속성을 설정하는 방식에는 변경을 가하지 않습니다. 읽기 전용 속성의 올바른 사용은 오직 정적 타입 체커(static type checker)에 의해서만 강제됩니다.</p>
<h2>동기 (Motivation)</h2>
<p>Python 타입 시스템(type system)에는 속성을 읽기 전용으로 표시하는 단일하고 간결한 방법이 부족합니다. 이 기능은 C# 또는 TypeScript와 같은 다른 정적 및 점진적 타입 언어에 존재하며, 타입 체커 수준에서 속성을 재할당(reassign)하거나 삭제(delete)하는 기능을 제거하고, 구조적 서브타이핑(structural subtyping)을 위한 광범위한 인터페이스를 정의하는 데 유용합니다.</p>
<h3>클래스 (Classes)</h3>
<p>오늘날, 타입 체커들이 인정하는 읽기 전용 속성을 달성하는 세 가지 주요 방법이 있습니다.</p>
<ol>
<li>
<p><strong>속성에 <code>typing.Final</code> 어노테이션 달기:</strong></p>
<pre><code class="language-python">class Foo:
    number: Final[int]
    def __init__(self, number: int) -> None:
        self.number = number

class Bar:
    def __init__(self, number: int) -> None:
        self.number: Final = number
</code></pre>
<p><code>dataclasses</code>에서 지원되며, <code>typing#1669</code> 이후 타입 체커에서도 지원됩니다. <code>Final</code>의 명세에 따라 하위 클래스에서 <code>number</code>를 재정의할 수 없습니다.</p>
</li>
<li>
<p><strong><code>@property</code>를 통한 읽기 전용 프록시(proxy):</strong></p>
<pre><code class="language-python">class Foo:
    _number: int
    def __init__(self, number: int) -> None:
        self._number = number

    @property
    def number(self) -> int:
        return self._number
</code></pre>
<p><code>number</code>를 재정의하는 것이 가능합니다. 타입 체커마다 특정 규칙에 대한 의견이 다릅니다. 런타임에는 읽기 전용이지만, 추가적인 보일러플레이트(boilerplate) 코드가 필요합니다. <code>dataclasses</code>에서 지원되지만, 합성(compose)이 잘 되지 않습니다. 합성된 <code>__init__</code> 및 <code>__repr__</code>은 <code>_number</code>를 매개변수/속성 이름으로 사용합니다.</p>
</li>
<li>
<p><strong><code>dataclasses.dataclass(frozen=True)</code> 또는 <code>typing.NamedTuple</code>과 같은 "고정(freezing)" 메커니즘 사용:</strong></p>
<pre><code class="language-python">@dataclass(frozen=True)
class Foo:
    number: int # 암묵적으로 읽기 전용

class Bar(NamedTuple):
    number: int # 암묵적으로 읽기 전용
</code></pre>
<p><code>@dataclass</code>의 경우 <code>number</code>를 재정의하는 것이 가능합니다. 런타임에는 읽기 전용입니다. 속성별 제어가 불가능하며, 이 메커니즘은 전체 클래스에 적용됩니다. 고정된 데이터클래스(frozen dataclasses)는 약간의 런타임 오버헤드를 발생시킵니다. <code>NamedTuple</code>은 여전히 튜플(tuple)이며, 대부분의 클래스는 인덱싱(indexing), 이터레이션(iteration) 또는 연결(concatenation)을 상속할 필요가 없습니다.</p>
</li>
</ol>
<h3>프로토콜 (Protocols)</h3>
<p><code>name: T</code>라는 멤버를 정의하는 <code>Protocol</code>을 가정해봅시다. 이는 두 가지 요구사항을 정의합니다.</p>
<ul>
<li><code>hasattr(obj, "name")</code></li>
<li><code>isinstance(obj.name, T)</code></li>
</ul>
<p>이러한 요구사항은 런타임에 다음 모두에 의해 충족될 수 있습니다.</p>
<ul>
<li>속성 <code>name: T</code>를 가진 객체</li>
<li>클래스 변수 <code>name: ClassVar[T]</code>를 가진 클래스</li>
<li>위 클래스의 인스턴스</li>
<li><code>@property def name(self) -> T</code>를 가진 객체</li>
<li><code>functools.cached_property()</code>와 같은 사용자 정의 디스크립터(descriptor)를 가진 객체</li>
</ul>
<p>현재 타입 명세(typing spec)는 (추상) 속성을 사용하여 이러한 프로토콜 멤버를 생성하는 것을 허용합니다.</p>
<pre><code class="language-python">class HasName(Protocol):
    @property
    def name(self) -> T:
        ...
</code></pre>
<p>이 문법은 몇 가지 단점이 있습니다.</p>
<ul>
<li>다소 장황합니다.</li>
<li>여기서 전달되는 품질이 속성의 읽기 전용 특성이라는 것이 명확하지 않습니다.</li>
<li>타입 한정자와 합성될 수 없습니다.</li>
<li>모든 타입 체커가 위의 다섯 가지 객체 모두가 이 구조적 타입에 할당될 수 있다는 것에 동의하지 않습니다.</li>
</ul>
<h2>근거 (Rationale)</h2>
<p>이러한 문제들은 속성 수준의 타입 한정자로 해결될 수 있습니다. <code>ReadOnly</code>가 이 역할을 위해 선택되었는데, 그 이름이 의도를 잘 전달하고, 새로 제안된 변경 사항이 PEP 705에서 정의된 의미를 보완하기 때문입니다.</p>
<p>읽기 전용 인스턴스 속성을 가진 클래스는 이제 다음과 같이 정의할 수 있습니다.</p>
<pre><code class="language-python">from typing import ReadOnly

class Member:
    def __init__(self, id: int) -> None:
        self.id: ReadOnly[int] = id
</code></pre>
<p>그리고 "프로토콜" 섹션에서 설명한 프로토콜은 이제 다음과 같습니다.</p>
<pre><code class="language-python">from typing import Protocol, ReadOnly

class HasName(Protocol):
    name: ReadOnly[str]

def greet(obj: HasName, /) -> str:
    return f"Hello, {obj.name}!"
</code></pre>
<p><code>Member</code>의 서브클래스(subclass)는 <code>.id</code>를 쓰기 가능한 속성이나 디스크립터로 재정의할 수 있습니다. 또한 타입을 좁힐(narrow) 수도 있습니다. <code>HasName</code> 프로토콜은 더 간결한 정의를 가지며, 속성의 쓰기 가능성(writability)에 구애받지 않습니다. <code>greet</code> 함수는 이제 다양한 호환 가능한 객체를 허용하면서, 입력에 대한 수정이 이루어지지 않음을 명시할 수 있습니다.</p>
<h2>명세 (Specification)</h2>
<p><code>typing.ReadOnly</code> 타입 한정자는 클래스 및 프로토콜의 속성에 대한 유효한 어노테이션이 됩니다. 개별 속성을 읽기 전용으로 표시하기 위해 클래스 수준 또는 <code>__init__</code> 내에서 사용할 수 있습니다.</p>
<pre><code class="language-python">class Book:
    id: ReadOnly[int]
    def __init__(self, id: int, name: str) -> None:
        self.id = id
        self.name: ReadOnly[str] = name
</code></pre>
<p>타입 체커는 <code>ReadOnly</code>로 어노테이션된 속성을 재할당하거나 삭제하려는 모든 시도에 대해 오류를 발생시켜야 합니다. 또한 <code>Final</code>로 어노테이션된 속성을 삭제하려는 모든 시도에 대해서도 오류를 발생시켜야 합니다 (이는 현재 명세되어 있지 않습니다).</p>
<p><code>ReadOnly</code>가 현재 의미가 없는 다른 위치(예: 지역/전역 변수 또는 함수 매개변수)의 어노테이션에 사용되는 것은 이 PEP의 범위를 벗어납니다.</p>
<p><code>Final</code>과 유사하게, <code>ReadOnly</code>는 타입 체커가 할당된 객체의 가변성(mutability)을 인식하는 방식에 영향을 미치지 않습니다. 불변(immutable) ABCs 및 컨테이너는 <code>ReadOnly</code>와 함께 사용하여 타입 체커 수준에서 그러한 값의 변형을 금지할 수 있습니다.</p>
<pre><code class="language-python">from collections import abc
from dataclasses import dataclass
from typing import Protocol, ReadOnly

@dataclass
class Game:
    name: str

class HasGames[T: abc.Collection[Game]](Protocol):
    games: ReadOnly[T]

def add_games(shelf: HasGames[list[Game]]) -> None:
    shelf.games.append(Game("Half-Life")) # ok: list는 가변
    shelf.games[-1].name = "Black Mesa" # ok: "name"은 읽기 전용이 아님
    shelf.games = [] # error: "games"는 읽기 전용
    del shelf.games # error: "games"는 읽기 전용이며 삭제할 수 없음

def read_games(shelf: HasGames[abc.Sequence[Game]]) -> None:
    shelf.games.append(...) # error: "Sequence"는 "append" 속성이 없음
    shelf.games[0].name = "Blue Shift" # ok: "name"은 읽기 전용이 아님
    shelf.games = [] # error: "games"는 읽기 전용
</code></pre>
<p>고정된 데이터클래스(<code>frozen dataclasses</code>) 및 <code>NamedTuple</code>의 모든 인스턴스 속성은 암묵적으로 읽기 전용이어야 합니다. 타입 체커는 이러한 속성에 <code>ReadOnly</code>를 어노테이션하는 것이 중복임을 알릴 수 있지만, 오류로 간주되어서는 안 됩니다.</p>
<pre><code class="language-python">from dataclasses import dataclass
from typing import NewType, ReadOnly

@dataclass(frozen=True)
class Point:
    x: int # 암묵적 읽기 전용
    y: ReadOnly[int] # ok, 중복

uint = NewType("uint", int)

@dataclass(frozen=True)
class UnsignedPoint(Point):
    x: ReadOnly[uint] # ok, 중복; 더 좁은 타입
    y: Final[uint] # 중복 아님, Final은 추가적인 제약 조건 부과; 더 좁은 타입
</code></pre>
<h3>초기화 (Initialization)</h3>
<p>읽기 전용 속성에 대한 할당은 속성을 선언하는 클래스 내에서만 발생할 수 있습니다. 속성이 몇 번 할당될 수 있는지에 대한 제한은 없습니다. 속성의 종류에 따라 다른 위치에서 할당될 수 있습니다.</p>
<h4>인스턴스 속성 (Instance Attributes)</h4>
<p>인스턴스 속성에 대한 할당은 다음 컨텍스트에서 허용되어야 합니다.</p>
<ul>
<li><code>__init__</code>에서, 첫 번째 매개변수로 받은 인스턴스(대개 <code>self</code>)에.</li>
<li><code>__new__</code>에서, 상위 클래스의 <code>__new__</code> 메서드 호출을 통해 생성된 선언 클래스의 인스턴스에.</li>
<li>클래스 본문 내 선언 시.</li>
</ul>
<p>또한, 타입 체커는 다음 할당을 허용하도록 선택할 수 있습니다.</p>
<ul>
<li><code>__new__</code>에서, 인스턴스의 출처와 관계없이 선언 클래스의 인스턴스에. (이 선택은 인스턴스가 이미 초기화되었을 수 있으므로 견고함(soundness)을 구현의 단순성과 교환합니다.)</li>
<li><code>@classmethod</code>에서, 클래스 또는 상위 클래스의 <code>__new__</code> 메서드 호출을 통해 생성된 선언 클래스의 인스턴스에.</li>
</ul>
<pre><code class="language-python">from collections import abc
from typing import ReadOnly

class Band:
    name: str
    songs: ReadOnly[list[str]]

    def __init__(self, name: str, songs: abc.Iterable[str] | None = None) -> None:
        self.name = name
        self.songs = []
        if songs is not None:
            self.songs = list(songs) # 여러 번 할당 가능

    def clear(self) -> None:
        self.songs = [] # error: 초기화 외부에서 읽기 전용 "songs"에 할당

band = Band(name="Bôa", songs=["Duvet"])
band.name = "Python" # ok: "name"은 읽기 전용이 아님
band.songs = [] # error: "songs"는 읽기 전용
band.songs.append("Twilight") # ok: list는 가변

class SubBand(Band):
    def __init__(self) -> None:
        self.songs = [] # error: 기본 클래스의 읽기 전용 속성에 할당할 수 없음

# 단순화된 불변 Fraction 클래스
class Fraction:
    numerator: ReadOnly[int]
    denominator: ReadOnly[int]

    def __new__(
        cls,
        numerator: str | int | float | Decimal | Rational = 0,
        denominator: int | Rational | None = None
    ) -> Self:
        self = super().__new__(cls)
        if denominator is None:
            if type(numerator) is int:
                self.numerator = numerator
                self.denominator = 1
            return self
        elif isinstance(numerator, Rational):
            ...
        else:
            ...

    @classmethod
    def from_float(cls, f: float, /) -> Self:
        self = super().__new__(cls)
        self.numerator, self.denominator = f.as_integer_ratio()
        return self
</code></pre>
<h4>클래스 속성 (Class Attributes)</h4>
<p>읽기 전용 클래스 속성은 <code>ReadOnly</code>와 <code>ClassVar</code> 모두로 어노테이션된 속성입니다. 이러한 속성에 대한 할당은 다음 컨텍스트에서 허용되어야 합니다.</p>
<ul>
<li>클래스 본문 내 선언 시.</li>
<li><code>__init_subclass__</code>에서, 첫 번째 매개변수로 받은 클래스 객체(대개 <code>cls</code>)에.</li>
</ul>
<pre><code class="language-python">class URI:
    protocol: ReadOnly[ClassVar[str]] = ""

    def __init_subclass__(cls, protocol: str = "") -> None:
        cls.protocol = protocol

class File(URI, protocol="file"):
    ...
</code></pre>
<p>클래스 수준 선언에 초기화 값이 있는 경우, 인스턴스를 위한 플라이웨이트(flyweight) 기본값으로 사용될 수 있습니다.</p>
<pre><code class="language-python">class Patient:
    number: ReadOnly[int] = 0

    def __init__(self, number: int | None = None) -> None:
        if number is not None:
            self.number = number
</code></pre>
<p>참고: 이 기능은 <code>__slots__</code>와 충돌합니다. 클래스 수준 값을 가진 속성은 슬롯(slots)에 포함될 수 없으며, 효과적으로 클래스 변수가 됩니다.</p>
<p>타입 체커는 인스턴스가 생성된 후 초기화되지 않은 상태로 남을 수 있는 읽기 전용 속성(스텁(stub), 프로토콜 또는 ABCs 제외)에 대해 경고하도록 선택할 수 있습니다.</p>
<pre><code class="language-python">class Patient:
    id: ReadOnly[int] # error: 모든 코드 경로에서 "id"가 초기화되지 않음
    name: ReadOnly[str] # error: "name"이 전혀 초기화되지 않음
    def __init__(self) -> None:
        if random.random() > 0.5:
            self.id = 123

class HasName(Protocol):
    name: ReadOnly[str] # ok
</code></pre>
<h3>서브타이핑 (Subtyping)</h3>
<p>읽기 전용 속성을 재할당할 수 없기 때문에 공변적(covariant)입니다. 이는 몇 가지 서브타이핑 함의를 가집니다. PEP 705에서 빌려온 내용입니다.</p>
<p>읽기 전용 속성은 쓰기 가능한 속성, 디스크립터 또는 클래스 변수로 재선언될 수 있습니다.</p>
<pre><code class="language-python">@dataclass
class HasTitle:
    title: ReadOnly[str]

@dataclass
class Game(HasTitle):
    title: str
    year: int

game = Game(title="DOOM", year=1993)
game.year = 1994
game.title = "DOOM II" # ok: 속성이 읽기 전용이 아님

class TitleProxy(HasTitle):
    @functools.cached_property
    def title(self) -> str:
        ...

class SharedTitle(HasTitle):
    title: ClassVar[str] = "Still Grey"
</code></pre>
<p>읽기 전용 속성이 재선언되지 않으면, 계속 읽기 전용으로 유지됩니다.</p>
<pre><code class="language-python">class Game(HasTitle):
    year: int
    def __init__(self, title: str, year: int) -> None:
        super().__init__(title)
        self.title = title # error: 기본 클래스의 읽기 전용 속성에 할당할 수 없음
        self.year = year

game = Game(title="Robot Wants Kitty", year=2010)
game.title = "Robot Wants Puppy" # error: "title"은 읽기 전용
</code></pre>
<p>서브타입(subtype)은 읽기 전용 속성의 타입을 좁힐 수 있습니다.</p>
<pre><code class="language-python">class GameCollection(Protocol):
    games: ReadOnly[abc.Collection[Game]]

@dataclass
class GameSeries(GameCollection):
    name: str
    games: ReadOnly[list[Game]] # ok: list[Game]은 Collection[Game]에 할당 가능
</code></pre>
<p>프로토콜 및 ABCs의 명목적(nominal) 서브클래스는 기본 클래스가 어떤 방식으로든 초기화하지 않는 한, 구현하기 위해 읽기 전용 속성을 재선언해야 합니다.</p>
<pre><code class="language-python">class MyBase(abc.ABC):
    foo: ReadOnly[int]
    bar: ReadOnly[str] = "abc"
    baz: ReadOnly[float]
    def __init__(self, baz: float) -> None:
        self.baz = baz

    @abstractmethod
    def pprint(self) -> None:
        ...

@final
class MySubclass(MyBase):
    # error: MySubclass는 "foo"를 재정의하지 않음
    def pprint(self) -> None:
        print(self.foo, self.bar, self.baz)
</code></pre>
<p>프로토콜 속성 선언에서 <code>name: ReadOnly[T]</code>는 구조적 서브타입이 <code>.name</code> 접근을 지원해야 하며, 반환된 값이 <code>T</code>에 할당 가능함을 나타냅니다.</p>
<pre><code class="language-python">class HasName(Protocol):
    name: ReadOnly[str]

class NamedAttr:
    name: str

class NamedProp:
    @property
    def name(self) -> str:
        ...

class NamedClassVar:
    name: ClassVar[str]

class NamedDescriptor:
    @cached_property
    def name(self) -> str:
        ...

# 다음 모두 올바름
has_name: HasName
has_name = NamedAttr()
has_name = NamedProp()
has_name = NamedClassVar
has_name = NamedClassVar()
has_name = NamedDescriptor()
</code></pre>
<h3>다른 타입 한정자와의 상호작용 (Interaction with Other Type Qualifiers)</h3>
<p><code>ReadOnly</code>는 <code>ClassVar</code> 및 <code>Annotated</code>와 어떤 중첩 순서로든 사용될 수 있습니다.</p>
<pre><code class="language-python">class Foo:
    foo: ClassVar[ReadOnly[str]] = "foo"
    bar: Annotated[ReadOnly[int], Gt(0)]

class Foo:
    foo: ReadOnly[ClassVar[str]] = "foo"
    bar: ReadOnly[Annotated[int, Gt(0)]]
</code></pre>
<p>이는 PEP 705에서 정의된 <code>ReadOnly</code>와 <code>typing.TypedDict</code>의 상호작용과 일치합니다.</p>
<p>속성은 <code>ReadOnly</code>와 <code>Final</code>로 동시에 어노테이션될 수 없습니다. 두 한정자는 의미가 다르며, <code>Final</code>이 일반적으로 더 제한적입니다. <code>Final</code>은 읽기 전용으로만 암시되는 속성의 어노테이션으로는 계속 허용됩니다. 또한 기본 클래스의 <code>ReadOnly</code> 속성을 재선언하는 데 사용될 수도 있습니다.</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>이 PEP는 <code>ReadOnly</code>가 유효한 새로운 컨텍스트를 도입합니다. 해당 위치를 검사하는 프로그램은 이를 지원하기 위해 변경되어야 합니다. 이는 주로 타입 체커에 영향을 미칠 것으로 예상됩니다.</p>
<p>그러나 이전 버전의 Python에서 백포트(backported)된 <code>typing_extensions.ReadOnly</code>를 사용할 때는 주의가 필요합니다. 어노테이션을 검사하는 메커니즘이 <code>ReadOnly</code>를 만났을 때 잘못 동작할 수 있으며, 특히 <code>ClassVar</code>를 찾는 <code>@dataclass</code> 데코레이터는 <code>ReadOnly[ClassVar[...]]</code>를 인스턴스 속성으로 오인할 수 있습니다.</p>
<p>인트로스펙션(introspection) 문제를 피하려면 <code>ReadOnly[ClassVar[...]]</code> 대신 <code>ClassVar[ReadOnly[...]]</code>를 사용하세요.</p>
<h2>보안 고려사항 (Security Implications)</h2>
<p>이 PEP로 인해 발생하는 알려진 보안 문제는 없습니다.</p>
<h2>교육 방법 (How to Teach This)</h2>
<p>PEP 705의 지침에 따라 <code>typing</code> 모듈 문서에 제안된 변경 사항:</p>
<ul>
<li>
<p>이 PEP를 다른 나열된 PEP에 추가합니다.</p>
</li>
<li>
<p><code>typing.ReadOnly</code>를 이 PEP에 연결합니다.</p>
</li>
<li>
<p><code>typing.ReadOnly</code>의 설명을 업데이트합니다.</p>
<blockquote>
<p>클래스의 속성 또는 <code>TypedDict</code>의 항목을 읽기 전용으로 표시하는 특별한 타입 구조입니다.</p>
</blockquote>
</li>
<li>
<p>타입 한정자 섹션 아래에 <code>ReadOnly</code>에 대한 독립적인 항목을 추가합니다.</p>
<blockquote>
<p>클래스 속성 어노테이션의 <code>ReadOnly</code> 타입 한정자는 클래스의 속성을 읽을 수는 있지만, 재할당하거나 삭제할 수 없음을 나타냅니다. <code>TypedDict</code>에서의 사용은 <code>ReadOnly</code>를 참조하십시오.</p>
</blockquote>
</li>
</ul>
<h2>거부된 아이디어 (Rejected Ideas)</h2>
<h3><code>@property</code>와 프로토콜의 상호작용 명확화 (Clarifying Interaction of @property and Protocols)</h3>
<p>"프로토콜" 섹션에서는 프로토콜 내 속성의 해석에 있어 타입 체커 간의 불일치가 언급됩니다. 이 문제는 타입 명세를 수정하여 이러한 속성의 읽기 전용 특성을 구현하는 것이 무엇인지 명확히 함으로써 해결될 수 있었습니다.</p>
<p>이 PEP는 프로토콜에서 읽기 전용 속성을 정의하는 더 나은 대안으로 <code>ReadOnly</code>를 만들고, 이 목적으로 속성을 사용하는 것을 대체합니다.</p>
<h3><code>__init__</code> 및 클래스 본문 내에서만 할당 (Assignment Only in <code>__init__</code> and Class Body)</h3>
<p>이 PEP의 초기 버전에서는 읽기 전용 속성이 <code>__init__</code> 및 클래스 본문 내에서만 할당될 수 있다고 제안했습니다. 이후 논의를 통해 이 제한이 일반적으로 <code>__init__</code>을 정의하지 않는 불변 클래스(immutable classes) 내에서 <code>ReadOnly</code>의 유용성을 심각하게 제한할 것이라는 점이 밝혀졌습니다.</p>
<p><code>fractions.Fraction</code>은 불변 클래스의 한 예로, 속성 초기화가 <code>__new__</code> 및 클래스 메서드 내에서 발생합니다. 그러나 <code>__init__</code>과 달리, <code>__new__</code> 및 클래스 메서드 내에서의 할당은 인스턴스가 이미 최종화된 인스턴스를 포함하여 임의의 위치에서 소스될 수 있으므로 잠재적으로 불건전(unsound)합니다.</p>
<p>이 타입 검사 기능이 읽기 전용 속성의 가장 중요한 사용처인 불변 클래스에 유용해야 한다고 생각합니다. 따라서 PEP는 초기화 섹션에 설명된 일련의 규칙에 따라 <code>__new__</code> 및 클래스 메서드에서 할당을 허용하도록 변경되었습니다.</p>
<h2>미해결 문제 (Open Issues)</h2>
<h3>초기화 확장 (Extending Initialization)</h3>
<p><code>dataclasses.__post_init__()</code> 또는 <code>attrs</code>의 초기화 훅(hook)과 같은 메커니즘은 초기화 중에 호출되는 특별한 훅 세트를 제공하여 객체 생성을 보강합니다.</p>
<p>이 PEP에 정의된 현재 초기화 규칙은 이러한 메서드에서 읽기 전용 속성에 대한 할당을 허용하지 않습니다. 이러한 3rd-party 훅을 포함하면서 해당 속성의 읽기 전용 특성과 관련된 불변성을 유지하는 방식으로 규칙을 만족스럽게 만들 수 있는지 여부는 불분명합니다.</p>
<p>Python 타입 시스템은 <code>__new__</code> 및 <code>__init__</code>의 동작에 대해 길고 상세한 명세를 가지고 있습니다. 3rd-party 훅에서 동일한 수준의 세부 정보를 기대하는 것은 다소 비현실적입니다.</p>
<p>잠재적인 해결책은 타입 체커가 이와 관련하여 구성을 제공하여 최종 사용자가 초기화를 허용하려는 메서드 세트를 수동으로 지정하도록 요구하는 것입니다. 그러나 이는 사용자가 앞서 언급한 불변성을 실수로 또는 의도적으로 위반할 수 있습니다. 또한 상대적으로 틈새(niche) 기능에 대한 상당히 큰 요구 사항입니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/767\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/767/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/767\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"767\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/767\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T601f,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0767/\"\u003ePEP 767 - Annotating Read-Only Attributes\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Draft | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 18-Nov-2024\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch1\u003ePEP 767: 읽기 전용 속성 어노테이션\u003c/h1\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003ePEP 705에서 \u003ccode\u003etyping.ReadOnly\u003c/code\u003e 타입 한정자(type qualifier)를 도입하여 \u003ccode\u003etyping.TypedDict\u003c/code\u003e 항목을 읽기 전용으로 정의할 수 있게 했습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 클래스와 프로토콜(protocol) 속성 어노테이션(annotation)에서 \u003ccode\u003eReadOnly\u003c/code\u003e를 사용하여 속성을 읽기 전용으로 표시하는 간결한 방법을 제안합니다.\u003c/p\u003e\n\u003cp\u003ePEP 705와 마찬가지로, 이 제안은 런타임(runtime)에 속성을 설정하는 방식에는 변경을 가하지 않습니다. 읽기 전용 속성의 올바른 사용은 오직 정적 타입 체커(static type checker)에 의해서만 강제됩니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePython 타입 시스템(type system)에는 속성을 읽기 전용으로 표시하는 단일하고 간결한 방법이 부족합니다. 이 기능은 C# 또는 TypeScript와 같은 다른 정적 및 점진적 타입 언어에 존재하며, 타입 체커 수준에서 속성을 재할당(reassign)하거나 삭제(delete)하는 기능을 제거하고, 구조적 서브타이핑(structural subtyping)을 위한 광범위한 인터페이스를 정의하는 데 유용합니다.\u003c/p\u003e\n\u003ch3\u003e클래스 (Classes)\u003c/h3\u003e\n\u003cp\u003e오늘날, 타입 체커들이 인정하는 읽기 전용 속성을 달성하는 세 가지 주요 방법이 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e속성에 \u003ccode\u003etyping.Final\u003c/code\u003e 어노테이션 달기:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Foo:\n    number: Final[int]\n    def __init__(self, number: int) -\u003e None:\n        self.number = number\n\nclass Bar:\n    def __init__(self, number: int) -\u003e None:\n        self.number: Final = number\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edataclasses\u003c/code\u003e에서 지원되며, \u003ccode\u003etyping#1669\u003c/code\u003e 이후 타입 체커에서도 지원됩니다. \u003ccode\u003eFinal\u003c/code\u003e의 명세에 따라 하위 클래스에서 \u003ccode\u003enumber\u003c/code\u003e를 재정의할 수 없습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e@property\u003c/code\u003e를 통한 읽기 전용 프록시(proxy):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Foo:\n    _number: int\n    def __init__(self, number: int) -\u003e None:\n        self._number = number\n\n    @property\n    def number(self) -\u003e int:\n        return self._number\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003enumber\u003c/code\u003e를 재정의하는 것이 가능합니다. 타입 체커마다 특정 규칙에 대한 의견이 다릅니다. 런타임에는 읽기 전용이지만, 추가적인 보일러플레이트(boilerplate) 코드가 필요합니다. \u003ccode\u003edataclasses\u003c/code\u003e에서 지원되지만, 합성(compose)이 잘 되지 않습니다. 합성된 \u003ccode\u003e__init__\u003c/code\u003e 및 \u003ccode\u003e__repr__\u003c/code\u003e은 \u003ccode\u003e_number\u003c/code\u003e를 매개변수/속성 이름으로 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003edataclasses.dataclass(frozen=True)\u003c/code\u003e 또는 \u003ccode\u003etyping.NamedTuple\u003c/code\u003e과 같은 \"고정(freezing)\" 메커니즘 사용:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@dataclass(frozen=True)\nclass Foo:\n    number: int # 암묵적으로 읽기 전용\n\nclass Bar(NamedTuple):\n    number: int # 암묵적으로 읽기 전용\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e@dataclass\u003c/code\u003e의 경우 \u003ccode\u003enumber\u003c/code\u003e를 재정의하는 것이 가능합니다. 런타임에는 읽기 전용입니다. 속성별 제어가 불가능하며, 이 메커니즘은 전체 클래스에 적용됩니다. 고정된 데이터클래스(frozen dataclasses)는 약간의 런타임 오버헤드를 발생시킵니다. \u003ccode\u003eNamedTuple\u003c/code\u003e은 여전히 튜플(tuple)이며, 대부분의 클래스는 인덱싱(indexing), 이터레이션(iteration) 또는 연결(concatenation)을 상속할 필요가 없습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e프로토콜 (Protocols)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ename: T\u003c/code\u003e라는 멤버를 정의하는 \u003ccode\u003eProtocol\u003c/code\u003e을 가정해봅시다. 이는 두 가지 요구사항을 정의합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ehasattr(obj, \"name\")\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eisinstance(obj.name, T)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 요구사항은 런타임에 다음 모두에 의해 충족될 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e속성 \u003ccode\u003ename: T\u003c/code\u003e를 가진 객체\u003c/li\u003e\n\u003cli\u003e클래스 변수 \u003ccode\u003ename: ClassVar[T]\u003c/code\u003e를 가진 클래스\u003c/li\u003e\n\u003cli\u003e위 클래스의 인스턴스\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@property def name(self) -\u003e T\u003c/code\u003e를 가진 객체\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efunctools.cached_property()\u003c/code\u003e와 같은 사용자 정의 디스크립터(descriptor)를 가진 객체\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e현재 타입 명세(typing spec)는 (추상) 속성을 사용하여 이러한 프로토콜 멤버를 생성하는 것을 허용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass HasName(Protocol):\n    @property\n    def name(self) -\u003e T:\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 문법은 몇 가지 단점이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e다소 장황합니다.\u003c/li\u003e\n\u003cli\u003e여기서 전달되는 품질이 속성의 읽기 전용 특성이라는 것이 명확하지 않습니다.\u003c/li\u003e\n\u003cli\u003e타입 한정자와 합성될 수 없습니다.\u003c/li\u003e\n\u003cli\u003e모든 타입 체커가 위의 다섯 가지 객체 모두가 이 구조적 타입에 할당될 수 있다는 것에 동의하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e이러한 문제들은 속성 수준의 타입 한정자로 해결될 수 있습니다. \u003ccode\u003eReadOnly\u003c/code\u003e가 이 역할을 위해 선택되었는데, 그 이름이 의도를 잘 전달하고, 새로 제안된 변경 사항이 PEP 705에서 정의된 의미를 보완하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e읽기 전용 인스턴스 속성을 가진 클래스는 이제 다음과 같이 정의할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import ReadOnly\n\nclass Member:\n    def __init__(self, id: int) -\u003e None:\n        self.id: ReadOnly[int] = id\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 \"프로토콜\" 섹션에서 설명한 프로토콜은 이제 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Protocol, ReadOnly\n\nclass HasName(Protocol):\n    name: ReadOnly[str]\n\ndef greet(obj: HasName, /) -\u003e str:\n    return f\"Hello, {obj.name}!\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eMember\u003c/code\u003e의 서브클래스(subclass)는 \u003ccode\u003e.id\u003c/code\u003e를 쓰기 가능한 속성이나 디스크립터로 재정의할 수 있습니다. 또한 타입을 좁힐(narrow) 수도 있습니다. \u003ccode\u003eHasName\u003c/code\u003e 프로토콜은 더 간결한 정의를 가지며, 속성의 쓰기 가능성(writability)에 구애받지 않습니다. \u003ccode\u003egreet\u003c/code\u003e 함수는 이제 다양한 호환 가능한 객체를 허용하면서, 입력에 대한 수정이 이루어지지 않음을 명시할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003etyping.ReadOnly\u003c/code\u003e 타입 한정자는 클래스 및 프로토콜의 속성에 대한 유효한 어노테이션이 됩니다. 개별 속성을 읽기 전용으로 표시하기 위해 클래스 수준 또는 \u003ccode\u003e__init__\u003c/code\u003e 내에서 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Book:\n    id: ReadOnly[int]\n    def __init__(self, id: int, name: str) -\u003e None:\n        self.id = id\n        self.name: ReadOnly[str] = name\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e타입 체커는 \u003ccode\u003eReadOnly\u003c/code\u003e로 어노테이션된 속성을 재할당하거나 삭제하려는 모든 시도에 대해 오류를 발생시켜야 합니다. 또한 \u003ccode\u003eFinal\u003c/code\u003e로 어노테이션된 속성을 삭제하려는 모든 시도에 대해서도 오류를 발생시켜야 합니다 (이는 현재 명세되어 있지 않습니다).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eReadOnly\u003c/code\u003e가 현재 의미가 없는 다른 위치(예: 지역/전역 변수 또는 함수 매개변수)의 어노테이션에 사용되는 것은 이 PEP의 범위를 벗어납니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eFinal\u003c/code\u003e과 유사하게, \u003ccode\u003eReadOnly\u003c/code\u003e는 타입 체커가 할당된 객체의 가변성(mutability)을 인식하는 방식에 영향을 미치지 않습니다. 불변(immutable) ABCs 및 컨테이너는 \u003ccode\u003eReadOnly\u003c/code\u003e와 함께 사용하여 타입 체커 수준에서 그러한 값의 변형을 금지할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom collections import abc\nfrom dataclasses import dataclass\nfrom typing import Protocol, ReadOnly\n\n@dataclass\nclass Game:\n    name: str\n\nclass HasGames[T: abc.Collection[Game]](Protocol):\n    games: ReadOnly[T]\n\ndef add_games(shelf: HasGames[list[Game]]) -\u003e None:\n    shelf.games.append(Game(\"Half-Life\")) # ok: list는 가변\n    shelf.games[-1].name = \"Black Mesa\" # ok: \"name\"은 읽기 전용이 아님\n    shelf.games = [] # error: \"games\"는 읽기 전용\n    del shelf.games # error: \"games\"는 읽기 전용이며 삭제할 수 없음\n\ndef read_games(shelf: HasGames[abc.Sequence[Game]]) -\u003e None:\n    shelf.games.append(...) # error: \"Sequence\"는 \"append\" 속성이 없음\n    shelf.games[0].name = \"Blue Shift\" # ok: \"name\"은 읽기 전용이 아님\n    shelf.games = [] # error: \"games\"는 읽기 전용\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e고정된 데이터클래스(\u003ccode\u003efrozen dataclasses\u003c/code\u003e) 및 \u003ccode\u003eNamedTuple\u003c/code\u003e의 모든 인스턴스 속성은 암묵적으로 읽기 전용이어야 합니다. 타입 체커는 이러한 속성에 \u003ccode\u003eReadOnly\u003c/code\u003e를 어노테이션하는 것이 중복임을 알릴 수 있지만, 오류로 간주되어서는 안 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom dataclasses import dataclass\nfrom typing import NewType, ReadOnly\n\n@dataclass(frozen=True)\nclass Point:\n    x: int # 암묵적 읽기 전용\n    y: ReadOnly[int] # ok, 중복\n\nuint = NewType(\"uint\", int)\n\n@dataclass(frozen=True)\nclass UnsignedPoint(Point):\n    x: ReadOnly[uint] # ok, 중복; 더 좁은 타입\n    y: Final[uint] # 중복 아님, Final은 추가적인 제약 조건 부과; 더 좁은 타입\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e초기화 (Initialization)\u003c/h3\u003e\n\u003cp\u003e읽기 전용 속성에 대한 할당은 속성을 선언하는 클래스 내에서만 발생할 수 있습니다. 속성이 몇 번 할당될 수 있는지에 대한 제한은 없습니다. 속성의 종류에 따라 다른 위치에서 할당될 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e인스턴스 속성 (Instance Attributes)\u003c/h4\u003e\n\u003cp\u003e인스턴스 속성에 대한 할당은 다음 컨텍스트에서 허용되어야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__init__\u003c/code\u003e에서, 첫 번째 매개변수로 받은 인스턴스(대개 \u003ccode\u003eself\u003c/code\u003e)에.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__new__\u003c/code\u003e에서, 상위 클래스의 \u003ccode\u003e__new__\u003c/code\u003e 메서드 호출을 통해 생성된 선언 클래스의 인스턴스에.\u003c/li\u003e\n\u003cli\u003e클래스 본문 내 선언 시.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한, 타입 체커는 다음 할당을 허용하도록 선택할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__new__\u003c/code\u003e에서, 인스턴스의 출처와 관계없이 선언 클래스의 인스턴스에. (이 선택은 인스턴스가 이미 초기화되었을 수 있으므로 견고함(soundness)을 구현의 단순성과 교환합니다.)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@classmethod\u003c/code\u003e에서, 클래스 또는 상위 클래스의 \u003ccode\u003e__new__\u003c/code\u003e 메서드 호출을 통해 생성된 선언 클래스의 인스턴스에.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom collections import abc\nfrom typing import ReadOnly\n\nclass Band:\n    name: str\n    songs: ReadOnly[list[str]]\n\n    def __init__(self, name: str, songs: abc.Iterable[str] | None = None) -\u003e None:\n        self.name = name\n        self.songs = []\n        if songs is not None:\n            self.songs = list(songs) # 여러 번 할당 가능\n\n    def clear(self) -\u003e None:\n        self.songs = [] # error: 초기화 외부에서 읽기 전용 \"songs\"에 할당\n\nband = Band(name=\"Bôa\", songs=[\"Duvet\"])\nband.name = \"Python\" # ok: \"name\"은 읽기 전용이 아님\nband.songs = [] # error: \"songs\"는 읽기 전용\nband.songs.append(\"Twilight\") # ok: list는 가변\n\nclass SubBand(Band):\n    def __init__(self) -\u003e None:\n        self.songs = [] # error: 기본 클래스의 읽기 전용 속성에 할당할 수 없음\n\n# 단순화된 불변 Fraction 클래스\nclass Fraction:\n    numerator: ReadOnly[int]\n    denominator: ReadOnly[int]\n\n    def __new__(\n        cls,\n        numerator: str | int | float | Decimal | Rational = 0,\n        denominator: int | Rational | None = None\n    ) -\u003e Self:\n        self = super().__new__(cls)\n        if denominator is None:\n            if type(numerator) is int:\n                self.numerator = numerator\n                self.denominator = 1\n            return self\n        elif isinstance(numerator, Rational):\n            ...\n        else:\n            ...\n\n    @classmethod\n    def from_float(cls, f: float, /) -\u003e Self:\n        self = super().__new__(cls)\n        self.numerator, self.denominator = f.as_integer_ratio()\n        return self\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e클래스 속성 (Class Attributes)\u003c/h4\u003e\n\u003cp\u003e읽기 전용 클래스 속성은 \u003ccode\u003eReadOnly\u003c/code\u003e와 \u003ccode\u003eClassVar\u003c/code\u003e 모두로 어노테이션된 속성입니다. 이러한 속성에 대한 할당은 다음 컨텍스트에서 허용되어야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e클래스 본문 내 선언 시.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__init_subclass__\u003c/code\u003e에서, 첫 번째 매개변수로 받은 클래스 객체(대개 \u003ccode\u003ecls\u003c/code\u003e)에.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass URI:\n    protocol: ReadOnly[ClassVar[str]] = \"\"\n\n    def __init_subclass__(cls, protocol: str = \"\") -\u003e None:\n        cls.protocol = protocol\n\nclass File(URI, protocol=\"file\"):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e클래스 수준 선언에 초기화 값이 있는 경우, 인스턴스를 위한 플라이웨이트(flyweight) 기본값으로 사용될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Patient:\n    number: ReadOnly[int] = 0\n\n    def __init__(self, number: int | None = None) -\u003e None:\n        if number is not None:\n            self.number = number\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고: 이 기능은 \u003ccode\u003e__slots__\u003c/code\u003e와 충돌합니다. 클래스 수준 값을 가진 속성은 슬롯(slots)에 포함될 수 없으며, 효과적으로 클래스 변수가 됩니다.\u003c/p\u003e\n\u003cp\u003e타입 체커는 인스턴스가 생성된 후 초기화되지 않은 상태로 남을 수 있는 읽기 전용 속성(스텁(stub), 프로토콜 또는 ABCs 제외)에 대해 경고하도록 선택할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Patient:\n    id: ReadOnly[int] # error: 모든 코드 경로에서 \"id\"가 초기화되지 않음\n    name: ReadOnly[str] # error: \"name\"이 전혀 초기화되지 않음\n    def __init__(self) -\u003e None:\n        if random.random() \u003e 0.5:\n            self.id = 123\n\nclass HasName(Protocol):\n    name: ReadOnly[str] # ok\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e서브타이핑 (Subtyping)\u003c/h3\u003e\n\u003cp\u003e읽기 전용 속성을 재할당할 수 없기 때문에 공변적(covariant)입니다. 이는 몇 가지 서브타이핑 함의를 가집니다. PEP 705에서 빌려온 내용입니다.\u003c/p\u003e\n\u003cp\u003e읽기 전용 속성은 쓰기 가능한 속성, 디스크립터 또는 클래스 변수로 재선언될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@dataclass\nclass HasTitle:\n    title: ReadOnly[str]\n\n@dataclass\nclass Game(HasTitle):\n    title: str\n    year: int\n\ngame = Game(title=\"DOOM\", year=1993)\ngame.year = 1994\ngame.title = \"DOOM II\" # ok: 속성이 읽기 전용이 아님\n\nclass TitleProxy(HasTitle):\n    @functools.cached_property\n    def title(self) -\u003e str:\n        ...\n\nclass SharedTitle(HasTitle):\n    title: ClassVar[str] = \"Still Grey\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e읽기 전용 속성이 재선언되지 않으면, 계속 읽기 전용으로 유지됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Game(HasTitle):\n    year: int\n    def __init__(self, title: str, year: int) -\u003e None:\n        super().__init__(title)\n        self.title = title # error: 기본 클래스의 읽기 전용 속성에 할당할 수 없음\n        self.year = year\n\ngame = Game(title=\"Robot Wants Kitty\", year=2010)\ngame.title = \"Robot Wants Puppy\" # error: \"title\"은 읽기 전용\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서브타입(subtype)은 읽기 전용 속성의 타입을 좁힐 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass GameCollection(Protocol):\n    games: ReadOnly[abc.Collection[Game]]\n\n@dataclass\nclass GameSeries(GameCollection):\n    name: str\n    games: ReadOnly[list[Game]] # ok: list[Game]은 Collection[Game]에 할당 가능\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프로토콜 및 ABCs의 명목적(nominal) 서브클래스는 기본 클래스가 어떤 방식으로든 초기화하지 않는 한, 구현하기 위해 읽기 전용 속성을 재선언해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass MyBase(abc.ABC):\n    foo: ReadOnly[int]\n    bar: ReadOnly[str] = \"abc\"\n    baz: ReadOnly[float]\n    def __init__(self, baz: float) -\u003e None:\n        self.baz = baz\n\n    @abstractmethod\n    def pprint(self) -\u003e None:\n        ...\n\n@final\nclass MySubclass(MyBase):\n    # error: MySubclass는 \"foo\"를 재정의하지 않음\n    def pprint(self) -\u003e None:\n        print(self.foo, self.bar, self.baz)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프로토콜 속성 선언에서 \u003ccode\u003ename: ReadOnly[T]\u003c/code\u003e는 구조적 서브타입이 \u003ccode\u003e.name\u003c/code\u003e 접근을 지원해야 하며, 반환된 값이 \u003ccode\u003eT\u003c/code\u003e에 할당 가능함을 나타냅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass HasName(Protocol):\n    name: ReadOnly[str]\n\nclass NamedAttr:\n    name: str\n\nclass NamedProp:\n    @property\n    def name(self) -\u003e str:\n        ...\n\nclass NamedClassVar:\n    name: ClassVar[str]\n\nclass NamedDescriptor:\n    @cached_property\n    def name(self) -\u003e str:\n        ...\n\n# 다음 모두 올바름\nhas_name: HasName\nhas_name = NamedAttr()\nhas_name = NamedProp()\nhas_name = NamedClassVar\nhas_name = NamedClassVar()\nhas_name = NamedDescriptor()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e다른 타입 한정자와의 상호작용 (Interaction with Other Type Qualifiers)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eReadOnly\u003c/code\u003e는 \u003ccode\u003eClassVar\u003c/code\u003e 및 \u003ccode\u003eAnnotated\u003c/code\u003e와 어떤 중첩 순서로든 사용될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Foo:\n    foo: ClassVar[ReadOnly[str]] = \"foo\"\n    bar: Annotated[ReadOnly[int], Gt(0)]\n\nclass Foo:\n    foo: ReadOnly[ClassVar[str]] = \"foo\"\n    bar: ReadOnly[Annotated[int, Gt(0)]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 PEP 705에서 정의된 \u003ccode\u003eReadOnly\u003c/code\u003e와 \u003ccode\u003etyping.TypedDict\u003c/code\u003e의 상호작용과 일치합니다.\u003c/p\u003e\n\u003cp\u003e속성은 \u003ccode\u003eReadOnly\u003c/code\u003e와 \u003ccode\u003eFinal\u003c/code\u003e로 동시에 어노테이션될 수 없습니다. 두 한정자는 의미가 다르며, \u003ccode\u003eFinal\u003c/code\u003e이 일반적으로 더 제한적입니다. \u003ccode\u003eFinal\u003c/code\u003e은 읽기 전용으로만 암시되는 속성의 어노테이션으로는 계속 허용됩니다. 또한 기본 클래스의 \u003ccode\u003eReadOnly\u003c/code\u003e 속성을 재선언하는 데 사용될 수도 있습니다.\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003eReadOnly\u003c/code\u003e가 유효한 새로운 컨텍스트를 도입합니다. 해당 위치를 검사하는 프로그램은 이를 지원하기 위해 변경되어야 합니다. 이는 주로 타입 체커에 영향을 미칠 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e그러나 이전 버전의 Python에서 백포트(backported)된 \u003ccode\u003etyping_extensions.ReadOnly\u003c/code\u003e를 사용할 때는 주의가 필요합니다. 어노테이션을 검사하는 메커니즘이 \u003ccode\u003eReadOnly\u003c/code\u003e를 만났을 때 잘못 동작할 수 있으며, 특히 \u003ccode\u003eClassVar\u003c/code\u003e를 찾는 \u003ccode\u003e@dataclass\u003c/code\u003e 데코레이터는 \u003ccode\u003eReadOnly[ClassVar[...]]\u003c/code\u003e를 인스턴스 속성으로 오인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e인트로스펙션(introspection) 문제를 피하려면 \u003ccode\u003eReadOnly[ClassVar[...]]\u003c/code\u003e 대신 \u003ccode\u003eClassVar[ReadOnly[...]]\u003c/code\u003e를 사용하세요.\u003c/p\u003e\n\u003ch2\u003e보안 고려사항 (Security Implications)\u003c/h2\u003e\n\u003cp\u003e이 PEP로 인해 발생하는 알려진 보안 문제는 없습니다.\u003c/p\u003e\n\u003ch2\u003e교육 방법 (How to Teach This)\u003c/h2\u003e\n\u003cp\u003ePEP 705의 지침에 따라 \u003ccode\u003etyping\u003c/code\u003e 모듈 문서에 제안된 변경 사항:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e이 PEP를 다른 나열된 PEP에 추가합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003etyping.ReadOnly\u003c/code\u003e를 이 PEP에 연결합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003etyping.ReadOnly\u003c/code\u003e의 설명을 업데이트합니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e클래스의 속성 또는 \u003ccode\u003eTypedDict\u003c/code\u003e의 항목을 읽기 전용으로 표시하는 특별한 타입 구조입니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e타입 한정자 섹션 아래에 \u003ccode\u003eReadOnly\u003c/code\u003e에 대한 독립적인 항목을 추가합니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e클래스 속성 어노테이션의 \u003ccode\u003eReadOnly\u003c/code\u003e 타입 한정자는 클래스의 속성을 읽을 수는 있지만, 재할당하거나 삭제할 수 없음을 나타냅니다. \u003ccode\u003eTypedDict\u003c/code\u003e에서의 사용은 \u003ccode\u003eReadOnly\u003c/code\u003e를 참조하십시오.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e거부된 아이디어 (Rejected Ideas)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003e@property\u003c/code\u003e와 프로토콜의 상호작용 명확화 (Clarifying Interaction of @property and Protocols)\u003c/h3\u003e\n\u003cp\u003e\"프로토콜\" 섹션에서는 프로토콜 내 속성의 해석에 있어 타입 체커 간의 불일치가 언급됩니다. 이 문제는 타입 명세를 수정하여 이러한 속성의 읽기 전용 특성을 구현하는 것이 무엇인지 명확히 함으로써 해결될 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 프로토콜에서 읽기 전용 속성을 정의하는 더 나은 대안으로 \u003ccode\u003eReadOnly\u003c/code\u003e를 만들고, 이 목적으로 속성을 사용하는 것을 대체합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003e__init__\u003c/code\u003e 및 클래스 본문 내에서만 할당 (Assignment Only in \u003ccode\u003e__init__\u003c/code\u003e and Class Body)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 초기 버전에서는 읽기 전용 속성이 \u003ccode\u003e__init__\u003c/code\u003e 및 클래스 본문 내에서만 할당될 수 있다고 제안했습니다. 이후 논의를 통해 이 제한이 일반적으로 \u003ccode\u003e__init__\u003c/code\u003e을 정의하지 않는 불변 클래스(immutable classes) 내에서 \u003ccode\u003eReadOnly\u003c/code\u003e의 유용성을 심각하게 제한할 것이라는 점이 밝혀졌습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efractions.Fraction\u003c/code\u003e은 불변 클래스의 한 예로, 속성 초기화가 \u003ccode\u003e__new__\u003c/code\u003e 및 클래스 메서드 내에서 발생합니다. 그러나 \u003ccode\u003e__init__\u003c/code\u003e과 달리, \u003ccode\u003e__new__\u003c/code\u003e 및 클래스 메서드 내에서의 할당은 인스턴스가 이미 최종화된 인스턴스를 포함하여 임의의 위치에서 소스될 수 있으므로 잠재적으로 불건전(unsound)합니다.\u003c/p\u003e\n\u003cp\u003e이 타입 검사 기능이 읽기 전용 속성의 가장 중요한 사용처인 불변 클래스에 유용해야 한다고 생각합니다. 따라서 PEP는 초기화 섹션에 설명된 일련의 규칙에 따라 \u003ccode\u003e__new__\u003c/code\u003e 및 클래스 메서드에서 할당을 허용하도록 변경되었습니다.\u003c/p\u003e\n\u003ch2\u003e미해결 문제 (Open Issues)\u003c/h2\u003e\n\u003ch3\u003e초기화 확장 (Extending Initialization)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edataclasses.__post_init__()\u003c/code\u003e 또는 \u003ccode\u003eattrs\u003c/code\u003e의 초기화 훅(hook)과 같은 메커니즘은 초기화 중에 호출되는 특별한 훅 세트를 제공하여 객체 생성을 보강합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP에 정의된 현재 초기화 규칙은 이러한 메서드에서 읽기 전용 속성에 대한 할당을 허용하지 않습니다. 이러한 3rd-party 훅을 포함하면서 해당 속성의 읽기 전용 특성과 관련된 불변성을 유지하는 방식으로 규칙을 만족스럽게 만들 수 있는지 여부는 불분명합니다.\u003c/p\u003e\n\u003cp\u003ePython 타입 시스템은 \u003ccode\u003e__new__\u003c/code\u003e 및 \u003ccode\u003e__init__\u003c/code\u003e의 동작에 대해 길고 상세한 명세를 가지고 있습니다. 3rd-party 훅에서 동일한 수준의 세부 정보를 기대하는 것은 다소 비현실적입니다.\u003c/p\u003e\n\u003cp\u003e잠재적인 해결책은 타입 체커가 이와 관련하여 구성을 제공하여 최종 사용자가 초기화를 허용하려는 메서드 세트를 수동으로 지정하도록 요구하는 것입니다. 그러나 이는 사용자가 앞서 언급한 불변성을 실수로 또는 의도적으로 위반할 수 있습니다. 또한 상대적으로 틈새(niche) 기능에 대한 상당히 큰 요구 사항입니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Draft] PEP 767 - Annotating Read-Only Attributes\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 13:49:33+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>