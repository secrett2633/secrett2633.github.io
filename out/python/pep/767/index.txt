3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-1a135130af3e1cae.js","185","static/chunks/app/layout-c3e2e457f12fb6f6.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js"],""]
4:["slug","python/pep/767","c"]
0:["8N6icDw00Cy0kKVlExSq2",[[["",{"children":[["slug","python/pep/767","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"767\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/767","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e975486d410ad4e9.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T60f9,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0767/">PEP 767 - Annotating Read-Only Attributes</a></p>
<p><strong>상태:</strong> Draft | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 18-Nov-2024</p>
</blockquote>
<hr>
<h1>PEP 767: 읽기 전용 속성 어노테이션</h1>
<h2>초록 (Abstract)</h2>
<p>PEP 705에서 <code>typing.ReadOnly</code> 타입 한정자(type qualifier)를 도입하여 <code>typing.TypedDict</code> 항목을 읽기 전용으로 정의할 수 있게 했습니다.</p>
<p>이 PEP는 클래스와 프로토콜(protocol) 속성 어노테이션(annotation)에서 <code>ReadOnly</code>를 사용하여 속성을 읽기 전용으로 표시하는 간결한 방법을 제안합니다.</p>
<p>PEP 705와 마찬가지로, 이 제안은 런타임(runtime)에 속성을 설정하는 방식에는 변경을 가하지 않습니다. 읽기 전용 속성의 올바른 사용은 오직 정적 타입 체커(static type checker)에 의해서만 강제됩니다.</p>
<h2>동기 (Motivation)</h2>
<p>Python 타입 시스템(type system)에는 속성을 읽기 전용으로 표시하는 단일하고 간결한 방법이 부족합니다. 이 기능은 C# 또는 TypeScript와 같은 다른 정적 및 점진적 타입 언어에 존재하며, 타입 체커 수준에서 속성을 재할당(reassign)하거나 삭제(delete)하는 기능을 제거하고, 구조적 서브타이핑(structural subtyping)을 위한 광범위한 인터페이스를 정의하는 데 유용합니다.</p>
<h3>클래스 (Classes)</h3>
<p>오늘날, 타입 체커들이 인정하는 읽기 전용 속성을 달성하는 세 가지 주요 방법이 있습니다.</p>
<ol>
<li>
<p><strong>속성에 <code>typing.Final</code> 어노테이션 달기:</strong></p>
<pre><code class="language-python">class Foo:
    number: Final[int]
    def __init__(self, number: int) -> None:
        self.number = number

class Bar:
    def __init__(self, number: int) -> None:
        self.number: Final = number
</code></pre>
<p><code>dataclasses</code>에서 지원되며, <code>typing#1669</code> 이후 타입 체커에서도 지원됩니다. <code>Final</code>의 명세에 따라 하위 클래스에서 <code>number</code>를 재정의할 수 없습니다.</p>
</li>
<li>
<p><strong><code>@property</code>를 통한 읽기 전용 프록시(proxy):</strong></p>
<pre><code class="language-python">class Foo:
    _number: int
    def __init__(self, number: int) -> None:
        self._number = number

    @property
    def number(self) -> int:
        return self._number
</code></pre>
<p><code>number</code>를 재정의하는 것이 가능합니다. 타입 체커마다 특정 규칙에 대한 의견이 다릅니다. 런타임에는 읽기 전용이지만, 추가적인 보일러플레이트(boilerplate) 코드가 필요합니다. <code>dataclasses</code>에서 지원되지만, 합성(compose)이 잘 되지 않습니다. 합성된 <code>__init__</code> 및 <code>__repr__</code>은 <code>_number</code>를 매개변수/속성 이름으로 사용합니다.</p>
</li>
<li>
<p><strong><code>dataclasses.dataclass(frozen=True)</code> 또는 <code>typing.NamedTuple</code>과 같은 "고정(freezing)" 메커니즘 사용:</strong></p>
<pre><code class="language-python">@dataclass(frozen=True)
class Foo:
    number: int # 암묵적으로 읽기 전용

class Bar(NamedTuple):
    number: int # 암묵적으로 읽기 전용
</code></pre>
<p><code>@dataclass</code>의 경우 <code>number</code>를 재정의하는 것이 가능합니다. 런타임에는 읽기 전용입니다. 속성별 제어가 불가능하며, 이 메커니즘은 전체 클래스에 적용됩니다. 고정된 데이터클래스(frozen dataclasses)는 약간의 런타임 오버헤드를 발생시킵니다. <code>NamedTuple</code>은 여전히 튜플(tuple)이며, 대부분의 클래스는 인덱싱(indexing), 이터레이션(iteration) 또는 연결(concatenation)을 상속할 필요가 없습니다.</p>
</li>
</ol>
<h3>프로토콜 (Protocols)</h3>
<p><code>name: T</code>라는 멤버를 정의하는 <code>Protocol</code>을 가정해봅시다. 이는 두 가지 요구사항을 정의합니다.</p>
<ul>
<li><code>hasattr(obj, "name")</code></li>
<li><code>isinstance(obj.name, T)</code></li>
</ul>
<p>이러한 요구사항은 런타임에 다음 모두에 의해 충족될 수 있습니다.</p>
<ul>
<li>속성 <code>name: T</code>를 가진 객체</li>
<li>클래스 변수 <code>name: ClassVar[T]</code>를 가진 클래스</li>
<li>위 클래스의 인스턴스</li>
<li><code>@property def name(self) -> T</code>를 가진 객체</li>
<li><code>functools.cached_property()</code>와 같은 사용자 정의 디스크립터(descriptor)를 가진 객체</li>
</ul>
<p>현재 타입 명세(typing spec)는 (추상) 속성을 사용하여 이러한 프로토콜 멤버를 생성하는 것을 허용합니다.</p>
<pre><code class="language-python">class HasName(Protocol):
    @property
    def name(self) -> T:
        ...
</code></pre>
<p>이 문법은 몇 가지 단점이 있습니다.</p>
<ul>
<li>다소 장황합니다.</li>
<li>여기서 전달되는 품질이 속성의 읽기 전용 특성이라는 것이 명확하지 않습니다.</li>
<li>타입 한정자와 합성될 수 없습니다.</li>
<li>모든 타입 체커가 위의 다섯 가지 객체 모두가 이 구조적 타입에 할당될 수 있다는 것에 동의하지 않습니다.</li>
</ul>
<h2>근거 (Rationale)</h2>
<p>이러한 문제들은 속성 수준의 타입 한정자로 해결될 수 있습니다. <code>ReadOnly</code>가 이 역할을 위해 선택되었는데, 그 이름이 의도를 잘 전달하고, 새로 제안된 변경 사항이 PEP 705에서 정의된 의미를 보완하기 때문입니다.</p>
<p>읽기 전용 인스턴스 속성을 가진 클래스는 이제 다음과 같이 정의할 수 있습니다.</p>
<pre><code class="language-python">from typing import ReadOnly

class Member:
    def __init__(self, id: int) -> None:
        self.id: ReadOnly[int] = id
</code></pre>
<p>그리고 "프로토콜" 섹션에서 설명한 프로토콜은 이제 다음과 같습니다.</p>
<pre><code class="language-python">from typing import Protocol, ReadOnly

class HasName(Protocol):
    name: ReadOnly[str]

def greet(obj: HasName, /) -> str:
    return f"Hello, {obj.name}!"
</code></pre>
<p><code>Member</code>의 서브클래스(subclass)는 <code>.id</code>를 쓰기 가능한 속성이나 디스크립터로 재정의할 수 있습니다. 또한 타입을 좁힐(narrow) 수도 있습니다. <code>HasName</code> 프로토콜은 더 간결한 정의를 가지며, 속성의 쓰기 가능성(writability)에 구애받지 않습니다. <code>greet</code> 함수는 이제 다양한 호환 가능한 객체를 허용하면서, 입력에 대한 수정이 이루어지지 않음을 명시할 수 있습니다.</p>
<h2>명세 (Specification)</h2>
<p><code>typing.ReadOnly</code> 타입 한정자는 클래스 및 프로토콜의 속성에 대한 유효한 어노테이션이 됩니다. 개별 속성을 읽기 전용으로 표시하기 위해 클래스 수준 또는 <code>__init__</code> 내에서 사용할 수 있습니다.</p>
<pre><code class="language-python">class Book:
    id: ReadOnly[int]
    def __init__(self, id: int, name: str) -> None:
        self.id = id
        self.name: ReadOnly[str] = name
</code></pre>
<p>타입 체커는 <code>ReadOnly</code>로 어노테이션된 속성을 재할당하거나 삭제하려는 모든 시도에 대해 오류를 발생시켜야 합니다. 또한 <code>Final</code>로 어노테이션된 속성을 삭제하려는 모든 시도에 대해서도 오류를 발생시켜야 합니다 (이는 현재 명세되어 있지 않습니다).</p>
<p><code>ReadOnly</code>가 현재 의미가 없는 다른 위치(예: 지역/전역 변수 또는 함수 매개변수)의 어노테이션에 사용되는 것은 이 PEP의 범위를 벗어납니다.</p>
<p><code>Final</code>과 유사하게, <code>ReadOnly</code>는 타입 체커가 할당된 객체의 가변성(mutability)을 인식하는 방식에 영향을 미치지 않습니다. 불변(immutable) ABCs 및 컨테이너는 <code>ReadOnly</code>와 함께 사용하여 타입 체커 수준에서 그러한 값의 변형을 금지할 수 있습니다.</p>
<pre><code class="language-python">from collections import abc
from dataclasses import dataclass
from typing import Protocol, ReadOnly

@dataclass
class Game:
    name: str

class HasGames[T: abc.Collection[Game]](Protocol):
    games: ReadOnly[T]

def add_games(shelf: HasGames[list[Game]]) -> None:
    shelf.games.append(Game("Half-Life")) # ok: list는 가변
    shelf.games[-1].name = "Black Mesa" # ok: "name"은 읽기 전용이 아님
    shelf.games = [] # error: "games"는 읽기 전용
    del shelf.games # error: "games"는 읽기 전용이며 삭제할 수 없음

def read_games(shelf: HasGames[abc.Sequence[Game]]) -> None:
    shelf.games.append(...) # error: "Sequence"는 "append" 속성이 없음
    shelf.games[0].name = "Blue Shift" # ok: "name"은 읽기 전용이 아님
    shelf.games = [] # error: "games"는 읽기 전용
</code></pre>
<p>고정된 데이터클래스(<code>frozen dataclasses</code>) 및 <code>NamedTuple</code>의 모든 인스턴스 속성은 암묵적으로 읽기 전용이어야 합니다. 타입 체커는 이러한 속성에 <code>ReadOnly</code>를 어노테이션하는 것이 중복임을 알릴 수 있지만, 오류로 간주되어서는 안 됩니다.</p>
<pre><code class="language-python">from dataclasses import dataclass
from typing import NewType, ReadOnly

@dataclass(frozen=True)
class Point:
    x: int # 암묵적 읽기 전용
    y: ReadOnly[int] # ok, 중복

uint = NewType("uint", int)

@dataclass(frozen=True)
class UnsignedPoint(Point):
    x: ReadOnly[uint] # ok, 중복; 더 좁은 타입
    y: Final[uint] # 중복 아님, Final은 추가적인 제약 조건 부과; 더 좁은 타입
</code></pre>
<h3>초기화 (Initialization)</h3>
<p>읽기 전용 속성에 대한 할당은 속성을 선언하는 클래스 내에서만 발생할 수 있습니다. 속성이 몇 번 할당될 수 있는지에 대한 제한은 없습니다. 속성의 종류에 따라 다른 위치에서 할당될 수 있습니다.</p>
<h4>인스턴스 속성 (Instance Attributes)</h4>
<p>인스턴스 속성에 대한 할당은 다음 컨텍스트에서 허용되어야 합니다.</p>
<ul>
<li><code>__init__</code>에서, 첫 번째 매개변수로 받은 인스턴스(대개 <code>self</code>)에.</li>
<li><code>__new__</code>에서, 상위 클래스의 <code>__new__</code> 메서드 호출을 통해 생성된 선언 클래스의 인스턴스에.</li>
<li>클래스 본문 내 선언 시.</li>
</ul>
<p>또한, 타입 체커는 다음 할당을 허용하도록 선택할 수 있습니다.</p>
<ul>
<li><code>__new__</code>에서, 인스턴스의 출처와 관계없이 선언 클래스의 인스턴스에. (이 선택은 인스턴스가 이미 초기화되었을 수 있으므로 견고함(soundness)을 구현의 단순성과 교환합니다.)</li>
<li><code>@classmethod</code>에서, 클래스 또는 상위 클래스의 <code>__new__</code> 메서드 호출을 통해 생성된 선언 클래스의 인스턴스에.</li>
</ul>
<pre><code class="language-python">from collections import abc
from typing import ReadOnly

class Band:
    name: str
    songs: ReadOnly[list[str]]

    def __init__(self, name: str, songs: abc.Iterable[str] | None = None) -> None:
        self.name = name
        self.songs = []
        if songs is not None:
            self.songs = list(songs) # 여러 번 할당 가능

    def clear(self) -> None:
        self.songs = [] # error: 초기화 외부에서 읽기 전용 "songs"에 할당

band = Band(name="Bôa", songs=["Duvet"])
band.name = "Python" # ok: "name"은 읽기 전용이 아님
band.songs = [] # error: "songs"는 읽기 전용
band.songs.append("Twilight") # ok: list는 가변

class SubBand(Band):
    def __init__(self) -> None:
        self.songs = [] # error: 기본 클래스의 읽기 전용 속성에 할당할 수 없음

# 단순화된 불변 Fraction 클래스
class Fraction:
    numerator: ReadOnly[int]
    denominator: ReadOnly[int]

    def __new__(
        cls,
        numerator: str | int | float | Decimal | Rational = 0,
        denominator: int | Rational | None = None
    ) -> Self:
        self = super().__new__(cls)
        if denominator is None:
            if type(numerator) is int:
                self.numerator = numerator
                self.denominator = 1
            return self
        elif isinstance(numerator, Rational):
            ...
        else:
            ...

    @classmethod
    def from_float(cls, f: float, /) -> Self:
        self = super().__new__(cls)
        self.numerator, self.denominator = f.as_integer_ratio()
        return self
</code></pre>
<h4>클래스 속성 (Class Attributes)</h4>
<p>읽기 전용 클래스 속성은 <code>ReadOnly</code>와 <code>ClassVar</code> 모두로 어노테이션된 속성입니다. 이러한 속성에 대한 할당은 다음 컨텍스트에서 허용되어야 합니다.</p>
<ul>
<li>클래스 본문 내 선언 시.</li>
<li><code>__init_subclass__</code>에서, 첫 번째 매개변수로 받은 클래스 객체(대개 <code>cls</code>)에.</li>
</ul>
<pre><code class="language-python">class URI:
    protocol: ReadOnly[ClassVar[str]] = ""

    def __init_subclass__(cls, protocol: str = "") -> None:
        cls.protocol = protocol

class File(URI, protocol="file"):
    ...
</code></pre>
<p>클래스 수준 선언에 초기화 값이 있는 경우, 인스턴스를 위한 플라이웨이트(flyweight) 기본값으로 사용될 수 있습니다.</p>
<pre><code class="language-python">class Patient:
    number: ReadOnly[int] = 0

    def __init__(self, number: int | None = None) -> None:
        if number is not None:
            self.number = number
</code></pre>
<p>참고: 이 기능은 <code>__slots__</code>와 충돌합니다. 클래스 수준 값을 가진 속성은 슬롯(slots)에 포함될 수 없으며, 효과적으로 클래스 변수가 됩니다.</p>
<p>타입 체커는 인스턴스가 생성된 후 초기화되지 않은 상태로 남을 수 있는 읽기 전용 속성(스텁(stub), 프로토콜 또는 ABCs 제외)에 대해 경고하도록 선택할 수 있습니다.</p>
<pre><code class="language-python">class Patient:
    id: ReadOnly[int] # error: 모든 코드 경로에서 "id"가 초기화되지 않음
    name: ReadOnly[str] # error: "name"이 전혀 초기화되지 않음
    def __init__(self) -> None:
        if random.random() > 0.5:
            self.id = 123

class HasName(Protocol):
    name: ReadOnly[str] # ok
</code></pre>
<h3>서브타이핑 (Subtyping)</h3>
<p>읽기 전용 속성을 재할당할 수 없기 때문에 공변적(covariant)입니다. 이는 몇 가지 서브타이핑 함의를 가집니다. PEP 705에서 빌려온 내용입니다.</p>
<p>읽기 전용 속성은 쓰기 가능한 속성, 디스크립터 또는 클래스 변수로 재선언될 수 있습니다.</p>
<pre><code class="language-python">@dataclass
class HasTitle:
    title: ReadOnly[str]

@dataclass
class Game(HasTitle):
    title: str
    year: int

game = Game(title="DOOM", year=1993)
game.year = 1994
game.title = "DOOM II" # ok: 속성이 읽기 전용이 아님

class TitleProxy(HasTitle):
    @functools.cached_property
    def title(self) -> str:
        ...

class SharedTitle(HasTitle):
    title: ClassVar[str] = "Still Grey"
</code></pre>
<p>읽기 전용 속성이 재선언되지 않으면, 계속 읽기 전용으로 유지됩니다.</p>
<pre><code class="language-python">class Game(HasTitle):
    year: int
    def __init__(self, title: str, year: int) -> None:
        super().__init__(title)
        self.title = title # error: 기본 클래스의 읽기 전용 속성에 할당할 수 없음
        self.year = year

game = Game(title="Robot Wants Kitty", year=2010)
game.title = "Robot Wants Puppy" # error: "title"은 읽기 전용
</code></pre>
<p>서브타입(subtype)은 읽기 전용 속성의 타입을 좁힐 수 있습니다.</p>
<pre><code class="language-python">class GameCollection(Protocol):
    games: ReadOnly[abc.Collection[Game]]

@dataclass
class GameSeries(GameCollection):
    name: str
    games: ReadOnly[list[Game]] # ok: list[Game]은 Collection[Game]에 할당 가능
</code></pre>
<p>프로토콜 및 ABCs의 명목적(nominal) 서브클래스는 기본 클래스가 어떤 방식으로든 초기화하지 않는 한, 구현하기 위해 읽기 전용 속성을 재선언해야 합니다.</p>
<pre><code class="language-python">class MyBase(abc.ABC):
    foo: ReadOnly[int]
    bar: ReadOnly[str] = "abc"
    baz: ReadOnly[float]
    def __init__(self, baz: float) -> None:
        self.baz = baz

    @abstractmethod
    def pprint(self) -> None:
        ...

@final
class MySubclass(MyBase):
    # error: MySubclass는 "foo"를 재정의하지 않음
    def pprint(self) -> None:
        print(self.foo, self.bar, self.baz)
</code></pre>
<p>프로토콜 속성 선언에서 <code>name: ReadOnly[T]</code>는 구조적 서브타입이 <code>.name</code> 접근을 지원해야 하며, 반환된 값이 <code>T</code>에 할당 가능함을 나타냅니다.</p>
<pre><code class="language-python">class HasName(Protocol):
    name: ReadOnly[str]

class NamedAttr:
    name: str

class NamedProp:
    @property
    def name(self) -> str:
        ...

class NamedClassVar:
    name: ClassVar[str]

class NamedDescriptor:
    @cached_property
    def name(self) -> str:
        ...

# 다음 모두 올바름
has_name: HasName
has_name = NamedAttr()
has_name = NamedProp()
has_name = NamedClassVar
has_name = NamedClassVar()
has_name = NamedDescriptor()
</code></pre>
<h3>다른 타입 한정자와의 상호작용 (Interaction with Other Type Qualifiers)</h3>
<p><code>ReadOnly</code>는 <code>ClassVar</code> 및 <code>Annotated</code>와 어떤 중첩 순서로든 사용될 수 있습니다.</p>
<pre><code class="language-python">class Foo:
    foo: ClassVar[ReadOnly[str]] = "foo"
    bar: Annotated[ReadOnly[int], Gt(0)]

class Foo:
    foo: ReadOnly[ClassVar[str]] = "foo"
    bar: ReadOnly[Annotated[int, Gt(0)]]
</code></pre>
<p>이는 PEP 705에서 정의된 <code>ReadOnly</code>와 <code>typing.TypedDict</code>의 상호작용과 일치합니다.</p>
<p>속성은 <code>ReadOnly</code>와 <code>Final</code>로 동시에 어노테이션될 수 없습니다. 두 한정자는 의미가 다르며, <code>Final</code>이 일반적으로 더 제한적입니다. <code>Final</code>은 읽기 전용으로만 암시되는 속성의 어노테이션으로는 계속 허용됩니다. 또한 기본 클래스의 <code>ReadOnly</code> 속성을 재선언하는 데 사용될 수도 있습니다.</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>이 PEP는 <code>ReadOnly</code>가 유효한 새로운 컨텍스트를 도입합니다. 해당 위치를 검사하는 프로그램은 이를 지원하기 위해 변경되어야 합니다. 이는 주로 타입 체커에 영향을 미칠 것으로 예상됩니다.</p>
<p>그러나 이전 버전의 Python에서 백포트(backported)된 <code>typing_extensions.ReadOnly</code>를 사용할 때는 주의가 필요합니다. 어노테이션을 검사하는 메커니즘이 <code>ReadOnly</code>를 만났을 때 잘못 동작할 수 있으며, 특히 <code>ClassVar</code>를 찾는 <code>@dataclass</code> 데코레이터는 <code>ReadOnly[ClassVar[...]]</code>를 인스턴스 속성으로 오인할 수 있습니다.</p>
<p>인트로스펙션(introspection) 문제를 피하려면 <code>ReadOnly[ClassVar[...]]</code> 대신 <code>ClassVar[ReadOnly[...]]</code>를 사용하세요.</p>
<h2>보안 고려사항 (Security Implications)</h2>
<p>이 PEP로 인해 발생하는 알려진 보안 문제는 없습니다.</p>
<h2>교육 방법 (How to Teach This)</h2>
<p>PEP 705의 지침에 따라 <code>typing</code> 모듈 문서에 제안된 변경 사항:</p>
<ul>
<li>
<p>이 PEP를 다른 나열된 PEP에 추가합니다.</p>
</li>
<li>
<p><code>typing.ReadOnly</code>를 이 PEP에 연결합니다.</p>
</li>
<li>
<p><code>typing.ReadOnly</code>의 설명을 업데이트합니다.</p>
<blockquote>
<p>클래스의 속성 또는 <code>TypedDict</code>의 항목을 읽기 전용으로 표시하는 특별한 타입 구조입니다.</p>
</blockquote>
</li>
<li>
<p>타입 한정자 섹션 아래에 <code>ReadOnly</code>에 대한 독립적인 항목을 추가합니다.</p>
<blockquote>
<p>클래스 속성 어노테이션의 <code>ReadOnly</code> 타입 한정자는 클래스의 속성을 읽을 수는 있지만, 재할당하거나 삭제할 수 없음을 나타냅니다. <code>TypedDict</code>에서의 사용은 <code>ReadOnly</code>를 참조하십시오.</p>
</blockquote>
</li>
</ul>
<h2>거부된 아이디어 (Rejected Ideas)</h2>
<h3><code>@property</code>와 프로토콜의 상호작용 명확화 (Clarifying Interaction of @property and Protocols)</h3>
<p>"프로토콜" 섹션에서는 프로토콜 내 속성의 해석에 있어 타입 체커 간의 불일치가 언급됩니다. 이 문제는 타입 명세를 수정하여 이러한 속성의 읽기 전용 특성을 구현하는 것이 무엇인지 명확히 함으로써 해결될 수 있었습니다.</p>
<p>이 PEP는 프로토콜에서 읽기 전용 속성을 정의하는 더 나은 대안으로 <code>ReadOnly</code>를 만들고, 이 목적으로 속성을 사용하는 것을 대체합니다.</p>
<h3><code>__init__</code> 및 클래스 본문 내에서만 할당 (Assignment Only in <code>__init__</code> and Class Body)</h3>
<p>이 PEP의 초기 버전에서는 읽기 전용 속성이 <code>__init__</code> 및 클래스 본문 내에서만 할당될 수 있다고 제안했습니다. 이후 논의를 통해 이 제한이 일반적으로 <code>__init__</code>을 정의하지 않는 불변 클래스(immutable classes) 내에서 <code>ReadOnly</code>의 유용성을 심각하게 제한할 것이라는 점이 밝혀졌습니다.</p>
<p><code>fractions.Fraction</code>은 불변 클래스의 한 예로, 속성 초기화가 <code>__new__</code> 및 클래스 메서드 내에서 발생합니다. 그러나 <code>__init__</code>과 달리, <code>__new__</code> 및 클래스 메서드 내에서의 할당은 인스턴스가 이미 최종화된 인스턴스를 포함하여 임의의 위치에서 소스될 수 있으므로 잠재적으로 불건전(unsound)합니다.</p>
<p>이 타입 검사 기능이 읽기 전용 속성의 가장 중요한 사용처인 불변 클래스에 유용해야 한다고 생각합니다. 따라서 PEP는 초기화 섹션에 설명된 일련의 규칙에 따라 <code>__new__</code> 및 클래스 메서드에서 할당을 허용하도록 변경되었습니다.</p>
<h2>미해결 문제 (Open Issues)</h2>
<h3>초기화 확장 (Extending Initialization)</h3>
<p><code>dataclasses.__post_init__()</code> 또는 <code>attrs</code>의 초기화 훅(hook)과 같은 메커니즘은 초기화 중에 호출되는 특별한 훅 세트를 제공하여 객체 생성을 보강합니다.</p>
<p>이 PEP에 정의된 현재 초기화 규칙은 이러한 메서드에서 읽기 전용 속성에 대한 할당을 허용하지 않습니다. 이러한 3rd-party 훅을 포함하면서 해당 속성의 읽기 전용 특성과 관련된 불변성을 유지하는 방식으로 규칙을 만족스럽게 만들 수 있는지 여부는 불분명합니다.</p>
<p>Python 타입 시스템은 <code>__new__</code> 및 <code>__init__</code>의 동작에 대해 길고 상세한 명세를 가지고 있습니다. 3rd-party 훅에서 동일한 수준의 세부 정보를 기대하는 것은 다소 비현실적입니다.</p>
<p>잠재적인 해결책은 타입 체커가 이와 관련하여 구성을 제공하여 최종 사용자가 초기화를 허용하려는 메서드 세트를 수동으로 지정하도록 요구하는 것입니다. 그러나 이는 사용자가 앞서 언급한 불변성을 실수로 또는 의도적으로 위반할 수 있습니다. 또한 상대적으로 틈새(niche) 기능에 대한 상당히 큰 요구 사항입니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1318,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Draft] PEP 767 - Annotating Read-Only Attributes"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-27 13:49:33+0900","children":"2025년 9월 27일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 27일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}]]
1:null
