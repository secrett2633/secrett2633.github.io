<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d6cea809dcbae606.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-0395f68b8cc78a20.js" async=""></script><script src="/_next/static/chunks/23-706b53707bbf0661.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-467e37449c5a68fc.js" async=""></script><script src="/_next/static/chunks/app/layout-0948ad04ab71c381.js" async=""></script><script src="/_next/static/chunks/app/page-90c91ef098171651.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2457<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 660 - Editable installs for pyproject.toml based builds (wheel based)</h1><div class="page__meta"><time dateTime="2025-09-27 09:55:28+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0660/">PEP 660 - Editable installs for pyproject.toml based builds (wheel based)</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 30-Mar-2021</p>
</blockquote>
<h1>PEP 660 – <code>pyproject.toml</code> 기반 빌드를 위한 편집 가능(Editable) 설치 (휠 기반)</h1>
<h2>초록 (Abstract)</h2>
<p>이 문서는 패키지를 편집 가능(editable) 모드로 설치하기 위한 <a href="https://peps.python.org/pep-0517/">PEP 517</a> 스타일의 메서드를 설명합니다.</p>
<h2>동기 (Motivation)</h2>
<p>Python 개발자들은 소스 저장소의 체크아웃(checkout)에서 작업하는 방식 등으로, 패키지를 <code>site-packages</code>에 설치(즉, 복사)할 필요 없이 개발할 수 있기를 원합니다.</p>
<p>이러한 방식은 관련 소스 디렉토리를 <code>PYTHONPATH</code>에 추가함으로써 가능하지만, <code>setuptools</code>는 이 과정을 더 쉽게 만들어주는 <code>setup.py develop</code> 메커니즘을 제공하며, 의존성 및 콘솔 스크립트와 같은 진입점(entry points)도 설치합니다. <code>pip</code>은 <code>pip install --editable</code> 옵션을 통해 이 메커니즘을 노출합니다.</p>
<p>가져와서(import) 사용되는 Python 코드가 소스 디렉토리에 남아 있도록 프로젝트를 설치하는 방식을 "편집 가능 설치(editable installation mode)"라고 합니다.</p>
<p>이제 <a href="https://peps.python.org/pep-0517/">PEP 517</a>이 <code>setuptools</code>를 대체할 수 있는 메커니즘을 제공하고, 설치 프론트엔드와 빌드 백엔드를 분리함에 따라, 패키지를 편집 가능 모드로 설치하기 위한 새로운 메커니즘이 필요하게 되었습니다.</p>
<h2>근거 (Rationale)</h2>
<p><a href="https://peps.python.org/pep-0517/">PEP 517</a>은 "편집 가능 설치" 기능을 보류했으며, 이는 <code>setup.py</code>를 사용하지 않는 배포판에는 해당 기능이 없다는 것을 의미했습니다. 이러한 배포판에 편집 가능 설치를 유지하는 유일한 방법은 호환되는 <code>setup.py develop</code> 구현을 제공하는 것이었습니다. 편집 가능 훅(hook)을 정의함으로써 다른 빌드 프론트엔드도 <code>setup.py</code>와 동등한 기능을 얻게 됩니다.</p>
<h2>용어 및 목표 (Terminology and goals)</h2>
<p>"편집 가능 설치 모드(editable installation mode)"는 설치될 프로젝트의 소스 코드가 로컬 디렉토리에 존재함을 의미합니다.</p>
<p>프로젝트가 편집 가능 모드로 설치되면, 사용자는 로컬 소스 트리에서 프로젝트 Python 코드에 대한 변경 사항이 새로운 설치 단계 없이도 즉시 적용될 것으로 기대합니다.</p>
<p>하지만 진입점 추가 또는 수정, 새로운 의존성 추가와 같은 일부 변경 사항은 적용을 위해 새로운 설치 단계를 필요로 합니다. 이러한 변경 사항은 일반적으로 빌드 백엔드 구성 파일(예: <code>pyproject.toml</code>)에서 이루어지므로, Python 소스 코드가 소스 트리에서 가져와진다는 일반적인 사용자 기대와 일치합니다.</p>
<p>C 확장 모듈과 같은 비(非) Python 소스 코드의 수정은 명백히 적용을 위해 컴파일 및/또는 설치 단계를 필요로 합니다. 수행해야 할 정확한 단계는 사용되는 빌드 백엔드에 따라 달라집니다.</p>
<p>프로젝트가 편집 가능 모드로 설치될 때, 사용자는 일반적인 설치와 동일하게 작동할 것을 기대합니다. 특히 코드는 다른 코드에 의해 가져올 수 있어야 하며(importable), <code>importlib.metadata</code>와 같은 표준 메커니즘을 통해 메타데이터를 사용할 수 있어야 합니다.</p>
<p>빌드 백엔드가 이 명세를 구현하는 방식에 따라, 소스 트리에 추가 파일이 존재하여 일반적인 설치의 일부가 아닐 수도 있는 등의 사소한 차이가 있을 수 있습니다. 빌드 백엔드는 이러한 잠재적 차이를 문서화하도록 권장됩니다.</p>
<h2>메커니즘 (The Mechanism)</h2>
<p>이 PEP는 <a href="https://peps.python.org/pep-0517/">PEP 517</a> 백엔드 인터페이스에 세 가지 선택적 훅(hooks)을 추가합니다. 이 훅들은 설치 시 해당 배포판을 소스 폴더에서 가져올 수 있도록 하는 휠(wheel)을 빌드하는 데 사용됩니다.</p>
<h3><code>build_editable</code></h3>
<pre><code class="language-python">def build_editable(wheel_directory, config_settings=None, metadata_directory=None):
    ...
</code></pre>
<p><code>.whl</code> 파일을 빌드하여 지정된 <code>wheel_directory</code>에 배치해야 합니다. 생성된 <code>.whl</code> 파일의 기본 이름(전체 경로 아님)을 유니코드 문자열로 반환해야 합니다.</p>
<p>확장 모듈 또는 다른 빌드 아티팩트(artifacts)가 사용 준비될 수 있도록, 배포판의 인플레이스(in-place) 빌드를 부수 효과(side effect)로 수행할 수 있습니다.</p>
<p><code>.whl</code> 파일은 <a href="https://peps.python.org/pep-0427/">Wheel 바이너리 파일 형식 명세(PEP 427)</a>를 준수해야 합니다. 특히, 규격을 준수하는 <code>.dist-info</code> 디렉토리를 포함해야 합니다. 메타데이터는 <code>build_wheel</code> 또는 <code>prepare_metadata_for_build_wheel</code>에 의해 생성되었을 메타데이터와 동일해야 하지만, <code>Requires-Dist</code>는 아래 설명된 대로 약간 다를 수 있습니다.</p>
<p>빌드 백엔드는 <code>build_wheel</code> 훅에 의해 생성된 휠과 동일한 의존성(<code>Requires-Dist</code> 메타데이터)을 가진 휠을 생성해야 합니다. 단, 편집 가능 메커니즘이 런타임에 작동하는 데 필요한 의존성(예: <code>editables</code>)을 추가할 수 있습니다.</p>
<p>"편집 가능" 휠의 파일명도 <a href="https://peps.python.org/pep-0427/">PEP 427</a>을 준수해야 합니다. <code>build_wheel</code>과 동일한 태그를 사용할 필요는 없지만, 시스템과 호환되도록 태그가 지정되어야 합니다.</p>
<p>빌드 프론트엔드가 이전에 <code>prepare_metadata_for_build_editable</code>을 호출했고, 이 호출로 인해 생성된 휠이 이전 호출과 일치하는 메타데이터를 갖도록 의존하는 경우, 생성된 <code>.dist-info</code> 디렉토리의 경로를 <code>metadata_directory</code> 인수로 제공해야 합니다. 이 인수가 제공되면 <code>build_editable</code>은 동일한 메타데이터를 가진 휠을 생성해야 합니다. 빌드 프론트엔드가 전달하는 디렉토리는 생성된 인식되지 않는 파일들을 포함하여 <code>prepare_metadata_for_build_editable</code>에 의해 생성된 디렉토리와 동일해야 합니다.</p>
<p>"편집 가능" 휠은 배포용이 아니라 빌드 시스템과 프론트엔드 간의 임시 통신 수단으로 휠 형식을 사용합니다. 이는 빌드 백엔드가 아무것도 직접 설치하는 것을 피하게 합니다. 이 휠은 최종 사용자에게 노출되거나 캐시되거나 배포되어서는 안 됩니다.</p>
<h3><code>get_requires_for_build_editable</code></h3>
<pre><code class="language-python">def get_requires_for_build_editable(config_settings=None):
    ...
</code></pre>
<p>이 훅은 <code>build_editable</code> 훅을 호출할 때 설치해야 할, <code>pyproject.toml</code> 파일에 지정된 것 외의 <a href="https://peps.python.org/pep-0508/">PEP 508</a> 의존성 명세(dependency specifications)를 포함하는 추가 문자열 목록을 반환해야 합니다.</p>
<p>정의되지 않은 경우, 기본 구현은 <code>return []</code>와 동일합니다.</p>
<h3><code>prepare_metadata_for_build_editable</code></h3>
<pre><code class="language-python">def prepare_metadata_for_build_editable(metadata_directory, config_settings=None):
    ...
</code></pre>
<p>지정된 <code>metadata_directory</code> 내부에 휠 메타데이터를 포함하는 <code>.dist-info</code> 디렉토리(예: <code>{metadata_directory}/{package}-{version}.dist-info/</code>와 같은 디렉토리)를 생성해야 합니다. 이 디렉토리는 휠 명세에 정의된 유효한 <code>.dist-info</code> 디렉토리여야 하지만, <code>RECORD</code> 또는 서명(signatures)을 포함할 필요는 없습니다. 훅은 이 디렉토리 안에 다른 파일을 생성할 수도 있으며, 빌드 프론트엔드는 이러한 파일을 보존해야 하지만, 그 외에는 무시해야 합니다. 여기서의 의도는 메타데이터가 빌드 시간 결정에 의존하는 경우, 빌드 백엔드가 이러한 결정을 실제 휠 빌드 단계에서 재사용할 수 있는 편리한 형식으로 기록해야 할 수도 있다는 것입니다.</p>
<p>생성된 <code>.dist-info</code> 디렉토리의 기본 이름(전체 경로 아님)을 유니코드 문자열로 반환해야 합니다.</p>
<p>빌드 프론트엔드가 이 정보가 필요하지만 메서드가 정의되지 않은 경우, <code>build_editable</code>을 호출하고 결과 메타데이터를 직접 확인해야 합니다.</p>
<h3>휠에 포함할 내용 (What to put in the wheel)</h3>
<p>빌드 백엔드는 생성된 휠에 설치될 때 편집 가능 설치를 초래할 파일을 채워야 합니다. 빌드 백엔드는 편집 가능 설치의 목표를 달성하기 위해 다양한 기술을 사용할 수 있습니다. 이 섹션은 예시를 제공하며 규범적이지 않습니다.</p>
<p>빌드 백엔드는 <code>.whl</code> 파일의 루트에 소스 트리의 루트 디렉토리를 포함하는 <code>.pth</code> 파일을 배치할 수 있습니다. 이 접근 방식은 간단하지만 매우 정밀하지는 않습니다. 그러나 충분히 좋다고 간주될 수 있으며(특히 <code>src</code> 레이아웃을 사용할 때) 현재 <code>setup.py develop</code>이 하는 방식과 유사합니다. <code>editables</code> 라이브러리는 고품질의 편집 가능 설치를 제공하는 프록시 모듈을 빌드하는 방법을 보여줍니다. 이는 포함하고 숨길 모듈 목록을 허용합니다. 가져올 때, 이 프록시 모듈은 소스 트리의 코드로 자신을 대체합니다. 경로 기반(Path-based) 메서드는 경로 아래의 모든 스크립트를 가져올 수 있게 만드는데, 종종 프로젝트 자체의 <code>setup.py</code> 및 일반 설치의 일부가 아닐 다른 스크립트도 포함합니다. 프록시 전략은 경로 기반 메서드보다 높은 수준의 충실도를 달성할 수 있습니다. 심볼릭 링크(Symbolic links)는 편집 가능 설치를 구현하는 또 다른 유용한 메커니즘입니다. 이 문서 작성 시점에는 휠 명세가 심볼릭 링크를 지원하지 않으므로, 대상 환경에 심볼릭 링크를 직접 설정하는 데 사용할 수 없습니다. 그러나 백엔드가 소스 트리의 일부 빌드 디렉토리에 심볼릭 링크 구조를 생성하고, "편집 가능" 휠의 <code>.pth</code> 파일을 통해 해당 디렉토리를 Python 경로에 추가하는 것은 가능합니다. 이러한 방식으로 링크된 일부 파일이 Python 구현 또는 버전, ABI 또는 플랫폼에 의존하는 경우, 호환성 태그에 따라 다른 디렉토리에 링크 구조를 생성하도록 주의해야 하므로, 동일한 프로젝트 트리를 여러 환경에 편집 가능 모드로 설치할 수 있습니다.</p>
<h3>프론트엔드 요구 사항 (Frontend requirements)</h3>
<p>프론트엔드는 "편집 가능" 휠을 일반 휠과 동일한 방식으로 설치해야 합니다. 이는 편집 가능 설치의 제거(uninstallation)에 특별한 처리가 필요 없음을 의미합니다.</p>
<p>프론트엔드는 설치된 배포판의 <code>.dist-info</code> 디렉토리에 <a href="https://peps.python.org/pep-0610/">PEP 610</a>을 준수하는 <code>direct_url.json</code> 파일을 생성해야 합니다. <code>url</code> 값은 프로젝트 디렉토리(즉, <code>pyproject.toml</code>을 포함하는 디렉토리)를 가리키는 <code>file://</code> URL이어야 하며, <code>dir_info</code> 값은 <code>{'editable': true}</code>여야 합니다.</p>
<p>프론트엔드는 <code>pyproject.toml</code> 파일에 지정된 부트스트랩 요구 사항(bootstrap requirements)을 포함하는 환경에서 <code>get_requires_for_build_editable</code> 훅을 실행해야 합니다.</p>
<p>프론트엔드는 <code>pyproject.toml</code>의 부트스트랩 요구 사항과 <code>get_requires_for_build_editable</code> 훅에 의해 지정된 요구 사항을 포함하는 환경에서 <code>prepare_metadata_for_build_editable</code> 및 <code>build_editable</code> 훅을 실행해야 합니다.</p>
<p>프론트엔드는 <code>build_editable</code>에서 얻은 휠을 최종 사용자에게 노출해서는 안 됩니다. 휠은 설치 후 폐기되어야 하며 캐시되거나 배포되어서는 안 됩니다.</p>
<h2>제한 사항 (Limitations)</h2>
<p>휠의 <code>.data</code> 디렉토리와 관련하여, 이 PEP는 <code>purelib</code> 및 <code>platlib</code> 카테고리(<code>site-packages</code>에 설치됨)를 "편집 가능"하게 만드는 데 중점을 둡니다. <code>headers</code>, <code>data</code>, <code>scripts</code>와 같은 다른 카테고리에 대해서는 특별한 조항을 두지 않습니다. 패키지 작성자는 <code>console_scripts</code>를 사용하거나, 스크립트를 라이브러리 기능에 대한 작은 래퍼(wrapper)로 만들거나, 개발 중에 소스 체크아웃에서 이러한 스크립트를 관리하도록 권장됩니다.</p>
<h2>프로토타입 (Prototypes)</h2>
<p>이 PEP 작성 시점에 여러 프론트엔드 및 백엔드에서 다양한 프로토타입 구현이 제공되고 있습니다. 가능한 접근 방식을 설명하기 위해 아래에 링크를 제공합니다.</p>
<p><strong>프론트엔드:</strong></p>
<ul>
<li><code>pip</code> (풀 리퀘스트)</li>
</ul>
<p><strong>빌드 백엔드:</strong></p>
<ul>
<li><code>enscons</code> (풀 리퀘스트 1, 풀 리퀘스트 2)</li>
<li><code>flit</code> (풀 리퀘스트)</li>
<li><code>hatchling</code> (sdist)</li>
<li><code>pdm</code> (풀 리퀘스트)</li>
<li><code>setuptools</code> (<code>setuptools_pep660</code> 저장소)</li>
</ul>
<h2>채택되지 않은 아이디어 (Rejected ideas)</h2>
<h3>편집 가능 로컬 버전 식별자 (editable local version identifier)</h3>
<p>빌드 백엔드가 로컬 버전 식별자에 <code>editable</code> 문자열을 추가하거나 수정하는 아이디어는 로컬 버전 식별자를 포함하는 <code>==</code> 버전 지정자(specifier)를 만족시키지 못하기 때문에 거부되었습니다. 다시 말해, <code>pkg==1.0+local</code>은 <code>1.0+local.editable</code> 버전으로는 만족되지 않습니다.</p>
<h3>가상 휠 (Virtual wheel)</h3>
<p>또 다른 접근 방식은 <a href="https://peps.python.org/pep-0662/">PEP 662</a>에서 제안되었는데, 빌드 백엔드가 소스 파일 및 디렉토리에서 설치된 레이아웃으로의 매핑을 반환하는 방식입니다. 그런 다음 설치 프로그램(installer) 프론트엔드가 사용자에게 적절하다고 판단하는 모든 수단을 통해 편집 가능 설치를 구현하도록 맡겨집니다.</p>
<p>기능 면에서 두 제안 모두 핵심 "편집 가능" 기능을 제공합니다.</p>
<p>주요 차이점은 <a href="https://peps.python.org/pep-0662/">PEP 662</a>는 프론트엔드가 편집 가능 설치가 어떻게 구현될지 결정하도록 하는 반면, 이 PEP에서는 백엔드가 선택을 해야 한다는 것입니다. 두 접근 방식 모두 원칙적으로 주어진 프로젝트에 대해 여러 편집 가능 설치 메서드를 제공하고 개발자가 설치 시 선택하도록 할 수 있습니다.</p>
<p>이 PEP 작성 시점에 커뮤니티에는 편집 가능 설치에 대한 광범위한 이론적, 실제적 기대치가 있다는 것이 분명합니다. 현실은 <code>.pth</code>를 통한 경로 삽입(즉, <code>setup.py develop</code>이 하는 일)에 대한 경험이 가장 많다는 것입니다.</p>
<p>우리는 <a href="https://peps.python.org/pep-0660/">PEP 660</a>이 프로젝트 작성자가 자신의 요구 사항에 가장 적합한 편집 가능 메커니즘을 제공하는 백엔드를 선택하거나 메서드를 구현하고 올바르게 작동하는지 테스트하도록 함으로써, 현재 "알 수 없는 미지(unknown unknowns)"를 가장 신뢰할 수 있는 방식으로 더 잘 다룬다고 믿습니다. 프론트엔드는 "편집 가능" 휠을 설치하는 방법에 대한 재량이 없으므로, 문제가 발생하는 경우 조사할 곳은 빌드 백엔드 한 곳뿐입니다.</p>
<p><a href="https://peps.python.org/pep-0662/">PEP 662</a>를 사용하면 프론트엔드, 백엔드, 그리고 어쩌면 명세까지 문제를 조사해야 합니다. 또한, 명세를 다른 방식으로 구현하는 여러 프론트엔드가 프로젝트 작성자가 의도한 것과 다르게 동작하는 설치를 생성하여 혼란을 야기하거나, 더 나쁘게는 특정 프론트엔드나 IDE에서만 작동하는 프로젝트를 만들 가능성이 높습니다.</p>
<h3>압축 해제된 휠 (Unpacked wheel)</h3>
<p>임시 디렉토리에 압축 해제된 휠을 생성하여 프론트엔드가 대상 환경으로 복사하도록 하는 프로토타입이 만들어졌습니다. 이 접근 방식은 백엔드가 휠 아카이브를 쉽게 생성할 수 있고, 통신 메커니즘으로 휠을 사용하는 것이 <a href="https://peps.python.org/pep-0517/">PEP 517</a> 철학과 더 잘 맞으며, 따라서 프론트엔드에게 작업을 더 간단하게 유지하기 때문에 더 이상 추구되지 않았습니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 있거나 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 제공됩니다.## PEP 660 – <code>pyproject.toml</code> 기반 빌드를 위한 편집 가능(Editable) 설치 (휠 기반)</p>
<h3>초록 (Abstract)</h3>
<p>이 문서는 패키지를 편집 가능(editable) 모드로 설치하기 위한 <a href="https://peps.python.org/pep-0517/">PEP 517</a> 스타일의 메서드를 설명합니다.</p>
<h3>동기 (Motivation)</h3>
<p>Python 개발자들은 소스 코드 저장소를 체크아웃(checkout)하여 작업하는 방식 등으로, 패키지를 <code>site-packages</code>에 설치(즉, 복사)할 필요 없이 개발할 수 있기를 원합니다.</p>
<p>이러한 개발 방식은 관련 소스 디렉토리를 <code>PYTHONPATH</code> 환경 변수에 추가하여 구현할 수 있습니다. 하지만 <code>setuptools</code>는 <code>setup.py develop</code> 메커니즘을 제공하여 이 과정을 간소화하고, 의존성 패키지 및 콘솔 스크립트와 같은 진입점(entry points)도 함께 설치합니다. <code>pip</code>은 <code>pip install --editable</code> 옵션을 통해 이 메커니즘을 지원합니다.</p>
<p>가져와서(import) 사용되는 Python 코드가 소스 디렉토리에 계속 남아 있도록 프로젝트를 설치하는 방식을 "편집 가능 설치(editable installation mode)"라고 합니다.</p>
<p><a href="https://peps.python.org/pep-0517/">PEP 517</a>이 <code>setuptools</code>를 대체할 수 있는 메커니즘을 제공하고, 설치 프론트엔드와 빌드 백엔드를 분리함에 따라, 패키지를 편집 가능 모드로 설치하기 위한 새로운 표준 메커니즘이 필요하게 되었습니다.</p>
<h3>근거 (Rationale)</h3>
<p><a href="https://peps.python.org/pep-0517/">PEP 517</a>은 "편집 가능 설치" 기능을 미뤄두었으며, 이는 <code>setup.py</code>를 사용하지 않는 배포판에는 이 기능이 없다는 것을 의미했습니다. 이러한 배포판에 편집 가능 설치를 제공하는 유일한 방법은 호환되는 <code>setup.py develop</code> 구현을 제공하는 것이었습니다. 이 PEP에서 편집 가능 훅(hook)을 정의함으로써, 다른 빌드 프론트엔드들도 <code>setup.py</code>와 동등한 편집 가능 설치 기능을 사용할 수 있게 됩니다.</p>
<h3>용어 및 목표 (Terminology and goals)</h3>
<p>"편집 가능 설치 모드(editable installation mode)"는 설치될 프로젝트의 소스 코드가 로컬 디렉토리에 존재해야 함을 의미합니다.</p>
<p>프로젝트가 편집 가능 모드로 설치되면, 사용자는 로컬 소스 트리에서 프로젝트 Python 코드에 대한 변경 사항이 새로운 설치 단계 없이 즉시 적용될 것으로 기대합니다.</p>
<p>그러나 진입점(entry points)의 추가 또는 수정, 새로운 의존성(dependencies) 추가와 같은 일부 변경 사항은 적용을 위해 새로운 설치 단계를 필요로 합니다. 이러한 변경 사항은 일반적으로 빌드 백엔드 구성 파일(예: <code>pyproject.toml</code>)에서 이루어지므로, Python 소스 코드가 소스 트리에서 직접 가져와진다는 일반적인 사용자 기대와 일치합니다.</p>
<p>C 확장 모듈과 같은 비(非) Python 소스 코드의 수정은 적용을 위해 컴파일 및/또는 설치 단계를 명백히 필요로 합니다. 이러한 정확한 단계는 사용되는 빌드 백엔드에 따라 달라집니다.</p>
<p>프로젝트가 편집 가능 모드로 설치될 때, 사용자는 일반적인 설치와 동일하게 동작할 것을 기대합니다. 특히 코드는 다른 코드에 의해 가져올 수 있어야 하며(importable), <code>importlib.metadata</code>와 같은 표준 메커니즘을 통해 메타데이터를 사용할 수 있어야 합니다.</p>
<p>빌드 백엔드가 이 명세를 구현하는 방식에 따라, 소스 트리에 추가 파일이 존재하여 일반적인 설치의 일부가 아닐 수 있는 등의 사소한 차이가 있을 수 있습니다. 빌드 백엔드는 이러한 잠재적 차이를 문서화하도록 권장됩니다.</p>
<h3>메커니즘 (The Mechanism)</h3>
<p>이 PEP는 <a href="https://peps.python.org/pep-0517/">PEP 517</a> 백엔드 인터페이스에 세 가지 선택적 훅(hooks)을 추가합니다. 이 훅들은 설치 시 해당 배포판을 소스 폴더에서 가져올 수 있도록 하는 휠(wheel)을 빌드하는 데 사용됩니다.</p>
<h4><code>build_editable</code></h4>
<pre><code class="language-python">def build_editable(wheel_directory, config_settings=None, metadata_directory=None):
    ...
</code></pre>
<ul>
<li><code>.whl</code> 파일을 빌드하고, 지정된 <code>wheel_directory</code>에 배치해야 합니다.</li>
<li>생성된 <code>.whl</code> 파일의 기본 이름(전체 경로 아님)을 유니코드 문자열로 반환해야 합니다.</li>
<li>확장 모듈 또는 다른 빌드 아티팩트(artifacts)가 사용 준비될 수 있도록, 배포판의 인플레이스(in-place) 빌드를 부수 효과(side effect)로 수행할 수 있습니다.</li>
<li><code>.whl</code> 파일은 <a href="https://peps.python.org/pep-0427/">Wheel 바이너리 파일 형식 명세(PEP 427)</a>를 준수해야 합니다. 특히, 규격을 준수하는 <code>.dist-info</code> 디렉토리를 포함해야 합니다.</li>
<li>메타데이터는 <code>build_wheel</code> 또는 <code>prepare_metadata_for_build_wheel</code>에 의해 생성되었을 메타데이터와 동일해야 하지만, <code>Requires-Dist</code> 필드는 편집 가능 메커니즘의 런타임 작동에 필요한 의존성(예: <code>editables</code>)을 추가할 수 있다는 점에서 약간 다를 수 있습니다.</li>
<li>"편집 가능" 휠의 파일명도 <a href="https://peps.python.org/pep-0427/">PEP 427</a>을 준수해야 하며, 시스템과 호환되도록 태그가 지정되어야 합니다.</li>
<li>만약 빌드 프론트엔드가 이전에 <code>prepare_metadata_for_build_editable</code>을 호출했고, 이 호출로 생성된 휠이 이전 호출과 일치하는 메타데이터를 가져야 한다면, 생성된 <code>.dist-info</code> 디렉토리의 경로를 <code>metadata_directory</code> 인수로 제공해야 합니다. 이 인수가 제공되면 <code>build_editable</code>은 동일한 메타데이터를 가진 휠을 생성해야 합니다.</li>
<li>"편집 가능" 휠은 배포용이 아니라 빌드 시스템과 프론트엔드 간의 임시 통신 수단으로 휠 형식을 사용합니다. 이는 빌드 백엔드가 아무것도 직접 설치하는 것을 방지합니다. 이 휠은 최종 사용자에게 노출되거나 캐시되거나 배포되어서는 안 됩니다.</li>
</ul>
<h4><code>get_requires_for_build_editable</code></h4>
<pre><code class="language-python">def get_requires_for_build_editable(config_settings=None):
    ...
</code></pre>
<ul>
<li>이 훅은 <code>build_editable</code> 훅을 호출할 때 설치해야 할, <code>pyproject.toml</code> 파일에 지정된 것 외의 <a href="https://peps.python.org/pep-0508/">PEP 508</a> 의존성 명세(dependency specifications)를 포함하는 추가 문자열 목록을 반환해야 합니다.</li>
<li>정의되지 않은 경우, 기본 구현은 <code>return []</code>와 동일합니다.</li>
</ul>
<h4><code>prepare_metadata_for_build_editable</code></h4>
<pre><code class="language-python">def prepare_metadata_for_build_editable(metadata_directory, config_settings=None):
    ...
</code></pre>
<ul>
<li>지정된 <code>metadata_directory</code> 내부에 휠 메타데이터를 포함하는 <code>.dist-info</code> 디렉토리(예: <code>{metadata_directory}/{package}-{version}.dist-info/</code>와 같은 디렉토리)를 생성해야 합니다.</li>
<li>이 디렉토리는 휠 명세에 정의된 유효한 <code>.dist-info</code> 디렉토리여야 하지만, <code>RECORD</code> 파일 또는 서명(signatures)을 포함할 필요는 없습니다. 훅은 이 디렉토리 안에 다른 파일을 생성할 수도 있으며, 빌드 프론트엔드는 이러한 파일을 보존해야 하지만, 그 외에는 무시해야 합니다. 이는 메타데이터가 빌드 시간 결정에 의존하는 경우, 빌드 백엔드가 이러한 결정을 실제 휠 빌드 단계에서 재사용할 수 있는 형식으로 기록해야 할 수도 있음을 의미합니다.</li>
<li>생성된 <code>.dist-info</code> 디렉토리의 기본 이름(전체 경로 아님)을 유니코드 문자열로 반환해야 합니다.</li>
<li>빌드 프론트엔드가 이 정보가 필요하지만 메서드가 정의되지 않은 경우, <code>build_editable</code>을 호출하고 결과 메타데이터를 직접 확인해야 합니다.</li>
</ul>
<h4>휠에 포함할 내용 (What to put in the wheel)</h4>
<p>빌드 백엔드는 생성된 휠에 설치될 때 편집 가능 설치를 가능하게 할 파일을 채워야 합니다. 빌드 백엔드는 이 목표를 달성하기 위해 다양한 기술을 사용할 수 있으며, 이 섹션은 예시를 제공하며 규범적이지 않습니다.</p>
<ul>
<li><strong><code>.pth</code> 파일 사용:</strong> 빌드 백엔드는 <code>.whl</code> 파일의 루트에 소스 트리의 루트 디렉토리를 포함하는 <code>.pth</code> 파일을 배치할 수 있습니다. 이 접근 방식은 간단하며 <code>setup.py develop</code>이 현재 하는 방식과 유사합니다.</li>
<li><strong>프록시 모듈(Proxy modules):</strong> <code>editables</code> 라이브러리는 고품질의 편집 가능 설치를 제공하는 프록시 모듈을 빌드하는 방법을 보여줍니다. 이 모듈들은 임포트될 때 소스 트리의 코드로 자신을 대체합니다.</li>
<li><strong>심볼릭 링크(Symbolic links):</strong> 심볼릭 링크도 유용한 메커니즘이지만, 휠 명세가 현재 이를 직접 지원하지 않습니다. 백엔드가 빌드 디렉토리에 심볼릭 링크 구조를 생성하고 <code>.pth</code> 파일을 통해 이 디렉토리를 Python 경로에 추가하는 방식은 가능합니다.</li>
</ul>
<h4>프론트엔드 요구 사항 (Frontend requirements)</h4>
<ul>
<li>프론트엔드는 "편집 가능" 휠을 일반 휠과 동일한 방식으로 설치해야 합니다. 이는 편집 가능 설치의 제거(uninstallation)에 특별한 처리가 필요 없음을 의미합니다.</li>
<li>프론트엔드는 설치된 배포판의 <code>.dist-info</code> 디렉토리에 <a href="https://peps.python.org/pep-0610/">PEP 610</a>을 준수하는 <code>direct_url.json</code> 파일을 생성해야 합니다. <code>url</code> 값은 프로젝트 디렉토리(즉, <code>pyproject.toml</code>을 포함하는 디렉토리)를 가리키는 <code>file://</code> URL이어야 하며, <code>dir_info</code> 값은 <code>{'editable': true}</code>여야 합니다.</li>
<li>프론트엔드는 <code>pyproject.toml</code>에 지정된 부트스트랩 요구 사항을 포함하는 환경에서 <code>get_requires_for_build_editable</code> 훅을 실행해야 합니다.</li>
<li>프론트엔드는 <code>pyproject.toml</code>의 부트스트랩 요구 사항과 <code>get_requires_for_build_editable</code> 훅에 의해 지정된 요구 사항을 포함하는 환경에서 <code>prepare_metadata_for_build_editable</code> 및 <code>build_editable</code> 훅을 실행해야 합니다.</li>
<li>프론트엔드는 <code>build_editable</code>에서 얻은 휠을 최종 사용자에게 노출해서는 안 됩니다. 휠은 설치 후 폐기되어야 하며 캐시되거나 배포되어서는 안 됩니다.</li>
</ul>
<h3>제한 사항 (Limitations)</h3>
<p>이 PEP는 휠의 <code>.data</code> 디렉토리와 관련하여 <code>purelib</code> 및 <code>platlib</code> 카테고리(<code>site-packages</code>에 설치됨)를 "편집 가능"하게 만드는 데 중점을 둡니다. <code>headers</code>, <code>data</code>, <code>scripts</code>와 같은 다른 카테고리에 대해서는 특별한 조항을 두지 않습니다. 패키지 작성자는 <code>console_scripts</code>를 사용하거나, 스크립트를 라이브러리 기능에 대한 작은 래퍼(wrapper)로 만들거나, 개발 중에 소스 체크아웃에서 이러한 스크립트를 관리하도록 권장됩니다.</p>
<h3>프로토타입 (Prototypes)</h3>
<p>이 PEP 작성 시점에 여러 프론트엔드 및 백엔드에서 다양한 프로토타입 구현이 제공되고 있습니다.</p>
<p><strong>프론트엔드:</strong></p>
<ul>
<li><code>pip</code> (풀 리퀘스트)</li>
</ul>
<p><strong>빌드 백엔드:</strong></p>
<ul>
<li><code>enscons</code> (풀 리퀘스트 1, 풀 리퀘스트 2)</li>
<li><code>flit</code> (풀 리퀘스트)</li>
<li><code>hatchling</code> (sdist)</li>
<li><code>pdm</code> (풀 리퀘스트)</li>
<li><code>setuptools</code> (<code>setuptools_pep660</code> 저장소)</li>
</ul>
<h3>채택되지 않은 아이디어 (Rejected ideas)</h3>
<h4>편집 가능 로컬 버전 식별자 (editable local version identifier)</h4>
<p>빌드 백엔드가 로컬 버전 식별자에 <code>editable</code> 문자열을 추가하거나 수정하는 아이디어는 로컬 버전 식별자를 포함하는 <code>==</code> 버전 지정자(specifier)를 만족시키지 못하기 때문에 거부되었습니다. 예를 들어, <code>pkg==1.0+local</code>은 <code>1.0+local.editable</code> 버전으로는 만족되지 않습니다.</p>
<h4>가상 휠 (Virtual wheel)</h4>
<p>또 다른 접근 방식은 <a href="https://peps.python.org/pep-0662/">PEP 662</a>에서 제안되었는데, 빌드 백엔드가 소스 파일 및 디렉토리에서 설치된 레이아웃으로의 매핑을 반환하는 방식입니다. 그런 다음 설치 프로그램(installer) 프론트엔드가 사용자에게 적절하다고 판단하는 모든 수단을 통해 편집 가능 설치를 구현하도록 맡겨집니다.</p>
<p>기능 면에서 두 제안 모두 핵심 "편집 가능" 기능을 제공합니다.</p>
<p>주요 차이점은 <a href="https://peps.python.org/pep-0662/">PEP 662</a>는 프론트엔드가 편집 가능 설치가 어떻게 구현될지 결정하도록 하는 반면, 이 PEP(660)에서는 백엔드가 선택을 해야 한다는 것입니다.</p>
<p><a href="https://peps.python.org/pep-0660/">PEP 660</a>은 프로젝트 작성자가 자신의 요구 사항에 가장 적합한 편집 가능 메커니즘을 제공하는 백엔드를 선택하거나 메서드를 구현하고 올바르게 작동하는지 테스트하도록 함으로써, "알 수 없는 미지(unknown unknowns)"를 가장 신뢰할 수 있는 방식으로 다룬다고 믿어집니다. 프론트엔드는 "편집 가능" 휠을 설치하는 방법에 대한 재량이 없으므로, 문제가 발생하는 경우 조사할 곳은 빌드 백엔드 한 곳뿐입니다.</p>
<p><a href="https://peps.python.org/pep-0662/">PEP 662</a>를 사용하면 프론트엔드, 백엔드, 그리고 어쩌면 명세까지 문제를 조사해야 할 가능성이 있습니다. 또한, 명세를 다르게 구현하는 여러 프론트엔드가 프로젝트 작성자가 의도한 것과 다르게 동작하는 설치를 생성하여 혼란을 야기하거나, 특정 프론트엔드나 IDE에서만 작동하는 프로젝트를 만들 가능성이 높습니다.</p>
<h4>압축 해제된 휠 (Unpacked wheel)</h4>
<p>임시 디렉토리에 압축 해제된 휠을 생성하여 프론트엔드가 대상 환경으로 복사하도록 하는 프로토타입이 만들어졌습니다. 이 접근 방식은 백엔드가 휠 아카이브를 쉽게 생성할 수 있고, 통신 메커니즘으로 휠을 사용하는 것이 <a href="https://peps.python.org/pep-0517/">PEP 517</a> 철학과 더 잘 맞으며, 따라서 프론트엔드에게 작업을 더 간단하게 유지하기 때문에 더 이상 추구되지 않았습니다.</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 있거나 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 제공됩니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/659/">[Final] PEP 659 - Specializing Adaptive Interpreter</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 660 - Editable installs for pyproject.toml based builds (wheel based)</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/661/">[Deferred] PEP 661 - Sentinel Values</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d6cea809dcbae606.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-0948ad04ab71c381.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"931\",\"static/chunks/app/page-90c91ef098171651.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/660\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d6cea809dcbae606.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"UQr4JHFOI5XWpsk7z3lW6\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/660/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/660\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"660\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/660\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"default\"]\ne:T8729,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0660/\"\u003ePEP 660 - Editable installs for pyproject.toml based builds (wheel based)\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 30-Mar-2021\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 660 – \u003ccode\u003epyproject.toml\u003c/code\u003e 기반 빌드를 위한 편집 가능(Editable) 설치 (휠 기반)\u003c/h1\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 문서는 패키지를 편집 가능(editable) 모드로 설치하기 위한 \u003ca href=\"https://peps.python.org/pep-0517/\"\u003ePEP 517\u003c/a\u003e 스타일의 메서드를 설명합니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePython 개발자들은 소스 저장소의 체크아웃(checkout)에서 작업하는 방식 등으로, 패키지를 \u003ccode\u003esite-packages\u003c/code\u003e에 설치(즉, 복사)할 필요 없이 개발할 수 있기를 원합니다.\u003c/p\u003e\n\u003cp\u003e이러한 방식은 관련 소스 디렉토리를 \u003ccode\u003ePYTHONPATH\u003c/code\u003e에 추가함으로써 가능하지만, \u003ccode\u003esetuptools\u003c/code\u003e는 이 과정을 더 쉽게 만들어주는 \u003ccode\u003esetup.py develop\u003c/code\u003e 메커니즘을 제공하며, 의존성 및 콘솔 스크립트와 같은 진입점(entry points)도 설치합니다. \u003ccode\u003epip\u003c/code\u003e은 \u003ccode\u003epip install --editable\u003c/code\u003e 옵션을 통해 이 메커니즘을 노출합니다.\u003c/p\u003e\n\u003cp\u003e가져와서(import) 사용되는 Python 코드가 소스 디렉토리에 남아 있도록 프로젝트를 설치하는 방식을 \"편집 가능 설치(editable installation mode)\"라고 합니다.\u003c/p\u003e\n\u003cp\u003e이제 \u003ca href=\"https://peps.python.org/pep-0517/\"\u003ePEP 517\u003c/a\u003e이 \u003ccode\u003esetuptools\u003c/code\u003e를 대체할 수 있는 메커니즘을 제공하고, 설치 프론트엔드와 빌드 백엔드를 분리함에 따라, 패키지를 편집 가능 모드로 설치하기 위한 새로운 메커니즘이 필요하게 되었습니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://peps.python.org/pep-0517/\"\u003ePEP 517\u003c/a\u003e은 \"편집 가능 설치\" 기능을 보류했으며, 이는 \u003ccode\u003esetup.py\u003c/code\u003e를 사용하지 않는 배포판에는 해당 기능이 없다는 것을 의미했습니다. 이러한 배포판에 편집 가능 설치를 유지하는 유일한 방법은 호환되는 \u003ccode\u003esetup.py develop\u003c/code\u003e 구현을 제공하는 것이었습니다. 편집 가능 훅(hook)을 정의함으로써 다른 빌드 프론트엔드도 \u003ccode\u003esetup.py\u003c/code\u003e와 동등한 기능을 얻게 됩니다.\u003c/p\u003e\n\u003ch2\u003e용어 및 목표 (Terminology and goals)\u003c/h2\u003e\n\u003cp\u003e\"편집 가능 설치 모드(editable installation mode)\"는 설치될 프로젝트의 소스 코드가 로컬 디렉토리에 존재함을 의미합니다.\u003c/p\u003e\n\u003cp\u003e프로젝트가 편집 가능 모드로 설치되면, 사용자는 로컬 소스 트리에서 프로젝트 Python 코드에 대한 변경 사항이 새로운 설치 단계 없이도 즉시 적용될 것으로 기대합니다.\u003c/p\u003e\n\u003cp\u003e하지만 진입점 추가 또는 수정, 새로운 의존성 추가와 같은 일부 변경 사항은 적용을 위해 새로운 설치 단계를 필요로 합니다. 이러한 변경 사항은 일반적으로 빌드 백엔드 구성 파일(예: \u003ccode\u003epyproject.toml\u003c/code\u003e)에서 이루어지므로, Python 소스 코드가 소스 트리에서 가져와진다는 일반적인 사용자 기대와 일치합니다.\u003c/p\u003e\n\u003cp\u003eC 확장 모듈과 같은 비(非) Python 소스 코드의 수정은 명백히 적용을 위해 컴파일 및/또는 설치 단계를 필요로 합니다. 수행해야 할 정확한 단계는 사용되는 빌드 백엔드에 따라 달라집니다.\u003c/p\u003e\n\u003cp\u003e프로젝트가 편집 가능 모드로 설치될 때, 사용자는 일반적인 설치와 동일하게 작동할 것을 기대합니다. 특히 코드는 다른 코드에 의해 가져올 수 있어야 하며(importable), \u003ccode\u003eimportlib.metadata\u003c/code\u003e와 같은 표준 메커니즘을 통해 메타데이터를 사용할 수 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e빌드 백엔드가 이 명세를 구현하는 방식에 따라, 소스 트리에 추가 파일이 존재하여 일반적인 설치의 일부가 아닐 수도 있는 등의 사소한 차이가 있을 수 있습니다. 빌드 백엔드는 이러한 잠재적 차이를 문서화하도록 권장됩니다.\u003c/p\u003e\n\u003ch2\u003e메커니즘 (The Mechanism)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ca href=\"https://peps.python.org/pep-0517/\"\u003ePEP 517\u003c/a\u003e 백엔드 인터페이스에 세 가지 선택적 훅(hooks)을 추가합니다. 이 훅들은 설치 시 해당 배포판을 소스 폴더에서 가져올 수 있도록 하는 휠(wheel)을 빌드하는 데 사용됩니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ebuild_editable\u003c/code\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef build_editable(wheel_directory, config_settings=None, metadata_directory=None):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e.whl\u003c/code\u003e 파일을 빌드하여 지정된 \u003ccode\u003ewheel_directory\u003c/code\u003e에 배치해야 합니다. 생성된 \u003ccode\u003e.whl\u003c/code\u003e 파일의 기본 이름(전체 경로 아님)을 유니코드 문자열로 반환해야 합니다.\u003c/p\u003e\n\u003cp\u003e확장 모듈 또는 다른 빌드 아티팩트(artifacts)가 사용 준비될 수 있도록, 배포판의 인플레이스(in-place) 빌드를 부수 효과(side effect)로 수행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e.whl\u003c/code\u003e 파일은 \u003ca href=\"https://peps.python.org/pep-0427/\"\u003eWheel 바이너리 파일 형식 명세(PEP 427)\u003c/a\u003e를 준수해야 합니다. 특히, 규격을 준수하는 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리를 포함해야 합니다. 메타데이터는 \u003ccode\u003ebuild_wheel\u003c/code\u003e 또는 \u003ccode\u003eprepare_metadata_for_build_wheel\u003c/code\u003e에 의해 생성되었을 메타데이터와 동일해야 하지만, \u003ccode\u003eRequires-Dist\u003c/code\u003e는 아래 설명된 대로 약간 다를 수 있습니다.\u003c/p\u003e\n\u003cp\u003e빌드 백엔드는 \u003ccode\u003ebuild_wheel\u003c/code\u003e 훅에 의해 생성된 휠과 동일한 의존성(\u003ccode\u003eRequires-Dist\u003c/code\u003e 메타데이터)을 가진 휠을 생성해야 합니다. 단, 편집 가능 메커니즘이 런타임에 작동하는 데 필요한 의존성(예: \u003ccode\u003eeditables\u003c/code\u003e)을 추가할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\"편집 가능\" 휠의 파일명도 \u003ca href=\"https://peps.python.org/pep-0427/\"\u003ePEP 427\u003c/a\u003e을 준수해야 합니다. \u003ccode\u003ebuild_wheel\u003c/code\u003e과 동일한 태그를 사용할 필요는 없지만, 시스템과 호환되도록 태그가 지정되어야 합니다.\u003c/p\u003e\n\u003cp\u003e빌드 프론트엔드가 이전에 \u003ccode\u003eprepare_metadata_for_build_editable\u003c/code\u003e을 호출했고, 이 호출로 인해 생성된 휠이 이전 호출과 일치하는 메타데이터를 갖도록 의존하는 경우, 생성된 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리의 경로를 \u003ccode\u003emetadata_directory\u003c/code\u003e 인수로 제공해야 합니다. 이 인수가 제공되면 \u003ccode\u003ebuild_editable\u003c/code\u003e은 동일한 메타데이터를 가진 휠을 생성해야 합니다. 빌드 프론트엔드가 전달하는 디렉토리는 생성된 인식되지 않는 파일들을 포함하여 \u003ccode\u003eprepare_metadata_for_build_editable\u003c/code\u003e에 의해 생성된 디렉토리와 동일해야 합니다.\u003c/p\u003e\n\u003cp\u003e\"편집 가능\" 휠은 배포용이 아니라 빌드 시스템과 프론트엔드 간의 임시 통신 수단으로 휠 형식을 사용합니다. 이는 빌드 백엔드가 아무것도 직접 설치하는 것을 피하게 합니다. 이 휠은 최종 사용자에게 노출되거나 캐시되거나 배포되어서는 안 됩니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eget_requires_for_build_editable\u003c/code\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef get_requires_for_build_editable(config_settings=None):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 훅은 \u003ccode\u003ebuild_editable\u003c/code\u003e 훅을 호출할 때 설치해야 할, \u003ccode\u003epyproject.toml\u003c/code\u003e 파일에 지정된 것 외의 \u003ca href=\"https://peps.python.org/pep-0508/\"\u003ePEP 508\u003c/a\u003e 의존성 명세(dependency specifications)를 포함하는 추가 문자열 목록을 반환해야 합니다.\u003c/p\u003e\n\u003cp\u003e정의되지 않은 경우, 기본 구현은 \u003ccode\u003ereturn []\u003c/code\u003e와 동일합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eprepare_metadata_for_build_editable\u003c/code\u003e\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef prepare_metadata_for_build_editable(metadata_directory, config_settings=None):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지정된 \u003ccode\u003emetadata_directory\u003c/code\u003e 내부에 휠 메타데이터를 포함하는 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리(예: \u003ccode\u003e{metadata_directory}/{package}-{version}.dist-info/\u003c/code\u003e와 같은 디렉토리)를 생성해야 합니다. 이 디렉토리는 휠 명세에 정의된 유효한 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리여야 하지만, \u003ccode\u003eRECORD\u003c/code\u003e 또는 서명(signatures)을 포함할 필요는 없습니다. 훅은 이 디렉토리 안에 다른 파일을 생성할 수도 있으며, 빌드 프론트엔드는 이러한 파일을 보존해야 하지만, 그 외에는 무시해야 합니다. 여기서의 의도는 메타데이터가 빌드 시간 결정에 의존하는 경우, 빌드 백엔드가 이러한 결정을 실제 휠 빌드 단계에서 재사용할 수 있는 편리한 형식으로 기록해야 할 수도 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e생성된 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리의 기본 이름(전체 경로 아님)을 유니코드 문자열로 반환해야 합니다.\u003c/p\u003e\n\u003cp\u003e빌드 프론트엔드가 이 정보가 필요하지만 메서드가 정의되지 않은 경우, \u003ccode\u003ebuild_editable\u003c/code\u003e을 호출하고 결과 메타데이터를 직접 확인해야 합니다.\u003c/p\u003e\n\u003ch3\u003e휠에 포함할 내용 (What to put in the wheel)\u003c/h3\u003e\n\u003cp\u003e빌드 백엔드는 생성된 휠에 설치될 때 편집 가능 설치를 초래할 파일을 채워야 합니다. 빌드 백엔드는 편집 가능 설치의 목표를 달성하기 위해 다양한 기술을 사용할 수 있습니다. 이 섹션은 예시를 제공하며 규범적이지 않습니다.\u003c/p\u003e\n\u003cp\u003e빌드 백엔드는 \u003ccode\u003e.whl\u003c/code\u003e 파일의 루트에 소스 트리의 루트 디렉토리를 포함하는 \u003ccode\u003e.pth\u003c/code\u003e 파일을 배치할 수 있습니다. 이 접근 방식은 간단하지만 매우 정밀하지는 않습니다. 그러나 충분히 좋다고 간주될 수 있으며(특히 \u003ccode\u003esrc\u003c/code\u003e 레이아웃을 사용할 때) 현재 \u003ccode\u003esetup.py develop\u003c/code\u003e이 하는 방식과 유사합니다. \u003ccode\u003eeditables\u003c/code\u003e 라이브러리는 고품질의 편집 가능 설치를 제공하는 프록시 모듈을 빌드하는 방법을 보여줍니다. 이는 포함하고 숨길 모듈 목록을 허용합니다. 가져올 때, 이 프록시 모듈은 소스 트리의 코드로 자신을 대체합니다. 경로 기반(Path-based) 메서드는 경로 아래의 모든 스크립트를 가져올 수 있게 만드는데, 종종 프로젝트 자체의 \u003ccode\u003esetup.py\u003c/code\u003e 및 일반 설치의 일부가 아닐 다른 스크립트도 포함합니다. 프록시 전략은 경로 기반 메서드보다 높은 수준의 충실도를 달성할 수 있습니다. 심볼릭 링크(Symbolic links)는 편집 가능 설치를 구현하는 또 다른 유용한 메커니즘입니다. 이 문서 작성 시점에는 휠 명세가 심볼릭 링크를 지원하지 않으므로, 대상 환경에 심볼릭 링크를 직접 설정하는 데 사용할 수 없습니다. 그러나 백엔드가 소스 트리의 일부 빌드 디렉토리에 심볼릭 링크 구조를 생성하고, \"편집 가능\" 휠의 \u003ccode\u003e.pth\u003c/code\u003e 파일을 통해 해당 디렉토리를 Python 경로에 추가하는 것은 가능합니다. 이러한 방식으로 링크된 일부 파일이 Python 구현 또는 버전, ABI 또는 플랫폼에 의존하는 경우, 호환성 태그에 따라 다른 디렉토리에 링크 구조를 생성하도록 주의해야 하므로, 동일한 프로젝트 트리를 여러 환경에 편집 가능 모드로 설치할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e프론트엔드 요구 사항 (Frontend requirements)\u003c/h3\u003e\n\u003cp\u003e프론트엔드는 \"편집 가능\" 휠을 일반 휠과 동일한 방식으로 설치해야 합니다. 이는 편집 가능 설치의 제거(uninstallation)에 특별한 처리가 필요 없음을 의미합니다.\u003c/p\u003e\n\u003cp\u003e프론트엔드는 설치된 배포판의 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리에 \u003ca href=\"https://peps.python.org/pep-0610/\"\u003ePEP 610\u003c/a\u003e을 준수하는 \u003ccode\u003edirect_url.json\u003c/code\u003e 파일을 생성해야 합니다. \u003ccode\u003eurl\u003c/code\u003e 값은 프로젝트 디렉토리(즉, \u003ccode\u003epyproject.toml\u003c/code\u003e을 포함하는 디렉토리)를 가리키는 \u003ccode\u003efile://\u003c/code\u003e URL이어야 하며, \u003ccode\u003edir_info\u003c/code\u003e 값은 \u003ccode\u003e{'editable': true}\u003c/code\u003e여야 합니다.\u003c/p\u003e\n\u003cp\u003e프론트엔드는 \u003ccode\u003epyproject.toml\u003c/code\u003e 파일에 지정된 부트스트랩 요구 사항(bootstrap requirements)을 포함하는 환경에서 \u003ccode\u003eget_requires_for_build_editable\u003c/code\u003e 훅을 실행해야 합니다.\u003c/p\u003e\n\u003cp\u003e프론트엔드는 \u003ccode\u003epyproject.toml\u003c/code\u003e의 부트스트랩 요구 사항과 \u003ccode\u003eget_requires_for_build_editable\u003c/code\u003e 훅에 의해 지정된 요구 사항을 포함하는 환경에서 \u003ccode\u003eprepare_metadata_for_build_editable\u003c/code\u003e 및 \u003ccode\u003ebuild_editable\u003c/code\u003e 훅을 실행해야 합니다.\u003c/p\u003e\n\u003cp\u003e프론트엔드는 \u003ccode\u003ebuild_editable\u003c/code\u003e에서 얻은 휠을 최종 사용자에게 노출해서는 안 됩니다. 휠은 설치 후 폐기되어야 하며 캐시되거나 배포되어서는 안 됩니다.\u003c/p\u003e\n\u003ch2\u003e제한 사항 (Limitations)\u003c/h2\u003e\n\u003cp\u003e휠의 \u003ccode\u003e.data\u003c/code\u003e 디렉토리와 관련하여, 이 PEP는 \u003ccode\u003epurelib\u003c/code\u003e 및 \u003ccode\u003eplatlib\u003c/code\u003e 카테고리(\u003ccode\u003esite-packages\u003c/code\u003e에 설치됨)를 \"편집 가능\"하게 만드는 데 중점을 둡니다. \u003ccode\u003eheaders\u003c/code\u003e, \u003ccode\u003edata\u003c/code\u003e, \u003ccode\u003escripts\u003c/code\u003e와 같은 다른 카테고리에 대해서는 특별한 조항을 두지 않습니다. 패키지 작성자는 \u003ccode\u003econsole_scripts\u003c/code\u003e를 사용하거나, 스크립트를 라이브러리 기능에 대한 작은 래퍼(wrapper)로 만들거나, 개발 중에 소스 체크아웃에서 이러한 스크립트를 관리하도록 권장됩니다.\u003c/p\u003e\n\u003ch2\u003e프로토타입 (Prototypes)\u003c/h2\u003e\n\u003cp\u003e이 PEP 작성 시점에 여러 프론트엔드 및 백엔드에서 다양한 프로토타입 구현이 제공되고 있습니다. 가능한 접근 방식을 설명하기 위해 아래에 링크를 제공합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e프론트엔드:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epip\u003c/code\u003e (풀 리퀘스트)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e빌드 백엔드:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eenscons\u003c/code\u003e (풀 리퀘스트 1, 풀 리퀘스트 2)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eflit\u003c/code\u003e (풀 리퀘스트)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehatchling\u003c/code\u003e (sdist)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epdm\u003c/code\u003e (풀 리퀘스트)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esetuptools\u003c/code\u003e (\u003ccode\u003esetuptools_pep660\u003c/code\u003e 저장소)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e채택되지 않은 아이디어 (Rejected ideas)\u003c/h2\u003e\n\u003ch3\u003e편집 가능 로컬 버전 식별자 (editable local version identifier)\u003c/h3\u003e\n\u003cp\u003e빌드 백엔드가 로컬 버전 식별자에 \u003ccode\u003eeditable\u003c/code\u003e 문자열을 추가하거나 수정하는 아이디어는 로컬 버전 식별자를 포함하는 \u003ccode\u003e==\u003c/code\u003e 버전 지정자(specifier)를 만족시키지 못하기 때문에 거부되었습니다. 다시 말해, \u003ccode\u003epkg==1.0+local\u003c/code\u003e은 \u003ccode\u003e1.0+local.editable\u003c/code\u003e 버전으로는 만족되지 않습니다.\u003c/p\u003e\n\u003ch3\u003e가상 휠 (Virtual wheel)\u003c/h3\u003e\n\u003cp\u003e또 다른 접근 방식은 \u003ca href=\"https://peps.python.org/pep-0662/\"\u003ePEP 662\u003c/a\u003e에서 제안되었는데, 빌드 백엔드가 소스 파일 및 디렉토리에서 설치된 레이아웃으로의 매핑을 반환하는 방식입니다. 그런 다음 설치 프로그램(installer) 프론트엔드가 사용자에게 적절하다고 판단하는 모든 수단을 통해 편집 가능 설치를 구현하도록 맡겨집니다.\u003c/p\u003e\n\u003cp\u003e기능 면에서 두 제안 모두 핵심 \"편집 가능\" 기능을 제공합니다.\u003c/p\u003e\n\u003cp\u003e주요 차이점은 \u003ca href=\"https://peps.python.org/pep-0662/\"\u003ePEP 662\u003c/a\u003e는 프론트엔드가 편집 가능 설치가 어떻게 구현될지 결정하도록 하는 반면, 이 PEP에서는 백엔드가 선택을 해야 한다는 것입니다. 두 접근 방식 모두 원칙적으로 주어진 프로젝트에 대해 여러 편집 가능 설치 메서드를 제공하고 개발자가 설치 시 선택하도록 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP 작성 시점에 커뮤니티에는 편집 가능 설치에 대한 광범위한 이론적, 실제적 기대치가 있다는 것이 분명합니다. 현실은 \u003ccode\u003e.pth\u003c/code\u003e를 통한 경로 삽입(즉, \u003ccode\u003esetup.py develop\u003c/code\u003e이 하는 일)에 대한 경험이 가장 많다는 것입니다.\u003c/p\u003e\n\u003cp\u003e우리는 \u003ca href=\"https://peps.python.org/pep-0660/\"\u003ePEP 660\u003c/a\u003e이 프로젝트 작성자가 자신의 요구 사항에 가장 적합한 편집 가능 메커니즘을 제공하는 백엔드를 선택하거나 메서드를 구현하고 올바르게 작동하는지 테스트하도록 함으로써, 현재 \"알 수 없는 미지(unknown unknowns)\"를 가장 신뢰할 수 있는 방식으로 더 잘 다룬다고 믿습니다. 프론트엔드는 \"편집 가능\" 휠을 설치하는 방법에 대한 재량이 없으므로, 문제가 발생하는 경우 조사할 곳은 빌드 백엔드 한 곳뿐입니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://peps.python.org/pep-0662/\"\u003ePEP 662\u003c/a\u003e를 사용하면 프론트엔드, 백엔드, 그리고 어쩌면 명세까지 문제를 조사해야 합니다. 또한, 명세를 다른 방식으로 구현하는 여러 프론트엔드가 프로젝트 작성자가 의도한 것과 다르게 동작하는 설치를 생성하여 혼란을 야기하거나, 더 나쁘게는 특정 프론트엔드나 IDE에서만 작동하는 프로젝트를 만들 가능성이 높습니다.\u003c/p\u003e\n\u003ch3\u003e압축 해제된 휠 (Unpacked wheel)\u003c/h3\u003e\n\u003cp\u003e임시 디렉토리에 압축 해제된 휠을 생성하여 프론트엔드가 대상 환경으로 복사하도록 하는 프로토타입이 만들어졌습니다. 이 접근 방식은 백엔드가 휠 아카이브를 쉽게 생성할 수 있고, 통신 메커니즘으로 휠을 사용하는 것이 \u003ca href=\"https://peps.python.org/pep-0517/\"\u003ePEP 517\u003c/a\u003e 철학과 더 잘 맞으며, 따라서 프론트엔드에게 작업을 더 간단하게 유지하기 때문에 더 이상 추구되지 않았습니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 있거나 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 제공됩니다.## PEP 660 – \u003ccode\u003epyproject.toml\u003c/code\u003e 기반 빌드를 위한 편집 가능(Editable) 설치 (휠 기반)\u003c/p\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 문서는 패키지를 편집 가능(editable) 모드로 설치하기 위한 \u003ca href=\"https://peps.python.org/pep-0517/\"\u003ePEP 517\u003c/a\u003e 스타일의 메서드를 설명합니다.\u003c/p\u003e\n\u003ch3\u003e동기 (Motivation)\u003c/h3\u003e\n\u003cp\u003ePython 개발자들은 소스 코드 저장소를 체크아웃(checkout)하여 작업하는 방식 등으로, 패키지를 \u003ccode\u003esite-packages\u003c/code\u003e에 설치(즉, 복사)할 필요 없이 개발할 수 있기를 원합니다.\u003c/p\u003e\n\u003cp\u003e이러한 개발 방식은 관련 소스 디렉토리를 \u003ccode\u003ePYTHONPATH\u003c/code\u003e 환경 변수에 추가하여 구현할 수 있습니다. 하지만 \u003ccode\u003esetuptools\u003c/code\u003e는 \u003ccode\u003esetup.py develop\u003c/code\u003e 메커니즘을 제공하여 이 과정을 간소화하고, 의존성 패키지 및 콘솔 스크립트와 같은 진입점(entry points)도 함께 설치합니다. \u003ccode\u003epip\u003c/code\u003e은 \u003ccode\u003epip install --editable\u003c/code\u003e 옵션을 통해 이 메커니즘을 지원합니다.\u003c/p\u003e\n\u003cp\u003e가져와서(import) 사용되는 Python 코드가 소스 디렉토리에 계속 남아 있도록 프로젝트를 설치하는 방식을 \"편집 가능 설치(editable installation mode)\"라고 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://peps.python.org/pep-0517/\"\u003ePEP 517\u003c/a\u003e이 \u003ccode\u003esetuptools\u003c/code\u003e를 대체할 수 있는 메커니즘을 제공하고, 설치 프론트엔드와 빌드 백엔드를 분리함에 따라, 패키지를 편집 가능 모드로 설치하기 위한 새로운 표준 메커니즘이 필요하게 되었습니다.\u003c/p\u003e\n\u003ch3\u003e근거 (Rationale)\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://peps.python.org/pep-0517/\"\u003ePEP 517\u003c/a\u003e은 \"편집 가능 설치\" 기능을 미뤄두었으며, 이는 \u003ccode\u003esetup.py\u003c/code\u003e를 사용하지 않는 배포판에는 이 기능이 없다는 것을 의미했습니다. 이러한 배포판에 편집 가능 설치를 제공하는 유일한 방법은 호환되는 \u003ccode\u003esetup.py develop\u003c/code\u003e 구현을 제공하는 것이었습니다. 이 PEP에서 편집 가능 훅(hook)을 정의함으로써, 다른 빌드 프론트엔드들도 \u003ccode\u003esetup.py\u003c/code\u003e와 동등한 편집 가능 설치 기능을 사용할 수 있게 됩니다.\u003c/p\u003e\n\u003ch3\u003e용어 및 목표 (Terminology and goals)\u003c/h3\u003e\n\u003cp\u003e\"편집 가능 설치 모드(editable installation mode)\"는 설치될 프로젝트의 소스 코드가 로컬 디렉토리에 존재해야 함을 의미합니다.\u003c/p\u003e\n\u003cp\u003e프로젝트가 편집 가능 모드로 설치되면, 사용자는 로컬 소스 트리에서 프로젝트 Python 코드에 대한 변경 사항이 새로운 설치 단계 없이 즉시 적용될 것으로 기대합니다.\u003c/p\u003e\n\u003cp\u003e그러나 진입점(entry points)의 추가 또는 수정, 새로운 의존성(dependencies) 추가와 같은 일부 변경 사항은 적용을 위해 새로운 설치 단계를 필요로 합니다. 이러한 변경 사항은 일반적으로 빌드 백엔드 구성 파일(예: \u003ccode\u003epyproject.toml\u003c/code\u003e)에서 이루어지므로, Python 소스 코드가 소스 트리에서 직접 가져와진다는 일반적인 사용자 기대와 일치합니다.\u003c/p\u003e\n\u003cp\u003eC 확장 모듈과 같은 비(非) Python 소스 코드의 수정은 적용을 위해 컴파일 및/또는 설치 단계를 명백히 필요로 합니다. 이러한 정확한 단계는 사용되는 빌드 백엔드에 따라 달라집니다.\u003c/p\u003e\n\u003cp\u003e프로젝트가 편집 가능 모드로 설치될 때, 사용자는 일반적인 설치와 동일하게 동작할 것을 기대합니다. 특히 코드는 다른 코드에 의해 가져올 수 있어야 하며(importable), \u003ccode\u003eimportlib.metadata\u003c/code\u003e와 같은 표준 메커니즘을 통해 메타데이터를 사용할 수 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e빌드 백엔드가 이 명세를 구현하는 방식에 따라, 소스 트리에 추가 파일이 존재하여 일반적인 설치의 일부가 아닐 수 있는 등의 사소한 차이가 있을 수 있습니다. 빌드 백엔드는 이러한 잠재적 차이를 문서화하도록 권장됩니다.\u003c/p\u003e\n\u003ch3\u003e메커니즘 (The Mechanism)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ca href=\"https://peps.python.org/pep-0517/\"\u003ePEP 517\u003c/a\u003e 백엔드 인터페이스에 세 가지 선택적 훅(hooks)을 추가합니다. 이 훅들은 설치 시 해당 배포판을 소스 폴더에서 가져올 수 있도록 하는 휠(wheel)을 빌드하는 데 사용됩니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003ebuild_editable\u003c/code\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef build_editable(wheel_directory, config_settings=None, metadata_directory=None):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e.whl\u003c/code\u003e 파일을 빌드하고, 지정된 \u003ccode\u003ewheel_directory\u003c/code\u003e에 배치해야 합니다.\u003c/li\u003e\n\u003cli\u003e생성된 \u003ccode\u003e.whl\u003c/code\u003e 파일의 기본 이름(전체 경로 아님)을 유니코드 문자열로 반환해야 합니다.\u003c/li\u003e\n\u003cli\u003e확장 모듈 또는 다른 빌드 아티팩트(artifacts)가 사용 준비될 수 있도록, 배포판의 인플레이스(in-place) 빌드를 부수 효과(side effect)로 수행할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.whl\u003c/code\u003e 파일은 \u003ca href=\"https://peps.python.org/pep-0427/\"\u003eWheel 바이너리 파일 형식 명세(PEP 427)\u003c/a\u003e를 준수해야 합니다. 특히, 규격을 준수하는 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리를 포함해야 합니다.\u003c/li\u003e\n\u003cli\u003e메타데이터는 \u003ccode\u003ebuild_wheel\u003c/code\u003e 또는 \u003ccode\u003eprepare_metadata_for_build_wheel\u003c/code\u003e에 의해 생성되었을 메타데이터와 동일해야 하지만, \u003ccode\u003eRequires-Dist\u003c/code\u003e 필드는 편집 가능 메커니즘의 런타임 작동에 필요한 의존성(예: \u003ccode\u003eeditables\u003c/code\u003e)을 추가할 수 있다는 점에서 약간 다를 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\"편집 가능\" 휠의 파일명도 \u003ca href=\"https://peps.python.org/pep-0427/\"\u003ePEP 427\u003c/a\u003e을 준수해야 하며, 시스템과 호환되도록 태그가 지정되어야 합니다.\u003c/li\u003e\n\u003cli\u003e만약 빌드 프론트엔드가 이전에 \u003ccode\u003eprepare_metadata_for_build_editable\u003c/code\u003e을 호출했고, 이 호출로 생성된 휠이 이전 호출과 일치하는 메타데이터를 가져야 한다면, 생성된 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리의 경로를 \u003ccode\u003emetadata_directory\u003c/code\u003e 인수로 제공해야 합니다. 이 인수가 제공되면 \u003ccode\u003ebuild_editable\u003c/code\u003e은 동일한 메타데이터를 가진 휠을 생성해야 합니다.\u003c/li\u003e\n\u003cli\u003e\"편집 가능\" 휠은 배포용이 아니라 빌드 시스템과 프론트엔드 간의 임시 통신 수단으로 휠 형식을 사용합니다. 이는 빌드 백엔드가 아무것도 직접 설치하는 것을 방지합니다. 이 휠은 최종 사용자에게 노출되거나 캐시되거나 배포되어서는 안 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003ccode\u003eget_requires_for_build_editable\u003c/code\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef get_requires_for_build_editable(config_settings=None):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e이 훅은 \u003ccode\u003ebuild_editable\u003c/code\u003e 훅을 호출할 때 설치해야 할, \u003ccode\u003epyproject.toml\u003c/code\u003e 파일에 지정된 것 외의 \u003ca href=\"https://peps.python.org/pep-0508/\"\u003ePEP 508\u003c/a\u003e 의존성 명세(dependency specifications)를 포함하는 추가 문자열 목록을 반환해야 합니다.\u003c/li\u003e\n\u003cli\u003e정의되지 않은 경우, 기본 구현은 \u003ccode\u003ereturn []\u003c/code\u003e와 동일합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003ccode\u003eprepare_metadata_for_build_editable\u003c/code\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef prepare_metadata_for_build_editable(metadata_directory, config_settings=None):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e지정된 \u003ccode\u003emetadata_directory\u003c/code\u003e 내부에 휠 메타데이터를 포함하는 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리(예: \u003ccode\u003e{metadata_directory}/{package}-{version}.dist-info/\u003c/code\u003e와 같은 디렉토리)를 생성해야 합니다.\u003c/li\u003e\n\u003cli\u003e이 디렉토리는 휠 명세에 정의된 유효한 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리여야 하지만, \u003ccode\u003eRECORD\u003c/code\u003e 파일 또는 서명(signatures)을 포함할 필요는 없습니다. 훅은 이 디렉토리 안에 다른 파일을 생성할 수도 있으며, 빌드 프론트엔드는 이러한 파일을 보존해야 하지만, 그 외에는 무시해야 합니다. 이는 메타데이터가 빌드 시간 결정에 의존하는 경우, 빌드 백엔드가 이러한 결정을 실제 휠 빌드 단계에서 재사용할 수 있는 형식으로 기록해야 할 수도 있음을 의미합니다.\u003c/li\u003e\n\u003cli\u003e생성된 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리의 기본 이름(전체 경로 아님)을 유니코드 문자열로 반환해야 합니다.\u003c/li\u003e\n\u003cli\u003e빌드 프론트엔드가 이 정보가 필요하지만 메서드가 정의되지 않은 경우, \u003ccode\u003ebuild_editable\u003c/code\u003e을 호출하고 결과 메타데이터를 직접 확인해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e휠에 포함할 내용 (What to put in the wheel)\u003c/h4\u003e\n\u003cp\u003e빌드 백엔드는 생성된 휠에 설치될 때 편집 가능 설치를 가능하게 할 파일을 채워야 합니다. 빌드 백엔드는 이 목표를 달성하기 위해 다양한 기술을 사용할 수 있으며, 이 섹션은 예시를 제공하며 규범적이지 않습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e.pth\u003c/code\u003e 파일 사용:\u003c/strong\u003e 빌드 백엔드는 \u003ccode\u003e.whl\u003c/code\u003e 파일의 루트에 소스 트리의 루트 디렉토리를 포함하는 \u003ccode\u003e.pth\u003c/code\u003e 파일을 배치할 수 있습니다. 이 접근 방식은 간단하며 \u003ccode\u003esetup.py develop\u003c/code\u003e이 현재 하는 방식과 유사합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e프록시 모듈(Proxy modules):\u003c/strong\u003e \u003ccode\u003eeditables\u003c/code\u003e 라이브러리는 고품질의 편집 가능 설치를 제공하는 프록시 모듈을 빌드하는 방법을 보여줍니다. 이 모듈들은 임포트될 때 소스 트리의 코드로 자신을 대체합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e심볼릭 링크(Symbolic links):\u003c/strong\u003e 심볼릭 링크도 유용한 메커니즘이지만, 휠 명세가 현재 이를 직접 지원하지 않습니다. 백엔드가 빌드 디렉토리에 심볼릭 링크 구조를 생성하고 \u003ccode\u003e.pth\u003c/code\u003e 파일을 통해 이 디렉토리를 Python 경로에 추가하는 방식은 가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e프론트엔드 요구 사항 (Frontend requirements)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e프론트엔드는 \"편집 가능\" 휠을 일반 휠과 동일한 방식으로 설치해야 합니다. 이는 편집 가능 설치의 제거(uninstallation)에 특별한 처리가 필요 없음을 의미합니다.\u003c/li\u003e\n\u003cli\u003e프론트엔드는 설치된 배포판의 \u003ccode\u003e.dist-info\u003c/code\u003e 디렉토리에 \u003ca href=\"https://peps.python.org/pep-0610/\"\u003ePEP 610\u003c/a\u003e을 준수하는 \u003ccode\u003edirect_url.json\u003c/code\u003e 파일을 생성해야 합니다. \u003ccode\u003eurl\u003c/code\u003e 값은 프로젝트 디렉토리(즉, \u003ccode\u003epyproject.toml\u003c/code\u003e을 포함하는 디렉토리)를 가리키는 \u003ccode\u003efile://\u003c/code\u003e URL이어야 하며, \u003ccode\u003edir_info\u003c/code\u003e 값은 \u003ccode\u003e{'editable': true}\u003c/code\u003e여야 합니다.\u003c/li\u003e\n\u003cli\u003e프론트엔드는 \u003ccode\u003epyproject.toml\u003c/code\u003e에 지정된 부트스트랩 요구 사항을 포함하는 환경에서 \u003ccode\u003eget_requires_for_build_editable\u003c/code\u003e 훅을 실행해야 합니다.\u003c/li\u003e\n\u003cli\u003e프론트엔드는 \u003ccode\u003epyproject.toml\u003c/code\u003e의 부트스트랩 요구 사항과 \u003ccode\u003eget_requires_for_build_editable\u003c/code\u003e 훅에 의해 지정된 요구 사항을 포함하는 환경에서 \u003ccode\u003eprepare_metadata_for_build_editable\u003c/code\u003e 및 \u003ccode\u003ebuild_editable\u003c/code\u003e 훅을 실행해야 합니다.\u003c/li\u003e\n\u003cli\u003e프론트엔드는 \u003ccode\u003ebuild_editable\u003c/code\u003e에서 얻은 휠을 최종 사용자에게 노출해서는 안 됩니다. 휠은 설치 후 폐기되어야 하며 캐시되거나 배포되어서는 안 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e제한 사항 (Limitations)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 휠의 \u003ccode\u003e.data\u003c/code\u003e 디렉토리와 관련하여 \u003ccode\u003epurelib\u003c/code\u003e 및 \u003ccode\u003eplatlib\u003c/code\u003e 카테고리(\u003ccode\u003esite-packages\u003c/code\u003e에 설치됨)를 \"편집 가능\"하게 만드는 데 중점을 둡니다. \u003ccode\u003eheaders\u003c/code\u003e, \u003ccode\u003edata\u003c/code\u003e, \u003ccode\u003escripts\u003c/code\u003e와 같은 다른 카테고리에 대해서는 특별한 조항을 두지 않습니다. 패키지 작성자는 \u003ccode\u003econsole_scripts\u003c/code\u003e를 사용하거나, 스크립트를 라이브러리 기능에 대한 작은 래퍼(wrapper)로 만들거나, 개발 중에 소스 체크아웃에서 이러한 스크립트를 관리하도록 권장됩니다.\u003c/p\u003e\n\u003ch3\u003e프로토타입 (Prototypes)\u003c/h3\u003e\n\u003cp\u003e이 PEP 작성 시점에 여러 프론트엔드 및 백엔드에서 다양한 프로토타입 구현이 제공되고 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e프론트엔드:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epip\u003c/code\u003e (풀 리퀘스트)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e빌드 백엔드:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eenscons\u003c/code\u003e (풀 리퀘스트 1, 풀 리퀘스트 2)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eflit\u003c/code\u003e (풀 리퀘스트)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehatchling\u003c/code\u003e (sdist)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epdm\u003c/code\u003e (풀 리퀘스트)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esetuptools\u003c/code\u003e (\u003ccode\u003esetuptools_pep660\u003c/code\u003e 저장소)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e채택되지 않은 아이디어 (Rejected ideas)\u003c/h3\u003e\n\u003ch4\u003e편집 가능 로컬 버전 식별자 (editable local version identifier)\u003c/h4\u003e\n\u003cp\u003e빌드 백엔드가 로컬 버전 식별자에 \u003ccode\u003eeditable\u003c/code\u003e 문자열을 추가하거나 수정하는 아이디어는 로컬 버전 식별자를 포함하는 \u003ccode\u003e==\u003c/code\u003e 버전 지정자(specifier)를 만족시키지 못하기 때문에 거부되었습니다. 예를 들어, \u003ccode\u003epkg==1.0+local\u003c/code\u003e은 \u003ccode\u003e1.0+local.editable\u003c/code\u003e 버전으로는 만족되지 않습니다.\u003c/p\u003e\n\u003ch4\u003e가상 휠 (Virtual wheel)\u003c/h4\u003e\n\u003cp\u003e또 다른 접근 방식은 \u003ca href=\"https://peps.python.org/pep-0662/\"\u003ePEP 662\u003c/a\u003e에서 제안되었는데, 빌드 백엔드가 소스 파일 및 디렉토리에서 설치된 레이아웃으로의 매핑을 반환하는 방식입니다. 그런 다음 설치 프로그램(installer) 프론트엔드가 사용자에게 적절하다고 판단하는 모든 수단을 통해 편집 가능 설치를 구현하도록 맡겨집니다.\u003c/p\u003e\n\u003cp\u003e기능 면에서 두 제안 모두 핵심 \"편집 가능\" 기능을 제공합니다.\u003c/p\u003e\n\u003cp\u003e주요 차이점은 \u003ca href=\"https://peps.python.org/pep-0662/\"\u003ePEP 662\u003c/a\u003e는 프론트엔드가 편집 가능 설치가 어떻게 구현될지 결정하도록 하는 반면, 이 PEP(660)에서는 백엔드가 선택을 해야 한다는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://peps.python.org/pep-0660/\"\u003ePEP 660\u003c/a\u003e은 프로젝트 작성자가 자신의 요구 사항에 가장 적합한 편집 가능 메커니즘을 제공하는 백엔드를 선택하거나 메서드를 구현하고 올바르게 작동하는지 테스트하도록 함으로써, \"알 수 없는 미지(unknown unknowns)\"를 가장 신뢰할 수 있는 방식으로 다룬다고 믿어집니다. 프론트엔드는 \"편집 가능\" 휠을 설치하는 방법에 대한 재량이 없으므로, 문제가 발생하는 경우 조사할 곳은 빌드 백엔드 한 곳뿐입니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://peps.python.org/pep-0662/\"\u003ePEP 662\u003c/a\u003e를 사용하면 프론트엔드, 백엔드, 그리고 어쩌면 명세까지 문제를 조사해야 할 가능성이 있습니다. 또한, 명세를 다르게 구현하는 여러 프론트엔드가 프로젝트 작성자가 의도한 것과 다르게 동작하는 설치를 생성하여 혼란을 야기하거나, 특정 프론트엔드나 IDE에서만 작동하는 프로젝트를 만들 가능성이 높습니다.\u003c/p\u003e\n\u003ch4\u003e압축 해제된 휠 (Unpacked wheel)\u003c/h4\u003e\n\u003cp\u003e임시 디렉토리에 압축 해제된 휠을 생성하여 프론트엔드가 대상 환경으로 복사하도록 하는 프로토타입이 만들어졌습니다. 이 접근 방식은 백엔드가 휠 아카이브를 쉽게 생성할 수 있고, 통신 메커니즘으로 휠을 사용하는 것이 \u003ca href=\"https://peps.python.org/pep-0517/\"\u003ePEP 517\u003c/a\u003e 철학과 더 잘 맞으며, 따라서 프론트엔드에게 작업을 더 간단하게 유지하기 때문에 더 이상 추구되지 않았습니다.\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 있거나 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 제공됩니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2457,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 660 - Editable installs for pyproject.toml based builds (wheel based)\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 09:55:28+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/660/\",\"postId\":\"2025-09-27-pep-0660-editable-installs-for-pyproject-toml-based-builds-wheel-based\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/659/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 659 - Specializing Adaptive Interpreter\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 660 - Editable installs for pyproject.toml based builds (wheel based)\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/661/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Deferred] PEP 661 - Sentinel Values\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>