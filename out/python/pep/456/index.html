<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-17ec11482f243379.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1450<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 456 - Secure and interchangeable hash algorithm</h1><div class="page__meta"><time dateTime="2025-09-26 22:05:49+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0456/">PEP 456 - Secure and interchangeable hash algorithm</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 27-Sep-2013</p>
</blockquote>
<h2>PEP 456 – 안전하고 상호 교환 가능한 해시 알고리즘 (Secure and interchangeable hash algorithm)</h2>
<h3>초록 (Abstract)</h3>
<p>이 PEP는 해시 무작위화(hash randomization) 문제를 영구적으로 해결하기 위해 기본 문자열(string) 및 바이트(bytes) 해시 알고리즘으로 SipHash를 도입할 것을 제안합니다. 또한, 해시 코드를 통합하고 쉽게 상호 교환할 수 있도록 Python의 C 코드에 대한 수정 사항도 제안합니다.</p>
<h3>도입 배경 (Rationale)</h3>
<p>최근의 노력에도 불구하고, CPython은 여전히 해시 충돌 서비스 거부(DoS) 공격(hash collision DoS attacks)에 취약합니다. 현재의 해시 알고리즘과 그 무작위화는 공격에 대해 탄력적이지 않습니다. 적절한 암호화 해시 함수만이 비밀 무작위화 키(secret randomization keys)의 추출을 막을 수 있습니다. Python 기반 서비스에 대한 실제 공격 사례는 아직 보고되지 않았지만, 이 약점은 반드시 해결되어야 합니다. Jean-Philippe Aumasson과 Daniel J. Bernstein은 현재 구현의 시드(seed)를 복구하는 방법을 이미 시연했습니다.</p>
<p>또한, 현재의 해시 알고리즘은 하드코딩(hard-coded)되어 있으며, 바이트(bytes)와 세 가지 다른 유니코드 표현(UCS1, UCS2, UCS4)에 대해 여러 번 구현되어 있습니다. 이로 인해 임베더(embedders)가 인터프리터의 많은 부분을 패치하고 재컴파일하지 않고는 다른 구현으로 교체하는 것이 불가능합니다. 임베더는 더 적합한 해시 함수를 선택하기를 원할 수도 있습니다.</p>
<p>마지막으로, 현재의 구현 코드는 성능이 좋지 않습니다. 일반적인 경우 사이클당 1~2바이트만 처리합니다. 최신 64비트 프로세서에서는 코드를 쉽게 조정하여 한 번에 8바이트를 처리할 수 있습니다.</p>
<p>이 PEP는 문자열(strings) 및 바이트(bytes)의 해시 코드에 세 가지 주요 변경 사항을 제안합니다:</p>
<ol>
<li><strong>SipHash 도입</strong>: 암호화 속성에도 불구하고 빠르고 작은 SipHash가 기본 해시 알고리즘으로 도입됩니다. 잘 알려진 보안 및 암호화 전문가들이 설계했기 때문에 가까운 미래에도 안전하다고 가정할 수 있습니다. 64비트 데이터 타입이 없는 플랫폼을 위해 기존 FNV 코드는 유지됩니다. 이 알고리즘은 사이클당 더 큰 청크(chunks)를 처리하도록 최적화되었습니다.</li>
<li><strong>해시 함수 통합</strong>: 문자열(strings) 및 바이트(bytes)의 해시 계산은 <code>Objects/object.c</code> 및 <code>Objects/unicodeobject.c</code>에 있는 여러 전문화된 구현 대신 단일 API 함수로 이동합니다. 이 함수는 <code>void</code> 포인터와 길이를 받아 해시를 반환합니다.</li>
<li><strong>컴파일 시 알고리즘 선택</strong>: 알고리즘은 컴파일 시 선택할 수 있습니다. FNV는 모든 플랫폼에서 존재함을 보장합니다. SipHash는 대부분의 최신 시스템에서 사용할 수 있습니다.</li>
</ol>
<h3>해시 함수 요구사항 (Requirements for a hash function)</h3>
<p>새로운 해시 함수는 다음 요구사항을 충족해야 합니다:</p>
<ul>
<li>1바이트부터 최대 <code>ssize_t</code> 값까지 임의로 큰 메모리 블록을 해시할 수 있어야 합니다.</li>
<li>32비트 플랫폼에서는 최소 32비트, 64비트 플랫폼에서는 최소 64비트를 생성해야 합니다.</li>
<li><code>hash(memoryview)</code>를 지원하기 위해 정렬되지 않은 메모리(unaligned memory)의 해시를 지원해야 합니다.</li>
<li>입력 길이가 결과에 영향을 미치는 것이 강력히 권장됩니다. (예: <code>hash(b'\00') != hash(b'\x00\x00')</code>)</li>
</ul>
<p>내부 인터페이스 코드는 길이가 0인 입력 및 반환 값 <code>-1</code>에 대한 특수 사례를 구현합니다. 길이가 0인 입력은 해시 값 <code>0</code>에 매핑되고, 출력 <code>-1</code>은 <code>-2</code>에 매핑됩니다.</p>
<h3>수정된 FNV를 사용한 현재 구현 (Current implementation with modified FNV)</h3>
<p>CPython은 현재 Fowler-Noll-Vo 해시 함수(FNV)의 변형을 사용합니다. 이 변형은 일반적인 문자열에 대한 해시 충돌의 양과 비용을 줄이기 위해 수정되었습니다. 문자열의 첫 번째 문자는 두 번 추가되는데, 첫 번째는 7비트 시프트(bit shift)와 함께 추가됩니다. 입력 문자열의 길이는 최종 값과 XOR-ed 됩니다. 원래 FNV 알고리즘에서 벗어난 두 가지 모두 짧은 문자열에 대한 해시 충돌의 양을 줄입니다.</p>
<p>최근 [issue13703]에 따라 해시 값을 무작위화하기 위한 시도로 무작위 접두사(prefix)와 접미사(suffix)가 추가되었습니다. 해시 비밀(hash secret)을 보호하기 위해 코드는 여전히 길이가 0인 입력에 대해 <code>0</code>을 반환합니다.</p>
<p>FNV는 암호화 속성이 없는 간단한 곱셈 및 XOR 알고리즘입니다. 무작위화는 초기 해시 코드의 일부가 아니었지만, oCERT-2011-003 [ocert]에서 설명된 바와 같이 해시 충돌 공격에 대한 방어책으로 추가되었습니다. FNV는 암호화 해시 알고리즘이 아니고 <code>dict</code> 구현은 사이드 채널 분석(side channel analysis)에 대해 강화되지 않았기 때문에, 무작위화 비밀은 원격 공격자에 의해 계산될 수 있습니다. 이 PEP의 작성자는 비암호화 해시 함수의 본질상 비밀을 숨기는 것이 불가능하다고 강력히 믿습니다.</p>
<h3>검토된 해싱 알고리즘 (Examined hashing algorithms)</h3>
<p>이 PEP의 작성자는 현대적이고 빠르며 최첨단으로 간주되는 여러 해싱 알고리즘을 연구했습니다.</p>
<ul>
<li><strong>SipHash</strong>: 128비트 시드(seed)와 64비트 출력을 가진 암호화 의사 난수 함수(cryptographic pseudo random function)입니다. 짧은 메시지에 대한 속도에 최적화되어 있으며, 네트워크 트래픽 인증 및 해시 플러딩 DoS 공격(hash-flooding DoS attacks) 방어와 같은 응용 분야를 목표로 합니다. Ruby, Perl, OpenDNS, Rust, Redis, FreeBSD 등에서 사용됩니다. SipHash는 속도와 보안의 최상의 조합을 제공합니다.</li>
<li><strong>MurmurHash</strong>: Austin Appleby가 개발한 비암호화 키 기반 해시 함수(non-cryptographic keyed hash function)입니다. Murmur3은 최신이며 빠른 MurmurHash의 변형입니다. 그러나 Aumasson, Bernstein 및 Boßlet은 Murmur3이 해시 충돌 공격에 탄력적이지 않다는 것을 보여주었습니다.</li>
<li><strong>CityHash</strong>: Geoff Pike와 Jyrki Alakuijala가 Google을 위해 개발한 비암호화 해시 함수입니다. MurmurHash와 마찬가지로 CityHash에서도 비슷한 취약점이 발견되었습니다.</li>
<li><strong>DJBX33A</strong>: Daniel J. Bernstein의 매우 간단한 곱셈 및 덧셈 알고리즘입니다. 빠르고 설정 비용이 낮지만 해시 충돌 공격에 안전하지 않습니다. 작은 문자열 해싱 최적화에 적합할 수 있습니다.</li>
<li><strong>기타(Other)</strong>: HMAC, MD5, SHA-1 또는 SHA-2와 같은 암호화 알고리즘은 너무 느리고 설정 및 마무리 비용이 높으므로 이 목적에 적합하지 않다고 간주되었습니다.</li>
</ul>
<p>결론적으로, SipHash는 속도와 보안의 최상의 조합을 제공합니다. 다른 주요 프로젝트의 개발자들도 동일한 결론에 도달했습니다.</p>
<h3>작은 문자열 최적화 (Small string optimization)</h3>
<p>SipHash24와 같은 해시 함수는 초기화 및 마무리 코드가 비용이 많이 들어 매우 짧은 문자열의 경우 알고리즘 속도를 지배할 수 있습니다. 반면에 Python은 짧은 문자열의 해시 값을 매우 자주 계산합니다. 특히 작은 문자열 해싱을 위한 간단하고 빠른 함수는 성능에 측정 가능한 영향을 미칠 수 있습니다.</p>
<p>그러나 DJBX33A와 같은 빠른 함수는 SipHash24만큼 안전하지 않습니다. 약 5~7바이트에서 잘라내기(cutoff)를 설정하면 적절한 안전 마진과 속도 향상을 동시에 제공할 수 있습니다. PEP의 참조 구현은 <code>Py_HASH_CUTOFF</code>를 사용하여 이러한 잘라내기를 제공합니다. 이 최적화는 여러 가지 이유로 기본적으로 비활성화되어 있습니다.</p>
<h3>C API 추가 (C API additions)</h3>
<p>모든 C API 확장 수정은 안정적인 API(stable API)의 일부가 아닙니다.</p>
<ul>
<li><strong>hash secret</strong>: <code>_Py_HashSecret_t</code> 타입이 SipHash에 필요한 두 개의 64비트 unsigned integer 키를 지원하도록 변경됩니다. 이는 모든 아키텍처에서 24바이트의 보장된 크기를 가진 유니온(union)으로 정의됩니다.</li>
<li><strong>hash function definition</strong>: 해시 함수 포인터, 이름, 해시 값의 내부 크기, 시드 입력의 크기를 포함하는 <code>PyHash_FuncDef</code> 구조체가 추가됩니다.</li>
<li><strong>autoconf</strong>: <code>configure</code> 스크립트에 새로운 테스트가 추가되어 정렬된 메모리 접근(aligned memory access)이 필요한 플랫폼을 감지합니다. 또한, <code>---with-hash-algorithm</code> 옵션을 통해 사용자가 컴파일 시 해시 알고리즘을 선택할 수 있도록 합니다.</li>
<li><strong>hash function selection</strong>: <code>Py_HASH_ALGORITHM</code> 매크로의 값에 따라 내부적으로 사용될 해시 알고리즘이 정의됩니다. <code>Py_HASH_SIPHASH24</code>, <code>Py_HASH_FNV</code> 또는 <code>Py_HASH_EXTERNAL</code> 중 하나로 설정될 수 있습니다. <code>Py_HASH_EXTERNAL</code>은 제3자가 컴파일 시 자신만의 구현을 제공할 수 있도록 합니다.</li>
</ul>
<h3>Python API 추가 (Python API addition)</h3>
<ul>
<li><strong>sys module</strong>: <code>sys.hash_info</code> 구조 시퀀스에 활성 해시 알고리즘 및 그 속성을 반영하는 더 많은 필드가 추가됩니다. (예: <code>algorithm</code>, <code>hash_bits</code>, <code>seed_bits</code>, <code>cutoff</code>).</li>
</ul>
<h3>C 코드의 필수 수정사항 (Necessary modifications to C code)</h3>
<ul>
<li><code>_Py_HashBytes()</code> (<code>Objects/object.c</code>): 바이트(bytes), <code>memoryview</code>, <code>datetime</code> 클래스를 위한 해싱 코드를 제공하는 내부 헬퍼(helper) 함수입니다. 이 함수는 <code>Python/pyhash.c</code>로 이동하고 <code>PyHash_Func.hash()</code>를 통해 해시 함수를 사용하도록 수정됩니다. 함수의 시그니처(signature)는 첫 번째 인수로 <code>const void *</code>를 받도록 변경됩니다.</li>
<li><code>bytes_hash()</code> (<code>Objects/bytesobject.c</code>), <code>memory_hash()</code> (<code>Objects/memoryobject.c</code>): <code>_Py_HashBytes</code>를 계속 사용하지만, 타입 캐스트(type cast) 없이 사용하도록 수정됩니다. <code>memory_hash()</code>는 향후 정렬되지 않은 메모리 세그먼트(unaligned memory segments)의 해시를 지원해야 하는 유일한 함수입니다.</li>
<li><code>unicode_hash()</code> (<code>Objects/unicodeobject.c</code>): 유니코드(unicode)의 <code>tp_hash</code> 슬롯 함수를 제공합니다. <code>PyUnicode_GET_LENGTH</code>가 유니코드 문자열의 길이가 아닌 옥텟(octets) 단위의 크기를 반환하므로, 길이는 내부 유니코드 종류의 크기와 곱해져야 합니다.</li>
<li><code>generic_hash()</code> (<code>Modules/_datetimemodule.c</code>): <code>date</code>, <code>time</code>, <code>datetime</code> 타입의 <code>tp_hash</code> 슬롯을 위한 <code>_Py_HashBytes</code>의 래퍼(wrapper) 역할을 합니다. <code>date</code>, <code>time</code>, <code>datetime</code> 타입 구조체의 데이터 멤버는 <code>void*</code> 정렬이 되어 있지 않아 <code>memcpy()</code>를 통해 정렬된 버퍼로 복사하여 해결할 수 있습니다.</li>
</ul>
<h3>성능 (Performance)</h3>
<p>일반적으로 SipHash24를 사용하는 PEP 456 코드는 FNV를 사용하는 기존 코드만큼 빠릅니다. SipHash24는 최신 컴파일러, CPU 및 대형 L1 캐시를 더 잘 활용하는 것으로 보입니다. 여러 벤치마크는 Intel Core i5 및 Intel Core i7 프로세서와 같은 64비트 CPU에서 약간의 속도 향상을 보여줍니다. 32비트 빌드 및 AMD Athlon X2와 같은 구형 CPU에서의 벤치마크는 SipHash24에서 약간 더 느립니다. 성능 향상 또는 감소는 너무 작아서 어떤 애플리케이션 코드에도 영향을 미치지 않을 것으로 예상됩니다.</p>
<h3>하위 호환성 (Backwards Compatibility)</h3>
<p>이 수정 사항은 기존 API를 변경하지 않습니다.
문자열(strings) 및 바이트(bytes)에 대한 <code>hash()</code>의 출력은 달라집니다. ASCII 유니코드(Unicode)와 ASCII 바이트(bytes)에 대한 해시 값은 동일하게 유지됩니다.</p>
<h3>해시 충돌 DoS에 대한 대체 방안 (Alternative counter measures against hash collision DoS)</h3>
<p>과거에 해시 충돌에 대한 세 가지 대체 방안이 논의되었지만, 이 PEP의 주제는 아닙니다.</p>
<ol>
<li><strong>해시 충돌 카운트</strong>: <code>dict</code>가 해시 충돌을 세어 너무 많은 충돌이 발생하면 예외를 발생시키는 방안입니다.</li>
<li><strong>새로운 데이터 구조 도입</strong>: 최악의 경우 <code>O(log n)</code> 동작을 가진 레드-블랙-트리(red-black-tree) 또는 접두사 트리(prefix trees, trie)와 같은 새로운 데이터 구조를 도입하여 해시 충돌 공격의 근본 원인을 제거하는 방안입니다.</li>
</ol>
<h3>논의 (Discussion)</h3>
<ul>
<li><strong>Pluggable (플러그인 방식)</strong>: 이 PEP의 첫 번째 초안은 런타임에 해시 알고리즘을 플러그인 방식으로 만들었습니다. 하지만 여러 핵심 커미터(core committers)에 의해 불필요한 복잡성으로 간주되어 이후 버전에서는 컴파일 타임(compile time) 설정으로 변경되었습니다.</li>
<li><strong>Non-aligned memory access (정렬되지 않은 메모리 접근)</strong>: SipHash24 구현은 정렬되지 않은 메모리 문제를 무시하므로 정수 타입의 정렬을 요구하는 아키텍처에서는 작동하지 않는다는 비판을 받았습니다. 이 PEP는 이러한 특수 사례를 의도적으로 무시하며, 이러한 플랫폼에서는 SipHash24를 지원하지 않습니다. X86, X86_64, ARMv6+와 같은 모든 주요 플랫폼은 최소한의 또는 전혀 속도 영향 없이 정렬되지 않은 메모리를 처리할 수 있습니다.</li>
<li><strong>ASCII str / bytes hash collision</strong>: PEP 393 구현 이후, 바이트(bytes)와 ASCII 텍스트는 동일한 메모리 레이아웃을 가집니다. 따라서 새로운 해싱 API는 <code>hash("ascii string") == hash(b"ascii string")</code>이라는 불변성을 유지합니다. 동일한 해시 값은 해시 충돌을 초래하며, 이는 혼합된 키(mixed keys)를 가진 <code>dict</code> 및 <code>set</code>에 대해 약간의 속도 저하를 유발합니다. 이 PEP는 해시 값을 변경하지 않습니다.</li>
</ul>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-17ec11482f243379.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/456\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"qd33V0IpW4K1wJhro15P-\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/456/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/456\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"456\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/456\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T3ebf,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0456/\"\u003ePEP 456 - Secure and interchangeable hash algorithm\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 27-Sep-2013\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 456 – 안전하고 상호 교환 가능한 해시 알고리즘 (Secure and interchangeable hash algorithm)\u003c/h2\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 해시 무작위화(hash randomization) 문제를 영구적으로 해결하기 위해 기본 문자열(string) 및 바이트(bytes) 해시 알고리즘으로 SipHash를 도입할 것을 제안합니다. 또한, 해시 코드를 통합하고 쉽게 상호 교환할 수 있도록 Python의 C 코드에 대한 수정 사항도 제안합니다.\u003c/p\u003e\n\u003ch3\u003e도입 배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003e최근의 노력에도 불구하고, CPython은 여전히 해시 충돌 서비스 거부(DoS) 공격(hash collision DoS attacks)에 취약합니다. 현재의 해시 알고리즘과 그 무작위화는 공격에 대해 탄력적이지 않습니다. 적절한 암호화 해시 함수만이 비밀 무작위화 키(secret randomization keys)의 추출을 막을 수 있습니다. Python 기반 서비스에 대한 실제 공격 사례는 아직 보고되지 않았지만, 이 약점은 반드시 해결되어야 합니다. Jean-Philippe Aumasson과 Daniel J. Bernstein은 현재 구현의 시드(seed)를 복구하는 방법을 이미 시연했습니다.\u003c/p\u003e\n\u003cp\u003e또한, 현재의 해시 알고리즘은 하드코딩(hard-coded)되어 있으며, 바이트(bytes)와 세 가지 다른 유니코드 표현(UCS1, UCS2, UCS4)에 대해 여러 번 구현되어 있습니다. 이로 인해 임베더(embedders)가 인터프리터의 많은 부분을 패치하고 재컴파일하지 않고는 다른 구현으로 교체하는 것이 불가능합니다. 임베더는 더 적합한 해시 함수를 선택하기를 원할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 현재의 구현 코드는 성능이 좋지 않습니다. 일반적인 경우 사이클당 1~2바이트만 처리합니다. 최신 64비트 프로세서에서는 코드를 쉽게 조정하여 한 번에 8바이트를 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 문자열(strings) 및 바이트(bytes)의 해시 코드에 세 가지 주요 변경 사항을 제안합니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eSipHash 도입\u003c/strong\u003e: 암호화 속성에도 불구하고 빠르고 작은 SipHash가 기본 해시 알고리즘으로 도입됩니다. 잘 알려진 보안 및 암호화 전문가들이 설계했기 때문에 가까운 미래에도 안전하다고 가정할 수 있습니다. 64비트 데이터 타입이 없는 플랫폼을 위해 기존 FNV 코드는 유지됩니다. 이 알고리즘은 사이클당 더 큰 청크(chunks)를 처리하도록 최적화되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e해시 함수 통합\u003c/strong\u003e: 문자열(strings) 및 바이트(bytes)의 해시 계산은 \u003ccode\u003eObjects/object.c\u003c/code\u003e 및 \u003ccode\u003eObjects/unicodeobject.c\u003c/code\u003e에 있는 여러 전문화된 구현 대신 단일 API 함수로 이동합니다. 이 함수는 \u003ccode\u003evoid\u003c/code\u003e 포인터와 길이를 받아 해시를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e컴파일 시 알고리즘 선택\u003c/strong\u003e: 알고리즘은 컴파일 시 선택할 수 있습니다. FNV는 모든 플랫폼에서 존재함을 보장합니다. SipHash는 대부분의 최신 시스템에서 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e해시 함수 요구사항 (Requirements for a hash function)\u003c/h3\u003e\n\u003cp\u003e새로운 해시 함수는 다음 요구사항을 충족해야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1바이트부터 최대 \u003ccode\u003essize_t\u003c/code\u003e 값까지 임의로 큰 메모리 블록을 해시할 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e32비트 플랫폼에서는 최소 32비트, 64비트 플랫폼에서는 최소 64비트를 생성해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehash(memoryview)\u003c/code\u003e를 지원하기 위해 정렬되지 않은 메모리(unaligned memory)의 해시를 지원해야 합니다.\u003c/li\u003e\n\u003cli\u003e입력 길이가 결과에 영향을 미치는 것이 강력히 권장됩니다. (예: \u003ccode\u003ehash(b'\\00') != hash(b'\\x00\\x00')\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e내부 인터페이스 코드는 길이가 0인 입력 및 반환 값 \u003ccode\u003e-1\u003c/code\u003e에 대한 특수 사례를 구현합니다. 길이가 0인 입력은 해시 값 \u003ccode\u003e0\u003c/code\u003e에 매핑되고, 출력 \u003ccode\u003e-1\u003c/code\u003e은 \u003ccode\u003e-2\u003c/code\u003e에 매핑됩니다.\u003c/p\u003e\n\u003ch3\u003e수정된 FNV를 사용한 현재 구현 (Current implementation with modified FNV)\u003c/h3\u003e\n\u003cp\u003eCPython은 현재 Fowler-Noll-Vo 해시 함수(FNV)의 변형을 사용합니다. 이 변형은 일반적인 문자열에 대한 해시 충돌의 양과 비용을 줄이기 위해 수정되었습니다. 문자열의 첫 번째 문자는 두 번 추가되는데, 첫 번째는 7비트 시프트(bit shift)와 함께 추가됩니다. 입력 문자열의 길이는 최종 값과 XOR-ed 됩니다. 원래 FNV 알고리즘에서 벗어난 두 가지 모두 짧은 문자열에 대한 해시 충돌의 양을 줄입니다.\u003c/p\u003e\n\u003cp\u003e최근 [issue13703]에 따라 해시 값을 무작위화하기 위한 시도로 무작위 접두사(prefix)와 접미사(suffix)가 추가되었습니다. 해시 비밀(hash secret)을 보호하기 위해 코드는 여전히 길이가 0인 입력에 대해 \u003ccode\u003e0\u003c/code\u003e을 반환합니다.\u003c/p\u003e\n\u003cp\u003eFNV는 암호화 속성이 없는 간단한 곱셈 및 XOR 알고리즘입니다. 무작위화는 초기 해시 코드의 일부가 아니었지만, oCERT-2011-003 [ocert]에서 설명된 바와 같이 해시 충돌 공격에 대한 방어책으로 추가되었습니다. FNV는 암호화 해시 알고리즘이 아니고 \u003ccode\u003edict\u003c/code\u003e 구현은 사이드 채널 분석(side channel analysis)에 대해 강화되지 않았기 때문에, 무작위화 비밀은 원격 공격자에 의해 계산될 수 있습니다. 이 PEP의 작성자는 비암호화 해시 함수의 본질상 비밀을 숨기는 것이 불가능하다고 강력히 믿습니다.\u003c/p\u003e\n\u003ch3\u003e검토된 해싱 알고리즘 (Examined hashing algorithms)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 작성자는 현대적이고 빠르며 최첨단으로 간주되는 여러 해싱 알고리즘을 연구했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSipHash\u003c/strong\u003e: 128비트 시드(seed)와 64비트 출력을 가진 암호화 의사 난수 함수(cryptographic pseudo random function)입니다. 짧은 메시지에 대한 속도에 최적화되어 있으며, 네트워크 트래픽 인증 및 해시 플러딩 DoS 공격(hash-flooding DoS attacks) 방어와 같은 응용 분야를 목표로 합니다. Ruby, Perl, OpenDNS, Rust, Redis, FreeBSD 등에서 사용됩니다. SipHash는 속도와 보안의 최상의 조합을 제공합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMurmurHash\u003c/strong\u003e: Austin Appleby가 개발한 비암호화 키 기반 해시 함수(non-cryptographic keyed hash function)입니다. Murmur3은 최신이며 빠른 MurmurHash의 변형입니다. 그러나 Aumasson, Bernstein 및 Boßlet은 Murmur3이 해시 충돌 공격에 탄력적이지 않다는 것을 보여주었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCityHash\u003c/strong\u003e: Geoff Pike와 Jyrki Alakuijala가 Google을 위해 개발한 비암호화 해시 함수입니다. MurmurHash와 마찬가지로 CityHash에서도 비슷한 취약점이 발견되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDJBX33A\u003c/strong\u003e: Daniel J. Bernstein의 매우 간단한 곱셈 및 덧셈 알고리즘입니다. 빠르고 설정 비용이 낮지만 해시 충돌 공격에 안전하지 않습니다. 작은 문자열 해싱 최적화에 적합할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e기타(Other)\u003c/strong\u003e: HMAC, MD5, SHA-1 또는 SHA-2와 같은 암호화 알고리즘은 너무 느리고 설정 및 마무리 비용이 높으므로 이 목적에 적합하지 않다고 간주되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e결론적으로, SipHash는 속도와 보안의 최상의 조합을 제공합니다. 다른 주요 프로젝트의 개발자들도 동일한 결론에 도달했습니다.\u003c/p\u003e\n\u003ch3\u003e작은 문자열 최적화 (Small string optimization)\u003c/h3\u003e\n\u003cp\u003eSipHash24와 같은 해시 함수는 초기화 및 마무리 코드가 비용이 많이 들어 매우 짧은 문자열의 경우 알고리즘 속도를 지배할 수 있습니다. 반면에 Python은 짧은 문자열의 해시 값을 매우 자주 계산합니다. 특히 작은 문자열 해싱을 위한 간단하고 빠른 함수는 성능에 측정 가능한 영향을 미칠 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 DJBX33A와 같은 빠른 함수는 SipHash24만큼 안전하지 않습니다. 약 5~7바이트에서 잘라내기(cutoff)를 설정하면 적절한 안전 마진과 속도 향상을 동시에 제공할 수 있습니다. PEP의 참조 구현은 \u003ccode\u003ePy_HASH_CUTOFF\u003c/code\u003e를 사용하여 이러한 잘라내기를 제공합니다. 이 최적화는 여러 가지 이유로 기본적으로 비활성화되어 있습니다.\u003c/p\u003e\n\u003ch3\u003eC API 추가 (C API additions)\u003c/h3\u003e\n\u003cp\u003e모든 C API 확장 수정은 안정적인 API(stable API)의 일부가 아닙니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ehash secret\u003c/strong\u003e: \u003ccode\u003e_Py_HashSecret_t\u003c/code\u003e 타입이 SipHash에 필요한 두 개의 64비트 unsigned integer 키를 지원하도록 변경됩니다. 이는 모든 아키텍처에서 24바이트의 보장된 크기를 가진 유니온(union)으로 정의됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ehash function definition\u003c/strong\u003e: 해시 함수 포인터, 이름, 해시 값의 내부 크기, 시드 입력의 크기를 포함하는 \u003ccode\u003ePyHash_FuncDef\u003c/code\u003e 구조체가 추가됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eautoconf\u003c/strong\u003e: \u003ccode\u003econfigure\u003c/code\u003e 스크립트에 새로운 테스트가 추가되어 정렬된 메모리 접근(aligned memory access)이 필요한 플랫폼을 감지합니다. 또한, \u003ccode\u003e---with-hash-algorithm\u003c/code\u003e 옵션을 통해 사용자가 컴파일 시 해시 알고리즘을 선택할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ehash function selection\u003c/strong\u003e: \u003ccode\u003ePy_HASH_ALGORITHM\u003c/code\u003e 매크로의 값에 따라 내부적으로 사용될 해시 알고리즘이 정의됩니다. \u003ccode\u003ePy_HASH_SIPHASH24\u003c/code\u003e, \u003ccode\u003ePy_HASH_FNV\u003c/code\u003e 또는 \u003ccode\u003ePy_HASH_EXTERNAL\u003c/code\u003e 중 하나로 설정될 수 있습니다. \u003ccode\u003ePy_HASH_EXTERNAL\u003c/code\u003e은 제3자가 컴파일 시 자신만의 구현을 제공할 수 있도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ePython API 추가 (Python API addition)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003esys module\u003c/strong\u003e: \u003ccode\u003esys.hash_info\u003c/code\u003e 구조 시퀀스에 활성 해시 알고리즘 및 그 속성을 반영하는 더 많은 필드가 추가됩니다. (예: \u003ccode\u003ealgorithm\u003c/code\u003e, \u003ccode\u003ehash_bits\u003c/code\u003e, \u003ccode\u003eseed_bits\u003c/code\u003e, \u003ccode\u003ecutoff\u003c/code\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eC 코드의 필수 수정사항 (Necessary modifications to C code)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e_Py_HashBytes()\u003c/code\u003e (\u003ccode\u003eObjects/object.c\u003c/code\u003e): 바이트(bytes), \u003ccode\u003ememoryview\u003c/code\u003e, \u003ccode\u003edatetime\u003c/code\u003e 클래스를 위한 해싱 코드를 제공하는 내부 헬퍼(helper) 함수입니다. 이 함수는 \u003ccode\u003ePython/pyhash.c\u003c/code\u003e로 이동하고 \u003ccode\u003ePyHash_Func.hash()\u003c/code\u003e를 통해 해시 함수를 사용하도록 수정됩니다. 함수의 시그니처(signature)는 첫 번째 인수로 \u003ccode\u003econst void *\u003c/code\u003e를 받도록 변경됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebytes_hash()\u003c/code\u003e (\u003ccode\u003eObjects/bytesobject.c\u003c/code\u003e), \u003ccode\u003ememory_hash()\u003c/code\u003e (\u003ccode\u003eObjects/memoryobject.c\u003c/code\u003e): \u003ccode\u003e_Py_HashBytes\u003c/code\u003e를 계속 사용하지만, 타입 캐스트(type cast) 없이 사용하도록 수정됩니다. \u003ccode\u003ememory_hash()\u003c/code\u003e는 향후 정렬되지 않은 메모리 세그먼트(unaligned memory segments)의 해시를 지원해야 하는 유일한 함수입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunicode_hash()\u003c/code\u003e (\u003ccode\u003eObjects/unicodeobject.c\u003c/code\u003e): 유니코드(unicode)의 \u003ccode\u003etp_hash\u003c/code\u003e 슬롯 함수를 제공합니다. \u003ccode\u003ePyUnicode_GET_LENGTH\u003c/code\u003e가 유니코드 문자열의 길이가 아닌 옥텟(octets) 단위의 크기를 반환하므로, 길이는 내부 유니코드 종류의 크기와 곱해져야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egeneric_hash()\u003c/code\u003e (\u003ccode\u003eModules/_datetimemodule.c\u003c/code\u003e): \u003ccode\u003edate\u003c/code\u003e, \u003ccode\u003etime\u003c/code\u003e, \u003ccode\u003edatetime\u003c/code\u003e 타입의 \u003ccode\u003etp_hash\u003c/code\u003e 슬롯을 위한 \u003ccode\u003e_Py_HashBytes\u003c/code\u003e의 래퍼(wrapper) 역할을 합니다. \u003ccode\u003edate\u003c/code\u003e, \u003ccode\u003etime\u003c/code\u003e, \u003ccode\u003edatetime\u003c/code\u003e 타입 구조체의 데이터 멤버는 \u003ccode\u003evoid*\u003c/code\u003e 정렬이 되어 있지 않아 \u003ccode\u003ememcpy()\u003c/code\u003e를 통해 정렬된 버퍼로 복사하여 해결할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e성능 (Performance)\u003c/h3\u003e\n\u003cp\u003e일반적으로 SipHash24를 사용하는 PEP 456 코드는 FNV를 사용하는 기존 코드만큼 빠릅니다. SipHash24는 최신 컴파일러, CPU 및 대형 L1 캐시를 더 잘 활용하는 것으로 보입니다. 여러 벤치마크는 Intel Core i5 및 Intel Core i7 프로세서와 같은 64비트 CPU에서 약간의 속도 향상을 보여줍니다. 32비트 빌드 및 AMD Athlon X2와 같은 구형 CPU에서의 벤치마크는 SipHash24에서 약간 더 느립니다. 성능 향상 또는 감소는 너무 작아서 어떤 애플리케이션 코드에도 영향을 미치지 않을 것으로 예상됩니다.\u003c/p\u003e\n\u003ch3\u003e하위 호환성 (Backwards Compatibility)\u003c/h3\u003e\n\u003cp\u003e이 수정 사항은 기존 API를 변경하지 않습니다.\r\n문자열(strings) 및 바이트(bytes)에 대한 \u003ccode\u003ehash()\u003c/code\u003e의 출력은 달라집니다. ASCII 유니코드(Unicode)와 ASCII 바이트(bytes)에 대한 해시 값은 동일하게 유지됩니다.\u003c/p\u003e\n\u003ch3\u003e해시 충돌 DoS에 대한 대체 방안 (Alternative counter measures against hash collision DoS)\u003c/h3\u003e\n\u003cp\u003e과거에 해시 충돌에 대한 세 가지 대체 방안이 논의되었지만, 이 PEP의 주제는 아닙니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e해시 충돌 카운트\u003c/strong\u003e: \u003ccode\u003edict\u003c/code\u003e가 해시 충돌을 세어 너무 많은 충돌이 발생하면 예외를 발생시키는 방안입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e새로운 데이터 구조 도입\u003c/strong\u003e: 최악의 경우 \u003ccode\u003eO(log n)\u003c/code\u003e 동작을 가진 레드-블랙-트리(red-black-tree) 또는 접두사 트리(prefix trees, trie)와 같은 새로운 데이터 구조를 도입하여 해시 충돌 공격의 근본 원인을 제거하는 방안입니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e논의 (Discussion)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePluggable (플러그인 방식)\u003c/strong\u003e: 이 PEP의 첫 번째 초안은 런타임에 해시 알고리즘을 플러그인 방식으로 만들었습니다. 하지만 여러 핵심 커미터(core committers)에 의해 불필요한 복잡성으로 간주되어 이후 버전에서는 컴파일 타임(compile time) 설정으로 변경되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNon-aligned memory access (정렬되지 않은 메모리 접근)\u003c/strong\u003e: SipHash24 구현은 정렬되지 않은 메모리 문제를 무시하므로 정수 타입의 정렬을 요구하는 아키텍처에서는 작동하지 않는다는 비판을 받았습니다. 이 PEP는 이러한 특수 사례를 의도적으로 무시하며, 이러한 플랫폼에서는 SipHash24를 지원하지 않습니다. X86, X86_64, ARMv6+와 같은 모든 주요 플랫폼은 최소한의 또는 전혀 속도 영향 없이 정렬되지 않은 메모리를 처리할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eASCII str / bytes hash collision\u003c/strong\u003e: PEP 393 구현 이후, 바이트(bytes)와 ASCII 텍스트는 동일한 메모리 레이아웃을 가집니다. 따라서 새로운 해싱 API는 \u003ccode\u003ehash(\"ascii string\") == hash(b\"ascii string\")\u003c/code\u003e이라는 불변성을 유지합니다. 동일한 해시 값은 해시 충돌을 초래하며, 이는 혼합된 키(mixed keys)를 가진 \u003ccode\u003edict\u003c/code\u003e 및 \u003ccode\u003eset\u003c/code\u003e에 대해 약간의 속도 저하를 유발합니다. 이 PEP는 해시 값을 변경하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1450,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 456 - Secure and interchangeable hash algorithm\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:05:49+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>