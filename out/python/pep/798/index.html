<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/773b243a13a00265.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/app/layout-f2c168e996e2da30.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2335<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Draft] PEP 798 - Unpacking in Comprehensions</h1><div class="page__meta"><time dateTime="2025-09-27 14:08:32+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0798/">PEP 798 - Unpacking in Comprehensions</a></p>
<p><strong>상태:</strong> Draft | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 19-Jul-2025</p>
</blockquote>
<p>PEP 798 – Comprehension 내 언패킹 (Unpacking)</p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 <code>list</code>, <code>set</code>, <code>dictionary</code> Comprehension (컴프리헨션) 및 <code>generator expression</code> (제너레이터 표현식)을 확장하여 표현식 시작 부분에 언패킹(Unpacking) 표기법(<code>*</code> 및 <code>**</code>)을 허용할 것을 제안합니다. 이는 임의의 수의 iterable을 하나의 <code>list</code>, <code>set</code> 또는 <code>generator</code>로, 또는 임의의 수의 딕셔너리를 하나의 딕셔너리로 결합하는 간결한 방법을 제공합니다.</p>
<p>예시는 다음과 같습니다:</p>
<pre><code class="language-python">[*it for it in its] # 'its' 내의 iterable들을 연결한 list
{*it for it in its} # 'its' 내의 iterable들을 합집합(union)한 set
{**d for d in dicts} # 'dicts' 내의 딕셔너리들을 조합한 dict
(*it for it in its) # 'its' 내의 iterable들을 연결한 generator
</code></pre>
<h2>동기 (Motivation)</h2>
<p>PEP 448에 도입된 확장 언패킹 표기법(<code>*</code> 및 <code>**</code>)은 몇 개의 iterable 또는 딕셔너리를 쉽게 결합할 수 있도록 합니다.</p>
<pre><code class="language-python">[*it1, *it2, *it3] # 세 개의 iterable을 연결한 list
{*it1, *it2, *it3} # 세 개의 iterable을 합집합(union)한 set
{ **dict1, ** dict2, **dict3} # 세 개의 딕셔너리를 조합한 dict
</code></pre>
<p>하지만 임의의 수의 iterable을 유사하게 결합하려는 경우에는 동일한 방식으로 언패킹을 사용할 수 없습니다.</p>
<p>여러 iterable을 결합하는 몇 가지 기존 방법이 있습니다. 예를 들어, 명시적인 루프 구조와 내장된 결합 방법을 사용할 수 있습니다:</p>
<pre><code class="language-python">new_list = []
for it in its:
    new_list.extend(it)

new_set = set()
for it in its:
    new_set.update(it)

new_dict = {}
for d in dicts:
    new_dict.update(d)

def new_generator():
    for it in its:
        yield from it
</code></pre>
<p>또는 두 개의 루프를 사용하는 Comprehension으로 더 간결하게 표현할 수 있습니다:</p>
<pre><code class="language-python">[x for it in its for x in it]
{x for it in its for x in it}
{key: value for d in dicts for key, value in d.items()}
(x for it in its for x in it)
</code></pre>
<p><code>itertools.chain</code> 또는 <code>itertools.chain.from_iterable</code>을 사용할 수도 있습니다:</p>
<pre><code class="language-python">list(itertools.chain(*its))
set(itertools.chain(*its))
dict(itertools.chain(*(d.items() for d in dicts)))
itertools.chain(*its)
list(itertools.chain.from_iterable(its))
set(itertools.chain.from_iterable(its))
dict(itertools.chain.from_iterable(d.items() for d in dicts))
itertools.chain.from_iterable(its)
</code></pre>
<p>또는 <code>generator</code>를 제외한 모든 경우에 <code>functools.reduce</code>를 사용할 수 있습니다:</p>
<pre><code class="language-python">functools.reduce(operator.iconcat, its, (new_list := []))
functools.reduce(operator.ior, its, (new_set := set()))
functools.reduce(operator.ior, its, (new_dict := {}))
</code></pre>
<p>이 PEP는 Comprehension 내에서 언패킹 연산을 추가적인 대안으로 허용할 것을 제안합니다.</p>
<pre><code class="language-python">[*it for it in its] # 'its' 내의 iterable들을 연결한 list
{*it for it in its} # 'its' 내의 iterable들을 합집합(union)한 set
{**d for d in dicts} # 'dicts' 내의 딕셔너리들을 조합한 dict
(*it for it in its) # 'its' 내의 iterable들을 연결한 generator
</code></pre>
<p>이 제안은 비동기 Comprehension 및 <code>generator expression</code>에도 확장되어, 예를 들어 <code>(*ait async for ait in aits())</code>는 <code>(x async for ait in aits() for x in ait)</code>와 동일합니다.</p>
<h2>근거 (Rationale)</h2>
<p>iterable 객체들을 하나의 더 큰 객체로 결합하는 것은 흔한 작업입니다. 예를 들어, 리스트의 리스트를 평탄화(flattening)하는 방법에 대한 StackOverflow 게시물은 460만 회 조회되었습니다. 이처럼 흔한 작업임에도 불구하고, 현재 간결하게 수행할 수 있는 옵션들은 간접적인 수준을 요구하여 결과 코드를 읽고 이해하기 어렵게 만들 수 있습니다.</p>
<p>제안된 표기법은 간결하며(보조 변수의 사용과 반복을 피함), Comprehension과 언패킹 표기법 모두에 익숙한 프로그래머에게 직관적이고 친숙할 것으로 예상됩니다. 표준 라이브러리의 코드를 제안된 구문으로 더 명확하고 간결하게 다시 작성할 수 있는 예시는 <code>Code Examples</code> 섹션을 참조하십시오.</p>
<p>이 제안은 부분적으로 Python 프로그래밍 수업의 필기시험에서 동기를 얻었습니다. 여러 학생들이 Python에 이미 존재한다고 가정하고 이 표기법(특히 <code>set</code> 버전)을 솔루션에 사용했습니다. 이는 이 표기법이 초보자에게도 직관적임을 시사합니다. 반대로, 기존 구문인 <code>[x for it in its for x in it]</code>는 학생들이 종종 틀리는 부분이며, 많은 학생들이 <code>for</code> 절의 순서를 뒤바꾸는 경향이 있습니다.</p>
<p>또한, 이 PEP가 발표된 후 Reddit 게시물의 댓글 섹션은 이 제안에 대한 상당한 지지를 보여주며, 여기에 제안된 구문이 가독성이 좋고, 직관적이며, 유용하다는 점을 시사합니다.</p>
<h2>명세 (Specification)</h2>
<h3>구문 (Syntax)</h3>
<p>문법은 <code>list</code>/<code>set</code> Comprehension 및 <code>generator expression</code>에서 표현식 앞에 <code>*</code>를 허용하도록 변경되어야 합니다. 또한 <code>dictionary comprehension</code>의 대체 형식으로 <code>key: value</code> 쌍 대신 <code>double-starred</code> 표현식을 사용할 수 있도록 허용해야 합니다.</p>
<p>이는 <code>listcomp</code> 및 <code>setcomp</code> 규칙을 <code>named_expression</code> 대신 <code>star_named_expression</code>을 사용하도록 업데이트함으로써 달성할 수 있습니다:</p>
<pre><code>listcomp[expr_ty]:
    | '[' a=star_named_expression b=for_if_clauses ']'
setcomp[expr_ty]:
    | '{' a=star_named_expression b=for_if_clauses '}'
</code></pre>
<p><code>genexp</code> 규칙도 유사하게 <code>starred_expression</code>을 허용하도록 수정해야 합니다:</p>
<pre><code>genexp[expr_ty]:
    | '(' a=(assignment_expression | expression !':=' | starred_expression) b=for_if_clauses ')'
</code></pre>
<p><code>dictionary comprehension</code> 규칙도 이 새로운 형식을 허용하도록 조정해야 합니다:</p>
<pre><code>dictcomp[expr_ty]:
    | '{' a=double_starred_kvpair b=for_if_clauses '}'
</code></pre>
<p>함수 호출에서 인자 언패킹이 처리되는 방식에는 변경이 없어야 합니다. 즉, 함수에 유일한 인수로 제공되는 <code>generator expression</code>이 추가적인 중복 괄호를 필요로 하지 않는다는 일반 규칙은 유지되어야 합니다. 이는 예를 들어 <code>f(*x for x in it)</code>가 <code>f((*x for x in it))</code>와 동일함을 의미합니다. (<code>Starred Generators as Function Arguments</code> 섹션에서 더 자세한 논의를 참조하십시오).</p>
<p><code>*</code> 및 <code>**</code>는 Comprehension 내 표현식의 최상위 레벨에서만 허용되어야 합니다. (<code>Further Generalizing Unpacking Operators</code> 섹션에서 더 자세한 논의를 참조하십시오).</p>
<h3>의미론: List/Set/Dict Comprehension (Semantics: List/Set/Dict Comprehensions)</h3>
<p><code>list comprehension</code> 내에서 별표가 붙은 표현식 <code>[*expr for x in it]</code>의 의미는 각 표현식을 <code>iterable</code>로 취급하고, <code>[*expr1, *expr2, ...]</code>와 같이 명시적으로 나열된 것처럼 이들을 연결하는 것입니다. 유사하게, <code>{*expr for x in it}</code>는 <code>{*expr1, *expr2, ...}</code>와 같이 명시적으로 나열된 것처럼 <code>set union</code>을 형성합니다. 그리고 <code>{ **expr for x in it}</code>는 <code>{** expr1, **expr2, ...}</code>와 같이 명시적으로 나열된 것처럼 딕셔너리를 결합합니다. 이러한 연산은 이 방식으로 컬렉션을 결합하는 모든 동등한 의미론(예: 딕셔너리를 결합할 때 중복된 키의 경우 나중 값이 이전 값을 덮어쓰는 것 포함)을 유지해야 합니다.</p>
<p>다시 말해, 다음 Comprehension에 의해 생성된 객체들은:</p>
<pre><code class="language-python">new_list = [*expr for x in its]
new_set = {*expr for x in its}
new_dict = {**expr for d in dicts}
</code></pre>
<p>각각 다음 코드 조각에 의해 생성된 객체들과 동등해야 합니다:</p>
<pre><code class="language-python">new_list = []
for x in its:
    new_list.extend(expr)

new_set = set()
for x in its:
    new_set.update(expr)

new_dict = {}
for x in dicts:
    new_dict.update(expr)
</code></pre>
<h3>의미론: Generator Expression (Semantics: Generator Expressions)</h3>
<p>언패킹 구문을 사용하는 <code>generator expression</code>은 표현식에 의해 주어진 iterable들을 연결하여 값을 생성하는 새로운 <code>generator</code>를 형성해야 합니다. 특히, 동작은 다음 코드와 동일하게 정의됩니다:</p>
<pre><code class="language-python"># g = (*expr for x in it) 와 동일
def generator():
    for x in it:
        yield from expr
g = generator()
</code></pre>
<p><code>yield from</code>은 비동기 <code>generator</code> 내에서 허용되지 않으므로 (PEP 525의 <code>Asynchronous yield from</code> 섹션 참조), <code>(*expr async for x in ait())</code>의 동등한 표현은 다음과 같습니다 (물론 이 새로운 형식은 루프 변수 <code>i</code>를 정의하거나 참조하지 않아야 합니다):</p>
<pre><code class="language-python"># g = (*expr async for x in ait()) 와 동일
async def generator():
    async for x in ait():
        for i in expr:
            yield i
g = generator()
</code></pre>
<p>이러한 의미론의 세부 사항은 미래에 재검토되어야 합니다. 특히 비동기 <code>generator</code>가 <code>yield from</code>을 지원하게 된다면 (<code>async</code> 변형이 명시적인 루프 대신 <code>yield from</code>을 사용하도록 변경될 수 있음). (<code>Alternative Generator Expression Semantics</code> 섹션에서 더 자세한 논의를 참조하십시오).</p>
<h3>할당 표현식과의 상호작용 (Interaction with Assignment Expressions)</h3>
<p>이 제안은 Comprehension의 다양한 부분의 평가 순서나 스코프(scope) 규칙을 변경하지 않습니다. 이는 PEP 572의 "walrus operator" <code>:=</code>를 사용하는 <code>generator expression</code>에 특히 관련이 있습니다. 이 연산자는 Comprehension 또는 <code>generator expression</code>에서 사용될 때, 변수 바인딩을 Comprehension 내의 지역 스코프가 아닌 포함하는 스코프(containing scope)에서 수행합니다.</p>
<p>예를 들어, <code>(*(y := [i, i+1]) for i in (0, 2, 4))</code> 표현식의 평가에서 발생하는 <code>generator</code>를 고려해 봅시다. 이는 다음 <code>generator</code>와 거의 동일하지만, <code>generator expression</code> 형태에서는 <code>y</code>가 지역적으로 바인딩되는 대신 포함하는 스코프에서 바인딩됩니다.</p>
<pre><code class="language-python">def generator():
    for i in (0, 2, 4):
        yield from (y := [i, i+1])
</code></pre>
<p>이 예제에서, 서브 표현식 <code>(y := [i, i+1])</code>는 <code>generator</code>가 소진되기 전에 정확히 세 번 평가됩니다: Comprehension에서 <code>i</code>가 각각 <code>0</code>, <code>2</code>, <code>4</code>로 할당된 직후입니다. 따라서 <code>y</code>(포함하는 스코프 내)는 해당 시점에 수정됩니다:</p>
<pre><code class="language-python">>>> g = (*(y := [i, i+1]) for i in (0, 2, 4))
>>> y
Traceback (most recent call last):
  File "&#x3C;python-input-1>", line 1, in &#x3C;module>
NameError: name 'y' is not defined
>>> next(g)
0
>>> y
[0, 1]
>>> next(g)
1
>>> y
[0, 1]
>>> next(g)
2
>>> y
[2, 3]
</code></pre>
<h3>오류 보고 (Error Reporting)</h3>
<p>현재 제안된 구문은 <code>SyntaxError</code>를 발생시킵니다. 이러한 형식이 구문적으로 유효한 것으로 인식되도록 허용하려면 <code>invalid_comprehension</code> 및 <code>invalid_dict_comprehension</code>에 대한 문법 규칙을 각각 <code>*</code> 및 <code> **</code> 사용을 허용하도록 조정해야 합니다.</p>
<p>최소한 다음 경우에 추가적인 특정 오류 메시지가 제공되어야 합니다:</p>
<p><code>list comprehension</code> 또는 <code>generator expression</code>에서 <code>** </code>를 사용하려고 시도하면 딕셔너리 언패킹이 해당 구조에서 사용될 수 없음을 보고해야 합니다. 예를 들면:</p>
<pre><code class="language-python">>>> [ **x for x in y]
  File "&#x3C;stdin>", line 1
    [** x for x in y]
    ^^^
SyntaxError: cannot use dict unpacking in list comprehension
>>> ( **x for x in y)
  File "&#x3C;stdin>", line 1
    (** x for x in y)
    ^^^
SyntaxError: cannot use dict unpacking in generator expression
</code></pre>
<p><code>dictionary key/value</code>에서 <code>*</code>를 사용하려고 시도할 때의 기존 오류 메시지는 유지되어야 하지만, <code>dictionary key</code> 또는 <code>value</code>에서 <code>**</code> 언패킹을 사용하려고 시도할 때도 유사한 메시지가 보고되어야 합니다. 예를 들면:</p>
<pre><code class="language-python">>>> {*k: v for k,v in items}
  File "&#x3C;stdin>", line 1
    {*k: v for k,v in items}
    ^^
SyntaxError: cannot use a starred expression in a dictionary key
>>> {k: *v for k,v in items}
  File "&#x3C;stdin>", line 1
    {k: *v for k,v in items}
    ^^
SyntaxError: cannot use a starred expression in a dictionary value
>>> { **k: v for k,v in items}
  File "&#x3C;stdin>", line 1
    {** k: v for k,v in items}
    ^^^
SyntaxError: cannot use dict unpacking in a dictionary key
>>> {k: **v for k,v in items}
  File "&#x3C;stdin>", line 1
    {k: ** v for k,v in items}
    ^^^
SyntaxError: cannot use dict unpacking in a dictionary value
</code></pre>
<p>다른 기존 오류 메시지의 문구도 새 구문의 존재를 설명하고, 또는 언패킹과 일반적으로 관련된 모호하거나 혼란스러운 경우(특히 <code>Further Generalizing Unpacking Operators</code>에서 언급된 경우)를 명확히 하기 위해 조정되어야 합니다. 예를 들면:</p>
<pre><code class="language-python">>>> [*x if x else y]
  File "&#x3C;stdin>", line 1
    [*x if x else y]
    ^^^^^^^^^^^^^^
SyntaxError: invalid starred expression. Did you forget to wrap the conditional expression in parentheses?
>>> { **x if x else y}
  File "&#x3C;stdin>", line 1
    {** x if x else y}
    ^^^^^^^^^^^^^^^
SyntaxError: invalid double starred expression. Did you forget to wrap the conditional expression in parentheses?
>>> [x if x else *y]
  File "&#x3C;stdin>", line 1
    [x if x else *y]
    ^
SyntaxError: cannot unpack only part of a conditional expression
>>> {x if x else **y}
  File "&#x3C;stdin>", line 1
    {x if x else ** y}
    ^^
SyntaxError: cannot use dict unpacking on only part of a conditional expression
</code></pre>
<h2>참조 구현 (Reference Implementation)</h2>
<p>참조 구현은 이 기능을 구현하며, 초안 문서와 추가 테스트 케이스를 포함합니다.</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>현재 구문적으로 유효한 모든 Comprehension의 동작은 이 변경의 영향을 받지 않으므로, 하위 호환성 문제가 많지는 않을 것으로 예상됩니다. 원칙적으로 이 변경은 Comprehension에서 언패킹 연산을 시도하면 <code>SyntaxError</code>가 발생한다는 사실에 의존하는 코드, 또는 대체되는 이전 오류 메시지의 특정 문구에 의존하는 코드에만 영향을 미칠 것입니다. 이는 드물 것으로 예상됩니다.</p>
<p>하나의 관련 우려는 미래에 비동기 <code>generator expression</code>의 의미론을 변경하여 언패킹 시 <code>yield from</code>을 사용하도록(언패킹되는 <code>generator</code>에게 위임하도록) 결정하는 경우입니다. 이는 <code>.asend()</code>, <code>.athrow()</code>, <code>.aclose()</code>와 함께 사용될 때 결과 <code>generator</code>의 동작에 영향을 미치므로 하위 호환성이 없을 것입니다. 그러나 하위 호환성이 없음에도 불구하고, 이러한 변경은 이 제안 하에서 특별히 유용하지 않은 구조의 동작에만 영향을 미치므로 큰 영향을 미치지 않을 가능성이 높습니다. (<code>Alternative Generator Expression Semantics</code> 섹션에서 더 자세한 논의를 참조하십시오).</p>
<h2>코드 예시 (Code Examples)</h2>
<p>이 섹션은 표준 라이브러리의 작은 코드 조각들을 어떻게 이 새로운 구문을 사용하여 간결성과 가독성을 향상시키도록 다시 작성할 수 있는지 보여주는 예시를 제시합니다. 참조 구현은 이러한 대체가 이루어진 후에도 모든 테스트를 통과합니다.</p>
<h3>명시적 루프 대체 (Replacing Explicit Loops)</h3>
<p>명시적 루프를 대체하면 여러 줄이 한 줄로 압축되고, 보조 변수를 정의하고 참조할 필요가 없어집니다.</p>
<p><code>email/_header_value_parser.py</code>에서:</p>
<pre><code class="language-python"># 현재:
comments = []
for token in self:
    comments.extend(token.comments)
return comments

# 개선:
return [*token.comments for token in self]
</code></pre>
<p><code>shutil.py</code>에서:</p>
<pre><code class="language-python"># 현재:
ignored_names = []
for pattern in patterns:
    ignored_names.extend(fnmatch.filter(names, pattern))
return set(ignored_names)

# 개선:
return {*fnmatch.filter(names, pattern) for pattern in patterns}
</code></pre>
<p><code>http/cookiejar.py</code>에서:</p>
<pre><code class="language-python"># 현재:
cookies = []
for domain in self._cookies.keys():
    cookies.extend(self._cookies_for_domain(domain, request))
return cookies

# 개선:
return [
    *self._cookies_for_domain(domain, request) for domain in self._cookies.keys()
]
</code></pre>
<h3><code>from_iterable</code> 및 관련 함수 대체 (Replacing from_iterable and Friends)</h3>
<p>항상 올바른 선택은 아니지만, <code>itertools.chain.from_iterable</code> 및 <code>map</code>을 대체하면 추가적인 간접 레벨을 피할 수 있어, Comprehension이 <code>map</code>/<code>filter</code>보다 가독성이 좋다는 일반적인 통념을 따르는 코드가 됩니다.</p>
<p><code>dataclasses.py</code>에서:</p>
<pre><code class="language-python"># 현재:
inherited_slots = set(
    itertools.chain.from_iterable(map(_get_slots, cls.__mro__[1:-1]))
)

# 개선:
inherited_slots = {*_get_slots(c) for c in cls.__mro__[1:-1]}
</code></pre>
<p><code>importlib/metadata/__init__.py</code>에서:</p>
<pre><code class="language-python"># 현재:
return itertools.chain.from_iterable(
    path.search(prepared) for path in map(FastPath, paths)
)

# 개선:
return (*FastPath(path).search(prepared) for path in paths)
</code></pre>
<p><code>collections/__init__.py</code> (<code>Counter</code> 클래스)에서:</p>
<pre><code class="language-python"># 현재:
return _chain.from_iterable(_starmap(_repeat, self.items()))

# 개선:
return (*_repeat(elt, num) for elt, num in self.items())
</code></pre>
<p><code>zipfile/_path/__init__.py</code>에서:</p>
<pre><code class="language-python"># 현재:
parents = itertools.chain.from_iterable(map(_parents, names))

# 개선:
parents = (*_parents(name) for name in names)
</code></pre>
<p><code>_pyrepl/_module_completer.py</code>에서:</p>
<pre><code class="language-python"># 현재:
search_locations = set(chain.from_iterable(
    getattr(spec, 'submodule_search_locations', []) for spec in specs if spec
))

# 개선:
search_locations = {
    *getattr(spec, 'submodule_search_locations', []) for spec in specs if spec
}
</code></pre>
<h3>Comprehension 내 이중 루프 대체 (Replacing Double Loops in Comprehensions)</h3>
<p>Comprehension 내 이중 루프를 대체하면 보조 변수를 정의하고 참조할 필요가 없어 혼란을 줄일 수 있습니다.</p>
<p><code>importlib/resources/readers.py</code>에서:</p>
<pre><code class="language-python"># 현재:
children = (child for path in self._paths for child in path.iterdir())

# 개선:
children = (*path.iterdir() for path in self._paths)
</code></pre>
<p><code>asyncio/base_events.py</code>에서:</p>
<pre><code class="language-python"># 현재:
exceptions = [exc for sub in exceptions for exc in sub]

# 개선:
exceptions = [*sub for sub in exceptions]
</code></pre>
<p><code>_weakrefset.py</code>에서:</p>
<pre><code class="language-python"># 현재:
return self.__class__(e for s in (self, other) for e in s)

# 개선:
return self.__class__(*s for s in (self, other))
</code></pre>
<h2>교육 방법 (How to Teach This)</h2>
<p>현재 Comprehension의 개념을 소개하는 일반적인 방법(Python 튜토리얼에서 사용됨)은 동등한 코드를 보여주는 것입니다. 예를 들어, 이 방법은 <code>out = [expr for x in it]</code>가 다음 코드와 동일하다고 말할 것입니다:</p>
<pre><code class="language-python">out = []
for x in it:
    out.append(expr)
</code></pre>
<p>이 접근 방식을 취하면 <code>out = [*expr for x in it]</code>를 대신 다음 코드와 동일하다고 소개할 수 있습니다 (<code>append</code> 대신 <code>extend</code> 사용):</p>
<pre><code class="language-python">out = []
for x in it:
    out.extend(expr)
</code></pre>
<p>언패킹을 사용하는 <code>set</code> 및 <code>dict comprehension</code>도 유사한 비유를 통해 소개될 수 있습니다:</p>
<pre><code class="language-python"># out = {expr for x in it} 와 동일
out = set()
for x in it:
    out.add(expr)

# out = {*expr for x in it} 와 동일
out = set()
for x in it:
    out.update(expr)

# out = {k_expr: v_expr for x in it} 와 동일
out = {}
for x in it:
    out[k_expr] = v_expr

# out = { **expr for x in it} 와 동일 (expr이 ** 로 언패킹될 수 있는 매핑으로 평가되는 경우)
out = {}
for x in it:
    out.update(expr)
</code></pre>
<p>그리고 언패킹을 포함하는 <code>generator expression</code>의 동작을 설명하기 위해 유사한 접근 방식을 취할 수 있습니다:</p>
<pre><code class="language-python"># g = (expr for x in it) 와 동일
def generator():
    for x in it:
        yield expr
g = generator()

# g = (*expr for x in it) 와 동일
def generator():
    for x in it:
        yield from expr
g = generator()
</code></pre>
<p>이러한 특정 예시들로부터, 별표가 없는 Comprehension/genexp가 컬렉션에 단일 요소를 추가하는 연산자를 사용하는 모든 곳에서, 별표가 있는 버전은 대신 해당 컬렉션에 여러 요소를 추가하는 연산자를 사용할 것이라는 아이디어로 일반화할 수 있습니다.</p>
<p>대안으로, 두 아이디어를 별개로 생각할 필요 없이, 새로운 구문을 통해 <code>out = [...x... for x in it]</code>를 다음 코드와 동일하다고 생각할 수 있습니다 (여기서 <code>...x...</code>는 임의의 코드를 나타냅니다), <code>...x...</code>가 <code>*</code>를 사용하는지 여부와 관계없이:</p>
<pre><code class="language-python">out = []
for x in it:
    out.extend([...x...])
</code></pre>
<p>마찬가지로, <code>out = {...x... for x in it}</code>를 다음 코드와 동일하다고 생각할 수 있습니다. <code>...x...</code>가 <code>*</code> 또는 <code>**</code> 또는 <code>:</code>를 사용하는지 여부와 관계없이:</p>
<pre><code class="language-python">out = set() # 또는 out = {}
for x in it:
    out.update({...x...})
</code></pre>
<p>이러한 예시는 Comprehension이 있는 버전과 없는 버전 모두에서 동일한 출력을 생성한다는 의미에서 동등하지만, Comprehension이 없는 버전은 각 <code>extend</code> 또는 <code>update</code> 전에 새로운 <code>list</code>/<code>set</code>/<code>dictionary</code>를 만들기 때문에 약간 덜 효율적입니다. 이는 Comprehension을 사용하는 버전에서는 불필요합니다.</p>
<h2>거부된 대안 제안 (Rejected Alternative Proposals)</h2>
<p>위 명세에 대해 생각할 때 주된 목표는 언패킹 및 Comprehension / <code>generator expression</code>에 대한 기존 규범과의 일관성이었습니다. 이를 해석하는 한 가지 방법은 기존 문법 및 코드 생성에 가능한 가장 작은 변경 사항만 요구하도록 명세를 작성하여, 기존 코드가 주변 의미론을 형성하도록 하는 것이 목표였다는 것입니다.</p>
<p>아래에서는 논의에서 제기되었지만 이 제안에 포함되지 않은 일반적인 우려/대안 제안 중 일부를 논의합니다.</p>
<h3>함수 인수로 사용되는 Starred Generator (Starred Generators as Function Arguments)</h3>
<p>여러 번 제기된 일반적인 우려(위에서 링크된 논의 스레드뿐만 아니라 이와 동일한 아이디어에 대한 이전 논의에서도)는 <code>f(*x for x in y)</code>와 같이 별표가 붙은 <code>generator</code>를 함수의 단일 인수로 전달할 때 발생할 수 있는 구문적 모호성입니다. 원래 PEP 448에서는 이 모호성이 제안의 일부로 유사한 일반화를 포함하지 않은 이유로 언급되었습니다.</p>
<p>이 제안은 <code>f(*x for x in y)</code>가 <code>f((*x for x in y))</code>로 해석되어야 하며, 결과 <code>generator</code>에 대한 추가 언패킹을 시도해서는 안 된다고 제안합니다. 그러나 논의에서는 몇 가지 대안이 제시되었습니다(및/또는 과거에 제시된 바 있음), 예를 들어:</p>
<ul>
<li><code>f(*x for x in y)</code>를 <code>f(*(x for x in y))</code>로 해석하거나,</li>
<li><code>f(*x for x in y)</code>를 <code>f(*(*x for x in y))</code>로 해석하거나,</li>
<li>이 제안의 다른 측면이 수락되더라도 <code>f(*x for x in y)</code>에 대해 계속 <code>SyntaxError</code>를 발생시키는 것입니다.</li>
</ul>
<p>이러한 대안보다 이 제안을 선호하는 이유는 <code>generator expression</code> 주변의 기존 구두점 규칙을 유지하기 위함입니다. 현재 일반적인 규칙은 <code>generator expression</code>이 함수의 단일 인수로 제공되는 경우를 제외하고는 괄호로 묶여야 한다는 것입니다. 이 제안은 더 많은 종류의 <code>generator expression</code>을 허용하더라도 이 규칙을 유지할 것을 제안합니다. 이 옵션은 언패킹을 사용하는 Comprehension 및 <code>generator expression</code>과 그렇지 않은 것들 사이에 완전한 대칭을 유지합니다.</p>
<p>현재 우리는 다음 규칙을 가지고 있습니다:</p>
<pre><code class="language-python">f([x for x in y])   # 단일 list 전달
f({x for x in y})   # 단일 set 전달
f(x for x in y)     # 단일 generator 전달 (genexp 주변에 추가 괄호 불필요)
f(*[x for x in y])  # list의 요소들을 개별적으로 전달
f(*{x for x in y})  # set의 요소들을 개별적으로 전달
f(*(x for x in y)) # generator의 요소들을 개별적으로 전달 (괄호 필요)
</code></pre>
<p>이 제안은 Comprehension이 언패킹을 사용하는 경우에도 이러한 규칙을 유지하기로 선택합니다:</p>
<pre><code class="language-python">f([*x for x in y])   # 단일 list 전달
f({*x for x in y})   # 단일 set 전달
f(*x for x in y)     # 단일 generator 전달 (genexp 주변에 추가 괄호 불필요)
f(*[*x for x in y])  # list의 요소들을 개별적으로 전달
f(*{*x for x in y})  # set의 요소들을 개별적으로 전달
f(*(*x for x in y)) # generator의 요소들을 개별적으로 전달 (괄호 필요)
</code></pre>
<h3>언패킹 연산자 추가 일반화 (Further Generalizing Unpacking Operators)</h3>
<p>논의에서 나온 또 다른 제안은 Comprehension 내에서 표현식을 언패킹하는 것을 허용하는 것 이상으로 <code>*</code>를 더욱 일반화하는 것이었습니다. 이 확장의 두 가지 주요 유형이 고려되었습니다:</p>
<ul>
<li>
<p><code>*</code> 및 <code>**</code>를 새로운 종류의 <code>Unpackable</code> 객체(또는 유사한 것)를 생성하는 진정한 단항 연산자로 만들어서, Comprehension이 이를 언패킹하여 처리할 수 있지만 다른 컨텍스트에서도 사용될 수 있도록 하는 것; 또는</p>
</li>
<li>
<p><code>*</code> 및 <code>**</code>를 이 제안에서 허용되는 다른 곳(표현식 리스트, Comprehension, <code>generator expression</code>, 인자 리스트)에서만 허용하되, Comprehension 내의 서브 표현식에서도 사용할 수 있도록 허용하여, 예를 들어 일부 iterable 객체와 일부 non-iterable 객체를 포함하는 리스트를 평탄화하는 방법으로 다음을 허용하는 것:</p>
<pre><code class="language-python">[*x if isinstance(x, Iterable) else x for x in [[1,2,3], 4]]
</code></pre>
</li>
</ul>
<p>이러한 변형은 (이해하고 구현하기에) 실질적으로 더 복잡하고 유용성이 미미하다고 간주되어 이 PEP에 포함되지 않았습니다. 따라서 이러한 형식은 계속 <code>SyntaxError</code>를 발생시켜야 하지만, 위에서 설명한 새로운 오류 메시지와 함께 제공되어야 합니다. 그러나 미래 제안을 위한 고려 사항으로 배제되어서는 안 됩니다.</p>
<h3>대체 Generator Expression 의미론 (Alternative Generator Expression Semantics)</h3>
<p>또 다른 논의 지점은 <code>generator expression</code>의 언패킹 의미론, 특히 비동기 <code>generator</code>가 <code>yield from</code>을 지원하지 않는다는 점을 고려할 때 동기 및 비동기 <code>generator expression</code>의 의미론 간의 관계에 중점을 두었습니다 (PEP 525의 <code>Asynchronous yield from</code> 섹션 참조).</p>
<p>핵심 질문은 동기 및 비동기 <code>generator expression</code>이 언패킹할 때 명시적인 루프 대신 <code>yield from</code>(또는 동등한 것)을 사용해야 하는지에 대한 것이었습니다. 이러한 옵션 간의 주요 차이점은 결과 <code>generator</code>가 언패킹되는 객체에 위임하는지 여부입니다. 이는 언패킹되는 객체 자체가 <code>generator</code>인 경우 <code>.send()/.asend()</code>, <code>.throw()/.athrow()</code>, <code>.close()/.aclose()</code>와 함께 사용될 때 이러한 <code>generator expression</code>의 동작에 영향을 미칠 것입니다. 이러한 옵션 간의 차이점은 <code>Appendix: Semantics of Generator Delegation</code>에 요약되어 있습니다.</p>
<p>몇 가지 합리적인 옵션이 고려되었으며, Discourse 스레드의 투표에서 명확한 승자는 없었습니다. 위에서 설명한 제안 외에 다음도 고려되었습니다:</p>
<ul>
<li>
<p>동기 및 비동기 <code>generator expression</code> 모두에 명시적 루프를 사용하는 것.</p>
<p>이 전략은 동기 및 비동기 <code>generator expression</code> 사이에 대칭성을 가져왔겠지만, 동기 <code>generator expression</code>의 경우 위임을 허용하지 않아 잠재적으로 유용한 도구를 막았을 것입니다. 이 접근 방식의 한 가지 특정 우려는 동기 및 비동기 <code>generator</code> 간의 비대칭성을 도입하는 것이지만, 이러한 비대칭성이 이미 동기 및 비동기 <code>generator</code> 사이에 더 일반적으로 존재한다는 사실로 인해 이 우려는 완화됩니다.</p>
</li>
<li>
<p>동기 <code>generator expression</code>의 언패킹에 <code>yield from</code>을 사용하고, 비동기 <code>generator expression</code>의 언패킹에 <code>yield from</code>의 동작을 모방하는 것.</p>
<p>이 전략은 동기 및 비동기 <code>generator</code>의 언패킹 동작을 대칭적으로 만들겠지만, 더 복잡할 것이며, 그 비용이 이점만큼 가치가 없을 수도 있습니다. 따라서 이 PEP는 언패킹 연산자를 사용하는 <code>generator expression</code>이 <code>yield from</code>이 비동기 <code>generator</code>에서 더 일반적으로 지원될 때까지 <code>yield from</code>과 유사한 의미론을 사용해서는 안 된다고 제안합니다.</p>
</li>
<li>
<p>동기 <code>generator expression</code>의 언패킹에 <code>yield from</code>을 사용하고, 비동기 <code>generator expression</code>이 <code>yield from</code>을 지원할 때까지 비동기 <code>generator expression</code>에서의 언패킹을 금지하는 것.</p>
<p>이 전략은 비동기 <code>generator expression</code>이 미래에 <code>yield from</code>에 대한 지원을 얻게 된다면, 그때 내려지는 모든 결정이 완전히 하위 호환성을 갖도록 보장함으로써 마찰을 줄일 수 있을 것입니다. 그러나 그 컨텍스트에서 언패킹의 유용성은 비동기 <code>generator expression</code>이 <code>yield from</code>에 대한 지원을 받는 경우 미래에 최소한의 침해적인 하위 비호환성 변경의 잠재적인 단점보다 클 것으로 보입니다.</p>
</li>
<li>
<p>모든 <code>generator expression</code>에서 언패킹을 금지하는 것.</p>
<p>이는 두 경우 사이에 대칭성을 유지하겠지만, 매우 표현적인 형태를 잃는 단점이 있습니다.</p>
</li>
</ul>
<p>이러한 각 옵션(이 PEP에 제시된 옵션 포함)은 장점과 단점을 가지고 있으며, 모든 면에서 명확하게 우월한 옵션은 없습니다. <code>Semantics: Generator Expressions</code>에 제안된 의미론은 동기 및 비동기 <code>generator expression</code> 모두에서 언패킹이 현재 동등한 <code>generator</code>를 작성하는 일반적인 방법을 반영하는 합리적인 절충안을 나타냅니다. 또한, 이러한 미묘한 차이는 일반적인 사용 사례에 큰 영향을 미치지 않을 가능성이 높습니다 (예를 들어, 단순 컬렉션을 결합하는 가장 흔한 사용 사례에는 차이가 없습니다).</p>
<p>위에서 제안된 바와 같이, 이 결정은 비동기 <code>generator</code>가 미래에 <code>yield from</code>에 대한 지원을 받을 경우 재검토되어야 하며, 이 경우 비동기 <code>generator expression</code>에서 언패킹의 의미론을 <code>yield from</code>을 사용하도록 조정하는 것을 고려해야 합니다.</p>
<h2>우려 사항 및 단점 (Concerns and Disadvantages)</h2>
<p>논의 스레드에서 전반적인 합의는 이 구문이 명확하고 직관적이라는 것이었지만, 몇 가지 우려 사항과 잠재적인 단점도 제기되었습니다. 이 섹션은 이러한 우려 사항을 요약하는 것을 목표로 합니다.</p>
<ul>
<li><strong>기존 대안과의 중복:</strong> 제안된 구문이 더 명확하고 간결하다고 주장할 수 있지만, Python에는 이미 동일한 작업을 수행하는 여러 가지 방법이 있습니다.</li>
<li><strong>함수 호출 모호성:</strong> <code>f(*x for x in y)</code>와 같은 표현식은 <code>generator</code>를 언패킹하려는 것인지 또는 단일 인수로 전달하려는 것인지가 명확하지 않아 처음에는 모호하게 보일 수 있습니다. 이 제안은 이 형식을 <code>f((*x for x in y))</code>와 동일하게 처리하여 기존 규칙을 유지하지만, 이 동등성이 즉시 명확하지 않을 수 있습니다.</li>
<li><strong>과도한 사용 또는 오용 가능성:</strong> Comprehension에서 언패킹을 복잡하게 사용하면 명시적 루프에서 더 명확할 수 있는 로직을 모호하게 만들 수 있습니다. 이는 Comprehension 전반에 걸쳐 이미 우려되는 사항이지만, <code>*</code> 및 <code>**</code>의 추가는 특히 복잡한 사용을 한눈에 읽고 이해하기 훨씬 더 어렵게 만들 수 있습니다. 예를 들어, 이러한 상황이 드물기는 하지만, 여러 방식으로 언패킹을 사용하는 Comprehension은 무엇이 언제 언패킹되는지 알기 어렵게 만들 수 있습니다: <code>f(*(*x for *x, _ in list_of_lists))</code>.</li>
<li><strong>스코프 제한의 불명확성:</strong> 이 제안은 언패킹을 Comprehension 표현식의 최상위 레벨로 제한하지만, 일부 사용자는 <code>Further Generalizing Unpacking Operators</code>에서 논의된 바와 같이 언패킹 연산자가 추가로 일반화될 것이라고 예상할 수 있습니다.</li>
<li><strong>외부 도구에 미치는 영향:</strong> Python 구문의 다른 변경 사항과 마찬가지로, 이 변경 사항은 코드 포매터, 린터, 타입 체커 등의 유지보수자에게 새로운 구문이 지원되도록 작업을 생성할 것입니다.</li>
</ul>
<h2>부록: 다른 언어 (Appendix: Other Languages)</h2>
<p>꽤 많은 다른 언어들이 Python에 이미 있는 것과 유사한 구문으로 이러한 종류의 평탄화(flattening)를 지원하지만, Comprehension 내에서 언패킹 구문을 사용하는 것에 대한 지원은 드뭅니다. 이 섹션은 몇 가지 다른 언어에서 유사한 구문에 대한 지원을 간략하게 요약합니다.</p>
<p>Comprehension을 지원하는 많은 언어들은 이중 루프를 지원합니다:</p>
<pre><code class="language-python"># python
[x for xs in [[1,2,3], [], [4,5]] for x in xs * 2]

-- haskell
[x | xs &#x3C;- [[1,2,3], [], [4,5]], x &#x3C;- xs ++ xs]

# julia
[x for xs in [[1,2,3], [], [4,5]] for x in [xs; xs]]

; clojure
(for [xs [[1 2 3] [] [4 5]] x (concat xs xs)] x)
</code></pre>
<p>몇몇 다른 언어들(Comprehension이 없는 언어들도)은 중첩된 구조의 평탄화를 지원하기 위해 내장 함수나 메서드를 통해 이러한 연산을 지원합니다:</p>
<pre><code class="language-python"># python
list(itertools.chain(*(xs*2 for xs in [[1,2,3], [], [4,5]])))

// javascript
[[1,2,3], [], [4,5]].flatMap(xs => [...xs, ...xs])

-- haskell
concat (map (\x -> x ++ x) [[1,2,3], [], [4,5]])

# ruby
[[1, 2, 3], [], [4, 5]].flat_map {|e| e * 2}
</code></pre>
<p>그러나 Comprehension과 언패킹을 모두 지원하는 언어는 Comprehension 내에서 언패킹을 허용하는 경향이 없습니다. 예를 들어, Julia에서 다음 표현식은 현재 구문 오류로 이어집니다:</p>
<pre><code class="language-julia">[xs... for xs in [[1,2,3], [], [4,5]]]
</code></pre>
<p>한 가지 반례로, Civet에는 최근 유사한 구문이 추가되었습니다. 예를 들어, 다음은 Civet의 유효한 Comprehension이며, JavaScript의 <code>...</code> 구문을 사용하여 언패킹을 활용합니다:</p>
<pre><code class="language-coffeescript">for xs of [[1,2,3], [], [4,5]] then ...(xs++xs)
</code></pre>
<h2>부록: Generator 위임의 의미론 (Appendix: Semantics of Generator Delegation)</h2>
<p>위에서 설명된 의미론에 대한 일반적인 질문 중 하나는 <code>generator expression</code> 내에서 언패킹할 때 <code>yield from</code>을 사용하는 것과 명시적인 루프를 사용하는 것의 차이점에 관한 것이었습니다. 이는 <code>generator</code>의 상당히 고급 기능이므로, 이 부록은 <code>yield from</code>을 사용하는 <code>generator</code>와 명시적인 루프를 사용하는 <code>generator</code> 간의 몇 가지 주요 차이점을 요약합니다.</p>
<h3>기본 동작 (Basic Behavior)</h3>
<p>값에 대한 단순한 반복의 경우, 이는 <code>generator expression</code>에서 언패킹의 가장 일반적인 용도가 될 것으로 예상되며, 두 접근 방식 모두 동일한 결과를 생성합니다:</p>
<pre><code class="language-python">def yield_from(iterables):
    for iterable in iterables:
        yield from iterable

def explicit_loop(iterables):
    for iterable in iterables:
        for item in iterable:
            yield item

# 두 가지 모두 동일한 값 시퀀스를 생성합니다.
x = list(yield_from([[1, 2], [3, 4]]))
y = list(explicit_loop([[1, 2], [3, 4]]))
print(x == y) # True 출력
</code></pre>
<h3>고급 Generator 프로토콜 차이 (Advanced Generator Protocol Differences)</h3>
<p>차이점은 고급 <code>generator</code> 프로토콜 메서드인 <code>.send()</code>, <code>.throw()</code>, <code>.close()</code>를 사용할 때, 그리고 서브 iterable이 단순 시퀀스가 아닌 <code>generator</code> 자체일 때 나타납니다. 이러한 경우, <code>yield from</code> 버전은 관련 신호가 서브 <code>generator</code>에 도달하게 하지만, 명시적 루프가 있는 버전은 그렇지 않습니다.</p>
<h4><code>.send()</code>를 사용한 위임 (Delegation with .send())</h4>
<pre><code class="language-python">def sub_generator():
    x = yield "first"
    yield f"received: {x}"
    yield "last"

def yield_from():
    yield from sub_generator()

def explicit_loop():
    for item in sub_generator():
        yield item

# yield from을 사용하면 값이 서브-generator로 전달됩니다.
gen1 = yield_from()
print(next(gen1)) # "first" 출력
print(gen1.send("hello")) # "received: hello" 출력
print(next(gen1)) # "last" 출력

# 명시적 루프를 사용하면 .send()가 외부 generator에만 영향을 미칩니다.
# 값은 서브-generator에 도달하지 않습니다.
gen2 = explicit_loop()
print(next(gen2)) # "first" 출력
print(gen2.send("hello")) # "received: None" 출력 (서브-generator는 "hello" 대신 None을 받습니다)
print(next(gen2)) # "last" 출력
</code></pre>
<h4><code>.throw()</code>를 사용한 예외 처리 (Exception Handling with .throw())</h4>
<pre><code class="language-python">def sub_generator_with_exception_handling():
    try:
        yield "first"
        yield "second"
    except ValueError as e:
        yield f"caught: {e}"

def yield_from():
    yield from sub_generator_with_exception_handling()

def explicit_loop():
    for item in sub_generator_with_exception_handling():
        yield item

# yield from을 사용하면 예외가 서브-generator로 전달됩니다.
gen1 = yield_from()
print(next(gen1)) # "first" 출력
print(gen1.throw(ValueError("test"))) # "caught: test" 출력

# 명시적 루프를 사용하면 예외가 외부 generator에만 영향을 미칩니다.
gen2 = explicit_loop()
print(next(gen2)) # "first" 출력
print(gen2.throw(ValueError("test"))) # ValueError가 발생합니다. 서브-generator는 이를 보지 못합니다.
</code></pre>
<h4><code>.close()</code>를 사용한 Generator 정리 (Generator Cleanup with .close())</h4>
<pre><code class="language-python"># 서브-generator에 대한 참조를 유지하여 GC가 명시적 루프 버전을 닫지 않도록 합니다.
references = []

def sub_generator_with_cleanup():
    try:
        yield "first"
        yield "second"
    finally:
        print("sub-generator received GeneratorExit")

def yield_from():
    try:
        g = sub_generator_with_cleanup()
        references.append(g)
        yield from g
    finally:
        print("outer generator received GeneratorExit")

def explicit_loop():
    try:
        g = sub_generator_with_cleanup()
        references.append(g)
        for item in g:
            yield item
    finally:
        print("outer generator received GeneratorExit")

# yield from을 사용하면 GeneratorExit이 서브-generator로 전달됩니다.
gen1 = yield_from()
print(next(gen1)) # "first" 출력
gen1.close() # 서브-generator를 닫은 다음 외부 generator를 닫습니다.

# 명시적 루프를 사용하면 GeneratorExit이 외부 generator에만 전달됩니다.
gen2 = explicit_loop()
print(next(gen2)) # "first" 출력
gen2.close() # 외부 generator만 닫습니다.
print('program finished; GC will close the explicit loop subgenerator')
# 두 번째 내부 generator는 GC가 프로그램을 마칠 때 닫힙니다.
</code></pre>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/794/">[Accepted] PEP 794 - Import Name Metadata</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Draft] PEP 798 - Unpacking in Comprehensions</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/799/">[Draft] PEP 799 - A dedicatedprofilingpackage for organizing Python profiling tools</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/773b243a13a00265.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"185\",\"static/chunks/app/layout-f2c168e996e2da30.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/798\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/773b243a13a00265.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"-9tNcy1wwtJPV_mfE6jXv\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/798/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/798\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"798\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/798\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"default\"]\ne:Tb027,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0798/\"\u003ePEP 798 - Unpacking in Comprehensions\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Draft | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 19-Jul-2025\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 798 – Comprehension 내 언패킹 (Unpacking)\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003elist\u003c/code\u003e, \u003ccode\u003eset\u003c/code\u003e, \u003ccode\u003edictionary\u003c/code\u003e Comprehension (컴프리헨션) 및 \u003ccode\u003egenerator expression\u003c/code\u003e (제너레이터 표현식)을 확장하여 표현식 시작 부분에 언패킹(Unpacking) 표기법(\u003ccode\u003e*\u003c/code\u003e 및 \u003ccode\u003e**\u003c/code\u003e)을 허용할 것을 제안합니다. 이는 임의의 수의 iterable을 하나의 \u003ccode\u003elist\u003c/code\u003e, \u003ccode\u003eset\u003c/code\u003e 또는 \u003ccode\u003egenerator\u003c/code\u003e로, 또는 임의의 수의 딕셔너리를 하나의 딕셔너리로 결합하는 간결한 방법을 제공합니다.\u003c/p\u003e\n\u003cp\u003e예시는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e[*it for it in its] # 'its' 내의 iterable들을 연결한 list\n{*it for it in its} # 'its' 내의 iterable들을 합집합(union)한 set\n{**d for d in dicts} # 'dicts' 내의 딕셔너리들을 조합한 dict\n(*it for it in its) # 'its' 내의 iterable들을 연결한 generator\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePEP 448에 도입된 확장 언패킹 표기법(\u003ccode\u003e*\u003c/code\u003e 및 \u003ccode\u003e**\u003c/code\u003e)은 몇 개의 iterable 또는 딕셔너리를 쉽게 결합할 수 있도록 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e[*it1, *it2, *it3] # 세 개의 iterable을 연결한 list\n{*it1, *it2, *it3} # 세 개의 iterable을 합집합(union)한 set\n{ **dict1, ** dict2, **dict3} # 세 개의 딕셔너리를 조합한 dict\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 임의의 수의 iterable을 유사하게 결합하려는 경우에는 동일한 방식으로 언패킹을 사용할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e여러 iterable을 결합하는 몇 가지 기존 방법이 있습니다. 예를 들어, 명시적인 루프 구조와 내장된 결합 방법을 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003enew_list = []\nfor it in its:\n    new_list.extend(it)\n\nnew_set = set()\nfor it in its:\n    new_set.update(it)\n\nnew_dict = {}\nfor d in dicts:\n    new_dict.update(d)\n\ndef new_generator():\n    for it in its:\n        yield from it\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 두 개의 루프를 사용하는 Comprehension으로 더 간결하게 표현할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e[x for it in its for x in it]\n{x for it in its for x in it}\n{key: value for d in dicts for key, value in d.items()}\n(x for it in its for x in it)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eitertools.chain\u003c/code\u003e 또는 \u003ccode\u003eitertools.chain.from_iterable\u003c/code\u003e을 사용할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elist(itertools.chain(*its))\nset(itertools.chain(*its))\ndict(itertools.chain(*(d.items() for d in dicts)))\nitertools.chain(*its)\nlist(itertools.chain.from_iterable(its))\nset(itertools.chain.from_iterable(its))\ndict(itertools.chain.from_iterable(d.items() for d in dicts))\nitertools.chain.from_iterable(its)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 \u003ccode\u003egenerator\u003c/code\u003e를 제외한 모든 경우에 \u003ccode\u003efunctools.reduce\u003c/code\u003e를 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efunctools.reduce(operator.iconcat, its, (new_list := []))\nfunctools.reduce(operator.ior, its, (new_set := set()))\nfunctools.reduce(operator.ior, its, (new_dict := {}))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 PEP는 Comprehension 내에서 언패킹 연산을 추가적인 대안으로 허용할 것을 제안합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e[*it for it in its] # 'its' 내의 iterable들을 연결한 list\n{*it for it in its} # 'its' 내의 iterable들을 합집합(union)한 set\n{**d for d in dicts} # 'dicts' 내의 딕셔너리들을 조합한 dict\n(*it for it in its) # 'its' 내의 iterable들을 연결한 generator\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 제안은 비동기 Comprehension 및 \u003ccode\u003egenerator expression\u003c/code\u003e에도 확장되어, 예를 들어 \u003ccode\u003e(*ait async for ait in aits())\u003c/code\u003e는 \u003ccode\u003e(x async for ait in aits() for x in ait)\u003c/code\u003e와 동일합니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003eiterable 객체들을 하나의 더 큰 객체로 결합하는 것은 흔한 작업입니다. 예를 들어, 리스트의 리스트를 평탄화(flattening)하는 방법에 대한 StackOverflow 게시물은 460만 회 조회되었습니다. 이처럼 흔한 작업임에도 불구하고, 현재 간결하게 수행할 수 있는 옵션들은 간접적인 수준을 요구하여 결과 코드를 읽고 이해하기 어렵게 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e제안된 표기법은 간결하며(보조 변수의 사용과 반복을 피함), Comprehension과 언패킹 표기법 모두에 익숙한 프로그래머에게 직관적이고 친숙할 것으로 예상됩니다. 표준 라이브러리의 코드를 제안된 구문으로 더 명확하고 간결하게 다시 작성할 수 있는 예시는 \u003ccode\u003eCode Examples\u003c/code\u003e 섹션을 참조하십시오.\u003c/p\u003e\n\u003cp\u003e이 제안은 부분적으로 Python 프로그래밍 수업의 필기시험에서 동기를 얻었습니다. 여러 학생들이 Python에 이미 존재한다고 가정하고 이 표기법(특히 \u003ccode\u003eset\u003c/code\u003e 버전)을 솔루션에 사용했습니다. 이는 이 표기법이 초보자에게도 직관적임을 시사합니다. 반대로, 기존 구문인 \u003ccode\u003e[x for it in its for x in it]\u003c/code\u003e는 학생들이 종종 틀리는 부분이며, 많은 학생들이 \u003ccode\u003efor\u003c/code\u003e 절의 순서를 뒤바꾸는 경향이 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, 이 PEP가 발표된 후 Reddit 게시물의 댓글 섹션은 이 제안에 대한 상당한 지지를 보여주며, 여기에 제안된 구문이 가독성이 좋고, 직관적이며, 유용하다는 점을 시사합니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003ch3\u003e구문 (Syntax)\u003c/h3\u003e\n\u003cp\u003e문법은 \u003ccode\u003elist\u003c/code\u003e/\u003ccode\u003eset\u003c/code\u003e Comprehension 및 \u003ccode\u003egenerator expression\u003c/code\u003e에서 표현식 앞에 \u003ccode\u003e*\u003c/code\u003e를 허용하도록 변경되어야 합니다. 또한 \u003ccode\u003edictionary comprehension\u003c/code\u003e의 대체 형식으로 \u003ccode\u003ekey: value\u003c/code\u003e 쌍 대신 \u003ccode\u003edouble-starred\u003c/code\u003e 표현식을 사용할 수 있도록 허용해야 합니다.\u003c/p\u003e\n\u003cp\u003e이는 \u003ccode\u003elistcomp\u003c/code\u003e 및 \u003ccode\u003esetcomp\u003c/code\u003e 규칙을 \u003ccode\u003enamed_expression\u003c/code\u003e 대신 \u003ccode\u003estar_named_expression\u003c/code\u003e을 사용하도록 업데이트함으로써 달성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elistcomp[expr_ty]:\n    | '[' a=star_named_expression b=for_if_clauses ']'\nsetcomp[expr_ty]:\n    | '{' a=star_named_expression b=for_if_clauses '}'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egenexp\u003c/code\u003e 규칙도 유사하게 \u003ccode\u003estarred_expression\u003c/code\u003e을 허용하도록 수정해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egenexp[expr_ty]:\n    | '(' a=(assignment_expression | expression !':=' | starred_expression) b=for_if_clauses ')'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edictionary comprehension\u003c/code\u003e 규칙도 이 새로운 형식을 허용하도록 조정해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edictcomp[expr_ty]:\n    | '{' a=double_starred_kvpair b=for_if_clauses '}'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e함수 호출에서 인자 언패킹이 처리되는 방식에는 변경이 없어야 합니다. 즉, 함수에 유일한 인수로 제공되는 \u003ccode\u003egenerator expression\u003c/code\u003e이 추가적인 중복 괄호를 필요로 하지 않는다는 일반 규칙은 유지되어야 합니다. 이는 예를 들어 \u003ccode\u003ef(*x for x in it)\u003c/code\u003e가 \u003ccode\u003ef((*x for x in it))\u003c/code\u003e와 동일함을 의미합니다. (\u003ccode\u003eStarred Generators as Function Arguments\u003c/code\u003e 섹션에서 더 자세한 논의를 참조하십시오).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e*\u003c/code\u003e 및 \u003ccode\u003e**\u003c/code\u003e는 Comprehension 내 표현식의 최상위 레벨에서만 허용되어야 합니다. (\u003ccode\u003eFurther Generalizing Unpacking Operators\u003c/code\u003e 섹션에서 더 자세한 논의를 참조하십시오).\u003c/p\u003e\n\u003ch3\u003e의미론: List/Set/Dict Comprehension (Semantics: List/Set/Dict Comprehensions)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003elist comprehension\u003c/code\u003e 내에서 별표가 붙은 표현식 \u003ccode\u003e[*expr for x in it]\u003c/code\u003e의 의미는 각 표현식을 \u003ccode\u003eiterable\u003c/code\u003e로 취급하고, \u003ccode\u003e[*expr1, *expr2, ...]\u003c/code\u003e와 같이 명시적으로 나열된 것처럼 이들을 연결하는 것입니다. 유사하게, \u003ccode\u003e{*expr for x in it}\u003c/code\u003e는 \u003ccode\u003e{*expr1, *expr2, ...}\u003c/code\u003e와 같이 명시적으로 나열된 것처럼 \u003ccode\u003eset union\u003c/code\u003e을 형성합니다. 그리고 \u003ccode\u003e{ **expr for x in it}\u003c/code\u003e는 \u003ccode\u003e{** expr1, **expr2, ...}\u003c/code\u003e와 같이 명시적으로 나열된 것처럼 딕셔너리를 결합합니다. 이러한 연산은 이 방식으로 컬렉션을 결합하는 모든 동등한 의미론(예: 딕셔너리를 결합할 때 중복된 키의 경우 나중 값이 이전 값을 덮어쓰는 것 포함)을 유지해야 합니다.\u003c/p\u003e\n\u003cp\u003e다시 말해, 다음 Comprehension에 의해 생성된 객체들은:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003enew_list = [*expr for x in its]\nnew_set = {*expr for x in its}\nnew_dict = {**expr for d in dicts}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e각각 다음 코드 조각에 의해 생성된 객체들과 동등해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003enew_list = []\nfor x in its:\n    new_list.extend(expr)\n\nnew_set = set()\nfor x in its:\n    new_set.update(expr)\n\nnew_dict = {}\nfor x in dicts:\n    new_dict.update(expr)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e의미론: Generator Expression (Semantics: Generator Expressions)\u003c/h3\u003e\n\u003cp\u003e언패킹 구문을 사용하는 \u003ccode\u003egenerator expression\u003c/code\u003e은 표현식에 의해 주어진 iterable들을 연결하여 값을 생성하는 새로운 \u003ccode\u003egenerator\u003c/code\u003e를 형성해야 합니다. 특히, 동작은 다음 코드와 동일하게 정의됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# g = (*expr for x in it) 와 동일\ndef generator():\n    for x in it:\n        yield from expr\ng = generator()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eyield from\u003c/code\u003e은 비동기 \u003ccode\u003egenerator\u003c/code\u003e 내에서 허용되지 않으므로 (PEP 525의 \u003ccode\u003eAsynchronous yield from\u003c/code\u003e 섹션 참조), \u003ccode\u003e(*expr async for x in ait())\u003c/code\u003e의 동등한 표현은 다음과 같습니다 (물론 이 새로운 형식은 루프 변수 \u003ccode\u003ei\u003c/code\u003e를 정의하거나 참조하지 않아야 합니다):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# g = (*expr async for x in ait()) 와 동일\nasync def generator():\n    async for x in ait():\n        for i in expr:\n            yield i\ng = generator()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 의미론의 세부 사항은 미래에 재검토되어야 합니다. 특히 비동기 \u003ccode\u003egenerator\u003c/code\u003e가 \u003ccode\u003eyield from\u003c/code\u003e을 지원하게 된다면 (\u003ccode\u003easync\u003c/code\u003e 변형이 명시적인 루프 대신 \u003ccode\u003eyield from\u003c/code\u003e을 사용하도록 변경될 수 있음). (\u003ccode\u003eAlternative Generator Expression Semantics\u003c/code\u003e 섹션에서 더 자세한 논의를 참조하십시오).\u003c/p\u003e\n\u003ch3\u003e할당 표현식과의 상호작용 (Interaction with Assignment Expressions)\u003c/h3\u003e\n\u003cp\u003e이 제안은 Comprehension의 다양한 부분의 평가 순서나 스코프(scope) 규칙을 변경하지 않습니다. 이는 PEP 572의 \"walrus operator\" \u003ccode\u003e:=\u003c/code\u003e를 사용하는 \u003ccode\u003egenerator expression\u003c/code\u003e에 특히 관련이 있습니다. 이 연산자는 Comprehension 또는 \u003ccode\u003egenerator expression\u003c/code\u003e에서 사용될 때, 변수 바인딩을 Comprehension 내의 지역 스코프가 아닌 포함하는 스코프(containing scope)에서 수행합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003e(*(y := [i, i+1]) for i in (0, 2, 4))\u003c/code\u003e 표현식의 평가에서 발생하는 \u003ccode\u003egenerator\u003c/code\u003e를 고려해 봅시다. 이는 다음 \u003ccode\u003egenerator\u003c/code\u003e와 거의 동일하지만, \u003ccode\u003egenerator expression\u003c/code\u003e 형태에서는 \u003ccode\u003ey\u003c/code\u003e가 지역적으로 바인딩되는 대신 포함하는 스코프에서 바인딩됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef generator():\n    for i in (0, 2, 4):\n        yield from (y := [i, i+1])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서, 서브 표현식 \u003ccode\u003e(y := [i, i+1])\u003c/code\u003e는 \u003ccode\u003egenerator\u003c/code\u003e가 소진되기 전에 정확히 세 번 평가됩니다: Comprehension에서 \u003ccode\u003ei\u003c/code\u003e가 각각 \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003e2\u003c/code\u003e, \u003ccode\u003e4\u003c/code\u003e로 할당된 직후입니다. 따라서 \u003ccode\u003ey\u003c/code\u003e(포함하는 스코프 내)는 해당 시점에 수정됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e g = (*(y := [i, i+1]) for i in (0, 2, 4))\n\u003e\u003e\u003e y\nTraceback (most recent call last):\n  File \"\u0026#x3C;python-input-1\u003e\", line 1, in \u0026#x3C;module\u003e\nNameError: name 'y' is not defined\n\u003e\u003e\u003e next(g)\n0\n\u003e\u003e\u003e y\n[0, 1]\n\u003e\u003e\u003e next(g)\n1\n\u003e\u003e\u003e y\n[0, 1]\n\u003e\u003e\u003e next(g)\n2\n\u003e\u003e\u003e y\n[2, 3]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e오류 보고 (Error Reporting)\u003c/h3\u003e\n\u003cp\u003e현재 제안된 구문은 \u003ccode\u003eSyntaxError\u003c/code\u003e를 발생시킵니다. 이러한 형식이 구문적으로 유효한 것으로 인식되도록 허용하려면 \u003ccode\u003einvalid_comprehension\u003c/code\u003e 및 \u003ccode\u003einvalid_dict_comprehension\u003c/code\u003e에 대한 문법 규칙을 각각 \u003ccode\u003e*\u003c/code\u003e 및 \u003ccode\u003e **\u003c/code\u003e 사용을 허용하도록 조정해야 합니다.\u003c/p\u003e\n\u003cp\u003e최소한 다음 경우에 추가적인 특정 오류 메시지가 제공되어야 합니다:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003elist comprehension\u003c/code\u003e 또는 \u003ccode\u003egenerator expression\u003c/code\u003e에서 \u003ccode\u003e** \u003c/code\u003e를 사용하려고 시도하면 딕셔너리 언패킹이 해당 구조에서 사용될 수 없음을 보고해야 합니다. 예를 들면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e [ **x for x in y]\n  File \"\u0026#x3C;stdin\u003e\", line 1\n    [** x for x in y]\n    ^^^\nSyntaxError: cannot use dict unpacking in list comprehension\n\u003e\u003e\u003e ( **x for x in y)\n  File \"\u0026#x3C;stdin\u003e\", line 1\n    (** x for x in y)\n    ^^^\nSyntaxError: cannot use dict unpacking in generator expression\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edictionary key/value\u003c/code\u003e에서 \u003ccode\u003e*\u003c/code\u003e를 사용하려고 시도할 때의 기존 오류 메시지는 유지되어야 하지만, \u003ccode\u003edictionary key\u003c/code\u003e 또는 \u003ccode\u003evalue\u003c/code\u003e에서 \u003ccode\u003e**\u003c/code\u003e 언패킹을 사용하려고 시도할 때도 유사한 메시지가 보고되어야 합니다. 예를 들면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e {*k: v for k,v in items}\n  File \"\u0026#x3C;stdin\u003e\", line 1\n    {*k: v for k,v in items}\n    ^^\nSyntaxError: cannot use a starred expression in a dictionary key\n\u003e\u003e\u003e {k: *v for k,v in items}\n  File \"\u0026#x3C;stdin\u003e\", line 1\n    {k: *v for k,v in items}\n    ^^\nSyntaxError: cannot use a starred expression in a dictionary value\n\u003e\u003e\u003e { **k: v for k,v in items}\n  File \"\u0026#x3C;stdin\u003e\", line 1\n    {** k: v for k,v in items}\n    ^^^\nSyntaxError: cannot use dict unpacking in a dictionary key\n\u003e\u003e\u003e {k: **v for k,v in items}\n  File \"\u0026#x3C;stdin\u003e\", line 1\n    {k: ** v for k,v in items}\n    ^^^\nSyntaxError: cannot use dict unpacking in a dictionary value\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 기존 오류 메시지의 문구도 새 구문의 존재를 설명하고, 또는 언패킹과 일반적으로 관련된 모호하거나 혼란스러운 경우(특히 \u003ccode\u003eFurther Generalizing Unpacking Operators\u003c/code\u003e에서 언급된 경우)를 명확히 하기 위해 조정되어야 합니다. 예를 들면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e [*x if x else y]\n  File \"\u0026#x3C;stdin\u003e\", line 1\n    [*x if x else y]\n    ^^^^^^^^^^^^^^\nSyntaxError: invalid starred expression. Did you forget to wrap the conditional expression in parentheses?\n\u003e\u003e\u003e { **x if x else y}\n  File \"\u0026#x3C;stdin\u003e\", line 1\n    {** x if x else y}\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid double starred expression. Did you forget to wrap the conditional expression in parentheses?\n\u003e\u003e\u003e [x if x else *y]\n  File \"\u0026#x3C;stdin\u003e\", line 1\n    [x if x else *y]\n    ^\nSyntaxError: cannot unpack only part of a conditional expression\n\u003e\u003e\u003e {x if x else **y}\n  File \"\u0026#x3C;stdin\u003e\", line 1\n    {x if x else ** y}\n    ^^\nSyntaxError: cannot use dict unpacking on only part of a conditional expression\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e참조 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003e참조 구현은 이 기능을 구현하며, 초안 문서와 추가 테스트 케이스를 포함합니다.\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e현재 구문적으로 유효한 모든 Comprehension의 동작은 이 변경의 영향을 받지 않으므로, 하위 호환성 문제가 많지는 않을 것으로 예상됩니다. 원칙적으로 이 변경은 Comprehension에서 언패킹 연산을 시도하면 \u003ccode\u003eSyntaxError\u003c/code\u003e가 발생한다는 사실에 의존하는 코드, 또는 대체되는 이전 오류 메시지의 특정 문구에 의존하는 코드에만 영향을 미칠 것입니다. 이는 드물 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e하나의 관련 우려는 미래에 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e의 의미론을 변경하여 언패킹 시 \u003ccode\u003eyield from\u003c/code\u003e을 사용하도록(언패킹되는 \u003ccode\u003egenerator\u003c/code\u003e에게 위임하도록) 결정하는 경우입니다. 이는 \u003ccode\u003e.asend()\u003c/code\u003e, \u003ccode\u003e.athrow()\u003c/code\u003e, \u003ccode\u003e.aclose()\u003c/code\u003e와 함께 사용될 때 결과 \u003ccode\u003egenerator\u003c/code\u003e의 동작에 영향을 미치므로 하위 호환성이 없을 것입니다. 그러나 하위 호환성이 없음에도 불구하고, 이러한 변경은 이 제안 하에서 특별히 유용하지 않은 구조의 동작에만 영향을 미치므로 큰 영향을 미치지 않을 가능성이 높습니다. (\u003ccode\u003eAlternative Generator Expression Semantics\u003c/code\u003e 섹션에서 더 자세한 논의를 참조하십시오).\u003c/p\u003e\n\u003ch2\u003e코드 예시 (Code Examples)\u003c/h2\u003e\n\u003cp\u003e이 섹션은 표준 라이브러리의 작은 코드 조각들을 어떻게 이 새로운 구문을 사용하여 간결성과 가독성을 향상시키도록 다시 작성할 수 있는지 보여주는 예시를 제시합니다. 참조 구현은 이러한 대체가 이루어진 후에도 모든 테스트를 통과합니다.\u003c/p\u003e\n\u003ch3\u003e명시적 루프 대체 (Replacing Explicit Loops)\u003c/h3\u003e\n\u003cp\u003e명시적 루프를 대체하면 여러 줄이 한 줄로 압축되고, 보조 변수를 정의하고 참조할 필요가 없어집니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eemail/_header_value_parser.py\u003c/code\u003e에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재:\ncomments = []\nfor token in self:\n    comments.extend(token.comments)\nreturn comments\n\n# 개선:\nreturn [*token.comments for token in self]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eshutil.py\u003c/code\u003e에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재:\nignored_names = []\nfor pattern in patterns:\n    ignored_names.extend(fnmatch.filter(names, pattern))\nreturn set(ignored_names)\n\n# 개선:\nreturn {*fnmatch.filter(names, pattern) for pattern in patterns}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ehttp/cookiejar.py\u003c/code\u003e에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재:\ncookies = []\nfor domain in self._cookies.keys():\n    cookies.extend(self._cookies_for_domain(domain, request))\nreturn cookies\n\n# 개선:\nreturn [\n    *self._cookies_for_domain(domain, request) for domain in self._cookies.keys()\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003ccode\u003efrom_iterable\u003c/code\u003e 및 관련 함수 대체 (Replacing from_iterable and Friends)\u003c/h3\u003e\n\u003cp\u003e항상 올바른 선택은 아니지만, \u003ccode\u003eitertools.chain.from_iterable\u003c/code\u003e 및 \u003ccode\u003emap\u003c/code\u003e을 대체하면 추가적인 간접 레벨을 피할 수 있어, Comprehension이 \u003ccode\u003emap\u003c/code\u003e/\u003ccode\u003efilter\u003c/code\u003e보다 가독성이 좋다는 일반적인 통념을 따르는 코드가 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edataclasses.py\u003c/code\u003e에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재:\ninherited_slots = set(\n    itertools.chain.from_iterable(map(_get_slots, cls.__mro__[1:-1]))\n)\n\n# 개선:\ninherited_slots = {*_get_slots(c) for c in cls.__mro__[1:-1]}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eimportlib/metadata/__init__.py\u003c/code\u003e에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재:\nreturn itertools.chain.from_iterable(\n    path.search(prepared) for path in map(FastPath, paths)\n)\n\n# 개선:\nreturn (*FastPath(path).search(prepared) for path in paths)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ecollections/__init__.py\u003c/code\u003e (\u003ccode\u003eCounter\u003c/code\u003e 클래스)에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재:\nreturn _chain.from_iterable(_starmap(_repeat, self.items()))\n\n# 개선:\nreturn (*_repeat(elt, num) for elt, num in self.items())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ezipfile/_path/__init__.py\u003c/code\u003e에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재:\nparents = itertools.chain.from_iterable(map(_parents, names))\n\n# 개선:\nparents = (*_parents(name) for name in names)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e_pyrepl/_module_completer.py\u003c/code\u003e에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재:\nsearch_locations = set(chain.from_iterable(\n    getattr(spec, 'submodule_search_locations', []) for spec in specs if spec\n))\n\n# 개선:\nsearch_locations = {\n    *getattr(spec, 'submodule_search_locations', []) for spec in specs if spec\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eComprehension 내 이중 루프 대체 (Replacing Double Loops in Comprehensions)\u003c/h3\u003e\n\u003cp\u003eComprehension 내 이중 루프를 대체하면 보조 변수를 정의하고 참조할 필요가 없어 혼란을 줄일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimportlib/resources/readers.py\u003c/code\u003e에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재:\nchildren = (child for path in self._paths for child in path.iterdir())\n\n# 개선:\nchildren = (*path.iterdir() for path in self._paths)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003easyncio/base_events.py\u003c/code\u003e에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재:\nexceptions = [exc for sub in exceptions for exc in sub]\n\n# 개선:\nexceptions = [*sub for sub in exceptions]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e_weakrefset.py\u003c/code\u003e에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재:\nreturn self.__class__(e for s in (self, other) for e in s)\n\n# 개선:\nreturn self.__class__(*s for s in (self, other))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e교육 방법 (How to Teach This)\u003c/h2\u003e\n\u003cp\u003e현재 Comprehension의 개념을 소개하는 일반적인 방법(Python 튜토리얼에서 사용됨)은 동등한 코드를 보여주는 것입니다. 예를 들어, 이 방법은 \u003ccode\u003eout = [expr for x in it]\u003c/code\u003e가 다음 코드와 동일하다고 말할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eout = []\nfor x in it:\n    out.append(expr)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 접근 방식을 취하면 \u003ccode\u003eout = [*expr for x in it]\u003c/code\u003e를 대신 다음 코드와 동일하다고 소개할 수 있습니다 (\u003ccode\u003eappend\u003c/code\u003e 대신 \u003ccode\u003eextend\u003c/code\u003e 사용):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eout = []\nfor x in it:\n    out.extend(expr)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e언패킹을 사용하는 \u003ccode\u003eset\u003c/code\u003e 및 \u003ccode\u003edict comprehension\u003c/code\u003e도 유사한 비유를 통해 소개될 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# out = {expr for x in it} 와 동일\nout = set()\nfor x in it:\n    out.add(expr)\n\n# out = {*expr for x in it} 와 동일\nout = set()\nfor x in it:\n    out.update(expr)\n\n# out = {k_expr: v_expr for x in it} 와 동일\nout = {}\nfor x in it:\n    out[k_expr] = v_expr\n\n# out = { **expr for x in it} 와 동일 (expr이 ** 로 언패킹될 수 있는 매핑으로 평가되는 경우)\nout = {}\nfor x in it:\n    out.update(expr)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 언패킹을 포함하는 \u003ccode\u003egenerator expression\u003c/code\u003e의 동작을 설명하기 위해 유사한 접근 방식을 취할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# g = (expr for x in it) 와 동일\ndef generator():\n    for x in it:\n        yield expr\ng = generator()\n\n# g = (*expr for x in it) 와 동일\ndef generator():\n    for x in it:\n        yield from expr\ng = generator()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 특정 예시들로부터, 별표가 없는 Comprehension/genexp가 컬렉션에 단일 요소를 추가하는 연산자를 사용하는 모든 곳에서, 별표가 있는 버전은 대신 해당 컬렉션에 여러 요소를 추가하는 연산자를 사용할 것이라는 아이디어로 일반화할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e대안으로, 두 아이디어를 별개로 생각할 필요 없이, 새로운 구문을 통해 \u003ccode\u003eout = [...x... for x in it]\u003c/code\u003e를 다음 코드와 동일하다고 생각할 수 있습니다 (여기서 \u003ccode\u003e...x...\u003c/code\u003e는 임의의 코드를 나타냅니다), \u003ccode\u003e...x...\u003c/code\u003e가 \u003ccode\u003e*\u003c/code\u003e를 사용하는지 여부와 관계없이:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eout = []\nfor x in it:\n    out.extend([...x...])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마찬가지로, \u003ccode\u003eout = {...x... for x in it}\u003c/code\u003e를 다음 코드와 동일하다고 생각할 수 있습니다. \u003ccode\u003e...x...\u003c/code\u003e가 \u003ccode\u003e*\u003c/code\u003e 또는 \u003ccode\u003e**\u003c/code\u003e 또는 \u003ccode\u003e:\u003c/code\u003e를 사용하는지 여부와 관계없이:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eout = set() # 또는 out = {}\nfor x in it:\n    out.update({...x...})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 예시는 Comprehension이 있는 버전과 없는 버전 모두에서 동일한 출력을 생성한다는 의미에서 동등하지만, Comprehension이 없는 버전은 각 \u003ccode\u003eextend\u003c/code\u003e 또는 \u003ccode\u003eupdate\u003c/code\u003e 전에 새로운 \u003ccode\u003elist\u003c/code\u003e/\u003ccode\u003eset\u003c/code\u003e/\u003ccode\u003edictionary\u003c/code\u003e를 만들기 때문에 약간 덜 효율적입니다. 이는 Comprehension을 사용하는 버전에서는 불필요합니다.\u003c/p\u003e\n\u003ch2\u003e거부된 대안 제안 (Rejected Alternative Proposals)\u003c/h2\u003e\n\u003cp\u003e위 명세에 대해 생각할 때 주된 목표는 언패킹 및 Comprehension / \u003ccode\u003egenerator expression\u003c/code\u003e에 대한 기존 규범과의 일관성이었습니다. 이를 해석하는 한 가지 방법은 기존 문법 및 코드 생성에 가능한 가장 작은 변경 사항만 요구하도록 명세를 작성하여, 기존 코드가 주변 의미론을 형성하도록 하는 것이 목표였다는 것입니다.\u003c/p\u003e\n\u003cp\u003e아래에서는 논의에서 제기되었지만 이 제안에 포함되지 않은 일반적인 우려/대안 제안 중 일부를 논의합니다.\u003c/p\u003e\n\u003ch3\u003e함수 인수로 사용되는 Starred Generator (Starred Generators as Function Arguments)\u003c/h3\u003e\n\u003cp\u003e여러 번 제기된 일반적인 우려(위에서 링크된 논의 스레드뿐만 아니라 이와 동일한 아이디어에 대한 이전 논의에서도)는 \u003ccode\u003ef(*x for x in y)\u003c/code\u003e와 같이 별표가 붙은 \u003ccode\u003egenerator\u003c/code\u003e를 함수의 단일 인수로 전달할 때 발생할 수 있는 구문적 모호성입니다. 원래 PEP 448에서는 이 모호성이 제안의 일부로 유사한 일반화를 포함하지 않은 이유로 언급되었습니다.\u003c/p\u003e\n\u003cp\u003e이 제안은 \u003ccode\u003ef(*x for x in y)\u003c/code\u003e가 \u003ccode\u003ef((*x for x in y))\u003c/code\u003e로 해석되어야 하며, 결과 \u003ccode\u003egenerator\u003c/code\u003e에 대한 추가 언패킹을 시도해서는 안 된다고 제안합니다. 그러나 논의에서는 몇 가지 대안이 제시되었습니다(및/또는 과거에 제시된 바 있음), 예를 들어:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ef(*x for x in y)\u003c/code\u003e를 \u003ccode\u003ef(*(x for x in y))\u003c/code\u003e로 해석하거나,\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ef(*x for x in y)\u003c/code\u003e를 \u003ccode\u003ef(*(*x for x in y))\u003c/code\u003e로 해석하거나,\u003c/li\u003e\n\u003cli\u003e이 제안의 다른 측면이 수락되더라도 \u003ccode\u003ef(*x for x in y)\u003c/code\u003e에 대해 계속 \u003ccode\u003eSyntaxError\u003c/code\u003e를 발생시키는 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 대안보다 이 제안을 선호하는 이유는 \u003ccode\u003egenerator expression\u003c/code\u003e 주변의 기존 구두점 규칙을 유지하기 위함입니다. 현재 일반적인 규칙은 \u003ccode\u003egenerator expression\u003c/code\u003e이 함수의 단일 인수로 제공되는 경우를 제외하고는 괄호로 묶여야 한다는 것입니다. 이 제안은 더 많은 종류의 \u003ccode\u003egenerator expression\u003c/code\u003e을 허용하더라도 이 규칙을 유지할 것을 제안합니다. 이 옵션은 언패킹을 사용하는 Comprehension 및 \u003ccode\u003egenerator expression\u003c/code\u003e과 그렇지 않은 것들 사이에 완전한 대칭을 유지합니다.\u003c/p\u003e\n\u003cp\u003e현재 우리는 다음 규칙을 가지고 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ef([x for x in y])   # 단일 list 전달\nf({x for x in y})   # 단일 set 전달\nf(x for x in y)     # 단일 generator 전달 (genexp 주변에 추가 괄호 불필요)\nf(*[x for x in y])  # list의 요소들을 개별적으로 전달\nf(*{x for x in y})  # set의 요소들을 개별적으로 전달\nf(*(x for x in y)) # generator의 요소들을 개별적으로 전달 (괄호 필요)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 제안은 Comprehension이 언패킹을 사용하는 경우에도 이러한 규칙을 유지하기로 선택합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ef([*x for x in y])   # 단일 list 전달\nf({*x for x in y})   # 단일 set 전달\nf(*x for x in y)     # 단일 generator 전달 (genexp 주변에 추가 괄호 불필요)\nf(*[*x for x in y])  # list의 요소들을 개별적으로 전달\nf(*{*x for x in y})  # set의 요소들을 개별적으로 전달\nf(*(*x for x in y)) # generator의 요소들을 개별적으로 전달 (괄호 필요)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e언패킹 연산자 추가 일반화 (Further Generalizing Unpacking Operators)\u003c/h3\u003e\n\u003cp\u003e논의에서 나온 또 다른 제안은 Comprehension 내에서 표현식을 언패킹하는 것을 허용하는 것 이상으로 \u003ccode\u003e*\u003c/code\u003e를 더욱 일반화하는 것이었습니다. 이 확장의 두 가지 주요 유형이 고려되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e*\u003c/code\u003e 및 \u003ccode\u003e**\u003c/code\u003e를 새로운 종류의 \u003ccode\u003eUnpackable\u003c/code\u003e 객체(또는 유사한 것)를 생성하는 진정한 단항 연산자로 만들어서, Comprehension이 이를 언패킹하여 처리할 수 있지만 다른 컨텍스트에서도 사용될 수 있도록 하는 것; 또는\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e*\u003c/code\u003e 및 \u003ccode\u003e**\u003c/code\u003e를 이 제안에서 허용되는 다른 곳(표현식 리스트, Comprehension, \u003ccode\u003egenerator expression\u003c/code\u003e, 인자 리스트)에서만 허용하되, Comprehension 내의 서브 표현식에서도 사용할 수 있도록 허용하여, 예를 들어 일부 iterable 객체와 일부 non-iterable 객체를 포함하는 리스트를 평탄화하는 방법으로 다음을 허용하는 것:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e[*x if isinstance(x, Iterable) else x for x in [[1,2,3], 4]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 변형은 (이해하고 구현하기에) 실질적으로 더 복잡하고 유용성이 미미하다고 간주되어 이 PEP에 포함되지 않았습니다. 따라서 이러한 형식은 계속 \u003ccode\u003eSyntaxError\u003c/code\u003e를 발생시켜야 하지만, 위에서 설명한 새로운 오류 메시지와 함께 제공되어야 합니다. 그러나 미래 제안을 위한 고려 사항으로 배제되어서는 안 됩니다.\u003c/p\u003e\n\u003ch3\u003e대체 Generator Expression 의미론 (Alternative Generator Expression Semantics)\u003c/h3\u003e\n\u003cp\u003e또 다른 논의 지점은 \u003ccode\u003egenerator expression\u003c/code\u003e의 언패킹 의미론, 특히 비동기 \u003ccode\u003egenerator\u003c/code\u003e가 \u003ccode\u003eyield from\u003c/code\u003e을 지원하지 않는다는 점을 고려할 때 동기 및 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e의 의미론 간의 관계에 중점을 두었습니다 (PEP 525의 \u003ccode\u003eAsynchronous yield from\u003c/code\u003e 섹션 참조).\u003c/p\u003e\n\u003cp\u003e핵심 질문은 동기 및 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e이 언패킹할 때 명시적인 루프 대신 \u003ccode\u003eyield from\u003c/code\u003e(또는 동등한 것)을 사용해야 하는지에 대한 것이었습니다. 이러한 옵션 간의 주요 차이점은 결과 \u003ccode\u003egenerator\u003c/code\u003e가 언패킹되는 객체에 위임하는지 여부입니다. 이는 언패킹되는 객체 자체가 \u003ccode\u003egenerator\u003c/code\u003e인 경우 \u003ccode\u003e.send()/.asend()\u003c/code\u003e, \u003ccode\u003e.throw()/.athrow()\u003c/code\u003e, \u003ccode\u003e.close()/.aclose()\u003c/code\u003e와 함께 사용될 때 이러한 \u003ccode\u003egenerator expression\u003c/code\u003e의 동작에 영향을 미칠 것입니다. 이러한 옵션 간의 차이점은 \u003ccode\u003eAppendix: Semantics of Generator Delegation\u003c/code\u003e에 요약되어 있습니다.\u003c/p\u003e\n\u003cp\u003e몇 가지 합리적인 옵션이 고려되었으며, Discourse 스레드의 투표에서 명확한 승자는 없었습니다. 위에서 설명한 제안 외에 다음도 고려되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e동기 및 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e 모두에 명시적 루프를 사용하는 것.\u003c/p\u003e\n\u003cp\u003e이 전략은 동기 및 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e 사이에 대칭성을 가져왔겠지만, 동기 \u003ccode\u003egenerator expression\u003c/code\u003e의 경우 위임을 허용하지 않아 잠재적으로 유용한 도구를 막았을 것입니다. 이 접근 방식의 한 가지 특정 우려는 동기 및 비동기 \u003ccode\u003egenerator\u003c/code\u003e 간의 비대칭성을 도입하는 것이지만, 이러한 비대칭성이 이미 동기 및 비동기 \u003ccode\u003egenerator\u003c/code\u003e 사이에 더 일반적으로 존재한다는 사실로 인해 이 우려는 완화됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e동기 \u003ccode\u003egenerator expression\u003c/code\u003e의 언패킹에 \u003ccode\u003eyield from\u003c/code\u003e을 사용하고, 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e의 언패킹에 \u003ccode\u003eyield from\u003c/code\u003e의 동작을 모방하는 것.\u003c/p\u003e\n\u003cp\u003e이 전략은 동기 및 비동기 \u003ccode\u003egenerator\u003c/code\u003e의 언패킹 동작을 대칭적으로 만들겠지만, 더 복잡할 것이며, 그 비용이 이점만큼 가치가 없을 수도 있습니다. 따라서 이 PEP는 언패킹 연산자를 사용하는 \u003ccode\u003egenerator expression\u003c/code\u003e이 \u003ccode\u003eyield from\u003c/code\u003e이 비동기 \u003ccode\u003egenerator\u003c/code\u003e에서 더 일반적으로 지원될 때까지 \u003ccode\u003eyield from\u003c/code\u003e과 유사한 의미론을 사용해서는 안 된다고 제안합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e동기 \u003ccode\u003egenerator expression\u003c/code\u003e의 언패킹에 \u003ccode\u003eyield from\u003c/code\u003e을 사용하고, 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e이 \u003ccode\u003eyield from\u003c/code\u003e을 지원할 때까지 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e에서의 언패킹을 금지하는 것.\u003c/p\u003e\n\u003cp\u003e이 전략은 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e이 미래에 \u003ccode\u003eyield from\u003c/code\u003e에 대한 지원을 얻게 된다면, 그때 내려지는 모든 결정이 완전히 하위 호환성을 갖도록 보장함으로써 마찰을 줄일 수 있을 것입니다. 그러나 그 컨텍스트에서 언패킹의 유용성은 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e이 \u003ccode\u003eyield from\u003c/code\u003e에 대한 지원을 받는 경우 미래에 최소한의 침해적인 하위 비호환성 변경의 잠재적인 단점보다 클 것으로 보입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e모든 \u003ccode\u003egenerator expression\u003c/code\u003e에서 언패킹을 금지하는 것.\u003c/p\u003e\n\u003cp\u003e이는 두 경우 사이에 대칭성을 유지하겠지만, 매우 표현적인 형태를 잃는 단점이 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 각 옵션(이 PEP에 제시된 옵션 포함)은 장점과 단점을 가지고 있으며, 모든 면에서 명확하게 우월한 옵션은 없습니다. \u003ccode\u003eSemantics: Generator Expressions\u003c/code\u003e에 제안된 의미론은 동기 및 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e 모두에서 언패킹이 현재 동등한 \u003ccode\u003egenerator\u003c/code\u003e를 작성하는 일반적인 방법을 반영하는 합리적인 절충안을 나타냅니다. 또한, 이러한 미묘한 차이는 일반적인 사용 사례에 큰 영향을 미치지 않을 가능성이 높습니다 (예를 들어, 단순 컬렉션을 결합하는 가장 흔한 사용 사례에는 차이가 없습니다).\u003c/p\u003e\n\u003cp\u003e위에서 제안된 바와 같이, 이 결정은 비동기 \u003ccode\u003egenerator\u003c/code\u003e가 미래에 \u003ccode\u003eyield from\u003c/code\u003e에 대한 지원을 받을 경우 재검토되어야 하며, 이 경우 비동기 \u003ccode\u003egenerator expression\u003c/code\u003e에서 언패킹의 의미론을 \u003ccode\u003eyield from\u003c/code\u003e을 사용하도록 조정하는 것을 고려해야 합니다.\u003c/p\u003e\n\u003ch2\u003e우려 사항 및 단점 (Concerns and Disadvantages)\u003c/h2\u003e\n\u003cp\u003e논의 스레드에서 전반적인 합의는 이 구문이 명확하고 직관적이라는 것이었지만, 몇 가지 우려 사항과 잠재적인 단점도 제기되었습니다. 이 섹션은 이러한 우려 사항을 요약하는 것을 목표로 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e기존 대안과의 중복:\u003c/strong\u003e 제안된 구문이 더 명확하고 간결하다고 주장할 수 있지만, Python에는 이미 동일한 작업을 수행하는 여러 가지 방법이 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e함수 호출 모호성:\u003c/strong\u003e \u003ccode\u003ef(*x for x in y)\u003c/code\u003e와 같은 표현식은 \u003ccode\u003egenerator\u003c/code\u003e를 언패킹하려는 것인지 또는 단일 인수로 전달하려는 것인지가 명확하지 않아 처음에는 모호하게 보일 수 있습니다. 이 제안은 이 형식을 \u003ccode\u003ef((*x for x in y))\u003c/code\u003e와 동일하게 처리하여 기존 규칙을 유지하지만, 이 동등성이 즉시 명확하지 않을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e과도한 사용 또는 오용 가능성:\u003c/strong\u003e Comprehension에서 언패킹을 복잡하게 사용하면 명시적 루프에서 더 명확할 수 있는 로직을 모호하게 만들 수 있습니다. 이는 Comprehension 전반에 걸쳐 이미 우려되는 사항이지만, \u003ccode\u003e*\u003c/code\u003e 및 \u003ccode\u003e**\u003c/code\u003e의 추가는 특히 복잡한 사용을 한눈에 읽고 이해하기 훨씬 더 어렵게 만들 수 있습니다. 예를 들어, 이러한 상황이 드물기는 하지만, 여러 방식으로 언패킹을 사용하는 Comprehension은 무엇이 언제 언패킹되는지 알기 어렵게 만들 수 있습니다: \u003ccode\u003ef(*(*x for *x, _ in list_of_lists))\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e스코프 제한의 불명확성:\u003c/strong\u003e 이 제안은 언패킹을 Comprehension 표현식의 최상위 레벨로 제한하지만, 일부 사용자는 \u003ccode\u003eFurther Generalizing Unpacking Operators\u003c/code\u003e에서 논의된 바와 같이 언패킹 연산자가 추가로 일반화될 것이라고 예상할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e외부 도구에 미치는 영향:\u003c/strong\u003e Python 구문의 다른 변경 사항과 마찬가지로, 이 변경 사항은 코드 포매터, 린터, 타입 체커 등의 유지보수자에게 새로운 구문이 지원되도록 작업을 생성할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e부록: 다른 언어 (Appendix: Other Languages)\u003c/h2\u003e\n\u003cp\u003e꽤 많은 다른 언어들이 Python에 이미 있는 것과 유사한 구문으로 이러한 종류의 평탄화(flattening)를 지원하지만, Comprehension 내에서 언패킹 구문을 사용하는 것에 대한 지원은 드뭅니다. 이 섹션은 몇 가지 다른 언어에서 유사한 구문에 대한 지원을 간략하게 요약합니다.\u003c/p\u003e\n\u003cp\u003eComprehension을 지원하는 많은 언어들은 이중 루프를 지원합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# python\n[x for xs in [[1,2,3], [], [4,5]] for x in xs * 2]\n\n-- haskell\n[x | xs \u0026#x3C;- [[1,2,3], [], [4,5]], x \u0026#x3C;- xs ++ xs]\n\n# julia\n[x for xs in [[1,2,3], [], [4,5]] for x in [xs; xs]]\n\n; clojure\n(for [xs [[1 2 3] [] [4 5]] x (concat xs xs)] x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e몇몇 다른 언어들(Comprehension이 없는 언어들도)은 중첩된 구조의 평탄화를 지원하기 위해 내장 함수나 메서드를 통해 이러한 연산을 지원합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# python\nlist(itertools.chain(*(xs*2 for xs in [[1,2,3], [], [4,5]])))\n\n// javascript\n[[1,2,3], [], [4,5]].flatMap(xs =\u003e [...xs, ...xs])\n\n-- haskell\nconcat (map (\\x -\u003e x ++ x) [[1,2,3], [], [4,5]])\n\n# ruby\n[[1, 2, 3], [], [4, 5]].flat_map {|e| e * 2}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 Comprehension과 언패킹을 모두 지원하는 언어는 Comprehension 내에서 언패킹을 허용하는 경향이 없습니다. 예를 들어, Julia에서 다음 표현식은 현재 구문 오류로 이어집니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-julia\"\u003e[xs... for xs in [[1,2,3], [], [4,5]]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e한 가지 반례로, Civet에는 최근 유사한 구문이 추가되었습니다. 예를 들어, 다음은 Civet의 유효한 Comprehension이며, JavaScript의 \u003ccode\u003e...\u003c/code\u003e 구문을 사용하여 언패킹을 활용합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-coffeescript\"\u003efor xs of [[1,2,3], [], [4,5]] then ...(xs++xs)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e부록: Generator 위임의 의미론 (Appendix: Semantics of Generator Delegation)\u003c/h2\u003e\n\u003cp\u003e위에서 설명된 의미론에 대한 일반적인 질문 중 하나는 \u003ccode\u003egenerator expression\u003c/code\u003e 내에서 언패킹할 때 \u003ccode\u003eyield from\u003c/code\u003e을 사용하는 것과 명시적인 루프를 사용하는 것의 차이점에 관한 것이었습니다. 이는 \u003ccode\u003egenerator\u003c/code\u003e의 상당히 고급 기능이므로, 이 부록은 \u003ccode\u003eyield from\u003c/code\u003e을 사용하는 \u003ccode\u003egenerator\u003c/code\u003e와 명시적인 루프를 사용하는 \u003ccode\u003egenerator\u003c/code\u003e 간의 몇 가지 주요 차이점을 요약합니다.\u003c/p\u003e\n\u003ch3\u003e기본 동작 (Basic Behavior)\u003c/h3\u003e\n\u003cp\u003e값에 대한 단순한 반복의 경우, 이는 \u003ccode\u003egenerator expression\u003c/code\u003e에서 언패킹의 가장 일반적인 용도가 될 것으로 예상되며, 두 접근 방식 모두 동일한 결과를 생성합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef yield_from(iterables):\n    for iterable in iterables:\n        yield from iterable\n\ndef explicit_loop(iterables):\n    for iterable in iterables:\n        for item in iterable:\n            yield item\n\n# 두 가지 모두 동일한 값 시퀀스를 생성합니다.\nx = list(yield_from([[1, 2], [3, 4]]))\ny = list(explicit_loop([[1, 2], [3, 4]]))\nprint(x == y) # True 출력\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e고급 Generator 프로토콜 차이 (Advanced Generator Protocol Differences)\u003c/h3\u003e\n\u003cp\u003e차이점은 고급 \u003ccode\u003egenerator\u003c/code\u003e 프로토콜 메서드인 \u003ccode\u003e.send()\u003c/code\u003e, \u003ccode\u003e.throw()\u003c/code\u003e, \u003ccode\u003e.close()\u003c/code\u003e를 사용할 때, 그리고 서브 iterable이 단순 시퀀스가 아닌 \u003ccode\u003egenerator\u003c/code\u003e 자체일 때 나타납니다. 이러한 경우, \u003ccode\u003eyield from\u003c/code\u003e 버전은 관련 신호가 서브 \u003ccode\u003egenerator\u003c/code\u003e에 도달하게 하지만, 명시적 루프가 있는 버전은 그렇지 않습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003e.send()\u003c/code\u003e를 사용한 위임 (Delegation with .send())\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef sub_generator():\n    x = yield \"first\"\n    yield f\"received: {x}\"\n    yield \"last\"\n\ndef yield_from():\n    yield from sub_generator()\n\ndef explicit_loop():\n    for item in sub_generator():\n        yield item\n\n# yield from을 사용하면 값이 서브-generator로 전달됩니다.\ngen1 = yield_from()\nprint(next(gen1)) # \"first\" 출력\nprint(gen1.send(\"hello\")) # \"received: hello\" 출력\nprint(next(gen1)) # \"last\" 출력\n\n# 명시적 루프를 사용하면 .send()가 외부 generator에만 영향을 미칩니다.\n# 값은 서브-generator에 도달하지 않습니다.\ngen2 = explicit_loop()\nprint(next(gen2)) # \"first\" 출력\nprint(gen2.send(\"hello\")) # \"received: None\" 출력 (서브-generator는 \"hello\" 대신 None을 받습니다)\nprint(next(gen2)) # \"last\" 출력\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003ccode\u003e.throw()\u003c/code\u003e를 사용한 예외 처리 (Exception Handling with .throw())\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef sub_generator_with_exception_handling():\n    try:\n        yield \"first\"\n        yield \"second\"\n    except ValueError as e:\n        yield f\"caught: {e}\"\n\ndef yield_from():\n    yield from sub_generator_with_exception_handling()\n\ndef explicit_loop():\n    for item in sub_generator_with_exception_handling():\n        yield item\n\n# yield from을 사용하면 예외가 서브-generator로 전달됩니다.\ngen1 = yield_from()\nprint(next(gen1)) # \"first\" 출력\nprint(gen1.throw(ValueError(\"test\"))) # \"caught: test\" 출력\n\n# 명시적 루프를 사용하면 예외가 외부 generator에만 영향을 미칩니다.\ngen2 = explicit_loop()\nprint(next(gen2)) # \"first\" 출력\nprint(gen2.throw(ValueError(\"test\"))) # ValueError가 발생합니다. 서브-generator는 이를 보지 못합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003ccode\u003e.close()\u003c/code\u003e를 사용한 Generator 정리 (Generator Cleanup with .close())\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 서브-generator에 대한 참조를 유지하여 GC가 명시적 루프 버전을 닫지 않도록 합니다.\nreferences = []\n\ndef sub_generator_with_cleanup():\n    try:\n        yield \"first\"\n        yield \"second\"\n    finally:\n        print(\"sub-generator received GeneratorExit\")\n\ndef yield_from():\n    try:\n        g = sub_generator_with_cleanup()\n        references.append(g)\n        yield from g\n    finally:\n        print(\"outer generator received GeneratorExit\")\n\ndef explicit_loop():\n    try:\n        g = sub_generator_with_cleanup()\n        references.append(g)\n        for item in g:\n            yield item\n    finally:\n        print(\"outer generator received GeneratorExit\")\n\n# yield from을 사용하면 GeneratorExit이 서브-generator로 전달됩니다.\ngen1 = yield_from()\nprint(next(gen1)) # \"first\" 출력\ngen1.close() # 서브-generator를 닫은 다음 외부 generator를 닫습니다.\n\n# 명시적 루프를 사용하면 GeneratorExit이 외부 generator에만 전달됩니다.\ngen2 = explicit_loop()\nprint(next(gen2)) # \"first\" 출력\ngen2.close() # 외부 generator만 닫습니다.\nprint('program finished; GC will close the explicit loop subgenerator')\n# 두 번째 내부 generator는 GC가 프로그램을 마칠 때 닫힙니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2335,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Draft] PEP 798 - Unpacking in Comprehensions\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 14:08:32+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/798/\",\"postId\":\"2025-09-27-pep-0798-unpacking-in-comprehensions\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/794/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Accepted] PEP 794 - Import Name Metadata\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Draft] PEP 798 - Unpacking in Comprehensions\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/799/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Draft] PEP 799 - A dedicatedprofilingpackage for organizing Python profiling tools\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>