3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-17ec11482f243379.js","185","static/chunks/app/layout-c3e2e457f12fb6f6.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js"],""]
4:["slug","python/pep/681","c"]
0:["qd33V0IpW4K1wJhro15P-",[[["",{"children":[["slug","python/pep/681","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"681\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/681","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e975486d410ad4e9.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T4432,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0681/">PEP 681 - Data Class Transforms</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 02-Dec-2021</p>
</blockquote>
<p>PEP 681 – Data Class Transforms</p>
<h2>개요 (Abstract)</h2>
<p>PEP 557은 Python 표준 라이브러리에 <code>dataclass</code>를 도입했습니다. <code>dataclass</code>와 유사한 동작을 제공하지만 표준 타입 어노테이션으로는 설명할 수 없는 인기 있는 라이브러리들(예: <code>attrs</code>, <code>pydantic</code>, SQLAlchemy, Django와 같은 ORM 패키지)이 많습니다.</p>
<p>대부분의 타입 체커, 린터 및 언어 서버는 <code>dataclass</code>를 완벽하게 지원합니다. 이 제안은 이러한 기능을 일반화하고, 서드파티 라이브러리가 특정 데코레이터 함수, 클래스 및 메타클래스가 <code>dataclass</code>와 유사한 동작을 제공함을 나타낼 수 있는 방법을 제공하는 것을 목표로 합니다.</p>
<p>이러한 동작에는 다음이 포함됩니다:</p>
<ul>
<li>선언된 데이터 필드를 기반으로 <code>__init__</code> 메서드 합성.</li>
<li>선택적으로 <code>__eq__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, <code>__ge__</code> 메서드 합성.</li>
<li>정적 타입 체킹 중에 불변성(immutability)을 강제하는 "frozen" 클래스 지원.</li>
<li>정적 타입 체커가 알아야 할 개별 필드의 속성(예: 필드에 기본값이 제공되는지 여부)을 설명하는 "필드 지정자(field specifiers)" 지원.</li>
</ul>
<p>이 제안은 <code>typing.py</code>에 <code>dataclass_transform</code> 데코레이터를 추가하는 것 외에는 CPython에 직접적인 영향을 미치지 않습니다.</p>
<h2>동기 (Motivation)</h2>
<p><code>dataclass</code>와 유사한 의미론을 가진 라이브러리가 타입 체커에 자신의 동작을 선언할 수 있는 기존의 표준적인 방법이 없습니다. 이러한 한계를 해결하기 위해 많은 라이브러리를 위한 Mypy 커스텀 플러그인이 개발되었지만, 이 플러그인들은 다른 타입 체커, 린터 또는 언어 서버에서는 작동하지 않습니다. 또한, 라이브러리 개발자에게는 유지 관리 비용이 많이 들고, Python 개발자는 이러한 플러그인의 존재를 알아야 하고 환경 내에서 다운로드하고 구성해야 합니다.</p>
<h2>근거 (Rationale)</h2>
<p>이 제안의 목적은 <code>dataclass</code>와 유사한 의미론을 가진 모든 라이브러리의 모든 기능을 지원하는 것이 아니라, 정적 타입 체킹과 호환되는 방식으로 이러한 라이브러리의 가장 일반적인 기능을 사용할 수 있도록 하는 것입니다.</p>
<p>미래에 <code>dataclass</code>에 새로운 기능이 추가되면, 적절할 때 <code>dataclass_transform</code>에도 해당 기능에 대한 지원을 추가할 예정입니다. 이 두 기능 세트를 동기화하면 <code>dataclass</code> 사용자가 <code>dataclass_transform</code>를 더 쉽게 이해하고 사용할 수 있으며, 타입 체커에서 <code>dataclass</code> 지원을 유지 관리하는 것이 단순해질 것입니다.</p>
<p>또한, 여러 서드파티 라이브러리에서 채택되었지만 <code>dataclass</code>에서 지원되지 않는 기능에 대해서도 향후 <code>dataclass_transform</code> 지원을 추가하는 것을 고려할 것입니다.</p>
<h2>사양 (Specification)</h2>
<h3><code>dataclass_transform</code> 데코레이터</h3>
<p>이 사양은 <code>typing</code> 모듈에 <code>dataclass_transform</code>라는 새로운 데코레이터 함수를 도입합니다. 이 데코레이터는 데코레이터인 함수 자체, 클래스 또는 메타클래스에 적용될 수 있습니다. <code>dataclass_transform</code>의 존재는 정적 타입 체커에게 데코레이터가 적용된 함수, 클래스 또는 메타클래스가 런타임에 클래스를 변환하여 <code>dataclass</code>와 유사한 동작을 부여하는 "마법"을 수행함을 알립니다.</p>
<ul>
<li><code>dataclass_transform</code>가 <strong>함수</strong>에 적용되면, 해당 데코레이터 함수를 사용하는 것이 <code>dataclass</code>와 유사한 의미론을 적용하는 것으로 간주됩니다.</li>
<li><code>dataclass_transform</code>가 <strong>클래스</strong>에 적용되면, 해당 클래스를 직간접적으로 상속하거나 해당 클래스를 메타클래스로 사용하는 모든 클래스에 <code>dataclass</code>와 유사한 의미론이 적용되는 것으로 간주됩니다.</li>
<li><code>dataclass_transform</code>가 <strong>메타클래스</strong>에 적용되면, 해당 메타클래스를 사용하는 모든 클래스에 <code>dataclass</code>와 유사한 의미론이 적용되는 것으로 간주됩니다.</li>
</ul>
<p>예시 코드는 다음과 같습니다. (구현은 생략되었지만, <code>__init__</code>, <code>__eq__</code>, <code>__ne__</code> 메서드를 합성한다고 가정합니다.)</p>
<pre><code class="language-python"># 데코레이터 함수 예시
_T = TypeVar("_T")

@typing.dataclass_transform()
def create_model(cls: Type[_T]) -> Type[_T]:
    cls.__init__ = ...
    cls.__eq__ = ...
    cls.__ne__ = ...
    return cls

@create_model
class CustomerModel:
    id: int
    name: str

# 클래스 예시
@typing.dataclass_transform()
class ModelBase:
    ...

class CustomerModel(ModelBase):
    id: int
    name: str

# 메타클래스 예시
@typing.dataclass_transform()
class ModelMeta(type):
    ...

class ModelBase(metaclass=ModelMeta):
    ...

class CustomerModel(ModelBase):
    id: int
    name: str
</code></pre>
<h3>데코레이터 함수 및 클래스/메타클래스 매개변수</h3>
<p><code>dataclass</code>와 유사한 기능을 제공하는 데코레이터 함수, 클래스 또는 메타클래스는 특정 동작을 수정하는 매개변수를 받을 수 있습니다. 이 사양은 <code>dataclass_transform</code>에 의해 사용되는 경우 정적 타입 체커가 준수해야 하는 다음 매개변수들을 정의합니다. 각 매개변수는 <code>bool</code> 인수를 받으며, <code>bool</code> 값(<code>True</code> 또는 <code>False</code>)이 정적으로 평가될 수 있어야 합니다.</p>
<ul>
<li><code>eq</code>, <code>order</code>, <code>frozen</code>, <code>init</code>, <code>unsafe_hash</code>: 표준 라이브러리 <code>dataclass</code>에서 지원되는 매개변수이며, PEP 557에 정의된 의미를 가집니다.</li>
<li><code>kw_only</code>, <code>match_args</code>, <code>slots</code>: Python 3.10에서 처음 도입된 표준 라이브러리 <code>dataclass</code>에서 지원되는 매개변수입니다.</li>
</ul>
<h3><code>dataclass_transform</code> 매개변수</h3>
<p><code>dataclass_transform</code>에 전달되는 매개변수는 기본 동작을 어느 정도 사용자 정의할 수 있도록 합니다.</p>
<pre><code class="language-python">def dataclass_transform(
    *,
    eq_default: bool = True,
    order_default: bool = False,
    kw_only_default: bool = False,
    field_specifiers: tuple[type | Callable[..., Any], ...] = (),
    **kwargs: Any,
) -> Callable[[_T], _T]: ...
</code></pre>
<ul>
<li><code>eq_default</code>: 호출자가 <code>eq</code> 매개변수를 생략했을 때 <code>True</code> 또는 <code>False</code>로 가정할지 여부를 나타냅니다. 지정되지 않으면 기본값은 <code>True</code>입니다 (dataclass의 기본값과 동일).</li>
<li><code>order_default</code>: 호출자가 <code>order</code> 매개변수를 생략했을 때 <code>True</code> 또는 <code>False</code>로 가정할지 여부를 나타냅니다. 지정되지 않으면 기본값은 <code>False</code>입니다 (dataclass의 기본값과 동일).</li>
<li><code>kw_only_default</code>: 호출자가 <code>kw_only</code> 매개변수를 생략했을 때 <code>True</code> 또는 <code>False</code>로 가정할지 여부를 나타냅니다. 지정되지 않으면 기본값은 <code>False</code>입니다 (dataclass의 기본값과 동일).</li>
<li><code>field_specifiers</code>: 필드를 설명하는 지원되는 클래스들의 정적 목록을 지정합니다. 일부 라이브러리는 필드 지정자 인스턴스를 할당하는 함수도 제공하며, 이 함수들도 이 튜플에 지정될 수 있습니다. 지정되지 않으면 <code>field_specifiers</code>는 기본적으로 빈 튜플이 됩니다.</li>
<li><code>kwargs</code>: <code>dataclass_transform</code>에 임의의 추가 키워드 인수를 전달할 수 있도록 합니다. 이를 통해 타입 체커는 <code>typing.py</code>의 변경을 기다릴 필요 없이 실험적인 매개변수를 지원할 수 있습니다.</li>
</ul>
<p>예시 코드는 다음과 같습니다.</p>
<pre><code class="language-python"># 데코레이터 함수 예시
@typing.dataclass_transform(kw_only_default=True, order_default=True)
def create_model(
    *,
    frozen: bool = False,
    kw_only: bool = True,
) -> Callable[[Type[_T]], Type[_T]]: ...

@create_model(frozen=True, kw_only=False)
class CustomerModel:
    id: int
    name: str

# 클래스 예시
@typing.dataclass_transform(eq_default=True, order_default=True)
class ModelBase:
    def __init_subclass__(
        cls, *, init: bool = True, frozen: bool = False, eq: bool = True, order: bool = True,
    ): ...

class CustomerModel(
    ModelBase, init=False, frozen=True, eq=False, order=False,
):
    id: int
    name: str

# 메타클래스 예시
@typing.dataclass_transform(eq_default=True, order_default=True)
class ModelMeta(type):
    def __new__(
        cls, name, bases, namespace, *, init: bool = True, frozen: bool = False, eq: bool = True, order: bool = True,
    ): ...

class ModelBase(metaclass=ModelMeta):
    ...

class CustomerModel(
    ModelBase, init=False, frozen=True, eq=False, order=False,
):
    id: int
    name: str
</code></pre>
<h3>필드 지정자 (Field specifiers)</h3>
<p><code>dataclass</code>와 유사한 의미론을 지원하는 대부분의 라이브러리는 클래스 정의가 클래스의 각 필드에 대한 추가 메타데이터를 제공할 수 있도록 하나 이상의 "필드 지정자" 타입을 제공합니다. 이 메타데이터는 예를 들어 기본값을 설명하거나 필드가 합성된 <code>__init__</code> 메서드에 포함되어야 하는지 여부를 나타낼 수 있습니다.</p>
<p>예시:</p>
<pre><code class="language-python">@dataclass
class Employee:
    name: str                               # 지정자 없는 필드
    age: Optional[int] = field(default=None, init=False) # 필드 지정자 인스턴스를 사용하는 필드
    is_paid_hourly: bool = True             # 타입 어노테이션과 간단한 초기화자를 사용하여 기본값을 설명하는 필드
    office_number = "unassigned"            # 타입 어노테이션이 제공되지 않았으므로 필드가 아닌 클래스 변수
</code></pre>
<h3>필드 지정자 매개변수 (Field specifier parameters)</h3>
<p><code>dataclass</code>와 유사한 의미론을 지원하고 필드 지정자 클래스를 지원하는 라이브러리는 일반적으로 이러한 필드 지정자를 구성하기 위해 공통 매개변수 이름을 사용합니다. 이 사양은 정적 타입 체커가 이해해야 하는 매개변수의 이름과 의미를 공식화합니다. 이러한 표준화된 매개변수는 키워드 전용(<code>keyword-only</code>)이어야 합니다.</p>
<p><code>dataclasses.field</code>에서 지원하는 매개변수의 상위 집합입니다 (타입 체킹에 영향을 미치지 않는 <code>compare</code>, <code>hash</code> 등은 제외).</p>
<ul>
<li><code>init</code>: 필드가 합성된 <code>__init__</code> 메서드에 포함되어야 하는지 여부를 나타내는 선택적 <code>bool</code> 매개변수입니다. 지정되지 않으면 <code>init</code>은 기본적으로 <code>True</code>입니다.</li>
<li><code>default</code>: 필드의 기본값을 제공하는 선택적 매개변수입니다.</li>
<li><code>default_factory</code>: 필드의 기본값을 반환하는 런타임 콜백을 제공하는 선택적 매개변수입니다.</li>
<li><code>factory</code>: <code>default_factory</code>의 별칭입니다. <code>attrs</code> 라이브러리를 지원하기 위해 필요합니다.</li>
<li><code>kw_only</code>: 필드를 키워드 전용으로 표시해야 하는지 여부를 나타내는 선택적 <code>bool</code> 매개변수입니다.</li>
<li><code>alias</code>: 필드의 대체 이름을 제공하는 선택적 <code>str</code> 매개변수입니다. 이 대체 이름은 합성된 <code>__init__</code> 메서드에서 사용됩니다.</li>
</ul>
<p><code>default</code>, <code>default_factory</code>, <code>factory</code> 중 두 개 이상을 지정하는 것은 오류입니다.</p>
<h2>런타임 동작 (Runtime behavior)</h2>
<p>런타임에 <code>dataclass_transform</code> 데코레이터의 유일한 효과는 데코레이터가 적용된 함수 또는 클래스에 <code>__dataclass_transform__</code>이라는 속성을 설정하여 인트로스펙션(introspection)을 지원하는 것입니다. 이 속성의 값은 <code>dataclass_transform</code> 매개변수 이름을 해당 값에 매핑하는 <code>dict</code>여야 합니다.</p>
<p>예시:</p>
<pre><code class="language-python">{
 "eq_default": True,
 "order_default": False,
 "kw_only_default": False,
 "field_specifiers": (),
 "kwargs": {}
}
</code></pre>
<h2>Dataclass 의미론 (Dataclass semantics)</h2>
<p>이 PEP에서 달리 명시되지 않는 한, <code>dataclass_transform</code>의 영향을 받는 클래스는 표준 라이브러리 <code>dataclass</code>처럼 동작하는 것으로 가정합니다.</p>
<p>여기에는 다음 의미론이 포함되지만 이에 국한되지는 않습니다:</p>
<ul>
<li><code>frozen</code> dataclass는 <code>non-frozen</code> dataclass를 상속할 수 없습니다.</li>
<li>필드 순서 지정 및 상속은 PEP 557에 지정된 규칙을 따릅니다.</li>
<li>메서드 합성은 클래스 내에 명시적으로 선언된 메서드를 덮어쓰는 경우 건너뜁니다.</li>
<li><code>KW_ONLY</code> 센티넬 값은 지원됩니다.</li>
<li><code>ClassVar</code> 속성은 dataclass 필드로 간주되지 않으며 dataclass 메커니즘에 의해 무시됩니다.</li>
</ul>
<h2>정의되지 않은 동작 (Undefined behavior)</h2>
<p>단일 함수(오버로드 포함), 단일 클래스 또는 클래스 계층 구조 내에서 여러 <code>dataclass_transform</code> 데코레이터가 발견되면 결과 동작은 정의되지 않습니다. 라이브러리 작성자는 이러한 시나리오를 피해야 합니다.</p>
<h2>참조 구현 (Reference Implementation)</h2>
<p>Pyright는 <code>dataclass_transform</code>에 대한 타입 체커 지원의 참조 구현을 포함합니다. Pyright의 <code>dataClasses.ts</code> 소스 파일은 구현을 이해하는 데 좋은 출발점이 될 것입니다.</p>
<p><code>attrs</code> 및 <code>pydantic</code> 라이브러리는 <code>dataclass_transform</code>를 사용하고 있으며 실제 사용 예시로 사용됩니다.</p>
<h2>거부된 아이디어 (Rejected Ideas)</h2>
<ul>
<li><code>auto_attribs</code> 매개변수: <code>attrs</code> 라이브러리 특정 기능이므로 지원하지 않습니다.</li>
<li><code>cmp</code> 매개변수: <code>attrs</code> 라이브러리 특정 기능이며 <code>eq</code>와 <code>order</code> 매개변수로 에뮬레이트할 수 있으므로 지원하지 않습니다.</li>
<li>자동 필드 이름 별칭 (Automatic field name aliasing): <code>attrs</code> 라이브러리 특정 기능이며 <code>alias</code> 매개변수를 사용하여 수동으로 처리할 수 있으므로 지원하지 않습니다.</li>
<li>대체 필드 순서 지정 알고리즘 (Alternate field ordering algorithms): <code>dataclass</code>에서 사용하는 방식 외의 다른 필드 순서 지정은 지원하지 않습니다.</li>
<li>서브클래스에서 재선언된 필드 (Fields redeclared in subclasses): <code>dataclass</code>의 동작만 지원합니다.</li>
<li>Django의 기본 키 및 외래 키 (Django primary and foreign keys): Django 특정 로직이므로 지원하지 않습니다.</li>
<li>클래스 전체 기본값 (Class-wide default values): SQLAlchemy 특정 기능이므로 지원하지 않습니다.</li>
<li>디스크립터 타입 필드 지원 (Descriptor-typed field support): <code>dataclass</code>가 디스크립터 타입 필드를 적절히 지원한다는 사실이 확인되어 추가하지 않았습니다.</li>
<li><code>converter</code> 필드 지정자 매개변수: 입력 매개변수의 타입을 유추하기 어렵고 <code>Any</code> 타입으로 처리해야 할 수 있어 지원이 복잡하다고 판단했습니다.</li>
</ul>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1450,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 681 - Data Class Transforms"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-27 10:10:35+0900","children":"2025년 9월 27일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 27일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}]]
1:null
