<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d6cea809dcbae606.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-0395f68b8cc78a20.js" async=""></script><script src="/_next/static/chunks/23-706b53707bbf0661.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-467e37449c5a68fc.js" async=""></script><script src="/_next/static/chunks/app/layout-0948ad04ab71c381.js" async=""></script><script src="/_next/static/chunks/app/page-90c91ef098171651.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2457<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 681 - Data Class Transforms</h1><div class="page__meta"><time dateTime="2025-09-27 10:10:35+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0681/">PEP 681 - Data Class Transforms</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 02-Dec-2021</p>
</blockquote>
<p>PEP 681 – Data Class Transforms</p>
<h2>개요 (Abstract)</h2>
<p>PEP 557은 Python 표준 라이브러리에 <code>dataclass</code>를 도입했습니다. <code>dataclass</code>와 유사한 동작을 제공하지만 표준 타입 어노테이션으로는 설명할 수 없는 인기 있는 라이브러리들(예: <code>attrs</code>, <code>pydantic</code>, SQLAlchemy, Django와 같은 ORM 패키지)이 많습니다.</p>
<p>대부분의 타입 체커, 린터 및 언어 서버는 <code>dataclass</code>를 완벽하게 지원합니다. 이 제안은 이러한 기능을 일반화하고, 서드파티 라이브러리가 특정 데코레이터 함수, 클래스 및 메타클래스가 <code>dataclass</code>와 유사한 동작을 제공함을 나타낼 수 있는 방법을 제공하는 것을 목표로 합니다.</p>
<p>이러한 동작에는 다음이 포함됩니다:</p>
<ul>
<li>선언된 데이터 필드를 기반으로 <code>__init__</code> 메서드 합성.</li>
<li>선택적으로 <code>__eq__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, <code>__ge__</code> 메서드 합성.</li>
<li>정적 타입 체킹 중에 불변성(immutability)을 강제하는 "frozen" 클래스 지원.</li>
<li>정적 타입 체커가 알아야 할 개별 필드의 속성(예: 필드에 기본값이 제공되는지 여부)을 설명하는 "필드 지정자(field specifiers)" 지원.</li>
</ul>
<p>이 제안은 <code>typing.py</code>에 <code>dataclass_transform</code> 데코레이터를 추가하는 것 외에는 CPython에 직접적인 영향을 미치지 않습니다.</p>
<h2>동기 (Motivation)</h2>
<p><code>dataclass</code>와 유사한 의미론을 가진 라이브러리가 타입 체커에 자신의 동작을 선언할 수 있는 기존의 표준적인 방법이 없습니다. 이러한 한계를 해결하기 위해 많은 라이브러리를 위한 Mypy 커스텀 플러그인이 개발되었지만, 이 플러그인들은 다른 타입 체커, 린터 또는 언어 서버에서는 작동하지 않습니다. 또한, 라이브러리 개발자에게는 유지 관리 비용이 많이 들고, Python 개발자는 이러한 플러그인의 존재를 알아야 하고 환경 내에서 다운로드하고 구성해야 합니다.</p>
<h2>근거 (Rationale)</h2>
<p>이 제안의 목적은 <code>dataclass</code>와 유사한 의미론을 가진 모든 라이브러리의 모든 기능을 지원하는 것이 아니라, 정적 타입 체킹과 호환되는 방식으로 이러한 라이브러리의 가장 일반적인 기능을 사용할 수 있도록 하는 것입니다.</p>
<p>미래에 <code>dataclass</code>에 새로운 기능이 추가되면, 적절할 때 <code>dataclass_transform</code>에도 해당 기능에 대한 지원을 추가할 예정입니다. 이 두 기능 세트를 동기화하면 <code>dataclass</code> 사용자가 <code>dataclass_transform</code>를 더 쉽게 이해하고 사용할 수 있으며, 타입 체커에서 <code>dataclass</code> 지원을 유지 관리하는 것이 단순해질 것입니다.</p>
<p>또한, 여러 서드파티 라이브러리에서 채택되었지만 <code>dataclass</code>에서 지원되지 않는 기능에 대해서도 향후 <code>dataclass_transform</code> 지원을 추가하는 것을 고려할 것입니다.</p>
<h2>사양 (Specification)</h2>
<h3><code>dataclass_transform</code> 데코레이터</h3>
<p>이 사양은 <code>typing</code> 모듈에 <code>dataclass_transform</code>라는 새로운 데코레이터 함수를 도입합니다. 이 데코레이터는 데코레이터인 함수 자체, 클래스 또는 메타클래스에 적용될 수 있습니다. <code>dataclass_transform</code>의 존재는 정적 타입 체커에게 데코레이터가 적용된 함수, 클래스 또는 메타클래스가 런타임에 클래스를 변환하여 <code>dataclass</code>와 유사한 동작을 부여하는 "마법"을 수행함을 알립니다.</p>
<ul>
<li><code>dataclass_transform</code>가 <strong>함수</strong> 에 적용되면, 해당 데코레이터 함수를 사용하는 것이 <code>dataclass</code>와 유사한 의미론을 적용하는 것으로 간주됩니다.</li>
<li><code>dataclass_transform</code>가 <strong>클래스</strong> 에 적용되면, 해당 클래스를 직간접적으로 상속하거나 해당 클래스를 메타클래스로 사용하는 모든 클래스에 <code>dataclass</code>와 유사한 의미론이 적용되는 것으로 간주됩니다.</li>
<li><code>dataclass_transform</code>가 <strong>메타클래스</strong> 에 적용되면, 해당 메타클래스를 사용하는 모든 클래스에 <code>dataclass</code>와 유사한 의미론이 적용되는 것으로 간주됩니다.</li>
</ul>
<p>예시 코드는 다음과 같습니다. (구현은 생략되었지만, <code>__init__</code>, <code>__eq__</code>, <code>__ne__</code> 메서드를 합성한다고 가정합니다.)</p>
<pre><code class="language-python"># 데코레이터 함수 예시
_T = TypeVar("_T")

@typing.dataclass_transform()
def create_model(cls: Type[_T]) -> Type[_T]:
    cls.__init__ = ...
    cls.__eq__ = ...
    cls.__ne__ = ...
    return cls

@create_model
class CustomerModel:
    id: int
    name: str

# 클래스 예시
@typing.dataclass_transform()
class ModelBase:
    ...

class CustomerModel(ModelBase):
    id: int
    name: str

# 메타클래스 예시
@typing.dataclass_transform()
class ModelMeta(type):
    ...

class ModelBase(metaclass=ModelMeta):
    ...

class CustomerModel(ModelBase):
    id: int
    name: str
</code></pre>
<h3>데코레이터 함수 및 클래스/메타클래스 매개변수</h3>
<p><code>dataclass</code>와 유사한 기능을 제공하는 데코레이터 함수, 클래스 또는 메타클래스는 특정 동작을 수정하는 매개변수를 받을 수 있습니다. 이 사양은 <code>dataclass_transform</code>에 의해 사용되는 경우 정적 타입 체커가 준수해야 하는 다음 매개변수들을 정의합니다. 각 매개변수는 <code>bool</code> 인수를 받으며, <code>bool</code> 값(<code>True</code> 또는 <code>False</code>)이 정적으로 평가될 수 있어야 합니다.</p>
<ul>
<li><code>eq</code>, <code>order</code>, <code>frozen</code>, <code>init</code>, <code>unsafe_hash</code>: 표준 라이브러리 <code>dataclass</code>에서 지원되는 매개변수이며, PEP 557에 정의된 의미를 가집니다.</li>
<li><code>kw_only</code>, <code>match_args</code>, <code>slots</code>: Python 3.10에서 처음 도입된 표준 라이브러리 <code>dataclass</code>에서 지원되는 매개변수입니다.</li>
</ul>
<h3><code>dataclass_transform</code> 매개변수</h3>
<p><code>dataclass_transform</code>에 전달되는 매개변수는 기본 동작을 어느 정도 사용자 정의할 수 있도록 합니다.</p>
<pre><code class="language-python">def dataclass_transform(
    *,
    eq_default: bool = True,
    order_default: bool = False,
    kw_only_default: bool = False,
    field_specifiers: tuple[type | Callable[..., Any], ...] = (),
    **kwargs: Any,
) -> Callable[[_T], _T]: ...
</code></pre>
<ul>
<li><code>eq_default</code>: 호출자가 <code>eq</code> 매개변수를 생략했을 때 <code>True</code> 또는 <code>False</code>로 가정할지 여부를 나타냅니다. 지정되지 않으면 기본값은 <code>True</code>입니다 (dataclass의 기본값과 동일).</li>
<li><code>order_default</code>: 호출자가 <code>order</code> 매개변수를 생략했을 때 <code>True</code> 또는 <code>False</code>로 가정할지 여부를 나타냅니다. 지정되지 않으면 기본값은 <code>False</code>입니다 (dataclass의 기본값과 동일).</li>
<li><code>kw_only_default</code>: 호출자가 <code>kw_only</code> 매개변수를 생략했을 때 <code>True</code> 또는 <code>False</code>로 가정할지 여부를 나타냅니다. 지정되지 않으면 기본값은 <code>False</code>입니다 (dataclass의 기본값과 동일).</li>
<li><code>field_specifiers</code>: 필드를 설명하는 지원되는 클래스들의 정적 목록을 지정합니다. 일부 라이브러리는 필드 지정자 인스턴스를 할당하는 함수도 제공하며, 이 함수들도 이 튜플에 지정될 수 있습니다. 지정되지 않으면 <code>field_specifiers</code>는 기본적으로 빈 튜플이 됩니다.</li>
<li><code>kwargs</code>: <code>dataclass_transform</code>에 임의의 추가 키워드 인수를 전달할 수 있도록 합니다. 이를 통해 타입 체커는 <code>typing.py</code>의 변경을 기다릴 필요 없이 실험적인 매개변수를 지원할 수 있습니다.</li>
</ul>
<p>예시 코드는 다음과 같습니다.</p>
<pre><code class="language-python"># 데코레이터 함수 예시
@typing.dataclass_transform(kw_only_default=True, order_default=True)
def create_model(
    *,
    frozen: bool = False,
    kw_only: bool = True,
) -> Callable[[Type[_T]], Type[_T]]: ...

@create_model(frozen=True, kw_only=False)
class CustomerModel:
    id: int
    name: str

# 클래스 예시
@typing.dataclass_transform(eq_default=True, order_default=True)
class ModelBase:
    def __init_subclass__(
        cls, *, init: bool = True, frozen: bool = False, eq: bool = True, order: bool = True,
    ): ...

class CustomerModel(
    ModelBase, init=False, frozen=True, eq=False, order=False,
):
    id: int
    name: str

# 메타클래스 예시
@typing.dataclass_transform(eq_default=True, order_default=True)
class ModelMeta(type):
    def __new__(
        cls, name, bases, namespace, *, init: bool = True, frozen: bool = False, eq: bool = True, order: bool = True,
    ): ...

class ModelBase(metaclass=ModelMeta):
    ...

class CustomerModel(
    ModelBase, init=False, frozen=True, eq=False, order=False,
):
    id: int
    name: str
</code></pre>
<h3>필드 지정자 (Field specifiers)</h3>
<p><code>dataclass</code>와 유사한 의미론을 지원하는 대부분의 라이브러리는 클래스 정의가 클래스의 각 필드에 대한 추가 메타데이터를 제공할 수 있도록 하나 이상의 "필드 지정자" 타입을 제공합니다. 이 메타데이터는 예를 들어 기본값을 설명하거나 필드가 합성된 <code>__init__</code> 메서드에 포함되어야 하는지 여부를 나타낼 수 있습니다.</p>
<p>예시:</p>
<pre><code class="language-python">@dataclass
class Employee:
    name: str                               # 지정자 없는 필드
    age: Optional[int] = field(default=None, init=False) # 필드 지정자 인스턴스를 사용하는 필드
    is_paid_hourly: bool = True             # 타입 어노테이션과 간단한 초기화자를 사용하여 기본값을 설명하는 필드
    office_number = "unassigned"            # 타입 어노테이션이 제공되지 않았으므로 필드가 아닌 클래스 변수
</code></pre>
<h3>필드 지정자 매개변수 (Field specifier parameters)</h3>
<p><code>dataclass</code>와 유사한 의미론을 지원하고 필드 지정자 클래스를 지원하는 라이브러리는 일반적으로 이러한 필드 지정자를 구성하기 위해 공통 매개변수 이름을 사용합니다. 이 사양은 정적 타입 체커가 이해해야 하는 매개변수의 이름과 의미를 공식화합니다. 이러한 표준화된 매개변수는 키워드 전용(<code>keyword-only</code>)이어야 합니다.</p>
<p><code>dataclasses.field</code>에서 지원하는 매개변수의 상위 집합입니다 (타입 체킹에 영향을 미치지 않는 <code>compare</code>, <code>hash</code> 등은 제외).</p>
<ul>
<li><code>init</code>: 필드가 합성된 <code>__init__</code> 메서드에 포함되어야 하는지 여부를 나타내는 선택적 <code>bool</code> 매개변수입니다. 지정되지 않으면 <code>init</code>은 기본적으로 <code>True</code>입니다.</li>
<li><code>default</code>: 필드의 기본값을 제공하는 선택적 매개변수입니다.</li>
<li><code>default_factory</code>: 필드의 기본값을 반환하는 런타임 콜백을 제공하는 선택적 매개변수입니다.</li>
<li><code>factory</code>: <code>default_factory</code>의 별칭입니다. <code>attrs</code> 라이브러리를 지원하기 위해 필요합니다.</li>
<li><code>kw_only</code>: 필드를 키워드 전용으로 표시해야 하는지 여부를 나타내는 선택적 <code>bool</code> 매개변수입니다.</li>
<li><code>alias</code>: 필드의 대체 이름을 제공하는 선택적 <code>str</code> 매개변수입니다. 이 대체 이름은 합성된 <code>__init__</code> 메서드에서 사용됩니다.</li>
</ul>
<p><code>default</code>, <code>default_factory</code>, <code>factory</code> 중 두 개 이상을 지정하는 것은 오류입니다.</p>
<h2>런타임 동작 (Runtime behavior)</h2>
<p>런타임에 <code>dataclass_transform</code> 데코레이터의 유일한 효과는 데코레이터가 적용된 함수 또는 클래스에 <code>__dataclass_transform__</code>이라는 속성을 설정하여 인트로스펙션(introspection)을 지원하는 것입니다. 이 속성의 값은 <code>dataclass_transform</code> 매개변수 이름을 해당 값에 매핑하는 <code>dict</code>여야 합니다.</p>
<p>예시:</p>
<pre><code class="language-python">{
 "eq_default": True,
 "order_default": False,
 "kw_only_default": False,
 "field_specifiers": (),
 "kwargs": {}
}
</code></pre>
<h2>Dataclass 의미론 (Dataclass semantics)</h2>
<p>이 PEP에서 달리 명시되지 않는 한, <code>dataclass_transform</code>의 영향을 받는 클래스는 표준 라이브러리 <code>dataclass</code>처럼 동작하는 것으로 가정합니다.</p>
<p>여기에는 다음 의미론이 포함되지만 이에 국한되지는 않습니다:</p>
<ul>
<li><code>frozen</code> dataclass는 <code>non-frozen</code> dataclass를 상속할 수 없습니다.</li>
<li>필드 순서 지정 및 상속은 PEP 557에 지정된 규칙을 따릅니다.</li>
<li>메서드 합성은 클래스 내에 명시적으로 선언된 메서드를 덮어쓰는 경우 건너뜁니다.</li>
<li><code>KW_ONLY</code> 센티넬 값은 지원됩니다.</li>
<li><code>ClassVar</code> 속성은 dataclass 필드로 간주되지 않으며 dataclass 메커니즘에 의해 무시됩니다.</li>
</ul>
<h2>정의되지 않은 동작 (Undefined behavior)</h2>
<p>단일 함수(오버로드 포함), 단일 클래스 또는 클래스 계층 구조 내에서 여러 <code>dataclass_transform</code> 데코레이터가 발견되면 결과 동작은 정의되지 않습니다. 라이브러리 작성자는 이러한 시나리오를 피해야 합니다.</p>
<h2>참조 구현 (Reference Implementation)</h2>
<p>Pyright는 <code>dataclass_transform</code>에 대한 타입 체커 지원의 참조 구현을 포함합니다. Pyright의 <code>dataClasses.ts</code> 소스 파일은 구현을 이해하는 데 좋은 출발점이 될 것입니다.</p>
<p><code>attrs</code> 및 <code>pydantic</code> 라이브러리는 <code>dataclass_transform</code>를 사용하고 있으며 실제 사용 예시로 사용됩니다.</p>
<h2>거부된 아이디어 (Rejected Ideas)</h2>
<ul>
<li><code>auto_attribs</code> 매개변수: <code>attrs</code> 라이브러리 특정 기능이므로 지원하지 않습니다.</li>
<li><code>cmp</code> 매개변수: <code>attrs</code> 라이브러리 특정 기능이며 <code>eq</code>와 <code>order</code> 매개변수로 에뮬레이트할 수 있으므로 지원하지 않습니다.</li>
<li>자동 필드 이름 별칭 (Automatic field name aliasing): <code>attrs</code> 라이브러리 특정 기능이며 <code>alias</code> 매개변수를 사용하여 수동으로 처리할 수 있으므로 지원하지 않습니다.</li>
<li>대체 필드 순서 지정 알고리즘 (Alternate field ordering algorithms): <code>dataclass</code>에서 사용하는 방식 외의 다른 필드 순서 지정은 지원하지 않습니다.</li>
<li>서브클래스에서 재선언된 필드 (Fields redeclared in subclasses): <code>dataclass</code>의 동작만 지원합니다.</li>
<li>Django의 기본 키 및 외래 키 (Django primary and foreign keys): Django 특정 로직이므로 지원하지 않습니다.</li>
<li>클래스 전체 기본값 (Class-wide default values): SQLAlchemy 특정 기능이므로 지원하지 않습니다.</li>
<li>디스크립터 타입 필드 지원 (Descriptor-typed field support): <code>dataclass</code>가 디스크립터 타입 필드를 적절히 지원한다는 사실이 확인되어 추가하지 않았습니다.</li>
<li><code>converter</code> 필드 지정자 매개변수: 입력 매개변수의 타입을 유추하기 어렵고 <code>Any</code> 타입으로 처리해야 할 수 있어 지원이 복잡하다고 판단했습니다.</li>
</ul>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/680/">[Final] PEP 680 - tomllib: Support for Parsing TOML in the Standard Library</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 681 - Data Class Transforms</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/682/">[Final] PEP 682 - Format Specifier for Signed Zero</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d6cea809dcbae606.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-0948ad04ab71c381.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"931\",\"static/chunks/app/page-90c91ef098171651.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/681\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d6cea809dcbae606.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"UQr4JHFOI5XWpsk7z3lW6\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/681/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/681\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"681\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/681\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"default\"]\ne:T43d9,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0681/\"\u003ePEP 681 - Data Class Transforms\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 02-Dec-2021\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 681 – Data Class Transforms\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003ePEP 557은 Python 표준 라이브러리에 \u003ccode\u003edataclass\u003c/code\u003e를 도입했습니다. \u003ccode\u003edataclass\u003c/code\u003e와 유사한 동작을 제공하지만 표준 타입 어노테이션으로는 설명할 수 없는 인기 있는 라이브러리들(예: \u003ccode\u003eattrs\u003c/code\u003e, \u003ccode\u003epydantic\u003c/code\u003e, SQLAlchemy, Django와 같은 ORM 패키지)이 많습니다.\u003c/p\u003e\n\u003cp\u003e대부분의 타입 체커, 린터 및 언어 서버는 \u003ccode\u003edataclass\u003c/code\u003e를 완벽하게 지원합니다. 이 제안은 이러한 기능을 일반화하고, 서드파티 라이브러리가 특정 데코레이터 함수, 클래스 및 메타클래스가 \u003ccode\u003edataclass\u003c/code\u003e와 유사한 동작을 제공함을 나타낼 수 있는 방법을 제공하는 것을 목표로 합니다.\u003c/p\u003e\n\u003cp\u003e이러한 동작에는 다음이 포함됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e선언된 데이터 필드를 기반으로 \u003ccode\u003e__init__\u003c/code\u003e 메서드 합성.\u003c/li\u003e\n\u003cli\u003e선택적으로 \u003ccode\u003e__eq__\u003c/code\u003e, \u003ccode\u003e__ne__\u003c/code\u003e, \u003ccode\u003e__lt__\u003c/code\u003e, \u003ccode\u003e__le__\u003c/code\u003e, \u003ccode\u003e__gt__\u003c/code\u003e, \u003ccode\u003e__ge__\u003c/code\u003e 메서드 합성.\u003c/li\u003e\n\u003cli\u003e정적 타입 체킹 중에 불변성(immutability)을 강제하는 \"frozen\" 클래스 지원.\u003c/li\u003e\n\u003cli\u003e정적 타입 체커가 알아야 할 개별 필드의 속성(예: 필드에 기본값이 제공되는지 여부)을 설명하는 \"필드 지정자(field specifiers)\" 지원.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 제안은 \u003ccode\u003etyping.py\u003c/code\u003e에 \u003ccode\u003edataclass_transform\u003c/code\u003e 데코레이터를 추가하는 것 외에는 CPython에 직접적인 영향을 미치지 않습니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003edataclass\u003c/code\u003e와 유사한 의미론을 가진 라이브러리가 타입 체커에 자신의 동작을 선언할 수 있는 기존의 표준적인 방법이 없습니다. 이러한 한계를 해결하기 위해 많은 라이브러리를 위한 Mypy 커스텀 플러그인이 개발되었지만, 이 플러그인들은 다른 타입 체커, 린터 또는 언어 서버에서는 작동하지 않습니다. 또한, 라이브러리 개발자에게는 유지 관리 비용이 많이 들고, Python 개발자는 이러한 플러그인의 존재를 알아야 하고 환경 내에서 다운로드하고 구성해야 합니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e이 제안의 목적은 \u003ccode\u003edataclass\u003c/code\u003e와 유사한 의미론을 가진 모든 라이브러리의 모든 기능을 지원하는 것이 아니라, 정적 타입 체킹과 호환되는 방식으로 이러한 라이브러리의 가장 일반적인 기능을 사용할 수 있도록 하는 것입니다.\u003c/p\u003e\n\u003cp\u003e미래에 \u003ccode\u003edataclass\u003c/code\u003e에 새로운 기능이 추가되면, 적절할 때 \u003ccode\u003edataclass_transform\u003c/code\u003e에도 해당 기능에 대한 지원을 추가할 예정입니다. 이 두 기능 세트를 동기화하면 \u003ccode\u003edataclass\u003c/code\u003e 사용자가 \u003ccode\u003edataclass_transform\u003c/code\u003e를 더 쉽게 이해하고 사용할 수 있으며, 타입 체커에서 \u003ccode\u003edataclass\u003c/code\u003e 지원을 유지 관리하는 것이 단순해질 것입니다.\u003c/p\u003e\n\u003cp\u003e또한, 여러 서드파티 라이브러리에서 채택되었지만 \u003ccode\u003edataclass\u003c/code\u003e에서 지원되지 않는 기능에 대해서도 향후 \u003ccode\u003edataclass_transform\u003c/code\u003e 지원을 추가하는 것을 고려할 것입니다.\u003c/p\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003edataclass_transform\u003c/code\u003e 데코레이터\u003c/h3\u003e\n\u003cp\u003e이 사양은 \u003ccode\u003etyping\u003c/code\u003e 모듈에 \u003ccode\u003edataclass_transform\u003c/code\u003e라는 새로운 데코레이터 함수를 도입합니다. 이 데코레이터는 데코레이터인 함수 자체, 클래스 또는 메타클래스에 적용될 수 있습니다. \u003ccode\u003edataclass_transform\u003c/code\u003e의 존재는 정적 타입 체커에게 데코레이터가 적용된 함수, 클래스 또는 메타클래스가 런타임에 클래스를 변환하여 \u003ccode\u003edataclass\u003c/code\u003e와 유사한 동작을 부여하는 \"마법\"을 수행함을 알립니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edataclass_transform\u003c/code\u003e가 \u003cstrong\u003e함수\u003c/strong\u003e 에 적용되면, 해당 데코레이터 함수를 사용하는 것이 \u003ccode\u003edataclass\u003c/code\u003e와 유사한 의미론을 적용하는 것으로 간주됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edataclass_transform\u003c/code\u003e가 \u003cstrong\u003e클래스\u003c/strong\u003e 에 적용되면, 해당 클래스를 직간접적으로 상속하거나 해당 클래스를 메타클래스로 사용하는 모든 클래스에 \u003ccode\u003edataclass\u003c/code\u003e와 유사한 의미론이 적용되는 것으로 간주됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edataclass_transform\u003c/code\u003e가 \u003cstrong\u003e메타클래스\u003c/strong\u003e 에 적용되면, 해당 메타클래스를 사용하는 모든 클래스에 \u003ccode\u003edataclass\u003c/code\u003e와 유사한 의미론이 적용되는 것으로 간주됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시 코드는 다음과 같습니다. (구현은 생략되었지만, \u003ccode\u003e__init__\u003c/code\u003e, \u003ccode\u003e__eq__\u003c/code\u003e, \u003ccode\u003e__ne__\u003c/code\u003e 메서드를 합성한다고 가정합니다.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 데코레이터 함수 예시\n_T = TypeVar(\"_T\")\n\n@typing.dataclass_transform()\ndef create_model(cls: Type[_T]) -\u003e Type[_T]:\n    cls.__init__ = ...\n    cls.__eq__ = ...\n    cls.__ne__ = ...\n    return cls\n\n@create_model\nclass CustomerModel:\n    id: int\n    name: str\n\n# 클래스 예시\n@typing.dataclass_transform()\nclass ModelBase:\n    ...\n\nclass CustomerModel(ModelBase):\n    id: int\n    name: str\n\n# 메타클래스 예시\n@typing.dataclass_transform()\nclass ModelMeta(type):\n    ...\n\nclass ModelBase(metaclass=ModelMeta):\n    ...\n\nclass CustomerModel(ModelBase):\n    id: int\n    name: str\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e데코레이터 함수 및 클래스/메타클래스 매개변수\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edataclass\u003c/code\u003e와 유사한 기능을 제공하는 데코레이터 함수, 클래스 또는 메타클래스는 특정 동작을 수정하는 매개변수를 받을 수 있습니다. 이 사양은 \u003ccode\u003edataclass_transform\u003c/code\u003e에 의해 사용되는 경우 정적 타입 체커가 준수해야 하는 다음 매개변수들을 정의합니다. 각 매개변수는 \u003ccode\u003ebool\u003c/code\u003e 인수를 받으며, \u003ccode\u003ebool\u003c/code\u003e 값(\u003ccode\u003eTrue\u003c/code\u003e 또는 \u003ccode\u003eFalse\u003c/code\u003e)이 정적으로 평가될 수 있어야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eeq\u003c/code\u003e, \u003ccode\u003eorder\u003c/code\u003e, \u003ccode\u003efrozen\u003c/code\u003e, \u003ccode\u003einit\u003c/code\u003e, \u003ccode\u003eunsafe_hash\u003c/code\u003e: 표준 라이브러리 \u003ccode\u003edataclass\u003c/code\u003e에서 지원되는 매개변수이며, PEP 557에 정의된 의미를 가집니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekw_only\u003c/code\u003e, \u003ccode\u003ematch_args\u003c/code\u003e, \u003ccode\u003eslots\u003c/code\u003e: Python 3.10에서 처음 도입된 표준 라이브러리 \u003ccode\u003edataclass\u003c/code\u003e에서 지원되는 매개변수입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003edataclass_transform\u003c/code\u003e 매개변수\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edataclass_transform\u003c/code\u003e에 전달되는 매개변수는 기본 동작을 어느 정도 사용자 정의할 수 있도록 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef dataclass_transform(\n    *,\n    eq_default: bool = True,\n    order_default: bool = False,\n    kw_only_default: bool = False,\n    field_specifiers: tuple[type | Callable[..., Any], ...] = (),\n    **kwargs: Any,\n) -\u003e Callable[[_T], _T]: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eeq_default\u003c/code\u003e: 호출자가 \u003ccode\u003eeq\u003c/code\u003e 매개변수를 생략했을 때 \u003ccode\u003eTrue\u003c/code\u003e 또는 \u003ccode\u003eFalse\u003c/code\u003e로 가정할지 여부를 나타냅니다. 지정되지 않으면 기본값은 \u003ccode\u003eTrue\u003c/code\u003e입니다 (dataclass의 기본값과 동일).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eorder_default\u003c/code\u003e: 호출자가 \u003ccode\u003eorder\u003c/code\u003e 매개변수를 생략했을 때 \u003ccode\u003eTrue\u003c/code\u003e 또는 \u003ccode\u003eFalse\u003c/code\u003e로 가정할지 여부를 나타냅니다. 지정되지 않으면 기본값은 \u003ccode\u003eFalse\u003c/code\u003e입니다 (dataclass의 기본값과 동일).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekw_only_default\u003c/code\u003e: 호출자가 \u003ccode\u003ekw_only\u003c/code\u003e 매개변수를 생략했을 때 \u003ccode\u003eTrue\u003c/code\u003e 또는 \u003ccode\u003eFalse\u003c/code\u003e로 가정할지 여부를 나타냅니다. 지정되지 않으면 기본값은 \u003ccode\u003eFalse\u003c/code\u003e입니다 (dataclass의 기본값과 동일).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efield_specifiers\u003c/code\u003e: 필드를 설명하는 지원되는 클래스들의 정적 목록을 지정합니다. 일부 라이브러리는 필드 지정자 인스턴스를 할당하는 함수도 제공하며, 이 함수들도 이 튜플에 지정될 수 있습니다. 지정되지 않으면 \u003ccode\u003efield_specifiers\u003c/code\u003e는 기본적으로 빈 튜플이 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekwargs\u003c/code\u003e: \u003ccode\u003edataclass_transform\u003c/code\u003e에 임의의 추가 키워드 인수를 전달할 수 있도록 합니다. 이를 통해 타입 체커는 \u003ccode\u003etyping.py\u003c/code\u003e의 변경을 기다릴 필요 없이 실험적인 매개변수를 지원할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시 코드는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 데코레이터 함수 예시\n@typing.dataclass_transform(kw_only_default=True, order_default=True)\ndef create_model(\n    *,\n    frozen: bool = False,\n    kw_only: bool = True,\n) -\u003e Callable[[Type[_T]], Type[_T]]: ...\n\n@create_model(frozen=True, kw_only=False)\nclass CustomerModel:\n    id: int\n    name: str\n\n# 클래스 예시\n@typing.dataclass_transform(eq_default=True, order_default=True)\nclass ModelBase:\n    def __init_subclass__(\n        cls, *, init: bool = True, frozen: bool = False, eq: bool = True, order: bool = True,\n    ): ...\n\nclass CustomerModel(\n    ModelBase, init=False, frozen=True, eq=False, order=False,\n):\n    id: int\n    name: str\n\n# 메타클래스 예시\n@typing.dataclass_transform(eq_default=True, order_default=True)\nclass ModelMeta(type):\n    def __new__(\n        cls, name, bases, namespace, *, init: bool = True, frozen: bool = False, eq: bool = True, order: bool = True,\n    ): ...\n\nclass ModelBase(metaclass=ModelMeta):\n    ...\n\nclass CustomerModel(\n    ModelBase, init=False, frozen=True, eq=False, order=False,\n):\n    id: int\n    name: str\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e필드 지정자 (Field specifiers)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edataclass\u003c/code\u003e와 유사한 의미론을 지원하는 대부분의 라이브러리는 클래스 정의가 클래스의 각 필드에 대한 추가 메타데이터를 제공할 수 있도록 하나 이상의 \"필드 지정자\" 타입을 제공합니다. 이 메타데이터는 예를 들어 기본값을 설명하거나 필드가 합성된 \u003ccode\u003e__init__\u003c/code\u003e 메서드에 포함되어야 하는지 여부를 나타낼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@dataclass\nclass Employee:\n    name: str                               # 지정자 없는 필드\n    age: Optional[int] = field(default=None, init=False) # 필드 지정자 인스턴스를 사용하는 필드\n    is_paid_hourly: bool = True             # 타입 어노테이션과 간단한 초기화자를 사용하여 기본값을 설명하는 필드\n    office_number = \"unassigned\"            # 타입 어노테이션이 제공되지 않았으므로 필드가 아닌 클래스 변수\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e필드 지정자 매개변수 (Field specifier parameters)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edataclass\u003c/code\u003e와 유사한 의미론을 지원하고 필드 지정자 클래스를 지원하는 라이브러리는 일반적으로 이러한 필드 지정자를 구성하기 위해 공통 매개변수 이름을 사용합니다. 이 사양은 정적 타입 체커가 이해해야 하는 매개변수의 이름과 의미를 공식화합니다. 이러한 표준화된 매개변수는 키워드 전용(\u003ccode\u003ekeyword-only\u003c/code\u003e)이어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edataclasses.field\u003c/code\u003e에서 지원하는 매개변수의 상위 집합입니다 (타입 체킹에 영향을 미치지 않는 \u003ccode\u003ecompare\u003c/code\u003e, \u003ccode\u003ehash\u003c/code\u003e 등은 제외).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einit\u003c/code\u003e: 필드가 합성된 \u003ccode\u003e__init__\u003c/code\u003e 메서드에 포함되어야 하는지 여부를 나타내는 선택적 \u003ccode\u003ebool\u003c/code\u003e 매개변수입니다. 지정되지 않으면 \u003ccode\u003einit\u003c/code\u003e은 기본적으로 \u003ccode\u003eTrue\u003c/code\u003e입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edefault\u003c/code\u003e: 필드의 기본값을 제공하는 선택적 매개변수입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edefault_factory\u003c/code\u003e: 필드의 기본값을 반환하는 런타임 콜백을 제공하는 선택적 매개변수입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efactory\u003c/code\u003e: \u003ccode\u003edefault_factory\u003c/code\u003e의 별칭입니다. \u003ccode\u003eattrs\u003c/code\u003e 라이브러리를 지원하기 위해 필요합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekw_only\u003c/code\u003e: 필드를 키워드 전용으로 표시해야 하는지 여부를 나타내는 선택적 \u003ccode\u003ebool\u003c/code\u003e 매개변수입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ealias\u003c/code\u003e: 필드의 대체 이름을 제공하는 선택적 \u003ccode\u003estr\u003c/code\u003e 매개변수입니다. 이 대체 이름은 합성된 \u003ccode\u003e__init__\u003c/code\u003e 메서드에서 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003edefault\u003c/code\u003e, \u003ccode\u003edefault_factory\u003c/code\u003e, \u003ccode\u003efactory\u003c/code\u003e 중 두 개 이상을 지정하는 것은 오류입니다.\u003c/p\u003e\n\u003ch2\u003e런타임 동작 (Runtime behavior)\u003c/h2\u003e\n\u003cp\u003e런타임에 \u003ccode\u003edataclass_transform\u003c/code\u003e 데코레이터의 유일한 효과는 데코레이터가 적용된 함수 또는 클래스에 \u003ccode\u003e__dataclass_transform__\u003c/code\u003e이라는 속성을 설정하여 인트로스펙션(introspection)을 지원하는 것입니다. 이 속성의 값은 \u003ccode\u003edataclass_transform\u003c/code\u003e 매개변수 이름을 해당 값에 매핑하는 \u003ccode\u003edict\u003c/code\u003e여야 합니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e{\n \"eq_default\": True,\n \"order_default\": False,\n \"kw_only_default\": False,\n \"field_specifiers\": (),\n \"kwargs\": {}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eDataclass 의미론 (Dataclass semantics)\u003c/h2\u003e\n\u003cp\u003e이 PEP에서 달리 명시되지 않는 한, \u003ccode\u003edataclass_transform\u003c/code\u003e의 영향을 받는 클래스는 표준 라이브러리 \u003ccode\u003edataclass\u003c/code\u003e처럼 동작하는 것으로 가정합니다.\u003c/p\u003e\n\u003cp\u003e여기에는 다음 의미론이 포함되지만 이에 국한되지는 않습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efrozen\u003c/code\u003e dataclass는 \u003ccode\u003enon-frozen\u003c/code\u003e dataclass를 상속할 수 없습니다.\u003c/li\u003e\n\u003cli\u003e필드 순서 지정 및 상속은 PEP 557에 지정된 규칙을 따릅니다.\u003c/li\u003e\n\u003cli\u003e메서드 합성은 클래스 내에 명시적으로 선언된 메서드를 덮어쓰는 경우 건너뜁니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eKW_ONLY\u003c/code\u003e 센티넬 값은 지원됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eClassVar\u003c/code\u003e 속성은 dataclass 필드로 간주되지 않으며 dataclass 메커니즘에 의해 무시됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e정의되지 않은 동작 (Undefined behavior)\u003c/h2\u003e\n\u003cp\u003e단일 함수(오버로드 포함), 단일 클래스 또는 클래스 계층 구조 내에서 여러 \u003ccode\u003edataclass_transform\u003c/code\u003e 데코레이터가 발견되면 결과 동작은 정의되지 않습니다. 라이브러리 작성자는 이러한 시나리오를 피해야 합니다.\u003c/p\u003e\n\u003ch2\u003e참조 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003ePyright는 \u003ccode\u003edataclass_transform\u003c/code\u003e에 대한 타입 체커 지원의 참조 구현을 포함합니다. Pyright의 \u003ccode\u003edataClasses.ts\u003c/code\u003e 소스 파일은 구현을 이해하는 데 좋은 출발점이 될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eattrs\u003c/code\u003e 및 \u003ccode\u003epydantic\u003c/code\u003e 라이브러리는 \u003ccode\u003edataclass_transform\u003c/code\u003e를 사용하고 있으며 실제 사용 예시로 사용됩니다.\u003c/p\u003e\n\u003ch2\u003e거부된 아이디어 (Rejected Ideas)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eauto_attribs\u003c/code\u003e 매개변수: \u003ccode\u003eattrs\u003c/code\u003e 라이브러리 특정 기능이므로 지원하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecmp\u003c/code\u003e 매개변수: \u003ccode\u003eattrs\u003c/code\u003e 라이브러리 특정 기능이며 \u003ccode\u003eeq\u003c/code\u003e와 \u003ccode\u003eorder\u003c/code\u003e 매개변수로 에뮬레이트할 수 있으므로 지원하지 않습니다.\u003c/li\u003e\n\u003cli\u003e자동 필드 이름 별칭 (Automatic field name aliasing): \u003ccode\u003eattrs\u003c/code\u003e 라이브러리 특정 기능이며 \u003ccode\u003ealias\u003c/code\u003e 매개변수를 사용하여 수동으로 처리할 수 있으므로 지원하지 않습니다.\u003c/li\u003e\n\u003cli\u003e대체 필드 순서 지정 알고리즘 (Alternate field ordering algorithms): \u003ccode\u003edataclass\u003c/code\u003e에서 사용하는 방식 외의 다른 필드 순서 지정은 지원하지 않습니다.\u003c/li\u003e\n\u003cli\u003e서브클래스에서 재선언된 필드 (Fields redeclared in subclasses): \u003ccode\u003edataclass\u003c/code\u003e의 동작만 지원합니다.\u003c/li\u003e\n\u003cli\u003eDjango의 기본 키 및 외래 키 (Django primary and foreign keys): Django 특정 로직이므로 지원하지 않습니다.\u003c/li\u003e\n\u003cli\u003e클래스 전체 기본값 (Class-wide default values): SQLAlchemy 특정 기능이므로 지원하지 않습니다.\u003c/li\u003e\n\u003cli\u003e디스크립터 타입 필드 지원 (Descriptor-typed field support): \u003ccode\u003edataclass\u003c/code\u003e가 디스크립터 타입 필드를 적절히 지원한다는 사실이 확인되어 추가하지 않았습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econverter\u003c/code\u003e 필드 지정자 매개변수: 입력 매개변수의 타입을 유추하기 어렵고 \u003ccode\u003eAny\u003c/code\u003e 타입으로 처리해야 할 수 있어 지원이 복잡하다고 판단했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2457,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 681 - Data Class Transforms\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 10:10:35+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/681/\",\"postId\":\"2025-09-27-pep-0681-data-class-transforms\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/680/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 680 - tomllib: Support for Parsing TOML in the Standard Library\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 681 - Data Class Transforms\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/682/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 682 - Format Specifier for Signed Zero\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>