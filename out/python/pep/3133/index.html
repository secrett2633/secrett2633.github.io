<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 3133 - Introducing Roles</h1><div class="page__meta"><time dateTime="2025-09-27 14:33:16+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-3133/">PEP 3133 - Introducing Roles</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 01-May-2007</p>
</blockquote>
<h1>PEP 3133 – 역할(Roles) 소개 (PEP 3133 – Introducing Roles)</h1>
<ul>
<li><strong>작성자:</strong> Collin Winter</li>
<li><strong>상태:</strong> 거부됨 (Rejected)</li>
<li><strong>유형:</strong> 표준 트랙 (Standards Track)</li>
<li><strong>요구 사항:</strong> PEP 3115, PEP 3129</li>
<li><strong>작성일:</strong> 2007년 5월 1일</li>
<li><strong>Python 버전:</strong> 3.0</li>
<li><strong>게시 이력:</strong> 2007년 5월 13일</li>
</ul>
<h2>거부 공지 (Rejection Notice)</h2>
<p>이 PEP는 PEP 3119를 더 건전하고 미니멀리스트적인 접근 방식으로 발전시키는 데 도움이 되었지만, PEP 3119의 최신 버전을 훨씬 선호합니다. - GvR (Guido van Rossum)</p>
<h2>요약 (Abstract)</h2>
<p>Python의 기존 객체 모델은 객체를 구현 방식에 따라 조직합니다. 하지만 특히 Python과 같은 덕 타이핑(duck typing) 기반 언어에서는 객체가 해당 부분을 어떻게 충족하는지(구현)보다는 더 큰 시스템에서 어떤 역할을 하는지(의도)에 따라 객체를 조직하는 것이 바람직한 경우가 많습니다. 이 PEP는 객체를 구현보다는 의도에 따라 조직하는 메커니즘인 '역할(roles)' 개념을 소개합니다.</p>
<h2>배경 (Rationale)</h2>
<p>처음에 객체는 프로그래머가 기능과 상태를 결합하고 다형성(polymorphism) 및 상속(inheritance)과 같은 개념을 통해 코드 재사용성을 높일 수 있도록 해주었으며, 이는 매우 좋은 것이었습니다. 그러나 상속과 다형성만으로는 부족한 시기가 왔습니다. 개(dogs)와 나무(trees)라는 두 가지 개념의 등장으로, 우리는 단순히 "짖는(bark) 것을 이해하는가?"를 아는 것만으로는 만족할 수 없게 되었습니다. 이제 우리는 주어진 객체가 "짖는다"는 것을 무엇을 의미한다고 생각하는지 알아야 할 필요가 생겼습니다.</p>
<p>여기서 자세히 설명하는 한 가지 해결책은 전통적인 클래스/인스턴스 시스템에 직교적(orthogonal)이며 상호 보완적인 메커니즘인 '역할'입니다. 클래스가 상태와 구현에 초점을 맞추는 반면, 역할 메커니즘은 주어진 클래스에 구현된 '행동(behaviours)'만을 다룹니다.</p>
<p>이 시스템은 원래 "traits"라고 불렸고 Squeak Smalltalk에서 구현되었습니다. 이후 Perl 6에서 "roles"라는 이름으로 채택되었으며, 주로 여기서 이 개념이 Python 3용으로 해석되었습니다. Python 3에서는 "roles"라는 이름을 유지할 예정이었습니다.</p>
<p>요컨대, 역할은 객체가 '무엇을 하는지'를 알려주고, 클래스는 객체가 '어떻게 하는지'를 알려줍니다. 이 PEP에서는 주어진 객체의 "짖는다"는 이해가 나무와 같은지 개와 같은지를 쉽게 결정할 수 있는 Python 3용 시스템을 제시할 것입니다. (더 심각한 예시들도 있을 수 있습니다.)</p>
<h2>구문 관련 참고 사항 (A Note on Syntax)</h2>
<p>이 PEP에 제시된 구문 제안들은 잠정적인 것이며 단순한 아이디어로 간주되어야 합니다. 이 PEP가 의존하는 필수적인 부분들, 즉 PEP 3115의 클래스 정의 구문과 PEP 3129의 클래스 데코레이터(class decorators)는 아직 공식화 중이며 변경될 수 있습니다. 함수 이름은 물론, 오랜 시간 동안 논쟁의 대상이 될 것입니다.</p>
<h2>역할 수행 (Performing Your Role)</h2>
<h3>정적 역할 할당 (Static Role Assignment)</h3>
<p><code>Tree</code> 및 <code>Dog</code> 클래스를 정의하는 것부터 시작해 봅시다.</p>
<pre><code class="language-python">class Tree(Vegetable):
    def bark(self):
        return self.is_rough()

class Dog(Animal):
    def bark(self):
        return self.goes_ruff()
</code></pre>
<p>두 클래스 모두 동일한 시그니처(signature)를 가진 <code>bark()</code> 메서드를 구현하지만, 완전히 다른 작업을 수행합니다. 우리가 기대하는 바를 구별할 수 있는 방법이 필요합니다. 상속과 간단한 <code>isinstance()</code> 테스트에 의존하는 것은 코드 재사용을 제한하거나, 모든 개와 유사한 클래스가 <code>Dog</code>에서 상속받도록 강제할 수 있습니다. 역할이 도움이 될 수 있는지 살펴보겠습니다.</p>
<pre><code class="language-python">@perform_role(Doglike)
class Dog(Animal):
    ...

@perform_role(Treelike)
class Tree(Vegetable):
    ...

@perform_role(SitThere)
class Rock(Mineral):
    ...
</code></pre>
<p>우리는 PEP 3129의 클래스 데코레이터를 사용하여 특정 역할(들)을 클래스와 연결합니다. 이제 클라이언트 코드(client code)는 들어오는 객체가 <code>Doglike</code> 역할을 수행하는지 확인할 수 있으며, 이를 통해 <code>Wolf</code>, <code>LaughingHyena</code>, <code>Aibo</code> 인스턴스도 처리할 수 있습니다.</p>
<p>역할은 일반적인 상속을 통해 구성될 수 있습니다.</p>
<pre><code class="language-python">@perform_role(Guard, MummysLittleDarling)
class GermanShepherd(Dog):
    def guard(self, the_precious):
        while True:
            if intruder_near(the_precious):
                self.growl()
    def get_petted(self):
        self.swallow_pride()
</code></pre>
<p>여기서 <code>GermanShepherd</code> 인스턴스는 세 가지 역할을 수행합니다. <code>Guard</code>와 <code>MummysLittleDarling</code>은 직접 적용되고, <code>Doglike</code>는 <code>Dog</code>로부터 상속됩니다.</p>
<h3>런타임 역할 할당 (Assigning Roles at Runtime)</h3>
<p>역할은 데코레이터가 제공하는 문법적 설탕(syntactic sugar)을 풀어서 런타임에도 할당할 수 있습니다.</p>
<p>다른 모듈에서 <code>Robot</code> 클래스를 가져왔다고 가정해 봅시다. <code>Robot</code>이 이미 <code>Guard</code> 인터페이스를 구현하고 있다는 것을 알고 있으므로, <code>Guard</code> 관련 코드와 잘 작동하도록 만들고 싶습니다.</p>
<pre><code class="language-python">>>> perform(Guard)(Robot)
</code></pre>
<p>이것은 즉시 효력을 발휘하며 <code>Robot</code>의 모든 인스턴스에 영향을 미칩니다.</p>
<h3>역할에 대해 질문하기 (Asking Questions About Roles)</h3>
<p>로봇 군대에게 그들이 경비원(guards)이라고 말했다고 해서, 가끔 그들의 임무를 확인하고 싶을 것입니다.</p>
<pre><code class="language-python">>>> performs(our_robot, Guard)
True
</code></pre>
<p>저기 저 로봇은 어떻습니까?</p>
<pre><code class="language-python">>>> performs(that_robot_over_there, Guard)
True
</code></pre>
<p><code>performs()</code> 함수는 주어진 객체가 주어진 역할을 수행하는지 묻는 데 사용됩니다. 그러나 클래스에 그 인스턴스가 역할을 수행하는지 묻는 데는 사용할 수 없습니다.</p>
<pre><code class="language-python">>>> performs(Robot, Guard)
False
</code></pre>
<p>이는 <code>Robot</code> 클래스가 <code>Robot</code> 인스턴스와 상호 교환될 수 없기 때문입니다.</p>
<h2>새 역할 정의 (Defining New Roles)</h2>
<h3>빈 역할 (Empty Roles)</h3>
<p>역할은 일반 클래스처럼 정의되지만, <code>Role</code> 메타클래스(metaclass)를 사용합니다.</p>
<pre><code class="language-python">class Doglike(metaclass=Role):
    ...
</code></pre>
<p>메타클래스는 <code>Doglike</code>가 5가 <code>int</code>이고 <code>tuple</code>이 <code>type</code>인 것과 같은 방식으로 <code>Role</code>임을 나타내는 데 사용됩니다.</p>
<h3>상속을 통한 역할 구성 (Composing Roles via Inheritance)</h3>
<p>역할은 다른 역할을 상속받을 수 있으며, 이는 역할을 구성하는 효과를 가집니다. 여기서 <code>Dog</code>의 인스턴스는 <code>Doglike</code>와 <code>FourLegs</code> 역할을 모두 수행할 것입니다.</p>
<pre><code class="language-python">class FourLegs(metaclass=Role):
    pass

class Doglike(FourLegs, Carnivor):
    pass

@perform_role(Doglike)
class Dog(Mammal):
    pass
</code></pre>
<h3>구체적인 메서드 요구 (Requiring Concrete Methods)</h3>
<p>지금까지 우리는 빈 역할만을 정의했는데, 이는 그다지 유용하지 않습니다. 이제 <code>Doglike</code> 역할을 수행한다고 주장하는 모든 클래스가 <code>bark()</code> 메서드를 정의하도록 요구해 봅시다.</p>
<pre><code class="language-python">class Doglike(FourLegs):
    def bark(self):
        pass
</code></pre>
<p>메서드를 "추상(abstract)"으로 표시하기 위해 데코레이터가 필요하지 않으며, 이 메서드는 절대로 호출되지 않을 것이므로 포함된 코드(있는 경우)는 무관합니다. 역할은 추상 메서드만 제공합니다. 구체적인 기본 구현은 믹스인(mixins)과 같은 다른, 더 적합한 메커니즘에 맡겨집니다.</p>
<p>역할을 정의하고 클래스가 해당 역할을 수행한다고 주장하면, 그 주장이 검증되는 것이 필수적입니다. 여기서는 프로그래머가 역할에 필요한 메서드 중 하나를 잘못 입력했습니다.</p>
<pre><code class="language-python">@perform_role(FourLegs)
class Horse(Mammal):
    def run_like_teh_wind(self)
        ...
</code></pre>
<p>이는 역할 시스템이 <code>run_like_the_wind()</code> 메서드가 없다고 불평하며 예외(exception)를 발생시키게 할 것입니다. 역할 시스템은 클래스가 주어진 역할을 수행한다고 표시되는 즉시 이러한 검사를 수행합니다.</p>
<p>구체적인 메서드는 역할이 요구하는 시그니처와 정확히 일치해야 합니다. 여기서는 <code>bark()</code>의 구체적인 버전을 정의하여 역할을 충족시키려 했지만, 조금 어긋났습니다.</p>
<pre><code class="language-python">@perform_role(Doglike)
class Coyote(Mammal):
    def bark(self, target=moon):
        pass
</code></pre>
<p>이 메서드의 시그니처는 <code>Doglike</code> 역할이 기대했던 것과 정확히 일치하지 않으므로, 역할 시스템은 약간 문제를 일으킬 것입니다.</p>
<h2>메커니즘 (Mechanism)</h2>
<p>다음은 Python에서 역할이 어떻게 표현될 수 있는지에 대한 아이디어입니다. 여기 예시들은 역할 메커니즘이 Python 인터프리터(interpreter)를 변경하지 않고도 구현될 수 있도록 구성되었습니다. (예시는 Curtis Poe의 Perl 6 역할에 대한 기사에서 각색되었습니다.)</p>
<h3>정적 클래스 역할 할당 (Static class role assignment)</h3>
<pre><code class="language-python">@perform_role(Thieving)
class Elf(Character):
    ...
</code></pre>
<p><code>perform_role()</code>은 여러 인수를 허용하므로 다음도 유효합니다.</p>
<pre><code class="language-python">@perform_role(Thieving, Spying, Archer)
class Elf(Character):
    ...
</code></pre>
<p><code>Elf</code> 클래스는 이제 <code>Thieving</code>, <code>Spying</code>, <code>Archer</code> 역할을 모두 수행합니다.</p>
<h3>인스턴스 쿼리 (Querying instances)</h3>
<pre><code class="language-python">if performs(my_elf, Thieving):
    ...
</code></pre>
<p><code>performs()</code>의 두 번째 인수는 <code>__contains__()</code> 메서드를 가진 무엇이든 될 수 있으므로 다음도 유효합니다.</p>
<pre><code class="language-python">if performs(my_elf, set([Thieving, Spying, BoyScout])):
    ...
</code></pre>
<p><code>isinstance()</code>와 마찬가지로, 객체는 표현식이 <code>True</code>가 되기 위해 세트(set) 중 단 하나의 역할만 수행하면 됩니다.</p>
<h2>추상 기본 클래스(Abstract Base Classes)와의 관계 (Relationship to Abstract Base Classes)</h2>
<p>이 PEP의 초기 초안은 역할을 PEP 3119에서 제안된 추상 기본 클래스와 경쟁하는 것으로 보았습니다. 추가 논의와 숙고 끝에, 다음과 같이 책임과 사용 사례의 타협 및 위임이 이루어졌습니다.</p>
<p>역할은 객체의 '의미론(semantics)'과 '추상적인 능력(abstract capabilities)'을 나타내는 방법을 제공합니다. 역할은 추상 메서드를 정의할 수 있지만, 이는 특정 의미론에 접근하는 인터페이스를 묘사하는 방법으로만 사용됩니다. <code>Ordering</code> 역할은 특정 정렬 연산자(ordering operators) 집합이 정의되도록 요구할 수 있습니다.</p>
<pre><code class="language-python">class Ordering(metaclass=Role):
    def __ge__(self, other): pass
    def __le__(self, other): pass
    def __ne__(self, other): pass
    # ...and so on
</code></pre>
<p>이러한 방식으로, 우리는 특정 구현에 제약을 받거나 신경 쓰지 않고도 더 큰 시스템 내에서 객체의 역할이나 기능을 나타낼 수 있습니다.</p>
<p>이와 대조적으로, 추상 기본 클래스는 일반적이고 개별적인 구현 단위(discrete units of implementation)를 재사용하는 방법입니다. 예를 들어, 다른 연산자를 기반으로 여러 정렬 연산자를 구현하는 <code>OrderingMixin</code>을 정의할 수 있습니다.</p>
<pre><code class="language-python">class OrderingMixin:
    def __ge__(self, other): return self > other or self == other
    def __le__(self, other): return self &#x3C; other or self == other
    def __ne__(self, other): return not self == other
    # ...and so on
</code></pre>
<p>이 추상 기본 클래스—더 정확히는 구체적인 믹스인(concrete mixin)—를 사용하면 프로그래머는 제한된 연산자 집합을 정의하고 믹스인이 다른 연산자를 사실상 "파생"하도록 할 수 있습니다.</p>
<p>이 두 가지 직교적인 시스템을 결합함으로써, 우리는 a) 기능을 제공하고, b) 소비자 시스템에 이 기능의 존재와 가용성을 알릴 수 있습니다. 예를 들어, 위의 <code>OrderingMixin</code> 클래스는 <code>Ordering</code> 역할에서 표현된 인터페이스와 의미론을 만족시키므로, 우리는 믹스인이 해당 역할을 수행한다고 말합니다.</p>
<pre><code class="language-python">@perform_role(Ordering)
class OrderingMixin:
    def __ge__(self, other): return self > other or self == other
    def __le__(self, other): return self &#x3C; other or self == other
    def __ne__(self, other): return not self == other
    # ...and so on
</code></pre>
<p>이제 이 믹스인을 사용하는 모든 클래스는 자동으로—즉, 추가적인 프로그래머의 노력 없이—<code>Ordering</code> 역할을 수행하는 것으로 태그됩니다.</p>
<p>관심사를 두 개의 별개의 직교 시스템으로 분리하는 것은 각 시스템을 개별적으로 사용할 수 있도록 해주기 때문에 바람직합니다. 예를 들어, 해시 값(hash value)을 결정할 때 내용을 고려하는 컨테이너임을 나타내는 <code>RecursiveHash</code> 역할을 제공하는 타사 패키지를 생각해 봅시다. Python의 내장 <code>tuple</code> 및 <code>frozenset</code> 클래스는 이 의미론을 따르므로, <code>RecursiveHash</code> 역할을 이들에게 적용할 수 있습니다.</p>
<pre><code class="language-python">>>> perform_role(RecursiveHash)(tuple)
>>> perform_role(RecursiveHash)(frozenset)
</code></pre>
<p>이제 <code>RecursiveHash</code> 객체를 사용하는 모든 코드는 <code>tuple</code>과 <code>frozenset</code>도 사용할 수 있게 됩니다.</p>
<h2>미해결 문제 (Open Issues)</h2>
<h3>인스턴스가 클래스와 다른 역할을 수행하도록 허용 (Allowing Instances to Perform Different Roles Than Their Class)</h3>
<p>Perl 6는 인스턴스가 클래스와 다른 역할을 수행하는 것을 허용합니다. 이러한 변경 사항은 단일 인스턴스에 국한되며 클래스의 다른 인스턴스에는 영향을 미치지 않습니다. 예를 들어:</p>
<pre><code class="language-perl">my_elf = Elf();
my_elf.goes_on_quest();
my_elf.becomes_evil();
now_performs(my_elf, Thieving); # Only this one elf is a thief
my_elf.steals(["purses", "candy", "kisses"]);
</code></pre>
<p>Perl 6에서는 인스턴스의 원래 부모로부터 상속받고 추가 역할(들)을 수행하는 익명 클래스(anonymous class)를 생성하여 이를 수행합니다. 이는 Python 3에서도 가능하지만, 바람직한지는 또 다른 문제입니다.</p>
<p>이 기능을 포함하면 물론 Charles Dickens의 작품을 Python으로 표현하는 것이 훨씬 쉬워질 것입니다.</p>
<pre><code class="language-python">>>> from literature import role, BildungsRoman
>>> from dickens import Urchin, Gentleman
>>>
>>> with BildungsRoman() as OliverTwist:
...     mr_brownlow = Gentleman()
...     oliver, artful_dodger = Urchin(), Urchin()
...     now_performs(artful_dodger, [role.Thief, role.Scoundrel])
...
...     oliver.has_adventures_with(ArtfulDodger)
...     mr_brownlow.adopt_orphan(oliver)
...     now_performs(oliver, role.RichWard)
</code></pre>
<h3>속성 요구 (Requiring Attributes)</h3>
<p>Neal Norwitz는 메서드를 요구하는 것과 동일한 메커니즘을 사용하여 속성(attributes)의 존재에 대한 주장을 할 수 있는 기능을 요청했습니다. 역할은 클래스 정의 시점에 효력을 발휘하고, 대다수의 속성은 클래스의 <code>__init__()</code> 메서드에 의해 런타임에 정의되기 때문에, 메서드와 동시에 속성을 확인하는 좋은 방법은 없는 것 같습니다.</p>
<p>단지 문서화 목적이라도, 강제되지 않는 속성(non-enforced attributes)을 역할 정의에 포함하는 것이 여전히 바람직할 수 있습니다.</p>
<h3>역할의 역할 (Roles of Roles)</h3>
<p>제안된 의미론에 따르면, 역할도 자신만의 역할을 가질 수 있습니다.</p>
<pre><code class="language-python">@perform_role(Y)
class X(metaclass=Role):
    ...
</code></pre>
<p>이것은 가능하지만, 역할은 일반적으로 인스턴스화되지 않기 때문에 의미가 없습니다. 이 표현에 의미를 부여하는 것에 대한 오프라인 논의가 있었지만, 아직 좋은 아이디어가 나오지 않았습니다.</p>
<h3><code>class_performs()</code></h3>
<p>현재 클래스가 그 인스턴스가 특정 역할을 수행하는지 묻는 것은 불가능합니다. <code>performs()</code>의 아날로그를 제공하여 다음과 같이 만들 수 있습니다.</p>
<pre><code class="language-python">>>> isinstance(my_dwarf, Dwarf)
True
>>> performs(my_dwarf, Surly)
True
>>> performs(Dwarf, Surly)
False
>>> class_performs(Dwarf, Surly)
True
</code></pre>
<h3>더 예쁜 동적 역할 할당 구문 (Prettier Dynamic Role Assignment Syntax)</h3>
<p>이 PEP의 초기 초안에는 클래스에 동적으로 역할을 할당하는 별도의 메커니즘이 포함되어 있었습니다. 이는 다음과 같이 표현되었습니다.</p>
<pre><code class="language-python">>>> now_perform(Dwarf, GoldMiner)
</code></pre>
<p>이 동일한 기능은 데코레이터가 제공하는 문법적 설탕을 풀어서 이미 존재합니다.</p>
<pre><code class="language-python">>>> perform_role(GoldMiner)(Dwarf)
</code></pre>
<p>동적 역할 할당이 전용 표현을 정당화할 만큼 충분히 중요한지 여부가 문제입니다.</p>
<h3>구문 지원 (Syntax Support)</h3>
<p>이 PEP에 제시된 표현 방식은 역할 시스템이 독립형 패키지(stand-alone package)로 제공될 수 있도록 설계되었지만, 역할을 정의, 할당 및 쿼리하는 특수 구문을 추가하는 것이 바람직할 수 있습니다. 한 가지 예는 <code>role</code> 키워드일 수 있으며, 이는 다음을 변환할 것입니다.</p>
<pre><code class="language-python">class MyRole(metaclass=Role):
    ...
</code></pre>
<p>다음으로:</p>
<pre><code class="language-python">role MyRole:
    ...
</code></pre>
<p>역할 할당은 PEP 3115에서 제안된 클래스 정의 인수를 활용할 수 있습니다.</p>
<pre><code class="language-python">class MyClass(performs=MyRole):
    ...
</code></pre>
<h2>구현 (Implementation)</h2>
<p>참조 구현(reference implementation)이 곧 나올 예정입니다.</p>
<h2>감사 (Acknowledgements)</h2>
<p>역할과 추상 기본 클래스 간의 차이점, 중복, 미묘한 지점들을 해결하기 위해 여러 시간 동안 직접 논의해준 Jeffery Yasskin, Talin, Guido van Rossum에게 감사합니다.</p>
<h2>참조 (References)</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/AIBO">http://en.wikipedia.org/wiki/AIBO</a></li>
<li><a href="http://www.perlmonks.org/?node_id=384858">http://www.perlmonks.org/?node_id=384858</a></li>
<li><a href="http://dev.perl.org/perl6/doc/design/syn/S12.html">http://dev.perl.org/perl6/doc/design/syn/S12.html</a></li>
<li><a href="http://www.iam.unibe.ch/~scg/Archive/Papers/Scha03aTraits.pdf">http://www.iam.unibe.ch/~scg/Archive/Papers/Scha03aTraits.pdf</a></li>
<li><a href="https://mail.python.org/pipermail/python-3000/2007-April/007026.html">https://mail.python.org/pipermail/python-3000/2007-April/007026.html</a></li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/3133\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"jf5MDuRUbMNVvRN9tv5rq\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/3133/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/3133\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"3133\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/3133\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T5559,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-3133/\"\u003ePEP 3133 - Introducing Roles\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 01-May-2007\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 3133 – 역할(Roles) 소개 (PEP 3133 – Introducing Roles)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Collin Winter\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 거부됨 (Rejected)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e 표준 트랙 (Standards Track)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e요구 사항:\u003c/strong\u003e PEP 3115, PEP 3129\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e작성일:\u003c/strong\u003e 2007년 5월 1일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.0\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e게시 이력:\u003c/strong\u003e 2007년 5월 13일\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e거부 공지 (Rejection Notice)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 PEP 3119를 더 건전하고 미니멀리스트적인 접근 방식으로 발전시키는 데 도움이 되었지만, PEP 3119의 최신 버전을 훨씬 선호합니다. - GvR (Guido van Rossum)\u003c/p\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003ePython의 기존 객체 모델은 객체를 구현 방식에 따라 조직합니다. 하지만 특히 Python과 같은 덕 타이핑(duck typing) 기반 언어에서는 객체가 해당 부분을 어떻게 충족하는지(구현)보다는 더 큰 시스템에서 어떤 역할을 하는지(의도)에 따라 객체를 조직하는 것이 바람직한 경우가 많습니다. 이 PEP는 객체를 구현보다는 의도에 따라 조직하는 메커니즘인 '역할(roles)' 개념을 소개합니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003e처음에 객체는 프로그래머가 기능과 상태를 결합하고 다형성(polymorphism) 및 상속(inheritance)과 같은 개념을 통해 코드 재사용성을 높일 수 있도록 해주었으며, 이는 매우 좋은 것이었습니다. 그러나 상속과 다형성만으로는 부족한 시기가 왔습니다. 개(dogs)와 나무(trees)라는 두 가지 개념의 등장으로, 우리는 단순히 \"짖는(bark) 것을 이해하는가?\"를 아는 것만으로는 만족할 수 없게 되었습니다. 이제 우리는 주어진 객체가 \"짖는다\"는 것을 무엇을 의미한다고 생각하는지 알아야 할 필요가 생겼습니다.\u003c/p\u003e\n\u003cp\u003e여기서 자세히 설명하는 한 가지 해결책은 전통적인 클래스/인스턴스 시스템에 직교적(orthogonal)이며 상호 보완적인 메커니즘인 '역할'입니다. 클래스가 상태와 구현에 초점을 맞추는 반면, 역할 메커니즘은 주어진 클래스에 구현된 '행동(behaviours)'만을 다룹니다.\u003c/p\u003e\n\u003cp\u003e이 시스템은 원래 \"traits\"라고 불렸고 Squeak Smalltalk에서 구현되었습니다. 이후 Perl 6에서 \"roles\"라는 이름으로 채택되었으며, 주로 여기서 이 개념이 Python 3용으로 해석되었습니다. Python 3에서는 \"roles\"라는 이름을 유지할 예정이었습니다.\u003c/p\u003e\n\u003cp\u003e요컨대, 역할은 객체가 '무엇을 하는지'를 알려주고, 클래스는 객체가 '어떻게 하는지'를 알려줍니다. 이 PEP에서는 주어진 객체의 \"짖는다\"는 이해가 나무와 같은지 개와 같은지를 쉽게 결정할 수 있는 Python 3용 시스템을 제시할 것입니다. (더 심각한 예시들도 있을 수 있습니다.)\u003c/p\u003e\n\u003ch2\u003e구문 관련 참고 사항 (A Note on Syntax)\u003c/h2\u003e\n\u003cp\u003e이 PEP에 제시된 구문 제안들은 잠정적인 것이며 단순한 아이디어로 간주되어야 합니다. 이 PEP가 의존하는 필수적인 부분들, 즉 PEP 3115의 클래스 정의 구문과 PEP 3129의 클래스 데코레이터(class decorators)는 아직 공식화 중이며 변경될 수 있습니다. 함수 이름은 물론, 오랜 시간 동안 논쟁의 대상이 될 것입니다.\u003c/p\u003e\n\u003ch2\u003e역할 수행 (Performing Your Role)\u003c/h2\u003e\n\u003ch3\u003e정적 역할 할당 (Static Role Assignment)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eTree\u003c/code\u003e 및 \u003ccode\u003eDog\u003c/code\u003e 클래스를 정의하는 것부터 시작해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Tree(Vegetable):\n    def bark(self):\n        return self.is_rough()\n\nclass Dog(Animal):\n    def bark(self):\n        return self.goes_ruff()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 클래스 모두 동일한 시그니처(signature)를 가진 \u003ccode\u003ebark()\u003c/code\u003e 메서드를 구현하지만, 완전히 다른 작업을 수행합니다. 우리가 기대하는 바를 구별할 수 있는 방법이 필요합니다. 상속과 간단한 \u003ccode\u003eisinstance()\u003c/code\u003e 테스트에 의존하는 것은 코드 재사용을 제한하거나, 모든 개와 유사한 클래스가 \u003ccode\u003eDog\u003c/code\u003e에서 상속받도록 강제할 수 있습니다. 역할이 도움이 될 수 있는지 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@perform_role(Doglike)\nclass Dog(Animal):\n    ...\n\n@perform_role(Treelike)\nclass Tree(Vegetable):\n    ...\n\n@perform_role(SitThere)\nclass Rock(Mineral):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 PEP 3129의 클래스 데코레이터를 사용하여 특정 역할(들)을 클래스와 연결합니다. 이제 클라이언트 코드(client code)는 들어오는 객체가 \u003ccode\u003eDoglike\u003c/code\u003e 역할을 수행하는지 확인할 수 있으며, 이를 통해 \u003ccode\u003eWolf\u003c/code\u003e, \u003ccode\u003eLaughingHyena\u003c/code\u003e, \u003ccode\u003eAibo\u003c/code\u003e 인스턴스도 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e역할은 일반적인 상속을 통해 구성될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@perform_role(Guard, MummysLittleDarling)\nclass GermanShepherd(Dog):\n    def guard(self, the_precious):\n        while True:\n            if intruder_near(the_precious):\n                self.growl()\n    def get_petted(self):\n        self.swallow_pride()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003eGermanShepherd\u003c/code\u003e 인스턴스는 세 가지 역할을 수행합니다. \u003ccode\u003eGuard\u003c/code\u003e와 \u003ccode\u003eMummysLittleDarling\u003c/code\u003e은 직접 적용되고, \u003ccode\u003eDoglike\u003c/code\u003e는 \u003ccode\u003eDog\u003c/code\u003e로부터 상속됩니다.\u003c/p\u003e\n\u003ch3\u003e런타임 역할 할당 (Assigning Roles at Runtime)\u003c/h3\u003e\n\u003cp\u003e역할은 데코레이터가 제공하는 문법적 설탕(syntactic sugar)을 풀어서 런타임에도 할당할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다른 모듈에서 \u003ccode\u003eRobot\u003c/code\u003e 클래스를 가져왔다고 가정해 봅시다. \u003ccode\u003eRobot\u003c/code\u003e이 이미 \u003ccode\u003eGuard\u003c/code\u003e 인터페이스를 구현하고 있다는 것을 알고 있으므로, \u003ccode\u003eGuard\u003c/code\u003e 관련 코드와 잘 작동하도록 만들고 싶습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e perform(Guard)(Robot)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 즉시 효력을 발휘하며 \u003ccode\u003eRobot\u003c/code\u003e의 모든 인스턴스에 영향을 미칩니다.\u003c/p\u003e\n\u003ch3\u003e역할에 대해 질문하기 (Asking Questions About Roles)\u003c/h3\u003e\n\u003cp\u003e로봇 군대에게 그들이 경비원(guards)이라고 말했다고 해서, 가끔 그들의 임무를 확인하고 싶을 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e performs(our_robot, Guard)\nTrue\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e저기 저 로봇은 어떻습니까?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e performs(that_robot_over_there, Guard)\nTrue\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eperforms()\u003c/code\u003e 함수는 주어진 객체가 주어진 역할을 수행하는지 묻는 데 사용됩니다. 그러나 클래스에 그 인스턴스가 역할을 수행하는지 묻는 데는 사용할 수 없습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e performs(Robot, Guard)\nFalse\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 \u003ccode\u003eRobot\u003c/code\u003e 클래스가 \u003ccode\u003eRobot\u003c/code\u003e 인스턴스와 상호 교환될 수 없기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e새 역할 정의 (Defining New Roles)\u003c/h2\u003e\n\u003ch3\u003e빈 역할 (Empty Roles)\u003c/h3\u003e\n\u003cp\u003e역할은 일반 클래스처럼 정의되지만, \u003ccode\u003eRole\u003c/code\u003e 메타클래스(metaclass)를 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Doglike(metaclass=Role):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e메타클래스는 \u003ccode\u003eDoglike\u003c/code\u003e가 5가 \u003ccode\u003eint\u003c/code\u003e이고 \u003ccode\u003etuple\u003c/code\u003e이 \u003ccode\u003etype\u003c/code\u003e인 것과 같은 방식으로 \u003ccode\u003eRole\u003c/code\u003e임을 나타내는 데 사용됩니다.\u003c/p\u003e\n\u003ch3\u003e상속을 통한 역할 구성 (Composing Roles via Inheritance)\u003c/h3\u003e\n\u003cp\u003e역할은 다른 역할을 상속받을 수 있으며, 이는 역할을 구성하는 효과를 가집니다. 여기서 \u003ccode\u003eDog\u003c/code\u003e의 인스턴스는 \u003ccode\u003eDoglike\u003c/code\u003e와 \u003ccode\u003eFourLegs\u003c/code\u003e 역할을 모두 수행할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass FourLegs(metaclass=Role):\n    pass\n\nclass Doglike(FourLegs, Carnivor):\n    pass\n\n@perform_role(Doglike)\nclass Dog(Mammal):\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e구체적인 메서드 요구 (Requiring Concrete Methods)\u003c/h3\u003e\n\u003cp\u003e지금까지 우리는 빈 역할만을 정의했는데, 이는 그다지 유용하지 않습니다. 이제 \u003ccode\u003eDoglike\u003c/code\u003e 역할을 수행한다고 주장하는 모든 클래스가 \u003ccode\u003ebark()\u003c/code\u003e 메서드를 정의하도록 요구해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Doglike(FourLegs):\n    def bark(self):\n        pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e메서드를 \"추상(abstract)\"으로 표시하기 위해 데코레이터가 필요하지 않으며, 이 메서드는 절대로 호출되지 않을 것이므로 포함된 코드(있는 경우)는 무관합니다. 역할은 추상 메서드만 제공합니다. 구체적인 기본 구현은 믹스인(mixins)과 같은 다른, 더 적합한 메커니즘에 맡겨집니다.\u003c/p\u003e\n\u003cp\u003e역할을 정의하고 클래스가 해당 역할을 수행한다고 주장하면, 그 주장이 검증되는 것이 필수적입니다. 여기서는 프로그래머가 역할에 필요한 메서드 중 하나를 잘못 입력했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@perform_role(FourLegs)\nclass Horse(Mammal):\n    def run_like_teh_wind(self)\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 역할 시스템이 \u003ccode\u003erun_like_the_wind()\u003c/code\u003e 메서드가 없다고 불평하며 예외(exception)를 발생시키게 할 것입니다. 역할 시스템은 클래스가 주어진 역할을 수행한다고 표시되는 즉시 이러한 검사를 수행합니다.\u003c/p\u003e\n\u003cp\u003e구체적인 메서드는 역할이 요구하는 시그니처와 정확히 일치해야 합니다. 여기서는 \u003ccode\u003ebark()\u003c/code\u003e의 구체적인 버전을 정의하여 역할을 충족시키려 했지만, 조금 어긋났습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@perform_role(Doglike)\nclass Coyote(Mammal):\n    def bark(self, target=moon):\n        pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 메서드의 시그니처는 \u003ccode\u003eDoglike\u003c/code\u003e 역할이 기대했던 것과 정확히 일치하지 않으므로, 역할 시스템은 약간 문제를 일으킬 것입니다.\u003c/p\u003e\n\u003ch2\u003e메커니즘 (Mechanism)\u003c/h2\u003e\n\u003cp\u003e다음은 Python에서 역할이 어떻게 표현될 수 있는지에 대한 아이디어입니다. 여기 예시들은 역할 메커니즘이 Python 인터프리터(interpreter)를 변경하지 않고도 구현될 수 있도록 구성되었습니다. (예시는 Curtis Poe의 Perl 6 역할에 대한 기사에서 각색되었습니다.)\u003c/p\u003e\n\u003ch3\u003e정적 클래스 역할 할당 (Static class role assignment)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@perform_role(Thieving)\nclass Elf(Character):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eperform_role()\u003c/code\u003e은 여러 인수를 허용하므로 다음도 유효합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@perform_role(Thieving, Spying, Archer)\nclass Elf(Character):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eElf\u003c/code\u003e 클래스는 이제 \u003ccode\u003eThieving\u003c/code\u003e, \u003ccode\u003eSpying\u003c/code\u003e, \u003ccode\u003eArcher\u003c/code\u003e 역할을 모두 수행합니다.\u003c/p\u003e\n\u003ch3\u003e인스턴스 쿼리 (Querying instances)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif performs(my_elf, Thieving):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eperforms()\u003c/code\u003e의 두 번째 인수는 \u003ccode\u003e__contains__()\u003c/code\u003e 메서드를 가진 무엇이든 될 수 있으므로 다음도 유효합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif performs(my_elf, set([Thieving, Spying, BoyScout])):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eisinstance()\u003c/code\u003e와 마찬가지로, 객체는 표현식이 \u003ccode\u003eTrue\u003c/code\u003e가 되기 위해 세트(set) 중 단 하나의 역할만 수행하면 됩니다.\u003c/p\u003e\n\u003ch2\u003e추상 기본 클래스(Abstract Base Classes)와의 관계 (Relationship to Abstract Base Classes)\u003c/h2\u003e\n\u003cp\u003e이 PEP의 초기 초안은 역할을 PEP 3119에서 제안된 추상 기본 클래스와 경쟁하는 것으로 보았습니다. 추가 논의와 숙고 끝에, 다음과 같이 책임과 사용 사례의 타협 및 위임이 이루어졌습니다.\u003c/p\u003e\n\u003cp\u003e역할은 객체의 '의미론(semantics)'과 '추상적인 능력(abstract capabilities)'을 나타내는 방법을 제공합니다. 역할은 추상 메서드를 정의할 수 있지만, 이는 특정 의미론에 접근하는 인터페이스를 묘사하는 방법으로만 사용됩니다. \u003ccode\u003eOrdering\u003c/code\u003e 역할은 특정 정렬 연산자(ordering operators) 집합이 정의되도록 요구할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Ordering(metaclass=Role):\n    def __ge__(self, other): pass\n    def __le__(self, other): pass\n    def __ne__(self, other): pass\n    # ...and so on\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 방식으로, 우리는 특정 구현에 제약을 받거나 신경 쓰지 않고도 더 큰 시스템 내에서 객체의 역할이나 기능을 나타낼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이와 대조적으로, 추상 기본 클래스는 일반적이고 개별적인 구현 단위(discrete units of implementation)를 재사용하는 방법입니다. 예를 들어, 다른 연산자를 기반으로 여러 정렬 연산자를 구현하는 \u003ccode\u003eOrderingMixin\u003c/code\u003e을 정의할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass OrderingMixin:\n    def __ge__(self, other): return self \u003e other or self == other\n    def __le__(self, other): return self \u0026#x3C; other or self == other\n    def __ne__(self, other): return not self == other\n    # ...and so on\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 추상 기본 클래스—더 정확히는 구체적인 믹스인(concrete mixin)—를 사용하면 프로그래머는 제한된 연산자 집합을 정의하고 믹스인이 다른 연산자를 사실상 \"파생\"하도록 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 두 가지 직교적인 시스템을 결합함으로써, 우리는 a) 기능을 제공하고, b) 소비자 시스템에 이 기능의 존재와 가용성을 알릴 수 있습니다. 예를 들어, 위의 \u003ccode\u003eOrderingMixin\u003c/code\u003e 클래스는 \u003ccode\u003eOrdering\u003c/code\u003e 역할에서 표현된 인터페이스와 의미론을 만족시키므로, 우리는 믹스인이 해당 역할을 수행한다고 말합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@perform_role(Ordering)\nclass OrderingMixin:\n    def __ge__(self, other): return self \u003e other or self == other\n    def __le__(self, other): return self \u0026#x3C; other or self == other\n    def __ne__(self, other): return not self == other\n    # ...and so on\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 이 믹스인을 사용하는 모든 클래스는 자동으로—즉, 추가적인 프로그래머의 노력 없이—\u003ccode\u003eOrdering\u003c/code\u003e 역할을 수행하는 것으로 태그됩니다.\u003c/p\u003e\n\u003cp\u003e관심사를 두 개의 별개의 직교 시스템으로 분리하는 것은 각 시스템을 개별적으로 사용할 수 있도록 해주기 때문에 바람직합니다. 예를 들어, 해시 값(hash value)을 결정할 때 내용을 고려하는 컨테이너임을 나타내는 \u003ccode\u003eRecursiveHash\u003c/code\u003e 역할을 제공하는 타사 패키지를 생각해 봅시다. Python의 내장 \u003ccode\u003etuple\u003c/code\u003e 및 \u003ccode\u003efrozenset\u003c/code\u003e 클래스는 이 의미론을 따르므로, \u003ccode\u003eRecursiveHash\u003c/code\u003e 역할을 이들에게 적용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e perform_role(RecursiveHash)(tuple)\n\u003e\u003e\u003e perform_role(RecursiveHash)(frozenset)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 \u003ccode\u003eRecursiveHash\u003c/code\u003e 객체를 사용하는 모든 코드는 \u003ccode\u003etuple\u003c/code\u003e과 \u003ccode\u003efrozenset\u003c/code\u003e도 사용할 수 있게 됩니다.\u003c/p\u003e\n\u003ch2\u003e미해결 문제 (Open Issues)\u003c/h2\u003e\n\u003ch3\u003e인스턴스가 클래스와 다른 역할을 수행하도록 허용 (Allowing Instances to Perform Different Roles Than Their Class)\u003c/h3\u003e\n\u003cp\u003ePerl 6는 인스턴스가 클래스와 다른 역할을 수행하는 것을 허용합니다. 이러한 변경 사항은 단일 인스턴스에 국한되며 클래스의 다른 인스턴스에는 영향을 미치지 않습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl\"\u003emy_elf = Elf();\nmy_elf.goes_on_quest();\nmy_elf.becomes_evil();\nnow_performs(my_elf, Thieving); # Only this one elf is a thief\nmy_elf.steals([\"purses\", \"candy\", \"kisses\"]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePerl 6에서는 인스턴스의 원래 부모로부터 상속받고 추가 역할(들)을 수행하는 익명 클래스(anonymous class)를 생성하여 이를 수행합니다. 이는 Python 3에서도 가능하지만, 바람직한지는 또 다른 문제입니다.\u003c/p\u003e\n\u003cp\u003e이 기능을 포함하면 물론 Charles Dickens의 작품을 Python으로 표현하는 것이 훨씬 쉬워질 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e from literature import role, BildungsRoman\n\u003e\u003e\u003e from dickens import Urchin, Gentleman\n\u003e\u003e\u003e\n\u003e\u003e\u003e with BildungsRoman() as OliverTwist:\n...     mr_brownlow = Gentleman()\n...     oliver, artful_dodger = Urchin(), Urchin()\n...     now_performs(artful_dodger, [role.Thief, role.Scoundrel])\n...\n...     oliver.has_adventures_with(ArtfulDodger)\n...     mr_brownlow.adopt_orphan(oliver)\n...     now_performs(oliver, role.RichWard)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e속성 요구 (Requiring Attributes)\u003c/h3\u003e\n\u003cp\u003eNeal Norwitz는 메서드를 요구하는 것과 동일한 메커니즘을 사용하여 속성(attributes)의 존재에 대한 주장을 할 수 있는 기능을 요청했습니다. 역할은 클래스 정의 시점에 효력을 발휘하고, 대다수의 속성은 클래스의 \u003ccode\u003e__init__()\u003c/code\u003e 메서드에 의해 런타임에 정의되기 때문에, 메서드와 동시에 속성을 확인하는 좋은 방법은 없는 것 같습니다.\u003c/p\u003e\n\u003cp\u003e단지 문서화 목적이라도, 강제되지 않는 속성(non-enforced attributes)을 역할 정의에 포함하는 것이 여전히 바람직할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e역할의 역할 (Roles of Roles)\u003c/h3\u003e\n\u003cp\u003e제안된 의미론에 따르면, 역할도 자신만의 역할을 가질 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@perform_role(Y)\nclass X(metaclass=Role):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 가능하지만, 역할은 일반적으로 인스턴스화되지 않기 때문에 의미가 없습니다. 이 표현에 의미를 부여하는 것에 대한 오프라인 논의가 있었지만, 아직 좋은 아이디어가 나오지 않았습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eclass_performs()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e현재 클래스가 그 인스턴스가 특정 역할을 수행하는지 묻는 것은 불가능합니다. \u003ccode\u003eperforms()\u003c/code\u003e의 아날로그를 제공하여 다음과 같이 만들 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e isinstance(my_dwarf, Dwarf)\nTrue\n\u003e\u003e\u003e performs(my_dwarf, Surly)\nTrue\n\u003e\u003e\u003e performs(Dwarf, Surly)\nFalse\n\u003e\u003e\u003e class_performs(Dwarf, Surly)\nTrue\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e더 예쁜 동적 역할 할당 구문 (Prettier Dynamic Role Assignment Syntax)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 초기 초안에는 클래스에 동적으로 역할을 할당하는 별도의 메커니즘이 포함되어 있었습니다. 이는 다음과 같이 표현되었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e now_perform(Dwarf, GoldMiner)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 동일한 기능은 데코레이터가 제공하는 문법적 설탕을 풀어서 이미 존재합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e perform_role(GoldMiner)(Dwarf)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e동적 역할 할당이 전용 표현을 정당화할 만큼 충분히 중요한지 여부가 문제입니다.\u003c/p\u003e\n\u003ch3\u003e구문 지원 (Syntax Support)\u003c/h3\u003e\n\u003cp\u003e이 PEP에 제시된 표현 방식은 역할 시스템이 독립형 패키지(stand-alone package)로 제공될 수 있도록 설계되었지만, 역할을 정의, 할당 및 쿼리하는 특수 구문을 추가하는 것이 바람직할 수 있습니다. 한 가지 예는 \u003ccode\u003erole\u003c/code\u003e 키워드일 수 있으며, 이는 다음을 변환할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass MyRole(metaclass=Role):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003erole MyRole:\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e역할 할당은 PEP 3115에서 제안된 클래스 정의 인수를 활용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass MyClass(performs=MyRole):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e참조 구현(reference implementation)이 곧 나올 예정입니다.\u003c/p\u003e\n\u003ch2\u003e감사 (Acknowledgements)\u003c/h2\u003e\n\u003cp\u003e역할과 추상 기본 클래스 간의 차이점, 중복, 미묘한 지점들을 해결하기 위해 여러 시간 동안 직접 논의해준 Jeffery Yasskin, Talin, Guido van Rossum에게 감사합니다.\u003c/p\u003e\n\u003ch2\u003e참조 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://en.wikipedia.org/wiki/AIBO\"\u003ehttp://en.wikipedia.org/wiki/AIBO\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.perlmonks.org/?node_id=384858\"\u003ehttp://www.perlmonks.org/?node_id=384858\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://dev.perl.org/perl6/doc/design/syn/S12.html\"\u003ehttp://dev.perl.org/perl6/doc/design/syn/S12.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.iam.unibe.ch/~scg/Archive/Papers/Scha03aTraits.pdf\"\u003ehttp://www.iam.unibe.ch/~scg/Archive/Papers/Scha03aTraits.pdf\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://mail.python.org/pipermail/python-3000/2007-April/007026.html\"\u003ehttps://mail.python.org/pipermail/python-3000/2007-April/007026.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 3133 - Introducing Roles\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 14:33:16+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>