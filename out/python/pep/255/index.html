<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/edf391eeca43d999.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-ff7a2d518d7ddfe6.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1904<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 255 - Simple Generators</h1><div class="page__meta"><time dateTime="2025-09-26 17:35:06+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0255/">PEP 255 - Simple Generators</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 18-May-2001</p>
</blockquote>
<p>PEP 255 – 간단한 제너레이터 (Simple Generators)</p>
<h2>초록 (Abstract)</h2>
<p>이 PEP는 Python에 제너레이터(generators)의 개념과 함께 사용되는 새로운 문(statement)인 <code>yield</code> 문을 도입합니다.</p>
<h2>동기 (Motivation)</h2>
<p>생산자 함수(producer function)가 생성하는 값들 사이에 상태를 유지해야 하는 복잡한 작업을 수행할 때, 대부분의 프로그래밍 언어는 각 값이 생성될 때마다 호출되는 콜백 함수(callback function)를 생산자의 인자 목록에 추가하는 것 외에는 만족스럽고 효율적인 해결책을 제공하지 않습니다.</p>
<p>예를 들어, 표준 라이브러리의 <code>tokenize.py</code>는 이 방식을 사용합니다. 호출자는 <code>tokenize()</code>가 다음 토큰을 찾을 때마다 호출될 <code>token_eater</code> 함수를 <code>tokenize()</code>에 전달해야 합니다. 이 방식은 <code>tokenize</code> 코드를 자연스럽게 작성할 수 있게 하지만, <code>tokenize</code>를 호출하는 프로그램은 콜백 호출 사이에 어떤 토큰이 마지막으로 보였는지 기억해야 하므로 복잡해지는 경향이 있습니다. <code>tabnanny.py</code>의 <code>token_eater</code> 함수가 좋은 예인데, 이는 전역 변수에 상태 머신을 유지하여 콜백 간에 이전에 무엇을 보았고 다음에 무엇을 기대하는지 기억합니다. 이를 올바르게 작동하도록 만드는 것이 어려웠고, 사람들이 이해하기도 여전히 어렵습니다.</p>
<p>다른 대안으로는 <code>tokenize</code>가 Python 프로그램 전체를 한 번에 큰 리스트로 생성하는 방법이 있습니다. 이렇게 하면 <code>tokenize</code> 클라이언트 코드를 로컬 변수와 로컬 제어 흐름(예: 루프 및 중첩된 <code>if</code> 문)을 사용하여 상태를 추적하며 자연스럽게 작성할 수 있습니다. 그러나 이 방법은 현실적이지 않습니다. 프로그램은 매우 클 수 있으므로 전체 파싱 결과를 메모리에 올리는 데 필요한 메모리 양에 미리 제한을 둘 수 없고, 일부 <code>tokenize</code> 클라이언트는 프로그램 초기에 특정 내용이 나타나는지 여부만 확인하기를 원할 수 있기 때문입니다. 이 경우 전체 프로그램을 먼저 파싱하는 것은 심각한 시간 낭비입니다.</p>
<p>또 다른 대안은 <code>tokenize</code>를 이터레이터(iterator)로 만들어 <code>.next()</code> 메서드가 호출될 때마다 다음 토큰을 전달하는 것입니다. 이는 호출자에게는 결과의 큰 리스트와 동일한 방식으로 편리하지만, 메모리 및 "일찍 종료하고 싶다면?"과 같은 단점이 없습니다. 그러나 이 방식은 <code>tokenize</code>가 <code>.next()</code> 호출 사이에 상태를 기억하는 부담을 지게 하며, <code>tokenize.tokenize_loop()</code>를 살펴보면 이것이 얼마나 끔찍한 작업이 될지 쉽게 알 수 있습니다. 일반적인 트리 구조의 노드를 생성하기 위한 재귀 알고리즘을 이터레이터 프레임워크로 변환하려면 재귀를 수동으로 제거하고 순회 상태를 직접 관리해야 합니다.</p>
<p>네 번째 옵션은 생산자와 소비자를 별도의 스레드(threads)에서 실행하는 것입니다. 이를 통해 둘 다 자연스러운 방식으로 상태를 유지할 수 있으므로 양측 모두에게 편리합니다. 하지만 스레드가 없는 플랫폼에서는 작동하지 않으며, 스레드가 있는 플랫폼에서도 매우 느립니다.</p>
<p>마지막 옵션은 경량 코루틴(lightweight coroutines)을 지원하는 Stackless (PEP 219) 변형 Python 구현을 사용하는 것입니다. 이는 스레드 옵션과 유사한 프로그래밍적 이점을 제공하지만 훨씬 효율적입니다. 그러나 Stackless는 Python 코어에 대한 논쟁의 여지가 있는 재고(rethinking)이며, Jython이 동일한 의미론을 구현하는 것이 불가능할 수도 있습니다. 이 PEP는 해당 논쟁을 다룰 곳이 아니므로, 제너레이터가 현재 CPython 구현에 쉽게 통합될 수 있는 방식으로 Stackless 기능의 유용한 하위 집합을 제공하며, 다른 Python 구현에도 비교적 간단하게 적용될 수 있다고 말하는 것으로 충분합니다.</p>
<p>이것이 현재 대안들을 모두 설명한 것입니다. 다른 일부 고급 언어들은 만족스러운 해결책을 제공하는데, 특히 CLU의 이터레이터에서 영감을 받은 Sather의 이터레이터와 모든 표현식이 제너레이터인 독특한 언어인 Icon의 제너레이터가 있습니다. 이들 사이에는 차이점이 있지만, 기본적인 아이디어는 동일합니다. 즉, 호출자에게 중간 결과("다음 값")를 반환할 수 있지만, 함수의 로컬 상태를 유지하여 함수가 중단된 지점에서 다시 재개될 수 있는 일종의 함수를 제공하는 것입니다.</p>
<p>매우 간단한 예시:</p>
<pre><code class="language-python">def fib():
    a, b = 0, 1
    while 1:
        yield b
        a, b = b, a+b
</code></pre>
<p><code>fib()</code>가 처음 호출되면 <code>a</code>는 0으로, <code>b</code>는 1로 설정된 다음 <code>b</code>를 호출자에게 yield 합니다. 호출자는 1을 받습니다. <code>fib</code>가 재개되면, <code>fib</code>의 관점에서는 <code>yield</code> 문이 <code>print</code> 문과 거의 동일합니다. <code>fib</code>는 <code>yield</code> 이후에 모든 로컬 상태를 그대로 유지한 채 계속됩니다. <code>a</code>와 <code>b</code>는 1과 1이 되고, <code>fib</code>는 <code>yield</code>로 돌아가 호출자에게 1을 yield 합니다. 이런 식으로 계속됩니다. <code>fib</code>의 관점에서는 콜백을 통해 순서대로 결과를 전달하는 것과 같습니다. 그러나 호출자의 관점에서는 <code>fib</code> 호출이 원하는 대로 재개할 수 있는 이터러블(iterable) 객체입니다. 스레드 방식과 마찬가지로, 이 방식은 양측이 가장 자연스러운 방식으로 코드를 작성할 수 있게 합니다. 그러나 스레드 방식과 달리, 이 방식은 효율적으로 모든 플랫폼에서 수행될 수 있습니다. 실제로 제너레이터를 재개하는 것은 함수 호출보다 비용이 많이 들지 않아야 합니다.</p>
<p>동일한 접근 방식이 많은 생산자/소비자 함수에 적용됩니다. 예를 들어, <code>tokenize.py</code>는 콜백 함수를 인자로 호출하는 대신 다음 토큰을 yield 할 수 있으며, <code>tokenize</code> 클라이언트는 자연스러운 방식으로 토큰을 반복할 수 있습니다. Python 제너레이터는 일종의 Python 이터레이터이지만, 특히 강력한 종류입니다.</p>
<h2>명세: Yield (Specification: Yield)</h2>
<p>새로운 문이 도입됩니다.
<code>yield_stmt: "yield" expression_list</code></p>
<p><code>yield</code>는 새로운 키워드이므로, 초기 릴리스에서는 제너레이터를 사용하려는 모듈이 상단 근처에 <code>from __future__ import generators</code> 라인을 포함해야 합니다 (자세한 내용은 PEP 236 참조). <code>future</code> 문 없이 <code>yield</code> 식별자를 사용하는 모듈은 경고를 발생시킵니다. 다음 릴리스에서는 <code>yield</code>가 언어 키워드가 되고 <code>future</code> 문은 더 이상 필요하지 않습니다.</p>
<p><code>yield</code> 문은 함수 내부에서만 사용될 수 있습니다. <code>yield</code> 문을 포함하는 함수를 제너레이터 함수(generator function)라고 합니다. 제너레이터 함수는 모든 면에서 일반 함수 객체이지만, 코드 객체의 <code>co_flags</code> 멤버에 새로운 <code>CO_GENERATOR</code> 플래그가 설정됩니다.</p>
<p>제너레이터 함수가 호출될 때, 실제 인수는 일반적인 방식으로 함수-로컬(function-local) 형식 인자 이름에 바인딩되지만, 함수 본문의 코드는 실행되지 않습니다. 대신 제너레이터 이터레이터(generator-iterator) 객체가 반환됩니다. 이 객체는 이터레이터 프로토콜(iterator protocol)을 따르므로, 특히 <code>for</code> 루프에서 자연스럽게 사용될 수 있습니다. 의도가 문맥상 명확할 경우, "제너레이터(generator)"라는 이름은 제너레이터 함수 또는 제너레이터 이터레이터를 지칭하는 데 사용될 수 있습니다.</p>
<p>제너레이터 이터레이터의 <code>.next()</code> 메서드가 호출될 때마다, 제너레이터 함수의 본문 코드는 <code>yield</code> 또는 <code>return</code> 문(아래 참조)이 나올 때까지 또는 본문의 끝에 도달할 때까지 실행됩니다.</p>
<p><code>yield</code> 문이 나오면 함수의 상태는 "정지(frozen)"되고, <code>expression_list</code>의 값은 <code>.next()</code> 호출자에게 반환됩니다. "정지"라는 것은 현재 로컬 변수 바인딩, 명령어 포인터, 내부 평가 스택을 포함한 모든 로컬 상태가 유지된다는 것을 의미합니다. 충분한 정보가 저장되어 다음에 <code>.next()</code>가 호출될 때, 함수는 <code>yield</code> 문이 마치 또 다른 외부 호출이었던 것처럼 정확하게 진행할 수 있습니다.</p>
<p><strong>제한:</strong> <code>try/finally</code> 구성의 <code>try</code> 절에서는 <code>yield</code> 문이 허용되지 않습니다. 이는 제너레이터가 다시 재개될 것이라는 보장이 없으므로, <code>finally</code> 블록이 실행될 것이라는 보장도 없기 때문입니다. 이는 <code>finally</code>의 목적에 대한 너무 큰 위반입니다.</p>
<p><strong>제한:</strong> 제너레이터는 활성 상태로 실행 중일 때는 재개될 수 없습니다.</p>
<pre><code class="language-python">>>> def g():
... i = me.next()
... yield i
>>> me = g()
>>> me.next()
Traceback (most recent call last):
...
File "&#x3C;string>", line 2, in g
ValueError: generator already executing
</code></pre>
<h2>명세: Return (Specification: Return)</h2>
<p>제너레이터 함수는 다음과 같은 형태의 <code>return</code> 문을 포함할 수도 있습니다.
<code>return</code></p>
<p>제너레이터 본문 내의 <code>return</code> 문에서는 <code>expression_list</code>가 허용되지 않습니다 (물론, 제너레이터 내에 중첩된 비-제너레이터 함수의 본문에는 나타날 수 있습니다).</p>
<p><code>return</code> 문이 나오면, 모든 함수 반환과 마찬가지로 제어가 진행되며, 적절한 <code>finally</code> 절(있는 경우)을 실행합니다. 그런 다음 <code>StopIteration</code> 예외가 발생하여 이터레이터가 소진되었음을 알립니다. 명시적인 <code>return</code> 없이 제어 흐름이 제너레이터 끝에 도달하는 경우에도 <code>StopIteration</code> 예외가 발생합니다.</p>
<p><code>return</code>은 제너레이터 함수와 비-제너레이터 함수 모두에서 "나는 완료되었고, 반환할 흥미로운 것이 없다"는 의미를 가집니다.</p>
<p><code>return</code>이 항상 <code>StopIteration</code>을 발생하는 것과 동등하지는 않습니다. 차이점은 둘러싼 <code>try/except</code> 구성이 처리되는 방식에 있습니다. 예를 들어:</p>
<pre><code class="language-python">>>> def f1():
...     try:
...         return
...     except:
...         yield 1
>>> print(list(f1()))
[]
</code></pre>
<p>이는 어떤 함수에서와 마찬가지로 <code>return</code>이 단순히 종료하기 때문입니다. 하지만:</p>
<pre><code class="language-python">>>> def f2():
...     try:
...         raise StopIteration
...     except:
...         yield 42
>>> print(list(f2()))
[42]
</code></pre>
<p>이는 <code>StopIteration</code>이 다른 예외와 마찬가지로 bare <code>except</code>에 의해 포착되기 때문입니다.</p>
<h2>명세: 제너레이터와 예외 전파 (Specification: Generators and Exception Propagation)</h2>
<p><code>StopIteration</code>을 포함하되 이에 국한되지 않는, 처리되지 않은 예외가 제너레이터 함수에 의해 발생하거나 제너레이터 함수를 통과하는 경우, 예외는 일반적인 방식으로 호출자에게 전달되며, 이후 제너레이터 함수를 재개하려는 시도는 <code>StopIteration</code>을 발생시킵니다. 다시 말해, 처리되지 않은 예외는 제너레이터의 유효 수명을 종료시킵니다.</p>
<p>예시 (관용적이지 않지만 요점을 설명하기 위함):</p>
<pre><code class="language-python">>>> def f():
...     return 1/0
>>> def g():
...     yield f() # 0으로 나누기 예외가 전파됩니다.
...     yield 42  # 여기에 도달하지 못합니다.
>>> k = g()
>>> k.next()
Traceback (most recent call last):
File "&#x3C;stdin>", line 1, in ?
File "&#x3C;stdin>", line 2, in g
File "&#x3C;stdin>", line 2, in f
ZeroDivisionError: integer division or modulo by zero
>>> k.next() # 그리고 제너레이터는 재개될 수 없습니다.
Traceback (most recent call last):
File "&#x3C;stdin>", line 1, in ?
StopIteration
>>>
</code></pre>
<h2>명세: Try/Except/Finally (Specification: Try/Except/Finally)</h2>
<p>앞서 언급했듯이, <code>try/finally</code> 구성의 <code>try</code> 절에서는 <code>yield</code>가 허용되지 않습니다. 결과적으로 제너레이터는 중요한 리소스를 매우 신중하게 할당해야 합니다. 그 외에는 <code>finally</code> 절, <code>except</code> 절 또는 <code>try/except</code> 구성의 <code>try</code> 절에 <code>yield</code>가 나타나는 데 제한이 없습니다.</p>
<pre><code class="language-python">>>> def f():
...     try:
...         yield 1
...         try:
...             yield 2
...             1/0
...             yield 3 # 여기에 도달하지 못합니다.
...         except ZeroDivisionError:
...             yield 4
...             yield 5
...             raise
...         except:
...             yield 6
...             yield 7 # 위의 "raise"가 이것을 중단시킵니다.
...         except:
...             yield 8
...             yield 9
...         try:
...             x = 12
...         finally:
...             yield 10
...             yield 11
>>> print(list(f()))
[1, 2, 4, 5, 8, 9, 10, 11]
>>>
</code></pre>
<h2>예시 (Example)</h2>
<pre><code class="language-python"># 이진 트리 클래스.
class Tree:
    def __init__(self, label, left=None, right=None):
        self.label = label
        self.left = left
        self.right = right

    def __repr__(self, level=0, indent=" "):
        s = level*indent + repr(self.label) # `self.label` 대신 repr(self.label)로 변경
        if self.left:
            s = s + "\n" + self.left.__repr__(level+1, indent)
        if self.right:
            s = s + "\n" + self.right.__repr__(level+1, indent)
        return s

    def __iter__(self):
        return inorder(self)

# 리스트에서 트리를 생성합니다.
def tree(list_data): # list_data로 변수명 변경
    n = len(list_data)
    if n == 0:
        return None # 빈 리스트일 때 None 반환하도록 수정
    i = n // 2 # 정수 나눗셈으로 변경
    return Tree(list_data[i], tree(list_data[:i]), tree(list_data[i+1:]))

# 트리의 레이블을 중위 순서(in-order)로 생성하는 재귀 제너레이터.
def inorder(t):
    if t:
        for x in inorder(t.left):
            yield x
        yield t.label
        for x in inorder(t.right):
            yield x

# 시연: 트리를 생성합니다.
t = tree("ABCDEFGHIJKLMNOPQRSTUVWXYZ")

# 트리의 노드를 중위 순서로 출력합니다.
for x in t:
    print(x, end=' ') # print 문 수정
print()

# 비재귀 제너레이터.
def inorder_non_recursive(node): # 함수명 변경
    stack = []
    while node:
        while node.left:
            stack.append(node)
            node = node.left
        yield node.label
        while not node.right:
            try:
                node = stack.pop()
            except IndexError:
                return
            yield node.label
        node = node.right

# 비재귀 제너레이터를 실행합니다.
for x in inorder_non_recursive(t): # 함수명 변경
    print(x, end=' ') # print 문 수정
print()
</code></pre>
<p>두 출력 블록 모두 다음을 표시합니다.
<code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</code></p>
<h2>Q &#x26; A</h2>
<h3>왜 <code>def</code>를 재사용하는 대신 새로운 키워드를 사용하지 않았는가?</h3>
<p>BDFL Pronouncements 섹션을 참조하십시오.</p>
<h3>왜 <code>yield</code>에 새로운 키워드를 사용하는가? 빌트인 함수 대신에는 안 되는가?</h3>
<p>파이썬에서 제어 흐름은 키워드를 통해 훨씬 잘 표현되며, <code>yield</code>는 제어 구조입니다. 또한 Jython에서 효율적인 구현을 위해서는 컴파일러가 컴파일 시간에 잠재적 중단점(suspension points)을 결정할 수 있어야 한다고 여겨지며, 새로운 키워드는 이를 쉽게 만듭니다. CPython 참조 구현 또한 이를 활용하여 어떤 함수가 제너레이터 함수인지 감지합니다.</p>
<h3>그러면 새로운 키워드 없이 다른 특별한 구문은 안 되는가?</h3>
<p>예를 들어, <code>yield 3</code> 대신 다음과 같은 것들을 생각해 볼 수 있습니다.</p>
<ul>
<li><code>return 3 and continue</code></li>
<li><code>return and continue 3</code></li>
<li><code>return generating 3</code></li>
<li><code>continue return 3</code></li>
<li><code>return >> , 3 from generator</code></li>
<li><code>return >> 3</code></li>
<li><code>return &#x3C;&#x3C; 3</code></li>
<li><code>>> 3</code></li>
<li><code>&#x3C;&#x3C; 3 * 3</code></li>
</ul>
<p>수백 개의 메시지 중 세 가지만 이러한 대안을 제시했으며, 위 내용은 그중에서 발췌한 것입니다. 새로운 키워드가 필요 없는 것이 좋겠지만, <code>yield</code>를 매우 명확하게 만드는 것이 더 좋습니다. <code>yield</code>가 발생하는 것을 이전에는 의미 없던 키워드나 연산자의 시퀀스를 해석하여 추론하고 싶지 않습니다. 그래도 이것이 충분한 관심을 끈다면, 제안자들은 단일 합의 제안에 합의해야 하며, 귀도(Guido)가 그것에 대해 "선언(Pronounce)"할 것입니다.</p>
<h3>왜 <code>return</code>을 아예 허용하는가? 왜 <code>raise StopIteration</code>으로 종료를 강제하지 않는가?</h3>
<p><code>StopIteration</code>의 메커니즘은 Python 2.1의 <code>IndexError</code> 메커니즘과 같이 저수준 세부 사항입니다. 구현은 내부적으로 잘 정의된 작업을 수행해야 하며, Python은 고급 사용자를 위해 이러한 메커니즘을 노출합니다. 그러나 이것이 모든 사람에게 그 수준에서 작업하도록 강제해야 한다는 주장은 아닙니다. <code>return</code>은 어떤 종류의 함수에서든 "나는 완료되었다"를 의미하며, 이는 설명하고 사용하기 쉽습니다. 또한, <code>return</code>이 <code>try/except</code> 구성에서 <code>raise StopIteration</code>과 항상 동등하지는 않습니다 ( "명세: Return" 섹션 참조).</p>
<h3>그러면 <code>return</code>에도 표현식을 허용하지 않는가?</h3>
<p>어쩌면 언젠가는 허용할 수도 있습니다. Icon에서는 <code>return expr</code>이 "나는 완료되었다"와 "하지만 반환할 최종적으로 유용한 값도 있고, 그것이 이것이다"라는 두 가지를 의미합니다. 초기 단계에서는 <code>return expr</code>에 대한 설득력 있는 사용 사례가 없으므로, 값을 전달하는 데 <code>yield</code>만 사용하는 것이 더 깔끔합니다.</p>
<h2>BDFL 선언 (BDFL Pronouncements)</h2>
<p><strong>쟁점:</strong> <code>def</code> 대신 <code>gen</code> 또는 <code>generator</code>와 같은 다른 새로운 키워드를 도입하거나 구문을 변경하여 제너레이터 함수를 비-제너레이터 함수와 구분해야 하는가.</p>
<p><strong>반대 (Con):</strong> 실제로 (생각하는 방식에 따라), 제너레이터는 함수이지만, 재개 가능하다는 특징을 가집니다. 그것들이 어떻게 설정되는지에 대한 메커니즘은 비교적 사소한 기술적 문제이며, 새로운 키워드를 도입하는 것은 제너레이터가 시작되는 메커니즘(제너레이터 수명의 중요하지만 작은 부분)을 불필요하게 과도하게 강조할 것입니다.</p>
<p><strong>찬성 (Pro):</strong> 현실적으로 (생각하는 방식에 따라), 제너레이터 함수는 마법처럼 제너레이터 이터레이터를 생성하는 팩토리 함수(factory functions)입니다. 이런 점에서 그것들은 비-제너레이터 함수와 근본적으로 다르며, 함수라기보다는 생성자처럼 작동하므로 <code>def</code>를 재사용하는 것은 기껏해야 혼란스럽습니다. 본문 내부에 숨겨진 <code>yield</code> 문만으로는 의미론이 그렇게 다르다는 것을 충분히 경고하지 못합니다.</p>
<p><strong>BDFL (Guido van Rossum):</strong> <code>def</code>는 그대로 유지됩니다. 양측의 주장이 완전히 설득력 있는 것은 아니어서, 언어 설계자로서의 제 직관에 따라 결정했습니다. 제 직관은 이 PEP에서 제안된 구문이 정확히 맞다는 것을 알려줍니다. 너무 뜨겁지도, 너무 차갑지도 않습니다. 그러나 그리스 신화의 델피 신탁처럼, 왜 그런지는 알려주지 않으므로, PEP 구문에 반대하는 주장에 대한 반박은 없습니다. 제가 내놓을 수 있는 최선은 "FUD"(Fear, Uncertainty, Doubt - 공포, 불확실성, 의심)입니다. 만약 이것이 언어의 첫날부터 존재했다면, 앤드루 쿠클링(Andrew Kuchling)의 "Python Warts" 페이지에 실렸을 것이라고는 거의 의심하지 않습니다.</p>
<h2>참조 구현 (Reference Implementation)</h2>
<p>현재 구현은 예비 상태이지만 (문서는 없지만 잘 테스트되고 견고함), Python의 CVS 개발 트리의 일부입니다. 이를 사용하려면 소스에서 Python을 빌드해야 합니다. 이는 Neil Schemenauer의 이전 패치에서 파생되었습니다.</p>
<h2>각주 및 참고 자료 (Footnotes and References)</h2>
<p>https://www.stackless.com/
"Iteration Abstraction in Sather" Murer, Omohundro, Stoutamire and Szyperski http://www.icsi.berkeley.edu/~sather/Publications/toplas.html
http://www.cs.arizona.edu/icon/
http://python.ca/nas/python/generator.diff
이 구현을 실험하려면 http://sf.net/cvs/?group_id=5470 지침에 따라 CVS에서 Python을 체크아웃하십시오. 표준 테스트 <code>Lib/test/test_generators.py</code>에는 이 PEP의 모든 예제를 포함한 많은 예제가 있습니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/254/">[Rejected] PEP 254 - Making Classes Look More Like Types</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 255 - Simple Generators</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/256/">[Rejected] PEP 256 - Docstring Processing System Framework</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/edf391eeca43d999.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-ff7a2d518d7ddfe6.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/255\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/edf391eeca43d999.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"-P2_WUhcrV_SjEEzYp4Tq\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/255/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/255\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"255\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/255\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T5c91,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0255/\"\u003ePEP 255 - Simple Generators\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 18-May-2001\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 255 – 간단한 제너레이터 (Simple Generators)\u003c/p\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 Python에 제너레이터(generators)의 개념과 함께 사용되는 새로운 문(statement)인 \u003ccode\u003eyield\u003c/code\u003e 문을 도입합니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e생산자 함수(producer function)가 생성하는 값들 사이에 상태를 유지해야 하는 복잡한 작업을 수행할 때, 대부분의 프로그래밍 언어는 각 값이 생성될 때마다 호출되는 콜백 함수(callback function)를 생산자의 인자 목록에 추가하는 것 외에는 만족스럽고 효율적인 해결책을 제공하지 않습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 표준 라이브러리의 \u003ccode\u003etokenize.py\u003c/code\u003e는 이 방식을 사용합니다. 호출자는 \u003ccode\u003etokenize()\u003c/code\u003e가 다음 토큰을 찾을 때마다 호출될 \u003ccode\u003etoken_eater\u003c/code\u003e 함수를 \u003ccode\u003etokenize()\u003c/code\u003e에 전달해야 합니다. 이 방식은 \u003ccode\u003etokenize\u003c/code\u003e 코드를 자연스럽게 작성할 수 있게 하지만, \u003ccode\u003etokenize\u003c/code\u003e를 호출하는 프로그램은 콜백 호출 사이에 어떤 토큰이 마지막으로 보였는지 기억해야 하므로 복잡해지는 경향이 있습니다. \u003ccode\u003etabnanny.py\u003c/code\u003e의 \u003ccode\u003etoken_eater\u003c/code\u003e 함수가 좋은 예인데, 이는 전역 변수에 상태 머신을 유지하여 콜백 간에 이전에 무엇을 보았고 다음에 무엇을 기대하는지 기억합니다. 이를 올바르게 작동하도록 만드는 것이 어려웠고, 사람들이 이해하기도 여전히 어렵습니다.\u003c/p\u003e\n\u003cp\u003e다른 대안으로는 \u003ccode\u003etokenize\u003c/code\u003e가 Python 프로그램 전체를 한 번에 큰 리스트로 생성하는 방법이 있습니다. 이렇게 하면 \u003ccode\u003etokenize\u003c/code\u003e 클라이언트 코드를 로컬 변수와 로컬 제어 흐름(예: 루프 및 중첩된 \u003ccode\u003eif\u003c/code\u003e 문)을 사용하여 상태를 추적하며 자연스럽게 작성할 수 있습니다. 그러나 이 방법은 현실적이지 않습니다. 프로그램은 매우 클 수 있으므로 전체 파싱 결과를 메모리에 올리는 데 필요한 메모리 양에 미리 제한을 둘 수 없고, 일부 \u003ccode\u003etokenize\u003c/code\u003e 클라이언트는 프로그램 초기에 특정 내용이 나타나는지 여부만 확인하기를 원할 수 있기 때문입니다. 이 경우 전체 프로그램을 먼저 파싱하는 것은 심각한 시간 낭비입니다.\u003c/p\u003e\n\u003cp\u003e또 다른 대안은 \u003ccode\u003etokenize\u003c/code\u003e를 이터레이터(iterator)로 만들어 \u003ccode\u003e.next()\u003c/code\u003e 메서드가 호출될 때마다 다음 토큰을 전달하는 것입니다. 이는 호출자에게는 결과의 큰 리스트와 동일한 방식으로 편리하지만, 메모리 및 \"일찍 종료하고 싶다면?\"과 같은 단점이 없습니다. 그러나 이 방식은 \u003ccode\u003etokenize\u003c/code\u003e가 \u003ccode\u003e.next()\u003c/code\u003e 호출 사이에 상태를 기억하는 부담을 지게 하며, \u003ccode\u003etokenize.tokenize_loop()\u003c/code\u003e를 살펴보면 이것이 얼마나 끔찍한 작업이 될지 쉽게 알 수 있습니다. 일반적인 트리 구조의 노드를 생성하기 위한 재귀 알고리즘을 이터레이터 프레임워크로 변환하려면 재귀를 수동으로 제거하고 순회 상태를 직접 관리해야 합니다.\u003c/p\u003e\n\u003cp\u003e네 번째 옵션은 생산자와 소비자를 별도의 스레드(threads)에서 실행하는 것입니다. 이를 통해 둘 다 자연스러운 방식으로 상태를 유지할 수 있으므로 양측 모두에게 편리합니다. 하지만 스레드가 없는 플랫폼에서는 작동하지 않으며, 스레드가 있는 플랫폼에서도 매우 느립니다.\u003c/p\u003e\n\u003cp\u003e마지막 옵션은 경량 코루틴(lightweight coroutines)을 지원하는 Stackless (PEP 219) 변형 Python 구현을 사용하는 것입니다. 이는 스레드 옵션과 유사한 프로그래밍적 이점을 제공하지만 훨씬 효율적입니다. 그러나 Stackless는 Python 코어에 대한 논쟁의 여지가 있는 재고(rethinking)이며, Jython이 동일한 의미론을 구현하는 것이 불가능할 수도 있습니다. 이 PEP는 해당 논쟁을 다룰 곳이 아니므로, 제너레이터가 현재 CPython 구현에 쉽게 통합될 수 있는 방식으로 Stackless 기능의 유용한 하위 집합을 제공하며, 다른 Python 구현에도 비교적 간단하게 적용될 수 있다고 말하는 것으로 충분합니다.\u003c/p\u003e\n\u003cp\u003e이것이 현재 대안들을 모두 설명한 것입니다. 다른 일부 고급 언어들은 만족스러운 해결책을 제공하는데, 특히 CLU의 이터레이터에서 영감을 받은 Sather의 이터레이터와 모든 표현식이 제너레이터인 독특한 언어인 Icon의 제너레이터가 있습니다. 이들 사이에는 차이점이 있지만, 기본적인 아이디어는 동일합니다. 즉, 호출자에게 중간 결과(\"다음 값\")를 반환할 수 있지만, 함수의 로컬 상태를 유지하여 함수가 중단된 지점에서 다시 재개될 수 있는 일종의 함수를 제공하는 것입니다.\u003c/p\u003e\n\u003cp\u003e매우 간단한 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef fib():\n    a, b = 0, 1\n    while 1:\n        yield b\n        a, b = b, a+b\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efib()\u003c/code\u003e가 처음 호출되면 \u003ccode\u003ea\u003c/code\u003e는 0으로, \u003ccode\u003eb\u003c/code\u003e는 1로 설정된 다음 \u003ccode\u003eb\u003c/code\u003e를 호출자에게 yield 합니다. 호출자는 1을 받습니다. \u003ccode\u003efib\u003c/code\u003e가 재개되면, \u003ccode\u003efib\u003c/code\u003e의 관점에서는 \u003ccode\u003eyield\u003c/code\u003e 문이 \u003ccode\u003eprint\u003c/code\u003e 문과 거의 동일합니다. \u003ccode\u003efib\u003c/code\u003e는 \u003ccode\u003eyield\u003c/code\u003e 이후에 모든 로컬 상태를 그대로 유지한 채 계속됩니다. \u003ccode\u003ea\u003c/code\u003e와 \u003ccode\u003eb\u003c/code\u003e는 1과 1이 되고, \u003ccode\u003efib\u003c/code\u003e는 \u003ccode\u003eyield\u003c/code\u003e로 돌아가 호출자에게 1을 yield 합니다. 이런 식으로 계속됩니다. \u003ccode\u003efib\u003c/code\u003e의 관점에서는 콜백을 통해 순서대로 결과를 전달하는 것과 같습니다. 그러나 호출자의 관점에서는 \u003ccode\u003efib\u003c/code\u003e 호출이 원하는 대로 재개할 수 있는 이터러블(iterable) 객체입니다. 스레드 방식과 마찬가지로, 이 방식은 양측이 가장 자연스러운 방식으로 코드를 작성할 수 있게 합니다. 그러나 스레드 방식과 달리, 이 방식은 효율적으로 모든 플랫폼에서 수행될 수 있습니다. 실제로 제너레이터를 재개하는 것은 함수 호출보다 비용이 많이 들지 않아야 합니다.\u003c/p\u003e\n\u003cp\u003e동일한 접근 방식이 많은 생산자/소비자 함수에 적용됩니다. 예를 들어, \u003ccode\u003etokenize.py\u003c/code\u003e는 콜백 함수를 인자로 호출하는 대신 다음 토큰을 yield 할 수 있으며, \u003ccode\u003etokenize\u003c/code\u003e 클라이언트는 자연스러운 방식으로 토큰을 반복할 수 있습니다. Python 제너레이터는 일종의 Python 이터레이터이지만, 특히 강력한 종류입니다.\u003c/p\u003e\n\u003ch2\u003e명세: Yield (Specification: Yield)\u003c/h2\u003e\n\u003cp\u003e새로운 문이 도입됩니다.\n\u003ccode\u003eyield_stmt: \"yield\" expression_list\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eyield\u003c/code\u003e는 새로운 키워드이므로, 초기 릴리스에서는 제너레이터를 사용하려는 모듈이 상단 근처에 \u003ccode\u003efrom __future__ import generators\u003c/code\u003e 라인을 포함해야 합니다 (자세한 내용은 PEP 236 참조). \u003ccode\u003efuture\u003c/code\u003e 문 없이 \u003ccode\u003eyield\u003c/code\u003e 식별자를 사용하는 모듈은 경고를 발생시킵니다. 다음 릴리스에서는 \u003ccode\u003eyield\u003c/code\u003e가 언어 키워드가 되고 \u003ccode\u003efuture\u003c/code\u003e 문은 더 이상 필요하지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eyield\u003c/code\u003e 문은 함수 내부에서만 사용될 수 있습니다. \u003ccode\u003eyield\u003c/code\u003e 문을 포함하는 함수를 제너레이터 함수(generator function)라고 합니다. 제너레이터 함수는 모든 면에서 일반 함수 객체이지만, 코드 객체의 \u003ccode\u003eco_flags\u003c/code\u003e 멤버에 새로운 \u003ccode\u003eCO_GENERATOR\u003c/code\u003e 플래그가 설정됩니다.\u003c/p\u003e\n\u003cp\u003e제너레이터 함수가 호출될 때, 실제 인수는 일반적인 방식으로 함수-로컬(function-local) 형식 인자 이름에 바인딩되지만, 함수 본문의 코드는 실행되지 않습니다. 대신 제너레이터 이터레이터(generator-iterator) 객체가 반환됩니다. 이 객체는 이터레이터 프로토콜(iterator protocol)을 따르므로, 특히 \u003ccode\u003efor\u003c/code\u003e 루프에서 자연스럽게 사용될 수 있습니다. 의도가 문맥상 명확할 경우, \"제너레이터(generator)\"라는 이름은 제너레이터 함수 또는 제너레이터 이터레이터를 지칭하는 데 사용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e제너레이터 이터레이터의 \u003ccode\u003e.next()\u003c/code\u003e 메서드가 호출될 때마다, 제너레이터 함수의 본문 코드는 \u003ccode\u003eyield\u003c/code\u003e 또는 \u003ccode\u003ereturn\u003c/code\u003e 문(아래 참조)이 나올 때까지 또는 본문의 끝에 도달할 때까지 실행됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eyield\u003c/code\u003e 문이 나오면 함수의 상태는 \"정지(frozen)\"되고, \u003ccode\u003eexpression_list\u003c/code\u003e의 값은 \u003ccode\u003e.next()\u003c/code\u003e 호출자에게 반환됩니다. \"정지\"라는 것은 현재 로컬 변수 바인딩, 명령어 포인터, 내부 평가 스택을 포함한 모든 로컬 상태가 유지된다는 것을 의미합니다. 충분한 정보가 저장되어 다음에 \u003ccode\u003e.next()\u003c/code\u003e가 호출될 때, 함수는 \u003ccode\u003eyield\u003c/code\u003e 문이 마치 또 다른 외부 호출이었던 것처럼 정확하게 진행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e제한:\u003c/strong\u003e \u003ccode\u003etry/finally\u003c/code\u003e 구성의 \u003ccode\u003etry\u003c/code\u003e 절에서는 \u003ccode\u003eyield\u003c/code\u003e 문이 허용되지 않습니다. 이는 제너레이터가 다시 재개될 것이라는 보장이 없으므로, \u003ccode\u003efinally\u003c/code\u003e 블록이 실행될 것이라는 보장도 없기 때문입니다. 이는 \u003ccode\u003efinally\u003c/code\u003e의 목적에 대한 너무 큰 위반입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e제한:\u003c/strong\u003e 제너레이터는 활성 상태로 실행 중일 때는 재개될 수 없습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e def g():\n... i = me.next()\n... yield i\n\u003e\u003e\u003e me = g()\n\u003e\u003e\u003e me.next()\nTraceback (most recent call last):\n...\nFile \"\u0026#x3C;string\u003e\", line 2, in g\nValueError: generator already executing\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e명세: Return (Specification: Return)\u003c/h2\u003e\n\u003cp\u003e제너레이터 함수는 다음과 같은 형태의 \u003ccode\u003ereturn\u003c/code\u003e 문을 포함할 수도 있습니다.\n\u003ccode\u003ereturn\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e제너레이터 본문 내의 \u003ccode\u003ereturn\u003c/code\u003e 문에서는 \u003ccode\u003eexpression_list\u003c/code\u003e가 허용되지 않습니다 (물론, 제너레이터 내에 중첩된 비-제너레이터 함수의 본문에는 나타날 수 있습니다).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereturn\u003c/code\u003e 문이 나오면, 모든 함수 반환과 마찬가지로 제어가 진행되며, 적절한 \u003ccode\u003efinally\u003c/code\u003e 절(있는 경우)을 실행합니다. 그런 다음 \u003ccode\u003eStopIteration\u003c/code\u003e 예외가 발생하여 이터레이터가 소진되었음을 알립니다. 명시적인 \u003ccode\u003ereturn\u003c/code\u003e 없이 제어 흐름이 제너레이터 끝에 도달하는 경우에도 \u003ccode\u003eStopIteration\u003c/code\u003e 예외가 발생합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereturn\u003c/code\u003e은 제너레이터 함수와 비-제너레이터 함수 모두에서 \"나는 완료되었고, 반환할 흥미로운 것이 없다\"는 의미를 가집니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereturn\u003c/code\u003e이 항상 \u003ccode\u003eStopIteration\u003c/code\u003e을 발생하는 것과 동등하지는 않습니다. 차이점은 둘러싼 \u003ccode\u003etry/except\u003c/code\u003e 구성이 처리되는 방식에 있습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e def f1():\n...     try:\n...         return\n...     except:\n...         yield 1\n\u003e\u003e\u003e print(list(f1()))\n[]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 어떤 함수에서와 마찬가지로 \u003ccode\u003ereturn\u003c/code\u003e이 단순히 종료하기 때문입니다. 하지만:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e def f2():\n...     try:\n...         raise StopIteration\n...     except:\n...         yield 42\n\u003e\u003e\u003e print(list(f2()))\n[42]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 \u003ccode\u003eStopIteration\u003c/code\u003e이 다른 예외와 마찬가지로 bare \u003ccode\u003eexcept\u003c/code\u003e에 의해 포착되기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e명세: 제너레이터와 예외 전파 (Specification: Generators and Exception Propagation)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eStopIteration\u003c/code\u003e을 포함하되 이에 국한되지 않는, 처리되지 않은 예외가 제너레이터 함수에 의해 발생하거나 제너레이터 함수를 통과하는 경우, 예외는 일반적인 방식으로 호출자에게 전달되며, 이후 제너레이터 함수를 재개하려는 시도는 \u003ccode\u003eStopIteration\u003c/code\u003e을 발생시킵니다. 다시 말해, 처리되지 않은 예외는 제너레이터의 유효 수명을 종료시킵니다.\u003c/p\u003e\n\u003cp\u003e예시 (관용적이지 않지만 요점을 설명하기 위함):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e def f():\n...     return 1/0\n\u003e\u003e\u003e def g():\n...     yield f() # 0으로 나누기 예외가 전파됩니다.\n...     yield 42  # 여기에 도달하지 못합니다.\n\u003e\u003e\u003e k = g()\n\u003e\u003e\u003e k.next()\nTraceback (most recent call last):\nFile \"\u0026#x3C;stdin\u003e\", line 1, in ?\nFile \"\u0026#x3C;stdin\u003e\", line 2, in g\nFile \"\u0026#x3C;stdin\u003e\", line 2, in f\nZeroDivisionError: integer division or modulo by zero\n\u003e\u003e\u003e k.next() # 그리고 제너레이터는 재개될 수 없습니다.\nTraceback (most recent call last):\nFile \"\u0026#x3C;stdin\u003e\", line 1, in ?\nStopIteration\n\u003e\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e명세: Try/Except/Finally (Specification: Try/Except/Finally)\u003c/h2\u003e\n\u003cp\u003e앞서 언급했듯이, \u003ccode\u003etry/finally\u003c/code\u003e 구성의 \u003ccode\u003etry\u003c/code\u003e 절에서는 \u003ccode\u003eyield\u003c/code\u003e가 허용되지 않습니다. 결과적으로 제너레이터는 중요한 리소스를 매우 신중하게 할당해야 합니다. 그 외에는 \u003ccode\u003efinally\u003c/code\u003e 절, \u003ccode\u003eexcept\u003c/code\u003e 절 또는 \u003ccode\u003etry/except\u003c/code\u003e 구성의 \u003ccode\u003etry\u003c/code\u003e 절에 \u003ccode\u003eyield\u003c/code\u003e가 나타나는 데 제한이 없습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e def f():\n...     try:\n...         yield 1\n...         try:\n...             yield 2\n...             1/0\n...             yield 3 # 여기에 도달하지 못합니다.\n...         except ZeroDivisionError:\n...             yield 4\n...             yield 5\n...             raise\n...         except:\n...             yield 6\n...             yield 7 # 위의 \"raise\"가 이것을 중단시킵니다.\n...         except:\n...             yield 8\n...             yield 9\n...         try:\n...             x = 12\n...         finally:\n...             yield 10\n...             yield 11\n\u003e\u003e\u003e print(list(f()))\n[1, 2, 4, 5, 8, 9, 10, 11]\n\u003e\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e예시 (Example)\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 이진 트리 클래스.\nclass Tree:\n    def __init__(self, label, left=None, right=None):\n        self.label = label\n        self.left = left\n        self.right = right\n\n    def __repr__(self, level=0, indent=\" \"):\n        s = level*indent + repr(self.label) # `self.label` 대신 repr(self.label)로 변경\n        if self.left:\n            s = s + \"\\n\" + self.left.__repr__(level+1, indent)\n        if self.right:\n            s = s + \"\\n\" + self.right.__repr__(level+1, indent)\n        return s\n\n    def __iter__(self):\n        return inorder(self)\n\n# 리스트에서 트리를 생성합니다.\ndef tree(list_data): # list_data로 변수명 변경\n    n = len(list_data)\n    if n == 0:\n        return None # 빈 리스트일 때 None 반환하도록 수정\n    i = n // 2 # 정수 나눗셈으로 변경\n    return Tree(list_data[i], tree(list_data[:i]), tree(list_data[i+1:]))\n\n# 트리의 레이블을 중위 순서(in-order)로 생성하는 재귀 제너레이터.\ndef inorder(t):\n    if t:\n        for x in inorder(t.left):\n            yield x\n        yield t.label\n        for x in inorder(t.right):\n            yield x\n\n# 시연: 트리를 생성합니다.\nt = tree(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\n# 트리의 노드를 중위 순서로 출력합니다.\nfor x in t:\n    print(x, end=' ') # print 문 수정\nprint()\n\n# 비재귀 제너레이터.\ndef inorder_non_recursive(node): # 함수명 변경\n    stack = []\n    while node:\n        while node.left:\n            stack.append(node)\n            node = node.left\n        yield node.label\n        while not node.right:\n            try:\n                node = stack.pop()\n            except IndexError:\n                return\n            yield node.label\n        node = node.right\n\n# 비재귀 제너레이터를 실행합니다.\nfor x in inorder_non_recursive(t): # 함수명 변경\n    print(x, end=' ') # print 문 수정\nprint()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 출력 블록 모두 다음을 표시합니다.\n\u003ccode\u003eA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003eQ \u0026#x26; A\u003c/h2\u003e\n\u003ch3\u003e왜 \u003ccode\u003edef\u003c/code\u003e를 재사용하는 대신 새로운 키워드를 사용하지 않았는가?\u003c/h3\u003e\n\u003cp\u003eBDFL Pronouncements 섹션을 참조하십시오.\u003c/p\u003e\n\u003ch3\u003e왜 \u003ccode\u003eyield\u003c/code\u003e에 새로운 키워드를 사용하는가? 빌트인 함수 대신에는 안 되는가?\u003c/h3\u003e\n\u003cp\u003e파이썬에서 제어 흐름은 키워드를 통해 훨씬 잘 표현되며, \u003ccode\u003eyield\u003c/code\u003e는 제어 구조입니다. 또한 Jython에서 효율적인 구현을 위해서는 컴파일러가 컴파일 시간에 잠재적 중단점(suspension points)을 결정할 수 있어야 한다고 여겨지며, 새로운 키워드는 이를 쉽게 만듭니다. CPython 참조 구현 또한 이를 활용하여 어떤 함수가 제너레이터 함수인지 감지합니다.\u003c/p\u003e\n\u003ch3\u003e그러면 새로운 키워드 없이 다른 특별한 구문은 안 되는가?\u003c/h3\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003eyield 3\u003c/code\u003e 대신 다음과 같은 것들을 생각해 볼 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ereturn 3 and continue\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereturn and continue 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereturn generating 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtinue return 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereturn \u003e\u003e , 3 from generator\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereturn \u003e\u003e 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereturn \u0026#x3C;\u0026#x3C; 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u003e\u003e 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;\u0026#x3C; 3 * 3\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e수백 개의 메시지 중 세 가지만 이러한 대안을 제시했으며, 위 내용은 그중에서 발췌한 것입니다. 새로운 키워드가 필요 없는 것이 좋겠지만, \u003ccode\u003eyield\u003c/code\u003e를 매우 명확하게 만드는 것이 더 좋습니다. \u003ccode\u003eyield\u003c/code\u003e가 발생하는 것을 이전에는 의미 없던 키워드나 연산자의 시퀀스를 해석하여 추론하고 싶지 않습니다. 그래도 이것이 충분한 관심을 끈다면, 제안자들은 단일 합의 제안에 합의해야 하며, 귀도(Guido)가 그것에 대해 \"선언(Pronounce)\"할 것입니다.\u003c/p\u003e\n\u003ch3\u003e왜 \u003ccode\u003ereturn\u003c/code\u003e을 아예 허용하는가? 왜 \u003ccode\u003eraise StopIteration\u003c/code\u003e으로 종료를 강제하지 않는가?\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eStopIteration\u003c/code\u003e의 메커니즘은 Python 2.1의 \u003ccode\u003eIndexError\u003c/code\u003e 메커니즘과 같이 저수준 세부 사항입니다. 구현은 내부적으로 잘 정의된 작업을 수행해야 하며, Python은 고급 사용자를 위해 이러한 메커니즘을 노출합니다. 그러나 이것이 모든 사람에게 그 수준에서 작업하도록 강제해야 한다는 주장은 아닙니다. \u003ccode\u003ereturn\u003c/code\u003e은 어떤 종류의 함수에서든 \"나는 완료되었다\"를 의미하며, 이는 설명하고 사용하기 쉽습니다. 또한, \u003ccode\u003ereturn\u003c/code\u003e이 \u003ccode\u003etry/except\u003c/code\u003e 구성에서 \u003ccode\u003eraise StopIteration\u003c/code\u003e과 항상 동등하지는 않습니다 ( \"명세: Return\" 섹션 참조).\u003c/p\u003e\n\u003ch3\u003e그러면 \u003ccode\u003ereturn\u003c/code\u003e에도 표현식을 허용하지 않는가?\u003c/h3\u003e\n\u003cp\u003e어쩌면 언젠가는 허용할 수도 있습니다. Icon에서는 \u003ccode\u003ereturn expr\u003c/code\u003e이 \"나는 완료되었다\"와 \"하지만 반환할 최종적으로 유용한 값도 있고, 그것이 이것이다\"라는 두 가지를 의미합니다. 초기 단계에서는 \u003ccode\u003ereturn expr\u003c/code\u003e에 대한 설득력 있는 사용 사례가 없으므로, 값을 전달하는 데 \u003ccode\u003eyield\u003c/code\u003e만 사용하는 것이 더 깔끔합니다.\u003c/p\u003e\n\u003ch2\u003eBDFL 선언 (BDFL Pronouncements)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e쟁점:\u003c/strong\u003e \u003ccode\u003edef\u003c/code\u003e 대신 \u003ccode\u003egen\u003c/code\u003e 또는 \u003ccode\u003egenerator\u003c/code\u003e와 같은 다른 새로운 키워드를 도입하거나 구문을 변경하여 제너레이터 함수를 비-제너레이터 함수와 구분해야 하는가.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e반대 (Con):\u003c/strong\u003e 실제로 (생각하는 방식에 따라), 제너레이터는 함수이지만, 재개 가능하다는 특징을 가집니다. 그것들이 어떻게 설정되는지에 대한 메커니즘은 비교적 사소한 기술적 문제이며, 새로운 키워드를 도입하는 것은 제너레이터가 시작되는 메커니즘(제너레이터 수명의 중요하지만 작은 부분)을 불필요하게 과도하게 강조할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e찬성 (Pro):\u003c/strong\u003e 현실적으로 (생각하는 방식에 따라), 제너레이터 함수는 마법처럼 제너레이터 이터레이터를 생성하는 팩토리 함수(factory functions)입니다. 이런 점에서 그것들은 비-제너레이터 함수와 근본적으로 다르며, 함수라기보다는 생성자처럼 작동하므로 \u003ccode\u003edef\u003c/code\u003e를 재사용하는 것은 기껏해야 혼란스럽습니다. 본문 내부에 숨겨진 \u003ccode\u003eyield\u003c/code\u003e 문만으로는 의미론이 그렇게 다르다는 것을 충분히 경고하지 못합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBDFL (Guido van Rossum):\u003c/strong\u003e \u003ccode\u003edef\u003c/code\u003e는 그대로 유지됩니다. 양측의 주장이 완전히 설득력 있는 것은 아니어서, 언어 설계자로서의 제 직관에 따라 결정했습니다. 제 직관은 이 PEP에서 제안된 구문이 정확히 맞다는 것을 알려줍니다. 너무 뜨겁지도, 너무 차갑지도 않습니다. 그러나 그리스 신화의 델피 신탁처럼, 왜 그런지는 알려주지 않으므로, PEP 구문에 반대하는 주장에 대한 반박은 없습니다. 제가 내놓을 수 있는 최선은 \"FUD\"(Fear, Uncertainty, Doubt - 공포, 불확실성, 의심)입니다. 만약 이것이 언어의 첫날부터 존재했다면, 앤드루 쿠클링(Andrew Kuchling)의 \"Python Warts\" 페이지에 실렸을 것이라고는 거의 의심하지 않습니다.\u003c/p\u003e\n\u003ch2\u003e참조 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003e현재 구현은 예비 상태이지만 (문서는 없지만 잘 테스트되고 견고함), Python의 CVS 개발 트리의 일부입니다. 이를 사용하려면 소스에서 Python을 빌드해야 합니다. 이는 Neil Schemenauer의 이전 패치에서 파생되었습니다.\u003c/p\u003e\n\u003ch2\u003e각주 및 참고 자료 (Footnotes and References)\u003c/h2\u003e\n\u003cp\u003ehttps://www.stackless.com/\n\"Iteration Abstraction in Sather\" Murer, Omohundro, Stoutamire and Szyperski http://www.icsi.berkeley.edu/~sather/Publications/toplas.html\nhttp://www.cs.arizona.edu/icon/\nhttp://python.ca/nas/python/generator.diff\n이 구현을 실험하려면 http://sf.net/cvs/?group_id=5470 지침에 따라 CVS에서 Python을 체크아웃하십시오. 표준 테스트 \u003ccode\u003eLib/test/test_generators.py\u003c/code\u003e에는 이 PEP의 모든 예제를 포함한 많은 예제가 있습니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1904,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 255 - Simple Generators\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 17:35:06+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/254/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 254 - Making Classes Look More Like Types\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 255 - Simple Generators\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/256/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 256 - Docstring Processing System Framework\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>