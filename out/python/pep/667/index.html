<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/edf391eeca43d999.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-ad5f81b531af48c1.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1962<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 667 - Consistent views of namespaces</h1><div class="page__meta"><time dateTime="2025-09-27 10:03:19+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0667/">PEP 667 - Consistent views of namespaces</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 30-Jul-2021</p>
</blockquote>
<h1>PEP 667 – Consistent views of namespaces (네임스페이스의 일관된 뷰)</h1>
<ul>
<li><strong>작성자:</strong> Mark Shannon, Tian Gao</li>
<li><strong>상태:</strong> Final (최종)</li>
<li><strong>유형:</strong> Standards Track</li>
<li><strong>Python 버전:</strong> 3.13</li>
<li><strong>생성일:</strong> 2021년 7월 30일</li>
<li><strong>해결일:</strong> 2024년 4월 25일</li>
</ul>
<p>이 PEP는 역사적인 문서이며, 최신 및 공식 문서는 <a href="https://docs.python.org/3/library/functions.html#locals">locals()</a>에서 확인할 수 있습니다.</p>
<h2>개요 (Abstract)</h2>
<p>초기 Python 버전에서는 함수, 클래스, 모듈 등 모든 네임스페이스가 딕셔너리(dictionary)와 동일한 방식으로 구현되었습니다. 그러나 성능상의 이유로 함수 네임스페이스의 구현이 변경되었고, 이로 인해 <code>locals()</code> 및 <code>frame.f_locals</code>를 통한 네임스페이스 접근 방식이 일관성을 잃게 되었습니다. 시간이 지남에 따라 스레드, 제너레이터(generator), 코루틴(coroutine)이 추가되면서 일부 예기치 않은 버그가 발생했습니다.</p>
<p>이 PEP는 이러한 네임스페이스를 다시 일관성 있게 만드는 것을 제안합니다. <code>frame.f_locals</code>에 대한 수정은 항상 기본 변수에서 즉시 확인할 수 있습니다. 지역 변수(local variables)에 대한 수정은 <code>frame.f_locals</code>에서 즉시 확인할 수 있으며, 스레딩(threading)이나 코루틴(coroutines) 여부와 관계없이 일관성을 유지합니다.</p>
<p><code>locals()</code> 함수는 클래스(class) 및 모듈(module) 스코프(scope)에서는 현재와 동일하게 작동합니다. 함수 스코프에서는 프레임(frame) 객체에 캐시(cache)된 단일 공유 딕셔너리를 암시적으로 새로 고치는 대신, 기본 <code>frame.f_locals</code>의 즉각적인 스냅샷(snapshot)을 반환합니다.</p>
<h2>동기 (Motivation)</h2>
<p>Python 3.12 이전 버전의 <code>locals()</code>와 <code>frame.f_locals</code> 구현은 느리고, 일관성이 없으며, 버그가 많았습니다. 이 PEP는 이를 더 빠르고, 일관성 있게 만들고, 가장 중요하게는 버그를 수정하는 것을 목표로 합니다.</p>
<p>예를 들어, <code>frame</code> 객체를 통해 지역 변수를 조작하려 할 때:</p>
<pre><code class="language-python">class C:
    x = 1
    import sys
    sys._getframe().f_locals['x'] = 2
    print(x) # 2를 출력
</code></pre>
<p>위 코드는 <code>2</code>를 출력하지만, 함수에서는 다음과 같이 동작했습니다.</p>
<pre><code class="language-python">def f():
    x = 1
    import sys
    sys._getframe().f_locals['x'] = 2
    print(x)
f() # 1을 출력
</code></pre>
<p>이러한 불일치는 혼란스러웠습니다. Python 3.12의 동작은 이상한 버그를 유발할 수 있었습니다.</p>
<p>이 PEP를 통해 두 예제 모두 <code>2</code>를 출력하게 됩니다. 함수 수준의 변경 사항이 캐시된 딕셔너리 스냅샷이 아닌 프레임의 최적화된 지역 변수에 직접 기록되기 때문입니다.</p>
<p>Python 3.12의 동작에는 보상할 만한 이점이 없었으며, 신뢰할 수 없고 느렸습니다. <code>locals()</code> 내장 함수(builtin)도 바람직하지 않은 동작을 가지고 있었으며, 이에 대한 자세한 내용은 PEP 558에 명시되어 있습니다.</p>
<h2>근거 (Rationale)</h2>
<h3><code>frame.f_locals</code> 속성을 Write-Through Proxy로 만들기 (Making the frame.f_locals attribute a write-through proxy)</h3>
<p>Python 3.12의 <code>frame.f_locals</code> 구현은 지역 변수 배열에서 즉석에서 생성된 딕셔너리를 반환했습니다. 디버거(debugger)와 추적 함수(trace functions)가 변경 사항을 다시 배열에 쓰기 위해 <code>PyFrame_LocalsToFast()</code> C API를 호출했습니다. (Python 3.11까지는 이 API가 모든 추적 함수 호출 후에 암시적으로 호출되었지만, 이후에는 추적 함수에서 명시적으로 호출해야 했습니다.)</p>
<p>이로 인해 배열과 딕셔너리가 서로 동기화되지 않는 문제가 발생할 수 있었습니다. <code>PyFrame_LocalsToFast()</code>가 호출되지 않으면 <code>f_locals</code> 프레임 속성에 대한 쓰기가 지역 변수 수정으로 나타나지 않을 수 있습니다. 변수가 수정되기 전에 생성된 딕셔너리 스냅샷이 프레임에 다시 기록되면 지역 변수에 대한 쓰기가 손실될 수 있습니다.</p>
<p><code>frame.f_locals</code>가 기본 프레임에 대한 뷰(view)를 반환하도록 함으로써 이러한 문제가 사라집니다. <code>frame.f_locals</code>는 복사본이 아닌 뷰이기 때문에 항상 프레임과 동기화됩니다.</p>
<h3><code>locals()</code> 내장 함수가 독립적인 스냅샷을 반환하도록 만들기 (Making the locals() builtin return independent snapshots)</h3>
<p>PEP 558은 최적화된 스코프에서 <code>locals()</code> 내장 함수의 동작을 표준화하기 위해 세 가지 잠재적인 옵션을 고려했습니다.</p>
<ol>
<li>주어진 프레임에 대한 <code>locals()</code> 호출마다 지역 변수의 단일 공유 스냅샷을 업데이트하는 기존 동작을 유지합니다.</li>
<li><code>locals()</code>가 write-through proxy 인스턴스(<code>frame.f_locals</code>와 유사)를 반환하도록 합니다.</li>
<li><code>locals()</code>가 완전히 독립적인 스냅샷을 반환하도록 하여, <code>exec()</code>를 통해 지역 변수의 값을 변경하려는 시도가 특정 상황에서 수용되는 대신 일관되게 무시되도록 합니다.</li>
</ol>
<p>마지막 옵션이 언어 레퍼런스(language reference)에서 가장 쉽게 설명되고 사용자가 기억하기 쉽다는 이유로 선택되었습니다.</p>
<ul>
<li><code>locals()</code> 내장 함수는 최적화된 스코프에서 지역 변수의 즉각적인 스냅샷을 제공하며, 다른 스코프에서는 읽기/쓰기 접근을 제공합니다.</li>
<li><code>frame.f_locals</code>는 최적화된 스코프를 포함한 모든 스코프에서 지역 변수에 대한 읽기/쓰기 접근을 제공합니다.</li>
</ul>
<p>이 접근 방식은 쓰기 접근이 필요하지 않거나 바람직하지 않은 경우에도 두 API가 최적화된 스코프에서 전체 읽기/쓰기 접근을 허용하는 것보다 코드의 의도를 더 명확하게 할 수 있습니다. 이 설계 결정에 대한 자세한 내용은 PEP 558, 특히 'Motivation' 섹션과 'Additional considerations for eval() and exec() in optimized scopes'를 참조하십시오.</p>
<p>이 접근 방식에도 단점이 있으며, 이는 아래의 '하위 호환성(Backwards Compatibility)' 섹션에서 다룹니다.</p>
<h2>명세 (Specification)</h2>
<h3>Python API</h3>
<h4><code>frame.f_locals</code> 속성 (The frame.f_locals attribute)</h4>
<p>모듈(module) 및 클래스(class) 스코프(<code>exec()</code> 및 <code>eval()</code> 호출 포함)의 경우, <code>frame.f_locals</code>는 코드 실행에 사용되는 지역 변수 네임스페이스에 대한 직접적인 참조입니다.</p>
<p>함수 스코프(및 기타 최적화된 스코프)의 경우, <code>frame.f_locals</code>는 새로운 write-through proxy 타입의 인스턴스가 됩니다. 이 프록시는 기본 프레임의 최적화된 지역 변수 저장 배열과 비지역 변수에 대한 셀(cell) 참조 내용을 직접 수정할 수 있습니다.</p>
<p>뷰(view) 객체는 <code>collections.abc.Mapping</code> 인터페이스를 완전히 구현하며, 다음과 같은 변경 가능한 매핑(mutable mapping) 작업을 구현합니다.</p>
<ul>
<li>할당을 사용하여 새로운 키-값 쌍 추가</li>
<li>할당을 사용하여 키와 연결된 값 업데이트</li>
<li><code>setdefault()</code> 메서드를 통한 조건부 할당</li>
<li><code>update()</code> 메서드를 통한 대량 업데이트</li>
</ul>
<p>내용이 동일하더라도 다른 프레임의 뷰는 같지 않다고 비교됩니다.</p>
<p><code>f_locals</code> 매핑에 대한 모든 쓰기는 기본 변수에서 즉시 확인할 수 있습니다. 기본 변수에 대한 모든 변경은 매핑에서 즉시 확인할 수 있습니다.</p>
<p><code>f_locals</code> 객체는 완전한 매핑이며, 임의의 키-값 쌍을 추가할 수 있습니다. 프록시를 통해 추가된 새로운 이름은 기본 프레임 객체에 저장된 전용 공유 딕셔너리에 저장됩니다. (따라서 주어진 프레임에 대한 모든 프록시 인스턴스는 이런 방식으로 추가된 모든 이름에 접근할 수 있습니다.)</p>
<p><code>del</code> 문이나 <code>pop()</code> 메서드를 사용하여 기본 프레임의 지역 변수에 해당하지 않는 추가 키를 제거할 수 있습니다.</p>
<p><code>del</code> 또는 <code>pop()</code> 메서드를 사용하여 기본 프레임의 지역 변수에 해당하는 키를 제거하는 것은 지원되지 않으며, 그렇게 시도하면 <code>ValueError</code>가 발생합니다. 지역 변수는 프록시를 통해 <code>None</code>(또는 다른 값)으로만 설정할 수 있으며, 완전히 언바인딩(unbound)할 수 없습니다.</p>
<p><code>clear()</code> 메서드는 write-through proxy에서 구현되지 않습니다. 이는 지역 변수에 해당하는 항목을 삭제할 수 없는 경우 어떻게 처리해야 할지 불분명하기 때문입니다.</p>
<p>하위 호환성(backwards compatibility)을 유지하기 위해, <code>copy()</code>와 같이 새로운 매핑을 생성해야 하는 프록시 API는 write-through proxy 인스턴스 대신 일반적인 내장 <code>dict</code> 인스턴스를 생성합니다.</p>
<p>프레임 객체와 write-through proxy 사이에 순환 참조(circular reference)가 발생하는 것을 피하기 위해, <code>frame.f_locals</code>에 대한 각 접근은 새로운 write-through proxy 인스턴스를 반환합니다.</p>
<h4><code>locals()</code> 내장 함수 (The locals() builtin)</h4>
<p><code>locals()</code>는 다음과 같이 정의됩니다.</p>
<pre><code class="language-python">def locals():
    frame = sys._getframe(1)
    f_locals = frame.f_locals
    if frame._is_optimized(): # 실제 프레임 메서드는 아님
        f_locals = dict(f_locals)
    return f_locals
</code></pre>
<p>모듈(module) 및 클래스(class) 스코프(<code>exec()</code> 및 <code>eval()</code> 호출 포함)의 경우, <code>locals()</code>는 코드 실행에 사용되는 지역 변수 네임스페이스에 대한 직접적인 참조를 계속 반환합니다. (<code>frame.f_locals</code>에서 보고되는 값과 동일합니다.)</p>
<p>최적화된 스코프에서는 <code>locals()</code>에 대한 각 호출이 지역 변수의 독립적인 스냅샷을 생성합니다.</p>
<h4><code>eval()</code> 및 <code>exec()</code> 내장 함수 (The eval() and exec() builtins)</h4>
<p>이 PEP가 <code>locals()</code>의 동작을 변경하기 때문에 <code>eval()</code> 및 <code>exec()</code>의 동작도 변경됩니다.</p>
<p>명시적인 네임스페이스 인수로 <code>eval()</code> 작업을 수행하는 함수 <code>_eval()</code>이 있다고 가정하면, <code>eval()</code>은 다음과 같이 정의할 수 있습니다.</p>
<pre><code class="language-python">FrameProxyType = type((lambda: sys._getframe().f_locals)())

def eval(expression, /, globals=None, locals=None):
    if globals is None:
        # globals가 없으면 -> 호출 프레임의 globals 사용
        _calling_frame = sys._getframe(1)
        globals = _calling_frame.f_globals
    if locals is None:
        # globals 또는 locals가 없으면 -> 호출 프레임의 locals 사용
        locals = _calling_frame.f_locals
        if isinstance(locals, FrameProxyType):
            # 최적화된 프레임에서 locals() 내장 함수와 정렬
            locals = dict(locals)
    elif locals is None:
        # globals는 있지만 locals는 없으면 -> 둘 다 동일한 네임스페이스 사용
        locals = globals
    return _eval(expression, globals, locals)
</code></pre>
<p><code>exec()</code>에 대한 지정된 인수 처리도 유사하게 업데이트됩니다.</p>
<p>(Python 3.12 및 이전 버전에서는 <code>eval()</code> 또는 <code>exec()</code>에 <code>globals</code>를 제공하지 않고 <code>locals</code>를 제공하는 것이 불가능했습니다. 이는 이전에 위치 전용 인수였기 때문입니다. 이 PEP와는 별개로, Python 3.13은 이 내장 함수들이 키워드 인수를 받도록 업데이트되었습니다.)</p>
<h3>C API</h3>
<h4>PyEval C API에 추가 (Additions to the PyEval C API)</h4>
<p>세 가지 새로운 C-API 함수가 추가됩니다.</p>
<ul>
<li><code>PyObject *PyEval_GetFrameLocals(void)</code></li>
<li><code>PyObject *PyEval_GetFrameGlobals(void)</code></li>
<li><code>PyObject *PyEval_GetFrameBuiltins(void)</code></li>
</ul>
<p><code>PyEval_GetFrameLocals()</code>는 Python의 <code>locals()</code>와 동일합니다. <code>PyEval_GetFrameGlobals()</code>는 Python의 <code>globals()</code>와 동일합니다. 이 모든 함수는 새로운 참조(new reference)를 반환합니다.</p>
<h4><code>PyFrame_GetLocals</code> C API</h4>
<p>기존 <code>PyFrame_GetLocals(f)</code> C API는 Python의 <code>f.f_locals</code>와 동일합니다. 반환 값은 <code>f.f_locals</code> 접근에 대해 위에서 설명한 것과 같습니다.</p>
<p>이 함수는 새로운 참조를 반환하므로, 최적화된 스코프에서 각 호출 시 새로운 write-through proxy 인스턴스를 생성할 수 있습니다.</p>
<h4>더 이상 사용되지 않는 C API (Deprecated C APIs)</h4>
<p>다음 C API 함수는 빌려온 참조(borrowed references)를 반환하므로 더 이상 사용되지 않습니다.</p>
<ul>
<li><code>PyEval_GetLocals()</code></li>
<li><code>PyEval_GetGlobals()</code></li>
<li><code>PyEval_GetBuiltins()</code></li>
</ul>
<p>대신 다음 함수(새로운 참조를 반환하는)를 사용해야 합니다.</p>
<ul>
<li><code>PyEval_GetFrameLocals()</code></li>
<li><code>PyEval_GetFrameGlobals()</code></li>
<li><code>PyEval_GetFrameBuiltins()</code></li>
</ul>
<p>다음 C API 함수는 아무런 동작도 하지 않으며, 대체 없이 더 이상 사용되지 않습니다.</p>
<ul>
<li><code>PyFrame_FastToLocalsWithError()</code></li>
<li><code>PyFrame_FastToLocals()</code></li>
<li><code>PyFrame_LocalsToFast()</code></li>
</ul>
<p>더 이상 사용되지 않는 모든 함수는 Python 3.13 문서에 deprecated로 표시됩니다.</p>
<p>이러한 함수 중 <code>PyEval_GetLocals()</code>만이 상당한 유지보수 부담을 가집니다. 따라서 <code>PyEval_GetLocals()</code> 호출은 Python 3.14에서 <code>DeprecationWarning</code>을 발생시키고, Python 3.16(Python 3.14 이후 두 릴리스)에 제거될 예정입니다. 대안은 <code>PyEval_GetLocals</code> 호환성에서 설명된 대로 권장됩니다.</p>
<h2>변경 사항 요약 (Summary of Changes)</h2>
<p>이 섹션은 Python 3.13 이후 버전에서 지정된 동작이 Python 3.12 및 이전 버전의 기존 동작과 어떻게 다른지 요약합니다.</p>
<h3>Python API 변경 사항 (Python API changes)</h3>
<h4><code>frame.f_locals</code> 변경 사항 (<code>frame.f_locals</code> changes)</h4>
<p>다음 예시를 고려해 봅시다.</p>
<pre><code class="language-python">import sys

def l():
    "Get the locals of caller"
    return sys._getframe(1).f_locals

def test():
    if 0:
        y = 1 # Make 'y' a local variable
    x = 1
    l()['x'] = 2
    l()['y'] = 4
    l()['z'] = 5
    print(locals(), x)
test()
</code></pre>
<p>이 PEP의 변경 사항을 적용하면 <code>test()</code>는 <code>{'x': 2, 'y': 4, 'z': 5} 2</code>를 출력합니다.</p>
<p>Python 3.12에서는 <code>l()['y'] = 4</code>에 의한 <code>y</code>의 정의가 손실되어 <code>UnboundLocalError</code>가 발생합니다.</p>
<p>만약 마지막에서 두 번째 줄이 <code>y</code>에서 <code>z</code>로 변경된다면, Python 3.12와 마찬가지로 여전히 <code>NameError</code>가 발생합니다. <code>frame.f_locals</code>에 추가되었지만 어휘적으로(lexically) 지역 변수가 아닌 키는 <code>frame.f_locals</code>에는 계속 표시되지만, 동적으로 지역 변수가 되지는 않습니다.</p>
<h4><code>locals()</code> 변경 사항 (<code>locals()</code> changes)</h4>
<p>다음 예시를 고려해 봅시다.</p>
<pre><code class="language-python">def f():
    exec("x = 1")
    print(locals().get("x"))
f()
</code></pre>
<p>이 PEP의 변경 사항을 적용하면, 이 코드는 항상 <code>None</code>을 출력합니다. (<code>x</code>가 함수에 정의된 지역 변수인지 여부와 관계없이) 이는 <code>locals()</code>에 대한 명시적 호출이 <code>exec()</code> 호출에서 암시적으로 사용되는 것과 다른 별개의 스냅샷을 생성하기 때문입니다.</p>
<p>Python 3.12에서는 위 예시가 <code>1</code>을 출력했지만, 함수 정의에 대한 겉보기에는 관련 없는 변경으로 인해 <code>None</code>을 출력할 수도 있었습니다. (PEP 558의 'Additional considerations for eval() and exec() in exec() and eval() in optimized scopes' 섹션에 이 주제에 대한 자세한 내용이 있습니다.)</p>
<h4><code>eval()</code> 및 <code>exec()</code> 변경 사항 (<code>eval()</code> and <code>exec()</code> changes)</h4>
<p><code>eval()</code> 및 <code>exec()</code>에 영향을 미치는 주요 변경 사항은 "locals() 변경 사항" 예시에서 보여집니다. 최적화된 스코프에서 <code>locals()</code>에 반복적으로 접근하는 것이 더 이상 암시적으로 공통의 기본 네임스페이스를 공유하지 않게 됩니다.</p>
<h3>C API 변경 사항 (C API changes)</h3>
<h4><code>PyFrame_GetLocals</code> 변경 사항 (<code>PyFrame_GetLocals</code> change)</h4>
<p><code>PyFrame_GetLocals</code>는 이미 Python 3.12에서 임의의 매핑을 반환할 수 있었습니다. <code>exec()</code> 및 <code>eval()</code>은 <code>locals</code> 인수로 임의의 매핑을 허용하며, 메타클래스(metaclass)는 <code>__prepare__</code> 메서드에서 임의의 매핑을 반환할 수 있습니다.</p>
<p>최적화된 스코프에서 프레임 로컬 프록시(frame locals proxy)를 반환하는 것은 내장 딕셔너리가 아닌 다른 것이 반환되는 또 다른 경우를 추가할 뿐입니다.</p>
<h4><code>PyEval_GetLocals</code> 변경 사항 (<code>PyEval_GetLocals</code> change)</h4>
<p><code>PyEval_GetLocals()</code>의 의미론(semantics)은 기술적으로 변경되지 않았지만, 실제로는 변경됩니다. 최적화된 프레임에 캐시된 딕셔너리가 더 이상 프레임 로컬에 접근하는 다른 메커니즘( <code>locals()</code> 내장 함수, <code>PyFrame_GetLocals</code> 함수, <code>frame.f_locals</code> 속성)과 공유되지 않기 때문입니다.</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<h3>Python API 호환성 (Python API compatibility)</h3>
<p>Python 3.12 이하 버전에서 사용된 구현은 많은 예외적인 경우(corner cases)와 특이한 점이 있었습니다. 이러한 문제를 해결하기 위해 작성된 코드는 변경해야 할 수도 있습니다. 단순한 템플릿(templating)이나 <code>print</code> 디버깅을 위해 <code>locals()</code>를 사용하는 코드는 계속해서 올바르게 작동할 것입니다. 디버거와 <code>f_locals</code>를 사용하여 지역 변수를 수정하는 다른 도구들은 이제 스레드 코드, 코루틴, 제너레이터와 같은 동시성(concurrent) 코드 실행 메커니즘이 있는 경우에도 올바르게 작동할 것입니다.</p>
<h4><code>frame.f_locals</code> 호환성 (<code>frame.f_locals</code> compatibility)</h4>
<p><code>f.f_locals</code>는 함수의 네임스페이스인 것처럼 동작하지만, 몇 가지 눈에 띄는 차이점이 있습니다. 예를 들어, 최적화된 프레임의 경우 <code>f.f_locals is f.f_locals</code>는 <code>False</code>가 됩니다. 이는 속성에 접근할 때마다 새로운 write-through proxy 인스턴스가 생성되기 때문입니다.</p>
<p>그러나 <code>f.f_locals == f.f_locals</code>는 <code>True</code>이며, 매핑 키로 새 변수 이름을 추가하는 것을 포함하여 어떤 방식으로든 기본 변수에 대한 모든 변경은 항상 확인할 수 있습니다.</p>
<h4><code>locals()</code> 호환성 (<code>locals()</code> compatibility)</h4>
<p>최적화된 프레임의 경우 <code>locals() is locals()</code>는 <code>False</code>이므로, 다음 코드와 같은 코드는 <code>1</code>을 반환하는 대신 <code>KeyError</code>를 발생시킵니다.</p>
<pre><code class="language-python">def f():
    locals()["x"] = 1
    return locals()["x"]
</code></pre>
<p>이러한 코드가 계속 작동하려면, 이전의 암시적인 프레임 객체 캐싱에 의존하는 대신 수정할 네임스페이스를 지역 변수에 명시적으로 저장해야 합니다.</p>
<pre><code class="language-python">def f():
    ns = {}
    ns["x"] = 1
    return ns["x"]
</code></pre>
<p>이것은 기술적으로 공식적인 하위 호환성 파기(formal backwards compatibility break)는 아닙니다. (<code>locals()</code>에 다시 쓰는 동작이 명시적으로 정의되지 않은 것으로 문서화되었기 때문입니다.) 하지만 기존 동작에 의존하는 코드가 분명히 존재합니다. 따라서 업데이트된 동작은 문서에 변경 사항으로 명시적으로 기록될 것이며, Python 3.13 포팅 가이드(porting guide)에서 다룰 예정입니다.</p>
<p>Python 3.13 이상에서 중복 복사본을 만들지 않고 모든 버전의 최적화된 스코프에서 <code>locals()</code>의 복사본으로 작업하려면, 사용자는 Python 3.13 이전 버전에서만 명시적으로 복사본을 만드는 버전 종속 헬퍼 함수를 정의해야 합니다.</p>
<pre><code class="language-python">import sys

if sys.version_info >= (3, 13):
    def _ensure_func_snapshot(d):
        return d # 3.13+ locals()는 이미 스냅샷을 반환함
else:
    def _ensure_func_snapshot(d):
        return dict(d) # 이전 버전에서는 스냅샷 생성

def f():
    ns = _ensure_func_snapshot(locals())
    ns["x"] = 1
    return ns
</code></pre>
<p>다른 스코프에서는 <code>locals().copy()</code>를 무조건 호출해도 중복 복사본이 생성되지 않습니다.</p>
<h4><code>exec()</code> 및 <code>eval()</code>에 미치는 영향 (Impact on exec() and eval())</h4>
<p>이 PEP가 <code>exec()</code> 또는 <code>eval()</code>을 직접 수정하지는 않지만, <code>locals()</code>에 대한 의미론적 변경은 <code>exec()</code> 및 <code>eval()</code>의 동작에 영향을 미칩니다. 이는 기본적으로 호출하는 네임스페이스에서 코드를 실행하기 때문입니다.</p>
<p>이는 일부 코드에 잠재적인 호환성 문제를 제기합니다. 이전 구현에서는 함수 스코프에서 <code>locals()</code>가 여러 번 호출될 때 동일한 딕셔너리를 반환했기 때문에, 다음 코드는 암시적으로 공유된 지역 변수 네임스페이스 덕분에 일반적으로 작동했습니다.</p>
<pre><code class="language-python">def f():
    exec('a = 0') # exec('a = 0', globals(), locals())와 동일
    exec('print(a)') # exec('print(a)', globals(), locals())와 동일
    print(locals()) # {'a': 0}
    # 그러나, 여기서 print(a)는 작동하지 않을 것임
f()
</code></pre>
<p>이 PEP의 <code>locals()</code>에 대한 의미론적 변경으로 인해, <code>exec('print(a)')</code> 호출은 <code>NameError</code>로 실패하고, <code>print(locals())</code>는 빈 딕셔너리를 보고합니다. 각 줄이 프레임 객체에 저장된 단일 캐시된 스냅샷을 암시적으로 공유하는 대신, 자체적인 별개의 지역 변수 스냅샷을 사용하기 때문입니다.</p>
<p><code>exec()</code> 호출 간에 공유 네임스페이스를 얻으려면, 이전에 암시적으로 공유되던 프레임 네임스페이스에 의존하는 대신 명시적인 네임스페이스를 사용해야 합니다.</p>
<pre><code class="language-python">def f():
    ns = {}
    exec('a = 0', locals=ns)
    exec('print(a)', locals=ns) # 0
f()
</code></pre>
<p><code>frame.f_locals</code>를 명시적으로 사용하여 지역 스코프의 변수를 안정적으로 변경할 수도 있습니다. (이전에는 <code>ctypes</code>를 사용하여 <code>PyFrame_LocalsToFast</code>를 호출하는 것도 이 PEP의 다른 곳에서 논의된 상태 불일치 문제의 영향을 받았습니다.)</p>
<pre><code class="language-python">import sys

def f():
    a = None
    exec('a = 0', locals=sys._getframe().f_locals)
    print(a) # 0
f()
</code></pre>
<p>모듈(module) 및 클래스(class) 스코프(중첩된 호출 포함)에 대한 <code>exec()</code> 및 <code>eval()</code>의 동작은 변경되지 않습니다. 해당 스코프에서 <code>locals()</code>의 동작이 변경되지 않기 때문입니다.</p>
<h4>표준 라이브러리의 다른 코드 실행 API에 미치는 영향 (Impact on other code execution APIs in the standard library)</h4>
<p><code>pdb</code> 및 <code>bdb</code>는 <code>frame.f_locals</code> API를 사용하므로, 최적화된 프레임에서도 지역 변수를 안정적으로 업데이트할 수 있습니다. 이 PEP를 구현하면 디버거가 활성화된 동안 스레드, 제너레이터, 코루틴 및 기타 동시성 코드 실행 메커니즘과 관련된 이러한 모듈의 여러 오랜 버그가 해결될 것입니다.</p>
<p>표준 라이브러리의 다른 코드 실행 API(<code>code</code> 모듈 등)는 <code>locals()</code> 또는 <code>frame.f_locals</code>에 암시적으로 접근하지 않습니다. 하지만 이 PEP의 나머지 부분에서 설명하는 바와 같이 이러한 네임스페이스를 명시적으로 전달하는 동작은 변경될 것입니다. (최적화된 스코프에서 <code>locals()</code>를 전달하면 더 이상 호출 간에 코드 실행 네임스페이스가 암시적으로 공유되지 않으며, 최적화된 스코프에서 <code>frame.f_locals</code>를 전달하면 지역 변수 및 비지역 셀(nonlocal cell) 참조를 안정적으로 수정할 수 있습니다.)</p>
<h3>C API 호환성 (C API compatibility)</h3>
<h4><code>PyEval_GetLocals</code> 호환성 (<code>PyEval_GetLocals</code> compatibility)</h4>
<p><code>PyEval_GetLocals()</code>는 Python 수준에서 <code>locals()</code>를 에뮬레이트하는지 <code>sys._getframe().f_locals</code>를 에뮬레이트하는지를 역사적으로 구분하지 않았습니다. 이는 모두 지역 변수 바인딩의 동일한 공유 캐시에 대한 참조를 반환했기 때문입니다.</p>
<p>이 PEP를 통해 <code>locals()</code>는 최적화된 프레임에 대한 각 호출에서 독립적인 스냅샷을 반환하도록 변경됩니다. <code>frame.f_locals</code> (<code>PyFrame_GetLocals</code>와 함께)는 새로운 write-through proxy 인스턴스를 반환하도록 변경됩니다.</p>
<p><code>PyEval_GetLocals()</code>는 빌려온 참조를 반환하기 때문에, 이 두 대안 중 어느 하나에 맞춰 의미론을 업데이트하는 것이 불가능합니다. 따라서 프레임 객체에 저장된 공유 캐시 딕셔너리를 필요로 하는 유일한 남아있는 API가 됩니다.</p>
<p>이것이 기술적으로 함수의 의미론을 변경하지는 않지만, 다른 API 사용자가 추가 딕셔너리 항목을 볼 수 없게 합니다. 이는 해당 API가 더 이상 동일한 기본 캐시 딕셔너리에 접근하지 않기 때문입니다.</p>
<p><code>PyEval_GetLocals()</code>가 Python <code>locals()</code> 내장 함수와 동일하게 사용되는 경우, 대신 <code>PyEval_GetFrameLocals()</code>를 사용해야 합니다.</p>
<p>이 코드는:</p>
<pre><code class="language-c">locals = PyEval_GetLocals();
if (locals == NULL) {
    goto error_handler;
}
Py_INCREF(locals);
</code></pre>
<p>다음으로 대체되어야 합니다:</p>
<pre><code class="language-c">// Python 코드의 "locals()"와 동일
locals = PyEval_GetFrameLocals();
if (locals == NULL) {
    goto error_handler;
}
</code></pre>
<p><code>PyEval_GetLocals()</code>가 Python에서 <code>sys._getframe().f_locals</code>를 호출하는 것과 동일하게 사용되는 경우, <code>PyEval_GetFrame()</code> 결과에 대해 <code>PyFrame_GetLocals()</code>를 호출하여 대체해야 합니다.</p>
<p>이러한 경우, 원본 코드는 다음으로 대체되어야 합니다.</p>
<pre><code class="language-c">// Python 코드의 "sys._getframe()"과 동일
frame = PyEval_GetFrame();
if (frame == NULL) {
    goto error_handler;
}
// Python 코드의 "frame.f_locals"와 동일
locals = PyFrame_GetLocals(frame);
frame = NULL; // 빌려온 참조의 가시성 최소화
if (locals == NULL) {
    goto error_handler;
}
</code></pre>
<h3>PEP 709 인라인 컴프리헨션(Inlined Comprehensions)에 미치는 영향 (Impact on PEP 709 inlined comprehensions)</h3>
<p>함수 내의 인라인 컴프리헨션의 경우, <code>locals()</code>는 현재 컴프리헨션 내부 또는 외부에서 동일하게 동작하며, 이는 변경되지 않을 것입니다. 함수 내의 <code>locals()</code> 동작은 일반적으로 이 PEP의 나머지 부분에서 명시된 대로 변경됩니다.</p>
<p>모듈 또는 클래스 스코프의 인라인 컴프리헨션의 경우, 인라인 컴프리헨션 내에서 <code>locals()</code>를 호출하면 각 호출마다 새로운 딕셔너리를 반환합니다. 이 PEP는 함수 내의 <code>locals()</code>도 각 호출마다 항상 새로운 딕셔너리를 반환하도록 하여 일관성을 향상시킵니다. 클래스 또는 모듈 스코프의 인라인 컴프리헨션은 인라인 컴프리헨션이 여전히 별개의 함수인 것처럼 동작할 것입니다.</p>
<h2>구현 (Implementation)</h2>
<p><code>frame.f_locals</code>를 읽을 때마다 지역 변수(셀(cell) 및 자유(free) 변수 포함) 이름과 해당 지역 변수 값의 매핑처럼 보이는 새로운 프록시(proxy) 객체가 생성됩니다.</p>
<p>가능한 구현 스케치(sketch)는 다음과 같습니다. 밑줄로 시작하는 모든 속성은 보이지 않으며 직접 접근할 수 없습니다. 이는 제안된 설계를 설명하기 위한 것입니다.</p>
<h3>C API</h3>
<p><code>PyEval_GetLocals()</code>는 대략 다음과 같이 구현됩니다.</p>
<pre><code class="language-c">PyObject *PyEval_GetLocals(void) {
    PyFrameObject * = ...; // 현재 프레임 가져오기.
    if (frame->_locals_cache == NULL) {
        frame->_locals_cache = PyEval_GetFrameLocals();
    } else {
        PyDict_Update(frame->_locals_cache, PyFrame_GetLocals(frame));
    }
    return frame->_locals_cache;
}
</code></pre>
<p>빌려온 참조를 반환하는 모든 함수와 마찬가지로, 참조가 객체의 수명(lifetime)을 넘어 사용되지 않도록 주의해야 합니다.</p>
<h3>구현 노트 (Implementation Notes)</h3>
<p>PEP 텍스트가 승인되었을 때, <code>PyEval_GetLocals</code>는 새로운 write-through proxy의 캐시된 인스턴스를 반환하기 시작할 것을 제안했지만, 구현 스케치는 프레임 인스턴스에 캐시된 딕셔너리 스냅샷을 계속 반환할 것을 나타냈습니다. 이 불일치는 PEP를 구현하는 동안 확인되었으며, 스티어링 위원회(Steering Council)에서 Python 3.12의 동작을 유지하는 방향으로 해결되었습니다. (즉, 프레임 인스턴스에 캐시된 딕셔너리 스냅샷을 반환). PEP 텍스트는 이에 따라 업데이트되었습니다.</p>
<p>C API 명확화 논의 중에, 최적화된 스코프에서 <code>locals()</code>가 독립적인 스냅샷을 반환하도록 업데이트된 이유가 명확하지 않다는 점도 드러났습니다. 이는 이 PEP에서 독립적으로 다루기보다는 원래 PEP 558 논의에서 상속되었기 때문입니다. PEP 텍스트는 이 변경 사항을 더 잘 다루도록 업데이트되었으며, <code>Specification</code> 및 <code>Backwards Compatibility</code> 섹션에 추가 업데이트가 포함되어 <code>locals()</code> 네임스페이스에서 코드를 실행하는 코드 실행 API에 미치는 영향을 다룹니다. 추가 동기 및 근거 세부 정보도 PEP 558에 추가되었습니다.</p>
<p>Python 3.13.0에서는 write-through proxy가 <code>del</code> 및 <code>pop()</code>을 사용하여 추가 변수도 삭제하는 것을 허용하지 않았습니다. 이는 이후 호환성 회귀(compatibility regression)로 보고되었으며, 현재 'frame.f_locals 속성' 섹션에서 설명하는 대로 해결되었습니다.</p>
<h3>PEP 558과의 비교 (Comparison with PEP 558)</h3>
<p>이 PEP와 PEP 558은 <code>locals()</code> 및 <code>frame.f_locals()</code>의 의미론을 이해하기 쉽고, 그 동작을 안정적으로 만드는 공통 목표를 공유했습니다.</p>
<p>이 PEP와 PEP 558의 주요 차이점은 PEP 558이 레거시 <code>PyEval_GetLocals()</code> API와의 하위 호환성을 개선하기 위해 지역 변수의 전체 내부 딕셔너리 복사본 내부에 추가 변수를 저장하려고 시도한 반면, 이 PEP는 그렇지 않다는 것입니다. (이 PEP는 추가 지역 변수를 새로운 프레임 프록시 객체를 통해서만 접근되는 전용 딕셔너리에 저장하고, 요청 시에만 <code>PyEval_GetLocals()</code> 공유 딕셔너리에 복사합니다.)</p>
<p>PEP 558은 해당 내부 복사본이 언제 업데이트되는지 정확히 명시하지 않아, 이 PEP가 잘 명시된 여러 경우에 PEP 558의 동작을 추론하기 어렵게 만들었습니다.</p>
<p>PEP 558은 또한 확장 모듈이 현재 활성 Python 스코프가 최적화되었는지 여부를 더 쉽게 판단하고, 따라서 C API의 <code>locals()</code>와 동등한 것이 프레임의 지역 실행 네임스페이스에 대한 직접 참조를 반환하는지 아니면 프레임의 지역 변수 및 비지역 셀 참조의 얕은 복사본을 반환하는지 알 수 있도록 하는 몇 가지 추가 Python 스코프 인트로스펙션(introspection) 인터페이스를 C API에 도입할 것을 제안했습니다. 이러한 인트로스펙션 API를 추가할지 여부는 <code>locals()</code> 및 <code>frame.f_locals</code>에 제안된 변경 사항과 독립적이므로, 이 PEP에는 그러한 제안이 포함되지 않았습니다.</p>
<p>PEP 558은 결국 이 PEP를 위해 철회되었습니다.</p>
<h2>참조 구현 (Reference Implementation)</h2>
<p>구현은 GitHub에서 드래프트 풀 리퀘스트(draft pull request)로 개발 중입니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain) 또는 CC0-1.0-Universal 라이선스(둘 중 더 관대한 라이선스)에 따라 제공됩니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/666/">[Rejected] PEP 666 - Reject Foolish Indentation</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 667 - Consistent views of namespaces</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/668/">[Accepted] PEP 668 - Marking Python base environments as “externally managed”</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/edf391eeca43d999.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-ad5f81b531af48c1.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/667\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/edf391eeca43d999.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"ogGio3genoY6eym-8SYbg\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/667/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/667\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"667\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/667\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T8cbb,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0667/\"\u003ePEP 667 - Consistent views of namespaces\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 30-Jul-2021\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 667 – Consistent views of namespaces (네임스페이스의 일관된 뷰)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Mark Shannon, Tian Gao\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final (최종)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.13\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2021년 7월 30일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e해결일:\u003c/strong\u003e 2024년 4월 25일\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 PEP는 역사적인 문서이며, 최신 및 공식 문서는 \u003ca href=\"https://docs.python.org/3/library/functions.html#locals\"\u003elocals()\u003c/a\u003e에서 확인할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e초기 Python 버전에서는 함수, 클래스, 모듈 등 모든 네임스페이스가 딕셔너리(dictionary)와 동일한 방식으로 구현되었습니다. 그러나 성능상의 이유로 함수 네임스페이스의 구현이 변경되었고, 이로 인해 \u003ccode\u003elocals()\u003c/code\u003e 및 \u003ccode\u003eframe.f_locals\u003c/code\u003e를 통한 네임스페이스 접근 방식이 일관성을 잃게 되었습니다. 시간이 지남에 따라 스레드, 제너레이터(generator), 코루틴(coroutine)이 추가되면서 일부 예기치 않은 버그가 발생했습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 이러한 네임스페이스를 다시 일관성 있게 만드는 것을 제안합니다. \u003ccode\u003eframe.f_locals\u003c/code\u003e에 대한 수정은 항상 기본 변수에서 즉시 확인할 수 있습니다. 지역 변수(local variables)에 대한 수정은 \u003ccode\u003eframe.f_locals\u003c/code\u003e에서 즉시 확인할 수 있으며, 스레딩(threading)이나 코루틴(coroutines) 여부와 관계없이 일관성을 유지합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003elocals()\u003c/code\u003e 함수는 클래스(class) 및 모듈(module) 스코프(scope)에서는 현재와 동일하게 작동합니다. 함수 스코프에서는 프레임(frame) 객체에 캐시(cache)된 단일 공유 딕셔너리를 암시적으로 새로 고치는 대신, 기본 \u003ccode\u003eframe.f_locals\u003c/code\u003e의 즉각적인 스냅샷(snapshot)을 반환합니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePython 3.12 이전 버전의 \u003ccode\u003elocals()\u003c/code\u003e와 \u003ccode\u003eframe.f_locals\u003c/code\u003e 구현은 느리고, 일관성이 없으며, 버그가 많았습니다. 이 PEP는 이를 더 빠르고, 일관성 있게 만들고, 가장 중요하게는 버그를 수정하는 것을 목표로 합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003eframe\u003c/code\u003e 객체를 통해 지역 변수를 조작하려 할 때:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass C:\r\n    x = 1\r\n    import sys\r\n    sys._getframe().f_locals['x'] = 2\r\n    print(x) # 2를 출력\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 \u003ccode\u003e2\u003c/code\u003e를 출력하지만, 함수에서는 다음과 같이 동작했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef f():\r\n    x = 1\r\n    import sys\r\n    sys._getframe().f_locals['x'] = 2\r\n    print(x)\r\nf() # 1을 출력\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 불일치는 혼란스러웠습니다. Python 3.12의 동작은 이상한 버그를 유발할 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP를 통해 두 예제 모두 \u003ccode\u003e2\u003c/code\u003e를 출력하게 됩니다. 함수 수준의 변경 사항이 캐시된 딕셔너리 스냅샷이 아닌 프레임의 최적화된 지역 변수에 직접 기록되기 때문입니다.\u003c/p\u003e\n\u003cp\u003ePython 3.12의 동작에는 보상할 만한 이점이 없었으며, 신뢰할 수 없고 느렸습니다. \u003ccode\u003elocals()\u003c/code\u003e 내장 함수(builtin)도 바람직하지 않은 동작을 가지고 있었으며, 이에 대한 자세한 내용은 PEP 558에 명시되어 있습니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003eframe.f_locals\u003c/code\u003e 속성을 Write-Through Proxy로 만들기 (Making the frame.f_locals attribute a write-through proxy)\u003c/h3\u003e\n\u003cp\u003ePython 3.12의 \u003ccode\u003eframe.f_locals\u003c/code\u003e 구현은 지역 변수 배열에서 즉석에서 생성된 딕셔너리를 반환했습니다. 디버거(debugger)와 추적 함수(trace functions)가 변경 사항을 다시 배열에 쓰기 위해 \u003ccode\u003ePyFrame_LocalsToFast()\u003c/code\u003e C API를 호출했습니다. (Python 3.11까지는 이 API가 모든 추적 함수 호출 후에 암시적으로 호출되었지만, 이후에는 추적 함수에서 명시적으로 호출해야 했습니다.)\u003c/p\u003e\n\u003cp\u003e이로 인해 배열과 딕셔너리가 서로 동기화되지 않는 문제가 발생할 수 있었습니다. \u003ccode\u003ePyFrame_LocalsToFast()\u003c/code\u003e가 호출되지 않으면 \u003ccode\u003ef_locals\u003c/code\u003e 프레임 속성에 대한 쓰기가 지역 변수 수정으로 나타나지 않을 수 있습니다. 변수가 수정되기 전에 생성된 딕셔너리 스냅샷이 프레임에 다시 기록되면 지역 변수에 대한 쓰기가 손실될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eframe.f_locals\u003c/code\u003e가 기본 프레임에 대한 뷰(view)를 반환하도록 함으로써 이러한 문제가 사라집니다. \u003ccode\u003eframe.f_locals\u003c/code\u003e는 복사본이 아닌 뷰이기 때문에 항상 프레임과 동기화됩니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003elocals()\u003c/code\u003e 내장 함수가 독립적인 스냅샷을 반환하도록 만들기 (Making the locals() builtin return independent snapshots)\u003c/h3\u003e\n\u003cp\u003ePEP 558은 최적화된 스코프에서 \u003ccode\u003elocals()\u003c/code\u003e 내장 함수의 동작을 표준화하기 위해 세 가지 잠재적인 옵션을 고려했습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e주어진 프레임에 대한 \u003ccode\u003elocals()\u003c/code\u003e 호출마다 지역 변수의 단일 공유 스냅샷을 업데이트하는 기존 동작을 유지합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elocals()\u003c/code\u003e가 write-through proxy 인스턴스(\u003ccode\u003eframe.f_locals\u003c/code\u003e와 유사)를 반환하도록 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elocals()\u003c/code\u003e가 완전히 독립적인 스냅샷을 반환하도록 하여, \u003ccode\u003eexec()\u003c/code\u003e를 통해 지역 변수의 값을 변경하려는 시도가 특정 상황에서 수용되는 대신 일관되게 무시되도록 합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e마지막 옵션이 언어 레퍼런스(language reference)에서 가장 쉽게 설명되고 사용자가 기억하기 쉽다는 이유로 선택되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elocals()\u003c/code\u003e 내장 함수는 최적화된 스코프에서 지역 변수의 즉각적인 스냅샷을 제공하며, 다른 스코프에서는 읽기/쓰기 접근을 제공합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eframe.f_locals\u003c/code\u003e는 최적화된 스코프를 포함한 모든 스코프에서 지역 변수에 대한 읽기/쓰기 접근을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 접근 방식은 쓰기 접근이 필요하지 않거나 바람직하지 않은 경우에도 두 API가 최적화된 스코프에서 전체 읽기/쓰기 접근을 허용하는 것보다 코드의 의도를 더 명확하게 할 수 있습니다. 이 설계 결정에 대한 자세한 내용은 PEP 558, 특히 'Motivation' 섹션과 'Additional considerations for eval() and exec() in optimized scopes'를 참조하십시오.\u003c/p\u003e\n\u003cp\u003e이 접근 방식에도 단점이 있으며, 이는 아래의 '하위 호환성(Backwards Compatibility)' 섹션에서 다룹니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003ch3\u003ePython API\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003eframe.f_locals\u003c/code\u003e 속성 (The frame.f_locals attribute)\u003c/h4\u003e\n\u003cp\u003e모듈(module) 및 클래스(class) 스코프(\u003ccode\u003eexec()\u003c/code\u003e 및 \u003ccode\u003eeval()\u003c/code\u003e 호출 포함)의 경우, \u003ccode\u003eframe.f_locals\u003c/code\u003e는 코드 실행에 사용되는 지역 변수 네임스페이스에 대한 직접적인 참조입니다.\u003c/p\u003e\n\u003cp\u003e함수 스코프(및 기타 최적화된 스코프)의 경우, \u003ccode\u003eframe.f_locals\u003c/code\u003e는 새로운 write-through proxy 타입의 인스턴스가 됩니다. 이 프록시는 기본 프레임의 최적화된 지역 변수 저장 배열과 비지역 변수에 대한 셀(cell) 참조 내용을 직접 수정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e뷰(view) 객체는 \u003ccode\u003ecollections.abc.Mapping\u003c/code\u003e 인터페이스를 완전히 구현하며, 다음과 같은 변경 가능한 매핑(mutable mapping) 작업을 구현합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e할당을 사용하여 새로운 키-값 쌍 추가\u003c/li\u003e\n\u003cli\u003e할당을 사용하여 키와 연결된 값 업데이트\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esetdefault()\u003c/code\u003e 메서드를 통한 조건부 할당\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eupdate()\u003c/code\u003e 메서드를 통한 대량 업데이트\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e내용이 동일하더라도 다른 프레임의 뷰는 같지 않다고 비교됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ef_locals\u003c/code\u003e 매핑에 대한 모든 쓰기는 기본 변수에서 즉시 확인할 수 있습니다. 기본 변수에 대한 모든 변경은 매핑에서 즉시 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ef_locals\u003c/code\u003e 객체는 완전한 매핑이며, 임의의 키-값 쌍을 추가할 수 있습니다. 프록시를 통해 추가된 새로운 이름은 기본 프레임 객체에 저장된 전용 공유 딕셔너리에 저장됩니다. (따라서 주어진 프레임에 대한 모든 프록시 인스턴스는 이런 방식으로 추가된 모든 이름에 접근할 수 있습니다.)\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edel\u003c/code\u003e 문이나 \u003ccode\u003epop()\u003c/code\u003e 메서드를 사용하여 기본 프레임의 지역 변수에 해당하지 않는 추가 키를 제거할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edel\u003c/code\u003e 또는 \u003ccode\u003epop()\u003c/code\u003e 메서드를 사용하여 기본 프레임의 지역 변수에 해당하는 키를 제거하는 것은 지원되지 않으며, 그렇게 시도하면 \u003ccode\u003eValueError\u003c/code\u003e가 발생합니다. 지역 변수는 프록시를 통해 \u003ccode\u003eNone\u003c/code\u003e(또는 다른 값)으로만 설정할 수 있으며, 완전히 언바인딩(unbound)할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eclear()\u003c/code\u003e 메서드는 write-through proxy에서 구현되지 않습니다. 이는 지역 변수에 해당하는 항목을 삭제할 수 없는 경우 어떻게 처리해야 할지 불분명하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e하위 호환성(backwards compatibility)을 유지하기 위해, \u003ccode\u003ecopy()\u003c/code\u003e와 같이 새로운 매핑을 생성해야 하는 프록시 API는 write-through proxy 인스턴스 대신 일반적인 내장 \u003ccode\u003edict\u003c/code\u003e 인스턴스를 생성합니다.\u003c/p\u003e\n\u003cp\u003e프레임 객체와 write-through proxy 사이에 순환 참조(circular reference)가 발생하는 것을 피하기 위해, \u003ccode\u003eframe.f_locals\u003c/code\u003e에 대한 각 접근은 새로운 write-through proxy 인스턴스를 반환합니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003elocals()\u003c/code\u003e 내장 함수 (The locals() builtin)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003elocals()\u003c/code\u003e는 다음과 같이 정의됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef locals():\r\n    frame = sys._getframe(1)\r\n    f_locals = frame.f_locals\r\n    if frame._is_optimized(): # 실제 프레임 메서드는 아님\r\n        f_locals = dict(f_locals)\r\n    return f_locals\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모듈(module) 및 클래스(class) 스코프(\u003ccode\u003eexec()\u003c/code\u003e 및 \u003ccode\u003eeval()\u003c/code\u003e 호출 포함)의 경우, \u003ccode\u003elocals()\u003c/code\u003e는 코드 실행에 사용되는 지역 변수 네임스페이스에 대한 직접적인 참조를 계속 반환합니다. (\u003ccode\u003eframe.f_locals\u003c/code\u003e에서 보고되는 값과 동일합니다.)\u003c/p\u003e\n\u003cp\u003e최적화된 스코프에서는 \u003ccode\u003elocals()\u003c/code\u003e에 대한 각 호출이 지역 변수의 독립적인 스냅샷을 생성합니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eeval()\u003c/code\u003e 및 \u003ccode\u003eexec()\u003c/code\u003e 내장 함수 (The eval() and exec() builtins)\u003c/h4\u003e\n\u003cp\u003e이 PEP가 \u003ccode\u003elocals()\u003c/code\u003e의 동작을 변경하기 때문에 \u003ccode\u003eeval()\u003c/code\u003e 및 \u003ccode\u003eexec()\u003c/code\u003e의 동작도 변경됩니다.\u003c/p\u003e\n\u003cp\u003e명시적인 네임스페이스 인수로 \u003ccode\u003eeval()\u003c/code\u003e 작업을 수행하는 함수 \u003ccode\u003e_eval()\u003c/code\u003e이 있다고 가정하면, \u003ccode\u003eeval()\u003c/code\u003e은 다음과 같이 정의할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eFrameProxyType = type((lambda: sys._getframe().f_locals)())\r\n\r\ndef eval(expression, /, globals=None, locals=None):\r\n    if globals is None:\r\n        # globals가 없으면 -\u003e 호출 프레임의 globals 사용\r\n        _calling_frame = sys._getframe(1)\r\n        globals = _calling_frame.f_globals\r\n    if locals is None:\r\n        # globals 또는 locals가 없으면 -\u003e 호출 프레임의 locals 사용\r\n        locals = _calling_frame.f_locals\r\n        if isinstance(locals, FrameProxyType):\r\n            # 최적화된 프레임에서 locals() 내장 함수와 정렬\r\n            locals = dict(locals)\r\n    elif locals is None:\r\n        # globals는 있지만 locals는 없으면 -\u003e 둘 다 동일한 네임스페이스 사용\r\n        locals = globals\r\n    return _eval(expression, globals, locals)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eexec()\u003c/code\u003e에 대한 지정된 인수 처리도 유사하게 업데이트됩니다.\u003c/p\u003e\n\u003cp\u003e(Python 3.12 및 이전 버전에서는 \u003ccode\u003eeval()\u003c/code\u003e 또는 \u003ccode\u003eexec()\u003c/code\u003e에 \u003ccode\u003eglobals\u003c/code\u003e를 제공하지 않고 \u003ccode\u003elocals\u003c/code\u003e를 제공하는 것이 불가능했습니다. 이는 이전에 위치 전용 인수였기 때문입니다. 이 PEP와는 별개로, Python 3.13은 이 내장 함수들이 키워드 인수를 받도록 업데이트되었습니다.)\u003c/p\u003e\n\u003ch3\u003eC API\u003c/h3\u003e\n\u003ch4\u003ePyEval C API에 추가 (Additions to the PyEval C API)\u003c/h4\u003e\n\u003cp\u003e세 가지 새로운 C-API 함수가 추가됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyObject *PyEval_GetFrameLocals(void)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject *PyEval_GetFrameGlobals(void)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject *PyEval_GetFrameBuiltins(void)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ePyEval_GetFrameLocals()\u003c/code\u003e는 Python의 \u003ccode\u003elocals()\u003c/code\u003e와 동일합니다. \u003ccode\u003ePyEval_GetFrameGlobals()\u003c/code\u003e는 Python의 \u003ccode\u003eglobals()\u003c/code\u003e와 동일합니다. 이 모든 함수는 새로운 참조(new reference)를 반환합니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003ePyFrame_GetLocals\u003c/code\u003e C API\u003c/h4\u003e\n\u003cp\u003e기존 \u003ccode\u003ePyFrame_GetLocals(f)\u003c/code\u003e C API는 Python의 \u003ccode\u003ef.f_locals\u003c/code\u003e와 동일합니다. 반환 값은 \u003ccode\u003ef.f_locals\u003c/code\u003e 접근에 대해 위에서 설명한 것과 같습니다.\u003c/p\u003e\n\u003cp\u003e이 함수는 새로운 참조를 반환하므로, 최적화된 스코프에서 각 호출 시 새로운 write-through proxy 인스턴스를 생성할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e더 이상 사용되지 않는 C API (Deprecated C APIs)\u003c/h4\u003e\n\u003cp\u003e다음 C API 함수는 빌려온 참조(borrowed references)를 반환하므로 더 이상 사용되지 않습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyEval_GetLocals()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyEval_GetGlobals()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyEval_GetBuiltins()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e대신 다음 함수(새로운 참조를 반환하는)를 사용해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyEval_GetFrameLocals()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyEval_GetFrameGlobals()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyEval_GetFrameBuiltins()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 C API 함수는 아무런 동작도 하지 않으며, 대체 없이 더 이상 사용되지 않습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyFrame_FastToLocalsWithError()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyFrame_FastToLocals()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyFrame_LocalsToFast()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e더 이상 사용되지 않는 모든 함수는 Python 3.13 문서에 deprecated로 표시됩니다.\u003c/p\u003e\n\u003cp\u003e이러한 함수 중 \u003ccode\u003ePyEval_GetLocals()\u003c/code\u003e만이 상당한 유지보수 부담을 가집니다. 따라서 \u003ccode\u003ePyEval_GetLocals()\u003c/code\u003e 호출은 Python 3.14에서 \u003ccode\u003eDeprecationWarning\u003c/code\u003e을 발생시키고, Python 3.16(Python 3.14 이후 두 릴리스)에 제거될 예정입니다. 대안은 \u003ccode\u003ePyEval_GetLocals\u003c/code\u003e 호환성에서 설명된 대로 권장됩니다.\u003c/p\u003e\n\u003ch2\u003e변경 사항 요약 (Summary of Changes)\u003c/h2\u003e\n\u003cp\u003e이 섹션은 Python 3.13 이후 버전에서 지정된 동작이 Python 3.12 및 이전 버전의 기존 동작과 어떻게 다른지 요약합니다.\u003c/p\u003e\n\u003ch3\u003ePython API 변경 사항 (Python API changes)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003eframe.f_locals\u003c/code\u003e 변경 사항 (\u003ccode\u003eframe.f_locals\u003c/code\u003e changes)\u003c/h4\u003e\n\u003cp\u003e다음 예시를 고려해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport sys\r\n\r\ndef l():\r\n    \"Get the locals of caller\"\r\n    return sys._getframe(1).f_locals\r\n\r\ndef test():\r\n    if 0:\r\n        y = 1 # Make 'y' a local variable\r\n    x = 1\r\n    l()['x'] = 2\r\n    l()['y'] = 4\r\n    l()['z'] = 5\r\n    print(locals(), x)\r\ntest()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 PEP의 변경 사항을 적용하면 \u003ccode\u003etest()\u003c/code\u003e는 \u003ccode\u003e{'x': 2, 'y': 4, 'z': 5} 2\u003c/code\u003e를 출력합니다.\u003c/p\u003e\n\u003cp\u003ePython 3.12에서는 \u003ccode\u003el()['y'] = 4\u003c/code\u003e에 의한 \u003ccode\u003ey\u003c/code\u003e의 정의가 손실되어 \u003ccode\u003eUnboundLocalError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003cp\u003e만약 마지막에서 두 번째 줄이 \u003ccode\u003ey\u003c/code\u003e에서 \u003ccode\u003ez\u003c/code\u003e로 변경된다면, Python 3.12와 마찬가지로 여전히 \u003ccode\u003eNameError\u003c/code\u003e가 발생합니다. \u003ccode\u003eframe.f_locals\u003c/code\u003e에 추가되었지만 어휘적으로(lexically) 지역 변수가 아닌 키는 \u003ccode\u003eframe.f_locals\u003c/code\u003e에는 계속 표시되지만, 동적으로 지역 변수가 되지는 않습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003elocals()\u003c/code\u003e 변경 사항 (\u003ccode\u003elocals()\u003c/code\u003e changes)\u003c/h4\u003e\n\u003cp\u003e다음 예시를 고려해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef f():\r\n    exec(\"x = 1\")\r\n    print(locals().get(\"x\"))\r\nf()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 PEP의 변경 사항을 적용하면, 이 코드는 항상 \u003ccode\u003eNone\u003c/code\u003e을 출력합니다. (\u003ccode\u003ex\u003c/code\u003e가 함수에 정의된 지역 변수인지 여부와 관계없이) 이는 \u003ccode\u003elocals()\u003c/code\u003e에 대한 명시적 호출이 \u003ccode\u003eexec()\u003c/code\u003e 호출에서 암시적으로 사용되는 것과 다른 별개의 스냅샷을 생성하기 때문입니다.\u003c/p\u003e\n\u003cp\u003ePython 3.12에서는 위 예시가 \u003ccode\u003e1\u003c/code\u003e을 출력했지만, 함수 정의에 대한 겉보기에는 관련 없는 변경으로 인해 \u003ccode\u003eNone\u003c/code\u003e을 출력할 수도 있었습니다. (PEP 558의 'Additional considerations for eval() and exec() in exec() and eval() in optimized scopes' 섹션에 이 주제에 대한 자세한 내용이 있습니다.)\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eeval()\u003c/code\u003e 및 \u003ccode\u003eexec()\u003c/code\u003e 변경 사항 (\u003ccode\u003eeval()\u003c/code\u003e and \u003ccode\u003eexec()\u003c/code\u003e changes)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eeval()\u003c/code\u003e 및 \u003ccode\u003eexec()\u003c/code\u003e에 영향을 미치는 주요 변경 사항은 \"locals() 변경 사항\" 예시에서 보여집니다. 최적화된 스코프에서 \u003ccode\u003elocals()\u003c/code\u003e에 반복적으로 접근하는 것이 더 이상 암시적으로 공통의 기본 네임스페이스를 공유하지 않게 됩니다.\u003c/p\u003e\n\u003ch3\u003eC API 변경 사항 (C API changes)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003ePyFrame_GetLocals\u003c/code\u003e 변경 사항 (\u003ccode\u003ePyFrame_GetLocals\u003c/code\u003e change)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ePyFrame_GetLocals\u003c/code\u003e는 이미 Python 3.12에서 임의의 매핑을 반환할 수 있었습니다. \u003ccode\u003eexec()\u003c/code\u003e 및 \u003ccode\u003eeval()\u003c/code\u003e은 \u003ccode\u003elocals\u003c/code\u003e 인수로 임의의 매핑을 허용하며, 메타클래스(metaclass)는 \u003ccode\u003e__prepare__\u003c/code\u003e 메서드에서 임의의 매핑을 반환할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e최적화된 스코프에서 프레임 로컬 프록시(frame locals proxy)를 반환하는 것은 내장 딕셔너리가 아닌 다른 것이 반환되는 또 다른 경우를 추가할 뿐입니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003ePyEval_GetLocals\u003c/code\u003e 변경 사항 (\u003ccode\u003ePyEval_GetLocals\u003c/code\u003e change)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ePyEval_GetLocals()\u003c/code\u003e의 의미론(semantics)은 기술적으로 변경되지 않았지만, 실제로는 변경됩니다. 최적화된 프레임에 캐시된 딕셔너리가 더 이상 프레임 로컬에 접근하는 다른 메커니즘( \u003ccode\u003elocals()\u003c/code\u003e 내장 함수, \u003ccode\u003ePyFrame_GetLocals\u003c/code\u003e 함수, \u003ccode\u003eframe.f_locals\u003c/code\u003e 속성)과 공유되지 않기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003ch3\u003ePython API 호환성 (Python API compatibility)\u003c/h3\u003e\n\u003cp\u003ePython 3.12 이하 버전에서 사용된 구현은 많은 예외적인 경우(corner cases)와 특이한 점이 있었습니다. 이러한 문제를 해결하기 위해 작성된 코드는 변경해야 할 수도 있습니다. 단순한 템플릿(templating)이나 \u003ccode\u003eprint\u003c/code\u003e 디버깅을 위해 \u003ccode\u003elocals()\u003c/code\u003e를 사용하는 코드는 계속해서 올바르게 작동할 것입니다. 디버거와 \u003ccode\u003ef_locals\u003c/code\u003e를 사용하여 지역 변수를 수정하는 다른 도구들은 이제 스레드 코드, 코루틴, 제너레이터와 같은 동시성(concurrent) 코드 실행 메커니즘이 있는 경우에도 올바르게 작동할 것입니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eframe.f_locals\u003c/code\u003e 호환성 (\u003ccode\u003eframe.f_locals\u003c/code\u003e compatibility)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ef.f_locals\u003c/code\u003e는 함수의 네임스페이스인 것처럼 동작하지만, 몇 가지 눈에 띄는 차이점이 있습니다. 예를 들어, 최적화된 프레임의 경우 \u003ccode\u003ef.f_locals is f.f_locals\u003c/code\u003e는 \u003ccode\u003eFalse\u003c/code\u003e가 됩니다. 이는 속성에 접근할 때마다 새로운 write-through proxy 인스턴스가 생성되기 때문입니다.\u003c/p\u003e\n\u003cp\u003e그러나 \u003ccode\u003ef.f_locals == f.f_locals\u003c/code\u003e는 \u003ccode\u003eTrue\u003c/code\u003e이며, 매핑 키로 새 변수 이름을 추가하는 것을 포함하여 어떤 방식으로든 기본 변수에 대한 모든 변경은 항상 확인할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003elocals()\u003c/code\u003e 호환성 (\u003ccode\u003elocals()\u003c/code\u003e compatibility)\u003c/h4\u003e\n\u003cp\u003e최적화된 프레임의 경우 \u003ccode\u003elocals() is locals()\u003c/code\u003e는 \u003ccode\u003eFalse\u003c/code\u003e이므로, 다음 코드와 같은 코드는 \u003ccode\u003e1\u003c/code\u003e을 반환하는 대신 \u003ccode\u003eKeyError\u003c/code\u003e를 발생시킵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef f():\r\n    locals()[\"x\"] = 1\r\n    return locals()[\"x\"]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 코드가 계속 작동하려면, 이전의 암시적인 프레임 객체 캐싱에 의존하는 대신 수정할 네임스페이스를 지역 변수에 명시적으로 저장해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef f():\r\n    ns = {}\r\n    ns[\"x\"] = 1\r\n    return ns[\"x\"]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 기술적으로 공식적인 하위 호환성 파기(formal backwards compatibility break)는 아닙니다. (\u003ccode\u003elocals()\u003c/code\u003e에 다시 쓰는 동작이 명시적으로 정의되지 않은 것으로 문서화되었기 때문입니다.) 하지만 기존 동작에 의존하는 코드가 분명히 존재합니다. 따라서 업데이트된 동작은 문서에 변경 사항으로 명시적으로 기록될 것이며, Python 3.13 포팅 가이드(porting guide)에서 다룰 예정입니다.\u003c/p\u003e\n\u003cp\u003ePython 3.13 이상에서 중복 복사본을 만들지 않고 모든 버전의 최적화된 스코프에서 \u003ccode\u003elocals()\u003c/code\u003e의 복사본으로 작업하려면, 사용자는 Python 3.13 이전 버전에서만 명시적으로 복사본을 만드는 버전 종속 헬퍼 함수를 정의해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport sys\r\n\r\nif sys.version_info \u003e= (3, 13):\r\n    def _ensure_func_snapshot(d):\r\n        return d # 3.13+ locals()는 이미 스냅샷을 반환함\r\nelse:\r\n    def _ensure_func_snapshot(d):\r\n        return dict(d) # 이전 버전에서는 스냅샷 생성\r\n\r\ndef f():\r\n    ns = _ensure_func_snapshot(locals())\r\n    ns[\"x\"] = 1\r\n    return ns\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 스코프에서는 \u003ccode\u003elocals().copy()\u003c/code\u003e를 무조건 호출해도 중복 복사본이 생성되지 않습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eexec()\u003c/code\u003e 및 \u003ccode\u003eeval()\u003c/code\u003e에 미치는 영향 (Impact on exec() and eval())\u003c/h4\u003e\n\u003cp\u003e이 PEP가 \u003ccode\u003eexec()\u003c/code\u003e 또는 \u003ccode\u003eeval()\u003c/code\u003e을 직접 수정하지는 않지만, \u003ccode\u003elocals()\u003c/code\u003e에 대한 의미론적 변경은 \u003ccode\u003eexec()\u003c/code\u003e 및 \u003ccode\u003eeval()\u003c/code\u003e의 동작에 영향을 미칩니다. 이는 기본적으로 호출하는 네임스페이스에서 코드를 실행하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이는 일부 코드에 잠재적인 호환성 문제를 제기합니다. 이전 구현에서는 함수 스코프에서 \u003ccode\u003elocals()\u003c/code\u003e가 여러 번 호출될 때 동일한 딕셔너리를 반환했기 때문에, 다음 코드는 암시적으로 공유된 지역 변수 네임스페이스 덕분에 일반적으로 작동했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef f():\r\n    exec('a = 0') # exec('a = 0', globals(), locals())와 동일\r\n    exec('print(a)') # exec('print(a)', globals(), locals())와 동일\r\n    print(locals()) # {'a': 0}\r\n    # 그러나, 여기서 print(a)는 작동하지 않을 것임\r\nf()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 PEP의 \u003ccode\u003elocals()\u003c/code\u003e에 대한 의미론적 변경으로 인해, \u003ccode\u003eexec('print(a)')\u003c/code\u003e 호출은 \u003ccode\u003eNameError\u003c/code\u003e로 실패하고, \u003ccode\u003eprint(locals())\u003c/code\u003e는 빈 딕셔너리를 보고합니다. 각 줄이 프레임 객체에 저장된 단일 캐시된 스냅샷을 암시적으로 공유하는 대신, 자체적인 별개의 지역 변수 스냅샷을 사용하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eexec()\u003c/code\u003e 호출 간에 공유 네임스페이스를 얻으려면, 이전에 암시적으로 공유되던 프레임 네임스페이스에 의존하는 대신 명시적인 네임스페이스를 사용해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef f():\r\n    ns = {}\r\n    exec('a = 0', locals=ns)\r\n    exec('print(a)', locals=ns) # 0\r\nf()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eframe.f_locals\u003c/code\u003e를 명시적으로 사용하여 지역 스코프의 변수를 안정적으로 변경할 수도 있습니다. (이전에는 \u003ccode\u003ectypes\u003c/code\u003e를 사용하여 \u003ccode\u003ePyFrame_LocalsToFast\u003c/code\u003e를 호출하는 것도 이 PEP의 다른 곳에서 논의된 상태 불일치 문제의 영향을 받았습니다.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport sys\r\n\r\ndef f():\r\n    a = None\r\n    exec('a = 0', locals=sys._getframe().f_locals)\r\n    print(a) # 0\r\nf()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모듈(module) 및 클래스(class) 스코프(중첩된 호출 포함)에 대한 \u003ccode\u003eexec()\u003c/code\u003e 및 \u003ccode\u003eeval()\u003c/code\u003e의 동작은 변경되지 않습니다. 해당 스코프에서 \u003ccode\u003elocals()\u003c/code\u003e의 동작이 변경되지 않기 때문입니다.\u003c/p\u003e\n\u003ch4\u003e표준 라이브러리의 다른 코드 실행 API에 미치는 영향 (Impact on other code execution APIs in the standard library)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003epdb\u003c/code\u003e 및 \u003ccode\u003ebdb\u003c/code\u003e는 \u003ccode\u003eframe.f_locals\u003c/code\u003e API를 사용하므로, 최적화된 프레임에서도 지역 변수를 안정적으로 업데이트할 수 있습니다. 이 PEP를 구현하면 디버거가 활성화된 동안 스레드, 제너레이터, 코루틴 및 기타 동시성 코드 실행 메커니즘과 관련된 이러한 모듈의 여러 오랜 버그가 해결될 것입니다.\u003c/p\u003e\n\u003cp\u003e표준 라이브러리의 다른 코드 실행 API(\u003ccode\u003ecode\u003c/code\u003e 모듈 등)는 \u003ccode\u003elocals()\u003c/code\u003e 또는 \u003ccode\u003eframe.f_locals\u003c/code\u003e에 암시적으로 접근하지 않습니다. 하지만 이 PEP의 나머지 부분에서 설명하는 바와 같이 이러한 네임스페이스를 명시적으로 전달하는 동작은 변경될 것입니다. (최적화된 스코프에서 \u003ccode\u003elocals()\u003c/code\u003e를 전달하면 더 이상 호출 간에 코드 실행 네임스페이스가 암시적으로 공유되지 않으며, 최적화된 스코프에서 \u003ccode\u003eframe.f_locals\u003c/code\u003e를 전달하면 지역 변수 및 비지역 셀(nonlocal cell) 참조를 안정적으로 수정할 수 있습니다.)\u003c/p\u003e\n\u003ch3\u003eC API 호환성 (C API compatibility)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003ePyEval_GetLocals\u003c/code\u003e 호환성 (\u003ccode\u003ePyEval_GetLocals\u003c/code\u003e compatibility)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ePyEval_GetLocals()\u003c/code\u003e는 Python 수준에서 \u003ccode\u003elocals()\u003c/code\u003e를 에뮬레이트하는지 \u003ccode\u003esys._getframe().f_locals\u003c/code\u003e를 에뮬레이트하는지를 역사적으로 구분하지 않았습니다. 이는 모두 지역 변수 바인딩의 동일한 공유 캐시에 대한 참조를 반환했기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이 PEP를 통해 \u003ccode\u003elocals()\u003c/code\u003e는 최적화된 프레임에 대한 각 호출에서 독립적인 스냅샷을 반환하도록 변경됩니다. \u003ccode\u003eframe.f_locals\u003c/code\u003e (\u003ccode\u003ePyFrame_GetLocals\u003c/code\u003e와 함께)는 새로운 write-through proxy 인스턴스를 반환하도록 변경됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyEval_GetLocals()\u003c/code\u003e는 빌려온 참조를 반환하기 때문에, 이 두 대안 중 어느 하나에 맞춰 의미론을 업데이트하는 것이 불가능합니다. 따라서 프레임 객체에 저장된 공유 캐시 딕셔너리를 필요로 하는 유일한 남아있는 API가 됩니다.\u003c/p\u003e\n\u003cp\u003e이것이 기술적으로 함수의 의미론을 변경하지는 않지만, 다른 API 사용자가 추가 딕셔너리 항목을 볼 수 없게 합니다. 이는 해당 API가 더 이상 동일한 기본 캐시 딕셔너리에 접근하지 않기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyEval_GetLocals()\u003c/code\u003e가 Python \u003ccode\u003elocals()\u003c/code\u003e 내장 함수와 동일하게 사용되는 경우, 대신 \u003ccode\u003ePyEval_GetFrameLocals()\u003c/code\u003e를 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003e이 코드는:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003elocals = PyEval_GetLocals();\r\nif (locals == NULL) {\r\n    goto error_handler;\r\n}\r\nPy_INCREF(locals);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 대체되어야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e// Python 코드의 \"locals()\"와 동일\r\nlocals = PyEval_GetFrameLocals();\r\nif (locals == NULL) {\r\n    goto error_handler;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ePyEval_GetLocals()\u003c/code\u003e가 Python에서 \u003ccode\u003esys._getframe().f_locals\u003c/code\u003e를 호출하는 것과 동일하게 사용되는 경우, \u003ccode\u003ePyEval_GetFrame()\u003c/code\u003e 결과에 대해 \u003ccode\u003ePyFrame_GetLocals()\u003c/code\u003e를 호출하여 대체해야 합니다.\u003c/p\u003e\n\u003cp\u003e이러한 경우, 원본 코드는 다음으로 대체되어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e// Python 코드의 \"sys._getframe()\"과 동일\r\nframe = PyEval_GetFrame();\r\nif (frame == NULL) {\r\n    goto error_handler;\r\n}\r\n// Python 코드의 \"frame.f_locals\"와 동일\r\nlocals = PyFrame_GetLocals(frame);\r\nframe = NULL; // 빌려온 참조의 가시성 최소화\r\nif (locals == NULL) {\r\n    goto error_handler;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003ePEP 709 인라인 컴프리헨션(Inlined Comprehensions)에 미치는 영향 (Impact on PEP 709 inlined comprehensions)\u003c/h3\u003e\n\u003cp\u003e함수 내의 인라인 컴프리헨션의 경우, \u003ccode\u003elocals()\u003c/code\u003e는 현재 컴프리헨션 내부 또는 외부에서 동일하게 동작하며, 이는 변경되지 않을 것입니다. 함수 내의 \u003ccode\u003elocals()\u003c/code\u003e 동작은 일반적으로 이 PEP의 나머지 부분에서 명시된 대로 변경됩니다.\u003c/p\u003e\n\u003cp\u003e모듈 또는 클래스 스코프의 인라인 컴프리헨션의 경우, 인라인 컴프리헨션 내에서 \u003ccode\u003elocals()\u003c/code\u003e를 호출하면 각 호출마다 새로운 딕셔너리를 반환합니다. 이 PEP는 함수 내의 \u003ccode\u003elocals()\u003c/code\u003e도 각 호출마다 항상 새로운 딕셔너리를 반환하도록 하여 일관성을 향상시킵니다. 클래스 또는 모듈 스코프의 인라인 컴프리헨션은 인라인 컴프리헨션이 여전히 별개의 함수인 것처럼 동작할 것입니다.\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eframe.f_locals\u003c/code\u003e를 읽을 때마다 지역 변수(셀(cell) 및 자유(free) 변수 포함) 이름과 해당 지역 변수 값의 매핑처럼 보이는 새로운 프록시(proxy) 객체가 생성됩니다.\u003c/p\u003e\n\u003cp\u003e가능한 구현 스케치(sketch)는 다음과 같습니다. 밑줄로 시작하는 모든 속성은 보이지 않으며 직접 접근할 수 없습니다. 이는 제안된 설계를 설명하기 위한 것입니다.\u003c/p\u003e\n\u003ch3\u003eC API\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ePyEval_GetLocals()\u003c/code\u003e는 대략 다음과 같이 구현됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003ePyObject *PyEval_GetLocals(void) {\r\n    PyFrameObject * = ...; // 현재 프레임 가져오기.\r\n    if (frame-\u003e_locals_cache == NULL) {\r\n        frame-\u003e_locals_cache = PyEval_GetFrameLocals();\r\n    } else {\r\n        PyDict_Update(frame-\u003e_locals_cache, PyFrame_GetLocals(frame));\r\n    }\r\n    return frame-\u003e_locals_cache;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e빌려온 참조를 반환하는 모든 함수와 마찬가지로, 참조가 객체의 수명(lifetime)을 넘어 사용되지 않도록 주의해야 합니다.\u003c/p\u003e\n\u003ch3\u003e구현 노트 (Implementation Notes)\u003c/h3\u003e\n\u003cp\u003ePEP 텍스트가 승인되었을 때, \u003ccode\u003ePyEval_GetLocals\u003c/code\u003e는 새로운 write-through proxy의 캐시된 인스턴스를 반환하기 시작할 것을 제안했지만, 구현 스케치는 프레임 인스턴스에 캐시된 딕셔너리 스냅샷을 계속 반환할 것을 나타냈습니다. 이 불일치는 PEP를 구현하는 동안 확인되었으며, 스티어링 위원회(Steering Council)에서 Python 3.12의 동작을 유지하는 방향으로 해결되었습니다. (즉, 프레임 인스턴스에 캐시된 딕셔너리 스냅샷을 반환). PEP 텍스트는 이에 따라 업데이트되었습니다.\u003c/p\u003e\n\u003cp\u003eC API 명확화 논의 중에, 최적화된 스코프에서 \u003ccode\u003elocals()\u003c/code\u003e가 독립적인 스냅샷을 반환하도록 업데이트된 이유가 명확하지 않다는 점도 드러났습니다. 이는 이 PEP에서 독립적으로 다루기보다는 원래 PEP 558 논의에서 상속되었기 때문입니다. PEP 텍스트는 이 변경 사항을 더 잘 다루도록 업데이트되었으며, \u003ccode\u003eSpecification\u003c/code\u003e 및 \u003ccode\u003eBackwards Compatibility\u003c/code\u003e 섹션에 추가 업데이트가 포함되어 \u003ccode\u003elocals()\u003c/code\u003e 네임스페이스에서 코드를 실행하는 코드 실행 API에 미치는 영향을 다룹니다. 추가 동기 및 근거 세부 정보도 PEP 558에 추가되었습니다.\u003c/p\u003e\n\u003cp\u003ePython 3.13.0에서는 write-through proxy가 \u003ccode\u003edel\u003c/code\u003e 및 \u003ccode\u003epop()\u003c/code\u003e을 사용하여 추가 변수도 삭제하는 것을 허용하지 않았습니다. 이는 이후 호환성 회귀(compatibility regression)로 보고되었으며, 현재 'frame.f_locals 속성' 섹션에서 설명하는 대로 해결되었습니다.\u003c/p\u003e\n\u003ch3\u003ePEP 558과의 비교 (Comparison with PEP 558)\u003c/h3\u003e\n\u003cp\u003e이 PEP와 PEP 558은 \u003ccode\u003elocals()\u003c/code\u003e 및 \u003ccode\u003eframe.f_locals()\u003c/code\u003e의 의미론을 이해하기 쉽고, 그 동작을 안정적으로 만드는 공통 목표를 공유했습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP와 PEP 558의 주요 차이점은 PEP 558이 레거시 \u003ccode\u003ePyEval_GetLocals()\u003c/code\u003e API와의 하위 호환성을 개선하기 위해 지역 변수의 전체 내부 딕셔너리 복사본 내부에 추가 변수를 저장하려고 시도한 반면, 이 PEP는 그렇지 않다는 것입니다. (이 PEP는 추가 지역 변수를 새로운 프레임 프록시 객체를 통해서만 접근되는 전용 딕셔너리에 저장하고, 요청 시에만 \u003ccode\u003ePyEval_GetLocals()\u003c/code\u003e 공유 딕셔너리에 복사합니다.)\u003c/p\u003e\n\u003cp\u003ePEP 558은 해당 내부 복사본이 언제 업데이트되는지 정확히 명시하지 않아, 이 PEP가 잘 명시된 여러 경우에 PEP 558의 동작을 추론하기 어렵게 만들었습니다.\u003c/p\u003e\n\u003cp\u003ePEP 558은 또한 확장 모듈이 현재 활성 Python 스코프가 최적화되었는지 여부를 더 쉽게 판단하고, 따라서 C API의 \u003ccode\u003elocals()\u003c/code\u003e와 동등한 것이 프레임의 지역 실행 네임스페이스에 대한 직접 참조를 반환하는지 아니면 프레임의 지역 변수 및 비지역 셀 참조의 얕은 복사본을 반환하는지 알 수 있도록 하는 몇 가지 추가 Python 스코프 인트로스펙션(introspection) 인터페이스를 C API에 도입할 것을 제안했습니다. 이러한 인트로스펙션 API를 추가할지 여부는 \u003ccode\u003elocals()\u003c/code\u003e 및 \u003ccode\u003eframe.f_locals\u003c/code\u003e에 제안된 변경 사항과 독립적이므로, 이 PEP에는 그러한 제안이 포함되지 않았습니다.\u003c/p\u003e\n\u003cp\u003ePEP 558은 결국 이 PEP를 위해 철회되었습니다.\u003c/p\u003e\n\u003ch2\u003e참조 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003e구현은 GitHub에서 드래프트 풀 리퀘스트(draft pull request)로 개발 중입니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain) 또는 CC0-1.0-Universal 라이선스(둘 중 더 관대한 라이선스)에 따라 제공됩니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1962,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 667 - Consistent views of namespaces\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 10:03:19+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/666/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 666 - Reject Foolish Indentation\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 667 - Consistent views of namespaces\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/668/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Accepted] PEP 668 - Marking Python base environments as “externally managed”\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>