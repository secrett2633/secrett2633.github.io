3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-aea36c7c8fc4866f.js","185","static/chunks/app/layout-b06e577e11976c7d.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-eb985a9c6ac1f073.js"],""]
4:["slug","python/pep/302","c"]
0:["IohWMDsTTjKMLrs8H0jIq",[[["",{"children":[["slug","python/pep/302","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"302\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/302","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/edf391eeca43d999.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T6045,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0302/">PEP 302 - New Import Hooks</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 19-Dec-2002</p>
</blockquote>
<h1>PEP 302 – 새로운 임포트 훅 (New Import Hooks)</h1>
<ul>
<li><strong>작성자</strong>: Just van Rossum, Paul Moore</li>
<li><strong>상태</strong>: Final (최종)</li>
<li><strong>유형</strong>: Standards Track (표준 트랙)</li>
<li><strong>작성일</strong>: 2002년 12월 19일</li>
<li><strong>Python 버전</strong>: 2.3</li>
</ul>
<p><strong>경고</strong>: 임포트에 대한 언어 참조 및 <code>importlib</code> 문서가 현재 이 PEP를 대체합니다. 이 문서는 더 이상 업데이트되지 않으며 역사적 목적으로만 제공됩니다.</p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 Python 임포트 메커니즘을 더 잘 사용자 정의할 수 있는 새로운 임포트 훅 세트를 추가할 것을 제안합니다. 기존의 <code>__import__</code> 훅과 달리, 새로운 방식의 훅은 기존 스키마에 주입(inject)될 수 있어 모듈이 발견되고 로드되는 방식에 대해 더 세밀한 제어가 가능합니다.</p>
<h2>동기 (Motivation)</h2>
<p>현재 임포트 메커니즘을 사용자 정의하는 유일한 방법은 내장 함수인 <code>__import__</code>를 오버라이드(override)하는 것입니다. 하지만 <code>__import__</code>를 오버라이드하는 것은 다음과 같은 여러 가지 문제를 가지고 있습니다.</p>
<ul>
<li><code>__import__</code>를 대체하는 코드는 전체 임포트 메커니즘을 완전히 재구현하거나, 사용자 정의 코드 전후에 원래 <code>__import__</code>를 호출해야 합니다. 이는 매우 복잡한 의미와 책임을 가집니다.</li>
<li><code>__import__</code>는 <code>sys.modules</code>에 이미 있는 모듈에 대해서도 호출되는데, 이는 모니터링 도구를 작성하는 경우가 아니라면 거의 원하지 않는 동작입니다.</li>
<li>C 언어에서 임포트 메커니즘을 확장해야 할 경우, 현재는 Python의 <code>import.c</code>를 직접 수정하거나 <code>import.c</code>의 많은 부분을 처음부터 재구현하는 것 외에는 불가능합니다.</li>
</ul>
<p>과거에는 <code>__import__</code> 훅을 기반으로 임포트 메커니즘을 확장하는 다양한 Python 도구들이 있었습니다 (<code>ihooks.py</code>, <code>imputil.py</code>, <code>iu.py</code> 등). 하지만 이러한 도구들은 Python으로 작성되었기 때문에 부트스트랩(bootstrapping) 문제 등 유용성에 한계가 있었습니다. 예를 들어, 전체 표준 라이브러리를 임포트 훅에서 로드하려면 훅 자체가 C로 작성되어야 했습니다.</p>
<h2>사용 사례 (Use cases)</h2>
<p>이 섹션에서는 임포트 훅에 의존하는 몇 가지 기존 애플리케이션을 나열합니다. 당시 더 유연한 임포트 훅이 있었다면 절약할 수 있었을 많은 중복 작업이 수행되었습니다. 이 PEP는 미래의 유사한 프로젝트들을 훨씬 더 쉽게 만들 것입니다.</p>
<p>임포트 메커니즘의 확장은 모듈이 비표준적인 방식으로 저장되어 있을 때 필요합니다. 예를 들어, 다음과 같은 경우입니다.</p>
<ul>
<li>아카이브(archive) 안에 함께 묶인 모듈들</li>
<li><code>.pyc</code> 형식 파일에 저장되지 않은 바이트코드(byte code)</li>
<li>네트워크를 통해 데이터베이스에서 로드되는 모듈</li>
</ul>
<p>이 PEP에 대한 작업은 부분적으로 Zip 아카이브에서 임포트하는 기능을 Python에 내장 기능으로 추가하는 PEP 273의 구현에 의해 촉발되었습니다. PEP 273 구현은 <code>import.c</code>에 많은 코드를 추가해야 했는데, 이는 기존 <code>import.c</code>의 한계 때문이었습니다.</p>
<p>최종 사용자를 위한 애플리케이션 패키징(packaging)은 임포트 훅의 전형적인 사용 사례입니다. 많은 소스 파일이나 <code>.pyc</code> 파일을 배포하는 것이 항상 적절하지 않으므로 (별도의 Python 설치는 말할 것도 없고), 필요한 모든 모듈을 단일 파일로 묶으려는 요구가 자주 있었습니다. 이러한 요구로 인해 <code>Freeze</code>, <code>Squeeze</code>, <code>Installer</code>, <code>py2exe</code>, <code>BuildApplication</code>과 같은 여러 솔루션이 구현되었습니다. 이 PEP에서 제안하는 훅은 <code>import.c</code>에 하드코딩된 훅을 제거하고, <code>__import__</code> 기반 도구들이 <code>import.c</code> 에뮬레이션(emulation) 코드를 대부분 없앨 수 있도록 할 것입니다.</p>
<h2>근거 (Rationale)</h2>
<p>내장 Zip 임포트를 구현하기 위한 대안적인 아이디어를 실험하던 중, <code>import.c</code>에 비교적 적은 변경만으로도 이것이 가능하다는 것이 발견되었습니다. 이로 인해 Zip 관련 특정 기능을 새로운 소스 파일로 분리하는 동시에, 일반적인 새로운 임포트 훅 스키마(현재 이 PEP에서 설명하는 방식)를 만들 수 있게 되었습니다.</p>
<p>초기 디자인에서는 <code>sys.path</code>에 문자열이 아닌 객체를 허용했습니다. 이러한 객체는 임포트를 처리하는 데 필요한 메서드를 가질 수 있었습니다. 하지만 이 방식은 두 가지 단점이 있었습니다.</p>
<ol>
<li><code>sys.path</code>의 모든 항목이 문자열이라고 가정하는 코드를 깨뜨립니다.</li>
<li><code>PYTHONPATH</code> 환경 변수와 호환되지 않습니다.</li>
</ol>
<p>이후 Jython에서 아이디어를 얻어 <code>sys.path</code>에 문자열 서브클래스를 허용하는 타협안이 제시되었으나, "보기 흉한 해킹"으로 인식되었습니다.</p>
<p>결과적으로, 각 <code>sys.path</code> 항목을 처리할 수 있는지 <code>sys.path_hooks</code>의 후보 목록을 순회하며 묻는 방식(McMillan의 <code>iu.py</code>에서 대부분 복사)이 채택되었습니다. 이 후보 목록은 <code>sys</code> 모듈의 새로운 객체인 <code>sys.path_hooks</code>입니다.</p>
<p>각 새로운 임포트 시 <code>sys.path_hooks</code>를 순회하는 것은 비용이 많이 들 수 있으므로, 그 결과는 <code>sys.path_importer_cache</code>라는 또 다른 <code>sys</code> 모듈의 새로운 객체에 캐시됩니다. 이것은 <code>sys.path</code> 항목을 임포터(importer) 객체에 매핑합니다.</p>
<p><code>import.c</code>에 미치는 영향을 최소화하고 추가 오버헤드를 피하기 위해, 기존 파일 시스템 임포트 로직에 대한 명시적인 훅이나 임포터 객체를 추가하지 않고, <code>sys.path_hooks</code>의 어떤 훅도 경로 항목을 처리할 수 없을 경우 단순히 내장 로직으로 폴백(fall back)하도록 선택되었습니다. 이 경우 <code>None</code> 값이 <code>sys.path_importer_cache</code>에 저장되어 반복적인 조회를 피합니다.</p>
<p><code>sys.path</code> 항목이 필요 없는 임포터(예: 내장 및 프로즌 모듈)에 대한 질문이 제기되었고, Gordon McMillan의 <code>iu.py</code>에 있는 "메타패스(metapath)" 개념이 도입되었습니다. 이 PEP의 구현에서는 <code>sys.path</code>가 순회되기 전에 순회되는 임포터 객체 목록이며, <code>sys.meta_path</code>라는 새로운 <code>sys</code> 모듈 객체입니다.</p>
<h2>사양 1부: 임포터 프로토콜 (Specification part 1: The Importer Protocol)</h2>
<p>이 PEP는 "임포터 프로토콜"이라는 새로운 프로토콜을 소개합니다. 프로토콜이 작동하는 컨텍스트를 이해하는 것이 중요하므로, 임포트 메커니즘의 외부 흐름을 간략하게 설명합니다.</p>
<p><code>import</code> 문이 나타나면 인터프리터는 내장 이름 공간에서 <code>__import__</code> 함수를 찾습니다. <code>__import__</code>는 모듈 이름과 현재 전역 이름 공간에 대한 참조를 포함한 네 가지 인수로 호출됩니다. 내장 <code>__import__</code> 함수는 모듈이 패키지 또는 패키지의 서브모듈인지 확인하고, 해당될 경우 패키지에 상대적으로 임포트를 시도합니다. 실패하면 절대 임포트(absolute import)로 진행됩니다.</p>
<p>임포터 프로토콜은 개별 임포트 수준에서 작동합니다. <code>spam.ham</code> 임포트 요청이 임포터에게 전달될 때, <code>spam</code> 모듈은 이미 임포트되어 있습니다.</p>
<p>프로토콜은 <code>finder</code>와 <code>loader</code>, 두 가지 객체를 포함합니다.</p>
<h3>Finder (파인더)</h3>
<p><code>finder</code> 객체는 단일 메서드를 가집니다.</p>
<ul>
<li><code>finder.find_module(fullname, path=None)</code>
<ul>
<li>이 메서드는 모듈의 완전한 이름(fully qualified name)으로 호출됩니다.</li>
<li><code>finder</code>가 <code>sys.meta_path</code>에 설치된 경우, 두 번째 인수로 최상위 모듈에 대해서는 <code>None</code>을, 서브모듈 또는 서브패키지에 대해서는 <code>package.__path__</code>를 받습니다.</li>
<li>모듈을 찾으면 <code>loader</code> 객체를 반환하고, 찾지 못하면 <code>None</code>을 반환해야 합니다.</li>
<li><code>find_module()</code>이 예외를 발생시키면 호출자에게 전파되어 임포트가 중단됩니다.</li>
</ul>
</li>
</ul>
<h3>Loader (로더)</h3>
<p><code>loader</code> 객체도 하나의 메서드를 가집니다.</p>
<ul>
<li><code>loader.load_module(fullname)</code>
<ul>
<li>이 메서드는 로드된 모듈을 반환하거나 예외를 발생시킵니다 (기존 예외가 전파되지 않는 경우 <code>ImportError</code>가 바람직합니다).</li>
<li>로드할 수 없는 모듈을 로드하도록 요청받으면 <code>ImportError</code>를 발생시켜야 합니다.</li>
</ul>
</li>
</ul>
<p>많은 경우 <code>finder</code>와 <code>loader</code>는 동일한 객체일 수 있습니다. <code>finder.find_module()</code>은 단순히 <code>self</code>를 반환할 수 있습니다.</p>
<p>두 메서드의 <code>fullname</code> 인수는 "spam.eggs.ham"과 같은 완전한 모듈 이름입니다. <code>find_module()</code> 메서드는 실제 임포트 중에 항상 호출되는 것은 아니므로, <code>finder</code>는 <code>sys.modules</code>에 부모 패키지가 존재한다고 의존해서는 안 됩니다.</p>
<p><code>load_module()</code> 메서드는 코드를 실행하기 전에 몇 가지 책임을 이행해야 합니다.</p>
<ul>
<li><code>sys.modules</code>에 <code>fullname</code>이라는 이름의 기존 모듈 객체가 있으면 로더는 해당 객체를 사용해야 합니다.</li>
<li><code>sys.modules</code>에 <code>fullname</code>이라는 이름의 모듈이 없으면 로더는 새 모듈 객체를 생성하고 <code>sys.modules</code>에 추가해야 합니다. 이 작업은 로더가 모듈 코드를 실행하기 전에 이루어져야 합니다.</li>
<li>로드에 실패하면 로더는 <code>sys.modules</code>에 삽입했을 수 있는 모듈을 제거해야 합니다.</li>
<li><code>__file__</code> 속성이 설정되어야 합니다. 이는 문자열이어야 하며, " <code>&#x3C;frozen></code> "과 같은 더미 값일 수 있습니다. <code>__file__</code> 속성이 전혀 없는 특권은 내장 모듈에만 주어집니다.</li>
<li><code>__name__</code> 속성이 설정되어야 합니다. <code>imp.new_module()</code>을 사용하면 자동으로 설정됩니다.</li>
<li>패키지인 경우 <code>__path__</code> 변수가 설정되어야 합니다. 이는 리스트여야 하며, 임포터에게 <code>__path__</code>가 더 이상 의미가 없다면 비어있을 수 있습니다.</li>
<li><code>__loader__</code> 속성은 로더 객체로 설정되어야 합니다. 이는 주로 인트로스펙션(introspection) 및 재로드(reloading)를 위한 것입니다.</li>
<li><code>__package__</code> 속성이 설정되어야 합니다 (PEP 366).</li>
<li>모듈이 Python 모듈인 경우 (내장 모듈이나 동적으로 로드된 확장 모듈과 반대), 모듈의 전역 이름 공간( <code>module.__dict__</code> )에서 모듈 코드를 실행해야 합니다.</li>
</ul>
<p><code>load_module()</code> 메서드를 위한 최소한의 패턴은 다음과 같습니다.</p>
<pre><code class="language-python"># 대부분의 세부 사항을 처리하기 위해 importlib.util.module_for_loader()를 사용하는 것을 고려하세요.
def load_module(self, fullname):
    code = self.get_code(fullname)
    ispkg = self.is_package(fullname)
    mod = sys.modules.setdefault(fullname, imp.new_module(fullname))
    mod.__file__ = "&#x3C;%s>" % self.__class__.__name__
    mod.__loader__ = self
    if ispkg:
        mod.__path__ = []
        mod.__package__ = fullname
    else:
        mod.__package__ = fullname.rpartition('.')[0]
    exec(code, mod.__dict__)
    return mod
</code></pre>
<h2>사양 2부: 훅 등록 (Specification part 2: Registering Hooks)</h2>
<p>두 가지 유형의 임포트 훅이 있습니다: **메타 훅(Meta hooks)**과 <strong>경로 훅(Path hooks)</strong>.</p>
<h3>메타 훅 (Meta hooks)</h3>
<ul>
<li>임포트 처리 시작 시, 다른 임포트 처리보다 먼저 호출됩니다 (따라서 메타 훅은 <code>sys.path</code> 처리, 프로즌 모듈, 심지어 내장 모듈까지 재정의할 수 있습니다).</li>
<li>메타 훅을 등록하려면 <code>finder</code> 객체를 <code>sys.meta_path</code> (등록된 메타 훅 목록)에 추가하기만 하면 됩니다.</li>
<li>현재 기본적으로 비어 있습니다.</li>
</ul>
<h3>경로 훅 (Path hooks)</h3>
<ul>
<li><code>sys.path</code> (또는 <code>package.__path__</code>) 처리의 일부로, 관련 경로 항목이 발견되는 시점에 호출됩니다.</li>
<li>경로 훅은 <code>sys.path_hooks</code>에 임포터 팩토리(importer factory)를 추가하여 등록됩니다.</li>
<li><code>sys.path_hooks</code>는 콜러블(callable) 목록이며, 주어진 경로 항목을 처리할 수 있는지 순서대로 확인됩니다.</li>
<li>콜러블은 경로 항목을 처리할 수 없으면 <code>ImportError</code>를 발생시키고, 처리할 수 있으면 임포터 객체를 반환해야 합니다.</li>
<li>경로 훅 검사 결과는 <code>sys.path_importer_cache</code>에 캐시됩니다. 이 캐시는 <code>sys.path_hooks</code>를 스캔하기 전에 확인됩니다.</li>
</ul>
<p>새로운 <code>sys</code> 변수들은 <code>sys.path</code>와 마찬가지로 특정 유형을 가져야 합니다.</p>
<ul>
<li><code>sys.meta_path</code>와 <code>sys.path_hooks</code>는 Python 리스트여야 합니다.</li>
<li><code>sys.path_importer_cache</code>는 Python 딕셔너리여야 합니다.</li>
</ul>
<p>이러한 변수를 인플레이스(in-place)로 수정하거나 새 객체로 교체하는 것은 허용됩니다.</p>
<h2>패키지와 <code>__path__</code>의 역할 (Packages and the role of <strong>path</strong>)</h2>
<p>모듈이 <code>__path__</code> 속성을 가지고 있으면 임포트 메커니즘은 이를 패키지로 취급합니다. 패키지의 서브모듈을 임포트할 때 <code>sys.path</code> 대신 <code>__path__</code> 변수가 사용됩니다. 따라서 <code>sys.path</code>에 대한 규칙은 <code>pkg.__path__</code>에도 적용됩니다. 즉, <code>pkg.__path__</code>가 순회될 때 <code>sys.path_hooks</code>도 참조됩니다.</p>
<p>메타 임포터는 작업을 수행하기 위해 <code>sys.path</code>를 전혀 사용하지 않을 수 있으므로 <code>pkg.__path__</code> 값을 무시할 수 있습니다. 이 경우에도 비어 있을 수 있는 리스트로 설정하는 것이 좋습니다.</p>
<h2>임포터 프로토콜의 선택적 확장 (Optional Extensions to the Importer Protocol)</h2>
<p>임포터 프로토콜은 세 가지 선택적 확장을 정의합니다.</p>
<ol>
<li>데이터 파일 검색</li>
<li>모듈 패키징 도구 및/또는 모듈 의존성 분석 도구(예: Freeze) 지원</li>
<li>모듈을 스크립트로 실행하는 지원</li>
</ol>
<p>이 세 가지 확장 모두 일반적인 임포터에 강력히 권장되지만, 해당 기능이 필요하지 않으면 안전하게 생략할 수 있습니다.</p>
<h3>데이터 파일 검색 (<code>get_data</code>)</h3>
<p>기저 저장소 백엔드에서 임의의 "파일"에 대한 데이터를 검색하기 위해 로더 객체는 <code>get_data()</code>라는 메서드를 제공할 수 있습니다.</p>
<ul>
<li><code>loader.get_data(path)</code>: 이 메서드는 데이터를 문자열로 반환하거나 "파일"을 찾지 못하면 <code>IOError</code>를 발생시킵니다. 데이터는 항상 "이진(binary)" 모드가 사용된 것처럼 반환됩니다. 이는 파일 시스템과 유사한 속성을 가진 임포터를 위한 것입니다.</li>
</ul>
<p>예시:</p>
<pre><code class="language-python">d = os.path.dirname(__file__)
data = __loader__.get_data(os.path.join(d, "logo.gif"))
</code></pre>
<h3>패키징/분석 도구 지원 (<code>is_package</code>, <code>get_code</code>, <code>get_source</code>)</h3>
<p>Freeze와 같은 도구에 대한 지원이 필요한 경우 다음 메서드 세트를 구현할 수 있습니다. 호출자가 쉽게 사용할 수 있도록 세 가지 메서드 모두 구현하거나, 아예 구현하지 않아야 합니다.</p>
<ul>
<li><code>loader.is_package(fullname)</code>: <code>fullname</code>으로 지정된 모듈이 패키지이면 <code>True</code>, 아니면 <code>False</code>를 반환해야 합니다.</li>
<li><code>loader.get_code(fullname)</code>: 모듈과 관련된 코드 객체를 반환하거나, 내장 또는 확장 모듈인 경우 <code>None</code>을 반환해야 합니다. 소스 코드는 있지만 코드 객체가 없으면 컴파일된 소스 코드를 반환해야 합니다.</li>
<li><code>loader.get_source(fullname)</code>: 모듈의 소스 코드를 문자열로 반환하거나, 소스를 사용할 수 없으면 <code>None</code>을 반환해야 합니다.</li>
</ul>
<p>이 세 메서드 모두 모듈을 찾을 수 없으면 <code>ImportError</code>를 발생시켜야 합니다.</p>
<h3>스크립트 실행 지원 (<code>get_filename</code>)</h3>
<p>모듈을 스크립트로 실행하는 것(PEP 338)을 지원하려면 위 세 가지 메서드가 구현되어야 합니다. 또한, <code>runpy</code> 모듈이 <code>__file__</code> 속성을 올바르게 설정할 수 있도록 다음 메서드를 제공할 수 있습니다.</p>
<ul>
<li><code>loader.get_filename(fullname)</code>: 이 메서드는 명명된 모듈이 로드될 경우 <code>__file__</code>이 설정될 값을 반환해야 합니다. 모듈을 찾을 수 없으면 <code>ImportError</code>를 발생시켜야 합니다.</li>
</ul>
<h2><code>imp</code> 모듈과의 통합 (Integration with the 'imp' module)</h2>
<p>새로운 임포트 훅은 기존 <code>imp.find_module()</code> 및 <code>imp.load_module()</code> 호출에 쉽게 통합되지 않습니다. 기존 코드에 영향을 주지 않고 통합하는 것은 의문이며, <code>imp</code> 모듈에 새 함수를 추가하는 것이 더 좋습니다.</p>
<p>기존 <code>imp.find_module()</code> 및 <code>imp.load_module()</code> 호출의 의미는 "내장 임포트 메커니즘을 노출"에서 "기본적으로 훅이 없는 내장 임포트 메커니즘을 노출"로 변경됩니다. 이들은 어떤 임포트 훅도 호출하지 않습니다.</p>
<p>새로운 <code>imp</code> 모듈 함수(<code>get_loader()</code>)가 제안되었으며, 다음과 같은 패턴으로 사용됩니다.</p>
<pre><code class="language-python">loader = imp.get_loader(fullname, path)
if loader is not None:
    loader.load_module(fullname)
</code></pre>
<p>"기본" 임포트의 경우, <code>loader</code> 객체는 <code>imp.find_module()</code>의 현재 출력에 대한 래퍼(wrapper)이며, <code>loader.load_module()</code>은 해당 출력을 사용하여 <code>imp.load_module()</code>을 호출합니다.</p>
<h2>향후 호환성 (Forward Compatibility)</h2>
<p>기존 <code>__import__</code> 훅은 폴백(fallback)으로 원래 <code>__import__</code> 함수를 호출하지 않는 한, 새로운 방식의 훅을 자동으로 호출하지 않습니다. 예를 들어, <code>ihooks.py</code>, <code>iu.py</code>, <code>imputil.py</code>는 이 PEP와 호환되지 않습니다.</p>
<h2>미해결 문제 (Open Issues)</h2>
<ul>
<li><strong>데이터 파일 위치</strong>: 모듈, 특히 복잡한 패키지나 전체 애플리케이션의 경우 지원 데이터 파일이 필요합니다. 현재는 일반적으로 <code>sys.path</code> (또는 <code>package.__path__</code> 속성)를 통해 이러한 파일을 찾습니다. 이 접근 방식은 임포트 훅을 통해 로드되는 모듈에는 일반적으로 작동하지 않습니다.
<ul>
<li>해결책으로 "그렇게 하지 마세요", <code>sys.prefix</code> 기반의 표준 위치에서 찾기, 임포트 훅이 모듈 파일에 상대적인 데이터 파일에 접근하는 표준적인 방법을 제공하는 것 등이 논의되었습니다. <code>zipimport</code> 객체는 <code>__loader__</code> 속성과 <code>get_data(name)</code> 메서드를 제공하여 이러한 문제를 해결합니다.</li>
</ul>
</li>
<li><strong>사용 가능한 모듈 및 데이터 파일 목록</strong>: 임포터로부터 사용 가능한 모듈 목록이나 <code>get_data()</code> 메서드와 함께 사용할 데이터 파일 목록을 받는 것이 유용할 수 있다는 제안이 있었습니다. <code>list_modules()</code> 및 <code>list_files()</code>와 같은 확장이 고려될 수 있습니다.</li>
<li><strong>대안적인 파일 형식 또는 컴파일러</strong>: 이 PEP는 대안적인 위치에서 모듈을 로드하는 데 중점을 둡니다. 대안적인 파일 형식이나 컴파일러로 모듈을 로드하기 위한 전용 솔루션을 제공하지 않습니다.</li>
<li><strong>훅 스태킹(Stacking) 지원 부족</strong>: 이 PEP 내에서는 훅 스태킹에 대한 특별한 지원이 없습니다. 예를 들어, <code>.tar</code> 및 <code>.gz</code> 파일에서 모듈을 로드하는 별도의 훅을 결합하여 <code>tar.gz</code> 파일에서 모듈을 로드하는 훅을 작성하는 방법은 명확하지 않습니다.</li>
<li><strong><code>sys.path</code> 처리 후 훅 추가</strong>: <code>sys.meta_path</code>를 통해 <code>sys.path</code>가 처리되기 전에 실행되는 훅을 추가할 수 있지만, <code>sys.path</code>가 처리된 후에 실행되는 훅을 추가하는 동등한 방법은 없습니다.</li>
</ul>
<h2>구현 (Implementation)</h2>
<p>PEP 302 구현은 Python 2.3a1부터 Python에 통합되었습니다.
PEP 273은 PEP 302의 임포트 훅을 사용하여 구현되었습니다.</p>
<h2>참고 및 각주 (References and Footnotes)</h2>
<ul>
<li>imputil module: <code>http://docs.python.org/library/imputil.html</code></li>
<li>The Freeze tool. See also the <code>Tools/freeze/</code> directory in a Python source distribution</li>
<li>py2exe by Thomas Heller: <code>http://www.py2exe.org/</code></li>
<li><code>imp.set_frozenmodules()</code> patch: <code>http://bugs.python.org/issue642578</code></li>
<li>The path argument to <code>finder.find_module()</code> is there because the <code>pkg.__path__</code> variable may be needed at this point. It may either come from the actual parent module or be supplied by <code>imp.find_module()</code> or the proposed <code>imp.get_loader()</code> function.</li>
<li>Quixote, a framework for developing Web applications: <code>http://www.mems-exchange.org/software/quixote/</code></li>
<li>New import hooks + Import from Zip files: <code>http://bugs.python.org/issue652586</code></li>
<li>Language reference for imports: <code>http://docs.python.org/3/reference/import.html</code></li>
<li>importlib documentation: <code>http://docs.python.org/3/library/importlib.html#module-importlib</code></li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)에 배포되었습니다.</p>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1682,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 302 - New Import Hooks"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 18:08:12+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}],["$","section",null,{"className":"mt-12 border-t border-gray-200 pt-8","children":[["$","h3",null,{"className":"text-base font-semibold text-gray-900 mb-4","children":["Python"," 의 다른글"]}],["$","ul",null,{"className":"space-y-2 text-sm","children":[["$","li",null,{"className":"text-gray-500","children":["이전글"," ",["$","$L7",null,{"href":"/python/pep/301/","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Final] PEP 301 - Package Index and Metadata for Distutils"}]]}],["$","li",null,{"className":"text-gray-900 font-semibold","children":["현재글 : ","[Final] PEP 302 - New Import Hooks"]}],["$","li",null,{"className":"text-gray-500","children":["다음글"," ",["$","$L7",null,{"href":"/python/pep/303/","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Rejected] PEP 303 - Extend divmod() for Multiple Divisors"}]]}]]}]]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://blog.secrett2633.site/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://blog.secrett2633.site/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","22",{"name":"next-size-adjust"}]]
1:null
