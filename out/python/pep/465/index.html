<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 465 - A dedicated infix operator for matrix multiplication</h1><div class="page__meta"><time dateTime="2025-09-26 22:12:46+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0465/">PEP 465 - A dedicated infix operator for matrix multiplication</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 20-Feb-2014</p>
</blockquote>
<h2>PEP 465: 행렬 곱셈을 위한 전용 중위(Infix) 연산자 <code>@</code> 추가 제안</h2>
<h3>요약</h3>
<p>이 PEP는 Python에 행렬 곱셈을 위한 새로운 이항(binary) 연산자 <code>@</code>를 도입할 것을 제안합니다. 이 연산자는 파이썬 3.5부터 도입되었습니다.</p>
<h3>제안 (Specification)</h3>
<p><code>@</code> 연산자는 <code>*</code> 연산자와 동일한 연산자 우선순위와 좌측 결합성(left-associativity)을 가지며, <code>__matmul__</code> 메서드에 의해 구현됩니다. 또한, 해당 제자리(in-place) 버전인 <code>@=</code> 연산자는 <code>__imatmul__</code> 메서드를 통해 구현됩니다.</p>
<p>이러한 메서드는 내장 타입이나 표준 라이브러리 타입에는 추가되지 않습니다. 하지만 <code>numpy</code>와 같은 다수의 수치 계산 라이브러리에서 이 연산자에 대한 권장 시맨틱(semantics)에 합의를 이루었습니다.</p>
<p><strong>연산자 우선순위 및 결합성:</strong></p>
<p>| 연산자 | 우선순위/결합성 | 메서드               |
| ------ | --------------- | -------------------- |
| <code>@</code>    | <code>*</code>와 동일      | <code>__matmul__</code>, <code>__rmatmul__</code> |
| <code>@=</code>   | N/A             | <code>__imatmul__</code>        |</p>
<h3>동기 (Motivation)</h3>
<h4>개요 (Executive summary)</h4>
<p>수치 계산 코드에서는 원소별 곱셈(elementwise multiplication)과 행렬 곱셈(matrix multiplication)이라는 두 가지 중요한 연산이 Python의 <code>*</code> 연산자 사용을 두고 경쟁해왔습니다. Numeric 라이브러리가 처음 제안된 이래 약 20년 동안 이 문제를 해결하기 위한 많은 시도가 있었지만, 만족스러운 해결책은 없었습니다.</p>
<p>현재 대부분의 수치 Python 코드에서는 원소별 곱셈에 <code>*</code>를 사용하고, 행렬 곱셈에는 함수/메서드 호출 문법을 사용합니다 (<code>numpy.dot(a, b)</code> 또는 <code>a.dot(b)</code>). 그러나 이로 인해 코드가 가독성이 떨어지고 복잡해지는 문제가 발생합니다. 이 문제는 너무 심각해서 일부 코드베이스에서는 반대 규칙(행렬 곱셈에 <code>*</code>를 사용하는)을 계속 사용하며 API 파편화를 초래했습니다.</p>
<p>현재 Python 문법 내에서 수치 API를 설계하는 좋은 해결책은 없어 보이며, 단지 다양한 방식으로 나쁜 선택지만 존재합니다. 이러한 문제를 해결하기 위한 최소한의 Python 문법 변경은 행렬 곱셈을 위한 새로운 중위 연산자 하나를 추가하는 것입니다.</p>
<p>행렬 곱셈은 다른 이항 연산과 구별되는 독특한 특징들을 가지고 있으며, 전용 중위 연산자 추가에 대한 강력한 근거를 제공합니다:</p>
<ul>
<li>기존 수치 연산자와 마찬가지로, 수학, 과학, 공학의 모든 분야에서 행렬 곱셈에 중위 표기법을 사용하는 방대한 선례가 있습니다. <code>@</code>는 Python의 기존 연산자 시스템의 빈틈을 조화롭게 채워줍니다.</li>
<li><code>@</code>는 실제 코드의 가독성을 크게 향상시킵니다.</li>
<li><code>@</code>는 가독성 낮은 코드와 API 파편화로 인해 특히 어려움을 겪는 비전문 프로그래머들을 위한 학습 진입 장벽을 낮춥니다.</li>
<li><code>@</code>는 Python 사용자 커뮤니티의 상당하고 성장하는 부분에 이점을 제공할 것입니다.</li>
<li><code>@</code>는 자주 사용될 것이며, 심지어 <code>//</code>나 비트와이즈 연산자보다 더 자주 사용될 수 있다는 증거가 있습니다.</li>
<li><code>@</code>는 Python 수치 커뮤니티가 파편화를 줄이고, 모든 수치 배열 객체에 대한 단일 합의 오리 타이핑(duck type)을 표준화할 수 있도록 합니다.</li>
</ul>
<h4>현재 상황의 문제점 (Background: What's wrong with the status quo?)</h4>
<p>수치 계산 시, <code>n</code>차원 배열(n-dimensional array)은 대량의 숫자에 대해 한 번에 간단한 연산을 적용할 수 있게 하는 기본 객체입니다. <code>numpy</code>는 Python에서 이러한 배열을 제공하는 가장 유명한 라이브러리입니다.</p>
<p><code>n</code>차원 배열을 다룰 때, 곱셈을 정의하는 두 가지 방법이 있습니다:</p>
<ol>
<li>
<p><strong>원소별 곱셈 (Elementwise multiplication):</strong></p>
<pre><code>[[1, 2],    [[11, 12],    [[1 * 11, 2 * 12],
 [3, 4]] x   [13, 14]] =   [3 * 13, 4 * 14]]
</code></pre>
<p>이 방식은 <code>for</code> 루프 없이 대량의 값에 대해 빠르고 쉽게 곱셈을 수행할 수 있어 유용합니다. <code>numpy</code>와 같은 라이브러리의 배열 객체를 사용할 때, 모든 Python 연산자는 모든 차원의 배열에 대해 원소별로 작동합니다.</p>
</li>
<li>
<p><strong>행렬 곱셈 (Matrix multiplication):</strong></p>
<pre><code>[[1, 2],    [[11, 12],    [[1 * 11 + 2 * 13, 1 * 12 + 2 * 14],
 [3, 4]] x   [13, 14]] =   [3 * 11 + 4 * 13, 3 * 12 + 4 * 14]]
</code></pre>
<p>행렬 곱셈은 2D 배열(행렬)에 대해서만 정의되며, 다른 연산들과 달리 중요한 "행렬" 버전이 있는 유일한 곱셈 연산입니다. 모든 수치 응용 분야에서 매우 중요하게 사용됩니다.</p>
</li>
</ol>
<p>Python 문법은 현재 단일 곱셈 연산자 <code>*</code>만 허용하므로, 배열과 유사한 객체를 제공하는 라이브러리는 <code>*</code>를 원소별 곱셈에 사용할지, 아니면 행렬 곱셈에 사용할지 결정해야 합니다. 불행히도, 일반적인 수치 계산에서는 두 연산 모두 자주 사용되며, 두 경우 모두 함수 호출 문법보다는 중위 연산자 사용에 큰 이점이 있습니다. 이로 인해 어떤 규칙이 최적인지 불분명하며, 프로젝트 간 API 파편화가 발생합니다. 예를 들어 <code>numpy.ndarray</code>는 <code>*</code>를 원소별 곱셈에 사용하고, <code>numpy.matrix</code>는 <code>*</code>를 행렬 곱셈에 사용하여 코드 통합 시 문제를 야기합니다.</p>
<p>PEP 238이 <code>/</code>를 <code>/</code>와 <code>//</code> 두 연산자로 나눴던 것처럼, 이 PEP는 <code>*</code>를 원소별 곱셈을 위한 <code>*</code>와 행렬 곱셈을 위한 <code>@</code>로 나눌 것을 제안합니다.</p>
<h4>행렬 곱셈이 중위 연산자여야 하는 이유 (Why should matrix multiplication be infix?)</h4>
<p>현재 대부분의 Python 수치 코드는 <code>numpy.dot(a, b)</code> 또는 <code>a.dot(b)</code>와 같은 문법을 사용하여 행렬 곱셈을 수행합니다. 이 방법은 작동하지만, 전 세계 수학, 과학, 공학 분야에서 보편적으로 중위 표기법이 사용되어 왔기 때문에 가독성 측면에서 중위 연산자가 훨씬 우수합니다.</p>
<p>예를 들어, 통계 가설 검정에서 사용되는 OLS 회귀 모델의 선형 가설 검정 수식 <code>S = (Hβ − r)T(HVHT) − 1(Hβ − r)</code>을 구현하는 경우를 살펴보겠습니다.</p>
<ul>
<li><strong>현재 <code>dot</code> 함수 사용 시:</strong>
<pre><code class="language-python">S = np.dot((np.dot(H, beta) - r).T, np.dot(inv(np.dot(np.dot(H, V), H.T)), np.dot(H, beta) - r))
</code></pre>
</li>
<li><strong>현재 <code>dot</code> 메서드 사용 시:</strong>
<pre><code class="language-python">S = (H.dot(beta) - r).T.dot(inv(H.dot(V).dot(H.T))).dot(H.dot(beta) - r)
</code></pre>
</li>
<li><strong><code>@</code> 연산자 사용 시:</strong>
<pre><code class="language-python">S = (H @ beta - r).T @ inv(H @ V @ H.T) @ (H @ beta - r)
</code></pre>
</li>
</ul>
<p><code>@</code> 연산자를 사용하면 원본 수식의 기호와 코드가 1:1로 투명하게 매핑되어 훨씬 읽기 쉽습니다. <code>@</code>는 불필요한 괄호를 줄여 코드를 더 간결하고 명확하게 만들며, 전문가와 비전문가 모두에게 행렬 코드의 사용성을 크게 향상시킵니다.</p>
<h4>비전문 프로그래머에게 투명한 문법이 특히 중요한 이유 (Transparent syntax is especially crucial for non-expert programmers)</h4>
<p>많은 과학 분야 코드는 해당 분야의 전문가들이 작성하지만, 프로그래밍 전문가는 아닌 경우가 많습니다. 이러한 사용자들은 수학 공식과 코드 간의 투명한 매핑이 매우 중요하며, 이는 코드를 작성하는 데 성공하느냐 실패하느냐의 차이를 만듭니다. <code>numpy.matrix</code> 타입이 <code>*</code>를 행렬 곱셈으로 정의하는 이유도 이러한 교육적 사용 사례 때문이며, <code>@</code> 연산자는 시작 및 고급 사용자 모두에게 더 나은 문법을 제공하고, 처음부터 동일한 표기법으로 표준화할 수 있도록 돕습니다.</p>
<h4>행렬 곱셈이 틈새 시장 요구 사항에 불과한가? (But isn't matrix multiplication a pretty niche requirement?)</h4>
<p>세계는 연속 데이터로 가득 차 있으며, 컴퓨터는 이를 정교하게 처리해야 하는 요구가 점점 늘고 있습니다. 배열(Array)은 금융, 머신러닝, 3D 그래픽, 컴퓨터 비전, 로봇 공학, 운영 연구, 계량 경제학, 기상학, 전산 언어학, 추천 시스템, 신경 과학, 천문학, 생물 정보학 등 다양한 응용 분야의 공통 언어입니다. 이러한 분야의 대부분에서 Python은 전통적인 이산 데이터 구조와 현대적인 수치 데이터 유형 및 알고리즘을 우아하게 혼합할 수 있는 능력 덕분에 빠르게 지배적인 역할을 하고 있습니다.</p>
<p>2013년에는 수치 Python에 특화된 7개의 국제 컨퍼런스가 개최되었고, PyCon 2014에서는 튜토리얼의 약 20%가 행렬 사용과 관련되어 있었습니다. GitHub 코드 검색 결과(<code>2014-04-10 기준</code>), <code>numpy</code>는 <code>sys</code>, <code>os</code>, <code>re</code> 다음으로 가장 많이 임포트되는 모듈 중 하나이며, <code>subprocess</code>, <code>math</code>, <code>pickle</code>, <code>threading</code>과 같은 표준 라이브러리 모듈보다도 더 많이 임포트됩니다. 이는 수치 계산이 현대 Python 사용의 주류를 이루고 있음을 시사합니다.</p>
<p>또한, 정수 나눗셈 연산자 <code>//</code>와 같이 특정 상황에서 매우 유용한 특수 산술 연산을 위해 중위 연산자를 추가한 선례가 있습니다. <code>//</code>나 비트와이즈 연산자를 사용해본 적이 없는 Python 프로그래머가 많을 수 있지만, <code>@</code>는 <code>//</code>보다 더 틈새 시장에 속하지 않습니다.</p>
<h4><code>@</code>는 행렬 공식에 유용하지만, 얼마나 자주 사용될까? (So @ is good for matrix formulas, but how common are those really?)</h4>
<p>표준 라이브러리, scikit-learn, nipy의 코드 베이스에서 연산자 사용 빈도를 분석한 결과, 행렬 곱셈 연산(dot)은 이 두 수치 패키지에서만 약 780번 사용되었으며, 대부분의 비교 연산자(<code>!=</code>, <code>&#x3C;</code>, <code>&#x3C;=</code>, <code>>=</code>)보다 더 자주 사용됩니다. 표준 라이브러리까지 포함한 전체 코드 베이스에서는 행렬 곱셈이 비트와이즈 연산자들보다 더 자주 사용되고, <code>//</code>보다 2배 더 자주 사용됩니다. 이는 수치 프로그래밍이 일반적이고 주류 활동임을 나타냅니다.</p>
<h4>표준 라이브러리에서 사용되지 않는 연산자를 추가하는 것이 이상한가? (But isn't it weird to add an operator with no stdlib uses?)</h4>
<p>특이한 경우이기는 하지만, 중요한 것은 변경 사항이 사용자에게 이점을 제공하는지 여부입니다. <code>@</code>가 많이 사용될 것이 분명하며, 이 PEP는 Python 수치 커뮤니티가 모든 배열과 유사한 객체에 대한 표준 오리 타이핑에 최종 합의에 도달할 수 있게 하는 중요한 조각을 제공합니다. 이는 표준 라이브러리에 수치 배열 타입을 추가하는 데 필요한 전제 조건입니다.</p>
<h3>호환성 고려 사항 (Compatibility considerations)</h3>
<p>현재 Python 코드에서 <code>@</code> 토큰의 유일한 합법적인 사용처는 데코레이터에서 문장 시작 부분입니다. 새로운 연산자는 모두 중위 연산자이므로 문장 시작 부분에는 나타날 수 없습니다. 따라서 이 연산자들을 추가해도 기존 코드가 손상되지 않으며, 데코레이터 <code>@</code>와 새로운 연산자 사이에 구문 분석(parsing) 모호성도 없습니다.</p>
<p>또한, 행렬을 사용하지 않는 사용자가 이 변경 사항으로 인해 Python 언어에 대한 이해를 업데이트하는 데 드는 정신적 비용도 최소화됩니다.</p>
<h3>의도된 사용법 세부 사항 (Intended usage details)</h3>
<p>이 섹션은 정보 제공을 목적으로 하며, 배열 또는 행렬과 유사한 객체를 제공하는 여러 라이브러리가 <code>@</code>를 구현하는 방법에 대한 합의를 문서화합니다.</p>
<p><code>numpy</code> 용어를 사용하여 임의의 다차원 배열을 설명합니다.</p>
<ul>
<li><strong>2차원 입력:</strong> 일반적인 행렬로 간주하며, 전통적인 행렬 곱셈을 적용합니다. 예를 들어, <code>arr(2, 3) @ arr(3, 4)</code>는 <code>(2, 4)</code> 형태의 배열을 반환합니다.</li>
<li><strong>1차원 벡터 입력:</strong> 형태에 '1'을 앞 또는 뒤에 붙여 2차원으로 승격된 후 연산이 수행됩니다. 이로 인해 <code>matrix @ vector</code>와 <code>vector @ matrix</code> 모두 허용되며 1차원 벡터를 반환하고, <code>vector @ vector</code>는 스칼라를 반환합니다. 예를 들어:
<ul>
<li><code>arr(2, 3) @ arr(3)</code>는 <code>arr(3)</code>을 <code>(3, 1)</code> 형태의 행렬로 처리하여 <code>(2,)</code> 형태의 1차원 벡터를 반환합니다.</li>
<li><code>arr(3) @ arr(3)</code>는 내적(inner product)을 수행하여 스칼라 값을 반환합니다.
이러한 정의는 일부 경우 <code>@</code>를 비결합적(non-associative)으로 만들 수 있지만, 실제 사용 사례의 중요성 때문에 채택되었습니다.</li>
</ul>
</li>
<li><strong>2차원보다 큰 입력:</strong> 마지막 두 차원을 곱할 행렬의 차원으로 취급하고, 다른 차원에 걸쳐 '브로드캐스트(broadcast)'됩니다. 예를 들어, <code>arr(10, 2, 3) @ arr(10, 3, 4)</code>는 10개의 개별 행렬 곱셈을 수행하여 <code>(10, 2, 4)</code> 형태의 배열을 반환합니다.</li>
<li><strong>0차원 (스칼라) 입력:</strong> 오류를 발생시킵니다. 스칼라와 행렬의 곱셈은 <code>*</code> 연산자로 이미 처리됩니다.</li>
</ul>
<h3>채택 (Adoption)</h3>
<p>현재 원소별 곱셈과 행렬 곱셈에 다른 API를 사용하는 기존 Python 프로젝트들은 이 PEP의 승인에 따라 다음과 같이 전환할 계획을 가지고 있습니다.</p>
<ul>
<li><strong><code>*</code>를 원소별 곱셈에, 함수/메서드 호출을 행렬 곱셈에 사용하는 프로젝트:</strong>
<ul>
<li><code>numpy</code>, <code>pandas</code>, <code>blaze</code>, <code>theano</code> 등의 개발자들은 위에서 설명한 시맨틱을 사용하여 <code>@</code>를 구현할 의사를 표명했습니다.</li>
</ul>
</li>
<li><strong><code>*</code>를 행렬 곱셈에, 함수/메서드 호출을 원소별 곱셈에 사용하는 프로젝트:</strong>
<ul>
<li><code>numpy</code> (<code>numpy.matrix</code>), <code>scipy.sparse</code>, <code>pyoperators</code>, <code>pyviennacl</code> 등의 프로젝트는 이 PEP가 수락되면 현재 API에서 원소별 <code>*</code>, 행렬 곱셈 <code>@</code> 규칙으로 전환할 의사를 표명했습니다. 이는 이 PEP가 수락될 경우 API 파편화가 해소될 프로젝트 목록입니다.</li>
</ul>
</li>
<li><strong><code>*</code>를 행렬 곱셈에 사용하고, 원소별 행렬 곱셈에 크게 신경 쓰지 않는 프로젝트:</strong>
<ul>
<li><code>sympy</code>, <code>sage</code>와 같은 프로젝트는 추상 수학적 객체로서의 행렬에 초점을 맞추며, 원소별 연산의 필요성이 적습니다. 이들은 <code>@</code>가 수락되더라도 <code>*</code>를 행렬 곱셈에 계속 사용할 것이며, <code>@</code>를 별칭으로 추가할 수 있습니다.</li>
</ul>
</li>
</ul>
<h3>구현 세부 사항 (Implementation details)</h3>
<ul>
<li><code>operator.matmul</code> 및 <code>operator.__matmul__</code> 함수가 표준 라이브러리에 추가됩니다.</li>
<li><code>PyObject* PyObject_MatrixMultiply(PyObject *o1, PyObject *o2)</code> 함수가 C API에 추가됩니다.</li>
<li><code>MatMult</code>라는 새로운 AST(Abstract Syntax Tree) 노드, 새로운 토큰 <code>ATEQUAL</code>, 그리고 새로운 바이트코드 opcodes <code>BINARY_MATRIX_MULTIPLY</code> 및 <code>INPLACE_MATRIX_MULTIPLY</code>가 추가됩니다.</li>
<li>두 개의 새로운 타입 슬롯이 추가됩니다.</li>
</ul>
<h3>명세 세부 사항에 대한 근거 (Rationale for specification details)</h3>
<h4>연산자 선택 (Choice of operator)</h4>
<p><code>@</code>를 선택한 이유는 다음과 같습니다:</p>
<ul>
<li>미국 영어 키보드에 있는 기호 중 Python 표현식 컨텍스트에서 아직 의미가 없는 <code>@</code>, 백틱, <code>$</code>, <code>!</code>, <code>?</code> 중에서 <code>@</code>가 가장 적합합니다. <code>!</code>와 <code>?</code>는 프로그래밍 맥락에서 이미 다른 의미를 가지고 있고, 백틱은 BDFL에 의해 Python에서 금지되었으며, <code>$</code>는 <code>*</code>나 <code>·</code>와 더 이질적이며 Perl/PHP의 영향이 있습니다.</li>
<li><code>@</code>는 "스칼라/원소별 곱셈과 구별되는 행렬 곱셈"을 의미하는 데 필요한 연산자입니다. 프로그래밍이나 수학에서 이러한 의미를 가진 관습적인 기호는 없습니다.</li>
<li><code>@</code>는 데코레이터에서 이미 익숙하게 사용되는 친숙한 문자이지만, 데코레이터 사용과 수학 표현식 사용은 실제에서 혼동하기 어려울 정도로 충분히 다릅니다.</li>
<li>키보드 레이아웃에 관계없이 널리 접근 가능합니다 (이메일 주소에서의 사용 덕분에).</li>
<li><code>*</code>와 <code>·</code>처럼 둥근 형태를 가집니다.</li>
<li><code>mATrices</code>라는 연상 기호가 귀엽습니다.</li>
<li>회전하는 모양은 행렬 곱셈을 정의하는 행과 열에 대한 동시 스캔을 연상시킵니다.</li>
<li>비대칭성은 비결합적인 특성을 암시합니다.</li>
</ul>
<h4>우선순위 및 결합성 (Precedence and associativity)</h4>
<p><code>@</code> 연산자는 대부분의 Python 연산자와 마찬가지로 **좌측 결합성(left-associative)**을 가집니다.
비록 행렬 곱셈이 함수 적용/합성과 유사하여 일부 수학적으로 정교한 사용자들은 우측 결합성을 직관적으로 생각할 수 있고, <code>Mat @ (Mat @ vec)</code>과 같이 평가될 때 효율성 이점이 있을 수 있다는 주장이 있었지만, 다음 이유들로 인해 좌측 결합성이 채택되었습니다:</p>
<ul>
<li>실제 코드에서 <code>Mat @ Mat @ vec</code> 유형의 표현식이 지배적이라는 증거를 찾을 수 없었습니다.</li>
<li>R, Matlab, Julia, IDL, Gauss 등 선형 대수에 중점을 둔 다른 언어들도 행렬 곱셈 연산자를 압도적으로 좌측 결합성으로 만듭니다.</li>
<li>좌측 결합성은 <code>@</code>가 <code>*</code>와 유사하게 작동한다고 배우고 기억하기 훨씬 쉽습니다.</li>
</ul>
<h4>내장 타입에 대한 (비)정의 ((Non)-Definitions for built-in types)</h4>
<p><code>float</code>, <code>int</code> 등과 같은 내장 수치 타입이나 <code>numbers.Number</code> 계층에는 <code>__matmul__</code> 또는 <code>__matpow__</code>가 정의되지 않습니다. 이러한 타입은 스칼라를 나타내며, <code>@</code>의 합의된 시맨틱은 스칼라에 대해 오류를 발생시켜야 하기 때문입니다.</p>
<p><code>memoryview</code> 또는 <code>array.array</code> 객체에는 현재 <code>__matmul__</code> 메서드가 정의되지 않습니다. 이는 해당 타입이 수치 작업에 사용되기 전에 상당한 추가 작업이 필요하며, 효율적인 행렬 곱셈 구현의 복잡성 (BLAS 라이브러리 링크 및 <code>multiprocessing</code> 문제) 때문입니다.</p>
<p><code>str</code>, <code>list</code> 등 <code>__mul__</code>을 정의하는 비수치 Python 내장 타입에 대해서도 <code>__matmul__</code>은 정의되지 않습니다.</p>
<h4>행렬 거듭제곱의 미정의 (Non-definition of matrix power)</h4>
<p>이 PEP의 초기 버전에서는 <code>**</code>와 유사한 행렬 거듭제곱 연산자 <code>@@</code>도 제안했지만, 그 유용성이 불분명하여 현재는 제외되었습니다. <code>@</code> 연산자에 대한 경험이 더 쌓인 후에 <code>@@</code>의 필요성이 입증되면 다시 논의될 예정입니다.</p>
<h3>새로운 연산자 추가에 대한 거부된 대안 (Rejected alternatives to adding a new operator)</h3>
<p>지난 수십 년 동안 Python 수치 커뮤니티는 행렬 곱셈과 원소별 곱셈 연산 사이의 긴장을 해결하기 위한 다양한 방법을 모색했습니다. PEP 211과 PEP 225는 이 문제를 해결하기 위한 초기 시도였지만 심각한 결함이 있었습니다. 이후의 경험을 통해 수치 Python과 코어 Python 모두를 위한 최상의 해결책은 행렬 곱셈을 위한 단일 중위 연산자를 추가하는 것이라는 합의에 도달했습니다.</p>
<p>거부된 주요 대안들은 다음과 같습니다:</p>
<ul>
<li><strong><code>__mul__</code>을 행렬 곱셈으로 정의하는 두 번째 타입 사용:</strong> <code>numpy.matrix</code> 타입으로 수년 동안 시도되었지만, 배열에 대한 충돌하는 오리 타이핑으로 인해 <code>numpy</code> 개발자와 하위 패키지 개발자들 사이에서 <code>numpy.matrix</code>를 거의 사용하지 말아야 한다는 강력한 합의를 이끌어냈습니다.</li>
<li><strong>많은 새로운 연산자 추가 또는 중위 연산자를 정의하기 위한 새로운 일반 문법 추가:</strong> 일반적으로 Pythonic하지 않으며, BDFL에 의해 반복적으로 거부되었습니다. 과학 Python 커뮤니티는 행렬 곱셈을 위한 하나의 연산자 추가만으로 해결할 수 없는 고통스러운 문제를 해결하기에 충분하다는 합의에 도달했습니다.</li>
<li><strong>일반 Python에서 다른 의미를 가지는 새로운 <code>@</code> 연산자를 추가하고 수치 코드에서 오버로드:</strong> PEP 211이 취했던 접근 방식이었으나, <code>itertools.product</code>가 전용 연산자를 필요로 할 만큼 중요하지 않다는 문제가 있었습니다. 행렬 곱셈은 중위 연산자로 포함될 만한 독특하고 강력한 근거를 가집니다.</li>
<li><strong>배열 타입에 <code>.dot</code> 메서드를 추가하여 "유사 중위(pseudo-infix)" <code>A.dot(B)</code> 문법 허용:</strong> <code>numpy</code>에 수년 동안 존재했지만, 여전히 실제 중위 표기법보다 가독성이 떨어지며 과도한 괄호 문제가 있습니다.</li>
<li><strong><code>with</code> 블록을 사용하여 단일 코드 블록 내에서 <code>*</code>의 의미 전환:</strong> 전역 상태 확인 문제와 동적 스코프(dynamically scoped) 문제로 인해 안전하게 사용하기 어렵습니다.</li>
<li><strong>수치 지향 연산자 및 기타 구문을 추가하는 언어 전처리기 사용:</strong> 하나의 이항 연산자를 지원하기 위해 새로운 언어를 정의하는 것은 비실용적입니다. Python의 강점은 전문화된 수치 코드를 다른 일반적인 코드와 혼합할 수 있다는 점인데, "수치 Python"을 "실제 Python"과 분리하는 것은 혼란을 야기하고 파편화를 증가시킵니다.</li>
<li><strong><code>*dot*</code>과 같은 "새로운 중위 연산자"를 정의하기 위한 오버로딩 해킹 사용:</strong> 아름답지 않고 Pythonic하지 않으며, 초보자에게 특히 불친절합니다.</li>
<li><strong><code>arr.M * arr</code>과 같은 구문을 지원하기 위해 특수 "파사드(facade)" 타입 사용:</strong> "마법 같은" 특성으로 인해 위의 해킹과 유사한 반대를 받습니다. 또한, 파사드 객체가 다른 배열 객체와 파사드 객체 모두를 인식해야 하는 등 비직관적인 복잡성을 야기합니다.</li>
</ul>
<h3>참고 자료 (References)</h3>
<p>https://peps.python.org/pep-0465/</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/465\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"SAPzS3zi9tsG5MkeKvxIA\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/465/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/465\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"465\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/465\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T63f3,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0465/\"\u003ePEP 465 - A dedicated infix operator for matrix multiplication\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 20-Feb-2014\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 465: 행렬 곱셈을 위한 전용 중위(Infix) 연산자 \u003ccode\u003e@\u003c/code\u003e 추가 제안\u003c/h2\u003e\n\u003ch3\u003e요약\u003c/h3\u003e\n\u003cp\u003e이 PEP는 Python에 행렬 곱셈을 위한 새로운 이항(binary) 연산자 \u003ccode\u003e@\u003c/code\u003e를 도입할 것을 제안합니다. 이 연산자는 파이썬 3.5부터 도입되었습니다.\u003c/p\u003e\n\u003ch3\u003e제안 (Specification)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e@\u003c/code\u003e 연산자는 \u003ccode\u003e*\u003c/code\u003e 연산자와 동일한 연산자 우선순위와 좌측 결합성(left-associativity)을 가지며, \u003ccode\u003e__matmul__\u003c/code\u003e 메서드에 의해 구현됩니다. 또한, 해당 제자리(in-place) 버전인 \u003ccode\u003e@=\u003c/code\u003e 연산자는 \u003ccode\u003e__imatmul__\u003c/code\u003e 메서드를 통해 구현됩니다.\u003c/p\u003e\n\u003cp\u003e이러한 메서드는 내장 타입이나 표준 라이브러리 타입에는 추가되지 않습니다. 하지만 \u003ccode\u003enumpy\u003c/code\u003e와 같은 다수의 수치 계산 라이브러리에서 이 연산자에 대한 권장 시맨틱(semantics)에 합의를 이루었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e연산자 우선순위 및 결합성:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e| 연산자 | 우선순위/결합성 | 메서드               |\r\n| ------ | --------------- | -------------------- |\r\n| \u003ccode\u003e@\u003c/code\u003e    | \u003ccode\u003e*\u003c/code\u003e와 동일      | \u003ccode\u003e__matmul__\u003c/code\u003e, \u003ccode\u003e__rmatmul__\u003c/code\u003e |\r\n| \u003ccode\u003e@=\u003c/code\u003e   | N/A             | \u003ccode\u003e__imatmul__\u003c/code\u003e        |\u003c/p\u003e\n\u003ch3\u003e동기 (Motivation)\u003c/h3\u003e\n\u003ch4\u003e개요 (Executive summary)\u003c/h4\u003e\n\u003cp\u003e수치 계산 코드에서는 원소별 곱셈(elementwise multiplication)과 행렬 곱셈(matrix multiplication)이라는 두 가지 중요한 연산이 Python의 \u003ccode\u003e*\u003c/code\u003e 연산자 사용을 두고 경쟁해왔습니다. Numeric 라이브러리가 처음 제안된 이래 약 20년 동안 이 문제를 해결하기 위한 많은 시도가 있었지만, 만족스러운 해결책은 없었습니다.\u003c/p\u003e\n\u003cp\u003e현재 대부분의 수치 Python 코드에서는 원소별 곱셈에 \u003ccode\u003e*\u003c/code\u003e를 사용하고, 행렬 곱셈에는 함수/메서드 호출 문법을 사용합니다 (\u003ccode\u003enumpy.dot(a, b)\u003c/code\u003e 또는 \u003ccode\u003ea.dot(b)\u003c/code\u003e). 그러나 이로 인해 코드가 가독성이 떨어지고 복잡해지는 문제가 발생합니다. 이 문제는 너무 심각해서 일부 코드베이스에서는 반대 규칙(행렬 곱셈에 \u003ccode\u003e*\u003c/code\u003e를 사용하는)을 계속 사용하며 API 파편화를 초래했습니다.\u003c/p\u003e\n\u003cp\u003e현재 Python 문법 내에서 수치 API를 설계하는 좋은 해결책은 없어 보이며, 단지 다양한 방식으로 나쁜 선택지만 존재합니다. 이러한 문제를 해결하기 위한 최소한의 Python 문법 변경은 행렬 곱셈을 위한 새로운 중위 연산자 하나를 추가하는 것입니다.\u003c/p\u003e\n\u003cp\u003e행렬 곱셈은 다른 이항 연산과 구별되는 독특한 특징들을 가지고 있으며, 전용 중위 연산자 추가에 대한 강력한 근거를 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기존 수치 연산자와 마찬가지로, 수학, 과학, 공학의 모든 분야에서 행렬 곱셈에 중위 표기법을 사용하는 방대한 선례가 있습니다. \u003ccode\u003e@\u003c/code\u003e는 Python의 기존 연산자 시스템의 빈틈을 조화롭게 채워줍니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@\u003c/code\u003e는 실제 코드의 가독성을 크게 향상시킵니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@\u003c/code\u003e는 가독성 낮은 코드와 API 파편화로 인해 특히 어려움을 겪는 비전문 프로그래머들을 위한 학습 진입 장벽을 낮춥니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@\u003c/code\u003e는 Python 사용자 커뮤니티의 상당하고 성장하는 부분에 이점을 제공할 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@\u003c/code\u003e는 자주 사용될 것이며, 심지어 \u003ccode\u003e//\u003c/code\u003e나 비트와이즈 연산자보다 더 자주 사용될 수 있다는 증거가 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@\u003c/code\u003e는 Python 수치 커뮤니티가 파편화를 줄이고, 모든 수치 배열 객체에 대한 단일 합의 오리 타이핑(duck type)을 표준화할 수 있도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e현재 상황의 문제점 (Background: What's wrong with the status quo?)\u003c/h4\u003e\n\u003cp\u003e수치 계산 시, \u003ccode\u003en\u003c/code\u003e차원 배열(n-dimensional array)은 대량의 숫자에 대해 한 번에 간단한 연산을 적용할 수 있게 하는 기본 객체입니다. \u003ccode\u003enumpy\u003c/code\u003e는 Python에서 이러한 배열을 제공하는 가장 유명한 라이브러리입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003en\u003c/code\u003e차원 배열을 다룰 때, 곱셈을 정의하는 두 가지 방법이 있습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e원소별 곱셈 (Elementwise multiplication):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[[1, 2],    [[11, 12],    [[1 * 11, 2 * 12],\r\n [3, 4]] x   [13, 14]] =   [3 * 13, 4 * 14]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 방식은 \u003ccode\u003efor\u003c/code\u003e 루프 없이 대량의 값에 대해 빠르고 쉽게 곱셈을 수행할 수 있어 유용합니다. \u003ccode\u003enumpy\u003c/code\u003e와 같은 라이브러리의 배열 객체를 사용할 때, 모든 Python 연산자는 모든 차원의 배열에 대해 원소별로 작동합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e행렬 곱셈 (Matrix multiplication):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[[1, 2],    [[11, 12],    [[1 * 11 + 2 * 13, 1 * 12 + 2 * 14],\r\n [3, 4]] x   [13, 14]] =   [3 * 11 + 4 * 13, 3 * 12 + 4 * 14]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e행렬 곱셈은 2D 배열(행렬)에 대해서만 정의되며, 다른 연산들과 달리 중요한 \"행렬\" 버전이 있는 유일한 곱셈 연산입니다. 모든 수치 응용 분야에서 매우 중요하게 사용됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003ePython 문법은 현재 단일 곱셈 연산자 \u003ccode\u003e*\u003c/code\u003e만 허용하므로, 배열과 유사한 객체를 제공하는 라이브러리는 \u003ccode\u003e*\u003c/code\u003e를 원소별 곱셈에 사용할지, 아니면 행렬 곱셈에 사용할지 결정해야 합니다. 불행히도, 일반적인 수치 계산에서는 두 연산 모두 자주 사용되며, 두 경우 모두 함수 호출 문법보다는 중위 연산자 사용에 큰 이점이 있습니다. 이로 인해 어떤 규칙이 최적인지 불분명하며, 프로젝트 간 API 파편화가 발생합니다. 예를 들어 \u003ccode\u003enumpy.ndarray\u003c/code\u003e는 \u003ccode\u003e*\u003c/code\u003e를 원소별 곱셈에 사용하고, \u003ccode\u003enumpy.matrix\u003c/code\u003e는 \u003ccode\u003e*\u003c/code\u003e를 행렬 곱셈에 사용하여 코드 통합 시 문제를 야기합니다.\u003c/p\u003e\n\u003cp\u003ePEP 238이 \u003ccode\u003e/\u003c/code\u003e를 \u003ccode\u003e/\u003c/code\u003e와 \u003ccode\u003e//\u003c/code\u003e 두 연산자로 나눴던 것처럼, 이 PEP는 \u003ccode\u003e*\u003c/code\u003e를 원소별 곱셈을 위한 \u003ccode\u003e*\u003c/code\u003e와 행렬 곱셈을 위한 \u003ccode\u003e@\u003c/code\u003e로 나눌 것을 제안합니다.\u003c/p\u003e\n\u003ch4\u003e행렬 곱셈이 중위 연산자여야 하는 이유 (Why should matrix multiplication be infix?)\u003c/h4\u003e\n\u003cp\u003e현재 대부분의 Python 수치 코드는 \u003ccode\u003enumpy.dot(a, b)\u003c/code\u003e 또는 \u003ccode\u003ea.dot(b)\u003c/code\u003e와 같은 문법을 사용하여 행렬 곱셈을 수행합니다. 이 방법은 작동하지만, 전 세계 수학, 과학, 공학 분야에서 보편적으로 중위 표기법이 사용되어 왔기 때문에 가독성 측면에서 중위 연산자가 훨씬 우수합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 통계 가설 검정에서 사용되는 OLS 회귀 모델의 선형 가설 검정 수식 \u003ccode\u003eS = (Hβ − r)T(HVHT) − 1(Hβ − r)\u003c/code\u003e을 구현하는 경우를 살펴보겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e현재 \u003ccode\u003edot\u003c/code\u003e 함수 사용 시:\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eS = np.dot((np.dot(H, beta) - r).T, np.dot(inv(np.dot(np.dot(H, V), H.T)), np.dot(H, beta) - r))\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e현재 \u003ccode\u003edot\u003c/code\u003e 메서드 사용 시:\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eS = (H.dot(beta) - r).T.dot(inv(H.dot(V).dot(H.T))).dot(H.dot(beta) - r)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e@\u003c/code\u003e 연산자 사용 시:\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eS = (H @ beta - r).T @ inv(H @ V @ H.T) @ (H @ beta - r)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e@\u003c/code\u003e 연산자를 사용하면 원본 수식의 기호와 코드가 1:1로 투명하게 매핑되어 훨씬 읽기 쉽습니다. \u003ccode\u003e@\u003c/code\u003e는 불필요한 괄호를 줄여 코드를 더 간결하고 명확하게 만들며, 전문가와 비전문가 모두에게 행렬 코드의 사용성을 크게 향상시킵니다.\u003c/p\u003e\n\u003ch4\u003e비전문 프로그래머에게 투명한 문법이 특히 중요한 이유 (Transparent syntax is especially crucial for non-expert programmers)\u003c/h4\u003e\n\u003cp\u003e많은 과학 분야 코드는 해당 분야의 전문가들이 작성하지만, 프로그래밍 전문가는 아닌 경우가 많습니다. 이러한 사용자들은 수학 공식과 코드 간의 투명한 매핑이 매우 중요하며, 이는 코드를 작성하는 데 성공하느냐 실패하느냐의 차이를 만듭니다. \u003ccode\u003enumpy.matrix\u003c/code\u003e 타입이 \u003ccode\u003e*\u003c/code\u003e를 행렬 곱셈으로 정의하는 이유도 이러한 교육적 사용 사례 때문이며, \u003ccode\u003e@\u003c/code\u003e 연산자는 시작 및 고급 사용자 모두에게 더 나은 문법을 제공하고, 처음부터 동일한 표기법으로 표준화할 수 있도록 돕습니다.\u003c/p\u003e\n\u003ch4\u003e행렬 곱셈이 틈새 시장 요구 사항에 불과한가? (But isn't matrix multiplication a pretty niche requirement?)\u003c/h4\u003e\n\u003cp\u003e세계는 연속 데이터로 가득 차 있으며, 컴퓨터는 이를 정교하게 처리해야 하는 요구가 점점 늘고 있습니다. 배열(Array)은 금융, 머신러닝, 3D 그래픽, 컴퓨터 비전, 로봇 공학, 운영 연구, 계량 경제학, 기상학, 전산 언어학, 추천 시스템, 신경 과학, 천문학, 생물 정보학 등 다양한 응용 분야의 공통 언어입니다. 이러한 분야의 대부분에서 Python은 전통적인 이산 데이터 구조와 현대적인 수치 데이터 유형 및 알고리즘을 우아하게 혼합할 수 있는 능력 덕분에 빠르게 지배적인 역할을 하고 있습니다.\u003c/p\u003e\n\u003cp\u003e2013년에는 수치 Python에 특화된 7개의 국제 컨퍼런스가 개최되었고, PyCon 2014에서는 튜토리얼의 약 20%가 행렬 사용과 관련되어 있었습니다. GitHub 코드 검색 결과(\u003ccode\u003e2014-04-10 기준\u003c/code\u003e), \u003ccode\u003enumpy\u003c/code\u003e는 \u003ccode\u003esys\u003c/code\u003e, \u003ccode\u003eos\u003c/code\u003e, \u003ccode\u003ere\u003c/code\u003e 다음으로 가장 많이 임포트되는 모듈 중 하나이며, \u003ccode\u003esubprocess\u003c/code\u003e, \u003ccode\u003emath\u003c/code\u003e, \u003ccode\u003epickle\u003c/code\u003e, \u003ccode\u003ethreading\u003c/code\u003e과 같은 표준 라이브러리 모듈보다도 더 많이 임포트됩니다. 이는 수치 계산이 현대 Python 사용의 주류를 이루고 있음을 시사합니다.\u003c/p\u003e\n\u003cp\u003e또한, 정수 나눗셈 연산자 \u003ccode\u003e//\u003c/code\u003e와 같이 특정 상황에서 매우 유용한 특수 산술 연산을 위해 중위 연산자를 추가한 선례가 있습니다. \u003ccode\u003e//\u003c/code\u003e나 비트와이즈 연산자를 사용해본 적이 없는 Python 프로그래머가 많을 수 있지만, \u003ccode\u003e@\u003c/code\u003e는 \u003ccode\u003e//\u003c/code\u003e보다 더 틈새 시장에 속하지 않습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003e@\u003c/code\u003e는 행렬 공식에 유용하지만, 얼마나 자주 사용될까? (So @ is good for matrix formulas, but how common are those really?)\u003c/h4\u003e\n\u003cp\u003e표준 라이브러리, scikit-learn, nipy의 코드 베이스에서 연산자 사용 빈도를 분석한 결과, 행렬 곱셈 연산(dot)은 이 두 수치 패키지에서만 약 780번 사용되었으며, 대부분의 비교 연산자(\u003ccode\u003e!=\u003c/code\u003e, \u003ccode\u003e\u0026#x3C;\u003c/code\u003e, \u003ccode\u003e\u0026#x3C;=\u003c/code\u003e, \u003ccode\u003e\u003e=\u003c/code\u003e)보다 더 자주 사용됩니다. 표준 라이브러리까지 포함한 전체 코드 베이스에서는 행렬 곱셈이 비트와이즈 연산자들보다 더 자주 사용되고, \u003ccode\u003e//\u003c/code\u003e보다 2배 더 자주 사용됩니다. 이는 수치 프로그래밍이 일반적이고 주류 활동임을 나타냅니다.\u003c/p\u003e\n\u003ch4\u003e표준 라이브러리에서 사용되지 않는 연산자를 추가하는 것이 이상한가? (But isn't it weird to add an operator with no stdlib uses?)\u003c/h4\u003e\n\u003cp\u003e특이한 경우이기는 하지만, 중요한 것은 변경 사항이 사용자에게 이점을 제공하는지 여부입니다. \u003ccode\u003e@\u003c/code\u003e가 많이 사용될 것이 분명하며, 이 PEP는 Python 수치 커뮤니티가 모든 배열과 유사한 객체에 대한 표준 오리 타이핑에 최종 합의에 도달할 수 있게 하는 중요한 조각을 제공합니다. 이는 표준 라이브러리에 수치 배열 타입을 추가하는 데 필요한 전제 조건입니다.\u003c/p\u003e\n\u003ch3\u003e호환성 고려 사항 (Compatibility considerations)\u003c/h3\u003e\n\u003cp\u003e현재 Python 코드에서 \u003ccode\u003e@\u003c/code\u003e 토큰의 유일한 합법적인 사용처는 데코레이터에서 문장 시작 부분입니다. 새로운 연산자는 모두 중위 연산자이므로 문장 시작 부분에는 나타날 수 없습니다. 따라서 이 연산자들을 추가해도 기존 코드가 손상되지 않으며, 데코레이터 \u003ccode\u003e@\u003c/code\u003e와 새로운 연산자 사이에 구문 분석(parsing) 모호성도 없습니다.\u003c/p\u003e\n\u003cp\u003e또한, 행렬을 사용하지 않는 사용자가 이 변경 사항으로 인해 Python 언어에 대한 이해를 업데이트하는 데 드는 정신적 비용도 최소화됩니다.\u003c/p\u003e\n\u003ch3\u003e의도된 사용법 세부 사항 (Intended usage details)\u003c/h3\u003e\n\u003cp\u003e이 섹션은 정보 제공을 목적으로 하며, 배열 또는 행렬과 유사한 객체를 제공하는 여러 라이브러리가 \u003ccode\u003e@\u003c/code\u003e를 구현하는 방법에 대한 합의를 문서화합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enumpy\u003c/code\u003e 용어를 사용하여 임의의 다차원 배열을 설명합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e2차원 입력:\u003c/strong\u003e 일반적인 행렬로 간주하며, 전통적인 행렬 곱셈을 적용합니다. 예를 들어, \u003ccode\u003earr(2, 3) @ arr(3, 4)\u003c/code\u003e는 \u003ccode\u003e(2, 4)\u003c/code\u003e 형태의 배열을 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e1차원 벡터 입력:\u003c/strong\u003e 형태에 '1'을 앞 또는 뒤에 붙여 2차원으로 승격된 후 연산이 수행됩니다. 이로 인해 \u003ccode\u003ematrix @ vector\u003c/code\u003e와 \u003ccode\u003evector @ matrix\u003c/code\u003e 모두 허용되며 1차원 벡터를 반환하고, \u003ccode\u003evector @ vector\u003c/code\u003e는 스칼라를 반환합니다. 예를 들어:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003earr(2, 3) @ arr(3)\u003c/code\u003e는 \u003ccode\u003earr(3)\u003c/code\u003e을 \u003ccode\u003e(3, 1)\u003c/code\u003e 형태의 행렬로 처리하여 \u003ccode\u003e(2,)\u003c/code\u003e 형태의 1차원 벡터를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003earr(3) @ arr(3)\u003c/code\u003e는 내적(inner product)을 수행하여 스칼라 값을 반환합니다.\r\n이러한 정의는 일부 경우 \u003ccode\u003e@\u003c/code\u003e를 비결합적(non-associative)으로 만들 수 있지만, 실제 사용 사례의 중요성 때문에 채택되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2차원보다 큰 입력:\u003c/strong\u003e 마지막 두 차원을 곱할 행렬의 차원으로 취급하고, 다른 차원에 걸쳐 '브로드캐스트(broadcast)'됩니다. 예를 들어, \u003ccode\u003earr(10, 2, 3) @ arr(10, 3, 4)\u003c/code\u003e는 10개의 개별 행렬 곱셈을 수행하여 \u003ccode\u003e(10, 2, 4)\u003c/code\u003e 형태의 배열을 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e0차원 (스칼라) 입력:\u003c/strong\u003e 오류를 발생시킵니다. 스칼라와 행렬의 곱셈은 \u003ccode\u003e*\u003c/code\u003e 연산자로 이미 처리됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e채택 (Adoption)\u003c/h3\u003e\n\u003cp\u003e현재 원소별 곱셈과 행렬 곱셈에 다른 API를 사용하는 기존 Python 프로젝트들은 이 PEP의 승인에 따라 다음과 같이 전환할 계획을 가지고 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e*\u003c/code\u003e를 원소별 곱셈에, 함수/메서드 호출을 행렬 곱셈에 사용하는 프로젝트:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enumpy\u003c/code\u003e, \u003ccode\u003epandas\u003c/code\u003e, \u003ccode\u003eblaze\u003c/code\u003e, \u003ccode\u003etheano\u003c/code\u003e 등의 개발자들은 위에서 설명한 시맨틱을 사용하여 \u003ccode\u003e@\u003c/code\u003e를 구현할 의사를 표명했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e*\u003c/code\u003e를 행렬 곱셈에, 함수/메서드 호출을 원소별 곱셈에 사용하는 프로젝트:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enumpy\u003c/code\u003e (\u003ccode\u003enumpy.matrix\u003c/code\u003e), \u003ccode\u003escipy.sparse\u003c/code\u003e, \u003ccode\u003epyoperators\u003c/code\u003e, \u003ccode\u003epyviennacl\u003c/code\u003e 등의 프로젝트는 이 PEP가 수락되면 현재 API에서 원소별 \u003ccode\u003e*\u003c/code\u003e, 행렬 곱셈 \u003ccode\u003e@\u003c/code\u003e 규칙으로 전환할 의사를 표명했습니다. 이는 이 PEP가 수락될 경우 API 파편화가 해소될 프로젝트 목록입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e*\u003c/code\u003e를 행렬 곱셈에 사용하고, 원소별 행렬 곱셈에 크게 신경 쓰지 않는 프로젝트:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esympy\u003c/code\u003e, \u003ccode\u003esage\u003c/code\u003e와 같은 프로젝트는 추상 수학적 객체로서의 행렬에 초점을 맞추며, 원소별 연산의 필요성이 적습니다. 이들은 \u003ccode\u003e@\u003c/code\u003e가 수락되더라도 \u003ccode\u003e*\u003c/code\u003e를 행렬 곱셈에 계속 사용할 것이며, \u003ccode\u003e@\u003c/code\u003e를 별칭으로 추가할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e구현 세부 사항 (Implementation details)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eoperator.matmul\u003c/code\u003e 및 \u003ccode\u003eoperator.__matmul__\u003c/code\u003e 함수가 표준 라이브러리에 추가됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject* PyObject_MatrixMultiply(PyObject *o1, PyObject *o2)\u003c/code\u003e 함수가 C API에 추가됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMatMult\u003c/code\u003e라는 새로운 AST(Abstract Syntax Tree) 노드, 새로운 토큰 \u003ccode\u003eATEQUAL\u003c/code\u003e, 그리고 새로운 바이트코드 opcodes \u003ccode\u003eBINARY_MATRIX_MULTIPLY\u003c/code\u003e 및 \u003ccode\u003eINPLACE_MATRIX_MULTIPLY\u003c/code\u003e가 추가됩니다.\u003c/li\u003e\n\u003cli\u003e두 개의 새로운 타입 슬롯이 추가됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e명세 세부 사항에 대한 근거 (Rationale for specification details)\u003c/h3\u003e\n\u003ch4\u003e연산자 선택 (Choice of operator)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003e@\u003c/code\u003e를 선택한 이유는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e미국 영어 키보드에 있는 기호 중 Python 표현식 컨텍스트에서 아직 의미가 없는 \u003ccode\u003e@\u003c/code\u003e, 백틱, \u003ccode\u003e$\u003c/code\u003e, \u003ccode\u003e!\u003c/code\u003e, \u003ccode\u003e?\u003c/code\u003e 중에서 \u003ccode\u003e@\u003c/code\u003e가 가장 적합합니다. \u003ccode\u003e!\u003c/code\u003e와 \u003ccode\u003e?\u003c/code\u003e는 프로그래밍 맥락에서 이미 다른 의미를 가지고 있고, 백틱은 BDFL에 의해 Python에서 금지되었으며, \u003ccode\u003e$\u003c/code\u003e는 \u003ccode\u003e*\u003c/code\u003e나 \u003ccode\u003e·\u003c/code\u003e와 더 이질적이며 Perl/PHP의 영향이 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@\u003c/code\u003e는 \"스칼라/원소별 곱셈과 구별되는 행렬 곱셈\"을 의미하는 데 필요한 연산자입니다. 프로그래밍이나 수학에서 이러한 의미를 가진 관습적인 기호는 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@\u003c/code\u003e는 데코레이터에서 이미 익숙하게 사용되는 친숙한 문자이지만, 데코레이터 사용과 수학 표현식 사용은 실제에서 혼동하기 어려울 정도로 충분히 다릅니다.\u003c/li\u003e\n\u003cli\u003e키보드 레이아웃에 관계없이 널리 접근 가능합니다 (이메일 주소에서의 사용 덕분에).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e*\u003c/code\u003e와 \u003ccode\u003e·\u003c/code\u003e처럼 둥근 형태를 가집니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emATrices\u003c/code\u003e라는 연상 기호가 귀엽습니다.\u003c/li\u003e\n\u003cli\u003e회전하는 모양은 행렬 곱셈을 정의하는 행과 열에 대한 동시 스캔을 연상시킵니다.\u003c/li\u003e\n\u003cli\u003e비대칭성은 비결합적인 특성을 암시합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e우선순위 및 결합성 (Precedence and associativity)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003e@\u003c/code\u003e 연산자는 대부분의 Python 연산자와 마찬가지로 **좌측 결합성(left-associative)**을 가집니다.\r\n비록 행렬 곱셈이 함수 적용/합성과 유사하여 일부 수학적으로 정교한 사용자들은 우측 결합성을 직관적으로 생각할 수 있고, \u003ccode\u003eMat @ (Mat @ vec)\u003c/code\u003e과 같이 평가될 때 효율성 이점이 있을 수 있다는 주장이 있었지만, 다음 이유들로 인해 좌측 결합성이 채택되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e실제 코드에서 \u003ccode\u003eMat @ Mat @ vec\u003c/code\u003e 유형의 표현식이 지배적이라는 증거를 찾을 수 없었습니다.\u003c/li\u003e\n\u003cli\u003eR, Matlab, Julia, IDL, Gauss 등 선형 대수에 중점을 둔 다른 언어들도 행렬 곱셈 연산자를 압도적으로 좌측 결합성으로 만듭니다.\u003c/li\u003e\n\u003cli\u003e좌측 결합성은 \u003ccode\u003e@\u003c/code\u003e가 \u003ccode\u003e*\u003c/code\u003e와 유사하게 작동한다고 배우고 기억하기 훨씬 쉽습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e내장 타입에 대한 (비)정의 ((Non)-Definitions for built-in types)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e 등과 같은 내장 수치 타입이나 \u003ccode\u003enumbers.Number\u003c/code\u003e 계층에는 \u003ccode\u003e__matmul__\u003c/code\u003e 또는 \u003ccode\u003e__matpow__\u003c/code\u003e가 정의되지 않습니다. 이러한 타입은 스칼라를 나타내며, \u003ccode\u003e@\u003c/code\u003e의 합의된 시맨틱은 스칼라에 대해 오류를 발생시켜야 하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ememoryview\u003c/code\u003e 또는 \u003ccode\u003earray.array\u003c/code\u003e 객체에는 현재 \u003ccode\u003e__matmul__\u003c/code\u003e 메서드가 정의되지 않습니다. 이는 해당 타입이 수치 작업에 사용되기 전에 상당한 추가 작업이 필요하며, 효율적인 행렬 곱셈 구현의 복잡성 (BLAS 라이브러리 링크 및 \u003ccode\u003emultiprocessing\u003c/code\u003e 문제) 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estr\u003c/code\u003e, \u003ccode\u003elist\u003c/code\u003e 등 \u003ccode\u003e__mul__\u003c/code\u003e을 정의하는 비수치 Python 내장 타입에 대해서도 \u003ccode\u003e__matmul__\u003c/code\u003e은 정의되지 않습니다.\u003c/p\u003e\n\u003ch4\u003e행렬 거듭제곱의 미정의 (Non-definition of matrix power)\u003c/h4\u003e\n\u003cp\u003e이 PEP의 초기 버전에서는 \u003ccode\u003e**\u003c/code\u003e와 유사한 행렬 거듭제곱 연산자 \u003ccode\u003e@@\u003c/code\u003e도 제안했지만, 그 유용성이 불분명하여 현재는 제외되었습니다. \u003ccode\u003e@\u003c/code\u003e 연산자에 대한 경험이 더 쌓인 후에 \u003ccode\u003e@@\u003c/code\u003e의 필요성이 입증되면 다시 논의될 예정입니다.\u003c/p\u003e\n\u003ch3\u003e새로운 연산자 추가에 대한 거부된 대안 (Rejected alternatives to adding a new operator)\u003c/h3\u003e\n\u003cp\u003e지난 수십 년 동안 Python 수치 커뮤니티는 행렬 곱셈과 원소별 곱셈 연산 사이의 긴장을 해결하기 위한 다양한 방법을 모색했습니다. PEP 211과 PEP 225는 이 문제를 해결하기 위한 초기 시도였지만 심각한 결함이 있었습니다. 이후의 경험을 통해 수치 Python과 코어 Python 모두를 위한 최상의 해결책은 행렬 곱셈을 위한 단일 중위 연산자를 추가하는 것이라는 합의에 도달했습니다.\u003c/p\u003e\n\u003cp\u003e거부된 주요 대안들은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e__mul__\u003c/code\u003e을 행렬 곱셈으로 정의하는 두 번째 타입 사용:\u003c/strong\u003e \u003ccode\u003enumpy.matrix\u003c/code\u003e 타입으로 수년 동안 시도되었지만, 배열에 대한 충돌하는 오리 타이핑으로 인해 \u003ccode\u003enumpy\u003c/code\u003e 개발자와 하위 패키지 개발자들 사이에서 \u003ccode\u003enumpy.matrix\u003c/code\u003e를 거의 사용하지 말아야 한다는 강력한 합의를 이끌어냈습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e많은 새로운 연산자 추가 또는 중위 연산자를 정의하기 위한 새로운 일반 문법 추가:\u003c/strong\u003e 일반적으로 Pythonic하지 않으며, BDFL에 의해 반복적으로 거부되었습니다. 과학 Python 커뮤니티는 행렬 곱셈을 위한 하나의 연산자 추가만으로 해결할 수 없는 고통스러운 문제를 해결하기에 충분하다는 합의에 도달했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e일반 Python에서 다른 의미를 가지는 새로운 \u003ccode\u003e@\u003c/code\u003e 연산자를 추가하고 수치 코드에서 오버로드:\u003c/strong\u003e PEP 211이 취했던 접근 방식이었으나, \u003ccode\u003eitertools.product\u003c/code\u003e가 전용 연산자를 필요로 할 만큼 중요하지 않다는 문제가 있었습니다. 행렬 곱셈은 중위 연산자로 포함될 만한 독특하고 강력한 근거를 가집니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e배열 타입에 \u003ccode\u003e.dot\u003c/code\u003e 메서드를 추가하여 \"유사 중위(pseudo-infix)\" \u003ccode\u003eA.dot(B)\u003c/code\u003e 문법 허용:\u003c/strong\u003e \u003ccode\u003enumpy\u003c/code\u003e에 수년 동안 존재했지만, 여전히 실제 중위 표기법보다 가독성이 떨어지며 과도한 괄호 문제가 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ewith\u003c/code\u003e 블록을 사용하여 단일 코드 블록 내에서 \u003ccode\u003e*\u003c/code\u003e의 의미 전환:\u003c/strong\u003e 전역 상태 확인 문제와 동적 스코프(dynamically scoped) 문제로 인해 안전하게 사용하기 어렵습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e수치 지향 연산자 및 기타 구문을 추가하는 언어 전처리기 사용:\u003c/strong\u003e 하나의 이항 연산자를 지원하기 위해 새로운 언어를 정의하는 것은 비실용적입니다. Python의 강점은 전문화된 수치 코드를 다른 일반적인 코드와 혼합할 수 있다는 점인데, \"수치 Python\"을 \"실제 Python\"과 분리하는 것은 혼란을 야기하고 파편화를 증가시킵니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e*dot*\u003c/code\u003e과 같은 \"새로운 중위 연산자\"를 정의하기 위한 오버로딩 해킹 사용:\u003c/strong\u003e 아름답지 않고 Pythonic하지 않으며, 초보자에게 특히 불친절합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003earr.M * arr\u003c/code\u003e과 같은 구문을 지원하기 위해 특수 \"파사드(facade)\" 타입 사용:\u003c/strong\u003e \"마법 같은\" 특성으로 인해 위의 해킹과 유사한 반대를 받습니다. 또한, 파사드 객체가 다른 배열 객체와 파사드 객체 모두를 인식해야 하는 등 비직관적인 복잡성을 야기합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e참고 자료 (References)\u003c/h3\u003e\n\u003cp\u003ehttps://peps.python.org/pep-0465/\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 465 - A dedicated infix operator for matrix multiplication\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:12:46+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>