<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-287dd7aad5349a53.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1599<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 201 - Lockstep Iteration</h1><div class="page__meta"><time dateTime="2025-09-26 16:10:52+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0201/">PEP 201 - Lockstep Iteration</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 13-Jul-2000</p>
</blockquote>
<h1>PEP 201 – Lockstep Iteration</h1>
<ul>
<li><strong>작성자</strong>: Barry Warsaw </li>
<li><strong>상태</strong>: Final</li>
<li><strong>유형</strong>: Standards Track</li>
<li><strong>생성일</strong>: 2000년 7월 13일</li>
<li><strong>Python 버전</strong>: 2.0</li>
<li><strong>게시 이력</strong>: 2000년 7월 27일</li>
</ul>
<h2>서론 (Introduction)</h2>
<p>이 PEP는 'lockstep iteration' 제안을 설명합니다. 이 문서는 Python 2.0에 도입될 예정이었던 이 기능의 상태와 소유권을 추적합니다. 여기에는 기능에 대한 설명과 이 기능을 지원하는 데 필요한 변경 사항에 대한 개요가 포함되어 있습니다. 이 PEP는 메일링 리스트 포럼에서 진행된 논의를 요약하며, 필요에 따라 추가 정보에 대한 URL을 제공합니다. 이 파일의 CVS 리비전 히스토리는 확정적인 역사적 기록을 담고 있습니다.</p>
<h2>동기 (Motivation)</h2>
<p>Python의 표준 <code>for</code> 루프는 시퀀스가 소진될 때까지 시퀀스의 모든 요소를 반복합니다. 그러나 <code>for</code> 루프는 단일 시퀀스만 반복하며, 종종 여러 시퀀스를 'lock-step' 방식으로, 즉 루프의 i번째 반복에서 각 시퀀스의 i번째 요소를 포함하는 객체를 반환하는 방식으로 반복하는 것이 바람직합니다.</p>
<p>이를 달성하기 위해 사용되는 일반적인 관용구(idiom)는 직관적이지 않습니다. 이 PEP는 <code>zip</code>이라는 새로운 내장 함수를 도입하여 이러한 유형의 반복을 수행하는 표준적인 방법을 제안합니다.</p>
<p><code>zip()</code>의 주요 동기는 lock-step iteration에서 비롯되지만, <code>zip()</code>을 내장 함수로 구현함으로써 <code>for</code> 루프 이외의 다른 컨텍스트에서도 추가적인 유용성을 가집니다.</p>
<h2>Lockstep For-Loops (Lockstep For-루프)</h2>
<p>Lockstep <code>for</code> 루프는 둘 이상의 시퀀스에 대해 중첩되지 않은 반복을 수행하며, 루프를 한 번 통과할 때마다 각 시퀀스에서 하나의 요소를 가져와 대상을 구성합니다. 이 동작은 <code>map()</code> 내장 함수를 사용하여 Python에서 이미 달성할 수 있습니다:</p>
<pre><code class="language-python">>>> a = (1, 2, 3)
>>> b = (4, 5, 6)
>>> for i in map(None, a, b):
...     print i
...
(1, 4)
(2, 5)
(3, 6)
>>> map(None, a, b)
[(1, 4), (2, 5), (3, 6)]
</code></pre>
<p><code>for</code> 루프는 단순히 이 리스트를 정상적으로 반복합니다.</p>
<p><code>map()</code> 관용구는 Python에서 흔히 사용되지만, 다음과 같은 몇 가지 단점이 있습니다:</p>
<ul>
<li>
<p>함수형 프로그래밍 배경이 없는 프로그래머에게는 불분명합니다.</p>
</li>
<li>
<p>첫 번째 인수로 <code>None</code>을 사용하는 "마법" 같은 방식이 불분명합니다.</p>
</li>
<li>
<p>리스트의 길이가 같지 않을 때 임의적이고 종종 의도치 않은 유연하지 못한 의미를 가집니다. 짧은 시퀀스는 <code>None</code>으로 채워집니다:</p>
<pre><code class="language-python">>>> c = (4, 5, 6, 7)
>>> map(None, a, c)
[(1, 4), (2, 5), (3, 6), (None, 7)]
</code></pre>
</li>
</ul>
<p>이러한 이유로 Python 2.0 베타 기간 동안 lockstep <code>for</code> 루프에 대한 구문 지원을 위한 여러 제안이 나왔습니다. 다음은 두 가지 제안입니다:</p>
<pre><code class="language-python">for x in seq1, y in seq2: # stuff

for x, y in seq1, seq2: # stuff
</code></pre>
<p>이러한 형식 중 어느 것도 작동하지 않을 것입니다. 왜냐하면 둘 다 Python에서 이미 어떤 의미를 가지며, 그 의미를 변경하는 것은 기존 코드를 손상시키기 때문입니다. 새로운 구문에 대한 다른 모든 제안들도 동일한 문제를 겪었거나, 'list comprehensions'이라는 다른 제안된 기능(PEP 202 참조)과 충돌했습니다.</p>
<h2>제안된 해결책 (The Proposed Solution)</h2>
<p>제안된 해결책은 <code>__builtin__</code> 모듈에서 사용할 수 있는 새로운 내장 시퀀스 제너레이터(sequence generator) 함수를 도입하는 것입니다. 이 함수는 <code>zip</code>이라고 불리며 다음 서명을 가집니다:</p>
<pre><code class="language-python">zip(seqa, [seqb, [...]])
</code></pre>
<p><code>zip()</code>은 하나 이상의 시퀀스를 받아 <code>map(None, ...)</code>이 길이가 같은 시퀀스에서 하는 것처럼 요소들을 함께 엮습니다. 엮는 작업은 가장 짧은 시퀀스가 소진될 때 중지됩니다.</p>
<h2>반환 값 (Return Value)</h2>
<p><code>zip()</code>은 <code>map()</code>이 하는 방식과 동일하게 실제 Python 리스트를 반환합니다.</p>
<h2>예시 (Examples)</h2>
<p>아래 참조 구현(Reference Implementation)을 기반으로 한 몇 가지 예시입니다:</p>
<pre><code class="language-python">>>> a = (1, 2, 3, 4)
>>> b = (5, 6, 7, 8)
>>> c = (9, 10, 11)
>>> d = (12, 13)
>>> zip(a, b)
[(1, 5), (2, 6), (3, 7), (4, 8)]
>>> zip(a, d)
[(1, 12), (2, 13)]
>>> zip(a, b, c, d)
[(1, 5, 9, 12), (2, 6, 10, 13)]
</code></pre>
<p>시퀀스 길이가 같을 때 <code>zip()</code>은 역변환(reversible)이 가능합니다:</p>
<pre><code class="language-python">>>> a = (1, 2, 3)
>>> b = (4, 5, 6)
>>> x = zip(a, b)
>>> y = zip(*x) # alternatively, apply(zip, x)
>>> z = zip(*y) # alternatively, apply(zip, y)
>>> x
[(1, 4), (2, 5), (3, 6)]
>>> y
[(1, 2, 3), (4, 5, 6)]
>>> z
[(1, 4), (2, 5), (3, 6)]
>>> x == z
True
</code></pre>
<p>시퀀스 길이가 모두 같지 않을 때는 이러한 방식으로 <code>zip</code>을 역변환할 수 없습니다.</p>
<h2>참조 구현 (Reference Implementation)</h2>
<p>다음은 <code>zip()</code> 내장 함수의 Python 참조 구현입니다. 최종 승인 후에는 C 구현으로 대체될 것입니다:</p>
<pre><code class="language-python">def zip(*args):
    if not args:
        raise TypeError('zip() expects one or more sequence arguments')
    ret = []
    i = 0
    try:
        while 1:
            item = []
            for s in args:
                item.append(s[i])
            ret.append(tuple(item))
            i = i + 1
    except IndexError:
        return ret
</code></pre>
<h2>BDFL의 선언 (BDFL Pronouncements)</h2>
<p><strong>참고</strong>: BDFL은 Python의 자비로운 종신 독재자(Benevolent Dictator For Life)인 Guido van Rossum을 지칭합니다.</p>
<ul>
<li><strong>함수 이름</strong>: 이 PEP의 이전 버전에는 <code>zip()</code>에 대한 20개 이상의 대체 이름이 나열된 미해결 문제가 포함되어 있었습니다. 압도적으로 더 나은 선택지가 없는 상황에서, BDFL은 Haskell에서 유래했기 때문에 <code>zip()</code>을 강력히 선호했습니다. <code>zip()</code>은 내장 함수여야 합니다.</li>
<li><strong>선택적 패딩(Optional padding)</strong>: 이 PEP의 이전 버전은 인자 시퀀스의 길이가 같지 않을 때 사용될 선택적 <code>pad</code> 키워드 인자를 제안했습니다. 이는 <code>map(None, ...)</code>의 의미와 유사하지만, 사용자가 <code>pad</code> 객체를 지정할 수 있도록 하는 것이었습니다. 이는 KISS (Keep It Simple, Stupid) 원칙에 따라 가장 짧은 시퀀스에 항상 잘라내는 것을 선호하여 BDFL에 의해 거부되었습니다.</li>
<li><strong>지연 평가(Lazy evaluation)</strong>: 이 PEP의 이전 버전은 <code>zip()</code>이 <code>__getitem__()</code> 프로토콜을 사용하여 지연 평가를 수행하는 내장 객체를 반환할 것을 제안했습니다. 이는 실제 Python 리스트를 반환하는 것을 선호하여 BDFL에 의해 강력히 거부되었습니다. 미래에 지연 평가가 필요하다면, BDFL은 <code>xzip()</code> 함수를 추가할 것을 제안합니다.</li>
<li><strong>인자 없는 <code>zip()</code></strong>: BDFL은 <code>TypeError</code> 예외를 발생시키는 것을 강력히 선호했습니다.</li>
<li><strong>인자 하나를 가진 <code>zip()</code></strong>: BDFL은 이것이 1-튜플(1-tuple)의 리스트를 반환하는 것을 강력히 선호했습니다.</li>
<li><strong>내부 및 외부 컨테이너 제어(Inner and outer container control)</strong>: 이 PEP의 이전 버전에는 일부 사람들이 원했던 기능, 즉 내부 및 외부 컨테이너 유형을 제어하는 기능에 대한 논의가 포함되어 있었습니다. 간소화된 API와 구현을 고려할 때, 이 기능은 거부되었습니다.</li>
</ul>
<h2><code>zip()</code>의 후속 변경 (Subsequent Change to zip())</h2>
<p>Python 2.4에서 인자 없는 <code>zip()</code>은 <code>TypeError</code> 예외를 발생시키는 대신 빈 리스트를 반환하도록 수정되었습니다. 원래 동작은 인자의 부재가 프로그래밍 오류를 나타낸다고 생각되었기 때문입니다. 그러나 이는 <code>*</code> 연산자를 사용하여 가변 길이 인자 리스트를 언팩(unpack)하는 <code>zip()</code>의 사용을 예상하지 못했습니다. 예를 들어, <code>zip</code>의 역함수는 <code>unzip = lambda s: zip(*s)</code>와 같이 정의될 수 있습니다. 이러한 변환은 행렬 전치(matrix transpose)나 테이블의 행/열 교환에도 사용되며, 특히 레코드를 행으로, 필드를 열로 하는 데이터 파일을 읽을 때 유용합니다.</p>
<p>예를 들어, 다음 코드는:</p>
<pre><code class="language-python">date, rain, high, low = zip(*csv.reader(file("weather.csv")))
</code></pre>
<p>각 필드가 개별 튜플로 수집되어 직접적인 반복 및 요약이 가능하도록 열 기반 데이터를 재정렬합니다. <code>zip(*[])</code>이 예외가 아닌 허용 가능한 경우로 처리될 경우 <code>zip(*args)</code>를 사용하는 것이 더 쉽게 코딩됩니다. 이 가능성을 보고, BDFL은 (약간의 망설임과 함께) Python 2.4에서 동작을 변경하는 것에 동의했습니다.</p>
<h2>기타 변경 사항 (Other Changes)</h2>
<p>위에서 논의된 <code>xzip()</code> 함수는 Python 2.3의 <code>itertools</code> 모듈에 <code>itertools.izip()</code>으로 구현되었습니다. 이 함수는 지연 동작(lazy behavior)을 제공하여, 각 반복에서 단일 요소를 소비하고 단일 튜플을 생성합니다. "Just-in-time" 방식은 메모리를 절약하고 리스트 기반 <code>zip()</code>보다 빠르게 실행됩니다. <code>itertools</code> 모듈은 또한 <code>itertools.repeat()</code>과 <code>itertools.chain()</code>을 추가했습니다. 이러한 도구들은 함께 사용하여 시퀀스를 <code>None</code>으로 채울 수 있습니다 (<code>map(None, seqn)</code>의 동작과 일치하도록):</p>
<pre><code class="language-python">zip(firstseq, chain(secondseq, repeat(None)))
</code></pre>
<h2>참고 자료 (References)</h2>
<ul>
<li>http://docs.python.org/reference/compound_stmts.html#for</li>
<li>http://www.haskell.org/onlinereport/standard-prelude.html#$vzip</li>
<li>Greg Wilson이 일부 CS 대학원생에게 제안된 구문에 대해 설문 조사: http://www.python.org/pipermail/python-dev/2000-July/013139.html</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-287dd7aad5349a53.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/201\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"UDStqnFgkjod-k9ijxbnd\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/201/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/201\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"201\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/201\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T2e85,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0201/\"\u003ePEP 201 - Lockstep Iteration\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 13-Jul-2000\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 201 – Lockstep Iteration\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자\u003c/strong\u003e: Barry Warsaw \u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태\u003c/strong\u003e: Final\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형\u003c/strong\u003e: Standards Track\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일\u003c/strong\u003e: 2000년 7월 13일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전\u003c/strong\u003e: 2.0\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e게시 이력\u003c/strong\u003e: 2000년 7월 27일\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e서론 (Introduction)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 'lockstep iteration' 제안을 설명합니다. 이 문서는 Python 2.0에 도입될 예정이었던 이 기능의 상태와 소유권을 추적합니다. 여기에는 기능에 대한 설명과 이 기능을 지원하는 데 필요한 변경 사항에 대한 개요가 포함되어 있습니다. 이 PEP는 메일링 리스트 포럼에서 진행된 논의를 요약하며, 필요에 따라 추가 정보에 대한 URL을 제공합니다. 이 파일의 CVS 리비전 히스토리는 확정적인 역사적 기록을 담고 있습니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePython의 표준 \u003ccode\u003efor\u003c/code\u003e 루프는 시퀀스가 소진될 때까지 시퀀스의 모든 요소를 반복합니다. 그러나 \u003ccode\u003efor\u003c/code\u003e 루프는 단일 시퀀스만 반복하며, 종종 여러 시퀀스를 'lock-step' 방식으로, 즉 루프의 i번째 반복에서 각 시퀀스의 i번째 요소를 포함하는 객체를 반환하는 방식으로 반복하는 것이 바람직합니다.\u003c/p\u003e\n\u003cp\u003e이를 달성하기 위해 사용되는 일반적인 관용구(idiom)는 직관적이지 않습니다. 이 PEP는 \u003ccode\u003ezip\u003c/code\u003e이라는 새로운 내장 함수를 도입하여 이러한 유형의 반복을 수행하는 표준적인 방법을 제안합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ezip()\u003c/code\u003e의 주요 동기는 lock-step iteration에서 비롯되지만, \u003ccode\u003ezip()\u003c/code\u003e을 내장 함수로 구현함으로써 \u003ccode\u003efor\u003c/code\u003e 루프 이외의 다른 컨텍스트에서도 추가적인 유용성을 가집니다.\u003c/p\u003e\n\u003ch2\u003eLockstep For-Loops (Lockstep For-루프)\u003c/h2\u003e\n\u003cp\u003eLockstep \u003ccode\u003efor\u003c/code\u003e 루프는 둘 이상의 시퀀스에 대해 중첩되지 않은 반복을 수행하며, 루프를 한 번 통과할 때마다 각 시퀀스에서 하나의 요소를 가져와 대상을 구성합니다. 이 동작은 \u003ccode\u003emap()\u003c/code\u003e 내장 함수를 사용하여 Python에서 이미 달성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e a = (1, 2, 3)\n\u003e\u003e\u003e b = (4, 5, 6)\n\u003e\u003e\u003e for i in map(None, a, b):\n...     print i\n...\n(1, 4)\n(2, 5)\n(3, 6)\n\u003e\u003e\u003e map(None, a, b)\n[(1, 4), (2, 5), (3, 6)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efor\u003c/code\u003e 루프는 단순히 이 리스트를 정상적으로 반복합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emap()\u003c/code\u003e 관용구는 Python에서 흔히 사용되지만, 다음과 같은 몇 가지 단점이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e함수형 프로그래밍 배경이 없는 프로그래머에게는 불분명합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e첫 번째 인수로 \u003ccode\u003eNone\u003c/code\u003e을 사용하는 \"마법\" 같은 방식이 불분명합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e리스트의 길이가 같지 않을 때 임의적이고 종종 의도치 않은 유연하지 못한 의미를 가집니다. 짧은 시퀀스는 \u003ccode\u003eNone\u003c/code\u003e으로 채워집니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e c = (4, 5, 6, 7)\n\u003e\u003e\u003e map(None, a, c)\n[(1, 4), (2, 5), (3, 6), (None, 7)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 이유로 Python 2.0 베타 기간 동안 lockstep \u003ccode\u003efor\u003c/code\u003e 루프에 대한 구문 지원을 위한 여러 제안이 나왔습니다. 다음은 두 가지 제안입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor x in seq1, y in seq2: # stuff\n\nfor x, y in seq1, seq2: # stuff\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 형식 중 어느 것도 작동하지 않을 것입니다. 왜냐하면 둘 다 Python에서 이미 어떤 의미를 가지며, 그 의미를 변경하는 것은 기존 코드를 손상시키기 때문입니다. 새로운 구문에 대한 다른 모든 제안들도 동일한 문제를 겪었거나, 'list comprehensions'이라는 다른 제안된 기능(PEP 202 참조)과 충돌했습니다.\u003c/p\u003e\n\u003ch2\u003e제안된 해결책 (The Proposed Solution)\u003c/h2\u003e\n\u003cp\u003e제안된 해결책은 \u003ccode\u003e__builtin__\u003c/code\u003e 모듈에서 사용할 수 있는 새로운 내장 시퀀스 제너레이터(sequence generator) 함수를 도입하는 것입니다. 이 함수는 \u003ccode\u003ezip\u003c/code\u003e이라고 불리며 다음 서명을 가집니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ezip(seqa, [seqb, [...]])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ezip()\u003c/code\u003e은 하나 이상의 시퀀스를 받아 \u003ccode\u003emap(None, ...)\u003c/code\u003e이 길이가 같은 시퀀스에서 하는 것처럼 요소들을 함께 엮습니다. 엮는 작업은 가장 짧은 시퀀스가 소진될 때 중지됩니다.\u003c/p\u003e\n\u003ch2\u003e반환 값 (Return Value)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ezip()\u003c/code\u003e은 \u003ccode\u003emap()\u003c/code\u003e이 하는 방식과 동일하게 실제 Python 리스트를 반환합니다.\u003c/p\u003e\n\u003ch2\u003e예시 (Examples)\u003c/h2\u003e\n\u003cp\u003e아래 참조 구현(Reference Implementation)을 기반으로 한 몇 가지 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e a = (1, 2, 3, 4)\n\u003e\u003e\u003e b = (5, 6, 7, 8)\n\u003e\u003e\u003e c = (9, 10, 11)\n\u003e\u003e\u003e d = (12, 13)\n\u003e\u003e\u003e zip(a, b)\n[(1, 5), (2, 6), (3, 7), (4, 8)]\n\u003e\u003e\u003e zip(a, d)\n[(1, 12), (2, 13)]\n\u003e\u003e\u003e zip(a, b, c, d)\n[(1, 5, 9, 12), (2, 6, 10, 13)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e시퀀스 길이가 같을 때 \u003ccode\u003ezip()\u003c/code\u003e은 역변환(reversible)이 가능합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e a = (1, 2, 3)\n\u003e\u003e\u003e b = (4, 5, 6)\n\u003e\u003e\u003e x = zip(a, b)\n\u003e\u003e\u003e y = zip(*x) # alternatively, apply(zip, x)\n\u003e\u003e\u003e z = zip(*y) # alternatively, apply(zip, y)\n\u003e\u003e\u003e x\n[(1, 4), (2, 5), (3, 6)]\n\u003e\u003e\u003e y\n[(1, 2, 3), (4, 5, 6)]\n\u003e\u003e\u003e z\n[(1, 4), (2, 5), (3, 6)]\n\u003e\u003e\u003e x == z\nTrue\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e시퀀스 길이가 모두 같지 않을 때는 이러한 방식으로 \u003ccode\u003ezip\u003c/code\u003e을 역변환할 수 없습니다.\u003c/p\u003e\n\u003ch2\u003e참조 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003e다음은 \u003ccode\u003ezip()\u003c/code\u003e 내장 함수의 Python 참조 구현입니다. 최종 승인 후에는 C 구현으로 대체될 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef zip(*args):\n    if not args:\n        raise TypeError('zip() expects one or more sequence arguments')\n    ret = []\n    i = 0\n    try:\n        while 1:\n            item = []\n            for s in args:\n                item.append(s[i])\n            ret.append(tuple(item))\n            i = i + 1\n    except IndexError:\n        return ret\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eBDFL의 선언 (BDFL Pronouncements)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e참고\u003c/strong\u003e: BDFL은 Python의 자비로운 종신 독재자(Benevolent Dictator For Life)인 Guido van Rossum을 지칭합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e함수 이름\u003c/strong\u003e: 이 PEP의 이전 버전에는 \u003ccode\u003ezip()\u003c/code\u003e에 대한 20개 이상의 대체 이름이 나열된 미해결 문제가 포함되어 있었습니다. 압도적으로 더 나은 선택지가 없는 상황에서, BDFL은 Haskell에서 유래했기 때문에 \u003ccode\u003ezip()\u003c/code\u003e을 강력히 선호했습니다. \u003ccode\u003ezip()\u003c/code\u003e은 내장 함수여야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e선택적 패딩(Optional padding)\u003c/strong\u003e: 이 PEP의 이전 버전은 인자 시퀀스의 길이가 같지 않을 때 사용될 선택적 \u003ccode\u003epad\u003c/code\u003e 키워드 인자를 제안했습니다. 이는 \u003ccode\u003emap(None, ...)\u003c/code\u003e의 의미와 유사하지만, 사용자가 \u003ccode\u003epad\u003c/code\u003e 객체를 지정할 수 있도록 하는 것이었습니다. 이는 KISS (Keep It Simple, Stupid) 원칙에 따라 가장 짧은 시퀀스에 항상 잘라내는 것을 선호하여 BDFL에 의해 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e지연 평가(Lazy evaluation)\u003c/strong\u003e: 이 PEP의 이전 버전은 \u003ccode\u003ezip()\u003c/code\u003e이 \u003ccode\u003e__getitem__()\u003c/code\u003e 프로토콜을 사용하여 지연 평가를 수행하는 내장 객체를 반환할 것을 제안했습니다. 이는 실제 Python 리스트를 반환하는 것을 선호하여 BDFL에 의해 강력히 거부되었습니다. 미래에 지연 평가가 필요하다면, BDFL은 \u003ccode\u003exzip()\u003c/code\u003e 함수를 추가할 것을 제안합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e인자 없는 \u003ccode\u003ezip()\u003c/code\u003e\u003c/strong\u003e: BDFL은 \u003ccode\u003eTypeError\u003c/code\u003e 예외를 발생시키는 것을 강력히 선호했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e인자 하나를 가진 \u003ccode\u003ezip()\u003c/code\u003e\u003c/strong\u003e: BDFL은 이것이 1-튜플(1-tuple)의 리스트를 반환하는 것을 강력히 선호했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e내부 및 외부 컨테이너 제어(Inner and outer container control)\u003c/strong\u003e: 이 PEP의 이전 버전에는 일부 사람들이 원했던 기능, 즉 내부 및 외부 컨테이너 유형을 제어하는 기능에 대한 논의가 포함되어 있었습니다. 간소화된 API와 구현을 고려할 때, 이 기능은 거부되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e\u003ccode\u003ezip()\u003c/code\u003e의 후속 변경 (Subsequent Change to zip())\u003c/h2\u003e\n\u003cp\u003ePython 2.4에서 인자 없는 \u003ccode\u003ezip()\u003c/code\u003e은 \u003ccode\u003eTypeError\u003c/code\u003e 예외를 발생시키는 대신 빈 리스트를 반환하도록 수정되었습니다. 원래 동작은 인자의 부재가 프로그래밍 오류를 나타낸다고 생각되었기 때문입니다. 그러나 이는 \u003ccode\u003e*\u003c/code\u003e 연산자를 사용하여 가변 길이 인자 리스트를 언팩(unpack)하는 \u003ccode\u003ezip()\u003c/code\u003e의 사용을 예상하지 못했습니다. 예를 들어, \u003ccode\u003ezip\u003c/code\u003e의 역함수는 \u003ccode\u003eunzip = lambda s: zip(*s)\u003c/code\u003e와 같이 정의될 수 있습니다. 이러한 변환은 행렬 전치(matrix transpose)나 테이블의 행/열 교환에도 사용되며, 특히 레코드를 행으로, 필드를 열로 하는 데이터 파일을 읽을 때 유용합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 다음 코드는:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edate, rain, high, low = zip(*csv.reader(file(\"weather.csv\")))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e각 필드가 개별 튜플로 수집되어 직접적인 반복 및 요약이 가능하도록 열 기반 데이터를 재정렬합니다. \u003ccode\u003ezip(*[])\u003c/code\u003e이 예외가 아닌 허용 가능한 경우로 처리될 경우 \u003ccode\u003ezip(*args)\u003c/code\u003e를 사용하는 것이 더 쉽게 코딩됩니다. 이 가능성을 보고, BDFL은 (약간의 망설임과 함께) Python 2.4에서 동작을 변경하는 것에 동의했습니다.\u003c/p\u003e\n\u003ch2\u003e기타 변경 사항 (Other Changes)\u003c/h2\u003e\n\u003cp\u003e위에서 논의된 \u003ccode\u003exzip()\u003c/code\u003e 함수는 Python 2.3의 \u003ccode\u003eitertools\u003c/code\u003e 모듈에 \u003ccode\u003eitertools.izip()\u003c/code\u003e으로 구현되었습니다. 이 함수는 지연 동작(lazy behavior)을 제공하여, 각 반복에서 단일 요소를 소비하고 단일 튜플을 생성합니다. \"Just-in-time\" 방식은 메모리를 절약하고 리스트 기반 \u003ccode\u003ezip()\u003c/code\u003e보다 빠르게 실행됩니다. \u003ccode\u003eitertools\u003c/code\u003e 모듈은 또한 \u003ccode\u003eitertools.repeat()\u003c/code\u003e과 \u003ccode\u003eitertools.chain()\u003c/code\u003e을 추가했습니다. 이러한 도구들은 함께 사용하여 시퀀스를 \u003ccode\u003eNone\u003c/code\u003e으로 채울 수 있습니다 (\u003ccode\u003emap(None, seqn)\u003c/code\u003e의 동작과 일치하도록):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ezip(firstseq, chain(secondseq, repeat(None)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e참고 자료 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ehttp://docs.python.org/reference/compound_stmts.html#for\u003c/li\u003e\n\u003cli\u003ehttp://www.haskell.org/onlinereport/standard-prelude.html#$vzip\u003c/li\u003e\n\u003cli\u003eGreg Wilson이 일부 CS 대학원생에게 제안된 구문에 대해 설문 조사: http://www.python.org/pipermail/python-dev/2000-July/013139.html\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1599,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 201 - Lockstep Iteration\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 16:10:52+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>