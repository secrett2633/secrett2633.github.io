3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-89b393b6f6553dc8.js","185","static/chunks/app/layout-b06e577e11976c7d.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js"],""]
4:["slug","python/pep/735","c"]
0:["3S0Yhp4qrbYK7pFtngQE8",[[["",{"children":[["slug","python/pep/735","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"735\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/735","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e975486d410ad4e9.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T6f92,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0735/">PEP 735 - Dependency Groups in pyproject.toml</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 20-Nov-2023</p>
</blockquote>
<h2>PEP 735 – <code>pyproject.toml</code> 내 의존성 그룹 (Dependency Groups)</h2>
<p><strong>상태:</strong> Final (최종)
<strong>유형:</strong> Standards Track (표준 추적)
<strong>주제:</strong> Packaging (패키징)
<strong>생성일:</strong> 2023년 11월 20일
<strong>해결일:</strong> 2024년 10월 10일</p>
<p><strong>중요 사항:</strong> 이 PEP는 역사적 문서입니다. 최신 규격인 Dependency Groups는 PyPA specs 페이지에서 유지 관리됩니다.</p>
<h3>초록 (Abstract)</h3>
<p>이 PEP는 프로젝트의 빌드된 배포판에 포함되지 않는 방식으로 <code>pyproject.toml</code> 파일에 패키지 요구사항을 저장하는 메커니즘을 명시합니다. 이는 <code>requirements.txt</code> 파일과 유사하게, 런처(launcher), IDE 및 기타 도구가 이름으로 찾아 식별할 수 있는 명명된 의존성 그룹을 생성하는 데 적합합니다. 여기서 정의된 기능은 "의존성 그룹(Dependency Groups)"이라고 불립니다.</p>
<h3>동기 (Motivation)</h3>
<p>파이썬 커뮤니티에는 표준화된 답변이 없는 두 가지 주요 사용 사례가 있습니다.</p>
<ol>
<li>패키지의 개발 의존성을 어떻게 정의해야 하는가?</li>
<li>배포판을 빌드하지 않는 프로젝트(비-패키지 프로젝트)의 의존성을 어떻게 정의해야 하는가?</li>
</ol>
<p>이 두 가지 요구사항을 지원하기 위해 이 제안과 유사한 두 가지 일반적인 해결책이 있습니다.</p>
<ul>
<li><code>requirements.txt</code> 파일</li>
<li><code>extras</code></li>
</ul>
<p><code>requirements.txt</code> 파일과 <code>extras</code> 모두 이 표준이 극복하고자 하는 한계를 가지고 있습니다.</p>
<p>이 PEP가 지원하고자 하는 두 가지 다른 유형의 프로젝트는 다음과 같습니다.</p>
<ul>
<li>라이브러리와 같은 파이썬 패키지</li>
<li>데이터 과학 프로젝트와 같은 비-패키지 프로젝트</li>
</ul>
<h4><code>requirements.txt</code> 파일의 한계</h4>
<p>많은 프로젝트가 하나 이상의 <code>requirements.txt</code> 파일을 정의할 수 있으며, 프로젝트 루트(예: <code>requirements.txt</code> 및 <code>test-requirements.txt</code>) 또는 디렉토리(예: <code>requirements/base.txt</code> 및 <code>requirements/test.txt</code>)에 배치할 수 있습니다. 그러나 이러한 방식으로 요구사항 파일을 사용하는 데에는 주요 문제가 있습니다.</p>
<ul>
<li>도구가 이러한 파일을 이름으로 검색하거나 사용할 수 있는 표준화된 명명 규칙이 없습니다.</li>
<li><code>requirements.txt</code> 파일은 표준화되어 있지 않고, 대신 <code>pip</code>에 옵션을 제공합니다.
<ul>
<li>결과적으로 <code>requirements.txt</code> 파일을 기반으로 도구 동작을 정의하기 어렵습니다.</li>
<li>이름으로 발견하거나 식별하기가 쉽지 않으며, 그 내용은 패키지 지정자(package specifiers)와 추가 <code>pip</code> 옵션이 혼합되어 있을 수 있습니다.</li>
<li><code>requirements.txt</code> 내용에 대한 표준의 부재는 <code>pip</code> 이외의 다른 도구에서 처리할 때 이식성이 없다는 것을 의미하기도 합니다.</li>
</ul>
</li>
<li>또한, <code>requirements.txt</code> 파일은 의존성 목록당 하나의 파일을 필요로 합니다. 특정 사용 사례의 경우, 이는 의존성 그룹화의 한계 비용을 이점과 비교하여 높게 만듭니다. 여러 개의 작은 의존성 그룹을 가진 프로젝트에는 더 간결한 선언이 유용합니다.</li>
</ul>
<p>이와 대조적으로, 의존성 그룹(Dependency Groups)은 <code>pyproject.toml</code>의 잘 알려진 위치에 완전히 표준화된 내용으로 정의됩니다.</p>
<h4><code>extras</code>의 한계</h4>
<p><code>extras</code>는 <code>[project.optional-dependencies]</code> 테이블에 선언된 추가 패키지 메타데이터입니다. 이는 패키지의 메타데이터의 일부로 게시되는 패키지 지정자 목록에 이름을 제공하며, 사용자는 <code>pip install 'foo[bar]'</code>와 같이 해당 이름으로 요청하여 <code>foo</code>를 <code>bar extra</code>와 함께 설치할 수 있습니다.</p>
<p><code>extras</code>는 패키지 메타데이터이므로 정적으로 정의된다는 보장이 없으며 해결하기 위해 빌드 시스템이 필요할 수 있습니다. 또한, <code>[project.optional-dependencies]</code>의 정의는 많은 도구에 프로젝트가 패키지임을 나타내며, <code>[project]</code> 테이블의 유효성 검사와 같은 도구 동작을 유도할 수 있습니다.</p>
<p>패키지인 프로젝트의 경우, <code>extras</code>는 개발 의존성을 정의하는 일반적인 해결책이지만, 이러한 상황에서도 단점이 있습니다.</p>
<ul>
<li><code>extra</code>는 선택적 추가 의존성을 정의하므로, 현재 패키지 및 그 의존성을 설치하지 않고 <code>extra</code>를 설치하는 것은 불가능합니다.</li>
<li>사용자가 설치할 수 있기 때문에 <code>extras</code>는 패키지의 공개 인터페이스의 일부입니다.</li>
<li><code>extras</code>가 게시되므로, 패키지 개발자는 개발 <code>extras</code>가 사용자 대면 <code>extras</code>와 혼동되지 않도록 보장하는 데 종종 신경을 씁니다.</li>
</ul>
<h3>근거 (Rationale)</h3>
<p>이 PEP는 <code>[dependency-groups]</code> 테이블 내의 목록에 요구사항 데이터를 저장하는 것을 정의합니다. 이 이름은 기능의 표준 이름("Dependency Groups")과 일치하도록 선택되었습니다.</p>
<p>이 형식은 많은 경우에 기존 <code>requirements.txt</code> 파일과 매우 유사한 형식을 가지며 가능한 한 간단하고 배우기 쉬워야 합니다. <code>[dependency-groups]</code>의 각 목록은 패키지 지정자 목록으로 정의됩니다. 예를 들어:</p>
<pre><code class="language-toml">[dependency-groups]
test = ["pytest>7", "coverage"]
</code></pre>
<p><code>requirements.txt</code> 파일에는 PEP 508 의존성 지정자(dependency specifiers)로 표현할 수 없는 데이터를 요구하는 여러 사용 사례가 있습니다. 이러한 필드는 의존성 그룹(Dependency Groups)에서는 유효하지 않습니다. 인덱스 서버, 해시, 경로 의존성 등 <code>pip</code>이 지원하는 많은 데이터와 필드를 포함하려면 새로운 표준이 필요합니다. 이 표준은 새로운 표준 및 개발을 위한 여지를 남겨두지만, 모든 유효한 <code>requirements.txt</code> 내용을 지원하려고 시도하지는 않습니다.</p>
<p>유일한 예외는 <code>requirements.txt</code> 파일이 다른 파일을 포함하는 데 사용하는 <code>-r</code> 플래그입니다. 의존성 그룹은 유사한 의미의 "include" 메커니즘을 지원하여 하나의 의존성 그룹이 다른 그룹을 확장할 수 있도록 합니다.</p>
<p>의존성 그룹에는 <code>requirements.txt</code> 파일과 유사한 두 가지 추가 기능이 있습니다.</p>
<ul>
<li>빌드된 배포판에 별도의 메타데이터로 게시되지 않습니다.</li>
<li>의존성 그룹을 설치한다고 해서 패키지의 의존성이나 패키지 자체의 설치가 암시되지는 않습니다.</li>
</ul>
<h4>사용 사례 (Use Cases)</h4>
<p>이 PEP의 중요한 목표로 간주되는 다음 사용 사례가 있습니다. 이는 "부록 C: 사용 사례(Appendix C: Use Cases)"에 자세히 정의되어 있습니다.</p>
<ul>
<li>파이썬 패키징 빌드 프로세스를 거치지 않고 배포되는 웹 애플리케이션</li>
<li>게시되지 않은 개발 의존성 그룹을 가진 라이브러리</li>
<li>의존성 그룹은 있지만 핵심 패키지가 없는 데이터 과학 프로젝트</li>
<li>락 파일(lockfile) 생성에 대한 입력 데이터 (의존성 그룹은 일반적으로 잠긴 의존성 데이터를 위한 위치로 사용되어서는 안 됩니다.)</li>
<li><code>tox</code>, <code>Nox</code>, <code>Hatch</code>와 같은 환경 관리자(environment manager)에 대한 입력 데이터</li>
<li>테스트 및 린터(linter) 요구사항의 구성 가능한 IDE 검색</li>
</ul>
<h4>Poetry 및 PDM 의존성 그룹 관련</h4>
<p>기존의 <code>Poetry</code> 및 <code>PDM</code> 도구는 각각 "Dependency Groups"라고 부르는 기능을 이미 제공합니다. 그러나 의존성 컬렉션을 지정하기 위한 표준이 없기 때문에 각 도구는 <code>[tool]</code> 테이블의 관련 섹션에서 도구별 방식으로 이를 정의합니다. (PDM은 일부 의존성 그룹에 <code>extras</code>도 사용하며 <code>extras</code> 개념과 많이 겹칩니다.)</p>
<p>이 PEP는 <code>Poetry</code> 및 <code>PDM</code>의 모든 기능을 지원하지 않습니다. 이러한 도구는 <code>pip</code>의 <code>requirements.txt</code> 파일과 마찬가지로 일반적인 의존성 지정자에 대한 여러 비표준 확장을 지원합니다.</p>
<p>이러한 도구는 표준화된 의존성 그룹을 자체 의존성 그룹 메커니즘의 확장으로 사용할 수 있어야 합니다. 그러나 기존 <code>Poetry</code> 및 <code>PDM</code> 솔루션을 대체하는 새로운 데이터 형식을 정의하는 것은 목표가 아닙니다. 그렇게 하려면 이러한 도구에서 지원하는 경로 의존성(path dependencies)과 같은 몇 가지 추가 기능을 표준화해야 합니다.</p>
<h4>의존성 그룹은 숨겨진 Extras가 아닙니다.</h4>
<p>의존성 그룹은 게시되지 않는 <code>extras</code>와 매우 유사합니다. 그러나 <code>extras</code>와는 다음과 같은 두 가지 주요 기능으로 구별됩니다.</p>
<ul>
<li>비-패키지 프로젝트를 지원합니다.</li>
<li>의존성 그룹을 설치한다고 해서 패키지의 의존성(또는 패키지 자체) 설치가 암시되지는 않습니다.</li>
</ul>
<h3>명세 (Specification)</h3>
<p>이 PEP는 <code>pyproject.toml</code> 파일에 <code>dependency-groups</code>라는 새 섹션(테이블)을 정의합니다. <code>dependency-groups</code> 테이블은 임의의 수의 사용자 정의 키를 포함하며, 각 키의 값은 요구사항(아래 정의됨) 목록입니다. 이 키는 유효한 비정규화된 이름이어야 하며, 비교하기 전에 정규화되어야 합니다.</p>
<p>도구는 기본적으로 원래의 비정규화된 이름을 사용자에게 제공하는 것을 선호해야 합니다. 정규화 후 중복된 이름이 발견되면, 도구는 오류를 발생시켜야 합니다.</p>
<p><code>dependency-groups</code> 아래의 요구사항 목록은 문자열, 테이블(파이썬에서는 "dict"), 또는 문자열과 테이블의 혼합을 포함할 수 있습니다.</p>
<ul>
<li>요구사항 목록의 문자열은 PEP 508에 정의된 유효한 의존성 지정자(Dependency Specifiers)여야 합니다.</li>
<li>요구사항 목록의 테이블은 유효한 의존성 객체 지정자(Dependency Object Specifiers)여야 합니다.</li>
</ul>
<h4>의존성 객체 지정자 (Dependency Object Specifiers)</h4>
<p>의존성 객체 지정자는 0개 이상의 의존성을 정의하는 테이블입니다. 이 PEP는 단 한 가지 유형의 의존성 객체 지정자인 "의존성 그룹 포함(Dependency Group Include)"만을 표준화합니다. 다른 유형은 향후 표준에서 추가될 수 있습니다.</p>
<h4>의존성 그룹 포함 (Dependency Group Include)</h4>
<p>의존성 그룹 포함은 다른 의존성 그룹의 의존성을 현재 의존성 그룹에 포함합니다. 포함은 정확히 하나의 키 <code>"include-group"</code>을 가진 테이블로 정의되며, 그 값은 다른 의존성 그룹의 이름인 문자열입니다.</p>
<p>예를 들어, <code>{include-group = "test"}</code>는 <code>test</code> 의존성 그룹의 내용을 확장하는 포함입니다.</p>
<p>포함은 명명된 의존성 그룹의 내용과 정확히 동일하게 정의되며, 포함 위치에 현재 그룹에 삽입됩니다. 예를 들어, <code>foo = ["a", "b"]</code>가 하나의 그룹이고 <code>bar = ["c", {include-group = "foo"}, "d"]</code>가 다른 그룹이라면, 의존성 그룹 포함이 확장될 때 <code>bar</code>는 <code>["c", "a", "b", "d"]</code>로 평가되어야 합니다.</p>
<p>의존성 그룹 포함은 동일한 패키지를 여러 번 지정할 수 있습니다. 도구는 포함에 의해 생성된 목록 내용을 중복 제거하거나 다른 방식으로 변경해서는 안 됩니다.</p>
<p>의존성 그룹 포함은 의존성 그룹 포함을 포함하는 목록을 포함할 수 있으며, 이 경우 해당 포함도 확장되어야 합니다. 의존성 그룹 포함은 순환(cycle)을 포함해서는 안 되며, 도구는 순환을 감지하면 오류를 보고해야 합니다.</p>
<h4>예시 의존성 그룹 테이블 (Example Dependency Groups Table)</h4>
<p>다음은 네 개의 의존성 그룹(<code>test</code>, <code>docs</code>, <code>typing</code>, <code>typing-test</code>)을 정의하기 위해 이를 사용하는 부분적인 <code>pyproject.toml</code>의 예시입니다.</p>
<pre><code class="language-toml">[dependency-groups]
test = ["pytest", "coverage"]
docs = ["sphinx", "sphinx-rtd-theme"]
typing = ["mypy", "types-requests"]
typing-test = [{include-group = "typing"}, {include-group = "test"}, "useful-types"]
</code></pre>
<p>이러한 의존성 그룹 선언 중 어떤 것도 현재 패키지, 그 의존성 또는 선택적 의존성을 암시적으로 설치하지 않습니다. <code>test</code>와 같은 의존성 그룹을 사용하여 패키지를 테스트하려면 사용자 구성 또는 도구 체인도 현재 패키(<code>.</code> )를 설치해야 합니다.</p>
<h4>패키지 빌딩 (Package Building)</h4>
<p>빌드 백엔드(build backends)는 빌드된 배포판에 의존성 그룹 데이터를 패키지 메타데이터로 포함해서는 안 됩니다. 이는 <code>sdists</code>의 <code>PKG-INFO</code> 및 <code>wheels</code>의 <code>METADATA</code>에 의존성 그룹을 포함하는 참조 가능한 필드가 없음을 의미합니다.</p>
<p>동적 메타데이터 평가에 의존성 그룹을 사용하는 것은 유효하며, <code>sdists</code>에 포함된 <code>pyproject.toml</code> 파일은 자연스럽게 <code>[dependency-groups]</code> 테이블을 계속 포함할 것입니다. 그러나 테이블 내용은 게시된 패키지의 인터페이스의 일부가 아닙니다.</p>
<h4>의존성 그룹 설치 (Installing Dependency Groups)</h4>
<p>의존성 그룹을 지원하는 도구는 사용자가 의존성 그룹에서 설치할 수 있도록 새로운 옵션과 인터페이스를 제공할 것으로 예상됩니다.</p>
<p>패키지의 의존성 그룹을 표현하기 위한 구문은 두 가지 이유로 정의되지 않습니다.</p>
<ol>
<li>PyPI에서 타사 패키지의 의존성 그룹을 참조하는 것은 유효하지 않습니다(데이터가 게시되지 않도록 정의되어 있기 때문입니다).</li>
<li>의존성 그룹에 대한 현재 패키지가 보장되지 않습니다 – 그 목적 중 일부는 비-패키지 프로젝트를 지원하는 것입니다.</li>
</ol>
<p>예를 들어, 의존성 그룹을 설치하기 위한 가능한 <code>pip</code> 인터페이스는 다음과 같습니다.</p>
<pre><code class="language-bash">pip install --dependency-groups=test,typing
</code></pre>
<p>이것은 예시일 뿐입니다. 이 PEP는 도구가 의존성 그룹 설치를 어떻게 지원해야 하는지에 대한 요구사항을 선언하지 않습니다.</p>
<h3>어떻게 가르칠 것인가 (How to Teach This)</h3>
<p>이 기능은 표준 이름인 "의존성 그룹(Dependency Groups)"으로 불려야 합니다.</p>
<p>기본적인 사용 형태는 일반적인 <code>requirements.txt</code> 데이터의 변형으로 가르쳐져야 합니다. 표준 의존성 지정자(PEP 508)는 명명된 목록에 추가될 수 있습니다. <code>pip</code>에게 <code>requirements.txt</code> 파일에서 설치하도록 요청하는 대신, <code>pip</code> 또는 관련 워크플로우 도구가 명명된 의존성 그룹에서 설치할 것입니다.</p>
<p>새로운 파이썬 사용자에게는 현재 <code>requirements.txt</code> 파일을 사용하는 방법을 배우는 것과 유사하게, <code>pyproject.toml</code>에 의존성 그룹을 포함하는 섹션을 직접 생성하도록 가르칠 수 있습니다. 이는 또한 새로운 파이썬 사용자가 패키지 빌딩에 대해 배울 필요 없이 <code>pyproject.toml</code> 파일에 대해 배울 수 있도록 합니다. <code>[dependency-groups]</code>만 있고 다른 테이블이 없는 <code>pyproject.toml</code> 파일도 유효합니다.</p>
<p>새로운 사용자와 숙련된 사용자 모두에게 의존성 그룹 포함(Dependency Group Includes)을 설명해야 합니다. <code>requirements.txt</code> 사용 경험이 있는 사용자에게는 <code>-r</code>의 유사체로 설명할 수 있습니다. 새로운 사용자에게는 포함이 하나의 의존성 그룹이 다른 그룹을 확장할 수 있도록 한다고 가르쳐야 합니다. 유사한 구성 인터페이스와 파이썬 <code>list.extend</code> 메서드를 비유로 사용하여 아이디어를 설명할 수 있습니다.</p>
<h3>거부된 아이디어 (Rejected Ideas)</h3>
<h4>각 의존성 그룹을 테이블로 정의하지 않는 이유</h4>
<p>각 의존성 그룹을 하위 테이블로 정의하여 각 그룹에 향후 키를 연결할 수 있도록 하는 것이 미래 확장성을 위한 가장 큰 유연성을 제공합니다. 그러나 이는 구조를 더 깊게 중첩시켜 가르치고 배우기 어렵게 만듭니다. 이 PEP의 목표 중 하나는 많은 <code>requirements.txt</code> 사용 사례에 대한 쉬운 대체제가 되는 것입니다.</p>
<h4>PEP 508 외의 더 많은 의존성 지정자를 허용하지 않는 이유</h4>
<p>논의 중에 PEP 508로 가능한 것보다 더 표현적인 지정자가 필요한 여러 사용 사례가 있었습니다. 특히 로컬 경로를 참조하는 "경로 의존성(Path Dependencies)"과 <code>[project.dependencies]</code>에 대한 참조가 특히 관심사였습니다.</p>
<p>그러나 이러한 기능에 대한 기존 표준이 없습니다(pip의 구현 세부 사항이라는 사실상의 표준 제외). 결과적으로, 이러한 기능을 이 PEP에 포함하려고 시도하면 이러한 다양한 기능과 <code>pip</code> 동작을 표준화하려는 시도로 인해 범위가 상당히 확대됩니다.</p>
<h3>지연된 아이디어 (Deferred Ideas)</h3>
<h4><code>[project.dependencies]</code> 또는 <code>[project.optional-dependencies]</code>에서 의존성 그룹 포함을 지원하지 않는 이유</h4>
<p>이 명세의 초기 초안은 <code>[project]</code> 테이블에서 의존성 그룹 포함을 사용할 수 있도록 허용했습니다. 그러나 커뮤니티 피드백 중에 제거로 이어진 여러 문제가 제기되었습니다.</p>
<p>의존성 그룹을 포함함으로써 해결될 추가 사용 사례는 소수에 불과했으며, 명세의 범위를 상당히 증가시켰습니다. 특히, 이러한 포함은 추가로 인해 영향을 받는 당사자의 수를 증가시킬 것입니다. 빌드 백엔드, SBOM 생성기 및 의존성 분석기를 포함하여 <code>[project]</code> 테이블을 읽는 많은 주체는 <code>[project]</code> 변경으로 인해 영향을 받지만, 새로운 (그러나 연결되지 않은) <code>[dependency-groups]</code> 테이블이 있는 경우 현재 상태로 계속 작동할 수 있습니다.</p>
<p>위의 우려와는 별개로, <code>[project]</code> 테이블에서 의존성 그룹의 포함을 허용하면 패키지 관리자가 의존성 메타데이터를 현재 표준 위치 밖으로 이동하도록 장려하게 됩니다. 이는 정적 <code>pyproject.toml</code> 메타데이터를 복잡하게 만들고 의존성 메타데이터를 한 곳에 저장하려는 PEP 621의 목표와 충돌합니다.</p>
<p>마지막으로, 이 PEP에서 <code>[project]</code> 지원을 제외하는 것은 최종적인 것이 아닙니다. 해당 테이블에서 포함을 사용하거나 <code>[dependency-groups]</code>에서 <code>[project]</code>로의 포함 구문은 향후 PEP에 의해 도입되어 자체적인 장점으로 고려될 수 있습니다.</p>
<h3>부록 C: 사용 사례 (Appendix C: Use Cases)</h3>
<h4>웹 애플리케이션 (Web Applications)</h4>
<p>웹 애플리케이션(예: Django 또는 Flask 앱)은 종종 배포판을 빌드할 필요가 없지만, 소스를 배포 도구 체인에 번들링하여 제공합니다. 이러한 애플리케이션은 빌드뿐만 아니라 린팅, 테스트 등을 위한 의존성 그룹을 가집니다. 오늘날 이러한 애플리케이션은 종종 패키징 도구와 <code>extras</code>와 같은 메커니즘을 사용하여 의존성 그룹을 관리하기 위해 자신을 패키지로 정의합니다. 그러나 개념적으로는 <code>sdist</code> 또는 <code>wheel</code> 형식으로 배포하기 위한 패키지가 아닙니다.</p>
<p>의존성 그룹은 이러한 애플리케이션이 패키징 메타데이터에 의존하거나 패키징 용어로 요구 사항을 표현하려고 하지 않고도 다양한 의존성을 정의할 수 있도록 합니다.</p>
<h4>라이브러리 (Libraries)</h4>
<p>라이브러리는 배포판(<code>sdist</code> 및 <code>wheel</code>)을 빌드하고 PyPI에 게시하는 파이썬 패키지입니다. 라이브러리의 경우, 의존성 그룹은 개발 의존성 그룹을 정의하기 위한 <code>extras</code>의 대안을 나타내며, 위에서 언급한 중요한 장점이 있습니다.</p>
<p>라이브러리는 테스트 및 타입 확인을 허용하는 <code>test</code> 및 <code>typing</code> 그룹을 정의할 수 있으며, 따라서 라이브러리 자체의 의존성( <code>[project.dependencies]</code>에 지정된 대로)에 의존합니다.</p>
<p>다른 개발 요구 사항은 패키지 설치를 전혀 요구하지 않을 수도 있습니다. 예를 들어, <code>lint</code> 의존성 그룹은 라이브러리 없이도 유효하고 더 빠르게 설치될 수 있습니다.</p>
<h4>데이터 과학 프로젝트 (Data Science Projects)</h4>
<p>데이터 과학 프로젝트는 일반적으로 공통 도구 체인을 사용하여 데이터를 처리하고 분석하기 위한 스크립트 및 유틸리티의 논리적 컬렉션 형태로 구성됩니다. 구성 요소는 Jupyter Notebook 형식(ipynb)으로 정의될 수 있지만, 동일한 공통 핵심 유틸리티 세트에 의존합니다.</p>
<p>이러한 프로젝트에서는 빌드하거나 설치할 패키지가 없습니다. 따라서 <code>pyproject.toml</code>은 현재 의존성 관리 또는 선언에 대한 해결책을 제공하지 않습니다.</p>
<p>이러한 프로젝트의 경우 적어도 하나의 주요 의존성 그룹을 정의할 수 있는 것이 중요합니다. 예를 들어:</p>
<pre><code class="language-toml">[dependency-groups]
main = ["numpy", "pandas", "matplotlib"]
</code></pre>
<p>그러나 다양한 스크립트에 추가 지원 도구가 필요할 수도 있습니다. 프로젝트는 시간이 지남에 따라 다른 구성 요소에 대해 충돌하거나 호환되지 않는 도구 또는 도구 버전을 가질 수도 있습니다.</p>
<p>다음과 같은 보다 정교한 구성을 고려해 보십시오.</p>
<pre><code class="language-toml">[dependency-groups]
main = ["numpy", "pandas", "matplotlib"]
scikit = [{include-group = "main"}, "scikit-learn==1.3.2"]
scikit-old = [{include-group = "main"}, "scikit-learn==0.24.2"]
</code></pre>
<p>이는 <code>scikit</code>과 <code>scikit-old</code>를 공통 의존성 모음의 두 가지 유사한 변형으로 정의하며, 다른 스크립트에 맞게 <code>scikit-learn</code>의 다른 버전을 가져옵니다.</p>
<h4>락 파일 생성 (Lockfile Generation)</h4>
<p>오늘날 파이썬 생태계에는 락 파일을 생성하는 여러 도구가 있습니다. <code>PDM</code>과 <code>Poetry</code>는 각각 자체 락 파일 형식을 사용하며, <code>pip-tools</code>는 버전 핀과 해시를 포함하는 <code>requirements.txt</code> 파일을 생성합니다.</p>
<p>의존성 그룹은 필요한 많은 기능이 부족하므로 락 파일을 저장하기에 적절한 장소가 아닙니다. 가장 중요한 것은 대부분의 락 파일 사용자가 필수적이라고 생각하는 해시를 저장할 수 없다는 것입니다.</p>
<p>그러나 의존성 그룹은 락 파일을 생성하는 도구에 대한 유효한 입력입니다. 또한 <code>PDM</code>과 <code>Poetry</code>는 모두 (자체 의존성 그룹 개념에 따라) 의존성 그룹 이름을 사용하여 해당 그룹의 잠긴 변형을 참조할 수 있도록 합니다.</p>
<h4>환경 관리자 입력 (Environment Manager Inputs)</h4>
<p><code>tox</code>, <code>Nox</code>, <code>Hatch</code>에서 흔히 사용되는 방식은 테스트 환경에 일련의 의존성을 설치하는 것입니다.</p>
<p>예를 들어, <code>tox.ini</code> 아래에 타입 확인 의존성이 인라인으로 정의될 수 있습니다.</p>
<pre><code class="language-ini">[testenv:typing]
deps = pyright
       useful-types
commands = pyright src/
</code></pre>
<p>이 조합은 제한된 컨텍스트 내에서 바람직한 개발자 경험을 제공합니다. 관련 환경 관리자 아래에서, 테스트 환경에 필요한 의존성은 해당 의존성이 필요한 명령과 함께 선언됩니다. 이는 <code>extras</code>처럼 패키지 메타데이터에 게시되지 않으며, 관련 환경을 구축하는 데 필요한 도구에 의해 검색 가능합니다.</p>
<p>의존성 그룹은 이러한 요구사항 데이터를 도구별 위치에서 더 광범위하게 사용할 수 있는 위치로 효과적으로 "끌어올림"으로써 이러한 용도에 적용됩니다.</p>
<h4>IDE 및 편집기의 요구사항 데이터 사용 (IDE and Editor Use of Requirements Data)</h4>
<p>IDE 및 편집기 통합은 통합에 사용되는 의존성 그룹에 대한 관례적이거나 구성 가능한 이름 정의의 이점을 누릴 수 있습니다.</p>
<p>편집기 또는 IDE가 프로젝트의 게시되지 않은 의존성을 검색할 수 있는 것이 유용한 두 가지 알려진 시나리오가 있습니다.</p>
<ul>
<li><strong>테스트:</strong> VS Code와 같은 IDE는 특정 테스트를 실행하기 위한 GUI 인터페이스를 지원합니다.</li>
<li><strong>린팅:</strong> 편집기 및 IDE는 종종 오류를 강조 표시하거나 자동 수정하는 린팅 및 자동 서식 통합을 지원합니다.</li>
</ul>
<p>이러한 경우는 <code>test</code>, <code>lint</code>, <code>fix</code>와 같은 관례적인 그룹 이름을 정의하거나 의존성 그룹을 선택할 수 있는 구성 메커니즘을 정의하여 처리할 수 있습니다.</p>
<p>예를 들어, 다음 <code>pyproject.toml</code>은 앞서 언급한 세 그룹을 선언합니다.</p>
<pre><code class="language-toml">[dependency-groups]
test = ["pytest", "pytest-timeout"]
lint = ["flake8", "mypy"]
fix = ["black", "isort", "pyupgrade"]
</code></pre>
<p>이 PEP는 이러한 이름을 표준화하거나 이러한 용도로 예약하려고 시도하지 않습니다. IDE는 다양한 목적에 사용되는 그룹 이름을 표준화하거나 사용자가 구성할 수 있도록 허용할 수 있습니다.</p>
<p>이 선언은 프로젝트에 적합한 도구에 대한 프로젝트 작성자의 지식을 해당 프로젝트의 모든 편집자와 공유할 수 있도록 합니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1615,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 735 - Dependency Groups in pyproject.toml"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-27 13:26:47+0900","children":"2025년 9월 27일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 27일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://blog.secrett2633.site/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://blog.secrett2633.site/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","22",{"name":"next-size-adjust"}]]
1:null
