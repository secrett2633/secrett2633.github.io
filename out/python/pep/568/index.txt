3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-aea36c7c8fc4866f.js","185","static/chunks/app/layout-b06e577e11976c7d.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-eb985a9c6ac1f073.js"],""]
4:["slug","python/pep/568","c"]
0:["IohWMDsTTjKMLrs8H0jIq",[[["",{"children":[["slug","python/pep/568","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"568\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/568","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/edf391eeca43d999.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T4a53,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0568/">PEP 568 - Generator-sensitivity for Context Variables</a></p>
<p><strong>상태:</strong> Deferred | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 04-Jan-2018</p>
</blockquote>
<p>다음은 Python Enhancement Proposal (PEP) 568 문서의 한국어 번역 및 정리입니다. 이 문서는 <code>Context Variable</code>에 대한 <code>Generator</code> 감도 (Generator-sensitivity)를 추가하는 내용을 다루고 있습니다.</p>
<hr>
<h1>PEP 568 – Context Variables에 대한 Generator 감도</h1>
<ul>
<li><strong>작성자:</strong> Nathaniel J. Smith </li>
<li><strong>상태:</strong> Deferred (보류됨)</li>
<li><strong>유형:</strong> Standards Track</li>
<li><strong>생성일:</strong> 2018년 1월 4일</li>
<li><strong>Python 버전:</strong> 3.8</li>
<li><strong>이력:</strong> (Post-History는 생략)</li>
</ul>
<h2>초록 (Abstract)</h2>
<p><code>Context variable</code>은 스레드-로컬 저장소 (thread-local storage)와 유사하지만, <code>asyncio Task</code>와 같은 다른 종류의 스레드와 유사한 컨텍스트에도 작동하도록 일반화된, 동적이고 컨텍스트-로컬 (context-local) 상태를 추적하기 위한 일반적인 메커니즘을 제공합니다. [PEP 550]은 <code>Generator</code> 컨텍스트에도 민감하게 반응하는 컨텍스트-로컬 상태 메커니즘을 제안했지만, 이는 상당히 복잡했습니다. 이에 BDFL (Python의 자비로운 종신독재자)은 이를 단순화할 것을 요청했고, 그 결과로 [PEP 567]이 나왔으며 Python 3.7에 포함될 예정이었습니다. 이 PEP 568은 PEP 567의 메커니즘을 확장하여 <code>Generator</code> 컨텍스트 감도 (generator context sensitivity)를 추가합니다.</p>
<p>이 PEP는 Python 3.7 기능 동결 (feature freeze) 전에 충분한 시간을 가지고 검토할 수 없었으므로 "deferred" 상태로 시작되었습니다. 현재 유일한 목표는 Python 3.8에서 <code>Generator</code> 컨텍스트 감도를 추가하기 위해 무엇이 필요한지 이해하는 것이며, 이를 통해 Python 3.7에서 의도치 않게 이 기능을 배제하는 것을 방지하는 것입니다. (의도적으로 배제하는 것은 Python 3.8까지 기다릴 수 있습니다.)</p>
<h2>배경 (Rationale)</h2>
<p>(현재 이 PEP의 목적은 이것이 어떻게 작동할지 이해하는 것이며, 이것이 좋은 아이디어인지에 대한 논의는 Python 3.7 기능 동결 이후로 연기되었습니다. 따라서 배경은 미정입니다.)</p>
<h2>높은 수준의 요약 (High-level summary)</h2>
<p>기존에는 단일 <code>Context</code> 객체를 유지했지만, 이제 <code>threadstate</code>는 <code>Context</code> 객체들의 <code>ChainMap</code>을 유지합니다. <code>ContextVar.get</code> 및 <code>ContextVar.set</code>은 이 <code>ChainMap</code>을 기반으로 작동합니다. <code>Generator</code>와 <code>Async Generator</code>는 각각 자신과 연관된 <code>Context</code>를 가지고 있으며, 실행 중에 이 <code>Context</code>를 <code>ChainMap</code>에 <code>push</code>하여 호출자 (caller)로부터 컨텍스트-로컬 변경 사항을 격리합니다. 그러나 <code>@contextlib.contextmanager</code>와 같이 <code>Generator</code>로부터 <code>Context</code> 변경 사항이 호출자로 "누출 (leak)"되는 것이 바람직한 경우에는 이를 재정의할 수 있습니다.</p>
<h2>상세 사양 (Specification)</h2>
<h3>PEP 567 검토 (Review of PEP 567)</h3>
<p>먼저 PEP 567이 어떻게 작동하는지 검토한 후, 다음 섹션에서 이 PEP와의 차이점을 설명합니다.</p>
<p>PEP 567에서 <code>Context</code>는 <code>ContextVar</code> 객체를 임의의 값에 매핑하는 <code>Mapping</code>입니다. 의사 코드 (pseudo-code)에서는 내부 저장소로 <code>dict</code>를 사용하는 것처럼 가정합니다. (실제 구현은 <code>dict</code>와 의미론적으로 동등하지만 성능 트레이드오프가 다른 HAMT를 사용합니다.)</p>
<pre><code class="language-python">class Context(collections.abc.Mapping):
    def __init__(self):
        self._data = {}
        self._in_use = False

    def __getitem__(self, key):
        return self._data[key]

    def __iter__(self):
        return iter(self._data)

    def __len__(self):
        return len(self._data)
</code></pre>
<p>어떤 시점에서든 <code>threadstate</code>는 현재 <code>Context</code>를 유지합니다 (스레드 상태가 생성될 때 빈 <code>Context</code>로 초기화됩니다). <code>Context.run</code>을 사용하여 현재 <code>Context</code>를 일시적으로 전환할 수 있습니다.</p>
<pre><code class="language-python"># Context.run
def run(self, fn, *args, **kwargs):
    if self._in_use:
        raise RuntimeError("Context already in use")
    tstate = get_thread_state()
    old_context = tstate.current_context
    tstate.current_context = self
    self._in_use = True
    try:
        return fn(*args, **kwargs)
    finally:
        tstate.current_context = old_context
        self._in_use = False
</code></pre>
<p><code>copy_context</code>를 호출하여 현재 <code>Context</code>의 얕은 복사본 (shallow copy)을 가져올 수 있습니다. 이는 일반적으로 새 <code>task</code>를 생성할 때 사용되며, 자식 <code>task</code>가 부모로부터 <code>Context</code>를 상속받을 수 있도록 합니다.</p>
<pre><code class="language-python">def copy_context():
    tstate = get_thread_state()
    new_context = Context()
    new_context._data = dict(tstate.current_context)
    return new_context
</code></pre>
<p>실제로 최종 사용자 (end user)가 주로 사용하는 것은 <code>ContextVar</code> 객체이며, 이것이 <code>Context</code>를 변경하는 유일한 방법입니다. <code>ContextVar</code>는 <code>Token</code>이라는 유틸리티 클래스와 함께 작동하며, <code>Token</code>은 <code>ContextVar</code>를 이전 값으로 복원하는 데 사용될 수 있습니다.</p>
<pre><code class="language-python">class Token:
    MISSING = sentinel_value()
    # Note: constructor is private
    def __init__(self, context, var, old_value):
        self._context = context
        self.var = var
        self.old_value = old_value

    def reset(self):
        if self.old_value is self.MISSING:
            del self._context._data[self.context_var]
        else:
            self._context._data[self.context_var] = self.old_value

class ContextVar:
    def __init__(self, name, *, default=None):
        self.name = name
        self.default = default

    def get(self):
        context = get_thread_state().current_context
        return context.get(self, self.default)

    def set(self, new_value):
        context = get_thread_state().current_context
        token = Token(context, self, context.get(self, Token.MISSING))
        context._data[self] = new_value
        return token
</code></pre>
<h3>PEP 567에서 이 PEP로의 변경 사항 (Changes from PEP 567 to this PEP)</h3>
<p>일반적으로 <code>Context</code>는 동일하게 유지됩니다. 그러나 이제 <code>threadstate</code>는 단일 <code>Context</code> 객체 대신 <code>Context</code> 객체 스택 (stack)을 저장합니다. 이 스택은 <code>collections.ChainMap</code>처럼 작동하므로, 의사 코드에서도 이를 사용합니다. 이에 따라 <code>Context.run</code>은 다음과 같이 변경됩니다.</p>
<pre><code class="language-python"># Context.run
def run(self, fn, *args, **kwargs):
    if self._in_use:
        raise RuntimeError("Context already in use")
    tstate = get_thread_state()
    old_context_stack = tstate.current_context_stack
    tstate.current_context_stack = ChainMap([self]) # 변경됨 (changed)
    self._in_use = True
    try:
        return fn(*args, **kwargs)
    finally:
        tstate.current_context_stack = old_context_stack
        self._in_use = False
</code></pre>
<p>일부 변수 이름 업데이트 (예: <code>tstate.current_context</code> → <code>tstate.current_context_stack</code>) 외에, 유일한 변경 사항은 표시된 줄에서 <code>context</code>를 <code>ChainMap</code>으로 감싸서 <code>threadstate</code>에 저장하는 것입니다.</p>
<p>또한 <code>Context.push</code> 메서드가 추가됩니다. 이 메서드는 <code>Context.run</code>과 거의 동일하지만, 전체 스택을 일시적으로 교체하는 대신 기존 스택에 <code>Context</code>를 일시적으로 <code>push</code>한다는 점에서 다릅니다.</p>
<pre><code class="language-python"># Context.push
def push(self, fn, *args, **kwargs):
    if self._in_use:
        raise RuntimeError("Context already in use")
    tstate = get_thread_state()
    tstate.current_context_stack.maps.insert(0, self) # run과 다름 (different from run)
    self._in_use = True
    try:
        return fn(*args, **kwargs)
    finally:
        tstate.current_context_stack.maps.pop(0) # run과 다름 (different from run)
        self._in_use = False
</code></pre>
<p>대부분의 경우 <code>push</code>가 직접 사용될 것이라고 예상하지는 않지만, 대신 <code>Generator</code>에 의해 암묵적으로 사용될 것입니다. 구체적으로, 모든 <code>Generator</code> 객체와 <code>Async Generator</code> 객체는 <code>.context</code>라는 새 속성을 갖게 됩니다. (Async) <code>Generator</code> 객체가 생성될 때, 이 속성은 빈 <code>Context</code>로 초기화됩니다 (<code>self.context = Context()</code>). 이 속성은 변경 가능하며, 사용자 코드에 의해 변경될 수 있습니다. 그러나 <code>Context</code> 객체나 <code>None</code>이 아닌 다른 값으로 설정하려고 하면 오류가 발생합니다.</p>
<p><code>__next__</code>, <code>send</code>, <code>throw</code>, 또는 <code>close</code>를 통해 <code>Generator</code>에 진입하거나, <code>__anext__</code>, <code>asend</code>, <code>athrow</code>, 또는 <code>aclose</code> 코루틴 (coroutine) 중 하나를 호출하여 <code>Async Generator</code>에 진입할 때마다, 해당 <code>.context</code> 속성이 확인되며, <code>None</code>이 아닌 경우 자동으로 <code>push</code>됩니다.</p>
<pre><code class="language-python"># GeneratorType.__next__
def __next__(self):
    if self.context is not None:
        return self.context.push(self.__real_next__)
    else:
        return self.__real_next__()
</code></pre>
<p><code>Context.push</code>가 자주 사용될 것으로 예상하지는 않지만, 이를 공개 API로 만드는 것은 <code>Generator</code>가 항상 동등한 의미를 가진 명시적인 이터레이터 클래스 (iterator class)로 재작성될 수 있다는 원칙을 보존합니다.</p>
<p>또한, <code>contextlib.(async)contextmanager</code>는 해당 (async) <code>Generator</code> 객체의 <code>.context</code> 속성을 항상 <code>None</code>으로 설정하도록 수정됩니다.</p>
<pre><code class="language-python"># contextlib._GeneratorContextManagerBase.__init__
def __init__(self, func, args, kwds):
    self.gen = func(*args, **kwds)
    self.gen.context = None # 추가됨 (added)
    # ...
</code></pre>
<p>이것은 다음 코드와 같은 코드가 예상대로 계속 작동하도록 보장합니다.</p>
<pre><code class="language-python">@contextmanager
def decimal_precision(prec):
    with decimal.localcontext() as ctx:
        ctx.prec = prec
        yield

with decimal_precision(2):
    # ...
</code></pre>
<p>여기서의 일반적인 아이디어는 기본적으로 모든 <code>Generator</code> 객체가 자체 로컬 컨텍스트를 얻지만, 사용자가 명시적으로 다른 동작을 원하면 그렇게 할 수 있다는 것입니다.</p>
<p>그 외에는 <code>threadstate Context</code> 대신 <code>threadstate ChainMap</code>을 사용하도록 모든 것을 변경하는 것을 제외하고는 대부분 이전과 동일하게 작동합니다. 자세한 내용은 다음과 같습니다.</p>
<p><code>copy_context</code> 함수는 이제 "유효한 (effective)" 컨텍스트의 평탄화된 (flattened) 복사본을 반환합니다. (최적화로, 구현은 이 평탄화를 지연시켜 수행할 수 있지만, 그렇게 하더라도 사용자에게는 보이지 않도록 할 것입니다.) 위의 이전 구현과 비교했을 때, 유일한 변경 사항은 <code>tstate.current_context</code>가 <code>tstate.current_context_stack</code>으로 대체되었다는 것입니다.</p>
<pre><code class="language-python">def copy_context() -> Context:
    tstate = get_thread_state()
    new_context = Context()
    new_context._data = dict(tstate.current_context_stack)
    return new_context
</code></pre>
<p><code>Token</code>은 변경되지 않았으며, <code>ContextVar.get</code>에 대한 변경 사항은 사소합니다.</p>
<pre><code class="language-python"># ContextVar.get
def get(self):
    context_stack = get_thread_state().current_context_stack
    return context_stack.get(self, self.default)
</code></pre>
<p><code>ContextVar.set</code>은 약간 더 흥미롭습니다. 다른 모든 것과 달리 <code>ChainMap</code> 메커니즘을 통하는 대신, 항상 스택에서 가장 위에 있는 <code>Context</code>를 변경하며, - 결정적으로! - 반환된 <code>Token</code>이 나중에 상태를 복원하도록 설정합니다. 이는 <code>old = var.get(); ...; var.set(old)</code>와 같이 수행할 경우 발생할 수 있는 스택의 다른 레벨 간에 값이 실수로 "승격 (promote)"되는 것을 방지합니다.</p>
<pre><code class="language-python"># ContextVar.set
def set(self, new_value):
    top_context = get_thread_state().current_context_stack.maps[0]
    token = Token(top_context, self, top_context.get(self, Token.MISSING))
    top_context._data[self] = new_value
    return token
</code></pre>
<p>마지막으로, 전체 컨텍스트 스택을 내부에서 검사 (introspection)할 수 있도록 <code>contextvars.get_context_stack</code>이라는 새 함수가 제공됩니다.</p>
<pre><code class="language-python">def get_context_stack() -> List[Context]:
    return list(get_thread_state().current_context_stack.maps)
</code></pre>
<p>이것이 전부입니다.</p>
<h3>PEP 550과의 비교 (Comparison to PEP 550)</h3>
<p>PEP 550과의 주요 차이점은 PEP 550이 우리가 "contexts"와 "context stacks"라고 부르는 것을 두 가지 다른 구체적인 유형 (<code>LocalContext</code>와 <code>ExecutionContext</code>)으로 구체화했다는 것입니다. 이는 차이점이 무엇이며, 어떤 객체를 어느 곳에 사용해야 하는지에 대한 많은 혼란을 야기했습니다. 이 제안은 <code>Context</code>만 구체화함으로써 (<code>"just a dict"</code>) 상황을 단순화하고, "context stack"을 인터프리터 런타임 상태의 이름 없는 기능으로 만듭니다. 하지만 디버깅 및 기타 목적을 위해 <code>get_context_stack</code>을 사용하여 이를 내부에서 검사하는 것은 여전히 가능합니다.</p>
<h3>구현 노트 (Implementation notes)</h3>
<p><code>Context</code>는 내부적으로 <code>dict</code> 대신 HAMT 기반의 매핑 구조를 계속 사용할 것입니다. 이는 <code>ContextVar.set</code> 호출보다 <code>copy_context</code> 호출이 훨씬 더 흔할 것으로 예상되기 때문입니다. 거의 모든 경우에 <code>copy_context</code>는 스택에 <code>Context</code>가 하나만 있음을 발견하고 (제너레이터가 새 작업을 생성하는 경우가 드물기 때문에) 단순히 이를 직접 재사용할 수 있습니다. 다른 경우에는 HAMT는 병합 비용이 저렴하며 지연하여 수행할 수 있습니다.</p>
<p>실제 <code>ChainMap</code> 객체 대신, <code>context stack</code>은 적절한 구조를 사용하여 표현될 것입니다. 가장 적절한 옵션은 <code>push</code>/<code>pop</code>을 사용할 수 있도록 스택의 "상단"이 리스트의 끝에 있는 일반 리스트이거나, 또는 효율적인 <code>push</code>/<code>pop</code>을 허용하기 위해 스택의 "상단"이 리스트의 시작 부분에 있는 침입형 연결 리스트 (<code>PyThreadState</code> → <code>Context</code> → <code>Context</code> → …)일 것입니다.</p>
<p>PEP 567의 중요한 최적화는 <code>ContextVar</code> 내부의 값 캐싱 (caching)입니다. 단일 <code>Context</code>에서 <code>Context stack</code>으로 전환하면 이것이 약간 더 복잡해지지만, 그리 많지는 않습니다. 현재는 <code>threadstate</code>의 현재 <code>Context</code>가 변경될 때마다 (스레드 전환 시, <code>Context.run</code> 진입/종료 시) 캐시를 무효화합니다. 여기서 가장 간단한 접근 방식은 스택이 변경될 때마다 (스레드 전환 시, <code>Context.run</code> 진입/종료 시, <code>Context.push</code> 진입/종료 시) 캐시를 무효화하는 것입니다. 이것의 주요 효과는 <code>Generator</code>를 이터레이션하는 것이 캐시를 무효화한다는 것입니다. 이것이 심각한 문제를 일으킬 가능성은 낮지만, 만약 그렇다면 <code>Context</code>를 <code>push</code>하고 <code>pop</code>하는 것이 <code>threadstate</code>를 이전 상태로 되돌린다는 것을 인식하는 더 영리한 캐시 키 (cache key)로 피할 수 있다고 생각합니다. (아이디어: 특정 스택 구성에 대한 캐시 키를 가장 상위 <code>Context</code>에 저장합니다.)</p>
<p>이 설계에서는 캐시되지 않은 <code>get</code>이 O(n)이 될 수밖에 없는 것으로 보입니다. 여기서 n은 <code>context stack</code>의 크기입니다. 그러나 n은 일반적으로 매우 작을 것입니다. 중첩된 <code>Generator</code>의 수와 대략 같으므로 보통 n=1이며, n이 예를 들어 5보다 큰 경우는 극히 드물 것입니다. 최악의 경우, n은 재귀 제한 (recursion limit)에 의해 제한됩니다. 또한, 깊은 <code>Generator</code> 재귀의 대부분의 경우 스택의 <code>Context</code> 대부분은 비어 있을 것이며, 따라서 조회 중에 매우 빠르게 건너뛸 수 있을 것으로 예상됩니다. 그리고 반복적인 조회에는 캐싱 메커니즘이 작동할 것입니다. 따라서 이것이 성능 문제를 일으키는 극단적인 경우를 구성하는 것이 가능할 수 있지만, 일반적인 코드는 본질적으로 영향을 받지 않을 것입니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1682,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Deferred] PEP 568 - Generator-sensitivity for Context Variables"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 23:51:20+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}],["$","section",null,{"className":"mt-12 border-t border-gray-200 pt-8","children":[["$","h3",null,{"className":"text-base font-semibold text-gray-900 mb-4","children":["Python"," 의 다른글"]}],["$","ul",null,{"className":"space-y-2 text-sm","children":[["$","li",null,{"className":"text-gray-500","children":["이전글"," ",["$","$L7",null,{"href":"/python/pep/567/","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Final] PEP 567 - Context Variables"}]]}],["$","li",null,{"className":"text-gray-900 font-semibold","children":["현재글 : ","[Deferred] PEP 568 - Generator-sensitivity for Context Variables"]}],["$","li",null,{"className":"text-gray-500","children":["다음글"," ",["$","$L7",null,{"href":"/python/pep/569/","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Final] PEP 569 - Python 3.8 Release Schedule"}]]}]]}]]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://blog.secrett2633.site/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://blog.secrett2633.site/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","22",{"name":"next-size-adjust"}]]
1:null
