<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-f9f5ec6d66d9670a.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/page-ca12a0ad24cce7b7.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1637<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Deferred] PEP 3150 - Statement local namespaces (aka “given” clause)</h1><div class="page__meta"><time dateTime="2025-09-27 14:40:31+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-3150/">PEP 3150 - Statement local namespaces (aka “given” clause)</a></p>
<p><strong>상태:</strong> Deferred | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 09-Jul-2010</p>
</blockquote>
<p>다음은 PEP 3150 문서의 내용을 한국어로 번역하고 정리한 것입니다.</p>
<h1>PEP 3150 – Statement local namespaces (일명 "given" 절)</h1>
<ul>
<li><strong>작성자:</strong> Alyssa Coghlan</li>
<li><strong>상태:</strong> Deferred (보류됨)</li>
<li><strong>유형:</strong> Standards Track</li>
<li><strong>생성일:</strong> 2010년 7월 9일</li>
<li><strong>Python 버전:</strong> 3.4</li>
</ul>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 현재 연관된 코드 스위트(code suite)가 없는 여러 Python 문장에 선택적 <code>given</code> 절을 추가할 것을 제안합니다. 이 절은 연관된 문장 내에서 접근 가능하지만, 포함하는 네임스페이스(namespace)의 일부가 되지 않는 추가적인 이름들을 위한 문장 로컬 네임스페이스(statement local namespace)를 생성합니다.</p>
<p>연관된 코드 스위트 실행을 통해 생성된 네임스페이스에 대한 전방 참조(forward reference)를 나타내기 위해 새로운 기호인 <code>?</code>를 도입할 것을 제안합니다. 이 <code>?</code>는 <code>types.SimpleNamespace</code> 객체에 대한 참조가 될 것입니다.</p>
<h2>제안 배경 (Motivation)</h2>
<p>주된 동기는 보다 선언적인 프로그래밍 스타일(declarative style of programming)을 가능하게 하는 것입니다. 이는 수행될 연산을 독자에게 먼저 제시하고, 필요한 하위 계산(subcalculations)의 세부 사항을 들여쓰기된 스위트(indented suite)에 제시하는 방식입니다. 예를 들어, 일반 할당 문장(assignment statement)을 <code>class</code> 및 <code>def</code> 문장과 동등하게 만들어, 정의될 항목의 이름이 해당 항목의 값이 계산되는 방식에 대한 세부 사항보다 먼저 독자에게 제시될 수 있도록 합니다. 또한, 이름이 현재 표현식에서만 플레이스홀더(placeholder)로 사용된 다음 이어지는 스위트에서 정의되는 "다중 라인 람다(multi-line lambda)" 방식으로 이름 있는 함수를 사용할 수 있게 합니다.</p>
<p>두 번째 동기는 모듈(module) 및 클래스(class) 수준 코드에서 중간 계산(interim calculations)을 단순화하면서도 결과 네임스페이스를 오염시키지 않는 것입니다.</p>
<p>이 <code>given</code> 절과 특정 연산을 수행하는 별도의 함수 정의 간의 관계는, 명시적인 <code>while</code> 루프와 동일한 연산 시퀀스를 생성하는 제너레이터(Generator) 간의 기존 관계와 유사하게 의도됩니다.</p>
<h2>제안 (Proposal)</h2>
<p>이 PEP는 표현식을 포함하거나 순전히 문법적 목적으로 그러한 문장을 대체할 수 있는 단순 문장(simple statements)의 구문에 선택적 <code>given</code> 절을 추가할 것을 제안합니다. 이 추가의 영향을 받는 단순 문장 목록은 다음과 같습니다:</p>
<ul>
<li><code>expression statement</code> (표현식 문장)</li>
<li><code>assignment statement</code> (할당 문장)</li>
<li><code>augmented assignment statement</code> (증강 할당 문장)</li>
<li><code>del statement</code> (<code>del</code> 문장)</li>
<li><code>return statement</code> (<code>return</code> 문장)</li>
<li><code>yield statement</code> (<code>yield</code> 문장)</li>
<li><code>raise statement</code> (<code>raise</code> 문장)</li>
<li><code>assert statement</code> (<code>assert</code> 문장)</li>
<li><code>pass statement</code> (<code>pass</code> 문장)</li>
</ul>
<p><code>given</code> 절은 헤더 라인에서 하위 표현식(subexpressions)을 이름으로 참조할 수 있게 하며, 실제 정의는 들여쓰기된 절에 이어집니다. 간단한 예시는 다음과 같습니다:</p>
<pre><code class="language-python">sorted_data = sorted(data, key=?.sort_key)
given:
    def sort_key(item):
        return item.attr1, item.attr2
</code></pre>
<p>새로운 기호 <code>?</code>는 <code>given</code> 네임스페이스를 참조하는 데 사용됩니다. 이는 <code>types.SimpleNamespace</code> 인스턴스가 되므로, <code>?.sort_key</code>는 <code>given</code> 절에 정의된 이름에 대한 전방 참조로 작동합니다.</p>
<p><code>given</code> 절에는 독스트링(docstring)이 허용되며, 결과 네임스페이스의 <code>__doc__</code> 속성으로 첨부됩니다.</p>
<h3>의미론 (Semantics)</h3>
<p>다음 문장:</p>
<pre><code class="language-python">op(?.f, ?.g)
given bound_a=a, bound_b=b in:
    def f():
        return bound_a + bound_b
    def g():
        return bound_a - bound_b
</code></pre>
<p>은 대략 다음 코드와 동일하게 작동합니다:</p>
<pre><code class="language-python">__arg1 = a
__arg2 = b
def __scope(bound_a, bound_b):
    def f():
        return bound_a + bound_b
    def g():
        return bound_a - bound_b
    return types.SimpleNamespace(**locals())
__ref = __scope(__arg1, __arg2)
__ref.__doc__ = __scope.__doc__
op(__ref.f, __ref.g)
</code></pre>
<p><code>given</code> 절은 본질적으로 생성된 다음 즉시 실행되는 중첩 함수(nested function)입니다. 명시적으로 전달되지 않는 한, 이름은 일반적인 스코핑 규칙(scoping rules)을 사용하여 조회되며, 따라서 클래스 스코프(class scope)에 정의된 이름은 보이지 않습니다. 전방 참조로 선언된 이름은 반환되어 헤더 문장에서 사용되며, 주변 네임스페이스에 로컬로 바인딩되지 않습니다.</p>
<h3>문법 변경 (Syntax Change)</h3>
<p>제안된 문법 변경은 <code>given_clause</code>를 여러 단순 문장에 선택적으로 추가합니다.</p>
<p>새로운 <code>given_clause</code>의 정의:</p>
<pre><code>given_clause: "given" [(NAME '=' test)+ "in"]":" suite
</code></pre>
<p>이러한 변경은 문법적 모호성을 피하기 위해 기존 문장의 선택적 요소로 추가됩니다. 그러나 <code>simple_stmt</code> 정의와 관련하여 문제가 발생할 수 있으며, 이는 문법의 비 trivial한 재구조화를 필요로 할 수 있다고 언급됩니다.</p>
<h3>새로운 PEP 8 가이드라인 (New PEP 8 Guidelines)</h3>
<p><code>python-ideas</code>에서 논의된 바와 같이, 일반 변수 할당 대신 <code>given</code> 절을 언제 사용해야 하는지에 대한 적절한 지침을 제공하기 위해 새로운 PEP 8 가이드라인이 개발되어야 합니다. PEP는 PEP 8의 "프로그래밍 컨벤션(Programming Conventions)" 섹션에 다음과 같은 추가를 제안합니다:</p>
<ul>
<li>별도의 함수로 합리적으로 분리될 수 있지만 현재 재사용되지 않는 코드의 경우, <code>given</code> 절 사용을 고려해야 합니다. 이는 어떤 변수들이 알고리즘 또는 애플리케이션 상태를 유지하기보다는 다른 문장의 하위 구성 요소를 정의하는 데만 사용되는지를 명확하게 보여줍니다. 이는 호출 가능한 인수를 취하는 연산에 다중 라인 함수를 전달할 때 특히 유용한 기술입니다.</li>
<li><code>given</code> 절은 간결하게 유지해야 합니다. 복잡해지면 여러 단계로 나누거나 세부 사항을 별도의 함수로 옮겨야 합니다.</li>
</ul>
<h2>설계 논의 (Design Discussion)</h2>
<h3>키워드 선택 (Keyword Choice)</h3>
<p>이 제안은 처음에는 Haskell의 유사한 구문 이름을 기반으로 <code>where</code>를 사용했습니다. 그러나 NumPy와 같은 기존 Python 라이브러리에서 SQL 쿼리 조건의 의미로 이미 <code>where</code>를 사용하고 있어 혼란을 야기할 수 있다는 지적이 있었습니다.</p>
<p><code>given</code>은 변수 이름으로도 사용될 수 있지만 (따라서 새로운 키워드 도입을 위한 일반적인 <code>__future__</code> 절차에 따라 사용이 중단될 수 있음), 새로운 절에 대한 "여기에 이 표현식이 사용할 수 있는 추가 변수들이 있습니다"라는 의미와 훨씬 더 강하게 연관됩니다.</p>
<p><code>with</code> 키워드를 재사용하는 것도 제안되었지만, <code>with</code> 절과 <code>with</code> 문장이 비슷하게 보이지만 완전히 다른 작업을 수행하므로 혼란의 가능성이 높다고 지적되었습니다.</p>
<h3>PEP 403과의 관계 (Relation to PEP 403)</h3>
<p>PEP 403 (<code>General Purpose Decorator Clause</code>)은 기존 데코레이터(decorator) 문법에서 영감을 받은 덜 급진적인 언어 변경을 통해 이 PEP의 주요 목표를 달성하려고 시도합니다.</p>
<p>두 PEP는 동일한 저자임에도 불구하고 서로 직접 경쟁 관계에 있습니다. PEP 403은 현 상태에서 최소한의 변경으로 유용한 기능을 달성하려는 미니멀리스트적 접근 방식을 대표합니다. 반면 이 PEP는 언어에 더 큰 변경을 요구하는 더 유연한 독립형 문장 설계를 목표로 합니다.</p>
<p>PEP 403이 제너레이터 표현식(generator expressions)의 동작을 더 잘 설명하는 데 적합한 반면, 이 PEP는 일반적으로 데코레이터 절의 동작을 설명하는 데 더 적합합니다. 두 PEP 모두 컨테이너 컴프리헨션(container comprehensions)의 의미론에 대한 적절한 설명을 지원합니다.</p>
<h3>컨테이너 컴프리헨션 및 제너레이터 표현식 설명 (Explaining Container Comprehensions and Generator Expressions)</h3>
<p>제안된 <code>given</code> 구문은 컨테이너 컴프리헨션의 스코핑(scoping) 및 실행 순서 의미론을 설명하는 데 원시적인 형태로 사용될 수 있습니다.</p>
<pre><code class="language-python">seq2 = [x for x in y if q(x) for y in seq if p(y)]
# 대략적으로 다음과 동일
seq2 = ?.result
given seq=seq:
    result = []
    for y in seq:
        if p(y):
            for x in y:
                if q(x):
                    result.append(x)
</code></pre>
<p>이 확장에서 중요한 점은 컴프리헨션이 클래스 스코프에서 오작동하는 것처럼 보이는 이유를 설명한다는 것입니다: 가장 바깥쪽 이터레이터(iterator)만 클래스 스코프에서 평가되고, 모든 조건자(predicates), 중첩된 이터레이터 및 값 표현식은 중첩된 스코프 내에서 평가됩니다.</p>
<h3>데코레이터 절 평가 및 적용 설명 (Explaining Decorator Clause Evaluation and Application)</h3>
<p>데코레이터 절의 평가 및 적용에 대한 표준 설명은 실행 순서 단계를 보여주기 위해 숨겨진 컴파일러 변수(hidden compiler variables) 개념을 다루어야 합니다. <code>given</code> 문장을 사용하면 다음과 같은 데코레이트된 함수 정의를:</p>
<pre><code class="language-python">@classmethod
def classname(cls):
    return cls.__name__
</code></pre>
<p>대략 다음과 같이 설명할 수 있습니다:</p>
<pre><code class="language-python">classname = ?.d1(classname)
given:
    d1 = classmethod
    def classname(cls):
        return cls.__name__
</code></pre>
<h2>예상되는 반대 의견 (Anticipated Objections)</h2>
<h3>두 가지 방법 (Two Ways To Do It)</h3>
<p>많은 코드가 이제 값을 사용하기 전에 정의하거나 <code>given</code> 절에서 나중에 정의할 수 있게 되어, 두 가지 방법이 생기고, 그 중 어느 것을 선택해야 할지 명확한 방법이 없을 수 있습니다.</p>
<p>이 PEP는 이것이 "하나의 명확한 방법(one obvious way)"이라는 격언의 잘못된 적용이라고 주장합니다. Python은 이미 코드를 작성하는 여러 방법을 제공하며, 언어는 사람들이 생각하는 방식에 맞춰 코드를 작성할 수 있도록 설계되었습니다. 이러한 스타일 질문은 코드베이스를 담당하는 개발 그룹에 맡겨져야 합니다. 그러나 CPython 및 표준 라이브러리를 위한 명시적인 PEP 8 지침이 필요할 것입니다.</p>
<h3>순서가 뒤바뀐 실행 (Out of Order Execution)</h3>
<p><code>given</code> 절은 <code>given</code> 절의 본문이 절 헤더의 단순 문장보다 먼저 실행되므로 실행이 다소 이상하게 왔다 갔다 합니다. Python의 다른 부분 중 가장 유사한 것은 리스트 컴프리헨션, 제너레이터 표현식 및 조건 표현식에서의 순서가 뒤바뀐 평가(out of order evaluation)와 데코레이터 함수의 지연된 적용(delayed application)입니다.</p>
<p>이것이 사실이지만, 이 문법은 사람들이 문제를 (언어의 관점에서 볼 때) 순서 없이 생각하는 경우를 위한 것입니다. 예를 들어, "이 시퀀스의 항목들을 각 항목의 <code>attr1</code>과 <code>attr2</code> 값에 따라 정렬하고 싶다"는 생각을 Python 사용자가 다음과 같이 표현할 수 있게 합니다:</p>
<pre><code class="language-python">sorted_list = sorted(original, key=?.key)
given:
    def key(item):
        return item.attr1, item.attr2
</code></pre>
<p>이는 사용자가 원래 생각한 순서와 동일하며, 정렬 기준에 대한 이름을 따로 만들 필요 없이 키워드 인수 이름을 직접 재사용할 수 있습니다.</p>
<h3>인트로스펙션(Introspection)에 해로움 (Harmful to Introspection)</h3>
<p>모듈(module) 및 클래스(class) 내부를 조사하는 것은 화이트박스 테스트(white-box testing) 및 인터랙티브 디버깅(interactive debugging)에 매우 유용한 도구입니다. <code>given</code> 절은 계산 중에 사용되는 임시 상태(temporary state)에 대한 접근을 상당히 효과적으로 방지할 것입니다.</p>
<p>이는 타당한 우려이지만, 테스트 가능성(testability)을 위한 설계는 프로그래밍의 여러 측면에 걸쳐 있는 문제입니다. 구성 요소가 독립적으로 테스트되어야 하는 경우, <code>given</code> 문장은 정보가 테스트 스위트에 노출되도록 별도의 문장으로 리팩토링(refactored)되어야 합니다. 이는 함수나 제너레이터 내부에 숨겨진 연산을 단순히 독립적으로 테스트하기 위해 별도의 함수로 리팩토링하는 것과 크게 다르지 않습니다.</p>
<h3>실제 영향 평가 부족 (Lack of Real World Impact Assessment)</h3>
<p>현재 PEP의 예시는 거의 모두 비교적 작은 "장난감(toy)" 예시입니다. 이 PEP의 제안은 실제 코드의 가독성이 진정으로 향상되는 예시를 찾기 위해 대규모 코드베이스 (예: 표준 라이브러리 또는 대규모 Twisted 애플리케이션)에 적용되는 테스트를 거쳐야 합니다.</p>
<h2>미해결 질문 (Open Questions)</h2>
<h3>전방 참조를 위한 문법 (Syntax for Forward References)</h3>
<p><code>?</code> 기호는 짧고 현재 사용되지 않으며 "여기에 나중에 채워질 무언가가 누락되어 있다"는 것을 암시하기 때문에 <code>given</code> 네임스페이스에 대한 전방 참조에 제안되었습니다. 이 제안은 기존 Python 기능과 깔끔하게 일치하지 않으므로 이미 사용 중인 기호 재사용은 의도적으로 피했습니다.</p>
<h3><code>nonlocal</code> 및 <code>global</code> 처리 (Handling of nonlocal and global)</h3>
<p><code>nonlocal</code> 및 <code>global</code>은 <code>given</code> 절 스위트 내에서 명시적으로 허용되지 않으며, 발생 시 문법 오류가 될 것입니다. 해당 스위트 내의 <code>def</code> 문장 내에 나타나면 정상적으로 작동합니다.</p>
<h3><code>break</code> 및 <code>continue</code> 처리 (Handling of break and continue)</h3>
<p><code>break</code> 및 <code>continue</code>는 익명 함수(anonymous functions)가 위 확장과 같이 정의된 것처럼 작동할 것입니다. <code>given</code> 절 스위트 내에 나타나면 문법 오류가 되지만, 해당 스위트의 일부로 <code>for</code> 또는 <code>while</code> 루프 내에 나타나면 정상적으로 작동합니다.</p>
<h3><code>return</code> 및 <code>yield</code> 처리 (Handling of return and yield)</h3>
<p><code>return</code> 및 <code>yield</code>는 <code>given</code> 절 스위트 내에서 명시적으로 허용되지 않으며, 발생 시 문법 오류가 될 것입니다. 해당 스위트 내의 <code>def</code> 문장 내에 나타나면 정상적으로 작동합니다.</p>
<h2>예시 (Examples)</h2>
<h3>이벤트 기반 프로그래밍을 위한 콜백 정의 (Defining callbacks for event driven programming)</h3>
<pre><code class="language-python"># 기존 Python
def cb(sock):
    # 소켓으로 뭔가 처리
def eb(exc):
    logging.exception(
        "Failed connecting to %s:%s", host, port)
loop.create_connection((host, port), cb, eb)

# becomes:
loop.create_connection((host, port), ?.cb, ?.eb)
given:
    def cb(sock):
        # 소켓으로 뭔가 처리
    def eb(exc):
        logging.exception(
            "Failed connecting to %s:%s", host, port)
</code></pre>
<h3>일반적으로 단일 인스턴스만 갖는 "일회성" 클래스 정의 (Defining “one-off” classes which typically only have a single instance)</h3>
<pre><code class="language-python"># becomes:
public_name = ?.MeaningfulClassName(*params)
given:
    class MeaningfulClassName():
        ... # 여러 라인
</code></pre>
<h3>로컬 네임스페이스를 오염시키지 않고 속성 계산 (Calculating attributes without polluting the local namespace)</h3>
<pre><code class="language-python"># 기존 Python (수동 네임스페이스 정리)
def _createenviron():
    ... # 27라인 함수
environ = _createenviron()
del _createenviron

# becomes:
environ = ?._createenviron()
given:
    def _createenviron():
        ... # 27라인 함수
</code></pre>
<h3>기본 인수 해킹(default argument hack) 대체 (Replacing default argument hack)</h3>
<pre><code class="language-python"># becomes:
return ?.decorating_function
given:
    # Cell 변수이지 locals는 아니지만, 유사한 속도 향상 제공
    tuple, sorted, len, KeyError = tuple, sorted, len, KeyError
    def decorating_function(user_function):
        ... # 60라인 함수
</code></pre>
<h2>거부된 대안 (Rejected Alternatives)</h2>
<p>이 PEP의 이전 버전은 후행 스위트(trailing suite)의 이름에 대한 암묵적인 전방 참조와 암묵적인 조기 바인딩(early binding) 의미론을 허용했습니다. 이 두 아이디어 모두 표현력의 충분한 증가 없이 제안을 상당히 복잡하게 만들었습니다. 명시적 전방 참조와 조기 바인딩을 가진 현재 제안은 새로운 구문을 기존 스코핑 의미론에 맞추어, 아이디어가 실제로 구현될 가능성을 크게 높였습니다.</p>
<p>두 스위트 "순서대로(in-order)" 변형에 대한 제안도 있었는데, 이는 순서가 뒤바뀐 실행을 지원하지 않고 이름의 제한된 스코핑을 제공합니다. 그러나 이러한 제안은 사람들이 다중 라인 람다 지원을 요청할 때 불평하는 요점, 즉 하위 표현식의 이름을 정하는 것이 특히 어렵다는 것이 아니라, 사용하는 문장보다 먼저 함수의 이름을 정하는 것이 개발자가 문제를 생각하는 방식과 코드가 일치하지 않게 만든다는 점을 놓치고 있다고 PEP는 주장합니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-f9f5ec6d66d9670a.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-ca12a0ad24cce7b7.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/3150\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"FglYEKp77LCCxCyk0Fxk6\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/3150/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/3150\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"3150\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/3150\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T4d94,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-3150/\"\u003ePEP 3150 - Statement local namespaces (aka “given” clause)\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Deferred | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 09-Jul-2010\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e다음은 PEP 3150 문서의 내용을 한국어로 번역하고 정리한 것입니다.\u003c/p\u003e\n\u003ch1\u003ePEP 3150 – Statement local namespaces (일명 \"given\" 절)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Alyssa Coghlan\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Deferred (보류됨)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2010년 7월 9일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.4\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 현재 연관된 코드 스위트(code suite)가 없는 여러 Python 문장에 선택적 \u003ccode\u003egiven\u003c/code\u003e 절을 추가할 것을 제안합니다. 이 절은 연관된 문장 내에서 접근 가능하지만, 포함하는 네임스페이스(namespace)의 일부가 되지 않는 추가적인 이름들을 위한 문장 로컬 네임스페이스(statement local namespace)를 생성합니다.\u003c/p\u003e\n\u003cp\u003e연관된 코드 스위트 실행을 통해 생성된 네임스페이스에 대한 전방 참조(forward reference)를 나타내기 위해 새로운 기호인 \u003ccode\u003e?\u003c/code\u003e를 도입할 것을 제안합니다. 이 \u003ccode\u003e?\u003c/code\u003e는 \u003ccode\u003etypes.SimpleNamespace\u003c/code\u003e 객체에 대한 참조가 될 것입니다.\u003c/p\u003e\n\u003ch2\u003e제안 배경 (Motivation)\u003c/h2\u003e\n\u003cp\u003e주된 동기는 보다 선언적인 프로그래밍 스타일(declarative style of programming)을 가능하게 하는 것입니다. 이는 수행될 연산을 독자에게 먼저 제시하고, 필요한 하위 계산(subcalculations)의 세부 사항을 들여쓰기된 스위트(indented suite)에 제시하는 방식입니다. 예를 들어, 일반 할당 문장(assignment statement)을 \u003ccode\u003eclass\u003c/code\u003e 및 \u003ccode\u003edef\u003c/code\u003e 문장과 동등하게 만들어, 정의될 항목의 이름이 해당 항목의 값이 계산되는 방식에 대한 세부 사항보다 먼저 독자에게 제시될 수 있도록 합니다. 또한, 이름이 현재 표현식에서만 플레이스홀더(placeholder)로 사용된 다음 이어지는 스위트에서 정의되는 \"다중 라인 람다(multi-line lambda)\" 방식으로 이름 있는 함수를 사용할 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003e두 번째 동기는 모듈(module) 및 클래스(class) 수준 코드에서 중간 계산(interim calculations)을 단순화하면서도 결과 네임스페이스를 오염시키지 않는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 \u003ccode\u003egiven\u003c/code\u003e 절과 특정 연산을 수행하는 별도의 함수 정의 간의 관계는, 명시적인 \u003ccode\u003ewhile\u003c/code\u003e 루프와 동일한 연산 시퀀스를 생성하는 제너레이터(Generator) 간의 기존 관계와 유사하게 의도됩니다.\u003c/p\u003e\n\u003ch2\u003e제안 (Proposal)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 표현식을 포함하거나 순전히 문법적 목적으로 그러한 문장을 대체할 수 있는 단순 문장(simple statements)의 구문에 선택적 \u003ccode\u003egiven\u003c/code\u003e 절을 추가할 것을 제안합니다. 이 추가의 영향을 받는 단순 문장 목록은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eexpression statement\u003c/code\u003e (표현식 문장)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eassignment statement\u003c/code\u003e (할당 문장)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaugmented assignment statement\u003c/code\u003e (증강 할당 문장)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edel statement\u003c/code\u003e (\u003ccode\u003edel\u003c/code\u003e 문장)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereturn statement\u003c/code\u003e (\u003ccode\u003ereturn\u003c/code\u003e 문장)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eyield statement\u003c/code\u003e (\u003ccode\u003eyield\u003c/code\u003e 문장)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eraise statement\u003c/code\u003e (\u003ccode\u003eraise\u003c/code\u003e 문장)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eassert statement\u003c/code\u003e (\u003ccode\u003eassert\u003c/code\u003e 문장)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epass statement\u003c/code\u003e (\u003ccode\u003epass\u003c/code\u003e 문장)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003egiven\u003c/code\u003e 절은 헤더 라인에서 하위 표현식(subexpressions)을 이름으로 참조할 수 있게 하며, 실제 정의는 들여쓰기된 절에 이어집니다. 간단한 예시는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esorted_data = sorted(data, key=?.sort_key)\ngiven:\n    def sort_key(item):\n        return item.attr1, item.attr2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 기호 \u003ccode\u003e?\u003c/code\u003e는 \u003ccode\u003egiven\u003c/code\u003e 네임스페이스를 참조하는 데 사용됩니다. 이는 \u003ccode\u003etypes.SimpleNamespace\u003c/code\u003e 인스턴스가 되므로, \u003ccode\u003e?.sort_key\u003c/code\u003e는 \u003ccode\u003egiven\u003c/code\u003e 절에 정의된 이름에 대한 전방 참조로 작동합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egiven\u003c/code\u003e 절에는 독스트링(docstring)이 허용되며, 결과 네임스페이스의 \u003ccode\u003e__doc__\u003c/code\u003e 속성으로 첨부됩니다.\u003c/p\u003e\n\u003ch3\u003e의미론 (Semantics)\u003c/h3\u003e\n\u003cp\u003e다음 문장:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eop(?.f, ?.g)\ngiven bound_a=a, bound_b=b in:\n    def f():\n        return bound_a + bound_b\n    def g():\n        return bound_a - bound_b\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e은 대략 다음 코드와 동일하게 작동합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e__arg1 = a\n__arg2 = b\ndef __scope(bound_a, bound_b):\n    def f():\n        return bound_a + bound_b\n    def g():\n        return bound_a - bound_b\n    return types.SimpleNamespace(**locals())\n__ref = __scope(__arg1, __arg2)\n__ref.__doc__ = __scope.__doc__\nop(__ref.f, __ref.g)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egiven\u003c/code\u003e 절은 본질적으로 생성된 다음 즉시 실행되는 중첩 함수(nested function)입니다. 명시적으로 전달되지 않는 한, 이름은 일반적인 스코핑 규칙(scoping rules)을 사용하여 조회되며, 따라서 클래스 스코프(class scope)에 정의된 이름은 보이지 않습니다. 전방 참조로 선언된 이름은 반환되어 헤더 문장에서 사용되며, 주변 네임스페이스에 로컬로 바인딩되지 않습니다.\u003c/p\u003e\n\u003ch3\u003e문법 변경 (Syntax Change)\u003c/h3\u003e\n\u003cp\u003e제안된 문법 변경은 \u003ccode\u003egiven_clause\u003c/code\u003e를 여러 단순 문장에 선택적으로 추가합니다.\u003c/p\u003e\n\u003cp\u003e새로운 \u003ccode\u003egiven_clause\u003c/code\u003e의 정의:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egiven_clause: \"given\" [(NAME '=' test)+ \"in\"]\":\" suite\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 변경은 문법적 모호성을 피하기 위해 기존 문장의 선택적 요소로 추가됩니다. 그러나 \u003ccode\u003esimple_stmt\u003c/code\u003e 정의와 관련하여 문제가 발생할 수 있으며, 이는 문법의 비 trivial한 재구조화를 필요로 할 수 있다고 언급됩니다.\u003c/p\u003e\n\u003ch3\u003e새로운 PEP 8 가이드라인 (New PEP 8 Guidelines)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epython-ideas\u003c/code\u003e에서 논의된 바와 같이, 일반 변수 할당 대신 \u003ccode\u003egiven\u003c/code\u003e 절을 언제 사용해야 하는지에 대한 적절한 지침을 제공하기 위해 새로운 PEP 8 가이드라인이 개발되어야 합니다. PEP는 PEP 8의 \"프로그래밍 컨벤션(Programming Conventions)\" 섹션에 다음과 같은 추가를 제안합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e별도의 함수로 합리적으로 분리될 수 있지만 현재 재사용되지 않는 코드의 경우, \u003ccode\u003egiven\u003c/code\u003e 절 사용을 고려해야 합니다. 이는 어떤 변수들이 알고리즘 또는 애플리케이션 상태를 유지하기보다는 다른 문장의 하위 구성 요소를 정의하는 데만 사용되는지를 명확하게 보여줍니다. 이는 호출 가능한 인수를 취하는 연산에 다중 라인 함수를 전달할 때 특히 유용한 기술입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egiven\u003c/code\u003e 절은 간결하게 유지해야 합니다. 복잡해지면 여러 단계로 나누거나 세부 사항을 별도의 함수로 옮겨야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e설계 논의 (Design Discussion)\u003c/h2\u003e\n\u003ch3\u003e키워드 선택 (Keyword Choice)\u003c/h3\u003e\n\u003cp\u003e이 제안은 처음에는 Haskell의 유사한 구문 이름을 기반으로 \u003ccode\u003ewhere\u003c/code\u003e를 사용했습니다. 그러나 NumPy와 같은 기존 Python 라이브러리에서 SQL 쿼리 조건의 의미로 이미 \u003ccode\u003ewhere\u003c/code\u003e를 사용하고 있어 혼란을 야기할 수 있다는 지적이 있었습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egiven\u003c/code\u003e은 변수 이름으로도 사용될 수 있지만 (따라서 새로운 키워드 도입을 위한 일반적인 \u003ccode\u003e__future__\u003c/code\u003e 절차에 따라 사용이 중단될 수 있음), 새로운 절에 대한 \"여기에 이 표현식이 사용할 수 있는 추가 변수들이 있습니다\"라는 의미와 훨씬 더 강하게 연관됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewith\u003c/code\u003e 키워드를 재사용하는 것도 제안되었지만, \u003ccode\u003ewith\u003c/code\u003e 절과 \u003ccode\u003ewith\u003c/code\u003e 문장이 비슷하게 보이지만 완전히 다른 작업을 수행하므로 혼란의 가능성이 높다고 지적되었습니다.\u003c/p\u003e\n\u003ch3\u003ePEP 403과의 관계 (Relation to PEP 403)\u003c/h3\u003e\n\u003cp\u003ePEP 403 (\u003ccode\u003eGeneral Purpose Decorator Clause\u003c/code\u003e)은 기존 데코레이터(decorator) 문법에서 영감을 받은 덜 급진적인 언어 변경을 통해 이 PEP의 주요 목표를 달성하려고 시도합니다.\u003c/p\u003e\n\u003cp\u003e두 PEP는 동일한 저자임에도 불구하고 서로 직접 경쟁 관계에 있습니다. PEP 403은 현 상태에서 최소한의 변경으로 유용한 기능을 달성하려는 미니멀리스트적 접근 방식을 대표합니다. 반면 이 PEP는 언어에 더 큰 변경을 요구하는 더 유연한 독립형 문장 설계를 목표로 합니다.\u003c/p\u003e\n\u003cp\u003ePEP 403이 제너레이터 표현식(generator expressions)의 동작을 더 잘 설명하는 데 적합한 반면, 이 PEP는 일반적으로 데코레이터 절의 동작을 설명하는 데 더 적합합니다. 두 PEP 모두 컨테이너 컴프리헨션(container comprehensions)의 의미론에 대한 적절한 설명을 지원합니다.\u003c/p\u003e\n\u003ch3\u003e컨테이너 컴프리헨션 및 제너레이터 표현식 설명 (Explaining Container Comprehensions and Generator Expressions)\u003c/h3\u003e\n\u003cp\u003e제안된 \u003ccode\u003egiven\u003c/code\u003e 구문은 컨테이너 컴프리헨션의 스코핑(scoping) 및 실행 순서 의미론을 설명하는 데 원시적인 형태로 사용될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eseq2 = [x for x in y if q(x) for y in seq if p(y)]\n# 대략적으로 다음과 동일\nseq2 = ?.result\ngiven seq=seq:\n    result = []\n    for y in seq:\n        if p(y):\n            for x in y:\n                if q(x):\n                    result.append(x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 확장에서 중요한 점은 컴프리헨션이 클래스 스코프에서 오작동하는 것처럼 보이는 이유를 설명한다는 것입니다: 가장 바깥쪽 이터레이터(iterator)만 클래스 스코프에서 평가되고, 모든 조건자(predicates), 중첩된 이터레이터 및 값 표현식은 중첩된 스코프 내에서 평가됩니다.\u003c/p\u003e\n\u003ch3\u003e데코레이터 절 평가 및 적용 설명 (Explaining Decorator Clause Evaluation and Application)\u003c/h3\u003e\n\u003cp\u003e데코레이터 절의 평가 및 적용에 대한 표준 설명은 실행 순서 단계를 보여주기 위해 숨겨진 컴파일러 변수(hidden compiler variables) 개념을 다루어야 합니다. \u003ccode\u003egiven\u003c/code\u003e 문장을 사용하면 다음과 같은 데코레이트된 함수 정의를:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@classmethod\ndef classname(cls):\n    return cls.__name__\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e대략 다음과 같이 설명할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclassname = ?.d1(classname)\ngiven:\n    d1 = classmethod\n    def classname(cls):\n        return cls.__name__\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e예상되는 반대 의견 (Anticipated Objections)\u003c/h2\u003e\n\u003ch3\u003e두 가지 방법 (Two Ways To Do It)\u003c/h3\u003e\n\u003cp\u003e많은 코드가 이제 값을 사용하기 전에 정의하거나 \u003ccode\u003egiven\u003c/code\u003e 절에서 나중에 정의할 수 있게 되어, 두 가지 방법이 생기고, 그 중 어느 것을 선택해야 할지 명확한 방법이 없을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 이것이 \"하나의 명확한 방법(one obvious way)\"이라는 격언의 잘못된 적용이라고 주장합니다. Python은 이미 코드를 작성하는 여러 방법을 제공하며, 언어는 사람들이 생각하는 방식에 맞춰 코드를 작성할 수 있도록 설계되었습니다. 이러한 스타일 질문은 코드베이스를 담당하는 개발 그룹에 맡겨져야 합니다. 그러나 CPython 및 표준 라이브러리를 위한 명시적인 PEP 8 지침이 필요할 것입니다.\u003c/p\u003e\n\u003ch3\u003e순서가 뒤바뀐 실행 (Out of Order Execution)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003egiven\u003c/code\u003e 절은 \u003ccode\u003egiven\u003c/code\u003e 절의 본문이 절 헤더의 단순 문장보다 먼저 실행되므로 실행이 다소 이상하게 왔다 갔다 합니다. Python의 다른 부분 중 가장 유사한 것은 리스트 컴프리헨션, 제너레이터 표현식 및 조건 표현식에서의 순서가 뒤바뀐 평가(out of order evaluation)와 데코레이터 함수의 지연된 적용(delayed application)입니다.\u003c/p\u003e\n\u003cp\u003e이것이 사실이지만, 이 문법은 사람들이 문제를 (언어의 관점에서 볼 때) 순서 없이 생각하는 경우를 위한 것입니다. 예를 들어, \"이 시퀀스의 항목들을 각 항목의 \u003ccode\u003eattr1\u003c/code\u003e과 \u003ccode\u003eattr2\u003c/code\u003e 값에 따라 정렬하고 싶다\"는 생각을 Python 사용자가 다음과 같이 표현할 수 있게 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esorted_list = sorted(original, key=?.key)\ngiven:\n    def key(item):\n        return item.attr1, item.attr2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 사용자가 원래 생각한 순서와 동일하며, 정렬 기준에 대한 이름을 따로 만들 필요 없이 키워드 인수 이름을 직접 재사용할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e인트로스펙션(Introspection)에 해로움 (Harmful to Introspection)\u003c/h3\u003e\n\u003cp\u003e모듈(module) 및 클래스(class) 내부를 조사하는 것은 화이트박스 테스트(white-box testing) 및 인터랙티브 디버깅(interactive debugging)에 매우 유용한 도구입니다. \u003ccode\u003egiven\u003c/code\u003e 절은 계산 중에 사용되는 임시 상태(temporary state)에 대한 접근을 상당히 효과적으로 방지할 것입니다.\u003c/p\u003e\n\u003cp\u003e이는 타당한 우려이지만, 테스트 가능성(testability)을 위한 설계는 프로그래밍의 여러 측면에 걸쳐 있는 문제입니다. 구성 요소가 독립적으로 테스트되어야 하는 경우, \u003ccode\u003egiven\u003c/code\u003e 문장은 정보가 테스트 스위트에 노출되도록 별도의 문장으로 리팩토링(refactored)되어야 합니다. 이는 함수나 제너레이터 내부에 숨겨진 연산을 단순히 독립적으로 테스트하기 위해 별도의 함수로 리팩토링하는 것과 크게 다르지 않습니다.\u003c/p\u003e\n\u003ch3\u003e실제 영향 평가 부족 (Lack of Real World Impact Assessment)\u003c/h3\u003e\n\u003cp\u003e현재 PEP의 예시는 거의 모두 비교적 작은 \"장난감(toy)\" 예시입니다. 이 PEP의 제안은 실제 코드의 가독성이 진정으로 향상되는 예시를 찾기 위해 대규모 코드베이스 (예: 표준 라이브러리 또는 대규모 Twisted 애플리케이션)에 적용되는 테스트를 거쳐야 합니다.\u003c/p\u003e\n\u003ch2\u003e미해결 질문 (Open Questions)\u003c/h2\u003e\n\u003ch3\u003e전방 참조를 위한 문법 (Syntax for Forward References)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e?\u003c/code\u003e 기호는 짧고 현재 사용되지 않으며 \"여기에 나중에 채워질 무언가가 누락되어 있다\"는 것을 암시하기 때문에 \u003ccode\u003egiven\u003c/code\u003e 네임스페이스에 대한 전방 참조에 제안되었습니다. 이 제안은 기존 Python 기능과 깔끔하게 일치하지 않으므로 이미 사용 중인 기호 재사용은 의도적으로 피했습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003enonlocal\u003c/code\u003e 및 \u003ccode\u003eglobal\u003c/code\u003e 처리 (Handling of nonlocal and global)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003enonlocal\u003c/code\u003e 및 \u003ccode\u003eglobal\u003c/code\u003e은 \u003ccode\u003egiven\u003c/code\u003e 절 스위트 내에서 명시적으로 허용되지 않으며, 발생 시 문법 오류가 될 것입니다. 해당 스위트 내의 \u003ccode\u003edef\u003c/code\u003e 문장 내에 나타나면 정상적으로 작동합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ebreak\u003c/code\u003e 및 \u003ccode\u003econtinue\u003c/code\u003e 처리 (Handling of break and continue)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ebreak\u003c/code\u003e 및 \u003ccode\u003econtinue\u003c/code\u003e는 익명 함수(anonymous functions)가 위 확장과 같이 정의된 것처럼 작동할 것입니다. \u003ccode\u003egiven\u003c/code\u003e 절 스위트 내에 나타나면 문법 오류가 되지만, 해당 스위트의 일부로 \u003ccode\u003efor\u003c/code\u003e 또는 \u003ccode\u003ewhile\u003c/code\u003e 루프 내에 나타나면 정상적으로 작동합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ereturn\u003c/code\u003e 및 \u003ccode\u003eyield\u003c/code\u003e 처리 (Handling of return and yield)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ereturn\u003c/code\u003e 및 \u003ccode\u003eyield\u003c/code\u003e는 \u003ccode\u003egiven\u003c/code\u003e 절 스위트 내에서 명시적으로 허용되지 않으며, 발생 시 문법 오류가 될 것입니다. 해당 스위트 내의 \u003ccode\u003edef\u003c/code\u003e 문장 내에 나타나면 정상적으로 작동합니다.\u003c/p\u003e\n\u003ch2\u003e예시 (Examples)\u003c/h2\u003e\n\u003ch3\u003e이벤트 기반 프로그래밍을 위한 콜백 정의 (Defining callbacks for event driven programming)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 기존 Python\ndef cb(sock):\n    # 소켓으로 뭔가 처리\ndef eb(exc):\n    logging.exception(\n        \"Failed connecting to %s:%s\", host, port)\nloop.create_connection((host, port), cb, eb)\n\n# becomes:\nloop.create_connection((host, port), ?.cb, ?.eb)\ngiven:\n    def cb(sock):\n        # 소켓으로 뭔가 처리\n    def eb(exc):\n        logging.exception(\n            \"Failed connecting to %s:%s\", host, port)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e일반적으로 단일 인스턴스만 갖는 \"일회성\" 클래스 정의 (Defining “one-off” classes which typically only have a single instance)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# becomes:\npublic_name = ?.MeaningfulClassName(*params)\ngiven:\n    class MeaningfulClassName():\n        ... # 여러 라인\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e로컬 네임스페이스를 오염시키지 않고 속성 계산 (Calculating attributes without polluting the local namespace)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 기존 Python (수동 네임스페이스 정리)\ndef _createenviron():\n    ... # 27라인 함수\nenviron = _createenviron()\ndel _createenviron\n\n# becomes:\nenviron = ?._createenviron()\ngiven:\n    def _createenviron():\n        ... # 27라인 함수\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e기본 인수 해킹(default argument hack) 대체 (Replacing default argument hack)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# becomes:\nreturn ?.decorating_function\ngiven:\n    # Cell 변수이지 locals는 아니지만, 유사한 속도 향상 제공\n    tuple, sorted, len, KeyError = tuple, sorted, len, KeyError\n    def decorating_function(user_function):\n        ... # 60라인 함수\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e거부된 대안 (Rejected Alternatives)\u003c/h2\u003e\n\u003cp\u003e이 PEP의 이전 버전은 후행 스위트(trailing suite)의 이름에 대한 암묵적인 전방 참조와 암묵적인 조기 바인딩(early binding) 의미론을 허용했습니다. 이 두 아이디어 모두 표현력의 충분한 증가 없이 제안을 상당히 복잡하게 만들었습니다. 명시적 전방 참조와 조기 바인딩을 가진 현재 제안은 새로운 구문을 기존 스코핑 의미론에 맞추어, 아이디어가 실제로 구현될 가능성을 크게 높였습니다.\u003c/p\u003e\n\u003cp\u003e두 스위트 \"순서대로(in-order)\" 변형에 대한 제안도 있었는데, 이는 순서가 뒤바뀐 실행을 지원하지 않고 이름의 제한된 스코핑을 제공합니다. 그러나 이러한 제안은 사람들이 다중 라인 람다 지원을 요청할 때 불평하는 요점, 즉 하위 표현식의 이름을 정하는 것이 특히 어렵다는 것이 아니라, 사용하는 문장보다 먼저 함수의 이름을 정하는 것이 개발자가 문제를 생각하는 방식과 코드가 일치하지 않게 만든다는 점을 놓치고 있다고 PEP는 주장합니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1637,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Deferred] PEP 3150 - Statement local namespaces (aka “given” clause)\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 14:40:31+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>