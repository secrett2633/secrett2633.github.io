<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/edf391eeca43d999.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d2fcfe6c399a7b4a.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1885<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 522 - Allow BlockingIOError in security sensitive APIs</h1><div class="page__meta"><time dateTime="2025-09-26 23:15:31+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0522/">PEP 522 - Allow BlockingIOError in security sensitive APIs</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 16-Jun-2016</p>
</blockquote>
<h2>PEP 522: 보안에 민감한 API에서 <code>BlockingIOError</code> 허용 (거부됨)</h2>
<h3>요약 (Abstract)</h3>
<p>표준 라이브러리 내의 여러 API는 보안에 민감한 작업에 적합한 무작위 값을 반환하는 것으로 알려져 있지만, 현재 일부 운영체제(특히 Linux 커널)에서는 시스템 난수 생성기가 완전히 초기화되기 전에 <code>/dev/urandom</code>에서 값을 읽는 것을 허용하여 실제로는 이러한 작업에 적합하지 않은 값을 반환할 수 있는 모호한 오류 모드가 존재합니다. 대부분의 다른 운영체제는 이러한 읽기 시에 난수 생성기가 준비될 때까지 암묵적으로 블록(block)합니다.</p>
<p>이 PEP는 하위 레벨의 <code>os.urandom</code> 및 <code>random.SystemRandom</code> API의 경우, Python 3.6부터는 탐지 및 디버그하기 어려웠던 침묵 오류(silent error)를 <code>BlockingIOError</code> 예외를 발생시켜 쉽게 탐지하고 디버그할 수 있는 오류로 변경할 것을 제안했습니다.</p>
<p>새로운 고수준 <code>secrets</code> API의 경우, 이 모듈이 난수를 생성할 때 필요하다면 암묵적으로 블록하도록 제안했습니다. 또한 <code>secrets.wait_for_system_rng()</code> 함수를 노출하여 하위 레벨 API를 사용하는 코드가 시스템 난수 생성기가 사용 가능해질 때까지 명시적으로 기다릴 수 있도록 했습니다.</p>
<p>이 변경 사항은 <code>getrandom()</code> 시스템 호출을 제공하는 모든 운영체제에 영향을 미치며, <code>Windows</code>, <code>Mac OS X</code>, <code>OpenBSD</code>와 같이 시스템 난수 생성기 초기화 전에 사용자 공간 코드 실행을 방지하거나 <code>getrandom()</code> 시스템 호출을 제공하지 않는 운영체제는 영향을 받지 않습니다.</p>
<h3>다른 PEP와의 관계 (Relationship with other PEPs)</h3>
<p>이 PEP는 <code>secrets</code> 모듈을 추가하는 승인된 PEP 506에 의존합니다.</p>
<p>이 PEP는 <code>os.urandom</code> 자체가 시스템 RNG가 준비되지 않았을 때 암묵적으로 블록하도록 제안하는 Victor Stinner의 PEP 524와 경쟁 관계에 있었습니다.</p>
<h3>PEP 거부 (PEP Rejection)</h3>
<p>레퍼런스 구현에 대해 Guido는 PEP 524의 무조건적인 암묵적 블록킹 제안을 선호하여 이 PEP를 거부했습니다. 이로 인해 CPython의 Linux 동작이 다른 운영체제의 동작과 일치하게 됩니다.</p>
<p>이는 Linux 배포판의 시스템 Python 설치에서 <code>os.urandom()</code>의 적절한 기본 동작에 대한 추가 논의는 CPython 메일링 리스트가 아닌 해당 배포판 메일링 리스트에서 진행되어야 함을 의미합니다.</p>
<h3>이 PEP와 독립적인 변경 사항 (Changes independent of this PEP)</h3>
<p>CPython 인터프리터 초기화 및 <code>random</code> 모듈 초기화는 이미 시스템 난수 생성기가 준비되지 않은 경우 대체 시딩(seeding) 옵션으로 우아하게 폴백(fallback)하도록 업데이트되었습니다.</p>
<p>이 PEP는 <code>getrandom</code> 시스템 호출을 노출하기 위해 <code>os.getrandom()</code> API를 추가하는 PEP 524의 제안과 경쟁하지 않습니다. <code>os</code> 모듈은 플랫폼에 의존하는 운영체제 기능을 감싸는 얇은 래퍼(wrapper) 역할을 하므로, 이 API는 <code>os.urandom()</code>의 기본 동작이 어떻게 되든 추가될 수 있습니다.</p>
<h3>제안 (Proposal)</h3>
<h4><code>getrandom()</code> 시스템 호출이 있는 플랫폼에서 <code>os.urandom()</code> 변경</h4>
<p>이 PEP는 Python 3.6+에서 <code>os.urandom()</code>가 <code>getrandom()</code> 시스템 호출을 비블록킹(non-blocking) 모드로 호출하고, 커널이 호출이 블록될 것이라고 보고하면 <code>BlockingIOError: system random number generator is not ready; see secrets.token_bytes()</code> 예외를 발생시키도록 업데이트될 것을 제안했습니다.</p>
<p>이 동작은 <code>random.Random()</code> API와 일치하는 <code>os.urandom()</code>의 얇은 래퍼인 기존 <code>random.SystemRandom</code>으로 전파될 것입니다.</p>
<p>그러나 PEP 506에 의해 도입된 새로운 <code>secrets</code> 모듈은 새로운 예외가 발생하면 이를 catch하고 시스템 난수 생성기를 암묵적으로 기다리도록 업데이트될 것입니다.</p>
<p>모든 경우에, 이 보안에 민감한 API 중 하나에 대한 호출이 성공하면, 해당 프로세스의 모든 향후 API 호출은 블록킹 없이 성공할 것입니다.</p>
<p>Linux 및 NetBSD에서는 <code>/dev/urandom</code>에서 읽은 잠재적으로 예측 가능한 결과를 반환하는 이전 동작을 대체할 것입니다. FreeBSD, Solaris, Illumos에서는 시스템 난수 생성기가 준비될 때까지 암묵적으로 블록하는 이전 동작을 대체할 것입니다.</p>
<h4><code>secrets.wait_for_system_rng()</code> 추가</h4>
<p>새로운 예외는 발생했을 때 해결 방법에 대한 명확한 권고 없이 추가되어서는 안 됩니다. 보안에 민감한 코드가 <code>secrets</code> 모듈 대신 하위 레벨 인터페이스를 사용해야 하고, 사용자 기반에서 이 문제가 실제 문제임을 나타내는 버그 보고서를 받는 경우, 이 PEP는 <code>__main__</code> 모듈에 다음 스니펫을 추가할 것을 권장했습니다.</p>
<pre><code class="language-python">import secrets
secrets.wait_for_system_rng()
</code></pre>
<p>Python 3.6 이전 버전과의 호환성이 필요한 경우:</p>
<pre><code class="language-python">try:
    import secrets
except ImportError:
    pass
else:
    secrets.wait_for_system_rng()
</code></pre>
<p><code>secrets</code> 모듈 자체 내에서는, 새로운 예외가 발생하면 <code>token_bytes()</code>에서 암묵적으로 블록하기 위해 사용될 것입니다.</p>
<pre><code class="language-python">def token_bytes(nbytes=None):
    if nbytes is None:
        nbytes = DEFAULT_ENTROPY
    try:
        result = os.urandom(nbytes)
    except BlockingIOError:
        wait_for_system_rng()
        result = os.urandom(nbytes)
    return result
</code></pre>
<p>다른 모듈 부분들은 <code>os.urandom()</code>을 직접 호출하는 대신 <code>token_bytes()</code>를 기본 난수 생성 빌딩 블록으로 사용하도록 업데이트될 것입니다.</p>
<p>시스템 난수 생성기 액세스가 거의 확실하게 필요한 사용 사례(예: 웹 프레임워크)를 다루는 애플리케이션 프레임워크는 <code>secrets.wait_for_system_rng()</code> 호출을 애플리케이션 시작 명령에 암묵적으로 통합하여, 기존 <code>os.urandom()</code> 호출이 해당 프레임워크를 사용할 때 새로운 예외를 발생시키지 않도록 할 수 있습니다.</p>
<p>직접 수정할 수 없는 애플리케이션의 경우, 다음 명령을 사용하여 시스템 난수 생성기가 초기화될 때까지 기다린 후 애플리케이션을 시작할 수 있습니다.</p>
<pre><code class="language-bash">python3 -c "import secrets; secrets.wait_for_system_rng()"
</code></pre>
<p>이 함수의 제안된 구현은 다음과 같습니다.</p>
<pre><code class="language-python">if hasattr(os, "getrandom"):
    # os.getrandom()은 기본적으로 시스템 RNG가 준비될 때까지 항상 블록합니다.
    def wait_for_system_rng():
        """시스템 난수 생성기가 준비될 때까지 블록합니다."""
        os.getrandom(1)
        return
else:
    # 우리가 아는 한, 다른 플랫폼은 BlockingIOError를 발생시키지 않지만,
    # 구현은 비관적인 가정을 합니다.
    def wait_for_system_rng():
        """시스템 난수 생성기가 준비될 때까지 블록합니다."""
        # 시스템 RNG가 이미 시드된 경우, 전혀 기다리지 않습니다.
        try:
            os.urandom(1)
            return
        except BlockingIOError:
            pass
        # 가능한 경우 아래의 바쁜 루프(busy loop)를 피합니다.
        try:
            block_on_system_rng = open("/dev/random", "rb")
        except FileNotFoundError:
            pass
        else:
            with block_on_system_rng:
                block_on_system_rng.read(1)
        # 시스템 RNG가 준비될 때까지 바쁜 루프
        while True:
            try:
                os.urandom(1)
                break
            except BlockingIOError:
                # 1밀리초마다 한 번만 확인합니다.
                time.sleep(0.001)
</code></pre>
<h4>범위 제한 (Limitations on scope)</h4>
<p><code>Windows</code> 또는 <code>Mac OS X</code> 시스템에 대한 변경 사항은 제안되지 않았습니다. 이 플랫폼들은 운영체제 난수 생성기가 초기화되기 전에 Python 코드를 실행할 메커니즘을 제공하지 않기 때문입니다.</p>
<p>마찬가지로, <code>getrandom()</code> 시스템 호출을 제공하지 않는 다른 *nix 시스템에 대한 변경 사항도 제안되지 않았습니다. 이러한 시스템에서 <code>os.urandom()</code>은 시스템 난수 생성기가 초기화될 때까지 계속 블록할 것입니다.</p>
<h3>근거 (Rationale)</h3>
<h4><code>secrets</code> 모듈이 필요할 때 암묵적으로 블록하도록 보장</h4>
<p>이것은 보안에 민감한 난수를 생성하는 가장 간단한 방법을 원하는 사람들에게 "가능할 때 <code>secrets</code> 모듈을 사용하십시오. 그렇지 않으면 애플리케이션이 예기치 않게 충돌할 수 있습니다."라는 밈(meme)을 장려하기 위한 것입니다.</p>
<p>또한 BDFL(Benevolent Dictator For Life, 자비로운 종신 독재자)이 예상치 못한 예외를 던지는 API보다 예기치 않게 블록할 수 있는 API에 대해 더 높은 허용 오차를 가지고 있기 때문입니다.</p>
<h4>Linux에서 <code>os.urandom()</code>이 <code>BlockingIOError</code>를 발생시키는 경우</h4>
<p>수년 동안 보안 커뮤니티의 지침은 Python에서 보안에 민감한 작업을 구현할 때 <code>os.urandom()</code>(또는 <code>random.SystemRandom()</code> 래퍼)을 사용하는 것이었습니다.</p>
<p>그러나 이 지침에는 오랜 경고가 있었습니다. Linux 및 잠재적으로 일부 다른 *BSD 시스템을 위한 보안에 민감한 소프트웨어를 작성하는 개발자는 운영체제의 난수 생성기가 보안에 민감한 작업에 사용할 준비가 될 때까지 기다려야 할 수도 있습니다.</p>
<p>Linux에서는 Python 3.4 이하 및 Python 3.5.2 이후의 Python 3.5 유지 보수 버전에서, Linux 부팅 프로세스 초기에 또는 엔트로피 소스가 부족한 하드웨어에서 실행될 때 소프트웨어가 예상대로 작동하지 않을 수 있다는 명확한 지표가 개발자에게 없었습니다. 이는 <code>/dev/urandom</code> 장치의 동작으로 인해 <code>os.urandom()</code>이 어떤 경우든 결과를 반환하고, 보안 취약점이 존재함을 입증하려면 광범위한 통계 분석이 필요했기 때문입니다.</p>
<p>대조적으로, 이러한 상황에서 <code>BlockingIOError</code>가 발생하면 Python 3.6+를 사용하는 개발자는 원하는 동작을 쉽게 선택할 수 있습니다.</p>
<ul>
<li>애플리케이션 시작 시 또는 그 이전에 시스템 RNG를 기다립니다 (보안에 민감한 경우).</li>
<li><code>random</code> 모듈 사용으로 전환합니다 (보안에 민감하지 않은 경우).</li>
</ul>
<h4><code>secrets.wait_for_system_rng()</code> 공개 (Making secrets.wait_for_system_rng() public)</h4>
<p>이 PEP의 초기 버전은 <code>os.urandom()</code>을 감싸서 보안에 민감한 사용 사례에 적합하게 만드는 여러 레시피를 제안했습니다.</p>
<p>보안-sig 메일링 리스트에서의 논의는 예외가 애플리케이션을 실패하게 하거나, 시스템 RNG가 준비될 때까지 블록하거나, <code>os.urandom</code> 대신 <code>random</code> 모듈을 사용하는 것 중에서 선택하는 것이 애플리케이션 및 사용 사례별 결정이라는 핵심 가정을 이끌어냈습니다.</p>
<p>이에 따라 PEP는 애플리케이션, 스크립트 및 프레임워크가 시스템 RNG가 사용 가능함을 확인한 후 계속 진행하기 위해 사용할 수 있는 API로 <code>secrets.wait_for_system_rng()</code>를 추가하도록 업데이트되었습니다. 라이브러리 개발자는 <code>os.urandom()</code>이 예기치 않게 블록할 것을 걱정하지 않고 계속 호출할 수 있습니다.</p>
<h3>하위 호환성 영향 평가 (Backwards Compatibility Impact Assessment)</h3>
<p>PEP 476과 유사하게, 이 제안은 이전에 침묵했던 보안 실패를 시끄러운 예외로 바꾸어 애플리케이션 개발자가 원하는 동작에 대해 명시적인 결정을 내리도록 요구합니다.</p>
<p><code>getrandom()</code> 시스템 호출을 제공하지 않는 운영체제에 대한 변경 사항은 제안되지 않았으므로, <code>os.urandom()</code>은 운영체제 난수 생성기가 준비되기 전에 Python 코드를 실행하기 어려운 문제로 인해 실제로는 비블록킹이지만 명목상 블록킹 API로서 기존 동작을 유지합니다.</p>
<p>Linux 및 유사한 <code>/dev/urandom</code> 동작을 가진 다른 플랫폼에서 <code>os.urandom()</code>은 보장된 비블록킹 API로서의 상태를 유지합니다. 그러나 운영체제 난수 생성기가 보안에 민감한 작업에 사용할 준비가 되지 않은 특정 경우에 그 상태를 달성하는 방법이 변경됩니다. 과거에는 잠재적으로 예측 가능한 무작위 데이터를 반환했지만, 이 PEP를 통해 <code>BlockingIOError</code>를 발생시키도록 변경될 것입니다.</p>
<p>영향을 받는 애플리케이션 개발자는 Python 3.6과의 정방향 호환성을 얻기 위해 개발 중인 애플리케이션 종류에 따라 다음 변경 사항 중 하나를 적용해야 합니다.</p>
<h4>영향을 받지 않는 애플리케이션 (Unaffected Applications)</h4>
<p>다음 종류의 애플리케이션은 보안에 민감한 작업을 수행하는지 여부와 관계없이 변경 사항의 영향을 전혀 받지 않습니다.</p>
<ul>
<li>Linux를 지원하지 않는 애플리케이션</li>
<li>데스크톱 또는 일반 서버에서만 실행되는 애플리케이션</li>
<li>시스템 RNG가 준비된 후에만 실행되는 애플리케이션 (애플리케이션 프레임워크가 대신 <code>secrets.wait_for_system_rng()</code>를 호출하는 경우 포함)</li>
</ul>
<h4>영향을 받는 보안에 민감한 애플리케이션 (Affected security sensitive applications)</h4>
<p>보안에 민감한 애플리케이션은 시스템 구성(애플리케이션이 시스템 난수 생성기가 보안에 민감한 작업에 준비된 후에만 시작되도록)을 변경하거나, 애플리케이션 시작 코드에서 <code>secrets.wait_for_system_rng()</code>를 호출하도록 변경하거나, 새로운 <code>secrets.token_bytes()</code> API를 사용하도록 전환해야 합니다.</p>
<h4>영향을 받는 비보안에 민감한 애플리케이션 (Affected non-security sensitive applications)</h4>
<p>보안에 민감하지 않은 애플리케이션은 <code>os.urandom</code> 대신 <code>random</code> 모듈을 사용하도록 업데이트해야 합니다.</p>
<pre><code class="language-python">def pseudorandom_bytes(num_bytes):
    return random.getrandbits(num_bytes*8).to_bytes(num_bytes, "little")
</code></pre>
<h3>추가 배경 (Additional Background)</h3>
<h4>왜 지금 제안되었는가? (Why propose this now?)</h4>
<p>주된 이유는 Python 3.5.0 릴리스가 파일 디스크립터 사용을 피하기 위해 <code>getrandom()</code> 시스템 호출을 사용하도록 전환했기 때문입니다. 이로 인해 다음 작업이 시스템 난수 생성기가 준비될 때까지 블록되는 부작용이 발생했습니다.</p>
<ul>
<li><code>os.urandom</code> (및 이에 의존하는 API)</li>
<li><code>random</code> 모듈 임포트</li>
<li>일부 내장 타입에서 사용되는 무작위화된 해시 알고리즘 초기화</li>
</ul>
<p>처음 두 가지 동작은 불필요하고 바람직하지 않으며, 마지막 동작은 Python 3.5.0 또는 3.5.1로 Linux init 프로세스 중에 Python 스크립트를 실행하려고 할 때 시스템 수준의 교착 상태(deadlock)를 유발하는 것으로 알려져 있습니다. 두 번째 동작은 강력한 엔트로피 소스가 구성되지 않은 가상 머신을 사용할 때 문제를 일으킬 수 있습니다.</p>
<p>CPython에서 이러한 동작을 분리하는 것은 유지 보수 릴리스보다는 기능 릴리스에 더 적합한 여러 구현 변경을 수반할 것이므로, Python 3.5.2에서 적용된 비교적 간단한 해결책은 이 세 가지를 모두 이전 Python 버전의 동작과 유사하게 되돌리는 것이었습니다. 즉, 새로운 Linux 시스템 호출이 블록될 것임을 나타내면 Python 3.5.2는 <code>/dev/urandom</code>에서 직접 읽기로 암묵적으로 폴백합니다.</p>
<p>그러나 이 버그 보고서는 <code>os.getrandom()</code>, <code>os.urandom_block()</code>, <code>os.pseudorandom()</code>, <code>os.cryptorandom()</code>와 같은 새로운 API를 추가하거나 <code>os.urandom()</code> 자체에 새로운 선택적 매개변수를 추가하는 등 다양한 제안으로 이어졌습니다. 이 제안들은 <code>secrets</code> 모듈이 이미 "이것을 사용하고 하위 수준 세부 사항에 대해 걱정하지 마십시오" 옵션으로 추가되고 있다는 점에서 과잉 반응으로 볼 수 있습니다.</p>
<p>그럼에도 불구하고, 저가 ARM 장치가 점점 더 보편화되고 있으며, 많은 장치가 Linux를 실행하고 Python 애플리케이션이 이러한 장치에서 실행되고 있습니다. 이는 진단 및 해결을 위해 Linux 부팅 프로세스 및 증명 가능한 예측 불가능한 난수 생성에 대한 많은 지식을 요구하는 모호한 보안 문제를 비교적 평범하고 인터넷 검색에서 쉽게 찾을 수 있는 런타임 예외로 전환할 기회를 만듭니다.</p>
<h4><code>os.urandom()</code>의 크로스 플랫폼 동작 (The cross-platform behaviour of os.urandom())</h4>
<p>Linux 및 NetBSD를 제외한 운영체제에서 <code>os.urandom()</code>은 운영체제의 난수 생성기가 준비될 때까지 블록할 수 있습니다. 이는 프로세스 수명 동안 최대 한 번 발생하며, 이후의 호출은 비블록킹이 보장됩니다.</p>
<p>Linux 및 NetBSD는 운영체제의 난수 생성기가 보안에 민감한 작업에 사용할 준비가 되지 않은 경우에도 <code>/dev/urandom</code> 장치에서 읽으면 사용 가능한 엔트로피를 기반으로 무작위 값을 반환한다는 점에서 예외적입니다.</p>
<p>이 동작은 잠재적으로 문제가 될 수 있으므로, Linux 3.17은 새로운 <code>getrandom()</code> 시스템 호출을 추가하여 호출자가 난수 생성기가 준비될 때까지 블록하거나, 난수 생성기가 준비되지 않은 경우 오류 반환을 요청할 수 있도록 했습니다.</p>
<p>Python 3.4 이하 버전은 Linux <code>/dev/urandom</code> 장치에 직접 액세스합니다. Python 3.5.0 및 3.5.1은 파일 디스크립터 사용을 피하기 위해 <code>getrandom()</code>을 블록킹 모드로 호출했습니다. 사용자 코드에서 <code>os.urandom()</code>이 블록킹하는 문제에 대한 보고는 없었지만, 인터프리터 시작 시 및 <code>random</code> 모듈 임포트 시 CPython이 암묵적으로 블록킹 동작을 호출하여 문제가 발생했습니다.</p>
<p>SipHash 초기화를 <code>os.urandom()</code> 구현과 분리하려는 시도 대신, Python 3.5.2는 <code>getrandom()</code>을 비블록킹 모드로 호출하고, 시스템 호출이 블록될 것임을 나타내면 <code>/dev/urandom</code>에서 읽기로 폴백하도록 전환했습니다.</p>
<p>결과적으로, Python 3.5 이하의 모든 Python 버전에서 <code>os.urandom()</code>은 <code>/dev/urandom</code> 장치의 동작을 Python 코드로 전파합니다.</p>
<h4>Linux의 <code>/dev/urandom</code> 동작 문제 (Problems with the behaviour of /dev/urandom on Linux)</h4>
<p>Python <code>os</code> 모듈은 Linux API와 함께 발전해 왔으므로, <code>os</code> 모듈 함수가 Linux에서 실행될 때 해당 Linux 운영체제 수준 카운터파트의 동작을 밀접하게 따르는 것은 일반적으로 바람직한 기능으로 간주됩니다.</p>
<p>그러나 <code>/dev/urandom</code>은 현재 동작이 문제가 있는 것으로 인정되지만, 커널 수준에서 일방적으로 수정하면 일부 Linux 배포판이 부팅되지 않는 것으로 나타난 경우입니다.</p>
<p>운영체제의 난수 생성기를 예측 불가능한 비밀번호를 생성하는 메서드라고 생각한다면, Linux의 <code>/dev/urandom</code>은 다음과 같이 구현된 것으로 생각할 수 있습니다.</p>
<pre><code class="language-python"># /dev/urandom을 구현하는 커널 코드의 과도하게 단순화된 예술적 개념
def generate_unpredictable_password():
    if system_rng_is_ready:
        return use_system_rng_to_generate_password()
    else:
        # 예측 불가능한 암호를 만들 수 없습니다. 대신 잠재적으로 예측 가능한 암호를
        # 조용히 반환합니다.
        return "p4ssw0rd"
</code></pre>
<p>이 시나리오는 일반적으로 좋지 않은 아이디어로 간주됩니다. 실제로 원하는 동작인 사용 사례는 전혀 없습니다. 이로 인해 실제 시스템에서 안전하지 않은 SSH 키가 사용되었고, 많은 *nix 계열 시스템(Mac OS X, OpenBSD, FreeBSD 포함)은 <code>/dev/urandom</code> 구현을 수정하여 예측 가능한 출력을 절대 반환하지 않도록 했습니다.</p>
<p>대신, 새로운 <code>getrandom()</code> 시스템 호출이 도입되어 사용자 공간 애플리케이션이 안전하게 시스템 난수 생성기에 액세스할 수 있게 되었으며, 기존 Linux 배포판의 시스템 초기화 프로세스에 디버그하기 어려운 교착 상태 문제를 도입하지 않습니다.</p>
<h4>Python에 <code>getrandom()</code> 가용성의 결과 (Consequences of getrandom() availability for Python)</h4>
<p><code>getrandom()</code> 시스템 호출이 도입되기 전에는 증명 가능한 안전한 방식으로 Linux 시스템 난수 생성기에 액세스하는 것이 단순히 불가능했으므로, 우리는 <code>/dev/urandom</code>에서 읽는 것을 최선의 선택으로 받아들일 수밖에 없었습니다. 그러나 <code>getrandom()</code>이 예측 가능한 데이터를 반환하는 대신 오류를 발생시키거나 블록하도록 요구하고 다른 이점도 있으므로, 이제 Linux에서 커널 RNG에 액세스하는 권장 방법이며, <code>/dev/urandom</code>에서 직접 읽는 것은 "레거시" 상태로 강등되었습니다.</p>
<p>이는 이전에 다른 사람의 문제(Linux 커널 개발팀의 문제)였던 것이 이제 Python의 문제가 되었음을 의미합니다. 시스템 RNG가 초기화되지 않았음을 감지할 수 있는 방법이 주어졌으므로, 시스템 RNG를 사용하려고 할 때마다 이 상황을 어떻게 처리할지 선택해야 합니다.</p>
<p>이 PEP에서 제안한 것처럼 단순히 블록하거나 오류를 발생시킬 수 있습니다.</p>
<ul>
<li><strong>블록킹 방식 (PEP 524와 유사):</strong>
<pre><code class="language-python">def generate_unpredictable_bytes_or_block(num_bytes):
    while not system_rng_is_ready:
        wait
    return unpredictable_bytes(num_bytes)
</code></pre>
</li>
<li><strong>오류 발생 방식 (이 PEP에서 제안):</strong>
<pre><code class="language-python">def generate_unpredictable_bytes_or_raise(num_bytes):
    if system_rng_is_ready:
        return unpredictable_bytes(num_bytes)
    else:
        raise BlockingIOError
</code></pre>
</li>
<li><strong><code>/dev/urandom</code> 폴백 방식 (Python 3.5.2rc1+):</strong>
<pre><code class="language-python">def generate_unpredictable_bytes_or_maybe_not(num_bytes):
    if system_rng_is_ready:
        return unpredictable_bytes(num_bytes)
    else:
        return (b"p4ssw0rd" * (num_bytes // 8 + 1))[:num_bytes]
</code></pre>
</li>
</ul>
<p>CPython과 표준 라이브러리가 운영체제의 난수 생성기를 사용하려고 시도하는 다섯 가지 장소가 있으며, 이 결정이 이루어져야 하는 다섯 가지 장소가 있습니다.</p>
<ol>
<li><code>str.__hash__</code> 및 관련 기능의 DoS 공격 방지를 위해 사용되는 SipHash 초기화 (시작 시 무조건 호출됨)</li>
<li><code>random</code> 모듈 초기화 (random이 임포트될 때 호출됨)</li>
<li><code>os.urandom</code> 공개 API에 대한 사용자 호출 처리</li>
<li>고수준 <code>random.SystemRandom</code> 공개 API</li>
<li>PEP 506에 의해 추가된 새로운 <code>secrets</code> 모듈 공개 API</li>
</ol>
<p>이 전체 문제는 3.5.0이 기본 코드를 <code>generate_unpredictable_bytes_or_block</code> 동작으로 전환했을 때 처음 발견되었습니다. Linux 부팅 스크립트가 시스템 초기화의 일부로 Python 프로그램을 실행하려고 시도하고, Python 시작 시퀀스가 SipHash 초기화를 시도하는 동안 블록되어, 시스템이 새 엔트로피 수집을 포함한 모든 작업을 중단하는 교착 상태가 발생한 드문 경우가 있었습니다. 이는 문제가 되는 스크립트가 신뢰할 수 없는 입력을 처리하지 않았으므로, 처음부터 SipHash를 증명 가능한 예측 불가능한 무작위 데이터로 초기화할 필요가 없었다는 점에서 특히 불운했습니다. 이는 3.5.2rc1에서 모든 경우에 이전 <code>/dev/urandom</code> 동작을 에뮬레이트하도록 변경한 동기가 되었습니다.</p>
<p>이 PEP와는 독립적으로, 처음 두 경우(<code>SipHash 초기화</code> 및 <code>random 모듈 초기화</code>)는 <code>os.urandom()</code>의 동작과 관계없이 절대 블록하지 않도록 이미 업데이트되었습니다.</p>
<p>PEP 524가 후자의 세 가지 경우를 모두 암묵적으로 블록하도록 제안하는 반면, 이 PEP는 <code>secrets</code> 모듈에 대해서만 해당 접근 방식을 제안하고, <code>os.urandom()</code> 및 <code>random.SystemRandom()</code>은 기본 운영체제 호출이 블록될 것임을 감지할 때 예외를 발생시키도록 제안했습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/521/">[Withdrawn] PEP 521 - Managing global context via ‘with’ blocks in generators and coroutines</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Rejected] PEP 522 - Allow BlockingIOError in security sensitive APIs</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/523/">[Final] PEP 523 - Adding a frame evaluation API to CPython</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/edf391eeca43d999.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d2fcfe6c399a7b4a.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/522\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/edf391eeca43d999.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"LkoFRRXGj3o0jVIpHD68u\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/522/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/522\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"522\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/522\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T6b60,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0522/\"\u003ePEP 522 - Allow BlockingIOError in security sensitive APIs\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 16-Jun-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 522: 보안에 민감한 API에서 \u003ccode\u003eBlockingIOError\u003c/code\u003e 허용 (거부됨)\u003c/h2\u003e\n\u003ch3\u003e요약 (Abstract)\u003c/h3\u003e\n\u003cp\u003e표준 라이브러리 내의 여러 API는 보안에 민감한 작업에 적합한 무작위 값을 반환하는 것으로 알려져 있지만, 현재 일부 운영체제(특히 Linux 커널)에서는 시스템 난수 생성기가 완전히 초기화되기 전에 \u003ccode\u003e/dev/urandom\u003c/code\u003e에서 값을 읽는 것을 허용하여 실제로는 이러한 작업에 적합하지 않은 값을 반환할 수 있는 모호한 오류 모드가 존재합니다. 대부분의 다른 운영체제는 이러한 읽기 시에 난수 생성기가 준비될 때까지 암묵적으로 블록(block)합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 하위 레벨의 \u003ccode\u003eos.urandom\u003c/code\u003e 및 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e API의 경우, Python 3.6부터는 탐지 및 디버그하기 어려웠던 침묵 오류(silent error)를 \u003ccode\u003eBlockingIOError\u003c/code\u003e 예외를 발생시켜 쉽게 탐지하고 디버그할 수 있는 오류로 변경할 것을 제안했습니다.\u003c/p\u003e\n\u003cp\u003e새로운 고수준 \u003ccode\u003esecrets\u003c/code\u003e API의 경우, 이 모듈이 난수를 생성할 때 필요하다면 암묵적으로 블록하도록 제안했습니다. 또한 \u003ccode\u003esecrets.wait_for_system_rng()\u003c/code\u003e 함수를 노출하여 하위 레벨 API를 사용하는 코드가 시스템 난수 생성기가 사용 가능해질 때까지 명시적으로 기다릴 수 있도록 했습니다.\u003c/p\u003e\n\u003cp\u003e이 변경 사항은 \u003ccode\u003egetrandom()\u003c/code\u003e 시스템 호출을 제공하는 모든 운영체제에 영향을 미치며, \u003ccode\u003eWindows\u003c/code\u003e, \u003ccode\u003eMac OS X\u003c/code\u003e, \u003ccode\u003eOpenBSD\u003c/code\u003e와 같이 시스템 난수 생성기 초기화 전에 사용자 공간 코드 실행을 방지하거나 \u003ccode\u003egetrandom()\u003c/code\u003e 시스템 호출을 제공하지 않는 운영체제는 영향을 받지 않습니다.\u003c/p\u003e\n\u003ch3\u003e다른 PEP와의 관계 (Relationship with other PEPs)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003esecrets\u003c/code\u003e 모듈을 추가하는 승인된 PEP 506에 의존합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003eos.urandom\u003c/code\u003e 자체가 시스템 RNG가 준비되지 않았을 때 암묵적으로 블록하도록 제안하는 Victor Stinner의 PEP 524와 경쟁 관계에 있었습니다.\u003c/p\u003e\n\u003ch3\u003ePEP 거부 (PEP Rejection)\u003c/h3\u003e\n\u003cp\u003e레퍼런스 구현에 대해 Guido는 PEP 524의 무조건적인 암묵적 블록킹 제안을 선호하여 이 PEP를 거부했습니다. 이로 인해 CPython의 Linux 동작이 다른 운영체제의 동작과 일치하게 됩니다.\u003c/p\u003e\n\u003cp\u003e이는 Linux 배포판의 시스템 Python 설치에서 \u003ccode\u003eos.urandom()\u003c/code\u003e의 적절한 기본 동작에 대한 추가 논의는 CPython 메일링 리스트가 아닌 해당 배포판 메일링 리스트에서 진행되어야 함을 의미합니다.\u003c/p\u003e\n\u003ch3\u003e이 PEP와 독립적인 변경 사항 (Changes independent of this PEP)\u003c/h3\u003e\n\u003cp\u003eCPython 인터프리터 초기화 및 \u003ccode\u003erandom\u003c/code\u003e 모듈 초기화는 이미 시스템 난수 생성기가 준비되지 않은 경우 대체 시딩(seeding) 옵션으로 우아하게 폴백(fallback)하도록 업데이트되었습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003egetrandom\u003c/code\u003e 시스템 호출을 노출하기 위해 \u003ccode\u003eos.getrandom()\u003c/code\u003e API를 추가하는 PEP 524의 제안과 경쟁하지 않습니다. \u003ccode\u003eos\u003c/code\u003e 모듈은 플랫폼에 의존하는 운영체제 기능을 감싸는 얇은 래퍼(wrapper) 역할을 하므로, 이 API는 \u003ccode\u003eos.urandom()\u003c/code\u003e의 기본 동작이 어떻게 되든 추가될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e제안 (Proposal)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003egetrandom()\u003c/code\u003e 시스템 호출이 있는 플랫폼에서 \u003ccode\u003eos.urandom()\u003c/code\u003e 변경\u003c/h4\u003e\n\u003cp\u003e이 PEP는 Python 3.6+에서 \u003ccode\u003eos.urandom()\u003c/code\u003e가 \u003ccode\u003egetrandom()\u003c/code\u003e 시스템 호출을 비블록킹(non-blocking) 모드로 호출하고, 커널이 호출이 블록될 것이라고 보고하면 \u003ccode\u003eBlockingIOError: system random number generator is not ready; see secrets.token_bytes()\u003c/code\u003e 예외를 발생시키도록 업데이트될 것을 제안했습니다.\u003c/p\u003e\n\u003cp\u003e이 동작은 \u003ccode\u003erandom.Random()\u003c/code\u003e API와 일치하는 \u003ccode\u003eos.urandom()\u003c/code\u003e의 얇은 래퍼인 기존 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e으로 전파될 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 PEP 506에 의해 도입된 새로운 \u003ccode\u003esecrets\u003c/code\u003e 모듈은 새로운 예외가 발생하면 이를 catch하고 시스템 난수 생성기를 암묵적으로 기다리도록 업데이트될 것입니다.\u003c/p\u003e\n\u003cp\u003e모든 경우에, 이 보안에 민감한 API 중 하나에 대한 호출이 성공하면, 해당 프로세스의 모든 향후 API 호출은 블록킹 없이 성공할 것입니다.\u003c/p\u003e\n\u003cp\u003eLinux 및 NetBSD에서는 \u003ccode\u003e/dev/urandom\u003c/code\u003e에서 읽은 잠재적으로 예측 가능한 결과를 반환하는 이전 동작을 대체할 것입니다. FreeBSD, Solaris, Illumos에서는 시스템 난수 생성기가 준비될 때까지 암묵적으로 블록하는 이전 동작을 대체할 것입니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003esecrets.wait_for_system_rng()\u003c/code\u003e 추가\u003c/h4\u003e\n\u003cp\u003e새로운 예외는 발생했을 때 해결 방법에 대한 명확한 권고 없이 추가되어서는 안 됩니다. 보안에 민감한 코드가 \u003ccode\u003esecrets\u003c/code\u003e 모듈 대신 하위 레벨 인터페이스를 사용해야 하고, 사용자 기반에서 이 문제가 실제 문제임을 나타내는 버그 보고서를 받는 경우, 이 PEP는 \u003ccode\u003e__main__\u003c/code\u003e 모듈에 다음 스니펫을 추가할 것을 권장했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport secrets\nsecrets.wait_for_system_rng()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 3.6 이전 버전과의 호환성이 필요한 경우:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\n    import secrets\nexcept ImportError:\n    pass\nelse:\n    secrets.wait_for_system_rng()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esecrets\u003c/code\u003e 모듈 자체 내에서는, 새로운 예외가 발생하면 \u003ccode\u003etoken_bytes()\u003c/code\u003e에서 암묵적으로 블록하기 위해 사용될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef token_bytes(nbytes=None):\n    if nbytes is None:\n        nbytes = DEFAULT_ENTROPY\n    try:\n        result = os.urandom(nbytes)\n    except BlockingIOError:\n        wait_for_system_rng()\n        result = os.urandom(nbytes)\n    return result\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 모듈 부분들은 \u003ccode\u003eos.urandom()\u003c/code\u003e을 직접 호출하는 대신 \u003ccode\u003etoken_bytes()\u003c/code\u003e를 기본 난수 생성 빌딩 블록으로 사용하도록 업데이트될 것입니다.\u003c/p\u003e\n\u003cp\u003e시스템 난수 생성기 액세스가 거의 확실하게 필요한 사용 사례(예: 웹 프레임워크)를 다루는 애플리케이션 프레임워크는 \u003ccode\u003esecrets.wait_for_system_rng()\u003c/code\u003e 호출을 애플리케이션 시작 명령에 암묵적으로 통합하여, 기존 \u003ccode\u003eos.urandom()\u003c/code\u003e 호출이 해당 프레임워크를 사용할 때 새로운 예외를 발생시키지 않도록 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e직접 수정할 수 없는 애플리케이션의 경우, 다음 명령을 사용하여 시스템 난수 생성기가 초기화될 때까지 기다린 후 애플리케이션을 시작할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epython3 -c \"import secrets; secrets.wait_for_system_rng()\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수의 제안된 구현은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif hasattr(os, \"getrandom\"):\n    # os.getrandom()은 기본적으로 시스템 RNG가 준비될 때까지 항상 블록합니다.\n    def wait_for_system_rng():\n        \"\"\"시스템 난수 생성기가 준비될 때까지 블록합니다.\"\"\"\n        os.getrandom(1)\n        return\nelse:\n    # 우리가 아는 한, 다른 플랫폼은 BlockingIOError를 발생시키지 않지만,\n    # 구현은 비관적인 가정을 합니다.\n    def wait_for_system_rng():\n        \"\"\"시스템 난수 생성기가 준비될 때까지 블록합니다.\"\"\"\n        # 시스템 RNG가 이미 시드된 경우, 전혀 기다리지 않습니다.\n        try:\n            os.urandom(1)\n            return\n        except BlockingIOError:\n            pass\n        # 가능한 경우 아래의 바쁜 루프(busy loop)를 피합니다.\n        try:\n            block_on_system_rng = open(\"/dev/random\", \"rb\")\n        except FileNotFoundError:\n            pass\n        else:\n            with block_on_system_rng:\n                block_on_system_rng.read(1)\n        # 시스템 RNG가 준비될 때까지 바쁜 루프\n        while True:\n            try:\n                os.urandom(1)\n                break\n            except BlockingIOError:\n                # 1밀리초마다 한 번만 확인합니다.\n                time.sleep(0.001)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e범위 제한 (Limitations on scope)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eWindows\u003c/code\u003e 또는 \u003ccode\u003eMac OS X\u003c/code\u003e 시스템에 대한 변경 사항은 제안되지 않았습니다. 이 플랫폼들은 운영체제 난수 생성기가 초기화되기 전에 Python 코드를 실행할 메커니즘을 제공하지 않기 때문입니다.\u003c/p\u003e\n\u003cp\u003e마찬가지로, \u003ccode\u003egetrandom()\u003c/code\u003e 시스템 호출을 제공하지 않는 다른 *nix 시스템에 대한 변경 사항도 제안되지 않았습니다. 이러한 시스템에서 \u003ccode\u003eos.urandom()\u003c/code\u003e은 시스템 난수 생성기가 초기화될 때까지 계속 블록할 것입니다.\u003c/p\u003e\n\u003ch3\u003e근거 (Rationale)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003esecrets\u003c/code\u003e 모듈이 필요할 때 암묵적으로 블록하도록 보장\u003c/h4\u003e\n\u003cp\u003e이것은 보안에 민감한 난수를 생성하는 가장 간단한 방법을 원하는 사람들에게 \"가능할 때 \u003ccode\u003esecrets\u003c/code\u003e 모듈을 사용하십시오. 그렇지 않으면 애플리케이션이 예기치 않게 충돌할 수 있습니다.\"라는 밈(meme)을 장려하기 위한 것입니다.\u003c/p\u003e\n\u003cp\u003e또한 BDFL(Benevolent Dictator For Life, 자비로운 종신 독재자)이 예상치 못한 예외를 던지는 API보다 예기치 않게 블록할 수 있는 API에 대해 더 높은 허용 오차를 가지고 있기 때문입니다.\u003c/p\u003e\n\u003ch4\u003eLinux에서 \u003ccode\u003eos.urandom()\u003c/code\u003e이 \u003ccode\u003eBlockingIOError\u003c/code\u003e를 발생시키는 경우\u003c/h4\u003e\n\u003cp\u003e수년 동안 보안 커뮤니티의 지침은 Python에서 보안에 민감한 작업을 구현할 때 \u003ccode\u003eos.urandom()\u003c/code\u003e(또는 \u003ccode\u003erandom.SystemRandom()\u003c/code\u003e 래퍼)을 사용하는 것이었습니다.\u003c/p\u003e\n\u003cp\u003e그러나 이 지침에는 오랜 경고가 있었습니다. Linux 및 잠재적으로 일부 다른 *BSD 시스템을 위한 보안에 민감한 소프트웨어를 작성하는 개발자는 운영체제의 난수 생성기가 보안에 민감한 작업에 사용할 준비가 될 때까지 기다려야 할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003eLinux에서는 Python 3.4 이하 및 Python 3.5.2 이후의 Python 3.5 유지 보수 버전에서, Linux 부팅 프로세스 초기에 또는 엔트로피 소스가 부족한 하드웨어에서 실행될 때 소프트웨어가 예상대로 작동하지 않을 수 있다는 명확한 지표가 개발자에게 없었습니다. 이는 \u003ccode\u003e/dev/urandom\u003c/code\u003e 장치의 동작으로 인해 \u003ccode\u003eos.urandom()\u003c/code\u003e이 어떤 경우든 결과를 반환하고, 보안 취약점이 존재함을 입증하려면 광범위한 통계 분석이 필요했기 때문입니다.\u003c/p\u003e\n\u003cp\u003e대조적으로, 이러한 상황에서 \u003ccode\u003eBlockingIOError\u003c/code\u003e가 발생하면 Python 3.6+를 사용하는 개발자는 원하는 동작을 쉽게 선택할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e애플리케이션 시작 시 또는 그 이전에 시스템 RNG를 기다립니다 (보안에 민감한 경우).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erandom\u003c/code\u003e 모듈 사용으로 전환합니다 (보안에 민감하지 않은 경우).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003ccode\u003esecrets.wait_for_system_rng()\u003c/code\u003e 공개 (Making secrets.wait_for_system_rng() public)\u003c/h4\u003e\n\u003cp\u003e이 PEP의 초기 버전은 \u003ccode\u003eos.urandom()\u003c/code\u003e을 감싸서 보안에 민감한 사용 사례에 적합하게 만드는 여러 레시피를 제안했습니다.\u003c/p\u003e\n\u003cp\u003e보안-sig 메일링 리스트에서의 논의는 예외가 애플리케이션을 실패하게 하거나, 시스템 RNG가 준비될 때까지 블록하거나, \u003ccode\u003eos.urandom\u003c/code\u003e 대신 \u003ccode\u003erandom\u003c/code\u003e 모듈을 사용하는 것 중에서 선택하는 것이 애플리케이션 및 사용 사례별 결정이라는 핵심 가정을 이끌어냈습니다.\u003c/p\u003e\n\u003cp\u003e이에 따라 PEP는 애플리케이션, 스크립트 및 프레임워크가 시스템 RNG가 사용 가능함을 확인한 후 계속 진행하기 위해 사용할 수 있는 API로 \u003ccode\u003esecrets.wait_for_system_rng()\u003c/code\u003e를 추가하도록 업데이트되었습니다. 라이브러리 개발자는 \u003ccode\u003eos.urandom()\u003c/code\u003e이 예기치 않게 블록할 것을 걱정하지 않고 계속 호출할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e하위 호환성 영향 평가 (Backwards Compatibility Impact Assessment)\u003c/h3\u003e\n\u003cp\u003ePEP 476과 유사하게, 이 제안은 이전에 침묵했던 보안 실패를 시끄러운 예외로 바꾸어 애플리케이션 개발자가 원하는 동작에 대해 명시적인 결정을 내리도록 요구합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egetrandom()\u003c/code\u003e 시스템 호출을 제공하지 않는 운영체제에 대한 변경 사항은 제안되지 않았으므로, \u003ccode\u003eos.urandom()\u003c/code\u003e은 운영체제 난수 생성기가 준비되기 전에 Python 코드를 실행하기 어려운 문제로 인해 실제로는 비블록킹이지만 명목상 블록킹 API로서 기존 동작을 유지합니다.\u003c/p\u003e\n\u003cp\u003eLinux 및 유사한 \u003ccode\u003e/dev/urandom\u003c/code\u003e 동작을 가진 다른 플랫폼에서 \u003ccode\u003eos.urandom()\u003c/code\u003e은 보장된 비블록킹 API로서의 상태를 유지합니다. 그러나 운영체제 난수 생성기가 보안에 민감한 작업에 사용할 준비가 되지 않은 특정 경우에 그 상태를 달성하는 방법이 변경됩니다. 과거에는 잠재적으로 예측 가능한 무작위 데이터를 반환했지만, 이 PEP를 통해 \u003ccode\u003eBlockingIOError\u003c/code\u003e를 발생시키도록 변경될 것입니다.\u003c/p\u003e\n\u003cp\u003e영향을 받는 애플리케이션 개발자는 Python 3.6과의 정방향 호환성을 얻기 위해 개발 중인 애플리케이션 종류에 따라 다음 변경 사항 중 하나를 적용해야 합니다.\u003c/p\u003e\n\u003ch4\u003e영향을 받지 않는 애플리케이션 (Unaffected Applications)\u003c/h4\u003e\n\u003cp\u003e다음 종류의 애플리케이션은 보안에 민감한 작업을 수행하는지 여부와 관계없이 변경 사항의 영향을 전혀 받지 않습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinux를 지원하지 않는 애플리케이션\u003c/li\u003e\n\u003cli\u003e데스크톱 또는 일반 서버에서만 실행되는 애플리케이션\u003c/li\u003e\n\u003cli\u003e시스템 RNG가 준비된 후에만 실행되는 애플리케이션 (애플리케이션 프레임워크가 대신 \u003ccode\u003esecrets.wait_for_system_rng()\u003c/code\u003e를 호출하는 경우 포함)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e영향을 받는 보안에 민감한 애플리케이션 (Affected security sensitive applications)\u003c/h4\u003e\n\u003cp\u003e보안에 민감한 애플리케이션은 시스템 구성(애플리케이션이 시스템 난수 생성기가 보안에 민감한 작업에 준비된 후에만 시작되도록)을 변경하거나, 애플리케이션 시작 코드에서 \u003ccode\u003esecrets.wait_for_system_rng()\u003c/code\u003e를 호출하도록 변경하거나, 새로운 \u003ccode\u003esecrets.token_bytes()\u003c/code\u003e API를 사용하도록 전환해야 합니다.\u003c/p\u003e\n\u003ch4\u003e영향을 받는 비보안에 민감한 애플리케이션 (Affected non-security sensitive applications)\u003c/h4\u003e\n\u003cp\u003e보안에 민감하지 않은 애플리케이션은 \u003ccode\u003eos.urandom\u003c/code\u003e 대신 \u003ccode\u003erandom\u003c/code\u003e 모듈을 사용하도록 업데이트해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef pseudorandom_bytes(num_bytes):\n    return random.getrandbits(num_bytes*8).to_bytes(num_bytes, \"little\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e추가 배경 (Additional Background)\u003c/h3\u003e\n\u003ch4\u003e왜 지금 제안되었는가? (Why propose this now?)\u003c/h4\u003e\n\u003cp\u003e주된 이유는 Python 3.5.0 릴리스가 파일 디스크립터 사용을 피하기 위해 \u003ccode\u003egetrandom()\u003c/code\u003e 시스템 호출을 사용하도록 전환했기 때문입니다. 이로 인해 다음 작업이 시스템 난수 생성기가 준비될 때까지 블록되는 부작용이 발생했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eos.urandom\u003c/code\u003e (및 이에 의존하는 API)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erandom\u003c/code\u003e 모듈 임포트\u003c/li\u003e\n\u003cli\u003e일부 내장 타입에서 사용되는 무작위화된 해시 알고리즘 초기화\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e처음 두 가지 동작은 불필요하고 바람직하지 않으며, 마지막 동작은 Python 3.5.0 또는 3.5.1로 Linux init 프로세스 중에 Python 스크립트를 실행하려고 할 때 시스템 수준의 교착 상태(deadlock)를 유발하는 것으로 알려져 있습니다. 두 번째 동작은 강력한 엔트로피 소스가 구성되지 않은 가상 머신을 사용할 때 문제를 일으킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003eCPython에서 이러한 동작을 분리하는 것은 유지 보수 릴리스보다는 기능 릴리스에 더 적합한 여러 구현 변경을 수반할 것이므로, Python 3.5.2에서 적용된 비교적 간단한 해결책은 이 세 가지를 모두 이전 Python 버전의 동작과 유사하게 되돌리는 것이었습니다. 즉, 새로운 Linux 시스템 호출이 블록될 것임을 나타내면 Python 3.5.2는 \u003ccode\u003e/dev/urandom\u003c/code\u003e에서 직접 읽기로 암묵적으로 폴백합니다.\u003c/p\u003e\n\u003cp\u003e그러나 이 버그 보고서는 \u003ccode\u003eos.getrandom()\u003c/code\u003e, \u003ccode\u003eos.urandom_block()\u003c/code\u003e, \u003ccode\u003eos.pseudorandom()\u003c/code\u003e, \u003ccode\u003eos.cryptorandom()\u003c/code\u003e와 같은 새로운 API를 추가하거나 \u003ccode\u003eos.urandom()\u003c/code\u003e 자체에 새로운 선택적 매개변수를 추가하는 등 다양한 제안으로 이어졌습니다. 이 제안들은 \u003ccode\u003esecrets\u003c/code\u003e 모듈이 이미 \"이것을 사용하고 하위 수준 세부 사항에 대해 걱정하지 마십시오\" 옵션으로 추가되고 있다는 점에서 과잉 반응으로 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그럼에도 불구하고, 저가 ARM 장치가 점점 더 보편화되고 있으며, 많은 장치가 Linux를 실행하고 Python 애플리케이션이 이러한 장치에서 실행되고 있습니다. 이는 진단 및 해결을 위해 Linux 부팅 프로세스 및 증명 가능한 예측 불가능한 난수 생성에 대한 많은 지식을 요구하는 모호한 보안 문제를 비교적 평범하고 인터넷 검색에서 쉽게 찾을 수 있는 런타임 예외로 전환할 기회를 만듭니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eos.urandom()\u003c/code\u003e의 크로스 플랫폼 동작 (The cross-platform behaviour of os.urandom())\u003c/h4\u003e\n\u003cp\u003eLinux 및 NetBSD를 제외한 운영체제에서 \u003ccode\u003eos.urandom()\u003c/code\u003e은 운영체제의 난수 생성기가 준비될 때까지 블록할 수 있습니다. 이는 프로세스 수명 동안 최대 한 번 발생하며, 이후의 호출은 비블록킹이 보장됩니다.\u003c/p\u003e\n\u003cp\u003eLinux 및 NetBSD는 운영체제의 난수 생성기가 보안에 민감한 작업에 사용할 준비가 되지 않은 경우에도 \u003ccode\u003e/dev/urandom\u003c/code\u003e 장치에서 읽으면 사용 가능한 엔트로피를 기반으로 무작위 값을 반환한다는 점에서 예외적입니다.\u003c/p\u003e\n\u003cp\u003e이 동작은 잠재적으로 문제가 될 수 있으므로, Linux 3.17은 새로운 \u003ccode\u003egetrandom()\u003c/code\u003e 시스템 호출을 추가하여 호출자가 난수 생성기가 준비될 때까지 블록하거나, 난수 생성기가 준비되지 않은 경우 오류 반환을 요청할 수 있도록 했습니다.\u003c/p\u003e\n\u003cp\u003ePython 3.4 이하 버전은 Linux \u003ccode\u003e/dev/urandom\u003c/code\u003e 장치에 직접 액세스합니다. Python 3.5.0 및 3.5.1은 파일 디스크립터 사용을 피하기 위해 \u003ccode\u003egetrandom()\u003c/code\u003e을 블록킹 모드로 호출했습니다. 사용자 코드에서 \u003ccode\u003eos.urandom()\u003c/code\u003e이 블록킹하는 문제에 대한 보고는 없었지만, 인터프리터 시작 시 및 \u003ccode\u003erandom\u003c/code\u003e 모듈 임포트 시 CPython이 암묵적으로 블록킹 동작을 호출하여 문제가 발생했습니다.\u003c/p\u003e\n\u003cp\u003eSipHash 초기화를 \u003ccode\u003eos.urandom()\u003c/code\u003e 구현과 분리하려는 시도 대신, Python 3.5.2는 \u003ccode\u003egetrandom()\u003c/code\u003e을 비블록킹 모드로 호출하고, 시스템 호출이 블록될 것임을 나타내면 \u003ccode\u003e/dev/urandom\u003c/code\u003e에서 읽기로 폴백하도록 전환했습니다.\u003c/p\u003e\n\u003cp\u003e결과적으로, Python 3.5 이하의 모든 Python 버전에서 \u003ccode\u003eos.urandom()\u003c/code\u003e은 \u003ccode\u003e/dev/urandom\u003c/code\u003e 장치의 동작을 Python 코드로 전파합니다.\u003c/p\u003e\n\u003ch4\u003eLinux의 \u003ccode\u003e/dev/urandom\u003c/code\u003e 동작 문제 (Problems with the behaviour of /dev/urandom on Linux)\u003c/h4\u003e\n\u003cp\u003ePython \u003ccode\u003eos\u003c/code\u003e 모듈은 Linux API와 함께 발전해 왔으므로, \u003ccode\u003eos\u003c/code\u003e 모듈 함수가 Linux에서 실행될 때 해당 Linux 운영체제 수준 카운터파트의 동작을 밀접하게 따르는 것은 일반적으로 바람직한 기능으로 간주됩니다.\u003c/p\u003e\n\u003cp\u003e그러나 \u003ccode\u003e/dev/urandom\u003c/code\u003e은 현재 동작이 문제가 있는 것으로 인정되지만, 커널 수준에서 일방적으로 수정하면 일부 Linux 배포판이 부팅되지 않는 것으로 나타난 경우입니다.\u003c/p\u003e\n\u003cp\u003e운영체제의 난수 생성기를 예측 불가능한 비밀번호를 생성하는 메서드라고 생각한다면, Linux의 \u003ccode\u003e/dev/urandom\u003c/code\u003e은 다음과 같이 구현된 것으로 생각할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# /dev/urandom을 구현하는 커널 코드의 과도하게 단순화된 예술적 개념\ndef generate_unpredictable_password():\n    if system_rng_is_ready:\n        return use_system_rng_to_generate_password()\n    else:\n        # 예측 불가능한 암호를 만들 수 없습니다. 대신 잠재적으로 예측 가능한 암호를\n        # 조용히 반환합니다.\n        return \"p4ssw0rd\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 시나리오는 일반적으로 좋지 않은 아이디어로 간주됩니다. 실제로 원하는 동작인 사용 사례는 전혀 없습니다. 이로 인해 실제 시스템에서 안전하지 않은 SSH 키가 사용되었고, 많은 *nix 계열 시스템(Mac OS X, OpenBSD, FreeBSD 포함)은 \u003ccode\u003e/dev/urandom\u003c/code\u003e 구현을 수정하여 예측 가능한 출력을 절대 반환하지 않도록 했습니다.\u003c/p\u003e\n\u003cp\u003e대신, 새로운 \u003ccode\u003egetrandom()\u003c/code\u003e 시스템 호출이 도입되어 사용자 공간 애플리케이션이 안전하게 시스템 난수 생성기에 액세스할 수 있게 되었으며, 기존 Linux 배포판의 시스템 초기화 프로세스에 디버그하기 어려운 교착 상태 문제를 도입하지 않습니다.\u003c/p\u003e\n\u003ch4\u003ePython에 \u003ccode\u003egetrandom()\u003c/code\u003e 가용성의 결과 (Consequences of getrandom() availability for Python)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003egetrandom()\u003c/code\u003e 시스템 호출이 도입되기 전에는 증명 가능한 안전한 방식으로 Linux 시스템 난수 생성기에 액세스하는 것이 단순히 불가능했으므로, 우리는 \u003ccode\u003e/dev/urandom\u003c/code\u003e에서 읽는 것을 최선의 선택으로 받아들일 수밖에 없었습니다. 그러나 \u003ccode\u003egetrandom()\u003c/code\u003e이 예측 가능한 데이터를 반환하는 대신 오류를 발생시키거나 블록하도록 요구하고 다른 이점도 있으므로, 이제 Linux에서 커널 RNG에 액세스하는 권장 방법이며, \u003ccode\u003e/dev/urandom\u003c/code\u003e에서 직접 읽는 것은 \"레거시\" 상태로 강등되었습니다.\u003c/p\u003e\n\u003cp\u003e이는 이전에 다른 사람의 문제(Linux 커널 개발팀의 문제)였던 것이 이제 Python의 문제가 되었음을 의미합니다. 시스템 RNG가 초기화되지 않았음을 감지할 수 있는 방법이 주어졌으므로, 시스템 RNG를 사용하려고 할 때마다 이 상황을 어떻게 처리할지 선택해야 합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP에서 제안한 것처럼 단순히 블록하거나 오류를 발생시킬 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e블록킹 방식 (PEP 524와 유사):\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef generate_unpredictable_bytes_or_block(num_bytes):\n    while not system_rng_is_ready:\n        wait\n    return unpredictable_bytes(num_bytes)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e오류 발생 방식 (이 PEP에서 제안):\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef generate_unpredictable_bytes_or_raise(num_bytes):\n    if system_rng_is_ready:\n        return unpredictable_bytes(num_bytes)\n    else:\n        raise BlockingIOError\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e/dev/urandom\u003c/code\u003e 폴백 방식 (Python 3.5.2rc1+):\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef generate_unpredictable_bytes_or_maybe_not(num_bytes):\n    if system_rng_is_ready:\n        return unpredictable_bytes(num_bytes)\n    else:\n        return (b\"p4ssw0rd\" * (num_bytes // 8 + 1))[:num_bytes]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCPython과 표준 라이브러리가 운영체제의 난수 생성기를 사용하려고 시도하는 다섯 가지 장소가 있으며, 이 결정이 이루어져야 하는 다섯 가지 장소가 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003estr.__hash__\u003c/code\u003e 및 관련 기능의 DoS 공격 방지를 위해 사용되는 SipHash 초기화 (시작 시 무조건 호출됨)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erandom\u003c/code\u003e 모듈 초기화 (random이 임포트될 때 호출됨)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eos.urandom\u003c/code\u003e 공개 API에 대한 사용자 호출 처리\u003c/li\u003e\n\u003cli\u003e고수준 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e 공개 API\u003c/li\u003e\n\u003cli\u003ePEP 506에 의해 추가된 새로운 \u003ccode\u003esecrets\u003c/code\u003e 모듈 공개 API\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 전체 문제는 3.5.0이 기본 코드를 \u003ccode\u003egenerate_unpredictable_bytes_or_block\u003c/code\u003e 동작으로 전환했을 때 처음 발견되었습니다. Linux 부팅 스크립트가 시스템 초기화의 일부로 Python 프로그램을 실행하려고 시도하고, Python 시작 시퀀스가 SipHash 초기화를 시도하는 동안 블록되어, 시스템이 새 엔트로피 수집을 포함한 모든 작업을 중단하는 교착 상태가 발생한 드문 경우가 있었습니다. 이는 문제가 되는 스크립트가 신뢰할 수 없는 입력을 처리하지 않았으므로, 처음부터 SipHash를 증명 가능한 예측 불가능한 무작위 데이터로 초기화할 필요가 없었다는 점에서 특히 불운했습니다. 이는 3.5.2rc1에서 모든 경우에 이전 \u003ccode\u003e/dev/urandom\u003c/code\u003e 동작을 에뮬레이트하도록 변경한 동기가 되었습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP와는 독립적으로, 처음 두 경우(\u003ccode\u003eSipHash 초기화\u003c/code\u003e 및 \u003ccode\u003erandom 모듈 초기화\u003c/code\u003e)는 \u003ccode\u003eos.urandom()\u003c/code\u003e의 동작과 관계없이 절대 블록하지 않도록 이미 업데이트되었습니다.\u003c/p\u003e\n\u003cp\u003ePEP 524가 후자의 세 가지 경우를 모두 암묵적으로 블록하도록 제안하는 반면, 이 PEP는 \u003ccode\u003esecrets\u003c/code\u003e 모듈에 대해서만 해당 접근 방식을 제안하고, \u003ccode\u003eos.urandom()\u003c/code\u003e 및 \u003ccode\u003erandom.SystemRandom()\u003c/code\u003e은 기본 운영체제 호출이 블록될 것임을 감지할 때 예외를 발생시키도록 제안했습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1885,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 522 - Allow BlockingIOError in security sensitive APIs\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:15:31+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/521/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Withdrawn] PEP 521 - Managing global context via ‘with’ blocks in generators and coroutines\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Rejected] PEP 522 - Allow BlockingIOError in security sensitive APIs\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/523/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 523 - Adding a frame evaluation API to CPython\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>