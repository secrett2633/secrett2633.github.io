<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d6cea809dcbae606.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-0395f68b8cc78a20.js" async=""></script><script src="/_next/static/chunks/23-706b53707bbf0661.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-467e37449c5a68fc.js" async=""></script><script src="/_next/static/chunks/app/layout-bb929596377d30e0.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2353<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 511 - API for code transformers</h1><div class="page__meta"><time dateTime="2025-09-26 22:56:47+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0511/">PEP 511 - API for code transformers</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 04-Jan-2016</p>
</blockquote>
<h2>PEP 511 – 코드 트랜스포머를 위한 API (API for code transformers)</h2>
<p><strong>상태:</strong> 이 PEP는 저자에 의해 <code>거부(Rejected)</code>되었습니다.</p>
<h3>거부 사유</h3>
<p>이 PEP는 일반 Python 언어와 유사하지만 호환되지 않는 새로운 Python 유사 프로그래밍 언어를 승인하는 것으로 해석되었습니다. 따라서 Python과 호환되지 않는 문법을 장려하지 않기로 결정되었습니다.</p>
<p>또한, 이 PEP는 새로운 Python 기능을 실험하기 위한 훌륭한 도구로 여겨졌지만, PEP 없이도 <code>importlib</code> 훅(hook)을 통해 이미 실험이 가능합니다. 어떤 기능이 유용하다고 판단되면, 서드 파티(third party) Python 모듈에 의존하는 대신 Python에 직접 포함되어야 한다고 보았습니다.</p>
<p>마지막으로, 이 PEP는 2016년에 중단된 FAT Python 최적화 프로젝트에 의해 추진되었습니다. 이 프로젝트는 상당한 속도 향상을 보여주지 못했을 뿐만 아니라, 가장 진보되고 복잡한 최적화를 구현할 시간 부족으로 인해 폐기되었습니다.</p>
<hr>
<h3>개요 (Abstract)</h3>
<p>이 PEP는 바이트코드(bytecode) 및 AST(Abstract Syntax Tree) 트랜스포머(transformer)를 등록하기 위한 API를 제안합니다. 또한 <code>.pyc</code> 파일 이름을 변경하는 <code>-o OPTIM_TAG</code> 명령줄 옵션과, 피플(peephole) 최적화 도구를 비활성화하는 <code>-o noopt</code> 옵션을 추가합니다. <code>.pyc</code> 파일이 없거나 코드를 변환하는 데 필요한 코드 트랜스포머가 누락된 경우, 임포트(import) 시 <code>ImportError</code> 예외를 발생시킵니다. 미리 변환된 코드( <code>.pyc</code> 파일에서 로드된 코드)를 실행하는 데는 코드 트랜스포머가 필요하지 않습니다.</p>
<h3>제안 배경 (Rationale)</h3>
<p>Python은 코드 변환을 위한 표준적인 방법을 제공하지 않습니다. 코드를 변환하는 프로젝트들은 다양한 훅을 사용합니다. 예를 들어, MacroPy 프로젝트는 <code>sys.meta_path</code>에 자체 모듈 파인더(finder)를 추가하여 AST 트랜스포머를 훅으로 연결하는 임포트 훅을 사용합니다. 또 다른 옵션은 내장 <code>compile()</code> 함수를 몽키 패치(monkey-patch)하는 것입니다. 코드 트랜스포머를 훅으로 연결하는 방법은 이 외에도 더 많이 있습니다.</p>
<p>Python 3.4에서는 <code>importlib.abc.SourceLoader</code>에 <code>compile_source()</code> 메서드가 추가되었습니다. 하지만 코드 변환은 단순히 모듈을 임포트하는 것보다 더 넓은 범위를 다루며, 아래에 설명된 사용 사례들을 참고할 수 있습니다.</p>
<p>최적화 도구 또는 전처리기(preprocessor)를 작성하는 것은 이 PEP의 범위 밖입니다.</p>
<h3>사용법 (Usage)</h3>
<h4>1. AST 최적화 도구 (AST optimizer)</h4>
<p>AST(Abstract Syntax Tree)를 변환하는 것은 최적화 도구를 구현하는 편리한 방법입니다. AST는 더 많은 정보를 포함하고 더 높은 수준(high level)이므로 바이트코드(bytecode)를 다루는 것보다 AST를 다루는 것이 더 쉽습니다.</p>
<p>최적화가 미리 수행될 수 있으므로, 복잡하지만 느린 최적화도 구현할 수 있습니다.</p>
<p>AST 최적화 도구로 구현할 수 있는 최적화 예시:</p>
<ul>
<li><strong>Copy propagation (복사 전파):</strong> <code>x=1; y=x</code>를 <code>x=1; y=1</code>로 대체.</li>
<li><strong>Constant folding (상수 폴딩):</strong> <code>1+1</code>을 <code>2</code>로 대체.</li>
<li><strong>Dead code elimination (불필요 코드 제거).</strong></li>
</ul>
<p>가드(guards, PEP 510 참고)를 사용하면 훨씬 더 다양한 최적화를 구현할 수 있습니다. 예시:</p>
<ul>
<li>반복 가능(iterable) 객체 단순화: <code>range(3)</code>가 반복 가능 객체로 사용될 때 <code>(0, 1, 2)</code>로 대체.</li>
<li>루프 언롤링(Loop unrolling).</li>
<li>순수(pure) 내장 함수 호출: <code>len("abc")</code>를 <code>3</code>으로 대체.</li>
<li>사용된 내장 심볼(symbol)을 상수로 복사.</li>
</ul>
<p>Python 3.6용 정적 최적화 도구인 <code>fatoptimizer</code>에 구현된 최적화도 참고할 수 있습니다.</p>
<p>다음과 같은 이슈들은 AST 최적화 도구로 구현될 수 있습니다:</p>
<ul>
<li>이슈 #1346238: AST를 위한 상수 폴딩 최적화 패스.</li>
<li>이슈 #2181: 함수 끝에 있는 지역 변수(local variables) 최적화.</li>
<li>이슈 #2499: 상수에서 단항 <code>+</code> 및 <code>not</code> 폴딩.</li>
<li>이슈 #4264: 패치: <code>list.append</code> 호출 대신 <code>LIST_APPEND</code>를 사용하도록 코드 최적화.</li>
<li>이슈 #7682: 상수 표현식(constant expression)을 사용한 <code>if</code> 최적화.</li>
<li>이슈 #10399: AST 최적화: 함수 호출 인라인화(inlining).</li>
<li>이슈 #11549: 피플 최적화 도구에서 일부 기능을 이동하여 AST 최적화 도구 구축.</li>
<li>이슈 #17068: 상수 문자열을 위한 피플 최적화.</li>
<li>이슈 #17430: 누락된 피플 최적화.</li>
</ul>
<h4>2. 전처리기 (Preprocessor)</h4>
<p>전처리기는 AST 트랜스포머로 쉽게 구현할 수 있습니다. 전처리기는 다양하고 다른 용도로 사용될 수 있습니다.</p>
<p>몇 가지 예시:</p>
<ul>
<li>운영 환경(production)에서 코드를 더 빠르게 실행하기 위해 어설션(assertions) 및 로그(logs)와 같은 디버그 코드를 제거.</li>
<li>꼬리 재귀 최적화(Tail-call Optimization).</li>
<li>프로파일링 코드 추가.</li>
<li>지연 평가(Lazy evaluation): <code>lazy_python</code> (바이트코드 트랜스포머) 및 MacroPy의 <code>lazy</code> 매크로(AST 트랜스포머) 참고.</li>
<li>딕셔너리 리터럴(dictionary literals)을 <code>collection.OrderedDict</code> 인스턴스로 변경.</li>
<li>상수 선언: <code>codetransformer</code>의 <code>@asconstants</code> 참고.</li>
<li>SQL 쿼리와 같은 도메인 특정 언어(DSL, Domain Specific Language). Python 언어 자체는 수정할 필요가 없습니다. PEP 335 - 오버로딩 가능한 부울 연산자(Overloadable Boolean Operators)와 같이 SQL을 위한 DSL을 구현하려는 이전 시도는 거부되었습니다.</li>
<li>함수형 언어의 패턴 매칭(Pattern Matching).</li>
<li>문자열 보간법(String Interpolation), 단 PEP 498은 Python 3.6에 병합되었습니다.</li>
</ul>
<p>MacroPy는 긴 예시 및 사용 사례 목록을 가지고 있습니다.</p>
<p>이 PEP는 새로운 코드 트랜스포머를 추가하지 않습니다. 코드 트랜스포머를 사용하려면 외부 모듈이 필요하며 수동으로 등록해야 합니다.</p>
<p>PyXfuscator: Python 난독화 도구(obfuscator), 역난독화 도구(deobfuscator) 및 사용자 지원 디컴파일러(decompiler)도 참고할 수 있습니다.</p>
<h4>3. 모든 최적화 비활성화 (Disable all optimization)</h4>
<p>Ned Batchelder는 코드 커버리지(code coverage) 구현을 더 어렵게 만들기 때문에 피플 최적화 도구를 비활성화하는 옵션을 추가해달라고 요청했습니다. <code>python-ideas</code> 메일링 리스트의 "Disable all peephole optimizations" 토론을 참고하십시오.</p>
<p>이 PEP는 피플 최적화 도구를 비활성화하는 새로운 <code>-o noopt</code> 명령줄 옵션을 추가합니다. Python에서는 다음과 같이 간단하게 처리할 수 있습니다:</p>
<pre><code class="language-python">sys.set_code_transformers([])
</code></pre>
<p>이것은 이슈 #2506: "Add mechanism to disable optimizations"를 해결할 것입니다.</p>
<h4>4. Python으로 새로운 바이트코드 최적화 도구 작성 (Write new bytecode optimizers in Python)</h4>
<p>Python 3.6은 피플 최적화 도구를 사용하여 코드를 최적화합니다. 정의상 피플 최적화 도구는 코드에 대한 시야가 좁으므로 기본적인 최적화만 구현할 수 있습니다. 이 최적화 도구는 바이트코드를 재작성합니다. C로 작성되었기 때문에 개선하기 어렵습니다.</p>
<p>이 PEP를 통해 순수 Python으로 새로운 바이트코드 최적화 도구를 구현하고 새로운 최적화를 실험하는 것이 가능해집니다.</p>
<p>상수 폴딩(constant folding)과 같은 일부 최적화는 AST에서 구현하기 더 쉽지만, 바이트코드에 대한 최적화도 여전히 유용합니다. 예를 들어, AST가 바이트코드로 컴파일될 때 컴파일러가 순진하여 아무것도 최적화하려고 하지 않기 때문에 쓸모없는 점프(jumps)가 발생할 수 있습니다.</p>
<h3>사용 사례 (Use Cases)</h3>
<p>이 섹션에서는 코드 트랜스포머가 언제 어떻게 사용될지 설명하는 사용 사례 예시를 제공합니다.</p>
<h4>인터랙티브 인터프리터 (Interactive interpreter)</h4>
<p>Python에서 인기 있고 일반적으로 Python을 시연하는 데 사용되는 인터랙티브 인터프리터와 함께 코드 트랜스포머를 사용할 수 있습니다.</p>
<p>코드는 런타임에 변환되므로 값비싼 코드 트랜스포머를 사용하는 경우 인터프리터가 느려질 수 있습니다.</p>
<h4>변환된 패키지 빌드 (Build a transformed package)</h4>
<p>변환된 코드의 패키지를 빌드할 수 있습니다.</p>
<p>트랜스포머는 구성(configuration)을 가질 수 있습니다. 이 구성은 패키지에 저장되지 않습니다.</p>
<p>패키지의 모든 <code>.pyc</code> 파일은 동일한 코드 트랜스포머와 동일한 트랜스포머 구성으로 변환되어야 합니다.</p>
<p>서로 다른 최적화 도구 태그(optimizer tags)를 사용하여 다른 <code>.pyc</code> 파일을 빌드하는 것이 가능합니다. 예를 들어, 기본 구성에는 <code>fat</code>, 함수 인라인화가 활성화된 다른 구성에는 <code>fat_inline</code>을 사용할 수 있습니다.</p>
<p>패키지에는 서로 다른 최적화 도구 태그를 가진 <code>.pyc</code> 파일이 포함될 수 있습니다.</p>
<h4>변환된 .pyc 파일을 포함하는 패키지 설치 (Install a package containing transformed .pyc files)</h4>
<p>변환된 <code>.pyc</code> 파일을 포함하는 패키지를 설치할 수 있습니다.</p>
<p>패키지에 포함된 모든 최적화 도구 태그를 가진 <code>.pyc</code> 파일이 설치되며, 현재 최적화 도구 태그에 대한 것만 설치되는 것이 아닙니다.</p>
<h4>패키지 설치 시 .pyc 파일 빌드 (Build .pyc files when installing a package)</h4>
<p>패키지에 현재 최적화 도구 태그의 <code>.pyc</code> 파일이 없거나 일부 <code>.pyc</code> 파일이 누락된 경우, 설치 중에 <code>.pyc</code> 파일이 생성됩니다.</p>
<p>최적화 도구 태그의 코드 트랜스포머가 필요합니다. 그렇지 않으면 설치가 오류와 함께 실패합니다.</p>
<h4>변환된 코드 실행 (Execute transformed code)</h4>
<p>변환된 코드를 실행할 수 있습니다.</p>
<p>현재 최적화 도구 태그의 <code>.pyc</code> 파일이 없거나 코드를 변환하는 데 필요한 코드 트랜스포머가 누락된 경우, 임포트 시 <code>ImportError</code> 예외를 발생시킵니다.</p>
<p>여기서 흥미로운 점은 필요한 모든 <code>.pyc</code> 파일이 이미 사용 가능하면 변환된 코드를 실행하는 데 코드 트랜스포머가 필요 없다는 것입니다.</p>
<h3>코드 트랜스포머 API (Code transformer API)</h3>
<p>코드 트랜스포머는 <code>ast_transformer()</code> 및/또는 <code>code_transformer()</code> 메서드(아래 설명된 API)와 <code>name</code> 속성을 가진 클래스입니다.</p>
<p>효율성을 위해 아무것도 하지 않는다면 <code>code_transformer()</code> 또는 <code>ast_transformer()</code> 메서드를 정의하지 마십시오.</p>
<p><code>name</code> 속성(<code>str</code>)은 최적화 도구를 식별하는 데 사용되는 짧은 문자열이어야 합니다. 이는 <code>.pyc</code> 파일 이름을 빌드하는 데 사용됩니다. <code>name</code>은 점(<code>.</code>), 대시(<code>-</code>) 또는 디렉토리 구분자(directory separators)를 포함해서는 안 됩니다. 점은 <code>.pyc</code> 파일 이름에서 필드를 구분하는 데 사용되고 대시는 코드 트랜스포머 이름을 결합하여 최적화 도구 태그를 빌드하는 데 사용됩니다.</p>
<h4><code>code_transformer()</code> 메서드</h4>
<p>프로토타입:</p>
<pre><code class="language-python">def code_transformer(self, code, context):
    ...
    new_code = ...
    ...
    return new_code
</code></pre>
<p>매개변수:</p>
<ul>
<li><code>code</code>: 코드 객체(code object).</li>
<li><code>context</code>: <code>optimize</code> 속성(<code>int</code>)을 가진 객체로, 최적화 수준(0, 1 또는 2)을 나타냅니다. <code>optimize</code> 속성의 값은 <code>compile()</code> 함수의 <code>optimize</code> 매개변수에서 오며, 기본적으로 <code>sys.flags.optimize</code>와 같습니다.</li>
</ul>
<p>Python의 각 구현은 <code>context</code>에 추가 속성을 추가할 수 있습니다. 예를 들어, CPython에서 <code>context</code>는 다음 속성도 가집니다:</p>
<ul>
<li><code>interactive</code> (<code>bool</code>): 인터랙티브 모드(interactive mode)인 경우 <code>True</code>.</li>
</ul>
<p>이 메서드는 코드 객체를 반환해야 합니다.</p>
<p>코드 트랜스포머는 바이트코드로 컴파일된 후에 실행됩니다.</p>
<h4><code>ast_transformer()</code> 메서드</h4>
<p>프로토타입:</p>
<pre><code class="language-python">def ast_transformer(self, tree, context):
    ...
    return tree
</code></pre>
<p>매개변수:</p>
<ul>
<li><code>tree</code>: AST 트리.</li>
<li><code>context</code>: <code>filename</code> 속성(<code>str</code>)을 가진 객체.</li>
</ul>
<p>이 메서드는 AST 트리를 반환해야 합니다. AST 트리를 그 자리에서 수정하거나 새 AST 트리를 생성할 수 있습니다.</p>
<p>AST 트랜스포머는 파서(parser)에 의해 AST가 생성된 후 바이트코드로 컴파일되기 전에 호출됩니다. 향후 <code>context</code>에 새 속성이 추가될 수 있습니다.</p>
<h3>변경 사항 (Changes)</h3>
<p>요약하자면, 다음을 추가합니다:</p>
<ul>
<li><code>-o OPTIM_TAG</code> 명령줄 옵션.</li>
<li><code>sys.implementation.optim_tag</code>.</li>
<li><code>sys.get_code_transformers()</code>.</li>
<li><code>sys.set_code_transformers(transformers)</code>.</li>
<li><code>ast.PyCF_TRANSFORMED_AST</code>.</li>
</ul>
<h4>코드 트랜스포머를 가져오고 설정하는 API (API to get/set code transformers)</h4>
<p>코드 트랜스포머를 등록하는 새로운 함수를 추가합니다:</p>
<ul>
<li><code>sys.set_code_transformers(transformers)</code>: 코드 트랜스포머 목록을 설정하고 <code>sys.implementation.optim_tag</code>를 업데이트합니다.</li>
<li><code>sys.get_code_transformers()</code>: 코드 트랜스포머 목록을 가져옵니다.</li>
</ul>
<p>코드 트랜스포머의 순서는 중요합니다. 트랜스포머 A를 실행한 다음 트랜스포머 B를 실행하는 것은 트랜스포머 B를 실행한 다음 트랜스포머 A를 실행하는 것과 다른 결과를 줄 수 있습니다.</p>
<p>새로운 코드 트랜스포머를 앞에 추가하는 예시:</p>
<pre><code class="language-python">transformers = sys.get_code_transformers()
transformers.insert(0, new_cool_transformer)
sys.set_code_transformers(transformers)
</code></pre>
<p>모든 AST 트랜스포머는 순차적으로 실행된 다음(예: 두 번째 트랜스포머는 첫 번째 트랜스포머의 입력을 받습니다), 모든 바이트코드 트랜스포머가 순차적으로 실행됩니다.</p>
<h4>최적화 도구 태그 (Optimizer tag)</h4>
<p>변경 사항:</p>
<ul>
<li><code>sys.implementation.optim_tag</code> (<code>str</code>): 최적화 태그를 추가합니다. 기본 최적화 태그는 <code>'opt'</code>입니다.</li>
<li><code>sys.implementation.optim_tag</code>를 설정하는 새로운 <code>-o OPTIM_TAG</code> 명령줄 옵션을 추가합니다.</li>
</ul>
<p><code>importlib</code>에 대한 변경 사항:</p>
<ul>
<li><code>importlib</code>는 항상 <code>'opt'</code>를 사용하는 대신 <code>sys.implementation.optim_tag</code>를 사용하여 모듈 임포트 시 <code>.pyc</code> 파일 이름을 빌드합니다.</li>
<li>코드 단순화를 위해 기본 최적화 태그 <code>'opt'</code>와 최적화 수준 0에 대한 특별한 경우를 제거합니다.</li>
<li>모듈 로드 시 <code>.pyc</code> 파일이 없지만 <code>.py</code> 파일이 사용 가능하면, 코드 최적화 도구가 현재 태그와 동일한 최적화 도구 태그를 가지고 있는 경우에만 <code>.py</code>가 사용되며, 그렇지 않으면 <code>ImportError</code> 예외가 발생합니다.</li>
</ul>
<p>모듈을 임포트하기 위해 <code>.py</code> 파일을 컴파일할 수 있는지 결정하는 <code>use_py()</code> 함수의 의사 코드(Pseudo-code):</p>
<pre><code class="language-python">def transformers_tag():
    transformers = sys.get_code_transformers()
    if not transformers:
        return 'noopt'
    return '-'.join(transformer.name for transformer in transformers)

def use_py():
    return (transformers_tag() == sys.implementation.optim_tag)
</code></pre>
<p><code>sys.get_code_transformers()</code>의 순서는 중요합니다. 예를 들어, <code>fat</code> 트랜스포머 다음에 <code>pythran</code> 트랜스포머가 오면 최적화 도구 태그는 <code>fat-pythran</code>이 됩니다.</p>
<p><code>importlib</code> 모듈의 동작은 기본 최적화 도구 태그(<code>'opt'</code>)에서는 변경되지 않습니다.</p>
<h4>피플 최적화 도구 (Peephole optimizer)</h4>
<p>기본적으로 <code>sys.implementation.optim_tag</code>는 <code>opt</code>이고 <code>sys.get_code_transformers()</code>는 피플 최적화 도구(바이트코드 최적화)라는 하나의 코드 트랜스포머 목록을 반환합니다.</p>
<p>피플 최적화 도구를 비활성화하려면 <code>-o noopt</code>를 사용합니다. 이 경우 최적화 도구 태그는 <code>noopt</code>이고 등록된 코드 트랜스포머는 없습니다.</p>
<p><code>-o opt</code> 옵션은 아무런 효과가 없습니다.</p>
<h4>AST 개선 사항 (AST enhancements)</h4>
<p>AST 트랜스포머 구현을 단순화하기 위한 개선 사항:</p>
<ul>
<li>변환된 AST를 얻기 위한 새로운 컴파일러 플래그 <code>PyCF_TRANSFORMED_AST</code>를 추가합니다.</li>
<li><code>PyCF_ONLY_AST</code>는 트랜스포머 이전의 AST를 반환합니다.</li>
</ul>
<h3>예시 (Examples)</h3>
<h4>.pyc 파일 이름</h4>
<p><code>os</code> 모듈의 <code>.pyc</code> 파일 이름 예시.</p>
<p>기본 최적화 도구 태그 <code>'opt'</code> 사용:</p>
<p>| .pyc 파일 이름              | 최적화 수준 |
| :-------------------------- | :---------- |
| <code>os.cpython-36.opt-0.pyc</code>   | 0           |
| <code>os.cpython-36.opt-1.pyc</code>   | 1           |
| <code>os.cpython-36.opt-2.pyc</code>   | 2           |</p>
<p><code>'fat'</code> 최적화 도구 태그 사용:</p>
<p>| .pyc 파일 이름              | 최적화 수준 |
| :-------------------------- | :---------- |
| <code>os.cpython-36.fat-0.pyc</code>   | 0           |
| <code>os.cpython-36.fat-1.pyc</code>   | 1           |
| <code>os.cpython-36.fat-2.pyc</code>   | 2           |</p>
<h4>바이트코드 트랜스포머 (Bytecode transformer)</h4>
<p>모든 문자열을 "Ni! Ni! Ni!"로 바꾸는 바이트코드 트랜스포머 예시:</p>
<pre><code class="language-python">import sys
import types

class BytecodeTransformer:
    name = "knights_who_say_ni"
    def code_transformer(self, code, context):
        consts = ['Ni! Ni! Ni!' if isinstance(const, str) else const for const in code.co_consts]
        return types.CodeType(code.co_argcount, code.co_kwonlyargcount,
                              code.co_nlocals, code.co_stacksize, code.co_flags,
                              code.co_code, tuple(consts), code.co_names,
                              code.co_varnames, code.co_filename, code.co_name,
                              code.co_firstlineno, code.co_lnotab,
                              code.co_freevars, code.co_cellvars)

# 기존 코드 트랜스포머를 새 바이트코드 트랜스포머로 교체
sys.set_code_transformers([BytecodeTransformer()])
# code_transformer()에 의해 변환될 코드 실행
exec("print('Hello World!')")
</code></pre>
<p>출력:</p>
<pre><code>Ni! Ni! Ni!
</code></pre>
<h4>AST 트랜스포머 (AST transformer)</h4>
<p>바이트코드 트랜스포머 예시와 유사하게, AST 트랜스포머도 모든 문자열을 "Ni! Ni! Ni!"로 바꿉니다:</p>
<pre><code class="language-python">import ast
import sys

class KnightsWhoSayNi(ast.NodeTransformer):
    def visit_Str(self, node):
        node.s = 'Ni! Ni! Ni!'
        return node

class ASTTransformer:
    name = "knights_who_say_ni"
    def __init__(self):
        self.transformer = KnightsWhoSayNi()
    def ast_transformer(self, tree, context):
        self.transformer.visit(tree)
        return tree

# 기존 코드 트랜스포머를 새 AST 트랜스포머로 교체
sys.set_code_transformers([ASTTransformer()])
# ast_transformer()에 의해 변환될 코드 실행
exec("print('Hello World!')")
</code></pre>
<p>출력:</p>
<pre><code>Ni! Ni! Ni!
</code></pre>
<h3>다른 Python 구현 (Other Python implementations)</h3>
<p>PEP 511은 모든 Python 구현에서 구현되어야 하지만, 바이트코드와 AST는 표준화되어 있지 않습니다.</p>
<p>심지어 CPython의 마이너 버전(minor version) 사이에서도 AST API에 변경 사항이 있습니다. 차이점은 있지만 사소한 차이점뿐입니다. 예를 들어 Python 2.7과 Python 3.5에서 작동하는 AST 트랜스포머를 작성하는 것은 꽤 쉽습니다.</p>
<h3>논의 (Discussion)</h3>
<ul>
<li>[Python-ideas] PEP 511: API for code transformers (2016년 1월)</li>
<li>[Python-Dev] AST optimizer implemented in Python (2012년 8월)</li>
</ul>
<h3>이전 작업 (Prior Art)</h3>
<h4>AST 최적화 도구 (AST optimizers)</h4>
<p>이슈 #17515 "Add sys.setasthook() to allow to use a custom AST"는 코드 트랜스포머를 위한 API의 첫 번째 시도였지만, AST에만 특화되어 있었습니다.</p>
<p>2015년에 Victor Stinner는 가드(guards)를 사용하여 함수를 특수화하는 AST 최적화 도구인 <code>fatoptimizer</code> 프로젝트를 작성했습니다.</p>
<p>2014년에 Kevin Conway는 PyCC 최적화 도구를 만들었습니다.</p>
<p>2012년에 Victor Stinner는 다양한 최적화를 구현하는 AST 최적화 도구인 <code>astoptimizer</code> 프로젝트를 작성했습니다. 가장 흥미로운 최적화는 변경 사항이 발생할 경우 최적화를 비활성화하는 가드가 사용되지 않으므로 Python 의미론(semantics)을 깨뜨립니다.</p>
<p>2011년에 Eugene Toder는 새로운 AST 최적화 도구에서 일부 피플 최적화를 재작성할 것을 제안했습니다: 이슈 #11549, "Build-out an AST optimizer, moving some functionality out of the peephole optimizer". 이 패치는 <code>ast.Lit</code>를 추가합니다(나중에 <code>ast.Literal</code>로 이름을 변경할 것을 제안).</p>
<h4>Python 전처리기 (Python Preprocessors)</h4>
<ul>
<li><strong>MacroPy</strong> : MacroPy는 Python 프로그래밍 언어에서 구문 매크로(Syntactic Macros)를 구현한 것입니다. MacroPy는 사용자 정의 함수(매크로)가 임포트 시 Python 프로그램의 AST에 변환을 수행할 수 있는 메커니즘을 제공합니다.</li>
<li><strong>pypreprocessor</strong> : <code>#define</code> 및 <code>#ifdef</code>와 같은 C 스타일 전처리기 지시문(directives)을 Python에서 제공합니다.</li>
</ul>
<h4>바이트코드 트랜스포머 (Bytecode transformers)</h4>
<ul>
<li><strong>codetransformer</strong> : <code>ast</code> 모듈의 <code>NodeTransformer</code>에서 영감을 받은 CPython용 바이트코드 트랜스포머입니다.</li>
<li><strong>byteplay</strong> : Byteplay는 Python 코드 객체를 다루기 쉬운 동등한 객체로 변환하고, 이 객체를 다시 실행 가능한 Python 코드 객체로 변환할 수 있습니다. Python 함수에 복잡한 변환을 적용하는 데 유용하며, Python 바이트코드의 복잡성을 배우는 데도 유용합니다. byteplay 문서를 참고하십시오.</li>
</ul>
<p>다음도 참고하십시오:</p>
<ul>
<li>BytecodeAssembler</li>
</ul>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인(public domain)에 있습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/510/">[Rejected] PEP 510 - Specialize functions with guards</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Rejected] PEP 511 - API for code transformers</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/512/">[Final] PEP 512 - Migrating from hg.python.org to GitHub</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d6cea809dcbae606.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-bb929596377d30e0.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/511\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d6cea809dcbae606.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"aIY0iLmQmvh4xdeXIovMZ\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/511/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/511\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"511\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/511\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"default\"]\ne:T6443,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0511/\"\u003ePEP 511 - API for code transformers\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 04-Jan-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 511 – 코드 트랜스포머를 위한 API (API for code transformers)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 이 PEP는 저자에 의해 \u003ccode\u003e거부(Rejected)\u003c/code\u003e되었습니다.\u003c/p\u003e\n\u003ch3\u003e거부 사유\u003c/h3\u003e\n\u003cp\u003e이 PEP는 일반 Python 언어와 유사하지만 호환되지 않는 새로운 Python 유사 프로그래밍 언어를 승인하는 것으로 해석되었습니다. 따라서 Python과 호환되지 않는 문법을 장려하지 않기로 결정되었습니다.\u003c/p\u003e\n\u003cp\u003e또한, 이 PEP는 새로운 Python 기능을 실험하기 위한 훌륭한 도구로 여겨졌지만, PEP 없이도 \u003ccode\u003eimportlib\u003c/code\u003e 훅(hook)을 통해 이미 실험이 가능합니다. 어떤 기능이 유용하다고 판단되면, 서드 파티(third party) Python 모듈에 의존하는 대신 Python에 직접 포함되어야 한다고 보았습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 이 PEP는 2016년에 중단된 FAT Python 최적화 프로젝트에 의해 추진되었습니다. 이 프로젝트는 상당한 속도 향상을 보여주지 못했을 뿐만 아니라, 가장 진보되고 복잡한 최적화를 구현할 시간 부족으로 인해 폐기되었습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 바이트코드(bytecode) 및 AST(Abstract Syntax Tree) 트랜스포머(transformer)를 등록하기 위한 API를 제안합니다. 또한 \u003ccode\u003e.pyc\u003c/code\u003e 파일 이름을 변경하는 \u003ccode\u003e-o OPTIM_TAG\u003c/code\u003e 명령줄 옵션과, 피플(peephole) 최적화 도구를 비활성화하는 \u003ccode\u003e-o noopt\u003c/code\u003e 옵션을 추가합니다. \u003ccode\u003e.pyc\u003c/code\u003e 파일이 없거나 코드를 변환하는 데 필요한 코드 트랜스포머가 누락된 경우, 임포트(import) 시 \u003ccode\u003eImportError\u003c/code\u003e 예외를 발생시킵니다. 미리 변환된 코드( \u003ccode\u003e.pyc\u003c/code\u003e 파일에서 로드된 코드)를 실행하는 데는 코드 트랜스포머가 필요하지 않습니다.\u003c/p\u003e\n\u003ch3\u003e제안 배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003ePython은 코드 변환을 위한 표준적인 방법을 제공하지 않습니다. 코드를 변환하는 프로젝트들은 다양한 훅을 사용합니다. 예를 들어, MacroPy 프로젝트는 \u003ccode\u003esys.meta_path\u003c/code\u003e에 자체 모듈 파인더(finder)를 추가하여 AST 트랜스포머를 훅으로 연결하는 임포트 훅을 사용합니다. 또 다른 옵션은 내장 \u003ccode\u003ecompile()\u003c/code\u003e 함수를 몽키 패치(monkey-patch)하는 것입니다. 코드 트랜스포머를 훅으로 연결하는 방법은 이 외에도 더 많이 있습니다.\u003c/p\u003e\n\u003cp\u003ePython 3.4에서는 \u003ccode\u003eimportlib.abc.SourceLoader\u003c/code\u003e에 \u003ccode\u003ecompile_source()\u003c/code\u003e 메서드가 추가되었습니다. 하지만 코드 변환은 단순히 모듈을 임포트하는 것보다 더 넓은 범위를 다루며, 아래에 설명된 사용 사례들을 참고할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e최적화 도구 또는 전처리기(preprocessor)를 작성하는 것은 이 PEP의 범위 밖입니다.\u003c/p\u003e\n\u003ch3\u003e사용법 (Usage)\u003c/h3\u003e\n\u003ch4\u003e1. AST 최적화 도구 (AST optimizer)\u003c/h4\u003e\n\u003cp\u003eAST(Abstract Syntax Tree)를 변환하는 것은 최적화 도구를 구현하는 편리한 방법입니다. AST는 더 많은 정보를 포함하고 더 높은 수준(high level)이므로 바이트코드(bytecode)를 다루는 것보다 AST를 다루는 것이 더 쉽습니다.\u003c/p\u003e\n\u003cp\u003e최적화가 미리 수행될 수 있으므로, 복잡하지만 느린 최적화도 구현할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eAST 최적화 도구로 구현할 수 있는 최적화 예시:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCopy propagation (복사 전파):\u003c/strong\u003e \u003ccode\u003ex=1; y=x\u003c/code\u003e를 \u003ccode\u003ex=1; y=1\u003c/code\u003e로 대체.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eConstant folding (상수 폴딩):\u003c/strong\u003e \u003ccode\u003e1+1\u003c/code\u003e을 \u003ccode\u003e2\u003c/code\u003e로 대체.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDead code elimination (불필요 코드 제거).\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e가드(guards, PEP 510 참고)를 사용하면 훨씬 더 다양한 최적화를 구현할 수 있습니다. 예시:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e반복 가능(iterable) 객체 단순화: \u003ccode\u003erange(3)\u003c/code\u003e가 반복 가능 객체로 사용될 때 \u003ccode\u003e(0, 1, 2)\u003c/code\u003e로 대체.\u003c/li\u003e\n\u003cli\u003e루프 언롤링(Loop unrolling).\u003c/li\u003e\n\u003cli\u003e순수(pure) 내장 함수 호출: \u003ccode\u003elen(\"abc\")\u003c/code\u003e를 \u003ccode\u003e3\u003c/code\u003e으로 대체.\u003c/li\u003e\n\u003cli\u003e사용된 내장 심볼(symbol)을 상수로 복사.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePython 3.6용 정적 최적화 도구인 \u003ccode\u003efatoptimizer\u003c/code\u003e에 구현된 최적화도 참고할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음과 같은 이슈들은 AST 최적화 도구로 구현될 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이슈 #1346238: AST를 위한 상수 폴딩 최적화 패스.\u003c/li\u003e\n\u003cli\u003e이슈 #2181: 함수 끝에 있는 지역 변수(local variables) 최적화.\u003c/li\u003e\n\u003cli\u003e이슈 #2499: 상수에서 단항 \u003ccode\u003e+\u003c/code\u003e 및 \u003ccode\u003enot\u003c/code\u003e 폴딩.\u003c/li\u003e\n\u003cli\u003e이슈 #4264: 패치: \u003ccode\u003elist.append\u003c/code\u003e 호출 대신 \u003ccode\u003eLIST_APPEND\u003c/code\u003e를 사용하도록 코드 최적화.\u003c/li\u003e\n\u003cli\u003e이슈 #7682: 상수 표현식(constant expression)을 사용한 \u003ccode\u003eif\u003c/code\u003e 최적화.\u003c/li\u003e\n\u003cli\u003e이슈 #10399: AST 최적화: 함수 호출 인라인화(inlining).\u003c/li\u003e\n\u003cli\u003e이슈 #11549: 피플 최적화 도구에서 일부 기능을 이동하여 AST 최적화 도구 구축.\u003c/li\u003e\n\u003cli\u003e이슈 #17068: 상수 문자열을 위한 피플 최적화.\u003c/li\u003e\n\u003cli\u003e이슈 #17430: 누락된 피플 최적화.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e2. 전처리기 (Preprocessor)\u003c/h4\u003e\n\u003cp\u003e전처리기는 AST 트랜스포머로 쉽게 구현할 수 있습니다. 전처리기는 다양하고 다른 용도로 사용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e몇 가지 예시:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e운영 환경(production)에서 코드를 더 빠르게 실행하기 위해 어설션(assertions) 및 로그(logs)와 같은 디버그 코드를 제거.\u003c/li\u003e\n\u003cli\u003e꼬리 재귀 최적화(Tail-call Optimization).\u003c/li\u003e\n\u003cli\u003e프로파일링 코드 추가.\u003c/li\u003e\n\u003cli\u003e지연 평가(Lazy evaluation): \u003ccode\u003elazy_python\u003c/code\u003e (바이트코드 트랜스포머) 및 MacroPy의 \u003ccode\u003elazy\u003c/code\u003e 매크로(AST 트랜스포머) 참고.\u003c/li\u003e\n\u003cli\u003e딕셔너리 리터럴(dictionary literals)을 \u003ccode\u003ecollection.OrderedDict\u003c/code\u003e 인스턴스로 변경.\u003c/li\u003e\n\u003cli\u003e상수 선언: \u003ccode\u003ecodetransformer\u003c/code\u003e의 \u003ccode\u003e@asconstants\u003c/code\u003e 참고.\u003c/li\u003e\n\u003cli\u003eSQL 쿼리와 같은 도메인 특정 언어(DSL, Domain Specific Language). Python 언어 자체는 수정할 필요가 없습니다. PEP 335 - 오버로딩 가능한 부울 연산자(Overloadable Boolean Operators)와 같이 SQL을 위한 DSL을 구현하려는 이전 시도는 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e함수형 언어의 패턴 매칭(Pattern Matching).\u003c/li\u003e\n\u003cli\u003e문자열 보간법(String Interpolation), 단 PEP 498은 Python 3.6에 병합되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMacroPy는 긴 예시 및 사용 사례 목록을 가지고 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 새로운 코드 트랜스포머를 추가하지 않습니다. 코드 트랜스포머를 사용하려면 외부 모듈이 필요하며 수동으로 등록해야 합니다.\u003c/p\u003e\n\u003cp\u003ePyXfuscator: Python 난독화 도구(obfuscator), 역난독화 도구(deobfuscator) 및 사용자 지원 디컴파일러(decompiler)도 참고할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e3. 모든 최적화 비활성화 (Disable all optimization)\u003c/h4\u003e\n\u003cp\u003eNed Batchelder는 코드 커버리지(code coverage) 구현을 더 어렵게 만들기 때문에 피플 최적화 도구를 비활성화하는 옵션을 추가해달라고 요청했습니다. \u003ccode\u003epython-ideas\u003c/code\u003e 메일링 리스트의 \"Disable all peephole optimizations\" 토론을 참고하십시오.\u003c/p\u003e\n\u003cp\u003e이 PEP는 피플 최적화 도구를 비활성화하는 새로운 \u003ccode\u003e-o noopt\u003c/code\u003e 명령줄 옵션을 추가합니다. Python에서는 다음과 같이 간단하게 처리할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esys.set_code_transformers([])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 이슈 #2506: \"Add mechanism to disable optimizations\"를 해결할 것입니다.\u003c/p\u003e\n\u003ch4\u003e4. Python으로 새로운 바이트코드 최적화 도구 작성 (Write new bytecode optimizers in Python)\u003c/h4\u003e\n\u003cp\u003ePython 3.6은 피플 최적화 도구를 사용하여 코드를 최적화합니다. 정의상 피플 최적화 도구는 코드에 대한 시야가 좁으므로 기본적인 최적화만 구현할 수 있습니다. 이 최적화 도구는 바이트코드를 재작성합니다. C로 작성되었기 때문에 개선하기 어렵습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP를 통해 순수 Python으로 새로운 바이트코드 최적화 도구를 구현하고 새로운 최적화를 실험하는 것이 가능해집니다.\u003c/p\u003e\n\u003cp\u003e상수 폴딩(constant folding)과 같은 일부 최적화는 AST에서 구현하기 더 쉽지만, 바이트코드에 대한 최적화도 여전히 유용합니다. 예를 들어, AST가 바이트코드로 컴파일될 때 컴파일러가 순진하여 아무것도 최적화하려고 하지 않기 때문에 쓸모없는 점프(jumps)가 발생할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e사용 사례 (Use Cases)\u003c/h3\u003e\n\u003cp\u003e이 섹션에서는 코드 트랜스포머가 언제 어떻게 사용될지 설명하는 사용 사례 예시를 제공합니다.\u003c/p\u003e\n\u003ch4\u003e인터랙티브 인터프리터 (Interactive interpreter)\u003c/h4\u003e\n\u003cp\u003ePython에서 인기 있고 일반적으로 Python을 시연하는 데 사용되는 인터랙티브 인터프리터와 함께 코드 트랜스포머를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e코드는 런타임에 변환되므로 값비싼 코드 트랜스포머를 사용하는 경우 인터프리터가 느려질 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e변환된 패키지 빌드 (Build a transformed package)\u003c/h4\u003e\n\u003cp\u003e변환된 코드의 패키지를 빌드할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e트랜스포머는 구성(configuration)을 가질 수 있습니다. 이 구성은 패키지에 저장되지 않습니다.\u003c/p\u003e\n\u003cp\u003e패키지의 모든 \u003ccode\u003e.pyc\u003c/code\u003e 파일은 동일한 코드 트랜스포머와 동일한 트랜스포머 구성으로 변환되어야 합니다.\u003c/p\u003e\n\u003cp\u003e서로 다른 최적화 도구 태그(optimizer tags)를 사용하여 다른 \u003ccode\u003e.pyc\u003c/code\u003e 파일을 빌드하는 것이 가능합니다. 예를 들어, 기본 구성에는 \u003ccode\u003efat\u003c/code\u003e, 함수 인라인화가 활성화된 다른 구성에는 \u003ccode\u003efat_inline\u003c/code\u003e을 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e패키지에는 서로 다른 최적화 도구 태그를 가진 \u003ccode\u003e.pyc\u003c/code\u003e 파일이 포함될 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e변환된 .pyc 파일을 포함하는 패키지 설치 (Install a package containing transformed .pyc files)\u003c/h4\u003e\n\u003cp\u003e변환된 \u003ccode\u003e.pyc\u003c/code\u003e 파일을 포함하는 패키지를 설치할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e패키지에 포함된 모든 최적화 도구 태그를 가진 \u003ccode\u003e.pyc\u003c/code\u003e 파일이 설치되며, 현재 최적화 도구 태그에 대한 것만 설치되는 것이 아닙니다.\u003c/p\u003e\n\u003ch4\u003e패키지 설치 시 .pyc 파일 빌드 (Build .pyc files when installing a package)\u003c/h4\u003e\n\u003cp\u003e패키지에 현재 최적화 도구 태그의 \u003ccode\u003e.pyc\u003c/code\u003e 파일이 없거나 일부 \u003ccode\u003e.pyc\u003c/code\u003e 파일이 누락된 경우, 설치 중에 \u003ccode\u003e.pyc\u003c/code\u003e 파일이 생성됩니다.\u003c/p\u003e\n\u003cp\u003e최적화 도구 태그의 코드 트랜스포머가 필요합니다. 그렇지 않으면 설치가 오류와 함께 실패합니다.\u003c/p\u003e\n\u003ch4\u003e변환된 코드 실행 (Execute transformed code)\u003c/h4\u003e\n\u003cp\u003e변환된 코드를 실행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e현재 최적화 도구 태그의 \u003ccode\u003e.pyc\u003c/code\u003e 파일이 없거나 코드를 변환하는 데 필요한 코드 트랜스포머가 누락된 경우, 임포트 시 \u003ccode\u003eImportError\u003c/code\u003e 예외를 발생시킵니다.\u003c/p\u003e\n\u003cp\u003e여기서 흥미로운 점은 필요한 모든 \u003ccode\u003e.pyc\u003c/code\u003e 파일이 이미 사용 가능하면 변환된 코드를 실행하는 데 코드 트랜스포머가 필요 없다는 것입니다.\u003c/p\u003e\n\u003ch3\u003e코드 트랜스포머 API (Code transformer API)\u003c/h3\u003e\n\u003cp\u003e코드 트랜스포머는 \u003ccode\u003east_transformer()\u003c/code\u003e 및/또는 \u003ccode\u003ecode_transformer()\u003c/code\u003e 메서드(아래 설명된 API)와 \u003ccode\u003ename\u003c/code\u003e 속성을 가진 클래스입니다.\u003c/p\u003e\n\u003cp\u003e효율성을 위해 아무것도 하지 않는다면 \u003ccode\u003ecode_transformer()\u003c/code\u003e 또는 \u003ccode\u003east_transformer()\u003c/code\u003e 메서드를 정의하지 마십시오.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ename\u003c/code\u003e 속성(\u003ccode\u003estr\u003c/code\u003e)은 최적화 도구를 식별하는 데 사용되는 짧은 문자열이어야 합니다. 이는 \u003ccode\u003e.pyc\u003c/code\u003e 파일 이름을 빌드하는 데 사용됩니다. \u003ccode\u003ename\u003c/code\u003e은 점(\u003ccode\u003e.\u003c/code\u003e), 대시(\u003ccode\u003e-\u003c/code\u003e) 또는 디렉토리 구분자(directory separators)를 포함해서는 안 됩니다. 점은 \u003ccode\u003e.pyc\u003c/code\u003e 파일 이름에서 필드를 구분하는 데 사용되고 대시는 코드 트랜스포머 이름을 결합하여 최적화 도구 태그를 빌드하는 데 사용됩니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003ecode_transformer()\u003c/code\u003e 메서드\u003c/h4\u003e\n\u003cp\u003e프로토타입:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef code_transformer(self, code, context):\n    ...\n    new_code = ...\n    ...\n    return new_code\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e매개변수:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecode\u003c/code\u003e: 코드 객체(code object).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtext\u003c/code\u003e: \u003ccode\u003eoptimize\u003c/code\u003e 속성(\u003ccode\u003eint\u003c/code\u003e)을 가진 객체로, 최적화 수준(0, 1 또는 2)을 나타냅니다. \u003ccode\u003eoptimize\u003c/code\u003e 속성의 값은 \u003ccode\u003ecompile()\u003c/code\u003e 함수의 \u003ccode\u003eoptimize\u003c/code\u003e 매개변수에서 오며, 기본적으로 \u003ccode\u003esys.flags.optimize\u003c/code\u003e와 같습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePython의 각 구현은 \u003ccode\u003econtext\u003c/code\u003e에 추가 속성을 추가할 수 있습니다. 예를 들어, CPython에서 \u003ccode\u003econtext\u003c/code\u003e는 다음 속성도 가집니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einteractive\u003c/code\u003e (\u003ccode\u003ebool\u003c/code\u003e): 인터랙티브 모드(interactive mode)인 경우 \u003ccode\u003eTrue\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 메서드는 코드 객체를 반환해야 합니다.\u003c/p\u003e\n\u003cp\u003e코드 트랜스포머는 바이트코드로 컴파일된 후에 실행됩니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003east_transformer()\u003c/code\u003e 메서드\u003c/h4\u003e\n\u003cp\u003e프로토타입:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef ast_transformer(self, tree, context):\n    ...\n    return tree\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e매개변수:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etree\u003c/code\u003e: AST 트리.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtext\u003c/code\u003e: \u003ccode\u003efilename\u003c/code\u003e 속성(\u003ccode\u003estr\u003c/code\u003e)을 가진 객체.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 메서드는 AST 트리를 반환해야 합니다. AST 트리를 그 자리에서 수정하거나 새 AST 트리를 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eAST 트랜스포머는 파서(parser)에 의해 AST가 생성된 후 바이트코드로 컴파일되기 전에 호출됩니다. 향후 \u003ccode\u003econtext\u003c/code\u003e에 새 속성이 추가될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e변경 사항 (Changes)\u003c/h3\u003e\n\u003cp\u003e요약하자면, 다음을 추가합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-o OPTIM_TAG\u003c/code\u003e 명령줄 옵션.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.implementation.optim_tag\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.get_code_transformers()\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.set_code_transformers(transformers)\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003east.PyCF_TRANSFORMED_AST\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e코드 트랜스포머를 가져오고 설정하는 API (API to get/set code transformers)\u003c/h4\u003e\n\u003cp\u003e코드 트랜스포머를 등록하는 새로운 함수를 추가합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esys.set_code_transformers(transformers)\u003c/code\u003e: 코드 트랜스포머 목록을 설정하고 \u003ccode\u003esys.implementation.optim_tag\u003c/code\u003e를 업데이트합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.get_code_transformers()\u003c/code\u003e: 코드 트랜스포머 목록을 가져옵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e코드 트랜스포머의 순서는 중요합니다. 트랜스포머 A를 실행한 다음 트랜스포머 B를 실행하는 것은 트랜스포머 B를 실행한 다음 트랜스포머 A를 실행하는 것과 다른 결과를 줄 수 있습니다.\u003c/p\u003e\n\u003cp\u003e새로운 코드 트랜스포머를 앞에 추가하는 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etransformers = sys.get_code_transformers()\ntransformers.insert(0, new_cool_transformer)\nsys.set_code_transformers(transformers)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 AST 트랜스포머는 순차적으로 실행된 다음(예: 두 번째 트랜스포머는 첫 번째 트랜스포머의 입력을 받습니다), 모든 바이트코드 트랜스포머가 순차적으로 실행됩니다.\u003c/p\u003e\n\u003ch4\u003e최적화 도구 태그 (Optimizer tag)\u003c/h4\u003e\n\u003cp\u003e변경 사항:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esys.implementation.optim_tag\u003c/code\u003e (\u003ccode\u003estr\u003c/code\u003e): 최적화 태그를 추가합니다. 기본 최적화 태그는 \u003ccode\u003e'opt'\u003c/code\u003e입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esys.implementation.optim_tag\u003c/code\u003e를 설정하는 새로운 \u003ccode\u003e-o OPTIM_TAG\u003c/code\u003e 명령줄 옵션을 추가합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eimportlib\u003c/code\u003e에 대한 변경 사항:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eimportlib\u003c/code\u003e는 항상 \u003ccode\u003e'opt'\u003c/code\u003e를 사용하는 대신 \u003ccode\u003esys.implementation.optim_tag\u003c/code\u003e를 사용하여 모듈 임포트 시 \u003ccode\u003e.pyc\u003c/code\u003e 파일 이름을 빌드합니다.\u003c/li\u003e\n\u003cli\u003e코드 단순화를 위해 기본 최적화 태그 \u003ccode\u003e'opt'\u003c/code\u003e와 최적화 수준 0에 대한 특별한 경우를 제거합니다.\u003c/li\u003e\n\u003cli\u003e모듈 로드 시 \u003ccode\u003e.pyc\u003c/code\u003e 파일이 없지만 \u003ccode\u003e.py\u003c/code\u003e 파일이 사용 가능하면, 코드 최적화 도구가 현재 태그와 동일한 최적화 도구 태그를 가지고 있는 경우에만 \u003ccode\u003e.py\u003c/code\u003e가 사용되며, 그렇지 않으면 \u003ccode\u003eImportError\u003c/code\u003e 예외가 발생합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e모듈을 임포트하기 위해 \u003ccode\u003e.py\u003c/code\u003e 파일을 컴파일할 수 있는지 결정하는 \u003ccode\u003euse_py()\u003c/code\u003e 함수의 의사 코드(Pseudo-code):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef transformers_tag():\n    transformers = sys.get_code_transformers()\n    if not transformers:\n        return 'noopt'\n    return '-'.join(transformer.name for transformer in transformers)\n\ndef use_py():\n    return (transformers_tag() == sys.implementation.optim_tag)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esys.get_code_transformers()\u003c/code\u003e의 순서는 중요합니다. 예를 들어, \u003ccode\u003efat\u003c/code\u003e 트랜스포머 다음에 \u003ccode\u003epythran\u003c/code\u003e 트랜스포머가 오면 최적화 도구 태그는 \u003ccode\u003efat-pythran\u003c/code\u003e이 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimportlib\u003c/code\u003e 모듈의 동작은 기본 최적화 도구 태그(\u003ccode\u003e'opt'\u003c/code\u003e)에서는 변경되지 않습니다.\u003c/p\u003e\n\u003ch4\u003e피플 최적화 도구 (Peephole optimizer)\u003c/h4\u003e\n\u003cp\u003e기본적으로 \u003ccode\u003esys.implementation.optim_tag\u003c/code\u003e는 \u003ccode\u003eopt\u003c/code\u003e이고 \u003ccode\u003esys.get_code_transformers()\u003c/code\u003e는 피플 최적화 도구(바이트코드 최적화)라는 하나의 코드 트랜스포머 목록을 반환합니다.\u003c/p\u003e\n\u003cp\u003e피플 최적화 도구를 비활성화하려면 \u003ccode\u003e-o noopt\u003c/code\u003e를 사용합니다. 이 경우 최적화 도구 태그는 \u003ccode\u003enoopt\u003c/code\u003e이고 등록된 코드 트랜스포머는 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e-o opt\u003c/code\u003e 옵션은 아무런 효과가 없습니다.\u003c/p\u003e\n\u003ch4\u003eAST 개선 사항 (AST enhancements)\u003c/h4\u003e\n\u003cp\u003eAST 트랜스포머 구현을 단순화하기 위한 개선 사항:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e변환된 AST를 얻기 위한 새로운 컴파일러 플래그 \u003ccode\u003ePyCF_TRANSFORMED_AST\u003c/code\u003e를 추가합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyCF_ONLY_AST\u003c/code\u003e는 트랜스포머 이전의 AST를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e예시 (Examples)\u003c/h3\u003e\n\u003ch4\u003e.pyc 파일 이름\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eos\u003c/code\u003e 모듈의 \u003ccode\u003e.pyc\u003c/code\u003e 파일 이름 예시.\u003c/p\u003e\n\u003cp\u003e기본 최적화 도구 태그 \u003ccode\u003e'opt'\u003c/code\u003e 사용:\u003c/p\u003e\n\u003cp\u003e| .pyc 파일 이름              | 최적화 수준 |\n| :-------------------------- | :---------- |\n| \u003ccode\u003eos.cpython-36.opt-0.pyc\u003c/code\u003e   | 0           |\n| \u003ccode\u003eos.cpython-36.opt-1.pyc\u003c/code\u003e   | 1           |\n| \u003ccode\u003eos.cpython-36.opt-2.pyc\u003c/code\u003e   | 2           |\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e'fat'\u003c/code\u003e 최적화 도구 태그 사용:\u003c/p\u003e\n\u003cp\u003e| .pyc 파일 이름              | 최적화 수준 |\n| :-------------------------- | :---------- |\n| \u003ccode\u003eos.cpython-36.fat-0.pyc\u003c/code\u003e   | 0           |\n| \u003ccode\u003eos.cpython-36.fat-1.pyc\u003c/code\u003e   | 1           |\n| \u003ccode\u003eos.cpython-36.fat-2.pyc\u003c/code\u003e   | 2           |\u003c/p\u003e\n\u003ch4\u003e바이트코드 트랜스포머 (Bytecode transformer)\u003c/h4\u003e\n\u003cp\u003e모든 문자열을 \"Ni! Ni! Ni!\"로 바꾸는 바이트코드 트랜스포머 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport sys\nimport types\n\nclass BytecodeTransformer:\n    name = \"knights_who_say_ni\"\n    def code_transformer(self, code, context):\n        consts = ['Ni! Ni! Ni!' if isinstance(const, str) else const for const in code.co_consts]\n        return types.CodeType(code.co_argcount, code.co_kwonlyargcount,\n                              code.co_nlocals, code.co_stacksize, code.co_flags,\n                              code.co_code, tuple(consts), code.co_names,\n                              code.co_varnames, code.co_filename, code.co_name,\n                              code.co_firstlineno, code.co_lnotab,\n                              code.co_freevars, code.co_cellvars)\n\n# 기존 코드 트랜스포머를 새 바이트코드 트랜스포머로 교체\nsys.set_code_transformers([BytecodeTransformer()])\n# code_transformer()에 의해 변환될 코드 실행\nexec(\"print('Hello World!')\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e출력:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eNi! Ni! Ni!\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eAST 트랜스포머 (AST transformer)\u003c/h4\u003e\n\u003cp\u003e바이트코드 트랜스포머 예시와 유사하게, AST 트랜스포머도 모든 문자열을 \"Ni! Ni! Ni!\"로 바꿉니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport ast\nimport sys\n\nclass KnightsWhoSayNi(ast.NodeTransformer):\n    def visit_Str(self, node):\n        node.s = 'Ni! Ni! Ni!'\n        return node\n\nclass ASTTransformer:\n    name = \"knights_who_say_ni\"\n    def __init__(self):\n        self.transformer = KnightsWhoSayNi()\n    def ast_transformer(self, tree, context):\n        self.transformer.visit(tree)\n        return tree\n\n# 기존 코드 트랜스포머를 새 AST 트랜스포머로 교체\nsys.set_code_transformers([ASTTransformer()])\n# ast_transformer()에 의해 변환될 코드 실행\nexec(\"print('Hello World!')\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e출력:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eNi! Ni! Ni!\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e다른 Python 구현 (Other Python implementations)\u003c/h3\u003e\n\u003cp\u003ePEP 511은 모든 Python 구현에서 구현되어야 하지만, 바이트코드와 AST는 표준화되어 있지 않습니다.\u003c/p\u003e\n\u003cp\u003e심지어 CPython의 마이너 버전(minor version) 사이에서도 AST API에 변경 사항이 있습니다. 차이점은 있지만 사소한 차이점뿐입니다. 예를 들어 Python 2.7과 Python 3.5에서 작동하는 AST 트랜스포머를 작성하는 것은 꽤 쉽습니다.\u003c/p\u003e\n\u003ch3\u003e논의 (Discussion)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e[Python-ideas] PEP 511: API for code transformers (2016년 1월)\u003c/li\u003e\n\u003cli\u003e[Python-Dev] AST optimizer implemented in Python (2012년 8월)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e이전 작업 (Prior Art)\u003c/h3\u003e\n\u003ch4\u003eAST 최적화 도구 (AST optimizers)\u003c/h4\u003e\n\u003cp\u003e이슈 #17515 \"Add sys.setasthook() to allow to use a custom AST\"는 코드 트랜스포머를 위한 API의 첫 번째 시도였지만, AST에만 특화되어 있었습니다.\u003c/p\u003e\n\u003cp\u003e2015년에 Victor Stinner는 가드(guards)를 사용하여 함수를 특수화하는 AST 최적화 도구인 \u003ccode\u003efatoptimizer\u003c/code\u003e 프로젝트를 작성했습니다.\u003c/p\u003e\n\u003cp\u003e2014년에 Kevin Conway는 PyCC 최적화 도구를 만들었습니다.\u003c/p\u003e\n\u003cp\u003e2012년에 Victor Stinner는 다양한 최적화를 구현하는 AST 최적화 도구인 \u003ccode\u003eastoptimizer\u003c/code\u003e 프로젝트를 작성했습니다. 가장 흥미로운 최적화는 변경 사항이 발생할 경우 최적화를 비활성화하는 가드가 사용되지 않으므로 Python 의미론(semantics)을 깨뜨립니다.\u003c/p\u003e\n\u003cp\u003e2011년에 Eugene Toder는 새로운 AST 최적화 도구에서 일부 피플 최적화를 재작성할 것을 제안했습니다: 이슈 #11549, \"Build-out an AST optimizer, moving some functionality out of the peephole optimizer\". 이 패치는 \u003ccode\u003east.Lit\u003c/code\u003e를 추가합니다(나중에 \u003ccode\u003east.Literal\u003c/code\u003e로 이름을 변경할 것을 제안).\u003c/p\u003e\n\u003ch4\u003ePython 전처리기 (Python Preprocessors)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMacroPy\u003c/strong\u003e : MacroPy는 Python 프로그래밍 언어에서 구문 매크로(Syntactic Macros)를 구현한 것입니다. MacroPy는 사용자 정의 함수(매크로)가 임포트 시 Python 프로그램의 AST에 변환을 수행할 수 있는 메커니즘을 제공합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epypreprocessor\u003c/strong\u003e : \u003ccode\u003e#define\u003c/code\u003e 및 \u003ccode\u003e#ifdef\u003c/code\u003e와 같은 C 스타일 전처리기 지시문(directives)을 Python에서 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e바이트코드 트랜스포머 (Bytecode transformers)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ecodetransformer\u003c/strong\u003e : \u003ccode\u003east\u003c/code\u003e 모듈의 \u003ccode\u003eNodeTransformer\u003c/code\u003e에서 영감을 받은 CPython용 바이트코드 트랜스포머입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ebyteplay\u003c/strong\u003e : Byteplay는 Python 코드 객체를 다루기 쉬운 동등한 객체로 변환하고, 이 객체를 다시 실행 가능한 Python 코드 객체로 변환할 수 있습니다. Python 함수에 복잡한 변환을 적용하는 데 유용하며, Python 바이트코드의 복잡성을 배우는 데도 유용합니다. byteplay 문서를 참고하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음도 참고하십시오:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBytecodeAssembler\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 있습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2353,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 511 - API for code transformers\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:56:47+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/511/\",\"postId\":\"2025-09-26-pep-0511-api-for-code-transformers\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/510/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 510 - Specialize functions with guards\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Rejected] PEP 511 - API for code transformers\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/512/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 512 - Migrating from hg.python.org to GitHub\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>