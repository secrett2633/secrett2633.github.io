<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/edf391eeca43d999.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-aea36c7c8fc4866f.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1682<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Draft] PEP 793 - PyModExport: A new entry point for C extension modules</h1><div class="page__meta"><time dateTime="2025-09-27 14:07:12+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0793/">PEP 793 - PyModExport: A new entry point for C extension modules</a></p>
<p><strong>상태:</strong> Draft | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 23-May-2025</p>
</blockquote>
<h2>PEP 793: PyModExport - C 확장 모듈을 위한 새로운 진입점</h2>
<ul>
<li><strong>작성자:</strong> Petr Viktorin</li>
<li><strong>상태:</strong> Draft (초안)</li>
<li><strong>생성일:</strong> 2025년 5월 23일</li>
<li><strong>Python 버전:</strong> 3.15</li>
</ul>
<h3>개요 (Abstract)</h3>
<p>PEP 793은 C 확장 모듈을 위한 새로운 진입점(entry point)을 제안합니다. 이 진입점을 통해 개발자들은 <code>PyModuleDef</code> 구조체 없이 <code>PyModuleDef_Slot</code> 구조체 배열을 사용하여 모듈을 정의할 수 있습니다. 이는 확장 모듈 개발자들이 정적으로 할당된 <code>PyObject</code>를 사용하지 않도록 하여, 단일 컴파일된 라이브러리 파일이 일반(regular) 빌드와 자유 스레딩(free-threaded) 빌드 CPython 모두에서 사용 가능하도록 하는 가장 큰 장애물을 제거합니다.</p>
<p>이 제안은 <code>PyModuleDef</code>의 필드를 대체할 새로운 모듈 슬롯 타입을 명시하고, <code>Py_tp_token</code>과 유사한 토큰을 추가할 수 있도록 합니다. 또한 슬롯을 사용하여 모듈을 동적으로 정의하는 API도 추가합니다. 기존 <code>PyInit_*</code> API는 소프트 비권장(soft-deprecated)됩니다. 즉, 경고 없이 계속 작동하고 문서화 및 지원되지만, 새 기능은 추가되지 않을 예정입니다.</p>
<h3>배경 및 동기 (Background &#x26; Motivation)</h3>
<p><strong>문제점:</strong>
Python 객체의 메모리 레이아웃은 일반 빌드와 자유 스레딩 빌드 간에 다릅니다. 따라서 두 가지 빌드 모두를 지원하는 ABI(Application Binary Interface)는 현재의 <code>PyObject</code> 메모리 레이아웃을 포함할 수 없습니다. 기존 ABI와의 호환성을 유지하기 위해 정적으로 할당된 Python 객체를 지원할 수 없습니다.</p>
<p>대부분의 확장 모듈에 필요하며 거의 모든 경우에 정적으로 할당되는 객체는 모듈 내보내기 훅(<code>PyInit_*</code> 함수)에서 반환되는 <code>PyModuleDef</code>입니다.</p>
<p><strong>인터프리터 전환 (The interpreter switch):</strong>
Python 3.12에서는 모듈이 서브 인터프리터(sub-interpreter)에 로드될 수 있는지 표시하는 <code>Py_mod_multiple_interpreters</code> 슬롯이 추가되었습니다. 이 슬롯을 "지원하지 않음(not supported)" 값으로 설정하면 확장이 메인 인터프리터에서만 로드될 수 있음을 나타냅니다.</p>
<p>문제는 Python이 모듈 내보내기 훅을 호출해야만 이 정보를 얻을 수 있다는 점입니다. 싱글 페이즈(single-phase) 모듈의 경우, 이는 모듈 객체를 생성하고 임의의 초기화 코드를 실행합니다. <code>Py_mod_multiple_interpreters</code>를 "지원하지 않음"으로 설정한 모듈의 경우, 이 초기화는 메인 인터프리터에서 이루어져야 합니다.</p>
<p>이를 위해, 새로운 모듈이 서브 인터프리터에 로드되면 Python은 임시적으로 메인 인터프리터로 전환하고, 그곳에서 내보내기 훅을 호출한 다음, 다시 원래 인터프리터로 전환하거나 가져오기를 실패하게 합니다. 이러한 불필요하고 취약한 추가 작업은 근본적인 설계 문제를 보여줍니다. 즉, Python은 확장 모듈이 잠재적으로 완전히 자신을 초기화하기 전에 해당 확장에 대한 정보를 얻을 방법이 없습니다.</p>
<h3>제안의 근거 (Rationale)</h3>
<p>정적으로 할당된 <code>PyObject*</code>를 요구하는 모듈 내보내기 훅을 피하기 위해 두 가지 옵션이 고려되었습니다.</p>
<ol>
<li><strong>동적으로 할당된 객체 반환:</strong> 인터프리터로 소유권이 이전되는 동적으로 할당된 객체를 반환합니다. 이 구조체는 기존 <code>PyModuleDef</code>와 매우 유사할 수 있지만, 참조 카운트(reference-counted)되어야 합니다.</li>
<li><strong>새로운 내보내기 훅 추가:</strong> <code>PyObject*</code>를 반환하지 않는 새로운 내보내기 훅을 추가합니다.</li>
</ol>
<p>PEP 489에서 Python 3.5를 위해 두 번째 옵션이 고려되었으나, <code>PyInit</code> 훅 이름을 유지하는 것이 더 간단한 해결책으로 판단되어 기각되었습니다. 그러나 10년이 지난 지금, 그 선택의 함의를 수정하는 작업은 더 이상 간단하지 않습니다.</p>
<p>새로운 훅은 Python이 "인터프리터 전환" 문제를 피할 수 있도록 합니다. 효과적으로 이는 다중 페이즈 초기화(multi-phase initialization)에 새로운 단계를 추가하여 Python이 모듈의 호환성을 미리 확인할 수 있게 합니다.</p>
<p><strong>래퍼 구조체 없는 슬롯 사용 (Using slots without a wrapper struct):</strong>
기존 <code>PyModuleDef</code>는 고정 필드와 "slots" 배열을 가진 구조체입니다. 슬롯과 달리 고정 필드는 개별적으로 비권장하거나 교체할 수 없습니다. 이 제안은 고정 필드를 제거하고 래퍼 구조체 없이 슬롯 배열을 직접 사용하는 것을 제안합니다.</p>
<p><strong>토큰 (Tokens):</strong>
정적 <code>PyModuleDef</code>는 모듈 생성 방법을 설명하는 것 외에 또 다른 목적을 가집니다. 모듈 객체에 연결된 정적으로 할당된 싱글톤으로서, 확장 개발자가 주어진 Python 모듈이 "자신의 것"인지 확인할 수 있게 합니다. 즉, 모듈 객체가 알려진 <code>PyModuleDef</code>를 가지면 해당 모듈 상태는 알려진 메모리 레이아웃을 가집니다.</p>
<p>유형(type)의 경우 유사한 문제가 <code>Py_tp_token</code>을 추가함으로써 해결되었습니다. 이 제안은 모듈에도 동일한 메커니즘을 추가합니다.</p>
<p><strong>기존 내보내기 훅의 소프트 비권장 (Soft-deprecating the existing export hook):</strong>
기존 확장의 개발자가 여기에 제안된 API로 전환할 유일한 이유는 단일 모듈이 자유 스레딩 및 비자유 스레딩 빌드 모두에서 작동하도록 허용하기 때문입니다. Python이 이를 허용하는 것이 중요하지만, 많은 기존 모듈의 경우 Python 3.14 이하 버전과의 호환성을 잃을 가치가 없습니다.</p>
<p>따라서, 이 PEP는 <code>PyInit_*</code> 방식에 새로운 기능을 추가하는 것을 중단할 것을 제안합니다. 결국, 확장 개발자가 전환하기에 가장 좋은 시점은 어차피 모듈 초기화를 수정하려는 때입니다.</p>
<h3>명세 (Specification)</h3>
<p><strong>새로운 내보내기 훅:</strong>
확장 모듈을 가져올 때, Python은 이제 다음과 같은 내보내기 훅을 먼저 찾습니다.</p>
<pre><code class="language-c">PyModuleDef_Slot *PyModExport_&#x3C;NAME>(PyObject *spec);
</code></pre>
<p><code>&#x3C;NAME></code>은 모듈의 이름입니다. 비 ASCII 이름의 경우, <code>PyModExportU_&#x3C;NAME></code>을 찾으며, <code>&#x3C;NAME></code>은 기존 <code>PyInitU_*</code> 훅과 같이 인코딩됩니다.</p>
<p>만약 찾지 못하면, 이전 Python 버전과 동일하게 (<code>PyInit_*</code> 또는 <code>PyInitU_*</code> 함수를 찾아) 가져오기가 계속됩니다.</p>
<p>훅을 찾으면, Python은 적절한 <code>importlib.machinery.ModuleSpec</code> 객체를 <code>spec</code>으로 사용하여 훅을 호출합니다. 훅은 성공 시 <code>PyModuleDef_Slot</code> 구조체 배열에 대한 포인터를 반환해야 하며, 실패 시 <code>NULL</code>을 반환하고 예외를 설정해야 합니다.</p>
<p><strong>동적 생성 (Dynamic creation):</strong>
슬롯 배열에서 모듈을 생성하는 새로운 함수가 추가됩니다:</p>
<pre><code class="language-c">PyObject *PyModule_FromSlotsAndSpec(PyModuleDef_Slot *slots, PyObject *spec)
</code></pre>
<p><code>slots</code> 인수는 <code>PyModuleDef_Slot</code> 구조체 배열을 가리켜야 하며, <code>{0}</code>으로 끝나는 슬롯으로 종료되어야 합니다.</p>
<p>모듈의 <code>exec</code> 슬롯(들)을 실행하는 새로운 함수 <code>PyModule_Exec</code>도 추가됩니다.</p>
<pre><code class="language-c">int PyModule_Exec(PyObject *module)
</code></pre>
<p>이 함수는 모듈을 완전히 초기화하는 데 필요하며, <code>PyModule_FromSlotsAndSpec</code>는 이를 실행하지 않습니다.</p>
<p><strong>토큰 (Tokens):</strong>
모듈 객체는 선택적으로 "토큰"을 저장합니다. 이는 유형(type)의 <code>Py_tp_token</code>과 유사한 <code>void*</code> 포인터입니다.</p>
<p>새로운 <code>Py_mod_token</code> 슬롯을 사용하여 지정된 경우, 모듈 토큰은 모듈보다 오래 존재해야 하며 해당 확장 모듈에 "속해야" 합니다. <code>PyModule_GetToken</code> 함수가 추가되어 토큰을 얻을 수 있습니다.</p>
<p><strong>새로운 슬롯 (New slots):</strong>
<code>PyModuleDef_HEAD_INIT</code>를 제외한 <code>PyModuleDef</code> 구조체의 각 필드에 대해 새로운 슬롯 ID가 제공됩니다. 예를 들어, <code>Py_mod_name</code>, <code>Py_mod_doc</code>, <code>Py_mod_clear</code> 등이 있습니다. 모듈 객체보다는 모듈 상태와 관련된 슬롯은 <code>Py_mod_state_</code> 접두사를 사용합니다.</p>
<p><strong>기존 내보내기 훅의 소프트 비권장 (Soft-deprecating the existing export hook):</strong>
<code>PyInit_*</code> 내보내기 훅은 소프트 비권장됩니다.</p>
<p><strong>새로운 API 요약 (New API summary):</strong>
새로운 모듈 내보내기 훅: <code>PyModExport_&#x3C;NAME></code> 및 <code>PyModExportU_&#x3C;ENCODED_NAME></code>
새로운 함수:</p>
<ul>
<li><code>PyObject *PyModule_FromSlotsAndSpec(PyModuleDef_Slot *, PyObject *spec)</code></li>
<li><code>int PyModule_Exec(PyObject *)</code></li>
<li><code>int PyModule_GetToken(PyObject *, void**)</code></li>
<li><code>PyObject *PyType_GetModuleByToken(PyTypeObject *type, void *token)</code></li>
<li><code>int PyModule_GetStateSize(PyObject *, Py_ssize_t *result)</code></li>
</ul>
<p>새로운 매크로: <code>PyMODEXPORT_FUNC</code></p>
<p>새로운 슬롯 타입: <code>Py_mod_name</code>, <code>Py_mod_doc</code>, <code>Py_mod_state_size</code>, <code>Py_mod_methods</code>, <code>Py_mod_state_traverse</code>, <code>Py_mod_state_clear</code>, <code>Py_mod_state_free</code>, <code>Py_mod_token</code></p>
<p>이 모든 것은 Limited API에 추가될 예정입니다.</p>
<h3>하위 호환성 (Backwards Compatibility)</h3>
<p>기존 모듈이 새 메커니즘을 사용하도록 포팅되면 <code>PyModule_GetDef</code>는 해당 모듈에 대해 <code>NULL</code>을 반환하기 시작합니다. 이는 모듈이 정의된 방식이 해당 모듈의 구현 세부 사항이므로 호환성을 깨는 변경으로 간주되어서는 안 됩니다.</p>
<p><code>PyType_GetModuleByDef</code> 함수는 이제 <code>def</code> 인수로 모듈 토큰을 허용합니다.</p>
<h3>포팅 가이드 (Porting Guide)</h3>
<p>기존 모듈을 새 API로 변환하기 위한 가이드입니다.</p>
<ol>
<li><strong><code>PyModule_GetDef</code> 사용 검토:</strong> 이 함수는 새 메커니즘을 사용하는 모듈에 대해 <code>NULL</code>을 반환합니다. 대신 <code>PyModule_GetNameObject</code>나 <code>__doc__</code> 속성, <code>PyModule_GetStateSize</code> 등을 사용하여 모듈의 속성을 얻거나, 모듈 객체가 "자신의 것"인지 테스트하려면 <code>PyModule_GetToken</code>을 사용합니다.</li>
<li><strong><code>PyType_GetModuleByDef</code> 사용 검토:</strong> 이를 <code>PyType_GetModuleByToken</code>으로 대체하는 것을 고려합니다. (하위 호환성을 위해 <code>PyType_GetModuleByDef</code>가 토큰을 허용하도록 변경됩니다.)</li>
<li><strong><code>Py_mod_create</code> 함수 검토:</strong> 이 함수의 두 번째 인수가 <code>NULL</code>로 호출될 수 있으므로 사용하지 않도록 합니다. 대신 기존 <code>PyModuleDef</code> 구조체를 직접 사용합니다.</li>
<li><strong><code>Py_mod_exec</code> 슬롯 통합:</strong> 여러 <code>Py_mod_exec</code> 슬롯이 있는 경우 하나로 통합합니다.</li>
<li><strong>새로운 <code>PyModuleDef_Slot</code> 배열 생성:</strong> 기존 <code>PyModuleDef</code>의 <code>m_slots</code> 멤버가 가리키는 <code>PyModuleDef_Slot</code> 배열을 복사하거나 새로 생성합니다.</li>
<li><strong>새로운 슬롯 추가:</strong> 기존 <code>PyModuleDef</code> 구조체의 모든 멤버에 대한 슬롯을 추가합니다. 예: <code>Py_mod_name</code>, <code>Py_mod_doc</code> 등.</li>
<li><strong><code>Py_mod_token</code> 슬롯 추가:</strong> <code>PyModule_GetToken</code> 또는 <code>PyType_GetModuleByToken</code>을 사용하는 경우, 기존 <code>PyModuleDef</code> 구조체를 가리키는 <code>Py_mod_token</code> 슬롯을 추가합니다.</li>
<li><strong>새로운 내보내기 훅 추가:</strong> <code>PyMODEXPORT_FUNC PyModExport_examplemodule(PyObject *spec)</code>와 같은 형식의 훅을 추가하여 새로 정의한 슬롯 배열을 반환합니다.</li>
<li><strong>하위 버전 지원 중단 시 <code>PyInit_</code> 함수 제거:</strong> 모듈이 더 낮은 버전의 Python을 지원하지 않게 되면 <code>PyInit_</code> 함수와 사용되지 않는 <code>PyModuleDef</code> 구조체를 제거할 수 있습니다.</li>
</ol>
<h3>보안 관련 사항 (Security Implications)</h3>
<p>알려진 보안 관련 사항은 없습니다.</p>
<h3>교육 방법 (How to Teach This)</h3>
<p>정기적인 참조 문서 외에, 포팅 가이드를 새로운 HOWTO 문서로 추가해야 합니다.</p>
<h3>예시 (Example)</h3>
<p>(PEP 문서에 포함된 C 코드 예시를 번역 대신 간략히 설명합니다.)
이 PEP는 C 수준의 모듈 전역 상태를 가지는 예시 모듈을 제공하며, 이 모듈은 일반 빌드와 자유 스레딩 빌드 모두에서 성공적으로 실행됩니다. 이 예시는 <code>Py_LIMITED_API</code>를 사용하여 CPython 버전별 ABI 종속성을 피하고, 새로운 <code>PyModExport</code> 훅과 <code>PyModuleDef_Slot</code> 배열을 사용하여 모듈을 정의합니다.</p>
<h3>가능한 향후 방향 (Possible Future Directions)</h3>
<ul>
<li><strong>슬롯 개선:</strong> <code>void *</code> 사용으로 인한 타입 안전성 문제 및 알려지지 않은 슬롯 ID에 대한 제한된 전방 호환성 문제를 해결할 수 있습니다.</li>
<li><strong>기본값 업데이트:</strong> <code>Py_mod_multiple_interpreters</code> 및 <code>Py_mod_gil</code> 슬롯의 기본값을 업데이트할 수 있습니다.</li>
<li><strong>inittab:</strong> <code>inittab</code>에서 <code>PyModuleDef</code> 없는 슬롯을 허용해야 할 수도 있습니다.</li>
</ul>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/792/">[Final] PEP 792 - Project status markers in the simple index</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Draft] PEP 793 - PyModExport: A new entry point for C extension modules</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/794/">[Accepted] PEP 794 - Import Name Metadata</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/edf391eeca43d999.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-aea36c7c8fc4866f.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/793\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/edf391eeca43d999.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"NhP1-beun3zO0F28j3_pl\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/793/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/793\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"793\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/793\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T3c78,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0793/\"\u003ePEP 793 - PyModExport: A new entry point for C extension modules\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Draft | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 23-May-2025\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 793: PyModExport - C 확장 모듈을 위한 새로운 진입점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Petr Viktorin\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Draft (초안)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2025년 5월 23일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.15\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003ePEP 793은 C 확장 모듈을 위한 새로운 진입점(entry point)을 제안합니다. 이 진입점을 통해 개발자들은 \u003ccode\u003ePyModuleDef\u003c/code\u003e 구조체 없이 \u003ccode\u003ePyModuleDef_Slot\u003c/code\u003e 구조체 배열을 사용하여 모듈을 정의할 수 있습니다. 이는 확장 모듈 개발자들이 정적으로 할당된 \u003ccode\u003ePyObject\u003c/code\u003e를 사용하지 않도록 하여, 단일 컴파일된 라이브러리 파일이 일반(regular) 빌드와 자유 스레딩(free-threaded) 빌드 CPython 모두에서 사용 가능하도록 하는 가장 큰 장애물을 제거합니다.\u003c/p\u003e\n\u003cp\u003e이 제안은 \u003ccode\u003ePyModuleDef\u003c/code\u003e의 필드를 대체할 새로운 모듈 슬롯 타입을 명시하고, \u003ccode\u003ePy_tp_token\u003c/code\u003e과 유사한 토큰을 추가할 수 있도록 합니다. 또한 슬롯을 사용하여 모듈을 동적으로 정의하는 API도 추가합니다. 기존 \u003ccode\u003ePyInit_*\u003c/code\u003e API는 소프트 비권장(soft-deprecated)됩니다. 즉, 경고 없이 계속 작동하고 문서화 및 지원되지만, 새 기능은 추가되지 않을 예정입니다.\u003c/p\u003e\n\u003ch3\u003e배경 및 동기 (Background \u0026#x26; Motivation)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e문제점:\u003c/strong\u003e\nPython 객체의 메모리 레이아웃은 일반 빌드와 자유 스레딩 빌드 간에 다릅니다. 따라서 두 가지 빌드 모두를 지원하는 ABI(Application Binary Interface)는 현재의 \u003ccode\u003ePyObject\u003c/code\u003e 메모리 레이아웃을 포함할 수 없습니다. 기존 ABI와의 호환성을 유지하기 위해 정적으로 할당된 Python 객체를 지원할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e대부분의 확장 모듈에 필요하며 거의 모든 경우에 정적으로 할당되는 객체는 모듈 내보내기 훅(\u003ccode\u003ePyInit_*\u003c/code\u003e 함수)에서 반환되는 \u003ccode\u003ePyModuleDef\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e인터프리터 전환 (The interpreter switch):\u003c/strong\u003e\nPython 3.12에서는 모듈이 서브 인터프리터(sub-interpreter)에 로드될 수 있는지 표시하는 \u003ccode\u003ePy_mod_multiple_interpreters\u003c/code\u003e 슬롯이 추가되었습니다. 이 슬롯을 \"지원하지 않음(not supported)\" 값으로 설정하면 확장이 메인 인터프리터에서만 로드될 수 있음을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e문제는 Python이 모듈 내보내기 훅을 호출해야만 이 정보를 얻을 수 있다는 점입니다. 싱글 페이즈(single-phase) 모듈의 경우, 이는 모듈 객체를 생성하고 임의의 초기화 코드를 실행합니다. \u003ccode\u003ePy_mod_multiple_interpreters\u003c/code\u003e를 \"지원하지 않음\"으로 설정한 모듈의 경우, 이 초기화는 메인 인터프리터에서 이루어져야 합니다.\u003c/p\u003e\n\u003cp\u003e이를 위해, 새로운 모듈이 서브 인터프리터에 로드되면 Python은 임시적으로 메인 인터프리터로 전환하고, 그곳에서 내보내기 훅을 호출한 다음, 다시 원래 인터프리터로 전환하거나 가져오기를 실패하게 합니다. 이러한 불필요하고 취약한 추가 작업은 근본적인 설계 문제를 보여줍니다. 즉, Python은 확장 모듈이 잠재적으로 완전히 자신을 초기화하기 전에 해당 확장에 대한 정보를 얻을 방법이 없습니다.\u003c/p\u003e\n\u003ch3\u003e제안의 근거 (Rationale)\u003c/h3\u003e\n\u003cp\u003e정적으로 할당된 \u003ccode\u003ePyObject*\u003c/code\u003e를 요구하는 모듈 내보내기 훅을 피하기 위해 두 가지 옵션이 고려되었습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e동적으로 할당된 객체 반환:\u003c/strong\u003e 인터프리터로 소유권이 이전되는 동적으로 할당된 객체를 반환합니다. 이 구조체는 기존 \u003ccode\u003ePyModuleDef\u003c/code\u003e와 매우 유사할 수 있지만, 참조 카운트(reference-counted)되어야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e새로운 내보내기 훅 추가:\u003c/strong\u003e \u003ccode\u003ePyObject*\u003c/code\u003e를 반환하지 않는 새로운 내보내기 훅을 추가합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003ePEP 489에서 Python 3.5를 위해 두 번째 옵션이 고려되었으나, \u003ccode\u003ePyInit\u003c/code\u003e 훅 이름을 유지하는 것이 더 간단한 해결책으로 판단되어 기각되었습니다. 그러나 10년이 지난 지금, 그 선택의 함의를 수정하는 작업은 더 이상 간단하지 않습니다.\u003c/p\u003e\n\u003cp\u003e새로운 훅은 Python이 \"인터프리터 전환\" 문제를 피할 수 있도록 합니다. 효과적으로 이는 다중 페이즈 초기화(multi-phase initialization)에 새로운 단계를 추가하여 Python이 모듈의 호환성을 미리 확인할 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e래퍼 구조체 없는 슬롯 사용 (Using slots without a wrapper struct):\u003c/strong\u003e\n기존 \u003ccode\u003ePyModuleDef\u003c/code\u003e는 고정 필드와 \"slots\" 배열을 가진 구조체입니다. 슬롯과 달리 고정 필드는 개별적으로 비권장하거나 교체할 수 없습니다. 이 제안은 고정 필드를 제거하고 래퍼 구조체 없이 슬롯 배열을 직접 사용하는 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e토큰 (Tokens):\u003c/strong\u003e\n정적 \u003ccode\u003ePyModuleDef\u003c/code\u003e는 모듈 생성 방법을 설명하는 것 외에 또 다른 목적을 가집니다. 모듈 객체에 연결된 정적으로 할당된 싱글톤으로서, 확장 개발자가 주어진 Python 모듈이 \"자신의 것\"인지 확인할 수 있게 합니다. 즉, 모듈 객체가 알려진 \u003ccode\u003ePyModuleDef\u003c/code\u003e를 가지면 해당 모듈 상태는 알려진 메모리 레이아웃을 가집니다.\u003c/p\u003e\n\u003cp\u003e유형(type)의 경우 유사한 문제가 \u003ccode\u003ePy_tp_token\u003c/code\u003e을 추가함으로써 해결되었습니다. 이 제안은 모듈에도 동일한 메커니즘을 추가합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e기존 내보내기 훅의 소프트 비권장 (Soft-deprecating the existing export hook):\u003c/strong\u003e\n기존 확장의 개발자가 여기에 제안된 API로 전환할 유일한 이유는 단일 모듈이 자유 스레딩 및 비자유 스레딩 빌드 모두에서 작동하도록 허용하기 때문입니다. Python이 이를 허용하는 것이 중요하지만, 많은 기존 모듈의 경우 Python 3.14 이하 버전과의 호환성을 잃을 가치가 없습니다.\u003c/p\u003e\n\u003cp\u003e따라서, 이 PEP는 \u003ccode\u003ePyInit_*\u003c/code\u003e 방식에 새로운 기능을 추가하는 것을 중단할 것을 제안합니다. 결국, 확장 개발자가 전환하기에 가장 좋은 시점은 어차피 모듈 초기화를 수정하려는 때입니다.\u003c/p\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e새로운 내보내기 훅:\u003c/strong\u003e\n확장 모듈을 가져올 때, Python은 이제 다음과 같은 내보내기 훅을 먼저 찾습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003ePyModuleDef_Slot *PyModExport_\u0026#x3C;NAME\u003e(PyObject *spec);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e\u0026#x3C;NAME\u003e\u003c/code\u003e은 모듈의 이름입니다. 비 ASCII 이름의 경우, \u003ccode\u003ePyModExportU_\u0026#x3C;NAME\u003e\u003c/code\u003e을 찾으며, \u003ccode\u003e\u0026#x3C;NAME\u003e\u003c/code\u003e은 기존 \u003ccode\u003ePyInitU_*\u003c/code\u003e 훅과 같이 인코딩됩니다.\u003c/p\u003e\n\u003cp\u003e만약 찾지 못하면, 이전 Python 버전과 동일하게 (\u003ccode\u003ePyInit_*\u003c/code\u003e 또는 \u003ccode\u003ePyInitU_*\u003c/code\u003e 함수를 찾아) 가져오기가 계속됩니다.\u003c/p\u003e\n\u003cp\u003e훅을 찾으면, Python은 적절한 \u003ccode\u003eimportlib.machinery.ModuleSpec\u003c/code\u003e 객체를 \u003ccode\u003espec\u003c/code\u003e으로 사용하여 훅을 호출합니다. 훅은 성공 시 \u003ccode\u003ePyModuleDef_Slot\u003c/code\u003e 구조체 배열에 대한 포인터를 반환해야 하며, 실패 시 \u003ccode\u003eNULL\u003c/code\u003e을 반환하고 예외를 설정해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e동적 생성 (Dynamic creation):\u003c/strong\u003e\n슬롯 배열에서 모듈을 생성하는 새로운 함수가 추가됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003ePyObject *PyModule_FromSlotsAndSpec(PyModuleDef_Slot *slots, PyObject *spec)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eslots\u003c/code\u003e 인수는 \u003ccode\u003ePyModuleDef_Slot\u003c/code\u003e 구조체 배열을 가리켜야 하며, \u003ccode\u003e{0}\u003c/code\u003e으로 끝나는 슬롯으로 종료되어야 합니다.\u003c/p\u003e\n\u003cp\u003e모듈의 \u003ccode\u003eexec\u003c/code\u003e 슬롯(들)을 실행하는 새로운 함수 \u003ccode\u003ePyModule_Exec\u003c/code\u003e도 추가됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint PyModule_Exec(PyObject *module)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 모듈을 완전히 초기화하는 데 필요하며, \u003ccode\u003ePyModule_FromSlotsAndSpec\u003c/code\u003e는 이를 실행하지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e토큰 (Tokens):\u003c/strong\u003e\n모듈 객체는 선택적으로 \"토큰\"을 저장합니다. 이는 유형(type)의 \u003ccode\u003ePy_tp_token\u003c/code\u003e과 유사한 \u003ccode\u003evoid*\u003c/code\u003e 포인터입니다.\u003c/p\u003e\n\u003cp\u003e새로운 \u003ccode\u003ePy_mod_token\u003c/code\u003e 슬롯을 사용하여 지정된 경우, 모듈 토큰은 모듈보다 오래 존재해야 하며 해당 확장 모듈에 \"속해야\" 합니다. \u003ccode\u003ePyModule_GetToken\u003c/code\u003e 함수가 추가되어 토큰을 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e새로운 슬롯 (New slots):\u003c/strong\u003e\n\u003ccode\u003ePyModuleDef_HEAD_INIT\u003c/code\u003e를 제외한 \u003ccode\u003ePyModuleDef\u003c/code\u003e 구조체의 각 필드에 대해 새로운 슬롯 ID가 제공됩니다. 예를 들어, \u003ccode\u003ePy_mod_name\u003c/code\u003e, \u003ccode\u003ePy_mod_doc\u003c/code\u003e, \u003ccode\u003ePy_mod_clear\u003c/code\u003e 등이 있습니다. 모듈 객체보다는 모듈 상태와 관련된 슬롯은 \u003ccode\u003ePy_mod_state_\u003c/code\u003e 접두사를 사용합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e기존 내보내기 훅의 소프트 비권장 (Soft-deprecating the existing export hook):\u003c/strong\u003e\n\u003ccode\u003ePyInit_*\u003c/code\u003e 내보내기 훅은 소프트 비권장됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e새로운 API 요약 (New API summary):\u003c/strong\u003e\n새로운 모듈 내보내기 훅: \u003ccode\u003ePyModExport_\u0026#x3C;NAME\u003e\u003c/code\u003e 및 \u003ccode\u003ePyModExportU_\u0026#x3C;ENCODED_NAME\u003e\u003c/code\u003e\n새로운 함수:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyObject *PyModule_FromSlotsAndSpec(PyModuleDef_Slot *, PyObject *spec)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint PyModule_Exec(PyObject *)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint PyModule_GetToken(PyObject *, void**)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject *PyType_GetModuleByToken(PyTypeObject *type, void *token)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint PyModule_GetStateSize(PyObject *, Py_ssize_t *result)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e새로운 매크로: \u003ccode\u003ePyMODEXPORT_FUNC\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e새로운 슬롯 타입: \u003ccode\u003ePy_mod_name\u003c/code\u003e, \u003ccode\u003ePy_mod_doc\u003c/code\u003e, \u003ccode\u003ePy_mod_state_size\u003c/code\u003e, \u003ccode\u003ePy_mod_methods\u003c/code\u003e, \u003ccode\u003ePy_mod_state_traverse\u003c/code\u003e, \u003ccode\u003ePy_mod_state_clear\u003c/code\u003e, \u003ccode\u003ePy_mod_state_free\u003c/code\u003e, \u003ccode\u003ePy_mod_token\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e이 모든 것은 Limited API에 추가될 예정입니다.\u003c/p\u003e\n\u003ch3\u003e하위 호환성 (Backwards Compatibility)\u003c/h3\u003e\n\u003cp\u003e기존 모듈이 새 메커니즘을 사용하도록 포팅되면 \u003ccode\u003ePyModule_GetDef\u003c/code\u003e는 해당 모듈에 대해 \u003ccode\u003eNULL\u003c/code\u003e을 반환하기 시작합니다. 이는 모듈이 정의된 방식이 해당 모듈의 구현 세부 사항이므로 호환성을 깨는 변경으로 간주되어서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyType_GetModuleByDef\u003c/code\u003e 함수는 이제 \u003ccode\u003edef\u003c/code\u003e 인수로 모듈 토큰을 허용합니다.\u003c/p\u003e\n\u003ch3\u003e포팅 가이드 (Porting Guide)\u003c/h3\u003e\n\u003cp\u003e기존 모듈을 새 API로 변환하기 위한 가이드입니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ePyModule_GetDef\u003c/code\u003e 사용 검토:\u003c/strong\u003e 이 함수는 새 메커니즘을 사용하는 모듈에 대해 \u003ccode\u003eNULL\u003c/code\u003e을 반환합니다. 대신 \u003ccode\u003ePyModule_GetNameObject\u003c/code\u003e나 \u003ccode\u003e__doc__\u003c/code\u003e 속성, \u003ccode\u003ePyModule_GetStateSize\u003c/code\u003e 등을 사용하여 모듈의 속성을 얻거나, 모듈 객체가 \"자신의 것\"인지 테스트하려면 \u003ccode\u003ePyModule_GetToken\u003c/code\u003e을 사용합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ePyType_GetModuleByDef\u003c/code\u003e 사용 검토:\u003c/strong\u003e 이를 \u003ccode\u003ePyType_GetModuleByToken\u003c/code\u003e으로 대체하는 것을 고려합니다. (하위 호환성을 위해 \u003ccode\u003ePyType_GetModuleByDef\u003c/code\u003e가 토큰을 허용하도록 변경됩니다.)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ePy_mod_create\u003c/code\u003e 함수 검토:\u003c/strong\u003e 이 함수의 두 번째 인수가 \u003ccode\u003eNULL\u003c/code\u003e로 호출될 수 있으므로 사용하지 않도록 합니다. 대신 기존 \u003ccode\u003ePyModuleDef\u003c/code\u003e 구조체를 직접 사용합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ePy_mod_exec\u003c/code\u003e 슬롯 통합:\u003c/strong\u003e 여러 \u003ccode\u003ePy_mod_exec\u003c/code\u003e 슬롯이 있는 경우 하나로 통합합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e새로운 \u003ccode\u003ePyModuleDef_Slot\u003c/code\u003e 배열 생성:\u003c/strong\u003e 기존 \u003ccode\u003ePyModuleDef\u003c/code\u003e의 \u003ccode\u003em_slots\u003c/code\u003e 멤버가 가리키는 \u003ccode\u003ePyModuleDef_Slot\u003c/code\u003e 배열을 복사하거나 새로 생성합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e새로운 슬롯 추가:\u003c/strong\u003e 기존 \u003ccode\u003ePyModuleDef\u003c/code\u003e 구조체의 모든 멤버에 대한 슬롯을 추가합니다. 예: \u003ccode\u003ePy_mod_name\u003c/code\u003e, \u003ccode\u003ePy_mod_doc\u003c/code\u003e 등.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ePy_mod_token\u003c/code\u003e 슬롯 추가:\u003c/strong\u003e \u003ccode\u003ePyModule_GetToken\u003c/code\u003e 또는 \u003ccode\u003ePyType_GetModuleByToken\u003c/code\u003e을 사용하는 경우, 기존 \u003ccode\u003ePyModuleDef\u003c/code\u003e 구조체를 가리키는 \u003ccode\u003ePy_mod_token\u003c/code\u003e 슬롯을 추가합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e새로운 내보내기 훅 추가:\u003c/strong\u003e \u003ccode\u003ePyMODEXPORT_FUNC PyModExport_examplemodule(PyObject *spec)\u003c/code\u003e와 같은 형식의 훅을 추가하여 새로 정의한 슬롯 배열을 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e하위 버전 지원 중단 시 \u003ccode\u003ePyInit_\u003c/code\u003e 함수 제거:\u003c/strong\u003e 모듈이 더 낮은 버전의 Python을 지원하지 않게 되면 \u003ccode\u003ePyInit_\u003c/code\u003e 함수와 사용되지 않는 \u003ccode\u003ePyModuleDef\u003c/code\u003e 구조체를 제거할 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e보안 관련 사항 (Security Implications)\u003c/h3\u003e\n\u003cp\u003e알려진 보안 관련 사항은 없습니다.\u003c/p\u003e\n\u003ch3\u003e교육 방법 (How to Teach This)\u003c/h3\u003e\n\u003cp\u003e정기적인 참조 문서 외에, 포팅 가이드를 새로운 HOWTO 문서로 추가해야 합니다.\u003c/p\u003e\n\u003ch3\u003e예시 (Example)\u003c/h3\u003e\n\u003cp\u003e(PEP 문서에 포함된 C 코드 예시를 번역 대신 간략히 설명합니다.)\n이 PEP는 C 수준의 모듈 전역 상태를 가지는 예시 모듈을 제공하며, 이 모듈은 일반 빌드와 자유 스레딩 빌드 모두에서 성공적으로 실행됩니다. 이 예시는 \u003ccode\u003ePy_LIMITED_API\u003c/code\u003e를 사용하여 CPython 버전별 ABI 종속성을 피하고, 새로운 \u003ccode\u003ePyModExport\u003c/code\u003e 훅과 \u003ccode\u003ePyModuleDef_Slot\u003c/code\u003e 배열을 사용하여 모듈을 정의합니다.\u003c/p\u003e\n\u003ch3\u003e가능한 향후 방향 (Possible Future Directions)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e슬롯 개선:\u003c/strong\u003e \u003ccode\u003evoid *\u003c/code\u003e 사용으로 인한 타입 안전성 문제 및 알려지지 않은 슬롯 ID에 대한 제한된 전방 호환성 문제를 해결할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e기본값 업데이트:\u003c/strong\u003e \u003ccode\u003ePy_mod_multiple_interpreters\u003c/code\u003e 및 \u003ccode\u003ePy_mod_gil\u003c/code\u003e 슬롯의 기본값을 업데이트할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003einittab:\u003c/strong\u003e \u003ccode\u003einittab\u003c/code\u003e에서 \u003ccode\u003ePyModuleDef\u003c/code\u003e 없는 슬롯을 허용해야 할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1682,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Draft] PEP 793 - PyModExport: A new entry point for C extension modules\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 14:07:12+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/792/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 792 - Project status markers in the simple index\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Draft] PEP 793 - PyModExport: A new entry point for C extension modules\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/794/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Accepted] PEP 794 - Import Name Metadata\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>