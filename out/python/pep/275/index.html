<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-89b393b6f6553dc8.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1615<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 275 - Switching on Multiple Values</h1><div class="page__meta"><time dateTime="2025-09-26 17:53:28+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0275/">PEP 275 - Switching on Multiple Values</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 10-Nov-2001</p>
</blockquote>
<h1>PEP 275 – 다중 값 스위칭 (Switching on Multiple Values)</h1>
<ul>
<li><strong>저자:</strong> Marc-André Lemburg</li>
<li><strong>상태:</strong> Rejected (거절됨)</li>
<li><strong>유형:</strong> Standards Track</li>
<li><strong>생성일:</strong> 2001년 11월 10일</li>
<li><strong>Python 버전:</strong> 2.6</li>
<li><strong>사후 이력:</strong> (생략)</li>
</ul>
<h2>거절 공지 (Rejection Notice)</h2>
<p>Python 3000을 위한 유사한 PEP인 PEP 3103이 이미 거절되었기 때문에, 이 제안 또한 받아들여질 가능성이 없습니다.</p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 단일 변수가 여러 가능한 값 중 하나를 가질 때 스위칭(switching)을 처리하는 Python의 성능을 향상하기 위한 전략을 제안합니다.</p>
<h2>문제 (Problem)</h2>
<p>Python 2.5까지, 다중 값 스위치를 작성하는 일반적인 방법은 다음과 같은 긴 <code>if-elif-else</code> 구문을 사용하는 것이었습니다.</p>
<pre><code class="language-python">if x == 'first state':
    ...
elif x == 'second state':
    ...
elif x == 'third state':
    ...
elif x == 'fourth state':
    ...
else:
    # default handling
    ...
</code></pre>
<p>이 방식은 짧은 스위치 구문에는 잘 작동합니다. 지역 변수(<code>x</code>)를 반복적으로 로드하고 상수에 비교하는 오버헤드가 낮기 때문입니다 (평균적으로 O(n)의 복잡도를 가집니다). 하지만, 파서(parser) 작성에 필요한 스테이트 머신(state machine)을 작성할 때 이러한 구문을 사용하면 가능한 상태의 수가 쉽게 10개 이상에 도달할 수 있습니다.</p>
<p>이 문제에 대한 현재의 해결책은 디스패치 테이블(dispatch table)을 사용하여 스위치 변수 값에 따라 실행할 케이스 구현 메서드를 찾는 것입니다 (이는 완전 해시 테이블(perfect hash tables) 등을 사용하여 평균적으로 O(1)의 복잡도로 조정될 수 있습니다). 이 방식은 다양한 케이스 메서드에서 복잡하고 긴 처리를 요구하는 스테이트 머신에는 잘 작동합니다. 그러나 각 케이스당 한두 개의 명령만 처리하는 경우에는 성능이 좋지 않습니다. 예를 들어:</p>
<pre><code class="language-python">def handle_data(self, data):
    self.stack.append(data)
</code></pre>
<p>이러한 경우의 좋은 예시는 Python 객체를 직렬화(serialize)하는 데 사용되는 <code>pickle.py</code>에 구현된 스테이트 머신입니다. 다른 대표적인 사례로는 XML SAX 파서 및 인터넷 프로토콜 핸들러가 있습니다.</p>
<h2>제안된 해결책 (Proposed Solutions)</h2>
<p>이 PEP는 서로 다르지만 반드시 상충하지는 않는 두 가지 해결책을 제안합니다.</p>
<ol>
<li>위에서 언급된 <code>if-elif-else</code> 구문을 감지하고 점프 오프셋(jump offsets)을 저장하기 위한 읽기 전용 딕셔너리(read-only dictionary)를 사용하는 특수 Opcode를 생성하는 Python 컴파일러 및 VM(가상 머신)에 최적화를 추가합니다.</li>
<li>C 스타일의 <code>switch</code> 문을 모방하는 새로운 구문을 Python에 추가합니다.</li>
</ol>
<p>첫 번째 해결책은 언어에 새로운 키워드를 추가하지 않는다는 장점이 있는 반면, 두 번째 해결책은 더 깔끔해 보입니다. 두 해결책 모두 스위칭 변수가 불변(immutable)이고 해시 가능(hashable)하다는 것을 보장하기 위해 일부 런타임 오버헤드를 수반합니다.</p>
<p>두 해결책 모두 올바른 점프 위치를 찾기 위해 딕셔너리 룩업(dictionary lookup)을 사용하므로, 스위치 변수와 상수가 모두 딕셔너리 구현과 호환되어야 한다는 동일한 문제 공간을 공유합니다 (해시 가능, 비교 가능, <code>a==b</code>이면 <code>hash(a)==hash(b)</code>).</p>
<h3>해결책 1: <code>if-elif-else</code> 최적화 (Optimizing <code>if-elif-else</code>)</h3>
<p><strong>구현 (Implementation):</strong>
컴파일러가 다음 시그니처를 가진 <code>if-elif-else</code> 구문을 감지할 수 있어야 합니다.</p>
<pre><code class="language-python">if x == 'first':
    ...
elif x == 'second':
    ...
else:
    ...
</code></pre>
<p>즉, 좌변은 항상 동일한 변수를 참조하고, 우변은 해시 가능한 불변(immutable) 내장 타입(built-in type)이어야 합니다. 우변들은 반드시 모두 같은 타입일 필요는 없지만, 좌변 스위치 변수의 타입과 비교 가능해야 합니다.</p>
<p>컴파일러는 그 후 읽기 전용 (완벽) 해시 테이블을 설정하고, 이를 상수에 저장한 다음, 표준 <code>if-elif-else</code> 바이트 코드 스트림 앞에 <code>SWITCH</code> Opcode를 추가할 수 있습니다. 이 Opcode는 다음 런타임 동작을 트리거합니다.</p>
<p>런타임 시 <code>SWITCH</code> Opcode는 <code>x</code>가 잘 알려진 불변 타입(문자열, 유니코드, 숫자) 중 하나인지 확인하고 해시 테이블을 사용하여 올바른 Opcode 스니펫을 찾습니다. 이 조건이 충족되지 않으면 인터프리터는 <code>SWITCH</code> Opcode를 단순히 건너뛰고 일반적인 <code>if-elif-else</code> 바이트 코드 스트림으로 진행하여 표준 <code>if-elif-else</code> 처리로 되돌아가야 합니다.</p>
<p><strong>문제점 (Issues):</strong></p>
<ul>
<li>새로운 최적화는 현재 Python의 의미론(semantics)을 변경해서는 안 됩니다 (최적화의 영향을 받는 <code>if-elif-else</code> 구문에서 <code>__cmp__</code> 호출 수를 줄이고 <code>__hash__</code> 호출을 추가함으로써). 이를 보장하기 위해, 스위칭은 "<code>from __future__</code>" 스타일 플래그가 사용되거나, 스위칭 변수가 <code>int</code>, <code>float</code>, <code>string</code>, <code>unicode</code> 등 내장 불변 타입(서브타입은 불변 여부가 불분명하므로 제외) 중 하나인 경우에만 안전하게 구현될 수 있습니다.</li>
<li>점프 테이블 딕셔너리의 사후 수정(post-modifications)을 방지하기 위해 (이는 보호된 코드에 도달하는 데 사용될 수 있음), 점프 테이블은 읽기 전용 타입(예: 읽기 전용 딕셔너리)이어야 합니다.</li>
<li>이 최적화는 최소 <code>n</code>개 이상의 케이스를 가진 <code>if-elif-else</code> 구문에만 사용되어야 합니다 (<code>n</code>은 성능 테스트에 따라 정의될 숫자).</li>
</ul>
<h3>해결책 2: Python에 <code>switch</code> 문 추가 (Adding a <code>switch</code> statement to Python)</h3>
<p><strong>새로운 구문 (New Syntax):</strong></p>
<pre><code class="language-python">switch EXPR:
    case CONSTANT: SUITE
    case CONSTANT: SUITE
    ...
    else: SUITE
</code></pre>
<p>("else" 부분은 선택 사항입니다.) <code>else</code> 부분이 주어지지 않고 정의된 케이스 중 일치하는 것이 없으면 아무런 동작도 취해지지 않고 <code>switch</code> 문은 무시됩니다. 이는 현재 <code>if</code> 문의 동작과 일치합니다. 예외를 사용하여 이 상황을 알리고 싶은 사용자는 의도된 동작을 구현하는 <code>else</code> 분기를 정의할 수 있습니다.</p>
<p>상수들은 반드시 모두 같은 타입일 필요는 없지만, 스위치 변수의 타입과 비교 가능해야 합니다.</p>
<p><strong>구현 (Implementation):</strong>
컴파일러는 이를 다음과 유사한 바이트 코드(bytecode)로 컴파일해야 합니다 (POP_TOP 및 SET_LINENO는 생략).</p>
<pre><code class="language-python">def whatis(x):
    switch(x):
        case 'one': print '1'
        case 'two': print '2'
        case 'three': print '3'
        else: print "D'oh!"
</code></pre>
<p>위 코드는 <code>SWITCH</code> Opcode가 <code>x</code>에 따라 14, 22, 30 또는 38로 점프하도록 컴파일됩니다.</p>
<p><strong>문제점 (Issues):</strong></p>
<ul>
<li><code>switch</code> 문은 (C 언어의 <code>switch</code> 문처럼) fall-through 동작을 구현해서는 안 됩니다. 각 <code>case</code>는 <code>if-elif-else</code> 문과 매우 유사하게 완전하고 독립적인 스위트(suite)를 정의합니다. 이는 루프 내의 <code>switch</code> 문에서 <code>break</code>를 사용하는 것도 가능하게 합니다.</li>
<li>인터프리터가 스위치 변수 <code>x</code>가 해시 가능하지 않다는 것을 발견하면, 런타임 시 <code>TypeError</code>를 발생시켜 문제를 지적해야 합니다.</li>
<li>기존 키워드를 재사용하고 새로운 키워드("switch" 및 "case")를 추가하는 것을 피하는 다른 구문 제안들이 있었습니다. 다른 이들은 C 키워드와 이름은 같지만 의미론(예: <code>break</code> 없는 fall-through)이 약간 다르므로 새로운 용어를 사용해야 한다고 주장했습니다. 제안된 변형 중 일부는 다음과 같습니다.
<pre><code class="language-python">case EXPR:
    of CONSTANT: SUITE
    of CONSTANT: SUITE
else: SUITE

case EXPR:
    if CONSTANT: SUITE
    if CONSTANT: SUITE
else: SUITE

when EXPR:
    in CONSTANT_TUPLE: SUITE
    in CONSTANT_TUPLE: SUITE
    ...
else: SUITE
</code></pre>
</li>
<li><code>switch</code> 문은 한 섹션에 여러 값을 허용하도록 확장될 수 있습니다 (예: <code>case 'a', 'b', 'c': ...</code>). 또 다른 제안된 확장으로는 값의 범위를 허용할 수 있습니다 (예: <code>case 10..14: ...</code>). 이러한 기능들은 아마도 나중에 고려되어야 하지만, 첫 번째 버전을 설계하고 구현할 때 염두에 두어야 합니다.</li>
</ul>
<h2>예시 (Examples)</h2>
<p>다음 예시들은 모두 해결책 2에서 제안된 새로운 구문을 사용합니다. 그러나 이 모든 예시는 해결책 1에서도 작동할 것입니다.</p>
<pre><code class="language-python"># switch EXPR:
#    case CONSTANT: SUITE
#    case CONSTANT: SUITE
#    ...
#    else: SUITE

# 예시 1: 기본 switch 문
switch x:
    case "first":
        print x
    case "second":
        x = x**2
        print x
    else:
        print "whoops!"

# 예시 2: 'of' 키워드 사용 (대체 구문 제안)
case x:
    of "first":
        print x
    of "second":
        print x**2
    else:
        print "whoops!"

# 예시 3: 'if' 키워드 사용 (대체 구문 제안)
case state:
    if "first":
        state = "second"
    if "second":
        state = "third"
    else:
        state = "first"

# 예시 4: 'when... in' 키워드 사용 (대체 구문 제안)
when state:
    in ("first", "second"):
        print state
        state = next_state(state)
    in ("seventh",):
        ...
        print "done"
    else:
        print "middle state"
        state = next_state(state)
        break # 루프를 빠져나옴!

# Jack Jansen이 찾은 또 다른 유용한 응용 (인자 타입에 따른 스위칭):
switch type(x).__name__:
    case 'int':
        SUITE
    case 'string':
        SUITE
</code></pre>
<h2>범위 (Scope)</h2>
<p><code>"from __future__ import switch"</code>에 대해 설명해야 합니다.</p>
<h2>기여자 (Credits)</h2>
<ul>
<li>Martin von Löwis (최적화 아이디어 관련 문제)</li>
<li>Thomas Wouters (switch 문 + 바이트 코드 컴파일러 예시)</li>
<li>Skip Montanaro (디스패칭 아이디어, 예시)</li>
<li>Donald Beaudry (switch 구문)</li>
<li>Greg Ewing (switch 구문)</li>
<li>Jack Jansen (타입 스위칭 예시)</li>
</ul>
<h2>참조 (References)</h2>
<p><code>https://sourceforge.net/tracker/index.php?func=detail&#x26;aid=481118&#x26;group_id=5470&#x26;atid=305470</code></p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)에 있습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-89b393b6f6553dc8.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/275\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"3S0Yhp4qrbYK7pFtngQE8\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/275/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/275\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"275\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/275\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T3049,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0275/\"\u003ePEP 275 - Switching on Multiple Values\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 10-Nov-2001\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 275 – 다중 값 스위칭 (Switching on Multiple Values)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e저자:\u003c/strong\u003e Marc-André Lemburg\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected (거절됨)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2001년 11월 10일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 2.6\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e사후 이력:\u003c/strong\u003e (생략)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e거절 공지 (Rejection Notice)\u003c/h2\u003e\n\u003cp\u003ePython 3000을 위한 유사한 PEP인 PEP 3103이 이미 거절되었기 때문에, 이 제안 또한 받아들여질 가능성이 없습니다.\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 단일 변수가 여러 가능한 값 중 하나를 가질 때 스위칭(switching)을 처리하는 Python의 성능을 향상하기 위한 전략을 제안합니다.\u003c/p\u003e\n\u003ch2\u003e문제 (Problem)\u003c/h2\u003e\n\u003cp\u003ePython 2.5까지, 다중 값 스위치를 작성하는 일반적인 방법은 다음과 같은 긴 \u003ccode\u003eif-elif-else\u003c/code\u003e 구문을 사용하는 것이었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif x == 'first state':\n    ...\nelif x == 'second state':\n    ...\nelif x == 'third state':\n    ...\nelif x == 'fourth state':\n    ...\nelse:\n    # default handling\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 방식은 짧은 스위치 구문에는 잘 작동합니다. 지역 변수(\u003ccode\u003ex\u003c/code\u003e)를 반복적으로 로드하고 상수에 비교하는 오버헤드가 낮기 때문입니다 (평균적으로 O(n)의 복잡도를 가집니다). 하지만, 파서(parser) 작성에 필요한 스테이트 머신(state machine)을 작성할 때 이러한 구문을 사용하면 가능한 상태의 수가 쉽게 10개 이상에 도달할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 문제에 대한 현재의 해결책은 디스패치 테이블(dispatch table)을 사용하여 스위치 변수 값에 따라 실행할 케이스 구현 메서드를 찾는 것입니다 (이는 완전 해시 테이블(perfect hash tables) 등을 사용하여 평균적으로 O(1)의 복잡도로 조정될 수 있습니다). 이 방식은 다양한 케이스 메서드에서 복잡하고 긴 처리를 요구하는 스테이트 머신에는 잘 작동합니다. 그러나 각 케이스당 한두 개의 명령만 처리하는 경우에는 성능이 좋지 않습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef handle_data(self, data):\n    self.stack.append(data)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 경우의 좋은 예시는 Python 객체를 직렬화(serialize)하는 데 사용되는 \u003ccode\u003epickle.py\u003c/code\u003e에 구현된 스테이트 머신입니다. 다른 대표적인 사례로는 XML SAX 파서 및 인터넷 프로토콜 핸들러가 있습니다.\u003c/p\u003e\n\u003ch2\u003e제안된 해결책 (Proposed Solutions)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 서로 다르지만 반드시 상충하지는 않는 두 가지 해결책을 제안합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e위에서 언급된 \u003ccode\u003eif-elif-else\u003c/code\u003e 구문을 감지하고 점프 오프셋(jump offsets)을 저장하기 위한 읽기 전용 딕셔너리(read-only dictionary)를 사용하는 특수 Opcode를 생성하는 Python 컴파일러 및 VM(가상 머신)에 최적화를 추가합니다.\u003c/li\u003e\n\u003cli\u003eC 스타일의 \u003ccode\u003eswitch\u003c/code\u003e 문을 모방하는 새로운 구문을 Python에 추가합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e첫 번째 해결책은 언어에 새로운 키워드를 추가하지 않는다는 장점이 있는 반면, 두 번째 해결책은 더 깔끔해 보입니다. 두 해결책 모두 스위칭 변수가 불변(immutable)이고 해시 가능(hashable)하다는 것을 보장하기 위해 일부 런타임 오버헤드를 수반합니다.\u003c/p\u003e\n\u003cp\u003e두 해결책 모두 올바른 점프 위치를 찾기 위해 딕셔너리 룩업(dictionary lookup)을 사용하므로, 스위치 변수와 상수가 모두 딕셔너리 구현과 호환되어야 한다는 동일한 문제 공간을 공유합니다 (해시 가능, 비교 가능, \u003ccode\u003ea==b\u003c/code\u003e이면 \u003ccode\u003ehash(a)==hash(b)\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003e해결책 1: \u003ccode\u003eif-elif-else\u003c/code\u003e 최적화 (Optimizing \u003ccode\u003eif-elif-else\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e구현 (Implementation):\u003c/strong\u003e\n컴파일러가 다음 시그니처를 가진 \u003ccode\u003eif-elif-else\u003c/code\u003e 구문을 감지할 수 있어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif x == 'first':\n    ...\nelif x == 'second':\n    ...\nelse:\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e즉, 좌변은 항상 동일한 변수를 참조하고, 우변은 해시 가능한 불변(immutable) 내장 타입(built-in type)이어야 합니다. 우변들은 반드시 모두 같은 타입일 필요는 없지만, 좌변 스위치 변수의 타입과 비교 가능해야 합니다.\u003c/p\u003e\n\u003cp\u003e컴파일러는 그 후 읽기 전용 (완벽) 해시 테이블을 설정하고, 이를 상수에 저장한 다음, 표준 \u003ccode\u003eif-elif-else\u003c/code\u003e 바이트 코드 스트림 앞에 \u003ccode\u003eSWITCH\u003c/code\u003e Opcode를 추가할 수 있습니다. 이 Opcode는 다음 런타임 동작을 트리거합니다.\u003c/p\u003e\n\u003cp\u003e런타임 시 \u003ccode\u003eSWITCH\u003c/code\u003e Opcode는 \u003ccode\u003ex\u003c/code\u003e가 잘 알려진 불변 타입(문자열, 유니코드, 숫자) 중 하나인지 확인하고 해시 테이블을 사용하여 올바른 Opcode 스니펫을 찾습니다. 이 조건이 충족되지 않으면 인터프리터는 \u003ccode\u003eSWITCH\u003c/code\u003e Opcode를 단순히 건너뛰고 일반적인 \u003ccode\u003eif-elif-else\u003c/code\u003e 바이트 코드 스트림으로 진행하여 표준 \u003ccode\u003eif-elif-else\u003c/code\u003e 처리로 되돌아가야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e문제점 (Issues):\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e새로운 최적화는 현재 Python의 의미론(semantics)을 변경해서는 안 됩니다 (최적화의 영향을 받는 \u003ccode\u003eif-elif-else\u003c/code\u003e 구문에서 \u003ccode\u003e__cmp__\u003c/code\u003e 호출 수를 줄이고 \u003ccode\u003e__hash__\u003c/code\u003e 호출을 추가함으로써). 이를 보장하기 위해, 스위칭은 \"\u003ccode\u003efrom __future__\u003c/code\u003e\" 스타일 플래그가 사용되거나, 스위칭 변수가 \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003estring\u003c/code\u003e, \u003ccode\u003eunicode\u003c/code\u003e 등 내장 불변 타입(서브타입은 불변 여부가 불분명하므로 제외) 중 하나인 경우에만 안전하게 구현될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e점프 테이블 딕셔너리의 사후 수정(post-modifications)을 방지하기 위해 (이는 보호된 코드에 도달하는 데 사용될 수 있음), 점프 테이블은 읽기 전용 타입(예: 읽기 전용 딕셔너리)이어야 합니다.\u003c/li\u003e\n\u003cli\u003e이 최적화는 최소 \u003ccode\u003en\u003c/code\u003e개 이상의 케이스를 가진 \u003ccode\u003eif-elif-else\u003c/code\u003e 구문에만 사용되어야 합니다 (\u003ccode\u003en\u003c/code\u003e은 성능 테스트에 따라 정의될 숫자).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e해결책 2: Python에 \u003ccode\u003eswitch\u003c/code\u003e 문 추가 (Adding a \u003ccode\u003eswitch\u003c/code\u003e statement to Python)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e새로운 구문 (New Syntax):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eswitch EXPR:\n    case CONSTANT: SUITE\n    case CONSTANT: SUITE\n    ...\n    else: SUITE\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(\"else\" 부분은 선택 사항입니다.) \u003ccode\u003eelse\u003c/code\u003e 부분이 주어지지 않고 정의된 케이스 중 일치하는 것이 없으면 아무런 동작도 취해지지 않고 \u003ccode\u003eswitch\u003c/code\u003e 문은 무시됩니다. 이는 현재 \u003ccode\u003eif\u003c/code\u003e 문의 동작과 일치합니다. 예외를 사용하여 이 상황을 알리고 싶은 사용자는 의도된 동작을 구현하는 \u003ccode\u003eelse\u003c/code\u003e 분기를 정의할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e상수들은 반드시 모두 같은 타입일 필요는 없지만, 스위치 변수의 타입과 비교 가능해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e구현 (Implementation):\u003c/strong\u003e\n컴파일러는 이를 다음과 유사한 바이트 코드(bytecode)로 컴파일해야 합니다 (POP_TOP 및 SET_LINENO는 생략).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef whatis(x):\n    switch(x):\n        case 'one': print '1'\n        case 'two': print '2'\n        case 'three': print '3'\n        else: print \"D'oh!\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 \u003ccode\u003eSWITCH\u003c/code\u003e Opcode가 \u003ccode\u003ex\u003c/code\u003e에 따라 14, 22, 30 또는 38로 점프하도록 컴파일됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e문제점 (Issues):\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eswitch\u003c/code\u003e 문은 (C 언어의 \u003ccode\u003eswitch\u003c/code\u003e 문처럼) fall-through 동작을 구현해서는 안 됩니다. 각 \u003ccode\u003ecase\u003c/code\u003e는 \u003ccode\u003eif-elif-else\u003c/code\u003e 문과 매우 유사하게 완전하고 독립적인 스위트(suite)를 정의합니다. 이는 루프 내의 \u003ccode\u003eswitch\u003c/code\u003e 문에서 \u003ccode\u003ebreak\u003c/code\u003e를 사용하는 것도 가능하게 합니다.\u003c/li\u003e\n\u003cli\u003e인터프리터가 스위치 변수 \u003ccode\u003ex\u003c/code\u003e가 해시 가능하지 않다는 것을 발견하면, 런타임 시 \u003ccode\u003eTypeError\u003c/code\u003e를 발생시켜 문제를 지적해야 합니다.\u003c/li\u003e\n\u003cli\u003e기존 키워드를 재사용하고 새로운 키워드(\"switch\" 및 \"case\")를 추가하는 것을 피하는 다른 구문 제안들이 있었습니다. 다른 이들은 C 키워드와 이름은 같지만 의미론(예: \u003ccode\u003ebreak\u003c/code\u003e 없는 fall-through)이 약간 다르므로 새로운 용어를 사용해야 한다고 주장했습니다. 제안된 변형 중 일부는 다음과 같습니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecase EXPR:\n    of CONSTANT: SUITE\n    of CONSTANT: SUITE\nelse: SUITE\n\ncase EXPR:\n    if CONSTANT: SUITE\n    if CONSTANT: SUITE\nelse: SUITE\n\nwhen EXPR:\n    in CONSTANT_TUPLE: SUITE\n    in CONSTANT_TUPLE: SUITE\n    ...\nelse: SUITE\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eswitch\u003c/code\u003e 문은 한 섹션에 여러 값을 허용하도록 확장될 수 있습니다 (예: \u003ccode\u003ecase 'a', 'b', 'c': ...\u003c/code\u003e). 또 다른 제안된 확장으로는 값의 범위를 허용할 수 있습니다 (예: \u003ccode\u003ecase 10..14: ...\u003c/code\u003e). 이러한 기능들은 아마도 나중에 고려되어야 하지만, 첫 번째 버전을 설계하고 구현할 때 염두에 두어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e예시 (Examples)\u003c/h2\u003e\n\u003cp\u003e다음 예시들은 모두 해결책 2에서 제안된 새로운 구문을 사용합니다. 그러나 이 모든 예시는 해결책 1에서도 작동할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# switch EXPR:\n#    case CONSTANT: SUITE\n#    case CONSTANT: SUITE\n#    ...\n#    else: SUITE\n\n# 예시 1: 기본 switch 문\nswitch x:\n    case \"first\":\n        print x\n    case \"second\":\n        x = x**2\n        print x\n    else:\n        print \"whoops!\"\n\n# 예시 2: 'of' 키워드 사용 (대체 구문 제안)\ncase x:\n    of \"first\":\n        print x\n    of \"second\":\n        print x**2\n    else:\n        print \"whoops!\"\n\n# 예시 3: 'if' 키워드 사용 (대체 구문 제안)\ncase state:\n    if \"first\":\n        state = \"second\"\n    if \"second\":\n        state = \"third\"\n    else:\n        state = \"first\"\n\n# 예시 4: 'when... in' 키워드 사용 (대체 구문 제안)\nwhen state:\n    in (\"first\", \"second\"):\n        print state\n        state = next_state(state)\n    in (\"seventh\",):\n        ...\n        print \"done\"\n    else:\n        print \"middle state\"\n        state = next_state(state)\n        break # 루프를 빠져나옴!\n\n# Jack Jansen이 찾은 또 다른 유용한 응용 (인자 타입에 따른 스위칭):\nswitch type(x).__name__:\n    case 'int':\n        SUITE\n    case 'string':\n        SUITE\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e범위 (Scope)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e\"from __future__ import switch\"\u003c/code\u003e에 대해 설명해야 합니다.\u003c/p\u003e\n\u003ch2\u003e기여자 (Credits)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eMartin von Löwis (최적화 아이디어 관련 문제)\u003c/li\u003e\n\u003cli\u003eThomas Wouters (switch 문 + 바이트 코드 컴파일러 예시)\u003c/li\u003e\n\u003cli\u003eSkip Montanaro (디스패칭 아이디어, 예시)\u003c/li\u003e\n\u003cli\u003eDonald Beaudry (switch 구문)\u003c/li\u003e\n\u003cli\u003eGreg Ewing (switch 구문)\u003c/li\u003e\n\u003cli\u003eJack Jansen (타입 스위칭 예시)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e참조 (References)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ehttps://sourceforge.net/tracker/index.php?func=detail\u0026#x26;aid=481118\u0026#x26;group_id=5470\u0026#x26;atid=305470\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 있습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1615,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 275 - Switching on Multiple Values\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 17:53:28+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>