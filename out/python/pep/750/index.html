<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-17ec11482f243379.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1450<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 750 - Template Strings</h1><div class="page__meta"><time dateTime="2025-09-27 13:38:50+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0750/">PEP 750 - Template Strings</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 08-Jul-2024</p>
</blockquote>
<h1>PEP 750 – Template Strings</h1>
<ul>
<li><strong>작성자:</strong> Jim Baker 외 다수</li>
<li><strong>논의처:</strong> Discourse thread</li>
<li><strong>상태:</strong> Final</li>
<li><strong>유형:</strong> Standards Track</li>
<li><strong>생성일:</strong> 2024년 7월 8일</li>
<li><strong>Python 버전:</strong> 3.14</li>
<li><strong>해결일:</strong> 2025년 4월 10일</li>
</ul>
<p><strong>중요:</strong> 이 PEP는 역사적인 문서이며, 최신 공식 문서는 <a href="https://docs.python.org/3.14/reference/lexical_analysis.html#template-strings">Template strings</a>에서 확인할 수 있습니다.</p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 커스텀 문자열 처리를 위한 Template Strings (템플릿 문자열)를 소개합니다.</p>
<p>템플릿 문자열은 <code>f-strings</code>의 일반화된 형태로, <code>f</code> 접두사 대신 <code>t</code> 접두사를 사용합니다. <code>str</code>로 평가되는 대신, <code>t-strings</code>는 새로운 타입인 <code>Template</code>으로 평가됩니다.</p>
<pre><code class="language-python">template: Template = t"Hello {name}"
</code></pre>
<p><code>Template</code>은 개발자가 문자열과 보간된 값(interpolated values)이 결합되기 전에 이들에 접근할 수 있도록 합니다. 이는 Python 언어에 유연한 기본 문자열 처리 기능을 제공하고, 보안 검사, 웹 템플릿, 도메인 특화 언어(DSL) 등을 가능하게 합니다.</p>
<h2>다른 PEPs와의 관계 (Relationship With Other PEPs)</h2>
<ul>
<li>Python은 PEP 498을 통해 Python 3.6에서 <code>f-strings</code>를 도입했습니다.</li>
<li>문법은 PEP 701에서 공식화되었고 일부 제한 사항이 해제되었습니다. 이 PEP는 PEP 701을 기반으로 합니다.</li>
<li>PEP 498과 거의 동시에 PEP 501이 "i-strings"(interpolation template strings)를 제공하기 위해 작성되었으나, <code>f-strings</code> 경험이 더 필요하여 연기되었습니다.</li>
<li>이 PEP는 2023년 3월 다른 저자에 의해 "t-strings"라는 템플릿 리터럴 문자열로 작업이 재개되었고, PEP 701 위에 구축되었습니다.</li>
<li>이 PEP의 저자들은 PEP 501의 업데이트된 작업에 대한 일반화 및 단순화로 간주합니다.</li>
</ul>
<h2>동기 (Motivation)</h2>
<p>Python의 <code>f-strings</code>는 사용하기 쉽고 매우 인기가 많습니다. 그러나 시간이 지남에 따라 개발자들은 특정 사용 사례에 적합하지 않은 제약 사항에 직면했습니다. 특히 <code>f-strings</code>는 보간된 값들이 최종 문자열로 결합되기 전에 가로채서 변환할 방법이 없습니다.</p>
<p>그 결과, <code>f-strings</code>를 부주의하게 사용하면 보안 취약점으로 이어질 수 있습니다. 예를 들어:</p>
<ul>
<li><code>sqlite3</code>를 사용하여 SQL 쿼리를 실행하는 사용자가 <code>f-string</code>을 사용하여 값을 SQL 표현식에 삽입하려 할 경우, SQL 인젝션 공격으로 이어질 수 있습니다.</li>
<li>HTML을 구축하는 개발자가 이스케이프되지 않은 사용자 입력을 문자열에 포함하면, Cross-Site Scripting (XSS) 취약점이 발생할 수 있습니다.</li>
</ul>
<p>더 나아가, 보간된 값들을 최종 문자열로 결합하기 전에 변환할 수 없다는 점은 더 복잡한 문자열 처리 작업에서 <code>f-strings</code>의 유용성을 제한합니다.</p>
<p>템플릿 문자열은 개발자에게 문자열과 보간된 값에 대한 접근 권한을 제공함으로써 이러한 문제들을 해결합니다.</p>
<p>예를 들어, HTML을 생성하고 싶다고 가정해 봅시다. 템플릿 문자열을 사용하면 콘텐츠를 자동으로 새니타이즈(sanitize)할 수 있는 <code>html()</code> 함수를 정의할 수 있습니다.</p>
<pre><code class="language-python">evil = "&#x3C;script>alert('evil')&#x3C;/script>"
template = t"&#x3C;p>{evil}&#x3C;/p>"
# html() 함수를 통해 악성 스크립트가 이스케이프됨
assert html(template) == "&#x3C;p>&#x26;lt;script&#x26;gt;alert('evil')&#x26;lt;/script&#x26;gt;&#x3C;/p>"
</code></pre>
<p>또한, <code>html()</code> 함수는 딕셔너리를 사용하여 HTML 요소에 속성을 쉽게 추가할 수 있도록 합니다.</p>
<pre><code class="language-python">attributes = {"src": "shrubbery.jpg", "alt": "looks nice"}
template = t"&#x3C;img {attributes} />"
assert html(template) == '&#x3C;img src="shrubbery.jpg" alt="looks nice" />'
</code></pre>
<p>이러한 예제들은 <code>f-strings</code>로는 불가능합니다. 보간된 값들을 가로채고 변환하는 메커니즘을 제공함으로써 템플릿 문자열은 광범위한 문자열 처리 사용 사례를 가능하게 합니다.</p>
<h2>사양 (Specification)</h2>
<h3>템플릿 문자열 리터럴 (Template String Literals)</h3>
<p>이 PEP는 템플릿 문자열 리터럴을 정의하기 위한 새로운 문자열 접두사 <code>t</code>를 소개합니다. 이 리터럴들은 표준 라이브러리 모듈 <code>string.templatelib</code>에 있는 새로운 타입 <code>Template</code>으로 해석됩니다.</p>
<p>다음 코드는 <code>Template</code> 인스턴스를 생성합니다.</p>
<pre><code class="language-python">from string.templatelib import Template
template = t"This is a template string."
assert isinstance(template, Template)
</code></pre>
<p>템플릿 문자열 리터럴은 PEP 701의 전체 문법을 지원합니다. 여기에는 보간(interpolations) 내에 템플릿 문자열을 중첩하는 기능과 모든 유효한 따옴표(<code>'</code>, <code>"</code>, <code>'''</code>, <code>"""</code>)를 사용하는 기능이 포함됩니다.</p>
<ul>
<li>다른 문자열 접두사처럼 <code>t</code> 접두사는 따옴표 바로 앞에 와야 합니다.</li>
<li><code>f-strings</code>와 마찬가지로 소문자 <code>t</code>와 대문자 <code>T</code> 접두사 모두 지원됩니다.</li>
<li><code>f-strings</code>와 마찬가지로 <code>t-strings</code>는 <code>u</code> 또는 <code>b</code> 접두사와 결합될 수 없습니다.</li>
<li>또한, <code>f-strings</code>와 <code>t-strings</code>는 결합될 수 없으므로 <code>ft</code> 접두사는 유효하지 않습니다.</li>
<li><code>t-strings</code>는 <code>r</code> 접두사와 결합될 수 있습니다. 자세한 내용은 "Raw Template Strings" 섹션을 참조하십시오.</li>
</ul>
<h3>Template 타입 (The Template Type)</h3>
<p>템플릿 문자열은 새로운 불변(immutable) 타입인 <code>string.templatelib.Template</code>의 인스턴스로 평가됩니다.</p>
<pre><code class="language-python">class Template:
    strings: tuple[str, ...]
    """
    템플릿의 문자열 부분으로 구성된 비어 있지 않은 튜플이며,
    템플릿의 보간 수 N에 대해 N+1개의 항목을 가집니다.
    """
    interpolations: tuple[Interpolation, ...]
    """
    템플릿의 보간 부분으로 구성된 튜플입니다.
    보간이 없는 경우 빈 튜플이 됩니다.
    """
    def __new__(cls, *args: str | Interpolation):
        """
        새로운 Template 인스턴스를 생성합니다. 인수는 어떤 순서로든 제공될 수 있습니다.
        """
        ...
    @property
    def values(self) -> tuple[object, ...]:
        """
        템플릿 내 각 Interpolation의 `value` 속성으로 구성된 튜플을 반환합니다.
        보간이 없는 경우 빈 튜플이 됩니다.
        """
        ...
    def __iter__(self) -> Iterator[str | Interpolation]:
        """
        템플릿의 문자열 부분과 보간을 나타나는 순서대로 반복합니다.
        빈 문자열은 포함되지 않습니다.
        """
        ...
</code></pre>
<p><code>strings</code> 및 <code>interpolations</code> 속성은 리터럴 내의 문자열 부분과 모든 보간에 접근할 수 있도록 합니다.</p>
<pre><code class="language-python">name = "World"
template = t"Hello {name}"
assert template.strings[0] == "Hello "
assert template.interpolations[0].value == "World"
</code></pre>
<h3>Interpolation 타입 (The Interpolation Type)</h3>
<p><code>Interpolation</code> 타입은 템플릿 문자열 내의 표현식을 나타냅니다. <code>Template</code>과 마찬가지로 <code>string.templatelib</code> 모듈에 있는 새로운 클래스입니다.</p>
<pre><code class="language-python">class Interpolation:
    value: object
    expression: str
    conversion: Literal["a", "r", "s"] | None
    format_spec: str
    __match_args__ = ("value", "expression", "conversion", "format_spec")
    def __new__(
        cls,
        value: object,
        expression: str = "",
        conversion: Literal["a", "r", "s"] | None = None,
        format_spec: str = "",
    ): ...
</code></pre>
<p><code>Interpolation</code> 타입은 얕은 불변(shallow immutable)입니다. 속성은 재할당될 수 없습니다.</p>
<ul>
<li>
<p><code>value</code> 속성은 보간의 평가된 결과입니다.</p>
<pre><code class="language-python">name = "World"
template = t"Hello {name}"
assert template.interpolations[0].value == "World"
</code></pre>
</li>
<li>
<p>템플릿 문자열 리터럴에서 보간이 생성될 때, <code>expression</code> 속성은 보간의 원래 텍스트를 포함합니다.</p>
<pre><code class="language-python">name = "World"
template = t"Hello {name}"
assert template.interpolations[0].expression == "name"
</code></pre>
<p>개발자가 명시적으로 <code>Interpolation</code>을 구성할 때, <code>expression</code> 속성의 값을 선택적으로 제공할 수 있습니다. 문자열로 저장되지만, 유효한 Python 표현식이어야 합니다. 값이 제공되지 않으면 <code>expression</code> 속성은 기본적으로 빈 문자열(<code>""</code>)이 됩니다.
대부분의 템플릿 처리 코드에서 <code>expression</code> 속성은 사용되지 않을 것으로 예상됩니다. 디버깅 및 인트로스펙션(introspection)을 위해 제공됩니다.</p>
</li>
<li>
<p><code>conversion</code> 속성은 선택적으로 사용할 수 있는 변환으로, <code>repr()</code>, <code>str()</code>, <code>ascii()</code> 변환에 해당하는 <code>r</code>, <code>s</code>, <code>a</code> 중 하나입니다. <code>f-strings</code>와 마찬가지로 다른 변환은 지원되지 않습니다.</p>
<pre><code class="language-python">name = "World"
template = t"Hello {name!r}"
assert template.interpolations[0].conversion == "r"
</code></pre>
<p>변환이 제공되지 않으면 <code>conversion</code>은 <code>None</code>입니다.</p>
</li>
<li>
<p><code>format_spec</code> 속성은 형식 지정(format specification)입니다. <code>f-strings</code>와 마찬가지로 값의 표현 방식을 정의하는 임의의 문자열입니다.</p>
<pre><code class="language-python">value = 42
template = t"Value: {value:.2f}"
assert template.interpolations[0].format_spec == ".2f"
</code></pre>
<p><code>f-strings</code>의 형식 지정은 그 자체로 보간을 포함할 수 있습니다. 템플릿 문자열에서도 허용되며, <code>format_spec</code>은 즉시 평가된 결과로 설정됩니다.</p>
<pre><code class="language-python">value = 42
precision = 2
template = t"Value: {value:.{precision}f}"
assert template.interpolations[0].format_spec == ".2f"
</code></pre>
<p>형식 지정이 제공되지 않으면 <code>format_spec</code>은 기본적으로 빈 문자열(<code>""</code>)이 됩니다. 이는 Python의 내장 <code>format()</code> 함수의 <code>format_spec</code> 매개변수와 일치합니다.</p>
<p><code>f-strings</code>와 달리, <code>conversion</code> 및 <code>format_spec</code> 속성을 해석하는 방법은 템플릿을 처리하는 코드에 달려 있습니다. 이러한 코드가 이 속성들을 반드시 사용해야 하는 것은 아니지만, 존재하는 경우 존중되어야 하며, 가능한 한 <code>f-strings</code>의 동작과 일치해야 합니다. 예를 들어, <code>{value:.2f}</code>를 사용하는 템플릿 문자열이 처리될 때 값을 소수점 이하 두 자리로 반올림하지 않는다면 놀라울 것입니다.</p>
</li>
</ul>
<h3>Template.values 속성 (The Template.values Property)</h3>
<p><code>Template.values</code> 속성은 템플릿 내 각 <code>Interpolation</code>의 <code>value</code> 속성에 접근하기 위한 단축키이며 다음 코드와 동일합니다.</p>
<pre><code class="language-python">@property
def values(self) -> tuple[object, ...]:
    return tuple(i.value for i in self.interpolations)
</code></pre>
<h3>템플릿 내용 반복 (Iterating Template Contents)</h3>
<p><code>Template.__iter__()</code> 메서드는 템플릿의 전체 내용에 접근하는 간단한 방법을 제공합니다. 이는 문자열 부분과 보간을 나타나는 순서대로, 빈 문자열을 제외하고 반환합니다.</p>
<p><code>__iter__()</code> 메서드는 다음 코드와 동일합니다.</p>
<pre><code class="language-python">def __iter__(self) -> Iterator[str | Interpolation]:
    for s, i in zip_longest(self.strings, self.interpolations):
        if s:
            yield s
        if i:
            yield i
</code></pre>
<p>다음 예제는 <code>__iter__()</code> 메서드의 동작을 보여줍니다.</p>
<pre><code class="language-python">assert list(t"") == []
assert list(t"Hello") == ["Hello"]

name = "World"
template = t"Hello {name}!"
contents = list(template)
assert len(contents) == 3
assert contents[0] == "Hello "
assert contents[1].value == "World"
assert contents[1].expression == "name"
assert contents[2] == "!"
</code></pre>
<p><code>Template.strings</code>에 존재할 수 있는 빈 문자열은 <code>__iter__()</code> 메서드의 출력에 포함되지 않습니다.</p>
<pre><code class="language-python">first = "Eat"
second = "Red Leicester"
template = t"{first}{second}"
contents = list(template)
assert len(contents) == 2
assert contents[0].value == "Eat"
assert contents[0].expression == "first"
assert contents[1].value == "Red Leicester"
assert contents[1].expression == "second"
# 그러나 strings 속성에는 빈 문자열이 포함됩니다:
assert template.strings == ("", "", "")
</code></pre>
<p>템플릿 처리 코드는 요구 사항과 편의에 따라 <code>strings</code>, <code>interpolations</code>, <code>values</code>, <code>__iter__()</code>의 어떤 조합으로든 작업할 수 있습니다.</p>
<h3>템플릿 문자열 처리 (Processing Template Strings)</h3>
<p>개발자는 템플릿 문자열을 처리하기 위한 임의의 코드를 작성할 수 있습니다. 예를 들어, 다음 함수는 템플릿의 정적 부분을 소문자로, 보간을 대문자로 렌더링합니다.</p>
<pre><code class="language-python">from string.templatelib import Template, Interpolation

def lower_upper(template: Template) -> str:
    """정적 부분은 소문자로, 보간은 대문자로 렌더링합니다."""
    parts: list[str] = []
    for item in template:
        if isinstance(item, Interpolation):
            parts.append(str(item.value).upper())
        else:
            parts.append(item.lower())
    return "".join(parts)

name = "world"
assert lower_upper(t"HELLO {name}") == "hello WORLD"
</code></pre>
<p>템플릿 문자열이 특정 방식으로 처리되어야 한다는 요구 사항은 없습니다. 템플릿을 처리하는 코드는 문자열을 반환할 의무가 없습니다. 템플릿 문자열은 유연하고 범용적인 기능입니다.</p>
<h3>템플릿 문자열 연결 (Template String Concatenation)</h3>
<p>템플릿 문자열은 <code>+</code>를 사용한 명시적 연결을 지원합니다. <code>Template.__add__()</code>를 통해 두 <code>Template</code> 인스턴스에 대한 연결이 지원됩니다.</p>
<pre><code class="language-python">name = "World"
assert isinstance(t"Hello " + t"{name}", Template)
assert (t"Hello " + t"{name}").strings == ("Hello ", "")
assert (t"Hello " + t"{name}").values[0] == "World"
</code></pre>
<p>두 템플릿 문자열 리터럴의 암시적 연결도 지원됩니다.</p>
<pre><code class="language-python">name = "World"
assert isinstance(t"Hello " t"{name}", Template)
assert (t"Hello " t"{name}").strings == ("Hello ", "")
assert (t"Hello " t"{name}").values[0] == "World"
</code></pre>
<p><code>Template</code>과 <code>str</code>의 암시적 및 명시적 연결은 금지됩니다. 이는 <code>str</code>이 정적 문자열 부분으로 처리되어야 하는지, 아니면 보간으로 처리되어야 하는지 모호하기 때문입니다.</p>
<p><code>Template</code>과 <code>str</code>을 결합하려면 개발자는 <code>str</code>을 어떻게 처리할지 명시적으로 결정해야 합니다. <code>str</code>이 정적 문자열 부분으로 의도된 경우 <code>Template</code>으로 래핑(wrap)해야 합니다. <code>str</code>이 보간 값으로 의도된 경우 <code>Interpolation</code>으로 래핑하고 <code>Template</code> 생성자에 전달해야 합니다. 예를 들어:</p>
<pre><code class="language-python">name = "World"
# `name`을 정적 문자열 부분으로 처리
template = t"Hello " + Template(name)
# `name`을 보간으로 처리
template = t"Hello " + Template(Interpolation(name, "name"))
</code></pre>
<h3>Template 및 Interpolation 동등성 (Template and Interpolation Equality)</h3>
<p><code>Template</code> 및 <code>Interpolation</code> 인스턴스는 객체 ID(<code>is</code>)로 비교됩니다.</p>
<p><code>Template</code> 인스턴스는 템플릿 처리 코드에 의해 사용될 의도로, 문자열 또는 다른 타입을 반환할 수 있습니다. 이러한 타입은 필요에 따라 자체 동등성 의미(equality semantics)를 제공할 수 있습니다.</p>
<h3>순서 지정 미지원 (No Support for Ordering)</h3>
<p><code>Template</code> 및 <code>Interpolation</code> 타입은 순서 지정을 지원하지 않습니다. 이는 어휘적 순서 지정을 지원하는 Python의 다른 모든 문자열 리터럴 타입과 다릅니다. 보간에는 임의의 값이 포함될 수 있으므로 자연스러운 순서가 없습니다. 결과적으로 <code>Template</code> 및 <code>Interpolation</code> 타입 모두 표준 비교 메서드를 구현하지 않습니다.</p>
<h3>디버그 지정자 지원 (<code>=</code>) (Support for the debug specifier ( = ))</h3>
<p>디버그 지정자 <code>=</code>는 템플릿 문자열에서 지원되며, <code>f-strings</code>에서와 유사하게 동작하지만 구현상의 제약으로 인해 약간의 차이가 있습니다.</p>
<p>특히 <code>t'{value=}'</code>는 <code>t'value={value!r}'</code>로 처리됩니다. 첫 번째 정적 문자열은 <code>""</code>에서 <code>"value="</code>로 다시 작성되고, 변환은 기본적으로 <code>r</code>로 설정됩니다.</p>
<pre><code class="language-python">name = "World"
template = t"Hello {name=}"
assert template.strings[0] == "Hello name="
assert template.interpolations[0].value == "World"
assert template.interpolations[0].conversion == "r"
</code></pre>
<ul>
<li>변환이 명시적으로 제공되면 유지됩니다: <code>t'{value=!s}'</code>는 <code>t'value={value!s}'</code>로 처리됩니다.</li>
<li>변환 없이 형식 문자열이 제공되면, 변환은 <code>None</code>으로 설정됩니다: <code>t'{value=:fmt}'</code>는 <code>t'value={value:fmt}'</code>로 처리됩니다.</li>
<li>디버그 지정자에서 공백은 유지되므로 <code>t'{value = }'</code>는 <code>t'value = {value!r}'</code>로 처리됩니다.</li>
</ul>
<h3>Raw Template Strings (원시 템플릿 문자열)</h3>
<p><code>rt</code> (또는 <code>tr</code>) 접두사를 사용하여 raw 템플릿 문자열이 지원됩니다.</p>
<pre><code class="language-python">trade = 'shrubberies'
template = rt'Did you say "{trade}"?\n'
assert template.strings[0] == r'Did you say "'
assert template.strings[1] == r'"?\n'
</code></pre>
<p>이 예제에서 <code>\n</code>은 줄 바꿈 문자가 아닌 두 개의 별도 문자(백슬래시 다음에 'n')로 처리됩니다. 이는 Python의 raw 문자열 동작과 일치합니다.</p>
<p>일반 템플릿 문자열과 마찬가지로 raw 템플릿 문자열 내의 보간은 정상적으로 처리되어 raw 문자열 동작과 동적 콘텐츠의 조합을 허용합니다.</p>
<h3>보간 표현식 평가 (Interpolation Expression Evaluation)</h3>
<p>보간에 대한 표현식 평가는 PEP 498과 동일합니다.</p>
<p>문자열에서 추출된 표현식은 템플릿 문자열이 나타난 컨텍스트에서 평가됩니다. 즉, 표현식은 지역 변수 및 전역 변수를 포함하여 어휘적 스코프(lexical scope)에 완전히 접근할 수 있습니다. 함수 및 메서드 호출을 포함한 모든 유효한 Python 표현식이 사용될 수 있습니다.</p>
<p>템플릿 문자열은 <code>f-strings</code>와 마찬가지로 왼쪽에서 오른쪽으로 즉시(eagerly) 평가됩니다. 이는 템플릿 문자열이 처리될 때 보간이 즉시 평가되며, 지연되거나 람다(lambdas)로 래핑되지 않음을 의미합니다.</p>
<h3>예외 (Exceptions)</h3>
<p><code>t-string</code> 리터럴에서 발생하는 예외는 <code>f-string</code> 리터럴에서 발생하는 예외와 동일합니다.</p>
<h3>Template.__str__() 구현 없음 (No Template.<strong>str</strong>() Implementation)</h3>
<p><code>Template</code> 타입은 특수화된 <code>__str__()</code> 구현을 제공하지 않습니다.</p>
<p>이는 <code>Template</code> 인스턴스가 템플릿 처리 코드에 의해 사용될 의도로, 문자열 또는 다른 타입을 반환할 수 있기 때문입니다. <code>Template</code>을 문자열로 변환하는 표준적인 방법은 없습니다.</p>
<p><code>Template</code> 및 <code>Interpolation</code> 타입 모두 유용한 <code>__repr__()</code> 구현을 제공합니다.</p>
<h3>string.templatelib 모듈 (The string.templatelib Module)</h3>
<p><code>string</code> 모듈은 패키지로 변환되며, <code>Template</code> 및 <code>Interpolation</code> 타입을 포함하는 새로운 <code>templatelib</code> 서브모듈을 가집니다. 이 PEP의 구현 이후, 이 새로운 모듈은 <code>convert()</code>와 같은 관련 함수나 향후 잠재적인 템플릿 처리 코드(예: 셸 스크립트 도우미)에 사용될 수 있습니다.</p>
<h2>예제 (Examples)</h2>
<p>이 PEP의 모든 예제는 공개 <code>pep750-examples</code> Git 저장소에 완전히 테스트된 참조 구현이 제공됩니다.</p>
<h3>예제: t-strings로 f-strings 구현하기 (Example: Implementing f-strings with t-strings)</h3>
<p><code>t-strings</code>를 사용하여 <code>f-strings</code>를 "구현"하는 것은 쉽습니다. 즉, <code>f-string</code> 리터럴과 매우 유사하게 <code>Template</code>을 처리하고 동일한 결과를 반환하는 함수 <code>f(template: Template) -> str</code>을 작성할 수 있습니다.</p>
<pre><code class="language-python">name = "World"
value = 42
templated = t"Hello {name!r}, value: {value:.2f}"
formatted = f"Hello {name!r}, value: {value:.2f}"
assert f(templated) == formatted
</code></pre>
<p><code>f()</code> 함수는 <code>!r</code>과 같은 변환 지정자와 <code>:.2f</code>와 같은 형식 지정자(format specifiers)를 모두 지원합니다. 전체 코드는 매우 간단합니다.</p>
<pre><code class="language-python">from string.templatelib import Template, Interpolation
from typing import Literal

def convert(value: object, conversion: Literal["a", "r", "s"] | None) -> object:
    if conversion == "a":
        return ascii(value)
    elif conversion == "r":
        return repr(value)
    elif conversion == "s":
        return str(value)
    return value

def f(template: Template) -> str:
    parts = []
    for item in template:
        match item:
            case str() as s:
                parts.append(s)
            case Interpolation(value, _, conversion, format_spec):
                value = convert(value, conversion)
                value = format(value, format_spec)
                parts.append(value)
    return "".join(parts)
</code></pre>
<h3>예제: 구조화된 로깅 (Example: Structured Logging)</h3>
<p>구조화된 로깅을 통해 개발자는 JSON과 같은 기계가 읽을 수 있는 형식으로 데이터를 로깅할 수 있습니다. <code>t-strings</code>를 사용하면 개발자는 단일 로그 문만으로 사람이 읽을 수 있는 메시지와 함께 구조화된 데이터를 쉽게 로깅할 수 있습니다.</p>
<p>템플릿 문자열로 구조화된 로깅을 구현하는 두 가지 다른 접근 방식을 제시합니다.</p>
<h4>접근 방식 1: 커스텀 로그 메시지 (Approach 1: Custom Log Messages)</h4>
<p>Python Logging Cookbook에는 구조화된 로깅을 구현하는 방법에 대한 짧은 섹션이 있습니다.</p>
<p>로깅 Cookbook은 간단한 텍스트 메시지와 별도의 값 딕셔너리로 구성되는 새로운 "메시지" 클래스 <code>StructuredMessage</code>를 생성할 것을 제안합니다.</p>
<pre><code class="language-python">message = StructuredMessage("user action", {
    "action": "traded",
    "amount": 42,
    "item": "shrubs"
})
logging.info(message)
# 출력:
# user action >>> {"action": "traded", "amount": 42, "item": "shrubs"}
</code></pre>
<p><code>StructuredMessage.__str__()</code> 메서드는 사람이 읽을 수 있는 메시지와 값을 모두 형식화하여 최종 문자열로 결합합니다.</p>
<p>템플릿 문자열을 사용하여 <code>StructuredMessage</code>의 개선된 버전을 구현할 수 있습니다.</p>
<pre><code class="language-python">import json
import logging
from string.templatelib import Interpolation, Template
from typing import Mapping

class TemplateMessage:
    def __init__(self, template: Template) -> None:
        self.template = template

    @property
    def message(self) -> str:
        # 이전 예제의 f() 함수를 사용
        return f(self.template)

    @property
    def values(self) -> Mapping[str, object]:
        return {
            item.expression: item.value
            for item in self.template if isinstance(item, Interpolation)
        }

    def __str__(self) -> str:
        return f"{self.message} >>> {json.dumps(self.values)}"

_ = TemplateMessage # 선택 사항, 가독성 향상
action, amount, item = "traded", 42, "shrubs"
logging.info(_(t"User {action}: {amount:.2f} {item}"))
# 출력:
# User traded: 42.00 shrubs >>> {"action": "traded", "amount": 42, "item": "shrubs"}
</code></pre>
<p>템플릿 문자열은 커스텀 메시지 클래스를 정의하는 더 우아한 방법을 제공합니다. 템플릿 문자열을 사용하면 개발자는 더 이상 형식 문자열과 값 딕셔너리가 동기화되도록 신경 쓸 필요가 없습니다. 단일 템플릿 문자열 리터럴만 있으면 됩니다. <code>TemplateMessage</code> 구현은 <code>Interpolation.expression</code> 및 <code>Interpolation.value</code> 속성에서 구조화된 키와 값을 자동으로 추출할 수 있습니다.</p>
<h4>접근 방식 2: 커스텀 포맷터 (Approach 2: Custom Formatters)</h4>
<p>커스텀 메시지는 구조화된 로깅에 대한 합리적인 접근 방식이지만 약간 어색할 수 있습니다. 이를 사용하려면 개발자는 작성하는 모든 로그 메시지를 커스텀 클래스로 래핑해야 합니다. 이는 잊기 쉬울 수 있습니다.</p>
<p>대안적인 접근 방식은 커스텀 <code>logging.Formatter</code> 클래스를 정의하는 것입니다. 이 접근 방식은 더 유연하며 최종 출력에 대한 더 많은 제어를 허용합니다. 특히, 단일 템플릿 문자열을 가져와 여러 형식(사람이 읽을 수 있는 형식 및 JSON)으로 별도의 로그 스트림으로 출력하는 것이 가능합니다.</p>
<p>사람이 읽을 수 있는 출력을 위한 <code>MessageFormatter</code>와 JSON 출력을 위한 <code>ValuesFormatter</code>라는 두 개의 간단한 포맷터를 정의합니다.</p>
<pre><code class="language-python">import json
import logging
from logging import Formatter, LogRecord
from string.templatelib import Interpolation, Template
from typing import Any, Mapping

class MessageFormatter(Formatter):
    def message(self, template: Template) -> str:
        # 이전 예제의 f() 함수를 사용
        return f(template)

    def format(self, record: LogRecord) -> str:
        msg = record.msg
        if not isinstance(msg, Template):
            return super().format(record)
        return self.message(msg)

class ValuesFormatter(Formatter):
    def values(self, template: Template) -> Mapping[str, Any]:
        return {
            item.expression: item.value
            for item in template if isinstance(item, Interpolation)
        }

    def format(self, record: LogRecord) -> str:
        msg = record.msg
        if not isinstance(msg, Template):
            return super().format(record)
        return json.dumps(self.values(msg))
</code></pre>
<p>그런 다음 로거를 구성할 때 이 포맷터들을 사용할 수 있습니다.</p>
<pre><code class="language-python">import logging
import sys

logger = logging.getLogger(__name__)

message_handler = logging.StreamHandler(sys.stdout)
message_handler.setFormatter(MessageFormatter())
logger.addHandler(message_handler)

values_handler = logging.StreamHandler(sys.stderr)
values_handler.setFormatter(ValuesFormatter())
logger.addHandler(values_handler)

action, amount, item = "traded", 42, "shrubs"
logger.info(t"User {action}: {amount:.2f} {item}")
# sys.stdout으로 출력:
# User traded: 42.00 shrubs
# 동시에, sys.stderr으로 출력:
# {"action": "traded", "amount": 42, "item": "shrubs"}
</code></pre>
<p>이 접근 방식은 구조화된 로깅에 대한 커스텀 메시지 접근 방식에 비해 몇 가지 장점이 있습니다.</p>
<ul>
<li>개발자는 커스텀 클래스로 래핑하지 않고도 <code>t-string</code>을 직접 로깅할 수 있습니다.</li>
<li>사람이 읽을 수 있는 출력과 구조화된 출력을 별도의 로그 스트림으로 보낼 수 있습니다. 이는 사람이 읽을 수 있는 데이터와 독립적으로 구조화된 데이터를 처리하는 로그 집계 시스템에 유용합니다.</li>
</ul>
<h3>예제: HTML 템플릿 (Example: HTML Templating)</h3>
<p>이 PEP에는 여러 짧은 HTML 템플릿 예제가 포함되어 있습니다. "동기 (Motivation)" 섹션(및 이 PEP의 다른 몇 군데)에 언급된 "가상의" <code>html()</code> 함수가 존재하며 <code>pep750-examples</code> 저장소에서 사용할 수 있습니다.</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p><code>f-strings</code>와 마찬가지로 템플릿 문자열의 사용은 이전 버전과의 구문적 하위 호환성을 깨는 요소가 됩니다.</p>
<h2>보안 영향 (Security Implications)</h2>
<p>보간과 관련하여 템플릿 문자열 작업의 보안 영향은 다음과 같습니다.</p>
<ul>
<li>스코프(Scope) 조회는 <code>f-strings</code>와 동일합니다(어휘적 스코프). 이 모델은 실제로 잘 작동하는 것으로 나타났습니다.</li>
<li><code>Template</code> 인스턴스를 처리하는 코드는 모든 보간이 나타나는 컨텍스트를 존중하는 등 안전한 방식으로 처리되도록 보장할 수 있습니다.</li>
</ul>
<h2>교육 방법 (How To Teach This)</h2>
<p>템플릿 문자열에는 여러 대상이 있습니다.</p>
<ul>
<li>템플릿 문자열 및 처리 함수를 사용하는 개발자</li>
<li>템플릿 처리 코드의 작성자</li>
<li>템플릿 문자열로 흥미로운 메커니즘을 구축하는 프레임워크 작성자</li>
</ul>
<p>개발자를 교육하는 것은 간단할 것으로 예상됩니다. 언뜻 보기에 템플릿 문자열은 <code>f-strings</code>와 똑같이 생겼습니다. 문법은 친숙하고 스코핑 규칙은 동일하게 유지됩니다.</p>
<p>개발자가 가장 먼저 배워야 할 것은 템플릿 문자열 리터럴이 문자열로 평가되지 않고, 새로운 타입인 <code>Template</code>으로 평가된다는 것입니다. 이는 템플릿 처리 코드에 의해 사용될 의도로 만들어진 간단한 타입입니다. 개발자가 처리 함수를 호출해야만 원하는 결과(일반적으로 문자열)를 얻을 수 있으며, 물론 처리 코드는 임의의 타입을 반환할 수 있습니다.</p>
<p>개발자는 또한 템플릿 문자열이 <code>f-strings</code> 및 <code>str.format()</code>과 같은 다른 문자열 형식화 방법과 어떻게 관련되는지 이해해야 할 것입니다. 각 방법을 언제 사용해야 할지 결정해야 합니다. 간단한 문자열만 필요하고 보안 영향이 없다면 <code>f-strings</code>가 최선의 선택일 것입니다. 형식 문자열이 사용되는 대부분의 경우, 템플릿 문자열 생성을 래핑하는 함수로 대체할 수 있습니다. 형식 문자열이 사용자 입력, 파일 시스템 또는 데이터베이스에서 얻어지는 경우, 원한다면 이를 <code>Template</code> 인스턴스로 변환하는 코드를 작성할 수 있습니다.</p>
<p>개발자는 <code>t-strings</code>가 거의 항상 처리 함수와 함께 사용된다는 것을 배울 것이기 때문에 <code>Template</code> 타입의 세부 사항을 반드시 이해할 필요는 없습니다. 디스크립터(descriptors) 및 데코레이터(decorators)와 마찬가지로, <code>t-string</code> 처리 함수를 작성하는 개발자보다 <code>t-strings</code>를 사용하는 개발자가 훨씬 더 많을 것으로 예상됩니다.</p>
<p>시간이 지남에 따라 소수의 더 고급 개발자들은 자체 템플릿 처리 코드를 작성하기를 원할 것입니다. 처리 코드를 작성하는 것은 종종 형식 문법(formal grammars)의 관점에서 생각해야 합니다. 개발자는 <code>Template</code> 인스턴스의 <code>strings</code> 및 <code>interpolation</code> 속성과 함께 작업하는 방법과 컨텍스트에 민감한 방식으로 보간을 처리하는 방법을 배워야 합니다. 더 정교한 문법은 추상 구문 트리(AST)와 같은 중간 표현(intermediate representations)으로 파싱해야 할 가능성이 높습니다. 훌륭한 템플릿 처리 코드는 적절할 때 형식 지정자 및 변환을 처리할 것입니다. 프로덕션 수준의 템플릿 처리 코드(예: HTML 템플릿을 지원하기 위한)를 작성하는 것은 큰 작업이 될 수 있습니다.</p>
<p>템플릿 문자열은 프레임워크 작성자에게 도구 상자에 강력한 새 도구를 제공할 것으로 예상됩니다. 템플릿 문자열의 기능이 템플릿 엔진과 같은 기존 도구와 겹치지만, <code>t-strings</code>는 해당 로직을 언어 자체로 옮깁니다. Python의 모든 강력함과 일반성을 문자열 처리 작업에 적용하는 것은 프레임워크 작성자에게 새로운 가능성을 열어줍니다.</p>
<h2>또 다른 템플릿 접근 방식이 필요한 이유 (Why another templating approach?)</h2>
<p>Python 세계에는 Jinja와 같이 널리 채택된 성숙한 템플릿 언어가 이미 존재합니다. 새로운 템플릿 시스템 생성을 위한 지원을 구축하는 이유는 무엇일까요?</p>
<p>Jinja와 같은 프로젝트는 템플릿이 개발자에 의한 소프트웨어의 일부라기보다는 디자이너 또는 심지어 사용자(예: CMS)가 생성한 콘텐츠의 일부인 경우 여전히 필요합니다.</p>
<p>프런트엔드 개발의 추세는 템플릿을 소프트웨어의 일부로 간주하고 개발자가 작성합니다. 그들은 최신 언어 기능과 좋은 툴링 경험을 원합니다. PEP 750은 비정적 부분이 Python인 DSL(Domain-Specific Languages)을 구상합니다. 즉, 동일한 스코프 규칙, 타이핑, 표현식 구문 등을 가집니다.</p>
<h2>템플릿 처리에서 흔히 볼 수 있는 패턴 (Common Patterns Seen in Processing Templates)</h2>
<h3>구조적 패턴 매칭 (Structural Pattern Matching)</h3>
<p>구조적 패턴 매칭을 사용하여 <code>Template</code>을 반복하는 것은 많은 템플릿 함수 구현에서 예상되는 모범 사례입니다.</p>
<pre><code class="language-python">from string.templatelib import Template, Interpolation
from typing import Any

def process(template: Template) -> Any:
    for item in template:
        match item:
            case str() as s:
                ... # 각 문자열 부분 처리
            case Interpolation() as interpolation:
                ... # 각 보간 처리
</code></pre>
<p>처리 코드는 <code>Interpolation</code> 타입의 속성에 대해 하위 매칭(sub-match)하는 것이 일반적일 수도 있습니다.</p>
<pre><code class="language-python">match arg:
    case Interpolation(int()):
        ... # 정수 값을 가진 보간 처리
    case Interpolation(value=str() as s):
        ... # 문자열 값을 가진 보간 처리
    # 등등
</code></pre>
<h3>메모이제이션 (Memoizing)</h3>
<p>템플릿 함수는 템플릿의 정적 및 동적 부분을 효율적으로 처리할 수 있습니다. <code>Template</code> 객체의 구조는 효과적인 메모이제이션(memoization)을 허용합니다.</p>
<pre><code class="language-python">strings = template.strings # 정적 문자열 부분
values = template.values # 동적 보간된 값
</code></pre>
<p>이러한 분리를 통해 처리된 정적 부분은 캐시하고 동적 부분은 필요에 따라 삽입할 수 있습니다. 템플릿 처리 코드의 작성자는 정적 문자열을 캐시 키로 사용하여 유사한 템플릿이 반복적으로 사용될 때 상당한 성능 향상을 이끌어낼 수 있습니다.</p>
<h3>중간 표현으로 파싱 (Parsing to Intermediate Representations)</h3>
<p>템플릿을 처리하는 코드는 템플릿 문자열을 AST(Abstract Syntax Tree)와 같은 중간 표현으로 파싱할 수 있습니다. 많은 템플릿 처리 라이브러리가 이 접근 방식을 사용할 것으로 예상됩니다.</p>
<p>예를 들어, 우리의 이론적인 <code>html()</code> 함수(<code>Motivation</code> 섹션 참조)는 <code>str</code>을 반환하는 대신 동일한 패키지에 정의된 HTML <code>Element</code>를 반환할 수 있습니다.</p>
<pre><code class="language-python">from dataclasses import dataclass
from typing import Mapping, Sequence

@dataclass(frozen=True)
class Element:
    tag: str
    attributes: Mapping[str, str | bool]
    children: Sequence[str | Element]

    def __str__(self) -> str: ...

def html(template: Template) -> Element: ...
</code></pre>
<p>그러면 <code>str(element)</code>를 호출하면 HTML이 렌더링되지만, 그동안 <code>Element</code>는 다양한 방식으로 조작될 수 있습니다.</p>
<h3>컨텍스트에 민감한 보간 처리 (Context-sensitive Processing of Interpolations)</h3>
<p>가상의 <code>html()</code> 함수를 계속해서, 이를 컨텍스트에 민감하게 만들 수 있습니다. 보간은 템플릿에 나타나는 위치에 따라 다르게 처리될 수 있습니다.</p>
<p>예를 들어, <code>html()</code> 함수는 여러 종류의 보간을 지원할 수 있습니다.</p>
<pre><code class="language-python">attributes = {"id": "main"}
attribute_value = "shrubbery"
content = "hello"
template = t"&#x3C;div {attributes} data-value={attribute_value}>{content}&#x3C;/div>"
element = html(template)
assert str(element) == '&#x3C;div id="main" data-value="shrubbery">hello&#x3C;/div>'
</code></pre>
<ul>
<li><code>{attributes}</code> 보간은 HTML 태그 컨텍스트에서 발생하고 해당하는 속성 이름이 없기 때문에 속성 딕셔너리로 처리됩니다.</li>
<li><code>{attribute_value}</code> 보간은 단순한 문자열 값으로 처리되고 최종 문자열에 포함되기 전에 인용됩니다.</li>
<li><code>{content}</code> 보간은 잠재적으로 안전하지 않은 콘텐츠로 처리되고 최종 문자열에 포함되기 전에 이스케이프됩니다.</li>
</ul>
<h3>중첩된 템플릿 문자열 (Nested Template Strings)</h3>
<p><code>html()</code> 함수로 한 단계 더 나아가 중첩된 템플릿 문자열을 지원할 수 있습니다. 이를 통해 더 간단한 템플릿으로 더 복잡한 HTML 구조를 구축할 수 있습니다.</p>
<pre><code class="language-python">name = "World"
content = html(t"&#x3C;p>Hello {name}&#x3C;/p>")
template = t"&#x3C;div>{content}&#x3C;/div>"
element = html(template)
assert str(element) == '&#x3C;div>&#x3C;p>Hello World&#x3C;/p>&#x3C;/div>'
</code></pre>
<p><code>{content}</code> 보간은 <code>Element</code> 인스턴스이므로 최종 문자열에 포함되기 전에 이스케이프될 필요가 없습니다.</p>
<p><code>html()</code> 함수에 <code>Template</code> 인스턴스가 전달되면 중첩된 템플릿에 대해 재귀적으로 자신을 호출하여 자동으로 <code>Element</code>로 변환할 수 있다는 멋진 단순화를 상상할 수 있습니다.</p>
<p>템플릿의 중첩 및 구성은 템플릿 처리 코드에서 일반적인 패턴이 될 것이며, 적절한 경우 단순한 문자열 연결보다 선호될 것으로 예상됩니다.</p>
<h3>지연 평가 접근 방식 (Approaches to Lazy Evaluation)</h3>
<p><code>f-strings</code>와 마찬가지로 <code>t-string</code> 리터럴의 보간은 즉시 평가됩니다. 그러나 지연 평가(lazy evaluation)가 바람직할 수 있는 경우가 있습니다.</p>
<p>단일 보간이 평가하는 데 비용이 많이 드는 경우, 템플릿 문자열 리터럴에서 람다로 명시적으로 래핑할 수 있습니다.</p>
<pre><code class="language-python">name = "World"
template = t"Hello {(lambda: name)}"
assert callable(template.interpolations[0].value)
assert template.interpolations[0].value() == "World"
</code></pre>
<p>물론, 이는 템플릿 처리 코드가 호출 가능한 보간 값을 예상하고 처리한다고 가정합니다. (이터레이터(iterators), 어웨이터블(awaitables) 등도 지원할 수 있다고 상상할 수 있습니다.) 이는 PEP의 요구 사항은 아니지만, 템플릿 처리 코드에서 일반적인 패턴입니다.</p>
<p>일반적으로 커뮤니티가 템플릿 문자열에서 보간의 지연 평가에 대한 모범 사례를 개발하고, 합리적인 경우 공통 라이브러리가 템플릿 처리 코드에서 호출 가능한 또는 어웨이터블(awaitable) 값을 지원하기를 바랍니다.</p>
<h3>비동기 평가 접근 방식 (Approaches to Asynchronous Evaluation)</h3>
<p>지연 평가와 밀접하게 관련된 것은 비동기 평가(asynchronous evaluation)입니다.</p>
<p><code>f-strings</code>와 마찬가지로 <code>await</code> 키워드는 보간에서 허용됩니다.</p>
<pre><code class="language-python">import asyncio

async def example():
    async def get_name() -> str:
        await asyncio.sleep(1)
        return "Sleepy"
    # f() 함수는 이전 f-string 예제에서 가져옴
    assert f(t"Hello {await get_name()}") == "Hello Sleepy"
</code></pre>
<p>더 정교한 템플릿 처리 코드는 이를 활용하여 보간에서 비동기 작업을 수행할 수 있습니다. 예를 들어, "스마트한" 처리 함수는 보간이 어웨이터블임을 예상하고 템플릿 문자열을 처리하기 전에 <code>await</code>할 수 있습니다.</p>
<pre><code class="language-python">import asyncio

async def async_f(template: Template) -> str:
    # ... async 처리 로직
    pass

async def example():
    async def get_name() -> str:
        await asyncio.sleep(1)
        return "Sleepy"
    template = t"Hello {get_name}"
    assert await async_f(template) == "Hello Sleepy"
</code></pre>
<p>이는 <code>async_f()</code>의 템플릿 처리 코드가 비동기적이고 보간 값(<code>get_name</code> 코루틴)을 <code>await</code>할 수 있다고 가정합니다.</p>
<h3>템플릿 재사용 접근 방식 (Approaches to Template Reuse)</h3>
<p>개발자가 다른 값으로 템플릿 문자열을 여러 번 재사용하려면 <code>Template</code> 인스턴스를 반환하는 함수를 작성할 수 있습니다.</p>
<pre><code class="language-python">def reusable(name: str, question: str) -> Template:
    return t"Hello {name}, {question}?"

template1 = reusable("friend", "how are you")
template2 = reusable("King Arthur", "what is your quest")
</code></pre>
<p>물론 이는 <code>f-strings</code>가 재사용될 수 있는 방식과 다르지 않습니다.</p>
<h3>형식 문자열과의 관계 (Relation to Format Strings)</h3>
<p>오래된 <code>str.format()</code> 메서드는 나중에 값을 형식화하는 데 사용할 수 있는 형식 문자열(format strings)을 허용합니다.</p>
<pre><code class="language-python">alas_fmt = "We're all out of {cheese}."
assert alas_fmt.format(cheese="Red Leicester") == "We're all out of Red Leicester."
</code></pre>
<p>형식 문자열을 일종의 함수 정의로 생각할 수 있습니다. <code>str.format()</code> 호출은 일종의 함수 호출로 볼 수 있습니다. <code>t-string</code>의 해당 기능은 <code>Template</code> 인스턴스를 반환하는 표준 Python 함수를 정의하는 것입니다.</p>
<pre><code class="language-python">def make_template(*, cheese: str) -> Template:
    return t"We're all out of {cheese}."

template = make_template(cheese="Red Leicester")
# 위 f-string 예제의 f() 함수를 사용
assert f(template) == "We're all out of Red Leicester."
</code></pre>
<p><code>make_template()</code> 함수 자체는 형식 문자열과 유사하다고 생각할 수 있습니다. <code>make_template()</code> 호출은 <code>str.format()</code> 호출과 유사합니다.</p>
<p>물론, 파일 시스템이나 데이터베이스와 같은 외부 소스에서 형식 문자열을 로드하는 것이 일반적입니다. 다행히 <code>Template</code> 및 <code>Interpolation</code>은 단순한 Python 타입이므로, 이전 스타일의 형식 문자열을 가져와 동등한 <code>Template</code> 인스턴스를 반환하는 함수를 작성할 수 있습니다.</p>
<pre><code class="language-python">def from_format(fmt: str, /, *args: object, **kwargs: object) -> Template:
    """`fmt`를 파싱하고 `Template` 인스턴스를 반환합니다."""
    ...

# 파일, 데이터베이스 등에서 로드
fmt = "We're all out of {cheese}."
template = from_format(fmt, cheese="Red Leicester")
# 위 f-string 예제의 f() 함수를 사용
assert f(template) == "We're all out of Red Leicester."
</code></pre>
<p>이는 개발자가 이전에 형식 문자열을 사용했을 곳에 템플릿 문자열을 사용할 수 있도록 하는 강력한 패턴입니다. <code>from_format()</code>의 전체 구현은 예제 저장소에서 사용할 수 있으며, 형식 문자열의 전체 문법을 지원합니다.</p>
<h2>참조 구현 (Reference Implementation)</h2>
<p>PEP 750의 CPython 구현이 제공됩니다.</p>
<p>또한 참조 구현을 기반으로 구축된 예제 및 테스트의 공개 저장소가 있습니다. 템플릿 문자열을 가지고 놀고 싶다면 이 저장소가 시작하기에 좋은 곳입니다.</p>
<h2>거부된 아이디어 (Rejected Ideas)</h2>
<p>이 PEP는 여러 중요한 개정판을 거쳤습니다. 또한 PEP 501의 개정판과 Discourse 논의에서 상당히 많은 흥미로운 아이디어들이 고려되었습니다.</p>
<p>고려되었지만 거부된 가장 중요한 아이디어들을 문서화하려고 합니다.</p>
<h3>임의의 문자열 리터럴 접두사 (Arbitrary String Literal Prefixes)</h3>
<p>JavaScript 태그된 템플릿 리터럴(tagged template literals)에서 영감을 받아, 이 PEP의 이전 버전은 리터럴 문자열 앞에 임의의 "태그" 접두사를 허용했습니다.</p>
<pre><code class="language-python">my_tag'Hello {name}'
</code></pre>
<p>접두사는 "태그 함수(tag function)"라고 불리는 특별한 호출 가능한(callable) 객체였습니다. 태그 함수는 인자 목록으로 템플릿 문자열의 부분들을 받았습니다. 그런 다음 문자열을 처리하고 임의의 값을 반환할 수 있었습니다.</p>
<pre><code class="language-python">def my_tag(*args: str | Interpolation) -> Any: ...
</code></pre>
<p>이 접근 방식은 여러 가지 이유로 거부되었습니다.</p>
<ul>
<li>완전한 일반성을 구축하기에는 너무 복잡하다고 판단되었습니다. JavaScript는 템플릿 문자열 앞에 임의의 표현식을 허용하며, 이는 Python에서 구현하기에 상당한 도전입니다.</li>
<li>새로운 문자열 접두사의 향후 도입을 배제했습니다.</li>
<li>네임스페이스를 불필요하게 오염시키는 것으로 보였습니다.</li>
</ul>
<p>단일 <code>t</code> 접두사를 사용하는 것이 더 간단하고 Python스러운 접근 방식이며, <code>f-strings</code>의 일반화로서 템플릿 문자열의 역할과 더 일치한다고 판단되었습니다.</p>
<h3>보간의 지연 평가 (Delayed Evaluation of Interpolations)</h3>
<p>이 PEP의 초기 버전은 보간이 지연 평가되어야 한다고 제안했습니다. 모든 보간은 암시적 람다로 "래핑"되었습니다. 즉시 평가되는 <code>value</code> 속성 대신, 보간에는 보간 값을 해결하는 <code>getvalue()</code> 메서드가 있었습니다.</p>
<pre><code class="language-python">class Interpolation:
    ...
    _value: Callable[[], object]
    def getvalue(self) -> object:
        return self._value()
</code></pre>
<p>이는 여러 가지 이유로 거부되었습니다.</p>
<ul>
<li>템플릿 문자열의 압도적인 대다수 사용 사례는 자연스럽게 즉시 평가를 요구합니다.</li>
<li>지연 평가는 <code>f-strings</code>의 동작과 상당한 차이가 있을 것입니다.</li>
<li>암시적 람다 래핑은 타입 힌트(type hints) 및 정적 분석(static analysis)에 어려움을 초래합니다.</li>
</ul>
<p>가장 중요하게도, 지연 평가가 바람직한 많은 경우에 암시적 람다 래핑에 대한 실현 가능한(완벽하지는 않지만) 대안이 있습니다. 자세한 내용은 위의 "Approaches to Lazy Evaluation" 섹션을 참조하십시오.</p>
<p>이 PEP에서는 지연 평가가 거부되었지만, 커뮤니티가 이 아이디어를 계속 탐구하기를 바랍니다.</p>
<h3>Template 및 Interpolation을 프로토콜로 만들기 (Making Template and Interpolation Into Protocols)</h3>
<p>이 PEP의 초기 버전은 <code>Template</code> 및 <code>Interpolation</code> 타입을 클래스 대신 런타임 검사 가능 프로토콜(runtime checkable protocols)로 제안했습니다.</p>
<p>결론적으로, 클래스를 사용하는 것이 더 간단하다고 판단되었습니다.</p>
<h3>Template 및 Interpolation에 대한 __eq__ 및 __hash__ 오버라이드 (Overridden <strong>eq</strong> and <strong>hash</strong> for Template and Interpolation)</h3>
<p>이 PEP의 이전 버전은 <code>Template</code> 및 <code>Interpolation</code> 타입이 자체 <code>__eq__</code> 및 <code>__hash__</code> 구현을 가져야 한다고 제안했습니다.</p>
<ul>
<li>템플릿은 <code>strings</code> 및 <code>interpolations</code>가 같으면 같다고 간주되었습니다.</li>
<li>보간은 <code>value</code>, <code>expression</code>, <code>conversion</code>, <code>format_spec</code>이 같으면 같다고 간주되었습니다.</li>
<li><code>Interpolation</code> 해싱은 튜플 해싱과 유사했습니다. 즉, <code>Interpolation</code>은 <code>value</code>가 해시 가능할 때만 해시 가능했습니다.</li>
</ul>
<p>이것은 <code>Template.__hash__</code>가 템플릿 처리 코드에서 캐시 키로 유용하지 않기 때문에 거부되었습니다. 이는 개발자에게 혼란을 줄 수 있다는 우려가 있었습니다.</p>
<p>이러한 <code>__eq__</code> 및 <code>__hash__</code> 구현을 삭제함으로써 다음과 같은 assert를 작성할 수 있는 능력을 잃게 됩니다.</p>
<pre><code class="language-python">name = "World"
assert t"Hello " + t"{name}" == t"Hello {name}"
</code></pre>
<p><code>Template</code> 인스턴스가 추가 코드에 의해 빠르게 처리될 의도이므로, 이러한 assert의 유용성은 제한적이라고 판단했습니다.</p>
<h3>추가 Decoded 타입 (An Additional Decoded Type)</h3>
<p>이 PEP의 초기 버전은 템플릿 문자열의 "정적 문자열" 부분을 나타내기 위한 <code>Decoded</code>라는 추가 타입을 제안했습니다. 이 타입은 <code>str</code>에서 파생되었으며, 문자열의 원래 텍스트를 제공하는 단일 <code>raw</code> 속성을 가졌습니다. 우리는 일반 <code>str</code>을 사용하고 <code>r</code> 및 <code>t</code> 접두사의 조합을 허용하는 더 간단한 접근 방식을 선호하여 이를 거부했습니다.</p>
<h3>Template 및 Interpolation의 최종 위치 (The Final Home for Template and Interpolation)</h3>
<p>이 PEP의 이전 버전은 <code>Template</code> 및 <code>Interpolation</code> 타입을 <code>types</code>, <code>collections</code>, <code>collections.abc</code>, 심지어 새로운 최상위 모듈인 <code>templatelib</code>에 배치할 것을 제안했습니다. 최종 결정은 <code>string.templatelib</code>에 배치하는 것이었습니다.</p>
<h3>원본 템플릿 리터럴의 완전한 재구성 활성화 (Enable Full Reconstruction of Original Template Literal)</h3>
<p>이 PEP의 이전 버전은 <code>Template</code> 인스턴스에서 원본 템플릿 문자열의 텍스트를 완전히 재구성할 수 있도록 시도했습니다. 이는 지나치게 복잡하다고 판단되어 거부되었습니다. 템플릿 리터럴 소스와 기본 AST 간의 매핑은 일대일이 아니며, 원본 소스 텍스트로 라운드 트립(round-tripping)하는 데 몇 가지 제한 사항이 있습니다.</p>
<p>첫째, <code>Interpolation.format_spec</code>은 제공되지 않으면 <code>""</code>로 기본 설정됩니다.</p>
<pre><code class="language-python">value = 42
template1 = t"{value}"
template2 = t"{value:}"
assert template1.interpolations[0].format_spec == ""
assert template2.interpolations[0].format_spec == ""
</code></pre>
<p>다음으로, 디버그 지정자 <code>=</code>는 특수한 경우로 처리되며 AST가 생성되기 전에 처리됩니다. 따라서 <code>t"{value=}"</code>와 <code>t"value={value!r}"</code>를 구별하는 것은 불가능합니다.</p>
<pre><code class="language-python">value = 42
template1 = t"{value=}"
template2 = t"value={value!r}"
assert template1.strings[0] == "value="
assert template1.interpolations[0].expression == "value"
assert template1.interpolations[0].conversion == "r"
assert template2.strings[0] == "value="
assert template2.interpolations[0].expression == "value"
assert template2.interpolations[0].conversion == "r"
</code></pre>
<p>마지막으로, <code>f-strings</code>의 형식 지정자는 임의의 중첩을 허용합니다. 이 PEP 및 참조 구현에서는 지정자가 즉시 평가되어 <code>Interpolation</code>의 <code>format_spec</code>을 설정하므로 원래 표현식을 잃게 됩니다. 예를 들어:</p>
<pre><code class="language-python">value = 42
precision = 2
template1 = t"{value:.2f}"
template2 = t"{value:.{precision}f}"
assert template1.interpolations[0].format_spec == ".2f"
assert template2.interpolations[0].format_spec == ".2f"
</code></pre>
<p>이러한 제한 사항이 실제로 중요한 문제가 될 것이라고는 예상하지 않습니다. 원본 템플릿 문자열 리터럴을 얻어야 하는 개발자는 항상 <code>inspect.getsource()</code> 또는 유사한 도구를 사용할 수 있습니다.</p>
<h3>템플릿 연결 금지 (Disallowing Template Concatenation)</h3>
<p>이 PEP의 이전 버전은 <code>Template</code> 인스턴스가 연결을 지원해서는 안 된다고 제안했습니다. 여러 <code>Template</code> 인스턴스의 연결을 허용하는 방향으로 거부되었습니다.</p>
<p>하나 또는 모든 형태의 연결을 거부하는 데는 합리적인 주장이 있습니다. 즉, 이는 잠재적인 버그 클래스를 차단하며, 특히 템플릿 문자열이 연결이 항상 동일한 의미(또는 어떤 의미도)를 갖지 않는 복잡한 문법을 포함할 것이라는 관점을 취할 때 그렇습니다.</p>
<p>더욱이, 이 PEP의 초기 버전은 JavaScript의 태그된 템플릿 리터럴에 더 가까운 구문을 제안했으며, 여기서 임의의 호출 가능한(callable) 객체를 문자열 리터럴의 접두사로 사용할 수 있었습니다. 호출 가능한 객체가 연결을 지원하는 타입을 반환한다는 보장이 없었습니다.</p>
<p>결론적으로, 새로운 문자열 타입이 연결을 지원하지 않는다는 것이 개발자들에게 줄 놀라움이 지원함으로써 발생하는 이론적인 해로움보다 클 것이라고 판단했습니다.</p>
<p>이 PEP는 두 <code>Template</code>의 연결을 지원하지만, <code>Template</code>과 <code>str</code>의 연결은 지원하지 않습니다. 이는 <code>str</code>이 정적 문자열로 처리되어야 하는지 또는 보간으로 처리되어야 하는지 모호하기 때문입니다. 개발자는 위에서 설명한 대로 <code>str</code>을 다른 <code>Template</code>과 연결하기 전에 <code>Template</code> 인스턴스로 래핑해야 합니다.</p>
<p>템플릿 문자열을 사용하는 코드는 연결보다는 중첩 및 구성을 통해 더 큰 템플릿을 구축하는 것이 더 일반적일 것으로 예상됩니다.</p>
<h3>임의의 변환 값 (Arbitrary Conversion Values)</h3>
<p>Python은 가능한 변환 타입 값으로 <code>r</code>, <code>s</code>, 또는 <code>a</code>만 허용합니다. 다른 값을 할당하려고 하면 <code>SyntaxError</code>가 발생합니다.</p>
<p>이론적으로 템플릿 함수는 다른 변환 타입을 처리하도록 선택할 수 있습니다. 그러나 이 PEP는 PEP 701을 엄격하게 준수합니다. 허용되는 값에 대한 모든 변경 사항은 별도의 PEP에서 다루어져야 합니다.</p>
<h3>Interpolation에서 conversion 제거 (Removing conversion From Interpolation)</h3>
<p>이 PEP를 초안 작성하는 동안 <code>Interpolation</code>에서 <code>conversion</code> 속성을 제거하고, <code>Interpolation.value</code>가 설정되기 전에 변환이 즉시 수행되도록 지정하는 것을 고려했습니다.</p>
<p>이는 템플릿 처리 코드 작성 작업을 단순화하기 위한 것이었습니다. <code>conversion</code> 속성은 확장성이 제한적입니다(<code>Literal["r", "s", "a"] | None</code>으로 타입 지정됨). 커스텀 형식 지정자로 더 잘 달성할 수 없는 템플릿 문자열에 상당한 가치나 유연성을 추가하는지는 명확하지 않습니다. 형식 지정자와 달리 Python의 내장 <code>format()</code>과 동등한 것이 없습니다. (대신 "Examples" 섹션에 <code>convert()</code>의 샘플 구현을 포함합니다.)</p>
<p>궁극적으로 우리는 <code>f-strings</code>와의 호환성을 유지하고 향후 확장성을 허용하기 위해 <code>conversion</code> 속성을 <code>Interpolation</code> 타입에 유지하기로 결정했습니다.</p>
<h3>대체 보간 기호 (Alternate Interpolation Symbols)</h3>
<p>이 PEP의 초기 단계에서 템플릿 문자열에서 보간에 대한 대체 기호를 허용하는 것을 고려했습니다. 예를 들어, i18n 또는 다른 목적에 유용할 수 있다는 생각으로 <code>{name}</code>의 대안으로 <code>${name}</code>을 허용하는 것을 고려했습니다. 자세한 내용은 Discourse 스레드를 참조하십시오.</p>
<p>이는 <code>t-string</code> 문법을 <code>f-string</code> 문법과 가능한 한 가깝게 유지하는 것을 선호하여 거부되었습니다.</p>
<h3>Template의 대체 레이아웃 (Alternate Layouts for Template)</h3>
<p>이 PEP 개발 중에 <code>Template</code> 타입에 대한 여러 대체 레이아웃을 고려했습니다. 많은 것들이 문자열과 보간을 모두 포함하는 단일 <code>args</code> 튜플에 초점을 맞췄습니다. 변형에는 다음이 포함되었습니다.</p>
<ul>
<li><code>args</code>는 <code>tuple[str | Interpolation, ...]</code>이었고, 첫 번째 및 마지막 항목이 문자열이고 문자열과 보간이 항상 번갈아 나타난다는 약속이 있었습니다. 이는 <code>args</code>가 항상 비어 있지 않고 인접한 보간 사이에 빈 문자열이 삽입됨을 의미했습니다. 이는 교대가 타입 시스템에 의해 포착될 수 없고 우리가 만들고자 하는 보장이 아니었기 때문에 거부되었습니다.</li>
<li><code>args</code>는 <code>tuple[str | Interpolation, ...]</code>으로 유지되었지만 인터리빙(interleaving)을 지원하지 않았습니다. 결과적으로 빈 문자열은 시퀀스에 추가되지 않았습니다. 더 이상 <code>args[::2]</code>로 정적 문자열을 얻을 수 없었고, 대신 문자열과 보간을 구별하기 위해 인스턴스 검사 또는 구조적 패턴 매칭을 사용해야 했습니다. 이 접근 방식은 성능 최적화를 위한 향후 기회가 적다고 판단되어 거부되었습니다.</li>
<li><code>args</code>는 <code>Sequence[tuple[str, Interpolation | None]]</code>으로 타입 지정되었습니다. 각 정적 문자열은 인접한 보간과 쌍을 이루었습니다. 최종 문자열 부분에는 해당하는 보간이 없었습니다. 이는 지나치게 복잡하다고 판단되어 거부되었습니다.</li>
</ul>
<h3>템플릿 "종류"를 설명하는 메커니즘 (Mechanism to Describe the “Kind” of Template)</h3>
<p><code>t-strings</code>가 인기를 얻으면 템플릿 문자열에서 발견되는 콘텐츠의 "종류"(예: "sql", "html", "css" 등)를 설명하는 방법이 유용할 수 있습니다. 이는 린터(linters), 포맷터(formatters), 타입 체커(type checkers), IDE와 같은 도구에서 강력한 새 기능을 가능하게 할 수 있습니다. (예를 들어, <code>t-strings</code>에서 HTML을 포맷하는 <code>black</code>이나 주어진 속성이 HTML 태그에 유효한지 확인하는 <code>mypy</code>를 상상해 보세요.) 흥미롭기는 하지만, 이 PEP는 특정 메커니즘을 제안하지 않습니다. 시간이 지남에 따라 커뮤니티가 이 목적을 위한 규칙을 개발하기를 바랍니다.</p>
<h3>바이너리 템플릿 문자열 (Binary Template Strings)</h3>
<p><code>t-strings</code>와 바이트(<code>tb</code>)의 조합은 이 PEP의 범위를 벗어나는 것으로 간주됩니다. 그러나 <code>f-strings</code>와 달리 <code>t-strings</code>와 바이트를 결합할 수 없는 근본적인 이유는 없습니다. 향후 PEP에서 지원이 고려될 수 있습니다.</p>
<h2>감사의 말 (Acknowledgements)</h2>
<p>템플릿 문자열로 이어진 아이디어 개발에 기여해준 Ryan Morshead에게 감사드립니다. 또한 몇 년 전에 유사한 아이디어를 다룬 Dropbox의 <code>pyxl</code>에게 특별한 언급을 합니다. Andrea Giammarchi는 이 PEP의 초기 초안에 대해 사려 깊은 피드백을 제공했습니다. 마지막으로, <code>tagged</code> 라이브러리에 대한 선구적인 작업에 대해 Joachim Viide에게 감사드립니다. <code>tagged</code>는 템플릿 문자열의 전신일 뿐만 아니라 GitHub 이슈 댓글을 통해 전체 노력이 시작된 곳입니다!</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-17ec11482f243379.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/750\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"qd33V0IpW4K1wJhro15P-\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/750/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/750\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"750\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/750\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:Tfd4a,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0750/\"\u003ePEP 750 - Template Strings\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 08-Jul-2024\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 750 – Template Strings\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Jim Baker 외 다수\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e논의처:\u003c/strong\u003e Discourse thread\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2024년 7월 8일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.14\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e해결일:\u003c/strong\u003e 2025년 4월 10일\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e중요:\u003c/strong\u003e 이 PEP는 역사적인 문서이며, 최신 공식 문서는 \u003ca href=\"https://docs.python.org/3.14/reference/lexical_analysis.html#template-strings\"\u003eTemplate strings\u003c/a\u003e에서 확인할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 커스텀 문자열 처리를 위한 Template Strings (템플릿 문자열)를 소개합니다.\u003c/p\u003e\n\u003cp\u003e템플릿 문자열은 \u003ccode\u003ef-strings\u003c/code\u003e의 일반화된 형태로, \u003ccode\u003ef\u003c/code\u003e 접두사 대신 \u003ccode\u003et\u003c/code\u003e 접두사를 사용합니다. \u003ccode\u003estr\u003c/code\u003e로 평가되는 대신, \u003ccode\u003et-strings\u003c/code\u003e는 새로운 타입인 \u003ccode\u003eTemplate\u003c/code\u003e으로 평가됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etemplate: Template = t\"Hello {name}\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eTemplate\u003c/code\u003e은 개발자가 문자열과 보간된 값(interpolated values)이 결합되기 전에 이들에 접근할 수 있도록 합니다. 이는 Python 언어에 유연한 기본 문자열 처리 기능을 제공하고, 보안 검사, 웹 템플릿, 도메인 특화 언어(DSL) 등을 가능하게 합니다.\u003c/p\u003e\n\u003ch2\u003e다른 PEPs와의 관계 (Relationship With Other PEPs)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ePython은 PEP 498을 통해 Python 3.6에서 \u003ccode\u003ef-strings\u003c/code\u003e를 도입했습니다.\u003c/li\u003e\n\u003cli\u003e문법은 PEP 701에서 공식화되었고 일부 제한 사항이 해제되었습니다. 이 PEP는 PEP 701을 기반으로 합니다.\u003c/li\u003e\n\u003cli\u003ePEP 498과 거의 동시에 PEP 501이 \"i-strings\"(interpolation template strings)를 제공하기 위해 작성되었으나, \u003ccode\u003ef-strings\u003c/code\u003e 경험이 더 필요하여 연기되었습니다.\u003c/li\u003e\n\u003cli\u003e이 PEP는 2023년 3월 다른 저자에 의해 \"t-strings\"라는 템플릿 리터럴 문자열로 작업이 재개되었고, PEP 701 위에 구축되었습니다.\u003c/li\u003e\n\u003cli\u003e이 PEP의 저자들은 PEP 501의 업데이트된 작업에 대한 일반화 및 단순화로 간주합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePython의 \u003ccode\u003ef-strings\u003c/code\u003e는 사용하기 쉽고 매우 인기가 많습니다. 그러나 시간이 지남에 따라 개발자들은 특정 사용 사례에 적합하지 않은 제약 사항에 직면했습니다. 특히 \u003ccode\u003ef-strings\u003c/code\u003e는 보간된 값들이 최종 문자열로 결합되기 전에 가로채서 변환할 방법이 없습니다.\u003c/p\u003e\n\u003cp\u003e그 결과, \u003ccode\u003ef-strings\u003c/code\u003e를 부주의하게 사용하면 보안 취약점으로 이어질 수 있습니다. 예를 들어:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esqlite3\u003c/code\u003e를 사용하여 SQL 쿼리를 실행하는 사용자가 \u003ccode\u003ef-string\u003c/code\u003e을 사용하여 값을 SQL 표현식에 삽입하려 할 경우, SQL 인젝션 공격으로 이어질 수 있습니다.\u003c/li\u003e\n\u003cli\u003eHTML을 구축하는 개발자가 이스케이프되지 않은 사용자 입력을 문자열에 포함하면, Cross-Site Scripting (XSS) 취약점이 발생할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e더 나아가, 보간된 값들을 최종 문자열로 결합하기 전에 변환할 수 없다는 점은 더 복잡한 문자열 처리 작업에서 \u003ccode\u003ef-strings\u003c/code\u003e의 유용성을 제한합니다.\u003c/p\u003e\n\u003cp\u003e템플릿 문자열은 개발자에게 문자열과 보간된 값에 대한 접근 권한을 제공함으로써 이러한 문제들을 해결합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, HTML을 생성하고 싶다고 가정해 봅시다. 템플릿 문자열을 사용하면 콘텐츠를 자동으로 새니타이즈(sanitize)할 수 있는 \u003ccode\u003ehtml()\u003c/code\u003e 함수를 정의할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eevil = \"\u0026#x3C;script\u003ealert('evil')\u0026#x3C;/script\u003e\"\r\ntemplate = t\"\u0026#x3C;p\u003e{evil}\u0026#x3C;/p\u003e\"\r\n# html() 함수를 통해 악성 스크립트가 이스케이프됨\r\nassert html(template) == \"\u0026#x3C;p\u003e\u0026#x26;lt;script\u0026#x26;gt;alert('evil')\u0026#x26;lt;/script\u0026#x26;gt;\u0026#x3C;/p\u003e\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한, \u003ccode\u003ehtml()\u003c/code\u003e 함수는 딕셔너리를 사용하여 HTML 요소에 속성을 쉽게 추가할 수 있도록 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eattributes = {\"src\": \"shrubbery.jpg\", \"alt\": \"looks nice\"}\r\ntemplate = t\"\u0026#x3C;img {attributes} /\u003e\"\r\nassert html(template) == '\u0026#x3C;img src=\"shrubbery.jpg\" alt=\"looks nice\" /\u003e'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 예제들은 \u003ccode\u003ef-strings\u003c/code\u003e로는 불가능합니다. 보간된 값들을 가로채고 변환하는 메커니즘을 제공함으로써 템플릿 문자열은 광범위한 문자열 처리 사용 사례를 가능하게 합니다.\u003c/p\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003ch3\u003e템플릿 문자열 리터럴 (Template String Literals)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 템플릿 문자열 리터럴을 정의하기 위한 새로운 문자열 접두사 \u003ccode\u003et\u003c/code\u003e를 소개합니다. 이 리터럴들은 표준 라이브러리 모듈 \u003ccode\u003estring.templatelib\u003c/code\u003e에 있는 새로운 타입 \u003ccode\u003eTemplate\u003c/code\u003e으로 해석됩니다.\u003c/p\u003e\n\u003cp\u003e다음 코드는 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스를 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom string.templatelib import Template\r\ntemplate = t\"This is a template string.\"\r\nassert isinstance(template, Template)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e템플릿 문자열 리터럴은 PEP 701의 전체 문법을 지원합니다. 여기에는 보간(interpolations) 내에 템플릿 문자열을 중첩하는 기능과 모든 유효한 따옴표(\u003ccode\u003e'\u003c/code\u003e, \u003ccode\u003e\"\u003c/code\u003e, \u003ccode\u003e'''\u003c/code\u003e, \u003ccode\u003e\"\"\"\u003c/code\u003e)를 사용하는 기능이 포함됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e다른 문자열 접두사처럼 \u003ccode\u003et\u003c/code\u003e 접두사는 따옴표 바로 앞에 와야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ef-strings\u003c/code\u003e와 마찬가지로 소문자 \u003ccode\u003et\u003c/code\u003e와 대문자 \u003ccode\u003eT\u003c/code\u003e 접두사 모두 지원됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ef-strings\u003c/code\u003e와 마찬가지로 \u003ccode\u003et-strings\u003c/code\u003e는 \u003ccode\u003eu\u003c/code\u003e 또는 \u003ccode\u003eb\u003c/code\u003e 접두사와 결합될 수 없습니다.\u003c/li\u003e\n\u003cli\u003e또한, \u003ccode\u003ef-strings\u003c/code\u003e와 \u003ccode\u003et-strings\u003c/code\u003e는 결합될 수 없으므로 \u003ccode\u003eft\u003c/code\u003e 접두사는 유효하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003et-strings\u003c/code\u003e는 \u003ccode\u003er\u003c/code\u003e 접두사와 결합될 수 있습니다. 자세한 내용은 \"Raw Template Strings\" 섹션을 참조하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eTemplate 타입 (The Template Type)\u003c/h3\u003e\n\u003cp\u003e템플릿 문자열은 새로운 불변(immutable) 타입인 \u003ccode\u003estring.templatelib.Template\u003c/code\u003e의 인스턴스로 평가됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Template:\r\n    strings: tuple[str, ...]\r\n    \"\"\"\r\n    템플릿의 문자열 부분으로 구성된 비어 있지 않은 튜플이며,\r\n    템플릿의 보간 수 N에 대해 N+1개의 항목을 가집니다.\r\n    \"\"\"\r\n    interpolations: tuple[Interpolation, ...]\r\n    \"\"\"\r\n    템플릿의 보간 부분으로 구성된 튜플입니다.\r\n    보간이 없는 경우 빈 튜플이 됩니다.\r\n    \"\"\"\r\n    def __new__(cls, *args: str | Interpolation):\r\n        \"\"\"\r\n        새로운 Template 인스턴스를 생성합니다. 인수는 어떤 순서로든 제공될 수 있습니다.\r\n        \"\"\"\r\n        ...\r\n    @property\r\n    def values(self) -\u003e tuple[object, ...]:\r\n        \"\"\"\r\n        템플릿 내 각 Interpolation의 `value` 속성으로 구성된 튜플을 반환합니다.\r\n        보간이 없는 경우 빈 튜플이 됩니다.\r\n        \"\"\"\r\n        ...\r\n    def __iter__(self) -\u003e Iterator[str | Interpolation]:\r\n        \"\"\"\r\n        템플릿의 문자열 부분과 보간을 나타나는 순서대로 반복합니다.\r\n        빈 문자열은 포함되지 않습니다.\r\n        \"\"\"\r\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003estrings\u003c/code\u003e 및 \u003ccode\u003einterpolations\u003c/code\u003e 속성은 리터럴 내의 문자열 부분과 모든 보간에 접근할 수 있도록 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\ntemplate = t\"Hello {name}\"\r\nassert template.strings[0] == \"Hello \"\r\nassert template.interpolations[0].value == \"World\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eInterpolation 타입 (The Interpolation Type)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eInterpolation\u003c/code\u003e 타입은 템플릿 문자열 내의 표현식을 나타냅니다. \u003ccode\u003eTemplate\u003c/code\u003e과 마찬가지로 \u003ccode\u003estring.templatelib\u003c/code\u003e 모듈에 있는 새로운 클래스입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Interpolation:\r\n    value: object\r\n    expression: str\r\n    conversion: Literal[\"a\", \"r\", \"s\"] | None\r\n    format_spec: str\r\n    __match_args__ = (\"value\", \"expression\", \"conversion\", \"format_spec\")\r\n    def __new__(\r\n        cls,\r\n        value: object,\r\n        expression: str = \"\",\r\n        conversion: Literal[\"a\", \"r\", \"s\"] | None = None,\r\n        format_spec: str = \"\",\r\n    ): ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eInterpolation\u003c/code\u003e 타입은 얕은 불변(shallow immutable)입니다. 속성은 재할당될 수 없습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003evalue\u003c/code\u003e 속성은 보간의 평가된 결과입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\ntemplate = t\"Hello {name}\"\r\nassert template.interpolations[0].value == \"World\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e템플릿 문자열 리터럴에서 보간이 생성될 때, \u003ccode\u003eexpression\u003c/code\u003e 속성은 보간의 원래 텍스트를 포함합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\ntemplate = t\"Hello {name}\"\r\nassert template.interpolations[0].expression == \"name\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e개발자가 명시적으로 \u003ccode\u003eInterpolation\u003c/code\u003e을 구성할 때, \u003ccode\u003eexpression\u003c/code\u003e 속성의 값을 선택적으로 제공할 수 있습니다. 문자열로 저장되지만, 유효한 Python 표현식이어야 합니다. 값이 제공되지 않으면 \u003ccode\u003eexpression\u003c/code\u003e 속성은 기본적으로 빈 문자열(\u003ccode\u003e\"\"\u003c/code\u003e)이 됩니다.\r\n대부분의 템플릿 처리 코드에서 \u003ccode\u003eexpression\u003c/code\u003e 속성은 사용되지 않을 것으로 예상됩니다. 디버깅 및 인트로스펙션(introspection)을 위해 제공됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003econversion\u003c/code\u003e 속성은 선택적으로 사용할 수 있는 변환으로, \u003ccode\u003erepr()\u003c/code\u003e, \u003ccode\u003estr()\u003c/code\u003e, \u003ccode\u003eascii()\u003c/code\u003e 변환에 해당하는 \u003ccode\u003er\u003c/code\u003e, \u003ccode\u003es\u003c/code\u003e, \u003ccode\u003ea\u003c/code\u003e 중 하나입니다. \u003ccode\u003ef-strings\u003c/code\u003e와 마찬가지로 다른 변환은 지원되지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\ntemplate = t\"Hello {name!r}\"\r\nassert template.interpolations[0].conversion == \"r\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e변환이 제공되지 않으면 \u003ccode\u003econversion\u003c/code\u003e은 \u003ccode\u003eNone\u003c/code\u003e입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eformat_spec\u003c/code\u003e 속성은 형식 지정(format specification)입니다. \u003ccode\u003ef-strings\u003c/code\u003e와 마찬가지로 값의 표현 방식을 정의하는 임의의 문자열입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003evalue = 42\r\ntemplate = t\"Value: {value:.2f}\"\r\nassert template.interpolations[0].format_spec == \".2f\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ef-strings\u003c/code\u003e의 형식 지정은 그 자체로 보간을 포함할 수 있습니다. 템플릿 문자열에서도 허용되며, \u003ccode\u003eformat_spec\u003c/code\u003e은 즉시 평가된 결과로 설정됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003evalue = 42\r\nprecision = 2\r\ntemplate = t\"Value: {value:.{precision}f}\"\r\nassert template.interpolations[0].format_spec == \".2f\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e형식 지정이 제공되지 않으면 \u003ccode\u003eformat_spec\u003c/code\u003e은 기본적으로 빈 문자열(\u003ccode\u003e\"\"\u003c/code\u003e)이 됩니다. 이는 Python의 내장 \u003ccode\u003eformat()\u003c/code\u003e 함수의 \u003ccode\u003eformat_spec\u003c/code\u003e 매개변수와 일치합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ef-strings\u003c/code\u003e와 달리, \u003ccode\u003econversion\u003c/code\u003e 및 \u003ccode\u003eformat_spec\u003c/code\u003e 속성을 해석하는 방법은 템플릿을 처리하는 코드에 달려 있습니다. 이러한 코드가 이 속성들을 반드시 사용해야 하는 것은 아니지만, 존재하는 경우 존중되어야 하며, 가능한 한 \u003ccode\u003ef-strings\u003c/code\u003e의 동작과 일치해야 합니다. 예를 들어, \u003ccode\u003e{value:.2f}\u003c/code\u003e를 사용하는 템플릿 문자열이 처리될 때 값을 소수점 이하 두 자리로 반올림하지 않는다면 놀라울 것입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eTemplate.values 속성 (The Template.values Property)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eTemplate.values\u003c/code\u003e 속성은 템플릿 내 각 \u003ccode\u003eInterpolation\u003c/code\u003e의 \u003ccode\u003evalue\u003c/code\u003e 속성에 접근하기 위한 단축키이며 다음 코드와 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@property\r\ndef values(self) -\u003e tuple[object, ...]:\r\n    return tuple(i.value for i in self.interpolations)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e템플릿 내용 반복 (Iterating Template Contents)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eTemplate.__iter__()\u003c/code\u003e 메서드는 템플릿의 전체 내용에 접근하는 간단한 방법을 제공합니다. 이는 문자열 부분과 보간을 나타나는 순서대로, 빈 문자열을 제외하고 반환합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__iter__()\u003c/code\u003e 메서드는 다음 코드와 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef __iter__(self) -\u003e Iterator[str | Interpolation]:\r\n    for s, i in zip_longest(self.strings, self.interpolations):\r\n        if s:\r\n            yield s\r\n        if i:\r\n            yield i\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 예제는 \u003ccode\u003e__iter__()\u003c/code\u003e 메서드의 동작을 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eassert list(t\"\") == []\r\nassert list(t\"Hello\") == [\"Hello\"]\r\n\r\nname = \"World\"\r\ntemplate = t\"Hello {name}!\"\r\ncontents = list(template)\r\nassert len(contents) == 3\r\nassert contents[0] == \"Hello \"\r\nassert contents[1].value == \"World\"\r\nassert contents[1].expression == \"name\"\r\nassert contents[2] == \"!\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eTemplate.strings\u003c/code\u003e에 존재할 수 있는 빈 문자열은 \u003ccode\u003e__iter__()\u003c/code\u003e 메서드의 출력에 포함되지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efirst = \"Eat\"\r\nsecond = \"Red Leicester\"\r\ntemplate = t\"{first}{second}\"\r\ncontents = list(template)\r\nassert len(contents) == 2\r\nassert contents[0].value == \"Eat\"\r\nassert contents[0].expression == \"first\"\r\nassert contents[1].value == \"Red Leicester\"\r\nassert contents[1].expression == \"second\"\r\n# 그러나 strings 속성에는 빈 문자열이 포함됩니다:\r\nassert template.strings == (\"\", \"\", \"\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e템플릿 처리 코드는 요구 사항과 편의에 따라 \u003ccode\u003estrings\u003c/code\u003e, \u003ccode\u003einterpolations\u003c/code\u003e, \u003ccode\u003evalues\u003c/code\u003e, \u003ccode\u003e__iter__()\u003c/code\u003e의 어떤 조합으로든 작업할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e템플릿 문자열 처리 (Processing Template Strings)\u003c/h3\u003e\n\u003cp\u003e개발자는 템플릿 문자열을 처리하기 위한 임의의 코드를 작성할 수 있습니다. 예를 들어, 다음 함수는 템플릿의 정적 부분을 소문자로, 보간을 대문자로 렌더링합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom string.templatelib import Template, Interpolation\r\n\r\ndef lower_upper(template: Template) -\u003e str:\r\n    \"\"\"정적 부분은 소문자로, 보간은 대문자로 렌더링합니다.\"\"\"\r\n    parts: list[str] = []\r\n    for item in template:\r\n        if isinstance(item, Interpolation):\r\n            parts.append(str(item.value).upper())\r\n        else:\r\n            parts.append(item.lower())\r\n    return \"\".join(parts)\r\n\r\nname = \"world\"\r\nassert lower_upper(t\"HELLO {name}\") == \"hello WORLD\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e템플릿 문자열이 특정 방식으로 처리되어야 한다는 요구 사항은 없습니다. 템플릿을 처리하는 코드는 문자열을 반환할 의무가 없습니다. 템플릿 문자열은 유연하고 범용적인 기능입니다.\u003c/p\u003e\n\u003ch3\u003e템플릿 문자열 연결 (Template String Concatenation)\u003c/h3\u003e\n\u003cp\u003e템플릿 문자열은 \u003ccode\u003e+\u003c/code\u003e를 사용한 명시적 연결을 지원합니다. \u003ccode\u003eTemplate.__add__()\u003c/code\u003e를 통해 두 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스에 대한 연결이 지원됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\nassert isinstance(t\"Hello \" + t\"{name}\", Template)\r\nassert (t\"Hello \" + t\"{name}\").strings == (\"Hello \", \"\")\r\nassert (t\"Hello \" + t\"{name}\").values[0] == \"World\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 템플릿 문자열 리터럴의 암시적 연결도 지원됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\nassert isinstance(t\"Hello \" t\"{name}\", Template)\r\nassert (t\"Hello \" t\"{name}\").strings == (\"Hello \", \"\")\r\nassert (t\"Hello \" t\"{name}\").values[0] == \"World\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eTemplate\u003c/code\u003e과 \u003ccode\u003estr\u003c/code\u003e의 암시적 및 명시적 연결은 금지됩니다. 이는 \u003ccode\u003estr\u003c/code\u003e이 정적 문자열 부분으로 처리되어야 하는지, 아니면 보간으로 처리되어야 하는지 모호하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTemplate\u003c/code\u003e과 \u003ccode\u003estr\u003c/code\u003e을 결합하려면 개발자는 \u003ccode\u003estr\u003c/code\u003e을 어떻게 처리할지 명시적으로 결정해야 합니다. \u003ccode\u003estr\u003c/code\u003e이 정적 문자열 부분으로 의도된 경우 \u003ccode\u003eTemplate\u003c/code\u003e으로 래핑(wrap)해야 합니다. \u003ccode\u003estr\u003c/code\u003e이 보간 값으로 의도된 경우 \u003ccode\u003eInterpolation\u003c/code\u003e으로 래핑하고 \u003ccode\u003eTemplate\u003c/code\u003e 생성자에 전달해야 합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\n# `name`을 정적 문자열 부분으로 처리\r\ntemplate = t\"Hello \" + Template(name)\r\n# `name`을 보간으로 처리\r\ntemplate = t\"Hello \" + Template(Interpolation(name, \"name\"))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eTemplate 및 Interpolation 동등성 (Template and Interpolation Equality)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eTemplate\u003c/code\u003e 및 \u003ccode\u003eInterpolation\u003c/code\u003e 인스턴스는 객체 ID(\u003ccode\u003eis\u003c/code\u003e)로 비교됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTemplate\u003c/code\u003e 인스턴스는 템플릿 처리 코드에 의해 사용될 의도로, 문자열 또는 다른 타입을 반환할 수 있습니다. 이러한 타입은 필요에 따라 자체 동등성 의미(equality semantics)를 제공할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e순서 지정 미지원 (No Support for Ordering)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eTemplate\u003c/code\u003e 및 \u003ccode\u003eInterpolation\u003c/code\u003e 타입은 순서 지정을 지원하지 않습니다. 이는 어휘적 순서 지정을 지원하는 Python의 다른 모든 문자열 리터럴 타입과 다릅니다. 보간에는 임의의 값이 포함될 수 있으므로 자연스러운 순서가 없습니다. 결과적으로 \u003ccode\u003eTemplate\u003c/code\u003e 및 \u003ccode\u003eInterpolation\u003c/code\u003e 타입 모두 표준 비교 메서드를 구현하지 않습니다.\u003c/p\u003e\n\u003ch3\u003e디버그 지정자 지원 (\u003ccode\u003e=\u003c/code\u003e) (Support for the debug specifier ( = ))\u003c/h3\u003e\n\u003cp\u003e디버그 지정자 \u003ccode\u003e=\u003c/code\u003e는 템플릿 문자열에서 지원되며, \u003ccode\u003ef-strings\u003c/code\u003e에서와 유사하게 동작하지만 구현상의 제약으로 인해 약간의 차이가 있습니다.\u003c/p\u003e\n\u003cp\u003e특히 \u003ccode\u003et'{value=}'\u003c/code\u003e는 \u003ccode\u003et'value={value!r}'\u003c/code\u003e로 처리됩니다. 첫 번째 정적 문자열은 \u003ccode\u003e\"\"\u003c/code\u003e에서 \u003ccode\u003e\"value=\"\u003c/code\u003e로 다시 작성되고, 변환은 기본적으로 \u003ccode\u003er\u003c/code\u003e로 설정됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\ntemplate = t\"Hello {name=}\"\r\nassert template.strings[0] == \"Hello name=\"\r\nassert template.interpolations[0].value == \"World\"\r\nassert template.interpolations[0].conversion == \"r\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e변환이 명시적으로 제공되면 유지됩니다: \u003ccode\u003et'{value=!s}'\u003c/code\u003e는 \u003ccode\u003et'value={value!s}'\u003c/code\u003e로 처리됩니다.\u003c/li\u003e\n\u003cli\u003e변환 없이 형식 문자열이 제공되면, 변환은 \u003ccode\u003eNone\u003c/code\u003e으로 설정됩니다: \u003ccode\u003et'{value=:fmt}'\u003c/code\u003e는 \u003ccode\u003et'value={value:fmt}'\u003c/code\u003e로 처리됩니다.\u003c/li\u003e\n\u003cli\u003e디버그 지정자에서 공백은 유지되므로 \u003ccode\u003et'{value = }'\u003c/code\u003e는 \u003ccode\u003et'value = {value!r}'\u003c/code\u003e로 처리됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRaw Template Strings (원시 템플릿 문자열)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ert\u003c/code\u003e (또는 \u003ccode\u003etr\u003c/code\u003e) 접두사를 사용하여 raw 템플릿 문자열이 지원됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etrade = 'shrubberies'\r\ntemplate = rt'Did you say \"{trade}\"?\\n'\r\nassert template.strings[0] == r'Did you say \"'\r\nassert template.strings[1] == r'\"?\\n'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서 \u003ccode\u003e\\n\u003c/code\u003e은 줄 바꿈 문자가 아닌 두 개의 별도 문자(백슬래시 다음에 'n')로 처리됩니다. 이는 Python의 raw 문자열 동작과 일치합니다.\u003c/p\u003e\n\u003cp\u003e일반 템플릿 문자열과 마찬가지로 raw 템플릿 문자열 내의 보간은 정상적으로 처리되어 raw 문자열 동작과 동적 콘텐츠의 조합을 허용합니다.\u003c/p\u003e\n\u003ch3\u003e보간 표현식 평가 (Interpolation Expression Evaluation)\u003c/h3\u003e\n\u003cp\u003e보간에 대한 표현식 평가는 PEP 498과 동일합니다.\u003c/p\u003e\n\u003cp\u003e문자열에서 추출된 표현식은 템플릿 문자열이 나타난 컨텍스트에서 평가됩니다. 즉, 표현식은 지역 변수 및 전역 변수를 포함하여 어휘적 스코프(lexical scope)에 완전히 접근할 수 있습니다. 함수 및 메서드 호출을 포함한 모든 유효한 Python 표현식이 사용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e템플릿 문자열은 \u003ccode\u003ef-strings\u003c/code\u003e와 마찬가지로 왼쪽에서 오른쪽으로 즉시(eagerly) 평가됩니다. 이는 템플릿 문자열이 처리될 때 보간이 즉시 평가되며, 지연되거나 람다(lambdas)로 래핑되지 않음을 의미합니다.\u003c/p\u003e\n\u003ch3\u003e예외 (Exceptions)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003et-string\u003c/code\u003e 리터럴에서 발생하는 예외는 \u003ccode\u003ef-string\u003c/code\u003e 리터럴에서 발생하는 예외와 동일합니다.\u003c/p\u003e\n\u003ch3\u003eTemplate.__str__() 구현 없음 (No Template.\u003cstrong\u003estr\u003c/strong\u003e() Implementation)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eTemplate\u003c/code\u003e 타입은 특수화된 \u003ccode\u003e__str__()\u003c/code\u003e 구현을 제공하지 않습니다.\u003c/p\u003e\n\u003cp\u003e이는 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스가 템플릿 처리 코드에 의해 사용될 의도로, 문자열 또는 다른 타입을 반환할 수 있기 때문입니다. \u003ccode\u003eTemplate\u003c/code\u003e을 문자열로 변환하는 표준적인 방법은 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTemplate\u003c/code\u003e 및 \u003ccode\u003eInterpolation\u003c/code\u003e 타입 모두 유용한 \u003ccode\u003e__repr__()\u003c/code\u003e 구현을 제공합니다.\u003c/p\u003e\n\u003ch3\u003estring.templatelib 모듈 (The string.templatelib Module)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003estring\u003c/code\u003e 모듈은 패키지로 변환되며, \u003ccode\u003eTemplate\u003c/code\u003e 및 \u003ccode\u003eInterpolation\u003c/code\u003e 타입을 포함하는 새로운 \u003ccode\u003etemplatelib\u003c/code\u003e 서브모듈을 가집니다. 이 PEP의 구현 이후, 이 새로운 모듈은 \u003ccode\u003econvert()\u003c/code\u003e와 같은 관련 함수나 향후 잠재적인 템플릿 처리 코드(예: 셸 스크립트 도우미)에 사용될 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e예제 (Examples)\u003c/h2\u003e\n\u003cp\u003e이 PEP의 모든 예제는 공개 \u003ccode\u003epep750-examples\u003c/code\u003e Git 저장소에 완전히 테스트된 참조 구현이 제공됩니다.\u003c/p\u003e\n\u003ch3\u003e예제: t-strings로 f-strings 구현하기 (Example: Implementing f-strings with t-strings)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003et-strings\u003c/code\u003e를 사용하여 \u003ccode\u003ef-strings\u003c/code\u003e를 \"구현\"하는 것은 쉽습니다. 즉, \u003ccode\u003ef-string\u003c/code\u003e 리터럴과 매우 유사하게 \u003ccode\u003eTemplate\u003c/code\u003e을 처리하고 동일한 결과를 반환하는 함수 \u003ccode\u003ef(template: Template) -\u003e str\u003c/code\u003e을 작성할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\nvalue = 42\r\ntemplated = t\"Hello {name!r}, value: {value:.2f}\"\r\nformatted = f\"Hello {name!r}, value: {value:.2f}\"\r\nassert f(templated) == formatted\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ef()\u003c/code\u003e 함수는 \u003ccode\u003e!r\u003c/code\u003e과 같은 변환 지정자와 \u003ccode\u003e:.2f\u003c/code\u003e와 같은 형식 지정자(format specifiers)를 모두 지원합니다. 전체 코드는 매우 간단합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom string.templatelib import Template, Interpolation\r\nfrom typing import Literal\r\n\r\ndef convert(value: object, conversion: Literal[\"a\", \"r\", \"s\"] | None) -\u003e object:\r\n    if conversion == \"a\":\r\n        return ascii(value)\r\n    elif conversion == \"r\":\r\n        return repr(value)\r\n    elif conversion == \"s\":\r\n        return str(value)\r\n    return value\r\n\r\ndef f(template: Template) -\u003e str:\r\n    parts = []\r\n    for item in template:\r\n        match item:\r\n            case str() as s:\r\n                parts.append(s)\r\n            case Interpolation(value, _, conversion, format_spec):\r\n                value = convert(value, conversion)\r\n                value = format(value, format_spec)\r\n                parts.append(value)\r\n    return \"\".join(parts)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e예제: 구조화된 로깅 (Example: Structured Logging)\u003c/h3\u003e\n\u003cp\u003e구조화된 로깅을 통해 개발자는 JSON과 같은 기계가 읽을 수 있는 형식으로 데이터를 로깅할 수 있습니다. \u003ccode\u003et-strings\u003c/code\u003e를 사용하면 개발자는 단일 로그 문만으로 사람이 읽을 수 있는 메시지와 함께 구조화된 데이터를 쉽게 로깅할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e템플릿 문자열로 구조화된 로깅을 구현하는 두 가지 다른 접근 방식을 제시합니다.\u003c/p\u003e\n\u003ch4\u003e접근 방식 1: 커스텀 로그 메시지 (Approach 1: Custom Log Messages)\u003c/h4\u003e\n\u003cp\u003ePython Logging Cookbook에는 구조화된 로깅을 구현하는 방법에 대한 짧은 섹션이 있습니다.\u003c/p\u003e\n\u003cp\u003e로깅 Cookbook은 간단한 텍스트 메시지와 별도의 값 딕셔너리로 구성되는 새로운 \"메시지\" 클래스 \u003ccode\u003eStructuredMessage\u003c/code\u003e를 생성할 것을 제안합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003emessage = StructuredMessage(\"user action\", {\r\n    \"action\": \"traded\",\r\n    \"amount\": 42,\r\n    \"item\": \"shrubs\"\r\n})\r\nlogging.info(message)\r\n# 출력:\r\n# user action \u003e\u003e\u003e {\"action\": \"traded\", \"amount\": 42, \"item\": \"shrubs\"}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eStructuredMessage.__str__()\u003c/code\u003e 메서드는 사람이 읽을 수 있는 메시지와 값을 모두 형식화하여 최종 문자열로 결합합니다.\u003c/p\u003e\n\u003cp\u003e템플릿 문자열을 사용하여 \u003ccode\u003eStructuredMessage\u003c/code\u003e의 개선된 버전을 구현할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport json\r\nimport logging\r\nfrom string.templatelib import Interpolation, Template\r\nfrom typing import Mapping\r\n\r\nclass TemplateMessage:\r\n    def __init__(self, template: Template) -\u003e None:\r\n        self.template = template\r\n\r\n    @property\r\n    def message(self) -\u003e str:\r\n        # 이전 예제의 f() 함수를 사용\r\n        return f(self.template)\r\n\r\n    @property\r\n    def values(self) -\u003e Mapping[str, object]:\r\n        return {\r\n            item.expression: item.value\r\n            for item in self.template if isinstance(item, Interpolation)\r\n        }\r\n\r\n    def __str__(self) -\u003e str:\r\n        return f\"{self.message} \u003e\u003e\u003e {json.dumps(self.values)}\"\r\n\r\n_ = TemplateMessage # 선택 사항, 가독성 향상\r\naction, amount, item = \"traded\", 42, \"shrubs\"\r\nlogging.info(_(t\"User {action}: {amount:.2f} {item}\"))\r\n# 출력:\r\n# User traded: 42.00 shrubs \u003e\u003e\u003e {\"action\": \"traded\", \"amount\": 42, \"item\": \"shrubs\"}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e템플릿 문자열은 커스텀 메시지 클래스를 정의하는 더 우아한 방법을 제공합니다. 템플릿 문자열을 사용하면 개발자는 더 이상 형식 문자열과 값 딕셔너리가 동기화되도록 신경 쓸 필요가 없습니다. 단일 템플릿 문자열 리터럴만 있으면 됩니다. \u003ccode\u003eTemplateMessage\u003c/code\u003e 구현은 \u003ccode\u003eInterpolation.expression\u003c/code\u003e 및 \u003ccode\u003eInterpolation.value\u003c/code\u003e 속성에서 구조화된 키와 값을 자동으로 추출할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e접근 방식 2: 커스텀 포맷터 (Approach 2: Custom Formatters)\u003c/h4\u003e\n\u003cp\u003e커스텀 메시지는 구조화된 로깅에 대한 합리적인 접근 방식이지만 약간 어색할 수 있습니다. 이를 사용하려면 개발자는 작성하는 모든 로그 메시지를 커스텀 클래스로 래핑해야 합니다. 이는 잊기 쉬울 수 있습니다.\u003c/p\u003e\n\u003cp\u003e대안적인 접근 방식은 커스텀 \u003ccode\u003elogging.Formatter\u003c/code\u003e 클래스를 정의하는 것입니다. 이 접근 방식은 더 유연하며 최종 출력에 대한 더 많은 제어를 허용합니다. 특히, 단일 템플릿 문자열을 가져와 여러 형식(사람이 읽을 수 있는 형식 및 JSON)으로 별도의 로그 스트림으로 출력하는 것이 가능합니다.\u003c/p\u003e\n\u003cp\u003e사람이 읽을 수 있는 출력을 위한 \u003ccode\u003eMessageFormatter\u003c/code\u003e와 JSON 출력을 위한 \u003ccode\u003eValuesFormatter\u003c/code\u003e라는 두 개의 간단한 포맷터를 정의합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport json\r\nimport logging\r\nfrom logging import Formatter, LogRecord\r\nfrom string.templatelib import Interpolation, Template\r\nfrom typing import Any, Mapping\r\n\r\nclass MessageFormatter(Formatter):\r\n    def message(self, template: Template) -\u003e str:\r\n        # 이전 예제의 f() 함수를 사용\r\n        return f(template)\r\n\r\n    def format(self, record: LogRecord) -\u003e str:\r\n        msg = record.msg\r\n        if not isinstance(msg, Template):\r\n            return super().format(record)\r\n        return self.message(msg)\r\n\r\nclass ValuesFormatter(Formatter):\r\n    def values(self, template: Template) -\u003e Mapping[str, Any]:\r\n        return {\r\n            item.expression: item.value\r\n            for item in template if isinstance(item, Interpolation)\r\n        }\r\n\r\n    def format(self, record: LogRecord) -\u003e str:\r\n        msg = record.msg\r\n        if not isinstance(msg, Template):\r\n            return super().format(record)\r\n        return json.dumps(self.values(msg))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 로거를 구성할 때 이 포맷터들을 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport logging\r\nimport sys\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\nmessage_handler = logging.StreamHandler(sys.stdout)\r\nmessage_handler.setFormatter(MessageFormatter())\r\nlogger.addHandler(message_handler)\r\n\r\nvalues_handler = logging.StreamHandler(sys.stderr)\r\nvalues_handler.setFormatter(ValuesFormatter())\r\nlogger.addHandler(values_handler)\r\n\r\naction, amount, item = \"traded\", 42, \"shrubs\"\r\nlogger.info(t\"User {action}: {amount:.2f} {item}\")\r\n# sys.stdout으로 출력:\r\n# User traded: 42.00 shrubs\r\n# 동시에, sys.stderr으로 출력:\r\n# {\"action\": \"traded\", \"amount\": 42, \"item\": \"shrubs\"}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 접근 방식은 구조화된 로깅에 대한 커스텀 메시지 접근 방식에 비해 몇 가지 장점이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e개발자는 커스텀 클래스로 래핑하지 않고도 \u003ccode\u003et-string\u003c/code\u003e을 직접 로깅할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e사람이 읽을 수 있는 출력과 구조화된 출력을 별도의 로그 스트림으로 보낼 수 있습니다. 이는 사람이 읽을 수 있는 데이터와 독립적으로 구조화된 데이터를 처리하는 로그 집계 시스템에 유용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e예제: HTML 템플릿 (Example: HTML Templating)\u003c/h3\u003e\n\u003cp\u003e이 PEP에는 여러 짧은 HTML 템플릿 예제가 포함되어 있습니다. \"동기 (Motivation)\" 섹션(및 이 PEP의 다른 몇 군데)에 언급된 \"가상의\" \u003ccode\u003ehtml()\u003c/code\u003e 함수가 존재하며 \u003ccode\u003epep750-examples\u003c/code\u003e 저장소에서 사용할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ef-strings\u003c/code\u003e와 마찬가지로 템플릿 문자열의 사용은 이전 버전과의 구문적 하위 호환성을 깨는 요소가 됩니다.\u003c/p\u003e\n\u003ch2\u003e보안 영향 (Security Implications)\u003c/h2\u003e\n\u003cp\u003e보간과 관련하여 템플릿 문자열 작업의 보안 영향은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e스코프(Scope) 조회는 \u003ccode\u003ef-strings\u003c/code\u003e와 동일합니다(어휘적 스코프). 이 모델은 실제로 잘 작동하는 것으로 나타났습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTemplate\u003c/code\u003e 인스턴스를 처리하는 코드는 모든 보간이 나타나는 컨텍스트를 존중하는 등 안전한 방식으로 처리되도록 보장할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e교육 방법 (How To Teach This)\u003c/h2\u003e\n\u003cp\u003e템플릿 문자열에는 여러 대상이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e템플릿 문자열 및 처리 함수를 사용하는 개발자\u003c/li\u003e\n\u003cli\u003e템플릿 처리 코드의 작성자\u003c/li\u003e\n\u003cli\u003e템플릿 문자열로 흥미로운 메커니즘을 구축하는 프레임워크 작성자\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e개발자를 교육하는 것은 간단할 것으로 예상됩니다. 언뜻 보기에 템플릿 문자열은 \u003ccode\u003ef-strings\u003c/code\u003e와 똑같이 생겼습니다. 문법은 친숙하고 스코핑 규칙은 동일하게 유지됩니다.\u003c/p\u003e\n\u003cp\u003e개발자가 가장 먼저 배워야 할 것은 템플릿 문자열 리터럴이 문자열로 평가되지 않고, 새로운 타입인 \u003ccode\u003eTemplate\u003c/code\u003e으로 평가된다는 것입니다. 이는 템플릿 처리 코드에 의해 사용될 의도로 만들어진 간단한 타입입니다. 개발자가 처리 함수를 호출해야만 원하는 결과(일반적으로 문자열)를 얻을 수 있으며, 물론 처리 코드는 임의의 타입을 반환할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e개발자는 또한 템플릿 문자열이 \u003ccode\u003ef-strings\u003c/code\u003e 및 \u003ccode\u003estr.format()\u003c/code\u003e과 같은 다른 문자열 형식화 방법과 어떻게 관련되는지 이해해야 할 것입니다. 각 방법을 언제 사용해야 할지 결정해야 합니다. 간단한 문자열만 필요하고 보안 영향이 없다면 \u003ccode\u003ef-strings\u003c/code\u003e가 최선의 선택일 것입니다. 형식 문자열이 사용되는 대부분의 경우, 템플릿 문자열 생성을 래핑하는 함수로 대체할 수 있습니다. 형식 문자열이 사용자 입력, 파일 시스템 또는 데이터베이스에서 얻어지는 경우, 원한다면 이를 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스로 변환하는 코드를 작성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e개발자는 \u003ccode\u003et-strings\u003c/code\u003e가 거의 항상 처리 함수와 함께 사용된다는 것을 배울 것이기 때문에 \u003ccode\u003eTemplate\u003c/code\u003e 타입의 세부 사항을 반드시 이해할 필요는 없습니다. 디스크립터(descriptors) 및 데코레이터(decorators)와 마찬가지로, \u003ccode\u003et-string\u003c/code\u003e 처리 함수를 작성하는 개발자보다 \u003ccode\u003et-strings\u003c/code\u003e를 사용하는 개발자가 훨씬 더 많을 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e시간이 지남에 따라 소수의 더 고급 개발자들은 자체 템플릿 처리 코드를 작성하기를 원할 것입니다. 처리 코드를 작성하는 것은 종종 형식 문법(formal grammars)의 관점에서 생각해야 합니다. 개발자는 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스의 \u003ccode\u003estrings\u003c/code\u003e 및 \u003ccode\u003einterpolation\u003c/code\u003e 속성과 함께 작업하는 방법과 컨텍스트에 민감한 방식으로 보간을 처리하는 방법을 배워야 합니다. 더 정교한 문법은 추상 구문 트리(AST)와 같은 중간 표현(intermediate representations)으로 파싱해야 할 가능성이 높습니다. 훌륭한 템플릿 처리 코드는 적절할 때 형식 지정자 및 변환을 처리할 것입니다. 프로덕션 수준의 템플릿 처리 코드(예: HTML 템플릿을 지원하기 위한)를 작성하는 것은 큰 작업이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e템플릿 문자열은 프레임워크 작성자에게 도구 상자에 강력한 새 도구를 제공할 것으로 예상됩니다. 템플릿 문자열의 기능이 템플릿 엔진과 같은 기존 도구와 겹치지만, \u003ccode\u003et-strings\u003c/code\u003e는 해당 로직을 언어 자체로 옮깁니다. Python의 모든 강력함과 일반성을 문자열 처리 작업에 적용하는 것은 프레임워크 작성자에게 새로운 가능성을 열어줍니다.\u003c/p\u003e\n\u003ch2\u003e또 다른 템플릿 접근 방식이 필요한 이유 (Why another templating approach?)\u003c/h2\u003e\n\u003cp\u003ePython 세계에는 Jinja와 같이 널리 채택된 성숙한 템플릿 언어가 이미 존재합니다. 새로운 템플릿 시스템 생성을 위한 지원을 구축하는 이유는 무엇일까요?\u003c/p\u003e\n\u003cp\u003eJinja와 같은 프로젝트는 템플릿이 개발자에 의한 소프트웨어의 일부라기보다는 디자이너 또는 심지어 사용자(예: CMS)가 생성한 콘텐츠의 일부인 경우 여전히 필요합니다.\u003c/p\u003e\n\u003cp\u003e프런트엔드 개발의 추세는 템플릿을 소프트웨어의 일부로 간주하고 개발자가 작성합니다. 그들은 최신 언어 기능과 좋은 툴링 경험을 원합니다. PEP 750은 비정적 부분이 Python인 DSL(Domain-Specific Languages)을 구상합니다. 즉, 동일한 스코프 규칙, 타이핑, 표현식 구문 등을 가집니다.\u003c/p\u003e\n\u003ch2\u003e템플릿 처리에서 흔히 볼 수 있는 패턴 (Common Patterns Seen in Processing Templates)\u003c/h2\u003e\n\u003ch3\u003e구조적 패턴 매칭 (Structural Pattern Matching)\u003c/h3\u003e\n\u003cp\u003e구조적 패턴 매칭을 사용하여 \u003ccode\u003eTemplate\u003c/code\u003e을 반복하는 것은 많은 템플릿 함수 구현에서 예상되는 모범 사례입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom string.templatelib import Template, Interpolation\r\nfrom typing import Any\r\n\r\ndef process(template: Template) -\u003e Any:\r\n    for item in template:\r\n        match item:\r\n            case str() as s:\r\n                ... # 각 문자열 부분 처리\r\n            case Interpolation() as interpolation:\r\n                ... # 각 보간 처리\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e처리 코드는 \u003ccode\u003eInterpolation\u003c/code\u003e 타입의 속성에 대해 하위 매칭(sub-match)하는 것이 일반적일 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ematch arg:\r\n    case Interpolation(int()):\r\n        ... # 정수 값을 가진 보간 처리\r\n    case Interpolation(value=str() as s):\r\n        ... # 문자열 값을 가진 보간 처리\r\n    # 등등\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e메모이제이션 (Memoizing)\u003c/h3\u003e\n\u003cp\u003e템플릿 함수는 템플릿의 정적 및 동적 부분을 효율적으로 처리할 수 있습니다. \u003ccode\u003eTemplate\u003c/code\u003e 객체의 구조는 효과적인 메모이제이션(memoization)을 허용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003estrings = template.strings # 정적 문자열 부분\r\nvalues = template.values # 동적 보간된 값\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 분리를 통해 처리된 정적 부분은 캐시하고 동적 부분은 필요에 따라 삽입할 수 있습니다. 템플릿 처리 코드의 작성자는 정적 문자열을 캐시 키로 사용하여 유사한 템플릿이 반복적으로 사용될 때 상당한 성능 향상을 이끌어낼 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e중간 표현으로 파싱 (Parsing to Intermediate Representations)\u003c/h3\u003e\n\u003cp\u003e템플릿을 처리하는 코드는 템플릿 문자열을 AST(Abstract Syntax Tree)와 같은 중간 표현으로 파싱할 수 있습니다. 많은 템플릿 처리 라이브러리가 이 접근 방식을 사용할 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 우리의 이론적인 \u003ccode\u003ehtml()\u003c/code\u003e 함수(\u003ccode\u003eMotivation\u003c/code\u003e 섹션 참조)는 \u003ccode\u003estr\u003c/code\u003e을 반환하는 대신 동일한 패키지에 정의된 HTML \u003ccode\u003eElement\u003c/code\u003e를 반환할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom dataclasses import dataclass\r\nfrom typing import Mapping, Sequence\r\n\r\n@dataclass(frozen=True)\r\nclass Element:\r\n    tag: str\r\n    attributes: Mapping[str, str | bool]\r\n    children: Sequence[str | Element]\r\n\r\n    def __str__(self) -\u003e str: ...\r\n\r\ndef html(template: Template) -\u003e Element: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 \u003ccode\u003estr(element)\u003c/code\u003e를 호출하면 HTML이 렌더링되지만, 그동안 \u003ccode\u003eElement\u003c/code\u003e는 다양한 방식으로 조작될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e컨텍스트에 민감한 보간 처리 (Context-sensitive Processing of Interpolations)\u003c/h3\u003e\n\u003cp\u003e가상의 \u003ccode\u003ehtml()\u003c/code\u003e 함수를 계속해서, 이를 컨텍스트에 민감하게 만들 수 있습니다. 보간은 템플릿에 나타나는 위치에 따라 다르게 처리될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003ehtml()\u003c/code\u003e 함수는 여러 종류의 보간을 지원할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eattributes = {\"id\": \"main\"}\r\nattribute_value = \"shrubbery\"\r\ncontent = \"hello\"\r\ntemplate = t\"\u0026#x3C;div {attributes} data-value={attribute_value}\u003e{content}\u0026#x3C;/div\u003e\"\r\nelement = html(template)\r\nassert str(element) == '\u0026#x3C;div id=\"main\" data-value=\"shrubbery\"\u003ehello\u0026#x3C;/div\u003e'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e{attributes}\u003c/code\u003e 보간은 HTML 태그 컨텍스트에서 발생하고 해당하는 속성 이름이 없기 때문에 속성 딕셔너리로 처리됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e{attribute_value}\u003c/code\u003e 보간은 단순한 문자열 값으로 처리되고 최종 문자열에 포함되기 전에 인용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e{content}\u003c/code\u003e 보간은 잠재적으로 안전하지 않은 콘텐츠로 처리되고 최종 문자열에 포함되기 전에 이스케이프됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e중첩된 템플릿 문자열 (Nested Template Strings)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ehtml()\u003c/code\u003e 함수로 한 단계 더 나아가 중첩된 템플릿 문자열을 지원할 수 있습니다. 이를 통해 더 간단한 템플릿으로 더 복잡한 HTML 구조를 구축할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\ncontent = html(t\"\u0026#x3C;p\u003eHello {name}\u0026#x3C;/p\u003e\")\r\ntemplate = t\"\u0026#x3C;div\u003e{content}\u0026#x3C;/div\u003e\"\r\nelement = html(template)\r\nassert str(element) == '\u0026#x3C;div\u003e\u0026#x3C;p\u003eHello World\u0026#x3C;/p\u003e\u0026#x3C;/div\u003e'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e{content}\u003c/code\u003e 보간은 \u003ccode\u003eElement\u003c/code\u003e 인스턴스이므로 최종 문자열에 포함되기 전에 이스케이프될 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehtml()\u003c/code\u003e 함수에 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스가 전달되면 중첩된 템플릿에 대해 재귀적으로 자신을 호출하여 자동으로 \u003ccode\u003eElement\u003c/code\u003e로 변환할 수 있다는 멋진 단순화를 상상할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e템플릿의 중첩 및 구성은 템플릿 처리 코드에서 일반적인 패턴이 될 것이며, 적절한 경우 단순한 문자열 연결보다 선호될 것으로 예상됩니다.\u003c/p\u003e\n\u003ch3\u003e지연 평가 접근 방식 (Approaches to Lazy Evaluation)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ef-strings\u003c/code\u003e와 마찬가지로 \u003ccode\u003et-string\u003c/code\u003e 리터럴의 보간은 즉시 평가됩니다. 그러나 지연 평가(lazy evaluation)가 바람직할 수 있는 경우가 있습니다.\u003c/p\u003e\n\u003cp\u003e단일 보간이 평가하는 데 비용이 많이 드는 경우, 템플릿 문자열 리터럴에서 람다로 명시적으로 래핑할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\ntemplate = t\"Hello {(lambda: name)}\"\r\nassert callable(template.interpolations[0].value)\r\nassert template.interpolations[0].value() == \"World\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e물론, 이는 템플릿 처리 코드가 호출 가능한 보간 값을 예상하고 처리한다고 가정합니다. (이터레이터(iterators), 어웨이터블(awaitables) 등도 지원할 수 있다고 상상할 수 있습니다.) 이는 PEP의 요구 사항은 아니지만, 템플릿 처리 코드에서 일반적인 패턴입니다.\u003c/p\u003e\n\u003cp\u003e일반적으로 커뮤니티가 템플릿 문자열에서 보간의 지연 평가에 대한 모범 사례를 개발하고, 합리적인 경우 공통 라이브러리가 템플릿 처리 코드에서 호출 가능한 또는 어웨이터블(awaitable) 값을 지원하기를 바랍니다.\u003c/p\u003e\n\u003ch3\u003e비동기 평가 접근 방식 (Approaches to Asynchronous Evaluation)\u003c/h3\u003e\n\u003cp\u003e지연 평가와 밀접하게 관련된 것은 비동기 평가(asynchronous evaluation)입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ef-strings\u003c/code\u003e와 마찬가지로 \u003ccode\u003eawait\u003c/code\u003e 키워드는 보간에서 허용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport asyncio\r\n\r\nasync def example():\r\n    async def get_name() -\u003e str:\r\n        await asyncio.sleep(1)\r\n        return \"Sleepy\"\r\n    # f() 함수는 이전 f-string 예제에서 가져옴\r\n    assert f(t\"Hello {await get_name()}\") == \"Hello Sleepy\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e더 정교한 템플릿 처리 코드는 이를 활용하여 보간에서 비동기 작업을 수행할 수 있습니다. 예를 들어, \"스마트한\" 처리 함수는 보간이 어웨이터블임을 예상하고 템플릿 문자열을 처리하기 전에 \u003ccode\u003eawait\u003c/code\u003e할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport asyncio\r\n\r\nasync def async_f(template: Template) -\u003e str:\r\n    # ... async 처리 로직\r\n    pass\r\n\r\nasync def example():\r\n    async def get_name() -\u003e str:\r\n        await asyncio.sleep(1)\r\n        return \"Sleepy\"\r\n    template = t\"Hello {get_name}\"\r\n    assert await async_f(template) == \"Hello Sleepy\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 \u003ccode\u003easync_f()\u003c/code\u003e의 템플릿 처리 코드가 비동기적이고 보간 값(\u003ccode\u003eget_name\u003c/code\u003e 코루틴)을 \u003ccode\u003eawait\u003c/code\u003e할 수 있다고 가정합니다.\u003c/p\u003e\n\u003ch3\u003e템플릿 재사용 접근 방식 (Approaches to Template Reuse)\u003c/h3\u003e\n\u003cp\u003e개발자가 다른 값으로 템플릿 문자열을 여러 번 재사용하려면 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스를 반환하는 함수를 작성할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef reusable(name: str, question: str) -\u003e Template:\r\n    return t\"Hello {name}, {question}?\"\r\n\r\ntemplate1 = reusable(\"friend\", \"how are you\")\r\ntemplate2 = reusable(\"King Arthur\", \"what is your quest\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e물론 이는 \u003ccode\u003ef-strings\u003c/code\u003e가 재사용될 수 있는 방식과 다르지 않습니다.\u003c/p\u003e\n\u003ch3\u003e형식 문자열과의 관계 (Relation to Format Strings)\u003c/h3\u003e\n\u003cp\u003e오래된 \u003ccode\u003estr.format()\u003c/code\u003e 메서드는 나중에 값을 형식화하는 데 사용할 수 있는 형식 문자열(format strings)을 허용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ealas_fmt = \"We're all out of {cheese}.\"\r\nassert alas_fmt.format(cheese=\"Red Leicester\") == \"We're all out of Red Leicester.\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e형식 문자열을 일종의 함수 정의로 생각할 수 있습니다. \u003ccode\u003estr.format()\u003c/code\u003e 호출은 일종의 함수 호출로 볼 수 있습니다. \u003ccode\u003et-string\u003c/code\u003e의 해당 기능은 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스를 반환하는 표준 Python 함수를 정의하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef make_template(*, cheese: str) -\u003e Template:\r\n    return t\"We're all out of {cheese}.\"\r\n\r\ntemplate = make_template(cheese=\"Red Leicester\")\r\n# 위 f-string 예제의 f() 함수를 사용\r\nassert f(template) == \"We're all out of Red Leicester.\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003emake_template()\u003c/code\u003e 함수 자체는 형식 문자열과 유사하다고 생각할 수 있습니다. \u003ccode\u003emake_template()\u003c/code\u003e 호출은 \u003ccode\u003estr.format()\u003c/code\u003e 호출과 유사합니다.\u003c/p\u003e\n\u003cp\u003e물론, 파일 시스템이나 데이터베이스와 같은 외부 소스에서 형식 문자열을 로드하는 것이 일반적입니다. 다행히 \u003ccode\u003eTemplate\u003c/code\u003e 및 \u003ccode\u003eInterpolation\u003c/code\u003e은 단순한 Python 타입이므로, 이전 스타일의 형식 문자열을 가져와 동등한 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스를 반환하는 함수를 작성할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef from_format(fmt: str, /, *args: object, **kwargs: object) -\u003e Template:\r\n    \"\"\"`fmt`를 파싱하고 `Template` 인스턴스를 반환합니다.\"\"\"\r\n    ...\r\n\r\n# 파일, 데이터베이스 등에서 로드\r\nfmt = \"We're all out of {cheese}.\"\r\ntemplate = from_format(fmt, cheese=\"Red Leicester\")\r\n# 위 f-string 예제의 f() 함수를 사용\r\nassert f(template) == \"We're all out of Red Leicester.\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 개발자가 이전에 형식 문자열을 사용했을 곳에 템플릿 문자열을 사용할 수 있도록 하는 강력한 패턴입니다. \u003ccode\u003efrom_format()\u003c/code\u003e의 전체 구현은 예제 저장소에서 사용할 수 있으며, 형식 문자열의 전체 문법을 지원합니다.\u003c/p\u003e\n\u003ch2\u003e참조 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003ePEP 750의 CPython 구현이 제공됩니다.\u003c/p\u003e\n\u003cp\u003e또한 참조 구현을 기반으로 구축된 예제 및 테스트의 공개 저장소가 있습니다. 템플릿 문자열을 가지고 놀고 싶다면 이 저장소가 시작하기에 좋은 곳입니다.\u003c/p\u003e\n\u003ch2\u003e거부된 아이디어 (Rejected Ideas)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 여러 중요한 개정판을 거쳤습니다. 또한 PEP 501의 개정판과 Discourse 논의에서 상당히 많은 흥미로운 아이디어들이 고려되었습니다.\u003c/p\u003e\n\u003cp\u003e고려되었지만 거부된 가장 중요한 아이디어들을 문서화하려고 합니다.\u003c/p\u003e\n\u003ch3\u003e임의의 문자열 리터럴 접두사 (Arbitrary String Literal Prefixes)\u003c/h3\u003e\n\u003cp\u003eJavaScript 태그된 템플릿 리터럴(tagged template literals)에서 영감을 받아, 이 PEP의 이전 버전은 리터럴 문자열 앞에 임의의 \"태그\" 접두사를 허용했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003emy_tag'Hello {name}'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e접두사는 \"태그 함수(tag function)\"라고 불리는 특별한 호출 가능한(callable) 객체였습니다. 태그 함수는 인자 목록으로 템플릿 문자열의 부분들을 받았습니다. 그런 다음 문자열을 처리하고 임의의 값을 반환할 수 있었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef my_tag(*args: str | Interpolation) -\u003e Any: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 접근 방식은 여러 가지 이유로 거부되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e완전한 일반성을 구축하기에는 너무 복잡하다고 판단되었습니다. JavaScript는 템플릿 문자열 앞에 임의의 표현식을 허용하며, 이는 Python에서 구현하기에 상당한 도전입니다.\u003c/li\u003e\n\u003cli\u003e새로운 문자열 접두사의 향후 도입을 배제했습니다.\u003c/li\u003e\n\u003cli\u003e네임스페이스를 불필요하게 오염시키는 것으로 보였습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단일 \u003ccode\u003et\u003c/code\u003e 접두사를 사용하는 것이 더 간단하고 Python스러운 접근 방식이며, \u003ccode\u003ef-strings\u003c/code\u003e의 일반화로서 템플릿 문자열의 역할과 더 일치한다고 판단되었습니다.\u003c/p\u003e\n\u003ch3\u003e보간의 지연 평가 (Delayed Evaluation of Interpolations)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 초기 버전은 보간이 지연 평가되어야 한다고 제안했습니다. 모든 보간은 암시적 람다로 \"래핑\"되었습니다. 즉시 평가되는 \u003ccode\u003evalue\u003c/code\u003e 속성 대신, 보간에는 보간 값을 해결하는 \u003ccode\u003egetvalue()\u003c/code\u003e 메서드가 있었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Interpolation:\r\n    ...\r\n    _value: Callable[[], object]\r\n    def getvalue(self) -\u003e object:\r\n        return self._value()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 여러 가지 이유로 거부되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e템플릿 문자열의 압도적인 대다수 사용 사례는 자연스럽게 즉시 평가를 요구합니다.\u003c/li\u003e\n\u003cli\u003e지연 평가는 \u003ccode\u003ef-strings\u003c/code\u003e의 동작과 상당한 차이가 있을 것입니다.\u003c/li\u003e\n\u003cli\u003e암시적 람다 래핑은 타입 힌트(type hints) 및 정적 분석(static analysis)에 어려움을 초래합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e가장 중요하게도, 지연 평가가 바람직한 많은 경우에 암시적 람다 래핑에 대한 실현 가능한(완벽하지는 않지만) 대안이 있습니다. 자세한 내용은 위의 \"Approaches to Lazy Evaluation\" 섹션을 참조하십시오.\u003c/p\u003e\n\u003cp\u003e이 PEP에서는 지연 평가가 거부되었지만, 커뮤니티가 이 아이디어를 계속 탐구하기를 바랍니다.\u003c/p\u003e\n\u003ch3\u003eTemplate 및 Interpolation을 프로토콜로 만들기 (Making Template and Interpolation Into Protocols)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 초기 버전은 \u003ccode\u003eTemplate\u003c/code\u003e 및 \u003ccode\u003eInterpolation\u003c/code\u003e 타입을 클래스 대신 런타임 검사 가능 프로토콜(runtime checkable protocols)로 제안했습니다.\u003c/p\u003e\n\u003cp\u003e결론적으로, 클래스를 사용하는 것이 더 간단하다고 판단되었습니다.\u003c/p\u003e\n\u003ch3\u003eTemplate 및 Interpolation에 대한 __eq__ 및 __hash__ 오버라이드 (Overridden \u003cstrong\u003eeq\u003c/strong\u003e and \u003cstrong\u003ehash\u003c/strong\u003e for Template and Interpolation)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 이전 버전은 \u003ccode\u003eTemplate\u003c/code\u003e 및 \u003ccode\u003eInterpolation\u003c/code\u003e 타입이 자체 \u003ccode\u003e__eq__\u003c/code\u003e 및 \u003ccode\u003e__hash__\u003c/code\u003e 구현을 가져야 한다고 제안했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e템플릿은 \u003ccode\u003estrings\u003c/code\u003e 및 \u003ccode\u003einterpolations\u003c/code\u003e가 같으면 같다고 간주되었습니다.\u003c/li\u003e\n\u003cli\u003e보간은 \u003ccode\u003evalue\u003c/code\u003e, \u003ccode\u003eexpression\u003c/code\u003e, \u003ccode\u003econversion\u003c/code\u003e, \u003ccode\u003eformat_spec\u003c/code\u003e이 같으면 같다고 간주되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eInterpolation\u003c/code\u003e 해싱은 튜플 해싱과 유사했습니다. 즉, \u003ccode\u003eInterpolation\u003c/code\u003e은 \u003ccode\u003evalue\u003c/code\u003e가 해시 가능할 때만 해시 가능했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이것은 \u003ccode\u003eTemplate.__hash__\u003c/code\u003e가 템플릿 처리 코드에서 캐시 키로 유용하지 않기 때문에 거부되었습니다. 이는 개발자에게 혼란을 줄 수 있다는 우려가 있었습니다.\u003c/p\u003e\n\u003cp\u003e이러한 \u003ccode\u003e__eq__\u003c/code\u003e 및 \u003ccode\u003e__hash__\u003c/code\u003e 구현을 삭제함으로써 다음과 같은 assert를 작성할 수 있는 능력을 잃게 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ename = \"World\"\r\nassert t\"Hello \" + t\"{name}\" == t\"Hello {name}\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eTemplate\u003c/code\u003e 인스턴스가 추가 코드에 의해 빠르게 처리될 의도이므로, 이러한 assert의 유용성은 제한적이라고 판단했습니다.\u003c/p\u003e\n\u003ch3\u003e추가 Decoded 타입 (An Additional Decoded Type)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 초기 버전은 템플릿 문자열의 \"정적 문자열\" 부분을 나타내기 위한 \u003ccode\u003eDecoded\u003c/code\u003e라는 추가 타입을 제안했습니다. 이 타입은 \u003ccode\u003estr\u003c/code\u003e에서 파생되었으며, 문자열의 원래 텍스트를 제공하는 단일 \u003ccode\u003eraw\u003c/code\u003e 속성을 가졌습니다. 우리는 일반 \u003ccode\u003estr\u003c/code\u003e을 사용하고 \u003ccode\u003er\u003c/code\u003e 및 \u003ccode\u003et\u003c/code\u003e 접두사의 조합을 허용하는 더 간단한 접근 방식을 선호하여 이를 거부했습니다.\u003c/p\u003e\n\u003ch3\u003eTemplate 및 Interpolation의 최종 위치 (The Final Home for Template and Interpolation)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 이전 버전은 \u003ccode\u003eTemplate\u003c/code\u003e 및 \u003ccode\u003eInterpolation\u003c/code\u003e 타입을 \u003ccode\u003etypes\u003c/code\u003e, \u003ccode\u003ecollections\u003c/code\u003e, \u003ccode\u003ecollections.abc\u003c/code\u003e, 심지어 새로운 최상위 모듈인 \u003ccode\u003etemplatelib\u003c/code\u003e에 배치할 것을 제안했습니다. 최종 결정은 \u003ccode\u003estring.templatelib\u003c/code\u003e에 배치하는 것이었습니다.\u003c/p\u003e\n\u003ch3\u003e원본 템플릿 리터럴의 완전한 재구성 활성화 (Enable Full Reconstruction of Original Template Literal)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 이전 버전은 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스에서 원본 템플릿 문자열의 텍스트를 완전히 재구성할 수 있도록 시도했습니다. 이는 지나치게 복잡하다고 판단되어 거부되었습니다. 템플릿 리터럴 소스와 기본 AST 간의 매핑은 일대일이 아니며, 원본 소스 텍스트로 라운드 트립(round-tripping)하는 데 몇 가지 제한 사항이 있습니다.\u003c/p\u003e\n\u003cp\u003e첫째, \u003ccode\u003eInterpolation.format_spec\u003c/code\u003e은 제공되지 않으면 \u003ccode\u003e\"\"\u003c/code\u003e로 기본 설정됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003evalue = 42\r\ntemplate1 = t\"{value}\"\r\ntemplate2 = t\"{value:}\"\r\nassert template1.interpolations[0].format_spec == \"\"\r\nassert template2.interpolations[0].format_spec == \"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로, 디버그 지정자 \u003ccode\u003e=\u003c/code\u003e는 특수한 경우로 처리되며 AST가 생성되기 전에 처리됩니다. 따라서 \u003ccode\u003et\"{value=}\"\u003c/code\u003e와 \u003ccode\u003et\"value={value!r}\"\u003c/code\u003e를 구별하는 것은 불가능합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003evalue = 42\r\ntemplate1 = t\"{value=}\"\r\ntemplate2 = t\"value={value!r}\"\r\nassert template1.strings[0] == \"value=\"\r\nassert template1.interpolations[0].expression == \"value\"\r\nassert template1.interpolations[0].conversion == \"r\"\r\nassert template2.strings[0] == \"value=\"\r\nassert template2.interpolations[0].expression == \"value\"\r\nassert template2.interpolations[0].conversion == \"r\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, \u003ccode\u003ef-strings\u003c/code\u003e의 형식 지정자는 임의의 중첩을 허용합니다. 이 PEP 및 참조 구현에서는 지정자가 즉시 평가되어 \u003ccode\u003eInterpolation\u003c/code\u003e의 \u003ccode\u003eformat_spec\u003c/code\u003e을 설정하므로 원래 표현식을 잃게 됩니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003evalue = 42\r\nprecision = 2\r\ntemplate1 = t\"{value:.2f}\"\r\ntemplate2 = t\"{value:.{precision}f}\"\r\nassert template1.interpolations[0].format_spec == \".2f\"\r\nassert template2.interpolations[0].format_spec == \".2f\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 제한 사항이 실제로 중요한 문제가 될 것이라고는 예상하지 않습니다. 원본 템플릿 문자열 리터럴을 얻어야 하는 개발자는 항상 \u003ccode\u003einspect.getsource()\u003c/code\u003e 또는 유사한 도구를 사용할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e템플릿 연결 금지 (Disallowing Template Concatenation)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 이전 버전은 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스가 연결을 지원해서는 안 된다고 제안했습니다. 여러 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스의 연결을 허용하는 방향으로 거부되었습니다.\u003c/p\u003e\n\u003cp\u003e하나 또는 모든 형태의 연결을 거부하는 데는 합리적인 주장이 있습니다. 즉, 이는 잠재적인 버그 클래스를 차단하며, 특히 템플릿 문자열이 연결이 항상 동일한 의미(또는 어떤 의미도)를 갖지 않는 복잡한 문법을 포함할 것이라는 관점을 취할 때 그렇습니다.\u003c/p\u003e\n\u003cp\u003e더욱이, 이 PEP의 초기 버전은 JavaScript의 태그된 템플릿 리터럴에 더 가까운 구문을 제안했으며, 여기서 임의의 호출 가능한(callable) 객체를 문자열 리터럴의 접두사로 사용할 수 있었습니다. 호출 가능한 객체가 연결을 지원하는 타입을 반환한다는 보장이 없었습니다.\u003c/p\u003e\n\u003cp\u003e결론적으로, 새로운 문자열 타입이 연결을 지원하지 않는다는 것이 개발자들에게 줄 놀라움이 지원함으로써 발생하는 이론적인 해로움보다 클 것이라고 판단했습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 두 \u003ccode\u003eTemplate\u003c/code\u003e의 연결을 지원하지만, \u003ccode\u003eTemplate\u003c/code\u003e과 \u003ccode\u003estr\u003c/code\u003e의 연결은 지원하지 않습니다. 이는 \u003ccode\u003estr\u003c/code\u003e이 정적 문자열로 처리되어야 하는지 또는 보간으로 처리되어야 하는지 모호하기 때문입니다. 개발자는 위에서 설명한 대로 \u003ccode\u003estr\u003c/code\u003e을 다른 \u003ccode\u003eTemplate\u003c/code\u003e과 연결하기 전에 \u003ccode\u003eTemplate\u003c/code\u003e 인스턴스로 래핑해야 합니다.\u003c/p\u003e\n\u003cp\u003e템플릿 문자열을 사용하는 코드는 연결보다는 중첩 및 구성을 통해 더 큰 템플릿을 구축하는 것이 더 일반적일 것으로 예상됩니다.\u003c/p\u003e\n\u003ch3\u003e임의의 변환 값 (Arbitrary Conversion Values)\u003c/h3\u003e\n\u003cp\u003ePython은 가능한 변환 타입 값으로 \u003ccode\u003er\u003c/code\u003e, \u003ccode\u003es\u003c/code\u003e, 또는 \u003ccode\u003ea\u003c/code\u003e만 허용합니다. 다른 값을 할당하려고 하면 \u003ccode\u003eSyntaxError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003cp\u003e이론적으로 템플릿 함수는 다른 변환 타입을 처리하도록 선택할 수 있습니다. 그러나 이 PEP는 PEP 701을 엄격하게 준수합니다. 허용되는 값에 대한 모든 변경 사항은 별도의 PEP에서 다루어져야 합니다.\u003c/p\u003e\n\u003ch3\u003eInterpolation에서 conversion 제거 (Removing conversion From Interpolation)\u003c/h3\u003e\n\u003cp\u003e이 PEP를 초안 작성하는 동안 \u003ccode\u003eInterpolation\u003c/code\u003e에서 \u003ccode\u003econversion\u003c/code\u003e 속성을 제거하고, \u003ccode\u003eInterpolation.value\u003c/code\u003e가 설정되기 전에 변환이 즉시 수행되도록 지정하는 것을 고려했습니다.\u003c/p\u003e\n\u003cp\u003e이는 템플릿 처리 코드 작성 작업을 단순화하기 위한 것이었습니다. \u003ccode\u003econversion\u003c/code\u003e 속성은 확장성이 제한적입니다(\u003ccode\u003eLiteral[\"r\", \"s\", \"a\"] | None\u003c/code\u003e으로 타입 지정됨). 커스텀 형식 지정자로 더 잘 달성할 수 없는 템플릿 문자열에 상당한 가치나 유연성을 추가하는지는 명확하지 않습니다. 형식 지정자와 달리 Python의 내장 \u003ccode\u003eformat()\u003c/code\u003e과 동등한 것이 없습니다. (대신 \"Examples\" 섹션에 \u003ccode\u003econvert()\u003c/code\u003e의 샘플 구현을 포함합니다.)\u003c/p\u003e\n\u003cp\u003e궁극적으로 우리는 \u003ccode\u003ef-strings\u003c/code\u003e와의 호환성을 유지하고 향후 확장성을 허용하기 위해 \u003ccode\u003econversion\u003c/code\u003e 속성을 \u003ccode\u003eInterpolation\u003c/code\u003e 타입에 유지하기로 결정했습니다.\u003c/p\u003e\n\u003ch3\u003e대체 보간 기호 (Alternate Interpolation Symbols)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 초기 단계에서 템플릿 문자열에서 보간에 대한 대체 기호를 허용하는 것을 고려했습니다. 예를 들어, i18n 또는 다른 목적에 유용할 수 있다는 생각으로 \u003ccode\u003e{name}\u003c/code\u003e의 대안으로 \u003ccode\u003e${name}\u003c/code\u003e을 허용하는 것을 고려했습니다. 자세한 내용은 Discourse 스레드를 참조하십시오.\u003c/p\u003e\n\u003cp\u003e이는 \u003ccode\u003et-string\u003c/code\u003e 문법을 \u003ccode\u003ef-string\u003c/code\u003e 문법과 가능한 한 가깝게 유지하는 것을 선호하여 거부되었습니다.\u003c/p\u003e\n\u003ch3\u003eTemplate의 대체 레이아웃 (Alternate Layouts for Template)\u003c/h3\u003e\n\u003cp\u003e이 PEP 개발 중에 \u003ccode\u003eTemplate\u003c/code\u003e 타입에 대한 여러 대체 레이아웃을 고려했습니다. 많은 것들이 문자열과 보간을 모두 포함하는 단일 \u003ccode\u003eargs\u003c/code\u003e 튜플에 초점을 맞췄습니다. 변형에는 다음이 포함되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eargs\u003c/code\u003e는 \u003ccode\u003etuple[str | Interpolation, ...]\u003c/code\u003e이었고, 첫 번째 및 마지막 항목이 문자열이고 문자열과 보간이 항상 번갈아 나타난다는 약속이 있었습니다. 이는 \u003ccode\u003eargs\u003c/code\u003e가 항상 비어 있지 않고 인접한 보간 사이에 빈 문자열이 삽입됨을 의미했습니다. 이는 교대가 타입 시스템에 의해 포착될 수 없고 우리가 만들고자 하는 보장이 아니었기 때문에 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eargs\u003c/code\u003e는 \u003ccode\u003etuple[str | Interpolation, ...]\u003c/code\u003e으로 유지되었지만 인터리빙(interleaving)을 지원하지 않았습니다. 결과적으로 빈 문자열은 시퀀스에 추가되지 않았습니다. 더 이상 \u003ccode\u003eargs[::2]\u003c/code\u003e로 정적 문자열을 얻을 수 없었고, 대신 문자열과 보간을 구별하기 위해 인스턴스 검사 또는 구조적 패턴 매칭을 사용해야 했습니다. 이 접근 방식은 성능 최적화를 위한 향후 기회가 적다고 판단되어 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eargs\u003c/code\u003e는 \u003ccode\u003eSequence[tuple[str, Interpolation | None]]\u003c/code\u003e으로 타입 지정되었습니다. 각 정적 문자열은 인접한 보간과 쌍을 이루었습니다. 최종 문자열 부분에는 해당하는 보간이 없었습니다. 이는 지나치게 복잡하다고 판단되어 거부되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e템플릿 \"종류\"를 설명하는 메커니즘 (Mechanism to Describe the “Kind” of Template)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003et-strings\u003c/code\u003e가 인기를 얻으면 템플릿 문자열에서 발견되는 콘텐츠의 \"종류\"(예: \"sql\", \"html\", \"css\" 등)를 설명하는 방법이 유용할 수 있습니다. 이는 린터(linters), 포맷터(formatters), 타입 체커(type checkers), IDE와 같은 도구에서 강력한 새 기능을 가능하게 할 수 있습니다. (예를 들어, \u003ccode\u003et-strings\u003c/code\u003e에서 HTML을 포맷하는 \u003ccode\u003eblack\u003c/code\u003e이나 주어진 속성이 HTML 태그에 유효한지 확인하는 \u003ccode\u003emypy\u003c/code\u003e를 상상해 보세요.) 흥미롭기는 하지만, 이 PEP는 특정 메커니즘을 제안하지 않습니다. 시간이 지남에 따라 커뮤니티가 이 목적을 위한 규칙을 개발하기를 바랍니다.\u003c/p\u003e\n\u003ch3\u003e바이너리 템플릿 문자열 (Binary Template Strings)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003et-strings\u003c/code\u003e와 바이트(\u003ccode\u003etb\u003c/code\u003e)의 조합은 이 PEP의 범위를 벗어나는 것으로 간주됩니다. 그러나 \u003ccode\u003ef-strings\u003c/code\u003e와 달리 \u003ccode\u003et-strings\u003c/code\u003e와 바이트를 결합할 수 없는 근본적인 이유는 없습니다. 향후 PEP에서 지원이 고려될 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e감사의 말 (Acknowledgements)\u003c/h2\u003e\n\u003cp\u003e템플릿 문자열로 이어진 아이디어 개발에 기여해준 Ryan Morshead에게 감사드립니다. 또한 몇 년 전에 유사한 아이디어를 다룬 Dropbox의 \u003ccode\u003epyxl\u003c/code\u003e에게 특별한 언급을 합니다. Andrea Giammarchi는 이 PEP의 초기 초안에 대해 사려 깊은 피드백을 제공했습니다. 마지막으로, \u003ccode\u003etagged\u003c/code\u003e 라이브러리에 대한 선구적인 작업에 대해 Joachim Viide에게 감사드립니다. \u003ccode\u003etagged\u003c/code\u003e는 템플릿 문자열의 전신일 뿐만 아니라 GitHub 이슈 댓글을 통해 전체 노력이 시작된 곳입니다!\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1450,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 750 - Template Strings\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 13:38:50+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>