<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-19cfc001fdac3337.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1098<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 518 - Specifying Minimum Build System Requirements for Python Projects</h1><div class="page__meta"><time dateTime="2025-09-26 23:12:43+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0518/">PEP 518 - Specifying Minimum Build System Requirements for Python Projects</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 10-May-2016</p>
</blockquote>
<h1>PEP 518 – Python 프로젝트를 위한 최소 빌드 시스템 요구사항 지정</h1>
<h2>초록 (Abstract)</h2>
<p>이 PEP는 Python 소프트웨어 패키지가 선택한 빌드 시스템을 실행하는 데 필요한 빌드 의존성(build dependencies)을 어떻게 명시해야 하는지 지정합니다. 이 사양의 일부로, 소프트웨어 패키지가 빌드 의존성을 지정하는 데 사용할 새로운 구성 파일이 도입됩니다 (동일한 구성 파일이 향후 다른 구성 세부 정보를 위해서도 사용될 것이라는 기대를 가지고 있습니다).</p>
<h2>도입 배경 (Rationale)</h2>
<p>Python이 처음 프로젝트용 소프트웨어 배포판을 빌드하기 위한 도구를 개발했을 때, <code>distutils</code>가 선택된 해결책이었습니다. 시간이 지나면서 <code>setuptools</code>는 <code>distutils</code> 위에 몇 가지 기능을 추가하며 인기를 얻었습니다. 둘 다 프로젝트 관리자가 소프트웨어 배포판을 빌드하기 위해 실행하는 <code>setup.py</code> 파일의 개념을 사용했습니다 (사용자들도 배포판을 설치하기 위해 이를 실행했습니다).</p>
<p><code>distutils</code>는 Python의 표준 라이브러리 일부이므로, 실행 가능한 파일을 사용하여 빌드 요구사항을 지정하는 것은 문제가 되지 않았습니다. 빌드 도구가 Python의 일부라는 것은 <code>setup.py</code>가 프로젝트 관리자가 프로젝트 배포판을 빌드하기 위해 걱정할 외부 의존성이 없다는 것을 의미했습니다. 유일한 의존성이 Python이었기 때문에 어떤 의존성 정보도 지정할 필요가 없었습니다.</p>
<p>그러나 프로젝트가 <code>setuptools</code>를 사용하기로 선택했을 때, <code>setup.py</code>와 같은 실행 가능한 파일의 사용은 문제가 됩니다. <code>setup.py</code> 파일의 의존성을 알지 못하면 실행할 수 없지만, 현재는 해당 정보가 저장된 <code>setup.py</code> 파일을 실행하지 않고는 자동화된 방식으로 해당 의존성을 알 수 있는 표준적인 방법이 없습니다. 이는 파일 내용을 알지 못하면 실행할 수 없고, 파일을 실행하지 않으면 프로그래밍 방식으로 내용을 알 수 없는 딜레마(catch-22)입니다.</p>
<p><code>setuptools</code>는 <code>setup()</code> 함수에 <code>setup_requires</code> 인수를 사용하여 이를 해결하려고 시도했습니다. 그러나 이 해결책에는 여러 문제가 있었습니다. 예를 들어:</p>
<ul>
<li><code>setuptools</code> 자체를 제외하고는 어떤 도구도 <code>setup.py</code>를 실행하지 않고는 이 정보에 접근할 수 없지만, 이 항목들이 설치되어 있지 않으면 <code>setup.py</code>는 실행될 수 없습니다.</li>
<li><code>setup_requires</code>에 나열된 항목들은 <code>setup.py</code>가 실행될 때마다 암시적으로 설치되지만, <code>setup.py</code>가 실행되는 일반적인 방법 중 하나는 <code>pip</code>와 같은 다른 도구를 통해서이며, <code>pip</code>는 이미 의존성을 관리하고 있습니다. 이는 <code>pip install spam</code>과 같은 명령이 <code>pip</code>와 <code>setuptools</code> 둘 다 패키지를 다운로드하고 설치하게 만들 수 있으며, 최종 사용자는 설치 저장소와 같은 설정을 변경하기 위해 두 도구 모두를 구성해야 할 수 있다는 의미입니다.</li>
</ul>
<p>이러한 문제로 인해 <code>setup_requires</code>의 사용은 드물었고, 프로젝트들은 <code>setup.py</code> 파일 간에 코드 스니펫을 복사하거나, 프로젝트를 빌드하거나 설치하기 전에 사용자가 수동으로 설치해야 할 것을 다른 곳에 문서화하는 방식을 택했습니다.</p>
<p>이 모든 상황은 <code>pip</code>가 <code>setup.py</code> 파일을 실행할 때 단순히 <code>setuptools</code>가 필요하다고 가정하게 만들었습니다. 그러나 이 방식은 <code>setuptools</code>처럼 다른 프로젝트가 커뮤니티에서 인기를 얻기 시작할 경우 확장되지 않습니다. 또한 <code>pip</code>가 <code>setuptools</code> 외의 다른 것이 필요하다는 사실을 추론할 수 없을 때, 프로젝트와 함께 사용해야 하는 마찰로 인해 다른 프로젝트가 인기를 얻는 것을 방해합니다.</p>
<p>이 PEP는 프로젝트의 빌드 시스템에 대한 최소 의존성을 특정 파일에 선언적인 방식으로 나열하는 방법을 지정함으로써 이러한 상황을 개선하려고 합니다. 이를 통해 프로젝트는 소스 체크아웃에서 Wheel과 같은 빌드 결과물을 생성하기 위해 필요한 빌드 의존성을 나열할 수 있으며, 도구가 프로젝트 자체를 빌드하는 데 필요한 것을 추론할 수 없는 <code>setup.py</code>의 딜레마에 빠지지 않습니다. 이 PEP를 구현하면 프로젝트는 어떤 빌드 시스템에 의존하는지 미리 지정할 수 있으므로 <code>pip</code>와 같은 도구가 빌드 시스템을 실행하여 프로젝트를 빌드하기 위해 필요한 것들이 설치되도록 보장할 수 있습니다.</p>
<p>이 PEP의 맥락과 동기를 더 자세히 설명하자면, 프로젝트의 빌드 결과물을 생성하는 데 필요한 (대략적인) 단계를 생각해보세요:</p>
<ol>
<li>프로젝트의 소스 체크아웃.</li>
<li>빌드 시스템 설치.</li>
<li>빌드 시스템 실행.</li>
</ol>
<p>이 PEP는 두 번째 단계인 "빌드 시스템 설치"를 다룹니다. PEP 517은 빌드 시스템이 작업을 수행하는 데 필요한 추가 의존성을 동적으로 지정하는 방법을 포함하여 세 번째 단계를 다룹니다. 그러나 이 PEP의 목적은 빌드 시스템이 단순히 실행을 시작하는 데 필요한 최소 요구사항을 지정하는 것입니다.</p>
<h2>사양 (Specification)</h2>
<h3>파일 형식 (File Format)</h3>
<p>빌드 시스템 의존성은 TOML 형식으로 작성된 <code>pyproject.toml</code>이라는 파일에 저장됩니다.</p>
<p>이 형식은 사람이 사용하기 쉽고 (JSON과 달리), 충분히 유연하며 (configparser와 달리), 표준에서 유래하고 (또한 configparser와 달리), 지나치게 복잡하지 않기 때문에 (YAML과 달리) 선택되었습니다. TOML 형식은 Rust 커뮤니티에서 Cargo 패키지 관리자의 일부로 이미 사용되고 있으며, 비공개 이메일을 통해 TOML 선택에 매우 만족하고 있음을 밝혔습니다. 다양한 대안이 선택되지 않은 이유에 대한 더 자세한 논의는 "Other file formats" 섹션에서 확인할 수 있습니다. 저자들은 구성 파일 형식의 선택이 궁극적으로 주관적이며 선택이 필요했고, 이 상황에서 TOML을 선호한다는 것을 인지하고 있습니다.</p>
<p>아래에는 도구가 인식/존중해야 할 테이블을 나열합니다. 이 PEP에 지정되지 않은 테이블은 다른 PEP에 의한 미래 사용을 위해 예약되어 있습니다.</p>
<h3><code>build-system</code> 테이블</h3>
<p><code>[build-system]</code> 테이블은 빌드 관련 데이터를 저장하는 데 사용됩니다. 초기에는 이 테이블의 한 키만 유효하며 필수적입니다: <code>requires</code>. 이 키는 빌드 시스템을 실행하는 데 필요한 PEP 508 의존성(현재는 <code>setup.py</code> 파일을 실행하는 데 필요한 의존성을 의미합니다)을 나타내는 문자열 목록 값을 가져야 합니다.</p>
<p><code>setuptools</code>에 의존하는 대다수의 Python 프로젝트의 경우, <code>pyproject.toml</code> 파일은 다음과 같을 것입니다:</p>
<pre><code class="language-toml">[build-system]
# 빌드 시스템을 실행하기 위한 최소 요구사항.
requires = ["setuptools"] # PEP 508 사양.
</code></pre>
<p><code>setuptools</code>의 사용이 현재 커뮤니티에서 매우 광범위하기 때문에, 빌드 도구는 <code>pyproject.toml</code> 파일이 없을 때 위에 제시된 예시 구성 파일을 기본 의미론으로 사용할 것으로 예상됩니다.</p>
<p>도구는 <code>[build-system]</code> 테이블의 존재를 요구해서는 안 됩니다. <code>pyproject.toml</code> 파일은 빌드 관련 데이터 외의 구성 세부 정보를 저장하는 데 사용될 수 있으며, 따라서 <code>[build-system]</code> 테이블이 합법적으로 없을 수 있습니다. 파일이 존재하지만 <code>[build-system]</code> 테이블이 없는 경우 위에서 지정된 기본값이 사용되어야 합니다. 테이블이 지정되었지만 필수 필드가 누락된 경우 도구는 이를 오류로 간주해야 합니다.</p>
<h3><code>tool</code> 테이블</h3>
<p><code>[tool]</code> 테이블은 빌드 도구뿐만 아니라 Python 프로젝트와 관련된 모든 도구가 <code>[tool]</code> 내의 하위 테이블을 사용하는 한 (예: <code>flit</code> 도구는 <code>[tool.flit]</code>에 구성을 저장) 사용자가 구성 데이터를 지정할 수 있는 곳입니다.</p>
<p>서로 다른 프로젝트가 동일한 하위 테이블을 사용하려고 시도하여 충돌하는 것을 방지하기 위해 <code>tool.*</code> 네임스페이스 내에서 이름을 할당하는 메커니즘이 필요합니다. 우리의 규칙은 프로젝트가 Cheeseshop/PyPI에서 <code>$NAME</code> 항목을 소유하는 경우에만 <code>tool.$NAME</code> 하위 테이블을 사용할 수 있다는 것입니다.</p>
<h3>JSON 스키마 (JSON Schema)</h3>
<p>TOML 파일에서 얻은 데이터의 유형별 표현을 설명 목적으로만 제공하기 위해, 다음 JSON Schema가 데이터 형식과 일치합니다:</p>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/schema#",
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "build-system": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "requires": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": ["requires"]
    },
    "tool": {
      "type": "object"
    }
  }
}
</code></pre>
<h2>거부된 아이디어 (Rejected Ideas)</h2>
<h3>의미론적 버전 키 (A semantic version key)</h3>
<p>구성 파일 구조의 미래 호환성을 위해 처음에는 의미론적 버전 키가 제안되었습니다. 기본값은 <code>1</code>로, 이전에 정의된 키 또는 테이블에 역호환되지 않는 의미론적 변경이 발생할 경우 <code>semantics-version</code>이 새 번호로 증가하는 것이 아이디어였습니다.</p>
<p>그러나 결국, 이것은 시기상조의 최적화로 결정되었습니다. 구성 파일에 의미론적으로 미리 정의된 내용의 변경은 상당히 보수적일 것으로 예상됩니다. 그리고 역호환되지 않는 변경이 발생했을 경우에는, 이전 도구를 손상시키지 않기 위해 새로운 의미론에 다른 이름을 사용할 수 있습니다.</p>
<h3>더 깊은 중첩 네임스페이스 (A more nested namespace)</h3>
<p>이 PEP의 초기 초안에는 최상위 <code>[package]</code> 테이블이 있었습니다. 이 아이디어는 의미론적 버전 관리 체계에 대한 일부 스코핑을 부과하기 위한 것이었습니다 (그 아이디어가 왜 거부되었는지에 대해서는 "A semantic version key"를 참조). 스코핑의 필요성이 제거되면서, 최상위 테이블을 두는 의미가 불필요해졌습니다.</p>
<h3>다른 테이블 이름 (Other table names)</h3>
<p><code>[build-system]</code> 테이블에 제안된 다른 이름은 <code>[build]</code>였습니다. 대체 이름이 더 짧지만, 테이블에 저장되는 정보의 의도를 많이 전달하지 못합니다. <code>distutils-sig</code> 메일링 리스트에서 투표 후 현재 이름이 채택되었습니다.</p>
<h3>다른 파일 형식 (Other file formats)</h3>
<p>여러 다른 파일 형식이 고려되었지만, 다양한 이유로 모두 거부되었습니다. 주요 요구사항은 형식이 사람이 편집할 수 있어야 하고, 프로젝트가 쉽게 벤더링할 수 있는 구현이 있어야 한다는 것이었습니다. 이는 XML과 같이 사람에게 친숙하지 않은 특정 형식을 처음부터 배제했으며, 심각하게 논의되지도 않았습니다.</p>
<h4>고려된 파일 형식 개요 (Overview of file formats considered)</h4>
<p>고려된 다른 대안들이 거부된 주요 이유는 다음 섹션에 요약되어 있으며, 전체 검토 (TOML을 지지하는 긍정적인 주장 포함)는에서 확인할 수 있습니다.</p>
<p>TOML은 궁극적으로 우리가 관심 있는 모든 기능을 제공하면서 대안들이 도입하는 단점을 피했기 때문에 선택되었습니다.</p>
<p>| 기능            | TOML | YAML | JSON | CFG/INI |
| :-------------- | :--- | :--- | :--- | :------ |
| 잘 정의됨       | 예   | 예   | 예   |         |
| 실제 데이터 유형 | 예   | 예   | 예   |         |
| 신뢰할 수 있는 Unicode | 예   | 예   | 예   |         |
| 신뢰할 수 있는 주석 | 예   | 예   |      | 예      |
| 사람이 편집하기 쉬움 | 예   | ??   | ??   |         |
| 도구가 편집하기 쉬움 | 예   | ??   | 예   | ??      |
| 표준 라이브러리에 포함 |      | 예   | 예   | 예      |
| pip가 벤더링하기 쉬움 | 예   | n/a  | n/a  |         |</p>
<p>(테이블의 "??"는 대부분의 사람들이 "예"라고 답하고 싶겠지만, 명확한 사양의 부족 또는 기본 파일 형식 사양이 놀랍도록 복잡하기 때문에 실제로는 많은 문제와 엣지 케이스가 발생하는 항목을 나타냅니다.)</p>
<p><code>pytoml</code> TOML 파서는 순수 Python 코드 약 300줄로 구성되어 있어, 표준 라이브러리 외부에 있다는 것이 크게 불리하게 작용하지 않았습니다.</p>
<p>Python 리터럴도 잠재적인 형식으로 논의되었지만 (일반적인 기존 파일 형식이 아니므로) 파일 형식 검토에서는 고려되지 않았습니다.</p>
<p><strong>JSON</strong>
JSON 형식은 처음에는 고려되었지만 빠르게 거부되었습니다. 인간이 읽을 수 있는 문자열 기반 데이터 교환 형식으로는 훌륭하지만, 구문이 인간이 쉽게 편집하기에 적합하지 않습니다 (예: 구문이 불필요하게 장황하고 주석을 허용하지 않습니다).</p>
<p>제안된 데이터에 대한 예시 JSON 파일은 다음과 같습니다:</p>
<pre><code class="language-json">{
  "build": {
    "requires": [
      "setuptools",
      "wheel>=0.27"
    ]
  }
}
</code></pre>
<p><strong>YAML</strong>
YAML 형식은 JSON의 상위 집합이면서 수동으로 작업하기 더 쉽도록 설계되었습니다. YAML에는 세 가지 주요 문제가 있습니다.</p>
<p>첫째, 사양이 방대합니다: A4 용지에 인쇄하면 86페이지에 달합니다. 이는 어떤 사람이 한 파서에서는 작동하지만 다른 파서에서는 작동하지 않는 YAML 기능을 사용할 가능성을 남깁니다. 하위 집합을 표준화하는 것이 제안되었지만, 이는 기본적으로 이 파일에 특정한 새로운 표준을 만드는 것을 의미하며 장기적으로는 실현 가능하지 않습니다.</p>
<p>둘째, YAML 자체는 기본적으로 안전하지 않습니다. 사양은 임의 코드 실행을 허용하며, 이는 구성 데이터를 다룰 때 피하는 것이 가장 좋습니다. 물론 이 동작을 피하는 것이 가능하지만 (예: PyYAML은 <code>safe_load</code> 작업을 제공), 어떤 도구가 부주의하게 <code>load</code>를 사용한다면 임의 코드 실행에 노출됩니다. 이 PEP는 본질적으로 코드 실행을 포함하는 프로젝트 빌딩에 초점을 맞추고 있지만, 프로젝트 이름 및 버전 번호와 같은 다른 구성 데이터가 언젠가 동일한 파일에 들어갈 수 있으며, 이때 임의 코드 실행은 바람직하지 않습니다.</p>
<p>마지막으로, YAML의 가장 인기 있는 Python 구현은 <code>PyYAML</code>인데, 이는 수천 줄의 코드와 선택적 C 확장 모듈을 가진 큰 프로젝트입니다. 그 자체로는 문제가 아닐 수 있지만, <code>pip</code>와 같은 프로젝트에는 더 큰 문제가 됩니다. <code>pip</code>는 완전히 독립적이기 위해 <code>PyYAML</code>을 의존성으로 벤더링해야 할 가능성이 높기 때문입니다 (그렇지 않으면 설치 도구가 작동하기 위해 또 다른 설치 도구가 필요하게 됩니다). 라이브러리의 더 간단한 버전을 벤더링하는 것이 얼마나 쉬운지 알아보기 위해 <code>PyYAML</code>의 개념 증명 재작업이 이루어졌으며, 이는 가능성이 있음을 보여줍니다.</p>
<p>예시 YAML 파일은 다음과 같습니다:</p>
<pre><code class="language-yaml">build:
  requires:
    - setuptools
    - wheel>=0.27
</code></pre>
<p><strong>configparser</strong>
<code>configparser</code>가 허용하는 INI 스타일 구성 파일이 고려되었습니다. 불행히도 <code>configparser</code>가 무엇을 허용하는지에 대한 사양이 없어서 버전 간에 지원 불균형이 발생합니다. 예를 들어, Python 2.7의 <code>ConfigParser</code>가 허용하는 것과 Python 3의 <code>configparser</code>가 허용하는 것은 동일하지 않습니다. Python 3이 허용하는 것을 표준화하고 <code>configparser</code> 모듈의 백포트를 벤더링할 수도 있지만, 이는 이 PEP가 이 PEP에 지정된 메타데이터를 사용하려는 모든 프로젝트가 <code>configparser</code>의 백포트를 사용해야 한다고 명시해야 함을 의미합니다. 이는 지나치게 제한적이며, 특정 버전의 <code>configparser</code>가 예상된다는 것을 모르는 사람들에게 혼란을 야기할 수 있습니다.</p>
<p>예시 INI 파일은 다음과 같습니다:</p>
<pre><code class="language-ini">[build]
requires = setuptools wheel>=0.27
</code></pre>
<p><strong>Python 리터럴 (Python literals)</strong>
어떤 사람은 Python 리터럴을 구성 형식으로 사용할 것을 제안했습니다. 파일은 최상위에 하나의 <code>dict</code>를 포함하고, 모든 데이터는 그 <code>dict</code> 안에 있으며, 섹션은 키로 정의됩니다. 모든 Python 프로그래머는 이 형식에 익숙하고, 구성 데이터를 읽기 위한 암묵적인 서드파티 의존성이 없으며, <code>ast.literal_eval()</code>로 파싱하면 안전할 수 있습니다. Python 리터럴은 JSON과 동일할 수 있으며, 후행 쉼표와 주석을 지원하는 추가적인 이점이 있습니다. 또한, Python의 더 풍부한 데이터 모델은 일부 미래 구성 요구사항 (예: 문자열이 아닌 딕셔너리 키, 부동 소수점 대 정수 값)에 유용할 수 있습니다.</p>
<p>다른 한편으로, Python 리터럴은 Python 특정 형식이며, 이 데이터는 Python으로 작성되지 않은 패키징 도구 등에 의해 읽힐 필요가 있을 것으로 예상됩니다.</p>
<p>제안된 데이터에 대한 예시 Python 리터럴 파일은 다음과 같습니다:</p>
<pre><code class="language-python"># 빌드 구성
{
    "build": {
        "requires": [
            "setuptools",
            "wheel>=0.27",  # 후행 쉼표
            # "numpy>=1.10" # 주석 처리된 데이터 라인
        ]  # 임의의 주석
    }
}
</code></pre>
<h3><code>setup.cfg</code> 유지 (Sticking with setup.cfg)</h3>
<p><code>setuptools</code>에서 일반적인 형식으로 사용되는 <code>setup.cfg</code>에는 두 가지 문제가 있습니다. 하나는 위에서 <code>configparser</code> 논의에서 언급된 문제가 있는 <code>.ini</code> 파일이라는 것입니다. 다른 하나는 해당 파일의 스키마가 엄격하게 정의된 적이 없어서, <code>setuptools</code> 설치를 잠재적으로 혼란스럽게 하지 않고 어떤 형식을 안전하게 사용할 수 있을지 알 수 없다는 것입니다.</p>
<h3>다른 파일 이름 (Other file names)</h3>
<p>여러 다른 파일 이름이 고려되었고 거부되었습니다 (비록 이것은 매우 "바이크셰딩(bikeshedding)" 주제이므로, 결정은 주로 취향에 따라 내려집니다).</p>
<ul>
<li><code>pysettings.toml</code>: 가장 합리적인 대안.</li>
<li><code>pypa.toml</code>: PyPA를 참조하는 것이 합리적이지만, 다소 틈새 용어입니다. 도메인 특정 지식 없이도 파일 이름이 이해되는 것이 더 좋습니다.</li>
<li><code>pybuild.toml</code>: 이 PEP의 제한적인 관점에서는 이 파일 이름이 합리적이지만, 빌드 관련이 아닌 메타데이터가 파일에 추가될 경우 이름이 의미를 잃게 됩니다.</li>
<li><code>pip.toml</code>: 너무 도구에 특화됨.</li>
<li><code>meta.toml</code>: 너무 일반적; 프로젝트가 자체 메타데이터 파일을 원할 수 있습니다.</li>
<li><code>setup.toml</code>: <code>setup.py</code> 덕분에 전통을 유지하지만, 파일이 미래에 포함할 수 있는 내용과 반드시 일치하지는 않습니다 (예: 프로젝트 이름이 본질적으로 설정의 일부인가?).</li>
<li><code>pymeta.toml</code>: 프로그래밍 및/또는 Python 초보자에게는 명확하지 않음.</li>
<li><code>pypackage.toml</code> &#x26; <code>pypackaging.toml</code>: "패키지"가 무엇인지에 대한 이름 혼동 (프로젝트 대 네임스페이스).</li>
<li><code>pydevelop.toml</code>: 파일에 개발에만 국한되지 않는 세부 정보가 포함될 수 있습니다.</li>
<li><code>pysource.toml</code>: 소스 코드와 직접 관련 없음.</li>
<li><code>pytools.toml</code>: 파일이 (현재) 프로젝트 관리를 목표로 하므로 오해의 소지가 있습니다.</li>
<li><code>dstufft.toml</code>: 너무 개인적. ;)</li>
</ul>
<h2>참조 (References)</h2>
<p><code>distutils</code> (https://docs.python.org/3/library/distutils.html#module-distutils)
<code>setuptools</code> (https://pypi.python.org/pypi/setuptools)
<code>setuptools</code>: New and Changed <code>setup()</code> Keywords (http://pythonhosted.org/setuptools/setuptools.html#new-and-changed-setup-keywords)
<code>pip</code> (https://pypi.python.org/pypi/pip)
<code>wheel</code> (https://pypi.python.org/pypi/wheel)
TOML (https://github.com/toml-lang/toml)
JSON (http://json.org/)
YAML (http://yaml.org/)
<code>configparser</code> (https://docs.python.org/3/library/configparser.html#module-configparser)
<code>PyYAML</code> (https://pypi.python.org/pypi/PyYAML)
PyPA (https://www.pypa.io)
Bazel (http://bazel.io/)
<code>ast.literal_eval()</code> (https://docs.python.org/3/library/ast.html#ast.literal_eval)
Cargo, Rust's package manager (http://doc.crates.io/)
JSON Schema (http://json-schema.org/)
Nathaniel J. Smith's file format review (https://gist.github.com/njsmith/78f68204c5d969f8c8bc645ef77d4a8f)</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-19cfc001fdac3337.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/518\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"FeyCvJug7In7AgUZlfHUx\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/518/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/518\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"518\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/518\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T5d82,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0518/\"\u003ePEP 518 - Specifying Minimum Build System Requirements for Python Projects\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 10-May-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 518 – Python 프로젝트를 위한 최소 빌드 시스템 요구사항 지정\u003c/h1\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 Python 소프트웨어 패키지가 선택한 빌드 시스템을 실행하는 데 필요한 빌드 의존성(build dependencies)을 어떻게 명시해야 하는지 지정합니다. 이 사양의 일부로, 소프트웨어 패키지가 빌드 의존성을 지정하는 데 사용할 새로운 구성 파일이 도입됩니다 (동일한 구성 파일이 향후 다른 구성 세부 정보를 위해서도 사용될 것이라는 기대를 가지고 있습니다).\u003c/p\u003e\n\u003ch2\u003e도입 배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003ePython이 처음 프로젝트용 소프트웨어 배포판을 빌드하기 위한 도구를 개발했을 때, \u003ccode\u003edistutils\u003c/code\u003e가 선택된 해결책이었습니다. 시간이 지나면서 \u003ccode\u003esetuptools\u003c/code\u003e는 \u003ccode\u003edistutils\u003c/code\u003e 위에 몇 가지 기능을 추가하며 인기를 얻었습니다. 둘 다 프로젝트 관리자가 소프트웨어 배포판을 빌드하기 위해 실행하는 \u003ccode\u003esetup.py\u003c/code\u003e 파일의 개념을 사용했습니다 (사용자들도 배포판을 설치하기 위해 이를 실행했습니다).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edistutils\u003c/code\u003e는 Python의 표준 라이브러리 일부이므로, 실행 가능한 파일을 사용하여 빌드 요구사항을 지정하는 것은 문제가 되지 않았습니다. 빌드 도구가 Python의 일부라는 것은 \u003ccode\u003esetup.py\u003c/code\u003e가 프로젝트 관리자가 프로젝트 배포판을 빌드하기 위해 걱정할 외부 의존성이 없다는 것을 의미했습니다. 유일한 의존성이 Python이었기 때문에 어떤 의존성 정보도 지정할 필요가 없었습니다.\u003c/p\u003e\n\u003cp\u003e그러나 프로젝트가 \u003ccode\u003esetuptools\u003c/code\u003e를 사용하기로 선택했을 때, \u003ccode\u003esetup.py\u003c/code\u003e와 같은 실행 가능한 파일의 사용은 문제가 됩니다. \u003ccode\u003esetup.py\u003c/code\u003e 파일의 의존성을 알지 못하면 실행할 수 없지만, 현재는 해당 정보가 저장된 \u003ccode\u003esetup.py\u003c/code\u003e 파일을 실행하지 않고는 자동화된 방식으로 해당 의존성을 알 수 있는 표준적인 방법이 없습니다. 이는 파일 내용을 알지 못하면 실행할 수 없고, 파일을 실행하지 않으면 프로그래밍 방식으로 내용을 알 수 없는 딜레마(catch-22)입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esetuptools\u003c/code\u003e는 \u003ccode\u003esetup()\u003c/code\u003e 함수에 \u003ccode\u003esetup_requires\u003c/code\u003e 인수를 사용하여 이를 해결하려고 시도했습니다. 그러나 이 해결책에는 여러 문제가 있었습니다. 예를 들어:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esetuptools\u003c/code\u003e 자체를 제외하고는 어떤 도구도 \u003ccode\u003esetup.py\u003c/code\u003e를 실행하지 않고는 이 정보에 접근할 수 없지만, 이 항목들이 설치되어 있지 않으면 \u003ccode\u003esetup.py\u003c/code\u003e는 실행될 수 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esetup_requires\u003c/code\u003e에 나열된 항목들은 \u003ccode\u003esetup.py\u003c/code\u003e가 실행될 때마다 암시적으로 설치되지만, \u003ccode\u003esetup.py\u003c/code\u003e가 실행되는 일반적인 방법 중 하나는 \u003ccode\u003epip\u003c/code\u003e와 같은 다른 도구를 통해서이며, \u003ccode\u003epip\u003c/code\u003e는 이미 의존성을 관리하고 있습니다. 이는 \u003ccode\u003epip install spam\u003c/code\u003e과 같은 명령이 \u003ccode\u003epip\u003c/code\u003e와 \u003ccode\u003esetuptools\u003c/code\u003e 둘 다 패키지를 다운로드하고 설치하게 만들 수 있으며, 최종 사용자는 설치 저장소와 같은 설정을 변경하기 위해 두 도구 모두를 구성해야 할 수 있다는 의미입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 문제로 인해 \u003ccode\u003esetup_requires\u003c/code\u003e의 사용은 드물었고, 프로젝트들은 \u003ccode\u003esetup.py\u003c/code\u003e 파일 간에 코드 스니펫을 복사하거나, 프로젝트를 빌드하거나 설치하기 전에 사용자가 수동으로 설치해야 할 것을 다른 곳에 문서화하는 방식을 택했습니다.\u003c/p\u003e\n\u003cp\u003e이 모든 상황은 \u003ccode\u003epip\u003c/code\u003e가 \u003ccode\u003esetup.py\u003c/code\u003e 파일을 실행할 때 단순히 \u003ccode\u003esetuptools\u003c/code\u003e가 필요하다고 가정하게 만들었습니다. 그러나 이 방식은 \u003ccode\u003esetuptools\u003c/code\u003e처럼 다른 프로젝트가 커뮤니티에서 인기를 얻기 시작할 경우 확장되지 않습니다. 또한 \u003ccode\u003epip\u003c/code\u003e가 \u003ccode\u003esetuptools\u003c/code\u003e 외의 다른 것이 필요하다는 사실을 추론할 수 없을 때, 프로젝트와 함께 사용해야 하는 마찰로 인해 다른 프로젝트가 인기를 얻는 것을 방해합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 프로젝트의 빌드 시스템에 대한 최소 의존성을 특정 파일에 선언적인 방식으로 나열하는 방법을 지정함으로써 이러한 상황을 개선하려고 합니다. 이를 통해 프로젝트는 소스 체크아웃에서 Wheel과 같은 빌드 결과물을 생성하기 위해 필요한 빌드 의존성을 나열할 수 있으며, 도구가 프로젝트 자체를 빌드하는 데 필요한 것을 추론할 수 없는 \u003ccode\u003esetup.py\u003c/code\u003e의 딜레마에 빠지지 않습니다. 이 PEP를 구현하면 프로젝트는 어떤 빌드 시스템에 의존하는지 미리 지정할 수 있으므로 \u003ccode\u003epip\u003c/code\u003e와 같은 도구가 빌드 시스템을 실행하여 프로젝트를 빌드하기 위해 필요한 것들이 설치되도록 보장할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP의 맥락과 동기를 더 자세히 설명하자면, 프로젝트의 빌드 결과물을 생성하는 데 필요한 (대략적인) 단계를 생각해보세요:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e프로젝트의 소스 체크아웃.\u003c/li\u003e\n\u003cli\u003e빌드 시스템 설치.\u003c/li\u003e\n\u003cli\u003e빌드 시스템 실행.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 PEP는 두 번째 단계인 \"빌드 시스템 설치\"를 다룹니다. PEP 517은 빌드 시스템이 작업을 수행하는 데 필요한 추가 의존성을 동적으로 지정하는 방법을 포함하여 세 번째 단계를 다룹니다. 그러나 이 PEP의 목적은 빌드 시스템이 단순히 실행을 시작하는 데 필요한 최소 요구사항을 지정하는 것입니다.\u003c/p\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003ch3\u003e파일 형식 (File Format)\u003c/h3\u003e\n\u003cp\u003e빌드 시스템 의존성은 TOML 형식으로 작성된 \u003ccode\u003epyproject.toml\u003c/code\u003e이라는 파일에 저장됩니다.\u003c/p\u003e\n\u003cp\u003e이 형식은 사람이 사용하기 쉽고 (JSON과 달리), 충분히 유연하며 (configparser와 달리), 표준에서 유래하고 (또한 configparser와 달리), 지나치게 복잡하지 않기 때문에 (YAML과 달리) 선택되었습니다. TOML 형식은 Rust 커뮤니티에서 Cargo 패키지 관리자의 일부로 이미 사용되고 있으며, 비공개 이메일을 통해 TOML 선택에 매우 만족하고 있음을 밝혔습니다. 다양한 대안이 선택되지 않은 이유에 대한 더 자세한 논의는 \"Other file formats\" 섹션에서 확인할 수 있습니다. 저자들은 구성 파일 형식의 선택이 궁극적으로 주관적이며 선택이 필요했고, 이 상황에서 TOML을 선호한다는 것을 인지하고 있습니다.\u003c/p\u003e\n\u003cp\u003e아래에는 도구가 인식/존중해야 할 테이블을 나열합니다. 이 PEP에 지정되지 않은 테이블은 다른 PEP에 의한 미래 사용을 위해 예약되어 있습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ebuild-system\u003c/code\u003e 테이블\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e[build-system]\u003c/code\u003e 테이블은 빌드 관련 데이터를 저장하는 데 사용됩니다. 초기에는 이 테이블의 한 키만 유효하며 필수적입니다: \u003ccode\u003erequires\u003c/code\u003e. 이 키는 빌드 시스템을 실행하는 데 필요한 PEP 508 의존성(현재는 \u003ccode\u003esetup.py\u003c/code\u003e 파일을 실행하는 데 필요한 의존성을 의미합니다)을 나타내는 문자열 목록 값을 가져야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esetuptools\u003c/code\u003e에 의존하는 대다수의 Python 프로젝트의 경우, \u003ccode\u003epyproject.toml\u003c/code\u003e 파일은 다음과 같을 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e[build-system]\r\n# 빌드 시스템을 실행하기 위한 최소 요구사항.\r\nrequires = [\"setuptools\"] # PEP 508 사양.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esetuptools\u003c/code\u003e의 사용이 현재 커뮤니티에서 매우 광범위하기 때문에, 빌드 도구는 \u003ccode\u003epyproject.toml\u003c/code\u003e 파일이 없을 때 위에 제시된 예시 구성 파일을 기본 의미론으로 사용할 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e도구는 \u003ccode\u003e[build-system]\u003c/code\u003e 테이블의 존재를 요구해서는 안 됩니다. \u003ccode\u003epyproject.toml\u003c/code\u003e 파일은 빌드 관련 데이터 외의 구성 세부 정보를 저장하는 데 사용될 수 있으며, 따라서 \u003ccode\u003e[build-system]\u003c/code\u003e 테이블이 합법적으로 없을 수 있습니다. 파일이 존재하지만 \u003ccode\u003e[build-system]\u003c/code\u003e 테이블이 없는 경우 위에서 지정된 기본값이 사용되어야 합니다. 테이블이 지정되었지만 필수 필드가 누락된 경우 도구는 이를 오류로 간주해야 합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003etool\u003c/code\u003e 테이블\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e[tool]\u003c/code\u003e 테이블은 빌드 도구뿐만 아니라 Python 프로젝트와 관련된 모든 도구가 \u003ccode\u003e[tool]\u003c/code\u003e 내의 하위 테이블을 사용하는 한 (예: \u003ccode\u003eflit\u003c/code\u003e 도구는 \u003ccode\u003e[tool.flit]\u003c/code\u003e에 구성을 저장) 사용자가 구성 데이터를 지정할 수 있는 곳입니다.\u003c/p\u003e\n\u003cp\u003e서로 다른 프로젝트가 동일한 하위 테이블을 사용하려고 시도하여 충돌하는 것을 방지하기 위해 \u003ccode\u003etool.*\u003c/code\u003e 네임스페이스 내에서 이름을 할당하는 메커니즘이 필요합니다. 우리의 규칙은 프로젝트가 Cheeseshop/PyPI에서 \u003ccode\u003e$NAME\u003c/code\u003e 항목을 소유하는 경우에만 \u003ccode\u003etool.$NAME\u003c/code\u003e 하위 테이블을 사용할 수 있다는 것입니다.\u003c/p\u003e\n\u003ch3\u003eJSON 스키마 (JSON Schema)\u003c/h3\u003e\n\u003cp\u003eTOML 파일에서 얻은 데이터의 유형별 표현을 설명 목적으로만 제공하기 위해, 다음 JSON Schema가 데이터 형식과 일치합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\r\n  \"$schema\": \"http://json-schema.org/schema#\",\r\n  \"type\": \"object\",\r\n  \"additionalProperties\": false,\r\n  \"properties\": {\r\n    \"build-system\": {\r\n      \"type\": \"object\",\r\n      \"additionalProperties\": false,\r\n      \"properties\": {\r\n        \"requires\": {\r\n          \"type\": \"array\",\r\n          \"items\": {\r\n            \"type\": \"string\"\r\n          }\r\n        }\r\n      },\r\n      \"required\": [\"requires\"]\r\n    },\r\n    \"tool\": {\r\n      \"type\": \"object\"\r\n    }\r\n  }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e거부된 아이디어 (Rejected Ideas)\u003c/h2\u003e\n\u003ch3\u003e의미론적 버전 키 (A semantic version key)\u003c/h3\u003e\n\u003cp\u003e구성 파일 구조의 미래 호환성을 위해 처음에는 의미론적 버전 키가 제안되었습니다. 기본값은 \u003ccode\u003e1\u003c/code\u003e로, 이전에 정의된 키 또는 테이블에 역호환되지 않는 의미론적 변경이 발생할 경우 \u003ccode\u003esemantics-version\u003c/code\u003e이 새 번호로 증가하는 것이 아이디어였습니다.\u003c/p\u003e\n\u003cp\u003e그러나 결국, 이것은 시기상조의 최적화로 결정되었습니다. 구성 파일에 의미론적으로 미리 정의된 내용의 변경은 상당히 보수적일 것으로 예상됩니다. 그리고 역호환되지 않는 변경이 발생했을 경우에는, 이전 도구를 손상시키지 않기 위해 새로운 의미론에 다른 이름을 사용할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e더 깊은 중첩 네임스페이스 (A more nested namespace)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 초기 초안에는 최상위 \u003ccode\u003e[package]\u003c/code\u003e 테이블이 있었습니다. 이 아이디어는 의미론적 버전 관리 체계에 대한 일부 스코핑을 부과하기 위한 것이었습니다 (그 아이디어가 왜 거부되었는지에 대해서는 \"A semantic version key\"를 참조). 스코핑의 필요성이 제거되면서, 최상위 테이블을 두는 의미가 불필요해졌습니다.\u003c/p\u003e\n\u003ch3\u003e다른 테이블 이름 (Other table names)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e[build-system]\u003c/code\u003e 테이블에 제안된 다른 이름은 \u003ccode\u003e[build]\u003c/code\u003e였습니다. 대체 이름이 더 짧지만, 테이블에 저장되는 정보의 의도를 많이 전달하지 못합니다. \u003ccode\u003edistutils-sig\u003c/code\u003e 메일링 리스트에서 투표 후 현재 이름이 채택되었습니다.\u003c/p\u003e\n\u003ch3\u003e다른 파일 형식 (Other file formats)\u003c/h3\u003e\n\u003cp\u003e여러 다른 파일 형식이 고려되었지만, 다양한 이유로 모두 거부되었습니다. 주요 요구사항은 형식이 사람이 편집할 수 있어야 하고, 프로젝트가 쉽게 벤더링할 수 있는 구현이 있어야 한다는 것이었습니다. 이는 XML과 같이 사람에게 친숙하지 않은 특정 형식을 처음부터 배제했으며, 심각하게 논의되지도 않았습니다.\u003c/p\u003e\n\u003ch4\u003e고려된 파일 형식 개요 (Overview of file formats considered)\u003c/h4\u003e\n\u003cp\u003e고려된 다른 대안들이 거부된 주요 이유는 다음 섹션에 요약되어 있으며, 전체 검토 (TOML을 지지하는 긍정적인 주장 포함)는에서 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eTOML은 궁극적으로 우리가 관심 있는 모든 기능을 제공하면서 대안들이 도입하는 단점을 피했기 때문에 선택되었습니다.\u003c/p\u003e\n\u003cp\u003e| 기능            | TOML | YAML | JSON | CFG/INI |\r\n| :-------------- | :--- | :--- | :--- | :------ |\r\n| 잘 정의됨       | 예   | 예   | 예   |         |\r\n| 실제 데이터 유형 | 예   | 예   | 예   |         |\r\n| 신뢰할 수 있는 Unicode | 예   | 예   | 예   |         |\r\n| 신뢰할 수 있는 주석 | 예   | 예   |      | 예      |\r\n| 사람이 편집하기 쉬움 | 예   | ??   | ??   |         |\r\n| 도구가 편집하기 쉬움 | 예   | ??   | 예   | ??      |\r\n| 표준 라이브러리에 포함 |      | 예   | 예   | 예      |\r\n| pip가 벤더링하기 쉬움 | 예   | n/a  | n/a  |         |\u003c/p\u003e\n\u003cp\u003e(테이블의 \"??\"는 대부분의 사람들이 \"예\"라고 답하고 싶겠지만, 명확한 사양의 부족 또는 기본 파일 형식 사양이 놀랍도록 복잡하기 때문에 실제로는 많은 문제와 엣지 케이스가 발생하는 항목을 나타냅니다.)\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epytoml\u003c/code\u003e TOML 파서는 순수 Python 코드 약 300줄로 구성되어 있어, 표준 라이브러리 외부에 있다는 것이 크게 불리하게 작용하지 않았습니다.\u003c/p\u003e\n\u003cp\u003ePython 리터럴도 잠재적인 형식으로 논의되었지만 (일반적인 기존 파일 형식이 아니므로) 파일 형식 검토에서는 고려되지 않았습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eJSON\u003c/strong\u003e\r\nJSON 형식은 처음에는 고려되었지만 빠르게 거부되었습니다. 인간이 읽을 수 있는 문자열 기반 데이터 교환 형식으로는 훌륭하지만, 구문이 인간이 쉽게 편집하기에 적합하지 않습니다 (예: 구문이 불필요하게 장황하고 주석을 허용하지 않습니다).\u003c/p\u003e\n\u003cp\u003e제안된 데이터에 대한 예시 JSON 파일은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\r\n  \"build\": {\r\n    \"requires\": [\r\n      \"setuptools\",\r\n      \"wheel\u003e=0.27\"\r\n    ]\r\n  }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eYAML\u003c/strong\u003e\r\nYAML 형식은 JSON의 상위 집합이면서 수동으로 작업하기 더 쉽도록 설계되었습니다. YAML에는 세 가지 주요 문제가 있습니다.\u003c/p\u003e\n\u003cp\u003e첫째, 사양이 방대합니다: A4 용지에 인쇄하면 86페이지에 달합니다. 이는 어떤 사람이 한 파서에서는 작동하지만 다른 파서에서는 작동하지 않는 YAML 기능을 사용할 가능성을 남깁니다. 하위 집합을 표준화하는 것이 제안되었지만, 이는 기본적으로 이 파일에 특정한 새로운 표준을 만드는 것을 의미하며 장기적으로는 실현 가능하지 않습니다.\u003c/p\u003e\n\u003cp\u003e둘째, YAML 자체는 기본적으로 안전하지 않습니다. 사양은 임의 코드 실행을 허용하며, 이는 구성 데이터를 다룰 때 피하는 것이 가장 좋습니다. 물론 이 동작을 피하는 것이 가능하지만 (예: PyYAML은 \u003ccode\u003esafe_load\u003c/code\u003e 작업을 제공), 어떤 도구가 부주의하게 \u003ccode\u003eload\u003c/code\u003e를 사용한다면 임의 코드 실행에 노출됩니다. 이 PEP는 본질적으로 코드 실행을 포함하는 프로젝트 빌딩에 초점을 맞추고 있지만, 프로젝트 이름 및 버전 번호와 같은 다른 구성 데이터가 언젠가 동일한 파일에 들어갈 수 있으며, 이때 임의 코드 실행은 바람직하지 않습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, YAML의 가장 인기 있는 Python 구현은 \u003ccode\u003ePyYAML\u003c/code\u003e인데, 이는 수천 줄의 코드와 선택적 C 확장 모듈을 가진 큰 프로젝트입니다. 그 자체로는 문제가 아닐 수 있지만, \u003ccode\u003epip\u003c/code\u003e와 같은 프로젝트에는 더 큰 문제가 됩니다. \u003ccode\u003epip\u003c/code\u003e는 완전히 독립적이기 위해 \u003ccode\u003ePyYAML\u003c/code\u003e을 의존성으로 벤더링해야 할 가능성이 높기 때문입니다 (그렇지 않으면 설치 도구가 작동하기 위해 또 다른 설치 도구가 필요하게 됩니다). 라이브러리의 더 간단한 버전을 벤더링하는 것이 얼마나 쉬운지 알아보기 위해 \u003ccode\u003ePyYAML\u003c/code\u003e의 개념 증명 재작업이 이루어졌으며, 이는 가능성이 있음을 보여줍니다.\u003c/p\u003e\n\u003cp\u003e예시 YAML 파일은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003ebuild:\r\n  requires:\r\n    - setuptools\r\n    - wheel\u003e=0.27\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003econfigparser\u003c/strong\u003e\r\n\u003ccode\u003econfigparser\u003c/code\u003e가 허용하는 INI 스타일 구성 파일이 고려되었습니다. 불행히도 \u003ccode\u003econfigparser\u003c/code\u003e가 무엇을 허용하는지에 대한 사양이 없어서 버전 간에 지원 불균형이 발생합니다. 예를 들어, Python 2.7의 \u003ccode\u003eConfigParser\u003c/code\u003e가 허용하는 것과 Python 3의 \u003ccode\u003econfigparser\u003c/code\u003e가 허용하는 것은 동일하지 않습니다. Python 3이 허용하는 것을 표준화하고 \u003ccode\u003econfigparser\u003c/code\u003e 모듈의 백포트를 벤더링할 수도 있지만, 이는 이 PEP가 이 PEP에 지정된 메타데이터를 사용하려는 모든 프로젝트가 \u003ccode\u003econfigparser\u003c/code\u003e의 백포트를 사용해야 한다고 명시해야 함을 의미합니다. 이는 지나치게 제한적이며, 특정 버전의 \u003ccode\u003econfigparser\u003c/code\u003e가 예상된다는 것을 모르는 사람들에게 혼란을 야기할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예시 INI 파일은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ini\"\u003e[build]\r\nrequires = setuptools wheel\u003e=0.27\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ePython 리터럴 (Python literals)\u003c/strong\u003e\r\n어떤 사람은 Python 리터럴을 구성 형식으로 사용할 것을 제안했습니다. 파일은 최상위에 하나의 \u003ccode\u003edict\u003c/code\u003e를 포함하고, 모든 데이터는 그 \u003ccode\u003edict\u003c/code\u003e 안에 있으며, 섹션은 키로 정의됩니다. 모든 Python 프로그래머는 이 형식에 익숙하고, 구성 데이터를 읽기 위한 암묵적인 서드파티 의존성이 없으며, \u003ccode\u003east.literal_eval()\u003c/code\u003e로 파싱하면 안전할 수 있습니다. Python 리터럴은 JSON과 동일할 수 있으며, 후행 쉼표와 주석을 지원하는 추가적인 이점이 있습니다. 또한, Python의 더 풍부한 데이터 모델은 일부 미래 구성 요구사항 (예: 문자열이 아닌 딕셔너리 키, 부동 소수점 대 정수 값)에 유용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다른 한편으로, Python 리터럴은 Python 특정 형식이며, 이 데이터는 Python으로 작성되지 않은 패키징 도구 등에 의해 읽힐 필요가 있을 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e제안된 데이터에 대한 예시 Python 리터럴 파일은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 빌드 구성\r\n{\r\n    \"build\": {\r\n        \"requires\": [\r\n            \"setuptools\",\r\n            \"wheel\u003e=0.27\",  # 후행 쉼표\r\n            # \"numpy\u003e=1.10\" # 주석 처리된 데이터 라인\r\n        ]  # 임의의 주석\r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003ccode\u003esetup.cfg\u003c/code\u003e 유지 (Sticking with setup.cfg)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esetuptools\u003c/code\u003e에서 일반적인 형식으로 사용되는 \u003ccode\u003esetup.cfg\u003c/code\u003e에는 두 가지 문제가 있습니다. 하나는 위에서 \u003ccode\u003econfigparser\u003c/code\u003e 논의에서 언급된 문제가 있는 \u003ccode\u003e.ini\u003c/code\u003e 파일이라는 것입니다. 다른 하나는 해당 파일의 스키마가 엄격하게 정의된 적이 없어서, \u003ccode\u003esetuptools\u003c/code\u003e 설치를 잠재적으로 혼란스럽게 하지 않고 어떤 형식을 안전하게 사용할 수 있을지 알 수 없다는 것입니다.\u003c/p\u003e\n\u003ch3\u003e다른 파일 이름 (Other file names)\u003c/h3\u003e\n\u003cp\u003e여러 다른 파일 이름이 고려되었고 거부되었습니다 (비록 이것은 매우 \"바이크셰딩(bikeshedding)\" 주제이므로, 결정은 주로 취향에 따라 내려집니다).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epysettings.toml\u003c/code\u003e: 가장 합리적인 대안.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epypa.toml\u003c/code\u003e: PyPA를 참조하는 것이 합리적이지만, 다소 틈새 용어입니다. 도메인 특정 지식 없이도 파일 이름이 이해되는 것이 더 좋습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epybuild.toml\u003c/code\u003e: 이 PEP의 제한적인 관점에서는 이 파일 이름이 합리적이지만, 빌드 관련이 아닌 메타데이터가 파일에 추가될 경우 이름이 의미를 잃게 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epip.toml\u003c/code\u003e: 너무 도구에 특화됨.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emeta.toml\u003c/code\u003e: 너무 일반적; 프로젝트가 자체 메타데이터 파일을 원할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esetup.toml\u003c/code\u003e: \u003ccode\u003esetup.py\u003c/code\u003e 덕분에 전통을 유지하지만, 파일이 미래에 포함할 수 있는 내용과 반드시 일치하지는 않습니다 (예: 프로젝트 이름이 본질적으로 설정의 일부인가?).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epymeta.toml\u003c/code\u003e: 프로그래밍 및/또는 Python 초보자에게는 명확하지 않음.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epypackage.toml\u003c/code\u003e \u0026#x26; \u003ccode\u003epypackaging.toml\u003c/code\u003e: \"패키지\"가 무엇인지에 대한 이름 혼동 (프로젝트 대 네임스페이스).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epydevelop.toml\u003c/code\u003e: 파일에 개발에만 국한되지 않는 세부 정보가 포함될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epysource.toml\u003c/code\u003e: 소스 코드와 직접 관련 없음.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epytools.toml\u003c/code\u003e: 파일이 (현재) 프로젝트 관리를 목표로 하므로 오해의 소지가 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edstufft.toml\u003c/code\u003e: 너무 개인적. ;)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e참조 (References)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003edistutils\u003c/code\u003e (https://docs.python.org/3/library/distutils.html#module-distutils)\r\n\u003ccode\u003esetuptools\u003c/code\u003e (https://pypi.python.org/pypi/setuptools)\r\n\u003ccode\u003esetuptools\u003c/code\u003e: New and Changed \u003ccode\u003esetup()\u003c/code\u003e Keywords (http://pythonhosted.org/setuptools/setuptools.html#new-and-changed-setup-keywords)\r\n\u003ccode\u003epip\u003c/code\u003e (https://pypi.python.org/pypi/pip)\r\n\u003ccode\u003ewheel\u003c/code\u003e (https://pypi.python.org/pypi/wheel)\r\nTOML (https://github.com/toml-lang/toml)\r\nJSON (http://json.org/)\r\nYAML (http://yaml.org/)\r\n\u003ccode\u003econfigparser\u003c/code\u003e (https://docs.python.org/3/library/configparser.html#module-configparser)\r\n\u003ccode\u003ePyYAML\u003c/code\u003e (https://pypi.python.org/pypi/PyYAML)\r\nPyPA (https://www.pypa.io)\r\nBazel (http://bazel.io/)\r\n\u003ccode\u003east.literal_eval()\u003c/code\u003e (https://docs.python.org/3/library/ast.html#ast.literal_eval)\r\nCargo, Rust's package manager (http://doc.crates.io/)\r\nJSON Schema (http://json-schema.org/)\r\nNathaniel J. Smith's file format review (https://gist.github.com/njsmith/78f68204c5d969f8c8bc645ef77d4a8f)\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1098,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 518 - Specifying Minimum Build System Requirements for Python Projects\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:12:43+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>