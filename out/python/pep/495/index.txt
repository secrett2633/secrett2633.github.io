3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-19cfc001fdac3337.js","185","static/chunks/app/layout-c3e2e457f12fb6f6.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","931","static/chunks/app/page-51594f997fc19690.js"],""]
4:["slug","python/pep/495","c"]
0:["FeyCvJug7In7AgUZlfHUx",[[["",{"children":[["slug","python/pep/495","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"495\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/495","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e975486d410ad4e9.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T6621,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0495/">PEP 495 - Local Time Disambiguation</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 02-Aug-2015</p>
</blockquote>
<p>PEP 495: 로컬 시간 중의성 해소</p>
<h2>초록 (Abstract)</h2>
<p>이 PEP는 <code>datetime.time</code> 및 <code>datetime.datetime</code> 클래스의 인스턴스에 <code>fold</code>라는 새로운 속성을 추가하는 것을 제안합니다. 이 <code>fold</code> 속성은 로컬 시간이 동일하지만 실제 시점은 다른 두 시간을 구별하는 데 사용됩니다. <code>fold</code> 속성의 허용되는 값은 0과 1이며, 0은 중의적인 로컬 시간의 두 가지 가능한 해석 중 이른 시점에 해당하고, 1은 늦은 시점에 해당합니다.</p>
<h2>도입 배경 (Rationale)</h2>
<p>대부분의 지역에서는 로컬 시계가 뒤로 이동하는 시기가 존재했습니다. 이러한 시기에는 로컬 시계가 같은 날 두 번 같은 시간을 표시하는 구간이 발생합니다. 이러한 상황에서는 로컬 시계에 표시되는 정보(또는 Python <code>datetime</code> 인스턴스에 저장된 정보)만으로는 특정 시점을 식별하기에 불충분합니다. 제안된 해결책은 <code>datetime</code> 인스턴스에 0과 1의 값을 가지는 속성을 추가하여 두 가지 중의적인 시간을 열거하는 것입니다.</p>
<p>일광 절약 시간 (DST)을 준수하는 지역에서는 보통 가을에 시계를 한 시간 뒤로 되돌립니다. 드물지만 다른 이유로 시계가 뒤로 이동하는 경우도 있습니다. 예를 들어, 우크라이나는 1990년 3월의 봄철 시간 전환을 건너뛰고 대신 1990년 7월 1일에 시계를 뒤로 옮겨 모스크바 시간에서 동유럽 시간으로 변경했습니다. 이 경우 전환 전후 모두 표준(겨울) 시간이 적용되었습니다. DST 및 표준 시간 변경 모두 한 시간 외의 시간 이동을 초래할 수 있습니다.</p>
<h2>용어 (Terminology)</h2>
<p>시계가 뒤로 이동할 때, 우리는 시간 안에 "폴드(fold)"가 생성된다고 말합니다. 시계가 앞으로 이동할 때, "갭(gap)"이 생성됩니다. 폴드 안에 있는 로컬 시간을 "중의적(ambiguous)"이라고 부르며, 갭 안에 있는 로컬 시간을 "누락(missing)"이라고 부릅니다.</p>
<h2>제안 (Proposal)</h2>
<h3><code>fold</code> 속성 (The “fold” attribute)</h3>
<p><code>datetime.time</code> 및 <code>datetime.datetime</code> 클래스의 인스턴스에 <code>fold</code>라는 속성을 추가할 것을 제안합니다. 이 속성은 중의적인 경우의 두 번째(시간 순서상 늦은) 시점을 나타내는 인스턴스를 제외한 모든 인스턴스에 대해 0의 값을 가져야 합니다. 해당 인스턴스의 경우 값은 1이 됩니다.</p>
<h3>영향을 받는 API (Affected APIs)</h3>
<h4>속성 (Attributes)</h4>
<p><code>datetime.time</code> 및 <code>datetime.datetime</code> 클래스의 인스턴스는 두 가지 가능한 값(0과 1)을 갖는 새로운 <code>fold</code> 속성을 갖게 됩니다.</p>
<h4>생성자 (Constructors)</h4>
<p><code>datetime.time</code> 및 <code>datetime.datetime</code> 클래스의 <code>__new__</code> 메서드는 기본값 0을 갖는 <code>fold</code>라는 새로운 키워드 전용 인자(keyword-only argument)를 갖게 됩니다. <code>fold</code> 인수의 값은 반환된 인스턴스의 <code>fold</code> 속성 값을 초기화하는 데 사용됩니다.</p>
<h4>메서드 (Methods)</h4>
<p><code>datetime.time</code> 및 <code>datetime.datetime</code> 클래스의 <code>replace()</code> 메서드는 <code>fold</code>라는 새로운 키워드 전용 인자를 갖게 됩니다. 이 인자는 다른 <code>replace()</code> 인자와 유사하게 동작합니다. <code>fold</code> 인자가 지정되고 0 또는 1의 값이 주어지면, <code>replace()</code>에 의해 반환된 새 인스턴스는 해당 값으로 <code>fold</code> 속성이 설정됩니다.</p>
<h4>C-API</h4>
<p><code>PyDateTime_DateTime</code> 및 <code>PyDateTime_Time</code> 객체에서 <code>fold</code> 값을 추출하기 위한 접근 매크로가 정의됩니다.</p>
<ul>
<li><code>int PyDateTime_DATE_GET_FOLD(PyDateTime_DateTime *o)</code>: <code>fold</code> 값을 C <code>int</code>로 반환합니다.</li>
<li><code>int PyDateTime_TIME_GET_FOLD(PyDateTime_Time *o)</code>: <code>fold</code> 값을 C <code>int</code>로 반환합니다.</li>
</ul>
<p>생성된 인스턴스의 <code>fold</code> 값을 지정하기 위한 추가 인자를 받는 새로운 생성자가 정의됩니다.</p>
<ul>
<li><code>PyObject* PyDateTime_FromDateAndTimeAndFold(int year, int month, int day, int hour, int minute, int second, int usecond, int fold)</code>: 지정된 연, 월, 일, 시, 분, 초, 마이크로초 및 <code>fold</code>를 가진 <code>datetime.datetime</code> 객체를 반환합니다.</li>
<li><code>PyObject* PyTime_FromTimeAndFold(int hour, int minute, int second, int usecond, int fold)</code>: 지정된 시, 분, 초, 마이크로초 및 <code>fold</code>를 가진 <code>datetime.time</code> 객체를 반환합니다.</li>
</ul>
<h3>영향을 받는 동작 (Affected Behaviors)</h3>
<h4>지금 몇 시인가요? (What time is it?)</h4>
<p>인수 없이 호출된 <code>datetime.now()</code> 메서드는 시스템 로컬 시간 폴드에서 두 가지 중의적인 시간 중 두 번째 시간을 반환할 때 <code>fold=1</code>로 설정합니다. <code>tzinfo</code> 인수를 사용하여 호출될 경우, <code>fold</code> 값은 <code>tzinfo.fromutc()</code> 구현에 의해 결정됩니다. <code>datetime.timezone</code> 클래스 인스턴스(예: <code>datetime.timezone.utc</code>)가 <code>tzinfo</code>로 전달되면 반환된 <code>datetime</code> 인스턴스는 항상 <code>fold=0</code>을 갖습니다. <code>datetime.utcnow()</code> 메서드는 영향을 받지 않습니다.</p>
<h4>naive 시간에서 aware 시간으로의 변환 (Conversion from naive to aware)</h4>
<p>naive <code>datetime</code> 인스턴스를 aware <code>datetime</code>으로 변환하는 것을 용이하게 하기 위한 새로운 기능이 제안됩니다.</p>
<p><code>astimezone()</code> 메서드는 이제 naive <code>self</code>에 대해 작동합니다. 이 경우 시스템 로컬 시간대가 가정되며, <code>fold</code> 플래그는 중의적인 경우 어떤 로컬 시간대가 적용되는지 결정하는 데 사용됩니다.</p>
<p>예를 들어, US/Eastern 시간대로 설정된 시스템에서:</p>
<pre><code class="language-python">>>> dt = datetime(2014, 11, 2, 1, 30)
>>> dt.astimezone().strftime('%D %T %Z%z')
'11/02/14 01:30:00 EDT-0400'
>>> dt.replace(fold=1).astimezone().strftime('%D %T %Z%z')
'11/02/14 01:30:00 EST-0500'
</code></pre>
<p>이는 <code>datetime.now(tz)</code>가 <code>datetime.now().astimezone(tz)</code>와 완전히 동등하다는 것을 의미합니다 (단, <code>tz</code>는 PEP 이후의 <code>tzinfo</code> 구현 인스턴스, 즉 <code>fold</code>를 올바르게 처리하고 설정하는 인스턴스여야 합니다).</p>
<h4>Epoch 이후 POSIX 초에서 변환 (Conversion from POSIX seconds from EPOCH)</h4>
<p><code>datetime.datetime</code>의 정적 메서드 <code>fromtimestamp()</code>는 반환되는 객체에서 <code>fold</code> 속성을 적절하게 설정합니다.</p>
<p>예를 들어, US/Eastern 시간대로 설정된 시스템에서:</p>
<pre><code class="language-python">>>> datetime.fromtimestamp(1414906200)
datetime.datetime(2014, 11, 2, 1, 30)
>>> datetime.fromtimestamp(1414906200 + 3600)
datetime.datetime(2014, 11, 2, 1, 30, fold=1)
</code></pre>
<h4>Epoch 이후 POSIX 초로 변환 (Conversion to POSIX seconds from EPOCH)</h4>
<p><code>datetime.datetime</code>의 <code>timestamp()</code> 메서드는 <code>fold</code> 속성 값만 다른 <code>datetime.datetime</code> 인스턴스가 중의적이거나 누락된 시간을 나타내는 경우에만 다른 값을 반환합니다.</p>
<p><code>datetime.datetime</code> 인스턴스 <code>dt</code>가 중의적인 시간을 나타낼 때, <code>s0</code>과 <code>s1</code>이라는 두 가지 값이 존재합니다.</p>
<p><code>datetime.fromtimestamp(s0) == datetime.fromtimestamp(s1) == dt</code></p>
<p>이 경우 <code>dt.timestamp()</code>는 <code>dt.fold == 0</code>이면 <code>s0</code>과 <code>s1</code> 중 작은 값을 반환하고, 그렇지 않으면 큰 값을 반환합니다.</p>
<p>예를 들어, US/Eastern 시간대로 설정된 시스템에서:</p>
<pre><code class="language-python">>>> datetime(2014, 11, 2, 1, 30, fold=0).timestamp()
1414906200.0
>>> datetime(2014, 11, 2, 1, 30, fold=1).timestamp()
1414909800.0
</code></pre>
<p><code>datetime.datetime</code> 인스턴스 <code>dt</code>가 누락된 시간을 나타낼 때, <code>datetime.fromtimestamp(s) == dt</code>를 만족하는 <code>s</code> 값은 없습니다. 하지만 갭의 크기(초)만큼 다른 두 개의 "알아두면 좋은" <code>s</code> 값을 형성할 수 있습니다.</p>
<p>누락된 <code>dt</code>에 대해 <code>dt.timestamp()</code>가 반환하는 값은 <code>dt.fold == 0</code>이면 두 "알아두면 좋은" 값 중 큰 값을 반환하고, 그렇지 않으면 작은 값을 반환합니다. (이는 오타가 아니며, 중의적인 시간 규칙과 의도적으로 반대입니다.)</p>
<p>예를 들어, US/Eastern 시간대로 설정된 시스템에서:</p>
<pre><code class="language-python">>>> datetime(2015, 3, 8, 2, 30, fold=0).timestamp()
1425799800.0
>>> datetime(2015, 3, 8, 2, 30, fold=1).timestamp()
1425796200.0
</code></pre>
<h4>Aware datetime 인스턴스 (Aware datetime instances)</h4>
<p>PEP 이전의 <code>tzinfo</code> 구현을 사용하는 사용자들은 aware <code>datetime</code> 인스턴스의 동작에서 어떤 변화도 보지 못할 것입니다. <code>fold</code> 속성 값만 다른 두 인스턴스는 <code>fold</code> 값에 대한 명시적인 접근 외에는 어떤 방법으로도 구별할 수 없습니다. (이는 PEP 이전 구현이 <code>fold</code> 속성을 사용하지 않기 때문입니다.)</p>
<p>반면에 객체의 <code>tzinfo</code>가 <code>fold</code>-aware 구현으로 설정되면, 폴드 또는 갭에서 <code>fold</code> 값은 <code>utcoffset()</code>, <code>dst()</code>, <code>tzname()</code>, <code>astimezone()</code>, <code>strftime()</code> (형식 지정에 "%Z" 또는 "%z" 지시어가 사용된 경우), <code>isoformat()</code>, <code>timetuple()</code> 등 여러 메서드의 결과에 영향을 미칩니다.</p>
<h4>날짜와 시간 결합 및 분리 (Combining and splitting date and time)</h4>
<p><code>datetime.datetime.combine()</code> 메서드는 <code>fold</code> 속성 값을 결과 <code>datetime.datetime</code> 인스턴스로 복사합니다.
<code>datetime.datetime.time()</code> 메서드는 <code>fold</code> 속성 값을 결과 <code>datetime.time</code> 인스턴스로 복사합니다.</p>
<h4>Pickles</h4>
<p><code>fold</code> 속성의 값은 프로토콜 버전 4 (Python 3.4에서 도입) 이상으로 생성된 pickle에만 저장됩니다.
<code>datetime.datetime</code> 및 <code>datetime.time</code> 객체의 pickle 크기는 변경되지 않습니다. <code>fold</code> 값은 <code>datetime.datetime</code> pickle 페이로드의 3번째 바이트의 첫 번째 비트와 <code>datetime.time</code> 페이로드의 첫 번째 바이트의 첫 번째 비트에 인코딩됩니다. 현재 구현에서 이 바이트들은 월(1-12)과 시간(0-23) 값을 저장하는 데 사용되며, 첫 번째 비트는 항상 0입니다.</p>
<h3>표준 라이브러리의 <code>tzinfo</code> 구현 (Implementations of tzinfo in the Standard Library)</h3>
<p>이 PEP에서는 <code>datetime.tzinfo</code> 추상 클래스의 새로운 구현을 제안하지 않습니다. 기존의 (고정 오프셋) 시간대(timezone)는 중의적인 로컬 시간을 도입하지 않으며, <code>utcoffset()</code> 구현은 <code>fold</code> 값에 관계없이 현재와 동일한 상수 값을 반환할 것입니다.</p>
<p>추상 <code>datetime.tzinfo</code> 클래스의 <code>fromutc()</code> 기본 구현은 변경되지 않습니다. 현재 stdlib의 유일한 <code>tzinfo</code> 구현(<code>datetime.timezone</code> 클래스)이 <code>fromutc()</code>를 오버라이드하기 때문에 어디에도 사용되지 않습니다. 기본 구현을 변경하지 않으면 기본 <code>fromutc()</code>를 상속하는 PEP 이전의 서드 파티 구현이 의도치 않게 영향을 받지 않는다는 이점이 있습니다.</p>
<h3>새로운 <code>tzinfo</code> 구현을 위한 가이드라인 (Guidelines for New tzinfo Implementations)</h3>
<p>가변 UTC 오프셋(DST 및 기타 원인으로 인한)을 지원하려는 구체적인 <code>datetime.tzinfo</code> 서브클래스 구현자는 다음 가이드라인을 따라야 합니다.</p>
<h4>무지는 축복이다 (Ignorance is Bliss)</h4>
<p><code>utcoffset()</code>, <code>tzname()</code>, <code>dst()</code> 메서드의 새로운 구현은 중의적이거나 누락된 시간에 대해 호출되지 않는 한 <code>fold</code> 값을 무시해야 합니다.</p>
<h4>폴드 안에서 (In the Fold)</h4>
<p>새로운 서브클래스는 기본 클래스의 <code>fromutc()</code> 메서드를 오버라이드하고, 두 개의 다른 UTC 시간 <code>u0</code>과 <code>u1</code>(<code>u0 &#x3C; u1</code>)이 동일한 로컬 시간 <code>t</code>에 해당하는 모든 경우에 <code>fromutc(u0)</code>는 <code>fold=0</code>인 인스턴스를 반환하고, <code>fromutc(u1)</code>는 <code>fold=1</code>인 인스턴스를 반환하도록 구현해야 합니다. 다른 모든 경우에는 반환된 인스턴스는 <code>fold=0</code>을 가져야 합니다.</p>
<p><code>utcoffset()</code>, <code>tzname()</code>, <code>dst()</code> 메서드는 <code>fold</code> 속성 값을 사용하여 중의적인 시간 <code>t</code>가 전환 전 또는 후의 시간에 해당하는지 여부를 결정해야 합니다. 정의에 따라 <code>utcoffset()</code>은 폴드를 생성하는 모든 전환 전에는 크고 전환 후에는 작습니다. <code>tzname()</code> 및 <code>dst()</code>가 반환하는 값은 전환 유형에 따라 <code>fold</code> 속성 값에 의존할 수도 있고 의존하지 않을 수도 있습니다.</p>
<h4>갭을 조심하세요 (Mind the Gap)</h4>
<p><code>fromutc()</code> 메서드는 갭 내의 시간을 생성해서는 안 됩니다.</p>
<p><code>utcoffset()</code>, <code>tzname()</code>, <code>dst()</code> 메서드가 갭에 속하는 로컬 시간에 대해 호출되면, <code>fold=0</code>인 경우 전환 전 규칙이 사용되어야 합니다. 그렇지 않으면 전환 후 규칙이 사용되어야 합니다.</p>
<h4>전환 시 규칙 요약 (Summary of Rules at a Transition)</h4>
<p>중의적이거나 누락된 시간에 <code>utcoffset()</code>은 다음 표에 따라 값을 반환해야 합니다.</p>
<p>| | <code>fold=0</code> | <code>fold=1</code> |
|---|---|---|
| <strong>Fold</strong> | <code>oldoff</code> | <code>newoff = oldoff - delta</code> |
| <strong>Gap</strong> | <code>oldoff</code> | <code>newoff = oldoff + delta</code> |</p>
<p>여기서 <code>oldoff</code> (<code>newoff</code>)는 전환 전 (후) UTC 오프셋이고 <code>delta</code>는 폴드 또는 갭의 절대 크기입니다.</p>
<h4>DST 전환 (The DST Transitions)</h4>
<p>DST 시작 시 도입된 누락된 시간에서 <code>utcoffset()</code> 및 <code>dst()</code> 메서드가 반환하는 값은 다음과 같아야 합니다.</p>
<p>| | <code>fold=0</code> | <code>fold=1</code> |
|---|---|---|
| <code>utcoffset()</code> | <code>stdoff</code> | <code>stdoff + dstoff</code> |
| <code>dst()</code> | <code>zero</code> | <code>dstoff</code> |</p>
<p>DST 종료 시 도입된 중의적인 시간에서 <code>utcoffset()</code> 및 <code>dst()</code> 메서드가 반환하는 값은 다음과 같아야 합니다.</p>
<p>| | <code>fold=0</code> | <code>fold=1</code> |
|---|---|---|
| <code>utcoffset()</code> | <code>stdoff + dstoff</code> | <code>stdoff</code> |
| <code>dst()</code> | <code>dstoff</code> | <code>zero</code> |</p>
<p>여기서 <code>stdoff</code>는 표준 (비-DST) 오프셋이고, <code>dstoff</code>는 DST 보정(<code>timedelta(hours=1)</code>이 일반적)이며, <code>zero = timedelta(0)</code>입니다.</p>
<h3>시간 산술 및 비교 연산자 (Temporal Arithmetic and Comparison Operators)</h3>
<p><code>fold</code> 속성의 값은 naive <code>datetime</code> 인스턴스를 사용하는 모든 연산에서 무시됩니다. 결과적으로 <code>fold</code> 값만 다른 naive <code>datetime.datetime</code> 또는 <code>datetime.time</code> 인스턴스는 같다고 비교됩니다. 이러한 인스턴스를 구별해야 하는 애플리케이션은 <code>fold</code> 값을 명시적으로 확인하거나 해당 인스턴스를 중의적인 시간이 없는 시간대(예: UTC)로 변환해야 합니다.</p>
<p><code>timedelta</code>가 aware 또는 naive <code>datetime</code> 인스턴스에 추가되거나 빼지는 경우에도 <code>fold</code> 값은 무시됩니다. <code>timedelta</code>를 <code>datetime</code>에 추가(또는 뺄셈)한 결과는 원래 <code>datetime</code> 인스턴스가 <code>fold=1</code>이었더라도 항상 <code>fold</code>가 0으로 설정됩니다.</p>
<p><code>datetime</code> 인스턴스 <code>t</code>와 <code>s</code>에 대한 차이 <code>t - s</code>가 계산되는 방식에는 변경이 제안되지 않습니다.</p>
<p>Naive 및 intra-zone 비교는 <code>fold</code> 값을 무시하고 현재와 동일한 결과를 반환합니다. (이는 하위 호환성을 유지하는 유일한 방법입니다. <code>fold</code>를 사용하는 aware intra-zone 비교가 필요하면 먼저 양쪽을 UTC로 변환해야 합니다.)</p>
<p>Inter-zone 뺄셈은 현재와 같이 정의됩니다: <code>t - s</code>는 <code>(t - t.utcoffset()) - (s - s.utcoffset()).replace(tzinfo=t.tzinfo)</code>로 계산되지만, <code>t.tzinfo</code> 또는 <code>s.tzinfo</code> 중 하나가 PEP 이후 구현인 경우 결과는 <code>t.fold</code> 및 <code>s.fold</code>의 값에 따라 달라집니다.</p>
<h4>Aware datetime 등가 비교 (Aware datetime Equality Comparison)</h4>
<p>aware <code>datetime</code> 비교 연산자는 현재와 동일하게 작동하며, 피연산자 중 하나의 <code>utcoffset()</code> 값이 <code>fold</code>에 의존할 때 결과는 간접적으로 <code>fold</code> 값의 영향을 받습니다. 단, 한 가지 예외가 있습니다. inter-zone 비교에서 하나 또는 둘 다의 피연산자가 <code>utcoffset()</code>이 <code>fold</code> 속성의 <code>fold</code> 값에 의존하는 경우, 결과는 <code>False</code>입니다.</p>
<h3>하위 및 상위 호환성 (Backward and Forward Compatibility)</h3>
<p>이 제안은 <code>fold</code> 플래그를 명시적으로 읽거나 이를 사용하는 <code>tzinfo</code> 구현을 사용하지 않는 프로그램에는 거의 영향을 미치지 않습니다. 이러한 프로그램에 대한 유일하게 눈에 띄는 변경 사항은 POSIX 타임스탬프와 상호 변환이 이제 올바르게 왕복한다는 것입니다 (부동 소수점 반올림 오차 내에서). 이전의 잘못된 동작에 대한 해결책을 구현한 프로그램은 수정해야 할 수도 있습니다.</p>
<p>오래된 프로그램으로 생성된 pickle은 완전히 상위 호환성을 유지합니다. 새로운 버전에서 <code>fold=1</code>로 pickle된 <code>datetime</code>/<code>time</code> 인스턴스만 이전 Python 버전에서는 읽을 수 없게 됩니다. <code>fold=0</code> (기본값) 인스턴스의 pickle은 변경되지 않습니다.</p>
<h3>질문과 답변 (Questions and Answers)</h3>
<h4>왜 새 플래그를 "isdst"라고 부르지 않나요? (Why not call the new flag “isdst”?)</h4>
<p><strong>비기술적 답변 (A non-technical answer)</strong></p>
<p><code>isdst</code>라는 이름은 Daylight Saving Time (DST)과 관련되어 혼란을 줄 수 있습니다. <code>fold</code>는 DST뿐만 아니라 시계가 뒤로 이동하는 모든 상황을 포괄하는 더 일반적인 개념입니다.</p>
<p><strong>기술적 이유 (A technical reason)</strong></p>
<p><code>time.struct_time</code> 객체의 <code>tm_isdst</code> 필드는 폴드에서 로컬 시간을 중의적으로 해소하는 데 사용될 수 있지만, 그러한 중의성 해소의 의미론은 이 PEP의 제안과 완전히 다릅니다.
<code>tm_isdst</code> 필드의 주요 문제는 시간대에 대한 자세한 정보(이는 <code>tzinfo</code> 구현에서만 사용 가능)를 알지 못하면 <code>tm_isdst</code>에 적절한 값을 알 수 없다는 것입니다.
<code>tm_isdst</code>와 달리 제안된 <code>fold</code> 속성은 해당 속성 없이 두 가지 (또는 없음) 해석이 가능하지 않는 한 <code>datetime</code> 인스턴스의 해석에 영향을 미치지 않습니다.</p>
<p><code>tm_isdst</code>와 동일한 의미론을 갖지 않는 <code>isdst</code>라는 이름을 사용하는 것은 매우 혼란스러울 것이기 때문에 다른 이름이 필요합니다. 또한 <code>datetime.datetime</code> 클래스에는 이미 <code>dst()</code>라는 메서드가 있으며, <code>fold</code>를 "isdst"라고 부르면 "isdst"가 0인데 <code>dst()</code>는 0이 아니거나 그 반대인 상황이 필연적으로 발생할 것입니다.</p>
<h4>왜 "fold"인가요? (Why “fold”?)</h4>
<p>Guido van Rossum이 제안했으며, 한 저자가 선호했습니다. 속성의 허용되는 값이 <code>False</code>/<code>True</code>에서 <code>0</code>/<code>1</code>로 변경된 후 합의가 이루어졌습니다. "fold"라는 명사는 올바른 함의를 가지며 기억하기 쉬운 규칙을 제공하지만, 동시에 근거 없는 가정을 유도하지 않습니다.</p>
<h4>"first"는 무엇인가요? (What is “first”?)</h4>
<p>이는 초기에는 명백한 대안("second")이 기존 속성과 충돌하기 때문에 선택된 속성의 작업 이름이었습니다. 주로 <code>True</code>를 기본값으로 만들 것이라는 이유로 거부되었습니다.</p>
<h4>두 가지 값으로 충분한가요? (Are two values enough?)</h4>
<p><code>fold</code> 속성에 <code>None</code> 또는 <code>-1</code> 값을 허용해야 한다는 몇 가지 이유가 제기되었습니다: 하위 호환성, <code>tm_isdst</code>와의 유사성, 그리고 무효 시간(invalid time)에 대한 엄격한 확인.</p>
<p><strong>하위 호환성 (Backward Compatibility)</strong></p>
<p><code>fold</code> 플래그의 기본값이 <code>None</code>이면 PEP 이전 동작을 요청하는 신호가 될 수 있어 하위 호환성을 개선할 수 있다는 제안이 있었습니다. 아래 분석을 기반으로 <code>fold=0</code> 기본값으로 제안된 변경 사항이 충분히 하위 호환성을 갖는다고 판단합니다.</p>
<p>이 PEP는 프로그램이 달리 동일한 <code>datetime</code> 인스턴스가 다른 <code>fold</code> 값을 갖는다는 것을 발견할 수 있는 세 가지 방법을 제공합니다: (1) <code>fold</code> 속성의 명시적 확인; (2) 인스턴스가 naive인 경우 - <code>astimezone()</code> 메서드를 사용하여 다른 시간대로 변환; 그리고 (3) <code>timestamp()</code> 메서드를 사용하여 float으로 변환.</p>
<p><strong><code>tm_isdst</code>와의 유사성 (Analogy with tm_isdst)</strong></p>
<p><code>time.mktime</code> 인터페이스는 <code>tm_isdst</code> 플래그에 대해 <code>-1, 0, 1</code> 세 가지 값을 허용합니다. 위에서 설명했듯이, <code>-1</code> (주어진 시간에 대해 DST가 적용되는지 여부를 <code>mktime</code>이 나머지 필드에서 결정하도록 요청)이 실제로 유용한 유일한 선택입니다.</p>
<p>그러나 <code>fold</code> 플래그를 사용하면 <code>datetime.timestamp()</code>는 대부분의 DST 전환 시간대에서 99.98%의 시간 동안 <code>tm_isdst=-1</code>을 사용한 <code>mktime</code>과 동일한 값을 반환합니다. 게다가 <code>tm_isdst=-1</code>과 같은 동작은 <code>fold</code> 값에 관계없이 지정됩니다.</p>
<p><strong>엄격한 무효 시간 확인 (Strict Invalid Time Checking)</strong></p>
<p>또 다른 제안은 <code>fold=-1</code> 또는 <code>fold=None</code>을 사용하여 프로그램이 폴드와 갭을 처리할 수 있는 수단이 없음을 나타내고, <code>dt</code>가 중의적이거나 누락된 로컬 시간을 나타낼 때마다 <code>dt.utcoffset()</code>이 오류를 발생시키도록 하는 것이었습니다.</p>
<p>이 제안의 주요 문제는 <code>dt.utcoffset()</code>이 오류를 발생시키는 것이 옵션이 아닌 상황에서 내부적으로 사용된다는 것입니다. 예를 들어, 딕셔너리 조회 또는 목록/세트 멤버십 확인 등입니다. 따라서 엄격한 갭/폴드 확인 동작은 별도의 플래그(<code>dt.utcoffset(raise_on_gap=True, raise_on_fold=False)</code>)로 제어되어야 합니다. 그러나 이 기능은 사용자 코드에서 쉽게 구현할 수 있습니다.</p>
<h2>구현 (Implementation)</h2>
<p>Github fork: <a href="https://github.com/abalkin/cpython/tree/issue24773-s3">https://github.com/abalkin/cpython/tree/issue24773-s3</a>
Tracker issue: <a href="http://bugs.python.org/issue24773">http://bugs.python.org/issue24773</a></p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1098,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 495 - Local Time Disambiguation"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 22:40:14+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}]]
1:null
