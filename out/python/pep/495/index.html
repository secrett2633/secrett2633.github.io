<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/da5e1dc2b9a7c5bb.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-aecaf5ac7a84facf.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-e3ea38185bb36cd2.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 495 - Local Time Disambiguation</h1><div class="page__meta"><time dateTime="2025-09-26 22:40:14+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0495/">PEP 495 - Local Time Disambiguation</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 02-Aug-2015</p>
</blockquote>
<p>PEP 495: 로컬 시간 중의성 해소</p>
<h2>초록 (Abstract)</h2>
<p>이 PEP는 <code>datetime.time</code> 및 <code>datetime.datetime</code> 클래스의 인스턴스에 <code>fold</code>라는 새로운 속성을 추가하는 것을 제안합니다. 이 <code>fold</code> 속성은 로컬 시간이 동일하지만 실제 시점은 다른 두 시간을 구별하는 데 사용됩니다. <code>fold</code> 속성의 허용되는 값은 0과 1이며, 0은 중의적인 로컬 시간의 두 가지 가능한 해석 중 이른 시점에 해당하고, 1은 늦은 시점에 해당합니다.</p>
<h2>도입 배경 (Rationale)</h2>
<p>대부분의 지역에서는 로컬 시계가 뒤로 이동하는 시기가 존재했습니다. 이러한 시기에는 로컬 시계가 같은 날 두 번 같은 시간을 표시하는 구간이 발생합니다. 이러한 상황에서는 로컬 시계에 표시되는 정보(또는 Python <code>datetime</code> 인스턴스에 저장된 정보)만으로는 특정 시점을 식별하기에 불충분합니다. 제안된 해결책은 <code>datetime</code> 인스턴스에 0과 1의 값을 가지는 속성을 추가하여 두 가지 중의적인 시간을 열거하는 것입니다.</p>
<p>일광 절약 시간 (DST)을 준수하는 지역에서는 보통 가을에 시계를 한 시간 뒤로 되돌립니다. 드물지만 다른 이유로 시계가 뒤로 이동하는 경우도 있습니다. 예를 들어, 우크라이나는 1990년 3월의 봄철 시간 전환을 건너뛰고 대신 1990년 7월 1일에 시계를 뒤로 옮겨 모스크바 시간에서 동유럽 시간으로 변경했습니다. 이 경우 전환 전후 모두 표준(겨울) 시간이 적용되었습니다. DST 및 표준 시간 변경 모두 한 시간 외의 시간 이동을 초래할 수 있습니다.</p>
<h2>용어 (Terminology)</h2>
<p>시계가 뒤로 이동할 때, 우리는 시간 안에 "폴드(fold)"가 생성된다고 말합니다. 시계가 앞으로 이동할 때, "갭(gap)"이 생성됩니다. 폴드 안에 있는 로컬 시간을 "중의적(ambiguous)"이라고 부르며, 갭 안에 있는 로컬 시간을 "누락(missing)"이라고 부릅니다.</p>
<h2>제안 (Proposal)</h2>
<h3><code>fold</code> 속성 (The “fold” attribute)</h3>
<p><code>datetime.time</code> 및 <code>datetime.datetime</code> 클래스의 인스턴스에 <code>fold</code>라는 속성을 추가할 것을 제안합니다. 이 속성은 중의적인 경우의 두 번째(시간 순서상 늦은) 시점을 나타내는 인스턴스를 제외한 모든 인스턴스에 대해 0의 값을 가져야 합니다. 해당 인스턴스의 경우 값은 1이 됩니다.</p>
<h3>영향을 받는 API (Affected APIs)</h3>
<h4>속성 (Attributes)</h4>
<p><code>datetime.time</code> 및 <code>datetime.datetime</code> 클래스의 인스턴스는 두 가지 가능한 값(0과 1)을 갖는 새로운 <code>fold</code> 속성을 갖게 됩니다.</p>
<h4>생성자 (Constructors)</h4>
<p><code>datetime.time</code> 및 <code>datetime.datetime</code> 클래스의 <code>__new__</code> 메서드는 기본값 0을 갖는 <code>fold</code>라는 새로운 키워드 전용 인자(keyword-only argument)를 갖게 됩니다. <code>fold</code> 인수의 값은 반환된 인스턴스의 <code>fold</code> 속성 값을 초기화하는 데 사용됩니다.</p>
<h4>메서드 (Methods)</h4>
<p><code>datetime.time</code> 및 <code>datetime.datetime</code> 클래스의 <code>replace()</code> 메서드는 <code>fold</code>라는 새로운 키워드 전용 인자를 갖게 됩니다. 이 인자는 다른 <code>replace()</code> 인자와 유사하게 동작합니다. <code>fold</code> 인자가 지정되고 0 또는 1의 값이 주어지면, <code>replace()</code>에 의해 반환된 새 인스턴스는 해당 값으로 <code>fold</code> 속성이 설정됩니다.</p>
<h4>C-API</h4>
<p><code>PyDateTime_DateTime</code> 및 <code>PyDateTime_Time</code> 객체에서 <code>fold</code> 값을 추출하기 위한 접근 매크로가 정의됩니다.</p>
<ul>
<li><code>int PyDateTime_DATE_GET_FOLD(PyDateTime_DateTime *o)</code>: <code>fold</code> 값을 C <code>int</code>로 반환합니다.</li>
<li><code>int PyDateTime_TIME_GET_FOLD(PyDateTime_Time *o)</code>: <code>fold</code> 값을 C <code>int</code>로 반환합니다.</li>
</ul>
<p>생성된 인스턴스의 <code>fold</code> 값을 지정하기 위한 추가 인자를 받는 새로운 생성자가 정의됩니다.</p>
<ul>
<li><code>PyObject* PyDateTime_FromDateAndTimeAndFold(int year, int month, int day, int hour, int minute, int second, int usecond, int fold)</code>: 지정된 연, 월, 일, 시, 분, 초, 마이크로초 및 <code>fold</code>를 가진 <code>datetime.datetime</code> 객체를 반환합니다.</li>
<li><code>PyObject* PyTime_FromTimeAndFold(int hour, int minute, int second, int usecond, int fold)</code>: 지정된 시, 분, 초, 마이크로초 및 <code>fold</code>를 가진 <code>datetime.time</code> 객체를 반환합니다.</li>
</ul>
<h3>영향을 받는 동작 (Affected Behaviors)</h3>
<h4>지금 몇 시인가요? (What time is it?)</h4>
<p>인수 없이 호출된 <code>datetime.now()</code> 메서드는 시스템 로컬 시간 폴드에서 두 가지 중의적인 시간 중 두 번째 시간을 반환할 때 <code>fold=1</code>로 설정합니다. <code>tzinfo</code> 인수를 사용하여 호출될 경우, <code>fold</code> 값은 <code>tzinfo.fromutc()</code> 구현에 의해 결정됩니다. <code>datetime.timezone</code> 클래스 인스턴스(예: <code>datetime.timezone.utc</code>)가 <code>tzinfo</code>로 전달되면 반환된 <code>datetime</code> 인스턴스는 항상 <code>fold=0</code>을 갖습니다. <code>datetime.utcnow()</code> 메서드는 영향을 받지 않습니다.</p>
<h4>naive 시간에서 aware 시간으로의 변환 (Conversion from naive to aware)</h4>
<p>naive <code>datetime</code> 인스턴스를 aware <code>datetime</code>으로 변환하는 것을 용이하게 하기 위한 새로운 기능이 제안됩니다.</p>
<p><code>astimezone()</code> 메서드는 이제 naive <code>self</code>에 대해 작동합니다. 이 경우 시스템 로컬 시간대가 가정되며, <code>fold</code> 플래그는 중의적인 경우 어떤 로컬 시간대가 적용되는지 결정하는 데 사용됩니다.</p>
<p>예를 들어, US/Eastern 시간대로 설정된 시스템에서:</p>
<pre><code class="language-python">>>> dt = datetime(2014, 11, 2, 1, 30)
>>> dt.astimezone().strftime('%D %T %Z%z')
'11/02/14 01:30:00 EDT-0400'
>>> dt.replace(fold=1).astimezone().strftime('%D %T %Z%z')
'11/02/14 01:30:00 EST-0500'
</code></pre>
<p>이는 <code>datetime.now(tz)</code>가 <code>datetime.now().astimezone(tz)</code>와 완전히 동등하다는 것을 의미합니다 (단, <code>tz</code>는 PEP 이후의 <code>tzinfo</code> 구현 인스턴스, 즉 <code>fold</code>를 올바르게 처리하고 설정하는 인스턴스여야 합니다).</p>
<h4>Epoch 이후 POSIX 초에서 변환 (Conversion from POSIX seconds from EPOCH)</h4>
<p><code>datetime.datetime</code>의 정적 메서드 <code>fromtimestamp()</code>는 반환되는 객체에서 <code>fold</code> 속성을 적절하게 설정합니다.</p>
<p>예를 들어, US/Eastern 시간대로 설정된 시스템에서:</p>
<pre><code class="language-python">>>> datetime.fromtimestamp(1414906200)
datetime.datetime(2014, 11, 2, 1, 30)
>>> datetime.fromtimestamp(1414906200 + 3600)
datetime.datetime(2014, 11, 2, 1, 30, fold=1)
</code></pre>
<h4>Epoch 이후 POSIX 초로 변환 (Conversion to POSIX seconds from EPOCH)</h4>
<p><code>datetime.datetime</code>의 <code>timestamp()</code> 메서드는 <code>fold</code> 속성 값만 다른 <code>datetime.datetime</code> 인스턴스가 중의적이거나 누락된 시간을 나타내는 경우에만 다른 값을 반환합니다.</p>
<p><code>datetime.datetime</code> 인스턴스 <code>dt</code>가 중의적인 시간을 나타낼 때, <code>s0</code>과 <code>s1</code>이라는 두 가지 값이 존재합니다.</p>
<p><code>datetime.fromtimestamp(s0) == datetime.fromtimestamp(s1) == dt</code></p>
<p>이 경우 <code>dt.timestamp()</code>는 <code>dt.fold == 0</code>이면 <code>s0</code>과 <code>s1</code> 중 작은 값을 반환하고, 그렇지 않으면 큰 값을 반환합니다.</p>
<p>예를 들어, US/Eastern 시간대로 설정된 시스템에서:</p>
<pre><code class="language-python">>>> datetime(2014, 11, 2, 1, 30, fold=0).timestamp()
1414906200.0
>>> datetime(2014, 11, 2, 1, 30, fold=1).timestamp()
1414909800.0
</code></pre>
<p><code>datetime.datetime</code> 인스턴스 <code>dt</code>가 누락된 시간을 나타낼 때, <code>datetime.fromtimestamp(s) == dt</code>를 만족하는 <code>s</code> 값은 없습니다. 하지만 갭의 크기(초)만큼 다른 두 개의 "알아두면 좋은" <code>s</code> 값을 형성할 수 있습니다.</p>
<p>누락된 <code>dt</code>에 대해 <code>dt.timestamp()</code>가 반환하는 값은 <code>dt.fold == 0</code>이면 두 "알아두면 좋은" 값 중 큰 값을 반환하고, 그렇지 않으면 작은 값을 반환합니다. (이는 오타가 아니며, 중의적인 시간 규칙과 의도적으로 반대입니다.)</p>
<p>예를 들어, US/Eastern 시간대로 설정된 시스템에서:</p>
<pre><code class="language-python">>>> datetime(2015, 3, 8, 2, 30, fold=0).timestamp()
1425799800.0
>>> datetime(2015, 3, 8, 2, 30, fold=1).timestamp()
1425796200.0
</code></pre>
<h4>Aware datetime 인스턴스 (Aware datetime instances)</h4>
<p>PEP 이전의 <code>tzinfo</code> 구현을 사용하는 사용자들은 aware <code>datetime</code> 인스턴스의 동작에서 어떤 변화도 보지 못할 것입니다. <code>fold</code> 속성 값만 다른 두 인스턴스는 <code>fold</code> 값에 대한 명시적인 접근 외에는 어떤 방법으로도 구별할 수 없습니다. (이는 PEP 이전 구현이 <code>fold</code> 속성을 사용하지 않기 때문입니다.)</p>
<p>반면에 객체의 <code>tzinfo</code>가 <code>fold</code>-aware 구현으로 설정되면, 폴드 또는 갭에서 <code>fold</code> 값은 <code>utcoffset()</code>, <code>dst()</code>, <code>tzname()</code>, <code>astimezone()</code>, <code>strftime()</code> (형식 지정에 "%Z" 또는 "%z" 지시어가 사용된 경우), <code>isoformat()</code>, <code>timetuple()</code> 등 여러 메서드의 결과에 영향을 미칩니다.</p>
<h4>날짜와 시간 결합 및 분리 (Combining and splitting date and time)</h4>
<p><code>datetime.datetime.combine()</code> 메서드는 <code>fold</code> 속성 값을 결과 <code>datetime.datetime</code> 인스턴스로 복사합니다.
<code>datetime.datetime.time()</code> 메서드는 <code>fold</code> 속성 값을 결과 <code>datetime.time</code> 인스턴스로 복사합니다.</p>
<h4>Pickles</h4>
<p><code>fold</code> 속성의 값은 프로토콜 버전 4 (Python 3.4에서 도입) 이상으로 생성된 pickle에만 저장됩니다.
<code>datetime.datetime</code> 및 <code>datetime.time</code> 객체의 pickle 크기는 변경되지 않습니다. <code>fold</code> 값은 <code>datetime.datetime</code> pickle 페이로드의 3번째 바이트의 첫 번째 비트와 <code>datetime.time</code> 페이로드의 첫 번째 바이트의 첫 번째 비트에 인코딩됩니다. 현재 구현에서 이 바이트들은 월(1-12)과 시간(0-23) 값을 저장하는 데 사용되며, 첫 번째 비트는 항상 0입니다.</p>
<h3>표준 라이브러리의 <code>tzinfo</code> 구현 (Implementations of tzinfo in the Standard Library)</h3>
<p>이 PEP에서는 <code>datetime.tzinfo</code> 추상 클래스의 새로운 구현을 제안하지 않습니다. 기존의 (고정 오프셋) 시간대(timezone)는 중의적인 로컬 시간을 도입하지 않으며, <code>utcoffset()</code> 구현은 <code>fold</code> 값에 관계없이 현재와 동일한 상수 값을 반환할 것입니다.</p>
<p>추상 <code>datetime.tzinfo</code> 클래스의 <code>fromutc()</code> 기본 구현은 변경되지 않습니다. 현재 stdlib의 유일한 <code>tzinfo</code> 구현(<code>datetime.timezone</code> 클래스)이 <code>fromutc()</code>를 오버라이드하기 때문에 어디에도 사용되지 않습니다. 기본 구현을 변경하지 않으면 기본 <code>fromutc()</code>를 상속하는 PEP 이전의 서드 파티 구현이 의도치 않게 영향을 받지 않는다는 이점이 있습니다.</p>
<h3>새로운 <code>tzinfo</code> 구현을 위한 가이드라인 (Guidelines for New tzinfo Implementations)</h3>
<p>가변 UTC 오프셋(DST 및 기타 원인으로 인한)을 지원하려는 구체적인 <code>datetime.tzinfo</code> 서브클래스 구현자는 다음 가이드라인을 따라야 합니다.</p>
<h4>무지는 축복이다 (Ignorance is Bliss)</h4>
<p><code>utcoffset()</code>, <code>tzname()</code>, <code>dst()</code> 메서드의 새로운 구현은 중의적이거나 누락된 시간에 대해 호출되지 않는 한 <code>fold</code> 값을 무시해야 합니다.</p>
<h4>폴드 안에서 (In the Fold)</h4>
<p>새로운 서브클래스는 기본 클래스의 <code>fromutc()</code> 메서드를 오버라이드하고, 두 개의 다른 UTC 시간 <code>u0</code>과 <code>u1</code>(<code>u0 &#x3C; u1</code>)이 동일한 로컬 시간 <code>t</code>에 해당하는 모든 경우에 <code>fromutc(u0)</code>는 <code>fold=0</code>인 인스턴스를 반환하고, <code>fromutc(u1)</code>는 <code>fold=1</code>인 인스턴스를 반환하도록 구현해야 합니다. 다른 모든 경우에는 반환된 인스턴스는 <code>fold=0</code>을 가져야 합니다.</p>
<p><code>utcoffset()</code>, <code>tzname()</code>, <code>dst()</code> 메서드는 <code>fold</code> 속성 값을 사용하여 중의적인 시간 <code>t</code>가 전환 전 또는 후의 시간에 해당하는지 여부를 결정해야 합니다. 정의에 따라 <code>utcoffset()</code>은 폴드를 생성하는 모든 전환 전에는 크고 전환 후에는 작습니다. <code>tzname()</code> 및 <code>dst()</code>가 반환하는 값은 전환 유형에 따라 <code>fold</code> 속성 값에 의존할 수도 있고 의존하지 않을 수도 있습니다.</p>
<h4>갭을 조심하세요 (Mind the Gap)</h4>
<p><code>fromutc()</code> 메서드는 갭 내의 시간을 생성해서는 안 됩니다.</p>
<p><code>utcoffset()</code>, <code>tzname()</code>, <code>dst()</code> 메서드가 갭에 속하는 로컬 시간에 대해 호출되면, <code>fold=0</code>인 경우 전환 전 규칙이 사용되어야 합니다. 그렇지 않으면 전환 후 규칙이 사용되어야 합니다.</p>
<h4>전환 시 규칙 요약 (Summary of Rules at a Transition)</h4>
<p>중의적이거나 누락된 시간에 <code>utcoffset()</code>은 다음 표에 따라 값을 반환해야 합니다.</p>
<p>| | <code>fold=0</code> | <code>fold=1</code> |
|---|---|---|
| <strong>Fold</strong> | <code>oldoff</code> | <code>newoff = oldoff - delta</code> |
| <strong>Gap</strong> | <code>oldoff</code> | <code>newoff = oldoff + delta</code> |</p>
<p>여기서 <code>oldoff</code> (<code>newoff</code>)는 전환 전 (후) UTC 오프셋이고 <code>delta</code>는 폴드 또는 갭의 절대 크기입니다.</p>
<h4>DST 전환 (The DST Transitions)</h4>
<p>DST 시작 시 도입된 누락된 시간에서 <code>utcoffset()</code> 및 <code>dst()</code> 메서드가 반환하는 값은 다음과 같아야 합니다.</p>
<p>| | <code>fold=0</code> | <code>fold=1</code> |
|---|---|---|
| <code>utcoffset()</code> | <code>stdoff</code> | <code>stdoff + dstoff</code> |
| <code>dst()</code> | <code>zero</code> | <code>dstoff</code> |</p>
<p>DST 종료 시 도입된 중의적인 시간에서 <code>utcoffset()</code> 및 <code>dst()</code> 메서드가 반환하는 값은 다음과 같아야 합니다.</p>
<p>| | <code>fold=0</code> | <code>fold=1</code> |
|---|---|---|
| <code>utcoffset()</code> | <code>stdoff + dstoff</code> | <code>stdoff</code> |
| <code>dst()</code> | <code>dstoff</code> | <code>zero</code> |</p>
<p>여기서 <code>stdoff</code>는 표준 (비-DST) 오프셋이고, <code>dstoff</code>는 DST 보정(<code>timedelta(hours=1)</code>이 일반적)이며, <code>zero = timedelta(0)</code>입니다.</p>
<h3>시간 산술 및 비교 연산자 (Temporal Arithmetic and Comparison Operators)</h3>
<p><code>fold</code> 속성의 값은 naive <code>datetime</code> 인스턴스를 사용하는 모든 연산에서 무시됩니다. 결과적으로 <code>fold</code> 값만 다른 naive <code>datetime.datetime</code> 또는 <code>datetime.time</code> 인스턴스는 같다고 비교됩니다. 이러한 인스턴스를 구별해야 하는 애플리케이션은 <code>fold</code> 값을 명시적으로 확인하거나 해당 인스턴스를 중의적인 시간이 없는 시간대(예: UTC)로 변환해야 합니다.</p>
<p><code>timedelta</code>가 aware 또는 naive <code>datetime</code> 인스턴스에 추가되거나 빼지는 경우에도 <code>fold</code> 값은 무시됩니다. <code>timedelta</code>를 <code>datetime</code>에 추가(또는 뺄셈)한 결과는 원래 <code>datetime</code> 인스턴스가 <code>fold=1</code>이었더라도 항상 <code>fold</code>가 0으로 설정됩니다.</p>
<p><code>datetime</code> 인스턴스 <code>t</code>와 <code>s</code>에 대한 차이 <code>t - s</code>가 계산되는 방식에는 변경이 제안되지 않습니다.</p>
<p>Naive 및 intra-zone 비교는 <code>fold</code> 값을 무시하고 현재와 동일한 결과를 반환합니다. (이는 하위 호환성을 유지하는 유일한 방법입니다. <code>fold</code>를 사용하는 aware intra-zone 비교가 필요하면 먼저 양쪽을 UTC로 변환해야 합니다.)</p>
<p>Inter-zone 뺄셈은 현재와 같이 정의됩니다: <code>t - s</code>는 <code>(t - t.utcoffset()) - (s - s.utcoffset()).replace(tzinfo=t.tzinfo)</code>로 계산되지만, <code>t.tzinfo</code> 또는 <code>s.tzinfo</code> 중 하나가 PEP 이후 구현인 경우 결과는 <code>t.fold</code> 및 <code>s.fold</code>의 값에 따라 달라집니다.</p>
<h4>Aware datetime 등가 비교 (Aware datetime Equality Comparison)</h4>
<p>aware <code>datetime</code> 비교 연산자는 현재와 동일하게 작동하며, 피연산자 중 하나의 <code>utcoffset()</code> 값이 <code>fold</code>에 의존할 때 결과는 간접적으로 <code>fold</code> 값의 영향을 받습니다. 단, 한 가지 예외가 있습니다. inter-zone 비교에서 하나 또는 둘 다의 피연산자가 <code>utcoffset()</code>이 <code>fold</code> 속성의 <code>fold</code> 값에 의존하는 경우, 결과는 <code>False</code>입니다.</p>
<h3>하위 및 상위 호환성 (Backward and Forward Compatibility)</h3>
<p>이 제안은 <code>fold</code> 플래그를 명시적으로 읽거나 이를 사용하는 <code>tzinfo</code> 구현을 사용하지 않는 프로그램에는 거의 영향을 미치지 않습니다. 이러한 프로그램에 대한 유일하게 눈에 띄는 변경 사항은 POSIX 타임스탬프와 상호 변환이 이제 올바르게 왕복한다는 것입니다 (부동 소수점 반올림 오차 내에서). 이전의 잘못된 동작에 대한 해결책을 구현한 프로그램은 수정해야 할 수도 있습니다.</p>
<p>오래된 프로그램으로 생성된 pickle은 완전히 상위 호환성을 유지합니다. 새로운 버전에서 <code>fold=1</code>로 pickle된 <code>datetime</code>/<code>time</code> 인스턴스만 이전 Python 버전에서는 읽을 수 없게 됩니다. <code>fold=0</code> (기본값) 인스턴스의 pickle은 변경되지 않습니다.</p>
<h3>질문과 답변 (Questions and Answers)</h3>
<h4>왜 새 플래그를 "isdst"라고 부르지 않나요? (Why not call the new flag “isdst”?)</h4>
<p><strong>비기술적 답변 (A non-technical answer)</strong></p>
<p><code>isdst</code>라는 이름은 Daylight Saving Time (DST)과 관련되어 혼란을 줄 수 있습니다. <code>fold</code>는 DST뿐만 아니라 시계가 뒤로 이동하는 모든 상황을 포괄하는 더 일반적인 개념입니다.</p>
<p><strong>기술적 이유 (A technical reason)</strong></p>
<p><code>time.struct_time</code> 객체의 <code>tm_isdst</code> 필드는 폴드에서 로컬 시간을 중의적으로 해소하는 데 사용될 수 있지만, 그러한 중의성 해소의 의미론은 이 PEP의 제안과 완전히 다릅니다.
<code>tm_isdst</code> 필드의 주요 문제는 시간대에 대한 자세한 정보(이는 <code>tzinfo</code> 구현에서만 사용 가능)를 알지 못하면 <code>tm_isdst</code>에 적절한 값을 알 수 없다는 것입니다.
<code>tm_isdst</code>와 달리 제안된 <code>fold</code> 속성은 해당 속성 없이 두 가지 (또는 없음) 해석이 가능하지 않는 한 <code>datetime</code> 인스턴스의 해석에 영향을 미치지 않습니다.</p>
<p><code>tm_isdst</code>와 동일한 의미론을 갖지 않는 <code>isdst</code>라는 이름을 사용하는 것은 매우 혼란스러울 것이기 때문에 다른 이름이 필요합니다. 또한 <code>datetime.datetime</code> 클래스에는 이미 <code>dst()</code>라는 메서드가 있으며, <code>fold</code>를 "isdst"라고 부르면 "isdst"가 0인데 <code>dst()</code>는 0이 아니거나 그 반대인 상황이 필연적으로 발생할 것입니다.</p>
<h4>왜 "fold"인가요? (Why “fold”?)</h4>
<p>Guido van Rossum이 제안했으며, 한 저자가 선호했습니다. 속성의 허용되는 값이 <code>False</code>/<code>True</code>에서 <code>0</code>/<code>1</code>로 변경된 후 합의가 이루어졌습니다. "fold"라는 명사는 올바른 함의를 가지며 기억하기 쉬운 규칙을 제공하지만, 동시에 근거 없는 가정을 유도하지 않습니다.</p>
<h4>"first"는 무엇인가요? (What is “first”?)</h4>
<p>이는 초기에는 명백한 대안("second")이 기존 속성과 충돌하기 때문에 선택된 속성의 작업 이름이었습니다. 주로 <code>True</code>를 기본값으로 만들 것이라는 이유로 거부되었습니다.</p>
<h4>두 가지 값으로 충분한가요? (Are two values enough?)</h4>
<p><code>fold</code> 속성에 <code>None</code> 또는 <code>-1</code> 값을 허용해야 한다는 몇 가지 이유가 제기되었습니다: 하위 호환성, <code>tm_isdst</code>와의 유사성, 그리고 무효 시간(invalid time)에 대한 엄격한 확인.</p>
<p><strong>하위 호환성 (Backward Compatibility)</strong></p>
<p><code>fold</code> 플래그의 기본값이 <code>None</code>이면 PEP 이전 동작을 요청하는 신호가 될 수 있어 하위 호환성을 개선할 수 있다는 제안이 있었습니다. 아래 분석을 기반으로 <code>fold=0</code> 기본값으로 제안된 변경 사항이 충분히 하위 호환성을 갖는다고 판단합니다.</p>
<p>이 PEP는 프로그램이 달리 동일한 <code>datetime</code> 인스턴스가 다른 <code>fold</code> 값을 갖는다는 것을 발견할 수 있는 세 가지 방법을 제공합니다: (1) <code>fold</code> 속성의 명시적 확인; (2) 인스턴스가 naive인 경우 - <code>astimezone()</code> 메서드를 사용하여 다른 시간대로 변환; 그리고 (3) <code>timestamp()</code> 메서드를 사용하여 float으로 변환.</p>
<p><strong><code>tm_isdst</code>와의 유사성 (Analogy with tm_isdst)</strong></p>
<p><code>time.mktime</code> 인터페이스는 <code>tm_isdst</code> 플래그에 대해 <code>-1, 0, 1</code> 세 가지 값을 허용합니다. 위에서 설명했듯이, <code>-1</code> (주어진 시간에 대해 DST가 적용되는지 여부를 <code>mktime</code>이 나머지 필드에서 결정하도록 요청)이 실제로 유용한 유일한 선택입니다.</p>
<p>그러나 <code>fold</code> 플래그를 사용하면 <code>datetime.timestamp()</code>는 대부분의 DST 전환 시간대에서 99.98%의 시간 동안 <code>tm_isdst=-1</code>을 사용한 <code>mktime</code>과 동일한 값을 반환합니다. 게다가 <code>tm_isdst=-1</code>과 같은 동작은 <code>fold</code> 값에 관계없이 지정됩니다.</p>
<p><strong>엄격한 무효 시간 확인 (Strict Invalid Time Checking)</strong></p>
<p>또 다른 제안은 <code>fold=-1</code> 또는 <code>fold=None</code>을 사용하여 프로그램이 폴드와 갭을 처리할 수 있는 수단이 없음을 나타내고, <code>dt</code>가 중의적이거나 누락된 로컬 시간을 나타낼 때마다 <code>dt.utcoffset()</code>이 오류를 발생시키도록 하는 것이었습니다.</p>
<p>이 제안의 주요 문제는 <code>dt.utcoffset()</code>이 오류를 발생시키는 것이 옵션이 아닌 상황에서 내부적으로 사용된다는 것입니다. 예를 들어, 딕셔너리 조회 또는 목록/세트 멤버십 확인 등입니다. 따라서 엄격한 갭/폴드 확인 동작은 별도의 플래그(<code>dt.utcoffset(raise_on_gap=True, raise_on_fold=False)</code>)로 제어되어야 합니다. 그러나 이 기능은 사용자 코드에서 쉽게 구현할 수 있습니다.</p>
<h2>구현 (Implementation)</h2>
<p>Github fork: <a href="https://github.com/abalkin/cpython/tree/issue24773-s3">https://github.com/abalkin/cpython/tree/issue24773-s3</a>
Tracker issue: <a href="http://bugs.python.org/issue24773">http://bugs.python.org/issue24773</a></p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-aecaf5ac7a84facf.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-e3ea38185bb36cd2.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/495\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"x02Anhkwgp1He7ftuyAhh\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/495/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/495\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"495\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/495\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T6621,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0495/\"\u003ePEP 495 - Local Time Disambiguation\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 02-Aug-2015\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 495: 로컬 시간 중의성 해소\u003c/p\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003edatetime.time\u003c/code\u003e 및 \u003ccode\u003edatetime.datetime\u003c/code\u003e 클래스의 인스턴스에 \u003ccode\u003efold\u003c/code\u003e라는 새로운 속성을 추가하는 것을 제안합니다. 이 \u003ccode\u003efold\u003c/code\u003e 속성은 로컬 시간이 동일하지만 실제 시점은 다른 두 시간을 구별하는 데 사용됩니다. \u003ccode\u003efold\u003c/code\u003e 속성의 허용되는 값은 0과 1이며, 0은 중의적인 로컬 시간의 두 가지 가능한 해석 중 이른 시점에 해당하고, 1은 늦은 시점에 해당합니다.\u003c/p\u003e\n\u003ch2\u003e도입 배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003e대부분의 지역에서는 로컬 시계가 뒤로 이동하는 시기가 존재했습니다. 이러한 시기에는 로컬 시계가 같은 날 두 번 같은 시간을 표시하는 구간이 발생합니다. 이러한 상황에서는 로컬 시계에 표시되는 정보(또는 Python \u003ccode\u003edatetime\u003c/code\u003e 인스턴스에 저장된 정보)만으로는 특정 시점을 식별하기에 불충분합니다. 제안된 해결책은 \u003ccode\u003edatetime\u003c/code\u003e 인스턴스에 0과 1의 값을 가지는 속성을 추가하여 두 가지 중의적인 시간을 열거하는 것입니다.\u003c/p\u003e\n\u003cp\u003e일광 절약 시간 (DST)을 준수하는 지역에서는 보통 가을에 시계를 한 시간 뒤로 되돌립니다. 드물지만 다른 이유로 시계가 뒤로 이동하는 경우도 있습니다. 예를 들어, 우크라이나는 1990년 3월의 봄철 시간 전환을 건너뛰고 대신 1990년 7월 1일에 시계를 뒤로 옮겨 모스크바 시간에서 동유럽 시간으로 변경했습니다. 이 경우 전환 전후 모두 표준(겨울) 시간이 적용되었습니다. DST 및 표준 시간 변경 모두 한 시간 외의 시간 이동을 초래할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e용어 (Terminology)\u003c/h2\u003e\n\u003cp\u003e시계가 뒤로 이동할 때, 우리는 시간 안에 \"폴드(fold)\"가 생성된다고 말합니다. 시계가 앞으로 이동할 때, \"갭(gap)\"이 생성됩니다. 폴드 안에 있는 로컬 시간을 \"중의적(ambiguous)\"이라고 부르며, 갭 안에 있는 로컬 시간을 \"누락(missing)\"이라고 부릅니다.\u003c/p\u003e\n\u003ch2\u003e제안 (Proposal)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003efold\u003c/code\u003e 속성 (The “fold” attribute)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003edatetime.time\u003c/code\u003e 및 \u003ccode\u003edatetime.datetime\u003c/code\u003e 클래스의 인스턴스에 \u003ccode\u003efold\u003c/code\u003e라는 속성을 추가할 것을 제안합니다. 이 속성은 중의적인 경우의 두 번째(시간 순서상 늦은) 시점을 나타내는 인스턴스를 제외한 모든 인스턴스에 대해 0의 값을 가져야 합니다. 해당 인스턴스의 경우 값은 1이 됩니다.\u003c/p\u003e\n\u003ch3\u003e영향을 받는 API (Affected APIs)\u003c/h3\u003e\n\u003ch4\u003e속성 (Attributes)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003edatetime.time\u003c/code\u003e 및 \u003ccode\u003edatetime.datetime\u003c/code\u003e 클래스의 인스턴스는 두 가지 가능한 값(0과 1)을 갖는 새로운 \u003ccode\u003efold\u003c/code\u003e 속성을 갖게 됩니다.\u003c/p\u003e\n\u003ch4\u003e생성자 (Constructors)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003edatetime.time\u003c/code\u003e 및 \u003ccode\u003edatetime.datetime\u003c/code\u003e 클래스의 \u003ccode\u003e__new__\u003c/code\u003e 메서드는 기본값 0을 갖는 \u003ccode\u003efold\u003c/code\u003e라는 새로운 키워드 전용 인자(keyword-only argument)를 갖게 됩니다. \u003ccode\u003efold\u003c/code\u003e 인수의 값은 반환된 인스턴스의 \u003ccode\u003efold\u003c/code\u003e 속성 값을 초기화하는 데 사용됩니다.\u003c/p\u003e\n\u003ch4\u003e메서드 (Methods)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003edatetime.time\u003c/code\u003e 및 \u003ccode\u003edatetime.datetime\u003c/code\u003e 클래스의 \u003ccode\u003ereplace()\u003c/code\u003e 메서드는 \u003ccode\u003efold\u003c/code\u003e라는 새로운 키워드 전용 인자를 갖게 됩니다. 이 인자는 다른 \u003ccode\u003ereplace()\u003c/code\u003e 인자와 유사하게 동작합니다. \u003ccode\u003efold\u003c/code\u003e 인자가 지정되고 0 또는 1의 값이 주어지면, \u003ccode\u003ereplace()\u003c/code\u003e에 의해 반환된 새 인스턴스는 해당 값으로 \u003ccode\u003efold\u003c/code\u003e 속성이 설정됩니다.\u003c/p\u003e\n\u003ch4\u003eC-API\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ePyDateTime_DateTime\u003c/code\u003e 및 \u003ccode\u003ePyDateTime_Time\u003c/code\u003e 객체에서 \u003ccode\u003efold\u003c/code\u003e 값을 추출하기 위한 접근 매크로가 정의됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eint PyDateTime_DATE_GET_FOLD(PyDateTime_DateTime *o)\u003c/code\u003e: \u003ccode\u003efold\u003c/code\u003e 값을 C \u003ccode\u003eint\u003c/code\u003e로 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint PyDateTime_TIME_GET_FOLD(PyDateTime_Time *o)\u003c/code\u003e: \u003ccode\u003efold\u003c/code\u003e 값을 C \u003ccode\u003eint\u003c/code\u003e로 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e생성된 인스턴스의 \u003ccode\u003efold\u003c/code\u003e 값을 지정하기 위한 추가 인자를 받는 새로운 생성자가 정의됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyObject* PyDateTime_FromDateAndTimeAndFold(int year, int month, int day, int hour, int minute, int second, int usecond, int fold)\u003c/code\u003e: 지정된 연, 월, 일, 시, 분, 초, 마이크로초 및 \u003ccode\u003efold\u003c/code\u003e를 가진 \u003ccode\u003edatetime.datetime\u003c/code\u003e 객체를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject* PyTime_FromTimeAndFold(int hour, int minute, int second, int usecond, int fold)\u003c/code\u003e: 지정된 시, 분, 초, 마이크로초 및 \u003ccode\u003efold\u003c/code\u003e를 가진 \u003ccode\u003edatetime.time\u003c/code\u003e 객체를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e영향을 받는 동작 (Affected Behaviors)\u003c/h3\u003e\n\u003ch4\u003e지금 몇 시인가요? (What time is it?)\u003c/h4\u003e\n\u003cp\u003e인수 없이 호출된 \u003ccode\u003edatetime.now()\u003c/code\u003e 메서드는 시스템 로컬 시간 폴드에서 두 가지 중의적인 시간 중 두 번째 시간을 반환할 때 \u003ccode\u003efold=1\u003c/code\u003e로 설정합니다. \u003ccode\u003etzinfo\u003c/code\u003e 인수를 사용하여 호출될 경우, \u003ccode\u003efold\u003c/code\u003e 값은 \u003ccode\u003etzinfo.fromutc()\u003c/code\u003e 구현에 의해 결정됩니다. \u003ccode\u003edatetime.timezone\u003c/code\u003e 클래스 인스턴스(예: \u003ccode\u003edatetime.timezone.utc\u003c/code\u003e)가 \u003ccode\u003etzinfo\u003c/code\u003e로 전달되면 반환된 \u003ccode\u003edatetime\u003c/code\u003e 인스턴스는 항상 \u003ccode\u003efold=0\u003c/code\u003e을 갖습니다. \u003ccode\u003edatetime.utcnow()\u003c/code\u003e 메서드는 영향을 받지 않습니다.\u003c/p\u003e\n\u003ch4\u003enaive 시간에서 aware 시간으로의 변환 (Conversion from naive to aware)\u003c/h4\u003e\n\u003cp\u003enaive \u003ccode\u003edatetime\u003c/code\u003e 인스턴스를 aware \u003ccode\u003edatetime\u003c/code\u003e으로 변환하는 것을 용이하게 하기 위한 새로운 기능이 제안됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eastimezone()\u003c/code\u003e 메서드는 이제 naive \u003ccode\u003eself\u003c/code\u003e에 대해 작동합니다. 이 경우 시스템 로컬 시간대가 가정되며, \u003ccode\u003efold\u003c/code\u003e 플래그는 중의적인 경우 어떤 로컬 시간대가 적용되는지 결정하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, US/Eastern 시간대로 설정된 시스템에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e dt = datetime(2014, 11, 2, 1, 30)\r\n\u003e\u003e\u003e dt.astimezone().strftime('%D %T %Z%z')\r\n'11/02/14 01:30:00 EDT-0400'\r\n\u003e\u003e\u003e dt.replace(fold=1).astimezone().strftime('%D %T %Z%z')\r\n'11/02/14 01:30:00 EST-0500'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 \u003ccode\u003edatetime.now(tz)\u003c/code\u003e가 \u003ccode\u003edatetime.now().astimezone(tz)\u003c/code\u003e와 완전히 동등하다는 것을 의미합니다 (단, \u003ccode\u003etz\u003c/code\u003e는 PEP 이후의 \u003ccode\u003etzinfo\u003c/code\u003e 구현 인스턴스, 즉 \u003ccode\u003efold\u003c/code\u003e를 올바르게 처리하고 설정하는 인스턴스여야 합니다).\u003c/p\u003e\n\u003ch4\u003eEpoch 이후 POSIX 초에서 변환 (Conversion from POSIX seconds from EPOCH)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003edatetime.datetime\u003c/code\u003e의 정적 메서드 \u003ccode\u003efromtimestamp()\u003c/code\u003e는 반환되는 객체에서 \u003ccode\u003efold\u003c/code\u003e 속성을 적절하게 설정합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, US/Eastern 시간대로 설정된 시스템에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e datetime.fromtimestamp(1414906200)\r\ndatetime.datetime(2014, 11, 2, 1, 30)\r\n\u003e\u003e\u003e datetime.fromtimestamp(1414906200 + 3600)\r\ndatetime.datetime(2014, 11, 2, 1, 30, fold=1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eEpoch 이후 POSIX 초로 변환 (Conversion to POSIX seconds from EPOCH)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003edatetime.datetime\u003c/code\u003e의 \u003ccode\u003etimestamp()\u003c/code\u003e 메서드는 \u003ccode\u003efold\u003c/code\u003e 속성 값만 다른 \u003ccode\u003edatetime.datetime\u003c/code\u003e 인스턴스가 중의적이거나 누락된 시간을 나타내는 경우에만 다른 값을 반환합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edatetime.datetime\u003c/code\u003e 인스턴스 \u003ccode\u003edt\u003c/code\u003e가 중의적인 시간을 나타낼 때, \u003ccode\u003es0\u003c/code\u003e과 \u003ccode\u003es1\u003c/code\u003e이라는 두 가지 값이 존재합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edatetime.fromtimestamp(s0) == datetime.fromtimestamp(s1) == dt\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e이 경우 \u003ccode\u003edt.timestamp()\u003c/code\u003e는 \u003ccode\u003edt.fold == 0\u003c/code\u003e이면 \u003ccode\u003es0\u003c/code\u003e과 \u003ccode\u003es1\u003c/code\u003e 중 작은 값을 반환하고, 그렇지 않으면 큰 값을 반환합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, US/Eastern 시간대로 설정된 시스템에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e datetime(2014, 11, 2, 1, 30, fold=0).timestamp()\r\n1414906200.0\r\n\u003e\u003e\u003e datetime(2014, 11, 2, 1, 30, fold=1).timestamp()\r\n1414909800.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edatetime.datetime\u003c/code\u003e 인스턴스 \u003ccode\u003edt\u003c/code\u003e가 누락된 시간을 나타낼 때, \u003ccode\u003edatetime.fromtimestamp(s) == dt\u003c/code\u003e를 만족하는 \u003ccode\u003es\u003c/code\u003e 값은 없습니다. 하지만 갭의 크기(초)만큼 다른 두 개의 \"알아두면 좋은\" \u003ccode\u003es\u003c/code\u003e 값을 형성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e누락된 \u003ccode\u003edt\u003c/code\u003e에 대해 \u003ccode\u003edt.timestamp()\u003c/code\u003e가 반환하는 값은 \u003ccode\u003edt.fold == 0\u003c/code\u003e이면 두 \"알아두면 좋은\" 값 중 큰 값을 반환하고, 그렇지 않으면 작은 값을 반환합니다. (이는 오타가 아니며, 중의적인 시간 규칙과 의도적으로 반대입니다.)\u003c/p\u003e\n\u003cp\u003e예를 들어, US/Eastern 시간대로 설정된 시스템에서:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e datetime(2015, 3, 8, 2, 30, fold=0).timestamp()\r\n1425799800.0\r\n\u003e\u003e\u003e datetime(2015, 3, 8, 2, 30, fold=1).timestamp()\r\n1425796200.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eAware datetime 인스턴스 (Aware datetime instances)\u003c/h4\u003e\n\u003cp\u003ePEP 이전의 \u003ccode\u003etzinfo\u003c/code\u003e 구현을 사용하는 사용자들은 aware \u003ccode\u003edatetime\u003c/code\u003e 인스턴스의 동작에서 어떤 변화도 보지 못할 것입니다. \u003ccode\u003efold\u003c/code\u003e 속성 값만 다른 두 인스턴스는 \u003ccode\u003efold\u003c/code\u003e 값에 대한 명시적인 접근 외에는 어떤 방법으로도 구별할 수 없습니다. (이는 PEP 이전 구현이 \u003ccode\u003efold\u003c/code\u003e 속성을 사용하지 않기 때문입니다.)\u003c/p\u003e\n\u003cp\u003e반면에 객체의 \u003ccode\u003etzinfo\u003c/code\u003e가 \u003ccode\u003efold\u003c/code\u003e-aware 구현으로 설정되면, 폴드 또는 갭에서 \u003ccode\u003efold\u003c/code\u003e 값은 \u003ccode\u003eutcoffset()\u003c/code\u003e, \u003ccode\u003edst()\u003c/code\u003e, \u003ccode\u003etzname()\u003c/code\u003e, \u003ccode\u003eastimezone()\u003c/code\u003e, \u003ccode\u003estrftime()\u003c/code\u003e (형식 지정에 \"%Z\" 또는 \"%z\" 지시어가 사용된 경우), \u003ccode\u003eisoformat()\u003c/code\u003e, \u003ccode\u003etimetuple()\u003c/code\u003e 등 여러 메서드의 결과에 영향을 미칩니다.\u003c/p\u003e\n\u003ch4\u003e날짜와 시간 결합 및 분리 (Combining and splitting date and time)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003edatetime.datetime.combine()\u003c/code\u003e 메서드는 \u003ccode\u003efold\u003c/code\u003e 속성 값을 결과 \u003ccode\u003edatetime.datetime\u003c/code\u003e 인스턴스로 복사합니다.\r\n\u003ccode\u003edatetime.datetime.time()\u003c/code\u003e 메서드는 \u003ccode\u003efold\u003c/code\u003e 속성 값을 결과 \u003ccode\u003edatetime.time\u003c/code\u003e 인스턴스로 복사합니다.\u003c/p\u003e\n\u003ch4\u003ePickles\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003efold\u003c/code\u003e 속성의 값은 프로토콜 버전 4 (Python 3.4에서 도입) 이상으로 생성된 pickle에만 저장됩니다.\r\n\u003ccode\u003edatetime.datetime\u003c/code\u003e 및 \u003ccode\u003edatetime.time\u003c/code\u003e 객체의 pickle 크기는 변경되지 않습니다. \u003ccode\u003efold\u003c/code\u003e 값은 \u003ccode\u003edatetime.datetime\u003c/code\u003e pickle 페이로드의 3번째 바이트의 첫 번째 비트와 \u003ccode\u003edatetime.time\u003c/code\u003e 페이로드의 첫 번째 바이트의 첫 번째 비트에 인코딩됩니다. 현재 구현에서 이 바이트들은 월(1-12)과 시간(0-23) 값을 저장하는 데 사용되며, 첫 번째 비트는 항상 0입니다.\u003c/p\u003e\n\u003ch3\u003e표준 라이브러리의 \u003ccode\u003etzinfo\u003c/code\u003e 구현 (Implementations of tzinfo in the Standard Library)\u003c/h3\u003e\n\u003cp\u003e이 PEP에서는 \u003ccode\u003edatetime.tzinfo\u003c/code\u003e 추상 클래스의 새로운 구현을 제안하지 않습니다. 기존의 (고정 오프셋) 시간대(timezone)는 중의적인 로컬 시간을 도입하지 않으며, \u003ccode\u003eutcoffset()\u003c/code\u003e 구현은 \u003ccode\u003efold\u003c/code\u003e 값에 관계없이 현재와 동일한 상수 값을 반환할 것입니다.\u003c/p\u003e\n\u003cp\u003e추상 \u003ccode\u003edatetime.tzinfo\u003c/code\u003e 클래스의 \u003ccode\u003efromutc()\u003c/code\u003e 기본 구현은 변경되지 않습니다. 현재 stdlib의 유일한 \u003ccode\u003etzinfo\u003c/code\u003e 구현(\u003ccode\u003edatetime.timezone\u003c/code\u003e 클래스)이 \u003ccode\u003efromutc()\u003c/code\u003e를 오버라이드하기 때문에 어디에도 사용되지 않습니다. 기본 구현을 변경하지 않으면 기본 \u003ccode\u003efromutc()\u003c/code\u003e를 상속하는 PEP 이전의 서드 파티 구현이 의도치 않게 영향을 받지 않는다는 이점이 있습니다.\u003c/p\u003e\n\u003ch3\u003e새로운 \u003ccode\u003etzinfo\u003c/code\u003e 구현을 위한 가이드라인 (Guidelines for New tzinfo Implementations)\u003c/h3\u003e\n\u003cp\u003e가변 UTC 오프셋(DST 및 기타 원인으로 인한)을 지원하려는 구체적인 \u003ccode\u003edatetime.tzinfo\u003c/code\u003e 서브클래스 구현자는 다음 가이드라인을 따라야 합니다.\u003c/p\u003e\n\u003ch4\u003e무지는 축복이다 (Ignorance is Bliss)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eutcoffset()\u003c/code\u003e, \u003ccode\u003etzname()\u003c/code\u003e, \u003ccode\u003edst()\u003c/code\u003e 메서드의 새로운 구현은 중의적이거나 누락된 시간에 대해 호출되지 않는 한 \u003ccode\u003efold\u003c/code\u003e 값을 무시해야 합니다.\u003c/p\u003e\n\u003ch4\u003e폴드 안에서 (In the Fold)\u003c/h4\u003e\n\u003cp\u003e새로운 서브클래스는 기본 클래스의 \u003ccode\u003efromutc()\u003c/code\u003e 메서드를 오버라이드하고, 두 개의 다른 UTC 시간 \u003ccode\u003eu0\u003c/code\u003e과 \u003ccode\u003eu1\u003c/code\u003e(\u003ccode\u003eu0 \u0026#x3C; u1\u003c/code\u003e)이 동일한 로컬 시간 \u003ccode\u003et\u003c/code\u003e에 해당하는 모든 경우에 \u003ccode\u003efromutc(u0)\u003c/code\u003e는 \u003ccode\u003efold=0\u003c/code\u003e인 인스턴스를 반환하고, \u003ccode\u003efromutc(u1)\u003c/code\u003e는 \u003ccode\u003efold=1\u003c/code\u003e인 인스턴스를 반환하도록 구현해야 합니다. 다른 모든 경우에는 반환된 인스턴스는 \u003ccode\u003efold=0\u003c/code\u003e을 가져야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eutcoffset()\u003c/code\u003e, \u003ccode\u003etzname()\u003c/code\u003e, \u003ccode\u003edst()\u003c/code\u003e 메서드는 \u003ccode\u003efold\u003c/code\u003e 속성 값을 사용하여 중의적인 시간 \u003ccode\u003et\u003c/code\u003e가 전환 전 또는 후의 시간에 해당하는지 여부를 결정해야 합니다. 정의에 따라 \u003ccode\u003eutcoffset()\u003c/code\u003e은 폴드를 생성하는 모든 전환 전에는 크고 전환 후에는 작습니다. \u003ccode\u003etzname()\u003c/code\u003e 및 \u003ccode\u003edst()\u003c/code\u003e가 반환하는 값은 전환 유형에 따라 \u003ccode\u003efold\u003c/code\u003e 속성 값에 의존할 수도 있고 의존하지 않을 수도 있습니다.\u003c/p\u003e\n\u003ch4\u003e갭을 조심하세요 (Mind the Gap)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003efromutc()\u003c/code\u003e 메서드는 갭 내의 시간을 생성해서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eutcoffset()\u003c/code\u003e, \u003ccode\u003etzname()\u003c/code\u003e, \u003ccode\u003edst()\u003c/code\u003e 메서드가 갭에 속하는 로컬 시간에 대해 호출되면, \u003ccode\u003efold=0\u003c/code\u003e인 경우 전환 전 규칙이 사용되어야 합니다. 그렇지 않으면 전환 후 규칙이 사용되어야 합니다.\u003c/p\u003e\n\u003ch4\u003e전환 시 규칙 요약 (Summary of Rules at a Transition)\u003c/h4\u003e\n\u003cp\u003e중의적이거나 누락된 시간에 \u003ccode\u003eutcoffset()\u003c/code\u003e은 다음 표에 따라 값을 반환해야 합니다.\u003c/p\u003e\n\u003cp\u003e| | \u003ccode\u003efold=0\u003c/code\u003e | \u003ccode\u003efold=1\u003c/code\u003e |\r\n|---|---|---|\r\n| \u003cstrong\u003eFold\u003c/strong\u003e | \u003ccode\u003eoldoff\u003c/code\u003e | \u003ccode\u003enewoff = oldoff - delta\u003c/code\u003e |\r\n| \u003cstrong\u003eGap\u003c/strong\u003e | \u003ccode\u003eoldoff\u003c/code\u003e | \u003ccode\u003enewoff = oldoff + delta\u003c/code\u003e |\u003c/p\u003e\n\u003cp\u003e여기서 \u003ccode\u003eoldoff\u003c/code\u003e (\u003ccode\u003enewoff\u003c/code\u003e)는 전환 전 (후) UTC 오프셋이고 \u003ccode\u003edelta\u003c/code\u003e는 폴드 또는 갭의 절대 크기입니다.\u003c/p\u003e\n\u003ch4\u003eDST 전환 (The DST Transitions)\u003c/h4\u003e\n\u003cp\u003eDST 시작 시 도입된 누락된 시간에서 \u003ccode\u003eutcoffset()\u003c/code\u003e 및 \u003ccode\u003edst()\u003c/code\u003e 메서드가 반환하는 값은 다음과 같아야 합니다.\u003c/p\u003e\n\u003cp\u003e| | \u003ccode\u003efold=0\u003c/code\u003e | \u003ccode\u003efold=1\u003c/code\u003e |\r\n|---|---|---|\r\n| \u003ccode\u003eutcoffset()\u003c/code\u003e | \u003ccode\u003estdoff\u003c/code\u003e | \u003ccode\u003estdoff + dstoff\u003c/code\u003e |\r\n| \u003ccode\u003edst()\u003c/code\u003e | \u003ccode\u003ezero\u003c/code\u003e | \u003ccode\u003edstoff\u003c/code\u003e |\u003c/p\u003e\n\u003cp\u003eDST 종료 시 도입된 중의적인 시간에서 \u003ccode\u003eutcoffset()\u003c/code\u003e 및 \u003ccode\u003edst()\u003c/code\u003e 메서드가 반환하는 값은 다음과 같아야 합니다.\u003c/p\u003e\n\u003cp\u003e| | \u003ccode\u003efold=0\u003c/code\u003e | \u003ccode\u003efold=1\u003c/code\u003e |\r\n|---|---|---|\r\n| \u003ccode\u003eutcoffset()\u003c/code\u003e | \u003ccode\u003estdoff + dstoff\u003c/code\u003e | \u003ccode\u003estdoff\u003c/code\u003e |\r\n| \u003ccode\u003edst()\u003c/code\u003e | \u003ccode\u003edstoff\u003c/code\u003e | \u003ccode\u003ezero\u003c/code\u003e |\u003c/p\u003e\n\u003cp\u003e여기서 \u003ccode\u003estdoff\u003c/code\u003e는 표준 (비-DST) 오프셋이고, \u003ccode\u003edstoff\u003c/code\u003e는 DST 보정(\u003ccode\u003etimedelta(hours=1)\u003c/code\u003e이 일반적)이며, \u003ccode\u003ezero = timedelta(0)\u003c/code\u003e입니다.\u003c/p\u003e\n\u003ch3\u003e시간 산술 및 비교 연산자 (Temporal Arithmetic and Comparison Operators)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003efold\u003c/code\u003e 속성의 값은 naive \u003ccode\u003edatetime\u003c/code\u003e 인스턴스를 사용하는 모든 연산에서 무시됩니다. 결과적으로 \u003ccode\u003efold\u003c/code\u003e 값만 다른 naive \u003ccode\u003edatetime.datetime\u003c/code\u003e 또는 \u003ccode\u003edatetime.time\u003c/code\u003e 인스턴스는 같다고 비교됩니다. 이러한 인스턴스를 구별해야 하는 애플리케이션은 \u003ccode\u003efold\u003c/code\u003e 값을 명시적으로 확인하거나 해당 인스턴스를 중의적인 시간이 없는 시간대(예: UTC)로 변환해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etimedelta\u003c/code\u003e가 aware 또는 naive \u003ccode\u003edatetime\u003c/code\u003e 인스턴스에 추가되거나 빼지는 경우에도 \u003ccode\u003efold\u003c/code\u003e 값은 무시됩니다. \u003ccode\u003etimedelta\u003c/code\u003e를 \u003ccode\u003edatetime\u003c/code\u003e에 추가(또는 뺄셈)한 결과는 원래 \u003ccode\u003edatetime\u003c/code\u003e 인스턴스가 \u003ccode\u003efold=1\u003c/code\u003e이었더라도 항상 \u003ccode\u003efold\u003c/code\u003e가 0으로 설정됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edatetime\u003c/code\u003e 인스턴스 \u003ccode\u003et\u003c/code\u003e와 \u003ccode\u003es\u003c/code\u003e에 대한 차이 \u003ccode\u003et - s\u003c/code\u003e가 계산되는 방식에는 변경이 제안되지 않습니다.\u003c/p\u003e\n\u003cp\u003eNaive 및 intra-zone 비교는 \u003ccode\u003efold\u003c/code\u003e 값을 무시하고 현재와 동일한 결과를 반환합니다. (이는 하위 호환성을 유지하는 유일한 방법입니다. \u003ccode\u003efold\u003c/code\u003e를 사용하는 aware intra-zone 비교가 필요하면 먼저 양쪽을 UTC로 변환해야 합니다.)\u003c/p\u003e\n\u003cp\u003eInter-zone 뺄셈은 현재와 같이 정의됩니다: \u003ccode\u003et - s\u003c/code\u003e는 \u003ccode\u003e(t - t.utcoffset()) - (s - s.utcoffset()).replace(tzinfo=t.tzinfo)\u003c/code\u003e로 계산되지만, \u003ccode\u003et.tzinfo\u003c/code\u003e 또는 \u003ccode\u003es.tzinfo\u003c/code\u003e 중 하나가 PEP 이후 구현인 경우 결과는 \u003ccode\u003et.fold\u003c/code\u003e 및 \u003ccode\u003es.fold\u003c/code\u003e의 값에 따라 달라집니다.\u003c/p\u003e\n\u003ch4\u003eAware datetime 등가 비교 (Aware datetime Equality Comparison)\u003c/h4\u003e\n\u003cp\u003eaware \u003ccode\u003edatetime\u003c/code\u003e 비교 연산자는 현재와 동일하게 작동하며, 피연산자 중 하나의 \u003ccode\u003eutcoffset()\u003c/code\u003e 값이 \u003ccode\u003efold\u003c/code\u003e에 의존할 때 결과는 간접적으로 \u003ccode\u003efold\u003c/code\u003e 값의 영향을 받습니다. 단, 한 가지 예외가 있습니다. inter-zone 비교에서 하나 또는 둘 다의 피연산자가 \u003ccode\u003eutcoffset()\u003c/code\u003e이 \u003ccode\u003efold\u003c/code\u003e 속성의 \u003ccode\u003efold\u003c/code\u003e 값에 의존하는 경우, 결과는 \u003ccode\u003eFalse\u003c/code\u003e입니다.\u003c/p\u003e\n\u003ch3\u003e하위 및 상위 호환성 (Backward and Forward Compatibility)\u003c/h3\u003e\n\u003cp\u003e이 제안은 \u003ccode\u003efold\u003c/code\u003e 플래그를 명시적으로 읽거나 이를 사용하는 \u003ccode\u003etzinfo\u003c/code\u003e 구현을 사용하지 않는 프로그램에는 거의 영향을 미치지 않습니다. 이러한 프로그램에 대한 유일하게 눈에 띄는 변경 사항은 POSIX 타임스탬프와 상호 변환이 이제 올바르게 왕복한다는 것입니다 (부동 소수점 반올림 오차 내에서). 이전의 잘못된 동작에 대한 해결책을 구현한 프로그램은 수정해야 할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e오래된 프로그램으로 생성된 pickle은 완전히 상위 호환성을 유지합니다. 새로운 버전에서 \u003ccode\u003efold=1\u003c/code\u003e로 pickle된 \u003ccode\u003edatetime\u003c/code\u003e/\u003ccode\u003etime\u003c/code\u003e 인스턴스만 이전 Python 버전에서는 읽을 수 없게 됩니다. \u003ccode\u003efold=0\u003c/code\u003e (기본값) 인스턴스의 pickle은 변경되지 않습니다.\u003c/p\u003e\n\u003ch3\u003e질문과 답변 (Questions and Answers)\u003c/h3\u003e\n\u003ch4\u003e왜 새 플래그를 \"isdst\"라고 부르지 않나요? (Why not call the new flag “isdst”?)\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e비기술적 답변 (A non-technical answer)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eisdst\u003c/code\u003e라는 이름은 Daylight Saving Time (DST)과 관련되어 혼란을 줄 수 있습니다. \u003ccode\u003efold\u003c/code\u003e는 DST뿐만 아니라 시계가 뒤로 이동하는 모든 상황을 포괄하는 더 일반적인 개념입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e기술적 이유 (A technical reason)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etime.struct_time\u003c/code\u003e 객체의 \u003ccode\u003etm_isdst\u003c/code\u003e 필드는 폴드에서 로컬 시간을 중의적으로 해소하는 데 사용될 수 있지만, 그러한 중의성 해소의 의미론은 이 PEP의 제안과 완전히 다릅니다.\r\n\u003ccode\u003etm_isdst\u003c/code\u003e 필드의 주요 문제는 시간대에 대한 자세한 정보(이는 \u003ccode\u003etzinfo\u003c/code\u003e 구현에서만 사용 가능)를 알지 못하면 \u003ccode\u003etm_isdst\u003c/code\u003e에 적절한 값을 알 수 없다는 것입니다.\r\n\u003ccode\u003etm_isdst\u003c/code\u003e와 달리 제안된 \u003ccode\u003efold\u003c/code\u003e 속성은 해당 속성 없이 두 가지 (또는 없음) 해석이 가능하지 않는 한 \u003ccode\u003edatetime\u003c/code\u003e 인스턴스의 해석에 영향을 미치지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etm_isdst\u003c/code\u003e와 동일한 의미론을 갖지 않는 \u003ccode\u003eisdst\u003c/code\u003e라는 이름을 사용하는 것은 매우 혼란스러울 것이기 때문에 다른 이름이 필요합니다. 또한 \u003ccode\u003edatetime.datetime\u003c/code\u003e 클래스에는 이미 \u003ccode\u003edst()\u003c/code\u003e라는 메서드가 있으며, \u003ccode\u003efold\u003c/code\u003e를 \"isdst\"라고 부르면 \"isdst\"가 0인데 \u003ccode\u003edst()\u003c/code\u003e는 0이 아니거나 그 반대인 상황이 필연적으로 발생할 것입니다.\u003c/p\u003e\n\u003ch4\u003e왜 \"fold\"인가요? (Why “fold”?)\u003c/h4\u003e\n\u003cp\u003eGuido van Rossum이 제안했으며, 한 저자가 선호했습니다. 속성의 허용되는 값이 \u003ccode\u003eFalse\u003c/code\u003e/\u003ccode\u003eTrue\u003c/code\u003e에서 \u003ccode\u003e0\u003c/code\u003e/\u003ccode\u003e1\u003c/code\u003e로 변경된 후 합의가 이루어졌습니다. \"fold\"라는 명사는 올바른 함의를 가지며 기억하기 쉬운 규칙을 제공하지만, 동시에 근거 없는 가정을 유도하지 않습니다.\u003c/p\u003e\n\u003ch4\u003e\"first\"는 무엇인가요? (What is “first”?)\u003c/h4\u003e\n\u003cp\u003e이는 초기에는 명백한 대안(\"second\")이 기존 속성과 충돌하기 때문에 선택된 속성의 작업 이름이었습니다. 주로 \u003ccode\u003eTrue\u003c/code\u003e를 기본값으로 만들 것이라는 이유로 거부되었습니다.\u003c/p\u003e\n\u003ch4\u003e두 가지 값으로 충분한가요? (Are two values enough?)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003efold\u003c/code\u003e 속성에 \u003ccode\u003eNone\u003c/code\u003e 또는 \u003ccode\u003e-1\u003c/code\u003e 값을 허용해야 한다는 몇 가지 이유가 제기되었습니다: 하위 호환성, \u003ccode\u003etm_isdst\u003c/code\u003e와의 유사성, 그리고 무효 시간(invalid time)에 대한 엄격한 확인.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e하위 호환성 (Backward Compatibility)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efold\u003c/code\u003e 플래그의 기본값이 \u003ccode\u003eNone\u003c/code\u003e이면 PEP 이전 동작을 요청하는 신호가 될 수 있어 하위 호환성을 개선할 수 있다는 제안이 있었습니다. 아래 분석을 기반으로 \u003ccode\u003efold=0\u003c/code\u003e 기본값으로 제안된 변경 사항이 충분히 하위 호환성을 갖는다고 판단합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 프로그램이 달리 동일한 \u003ccode\u003edatetime\u003c/code\u003e 인스턴스가 다른 \u003ccode\u003efold\u003c/code\u003e 값을 갖는다는 것을 발견할 수 있는 세 가지 방법을 제공합니다: (1) \u003ccode\u003efold\u003c/code\u003e 속성의 명시적 확인; (2) 인스턴스가 naive인 경우 - \u003ccode\u003eastimezone()\u003c/code\u003e 메서드를 사용하여 다른 시간대로 변환; 그리고 (3) \u003ccode\u003etimestamp()\u003c/code\u003e 메서드를 사용하여 float으로 변환.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003etm_isdst\u003c/code\u003e와의 유사성 (Analogy with tm_isdst)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etime.mktime\u003c/code\u003e 인터페이스는 \u003ccode\u003etm_isdst\u003c/code\u003e 플래그에 대해 \u003ccode\u003e-1, 0, 1\u003c/code\u003e 세 가지 값을 허용합니다. 위에서 설명했듯이, \u003ccode\u003e-1\u003c/code\u003e (주어진 시간에 대해 DST가 적용되는지 여부를 \u003ccode\u003emktime\u003c/code\u003e이 나머지 필드에서 결정하도록 요청)이 실제로 유용한 유일한 선택입니다.\u003c/p\u003e\n\u003cp\u003e그러나 \u003ccode\u003efold\u003c/code\u003e 플래그를 사용하면 \u003ccode\u003edatetime.timestamp()\u003c/code\u003e는 대부분의 DST 전환 시간대에서 99.98%의 시간 동안 \u003ccode\u003etm_isdst=-1\u003c/code\u003e을 사용한 \u003ccode\u003emktime\u003c/code\u003e과 동일한 값을 반환합니다. 게다가 \u003ccode\u003etm_isdst=-1\u003c/code\u003e과 같은 동작은 \u003ccode\u003efold\u003c/code\u003e 값에 관계없이 지정됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e엄격한 무효 시간 확인 (Strict Invalid Time Checking)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e또 다른 제안은 \u003ccode\u003efold=-1\u003c/code\u003e 또는 \u003ccode\u003efold=None\u003c/code\u003e을 사용하여 프로그램이 폴드와 갭을 처리할 수 있는 수단이 없음을 나타내고, \u003ccode\u003edt\u003c/code\u003e가 중의적이거나 누락된 로컬 시간을 나타낼 때마다 \u003ccode\u003edt.utcoffset()\u003c/code\u003e이 오류를 발생시키도록 하는 것이었습니다.\u003c/p\u003e\n\u003cp\u003e이 제안의 주요 문제는 \u003ccode\u003edt.utcoffset()\u003c/code\u003e이 오류를 발생시키는 것이 옵션이 아닌 상황에서 내부적으로 사용된다는 것입니다. 예를 들어, 딕셔너리 조회 또는 목록/세트 멤버십 확인 등입니다. 따라서 엄격한 갭/폴드 확인 동작은 별도의 플래그(\u003ccode\u003edt.utcoffset(raise_on_gap=True, raise_on_fold=False)\u003c/code\u003e)로 제어되어야 합니다. 그러나 이 기능은 사용자 코드에서 쉽게 구현할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003eGithub fork: \u003ca href=\"https://github.com/abalkin/cpython/tree/issue24773-s3\"\u003ehttps://github.com/abalkin/cpython/tree/issue24773-s3\u003c/a\u003e\r\nTracker issue: \u003ca href=\"http://bugs.python.org/issue24773\"\u003ehttp://bugs.python.org/issue24773\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 495 - Local Time Disambiguation\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:40:14+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>