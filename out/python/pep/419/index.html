<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Deferred] PEP 419 - Protecting cleanup statements from interruptions</h1><div class="page__meta"><time dateTime="2025-09-26 21:36:35+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0419/">PEP 419 - Protecting cleanup statements from interruptions</a></p>
<p><strong>상태:</strong> Deferred | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 06-Apr-2012</p>
</blockquote>
<p>파이썬 PEP 419: 정리 코드 블록 보호</p>
<h2>요약 (Abstract)</h2>
<p>이 PEP는 <code>finally</code> 절 또는 Context Manager (컨텍스트 관리자)의 정리 과정 중에 Python 코드가 <code>KeyboardInterrupt</code>나 <code>GeneratorExit</code>와 같은 인터럽트(방해)로부터 보호될 수 있는 방법을 제안합니다.</p>
<h2>PEP 연기 (PEP Deferral)</h2>
<p>이 PEP에서 다루는 개념에 대한 추가 탐색은 현재 이 PEP의 목표를 추진하고 피드백을 수집 및 통합하며, 이를 효과적으로 수행할 충분한 시간을 가진 담당자가 없기 때문에 연기되었습니다.</p>
<h2>배경 (Rationale)</h2>
<p>Python에는 <code>finally</code> 문과 <code>with</code> 문을 사용하는 Context Manager라는 두 가지 좋은 정리 방법이 있습니다. 그러나 이 두 가지 모두 <code>KeyboardInterrupt</code>나 <code>generator.throw()</code>에 의해 발생하는 <code>GeneratorExit</code>로부터 보호되지 않습니다.</p>
<p>예를 들어, 다음 코드를 살펴보겠습니다.</p>
<pre><code class="language-python">lock.acquire()
try:
    print('starting')
    do_something()
finally:
    print('finished')
    lock.release()
</code></pre>
<p>만약 <code>print('finished')</code> 호출 직후 <code>KeyboardInterrupt</code>가 발생하면, <code>lock</code>은 해제되지 않습니다.</p>
<p><code>with</code> 문을 사용하는 다음 코드도 유사한 문제를 겪습니다.</p>
<pre><code class="language-python">from threading import Lock

class MyLock:
    def __init__(self):
        self._lock_impl = Lock()
    def __enter__(self):
        self._lock_impl.acquire()
        print("LOCKED")
    def __exit__(self):
        print("UNLOCKING")
        self._lock_impl.release()

lock = MyLock()
with lock:
    do_something
</code></pre>
<p><code>print()</code> 호출 근처에서 <code>KeyboardInterrupt</code>가 발생하면 <code>lock</code>은 절대 해제되지 않을 수 있습니다.</p>
<h3>코루틴 사용 사례 (Coroutine Use Case)</h3>
<p>코루틴에서도 유사한 문제가 발생합니다. 코루틴 라이브러리는 종종 타임아웃으로 코루틴을 인터럽트(중단)하기를 원합니다. <code>generator.throw()</code> 메서드는 이 사용 사례에 적합하지만, 코루틴이 현재 <code>finally</code> 절 내에서 일시 중지되었는지 알 수 있는 방법이 없습니다.</p>
<p>다음은 <code>yield</code> 기반 코루틴을 사용하는 예시입니다.</p>
<pre><code class="language-python">def run_locked():
    yield connection.sendall('LOCK')
    try:
        yield do_something()
        yield do_something_else()
    finally:
        yield connection.sendall('UNLOCK')

with timeout(5):
    yield run_locked()
</code></pre>
<p>위 예시에서 <code>yield something</code>은 현재 코루틴의 실행을 일시 중지하고 <code>something</code> 코루틴이 완료될 때까지 실행함을 의미합니다. <code>with timeout(5)</code> 문은 모든 코드가 5초 타임아웃 내에 실행되도록 보장합니다. 이는 타임아웃 발생 시 코루틴 스택의 최상위 프레임에서 <code>generator.throw()</code>를 호출하는 콜백을 메인 루프에 등록함으로써 이루어집니다.</p>
<h2>제안 내용 (Specification)</h2>
<h3>프레임 플래그 <code>f_in_cleanup</code> (Frame Flag 'f_in_cleanup')</h3>
<p>프레임 객체에 새로운 플래그 <code>f_in_cleanup</code>를 추가하는 것을 제안합니다. 이 프레임이 현재 <code>finally</code> 절을 실행 중인 경우 이 플래그는 <code>True</code>로 설정됩니다. 내부적으로 이 플래그는 현재 실행 중인 중첩된 <code>finally</code> 문의 카운터로 구현되어야 합니다.</p>
<p>이 내부 카운터는 <code>SETUP_WITH</code> 및 <code>WITH_CLEANUP</code> 바이트코드 실행 중에도 증가해야 하며, 이들 바이트코드 실행이 완료되면 감소해야 합니다. 이는 <code>__enter__()</code> 및 <code>__exit__()</code> 메서드도 보호할 수 있도록 합니다.</p>
<h3><code>sys.setcleanuphook</code> 함수 (Function 'sys.setcleanuphook')</h3>
<p><code>sys</code> 모듈에 새로운 함수를 추가하는 것을 제안합니다. 이 함수는 <code>f_in_cleanup</code>가 <code>False</code>가 될 때마다 실행되는 콜백을 설정합니다. 콜백은 프레임 객체를 유일한 인수로 받아, 어디에서 호출되었는지 파악할 수 있습니다. 이 설정은 스레드 로컬이며 <code>PyThreadState</code> 구조체에 저장되어야 합니다.</p>
<h3><code>inspect</code> 모듈 개선 (Inspect Module Enhancements)</h3>
<p><code>inspect</code> 모듈에 <code>isframeincleanup()</code> 및 <code>getcleanupframe()</code> 두 가지 새로운 함수를 제안합니다.</p>
<ul>
<li><code>isframeincleanup()</code>: 프레임 또는 제너레이터 객체를 인수로 받아, 프레임 자체의 <code>f_in_cleanup</code> 속성 또는 제너레이터의 <code>gi_frame</code> 속성의 값을 반환합니다.</li>
<li><code>getcleanupframe()</code>: 프레임 객체를 인수로 받아, <code>f_in_cleanup</code> 값이 <code>True</code>인 가장 안쪽 프레임을 반환하거나, 스택에 해당 속성의 0이 아닌 값을 가진 프레임이 없으면 <code>None</code>을 반환합니다. <code>getouterframes()</code>와 마찬가지로 지정된 프레임부터 <code>f_back</code> 포인터를 사용하여 외부 프레임으로 탐색합니다.</li>
</ul>
<h3>예시 (Example)</h3>
<p>안전하게 인터럽트(SIGINT)를 처리하는 핸들러 구현 예시는 다음과 같습니다.</p>
<pre><code class="language-python">import inspect, sys, functools

def sigint_handler(sig, frame):
    if inspect.getcleanupframe(frame) is None:
        raise KeyboardInterrupt()
sys.setcleanuphook(functools.partial(sigint_handler, 0))
</code></pre>
<p>코루틴 예시는 코루틴 라이브러리에서 사용하는 트램폴린(또는 메인 루프)에 크게 의존하므로 이 문서의 범위 밖입니다.</p>
<h2>미해결 문제 (Unresolved Issues)</h2>
<h3><code>with</code> 문 표현식 내부에서의 인터럽트 (Interruption Inside With Statement Expression)</h3>
<p>다음과 같은 <code>with</code> 문에서 <code>open()</code>이 호출된 후, 하지만 <code>SETUP_WITH</code> 바이트코드가 실행되기 전에 Python이 인터럽트될 수 있습니다.</p>
<pre><code class="language-python">with open(filename):
    do_something()
</code></pre>
<p>두 가지 해결책이 있습니다.</p>
<ol>
<li>
<p><code>with</code> 표현식을 보호합니다. 이는 현재 <code>with</code> 표현식의 시작을 인식하는 방법이 없으므로 다른 바이트코드를 필요로 할 것입니다.</p>
</li>
<li>
<p>사용자가 중요하다고 생각하는 경우 래퍼(Wrapper)를 작성하게 합니다. 안전한 래퍼는 다음과 같을 수 있습니다.</p>
<pre><code class="language-python">class FileWrapper(object):
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
    def __enter__(self):
        self.file = open(self.filename, self.mode)
    def __exit__(self):
        self.file.close()
</code></pre>
<p>또는 <code>contextmanager()</code> 데코레이터를 사용하여 작성할 수 있습니다.</p>
<pre><code class="language-python">@contextmanager
def open_wrapper(filename, mode):
    file = open(filename, mode)
    try:
        yield file
    finally:
        file.close()
</code></pre>
<p>이 코드는 제너레이터의 첫 번째 부분(yield 이전)이 호출자의 <code>SETUP_WITH</code> 바이트코드 내에서 실행되므로 안전합니다.</p>
</li>
</ol>
<h3>예외 전파 (Exception Propagation)</h3>
<p>때로는 <code>finally</code> 절이나 <code>__enter__()</code>/<code>__exit__()</code> 메서드에서 예외가 발생할 수 있습니다. <code>KeyboardInterrupt</code>나 <code>SystemExit</code>와 같은 더 중요한 예외가 대신 발생해야 하므로 일반적으로 문제는 되지 않습니다. 그러나 원래 예외를 <code>__context__</code> 속성에 유지할 수 있다면 좋을 수 있습니다. 따라서 정리 훅(cleanup hook) 시그니처에 예외 인수를 추가할 수 있습니다.</p>
<pre><code class="language-python">def sigint_handler(sig, frame):
    if inspect.getcleanupframe(frame) is None:
        raise KeyboardInterrupt()
sys.setcleanuphook(retry_sigint)

def retry_sigint(frame, exception=None):
    if inspect.getcleanupframe(frame) is None:
        raise KeyboardInterrupt() from exception
</code></pre>
<p>Python 3에서는 예외에 <code>__traceback__</code> 속성이 있으므로 <code>__exit__</code> 메서드처럼 세 개의 인수가 필요하지 않습니다. 그러나 이렇게 하면 예외의 <code>__cause__</code>가 설정되는데, 이는 정확히 의도한 바가 아닙니다. 따라서 정리 훅에서 발생하는 모든 예외에 <code>__context__</code> 속성을 추가하기 위해 일부 숨겨진 인터프리터 로직이 사용될 수 있습니다.</p>
<h3>자원 획득과 <code>try</code> 블록 사이의 인터럽트 (Interruption Between Acquiring Resource and Try Block)</h3>
<p>첫 섹션의 예시는 완전히 안전하지 않습니다. 다음 코드를 다시 살펴보겠습니다.</p>
<pre><code class="language-python">lock.acquire()
try:
    do_something()
finally:
    lock.release()
</code></pre>
<p><code>lock.acquire()</code>가 실행된 직후 <code>try</code> 블록에 진입하기 전에 코드가 인터럽트되면 문제가 발생할 수 있습니다. 수정되지 않은 코드는 이 문제를 해결할 수 없습니다. 실제 해결책은 사용 사례에 크게 의존합니다. 일반적으로 <code>with</code> 문을 사용하여 코드를 수정할 수 있습니다.</p>
<pre><code class="language-python">with lock:
    do_something()
</code></pre>
<p>그러나 코루틴의 경우 <code>acquire</code> 및 <code>release</code> 작업 모두에 <code>yield</code>가 필요하므로 <code>with</code> 문을 사용할 수 없는 경우가 많습니다. 따라서 코드는 다음과 같이 다시 작성될 수 있습니다.</p>
<pre><code class="language-python">try:
    yield lock.acquire()
    do_something()
finally:
    yield lock.release()
</code></pre>
<p>실제 잠금(locking) 코드는 이 사용 사례를 지원하기 위해 더 많은 코드가 필요할 수 있지만, 구현은 일반적으로 간단합니다. 예를 들어, 잠금이 획득되었는지 확인하고 획득되었다면 잠금을 해제하는 식입니다.</p>
<h3><code>finally</code> 내부에서 <code>EINTR</code> 처리 (Handling EINTR Inside a Finally)</h3>
<p><code>f_in_cleanup</code> 플래그를 확인하도록 준비된 시그널 핸들러가 있더라도, 해당 시스템 호출이 <code>EINTR</code> 오류를 반환했기 때문에 정리 핸들러에서 <code>InterruptedError</code>가 발생할 수 있습니다. 주요 사용 사례는 이를 처리하도록 준비되어 있습니다.</p>
<ul>
<li>Posix 뮤텍스(mutexes)는 <code>EINTR</code>를 반환하지 않습니다.</li>
<li>네트워킹 라이브러리는 항상 <code>EINTR</code>를 처리하도록 준비되어 있습니다.</li>
<li>코루틴 라이브러리는 일반적으로 시그널이 아닌 <code>throw()</code> 메서드로 인터럽트됩니다.</li>
</ul>
<p>플랫폼 특정 함수 <code>siginterrupt()</code>를 사용하여 <code>EINTR</code>를 처리할 필요를 없앨 수 있습니다. 그러나 이로 인해 예측하기 어려운 결과가 발생할 수 있습니다. 예를 들어, 메인 스레드가 I/O 루틴에 갇혀 있으면 <code>SIGINT</code> 핸들러가 절대 호출되지 않을 수 있습니다.</p>
<p>더 나은 접근 방식은 일반적으로 정리 핸들러에서 사용되는 코드가 명시적으로 <code>InterruptedError</code>를 처리하도록 준비하는 것입니다. 파일 기반 잠금 구현이 이러한 코드의 예시가 될 수 있습니다.</p>
<p><code>signal.pthread_sigmask</code>를 사용하여 <code>EINTR</code>로 인터럽트될 수 있는 정리 핸들러 내부에서 시그널을 블록할 수 있습니다.</p>
<h3><code>finally</code> 자체 내부에서 인터럽트 컨텍스트 설정 (Setting Interruption Context Inside Finally Itself)</h3>
<p>일부 코루틴 라이브러리는 <code>finally</code> 절 자체에 타임아웃을 설정해야 할 수 있습니다. 예를 들어:</p>
<pre><code class="language-python">try:
    do_something()
finally:
    with timeout(0.5):
        try:
            yield do_slow_cleanup()
        finally:
            yield do_fast_cleanup()
</code></pre>
<p>현재 의미론으로는 <code>timeout</code>이 전체 <code>with</code> 블록을 보호하거나 전혀 보호하지 않을 수 있습니다. 이는 각 라이브러리의 구현에 따라 달라집니다. 작성자가 의도한 것은 <code>do_slow_cleanup</code>를 일반 코드로, <code>do_fast_cleanup</code>를 정리 코드(인터럽트 불가능한)로 취급하는 것입니다.</p>
<p>이 문제는 <code>f_in_cleanup</code>를 카운터로 노출하고, 카운터가 감소할 때마다 정리 훅을 호출하여 해결할 수 있습니다. 그러면 코루틴 라이브러리가 타임아웃 시작 시의 값을 기억하고 각 훅 실행 시 비교할 수 있습니다. 그러나 실제로는 이 예시가 너무 난해하여 고려할 가치가 없다고 간주됩니다.</p>
<h3><code>KeyboardInterrupt</code> 수정 (Modifying KeyboardInterrupt)</h3>
<p>기본 <code>SIGINT</code> 핸들러를 설명된 메커니즘을 사용하도록 수정해야 할지 결정해야 합니다. 초기 제안은 두 가지 이유로 이전 동작을 유지하는 것입니다.</p>
<ol>
<li>대부분의 애플리케이션은 종료 시 정리(외부 상태가 없거나 충돌 방지 방식으로 수정하는 경우)에 신경 쓰지 않습니다.</li>
<li>정리가 너무 많은 시간을 소요하여 사용자에게 애플리케이션을 인터럽트할 기회를 주지 않을 수 있습니다.</li>
</ol>
<p>후자의 경우는 <code>SIGINT</code> 핸들러가 두 번 호출되면 안전하지 않은 중단을 허용하여 해결할 수 있지만, 복잡성을 추가할 가치가 없는 것으로 보입니다.</p>
<h2>다른 Python 구현 지원 (Alternative Python Implementations Support)</h2>
<p><code>f_in_cleanup</code>는 구현 세부 사항으로 간주됩니다. 실제 구현은 시그널 핸들러, 정리 훅에 전달되고 <code>getcleanupframe()</code>에서 반환되는 일부 가짜 프레임과 유사한 객체를 가질 수 있습니다. 유일한 요구 사항은 <code>inspect</code> 모듈 함수가 이러한 객체에서 예상대로 작동한다는 것입니다. 이러한 이유로 <code>isframeincleanup()</code> 함수에 제너레이터 객체를 전달하는 것도 허용하며, 이는 <code>gi_frame</code> 속성을 사용할 필요를 없앱니다.</p>
<p><code>getcleanupframe()</code>이 다음 호출 시 정리 훅에 전달될 것과 동일한 객체를 반환해야 한다고 명시할 필요가 있을 수 있습니다.</p>
<h2>대체 이름 (Alternative Names)</h2>
<p>원래 제안에는 <code>f_in_finally</code> 프레임 속성이 있었는데, 원래 의도는 <code>finally</code> 절을 보호하는 것이었기 때문입니다. 그러나 <code>__enter__</code> 및 <code>__exit__</code> 메서드도 보호하도록 확장되면서 <code>f_in_cleanup</code> 이름이 더 적절해 보입니다. <code>__enter__</code> 메서드는 정리 루틴은 아니지만, Context Manager에 의해 수행되는 정리와 관련이 있습니다.</p>
<p><code>setcleanuphook</code>, <code>isframeincleanup</code>, <code>getcleanupframe</code>는 해당 모듈의 명명 규칙을 따르지만, <code>set_cleanup_hook</code>, <code>is_frame_in_cleanup</code>, <code>get_cleanup_frame</code>로 명확하게 바꿀 수 있습니다.</p>
<h2>대체 제안 (Alternative Proposals)</h2>
<h3><code>f_in_cleanup</code> 플래그 자동 전파 (Propagating 'f_in_cleanup' Flag Automatically)</h3>
<p>이것은 <code>getcleanupframe()</code>를 불필요하게 만들 수 있습니다. 그러나 <code>yield</code> 기반 코루틴의 경우 직접 전파해야 합니다. 쓰기 가능하게 만들면 <code>sys.setcleanuphook()</code>의 동작이 다소 예측 불가능해집니다.</p>
<h3>바이트코드 <code>INCR_CLEANUP</code>, <code>DECR_CLEANUP</code> 추가 (Add Bytecodes 'INCR_CLEANUP', 'DECR_CLEANUP')</h3>
<p>이러한 바이트코드는 <code>with</code> 문 내부의 표현식을 보호하는 데 사용될 수 있으며, 카운터 증가를 더 명시적이고 디버그하기 쉽게 만들 수 있습니다(디스어셈블리 내부에서 확인 가능). <code>END_FINALLY</code> 및 <code>SETUP_WITH</code>가 암시적으로 카운터를 감소시키는 것과 같은 중간 지점이 선택될 수 있습니다(<code>END_FINALLY</code>는 모든 <code>with</code> 스위트 끝에 있습니다).</p>
<p>그러나 새 바이트코드를 추가하는 것은 매우 신중하게 고려해야 합니다.</p>
<h3><code>f_in_cleanup</code>를 카운터로 노출 (Expose 'f_in_cleanup' as a Counter)</h3>
<p>원래 의도는 최소한의 필요한 기능을 노출하는 것이었습니다. 그러나 프레임 플래그 <code>f_in_cleanup</code>를 구현 세부 사항으로 간주하므로 이를 카운터로 노출할 수 있습니다.</p>
<p>마찬가지로, 카운터가 있다면 카운터가 감소할 때마다 정리 훅을 호출해야 할 수도 있습니다. 중첩된 <code>finally</code> 절은 흔하지 않은 경우이므로 성능에 큰 영향을 미칠 가능성은 낮습니다.</p>
<h3>코드 객체 플래그 <code>CO_CLEANUP</code> 추가 (Add code object flag 'CO_CLEANUP')</h3>
<p><code>SETUP_WITH</code> 및 <code>WITH_CLEANUP</code> 바이트코드 내에서 플래그를 설정하는 대안으로 <code>CO_CLEANUP</code> 플래그를 도입할 수 있습니다. 인터프리터가 <code>CO_CLEANUP</code>가 설정된 코드를 실행하기 시작하면 전체 함수 본문에 대해 <code>f_in_cleanup</code>를 설정합니다. 이 플래그는 <code>__enter__</code> 및 <code>__exit__</code> 특수 메서드의 코드 객체에 설정됩니다. 기술적으로는 <code>__enter__</code> 및 <code>__exit__</code>라는 함수에 설정될 수 있습니다.</p>
<p>이것은 덜 명확한 해결책으로 보입니다. 또한 <code>__enter__</code> 및 <code>__exit__</code>가 수동으로 호출되는 경우도 포함합니다. 이는 기능으로 받아들여지거나 불필요한 부작용(또는 발생 가능성은 낮지만 버그)으로 받아들여질 수 있습니다.</p>
<p><code>__enter__</code> 또는 <code>__exit__</code> 함수가 C로 구현된 경우 <code>f_in_cleanup</code> 플래그를 확인할 코드 객체가 없으므로 문제가 발생할 수도 있습니다.</p>
<h3>프레임 객체 자체에 정리 콜백 두기 (Have Cleanup Callback on Frame Object Itself)</h3>
<p>프레임 객체는 <code>f_in_cleanup</code>가 0으로 재설정될 때 호출되는 <code>f_cleanup_callback</code> 멤버를 가질 수 있도록 확장될 수 있습니다. 이것은 다른 코루틴에 다른 콜백을 등록하는 데 도움이 될 것입니다.</p>
<p>겉으로 보기에 아름답지만, 이 해결책은 아무것도 추가하지 않습니다. 두 가지 주요 사용 사례는 다음과 같습니다.</p>
<ul>
<li>시그널 핸들러에서 콜백을 설정하는 경우. 이 경우 콜백은 본질적으로 하나입니다.</li>
<li>코루틴 사용 사례에서 루프당 하나의 콜백을 사용하는 경우. 여기서는 거의 모든 경우에 스레드당 하나의 루프만 있습니다.</li>
</ul>
<h3>정리 훅 없음 (No Cleanup Hook)</h3>
<p>원래 제안에는 정리 훅 명세가 포함되지 않았는데, 현재 도구를 사용하여 동일한 목표를 달성할 수 있는 몇 가지 방법이 있기 때문입니다.</p>
<ul>
<li><code>sys.settrace()</code>와 <code>f_trace</code> 콜백 사용: 이는 디버깅에 문제가 될 수 있고 성능에 큰 영향을 미칩니다(인터럽트가 자주 발생하지는 않지만).</li>
<li>조금 더 기다렸다가 다시 시도: 코루틴 라이브러리에는 쉽습니다. 시그널의 경우 <code>signal.alert</code>를 사용하여 달성할 수 있습니다.</li>
</ul>
<p>두 가지 방법 모두 너무 비실용적이라고 간주되며, <code>finally</code> 절에서 나가는 것을 catch하는 방법이 제안되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/419\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"e6YNzZ2BVZ8NBZ6boXfWj\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/419/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/419\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"419\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/419\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T536b,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0419/\"\u003ePEP 419 - Protecting cleanup statements from interruptions\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Deferred | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 06-Apr-2012\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e파이썬 PEP 419: 정리 코드 블록 보호\u003c/p\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003efinally\u003c/code\u003e 절 또는 Context Manager (컨텍스트 관리자)의 정리 과정 중에 Python 코드가 \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e나 \u003ccode\u003eGeneratorExit\u003c/code\u003e와 같은 인터럽트(방해)로부터 보호될 수 있는 방법을 제안합니다.\u003c/p\u003e\n\u003ch2\u003ePEP 연기 (PEP Deferral)\u003c/h2\u003e\n\u003cp\u003e이 PEP에서 다루는 개념에 대한 추가 탐색은 현재 이 PEP의 목표를 추진하고 피드백을 수집 및 통합하며, 이를 효과적으로 수행할 충분한 시간을 가진 담당자가 없기 때문에 연기되었습니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003ePython에는 \u003ccode\u003efinally\u003c/code\u003e 문과 \u003ccode\u003ewith\u003c/code\u003e 문을 사용하는 Context Manager라는 두 가지 좋은 정리 방법이 있습니다. 그러나 이 두 가지 모두 \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e나 \u003ccode\u003egenerator.throw()\u003c/code\u003e에 의해 발생하는 \u003ccode\u003eGeneratorExit\u003c/code\u003e로부터 보호되지 않습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 다음 코드를 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elock.acquire()\r\ntry:\r\n    print('starting')\r\n    do_something()\r\nfinally:\r\n    print('finished')\r\n    lock.release()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 \u003ccode\u003eprint('finished')\u003c/code\u003e 호출 직후 \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e가 발생하면, \u003ccode\u003elock\u003c/code\u003e은 해제되지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewith\u003c/code\u003e 문을 사용하는 다음 코드도 유사한 문제를 겪습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom threading import Lock\r\n\r\nclass MyLock:\r\n    def __init__(self):\r\n        self._lock_impl = Lock()\r\n    def __enter__(self):\r\n        self._lock_impl.acquire()\r\n        print(\"LOCKED\")\r\n    def __exit__(self):\r\n        print(\"UNLOCKING\")\r\n        self._lock_impl.release()\r\n\r\nlock = MyLock()\r\nwith lock:\r\n    do_something\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eprint()\u003c/code\u003e 호출 근처에서 \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e가 발생하면 \u003ccode\u003elock\u003c/code\u003e은 절대 해제되지 않을 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e코루틴 사용 사례 (Coroutine Use Case)\u003c/h3\u003e\n\u003cp\u003e코루틴에서도 유사한 문제가 발생합니다. 코루틴 라이브러리는 종종 타임아웃으로 코루틴을 인터럽트(중단)하기를 원합니다. \u003ccode\u003egenerator.throw()\u003c/code\u003e 메서드는 이 사용 사례에 적합하지만, 코루틴이 현재 \u003ccode\u003efinally\u003c/code\u003e 절 내에서 일시 중지되었는지 알 수 있는 방법이 없습니다.\u003c/p\u003e\n\u003cp\u003e다음은 \u003ccode\u003eyield\u003c/code\u003e 기반 코루틴을 사용하는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef run_locked():\r\n    yield connection.sendall('LOCK')\r\n    try:\r\n        yield do_something()\r\n        yield do_something_else()\r\n    finally:\r\n        yield connection.sendall('UNLOCK')\r\n\r\nwith timeout(5):\r\n    yield run_locked()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예시에서 \u003ccode\u003eyield something\u003c/code\u003e은 현재 코루틴의 실행을 일시 중지하고 \u003ccode\u003esomething\u003c/code\u003e 코루틴이 완료될 때까지 실행함을 의미합니다. \u003ccode\u003ewith timeout(5)\u003c/code\u003e 문은 모든 코드가 5초 타임아웃 내에 실행되도록 보장합니다. 이는 타임아웃 발생 시 코루틴 스택의 최상위 프레임에서 \u003ccode\u003egenerator.throw()\u003c/code\u003e를 호출하는 콜백을 메인 루프에 등록함으로써 이루어집니다.\u003c/p\u003e\n\u003ch2\u003e제안 내용 (Specification)\u003c/h2\u003e\n\u003ch3\u003e프레임 플래그 \u003ccode\u003ef_in_cleanup\u003c/code\u003e (Frame Flag 'f_in_cleanup')\u003c/h3\u003e\n\u003cp\u003e프레임 객체에 새로운 플래그 \u003ccode\u003ef_in_cleanup\u003c/code\u003e를 추가하는 것을 제안합니다. 이 프레임이 현재 \u003ccode\u003efinally\u003c/code\u003e 절을 실행 중인 경우 이 플래그는 \u003ccode\u003eTrue\u003c/code\u003e로 설정됩니다. 내부적으로 이 플래그는 현재 실행 중인 중첩된 \u003ccode\u003efinally\u003c/code\u003e 문의 카운터로 구현되어야 합니다.\u003c/p\u003e\n\u003cp\u003e이 내부 카운터는 \u003ccode\u003eSETUP_WITH\u003c/code\u003e 및 \u003ccode\u003eWITH_CLEANUP\u003c/code\u003e 바이트코드 실행 중에도 증가해야 하며, 이들 바이트코드 실행이 완료되면 감소해야 합니다. 이는 \u003ccode\u003e__enter__()\u003c/code\u003e 및 \u003ccode\u003e__exit__()\u003c/code\u003e 메서드도 보호할 수 있도록 합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003esys.setcleanuphook\u003c/code\u003e 함수 (Function 'sys.setcleanuphook')\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esys\u003c/code\u003e 모듈에 새로운 함수를 추가하는 것을 제안합니다. 이 함수는 \u003ccode\u003ef_in_cleanup\u003c/code\u003e가 \u003ccode\u003eFalse\u003c/code\u003e가 될 때마다 실행되는 콜백을 설정합니다. 콜백은 프레임 객체를 유일한 인수로 받아, 어디에서 호출되었는지 파악할 수 있습니다. 이 설정은 스레드 로컬이며 \u003ccode\u003ePyThreadState\u003c/code\u003e 구조체에 저장되어야 합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003einspect\u003c/code\u003e 모듈 개선 (Inspect Module Enhancements)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003einspect\u003c/code\u003e 모듈에 \u003ccode\u003eisframeincleanup()\u003c/code\u003e 및 \u003ccode\u003egetcleanupframe()\u003c/code\u003e 두 가지 새로운 함수를 제안합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eisframeincleanup()\u003c/code\u003e: 프레임 또는 제너레이터 객체를 인수로 받아, 프레임 자체의 \u003ccode\u003ef_in_cleanup\u003c/code\u003e 속성 또는 제너레이터의 \u003ccode\u003egi_frame\u003c/code\u003e 속성의 값을 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egetcleanupframe()\u003c/code\u003e: 프레임 객체를 인수로 받아, \u003ccode\u003ef_in_cleanup\u003c/code\u003e 값이 \u003ccode\u003eTrue\u003c/code\u003e인 가장 안쪽 프레임을 반환하거나, 스택에 해당 속성의 0이 아닌 값을 가진 프레임이 없으면 \u003ccode\u003eNone\u003c/code\u003e을 반환합니다. \u003ccode\u003egetouterframes()\u003c/code\u003e와 마찬가지로 지정된 프레임부터 \u003ccode\u003ef_back\u003c/code\u003e 포인터를 사용하여 외부 프레임으로 탐색합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e예시 (Example)\u003c/h3\u003e\n\u003cp\u003e안전하게 인터럽트(SIGINT)를 처리하는 핸들러 구현 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport inspect, sys, functools\r\n\r\ndef sigint_handler(sig, frame):\r\n    if inspect.getcleanupframe(frame) is None:\r\n        raise KeyboardInterrupt()\r\nsys.setcleanuphook(functools.partial(sigint_handler, 0))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코루틴 예시는 코루틴 라이브러리에서 사용하는 트램폴린(또는 메인 루프)에 크게 의존하므로 이 문서의 범위 밖입니다.\u003c/p\u003e\n\u003ch2\u003e미해결 문제 (Unresolved Issues)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003ewith\u003c/code\u003e 문 표현식 내부에서의 인터럽트 (Interruption Inside With Statement Expression)\u003c/h3\u003e\n\u003cp\u003e다음과 같은 \u003ccode\u003ewith\u003c/code\u003e 문에서 \u003ccode\u003eopen()\u003c/code\u003e이 호출된 후, 하지만 \u003ccode\u003eSETUP_WITH\u003c/code\u003e 바이트코드가 실행되기 전에 Python이 인터럽트될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ewith open(filename):\r\n    do_something()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 가지 해결책이 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ewith\u003c/code\u003e 표현식을 보호합니다. 이는 현재 \u003ccode\u003ewith\u003c/code\u003e 표현식의 시작을 인식하는 방법이 없으므로 다른 바이트코드를 필요로 할 것입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e사용자가 중요하다고 생각하는 경우 래퍼(Wrapper)를 작성하게 합니다. 안전한 래퍼는 다음과 같을 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass FileWrapper(object):\r\n    def __init__(self, filename, mode):\r\n        self.filename = filename\r\n        self.mode = mode\r\n    def __enter__(self):\r\n        self.file = open(self.filename, self.mode)\r\n    def __exit__(self):\r\n        self.file.close()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 \u003ccode\u003econtextmanager()\u003c/code\u003e 데코레이터를 사용하여 작성할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@contextmanager\r\ndef open_wrapper(filename, mode):\r\n    file = open(filename, mode)\r\n    try:\r\n        yield file\r\n    finally:\r\n        file.close()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 제너레이터의 첫 번째 부분(yield 이전)이 호출자의 \u003ccode\u003eSETUP_WITH\u003c/code\u003e 바이트코드 내에서 실행되므로 안전합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e예외 전파 (Exception Propagation)\u003c/h3\u003e\n\u003cp\u003e때로는 \u003ccode\u003efinally\u003c/code\u003e 절이나 \u003ccode\u003e__enter__()\u003c/code\u003e/\u003ccode\u003e__exit__()\u003c/code\u003e 메서드에서 예외가 발생할 수 있습니다. \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e나 \u003ccode\u003eSystemExit\u003c/code\u003e와 같은 더 중요한 예외가 대신 발생해야 하므로 일반적으로 문제는 되지 않습니다. 그러나 원래 예외를 \u003ccode\u003e__context__\u003c/code\u003e 속성에 유지할 수 있다면 좋을 수 있습니다. 따라서 정리 훅(cleanup hook) 시그니처에 예외 인수를 추가할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef sigint_handler(sig, frame):\r\n    if inspect.getcleanupframe(frame) is None:\r\n        raise KeyboardInterrupt()\r\nsys.setcleanuphook(retry_sigint)\r\n\r\ndef retry_sigint(frame, exception=None):\r\n    if inspect.getcleanupframe(frame) is None:\r\n        raise KeyboardInterrupt() from exception\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 3에서는 예외에 \u003ccode\u003e__traceback__\u003c/code\u003e 속성이 있으므로 \u003ccode\u003e__exit__\u003c/code\u003e 메서드처럼 세 개의 인수가 필요하지 않습니다. 그러나 이렇게 하면 예외의 \u003ccode\u003e__cause__\u003c/code\u003e가 설정되는데, 이는 정확히 의도한 바가 아닙니다. 따라서 정리 훅에서 발생하는 모든 예외에 \u003ccode\u003e__context__\u003c/code\u003e 속성을 추가하기 위해 일부 숨겨진 인터프리터 로직이 사용될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e자원 획득과 \u003ccode\u003etry\u003c/code\u003e 블록 사이의 인터럽트 (Interruption Between Acquiring Resource and Try Block)\u003c/h3\u003e\n\u003cp\u003e첫 섹션의 예시는 완전히 안전하지 않습니다. 다음 코드를 다시 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elock.acquire()\r\ntry:\r\n    do_something()\r\nfinally:\r\n    lock.release()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003elock.acquire()\u003c/code\u003e가 실행된 직후 \u003ccode\u003etry\u003c/code\u003e 블록에 진입하기 전에 코드가 인터럽트되면 문제가 발생할 수 있습니다. 수정되지 않은 코드는 이 문제를 해결할 수 없습니다. 실제 해결책은 사용 사례에 크게 의존합니다. 일반적으로 \u003ccode\u003ewith\u003c/code\u003e 문을 사용하여 코드를 수정할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ewith lock:\r\n    do_something()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 코루틴의 경우 \u003ccode\u003eacquire\u003c/code\u003e 및 \u003ccode\u003erelease\u003c/code\u003e 작업 모두에 \u003ccode\u003eyield\u003c/code\u003e가 필요하므로 \u003ccode\u003ewith\u003c/code\u003e 문을 사용할 수 없는 경우가 많습니다. 따라서 코드는 다음과 같이 다시 작성될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\r\n    yield lock.acquire()\r\n    do_something()\r\nfinally:\r\n    yield lock.release()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e실제 잠금(locking) 코드는 이 사용 사례를 지원하기 위해 더 많은 코드가 필요할 수 있지만, 구현은 일반적으로 간단합니다. 예를 들어, 잠금이 획득되었는지 확인하고 획득되었다면 잠금을 해제하는 식입니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003efinally\u003c/code\u003e 내부에서 \u003ccode\u003eEINTR\u003c/code\u003e 처리 (Handling EINTR Inside a Finally)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ef_in_cleanup\u003c/code\u003e 플래그를 확인하도록 준비된 시그널 핸들러가 있더라도, 해당 시스템 호출이 \u003ccode\u003eEINTR\u003c/code\u003e 오류를 반환했기 때문에 정리 핸들러에서 \u003ccode\u003eInterruptedError\u003c/code\u003e가 발생할 수 있습니다. 주요 사용 사례는 이를 처리하도록 준비되어 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePosix 뮤텍스(mutexes)는 \u003ccode\u003eEINTR\u003c/code\u003e를 반환하지 않습니다.\u003c/li\u003e\n\u003cli\u003e네트워킹 라이브러리는 항상 \u003ccode\u003eEINTR\u003c/code\u003e를 처리하도록 준비되어 있습니다.\u003c/li\u003e\n\u003cli\u003e코루틴 라이브러리는 일반적으로 시그널이 아닌 \u003ccode\u003ethrow()\u003c/code\u003e 메서드로 인터럽트됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e플랫폼 특정 함수 \u003ccode\u003esiginterrupt()\u003c/code\u003e를 사용하여 \u003ccode\u003eEINTR\u003c/code\u003e를 처리할 필요를 없앨 수 있습니다. 그러나 이로 인해 예측하기 어려운 결과가 발생할 수 있습니다. 예를 들어, 메인 스레드가 I/O 루틴에 갇혀 있으면 \u003ccode\u003eSIGINT\u003c/code\u003e 핸들러가 절대 호출되지 않을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e더 나은 접근 방식은 일반적으로 정리 핸들러에서 사용되는 코드가 명시적으로 \u003ccode\u003eInterruptedError\u003c/code\u003e를 처리하도록 준비하는 것입니다. 파일 기반 잠금 구현이 이러한 코드의 예시가 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esignal.pthread_sigmask\u003c/code\u003e를 사용하여 \u003ccode\u003eEINTR\u003c/code\u003e로 인터럽트될 수 있는 정리 핸들러 내부에서 시그널을 블록할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003efinally\u003c/code\u003e 자체 내부에서 인터럽트 컨텍스트 설정 (Setting Interruption Context Inside Finally Itself)\u003c/h3\u003e\n\u003cp\u003e일부 코루틴 라이브러리는 \u003ccode\u003efinally\u003c/code\u003e 절 자체에 타임아웃을 설정해야 할 수 있습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\r\n    do_something()\r\nfinally:\r\n    with timeout(0.5):\r\n        try:\r\n            yield do_slow_cleanup()\r\n        finally:\r\n            yield do_fast_cleanup()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 의미론으로는 \u003ccode\u003etimeout\u003c/code\u003e이 전체 \u003ccode\u003ewith\u003c/code\u003e 블록을 보호하거나 전혀 보호하지 않을 수 있습니다. 이는 각 라이브러리의 구현에 따라 달라집니다. 작성자가 의도한 것은 \u003ccode\u003edo_slow_cleanup\u003c/code\u003e를 일반 코드로, \u003ccode\u003edo_fast_cleanup\u003c/code\u003e를 정리 코드(인터럽트 불가능한)로 취급하는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 문제는 \u003ccode\u003ef_in_cleanup\u003c/code\u003e를 카운터로 노출하고, 카운터가 감소할 때마다 정리 훅을 호출하여 해결할 수 있습니다. 그러면 코루틴 라이브러리가 타임아웃 시작 시의 값을 기억하고 각 훅 실행 시 비교할 수 있습니다. 그러나 실제로는 이 예시가 너무 난해하여 고려할 가치가 없다고 간주됩니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eKeyboardInterrupt\u003c/code\u003e 수정 (Modifying KeyboardInterrupt)\u003c/h3\u003e\n\u003cp\u003e기본 \u003ccode\u003eSIGINT\u003c/code\u003e 핸들러를 설명된 메커니즘을 사용하도록 수정해야 할지 결정해야 합니다. 초기 제안은 두 가지 이유로 이전 동작을 유지하는 것입니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e대부분의 애플리케이션은 종료 시 정리(외부 상태가 없거나 충돌 방지 방식으로 수정하는 경우)에 신경 쓰지 않습니다.\u003c/li\u003e\n\u003cli\u003e정리가 너무 많은 시간을 소요하여 사용자에게 애플리케이션을 인터럽트할 기회를 주지 않을 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e후자의 경우는 \u003ccode\u003eSIGINT\u003c/code\u003e 핸들러가 두 번 호출되면 안전하지 않은 중단을 허용하여 해결할 수 있지만, 복잡성을 추가할 가치가 없는 것으로 보입니다.\u003c/p\u003e\n\u003ch2\u003e다른 Python 구현 지원 (Alternative Python Implementations Support)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ef_in_cleanup\u003c/code\u003e는 구현 세부 사항으로 간주됩니다. 실제 구현은 시그널 핸들러, 정리 훅에 전달되고 \u003ccode\u003egetcleanupframe()\u003c/code\u003e에서 반환되는 일부 가짜 프레임과 유사한 객체를 가질 수 있습니다. 유일한 요구 사항은 \u003ccode\u003einspect\u003c/code\u003e 모듈 함수가 이러한 객체에서 예상대로 작동한다는 것입니다. 이러한 이유로 \u003ccode\u003eisframeincleanup()\u003c/code\u003e 함수에 제너레이터 객체를 전달하는 것도 허용하며, 이는 \u003ccode\u003egi_frame\u003c/code\u003e 속성을 사용할 필요를 없앱니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egetcleanupframe()\u003c/code\u003e이 다음 호출 시 정리 훅에 전달될 것과 동일한 객체를 반환해야 한다고 명시할 필요가 있을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e대체 이름 (Alternative Names)\u003c/h2\u003e\n\u003cp\u003e원래 제안에는 \u003ccode\u003ef_in_finally\u003c/code\u003e 프레임 속성이 있었는데, 원래 의도는 \u003ccode\u003efinally\u003c/code\u003e 절을 보호하는 것이었기 때문입니다. 그러나 \u003ccode\u003e__enter__\u003c/code\u003e 및 \u003ccode\u003e__exit__\u003c/code\u003e 메서드도 보호하도록 확장되면서 \u003ccode\u003ef_in_cleanup\u003c/code\u003e 이름이 더 적절해 보입니다. \u003ccode\u003e__enter__\u003c/code\u003e 메서드는 정리 루틴은 아니지만, Context Manager에 의해 수행되는 정리와 관련이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esetcleanuphook\u003c/code\u003e, \u003ccode\u003eisframeincleanup\u003c/code\u003e, \u003ccode\u003egetcleanupframe\u003c/code\u003e는 해당 모듈의 명명 규칙을 따르지만, \u003ccode\u003eset_cleanup_hook\u003c/code\u003e, \u003ccode\u003eis_frame_in_cleanup\u003c/code\u003e, \u003ccode\u003eget_cleanup_frame\u003c/code\u003e로 명확하게 바꿀 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e대체 제안 (Alternative Proposals)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003ef_in_cleanup\u003c/code\u003e 플래그 자동 전파 (Propagating 'f_in_cleanup' Flag Automatically)\u003c/h3\u003e\n\u003cp\u003e이것은 \u003ccode\u003egetcleanupframe()\u003c/code\u003e를 불필요하게 만들 수 있습니다. 그러나 \u003ccode\u003eyield\u003c/code\u003e 기반 코루틴의 경우 직접 전파해야 합니다. 쓰기 가능하게 만들면 \u003ccode\u003esys.setcleanuphook()\u003c/code\u003e의 동작이 다소 예측 불가능해집니다.\u003c/p\u003e\n\u003ch3\u003e바이트코드 \u003ccode\u003eINCR_CLEANUP\u003c/code\u003e, \u003ccode\u003eDECR_CLEANUP\u003c/code\u003e 추가 (Add Bytecodes 'INCR_CLEANUP', 'DECR_CLEANUP')\u003c/h3\u003e\n\u003cp\u003e이러한 바이트코드는 \u003ccode\u003ewith\u003c/code\u003e 문 내부의 표현식을 보호하는 데 사용될 수 있으며, 카운터 증가를 더 명시적이고 디버그하기 쉽게 만들 수 있습니다(디스어셈블리 내부에서 확인 가능). \u003ccode\u003eEND_FINALLY\u003c/code\u003e 및 \u003ccode\u003eSETUP_WITH\u003c/code\u003e가 암시적으로 카운터를 감소시키는 것과 같은 중간 지점이 선택될 수 있습니다(\u003ccode\u003eEND_FINALLY\u003c/code\u003e는 모든 \u003ccode\u003ewith\u003c/code\u003e 스위트 끝에 있습니다).\u003c/p\u003e\n\u003cp\u003e그러나 새 바이트코드를 추가하는 것은 매우 신중하게 고려해야 합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ef_in_cleanup\u003c/code\u003e를 카운터로 노출 (Expose 'f_in_cleanup' as a Counter)\u003c/h3\u003e\n\u003cp\u003e원래 의도는 최소한의 필요한 기능을 노출하는 것이었습니다. 그러나 프레임 플래그 \u003ccode\u003ef_in_cleanup\u003c/code\u003e를 구현 세부 사항으로 간주하므로 이를 카운터로 노출할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e마찬가지로, 카운터가 있다면 카운터가 감소할 때마다 정리 훅을 호출해야 할 수도 있습니다. 중첩된 \u003ccode\u003efinally\u003c/code\u003e 절은 흔하지 않은 경우이므로 성능에 큰 영향을 미칠 가능성은 낮습니다.\u003c/p\u003e\n\u003ch3\u003e코드 객체 플래그 \u003ccode\u003eCO_CLEANUP\u003c/code\u003e 추가 (Add code object flag 'CO_CLEANUP')\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eSETUP_WITH\u003c/code\u003e 및 \u003ccode\u003eWITH_CLEANUP\u003c/code\u003e 바이트코드 내에서 플래그를 설정하는 대안으로 \u003ccode\u003eCO_CLEANUP\u003c/code\u003e 플래그를 도입할 수 있습니다. 인터프리터가 \u003ccode\u003eCO_CLEANUP\u003c/code\u003e가 설정된 코드를 실행하기 시작하면 전체 함수 본문에 대해 \u003ccode\u003ef_in_cleanup\u003c/code\u003e를 설정합니다. 이 플래그는 \u003ccode\u003e__enter__\u003c/code\u003e 및 \u003ccode\u003e__exit__\u003c/code\u003e 특수 메서드의 코드 객체에 설정됩니다. 기술적으로는 \u003ccode\u003e__enter__\u003c/code\u003e 및 \u003ccode\u003e__exit__\u003c/code\u003e라는 함수에 설정될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이것은 덜 명확한 해결책으로 보입니다. 또한 \u003ccode\u003e__enter__\u003c/code\u003e 및 \u003ccode\u003e__exit__\u003c/code\u003e가 수동으로 호출되는 경우도 포함합니다. 이는 기능으로 받아들여지거나 불필요한 부작용(또는 발생 가능성은 낮지만 버그)으로 받아들여질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__enter__\u003c/code\u003e 또는 \u003ccode\u003e__exit__\u003c/code\u003e 함수가 C로 구현된 경우 \u003ccode\u003ef_in_cleanup\u003c/code\u003e 플래그를 확인할 코드 객체가 없으므로 문제가 발생할 수도 있습니다.\u003c/p\u003e\n\u003ch3\u003e프레임 객체 자체에 정리 콜백 두기 (Have Cleanup Callback on Frame Object Itself)\u003c/h3\u003e\n\u003cp\u003e프레임 객체는 \u003ccode\u003ef_in_cleanup\u003c/code\u003e가 0으로 재설정될 때 호출되는 \u003ccode\u003ef_cleanup_callback\u003c/code\u003e 멤버를 가질 수 있도록 확장될 수 있습니다. 이것은 다른 코루틴에 다른 콜백을 등록하는 데 도움이 될 것입니다.\u003c/p\u003e\n\u003cp\u003e겉으로 보기에 아름답지만, 이 해결책은 아무것도 추가하지 않습니다. 두 가지 주요 사용 사례는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e시그널 핸들러에서 콜백을 설정하는 경우. 이 경우 콜백은 본질적으로 하나입니다.\u003c/li\u003e\n\u003cli\u003e코루틴 사용 사례에서 루프당 하나의 콜백을 사용하는 경우. 여기서는 거의 모든 경우에 스레드당 하나의 루프만 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e정리 훅 없음 (No Cleanup Hook)\u003c/h3\u003e\n\u003cp\u003e원래 제안에는 정리 훅 명세가 포함되지 않았는데, 현재 도구를 사용하여 동일한 목표를 달성할 수 있는 몇 가지 방법이 있기 때문입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esys.settrace()\u003c/code\u003e와 \u003ccode\u003ef_trace\u003c/code\u003e 콜백 사용: 이는 디버깅에 문제가 될 수 있고 성능에 큰 영향을 미칩니다(인터럽트가 자주 발생하지는 않지만).\u003c/li\u003e\n\u003cli\u003e조금 더 기다렸다가 다시 시도: 코루틴 라이브러리에는 쉽습니다. 시그널의 경우 \u003ccode\u003esignal.alert\u003c/code\u003e를 사용하여 달성할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e두 가지 방법 모두 너무 비실용적이라고 간주되며, \u003ccode\u003efinally\u003c/code\u003e 절에서 나가는 것을 catch하는 방법이 제안되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Deferred] PEP 419 - Protecting cleanup statements from interruptions\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 21:36:35+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>