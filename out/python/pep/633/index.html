<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 633 - Dependency specification in pyproject.toml using an exploded TOML table</h1><div class="page__meta"><time dateTime="2025-09-27 01:25:08+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0633/">PEP 633 - Dependency specification in pyproject.toml using an exploded TOML table</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 02-Sep-2020</p>
</blockquote>
<h1>PEP 633 – pyproject.toml에서 확장된 TOML 테이블을 사용한 의존성 명세 (Dependency specification in pyproject.toml using an exploded TOML table)</h1>
<h2>거부 통지 (Rejection Notice)</h2>
<p>이 PEP는 PEP 631의 인기도, 기존 PEP 508 문자열 사용과의 일관성, 그리고 기존 패키징 도구 모음과의 호환성으로 인해 <strong>PEP 631을 지지하며 거부되었습니다.</strong></p>
<h2>요약 (Abstract)</h2>
<p>이 PEP 633은 PEP 621에 정의된 필드를 사용하여 <code>pyproject.toml</code> 파일에 프로젝트의 의존성(dependencies)을 정의하는 방법을 명세합니다. 이는 PEP 631에서 정의된 PEP 508 기반의 접근 방식에 대한 대안으로 제안되었습니다.</p>
<h2>동기 (Motivation)</h2>
<p>PEP 508 문자열 대신 TOML 테이블 및 기타 데이터 타입을 사용하여 요구사항(requirements)을 표현하는 데는 여러 이점이 있습니다.</p>
<ul>
<li><strong>쉬운 초기 유효성 검사:</strong> TOML 구문을 통해 쉽게 초기 유효성 검사를 수행할 수 있습니다.</li>
<li><strong>스키마를 통한 쉬운 보조 유효성 검사:</strong> 예를 들어 JSON Schema와 같은 스키마를 사용하여 추가적인 유효성 검사를 할 수 있습니다.</li>
<li><strong>사용자 편의성:</strong> 사용자가 구문을 암기할 필요 없이 특정 기능의 키를 추측할 가능성이 있습니다.</li>
<li><strong>다른 언어 사용자 친숙도:</strong> 다른 인기 있는 여러 언어의 사용자들은 이미 TOML 구문에 익숙할 수 있습니다.</li>
<li><strong>데이터 구조 이해:</strong> TOML은 JSON과 동일한 데이터 구조를 직접적으로 표현하며, 파이썬 리터럴(literals)의 부분 집합을 나타내므로 사용자가 계층 구조와 값의 유형을 이해하기 쉽습니다.</li>
</ul>
<h2>이론적 근거 (Rationale)</h2>
<p>이 PEP의 대부분은 PEP 621의 의존성 주제에 대한 논의에서 비롯되었습니다. Pipfile, Poetry, Dart의 의존성 관리 및 Rust의 Cargo에서 영감을 받았습니다. 이 형식과 PEP 508 스타일 명세자 간의 장단점을 비교한 문서도 존재합니다.</p>
<p>동일한 배포 이름에 대해 여러 요구사항을 명세할 때 (환경 마커(environment markers)가 적절한 의존성을 선택하는 경우), Poetry와 유사하게 요구사항 배열을 허용하는 방식이 채택되었습니다.</p>
<p><code>direct-reference</code> 키는 패키징 생태계의 차이를 줄이고 기존 명세 작업을 활용하기 위해 PEP 610 및 PEP 440과 밀접하게 일치하고 이를 활용합니다.</p>
<h2>명세 (Specification)</h2>
<p>PEP 621과 마찬가지로, 메타데이터가 부적절하게 명세된 경우 도구는 에러를 발생시켜야 합니다. 메타데이터는 TOML 명세를 따라야 합니다.</p>
<p>이 문서는 의존성 명세를 위한 명세서이므로 혼란을 줄이기 위해 "requirement"라는 단어는 PEP 508 의존성 명세를 의미하는 데 사용됩니다.</p>
<p>PEP 621에 명세된 <code>project</code> 테이블에 다음 테이블이 추가됩니다.</p>
<h3><code>dependencies</code></h3>
<ul>
<li><strong>형식:</strong> <code>table</code></li>
<li>이 테이블 내부의 키는 필요한 배포판의 이름입니다. 값은 다음 유형 중 하나를 가질 수 있습니다.
<ul>
<li><strong><code>string</code></strong>: 요구사항이 오직 버전 요구사항에 의해 정의되며, 요구사항 테이블의 버전 명세와 동일합니다. 단, 버전 제한을 두지 않음을 나타내는 빈 문자열 <code>""</code>을 허용합니다.</li>
<li><strong><code>table</code></strong>: 요구사항 테이블입니다.</li>
<li><strong><code>array</code></strong>: 요구사항 테이블의 배열입니다. 비워 있는 <code>[]</code> 배열을 값으로 지정하는 것은 에러입니다.</li>
</ul>
</li>
</ul>
<h3>요구사항 테이블 (Requirement table)</h3>
<p>요구사항 테이블의 키는 다음과 같습니다 (모두 선택 사항입니다).</p>
<ul>
<li><strong><code>version</code> (string):</strong> PEP 440 버전 명세자이며, 쉼표로 구분된 버전 명세 절(clauses) 목록입니다. 이 문자열은 비워 있을 수 없습니다.</li>
<li><strong><code>extras</code> (array of strings):</strong> 배포판에 대한 PEP 508 <code>extras</code> 선언 목록입니다. 이 목록은 비워 있을 수 없습니다.</li>
<li><strong><code>markers</code> (string):</strong> PEP 508 환경 마커(environment marker) 표현식입니다. 이 문자열은 비워 있을 수 없습니다.</li>
<li><strong><code>url</code> (string):</strong> 요구사항을 충족하기 위해 설치할 아티팩트(artifact)의 URL입니다. <code>file://</code>은 로컬 파일 시스템에서 패키지를 검색하는 데 사용되는 접두사입니다.</li>
<li><strong><code>git</code>, <code>hg</code>, <code>bzr</code> 또는 <code>svn</code> (string):</strong> 클론(clone)할 VCS 저장소(PEP 440에 명시됨)의 URL입니다. 해당 저장소의 트리는 요구사항을 충족하기 위해 설치됩니다. 추가 VCS 키는 PEP 610의 수정 사항을 통해 추가될 예정이며, 도구는 수정 사항이 승인되기 전에 명령줄 명령을 사용하여 다른 VCS를 지원하도록 선택할 수 있습니다.</li>
<li><strong><code>revision</code> (string):</strong> 설치 전에 체크아웃(check-out)할 지정된 VCS 저장소의 특정 리비전(revision) 식별자입니다. 사용자는 <code>git</code>, <code>hg</code>, <code>bzr</code>, <code>svn</code> 또는 다른 VCS 키 중 하나가 설치할 배포판을 식별하는 데 사용될 때만 이를 제공해야 합니다. 리비전 식별자는 PEP 610에 제안되어 있습니다.</li>
</ul>
<p><code>version</code>, <code>url</code>, <code>git</code>, <code>hg</code>, <code>bzr</code>, <code>svn</code> 및 기타 VCS 키는 논리적으로 서로 충돌하므로 동시에 최대 하나만 지정할 수 있습니다.</p>
<p>빈 요구사항 테이블 <code>{}</code>은 빈 문자열 <code>""</code> 외에 요구사항에 대한 제한을 두지 않습니다.</p>
<p>이 문서에 명시되지 않은 키가 제공되면 파싱(parsing) 시 에러가 발생해야 합니다.</p>
<h3><code>optional-dependencies</code></h3>
<ul>
<li><strong>형식:</strong> <code>table</code></li>
<li>이 테이블 내부의 키는 extra에 필요한 배포판의 이름입니다. 값은 다음 유형 중 하나를 가질 수 있습니다.
<ul>
<li><strong><code>table</code></strong>: 요구사항 테이블입니다.</li>
<li><strong><code>array</code></strong>: 요구사항 테이블의 배열입니다.</li>
</ul>
</li>
</ul>
<p>이러한 요구사항 테이블은 위에 명시된 것과 동일한 명세를 가지며, 다음 필수 키가 추가됩니다.</p>
<ul>
<li><strong><code>for-extra</code> (string):</strong> 이 요구사항이 필요한 PEP 508 extra의 이름입니다.</li>
</ul>
<h3>참조 구현 (Reference implementation)</h3>
<p>도구는 이 형식을 PEP 508 요구사항 문자열로 변환해야 합니다. 아래는 해당 변환의 예시 구현입니다 (유효성 검사가 이미 수행되었다고 가정합니다).</p>
<pre><code class="language-python">def convert_requirement_to_pep508(name, requirement):
    if isinstance(requirement, str):
        requirement = {"version": requirement}
    pep508 = name
    if "extras" in requirement:
        pep508 += " [" + ", ".join(requirement["extras"]) + "]"
    if "version" in requirement:
        pep508 += " " + requirement["version"]
    if "url" in requirement:
        pep508 += " @ " + requirement["url"]
    for vcs in ("git", "hg", "bzr", "svn"):
        if vcs in requirement:
            pep508 += " @ " + vcs + "+" + requirement[vcs]
            if "revision" in requirement:
                pep508 += "@" + requirement["revision"]
    extra = None
    if "for-extra" in requirement:
        extra = requirement["for-extra"]
    if "markers" in requirement:
        markers = requirement["markers"]
        if extra:
            markers = "extra = '" + extra + "' and (" + markers + ")"
        pep508 += "; " + markers
    return pep508, extra

def convert_requirements_to_pep508(dependencies):
    pep508s = []
    extras = set()
    for name, req in dependencies.items():
        if isinstance(req, list):
            for sub_req in req:
                pep508, extra = convert_requirement_to_pep508(name, sub_req)
                pep508s.append(pep508)
                if extra:
                    extras.add(extra)
        else:
            pep508, extra = convert_requirement_to_pep508(name, req)
            pep508s.append(pep508)
            if extra:
                extras.add(extra)
    return pep508s, extras

def convert_project_requirements_to_pep508(project):
    reqs, _ = convert_requirements_to_pep508(project.get("dependencies", {}))
    optional_reqs, extras = convert_requirements_to_pep508(
        project.get("optional-dependencies", {})
    )
    reqs += optional_reqs
    return reqs, extras
</code></pre>
<h3>JSON Schema</h3>
<p>초기 유효성 검사를 위해 JSON Schema를 사용할 수 있습니다. 이는 도구가 일관된 유효성 검사를 수행하는 데 도움이 될 뿐만 아니라, 코드 편집기가 사용자가 의존성 목록을 작성하는 동안 유효성 검사 오류를 강조 표시할 수 있도록 합니다.</p>
<p>(JSON Schema의 전체 내용은 생략합니다. 원문 PEP 633에서 확인할 수 있습니다.)</p>
<h3>예시 (Examples)</h3>
<p>PEP 633이 <code>pyproject.toml</code>에서 의존성을 어떻게 정의하는지에 대한 다양한 예시가 제공됩니다.</p>
<h4>버전 제약이 있는 의존성 (Version Constrained Dependencies)</h4>
<ul>
<li><strong>버전 제약 없음:</strong>
<pre><code class="language-toml"># PEP 508 스타일
# aiohttp
# PEP 633 스타일
aiohttp = {}
</code></pre>
</li>
<li><strong>간단한 버전 제약:</strong>
<pre><code class="language-toml"># PEP 508 스타일
# aiohttp >= 3.6.2, &#x3C; 4.0.0
# PEP 633 스타일
aiohttp = { version = ">= 3.6.2, &#x3C; 4.0.0" }
# 간결하게 문자열로도 표현 가능
# aiohttp = ">= 3.6.2, &#x3C; 4.0.0"
</code></pre>
</li>
</ul>
<h4>직접 참조 의존성 (Direct Reference Dependencies)</h4>
<ul>
<li><strong>URL 의존성:</strong>
<pre><code class="language-toml"># PEP 508 스타일
# aiohttp @ https://files.pythonhosted.org/packages/.../aiohttp-3.6.2-cp35-cp35m-macosx_10_13_x86_64.whl
# PEP 633 스타일
aiohttp = { url = "https://files.pythonhosted.org/packages/.../aiohttp-3.6.2-cp35-cp35m-macosx_10_13_x86_64.whl" }
</code></pre>
</li>
<li><strong>VCS 의존성 (Git):</strong>
<pre><code class="language-toml"># PEP 508 스타일
# aiohttp @ git+ssh://git@github.com/aio-libs/aiohttp.git@master
# PEP 633 스타일
aiohttp = { git = "ssh://git@github.com/aio-libs/aiohttp.git", revision = "master" }
</code></pre>
</li>
</ul>
<h4>환경 마커 (Environment Markers)</h4>
<ul>
<li><strong>간단한 환경 마커:</strong>
<pre><code class="language-toml"># PEP 508 스타일
# aiohttp >= 3.6.1; python_version >= '3.8'
# PEP 633 스타일
aiohttp = { version = ">= 3.6.1", markers = "python_version >= '3.8'" }
</code></pre>
</li>
<li><strong>복합 환경 마커 (배열 사용):</strong>
<pre><code class="language-toml"># PEP 508 스타일
# aiohttp >= 3.6.1; python_version >= '3.8'
# aiohttp >= 3.0.0, &#x3C; 3.6.1; python_version &#x3C; '3.8'
# PEP 633 스타일
aiohttp = [
    { version = ">= 3.6.1", markers = "python_version >= '3.8'" },
    { version = ">= 3.0.0, &#x3C; 3.6.1", markers = "python_version &#x3C; '3.8'" }
]
</code></pre>
</li>
</ul>
<h4>패키지 Extras (Package Extras)</h4>
<ul>
<li><strong>패키지 extra에 대한 의존성 지정:</strong>
<pre><code class="language-toml"># PEP 508 스타일
# aiohttp >= 3.6.2; extra == 'http'
# PEP 633 스타일
aiohttp = { version = ">= 3.6.2", for-extra = "http" }
</code></pre>
</li>
<li><strong>의존성에서 extra 사용:</strong>
<pre><code class="language-toml"># PEP 508 스타일
# aiohttp [speedups] >= 3.6.2
# PEP 633 스타일
aiohttp = { version = ">= 3.6.2", extras = ["speedups"] }
</code></pre>
</li>
</ul>
<h4>복합 예시 (Complex Examples)</h4>
<p>다양한 요소를 결합한 복잡한 예시도 제시됩니다.</p>
<h3>거부된 아이디어 (Rejected Ideas)</h3>
<p>이 섹션에서는 PEP 633을 설계하는 과정에서 논의되었으나 최종적으로 채택되지 않은 아이디어들을 설명합니다.</p>
<ul>
<li><strong><code>dependencies</code>를 배열로 전환 (Switch to an array for dependencies):</strong> 각 요소가 이름 키를 가진 테이블이 되고 요구사항 테이블의 배열은 없는 형식으로 의존성을 배열로 사용하는 아이디어. 이는 TOML 형식에서 너무 장황하고 제한적이었으며, 주어진 배포판에 대해 여러 요구사항을 갖는 경우가 흔하지 않기 때문에 거부되었습니다.</li>
<li><strong><code>optional-dependencies</code>를 <code>extras</code>로 대체 (Replace optional-dependencies with extras):</strong> 요구사항에 <code>optional</code> 키를 포함하고, 프로젝트의 extra에 필요한 (선택적) 요구사항을 명시하는 <code>extras</code> 테이블을 사용하여 <code>optional-dependencies</code> 테이블을 제거하는 아이디어. 이는 같은 명세를 가진 테이블 수를 줄이고 요구사항을 한 번만 명시하여 여러 extras에서 사용할 수 있게 하지만, 요구사항의 일부 속성(어떤 extra에 속하는지)을 멀리하고, 필수 및 선택적 의존성을 함께 그룹화하며, 배포판에 여러 요구사항이 있을 때 요구사항을 선택하는 간단한 방법이 없을 수 있어 거부되었습니다. PEP 621 초안에서 <code>optional-dependencies</code>가 이미 사용되었기 때문에 거부되었습니다.</li>
<li><strong>요구사항 내 <code>direct</code> 테이블 (direct table in requirement):</strong> <code>direct-reference</code> 키를 <code>direct</code> 테이블에 포함하고, VCS를 <code>vcs</code> 키의 값으로 명시하는 아이디어. 이는 더 명시적이고 JSON Schema 유효성 검사에 포함하기 쉬웠지만, 너무 장황하고 가독성이 떨어진다고 판단되어 거부되었습니다.</li>
<li><strong>해시 포함 (Include hash):</strong> <code>direct-reference</code> 요구사항에 해시(hash)를 포함하는 아이디어. 이는 패키지 락 파일(lock-files)에만 해당되며, 프로젝트 메타데이터에는 적합하지 않다고 판단되었습니다.</li>
<li><strong>각 extra에 대한 의존성 테이블 (Dependency tables for each extra):</strong> <code>optional-dependencies</code>를 각 extra에 대한 의존성 테이블의 테이블로 만드는 아이디어 (테이블 이름이 extra 이름이 됨). 이는 <code>optional-dependencies</code>를 <code>dependencies</code>와 다른 유형으로 만들어 사용자에게 혼란을 주고 파싱하기 어렵게 만들 수 있어 거부되었습니다.</li>
<li><strong>환경 마커 키 (Environment marker keys):</strong> 각 PEP 508 환경 마커를 요구사항의 키(또는 하위 테이블 키)로 만드는 아이디어. 이는 가독성과 파싱 용이성을 높일 수 있었지만, 더 많은 설계가 필요하다는 이유로 보류되었습니다.</li>
<li><strong>하나의 요구사항이 충족할 수 있는 여러 extras (Multiple extras which one requirement can satisfy):</strong> <code>for-extra</code> 키를 <code>for-extras</code>로 바꾸고, 그 값을 요구사항이 충족하는 extras의 배열로 하는 아이디어. 이는 일부 중복을 줄이지만, 이 경우 중복은 어떤 extra가 어떤 의존성을 가지는지 명시적으로 보여주기 때문에 거부되었습니다.</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)에 공개되거나 CC0-1.0-Universal 라이선스(둘 중 더 자유로운 조건)에 따라 제공됩니다.
Source: https://github.com/python/peps/blob/main/peps/pep-0633.rst
Last modified: 2025-02-01 08:55:40 GMTI have browsed the content of PEP 0633. Now I need to translate and summarize it into Korean, following all the specified guidelines.</p>
<p>Here's my plan:</p>
<ol>
<li><strong>Rejection Notice</strong>: Translate this first as it's crucial for understanding the PEP's status.</li>
<li><strong>Abstract</strong>: Translate the core idea.</li>
<li><strong>Motivation</strong>: Translate the reasons for proposing this PEP.</li>
<li><strong>Rationale</strong>: Translate the background and influences.</li>
<li><strong>Specification</strong>:
<ul>
<li>Translate the <code>dependencies</code> section, including its format and value types.</li>
<li>Translate the <code>Requirement table</code> details (keys, types, constraints).</li>
<li>Translate the <code>optional-dependencies</code> section, including its format and value types, and the <code>for-extra</code> key.</li>
</ul>
</li>
<li><strong>Reference implementation</strong>: Briefly explain its purpose and include the Python code snippet.</li>
<li><strong>JSON Schema</strong>: Briefly explain its purpose. (No need to include the full schema text).</li>
<li><strong>Examples</strong>: Translate and show a few key examples from "Compatibility Examples" to illustrate how the TOML format compares to PEP 508 strings for various dependency types (Version, URL, VCS, Environment Markers, Package Extras).</li>
<li><strong>Rejected Ideas</strong>: Summarize the key rejected ideas and their reasons.</li>
<li><strong>Copyright</strong>: Translate the copyright notice.</li>
</ol>
<p>Throughout the translation, I will pay close attention to:</p>
<ul>
<li><strong>Professionalism and Terminology</strong>: Using Python-specific terms correctly (e.g., PEP, TOML, <code>pyproject.toml</code>, <code>dependencies</code>, <code>optional-dependencies</code>, <code>extras</code>, <code>environment markers</code>, <code>VCS</code>).</li>
<li><strong>Korean/English Blending</strong>: Using Korean where natural, keeping English for keywords/uncommon translations, or using both (e.g., <code>Generator (제너레이터)</code>). Keywords in code (<code>async</code>, <code>await</code>, <code>class</code>, <code>def</code>) and variable names are <strong>not</strong> to be translated.</li>
<li><strong>Readability</strong>: Using Markdown headers, lists, and code blocks effectively.</li>
<li><strong>Accuracy and Completeness</strong>: Ensuring no critical information is lost.</li>
<li><strong>Citations</strong>: Adding `` to every sentence that refers to the browsed content.</li>
</ul>
<p>Let's start the translation.</p>
<h4>복합 예시 (Complex Examples)</h4>
<p>다양한 요소를 결합한 복잡한 예시도 제시됩니다.</p>
<h3>거부된 아이디어 (Rejected Ideas)</h3>
<p>이 섹션에서는 PEP 633을 설계하는 과정에서 논의되었으나 최종적으로 채택되지 않은 아이디어들을 설명합니다.</p>
<ul>
<li><strong><code>dependencies</code>를 배열로 전환 (Switch to an array for dependencies):</strong> 각 요소가 이름 키를 가진 테이블이 되고 요구사항 테이블의 배열은 없는 형식으로 의존성을 배열로 사용하는 아이디어. 이는 TOML 형식에서 너무 장황하고 제한적이었으며, 주어진 배포판에 대해 여러 요구사항을 갖는 경우가 흔하지 않기 때문에 거부되었습니다.</li>
<li><strong><code>optional-dependencies</code>를 <code>extras</code>로 대체 (Replace optional-dependencies with extras):</strong> 요구사항에 <code>optional</code> 키를 포함하고, 프로젝트의 extra에 필요한 (선택적) 요구사항을 명시하는 <code>extras</code> 테이블을 사용하여 <code>optional-dependencies</code> 테이블을 제거하는 아이디어. 이는 같은 명세를 가진 테이블 수를 줄이고 요구사항을 한 번만 명시하여 여러 extras에서 사용할 수 있게 하지만, 요구사항의 일부 속성(어떤 extra에 속하는지)을 멀리하고, 필수 및 선택적 의존성을 함께 그룹화하며, 배포판에 여러 요구사항이 있을 때 요구사항을 선택하는 간단한 방법이 없을 수 있어 거부되었습니다. PEP 621 초안에서 <code>optional-dependencies</code>가 이미 사용되었기 때문에 거부되었습니다.</li>
<li><strong>요구사항 내 <code>direct</code> 테이블 (direct table in requirement):</strong> <code>direct-reference</code> 키를 <code>direct</code> 테이블에 포함하고, VCS를 <code>vcs</code> 키의 값으로 명시하는 아이디어. 이는 더 명시적이고 JSON Schema 유효성 검사에 포함하기 쉬웠지만, 너무 장황하고 가독성이 떨어진다고 판단되어 거부되었습니다.</li>
<li><strong>해시 포함 (Include hash):</strong> <code>direct-reference</code> 요구사항에 해시(hash)를 포함하는 아이디어. 이는 패키지 락 파일(lock-files)에만 해당되며, 프로젝트 메타데이터에는 적합하지 않다고 판단되었습니다.</li>
<li><strong>각 extra에 대한 의존성 테이블 (Dependency tables for each extra):</strong> <code>optional-dependencies</code>를 각 extra에 대한 의존성 테이블의 테이블로 만드는 아이디어 (테이블 이름이 extra 이름이 됨). 이는 <code>optional-dependencies</code>를 <code>dependencies</code>와 다른 유형으로 만들어 사용자에게 혼란을 주고 파싱하기 어렵게 만들 수 있어 거부되었습니다.</li>
<li><strong>환경 마커 키 (Environment marker keys):</strong> 각 PEP 508 환경 마커를 요구사항의 키(또는 하위 테이블 키)로 만드는 아이디어. 이는 가독성과 파싱 용이성을 높일 수 있었지만, 더 많은 설계가 필요하다는 이유로 보류되었습니다.</li>
<li><strong>하나의 요구사항이 충족할 수 있는 여러 extras (Multiple extras which one requirement can satisfy):</strong> <code>for-extra</code> 키를 <code>for-extras</code>로 바꾸고, 그 값을 요구사항이 충족하는 extras의 배열로 하는 아이디어. 이는 일부 중복을 줄이지만, 이 경우 중복은 어떤 extra가 어떤 의존성을 가지는지 명시적으로 보여주기 때문에 거부되었습니다.</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)에 공개되거나 CC0-1.0-Universal 라이선스(둘 중 더 자유로운 조건)에 따라 제공됩니다.
Source: https://github.com/python/peps/blob/main/peps/pep-0633.rst
Last modified: 2025-02-01 08:55:40 GMTI have browsed the content of PEP 0633. Now I need to translate and summarize it into Korean, following all the specified guidelines.</p>
<p>Here's my plan:</p>
<ol>
<li><strong>Rejection Notice</strong>: Translate this first as it's crucial for understanding the PEP's status.</li>
<li><strong>Abstract</strong>: Translate the core idea.</li>
<li><strong>Motivation</strong>: Translate the reasons for proposing this PEP.</li>
<li><strong>Rationale</strong>: Translate the background and influences.</li>
<li><strong>Specification</strong>:
<ul>
<li>Translate the <code>dependencies</code> section, including its format and value types.</li>
<li>Translate the <code>Requirement table</code> details (keys, types, constraints).</li>
<li>Translate the <code>optional-dependencies</code> section, including its format and value types, and the <code>for-extra</code> key.</li>
</ul>
</li>
<li><strong>Reference implementation</strong>: Briefly explain its purpose and include the Python code snippet.</li>
<li><strong>JSON Schema</strong>: Briefly explain its purpose. (No need to include the full schema text).</li>
<li><strong>Examples</strong>: Translate and show a few key examples from "Compatibility Examples" to illustrate how the TOML format compares to PEP 508 strings for various dependency types (Version, URL, VCS, Environment Markers, Package Extras).</li>
<li><strong>Rejected Ideas</strong>: Summarize the key rejected ideas and their reasons.</li>
<li><strong>Copyright</strong>: Translate the copyright notice.</li>
</ol>
<p>Throughout the translation, I will pay close attention to:</p>
<ul>
<li><strong>Professionalism and Terminology</strong>: Using Python-specific terms correctly (e.g., PEP, TOML, <code>pyproject.toml</code>, <code>dependencies</code>, <code>optional-dependencies</code>, <code>extras</code>, <code>environment markers</code>, <code>VCS</code>).</li>
<li><strong>Korean/English Blending</strong>: Using Korean where natural, keeping English for keywords/uncommon translations, or using both (e.g., <code>Generator (제너레이터)</code>). Keywords in code (<code>async</code>, <code>await</code>, <code>class</code>, <code>def</code>) and variable names are <strong>not</strong> to be translated.</li>
<li><strong>Readability</strong>: Using Markdown headers, lists, and code blocks effectively.</li>
<li><strong>Accuracy and Completeness</strong>: Ensuring no critical information is lost.</li>
<li><strong>Citations</strong>: Adding `` to every sentence that refers to the browsed content.</li>
</ul>
<p>Let's start the translation.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/633\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"SAPzS3zi9tsG5MkeKvxIA\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/633/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/633\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"633\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/633\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T65d7,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0633/\"\u003ePEP 633 - Dependency specification in pyproject.toml using an exploded TOML table\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 02-Sep-2020\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 633 – pyproject.toml에서 확장된 TOML 테이블을 사용한 의존성 명세 (Dependency specification in pyproject.toml using an exploded TOML table)\u003c/h1\u003e\n\u003ch2\u003e거부 통지 (Rejection Notice)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 PEP 631의 인기도, 기존 PEP 508 문자열 사용과의 일관성, 그리고 기존 패키징 도구 모음과의 호환성으로 인해 \u003cstrong\u003ePEP 631을 지지하며 거부되었습니다.\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP 633은 PEP 621에 정의된 필드를 사용하여 \u003ccode\u003epyproject.toml\u003c/code\u003e 파일에 프로젝트의 의존성(dependencies)을 정의하는 방법을 명세합니다. 이는 PEP 631에서 정의된 PEP 508 기반의 접근 방식에 대한 대안으로 제안되었습니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePEP 508 문자열 대신 TOML 테이블 및 기타 데이터 타입을 사용하여 요구사항(requirements)을 표현하는 데는 여러 이점이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e쉬운 초기 유효성 검사:\u003c/strong\u003e TOML 구문을 통해 쉽게 초기 유효성 검사를 수행할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e스키마를 통한 쉬운 보조 유효성 검사:\u003c/strong\u003e 예를 들어 JSON Schema와 같은 스키마를 사용하여 추가적인 유효성 검사를 할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e사용자 편의성:\u003c/strong\u003e 사용자가 구문을 암기할 필요 없이 특정 기능의 키를 추측할 가능성이 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e다른 언어 사용자 친숙도:\u003c/strong\u003e 다른 인기 있는 여러 언어의 사용자들은 이미 TOML 구문에 익숙할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e데이터 구조 이해:\u003c/strong\u003e TOML은 JSON과 동일한 데이터 구조를 직접적으로 표현하며, 파이썬 리터럴(literals)의 부분 집합을 나타내므로 사용자가 계층 구조와 값의 유형을 이해하기 쉽습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e이론적 근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e이 PEP의 대부분은 PEP 621의 의존성 주제에 대한 논의에서 비롯되었습니다. Pipfile, Poetry, Dart의 의존성 관리 및 Rust의 Cargo에서 영감을 받았습니다. 이 형식과 PEP 508 스타일 명세자 간의 장단점을 비교한 문서도 존재합니다.\u003c/p\u003e\n\u003cp\u003e동일한 배포 이름에 대해 여러 요구사항을 명세할 때 (환경 마커(environment markers)가 적절한 의존성을 선택하는 경우), Poetry와 유사하게 요구사항 배열을 허용하는 방식이 채택되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edirect-reference\u003c/code\u003e 키는 패키징 생태계의 차이를 줄이고 기존 명세 작업을 활용하기 위해 PEP 610 및 PEP 440과 밀접하게 일치하고 이를 활용합니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003cp\u003ePEP 621과 마찬가지로, 메타데이터가 부적절하게 명세된 경우 도구는 에러를 발생시켜야 합니다. 메타데이터는 TOML 명세를 따라야 합니다.\u003c/p\u003e\n\u003cp\u003e이 문서는 의존성 명세를 위한 명세서이므로 혼란을 줄이기 위해 \"requirement\"라는 단어는 PEP 508 의존성 명세를 의미하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003ePEP 621에 명세된 \u003ccode\u003eproject\u003c/code\u003e 테이블에 다음 테이블이 추가됩니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003edependencies\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e형식:\u003c/strong\u003e \u003ccode\u003etable\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e이 테이블 내부의 키는 필요한 배포판의 이름입니다. 값은 다음 유형 중 하나를 가질 수 있습니다.\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003estring\u003c/code\u003e\u003c/strong\u003e: 요구사항이 오직 버전 요구사항에 의해 정의되며, 요구사항 테이블의 버전 명세와 동일합니다. 단, 버전 제한을 두지 않음을 나타내는 빈 문자열 \u003ccode\u003e\"\"\u003c/code\u003e을 허용합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003etable\u003c/code\u003e\u003c/strong\u003e: 요구사항 테이블입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003earray\u003c/code\u003e\u003c/strong\u003e: 요구사항 테이블의 배열입니다. 비워 있는 \u003ccode\u003e[]\u003c/code\u003e 배열을 값으로 지정하는 것은 에러입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e요구사항 테이블 (Requirement table)\u003c/h3\u003e\n\u003cp\u003e요구사항 테이블의 키는 다음과 같습니다 (모두 선택 사항입니다).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eversion\u003c/code\u003e (string):\u003c/strong\u003e PEP 440 버전 명세자이며, 쉼표로 구분된 버전 명세 절(clauses) 목록입니다. 이 문자열은 비워 있을 수 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eextras\u003c/code\u003e (array of strings):\u003c/strong\u003e 배포판에 대한 PEP 508 \u003ccode\u003eextras\u003c/code\u003e 선언 목록입니다. 이 목록은 비워 있을 수 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003emarkers\u003c/code\u003e (string):\u003c/strong\u003e PEP 508 환경 마커(environment marker) 표현식입니다. 이 문자열은 비워 있을 수 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eurl\u003c/code\u003e (string):\u003c/strong\u003e 요구사항을 충족하기 위해 설치할 아티팩트(artifact)의 URL입니다. \u003ccode\u003efile://\u003c/code\u003e은 로컬 파일 시스템에서 패키지를 검색하는 데 사용되는 접두사입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003egit\u003c/code\u003e, \u003ccode\u003ehg\u003c/code\u003e, \u003ccode\u003ebzr\u003c/code\u003e 또는 \u003ccode\u003esvn\u003c/code\u003e (string):\u003c/strong\u003e 클론(clone)할 VCS 저장소(PEP 440에 명시됨)의 URL입니다. 해당 저장소의 트리는 요구사항을 충족하기 위해 설치됩니다. 추가 VCS 키는 PEP 610의 수정 사항을 통해 추가될 예정이며, 도구는 수정 사항이 승인되기 전에 명령줄 명령을 사용하여 다른 VCS를 지원하도록 선택할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003erevision\u003c/code\u003e (string):\u003c/strong\u003e 설치 전에 체크아웃(check-out)할 지정된 VCS 저장소의 특정 리비전(revision) 식별자입니다. 사용자는 \u003ccode\u003egit\u003c/code\u003e, \u003ccode\u003ehg\u003c/code\u003e, \u003ccode\u003ebzr\u003c/code\u003e, \u003ccode\u003esvn\u003c/code\u003e 또는 다른 VCS 키 중 하나가 설치할 배포판을 식별하는 데 사용될 때만 이를 제공해야 합니다. 리비전 식별자는 PEP 610에 제안되어 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eversion\u003c/code\u003e, \u003ccode\u003eurl\u003c/code\u003e, \u003ccode\u003egit\u003c/code\u003e, \u003ccode\u003ehg\u003c/code\u003e, \u003ccode\u003ebzr\u003c/code\u003e, \u003ccode\u003esvn\u003c/code\u003e 및 기타 VCS 키는 논리적으로 서로 충돌하므로 동시에 최대 하나만 지정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e빈 요구사항 테이블 \u003ccode\u003e{}\u003c/code\u003e은 빈 문자열 \u003ccode\u003e\"\"\u003c/code\u003e 외에 요구사항에 대한 제한을 두지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 문서에 명시되지 않은 키가 제공되면 파싱(parsing) 시 에러가 발생해야 합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eoptional-dependencies\u003c/code\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e형식:\u003c/strong\u003e \u003ccode\u003etable\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e이 테이블 내부의 키는 extra에 필요한 배포판의 이름입니다. 값은 다음 유형 중 하나를 가질 수 있습니다.\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003etable\u003c/code\u003e\u003c/strong\u003e: 요구사항 테이블입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003earray\u003c/code\u003e\u003c/strong\u003e: 요구사항 테이블의 배열입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 요구사항 테이블은 위에 명시된 것과 동일한 명세를 가지며, 다음 필수 키가 추가됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003efor-extra\u003c/code\u003e (string):\u003c/strong\u003e 이 요구사항이 필요한 PEP 508 extra의 이름입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e참조 구현 (Reference implementation)\u003c/h3\u003e\n\u003cp\u003e도구는 이 형식을 PEP 508 요구사항 문자열로 변환해야 합니다. 아래는 해당 변환의 예시 구현입니다 (유효성 검사가 이미 수행되었다고 가정합니다).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef convert_requirement_to_pep508(name, requirement):\r\n    if isinstance(requirement, str):\r\n        requirement = {\"version\": requirement}\r\n    pep508 = name\r\n    if \"extras\" in requirement:\r\n        pep508 += \" [\" + \", \".join(requirement[\"extras\"]) + \"]\"\r\n    if \"version\" in requirement:\r\n        pep508 += \" \" + requirement[\"version\"]\r\n    if \"url\" in requirement:\r\n        pep508 += \" @ \" + requirement[\"url\"]\r\n    for vcs in (\"git\", \"hg\", \"bzr\", \"svn\"):\r\n        if vcs in requirement:\r\n            pep508 += \" @ \" + vcs + \"+\" + requirement[vcs]\r\n            if \"revision\" in requirement:\r\n                pep508 += \"@\" + requirement[\"revision\"]\r\n    extra = None\r\n    if \"for-extra\" in requirement:\r\n        extra = requirement[\"for-extra\"]\r\n    if \"markers\" in requirement:\r\n        markers = requirement[\"markers\"]\r\n        if extra:\r\n            markers = \"extra = '\" + extra + \"' and (\" + markers + \")\"\r\n        pep508 += \"; \" + markers\r\n    return pep508, extra\r\n\r\ndef convert_requirements_to_pep508(dependencies):\r\n    pep508s = []\r\n    extras = set()\r\n    for name, req in dependencies.items():\r\n        if isinstance(req, list):\r\n            for sub_req in req:\r\n                pep508, extra = convert_requirement_to_pep508(name, sub_req)\r\n                pep508s.append(pep508)\r\n                if extra:\r\n                    extras.add(extra)\r\n        else:\r\n            pep508, extra = convert_requirement_to_pep508(name, req)\r\n            pep508s.append(pep508)\r\n            if extra:\r\n                extras.add(extra)\r\n    return pep508s, extras\r\n\r\ndef convert_project_requirements_to_pep508(project):\r\n    reqs, _ = convert_requirements_to_pep508(project.get(\"dependencies\", {}))\r\n    optional_reqs, extras = convert_requirements_to_pep508(\r\n        project.get(\"optional-dependencies\", {})\r\n    )\r\n    reqs += optional_reqs\r\n    return reqs, extras\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eJSON Schema\u003c/h3\u003e\n\u003cp\u003e초기 유효성 검사를 위해 JSON Schema를 사용할 수 있습니다. 이는 도구가 일관된 유효성 검사를 수행하는 데 도움이 될 뿐만 아니라, 코드 편집기가 사용자가 의존성 목록을 작성하는 동안 유효성 검사 오류를 강조 표시할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e(JSON Schema의 전체 내용은 생략합니다. 원문 PEP 633에서 확인할 수 있습니다.)\u003c/p\u003e\n\u003ch3\u003e예시 (Examples)\u003c/h3\u003e\n\u003cp\u003ePEP 633이 \u003ccode\u003epyproject.toml\u003c/code\u003e에서 의존성을 어떻게 정의하는지에 대한 다양한 예시가 제공됩니다.\u003c/p\u003e\n\u003ch4\u003e버전 제약이 있는 의존성 (Version Constrained Dependencies)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e버전 제약 없음:\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e# PEP 508 스타일\r\n# aiohttp\r\n# PEP 633 스타일\r\naiohttp = {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e간단한 버전 제약:\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e# PEP 508 스타일\r\n# aiohttp \u003e= 3.6.2, \u0026#x3C; 4.0.0\r\n# PEP 633 스타일\r\naiohttp = { version = \"\u003e= 3.6.2, \u0026#x3C; 4.0.0\" }\r\n# 간결하게 문자열로도 표현 가능\r\n# aiohttp = \"\u003e= 3.6.2, \u0026#x3C; 4.0.0\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e직접 참조 의존성 (Direct Reference Dependencies)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eURL 의존성:\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e# PEP 508 스타일\r\n# aiohttp @ https://files.pythonhosted.org/packages/.../aiohttp-3.6.2-cp35-cp35m-macosx_10_13_x86_64.whl\r\n# PEP 633 스타일\r\naiohttp = { url = \"https://files.pythonhosted.org/packages/.../aiohttp-3.6.2-cp35-cp35m-macosx_10_13_x86_64.whl\" }\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVCS 의존성 (Git):\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e# PEP 508 스타일\r\n# aiohttp @ git+ssh://git@github.com/aio-libs/aiohttp.git@master\r\n# PEP 633 스타일\r\naiohttp = { git = \"ssh://git@github.com/aio-libs/aiohttp.git\", revision = \"master\" }\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e환경 마커 (Environment Markers)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e간단한 환경 마커:\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e# PEP 508 스타일\r\n# aiohttp \u003e= 3.6.1; python_version \u003e= '3.8'\r\n# PEP 633 스타일\r\naiohttp = { version = \"\u003e= 3.6.1\", markers = \"python_version \u003e= '3.8'\" }\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e복합 환경 마커 (배열 사용):\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e# PEP 508 스타일\r\n# aiohttp \u003e= 3.6.1; python_version \u003e= '3.8'\r\n# aiohttp \u003e= 3.0.0, \u0026#x3C; 3.6.1; python_version \u0026#x3C; '3.8'\r\n# PEP 633 스타일\r\naiohttp = [\r\n    { version = \"\u003e= 3.6.1\", markers = \"python_version \u003e= '3.8'\" },\r\n    { version = \"\u003e= 3.0.0, \u0026#x3C; 3.6.1\", markers = \"python_version \u0026#x3C; '3.8'\" }\r\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e패키지 Extras (Package Extras)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e패키지 extra에 대한 의존성 지정:\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e# PEP 508 스타일\r\n# aiohttp \u003e= 3.6.2; extra == 'http'\r\n# PEP 633 스타일\r\naiohttp = { version = \"\u003e= 3.6.2\", for-extra = \"http\" }\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e의존성에서 extra 사용:\u003c/strong\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e# PEP 508 스타일\r\n# aiohttp [speedups] \u003e= 3.6.2\r\n# PEP 633 스타일\r\naiohttp = { version = \"\u003e= 3.6.2\", extras = [\"speedups\"] }\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e복합 예시 (Complex Examples)\u003c/h4\u003e\n\u003cp\u003e다양한 요소를 결합한 복잡한 예시도 제시됩니다.\u003c/p\u003e\n\u003ch3\u003e거부된 아이디어 (Rejected Ideas)\u003c/h3\u003e\n\u003cp\u003e이 섹션에서는 PEP 633을 설계하는 과정에서 논의되었으나 최종적으로 채택되지 않은 아이디어들을 설명합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003edependencies\u003c/code\u003e를 배열로 전환 (Switch to an array for dependencies):\u003c/strong\u003e 각 요소가 이름 키를 가진 테이블이 되고 요구사항 테이블의 배열은 없는 형식으로 의존성을 배열로 사용하는 아이디어. 이는 TOML 형식에서 너무 장황하고 제한적이었으며, 주어진 배포판에 대해 여러 요구사항을 갖는 경우가 흔하지 않기 때문에 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eoptional-dependencies\u003c/code\u003e를 \u003ccode\u003eextras\u003c/code\u003e로 대체 (Replace optional-dependencies with extras):\u003c/strong\u003e 요구사항에 \u003ccode\u003eoptional\u003c/code\u003e 키를 포함하고, 프로젝트의 extra에 필요한 (선택적) 요구사항을 명시하는 \u003ccode\u003eextras\u003c/code\u003e 테이블을 사용하여 \u003ccode\u003eoptional-dependencies\u003c/code\u003e 테이블을 제거하는 아이디어. 이는 같은 명세를 가진 테이블 수를 줄이고 요구사항을 한 번만 명시하여 여러 extras에서 사용할 수 있게 하지만, 요구사항의 일부 속성(어떤 extra에 속하는지)을 멀리하고, 필수 및 선택적 의존성을 함께 그룹화하며, 배포판에 여러 요구사항이 있을 때 요구사항을 선택하는 간단한 방법이 없을 수 있어 거부되었습니다. PEP 621 초안에서 \u003ccode\u003eoptional-dependencies\u003c/code\u003e가 이미 사용되었기 때문에 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e요구사항 내 \u003ccode\u003edirect\u003c/code\u003e 테이블 (direct table in requirement):\u003c/strong\u003e \u003ccode\u003edirect-reference\u003c/code\u003e 키를 \u003ccode\u003edirect\u003c/code\u003e 테이블에 포함하고, VCS를 \u003ccode\u003evcs\u003c/code\u003e 키의 값으로 명시하는 아이디어. 이는 더 명시적이고 JSON Schema 유효성 검사에 포함하기 쉬웠지만, 너무 장황하고 가독성이 떨어진다고 판단되어 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e해시 포함 (Include hash):\u003c/strong\u003e \u003ccode\u003edirect-reference\u003c/code\u003e 요구사항에 해시(hash)를 포함하는 아이디어. 이는 패키지 락 파일(lock-files)에만 해당되며, 프로젝트 메타데이터에는 적합하지 않다고 판단되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e각 extra에 대한 의존성 테이블 (Dependency tables for each extra):\u003c/strong\u003e \u003ccode\u003eoptional-dependencies\u003c/code\u003e를 각 extra에 대한 의존성 테이블의 테이블로 만드는 아이디어 (테이블 이름이 extra 이름이 됨). 이는 \u003ccode\u003eoptional-dependencies\u003c/code\u003e를 \u003ccode\u003edependencies\u003c/code\u003e와 다른 유형으로 만들어 사용자에게 혼란을 주고 파싱하기 어렵게 만들 수 있어 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e환경 마커 키 (Environment marker keys):\u003c/strong\u003e 각 PEP 508 환경 마커를 요구사항의 키(또는 하위 테이블 키)로 만드는 아이디어. 이는 가독성과 파싱 용이성을 높일 수 있었지만, 더 많은 설계가 필요하다는 이유로 보류되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e하나의 요구사항이 충족할 수 있는 여러 extras (Multiple extras which one requirement can satisfy):\u003c/strong\u003e \u003ccode\u003efor-extra\u003c/code\u003e 키를 \u003ccode\u003efor-extras\u003c/code\u003e로 바꾸고, 그 값을 요구사항이 충족하는 extras의 배열로 하는 아이디어. 이는 일부 중복을 줄이지만, 이 경우 중복은 어떤 extra가 어떤 의존성을 가지는지 명시적으로 보여주기 때문에 거부되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 공개되거나 CC0-1.0-Universal 라이선스(둘 중 더 자유로운 조건)에 따라 제공됩니다.\r\nSource: https://github.com/python/peps/blob/main/peps/pep-0633.rst\r\nLast modified: 2025-02-01 08:55:40 GMTI have browsed the content of PEP 0633. Now I need to translate and summarize it into Korean, following all the specified guidelines.\u003c/p\u003e\n\u003cp\u003eHere's my plan:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eRejection Notice\u003c/strong\u003e: Translate this first as it's crucial for understanding the PEP's status.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAbstract\u003c/strong\u003e: Translate the core idea.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMotivation\u003c/strong\u003e: Translate the reasons for proposing this PEP.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRationale\u003c/strong\u003e: Translate the background and influences.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSpecification\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003eTranslate the \u003ccode\u003edependencies\u003c/code\u003e section, including its format and value types.\u003c/li\u003e\n\u003cli\u003eTranslate the \u003ccode\u003eRequirement table\u003c/code\u003e details (keys, types, constraints).\u003c/li\u003e\n\u003cli\u003eTranslate the \u003ccode\u003eoptional-dependencies\u003c/code\u003e section, including its format and value types, and the \u003ccode\u003efor-extra\u003c/code\u003e key.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReference implementation\u003c/strong\u003e: Briefly explain its purpose and include the Python code snippet.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eJSON Schema\u003c/strong\u003e: Briefly explain its purpose. (No need to include the full schema text).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExamples\u003c/strong\u003e: Translate and show a few key examples from \"Compatibility Examples\" to illustrate how the TOML format compares to PEP 508 strings for various dependency types (Version, URL, VCS, Environment Markers, Package Extras).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRejected Ideas\u003c/strong\u003e: Summarize the key rejected ideas and their reasons.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCopyright\u003c/strong\u003e: Translate the copyright notice.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThroughout the translation, I will pay close attention to:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eProfessionalism and Terminology\u003c/strong\u003e: Using Python-specific terms correctly (e.g., PEP, TOML, \u003ccode\u003epyproject.toml\u003c/code\u003e, \u003ccode\u003edependencies\u003c/code\u003e, \u003ccode\u003eoptional-dependencies\u003c/code\u003e, \u003ccode\u003eextras\u003c/code\u003e, \u003ccode\u003eenvironment markers\u003c/code\u003e, \u003ccode\u003eVCS\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKorean/English Blending\u003c/strong\u003e: Using Korean where natural, keeping English for keywords/uncommon translations, or using both (e.g., \u003ccode\u003eGenerator (제너레이터)\u003c/code\u003e). Keywords in code (\u003ccode\u003easync\u003c/code\u003e, \u003ccode\u003eawait\u003c/code\u003e, \u003ccode\u003eclass\u003c/code\u003e, \u003ccode\u003edef\u003c/code\u003e) and variable names are \u003cstrong\u003enot\u003c/strong\u003e to be translated.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReadability\u003c/strong\u003e: Using Markdown headers, lists, and code blocks effectively.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAccuracy and Completeness\u003c/strong\u003e: Ensuring no critical information is lost.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCitations\u003c/strong\u003e: Adding `` to every sentence that refers to the browsed content.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet's start the translation.\u003c/p\u003e\n\u003ch4\u003e복합 예시 (Complex Examples)\u003c/h4\u003e\n\u003cp\u003e다양한 요소를 결합한 복잡한 예시도 제시됩니다.\u003c/p\u003e\n\u003ch3\u003e거부된 아이디어 (Rejected Ideas)\u003c/h3\u003e\n\u003cp\u003e이 섹션에서는 PEP 633을 설계하는 과정에서 논의되었으나 최종적으로 채택되지 않은 아이디어들을 설명합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003edependencies\u003c/code\u003e를 배열로 전환 (Switch to an array for dependencies):\u003c/strong\u003e 각 요소가 이름 키를 가진 테이블이 되고 요구사항 테이블의 배열은 없는 형식으로 의존성을 배열로 사용하는 아이디어. 이는 TOML 형식에서 너무 장황하고 제한적이었으며, 주어진 배포판에 대해 여러 요구사항을 갖는 경우가 흔하지 않기 때문에 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eoptional-dependencies\u003c/code\u003e를 \u003ccode\u003eextras\u003c/code\u003e로 대체 (Replace optional-dependencies with extras):\u003c/strong\u003e 요구사항에 \u003ccode\u003eoptional\u003c/code\u003e 키를 포함하고, 프로젝트의 extra에 필요한 (선택적) 요구사항을 명시하는 \u003ccode\u003eextras\u003c/code\u003e 테이블을 사용하여 \u003ccode\u003eoptional-dependencies\u003c/code\u003e 테이블을 제거하는 아이디어. 이는 같은 명세를 가진 테이블 수를 줄이고 요구사항을 한 번만 명시하여 여러 extras에서 사용할 수 있게 하지만, 요구사항의 일부 속성(어떤 extra에 속하는지)을 멀리하고, 필수 및 선택적 의존성을 함께 그룹화하며, 배포판에 여러 요구사항이 있을 때 요구사항을 선택하는 간단한 방법이 없을 수 있어 거부되었습니다. PEP 621 초안에서 \u003ccode\u003eoptional-dependencies\u003c/code\u003e가 이미 사용되었기 때문에 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e요구사항 내 \u003ccode\u003edirect\u003c/code\u003e 테이블 (direct table in requirement):\u003c/strong\u003e \u003ccode\u003edirect-reference\u003c/code\u003e 키를 \u003ccode\u003edirect\u003c/code\u003e 테이블에 포함하고, VCS를 \u003ccode\u003evcs\u003c/code\u003e 키의 값으로 명시하는 아이디어. 이는 더 명시적이고 JSON Schema 유효성 검사에 포함하기 쉬웠지만, 너무 장황하고 가독성이 떨어진다고 판단되어 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e해시 포함 (Include hash):\u003c/strong\u003e \u003ccode\u003edirect-reference\u003c/code\u003e 요구사항에 해시(hash)를 포함하는 아이디어. 이는 패키지 락 파일(lock-files)에만 해당되며, 프로젝트 메타데이터에는 적합하지 않다고 판단되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e각 extra에 대한 의존성 테이블 (Dependency tables for each extra):\u003c/strong\u003e \u003ccode\u003eoptional-dependencies\u003c/code\u003e를 각 extra에 대한 의존성 테이블의 테이블로 만드는 아이디어 (테이블 이름이 extra 이름이 됨). 이는 \u003ccode\u003eoptional-dependencies\u003c/code\u003e를 \u003ccode\u003edependencies\u003c/code\u003e와 다른 유형으로 만들어 사용자에게 혼란을 주고 파싱하기 어렵게 만들 수 있어 거부되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e환경 마커 키 (Environment marker keys):\u003c/strong\u003e 각 PEP 508 환경 마커를 요구사항의 키(또는 하위 테이블 키)로 만드는 아이디어. 이는 가독성과 파싱 용이성을 높일 수 있었지만, 더 많은 설계가 필요하다는 이유로 보류되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e하나의 요구사항이 충족할 수 있는 여러 extras (Multiple extras which one requirement can satisfy):\u003c/strong\u003e \u003ccode\u003efor-extra\u003c/code\u003e 키를 \u003ccode\u003efor-extras\u003c/code\u003e로 바꾸고, 그 값을 요구사항이 충족하는 extras의 배열로 하는 아이디어. 이는 일부 중복을 줄이지만, 이 경우 중복은 어떤 extra가 어떤 의존성을 가지는지 명시적으로 보여주기 때문에 거부되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 공개되거나 CC0-1.0-Universal 라이선스(둘 중 더 자유로운 조건)에 따라 제공됩니다.\r\nSource: https://github.com/python/peps/blob/main/peps/pep-0633.rst\r\nLast modified: 2025-02-01 08:55:40 GMTI have browsed the content of PEP 0633. Now I need to translate and summarize it into Korean, following all the specified guidelines.\u003c/p\u003e\n\u003cp\u003eHere's my plan:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eRejection Notice\u003c/strong\u003e: Translate this first as it's crucial for understanding the PEP's status.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAbstract\u003c/strong\u003e: Translate the core idea.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMotivation\u003c/strong\u003e: Translate the reasons for proposing this PEP.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRationale\u003c/strong\u003e: Translate the background and influences.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSpecification\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003eTranslate the \u003ccode\u003edependencies\u003c/code\u003e section, including its format and value types.\u003c/li\u003e\n\u003cli\u003eTranslate the \u003ccode\u003eRequirement table\u003c/code\u003e details (keys, types, constraints).\u003c/li\u003e\n\u003cli\u003eTranslate the \u003ccode\u003eoptional-dependencies\u003c/code\u003e section, including its format and value types, and the \u003ccode\u003efor-extra\u003c/code\u003e key.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReference implementation\u003c/strong\u003e: Briefly explain its purpose and include the Python code snippet.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eJSON Schema\u003c/strong\u003e: Briefly explain its purpose. (No need to include the full schema text).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExamples\u003c/strong\u003e: Translate and show a few key examples from \"Compatibility Examples\" to illustrate how the TOML format compares to PEP 508 strings for various dependency types (Version, URL, VCS, Environment Markers, Package Extras).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRejected Ideas\u003c/strong\u003e: Summarize the key rejected ideas and their reasons.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCopyright\u003c/strong\u003e: Translate the copyright notice.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThroughout the translation, I will pay close attention to:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eProfessionalism and Terminology\u003c/strong\u003e: Using Python-specific terms correctly (e.g., PEP, TOML, \u003ccode\u003epyproject.toml\u003c/code\u003e, \u003ccode\u003edependencies\u003c/code\u003e, \u003ccode\u003eoptional-dependencies\u003c/code\u003e, \u003ccode\u003eextras\u003c/code\u003e, \u003ccode\u003eenvironment markers\u003c/code\u003e, \u003ccode\u003eVCS\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKorean/English Blending\u003c/strong\u003e: Using Korean where natural, keeping English for keywords/uncommon translations, or using both (e.g., \u003ccode\u003eGenerator (제너레이터)\u003c/code\u003e). Keywords in code (\u003ccode\u003easync\u003c/code\u003e, \u003ccode\u003eawait\u003c/code\u003e, \u003ccode\u003eclass\u003c/code\u003e, \u003ccode\u003edef\u003c/code\u003e) and variable names are \u003cstrong\u003enot\u003c/strong\u003e to be translated.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReadability\u003c/strong\u003e: Using Markdown headers, lists, and code blocks effectively.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAccuracy and Completeness\u003c/strong\u003e: Ensuring no critical information is lost.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCitations\u003c/strong\u003e: Adding `` to every sentence that refers to the browsed content.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet's start the translation.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 633 - Dependency specification in pyproject.toml using an exploded TOML table\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 01:25:08+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>