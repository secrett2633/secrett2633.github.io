<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-19cfc001fdac3337.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1098<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 688 - Making the buffer protocol accessible in Python</h1><div class="page__meta"><time dateTime="2025-09-27 10:13:02+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0688/">PEP 688 - Making the buffer protocol accessible in Python</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 23-Apr-2022</p>
</blockquote>
<h2>PEP 688 – Python에서 버퍼 프로토콜 접근성 확보</h2>
<h3>초록 (Abstract)</h3>
<p>이 PEP는 현재 C 코드에서만 접근 가능한 버퍼 프로토콜(buffer protocol)에 대해 Python 레벨 API를 제안합니다. 이를 통해 타입 체커(type checker)가 객체가 프로토콜을 구현하는지 여부를 평가할 수 있게 됩니다.</p>
<h3>동기 (Motivation)</h3>
<p>CPython C API는 객체의 기본 메모리에 접근하기 위한 다용도 메커니즘인 버퍼 프로토콜을 제공합니다. 이 프로토콜은 PEP 3118에서 도입되었으며, 이진 데이터를 받아들이는 함수는 일반적으로 버퍼 프로토콜을 구현하는 모든 객체를 처리하도록 작성됩니다. 현재 Python 코드에서는 객체가 버퍼 프로토콜을 지원하는지 여부를 검사할 방법이 없습니다. 또한, 정적 타입 시스템(static type system)은 이 프로토콜을 나타내는 타입 어노테이션(type annotation)을 제공하지 않아, 제네릭 버퍼를 허용하는 코드의 타입 어노테이션을 작성할 때 문제가 발생했습니다.</p>
<p>유사하게, Python으로 작성된 클래스가 버퍼 프로토콜을 지원하는 것은 불가능했습니다. Python에서 버퍼 클래스를 만들 수 있다면 사용자는 C 버퍼 객체를 쉽게 래핑(wrap)하거나, 버퍼 프로토콜을 사용하는 API의 동작을 테스트할 수 있을 것입니다.</p>
<h3>합리적 근거 (Rationale)</h3>
<h4>현재의 대안 (Current options)</h4>
<p>타입 시스템에서 버퍼 타입을 어노테이션하기 위한 두 가지 알려진 방법이 있었지만, 둘 다 적절하지 않았습니다.</p>
<ol>
<li><strong>typeshed의 타입 별칭(type alias):</strong> <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code>, <code>array.array</code>와 같은 표준 라이브러리의 잘 알려진 버퍼 타입을 나열하는 방식입니다. 이 방법은 표준 라이브러리에는 작동하지만, 서드 파티 버퍼 타입에는 적용되지 않습니다.</li>
<li><strong><code>typing.ByteString</code> 문서:</strong> <code>bytes</code>를 <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code> 타입의 시퀀스를 나타내는 약어로 사용할 수 있다고 명시되어 있습니다. 그러나 이 사용법은 어떤 타이핑 PEP에서도 명시되지 않았고, 모든 가능한 버퍼 타입을 포함하지 않으며, 타입 어노테이션에서 <code>bytes</code> 타입을 모호하게 만듭니다. 예를 들어, <code>bytes</code> 객체에는 유효하지만 <code>memoryview</code> 객체에는 유효하지 않은 많은 연산이 있으며, 함수가 <code>bytes</code>는 허용하지만 <code>memoryview</code>는 허용하지 않는 경우가 있을 수 있습니다.</li>
</ol>
<h4>버퍼의 종류 (Kinds of buffers)</h4>
<p>C 버퍼 프로토콜은 스트라이드(stride), 연속성(contiguity), 쓰기 지원 등 여러 옵션을 지원합니다. 이 중 일부는 타입 시스템에서 유용할 수 있지만, C 버퍼 프로토콜에서는 대부분의 옵션을 타입 객체에서 직접 쿼리할 수 없습니다. 특정 플래그를 지원하는지 여부를 파악하는 유일한 방법은 실제로 버퍼를 요청하는 것이며, <code>memoryview</code>와 같은 일부 타입의 경우 지원되는 플래그가 인스턴스에 따라 달라집니다. 결과적으로 타입 시스템에서 이러한 플래그 지원을 표현하기는 어렵습니다.</p>
<h3>명세 (Specification)</h3>
<h4>Python 레벨 버퍼 프로토콜 (Python-level buffer protocol)</h4>
<p>PEP 688은 <code>__buffer__</code>와 <code>__release_buffer__</code>라는 두 가지 Python 레벨 특수 메서드를 추가할 것을 제안합니다. 이 메서드를 구현하는 Python 클래스는 C 코드에서 버퍼로 사용될 수 있으며, 반대로 C로 구현된 버퍼 프로토콜을 지원하는 클래스는 Python 코드에서 접근 가능한 합성 메서드(synthesized methods)를 얻게 됩니다.</p>
<ul>
<li><strong><code>__buffer__(self, flags: int, /) -> memoryview</code></strong>: 이 메서드는 <code>memoryview()</code> 생성자와 같이 Python 객체에서 버퍼를 생성하기 위해 호출됩니다. C의 <code>bf_getbuffer</code> 슬롯에 해당하며, <code>memoryview</code> 객체를 반환해야 합니다.</li>
<li><strong><code>__release_buffer__(self, buffer: memoryview, /) -> None</code></strong>: 이 메서드는 <code>__buffer__</code>에 의해 반환된 버퍼가 더 이상 필요 없을 때 호출되어야 합니다. C의 <code>bf_releasebuffer</code> 슬롯에 해당하며, 버퍼 프로토콜의 선택적 부분입니다. <code>__buffer__</code>를 직접 호출하는 Python 코드는 버퍼 사용이 끝나면 동일한 객체에 대해 <code>__release_buffer__</code>를 호출해야 합니다.</li>
</ul>
<h4><code>inspect.BufferFlags</code></h4>
<p><code>__buffer__</code> 구현을 돕기 위해 <code>enum.IntFlag</code>의 서브클래스인 <code>inspect.BufferFlags</code>가 추가됩니다. 이 열거형(enum)은 C 버퍼 프로토콜에 정의된 모든 플래그를 포함합니다.</p>
<h4><code>collections.abc.Buffer</code></h4>
<p>새로운 추상 베이스 클래스(Abstract Base Class, ABC)인 <code>collections.abc.Buffer</code>가 추가되며, 이는 <code>__buffer__</code> 메서드를 요구합니다. 이 클래스는 주로 타입 어노테이션에 사용됩니다.</p>
<pre><code class="language-python">from collections.abc import Buffer

def need_buffer(b: Buffer) -> memoryview:
    return memoryview(b)

need_buffer(b"xy") # ok
need_buffer("xy") # 정적 타입 체커에 의해 거부됨 (rejected by static type checkers)
</code></pre>
<p>또한, <code>isinstance</code> 및 <code>issubclass</code> 검사에도 사용할 수 있습니다.</p>
<pre><code class="language-python">from collections.abc import Buffer
isinstance(b"xy", Buffer) # True
issubclass(bytes, Buffer) # True
issubclass(memoryview, Buffer) # True
isinstance("xy", Buffer) # False
issubclass(str, Buffer) # False
</code></pre>
<h4><code>bytes</code>에 대한 특별한 의미 제거 (No special meaning for bytes)</h4>
<p><code>bytes</code>가 다른 <code>ByteString</code> 타입의 약어로 사용될 수 있다는 특별한 경우는 타이핑 문서에서 제거될 것입니다. <code>collections.abc.Buffer</code>가 대안으로 제공됨에 따라 <code>bytes</code>를 약어로 허용할 정당한 이유가 없어집니다.</p>
<h3>하위 호환성 (Backwards Compatibility)</h3>
<h4><code>__buffer__</code> 및 <code>__release_buffer__</code> 속성</h4>
<p>이 PEP의 런타임 변경 사항은 새로운 기능만 추가하므로 하위 호환성 문제는 거의 없습니다. 그러나 다른 목적으로 <code>__buffer__</code> 또는 <code>__release_buffer__</code> 속성을 사용하는 코드는 영향을 받을 수 있습니다. 조사 결과, 이 PEP의 <code>__buffer__</code> 메서드 사용은 PyPy와의 상호 운용성을 개선하고 주요 Python 패키지의 현재 버전에 영향을 미치지 않을 것입니다. <code>__release_buffer__</code>라는 이름은 공개적으로 접근 가능한 코드에서 사용되지 않습니다.</p>
<h4><code>bytes</code> 특별 사례 제거</h4>
<p>타입 체커에서 <code>bytes</code>의 특별한 동작을 제거하라는 권고는 사용자에게 하위 호환성 영향을 미칩니다. <code>mypy</code>를 사용한 실험에 따르면, <code>bytes</code> 승격(promotion)이 제거될 경우 타입 검사에 사용하는 여러 주요 오픈 소스 프로젝트에서 새로운 오류가 발생할 것입니다. 이러한 오류 중 상당수는 <code>typeshed</code>의 스텁(stub) 파일을 개선하여 수정할 수 있습니다. 전반적으로 이 변경은 타입 안정성을 향상시키고 타입 시스템을 더 일관성 있게 만듭니다.</p>
<h3>교육 방법 (How to Teach This)</h3>
<p><code>typing.python.org</code> 및 <code>mypy</code> 치트 시트(cheat sheet)와 같은 문서의 적절한 위치에 <code>collections.abc.Buffer</code>를 가리키는 설명을 추가할 것입니다. 타입 체커는 오류 메시지에 추가적인 지침을 제공할 수 있습니다. 예를 들어, 버퍼 객체가 <code>bytes</code>만 허용하도록 어노테이션된 함수에 전달될 때, 오류 메시지는 <code>collections.abc.Buffer</code> 사용을 제안하는 설명을 포함할 수 있습니다.</p>
<h3>채택되지 않은 아이디어 (Rejected Ideas)</h3>
<h4><code>types.Buffer</code></h4>
<p>이전 버전의 PEP에서는 <code>__instancecheck__</code>가 C로 구현된 새로운 <code>types.Buffer</code> 타입을 추가하여 <code>isinstance()</code> 검사를 통해 타입이 버퍼 프로토콜을 구현하는지 확인할 수 있도록 제안했습니다. 그러나 이 접근 방식은 <code>types.Buffer</code>가 명목(nominal) 타입이지 구조(structural) 타입이 아니므로 나머지 타입 시스템과 잘 통합되지 않습니다. 예를 들어, "버퍼 프로토콜과 <code>__len__</code>을 모두 지원하는 객체"를 표현할 방법이 없었습니다. 현재 제안은 <code>__buffer__</code>가 다른 특수 메서드와 동일하게 작동하므로, <code>Protocol</code>을 사용하여 다른 메서드와 결합할 수 있습니다.</p>
<h4><code>bytearray</code>를 <code>bytes</code>와 호환되게 유지 (Keep bytearray compatible with bytes)</h4>
<p><code>memoryview</code>가 항상 <code>bytes</code>와 호환되도록 하는 특별한 경우는 제거하고 <code>bytearray</code>의 경우는 유지하자는 제안이 있었습니다. 그러나 여러 표준 라이브러리 함수(예: <code>re.compile</code>, <code>socket.getaddrinfo</code>)는 <code>bytes</code>는 허용하지만 <code>bytearray</code>는 허용하지 않습니다. 대부분의 코드베이스에서 <code>bytearray</code>는 흔한 타입이 아니며, PEP 688은 사용자가 허용되는 타입을 명시적으로 지정하거나(<code>PEP 544</code>의 <code>Protocol</code> 사용) 선호합니다.</p>
<h4>가변 버퍼와 불변 버퍼 구분 (Distinguish between mutable and immutable buffers)</h4>
<p>버퍼 타입 내에서 가장 자주 사용되는 구분은 버퍼의 가변성(mutability) 여부입니다. 일부 함수는 가변 버퍼만 허용하고, 다른 함수는 모든 버퍼를 허용합니다. 이전 버전의 PEP는 <code>bf_releasebuffer</code> 슬롯의 존재 여부를 사용하여 버퍼 타입이 가변인지 여부를 결정할 것을 제안했지만, 이 규칙은 대부분의 표준 라이브러리 버퍼 타입에는 적용되지만 절대적이지는 않습니다. (예: NumPy 배열은 가변이지만 이 슬롯이 없음) 현재 버퍼 프로토콜은 버퍼 타입이 가변 또는 불변 버퍼를 나타내는지 여부를 안정적으로 판단할 방법을 제공하지 않으므로, 이 PEP는 이 구분에 대한 타입 시스템 지원을 추가하지 않습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-19cfc001fdac3337.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/688\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"FeyCvJug7In7AgUZlfHUx\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/688/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/688\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"688\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/688\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T2d90,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0688/\"\u003ePEP 688 - Making the buffer protocol accessible in Python\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 23-Apr-2022\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 688 – Python에서 버퍼 프로토콜 접근성 확보\u003c/h2\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 현재 C 코드에서만 접근 가능한 버퍼 프로토콜(buffer protocol)에 대해 Python 레벨 API를 제안합니다. 이를 통해 타입 체커(type checker)가 객체가 프로토콜을 구현하는지 여부를 평가할 수 있게 됩니다.\u003c/p\u003e\n\u003ch3\u003e동기 (Motivation)\u003c/h3\u003e\n\u003cp\u003eCPython C API는 객체의 기본 메모리에 접근하기 위한 다용도 메커니즘인 버퍼 프로토콜을 제공합니다. 이 프로토콜은 PEP 3118에서 도입되었으며, 이진 데이터를 받아들이는 함수는 일반적으로 버퍼 프로토콜을 구현하는 모든 객체를 처리하도록 작성됩니다. 현재 Python 코드에서는 객체가 버퍼 프로토콜을 지원하는지 여부를 검사할 방법이 없습니다. 또한, 정적 타입 시스템(static type system)은 이 프로토콜을 나타내는 타입 어노테이션(type annotation)을 제공하지 않아, 제네릭 버퍼를 허용하는 코드의 타입 어노테이션을 작성할 때 문제가 발생했습니다.\u003c/p\u003e\n\u003cp\u003e유사하게, Python으로 작성된 클래스가 버퍼 프로토콜을 지원하는 것은 불가능했습니다. Python에서 버퍼 클래스를 만들 수 있다면 사용자는 C 버퍼 객체를 쉽게 래핑(wrap)하거나, 버퍼 프로토콜을 사용하는 API의 동작을 테스트할 수 있을 것입니다.\u003c/p\u003e\n\u003ch3\u003e합리적 근거 (Rationale)\u003c/h3\u003e\n\u003ch4\u003e현재의 대안 (Current options)\u003c/h4\u003e\n\u003cp\u003e타입 시스템에서 버퍼 타입을 어노테이션하기 위한 두 가지 알려진 방법이 있었지만, 둘 다 적절하지 않았습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003etypeshed의 타입 별칭(type alias):\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e, \u003ccode\u003ebytearray\u003c/code\u003e, \u003ccode\u003ememoryview\u003c/code\u003e, \u003ccode\u003earray.array\u003c/code\u003e와 같은 표준 라이브러리의 잘 알려진 버퍼 타입을 나열하는 방식입니다. 이 방법은 표준 라이브러리에는 작동하지만, 서드 파티 버퍼 타입에는 적용되지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003etyping.ByteString\u003c/code\u003e 문서:\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e를 \u003ccode\u003ebytes\u003c/code\u003e, \u003ccode\u003ebytearray\u003c/code\u003e, \u003ccode\u003ememoryview\u003c/code\u003e 타입의 시퀀스를 나타내는 약어로 사용할 수 있다고 명시되어 있습니다. 그러나 이 사용법은 어떤 타이핑 PEP에서도 명시되지 않았고, 모든 가능한 버퍼 타입을 포함하지 않으며, 타입 어노테이션에서 \u003ccode\u003ebytes\u003c/code\u003e 타입을 모호하게 만듭니다. 예를 들어, \u003ccode\u003ebytes\u003c/code\u003e 객체에는 유효하지만 \u003ccode\u003ememoryview\u003c/code\u003e 객체에는 유효하지 않은 많은 연산이 있으며, 함수가 \u003ccode\u003ebytes\u003c/code\u003e는 허용하지만 \u003ccode\u003ememoryview\u003c/code\u003e는 허용하지 않는 경우가 있을 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e버퍼의 종류 (Kinds of buffers)\u003c/h4\u003e\n\u003cp\u003eC 버퍼 프로토콜은 스트라이드(stride), 연속성(contiguity), 쓰기 지원 등 여러 옵션을 지원합니다. 이 중 일부는 타입 시스템에서 유용할 수 있지만, C 버퍼 프로토콜에서는 대부분의 옵션을 타입 객체에서 직접 쿼리할 수 없습니다. 특정 플래그를 지원하는지 여부를 파악하는 유일한 방법은 실제로 버퍼를 요청하는 것이며, \u003ccode\u003ememoryview\u003c/code\u003e와 같은 일부 타입의 경우 지원되는 플래그가 인스턴스에 따라 달라집니다. 결과적으로 타입 시스템에서 이러한 플래그 지원을 표현하기는 어렵습니다.\u003c/p\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003ch4\u003ePython 레벨 버퍼 프로토콜 (Python-level buffer protocol)\u003c/h4\u003e\n\u003cp\u003ePEP 688은 \u003ccode\u003e__buffer__\u003c/code\u003e와 \u003ccode\u003e__release_buffer__\u003c/code\u003e라는 두 가지 Python 레벨 특수 메서드를 추가할 것을 제안합니다. 이 메서드를 구현하는 Python 클래스는 C 코드에서 버퍼로 사용될 수 있으며, 반대로 C로 구현된 버퍼 프로토콜을 지원하는 클래스는 Python 코드에서 접근 가능한 합성 메서드(synthesized methods)를 얻게 됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e__buffer__(self, flags: int, /) -\u003e memoryview\u003c/code\u003e\u003c/strong\u003e: 이 메서드는 \u003ccode\u003ememoryview()\u003c/code\u003e 생성자와 같이 Python 객체에서 버퍼를 생성하기 위해 호출됩니다. C의 \u003ccode\u003ebf_getbuffer\u003c/code\u003e 슬롯에 해당하며, \u003ccode\u003ememoryview\u003c/code\u003e 객체를 반환해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e__release_buffer__(self, buffer: memoryview, /) -\u003e None\u003c/code\u003e\u003c/strong\u003e: 이 메서드는 \u003ccode\u003e__buffer__\u003c/code\u003e에 의해 반환된 버퍼가 더 이상 필요 없을 때 호출되어야 합니다. C의 \u003ccode\u003ebf_releasebuffer\u003c/code\u003e 슬롯에 해당하며, 버퍼 프로토콜의 선택적 부분입니다. \u003ccode\u003e__buffer__\u003c/code\u003e를 직접 호출하는 Python 코드는 버퍼 사용이 끝나면 동일한 객체에 대해 \u003ccode\u003e__release_buffer__\u003c/code\u003e를 호출해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003ccode\u003einspect.BufferFlags\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003e__buffer__\u003c/code\u003e 구현을 돕기 위해 \u003ccode\u003eenum.IntFlag\u003c/code\u003e의 서브클래스인 \u003ccode\u003einspect.BufferFlags\u003c/code\u003e가 추가됩니다. 이 열거형(enum)은 C 버퍼 프로토콜에 정의된 모든 플래그를 포함합니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003ecollections.abc.Buffer\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e새로운 추상 베이스 클래스(Abstract Base Class, ABC)인 \u003ccode\u003ecollections.abc.Buffer\u003c/code\u003e가 추가되며, 이는 \u003ccode\u003e__buffer__\u003c/code\u003e 메서드를 요구합니다. 이 클래스는 주로 타입 어노테이션에 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom collections.abc import Buffer\r\n\r\ndef need_buffer(b: Buffer) -\u003e memoryview:\r\n    return memoryview(b)\r\n\r\nneed_buffer(b\"xy\") # ok\r\nneed_buffer(\"xy\") # 정적 타입 체커에 의해 거부됨 (rejected by static type checkers)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한, \u003ccode\u003eisinstance\u003c/code\u003e 및 \u003ccode\u003eissubclass\u003c/code\u003e 검사에도 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom collections.abc import Buffer\r\nisinstance(b\"xy\", Buffer) # True\r\nissubclass(bytes, Buffer) # True\r\nissubclass(memoryview, Buffer) # True\r\nisinstance(\"xy\", Buffer) # False\r\nissubclass(str, Buffer) # False\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003ccode\u003ebytes\u003c/code\u003e에 대한 특별한 의미 제거 (No special meaning for bytes)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ebytes\u003c/code\u003e가 다른 \u003ccode\u003eByteString\u003c/code\u003e 타입의 약어로 사용될 수 있다는 특별한 경우는 타이핑 문서에서 제거될 것입니다. \u003ccode\u003ecollections.abc.Buffer\u003c/code\u003e가 대안으로 제공됨에 따라 \u003ccode\u003ebytes\u003c/code\u003e를 약어로 허용할 정당한 이유가 없어집니다.\u003c/p\u003e\n\u003ch3\u003e하위 호환성 (Backwards Compatibility)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003e__buffer__\u003c/code\u003e 및 \u003ccode\u003e__release_buffer__\u003c/code\u003e 속성\u003c/h4\u003e\n\u003cp\u003e이 PEP의 런타임 변경 사항은 새로운 기능만 추가하므로 하위 호환성 문제는 거의 없습니다. 그러나 다른 목적으로 \u003ccode\u003e__buffer__\u003c/code\u003e 또는 \u003ccode\u003e__release_buffer__\u003c/code\u003e 속성을 사용하는 코드는 영향을 받을 수 있습니다. 조사 결과, 이 PEP의 \u003ccode\u003e__buffer__\u003c/code\u003e 메서드 사용은 PyPy와의 상호 운용성을 개선하고 주요 Python 패키지의 현재 버전에 영향을 미치지 않을 것입니다. \u003ccode\u003e__release_buffer__\u003c/code\u003e라는 이름은 공개적으로 접근 가능한 코드에서 사용되지 않습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003ebytes\u003c/code\u003e 특별 사례 제거\u003c/h4\u003e\n\u003cp\u003e타입 체커에서 \u003ccode\u003ebytes\u003c/code\u003e의 특별한 동작을 제거하라는 권고는 사용자에게 하위 호환성 영향을 미칩니다. \u003ccode\u003emypy\u003c/code\u003e를 사용한 실험에 따르면, \u003ccode\u003ebytes\u003c/code\u003e 승격(promotion)이 제거될 경우 타입 검사에 사용하는 여러 주요 오픈 소스 프로젝트에서 새로운 오류가 발생할 것입니다. 이러한 오류 중 상당수는 \u003ccode\u003etypeshed\u003c/code\u003e의 스텁(stub) 파일을 개선하여 수정할 수 있습니다. 전반적으로 이 변경은 타입 안정성을 향상시키고 타입 시스템을 더 일관성 있게 만듭니다.\u003c/p\u003e\n\u003ch3\u003e교육 방법 (How to Teach This)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003etyping.python.org\u003c/code\u003e 및 \u003ccode\u003emypy\u003c/code\u003e 치트 시트(cheat sheet)와 같은 문서의 적절한 위치에 \u003ccode\u003ecollections.abc.Buffer\u003c/code\u003e를 가리키는 설명을 추가할 것입니다. 타입 체커는 오류 메시지에 추가적인 지침을 제공할 수 있습니다. 예를 들어, 버퍼 객체가 \u003ccode\u003ebytes\u003c/code\u003e만 허용하도록 어노테이션된 함수에 전달될 때, 오류 메시지는 \u003ccode\u003ecollections.abc.Buffer\u003c/code\u003e 사용을 제안하는 설명을 포함할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e채택되지 않은 아이디어 (Rejected Ideas)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003etypes.Buffer\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e이전 버전의 PEP에서는 \u003ccode\u003e__instancecheck__\u003c/code\u003e가 C로 구현된 새로운 \u003ccode\u003etypes.Buffer\u003c/code\u003e 타입을 추가하여 \u003ccode\u003eisinstance()\u003c/code\u003e 검사를 통해 타입이 버퍼 프로토콜을 구현하는지 확인할 수 있도록 제안했습니다. 그러나 이 접근 방식은 \u003ccode\u003etypes.Buffer\u003c/code\u003e가 명목(nominal) 타입이지 구조(structural) 타입이 아니므로 나머지 타입 시스템과 잘 통합되지 않습니다. 예를 들어, \"버퍼 프로토콜과 \u003ccode\u003e__len__\u003c/code\u003e을 모두 지원하는 객체\"를 표현할 방법이 없었습니다. 현재 제안은 \u003ccode\u003e__buffer__\u003c/code\u003e가 다른 특수 메서드와 동일하게 작동하므로, \u003ccode\u003eProtocol\u003c/code\u003e을 사용하여 다른 메서드와 결합할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003ebytearray\u003c/code\u003e를 \u003ccode\u003ebytes\u003c/code\u003e와 호환되게 유지 (Keep bytearray compatible with bytes)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ememoryview\u003c/code\u003e가 항상 \u003ccode\u003ebytes\u003c/code\u003e와 호환되도록 하는 특별한 경우는 제거하고 \u003ccode\u003ebytearray\u003c/code\u003e의 경우는 유지하자는 제안이 있었습니다. 그러나 여러 표준 라이브러리 함수(예: \u003ccode\u003ere.compile\u003c/code\u003e, \u003ccode\u003esocket.getaddrinfo\u003c/code\u003e)는 \u003ccode\u003ebytes\u003c/code\u003e는 허용하지만 \u003ccode\u003ebytearray\u003c/code\u003e는 허용하지 않습니다. 대부분의 코드베이스에서 \u003ccode\u003ebytearray\u003c/code\u003e는 흔한 타입이 아니며, PEP 688은 사용자가 허용되는 타입을 명시적으로 지정하거나(\u003ccode\u003ePEP 544\u003c/code\u003e의 \u003ccode\u003eProtocol\u003c/code\u003e 사용) 선호합니다.\u003c/p\u003e\n\u003ch4\u003e가변 버퍼와 불변 버퍼 구분 (Distinguish between mutable and immutable buffers)\u003c/h4\u003e\n\u003cp\u003e버퍼 타입 내에서 가장 자주 사용되는 구분은 버퍼의 가변성(mutability) 여부입니다. 일부 함수는 가변 버퍼만 허용하고, 다른 함수는 모든 버퍼를 허용합니다. 이전 버전의 PEP는 \u003ccode\u003ebf_releasebuffer\u003c/code\u003e 슬롯의 존재 여부를 사용하여 버퍼 타입이 가변인지 여부를 결정할 것을 제안했지만, 이 규칙은 대부분의 표준 라이브러리 버퍼 타입에는 적용되지만 절대적이지는 않습니다. (예: NumPy 배열은 가변이지만 이 슬롯이 없음) 현재 버퍼 프로토콜은 버퍼 타입이 가변 또는 불변 버퍼를 나타내는지 여부를 안정적으로 판단할 방법을 제공하지 않으므로, 이 PEP는 이 구분에 대한 타입 시스템 지원을 추가하지 않습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1098,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 688 - Making the buffer protocol accessible in Python\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 10:13:02+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>