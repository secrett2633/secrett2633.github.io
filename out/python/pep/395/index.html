<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/773b243a13a00265.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/app/layout-fa159ef0265a0843.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2215<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Withdrawn] PEP 395 - Qualified Names for Modules</h1><div class="page__meta"><time dateTime="2025-09-26 21:22:00+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0395/">PEP 395 - Qualified Names for Modules</a></p>
<p><strong>상태:</strong> Withdrawn | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 04-Mar-2011</p>
</blockquote>
<p>PEP 395 – 모듈의 정규화된 이름 (Qualified Names for Modules)</p>
<h2>개요</h2>
<p>PEP 395는 Python의 임포트(import) 시스템, 객체 직렬화(serialization), 그리고 인트로스펙션(introspection)을 다룰 때 발생하는 오래된 문제점들을 해결하기 위한 새로운 메커니즘을 제안하는 문서입니다. 이 제안은 PEP 3155에서 정의된 "정규화된 이름(Qualified Name)" 개념을 기반으로 합니다.</p>
<p><strong>현재 상태:</strong> 2013년 12월, 작성자에 의해 철회(Withdrawn)되었습니다. 이는 PEP가 작성된 이후 Python에 중요한 변화들이 있었고, 이로 인해 PEP 395의 여러 측면이 구식화되었기 때문입니다. 특히 PEP 420 (네임스페이스 패키지)은 패키지 감지와 관련된 일부 제안을 실현 불가능하게 만들었으며, PEP 451 (모듈 스펙)은 멀티프로세싱(multiprocessing) 문제를 해결하고 pickle 호환성 문제를 다룰 수 있는 방법을 제공했습니다.</p>
<h2>다른 PEP들과의 관계</h2>
<ul>
<li><strong>PEP 420 (네임스페이스 패키지):</strong> <code>__init__.py</code> 파일의 필수성 제거와 호환성을 위해 PEP 395에 상당한 변경이 필요하며, PEP 420은 Python 3.3에서 이미 구현 및 릴리스되었습니다.</li>
<li><strong>PEP 3155 (Qualified Name):</strong> 이 PEP는 PEP 3155에서 도입된 "qualified name" 개념을 기반으로 하며, 임의의 함수와 클래스의 직렬화 시 발생하는 문제들을 해결하려는 목표를 공유합니다.</li>
<li><strong>PEP 366 (Explicit Relative Imports):</strong> 주(main) 모듈에서 명시적 상대 임포트(explicit relative imports)가 특정 상황에서 올바르게 작동하도록 하는 초기 단계를 밟은 PEP 366을 기반으로 합니다.</li>
<li><strong>PEP 328 (Implicit Relative Imports):</strong> 임포트된 모듈에서의 암시적 상대 임포트(implicit relative imports)를 제거했습니다. PEP 395는 <code>sys.path[0]</code>에 대한 현재 초기화 동작으로 인해 제공되는 주 모듈의 사실상의 암시적 상대 임포트도 제거할 것을 제안합니다.</li>
</ul>
<h2><code>__name__</code> 속성의 문제점</h2>
<p>모듈의 <code>__name__</code> 속성은 시간이 지남에 따라 여러 가지 용도로 사용되어 왔습니다. 주요 사용 사례는 다음과 같습니다.</p>
<ul>
<li><code>if __name__ == "__main__":</code> 관례를 사용하여 프로그램의 주 모듈을 표시합니다.</li>
<li>상대 임포트의 시작점입니다.</li>
<li>실행 중인 애플리케이션 내에서 함수 및 클래스 정의의 위치를 식별합니다.</li>
<li>다른 인터프리터 인스턴스와 공유될 수 있는 pickle 객체로 직렬화하기 위한 클래스의 위치를 식별합니다.</li>
</ul>
<p>이처럼 <code>__name__</code>의 의미가 과도하게 사용되고, <code>sys.path[0]</code> 초기화 시 역사적으로 관련된 동작들이 결합되어 사용자들이 쉽게 빠질 수 있는 여러 함정을 만들었습니다. 이러한 함정들은 특히 초보자에게는 매우 불명확하고 혼란스러운 동작을 유발하여 실질적으로 성가실 수 있습니다.</p>
<h3>초보자를 위한 함정들 (Traps for the Unwary)</h3>
<h4>1. 임포트 오류 (Why are my imports broken?)</h4>
<p><code>sys.path</code>를 수정할 때 적용되는 일반적인 원칙은 패키지 디렉터리를 <code>sys.path</code>에 직접 추가하지 않는 것입니다. 이 문제가 발생하는 이유는 해당 디렉터리의 모든 모듈이 이제 두 가지 다른 이름으로 접근 가능할 수 있기 때문입니다.</p>
<ul>
<li>최상위 모듈(패키지 디렉터리가 <code>sys.path</code>에 있으므로)</li>
<li>패키지의 서브 모듈(패키지 자체를 포함하는 상위 디렉터리가 <code>sys.path</code>에 있는 경우)</li>
</ul>
<p>이러한 문제는 특히 초보자가 패키지 내의 스크립트를 다양한 방식으로 실행하려 할 때 발생하며, 모호한 오류 메시지로 인해 디버깅이 어렵습니다. 예를 들어, <code>test_foo.py</code>가 패키지 안에 있을 때 <code>./test_foo.py</code>나 <code>python test_foo.py</code>로 실행하면 대부분의 경우 임포트 오류가 발생할 수 있습니다. PEP 366 구현 이후에는 <code>python -m package.tests.test_foo</code>와 같이 <code>-m</code> 스위치를 사용하는 방법은 제대로 작동하지만, 여전히 많은 실행 방법이 혼란을 야기합니다.</p>
<h4>2. 주 모듈 이중 임포트 (Importing the main module twice)</h4>
<p>주 모듈이 실제 이름으로도 임포트될 때 발생하며, 동일한 모듈의 두 인스턴스가 다른 이름으로 생성됩니다. 만약 <code>__main__</code>에 저장된 상태가 프로그램의 올바른 작동에 중요하거나, 주 모듈에 비멱등(non-idempotent)적인 부작용을 일으키는 최상위 코드가 있다면, 이러한 중복은 모호하고 예상치 못한 오류를 유발할 수 있습니다.</p>
<h4>3. Pickle 문제 (In a bit of a pickle)</h4>
<p><code>pickle</code> 모듈은 임의의 클래스 인스턴스를 직렬화할 때 <code>__module__</code> 속성에 의존하는 경우가 있습니다. <code>__main__</code>에 정의된 클래스 인스턴스는 해당 방식으로 피클링(pickling)되며, 해당 모듈을 직접 실행하는 대신 임포트만 한 다른 Python 인스턴스에서는 올바르게 언피클링(unpickling)되지 않을 수 있습니다. 이는 객체 직렬화와 영속성을 사용하는 애플리케이션에서 <code>__main__</code> 모듈에 가능한 한 적은 코드를 두어야 한다는 조언의 근본적인 이유입니다.</p>
<h4>4. 소스 코드 위치 문제 (Where's the source?)</h4>
<p>일부 고급 사용자는 <code>pickle</code> 모듈을 통해 구현 세부 정보가 유출되는 문제를 인식하고 <code>__name__</code>을 모듈의 공개 위치를 참조하도록 변경하여 해결하려고 합니다. 그러나 이 접근 방식은 함수와 클래스의 인트로스펙션(<code>__module__</code> 속성이 이제 잘못된 곳을 가리키므로)을 손상시키는 대가를 치르게 됩니다.</p>
<h4>5. Windows의 멀티프로세싱 (Forkless Windows)</h4>
<p><code>os.fork</code>가 없는 Windows에서 <code>multiprocessing</code> 모듈은 주 모듈을 다시 실행하려고 시도하지만, <code>if __name__ == "__main__":</code> 검사로 보호된 코드는 건너뜁니다. 하지만 주 모듈이 일반적인 직접 실행 스크립트나 최상위 모듈이 아닐 때 가정하는 바가 유효하지 않아 문제가 발생할 수 있습니다. 패키지 및 <code>-m</code> 스위치를 통해 실행되는 비최상위 모듈, 그리고 직접 실행되는 zipfile이나 디렉터리는 새 프로세스를 생성할 때 Windows에서 <code>multiprocessing</code>이 잘못된 동작을 하도록 만들 가능성이 있습니다.</p>
<h2>모듈의 정규화된 이름 (<code>__qualname__</code>)</h2>
<p>이러한 문제들을 해결하기 위해 새로운 모듈 레벨 속성인 <code>__qualname__</code>을 추가할 것을 제안합니다. 이 "정규화된 이름"의 약어는 PEP 3155에서 중첩된 클래스 또는 함수 정의의 최상위 모듈에 대한 이름 지정 경로를 저장하는 데 사용됩니다.</p>
<ul>
<li>모듈의 경우, <code>__qualname__</code>은 일반적으로 <code>__name__</code>과 동일합니다.</li>
<li>하지만 <code>__name__</code>이 다른 목적으로 수정될 때(예: 주 모듈을 나타내기 위해), <code>__qualname__</code>은 변경되지 않은 상태로 유지되어 코드가 원래의 수정되지 않은 값에 접근할 수 있도록 합니다.</li>
<li>모듈 로더가 <code>__qualname__</code>을 직접 초기화하지 않으면, 임포트 시스템이 자동으로 추가합니다(<code>__name__</code>과 동일한 값으로 설정).</li>
</ul>
<h3>대안 이름들 (Alternative Names)</h3>
<p><code>__fullname__</code>과 <code>__implname__</code>도 고려되었지만, PEP 3155의 함수 및 클래스 사용 사례에 정확하지 않아 <code>__qualname__</code>이 채택되었습니다.</p>
<h2>문제점 해결 (Eliminating the Traps)</h2>
<p>다음 변경 사항들은 상호 연관되어 있으며, 함께 고려할 때 가장 의미가 있습니다. 이들은 위에 언급된 함정들을 완전히 제거하거나, 해결하기 위한 간단한 메커니즘을 제공합니다.</p>
<h3>1. 패키지 내 주 모듈 임포트 수정 (Fixing main module imports inside packages)</h3>
<p>이 문제를 제거하기 위해 <code>sys.path[0]</code>에 적절한 값을 결정할 때 추가적인 파일 시스템 검사를 수행할 것을 제안합니다. 이 검사는 Python의 명시적인 패키지 디렉터리 마커를 찾아 <code>sys.path</code>에 추가할 적절한 디렉터리를 사용합니다.</p>
<p>제안된 초기화 프로세스는 파일 시스템에 저장된 패키지 세부 정보를 고려하도록 수정됩니다.</p>
<ul>
<li><code>split_path_module()</code>이라는 지원 함수를 사용하여 파일 시스템 경로와 상대 모듈 이름을 기반으로 적절한 <code>sys.path</code> 항목과 정규화된 모듈 이름을 결정합니다.</li>
<li>이 <code>split_path_module()</code> 기능은 <code>runpy</code> 모듈을 통해 Python 사용자에게 직접 노출될 것을 제안합니다.</li>
</ul>
<p>이 수정 사항이 적용되면, 패키지 내의 모듈도 다양한 명령줄 호출 방식으로 올바르게 실행될 수 있습니다. 예를 들어, <code>project/example/tests/</code> 디렉터리에서 <code>test_foo.py</code>를 <code>python -m package.tests.test_foo</code> 또는 <code>python -c "from .test_foo import main; main()"</code> 등으로 실행해도 올바르게 작동하게 됩니다.</p>
<h3>2. 선택적 추가: 명령줄 상대 임포트 (Optional addition: command line relative imports)</h3>
<p>위의 변경 사항이 적용되면, <code>-m</code> 스위치의 인수로 명시적 상대 임포트를 허용하는 것은 비교적 사소한 추가 사항이 될 것입니다.
예시:</p>
<pre><code class="language-python"># 현재 작업 디렉토리: project/example/tests
python -m .test_foo
python -m ..tests.test_foo
</code></pre>
<p>이 추가 사항으로 <code>-m</code> 스위치의 시스템 초기화 방식이 변경됩니다.</p>
<h3>3. 주 모듈 이중 임포트 수정 (Fixing dual imports of the main module)</h3>
<p>주 모듈에서 <code>__qualname__</code>이 일관되게 올바르게 설정되도록 하는 위의 제안을 바탕으로, 주 모듈의 이중 임포트 문제를 제거하기 위한 간단한 변경 사항이 제안됩니다. 이는 <code>__main__</code>을 실제 이름으로 임포트하려는 시도를 감지하고 원래의 주 모듈을 반환하는 <code>sys.metapath</code> 훅을 추가하는 것입니다.</p>
<pre><code class="language-python">class AliasImporter:
    def __init__(self, module, alias):
        self.module = module
        self.alias = alias
    # ... (find_module, load_module 메서드 구현)
</code></pre>
<p>이 <code>metapath</code> 훅은 임포트 시스템 초기화 중에 자동으로 추가됩니다.</p>
<h3>4. 인트로스펙션을 손상시키지 않고 pickle 문제 수정 (Fixing pickling without breaking introspection)</h3>
<p>이 문제를 해결하기 위해, <code>__name__</code>이 어떤 이유로든 수정되었을 때 모듈의 실제 위치를 결정하기 위해 새로운 모듈 레벨 <code>__qualname__</code> 속성을 사용할 것을 제안합니다.</p>
<ul>
<li>주 모듈에서는 <code>__qualname__</code>이 인터프리터에 의해 주 모듈의 "실제" 이름으로 자동 설정됩니다.</li>
<li>공개 네임스페이스를 가리키도록 <code>__name__</code>을 조정하는 의사 모듈(pseudo-modules)은 <code>__qualname__</code>을 건드리지 않아 구현 위치가 인트로스펙션에 쉽게 접근 가능하도록 합니다.</li>
<li>여러 서브 모듈이 동일한 "공개" 네임스페이스를 사용하도록 설정될 수 있으므로, 함수와 클래스에는 해당 모듈의 <code>__qualname__</code>을 참조하는 새로운 <code>__qualmodule__</code> 속성이 부여됩니다.</li>
</ul>
<p>이러한 변경 사항은 <code>__name__</code> (및 간접적으로 해당하는 함수 및 클래스 <code>__module__</code> 속성)을 조정하는 것이 네임스페이스를 패키지로 구현하는 공식적인 방법이 되며, API는 여전히 단일 모듈인 것처럼 노출됩니다. 모든 직렬화 코드는 기본적으로 구현 세부 정보를 노출하는 것을 피하게 됩니다.</p>
<h3>5. Windows의 멀티프로세싱 수정 (Fixing multiprocessing on Windows)</h3>
<p><code>__qualname__</code>을 통해 <code>multiprocessing</code>이 주 모듈의 실제 이름을 알 수 있게 되면서, 자식 프로세스로 전달되는 직렬화된 정보에 단순히 이를 포함할 수 있게 되어 <code>__file__</code> 속성에 대한 현재의 의심스러운 인트로스펙션이 필요 없게 됩니다.</p>
<h3>6. 명시적 상대 임포트 (Explicit relative imports)</h3>
<p>이 PEP는 <code>__package__</code>가 주 모듈에서 <code>__qualname__.rpartition('.')[0]</code>으로 무조건 정의될 것을 제안합니다. 그 외에는 명시적 상대 임포트의 동작을 그대로 유지할 것을 제안합니다.</p>
<h2>호환성 (Compatibility)</h2>
<ul>
<li>
<p><strong>PEP 382와의 호환성:</strong> PEP 382 (네임스페이스 패키징)와 이 제안의 호환성은 <code>_is_package_dir()</code>의 의미만 변경하면 간단합니다.</p>
</li>
<li>
<p><strong>PEP 402와의 비호환성:</strong> PEP 402는 Python 패키지에 대한 파일 시스템의 명시적 마커 제거를 제안합니다. 이는 파일 시스템 경로와 Python 모듈 이름을 가지고 Python 모듈 네임스페이스에 대한 명확한 매핑을 찾아낼 수 있다는 제안된 개념을 근본적으로 깨뜨립니다. 결과적으로, <code>sys.path[0]</code> 계산 문제를 해결하는 것이 불가능해집니다.</p>
</li>
<li>
<p><strong>패키지에 저장된 스크립트와의 잠재적 비호환성:</strong> <code>sys.path[0]</code> 초기화에 대한 제안된 변경 사항은 일부 기존 코드를 깨뜨릴 수 있습니다. 특히 Python 3에서 올바르게 실행되기 위해 <code>__main__</code>의 암시적 상대 임포트에 의존하는 패키지 디렉터리에 저장된 스크립트가 영향을 받습니다. 이러한 스크립트들은 명시적 상대 임포트로 전환해야 다시 실행 가능한 스크립트이자 임포트 가능한 모듈로 작동하게 될 것입니다.</p>
</li>
</ul>
<h2>참고 구현 (Reference Implementation)</h2>
<p>아직 없습니다.</p>
<h2>참고 자료 (References)</h2>
<ul>
<li>Module aliases and/or “real names”</li>
<li>PEP 395 (Module aliasing) and the namespace PEPs</li>
<li>Updated PEP 395 (aka “Implicit Relative Imports Must Die!”)</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/394/">[Active] PEP 394 - The “python” Command on Unix-Like Systems</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Withdrawn] PEP 395 - Qualified Names for Modules</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/396/">[Withdrawn] PEP 396 - Module Version Numbers</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/773b243a13a00265.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"185\",\"static/chunks/app/layout-fa159ef0265a0843.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/395\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/773b243a13a00265.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"q5uHuVDyt3FPCtp0uxl7W\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/395/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/395\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"395\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/395\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"default\"]\ne:T3def,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0395/\"\u003ePEP 395 - Qualified Names for Modules\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Withdrawn | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 04-Mar-2011\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 395 – 모듈의 정규화된 이름 (Qualified Names for Modules)\u003c/p\u003e\n\u003ch2\u003e개요\u003c/h2\u003e\n\u003cp\u003ePEP 395는 Python의 임포트(import) 시스템, 객체 직렬화(serialization), 그리고 인트로스펙션(introspection)을 다룰 때 발생하는 오래된 문제점들을 해결하기 위한 새로운 메커니즘을 제안하는 문서입니다. 이 제안은 PEP 3155에서 정의된 \"정규화된 이름(Qualified Name)\" 개념을 기반으로 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e현재 상태:\u003c/strong\u003e 2013년 12월, 작성자에 의해 철회(Withdrawn)되었습니다. 이는 PEP가 작성된 이후 Python에 중요한 변화들이 있었고, 이로 인해 PEP 395의 여러 측면이 구식화되었기 때문입니다. 특히 PEP 420 (네임스페이스 패키지)은 패키지 감지와 관련된 일부 제안을 실현 불가능하게 만들었으며, PEP 451 (모듈 스펙)은 멀티프로세싱(multiprocessing) 문제를 해결하고 pickle 호환성 문제를 다룰 수 있는 방법을 제공했습니다.\u003c/p\u003e\n\u003ch2\u003e다른 PEP들과의 관계\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePEP 420 (네임스페이스 패키지):\u003c/strong\u003e \u003ccode\u003e__init__.py\u003c/code\u003e 파일의 필수성 제거와 호환성을 위해 PEP 395에 상당한 변경이 필요하며, PEP 420은 Python 3.3에서 이미 구현 및 릴리스되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePEP 3155 (Qualified Name):\u003c/strong\u003e 이 PEP는 PEP 3155에서 도입된 \"qualified name\" 개념을 기반으로 하며, 임의의 함수와 클래스의 직렬화 시 발생하는 문제들을 해결하려는 목표를 공유합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePEP 366 (Explicit Relative Imports):\u003c/strong\u003e 주(main) 모듈에서 명시적 상대 임포트(explicit relative imports)가 특정 상황에서 올바르게 작동하도록 하는 초기 단계를 밟은 PEP 366을 기반으로 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePEP 328 (Implicit Relative Imports):\u003c/strong\u003e 임포트된 모듈에서의 암시적 상대 임포트(implicit relative imports)를 제거했습니다. PEP 395는 \u003ccode\u003esys.path[0]\u003c/code\u003e에 대한 현재 초기화 동작으로 인해 제공되는 주 모듈의 사실상의 암시적 상대 임포트도 제거할 것을 제안합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e\u003ccode\u003e__name__\u003c/code\u003e 속성의 문제점\u003c/h2\u003e\n\u003cp\u003e모듈의 \u003ccode\u003e__name__\u003c/code\u003e 속성은 시간이 지남에 따라 여러 가지 용도로 사용되어 왔습니다. 주요 사용 사례는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eif __name__ == \"__main__\":\u003c/code\u003e 관례를 사용하여 프로그램의 주 모듈을 표시합니다.\u003c/li\u003e\n\u003cli\u003e상대 임포트의 시작점입니다.\u003c/li\u003e\n\u003cli\u003e실행 중인 애플리케이션 내에서 함수 및 클래스 정의의 위치를 식별합니다.\u003c/li\u003e\n\u003cli\u003e다른 인터프리터 인스턴스와 공유될 수 있는 pickle 객체로 직렬화하기 위한 클래스의 위치를 식별합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이처럼 \u003ccode\u003e__name__\u003c/code\u003e의 의미가 과도하게 사용되고, \u003ccode\u003esys.path[0]\u003c/code\u003e 초기화 시 역사적으로 관련된 동작들이 결합되어 사용자들이 쉽게 빠질 수 있는 여러 함정을 만들었습니다. 이러한 함정들은 특히 초보자에게는 매우 불명확하고 혼란스러운 동작을 유발하여 실질적으로 성가실 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e초보자를 위한 함정들 (Traps for the Unwary)\u003c/h3\u003e\n\u003ch4\u003e1. 임포트 오류 (Why are my imports broken?)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003esys.path\u003c/code\u003e를 수정할 때 적용되는 일반적인 원칙은 패키지 디렉터리를 \u003ccode\u003esys.path\u003c/code\u003e에 직접 추가하지 않는 것입니다. 이 문제가 발생하는 이유는 해당 디렉터리의 모든 모듈이 이제 두 가지 다른 이름으로 접근 가능할 수 있기 때문입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e최상위 모듈(패키지 디렉터리가 \u003ccode\u003esys.path\u003c/code\u003e에 있으므로)\u003c/li\u003e\n\u003cli\u003e패키지의 서브 모듈(패키지 자체를 포함하는 상위 디렉터리가 \u003ccode\u003esys.path\u003c/code\u003e에 있는 경우)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 문제는 특히 초보자가 패키지 내의 스크립트를 다양한 방식으로 실행하려 할 때 발생하며, 모호한 오류 메시지로 인해 디버깅이 어렵습니다. 예를 들어, \u003ccode\u003etest_foo.py\u003c/code\u003e가 패키지 안에 있을 때 \u003ccode\u003e./test_foo.py\u003c/code\u003e나 \u003ccode\u003epython test_foo.py\u003c/code\u003e로 실행하면 대부분의 경우 임포트 오류가 발생할 수 있습니다. PEP 366 구현 이후에는 \u003ccode\u003epython -m package.tests.test_foo\u003c/code\u003e와 같이 \u003ccode\u003e-m\u003c/code\u003e 스위치를 사용하는 방법은 제대로 작동하지만, 여전히 많은 실행 방법이 혼란을 야기합니다.\u003c/p\u003e\n\u003ch4\u003e2. 주 모듈 이중 임포트 (Importing the main module twice)\u003c/h4\u003e\n\u003cp\u003e주 모듈이 실제 이름으로도 임포트될 때 발생하며, 동일한 모듈의 두 인스턴스가 다른 이름으로 생성됩니다. 만약 \u003ccode\u003e__main__\u003c/code\u003e에 저장된 상태가 프로그램의 올바른 작동에 중요하거나, 주 모듈에 비멱등(non-idempotent)적인 부작용을 일으키는 최상위 코드가 있다면, 이러한 중복은 모호하고 예상치 못한 오류를 유발할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e3. Pickle 문제 (In a bit of a pickle)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003epickle\u003c/code\u003e 모듈은 임의의 클래스 인스턴스를 직렬화할 때 \u003ccode\u003e__module__\u003c/code\u003e 속성에 의존하는 경우가 있습니다. \u003ccode\u003e__main__\u003c/code\u003e에 정의된 클래스 인스턴스는 해당 방식으로 피클링(pickling)되며, 해당 모듈을 직접 실행하는 대신 임포트만 한 다른 Python 인스턴스에서는 올바르게 언피클링(unpickling)되지 않을 수 있습니다. 이는 객체 직렬화와 영속성을 사용하는 애플리케이션에서 \u003ccode\u003e__main__\u003c/code\u003e 모듈에 가능한 한 적은 코드를 두어야 한다는 조언의 근본적인 이유입니다.\u003c/p\u003e\n\u003ch4\u003e4. 소스 코드 위치 문제 (Where's the source?)\u003c/h4\u003e\n\u003cp\u003e일부 고급 사용자는 \u003ccode\u003epickle\u003c/code\u003e 모듈을 통해 구현 세부 정보가 유출되는 문제를 인식하고 \u003ccode\u003e__name__\u003c/code\u003e을 모듈의 공개 위치를 참조하도록 변경하여 해결하려고 합니다. 그러나 이 접근 방식은 함수와 클래스의 인트로스펙션(\u003ccode\u003e__module__\u003c/code\u003e 속성이 이제 잘못된 곳을 가리키므로)을 손상시키는 대가를 치르게 됩니다.\u003c/p\u003e\n\u003ch4\u003e5. Windows의 멀티프로세싱 (Forkless Windows)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eos.fork\u003c/code\u003e가 없는 Windows에서 \u003ccode\u003emultiprocessing\u003c/code\u003e 모듈은 주 모듈을 다시 실행하려고 시도하지만, \u003ccode\u003eif __name__ == \"__main__\":\u003c/code\u003e 검사로 보호된 코드는 건너뜁니다. 하지만 주 모듈이 일반적인 직접 실행 스크립트나 최상위 모듈이 아닐 때 가정하는 바가 유효하지 않아 문제가 발생할 수 있습니다. 패키지 및 \u003ccode\u003e-m\u003c/code\u003e 스위치를 통해 실행되는 비최상위 모듈, 그리고 직접 실행되는 zipfile이나 디렉터리는 새 프로세스를 생성할 때 Windows에서 \u003ccode\u003emultiprocessing\u003c/code\u003e이 잘못된 동작을 하도록 만들 가능성이 있습니다.\u003c/p\u003e\n\u003ch2\u003e모듈의 정규화된 이름 (\u003ccode\u003e__qualname__\u003c/code\u003e)\u003c/h2\u003e\n\u003cp\u003e이러한 문제들을 해결하기 위해 새로운 모듈 레벨 속성인 \u003ccode\u003e__qualname__\u003c/code\u003e을 추가할 것을 제안합니다. 이 \"정규화된 이름\"의 약어는 PEP 3155에서 중첩된 클래스 또는 함수 정의의 최상위 모듈에 대한 이름 지정 경로를 저장하는 데 사용됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모듈의 경우, \u003ccode\u003e__qualname__\u003c/code\u003e은 일반적으로 \u003ccode\u003e__name__\u003c/code\u003e과 동일합니다.\u003c/li\u003e\n\u003cli\u003e하지만 \u003ccode\u003e__name__\u003c/code\u003e이 다른 목적으로 수정될 때(예: 주 모듈을 나타내기 위해), \u003ccode\u003e__qualname__\u003c/code\u003e은 변경되지 않은 상태로 유지되어 코드가 원래의 수정되지 않은 값에 접근할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003e모듈 로더가 \u003ccode\u003e__qualname__\u003c/code\u003e을 직접 초기화하지 않으면, 임포트 시스템이 자동으로 추가합니다(\u003ccode\u003e__name__\u003c/code\u003e과 동일한 값으로 설정).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e대안 이름들 (Alternative Names)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e__fullname__\u003c/code\u003e과 \u003ccode\u003e__implname__\u003c/code\u003e도 고려되었지만, PEP 3155의 함수 및 클래스 사용 사례에 정확하지 않아 \u003ccode\u003e__qualname__\u003c/code\u003e이 채택되었습니다.\u003c/p\u003e\n\u003ch2\u003e문제점 해결 (Eliminating the Traps)\u003c/h2\u003e\n\u003cp\u003e다음 변경 사항들은 상호 연관되어 있으며, 함께 고려할 때 가장 의미가 있습니다. 이들은 위에 언급된 함정들을 완전히 제거하거나, 해결하기 위한 간단한 메커니즘을 제공합니다.\u003c/p\u003e\n\u003ch3\u003e1. 패키지 내 주 모듈 임포트 수정 (Fixing main module imports inside packages)\u003c/h3\u003e\n\u003cp\u003e이 문제를 제거하기 위해 \u003ccode\u003esys.path[0]\u003c/code\u003e에 적절한 값을 결정할 때 추가적인 파일 시스템 검사를 수행할 것을 제안합니다. 이 검사는 Python의 명시적인 패키지 디렉터리 마커를 찾아 \u003ccode\u003esys.path\u003c/code\u003e에 추가할 적절한 디렉터리를 사용합니다.\u003c/p\u003e\n\u003cp\u003e제안된 초기화 프로세스는 파일 시스템에 저장된 패키지 세부 정보를 고려하도록 수정됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esplit_path_module()\u003c/code\u003e이라는 지원 함수를 사용하여 파일 시스템 경로와 상대 모듈 이름을 기반으로 적절한 \u003ccode\u003esys.path\u003c/code\u003e 항목과 정규화된 모듈 이름을 결정합니다.\u003c/li\u003e\n\u003cli\u003e이 \u003ccode\u003esplit_path_module()\u003c/code\u003e 기능은 \u003ccode\u003erunpy\u003c/code\u003e 모듈을 통해 Python 사용자에게 직접 노출될 것을 제안합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 수정 사항이 적용되면, 패키지 내의 모듈도 다양한 명령줄 호출 방식으로 올바르게 실행될 수 있습니다. 예를 들어, \u003ccode\u003eproject/example/tests/\u003c/code\u003e 디렉터리에서 \u003ccode\u003etest_foo.py\u003c/code\u003e를 \u003ccode\u003epython -m package.tests.test_foo\u003c/code\u003e 또는 \u003ccode\u003epython -c \"from .test_foo import main; main()\"\u003c/code\u003e 등으로 실행해도 올바르게 작동하게 됩니다.\u003c/p\u003e\n\u003ch3\u003e2. 선택적 추가: 명령줄 상대 임포트 (Optional addition: command line relative imports)\u003c/h3\u003e\n\u003cp\u003e위의 변경 사항이 적용되면, \u003ccode\u003e-m\u003c/code\u003e 스위치의 인수로 명시적 상대 임포트를 허용하는 것은 비교적 사소한 추가 사항이 될 것입니다.\n예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 현재 작업 디렉토리: project/example/tests\npython -m .test_foo\npython -m ..tests.test_foo\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 추가 사항으로 \u003ccode\u003e-m\u003c/code\u003e 스위치의 시스템 초기화 방식이 변경됩니다.\u003c/p\u003e\n\u003ch3\u003e3. 주 모듈 이중 임포트 수정 (Fixing dual imports of the main module)\u003c/h3\u003e\n\u003cp\u003e주 모듈에서 \u003ccode\u003e__qualname__\u003c/code\u003e이 일관되게 올바르게 설정되도록 하는 위의 제안을 바탕으로, 주 모듈의 이중 임포트 문제를 제거하기 위한 간단한 변경 사항이 제안됩니다. 이는 \u003ccode\u003e__main__\u003c/code\u003e을 실제 이름으로 임포트하려는 시도를 감지하고 원래의 주 모듈을 반환하는 \u003ccode\u003esys.metapath\u003c/code\u003e 훅을 추가하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass AliasImporter:\n    def __init__(self, module, alias):\n        self.module = module\n        self.alias = alias\n    # ... (find_module, load_module 메서드 구현)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 \u003ccode\u003emetapath\u003c/code\u003e 훅은 임포트 시스템 초기화 중에 자동으로 추가됩니다.\u003c/p\u003e\n\u003ch3\u003e4. 인트로스펙션을 손상시키지 않고 pickle 문제 수정 (Fixing pickling without breaking introspection)\u003c/h3\u003e\n\u003cp\u003e이 문제를 해결하기 위해, \u003ccode\u003e__name__\u003c/code\u003e이 어떤 이유로든 수정되었을 때 모듈의 실제 위치를 결정하기 위해 새로운 모듈 레벨 \u003ccode\u003e__qualname__\u003c/code\u003e 속성을 사용할 것을 제안합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e주 모듈에서는 \u003ccode\u003e__qualname__\u003c/code\u003e이 인터프리터에 의해 주 모듈의 \"실제\" 이름으로 자동 설정됩니다.\u003c/li\u003e\n\u003cli\u003e공개 네임스페이스를 가리키도록 \u003ccode\u003e__name__\u003c/code\u003e을 조정하는 의사 모듈(pseudo-modules)은 \u003ccode\u003e__qualname__\u003c/code\u003e을 건드리지 않아 구현 위치가 인트로스펙션에 쉽게 접근 가능하도록 합니다.\u003c/li\u003e\n\u003cli\u003e여러 서브 모듈이 동일한 \"공개\" 네임스페이스를 사용하도록 설정될 수 있으므로, 함수와 클래스에는 해당 모듈의 \u003ccode\u003e__qualname__\u003c/code\u003e을 참조하는 새로운 \u003ccode\u003e__qualmodule__\u003c/code\u003e 속성이 부여됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 변경 사항은 \u003ccode\u003e__name__\u003c/code\u003e (및 간접적으로 해당하는 함수 및 클래스 \u003ccode\u003e__module__\u003c/code\u003e 속성)을 조정하는 것이 네임스페이스를 패키지로 구현하는 공식적인 방법이 되며, API는 여전히 단일 모듈인 것처럼 노출됩니다. 모든 직렬화 코드는 기본적으로 구현 세부 정보를 노출하는 것을 피하게 됩니다.\u003c/p\u003e\n\u003ch3\u003e5. Windows의 멀티프로세싱 수정 (Fixing multiprocessing on Windows)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e__qualname__\u003c/code\u003e을 통해 \u003ccode\u003emultiprocessing\u003c/code\u003e이 주 모듈의 실제 이름을 알 수 있게 되면서, 자식 프로세스로 전달되는 직렬화된 정보에 단순히 이를 포함할 수 있게 되어 \u003ccode\u003e__file__\u003c/code\u003e 속성에 대한 현재의 의심스러운 인트로스펙션이 필요 없게 됩니다.\u003c/p\u003e\n\u003ch3\u003e6. 명시적 상대 임포트 (Explicit relative imports)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003e__package__\u003c/code\u003e가 주 모듈에서 \u003ccode\u003e__qualname__.rpartition('.')[0]\u003c/code\u003e으로 무조건 정의될 것을 제안합니다. 그 외에는 명시적 상대 임포트의 동작을 그대로 유지할 것을 제안합니다.\u003c/p\u003e\n\u003ch2\u003e호환성 (Compatibility)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePEP 382와의 호환성:\u003c/strong\u003e PEP 382 (네임스페이스 패키징)와 이 제안의 호환성은 \u003ccode\u003e_is_package_dir()\u003c/code\u003e의 의미만 변경하면 간단합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePEP 402와의 비호환성:\u003c/strong\u003e PEP 402는 Python 패키지에 대한 파일 시스템의 명시적 마커 제거를 제안합니다. 이는 파일 시스템 경로와 Python 모듈 이름을 가지고 Python 모듈 네임스페이스에 대한 명확한 매핑을 찾아낼 수 있다는 제안된 개념을 근본적으로 깨뜨립니다. 결과적으로, \u003ccode\u003esys.path[0]\u003c/code\u003e 계산 문제를 해결하는 것이 불가능해집니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e패키지에 저장된 스크립트와의 잠재적 비호환성:\u003c/strong\u003e \u003ccode\u003esys.path[0]\u003c/code\u003e 초기화에 대한 제안된 변경 사항은 일부 기존 코드를 깨뜨릴 수 있습니다. 특히 Python 3에서 올바르게 실행되기 위해 \u003ccode\u003e__main__\u003c/code\u003e의 암시적 상대 임포트에 의존하는 패키지 디렉터리에 저장된 스크립트가 영향을 받습니다. 이러한 스크립트들은 명시적 상대 임포트로 전환해야 다시 실행 가능한 스크립트이자 임포트 가능한 모듈로 작동하게 될 것입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e참고 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003e아직 없습니다.\u003c/p\u003e\n\u003ch2\u003e참고 자료 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eModule aliases and/or “real names”\u003c/li\u003e\n\u003cli\u003ePEP 395 (Module aliasing) and the namespace PEPs\u003c/li\u003e\n\u003cli\u003eUpdated PEP 395 (aka “Implicit Relative Imports Must Die!”)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2215,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Withdrawn] PEP 395 - Qualified Names for Modules\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 21:22:00+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/395/\",\"postId\":\"2025-09-26-pep-0395-qualified-names-for-modules\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/394/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Active] PEP 394 - The “python” Command on Unix-Like Systems\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Withdrawn] PEP 395 - Qualified Names for Modules\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/396/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Withdrawn] PEP 396 - Module Version Numbers\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>