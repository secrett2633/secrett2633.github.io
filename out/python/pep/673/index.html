<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 673 - Self Type</h1><div class="page__meta"><time dateTime="2025-09-27 10:07:14+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0673/">PEP 673 - Self Type</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 10-Nov-2021</p>
</blockquote>
<h1>PEP 673 – <code>Self</code> 타입</h1>
<h2>요약 (Abstract)</h2>
<p>이 PEP는 메서드가 자신의 클래스 인스턴스를 반환할 때 이를 어노테이션(annotation)하는 간단하고 직관적인 방법을 제안합니다. 이 방식은 기존의 <code>TypeVar</code> 기반 접근 방식(PEP 484에 명시됨)과 동일하게 작동하지만, 더 간결하고 이해하기 쉽습니다.</p>
<h2>동기 (Motivation)</h2>
<p>자신의 클래스와 동일한 인스턴스를 반환하는 메서드를 작성하는 것은 흔한 사용 사례입니다. 예를 들어, 일반적으로 <code>self</code>를 반환하는 경우입니다.</p>
<pre><code class="language-python">class Shape:
    def set_scale(self, scale: float):
        self.scale = scale
        return self

Shape().set_scale(0.5) # => Shape 타입이어야 합니다.
</code></pre>
<p>반환 타입을 명시하는 한 가지 방법은 현재 클래스(예: <code>Shape</code>)로 지정하는 것입니다. 이 메서드를 사용하면 타입 검사기가 예상대로 <code>Shape</code> 타입을 추론합니다.</p>
<pre><code class="language-python">class Shape:
    def set_scale(self, scale: float) -> Shape:
        self.scale = scale
        return self

Shape().set_scale(0.5) # => Shape
</code></pre>
<p>그러나 <code>Shape</code>의 서브클래스에서 <code>set_scale</code>을 호출하면, 타입 검사기는 여전히 반환 타입을 <code>Shape</code>으로 추론합니다. 이는 아래와 같은 상황에서 문제가 될 수 있습니다. 예를 들어, 기본 클래스에는 없는 속성이나 메서드를 사용하려고 할 때 타입 검사기가 오류를 발생시킵니다.</p>
<pre><code class="language-python">class Circle(Shape):
    def set_radius(self, r: float) -> Circle:
        self.radius = r
        return self

Circle().set_scale(0.5) # *Shape* 타입으로 추론, Circle이 아님
Circle().set_scale(0.5).set_radius(2.7) # => 에러: Shape에는 set_radius 속성이 없습니다.
</code></pre>
<p>이러한 경우에 대한 현재의 해결책은 <code>TypeVar</code>를 정의하고, 기본 클래스를 바운드(bound)로 지정한 후, 이를 <code>self</code> 파라미터와 반환 타입의 어노테이션으로 사용하는 것입니다.</p>
<pre><code class="language-python">from typing import TypeVar

TShape = TypeVar("TShape", bound="Shape")

class Shape:
    def set_scale(self: TShape, scale: float) -> TShape:
        self.scale = scale
        return self

class Circle(Shape):
    def set_radius(self, radius: float) -> Circle:
        self.radius = radius
        return self

Circle().set_scale(0.5).set_radius(2.7) # => Circle
</code></pre>
<p>하지만 이 방법은 장황하고 직관적이지 않습니다. <code>self</code>는 일반적으로 명시적으로 어노테이션되지 않기 때문에, 위의 해결책은 쉽게 떠오르지 않을 뿐더러, <code>TypeVar</code>의 바운드(<code>bound="Shape"</code>)나 <code>self</code>에 대한 어노테이션을 잊어버리기 쉽습니다.</p>
<p>이러한 어려움 때문에 사용자들은 종종 포기하고 <code>Any</code>와 같은 대체 타입을 사용하거나, 아예 타입 어노테이션을 생략하게 됩니다. 이 두 가지 모두 코드의 타입 안전성(type safety)을 떨어뜨립니다.</p>
<p>이 PEP는 위의 의도를 표현하는 더 직관적이고 간결한 방법을 제안합니다. 우리는 감싸고 있는(encapsulating) 클래스에 바운드된 타입 변수를 나타내는 특별한 형태인 <code>Self</code>를 도입합니다. 위와 같은 상황에서, 사용자는 단순히 반환 타입을 <code>Self</code>로 어노테이션하면 됩니다.</p>
<pre><code class="language-python">from typing import Self

class Shape:
    def set_scale(self, scale: float) -> Self:
        self.scale = scale
        return self

class Circle(Shape):
    def set_radius(self, radius: float) -> Self:
        self.radius = radius
        return self
</code></pre>
<p>반환 타입을 <code>Self</code>로 어노테이션함으로써, 우리는 더 이상 기본 클래스에 명시적인 바운드를 가진 <code>TypeVar</code>를 선언할 필요가 없습니다. 반환 타입 <code>Self</code>는 함수가 <code>self</code>를 반환한다는 사실을 반영하며 이해하기 쉽습니다.</p>
<p>위 예제에서처럼, 타입 검사기는 <code>Circle().set_scale(0.5)</code>의 타입을 예상대로 <code>Circle</code>로 정확하게 추론할 것입니다.</p>
<h3>사용 통계 (Usage statistics)</h3>
<p>우리는 인기 있는 오픈 소스 프로젝트들을 분석했으며, 위와 같은 패턴이 <code>dict</code> 또는 <code>Callable</code>과 같은 인기 있는 타입만큼 자주 사용된다는 것을 발견했습니다 (약 40%). 예를 들어, 2021년 10월 기준으로 typeshed에서만 이러한 "Self" 타입은 523회 사용되었으며, <code>dict</code>는 1286회, <code>Callable</code>은 1314회 사용되었습니다. 이는 <code>Self</code> 타입이 상당히 자주 사용될 것이며, 사용자들은 이 더 간단한 접근 방식으로부터 많은 이점을 얻을 수 있음을 시사합니다.</p>
<p>Python 타입 사용자들도 제안 문서와 GitHub에서 이 기능을 자주 요청했습니다.</p>
<h2>명세 (Specification)</h2>
<h3>메서드 시그니처에서의 사용 (Use in Method Signatures)</h3>
<p>메서드 시그니처에서 사용되는 <code>Self</code>는 해당 클래스에 바운드된 <code>TypeVar</code>처럼 처리됩니다.</p>
<pre><code class="language-python">from typing import Self

class Shape:
    def set_scale(self, scale: float) -> Self:
        self.scale = scale
        return self
</code></pre>
<p>위 코드는 다음 코드와 동일하게 처리됩니다.</p>
<pre><code class="language-python">from typing import TypeVar

SelfShape = TypeVar("SelfShape", bound="Shape")

class Shape:
    def set_scale(self: SelfShape, scale: float) -> SelfShape:
        self.scale = scale
        return self
</code></pre>
<p>이것은 서브클래스에서도 동일하게 작동합니다.</p>
<pre><code class="language-python">class Circle(Shape):
    def set_radius(self, radius: float) -> Self:
        self.radius = radius
        return self
</code></pre>
<p>위 코드는 다음 코드와 동일하게 처리됩니다.</p>
<pre><code class="language-python">SelfCircle = TypeVar("SelfCircle", bound="Circle")

class Circle(Shape):
    def set_radius(self: SelfCircle, radius: float) -> SelfCircle:
        self.radius = radius
        return self
</code></pre>
<p>한 가지 구현 전략은 전처리 단계에서 전자를 후자로 단순히 "desugar"(구문 설탕 제거)하는 것입니다. 메서드가 시그니처에 <code>Self</code>를 사용하면, 메서드 내 <code>self</code>의 타입은 <code>Self</code>가 됩니다. 다른 경우에는 <code>self</code>의 타입은 감싸는(enclosing) 클래스로 유지됩니다.</p>
<h3>클래스메서드 시그니처에서의 사용 (Use in Classmethod Signatures)</h3>
<p><code>Self</code> 타입 어노테이션은 자신이 작동하는 클래스의 인스턴스를 반환하는 클래스메서드(classmethod)에서도 유용합니다. 예를 들어, 다음 스니펫의 <code>from_config</code>는 주어진 <code>config</code>로부터 <code>Shape</code> 객체를 만듭니다.</p>
<pre><code class="language-python">class Shape:
    def __init__(self, scale: float) -> None: ...
    @classmethod
    def from_config(cls, config: dict[str, float]) -> Shape:
        return cls(config["scale"])
</code></pre>
<p>그러나 이렇게 하면 <code>Circle.from_config(...)</code>가 <code>Shape</code> 타입의 값을 반환하는 것으로 추론되는데, 실제로는 <code>Circle</code>이어야 합니다.</p>
<pre><code class="language-python">class Circle(Shape):
    def circumference(self) -> float: ...

shape = Shape.from_config({"scale": 7.0}) # => Shape
circle = Circle.from_config({"scale": 7.0}) # => *Shape* 타입으로 추론, Circle이 아님
circle.circumference() # 에러: `Shape`에는 `circumference` 속성이 없습니다.
</code></pre>
<p>이에 대한 현재의 해결책은 직관적이지 않고 오류 발생 가능성이 높습니다.</p>
<pre><code class="language-python">Self = TypeVar("Self", bound="Shape") # TypeVar 이름 충돌을 피하기 위해 이름을 다르게 할 수도 있습니다.

class Shape:
    @classmethod
    def from_config(
        cls: type[Self], # 복잡한 어노테이션
        config: dict[str, float]
    ) -> Self:
        return cls(config["scale"])
</code></pre>
<p>우리는 <code>Self</code>를 직접 사용하는 것을 제안합니다.</p>
<pre><code class="language-python">from typing import Self

class Shape:
    @classmethod
    def from_config(cls, config: dict[str, float]) -> Self:
        return cls(config["scale"])
</code></pre>
<p>이는 복잡한 <code>cls: type[Self]</code> 어노테이션과 바운드가 있는 <code>TypeVar</code> 선언을 피하게 해줍니다. 다시 말하지만, 후자의 코드는 전자의 코드와 동일하게 동작합니다.</p>
<h3>파라미터 타입에서의 사용 (Use in Parameter Types)</h3>
<p><code>Self</code>의 또 다른 용도는 현재 클래스의 인스턴스를 기대하는 파라미터를 어노테이션하는 것입니다.</p>
<pre><code class="language-python">Self = TypeVar("Self", bound="Shape")

class Shape:
    def difference(self: Self, other: Self) -> float: ...
    def apply(self: Self, f: Callable[[Self], None]) -> None: ...
</code></pre>
<p>우리는 동일한 동작을 위해 <code>Self</code>를 직접 사용하는 것을 제안합니다.</p>
<pre><code class="language-python">from typing import Self

class Shape:
    def difference(self, other: Self) -> float: ...
    def apply(self, f: Callable[[Self], None]) -> None: ...
</code></pre>
<p><code>self: Self</code>를 명시하는 것이 무해하기 때문에, 일부 사용자들은 위 코드를 다음과 같이 작성하는 것이 더 읽기 쉽다고 생각할 수도 있습니다.</p>
<pre><code class="language-python">class Shape:
    def difference(self: Self, other: Self) -> float: ...
</code></pre>
<h3>속성 어노테이션에서의 사용 (Use in Attribute Annotations)</h3>
<p><code>Self</code>의 또 다른 용도는 속성(attribute)을 어노테이션하는 것입니다. 한 가지 예시는 요소가 현재 클래스의 서브클래스여야 하는 <code>LinkedList</code>를 가질 때입니다.</p>
<pre><code class="language-python">from dataclasses import dataclass
from typing import Generic, TypeVar

T = TypeVar("T")

@dataclass
class LinkedList(Generic[T]):
    value: T
    next: LinkedList[T] | None = None # OK
    # LinkedList[int](value=1, next=LinkedList[int](value=2)) # OK
    # LinkedList[int](value=1, next=LinkedList[str](value="hello")) # Not OK
</code></pre>
<p>그러나 <code>next</code> 속성을 <code>LinkedList[T]</code>로 어노테이션하면 서브클래스와 함께 유효하지 않은 구성이 허용됩니다.</p>
<pre><code class="language-python">@dataclass
class OrdinalLinkedList(LinkedList[int]):
    def ordinal_value(self) -> str:
        return as_ordinal(self.value)

# LinkedList[int]는 OrdinalLinkedList의 서브클래스가 아니므로
# 허용되어서는 안 되지만, 타입 검사기는 이를 허용합니다.
xs = OrdinalLinkedList(value=1, next=LinkedList[int](value=2))
if xs.next:
    print(xs.next.ordinal_value()) # 런타임 에러.
</code></pre>
<p>우리는 이 제약 조건을 <code>next: Self | None</code>을 사용하여 표현하는 것을 제안합니다.</p>
<pre><code class="language-python">from typing import Self
from dataclasses import dataclass
from typing import Generic, TypeVar

T = TypeVar("T")

@dataclass
class LinkedList(Generic[T]):
    value: T
    next: Self | None = None

@dataclass
class OrdinalLinkedList(LinkedList[int]):
    def ordinal_value(self) -> str:
        return str(self.value) # 예제에 맞게 변경

xs = OrdinalLinkedList(value=1, next=LinkedList[int](value=2))
# 타입 에러: OrdinalLinkedList가 예상되었지만, LinkedList[int]를 받았습니다.

if xs.next is not None:
    xs.next = OrdinalLinkedList(value=3, next=None) # OK
    xs.next = LinkedList[int](value=3, next=None) # Not OK (타입 에러)
</code></pre>
<p>위 코드는 <code>Self</code> 타입을 포함하는 각 속성을 해당 타입을 반환하는 <code>@property</code>처럼 취급하는 것과 의미론적으로 동일합니다.</p>
<pre><code class="language-python">from dataclasses import dataclass
from typing import Any, Generic, TypeVar

T = TypeVar("T")
Self = TypeVar("Self", bound="LinkedList") # 내부적으로 이렇게 처리될 수 있음

class LinkedList(Generic[T]):
    value: T
    _next: Any # 실제 내부 저장소

    @property
    def next(self: Self) -> Self | None:
        return self._next

    @next.setter
    def next(self: Self, next: Self | None) -> None:
        self._next = next

class OrdinalLinkedList(LinkedList[int]):
    def ordinal_value(self) -> str:
        return str(self.value)
</code></pre>
<h3>제네릭 클래스에서의 사용 (Use in Generic Classes)</h3>
<p><code>Self</code>는 제네릭(Generic) 클래스 메서드에서도 사용할 수 있습니다.</p>
<pre><code class="language-python">from typing import Generic, TypeVar

T = TypeVar("T")

class Container(Generic[T]):
    value: T
    def set_value(self, value: T) -> Self: ...
</code></pre>
<p>이는 다음 코드와 동일합니다.</p>
<pre><code class="language-python">from typing import Any, Generic, TypeVar

T = TypeVar("T")
Self = TypeVar("Self", bound="Container[Any]") # 내부적으로 이렇게 처리될 수 있음

class Container(Generic[T]):
    value: T
    def set_value(self: Self, value: T) -> Self: ...
</code></pre>
<p>동작은 메서드가 호출된 객체의 타입 인자(type argument)를 보존하는 것입니다. 구체적인 타입 <code>Container[int]</code>를 가진 객체에서 호출될 때, <code>Self</code>는 <code>Container[int]</code>에 바인딩됩니다. 제네릭 타입 <code>Container[T]</code>를 가진 객체에서 호출될 때, <code>Self</code>는 <code>Container[T]</code>에 바인딩됩니다.</p>
<pre><code class="language-python">def object_with_concrete_type() -> None:
    int_container: Container[int] = Container() # 실제 인스턴스화
    str_container: Container[str] = Container() # 실제 인스턴스화
    # reveal_type(int_container.set_value(42)) # => Container[int] (타입 검사기에서)
    # reveal_type(str_container.set_value("hello")) # => Container[str] (타입 검사기에서)

def object_with_generic_type(
    container: Container[T],
    value: T,
) -> Container[T]:
    return container.set_value(value) # => Container[T]
</code></pre>
<p>이 PEP는 메서드 <code>set_value</code> 내 <code>self.value</code>의 정확한 타입을 명시하지 않습니다. 일부 타입 검사기는 <code>Self = TypeVar("Self", bound=Container[T])</code>와 같은 클래스-로컬 타입 변수를 사용하여 <code>Self</code> 타입을 구현하여 정확한 타입 <code>T</code>를 추론할 수 있습니다. 그러나 클래스-로컬 타입 변수가 표준화된 타입 시스템 기능이 아니라는 점을 감안할 때, <code>self.value</code>에 대해 <code>Any</code>를 추론하는 것도 허용됩니다. 이 부분은 타입 검사기에게 맡겨집니다.</p>
<p><code>Self[int]</code>와 같이 타입 인자와 함께 <code>Self</code>를 사용하는 것은 거부됩니다. 이는 <code>self</code> 파라미터의 타입에 대한 모호성을 유발하고 불필요한 복잡성을 초래하기 때문입니다.</p>
<pre><code class="language-python">class Container(Generic[T]):
    def foo(
        self,
        other: Self[int], # 거부됨
        other2: Self,
    ) -> Self[str]: # 거부됨
        # ...
</code></pre>
<p>이러한 경우, <code>self</code>에 대해 명시적인 타입을 사용하는 것을 권장합니다.</p>
<pre><code class="language-python">class Container(Generic[T]):
    def foo(
        self: Container[T],
        other: Container[int],
        other2: Container[T]
    ) -> Container[str]: ...
</code></pre>
<h3>프로토콜에서의 사용 (Use in Protocols)</h3>
<p><code>Self</code>는 클래스에서의 사용과 유사하게 프로토콜(Protocol) 내에서도 유효합니다.</p>
<pre><code class="language-python">from typing import Protocol, Self

class ShapeProtocol(Protocol):
    scale: float
    def set_scale(self, scale: float) -> Self:
        self.scale = scale
        return self
</code></pre>
<p>위 코드는 다음 코드와 동일하게 처리됩니다.</p>
<pre><code class="language-python">from typing import TypeVar, Protocol

SelfShape = TypeVar("SelfShape", bound="ShapeProtocol")

class ShapeProtocol(Protocol):
    scale: float
    def set_scale(self: SelfShape, scale: float) -> SelfShape:
        self.scale = scale
        return self
</code></pre>
<p>프로토콜에 바운드된 <code>TypeVar</code>의 동작에 대한 자세한 내용은 PEP 544를 참조하세요.</p>
<p>클래스의 프로토콜 호환성 검사: 프로토콜이 메서드 또는 속성 어노테이션에 <code>Self</code>를 사용하는 경우, 클래스 <code>Foo</code>는 해당 메서드 및 속성 어노테이션에 <code>Self</code> 또는 <code>Foo</code> 또는 <code>Foo</code>의 서브클래스 중 하나를 사용하는 경우 프로토콜과 호환되는 것으로 간주됩니다. 다음 예시를 참조하세요.</p>
<pre><code class="language-python">from typing import Protocol

class ShapeProtocol(Protocol):
    def set_scale(self, scale: float) -> Self: ...

class ReturnSelf:
    scale: float = 1.0
    def set_scale(self, scale: float) -> Self:
        self.scale = scale
        return self

class ReturnConcreteShape:
    scale: float = 1.0
    def set_scale(self, scale: float) -> ReturnConcreteShape:
        self.scale = scale
        return self

class BadReturnType:
    scale: float = 1.0
    def set_scale(self, scale: float) -> int:
        self.scale = scale
        return 42

class ReturnDifferentClass:
    scale: float = 1.0
    def set_scale(self, scale: float) -> ReturnConcreteShape:
        return ReturnConcreteShape() # 인스턴스 생성

def accepts_shape(shape: ShapeProtocol) -> None:
    y = shape.set_scale(0.5)
    # reveal_type(y) # 타입 검사기에서 타입 확인

def main() -> None:
    return_self_shape: ReturnSelf
    return_concrete_shape: ReturnConcreteShape
    bad_return_type: BadReturnType
    return_different_class: ReturnDifferentClass

    accepts_shape(return_self_shape) # OK
    accepts_shape(return_concrete_shape) # OK
    accepts_shape(bad_return_type) # Not OK (반환 타입이 int이므로)
    # Not OK (서브클래스가 아닌 다른 클래스를 반환하므로)
    accepts_shape(return_different_class)
</code></pre>
<h3><code>Self</code>의 유효한 위치 (Valid Locations for Self)</h3>
<p><code>Self</code> 어노테이션은 클래스 컨텍스트 내에서만 유효하며, 항상 감싸는(encapsulating) 클래스를 참조합니다. 중첩된 클래스(nested classes)를 포함하는 컨텍스트에서는 <code>Self</code>가 항상 가장 안쪽 클래스를 참조합니다.</p>
<p>다음과 같은 <code>Self</code> 사용은 허용됩니다.</p>
<pre><code class="language-python">class ReturnsSelf:
    def foo(self) -> Self: ... # 허용됨
    @classmethod
    def bar(cls) -> Self: # 허용됨
        return cls()
    def __new__(cls, value: int) -> Self: ... # 허용됨
    def explicitly_use_self(self: Self) -> Self: ... # 허용됨
    # 허용됨 (Self는 다른 타입 내에 중첩될 수 있습니다)
    def returns_list(self) -> list[Self]: ... # 허용됨 (Self는 다른 타입 내에 중첩될 수 있습니다)
    @classmethod
    def return_cls(cls) -> type[Self]: return cls

class Child(ReturnsSelf): # 허용됨 (Self 어노테이션을 사용하는 메서드를 오버라이드할 수 있습니다)
    def foo(self) -> Self: ...

class TakesSelf:
    def foo(self, other: Self) -> bool: ... # 허용됨

class Recursive: # 허용됨 (@property가 Self | None을 반환하는 것으로 처리됩니다)
    next: Self | None

class CallableAttribute:
    def foo(self) -> int: ...
    # 허용됨 (@property가 Callable 타입을 반환하는 것으로 처리됩니다)
    bar: Callable[[Self], int] = foo

class HasNestedFunction:
    x: int = 42
    def foo(self) -> None:
        # 허용됨 (Self는 HasNestedFunction에 바인딩됩니다).
        def nested(z: int, inner_self: Self) -> Self:
            print(z)
            print(inner_self.x)
            return inner_self
        nested(42, self) # OK

class Outer:
    class Inner:
        def foo(self) -> Self: ... # 허용됨 (Self는 Inner에 바인딩됩니다)
</code></pre>
<p>다음과 같은 <code>Self</code> 사용은 거부됩니다.</p>
<pre><code class="language-python">def foo(bar: Self) -> Self: ... # 거부됨 (클래스 내부에 있지 않음)
bar: Self # 거부됨 (클래스 내부에 있지 않음)

class Foo:
    # 거부됨 (Self는 unknown으로 처리됩니다).
    def has_existing_self_annotation(self: T) -> Self: ...

class Foo:
    def return_concrete_type(self) -> Self:
        return Foo() # 거부됨 (아래 FooChild 참조)

class FooChild(Foo):
    child_value: int = 42
    def child_method(self) -> None:
        # 런타임 시, 이것은 Foo이며 FooChild가 아닙니다.
        y = self.return_concrete_type()
        # y.child_value # 런타임 에러: Foo에는 child_value 속성이 없습니다.
        # 위 시나리오가 문제가 되므로, Self를 반환할 때는 해당 서브클래스의 인스턴스를
        # 생성하여 반환해야 합니다 (예: return self.__class__())
</code></pre>
<pre><code class="language-python">class Bar(Generic[T]):
    def bar(self) -> T: ...
class Baz(Bar[Self]): ... # 거부됨
</code></pre>
<p><code>Self</code>를 포함하는 타입 별칭(type aliases)은 거부됩니다. 클래스 정의 외부에서 <code>Self</code>를 지원하려면 타입 검사기에서 많은 특별 처리가 필요할 수 있습니다. 또한 <code>Self</code>를 클래스 정의 외부에서 사용하는 것이 이 PEP의 나머지 부분과도 상반된다는 점을 고려할 때, 별칭의 추가적인 편리함이 그만한 가치가 있다고 보지 않습니다.</p>
<pre><code class="language-python">TupleSelf = Tuple[Self, Self] # 거부됨
class Alias:
    def return_tuple(self) -> TupleSelf: # 거부됨
        return (self, self)
</code></pre>
<p><code>staticmethod</code>에서는 <code>Self</code>가 거부됩니다. <code>self</code>나 <code>cls</code>를 반환할 필요가 없으므로 <code>Self</code>는 큰 가치를 추가하지 않습니다. 유일하게 가능한 사용 사례는 파라미터 자체를 반환하거나 파라미터로 전달된 컨테이너의 요소를 반환하는 것일 것입니다. 이러한 것들은 추가적인 복잡성만큼의 가치가 없는 것으로 판단됩니다.</p>
<pre><code class="language-python">class Base:
    @staticmethod
    def make() -> Self: # 거부됨
        ...
    @staticmethod
    def return_parameter(foo: Self) -> Self: # 거부됨
        ...
</code></pre>
<p>마찬가지로, 메타클래스(metaclasses)에서는 <code>Self</code>가 거부됩니다. 이 PEP의 <code>Self</code>는 일관되게 동일한 타입(<code>self</code>의 타입)을 참조합니다. 하지만 메타클래스에서는 서로 다른 메서드 시그니처에서 다른 타입을 참조해야 할 것입니다. 예를 들어, <code>__mul__</code>에서 반환 타입의 <code>Self</code>는 감싸는 클래스 <code>MyMetaclass</code>가 아닌 구현 클래스 <code>Foo</code>를 참조할 것입니다. 그러나 <code>__new__</code>에서는 반환 타입의 <code>Self</code>가 감싸는 클래스 <code>MyMetaclass</code>를 참조할 것입니다. 혼동을 피하기 위해 이 예외적인 경우는 거부됩니다.</p>
<pre><code class="language-python">class MyMetaclass(type):
    def __new__(cls, *args: Any) -> Self: # 거부됨
        return super().__new__(cls, *args)
    def __mul__(cls, count: int) -> list[Self]: # 거부됨
        return [cls()] * count

class Foo(metaclass=MyMetaclass): ...
</code></pre>
<h2>런타임 동작 (Runtime behavior)</h2>
<p><code>Self</code>는 subscriptable(첨자 사용 가능)하지 않으므로, <code>typing.NoReturn</code>과 유사한 구현을 제안합니다.</p>
<pre><code class="language-python">@_SpecialForm
def Self(self, params):
    """클래스에서 "self"의 타입을 나타내는 데 사용됩니다.
    예시::
        from typing import Self
        class ReturnsSelf:
            def parse(self, data: bytes) -> Self:
                ...
                return self
    """
    raise TypeError(f"{self} is not subscriptable")
</code></pre>
<h2>거부된 대안 (Rejected Alternatives)</h2>
<h3>타입 검사기가 반환 타입을 추론하도록 허용 (Allow the Type Checker to Infer the Return Type)</h3>
<p>한 가지 제안은 <code>Self</code> 타입을 암묵적으로 두고, 타입 검사기가 메서드 본문을 분석하여 반환 타입이 <code>self</code> 파라미터의 타입과 동일해야 한다고 추론하도록 하는 것입니다.</p>
<pre><code class="language-python">class Shape:
    def set_scale(self, scale: float):
        self.scale = scale
        return self # 타입 검사기가 self를 반환한다는 것을 추론합니다.
</code></pre>
<p>우리는 "명시적인 것이 암묵적인 것보다 낫다(Explicit Is Better Than Implicit)"는 이유로 이를 거부합니다. 또한, 위 접근 방식은 분석할 메서드 본문이 없는 타입 스텁(type stubs)에서는 실패할 것입니다.</p>
<h2>참고 구현 (Reference Implementations)</h2>
<ul>
<li>Mypy: Mypy의 개념 증명(Proof of concept) 구현.</li>
<li>Pyright: v1.1.184</li>
<li>Self의 런타임 구현: PR.</li>
</ul>
<h2>자료 (Resources)</h2>
<p>Python의 <code>Self</code> 타입에 대한 유사한 논의는 2016년경 Mypy에서 시작되었습니다. Mypy issue #1212 - SelfType or another way to spell “type of self”를 참조하세요. 그러나 최종적으로 채택된 접근 방식은 "before" 예시에서 보여진 바운드된 <code>TypeVar</code> 접근 방식이었습니다. 이와 관련된 다른 이슈로는 Mypy issue #2354 - Self types in generic classes가 있습니다.</p>
<p>Pradeep은 PyCon Typing Summit 2021에서 구체적인 제안을 발표했습니다. (녹화된 발표, 슬라이드 참조). James는 typing-sig에서 독립적으로 이 제안을 제기했습니다. (Typing-sig 스레드 참조).</p>
<p>다른 언어들도 감싸는 클래스의 타입을 표현하는 유사한 방법을 가지고 있습니다.</p>
<ul>
<li>TypeScript는 <code>this</code> 타입을 가지고 있습니다 (TypeScript docs).</li>
<li>Rust는 <code>Self</code> 타입을 가지고 있습니다 (Rust docs).</li>
</ul>
<p>이 PEP에 대한 피드백을 주신 다음 분들께 감사드립니다.
Jia Chen, Rebecca Chen, Sergei Lebedev, Kaylynn Morgan, Tuomas Suutari, Eric Traut, Alex Waygood, Shannon Zhu, and Никита Соболев.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 조건으로 배포됩니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/673\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"e6YNzZ2BVZ8NBZ6boXfWj\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/673/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/673\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"673\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/673\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T6f40,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0673/\"\u003ePEP 673 - Self Type\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 10-Nov-2021\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 673 – \u003ccode\u003eSelf\u003c/code\u003e 타입\u003c/h1\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 메서드가 자신의 클래스 인스턴스를 반환할 때 이를 어노테이션(annotation)하는 간단하고 직관적인 방법을 제안합니다. 이 방식은 기존의 \u003ccode\u003eTypeVar\u003c/code\u003e 기반 접근 방식(PEP 484에 명시됨)과 동일하게 작동하지만, 더 간결하고 이해하기 쉽습니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e자신의 클래스와 동일한 인스턴스를 반환하는 메서드를 작성하는 것은 흔한 사용 사례입니다. 예를 들어, 일반적으로 \u003ccode\u003eself\u003c/code\u003e를 반환하는 경우입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Shape:\r\n    def set_scale(self, scale: float):\r\n        self.scale = scale\r\n        return self\r\n\r\nShape().set_scale(0.5) # =\u003e Shape 타입이어야 합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e반환 타입을 명시하는 한 가지 방법은 현재 클래스(예: \u003ccode\u003eShape\u003c/code\u003e)로 지정하는 것입니다. 이 메서드를 사용하면 타입 검사기가 예상대로 \u003ccode\u003eShape\u003c/code\u003e 타입을 추론합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Shape:\r\n    def set_scale(self, scale: float) -\u003e Shape:\r\n        self.scale = scale\r\n        return self\r\n\r\nShape().set_scale(0.5) # =\u003e Shape\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 \u003ccode\u003eShape\u003c/code\u003e의 서브클래스에서 \u003ccode\u003eset_scale\u003c/code\u003e을 호출하면, 타입 검사기는 여전히 반환 타입을 \u003ccode\u003eShape\u003c/code\u003e으로 추론합니다. 이는 아래와 같은 상황에서 문제가 될 수 있습니다. 예를 들어, 기본 클래스에는 없는 속성이나 메서드를 사용하려고 할 때 타입 검사기가 오류를 발생시킵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Circle(Shape):\r\n    def set_radius(self, r: float) -\u003e Circle:\r\n        self.radius = r\r\n        return self\r\n\r\nCircle().set_scale(0.5) # *Shape* 타입으로 추론, Circle이 아님\r\nCircle().set_scale(0.5).set_radius(2.7) # =\u003e 에러: Shape에는 set_radius 속성이 없습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 경우에 대한 현재의 해결책은 \u003ccode\u003eTypeVar\u003c/code\u003e를 정의하고, 기본 클래스를 바운드(bound)로 지정한 후, 이를 \u003ccode\u003eself\u003c/code\u003e 파라미터와 반환 타입의 어노테이션으로 사용하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import TypeVar\r\n\r\nTShape = TypeVar(\"TShape\", bound=\"Shape\")\r\n\r\nclass Shape:\r\n    def set_scale(self: TShape, scale: float) -\u003e TShape:\r\n        self.scale = scale\r\n        return self\r\n\r\nclass Circle(Shape):\r\n    def set_radius(self, radius: float) -\u003e Circle:\r\n        self.radius = radius\r\n        return self\r\n\r\nCircle().set_scale(0.5).set_radius(2.7) # =\u003e Circle\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 이 방법은 장황하고 직관적이지 않습니다. \u003ccode\u003eself\u003c/code\u003e는 일반적으로 명시적으로 어노테이션되지 않기 때문에, 위의 해결책은 쉽게 떠오르지 않을 뿐더러, \u003ccode\u003eTypeVar\u003c/code\u003e의 바운드(\u003ccode\u003ebound=\"Shape\"\u003c/code\u003e)나 \u003ccode\u003eself\u003c/code\u003e에 대한 어노테이션을 잊어버리기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e이러한 어려움 때문에 사용자들은 종종 포기하고 \u003ccode\u003eAny\u003c/code\u003e와 같은 대체 타입을 사용하거나, 아예 타입 어노테이션을 생략하게 됩니다. 이 두 가지 모두 코드의 타입 안전성(type safety)을 떨어뜨립니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 위의 의도를 표현하는 더 직관적이고 간결한 방법을 제안합니다. 우리는 감싸고 있는(encapsulating) 클래스에 바운드된 타입 변수를 나타내는 특별한 형태인 \u003ccode\u003eSelf\u003c/code\u003e를 도입합니다. 위와 같은 상황에서, 사용자는 단순히 반환 타입을 \u003ccode\u003eSelf\u003c/code\u003e로 어노테이션하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Self\r\n\r\nclass Shape:\r\n    def set_scale(self, scale: float) -\u003e Self:\r\n        self.scale = scale\r\n        return self\r\n\r\nclass Circle(Shape):\r\n    def set_radius(self, radius: float) -\u003e Self:\r\n        self.radius = radius\r\n        return self\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e반환 타입을 \u003ccode\u003eSelf\u003c/code\u003e로 어노테이션함으로써, 우리는 더 이상 기본 클래스에 명시적인 바운드를 가진 \u003ccode\u003eTypeVar\u003c/code\u003e를 선언할 필요가 없습니다. 반환 타입 \u003ccode\u003eSelf\u003c/code\u003e는 함수가 \u003ccode\u003eself\u003c/code\u003e를 반환한다는 사실을 반영하며 이해하기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e위 예제에서처럼, 타입 검사기는 \u003ccode\u003eCircle().set_scale(0.5)\u003c/code\u003e의 타입을 예상대로 \u003ccode\u003eCircle\u003c/code\u003e로 정확하게 추론할 것입니다.\u003c/p\u003e\n\u003ch3\u003e사용 통계 (Usage statistics)\u003c/h3\u003e\n\u003cp\u003e우리는 인기 있는 오픈 소스 프로젝트들을 분석했으며, 위와 같은 패턴이 \u003ccode\u003edict\u003c/code\u003e 또는 \u003ccode\u003eCallable\u003c/code\u003e과 같은 인기 있는 타입만큼 자주 사용된다는 것을 발견했습니다 (약 40%). 예를 들어, 2021년 10월 기준으로 typeshed에서만 이러한 \"Self\" 타입은 523회 사용되었으며, \u003ccode\u003edict\u003c/code\u003e는 1286회, \u003ccode\u003eCallable\u003c/code\u003e은 1314회 사용되었습니다. 이는 \u003ccode\u003eSelf\u003c/code\u003e 타입이 상당히 자주 사용될 것이며, 사용자들은 이 더 간단한 접근 방식으로부터 많은 이점을 얻을 수 있음을 시사합니다.\u003c/p\u003e\n\u003cp\u003ePython 타입 사용자들도 제안 문서와 GitHub에서 이 기능을 자주 요청했습니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003ch3\u003e메서드 시그니처에서의 사용 (Use in Method Signatures)\u003c/h3\u003e\n\u003cp\u003e메서드 시그니처에서 사용되는 \u003ccode\u003eSelf\u003c/code\u003e는 해당 클래스에 바운드된 \u003ccode\u003eTypeVar\u003c/code\u003e처럼 처리됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Self\r\n\r\nclass Shape:\r\n    def set_scale(self, scale: float) -\u003e Self:\r\n        self.scale = scale\r\n        return self\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 다음 코드와 동일하게 처리됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import TypeVar\r\n\r\nSelfShape = TypeVar(\"SelfShape\", bound=\"Shape\")\r\n\r\nclass Shape:\r\n    def set_scale(self: SelfShape, scale: float) -\u003e SelfShape:\r\n        self.scale = scale\r\n        return self\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 서브클래스에서도 동일하게 작동합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Circle(Shape):\r\n    def set_radius(self, radius: float) -\u003e Self:\r\n        self.radius = radius\r\n        return self\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 다음 코드와 동일하게 처리됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eSelfCircle = TypeVar(\"SelfCircle\", bound=\"Circle\")\r\n\r\nclass Circle(Shape):\r\n    def set_radius(self: SelfCircle, radius: float) -\u003e SelfCircle:\r\n        self.radius = radius\r\n        return self\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e한 가지 구현 전략은 전처리 단계에서 전자를 후자로 단순히 \"desugar\"(구문 설탕 제거)하는 것입니다. 메서드가 시그니처에 \u003ccode\u003eSelf\u003c/code\u003e를 사용하면, 메서드 내 \u003ccode\u003eself\u003c/code\u003e의 타입은 \u003ccode\u003eSelf\u003c/code\u003e가 됩니다. 다른 경우에는 \u003ccode\u003eself\u003c/code\u003e의 타입은 감싸는(enclosing) 클래스로 유지됩니다.\u003c/p\u003e\n\u003ch3\u003e클래스메서드 시그니처에서의 사용 (Use in Classmethod Signatures)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eSelf\u003c/code\u003e 타입 어노테이션은 자신이 작동하는 클래스의 인스턴스를 반환하는 클래스메서드(classmethod)에서도 유용합니다. 예를 들어, 다음 스니펫의 \u003ccode\u003efrom_config\u003c/code\u003e는 주어진 \u003ccode\u003econfig\u003c/code\u003e로부터 \u003ccode\u003eShape\u003c/code\u003e 객체를 만듭니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Shape:\r\n    def __init__(self, scale: float) -\u003e None: ...\r\n    @classmethod\r\n    def from_config(cls, config: dict[str, float]) -\u003e Shape:\r\n        return cls(config[\"scale\"])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 이렇게 하면 \u003ccode\u003eCircle.from_config(...)\u003c/code\u003e가 \u003ccode\u003eShape\u003c/code\u003e 타입의 값을 반환하는 것으로 추론되는데, 실제로는 \u003ccode\u003eCircle\u003c/code\u003e이어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Circle(Shape):\r\n    def circumference(self) -\u003e float: ...\r\n\r\nshape = Shape.from_config({\"scale\": 7.0}) # =\u003e Shape\r\ncircle = Circle.from_config({\"scale\": 7.0}) # =\u003e *Shape* 타입으로 추론, Circle이 아님\r\ncircle.circumference() # 에러: `Shape`에는 `circumference` 속성이 없습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이에 대한 현재의 해결책은 직관적이지 않고 오류 발생 가능성이 높습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eSelf = TypeVar(\"Self\", bound=\"Shape\") # TypeVar 이름 충돌을 피하기 위해 이름을 다르게 할 수도 있습니다.\r\n\r\nclass Shape:\r\n    @classmethod\r\n    def from_config(\r\n        cls: type[Self], # 복잡한 어노테이션\r\n        config: dict[str, float]\r\n    ) -\u003e Self:\r\n        return cls(config[\"scale\"])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 \u003ccode\u003eSelf\u003c/code\u003e를 직접 사용하는 것을 제안합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Self\r\n\r\nclass Shape:\r\n    @classmethod\r\n    def from_config(cls, config: dict[str, float]) -\u003e Self:\r\n        return cls(config[\"scale\"])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 복잡한 \u003ccode\u003ecls: type[Self]\u003c/code\u003e 어노테이션과 바운드가 있는 \u003ccode\u003eTypeVar\u003c/code\u003e 선언을 피하게 해줍니다. 다시 말하지만, 후자의 코드는 전자의 코드와 동일하게 동작합니다.\u003c/p\u003e\n\u003ch3\u003e파라미터 타입에서의 사용 (Use in Parameter Types)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eSelf\u003c/code\u003e의 또 다른 용도는 현재 클래스의 인스턴스를 기대하는 파라미터를 어노테이션하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eSelf = TypeVar(\"Self\", bound=\"Shape\")\r\n\r\nclass Shape:\r\n    def difference(self: Self, other: Self) -\u003e float: ...\r\n    def apply(self: Self, f: Callable[[Self], None]) -\u003e None: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 동일한 동작을 위해 \u003ccode\u003eSelf\u003c/code\u003e를 직접 사용하는 것을 제안합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Self\r\n\r\nclass Shape:\r\n    def difference(self, other: Self) -\u003e float: ...\r\n    def apply(self, f: Callable[[Self], None]) -\u003e None: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eself: Self\u003c/code\u003e를 명시하는 것이 무해하기 때문에, 일부 사용자들은 위 코드를 다음과 같이 작성하는 것이 더 읽기 쉽다고 생각할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Shape:\r\n    def difference(self: Self, other: Self) -\u003e float: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e속성 어노테이션에서의 사용 (Use in Attribute Annotations)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eSelf\u003c/code\u003e의 또 다른 용도는 속성(attribute)을 어노테이션하는 것입니다. 한 가지 예시는 요소가 현재 클래스의 서브클래스여야 하는 \u003ccode\u003eLinkedList\u003c/code\u003e를 가질 때입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom dataclasses import dataclass\r\nfrom typing import Generic, TypeVar\r\n\r\nT = TypeVar(\"T\")\r\n\r\n@dataclass\r\nclass LinkedList(Generic[T]):\r\n    value: T\r\n    next: LinkedList[T] | None = None # OK\r\n    # LinkedList[int](value=1, next=LinkedList[int](value=2)) # OK\r\n    # LinkedList[int](value=1, next=LinkedList[str](value=\"hello\")) # Not OK\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 \u003ccode\u003enext\u003c/code\u003e 속성을 \u003ccode\u003eLinkedList[T]\u003c/code\u003e로 어노테이션하면 서브클래스와 함께 유효하지 않은 구성이 허용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@dataclass\r\nclass OrdinalLinkedList(LinkedList[int]):\r\n    def ordinal_value(self) -\u003e str:\r\n        return as_ordinal(self.value)\r\n\r\n# LinkedList[int]는 OrdinalLinkedList의 서브클래스가 아니므로\r\n# 허용되어서는 안 되지만, 타입 검사기는 이를 허용합니다.\r\nxs = OrdinalLinkedList(value=1, next=LinkedList[int](value=2))\r\nif xs.next:\r\n    print(xs.next.ordinal_value()) # 런타임 에러.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 이 제약 조건을 \u003ccode\u003enext: Self | None\u003c/code\u003e을 사용하여 표현하는 것을 제안합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Self\r\nfrom dataclasses import dataclass\r\nfrom typing import Generic, TypeVar\r\n\r\nT = TypeVar(\"T\")\r\n\r\n@dataclass\r\nclass LinkedList(Generic[T]):\r\n    value: T\r\n    next: Self | None = None\r\n\r\n@dataclass\r\nclass OrdinalLinkedList(LinkedList[int]):\r\n    def ordinal_value(self) -\u003e str:\r\n        return str(self.value) # 예제에 맞게 변경\r\n\r\nxs = OrdinalLinkedList(value=1, next=LinkedList[int](value=2))\r\n# 타입 에러: OrdinalLinkedList가 예상되었지만, LinkedList[int]를 받았습니다.\r\n\r\nif xs.next is not None:\r\n    xs.next = OrdinalLinkedList(value=3, next=None) # OK\r\n    xs.next = LinkedList[int](value=3, next=None) # Not OK (타입 에러)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 \u003ccode\u003eSelf\u003c/code\u003e 타입을 포함하는 각 속성을 해당 타입을 반환하는 \u003ccode\u003e@property\u003c/code\u003e처럼 취급하는 것과 의미론적으로 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom dataclasses import dataclass\r\nfrom typing import Any, Generic, TypeVar\r\n\r\nT = TypeVar(\"T\")\r\nSelf = TypeVar(\"Self\", bound=\"LinkedList\") # 내부적으로 이렇게 처리될 수 있음\r\n\r\nclass LinkedList(Generic[T]):\r\n    value: T\r\n    _next: Any # 실제 내부 저장소\r\n\r\n    @property\r\n    def next(self: Self) -\u003e Self | None:\r\n        return self._next\r\n\r\n    @next.setter\r\n    def next(self: Self, next: Self | None) -\u003e None:\r\n        self._next = next\r\n\r\nclass OrdinalLinkedList(LinkedList[int]):\r\n    def ordinal_value(self) -\u003e str:\r\n        return str(self.value)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e제네릭 클래스에서의 사용 (Use in Generic Classes)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eSelf\u003c/code\u003e는 제네릭(Generic) 클래스 메서드에서도 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Generic, TypeVar\r\n\r\nT = TypeVar(\"T\")\r\n\r\nclass Container(Generic[T]):\r\n    value: T\r\n    def set_value(self, value: T) -\u003e Self: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 다음 코드와 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Any, Generic, TypeVar\r\n\r\nT = TypeVar(\"T\")\r\nSelf = TypeVar(\"Self\", bound=\"Container[Any]\") # 내부적으로 이렇게 처리될 수 있음\r\n\r\nclass Container(Generic[T]):\r\n    value: T\r\n    def set_value(self: Self, value: T) -\u003e Self: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e동작은 메서드가 호출된 객체의 타입 인자(type argument)를 보존하는 것입니다. 구체적인 타입 \u003ccode\u003eContainer[int]\u003c/code\u003e를 가진 객체에서 호출될 때, \u003ccode\u003eSelf\u003c/code\u003e는 \u003ccode\u003eContainer[int]\u003c/code\u003e에 바인딩됩니다. 제네릭 타입 \u003ccode\u003eContainer[T]\u003c/code\u003e를 가진 객체에서 호출될 때, \u003ccode\u003eSelf\u003c/code\u003e는 \u003ccode\u003eContainer[T]\u003c/code\u003e에 바인딩됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef object_with_concrete_type() -\u003e None:\r\n    int_container: Container[int] = Container() # 실제 인스턴스화\r\n    str_container: Container[str] = Container() # 실제 인스턴스화\r\n    # reveal_type(int_container.set_value(42)) # =\u003e Container[int] (타입 검사기에서)\r\n    # reveal_type(str_container.set_value(\"hello\")) # =\u003e Container[str] (타입 검사기에서)\r\n\r\ndef object_with_generic_type(\r\n    container: Container[T],\r\n    value: T,\r\n) -\u003e Container[T]:\r\n    return container.set_value(value) # =\u003e Container[T]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 PEP는 메서드 \u003ccode\u003eset_value\u003c/code\u003e 내 \u003ccode\u003eself.value\u003c/code\u003e의 정확한 타입을 명시하지 않습니다. 일부 타입 검사기는 \u003ccode\u003eSelf = TypeVar(\"Self\", bound=Container[T])\u003c/code\u003e와 같은 클래스-로컬 타입 변수를 사용하여 \u003ccode\u003eSelf\u003c/code\u003e 타입을 구현하여 정확한 타입 \u003ccode\u003eT\u003c/code\u003e를 추론할 수 있습니다. 그러나 클래스-로컬 타입 변수가 표준화된 타입 시스템 기능이 아니라는 점을 감안할 때, \u003ccode\u003eself.value\u003c/code\u003e에 대해 \u003ccode\u003eAny\u003c/code\u003e를 추론하는 것도 허용됩니다. 이 부분은 타입 검사기에게 맡겨집니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSelf[int]\u003c/code\u003e와 같이 타입 인자와 함께 \u003ccode\u003eSelf\u003c/code\u003e를 사용하는 것은 거부됩니다. 이는 \u003ccode\u003eself\u003c/code\u003e 파라미터의 타입에 대한 모호성을 유발하고 불필요한 복잡성을 초래하기 때문입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Container(Generic[T]):\r\n    def foo(\r\n        self,\r\n        other: Self[int], # 거부됨\r\n        other2: Self,\r\n    ) -\u003e Self[str]: # 거부됨\r\n        # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 경우, \u003ccode\u003eself\u003c/code\u003e에 대해 명시적인 타입을 사용하는 것을 권장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Container(Generic[T]):\r\n    def foo(\r\n        self: Container[T],\r\n        other: Container[int],\r\n        other2: Container[T]\r\n    ) -\u003e Container[str]: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e프로토콜에서의 사용 (Use in Protocols)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eSelf\u003c/code\u003e는 클래스에서의 사용과 유사하게 프로토콜(Protocol) 내에서도 유효합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Protocol, Self\r\n\r\nclass ShapeProtocol(Protocol):\r\n    scale: float\r\n    def set_scale(self, scale: float) -\u003e Self:\r\n        self.scale = scale\r\n        return self\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 다음 코드와 동일하게 처리됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import TypeVar, Protocol\r\n\r\nSelfShape = TypeVar(\"SelfShape\", bound=\"ShapeProtocol\")\r\n\r\nclass ShapeProtocol(Protocol):\r\n    scale: float\r\n    def set_scale(self: SelfShape, scale: float) -\u003e SelfShape:\r\n        self.scale = scale\r\n        return self\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프로토콜에 바운드된 \u003ccode\u003eTypeVar\u003c/code\u003e의 동작에 대한 자세한 내용은 PEP 544를 참조하세요.\u003c/p\u003e\n\u003cp\u003e클래스의 프로토콜 호환성 검사: 프로토콜이 메서드 또는 속성 어노테이션에 \u003ccode\u003eSelf\u003c/code\u003e를 사용하는 경우, 클래스 \u003ccode\u003eFoo\u003c/code\u003e는 해당 메서드 및 속성 어노테이션에 \u003ccode\u003eSelf\u003c/code\u003e 또는 \u003ccode\u003eFoo\u003c/code\u003e 또는 \u003ccode\u003eFoo\u003c/code\u003e의 서브클래스 중 하나를 사용하는 경우 프로토콜과 호환되는 것으로 간주됩니다. 다음 예시를 참조하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Protocol\r\n\r\nclass ShapeProtocol(Protocol):\r\n    def set_scale(self, scale: float) -\u003e Self: ...\r\n\r\nclass ReturnSelf:\r\n    scale: float = 1.0\r\n    def set_scale(self, scale: float) -\u003e Self:\r\n        self.scale = scale\r\n        return self\r\n\r\nclass ReturnConcreteShape:\r\n    scale: float = 1.0\r\n    def set_scale(self, scale: float) -\u003e ReturnConcreteShape:\r\n        self.scale = scale\r\n        return self\r\n\r\nclass BadReturnType:\r\n    scale: float = 1.0\r\n    def set_scale(self, scale: float) -\u003e int:\r\n        self.scale = scale\r\n        return 42\r\n\r\nclass ReturnDifferentClass:\r\n    scale: float = 1.0\r\n    def set_scale(self, scale: float) -\u003e ReturnConcreteShape:\r\n        return ReturnConcreteShape() # 인스턴스 생성\r\n\r\ndef accepts_shape(shape: ShapeProtocol) -\u003e None:\r\n    y = shape.set_scale(0.5)\r\n    # reveal_type(y) # 타입 검사기에서 타입 확인\r\n\r\ndef main() -\u003e None:\r\n    return_self_shape: ReturnSelf\r\n    return_concrete_shape: ReturnConcreteShape\r\n    bad_return_type: BadReturnType\r\n    return_different_class: ReturnDifferentClass\r\n\r\n    accepts_shape(return_self_shape) # OK\r\n    accepts_shape(return_concrete_shape) # OK\r\n    accepts_shape(bad_return_type) # Not OK (반환 타입이 int이므로)\r\n    # Not OK (서브클래스가 아닌 다른 클래스를 반환하므로)\r\n    accepts_shape(return_different_class)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003ccode\u003eSelf\u003c/code\u003e의 유효한 위치 (Valid Locations for Self)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eSelf\u003c/code\u003e 어노테이션은 클래스 컨텍스트 내에서만 유효하며, 항상 감싸는(encapsulating) 클래스를 참조합니다. 중첩된 클래스(nested classes)를 포함하는 컨텍스트에서는 \u003ccode\u003eSelf\u003c/code\u003e가 항상 가장 안쪽 클래스를 참조합니다.\u003c/p\u003e\n\u003cp\u003e다음과 같은 \u003ccode\u003eSelf\u003c/code\u003e 사용은 허용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass ReturnsSelf:\r\n    def foo(self) -\u003e Self: ... # 허용됨\r\n    @classmethod\r\n    def bar(cls) -\u003e Self: # 허용됨\r\n        return cls()\r\n    def __new__(cls, value: int) -\u003e Self: ... # 허용됨\r\n    def explicitly_use_self(self: Self) -\u003e Self: ... # 허용됨\r\n    # 허용됨 (Self는 다른 타입 내에 중첩될 수 있습니다)\r\n    def returns_list(self) -\u003e list[Self]: ... # 허용됨 (Self는 다른 타입 내에 중첩될 수 있습니다)\r\n    @classmethod\r\n    def return_cls(cls) -\u003e type[Self]: return cls\r\n\r\nclass Child(ReturnsSelf): # 허용됨 (Self 어노테이션을 사용하는 메서드를 오버라이드할 수 있습니다)\r\n    def foo(self) -\u003e Self: ...\r\n\r\nclass TakesSelf:\r\n    def foo(self, other: Self) -\u003e bool: ... # 허용됨\r\n\r\nclass Recursive: # 허용됨 (@property가 Self | None을 반환하는 것으로 처리됩니다)\r\n    next: Self | None\r\n\r\nclass CallableAttribute:\r\n    def foo(self) -\u003e int: ...\r\n    # 허용됨 (@property가 Callable 타입을 반환하는 것으로 처리됩니다)\r\n    bar: Callable[[Self], int] = foo\r\n\r\nclass HasNestedFunction:\r\n    x: int = 42\r\n    def foo(self) -\u003e None:\r\n        # 허용됨 (Self는 HasNestedFunction에 바인딩됩니다).\r\n        def nested(z: int, inner_self: Self) -\u003e Self:\r\n            print(z)\r\n            print(inner_self.x)\r\n            return inner_self\r\n        nested(42, self) # OK\r\n\r\nclass Outer:\r\n    class Inner:\r\n        def foo(self) -\u003e Self: ... # 허용됨 (Self는 Inner에 바인딩됩니다)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 같은 \u003ccode\u003eSelf\u003c/code\u003e 사용은 거부됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef foo(bar: Self) -\u003e Self: ... # 거부됨 (클래스 내부에 있지 않음)\r\nbar: Self # 거부됨 (클래스 내부에 있지 않음)\r\n\r\nclass Foo:\r\n    # 거부됨 (Self는 unknown으로 처리됩니다).\r\n    def has_existing_self_annotation(self: T) -\u003e Self: ...\r\n\r\nclass Foo:\r\n    def return_concrete_type(self) -\u003e Self:\r\n        return Foo() # 거부됨 (아래 FooChild 참조)\r\n\r\nclass FooChild(Foo):\r\n    child_value: int = 42\r\n    def child_method(self) -\u003e None:\r\n        # 런타임 시, 이것은 Foo이며 FooChild가 아닙니다.\r\n        y = self.return_concrete_type()\r\n        # y.child_value # 런타임 에러: Foo에는 child_value 속성이 없습니다.\r\n        # 위 시나리오가 문제가 되므로, Self를 반환할 때는 해당 서브클래스의 인스턴스를\r\n        # 생성하여 반환해야 합니다 (예: return self.__class__())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Bar(Generic[T]):\r\n    def bar(self) -\u003e T: ...\r\nclass Baz(Bar[Self]): ... # 거부됨\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eSelf\u003c/code\u003e를 포함하는 타입 별칭(type aliases)은 거부됩니다. 클래스 정의 외부에서 \u003ccode\u003eSelf\u003c/code\u003e를 지원하려면 타입 검사기에서 많은 특별 처리가 필요할 수 있습니다. 또한 \u003ccode\u003eSelf\u003c/code\u003e를 클래스 정의 외부에서 사용하는 것이 이 PEP의 나머지 부분과도 상반된다는 점을 고려할 때, 별칭의 추가적인 편리함이 그만한 가치가 있다고 보지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eTupleSelf = Tuple[Self, Self] # 거부됨\r\nclass Alias:\r\n    def return_tuple(self) -\u003e TupleSelf: # 거부됨\r\n        return (self, self)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003estaticmethod\u003c/code\u003e에서는 \u003ccode\u003eSelf\u003c/code\u003e가 거부됩니다. \u003ccode\u003eself\u003c/code\u003e나 \u003ccode\u003ecls\u003c/code\u003e를 반환할 필요가 없으므로 \u003ccode\u003eSelf\u003c/code\u003e는 큰 가치를 추가하지 않습니다. 유일하게 가능한 사용 사례는 파라미터 자체를 반환하거나 파라미터로 전달된 컨테이너의 요소를 반환하는 것일 것입니다. 이러한 것들은 추가적인 복잡성만큼의 가치가 없는 것으로 판단됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Base:\r\n    @staticmethod\r\n    def make() -\u003e Self: # 거부됨\r\n        ...\r\n    @staticmethod\r\n    def return_parameter(foo: Self) -\u003e Self: # 거부됨\r\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마찬가지로, 메타클래스(metaclasses)에서는 \u003ccode\u003eSelf\u003c/code\u003e가 거부됩니다. 이 PEP의 \u003ccode\u003eSelf\u003c/code\u003e는 일관되게 동일한 타입(\u003ccode\u003eself\u003c/code\u003e의 타입)을 참조합니다. 하지만 메타클래스에서는 서로 다른 메서드 시그니처에서 다른 타입을 참조해야 할 것입니다. 예를 들어, \u003ccode\u003e__mul__\u003c/code\u003e에서 반환 타입의 \u003ccode\u003eSelf\u003c/code\u003e는 감싸는 클래스 \u003ccode\u003eMyMetaclass\u003c/code\u003e가 아닌 구현 클래스 \u003ccode\u003eFoo\u003c/code\u003e를 참조할 것입니다. 그러나 \u003ccode\u003e__new__\u003c/code\u003e에서는 반환 타입의 \u003ccode\u003eSelf\u003c/code\u003e가 감싸는 클래스 \u003ccode\u003eMyMetaclass\u003c/code\u003e를 참조할 것입니다. 혼동을 피하기 위해 이 예외적인 경우는 거부됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass MyMetaclass(type):\r\n    def __new__(cls, *args: Any) -\u003e Self: # 거부됨\r\n        return super().__new__(cls, *args)\r\n    def __mul__(cls, count: int) -\u003e list[Self]: # 거부됨\r\n        return [cls()] * count\r\n\r\nclass Foo(metaclass=MyMetaclass): ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e런타임 동작 (Runtime behavior)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eSelf\u003c/code\u003e는 subscriptable(첨자 사용 가능)하지 않으므로, \u003ccode\u003etyping.NoReturn\u003c/code\u003e과 유사한 구현을 제안합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@_SpecialForm\r\ndef Self(self, params):\r\n    \"\"\"클래스에서 \"self\"의 타입을 나타내는 데 사용됩니다.\r\n    예시::\r\n        from typing import Self\r\n        class ReturnsSelf:\r\n            def parse(self, data: bytes) -\u003e Self:\r\n                ...\r\n                return self\r\n    \"\"\"\r\n    raise TypeError(f\"{self} is not subscriptable\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e거부된 대안 (Rejected Alternatives)\u003c/h2\u003e\n\u003ch3\u003e타입 검사기가 반환 타입을 추론하도록 허용 (Allow the Type Checker to Infer the Return Type)\u003c/h3\u003e\n\u003cp\u003e한 가지 제안은 \u003ccode\u003eSelf\u003c/code\u003e 타입을 암묵적으로 두고, 타입 검사기가 메서드 본문을 분석하여 반환 타입이 \u003ccode\u003eself\u003c/code\u003e 파라미터의 타입과 동일해야 한다고 추론하도록 하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Shape:\r\n    def set_scale(self, scale: float):\r\n        self.scale = scale\r\n        return self # 타입 검사기가 self를 반환한다는 것을 추론합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 \"명시적인 것이 암묵적인 것보다 낫다(Explicit Is Better Than Implicit)\"는 이유로 이를 거부합니다. 또한, 위 접근 방식은 분석할 메서드 본문이 없는 타입 스텁(type stubs)에서는 실패할 것입니다.\u003c/p\u003e\n\u003ch2\u003e참고 구현 (Reference Implementations)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eMypy: Mypy의 개념 증명(Proof of concept) 구현.\u003c/li\u003e\n\u003cli\u003ePyright: v1.1.184\u003c/li\u003e\n\u003cli\u003eSelf의 런타임 구현: PR.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e자료 (Resources)\u003c/h2\u003e\n\u003cp\u003ePython의 \u003ccode\u003eSelf\u003c/code\u003e 타입에 대한 유사한 논의는 2016년경 Mypy에서 시작되었습니다. Mypy issue #1212 - SelfType or another way to spell “type of self”를 참조하세요. 그러나 최종적으로 채택된 접근 방식은 \"before\" 예시에서 보여진 바운드된 \u003ccode\u003eTypeVar\u003c/code\u003e 접근 방식이었습니다. 이와 관련된 다른 이슈로는 Mypy issue #2354 - Self types in generic classes가 있습니다.\u003c/p\u003e\n\u003cp\u003ePradeep은 PyCon Typing Summit 2021에서 구체적인 제안을 발표했습니다. (녹화된 발표, 슬라이드 참조). James는 typing-sig에서 독립적으로 이 제안을 제기했습니다. (Typing-sig 스레드 참조).\u003c/p\u003e\n\u003cp\u003e다른 언어들도 감싸는 클래스의 타입을 표현하는 유사한 방법을 가지고 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTypeScript는 \u003ccode\u003ethis\u003c/code\u003e 타입을 가지고 있습니다 (TypeScript docs).\u003c/li\u003e\n\u003cli\u003eRust는 \u003ccode\u003eSelf\u003c/code\u003e 타입을 가지고 있습니다 (Rust docs).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 PEP에 대한 피드백을 주신 다음 분들께 감사드립니다.\r\nJia Chen, Rebecca Chen, Sergei Lebedev, Kaylynn Morgan, Tuomas Suutari, Eric Traut, Alex Waygood, Shannon Zhu, and Никита Соболев.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 조건으로 배포됩니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 673 - Self Type\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 10:07:14+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>