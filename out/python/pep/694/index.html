<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Draft] PEP 694 - Upload 2.0 API for Python Package Indexes</h1><div class="page__meta"><time dateTime="2025-09-27 10:23:36+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0694/">PEP 694 - Upload 2.0 API for Python Package Indexes</a></p>
<p><strong>상태:</strong> Draft | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 11-Jun-2022</p>
</blockquote>
<h2>PEP 694 – Python 패키지 인덱스를 위한 Upload 2.0 API</h2>
<h3>개요 (Abstract)</h3>
<p>이 PEP는 PyPI(Python Package Index)와 같은 Python 패키지 인덱스에 파일을 업로드하기 위한 확장 가능한 API를 제안합니다. 이 새로운 업로드 API는 표준화와 더불어 다음과 같은 유용한 추가 기능을 제공합니다:</p>
<ul>
<li><strong>퍼블리싱 세션 (Publishing Session):</strong> 패키지 릴리스의 모든 휠 (wheels)을 동시에 퍼블리싱하는 데 사용될 수 있습니다.</li>
<li><strong>릴리스 스테이징 (Staging a Release):</strong> <code>test.pypi.org</code> 없이도 공개적으로 퍼블리싱하기 전에 업로드를 테스트하는 데 사용할 수 있습니다.</li>
<li><strong>아티팩트 덮어쓰기 및 교체:</strong> 세션이 퍼블리싱되기 전까지는 아티팩트를 덮어쓰고 교체할 수 있습니다.</li>
<li><strong>상세한 아티팩트 업로드 상태:</strong> 아티팩트 업로드 상태에 대한 상세한 정보를 제공합니다.</li>
<li><strong>아티팩트 업로드 없이 새 프로젝트 생성:</strong> 아티팩트를 업로드하지 않고도 새 프로젝트를 생성할 수 있습니다.</li>
<li><strong>업로드 메커니즘 확장 프로토콜:</strong> 향후 전체 PEP가 필요 없이 지원되는 업로드 메커니즘을 확장할 수 있는 프로토콜을 제공합니다. 이는 모든 인덱스에 대해 표준화 및 권장될 수 있으며, 인덱스별로도 가능합니다.</li>
</ul>
<p>이 새로운 업로드 API가 채택되면 기존의 레거시 API는 더 이상 사용되지 않을 수 있지만, 이 PEP는 레거시 API의 사용 중단 일정을 제안하지는 않습니다.</p>
<h3>도입 배경 (Rationale)</h3>
<p>현재 PyPI와 같은 Python 패키지 인덱스에 파일을 업로드하기 위한 표준화된 API는 없습니다. 대신, 모든 사용자는 기존의 "레거시" API를 역설계하여 사용해야 했습니다.</p>
<p>레거시 API는 기능적이지만, 원래 PyPI 코드베이스의 구현 세부 사항을 노출하며, 이는 새로운 코드베이스와 다른 구현에서 충실히 복제되었습니다.</p>
<p>또한, 레거시 API에는 여러 가지 주요 문제점이 있습니다:</p>
<ul>
<li><strong>완전히 동기적 (Fully Synchronous):</strong> 업로드 자체와 인덱스가 업로드된 파일을 처리하여 성공 또는 실패를 판단하는 동안 요청이 계속 열려 있어야 합니다.</li>
<li><strong>병렬 또는 재개 업로드 미지원:</strong> 업로드를 병렬화하거나 재개할 수 있는 메커니즘을 지원하지 않습니다. PyPI의 가장 큰 기본 파일 크기가 약 1GB인 상황에서 전체 업로드가 성공적으로 완료되어야 한다는 요구 사항은 요청 진행 중 네트워크 중단이 발생할 경우 대역폭 낭비를 초래합니다.</li>
<li><strong>단일 파일 단위의 작업:</strong> 작업의 최소 단위가 단일 파일입니다. 이는 릴리스가 논리적으로 sdist와 여러 바이너리 휠을 포함할 때 문제가 됩니다. 운이 나쁘게도 플랫폼의 휠이 완전히 업로드되기 전에 패키지를 요구하는 소비자들이 다른 버전의 패키지를 받을 수 있는 레이스 컨디션 (race condition)을 초래합니다. 릴리스가 sdist를 먼저 업로드하면 일부 소비자는 sdist만 보고 로컬에서 소스 빌드를 트리거할 수도 있습니다.</li>
<li><strong>제한적인 상태 보고:</strong> 여러 오류, 경고, 사용 중단 등을 보고하는 기능이 매우 제한적입니다. 상태는 HTTP 상태 코드 및 사유 구문 (reason phrase)으로 제한되며, 사유 구문은 HTTP/2 (RFC 7540) 이후로 더 이상 사용되지 않습니다.</li>
<li><strong>파일과 함께 제출되는 메타데이터:</strong> 릴리스에 대한 메타데이터는 파일과 함께 제출됩니다. 그러나 이 메타데이터는 신뢰할 수 없는 것으로 유명하여 대부분의 설치 프로그램은 대신 전체 파일을 다운로드하여 거기서 메타데이터를 읽습니다.</li>
<li><strong>업로드 전 유효성 검사 메커니즘 부재:</strong> 인덱스가 업로드에 대역폭을 소비하기 전에 어떤 종류의 유효성 검사도 할 수 있는 메커니즘이 없습니다. 유효하지 않은 메타데이터 또는 잘못된 권한의 많은 경우를 파일을 업로드하기 전에 확인할 수 있습니다.</li>
<li><strong>릴리스 스테이징 미지원:</strong> 인덱스에 퍼블리싱하기 전에 릴리스를 "스테이징"하는 기능이 없습니다.</li>
<li><strong>새 프로젝트 생성의 제약:</strong> 새 프로젝트를 생성하려면 최소 하나의 파일을 업로드해야 하므로 프로젝트 네임스페이스를 선점하기 위한 "스텁 (stub)" 업로드를 유도합니다.</li>
</ul>
<p>이 PEP에서 제안하는 새로운 업로드 API는 이러한 모든 문제를 직접적으로 또는 확장 가능한 접근 방식을 통해 해결하는 방법을 제공하며, 서버가 재개 가능한 (resumable) 및 병렬 (parallel) 업로드와 같은 기능을 구현할 수 있도록 합니다. 이 업로드 API는 더 나은 오류 보고, 더 견고한 릴리스 테스트 경험, 그리고 모든 릴리스 아티팩트의 원자적 (atomic)이고 동시적인 (simultaneous) 퍼블리싱을 제공합니다.</p>
<h3>레거시 API (Legacy API)</h3>
<p>다음은 레거시 API에 대한 개요입니다. 자세한 내용은 PyPI 사용자 가이드 문서를 참조하십시오.</p>
<h4>엔드포인트 (Endpoint)</h4>
<p>기존 업로드 API는 기본 URL에 있습니다. PyPI의 경우, 현재 해당 URL은 <code>https://upload.pypi.org/legacy/</code> 입니다. 클라이언트는 <code>file_upload</code> 값을 가진 <code>:action</code> URL 매개변수를 추가하여 호출하려는 API를 지정합니다.</p>
<p>레거시 API에는 <code>protocol_version</code> 매개변수도 있어 이론적으로 새로운 버전의 API를 정의할 수 있습니다. 실제로는 이런 일이 발생하지 않았으며, 값은 항상 <code>1</code> 입니다.</p>
<p>따라서 PyPI의 실질적인 업로드 API는 <code>https://upload.pypi.org/legacy/?:action=file_upload&#x26;protocol_version=1</code> 입니다.</p>
<h4>인코딩 (Encoding)</h4>
<p>제출할 데이터는 <code>multipart/form-data</code> 콘텐츠 타입을 가진 POST 요청으로 제출됩니다. 이는 레거시 API의 역사적 특성을 반영하는데, 원래 API가 아닌 초기 PyPI 구현의 웹 폼으로 설계되었고 클라이언트 코드는 해당 폼을 프로그래밍 방식으로 제출하도록 작성되었습니다.</p>
<h4>내용 (Content)</h4>
<p>대략적으로 말해, 패키지에 포함된 메타데이터는 <code>form-data</code> 콘텐츠 디스포지션 (content disposition)을 가지고 메타데이터 키가 필드 이름인 부분으로 제출됩니다. 이러한 다양한 메타데이터의 이름은 문서화되어 있지 않으며, 패키지 아티팩트의 <code>METADATA</code> 파일에 사용된 이름과 일치하는 경우도 있지만 항상 그런 것은 아닙니다. 대소문자가 일치하는 경우는 드물고, <code>form-data</code>에서 <code>METADATA</code>로의 변환은 일관성이 없습니다.</p>
<p>업로드 아티팩트 파일 자체는 <code>content</code>라는 이름으로 <code>application/octet-stream</code> 부분으로 전송되며, PGP 서명이 첨부된 경우 <code>gpg_signature</code>라는 이름으로 <code>application/octet-stream</code> 부분에 포함됩니다.</p>
<h4>인증 (Authentication)</h4>
<p>업로드 인증 또한 표준화되어 있지 않습니다. PyPI는 API 토큰을 비밀번호로, 사용자 이름 <code>__token__</code>을 사용하여 HTTP Basic Authentication을 사용합니다. 신뢰할 수 있는 퍼블리셔 (Trusted Publishers)는 OpenID Connect를 통해 인증하고 동일한 방식으로 사용되는 단기 API 토큰을 받습니다.</p>
<h3>Upload 2.0 API 사양 (Upload 2.0 API Specification)</h3>
<p>이 PEP는 기존 API의 대부분 문제의 근본 원인을 대략 두 가지로 추적합니다:</p>
<ol>
<li>메타데이터가 파일 자체에서 파싱되지 않고 파일과 함께 제출됩니다.</li>
<li>단일 요청만 지원하며, 폼 데이터만 사용하고, 성공하거나 실패하며, 모든 작업은 해당 단일 요청 내에서 원자적 (atomic)입니다.</li>
</ol>
<p>이러한 문제를 해결하기 위해 이 PEP는 다중 요청 워크플로우를 제안하며, 높은 수준에서는 다음 단계를 포함합니다:</p>
<ol>
<li>릴리스 스테이지를 생성하는 퍼블리싱 세션 (Publishing Session)을 시작합니다.</li>
<li>퍼블리싱 세션의 일부로 해당 스테이지에 파일 업로드 세션 (File Upload Session)을 시작합니다.</li>
<li>클라이언트와 서버 간에 사용할 특정 파일 업로드 메커니즘을 협상합니다.</li>
<li>협상된 메커니즘을 사용하여 파일 업로드 세션에 대한 파일 업로드 메커니즘을 실행합니다.</li>
<li>파일 업로드 세션을 완료하여 완료 또는 취소로 표시합니다.</li>
<li>퍼블리싱 세션을 완료하여 스테이지를 퍼블리싱하거나 폐기합니다.</li>
<li>선택적으로 퍼블리싱 세션의 상태를 확인합니다.</li>
</ol>
<h4>버전 관리 (Versioning)</h4>
<p>이 PEP는 PEP 691에서 사용된 것과 동일한 <code>MAJOR.MINOR</code> 버전 관리 시스템을 사용하지만, 그 외에는 독립적으로 버전이 관리됩니다. 레거시 API는 이 PEP에서 버전 <code>1.0</code>으로 간주되지만, 이 PEP는 레거시 API를 어떤 방식으로든 수정하지 않습니다.</p>
<p>따라서 이 PEP에서 제안하는 API는 버전 번호 <code>2.0</code>을 가집니다.</p>
<p>업로드 API의 주 버전 및 부 버전 번호는 PEP 프로세스를 통해서만 변경되어야 합니다. 인덱스 운영자 및 구현자는 승인된 PEP 없이는 새로운 API 버전을 광고하거나 구현해서는 안 됩니다. 이는 모든 구현에서 일관성을 보장하고 생태계의 파편화를 방지합니다.</p>
<h4>콘텐츠 타입 (Content Types)</h4>
<p>PEP 691과 마찬가지로, 이 PEP는 이 업로드 API의 모든 요청 및 응답이 콘텐츠가 무엇인지, 어떤 버전의 API를 나타내는지, 어떤 직렬화 (serialization) 형식이 사용되었는지를 설명하는 표준 콘텐츠 타입을 가질 것을 제안합니다.</p>
<p>이 표준 요청 콘텐츠 타입은 파일 업로드 메커니즘을 실행하기 위한 요청을 제외한 모든 요청에 적용되며, 해당 메커니즘의 문서에 의해 지정될 것입니다.</p>
<p>다른 모든 요청에 대한 <code>Content-Type</code> 헤더의 구조는 다음과 같습니다:</p>
<p><code>application/vnd.pypi.upload.$version+$format</code></p>
<p>부 API 버전 차이는 방해적이지 않아야 하므로, 주 버전만 콘텐츠 타입에 포함됩니다. 버전 번호는 <code>v</code> 접두사가 붙습니다.</p>
<p>클라이언트 요청의 <code>.meta.api-version</code> JSON 키에 지정된 주 API 버전은 <code>Content-Type</code> 헤더의 주 버전과 일치해야 합니다.</p>
<p>PEP 691과 달리, 이 PEP는 기존 레거시 1.0 업로드 API를 어떤 방식으로든 변경하지 않으므로, 서버는 이 PEP에 설명된 새로운 API를 기존 업로드 API와 다른 엔드포인트에서 호스팅해야 합니다.</p>
<p>JSON이 이 PEP에 정의된 유일한 요청 형식이므로, 이 PEP에 정의된 모든 파일 업로드 외 요청은 다음 <code>Content-Type</code> 헤더 값을 포함해야 합니다:</p>
<p><code>application/vnd.pypi.upload.v2+json</code></p>
<p>PEP 691과 유사하게, 이 PEP는 또한 서버 중심의 콘텐츠 협상 (server-driven content negotiation)을 사용하여 클라이언트가 다른 버전이나 직렬화 형식을 요청할 수 있도록 표준화하며, 이는 콘텐츠 타입의 <code>format</code> 부분을 포함합니다. 그러나 이 PEP는 기존 레거시 1.0 업로드 API가 다른 엔드포인트에 존재할 것으로 예상하고 현재 JSON 직렬화만 제공하므로 이 메커니즘은 특별히 유용하지 않습니다. 클라이언트는 요청할 수 있는 단일 버전과 직렬화만 가집니다. 그러나 클라이언트는 향후 추가 형식이나 버전이 추가될 경우 콘텐츠 협상을 원활하게 처리할 준비가 되어 있어야 합니다.</p>
<p>서버는 승인된 PEP에 정의된 API 버전 외의 버전에 대한 지원을 광고해서는 안 됩니다. 새로운 버전이나 형식은 새로운 PEP를 통한 표준화를 요구합니다.</p>
<p>달리 명시되지 않는 한, 이 문서의 모든 HTTP 요청 및 응답에는 <code>Content-Type: application/vnd.pypi.upload.v2+json</code> HTTP 헤더가 포함된 것으로 가정합니다.</p>
<h4>루트 엔드포인트 (Root Endpoint)</h4>
<p>여기에 설명된 모든 URL은 도메인의 URL 구조 내 어디에나 위치할 수 있는 "루트 엔드포인트"를 기준으로 합니다. 예를 들어, 루트 엔드포인트는 <code>https://upload.example.com/</code> 또는 <code>https://example.com/upload/</code>일 수 있습니다.</p>
<p>루트 엔드포인트의 선택은 인덱스 운영자에게 맡겨집니다.</p>
<h4>Upload 2.0 API를 위한 인증 (Authentication for Upload 2.0 API)</h4>
<p>이 사양의 모든 엔드포인트는 RFC 7235에 정의된 표준 HTTP 인증 메커니즘을 사용해야 합니다.</p>
<p>인증은 표준 HTTP 패턴을 따릅니다:</p>
<ul>
<li>인증이 필요할 때 서버는 <code>WWW-Authenticate</code> 응답 헤더를 사용합니다.</li>
<li>클라이언트는 <code>Authorization</code> 요청 헤더를 통해 자격 증명 (credentials)을 제공합니다.</li>
<li><code>401 Unauthorized</code>는 누락되거나 유효하지 않은 인증을 나타냅니다.</li>
<li><code>403 Forbidden</code>은 불충분한 권한을 나타냅니다.</li>
</ul>
<p>특정 인증 체계 (예: Bearer, Basic, Digest)는 인덱스 운영자가 결정합니다.</p>
<h4>오류 (Errors)</h4>
<p>콘텐츠를 포함하는 모든 오류 응답은 다음과 같습니다:</p>
<pre><code class="language-json">{
  "meta": {
    "api-version": "2.0"
  },
  "message": "...",
  "errors": [
    {
      "source": "...",
      "message": "..."
    }
  ]
}
</code></pre>
<p>표준 <code>meta</code> 키 외에, 다음과 같은 최상위 키를 가집니다:</p>
<ul>
<li><code>message</code>: 이 요청에서 발생했을 수 있는 모든 오류를 요약하는 단일 메시지.</li>
<li><code>errors</code>: 특정 오류의 배열로, 각 오류는 오류의 출처를 나타내는 문자열인 <code>source</code> 키와 해당 특정 오류에 대한 <code>message</code> 키를 포함합니다.</li>
</ul>
<p><code>message</code> 및 <code>source</code> 문자열에는 특정 의미가 없으며, 근본적인 문제를 진단하는 데 도움이 되는 인간 해석을 위한 것입니다.</p>
<h4>퍼블리싱 세션 (Publishing Session)</h4>
<p><strong>퍼블리싱 세션 생성 (Create a Publishing Session)</strong></p>
<p>릴리스는 새로운 퍼블리싱 세션을 생성하는 것으로 시작됩니다. 세션을 생성하기 위해 클라이언트는 다음과 같은 POST 요청을 루트 URL로 제출합니다:</p>
<pre><code class="language-json">{
  "meta": {
    "api-version": "2.0"
  },
  "name": "foo",
  "version": "1.0",
  "nonce": "&#x3C;string>"
}
</code></pre>
<p>요청에는 다음과 같은 최상위 키가 포함됩니다:</p>
<ul>
<li><code>meta</code> (필수): 페이로드 자체에 대한 정보를 설명합니다. 현재, 유일하게 정의된 하위 키는 <code>api-version</code>이며, 그 값은 문자열 "2.0"이어야 합니다.</li>
<li><code>name</code> (필수): 이 세션이 새 버전을 릴리스하려는 프로젝트의 이름입니다.</li>
<li><code>version</code> (필수): 이 세션이 파일을 추가하려는 프로젝트의 버전입니다.</li>
<li><code>nonce</code> (선택 사항): "퍼블리싱 세션 토큰" 알고리즘에 대한 추가 클라이언트 측 문자열 입력입니다. 자세한 내용은 아래에 제공되지만, 이 키가 생략되면 빈 문자열을 전달하는 것과 동일합니다.</li>
</ul>
<p>성공적인 세션 생성 시, 서버는 <code>201 Created</code> 응답을 반환합니다. 오류가 발생하면 "Errors" 섹션에 설명된 대로 적절한 <code>4xx</code> 코드가 반환됩니다.</p>
<p>이전 릴리스가 없는 프로젝트에 대해 세션이 생성되는 경우, 인덱스는 세션이 퍼블리싱되기 전에 프로젝트 이름을 예약할 수 있습니다. 그러나 스테이지가 퍼블리싱될 때까지 "정상적인" (즉, 스테이징되지 않은) 접근 프로토콜을 사용하여 해당 프로젝트로 이동할 수 없어야 합니다. 이 첫 번째 릴리스 스테이지가 취소되면 인덱스는 마치 업로드되지 않은 것처럼 프로젝트 레코드를 삭제해야 합니다.</p>
<p>세션은 이를 생성한 사용자가 소유하며, 모든 후속 요청은 동일한 자격 증명으로 수행되어야 합니다. 그렇지 않으면 후속 요청에 대해 <code>403 Forbidden</code>이 반환됩니다.</p>
<p><strong>응답 본문 (Response Body)</strong></p>
<p>성공적인 응답은 다음 콘텐츠를 포함합니다:</p>
<pre><code class="language-json">{
  "meta": {
    "api-version": "2.0"
  },
  "links": {
    "stage": "...",
    "upload": "...",
    "session": "...",
  },
  "mechanisms": ["http-post-bytes"],
  "session-token": "&#x3C;token-string>",
  "expires-at": "2025-08-01T12:00:00Z",
  "status": "pending",
  "files": {},
  "notices": [
    "a notice to display to the user"
  ]
}
</code></pre>
<p>요청 JSON과 동일한 형식을 가진 <code>meta</code> 키 외에, 성공 응답은 다음과 같은 키를 가집니다:</p>
<ul>
<li><code>links</code>: 이 세션과 관련된 URL을 키에 매핑하는 사전입니다. 자세한 내용은 아래에 제공됩니다.</li>
<li><code>mechanisms</code>: 서버가 지원하는 파일 업로드 메커니즘 목록으로, 서버가 선호하는 순서로 정렬됩니다. 최소 하나의 값이 필요합니다.</li>
<li><code>session-token</code>: 인덱스가 스테이징된 릴리스의 미리 보기를 지원하는 경우, 이 키는 릴리스가 퍼블리싱되기 전에 스테이징된 릴리스를 미리 볼 수 있도록 설치 프로그램에 제공될 수 있는 고유한 "세션 토큰"을 포함합니다. 인덱스가 스테이지 미리 보기를 지원하지 않는 경우, 이 키는 생략되어야 합니다.</li>
<li><code>expires-at</code>: 서버가 이 세션과 그 콘텐츠(업로드된 파일 및 세션과 관련된 URL 링크 포함)를 언제 만료할지를 나타내는 ISO8601 형식의 타임스탬프 문자열입니다. 클라이언트가 세션을 취소하거나 퍼블리싱하지 않는 한 세션은 최소한 이 시간까지 활성 상태를 유지해야 합니다. 서버는 이 만료 시간을 연장할 수 있지만, 절대 앞당겨서는 안 됩니다. 클라이언트는 세션 상태를 쿼리하여 세션의 현재 만료 시간을 얻을 수 있습니다.</li>
<li><code>status</code>: <code>pending</code>, <code>published</code>, <code>error</code>, 또는 <code>canceled</code> 중 하나를 포함하는 문자열로, 세션의 전체 상태를 나타냅니다.</li>
<li><code>files</code>: 이 세션에 업로드된 파일 이름과 이 세션에서 참조된 각 파일에 대한 세부 정보를 포함하는 매핑으로 구성된 매핑입니다.</li>
<li><code>notices</code>: 서버가 최종 사용자에게 전달하고자 하는 사람이 읽을 수 있는 정보성 알림 배열을 가리키는 선택적 키입니다. 이러한 알림은 세션 내의 특정 파일이 아니라 전체 세션에 대한 것입니다.</li>
</ul>
<p><strong>퍼블리싱 세션 링크 (Publishing Session Links)</strong></p>
<p>성공 JSON의 <code>links</code> 키에 대해 다음 하위 키가 유효합니다:</p>
<ul>
<li><code>upload</code>: 클라이언트가 이 세션에 포함될 각 파일에 대한 파일 업로드 세션을 시작하는 데 사용할 엔드포인트.</li>
<li><code>stage</code>: 이 스테이징된 릴리스를 세션 퍼블리싱 전에 미리 볼 수 있는 엔드포인트. 이는 아직 공개되지 않은 파일을 다운로드하고 검증하는 데 사용할 수 있습니다. 인덱스가 스테이징된 릴리스 미리 보기를 지원하지 않는 경우, 이 키는 생략되어야 합니다.</li>
<li><code>session</code>: 이 세션에 대한 작업을 수행할 수 있는 엔드포인트로, 이 세션 퍼블리싱, 세션 취소 및 폐기, 현재 세션 상태 쿼리, 세션 수명 연장 요청 (서버가 지원하는 경우)을 포함합니다.</li>
</ul>
<p><strong>퍼블리싱 세션 파일 (Publishing Session Files)</strong></p>
<p><code>files</code> 키는 이 세션에 업로드된 파일 이름을 다음 키를 포함하는 하위 매핑에 매핑합니다:</p>
<ul>
<li><code>status</code>: <code>pending</code>, <code>processing</code>, <code>complete</code>, <code>error</code>, 및 <code>canceled</code> 중 유효한 값을 가진 문자열입니다. 업로드 중 오류가 발생한 경우, 클라이언트는 파일이 사용 가능한 상태라고 가정해서는 안 되며, <code>error</code>가 반환되고 파일을 취소하거나 삭제하고 다시 시작하는 것이 가장 좋습니다. 이 작업은 세션 상태 응답 본문의 <code>files</code> 키에서 파일 이름을 제거합니다.</li>
<li><code>link</code>: 클라이언트가 이 특정 파일을 참조하는 데 사용해야 하는 절대 URL입니다. 이 URL은 참조된 파일을 검색, 교체 또는 삭제하는 데 사용됩니다. <code>nonce</code>가 제공된 경우, 이 URL은 "Publishing Session Token" 섹션에 설명된 대로 추측 불가능한 토큰으로 난독화되어야 합니다.</li>
<li><code>notices</code>: <code>notices</code> 세션 키와 유사한 형식과 의미를 가진 선택적 키입니다. 단, 이 알림은 참조된 파일에 특정합니다.</li>
</ul>
<p>동일한 <code>name-version</code> 쌍에 대해 세션이 <code>pending</code> 상태인 동안 두 번째 세션이 생성되면, 서버는 새롭고 비어 있는 세션을 생성하는 대신 이미 존재하는 세션에 대한 JSON 상태 응답과 함께 <code>200 OK</code> 상태 코드를 반환해야 합니다.</p>
<p><strong>퍼블리싱 세션 완료 (Complete a Publishing Session)</strong></p>
<p>세션을 완료하고 포함된 파일을 퍼블리싱하려면, 클라이언트는 세션 생성 응답 본문에 제공된 <code>session</code> 링크로 POST 요청을 발행합니다.</p>
<p>요청은 다음과 같습니다:</p>
<pre><code class="language-json">{
  "meta": {
    "api-version": "2.0"
  },
  "action": "publish",
}
</code></pre>
<p>서버가 퍼블리싱 세션을 즉시 완료할 수 있는 경우, 그렇게 하고 <code>201 Created</code> 응답을 반환할 수 있습니다. 즉시 완료할 수 없는 경우 (예: 단일 HTTP 요청에서 합리적인 시간보다 오래 걸릴 수 있는 유효성 검사가 필요한 경우), <code>202 Accepted</code> 응답을 반환할 수 있습니다.</p>
<p>어떤 경우든, 서버는 퍼블리싱 세션 상태 URL을 가리키는 <code>Location</code> 헤더를 포함해야 하며, 서버가 <code>202 Accepted</code>를 반환한 경우 클라이언트는 해당 URL을 폴링하여 상태 변경을 확인할 수 있습니다.</p>
<p>오류가 발생하면 "Errors" 섹션에 설명된 대로 적절한 <code>4xx</code> 코드가 반환되어야 합니다.</p>
<p><strong>취소 (Cancellation)</strong></p>
<p>퍼블리싱 세션을 취소하려면, 클라이언트는 세션 생성 응답 본문에 제공된 <code>session</code> 링크로 DELETE 요청을 발행합니다. 그러면 서버는 세션을 취소로 표시하고, 해당 세션의 일부로 업로드된 모든 데이터를 삭제해야 합니다. 향후 해당 세션 URL 또는 퍼블리싱 세션 URL에 접근하려는 시도는 <code>404 Not Found</code>를 반환해야 합니다.</p>
<p>매달린 세션 (dangling sessions)을 방지하기 위해 서버는 시간 초과된 세션을 자체적으로 취소할 수도 있습니다. 서버는 세션을 최소 일주일 후에 삭제하는 것이 권장되지만, 각 서버는 자체 일정을 선택할 수 있습니다. 서버는 클라이언트가 지시하는 세션 연장을 지원할 수 있습니다.</p>
<p><strong>퍼블리싱 세션 토큰 (Publishing Session Token)</strong></p>
<p>퍼블리싱 세션을 생성할 때, 클라이언트는 초기 세션 생성 요청에 <code>nonce</code>를 제공할 수 있습니다. 이 <code>nonce</code>는 임의의 콘텐츠를 가진 문자열입니다. <code>nonce</code>는 선택 사항이며, 생략되면 빈 문자열을 제공하는 것과 동일합니다.</p>
<p>스테이징된 업로드의 미리 보기를 지원하기 위해 패키지 이름 (<code>name</code>) 및 버전 (<code>version</code>)과 이 <code>nonce</code>는 해싱 알고리즘의 입력으로 사용되어 고유한 "세션 토큰"을 생성합니다. 이 세션 토큰은 세션의 수명 (즉, 취소 또는 퍼블리싱을 통해 완료될 때까지) 동안 유효하며, 지원하는 설치 프로그램에 제공되어 스테이징된 릴리스에 접근할 수 있습니다.</p>
<p><code>nonce</code>의 사용은 클라이언트가 스테이징된 릴리스의 가시성을 모호하게 할지 여부를 결정할 수 있도록 하며, 양쪽 선택에 대한 좋은 이유가 있을 수 있습니다. 예를 들어, CI 시스템이 새 릴리스를 위해 일부 휠을 업로드하고 퍼블리싱하기 전에 스테이지의 독립적인 유효성 검사를 허용하려면 클라이언트는 <code>nonce</code>를 포함하지 않기로 선택할 수 있습니다. 반면에, 클라이언트가 공개 발표 시점에 원자적으로 퍼블리싱하는 릴리스를 미리 시드 (pre-seed)하려면, 해당 클라이언트는 <code>nonce</code>를 제공하기로 선택할 가능성이 높습니다.</p>
<p>SHA256 알고리즘은 이러한 입력을 고유한 토큰으로 변환하는 데 사용되며, <code>name</code>, <code>version</code>, <code>nonce</code> 순서로 다음 Python 코드를 예시로 사용합니다:</p>
<pre><code class="language-python">from hashlib import sha256

def gentoken(name: bytes, version: bytes, nonce: bytes = b''):
    h = sha256()
    h.update(name)
    h.update(version)
    h.update(nonce)
    return h.hexdigest()
</code></pre>
<p>세션 생성 요청에 <code>nonce</code>가 제공되지 않으면 세션 토큰은 패키지 이름과 버전 번호만으로 쉽게 추측할 수 있다는 점이 분명해야 합니다. 클라이언트는 세션 토큰에 접근할 수 없는 누구에게나 미리 보기를 허용하려면 <code>nonce</code>를 생략 (또는 빈 문자열로 설정)하도록 선택할 수 있습니다. 비어 있지 않은 <code>nonce</code>를 제공함으로써 클라이언트는 보안-through-obscurity를 선택할 수 있지만, 이는 스테이징된 파일을 어떤 종류의 인증으로도 보호하지는 않습니다.</p>
<h4>파일 업로드 세션 (File Upload Session)</h4>
<p><strong>파일 업로드 세션 생성 (Create a File Upload Session)</strong></p>
<p>퍼블리싱 세션을 생성한 후, 응답의 세션 링크 매핑에서 <code>upload</code> 엔드포인트는 해당 세션으로 새 파일 업로드를 시작하는 데 사용됩니다. 클라이언트는 제공된 업로드 URL을 사용해야 하며, 한 세션에서 다음 세션으로 해당 URL에 어떤 패턴이나 공통성이 있다고 가정해서는 안 됩니다.</p>
<p>파일 업로드를 시작하려면, 클라이언트는 먼저 <code>upload</code> URL로 POST 요청을 보냅니다. 요청은 다음과 같습니다:</p>
<pre><code class="language-json">{
  "meta": {
    "api-version": "2.0"
  },
  "filename": "foo-1.0.tar.gz",
  "size": 1000,
  "hashes": {"sha256": "...", "blake2b": "..."},
  "metadata": "...",
  "mechanism": "http-post-bytes"
}
</code></pre>
<p>표준 <code>meta</code> 키 외에, 요청 JSON에는 다음과 같은 추가 키가 있습니다:</p>
<ul>
<li><code>filename</code> (필수): 업로드되는 파일의 이름.</li>
<li><code>size</code> (필수): 업로드되는 파일의 크기 (바이트 단위).</li>
<li><code>hashes</code> (필수): 해시 이름을 16진수로 인코딩된 다이제스트에 매핑하는 것입니다. 각 다이제스트는 이름에 식별된 알고리즘으로 해싱될 때 업로드되는 파일의 체크섬입니다. 기본적으로 <code>hashlib</code>에서 사용할 수 있는 모든 해시 알고리즘은 <code>hashes</code> 딕셔너리의 키로 사용될 수 있습니다. <code>hashlib.algorithms_guaranteed</code>에서 최소 하나의 안전한 알고리즘은 항상 포함되어야 합니다. 이 PEP는 특히 <code>sha256</code>을 권장합니다. 여러 해시를 한 번에 전달할 수 있지만, 제공된 모든 해시는 파일에 대해 유효해야 합니다.</li>
<li><code>mechanism</code> (필수): 클라이언트가 이 파일에 사용할 파일 업로드 메커니즘. 이 메커니즘은 퍼블리싱 세션 응답 본문에 광고된 메커니즘 목록에서 선택되어야 합니다. 클라이언트는 서버 운영자가 "사전 릴리스 (pre-release)" 기준으로 사용할 수 있는 새롭거나 예정된 메커니즘을 문서화한 경우 광고되지 않은 메커니즘을 보낼 수 있습니다.</li>
<li><code>metadata</code> (선택 사항): 제공된 경우, 파일의 코어 메타데이터를 포함하는 문자열 값입니다.</li>
</ul>
<p>서버는 이 요청에 제공된 데이터를 사용하여 파일 업로드를 허용하기 전에 일부 유효성 검사 (sanity checking)를 수행할 수 있습니다. 이러한 검사는 다음을 포함할 수 있지만 이에 국한되지 않습니다:</p>
<ul>
<li><code>filename</code>이 이미 퍼블리싱된 릴리스에 존재하는지 확인.</li>
<li><code>size</code>가 프로젝트 또는 파일 할당량을 초과하는지 확인.</li>
<li><code>metadata</code> (제공된 경우)의 내용이 유효한지 확인.</li>
</ul>
<p>서버가 업로드를 진행해야 한다고 판단하면, 아래 응답 본문과 함께 <code>202 Accepted</code> 응답을 반환합니다. 세션 상태에는 <code>files</code> 매핑에 파일 이름도 포함됩니다. 클라이언트가 제공한 메커니즘이 지원되지 않아 서버가 업로드를 진행할 수 없는 경우 <code>422 Unprocessable Entity</code>를 반환해야 합니다. 서버가 업로드를 진행할 수 없다고 판단하면 <code>409 Conflict</code>를 반환해야 합니다. 서버는 파일의 병렬 업로드를 허용할 수 있지만, 필수는 아닙니다.</p>
<p><strong>응답 본문 (Response Body)</strong></p>
<p>성공적인 응답은 다음을 포함합니다:</p>
<pre><code class="language-json">{
  "meta": {
    "api-version": "2.0"
  },
  "links": {
    "publishing-session": "...",
    "file-upload-session": "..."
  },
  "status": "pending",
  "expires-at": "2025-08-01T13:00:00Z",
  "mechanism": {
    "identifier": "http-post-bytes",
    "file_url": "...",
    "attestations_url": "..."
  }
}
</code></pre>
<p>클라이언트에게 다음 상태 업데이트를 위해 언제 폴링해야 하는지 알려주기 위해 <code>Retry-After</code> 응답 헤더가 존재해야 합니다.</p>
<p>요청 JSON과 동일한 형식을 가진 <code>meta</code> 키 외에, 성공 응답은 다음과 같은 키를 가집니다:</p>
<ul>
<li><code>links</code>: 이 세션과 관련된 URL을 키에 매핑하는 사전입니다. 자세한 내용은 아래에 제공됩니다.</li>
<li><code>status</code>: <code>pending</code>, <code>processing</code>, <code>complete</code>, <code>error</code>, 및 <code>canceled</code> 중 유효한 값을 가진 문자열로, 파일 업로드 세션의 현재 상태를 나타냅니다.</li>
<li><code>expires-at</code>: 서버가 이 파일 업로드 세션을 언제 만료할지를 나타내는 ISO8601 형식의 타임스탬프 문자열입니다. 클라이언트가 세션을 취소하거나 완료하지 않는 한 세션은 최소한 이 시간까지 활성 상태를 유지해야 합니다. 서버는 이 만료 시간을 연장할 수 있지만, 절대 앞당겨서는 안 됩니다.</li>
<li><code>mechanism</code>: 클라이언트와 서버가 협상한 지원 메커니즘에 필요한 세부 정보를 포함하는 매핑입니다. 이 매핑은 선택된 파일 업로드 메커니즘의 식별자 문자열에 매핑되는 <code>identifier</code> 키를 포함해야 합니다.</li>
</ul>
<p><strong>파일 업로드 세션 링크 (File Upload Session Links)</strong></p>
<p>성공 JSON의 <code>links</code> 키에 대해 다음 하위 키가 유효합니다:</p>
<ul>
<li><code>publishing-session</code>: 상위 퍼블리싱 세션에 대한 작업을 수행할 수 있는 엔드포인트.</li>
<li><code>file-upload-session</code>: 이 파일 업로드 세션에 대한 작업을 수행할 수 있는 엔드포인트로, 파일 업로드 세션 취소 및 폐기, 현재 파일 업로드 세션 상태 쿼리, 파일 업로드 세션 수명 연장 요청 (서버가 지원하는 경우)을 포함합니다.</li>
</ul>
<p><strong>파일 업로드 세션 완료 (Complete a File Upload Session)</strong></p>
<p>파일 업로드 세션을 완료하려면 (이는 파일 업로드 메커니즘이 실행되었고 오류를 생성하지 않았음을 나타냄), 클라이언트는 파일 업로드 세션 생성 응답 본문의 <code>file-upload-session</code> 링크로 POST 요청을 발행합니다.</p>
<p>요청은 다음과 같습니다:</p>
<pre><code class="language-json">{
  "meta": {
    "api-version": "2.0"
  },
  "action": "complete",
}
</code></pre>
<p>서버가 파일 업로드 세션을 즉시 완료할 수 있는 경우, 그렇게 하고 <code>201 Created</code> 응답을 반환하고 파일 업로드 세션의 상태를 <code>complete</code>로 설정할 수 있습니다. 즉시 완료할 수 없는 경우 (예: 단일 HTTP 요청에서 합리적인 시간보다 오래 걸릴 수 있는 유효성 검사가 필요한 경우), <code>202 Accepted</code> 응답을 반환하고 파일 업로드 세션의 상태를 <code>processing</code>으로 설정할 수 있습니다.</p>
<p>어떤 경우든, 서버는 파일 업로드 세션 상태 URL을 가리키는 <code>Location</code> 헤더를 포함해야 합니다.</p>
<p>서버는 클라이언트가 파일 업로드 세션 상태 URL을 폴링하여 상태 변경을 확인할 수 있도록 허용해야 합니다. 서버가 <code>202 Accepted</code>로 응답하면, 클라이언트는 파일 업로드 세션 상태 URL을 폴링하여 상태 변경을 확인할 수 있습니다. 클라이언트는 파일 업로드 세션 상태 응답의 <code>Retry-After</code> 헤더 값을 존중해야 합니다.</p>
<p>오류가 발생하면 "Errors" 섹션에 설명된 대로 적절한 <code>4xx</code> 코드가 반환되어야 합니다.</p>
<p><strong>취소 및 삭제 (Cancellation and Deletion)</strong></p>
<p>클라이언트는 진행 중인 파일 업로드 세션을 취소하거나 완전히 업로드된 파일을 삭제할 수 있습니다. 두 경우 모두 클라이언트는 삭제하려는 파일의 파일 업로드 세션 URL로 DELETE 요청을 발행하여 이를 수행합니다.</p>
<p>성공적인 삭제 요청은 <code>204 No Content</code>로 응답해야 합니다.</p>
<p>취소 또는 삭제되면 클라이언트는 이전 파일 업로드 세션 리소스 또는 관련 파일 업로드 메커니즘이 재사용될 수 있다고 가정해서는 안 됩니다.</p>
<p><strong>부분적 또는 완전히 업로드된 파일 교체 (Replacing a Partially or Fully Uploaded File)</strong></p>
<p>세션 파일을 교체하려면 파일 업로드가 이전에 완료되었거나 취소되었거나 삭제되었어야 합니다. 해당 파일의 업로드가 진행 중인 경우에는 파일을 교체할 수 없습니다.</p>
<p>세션 파일을 교체하려면 클라이언트는 교체하려는 파일의 업로드 리소스 URL로 DELETE를 발행하여 진행 중인 업로드를 취소하고 삭제해야 합니다. 이 후, 전체 파일 업로드 시퀀스를 다시 시작하여 새 파일 업로드를 시작할 수 있습니다. 이는 새로운 업로드 리소스 URL을 검색하기 위해 메타데이터 요청을 다시 제공하는 것을 의미합니다. 클라이언트는 삭제 후 이전 업로드 리소스 URL이 재사용될 수 있다고 가정해서는 안 됩니다.</p>
<p><strong>세션 상태 (Session Status)</strong></p>
<p>언제든지 클라이언트는 각각 세션 생성 응답 본문 또는 파일 업로드 세션 생성 응답 본문에 제공된 <code>publishing-session</code> 링크 또는 <code>file-upload-session</code> 링크로 GET 요청을 발행하여 세션의 상태를 쿼리할 수 있습니다.</p>
<p>서버는 이 GET 요청에 대해 초기 퍼블리싱 세션 또는 파일 업로드 세션을 생성했을 때와 동일한 퍼블리싱 세션 생성 응답 본문 또는 파일 업로드 세션 생성 응답 본문으로 응답합니다. 단, <code>status</code>, <code>expires-at</code>, 또는 <code>files</code>에 대한 변경 사항이 반영됩니다.</p>
<p><strong>세션 연장 (Session Extension)</strong></p>
<p>서버는 클라이언트가 세션을 연장하도록 허용할 수 있지만, 전체 수명과 허용되는 연장 횟수는 서버에 맡겨집니다. 세션을 연장하려면, 클라이언트는 각각 퍼블리싱 세션 생성 응답 본문 또는 파일 업로드 세션 생성 응답 본문에 제공된 <code>publishing-session</code> 링크 또는 <code>file-upload-session</code> 링크로 POST 요청을 발행합니다.</p>
<p>요청은 다음과 같습니다:</p>
<pre><code class="language-json">{
  "meta": {
    "api-version": "2.0"
  },
  "action": "extend",
  "extend-for": 3600
}
</code></pre>
<p>지정된 초 단위 숫자는 현재 세션을 추가로 연장할 시간 (초)에 대한 서버에 대한 제안일 뿐입니다. 예를 들어, 클라이언트가 현재 세션을 한 시간 더 연장하려면 <code>extend-for</code>는 <code>3600</code>이 됩니다. 성공적인 연장 시, 서버는 초기 퍼블리싱 세션 또는 파일 업로드 세션을 생성했을 때와 동일한 퍼블리싱 세션 생성 응답 본문 또는 파일 업로드 세션 생성 응답 본문으로 응답합니다. 단, <code>status</code>, <code>expires-at</code>, 또는 <code>files</code>에 대한 변경 사항이 반영됩니다.</p>
<p>서버가 요청된 시간 (초)만큼 세션을 연장하기를 거부하더라도 성공 응답을 반환하며, <code>expires-at</code> 키는 단순히 세션의 현재 만료 시간을 반영합니다.</p>
<p><strong>스테이지 미리 보기 (Stage Previews)</strong></p>
<p>퍼블리싱되기 전에 스테이징된 릴리스를 미리 볼 수 있는 기능은 이 PEP의 중요한 기능이며, 릴리스가 대중에게 공개되기 전에 추가적인 최종 테스트 수준을 가능하게 합니다. 인덱스는 퍼블리싱 세션이 생성될 때 반환되는 <code>links</code> 키의 <code>stage</code> 하위 키에 제공된 URL을 통해 이 기능을 제공할 수 있습니다. <code>stage</code> URL은 <code>--extra-index-url</code> 플래그를 이 값으로 설정하여 <code>pip</code>와 같은 설치 프로그램에 전달할 수 있습니다. 이 플래그를 여러 값으로 반복하여 여러 스테이지를 미리 볼 수도 있습니다.</p>
<p>지원되는 경우, 인덱스는 스테이징된 릴리스를 설치 프로그램 도구에 노출하는 뷰를 반환하여 최종 테스트를 위해 구축된 가상 환경에 다운로드하고 설치할 수 있도록 합니다. 이 옵션을 사용하면 기존 설치 프로그램이 설치 프로그램 도구에 변경 사항 없이 스테이징된 릴리스를 미리 볼 수 있습니다. 이 사용자 경험의 세부 사항은 설치 프로그램 도구 유지 관리자에게 맡겨집니다.</p>
<h4>파일 업로드 메커니즘 (File Upload Mechanisms)</h4>
<p>서버는 필수 파일 업로드 메커니즘을 구현해야 합니다. 이러한 메커니즘은 서버별 구현이 없는 경우 대체 (fallback) 역할을 합니다.</p>
<p>업로드 API의 각 주 버전은 최소 하나의 필수 파일 업로드 메커니즘을 지정해야 합니다.</p>
<p>주 버전 업데이트 없이는 새로운 필수 메커니즘을 추가하거나 기존 필수 메커니즘을 제거해서는 안 됩니다. 추가되거나 제거되는 서버별 또는 실험적 메커니즘은 이 사양의 주 또는 부 버전 번호를 변경해서는 안 됩니다.</p>
<p><strong>필수 파일 업로드 메커니즘 (Required File Upload Mechanisms)</strong></p>
<ul>
<li><strong><code>http-post-bytes</code></strong>
<ul>
<li>업로드 API 버전 2.0을 준수하는 서버는 <code>http-post-bytes</code> 메커니즘을 지원해야 합니다.</li>
<li>이 메커니즘은 Upload 2.0 프로토콜 엔드포인트의 나머지 부분과 동일한 인증 체계를 사용해야 합니다.</li>
<li>클라이언트는 파일 업로드 세션 생성 응답 본문의 <code>mechanism</code> 맵 내 <code>http-post-bytes</code> 맵에 반환된 <code>file_url</code>로 POST 요청을 제출하여 이 메커니즘을 실행합니다.</li>
</ul>
<pre><code>Content-Type: application/octet-stream
&#x3C;binary contents of the file to upload>
</code></pre>
<ul>
<li>서버는 파일에 대한 디지털 증명 (digital attestations) 업로드를 지원할 수 있습니다 (PEP 740 참조). 이 지원은 파일 업로드 세션 생성 응답 본문의 <code>mechanism</code> 맵 내 <code>http-post-bytes</code> 맵에 <code>attestations_url</code> 키를 포함하여 표시됩니다. 증명은 파일 업로드 세션 완료 전에 <code>attestations_url</code>로 업로드되어야 합니다.</li>
<li>증명을 업로드하려면, 클라이언트는 증명 객체의 JSON 배열을 포함하는 POST 요청을 <code>attestations_url</code>로 제출합니다.</li>
</ul>
<pre><code>Content-Type: application/json
[{"version": 1, "verification_material": {...}, "envelope": {...}},...]
</code></pre>
</li>
</ul>
<p><strong>서버별 파일 업로드 메커니즘 (Server Specific File Upload Mechanisms)</strong></p>
<p>주어진 서버는 임의의 수의 서버별 메커니즘을 구현할 수 있으며, 사용법을 문서화할 책임이 있습니다.</p>
<p>서버별 구현 파일 업로드 메커니즘 식별자는 세 부분으로 구성됩니다:</p>
<p><code>&#x3C;prefix>-&#x3C;operator identifier>-&#x3C;implementation identifier></code></p>
<p>서버별 구현은 <code>vnd</code>를 접두사로 사용해야 합니다. 운영자 식별자 (operator identifier)는 서버 운영자를 명확하게 식별하고, 다른 잘 알려진 인덱스와 고유하며, 영숫자 문자 <code>[a-z0-9]</code>만 포함해야 합니다. 구현 식별자 (implementation identifier)는 기본 구현을 간결하게 설명하고 영숫자 문자 <code>[a-z0-9]</code>와 <code>-</code>만 포함해야 합니다.</p>
<p>서버 운영자가 업로드 메커니즘에 중대한 변경 (breaking changes)을 해야 할 때, 기존 메커니즘을 수정하는 대신 새로운 메커니즘 식별자를 생성해야 합니다. 권장되는 패턴은 구현 식별자에 <code>-v1</code>, <code>-v2</code> 등과 같은 버전 접미사를 추가하는 것입니다. 이를 통해 클라이언트는 새로운 버전을 명시적으로 선택하면서 기존 클라이언트와의 하위 호환성을 유지할 수 있습니다.</p>
<p>예시:</p>
<p>| File Upload Mechanism string         | Server Operator | Mechanism description                                  |
| :----------------------------------- | :-------------- | :----------------------------------------------------- |
| <code>vnd-pypi-s3multipart-presigned</code>     | PyPI            | S3 multipart upload via pre-signed URL                 |
| <code>vnd-pypi-s3multipart-presigned-v2</code>  | PyPI            | S3 multipart upload via pre-signed URL version 2       |
| <code>vnd-pypi-http-fetch</code>                | PyPI            | File delivered by instructing server to fetch from a URL via HTTP request |
| <code>vnd-acmecorp-http-fetch</code>            | Acme Corp       | File delivered by instructing server to fetch from a URL via HTTP request |
| <code>vnd-acmecorp-postal</code>                | Acme Corp       | File delivered via postal mail                         |
| <code>vnd-widgetinc-stream-v1</code>            | Widget Inc.     | Streaming upload protocol version 1                    |
| <code>vnd-widgetinc-stream-v2</code>            | Widget Inc.     | Streaming upload protocol version 2                    |
| <code>vnd-madscience-quantumentanglement</code> | Mad Science Labs| Upload via quantum entanglement                        |</p>
<p>서버가 다른 서버의 구현 동작과 정확히 일치시키려는 경우, 해당 구현의 파일 업로드 메커니즘 이름으로 응답할 수 있습니다.</p>
<h3>FAQ</h3>
<p><strong>PyPI가 기존 업로드 API 지원을 중단할 계획이라는 의미입니까?</strong></p>
<p>현재 PyPI는 기존 업로드 API 지원을 중단할 구체적인 계획이 없습니다.</p>
<p>PEP 691과는 달리, 그렇게 하는 데 상당한 이점이 있으므로, 레거시 업로드 API 지원이 미래의 어느 시점에 (책임 있게) 사용 중단되고 제거될 가능성이 있습니다. 그러한 미래의 사용 중단 계획은 이 PEP의 범위를 명시적으로 벗어납니다.</p>
<p><strong>Upload 2.0 API를 사용하여 프로젝트 이름을 예약할 수 있습니까?</strong></p>
<p>예! 릴리스를 위해 파일을 업로드할 준비가 되지 않았더라도 프로젝트 이름을 예약할 수 있습니다 (물론 이름이 아직 존재하지 않는다고 가정).</p>
<p>이를 위해 새로운 퍼블리싱 세션을 생성한 다음, 파일을 업로드하지 않고 세션을 퍼블리싱하십시오. <code>create session</code> 요청의 JSON 본문에서 <code>version</code> 키는 필수이지만, 플레이스홀더 버전 번호 "0.0.0"을 사용하면 됩니다.</p>
<p>세션을 생성한 사용자가 새 프로젝트의 소유자가 됩니다.</p>
<h3>공개 질문 (Open Questions)</h3>
<p><strong>Upload 2.0 프로토콜 확장 (Extensions to the Upload 2.0 Protocol)</strong></p>
<p>이 PEP 검토 중에 업로드 처리 완료에 대한 비동기 웹훅 알림과 같은 기능이 논의되었습니다. 업로드 프로토콜의 기능 확장 개념이 논의되었는데, 이는 구현자가 비동기 알림 또는 웹훅과 같은 선택적 기능에 대한 지원을 광고할 수 있도록 합니다.</p>
<p>이 아이디어는 그러한 확장 프로토콜을 설계하고 Upload 2.0이 출시될 때 생태계의 과도한 파편화를 야기하지 않도록 보장하는 데 따르는 복잡성 때문에 보류되었습니다.</p>
<p>Upload 2.0 운영 경험이 쌓이면 업로드 프로토콜의 향후 개정에서 이러한 확장을 탐색해야 합니다.</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 제공됩니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/694\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"jf5MDuRUbMNVvRN9tv5rq\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/694/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/694\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"694\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/694\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:Tbe5c,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0694/\"\u003ePEP 694 - Upload 2.0 API for Python Package Indexes\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Draft | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 11-Jun-2022\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 694 – Python 패키지 인덱스를 위한 Upload 2.0 API\u003c/h2\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 PyPI(Python Package Index)와 같은 Python 패키지 인덱스에 파일을 업로드하기 위한 확장 가능한 API를 제안합니다. 이 새로운 업로드 API는 표준화와 더불어 다음과 같은 유용한 추가 기능을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e퍼블리싱 세션 (Publishing Session):\u003c/strong\u003e 패키지 릴리스의 모든 휠 (wheels)을 동시에 퍼블리싱하는 데 사용될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e릴리스 스테이징 (Staging a Release):\u003c/strong\u003e \u003ccode\u003etest.pypi.org\u003c/code\u003e 없이도 공개적으로 퍼블리싱하기 전에 업로드를 테스트하는 데 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e아티팩트 덮어쓰기 및 교체:\u003c/strong\u003e 세션이 퍼블리싱되기 전까지는 아티팩트를 덮어쓰고 교체할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상세한 아티팩트 업로드 상태:\u003c/strong\u003e 아티팩트 업로드 상태에 대한 상세한 정보를 제공합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e아티팩트 업로드 없이 새 프로젝트 생성:\u003c/strong\u003e 아티팩트를 업로드하지 않고도 새 프로젝트를 생성할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e업로드 메커니즘 확장 프로토콜:\u003c/strong\u003e 향후 전체 PEP가 필요 없이 지원되는 업로드 메커니즘을 확장할 수 있는 프로토콜을 제공합니다. 이는 모든 인덱스에 대해 표준화 및 권장될 수 있으며, 인덱스별로도 가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 새로운 업로드 API가 채택되면 기존의 레거시 API는 더 이상 사용되지 않을 수 있지만, 이 PEP는 레거시 API의 사용 중단 일정을 제안하지는 않습니다.\u003c/p\u003e\n\u003ch3\u003e도입 배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003e현재 PyPI와 같은 Python 패키지 인덱스에 파일을 업로드하기 위한 표준화된 API는 없습니다. 대신, 모든 사용자는 기존의 \"레거시\" API를 역설계하여 사용해야 했습니다.\u003c/p\u003e\n\u003cp\u003e레거시 API는 기능적이지만, 원래 PyPI 코드베이스의 구현 세부 사항을 노출하며, 이는 새로운 코드베이스와 다른 구현에서 충실히 복제되었습니다.\u003c/p\u003e\n\u003cp\u003e또한, 레거시 API에는 여러 가지 주요 문제점이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e완전히 동기적 (Fully Synchronous):\u003c/strong\u003e 업로드 자체와 인덱스가 업로드된 파일을 처리하여 성공 또는 실패를 판단하는 동안 요청이 계속 열려 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e병렬 또는 재개 업로드 미지원:\u003c/strong\u003e 업로드를 병렬화하거나 재개할 수 있는 메커니즘을 지원하지 않습니다. PyPI의 가장 큰 기본 파일 크기가 약 1GB인 상황에서 전체 업로드가 성공적으로 완료되어야 한다는 요구 사항은 요청 진행 중 네트워크 중단이 발생할 경우 대역폭 낭비를 초래합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e단일 파일 단위의 작업:\u003c/strong\u003e 작업의 최소 단위가 단일 파일입니다. 이는 릴리스가 논리적으로 sdist와 여러 바이너리 휠을 포함할 때 문제가 됩니다. 운이 나쁘게도 플랫폼의 휠이 완전히 업로드되기 전에 패키지를 요구하는 소비자들이 다른 버전의 패키지를 받을 수 있는 레이스 컨디션 (race condition)을 초래합니다. 릴리스가 sdist를 먼저 업로드하면 일부 소비자는 sdist만 보고 로컬에서 소스 빌드를 트리거할 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e제한적인 상태 보고:\u003c/strong\u003e 여러 오류, 경고, 사용 중단 등을 보고하는 기능이 매우 제한적입니다. 상태는 HTTP 상태 코드 및 사유 구문 (reason phrase)으로 제한되며, 사유 구문은 HTTP/2 (RFC 7540) 이후로 더 이상 사용되지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e파일과 함께 제출되는 메타데이터:\u003c/strong\u003e 릴리스에 대한 메타데이터는 파일과 함께 제출됩니다. 그러나 이 메타데이터는 신뢰할 수 없는 것으로 유명하여 대부분의 설치 프로그램은 대신 전체 파일을 다운로드하여 거기서 메타데이터를 읽습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e업로드 전 유효성 검사 메커니즘 부재:\u003c/strong\u003e 인덱스가 업로드에 대역폭을 소비하기 전에 어떤 종류의 유효성 검사도 할 수 있는 메커니즘이 없습니다. 유효하지 않은 메타데이터 또는 잘못된 권한의 많은 경우를 파일을 업로드하기 전에 확인할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e릴리스 스테이징 미지원:\u003c/strong\u003e 인덱스에 퍼블리싱하기 전에 릴리스를 \"스테이징\"하는 기능이 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e새 프로젝트 생성의 제약:\u003c/strong\u003e 새 프로젝트를 생성하려면 최소 하나의 파일을 업로드해야 하므로 프로젝트 네임스페이스를 선점하기 위한 \"스텁 (stub)\" 업로드를 유도합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 PEP에서 제안하는 새로운 업로드 API는 이러한 모든 문제를 직접적으로 또는 확장 가능한 접근 방식을 통해 해결하는 방법을 제공하며, 서버가 재개 가능한 (resumable) 및 병렬 (parallel) 업로드와 같은 기능을 구현할 수 있도록 합니다. 이 업로드 API는 더 나은 오류 보고, 더 견고한 릴리스 테스트 경험, 그리고 모든 릴리스 아티팩트의 원자적 (atomic)이고 동시적인 (simultaneous) 퍼블리싱을 제공합니다.\u003c/p\u003e\n\u003ch3\u003e레거시 API (Legacy API)\u003c/h3\u003e\n\u003cp\u003e다음은 레거시 API에 대한 개요입니다. 자세한 내용은 PyPI 사용자 가이드 문서를 참조하십시오.\u003c/p\u003e\n\u003ch4\u003e엔드포인트 (Endpoint)\u003c/h4\u003e\n\u003cp\u003e기존 업로드 API는 기본 URL에 있습니다. PyPI의 경우, 현재 해당 URL은 \u003ccode\u003ehttps://upload.pypi.org/legacy/\u003c/code\u003e 입니다. 클라이언트는 \u003ccode\u003efile_upload\u003c/code\u003e 값을 가진 \u003ccode\u003e:action\u003c/code\u003e URL 매개변수를 추가하여 호출하려는 API를 지정합니다.\u003c/p\u003e\n\u003cp\u003e레거시 API에는 \u003ccode\u003eprotocol_version\u003c/code\u003e 매개변수도 있어 이론적으로 새로운 버전의 API를 정의할 수 있습니다. 실제로는 이런 일이 발생하지 않았으며, 값은 항상 \u003ccode\u003e1\u003c/code\u003e 입니다.\u003c/p\u003e\n\u003cp\u003e따라서 PyPI의 실질적인 업로드 API는 \u003ccode\u003ehttps://upload.pypi.org/legacy/?:action=file_upload\u0026#x26;protocol_version=1\u003c/code\u003e 입니다.\u003c/p\u003e\n\u003ch4\u003e인코딩 (Encoding)\u003c/h4\u003e\n\u003cp\u003e제출할 데이터는 \u003ccode\u003emultipart/form-data\u003c/code\u003e 콘텐츠 타입을 가진 POST 요청으로 제출됩니다. 이는 레거시 API의 역사적 특성을 반영하는데, 원래 API가 아닌 초기 PyPI 구현의 웹 폼으로 설계되었고 클라이언트 코드는 해당 폼을 프로그래밍 방식으로 제출하도록 작성되었습니다.\u003c/p\u003e\n\u003ch4\u003e내용 (Content)\u003c/h4\u003e\n\u003cp\u003e대략적으로 말해, 패키지에 포함된 메타데이터는 \u003ccode\u003eform-data\u003c/code\u003e 콘텐츠 디스포지션 (content disposition)을 가지고 메타데이터 키가 필드 이름인 부분으로 제출됩니다. 이러한 다양한 메타데이터의 이름은 문서화되어 있지 않으며, 패키지 아티팩트의 \u003ccode\u003eMETADATA\u003c/code\u003e 파일에 사용된 이름과 일치하는 경우도 있지만 항상 그런 것은 아닙니다. 대소문자가 일치하는 경우는 드물고, \u003ccode\u003eform-data\u003c/code\u003e에서 \u003ccode\u003eMETADATA\u003c/code\u003e로의 변환은 일관성이 없습니다.\u003c/p\u003e\n\u003cp\u003e업로드 아티팩트 파일 자체는 \u003ccode\u003econtent\u003c/code\u003e라는 이름으로 \u003ccode\u003eapplication/octet-stream\u003c/code\u003e 부분으로 전송되며, PGP 서명이 첨부된 경우 \u003ccode\u003egpg_signature\u003c/code\u003e라는 이름으로 \u003ccode\u003eapplication/octet-stream\u003c/code\u003e 부분에 포함됩니다.\u003c/p\u003e\n\u003ch4\u003e인증 (Authentication)\u003c/h4\u003e\n\u003cp\u003e업로드 인증 또한 표준화되어 있지 않습니다. PyPI는 API 토큰을 비밀번호로, 사용자 이름 \u003ccode\u003e__token__\u003c/code\u003e을 사용하여 HTTP Basic Authentication을 사용합니다. 신뢰할 수 있는 퍼블리셔 (Trusted Publishers)는 OpenID Connect를 통해 인증하고 동일한 방식으로 사용되는 단기 API 토큰을 받습니다.\u003c/p\u003e\n\u003ch3\u003eUpload 2.0 API 사양 (Upload 2.0 API Specification)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 기존 API의 대부분 문제의 근본 원인을 대략 두 가지로 추적합니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e메타데이터가 파일 자체에서 파싱되지 않고 파일과 함께 제출됩니다.\u003c/li\u003e\n\u003cli\u003e단일 요청만 지원하며, 폼 데이터만 사용하고, 성공하거나 실패하며, 모든 작업은 해당 단일 요청 내에서 원자적 (atomic)입니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이러한 문제를 해결하기 위해 이 PEP는 다중 요청 워크플로우를 제안하며, 높은 수준에서는 다음 단계를 포함합니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e릴리스 스테이지를 생성하는 퍼블리싱 세션 (Publishing Session)을 시작합니다.\u003c/li\u003e\n\u003cli\u003e퍼블리싱 세션의 일부로 해당 스테이지에 파일 업로드 세션 (File Upload Session)을 시작합니다.\u003c/li\u003e\n\u003cli\u003e클라이언트와 서버 간에 사용할 특정 파일 업로드 메커니즘을 협상합니다.\u003c/li\u003e\n\u003cli\u003e협상된 메커니즘을 사용하여 파일 업로드 세션에 대한 파일 업로드 메커니즘을 실행합니다.\u003c/li\u003e\n\u003cli\u003e파일 업로드 세션을 완료하여 완료 또는 취소로 표시합니다.\u003c/li\u003e\n\u003cli\u003e퍼블리싱 세션을 완료하여 스테이지를 퍼블리싱하거나 폐기합니다.\u003c/li\u003e\n\u003cli\u003e선택적으로 퍼블리싱 세션의 상태를 확인합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e버전 관리 (Versioning)\u003c/h4\u003e\n\u003cp\u003e이 PEP는 PEP 691에서 사용된 것과 동일한 \u003ccode\u003eMAJOR.MINOR\u003c/code\u003e 버전 관리 시스템을 사용하지만, 그 외에는 독립적으로 버전이 관리됩니다. 레거시 API는 이 PEP에서 버전 \u003ccode\u003e1.0\u003c/code\u003e으로 간주되지만, 이 PEP는 레거시 API를 어떤 방식으로든 수정하지 않습니다.\u003c/p\u003e\n\u003cp\u003e따라서 이 PEP에서 제안하는 API는 버전 번호 \u003ccode\u003e2.0\u003c/code\u003e을 가집니다.\u003c/p\u003e\n\u003cp\u003e업로드 API의 주 버전 및 부 버전 번호는 PEP 프로세스를 통해서만 변경되어야 합니다. 인덱스 운영자 및 구현자는 승인된 PEP 없이는 새로운 API 버전을 광고하거나 구현해서는 안 됩니다. 이는 모든 구현에서 일관성을 보장하고 생태계의 파편화를 방지합니다.\u003c/p\u003e\n\u003ch4\u003e콘텐츠 타입 (Content Types)\u003c/h4\u003e\n\u003cp\u003ePEP 691과 마찬가지로, 이 PEP는 이 업로드 API의 모든 요청 및 응답이 콘텐츠가 무엇인지, 어떤 버전의 API를 나타내는지, 어떤 직렬화 (serialization) 형식이 사용되었는지를 설명하는 표준 콘텐츠 타입을 가질 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e이 표준 요청 콘텐츠 타입은 파일 업로드 메커니즘을 실행하기 위한 요청을 제외한 모든 요청에 적용되며, 해당 메커니즘의 문서에 의해 지정될 것입니다.\u003c/p\u003e\n\u003cp\u003e다른 모든 요청에 대한 \u003ccode\u003eContent-Type\u003c/code\u003e 헤더의 구조는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eapplication/vnd.pypi.upload.$version+$format\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e부 API 버전 차이는 방해적이지 않아야 하므로, 주 버전만 콘텐츠 타입에 포함됩니다. 버전 번호는 \u003ccode\u003ev\u003c/code\u003e 접두사가 붙습니다.\u003c/p\u003e\n\u003cp\u003e클라이언트 요청의 \u003ccode\u003e.meta.api-version\u003c/code\u003e JSON 키에 지정된 주 API 버전은 \u003ccode\u003eContent-Type\u003c/code\u003e 헤더의 주 버전과 일치해야 합니다.\u003c/p\u003e\n\u003cp\u003ePEP 691과 달리, 이 PEP는 기존 레거시 1.0 업로드 API를 어떤 방식으로든 변경하지 않으므로, 서버는 이 PEP에 설명된 새로운 API를 기존 업로드 API와 다른 엔드포인트에서 호스팅해야 합니다.\u003c/p\u003e\n\u003cp\u003eJSON이 이 PEP에 정의된 유일한 요청 형식이므로, 이 PEP에 정의된 모든 파일 업로드 외 요청은 다음 \u003ccode\u003eContent-Type\u003c/code\u003e 헤더 값을 포함해야 합니다:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eapplication/vnd.pypi.upload.v2+json\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003ePEP 691과 유사하게, 이 PEP는 또한 서버 중심의 콘텐츠 협상 (server-driven content negotiation)을 사용하여 클라이언트가 다른 버전이나 직렬화 형식을 요청할 수 있도록 표준화하며, 이는 콘텐츠 타입의 \u003ccode\u003eformat\u003c/code\u003e 부분을 포함합니다. 그러나 이 PEP는 기존 레거시 1.0 업로드 API가 다른 엔드포인트에 존재할 것으로 예상하고 현재 JSON 직렬화만 제공하므로 이 메커니즘은 특별히 유용하지 않습니다. 클라이언트는 요청할 수 있는 단일 버전과 직렬화만 가집니다. 그러나 클라이언트는 향후 추가 형식이나 버전이 추가될 경우 콘텐츠 협상을 원활하게 처리할 준비가 되어 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e서버는 승인된 PEP에 정의된 API 버전 외의 버전에 대한 지원을 광고해서는 안 됩니다. 새로운 버전이나 형식은 새로운 PEP를 통한 표준화를 요구합니다.\u003c/p\u003e\n\u003cp\u003e달리 명시되지 않는 한, 이 문서의 모든 HTTP 요청 및 응답에는 \u003ccode\u003eContent-Type: application/vnd.pypi.upload.v2+json\u003c/code\u003e HTTP 헤더가 포함된 것으로 가정합니다.\u003c/p\u003e\n\u003ch4\u003e루트 엔드포인트 (Root Endpoint)\u003c/h4\u003e\n\u003cp\u003e여기에 설명된 모든 URL은 도메인의 URL 구조 내 어디에나 위치할 수 있는 \"루트 엔드포인트\"를 기준으로 합니다. 예를 들어, 루트 엔드포인트는 \u003ccode\u003ehttps://upload.example.com/\u003c/code\u003e 또는 \u003ccode\u003ehttps://example.com/upload/\u003c/code\u003e일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e루트 엔드포인트의 선택은 인덱스 운영자에게 맡겨집니다.\u003c/p\u003e\n\u003ch4\u003eUpload 2.0 API를 위한 인증 (Authentication for Upload 2.0 API)\u003c/h4\u003e\n\u003cp\u003e이 사양의 모든 엔드포인트는 RFC 7235에 정의된 표준 HTTP 인증 메커니즘을 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003e인증은 표준 HTTP 패턴을 따릅니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e인증이 필요할 때 서버는 \u003ccode\u003eWWW-Authenticate\u003c/code\u003e 응답 헤더를 사용합니다.\u003c/li\u003e\n\u003cli\u003e클라이언트는 \u003ccode\u003eAuthorization\u003c/code\u003e 요청 헤더를 통해 자격 증명 (credentials)을 제공합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e401 Unauthorized\u003c/code\u003e는 누락되거나 유효하지 않은 인증을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e403 Forbidden\u003c/code\u003e은 불충분한 권한을 나타냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e특정 인증 체계 (예: Bearer, Basic, Digest)는 인덱스 운영자가 결정합니다.\u003c/p\u003e\n\u003ch4\u003e오류 (Errors)\u003c/h4\u003e\n\u003cp\u003e콘텐츠를 포함하는 모든 오류 응답은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"meta\": {\n    \"api-version\": \"2.0\"\n  },\n  \"message\": \"...\",\n  \"errors\": [\n    {\n      \"source\": \"...\",\n      \"message\": \"...\"\n    }\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e표준 \u003ccode\u003emeta\u003c/code\u003e 키 외에, 다음과 같은 최상위 키를 가집니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emessage\u003c/code\u003e: 이 요청에서 발생했을 수 있는 모든 오류를 요약하는 단일 메시지.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eerrors\u003c/code\u003e: 특정 오류의 배열로, 각 오류는 오류의 출처를 나타내는 문자열인 \u003ccode\u003esource\u003c/code\u003e 키와 해당 특정 오류에 대한 \u003ccode\u003emessage\u003c/code\u003e 키를 포함합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003emessage\u003c/code\u003e 및 \u003ccode\u003esource\u003c/code\u003e 문자열에는 특정 의미가 없으며, 근본적인 문제를 진단하는 데 도움이 되는 인간 해석을 위한 것입니다.\u003c/p\u003e\n\u003ch4\u003e퍼블리싱 세션 (Publishing Session)\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e퍼블리싱 세션 생성 (Create a Publishing Session)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e릴리스는 새로운 퍼블리싱 세션을 생성하는 것으로 시작됩니다. 세션을 생성하기 위해 클라이언트는 다음과 같은 POST 요청을 루트 URL로 제출합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"meta\": {\n    \"api-version\": \"2.0\"\n  },\n  \"name\": \"foo\",\n  \"version\": \"1.0\",\n  \"nonce\": \"\u0026#x3C;string\u003e\"\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e요청에는 다음과 같은 최상위 키가 포함됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emeta\u003c/code\u003e (필수): 페이로드 자체에 대한 정보를 설명합니다. 현재, 유일하게 정의된 하위 키는 \u003ccode\u003eapi-version\u003c/code\u003e이며, 그 값은 문자열 \"2.0\"이어야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ename\u003c/code\u003e (필수): 이 세션이 새 버전을 릴리스하려는 프로젝트의 이름입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eversion\u003c/code\u003e (필수): 이 세션이 파일을 추가하려는 프로젝트의 버전입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enonce\u003c/code\u003e (선택 사항): \"퍼블리싱 세션 토큰\" 알고리즘에 대한 추가 클라이언트 측 문자열 입력입니다. 자세한 내용은 아래에 제공되지만, 이 키가 생략되면 빈 문자열을 전달하는 것과 동일합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e성공적인 세션 생성 시, 서버는 \u003ccode\u003e201 Created\u003c/code\u003e 응답을 반환합니다. 오류가 발생하면 \"Errors\" 섹션에 설명된 대로 적절한 \u003ccode\u003e4xx\u003c/code\u003e 코드가 반환됩니다.\u003c/p\u003e\n\u003cp\u003e이전 릴리스가 없는 프로젝트에 대해 세션이 생성되는 경우, 인덱스는 세션이 퍼블리싱되기 전에 프로젝트 이름을 예약할 수 있습니다. 그러나 스테이지가 퍼블리싱될 때까지 \"정상적인\" (즉, 스테이징되지 않은) 접근 프로토콜을 사용하여 해당 프로젝트로 이동할 수 없어야 합니다. 이 첫 번째 릴리스 스테이지가 취소되면 인덱스는 마치 업로드되지 않은 것처럼 프로젝트 레코드를 삭제해야 합니다.\u003c/p\u003e\n\u003cp\u003e세션은 이를 생성한 사용자가 소유하며, 모든 후속 요청은 동일한 자격 증명으로 수행되어야 합니다. 그렇지 않으면 후속 요청에 대해 \u003ccode\u003e403 Forbidden\u003c/code\u003e이 반환됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e응답 본문 (Response Body)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e성공적인 응답은 다음 콘텐츠를 포함합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"meta\": {\n    \"api-version\": \"2.0\"\n  },\n  \"links\": {\n    \"stage\": \"...\",\n    \"upload\": \"...\",\n    \"session\": \"...\",\n  },\n  \"mechanisms\": [\"http-post-bytes\"],\n  \"session-token\": \"\u0026#x3C;token-string\u003e\",\n  \"expires-at\": \"2025-08-01T12:00:00Z\",\n  \"status\": \"pending\",\n  \"files\": {},\n  \"notices\": [\n    \"a notice to display to the user\"\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e요청 JSON과 동일한 형식을 가진 \u003ccode\u003emeta\u003c/code\u003e 키 외에, 성공 응답은 다음과 같은 키를 가집니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elinks\u003c/code\u003e: 이 세션과 관련된 URL을 키에 매핑하는 사전입니다. 자세한 내용은 아래에 제공됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emechanisms\u003c/code\u003e: 서버가 지원하는 파일 업로드 메커니즘 목록으로, 서버가 선호하는 순서로 정렬됩니다. 최소 하나의 값이 필요합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esession-token\u003c/code\u003e: 인덱스가 스테이징된 릴리스의 미리 보기를 지원하는 경우, 이 키는 릴리스가 퍼블리싱되기 전에 스테이징된 릴리스를 미리 볼 수 있도록 설치 프로그램에 제공될 수 있는 고유한 \"세션 토큰\"을 포함합니다. 인덱스가 스테이지 미리 보기를 지원하지 않는 경우, 이 키는 생략되어야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eexpires-at\u003c/code\u003e: 서버가 이 세션과 그 콘텐츠(업로드된 파일 및 세션과 관련된 URL 링크 포함)를 언제 만료할지를 나타내는 ISO8601 형식의 타임스탬프 문자열입니다. 클라이언트가 세션을 취소하거나 퍼블리싱하지 않는 한 세션은 최소한 이 시간까지 활성 상태를 유지해야 합니다. 서버는 이 만료 시간을 연장할 수 있지만, 절대 앞당겨서는 안 됩니다. 클라이언트는 세션 상태를 쿼리하여 세션의 현재 만료 시간을 얻을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estatus\u003c/code\u003e: \u003ccode\u003epending\u003c/code\u003e, \u003ccode\u003epublished\u003c/code\u003e, \u003ccode\u003eerror\u003c/code\u003e, 또는 \u003ccode\u003ecanceled\u003c/code\u003e 중 하나를 포함하는 문자열로, 세션의 전체 상태를 나타냅니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efiles\u003c/code\u003e: 이 세션에 업로드된 파일 이름과 이 세션에서 참조된 각 파일에 대한 세부 정보를 포함하는 매핑으로 구성된 매핑입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enotices\u003c/code\u003e: 서버가 최종 사용자에게 전달하고자 하는 사람이 읽을 수 있는 정보성 알림 배열을 가리키는 선택적 키입니다. 이러한 알림은 세션 내의 특정 파일이 아니라 전체 세션에 대한 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e퍼블리싱 세션 링크 (Publishing Session Links)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e성공 JSON의 \u003ccode\u003elinks\u003c/code\u003e 키에 대해 다음 하위 키가 유효합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eupload\u003c/code\u003e: 클라이언트가 이 세션에 포함될 각 파일에 대한 파일 업로드 세션을 시작하는 데 사용할 엔드포인트.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estage\u003c/code\u003e: 이 스테이징된 릴리스를 세션 퍼블리싱 전에 미리 볼 수 있는 엔드포인트. 이는 아직 공개되지 않은 파일을 다운로드하고 검증하는 데 사용할 수 있습니다. 인덱스가 스테이징된 릴리스 미리 보기를 지원하지 않는 경우, 이 키는 생략되어야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esession\u003c/code\u003e: 이 세션에 대한 작업을 수행할 수 있는 엔드포인트로, 이 세션 퍼블리싱, 세션 취소 및 폐기, 현재 세션 상태 쿼리, 세션 수명 연장 요청 (서버가 지원하는 경우)을 포함합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e퍼블리싱 세션 파일 (Publishing Session Files)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efiles\u003c/code\u003e 키는 이 세션에 업로드된 파일 이름을 다음 키를 포함하는 하위 매핑에 매핑합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003estatus\u003c/code\u003e: \u003ccode\u003epending\u003c/code\u003e, \u003ccode\u003eprocessing\u003c/code\u003e, \u003ccode\u003ecomplete\u003c/code\u003e, \u003ccode\u003eerror\u003c/code\u003e, 및 \u003ccode\u003ecanceled\u003c/code\u003e 중 유효한 값을 가진 문자열입니다. 업로드 중 오류가 발생한 경우, 클라이언트는 파일이 사용 가능한 상태라고 가정해서는 안 되며, \u003ccode\u003eerror\u003c/code\u003e가 반환되고 파일을 취소하거나 삭제하고 다시 시작하는 것이 가장 좋습니다. 이 작업은 세션 상태 응답 본문의 \u003ccode\u003efiles\u003c/code\u003e 키에서 파일 이름을 제거합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elink\u003c/code\u003e: 클라이언트가 이 특정 파일을 참조하는 데 사용해야 하는 절대 URL입니다. 이 URL은 참조된 파일을 검색, 교체 또는 삭제하는 데 사용됩니다. \u003ccode\u003enonce\u003c/code\u003e가 제공된 경우, 이 URL은 \"Publishing Session Token\" 섹션에 설명된 대로 추측 불가능한 토큰으로 난독화되어야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enotices\u003c/code\u003e: \u003ccode\u003enotices\u003c/code\u003e 세션 키와 유사한 형식과 의미를 가진 선택적 키입니다. 단, 이 알림은 참조된 파일에 특정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e동일한 \u003ccode\u003ename-version\u003c/code\u003e 쌍에 대해 세션이 \u003ccode\u003epending\u003c/code\u003e 상태인 동안 두 번째 세션이 생성되면, 서버는 새롭고 비어 있는 세션을 생성하는 대신 이미 존재하는 세션에 대한 JSON 상태 응답과 함께 \u003ccode\u003e200 OK\u003c/code\u003e 상태 코드를 반환해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e퍼블리싱 세션 완료 (Complete a Publishing Session)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e세션을 완료하고 포함된 파일을 퍼블리싱하려면, 클라이언트는 세션 생성 응답 본문에 제공된 \u003ccode\u003esession\u003c/code\u003e 링크로 POST 요청을 발행합니다.\u003c/p\u003e\n\u003cp\u003e요청은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"meta\": {\n    \"api-version\": \"2.0\"\n  },\n  \"action\": \"publish\",\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서버가 퍼블리싱 세션을 즉시 완료할 수 있는 경우, 그렇게 하고 \u003ccode\u003e201 Created\u003c/code\u003e 응답을 반환할 수 있습니다. 즉시 완료할 수 없는 경우 (예: 단일 HTTP 요청에서 합리적인 시간보다 오래 걸릴 수 있는 유효성 검사가 필요한 경우), \u003ccode\u003e202 Accepted\u003c/code\u003e 응답을 반환할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e어떤 경우든, 서버는 퍼블리싱 세션 상태 URL을 가리키는 \u003ccode\u003eLocation\u003c/code\u003e 헤더를 포함해야 하며, 서버가 \u003ccode\u003e202 Accepted\u003c/code\u003e를 반환한 경우 클라이언트는 해당 URL을 폴링하여 상태 변경을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e오류가 발생하면 \"Errors\" 섹션에 설명된 대로 적절한 \u003ccode\u003e4xx\u003c/code\u003e 코드가 반환되어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e취소 (Cancellation)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e퍼블리싱 세션을 취소하려면, 클라이언트는 세션 생성 응답 본문에 제공된 \u003ccode\u003esession\u003c/code\u003e 링크로 DELETE 요청을 발행합니다. 그러면 서버는 세션을 취소로 표시하고, 해당 세션의 일부로 업로드된 모든 데이터를 삭제해야 합니다. 향후 해당 세션 URL 또는 퍼블리싱 세션 URL에 접근하려는 시도는 \u003ccode\u003e404 Not Found\u003c/code\u003e를 반환해야 합니다.\u003c/p\u003e\n\u003cp\u003e매달린 세션 (dangling sessions)을 방지하기 위해 서버는 시간 초과된 세션을 자체적으로 취소할 수도 있습니다. 서버는 세션을 최소 일주일 후에 삭제하는 것이 권장되지만, 각 서버는 자체 일정을 선택할 수 있습니다. 서버는 클라이언트가 지시하는 세션 연장을 지원할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e퍼블리싱 세션 토큰 (Publishing Session Token)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e퍼블리싱 세션을 생성할 때, 클라이언트는 초기 세션 생성 요청에 \u003ccode\u003enonce\u003c/code\u003e를 제공할 수 있습니다. 이 \u003ccode\u003enonce\u003c/code\u003e는 임의의 콘텐츠를 가진 문자열입니다. \u003ccode\u003enonce\u003c/code\u003e는 선택 사항이며, 생략되면 빈 문자열을 제공하는 것과 동일합니다.\u003c/p\u003e\n\u003cp\u003e스테이징된 업로드의 미리 보기를 지원하기 위해 패키지 이름 (\u003ccode\u003ename\u003c/code\u003e) 및 버전 (\u003ccode\u003eversion\u003c/code\u003e)과 이 \u003ccode\u003enonce\u003c/code\u003e는 해싱 알고리즘의 입력으로 사용되어 고유한 \"세션 토큰\"을 생성합니다. 이 세션 토큰은 세션의 수명 (즉, 취소 또는 퍼블리싱을 통해 완료될 때까지) 동안 유효하며, 지원하는 설치 프로그램에 제공되어 스테이징된 릴리스에 접근할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enonce\u003c/code\u003e의 사용은 클라이언트가 스테이징된 릴리스의 가시성을 모호하게 할지 여부를 결정할 수 있도록 하며, 양쪽 선택에 대한 좋은 이유가 있을 수 있습니다. 예를 들어, CI 시스템이 새 릴리스를 위해 일부 휠을 업로드하고 퍼블리싱하기 전에 스테이지의 독립적인 유효성 검사를 허용하려면 클라이언트는 \u003ccode\u003enonce\u003c/code\u003e를 포함하지 않기로 선택할 수 있습니다. 반면에, 클라이언트가 공개 발표 시점에 원자적으로 퍼블리싱하는 릴리스를 미리 시드 (pre-seed)하려면, 해당 클라이언트는 \u003ccode\u003enonce\u003c/code\u003e를 제공하기로 선택할 가능성이 높습니다.\u003c/p\u003e\n\u003cp\u003eSHA256 알고리즘은 이러한 입력을 고유한 토큰으로 변환하는 데 사용되며, \u003ccode\u003ename\u003c/code\u003e, \u003ccode\u003eversion\u003c/code\u003e, \u003ccode\u003enonce\u003c/code\u003e 순서로 다음 Python 코드를 예시로 사용합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom hashlib import sha256\n\ndef gentoken(name: bytes, version: bytes, nonce: bytes = b''):\n    h = sha256()\n    h.update(name)\n    h.update(version)\n    h.update(nonce)\n    return h.hexdigest()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e세션 생성 요청에 \u003ccode\u003enonce\u003c/code\u003e가 제공되지 않으면 세션 토큰은 패키지 이름과 버전 번호만으로 쉽게 추측할 수 있다는 점이 분명해야 합니다. 클라이언트는 세션 토큰에 접근할 수 없는 누구에게나 미리 보기를 허용하려면 \u003ccode\u003enonce\u003c/code\u003e를 생략 (또는 빈 문자열로 설정)하도록 선택할 수 있습니다. 비어 있지 않은 \u003ccode\u003enonce\u003c/code\u003e를 제공함으로써 클라이언트는 보안-through-obscurity를 선택할 수 있지만, 이는 스테이징된 파일을 어떤 종류의 인증으로도 보호하지는 않습니다.\u003c/p\u003e\n\u003ch4\u003e파일 업로드 세션 (File Upload Session)\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e파일 업로드 세션 생성 (Create a File Upload Session)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e퍼블리싱 세션을 생성한 후, 응답의 세션 링크 매핑에서 \u003ccode\u003eupload\u003c/code\u003e 엔드포인트는 해당 세션으로 새 파일 업로드를 시작하는 데 사용됩니다. 클라이언트는 제공된 업로드 URL을 사용해야 하며, 한 세션에서 다음 세션으로 해당 URL에 어떤 패턴이나 공통성이 있다고 가정해서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e파일 업로드를 시작하려면, 클라이언트는 먼저 \u003ccode\u003eupload\u003c/code\u003e URL로 POST 요청을 보냅니다. 요청은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"meta\": {\n    \"api-version\": \"2.0\"\n  },\n  \"filename\": \"foo-1.0.tar.gz\",\n  \"size\": 1000,\n  \"hashes\": {\"sha256\": \"...\", \"blake2b\": \"...\"},\n  \"metadata\": \"...\",\n  \"mechanism\": \"http-post-bytes\"\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e표준 \u003ccode\u003emeta\u003c/code\u003e 키 외에, 요청 JSON에는 다음과 같은 추가 키가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efilename\u003c/code\u003e (필수): 업로드되는 파일의 이름.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esize\u003c/code\u003e (필수): 업로드되는 파일의 크기 (바이트 단위).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehashes\u003c/code\u003e (필수): 해시 이름을 16진수로 인코딩된 다이제스트에 매핑하는 것입니다. 각 다이제스트는 이름에 식별된 알고리즘으로 해싱될 때 업로드되는 파일의 체크섬입니다. 기본적으로 \u003ccode\u003ehashlib\u003c/code\u003e에서 사용할 수 있는 모든 해시 알고리즘은 \u003ccode\u003ehashes\u003c/code\u003e 딕셔너리의 키로 사용될 수 있습니다. \u003ccode\u003ehashlib.algorithms_guaranteed\u003c/code\u003e에서 최소 하나의 안전한 알고리즘은 항상 포함되어야 합니다. 이 PEP는 특히 \u003ccode\u003esha256\u003c/code\u003e을 권장합니다. 여러 해시를 한 번에 전달할 수 있지만, 제공된 모든 해시는 파일에 대해 유효해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emechanism\u003c/code\u003e (필수): 클라이언트가 이 파일에 사용할 파일 업로드 메커니즘. 이 메커니즘은 퍼블리싱 세션 응답 본문에 광고된 메커니즘 목록에서 선택되어야 합니다. 클라이언트는 서버 운영자가 \"사전 릴리스 (pre-release)\" 기준으로 사용할 수 있는 새롭거나 예정된 메커니즘을 문서화한 경우 광고되지 않은 메커니즘을 보낼 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emetadata\u003c/code\u003e (선택 사항): 제공된 경우, 파일의 코어 메타데이터를 포함하는 문자열 값입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e서버는 이 요청에 제공된 데이터를 사용하여 파일 업로드를 허용하기 전에 일부 유효성 검사 (sanity checking)를 수행할 수 있습니다. 이러한 검사는 다음을 포함할 수 있지만 이에 국한되지 않습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efilename\u003c/code\u003e이 이미 퍼블리싱된 릴리스에 존재하는지 확인.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esize\u003c/code\u003e가 프로젝트 또는 파일 할당량을 초과하는지 확인.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emetadata\u003c/code\u003e (제공된 경우)의 내용이 유효한지 확인.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e서버가 업로드를 진행해야 한다고 판단하면, 아래 응답 본문과 함께 \u003ccode\u003e202 Accepted\u003c/code\u003e 응답을 반환합니다. 세션 상태에는 \u003ccode\u003efiles\u003c/code\u003e 매핑에 파일 이름도 포함됩니다. 클라이언트가 제공한 메커니즘이 지원되지 않아 서버가 업로드를 진행할 수 없는 경우 \u003ccode\u003e422 Unprocessable Entity\u003c/code\u003e를 반환해야 합니다. 서버가 업로드를 진행할 수 없다고 판단하면 \u003ccode\u003e409 Conflict\u003c/code\u003e를 반환해야 합니다. 서버는 파일의 병렬 업로드를 허용할 수 있지만, 필수는 아닙니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e응답 본문 (Response Body)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e성공적인 응답은 다음을 포함합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"meta\": {\n    \"api-version\": \"2.0\"\n  },\n  \"links\": {\n    \"publishing-session\": \"...\",\n    \"file-upload-session\": \"...\"\n  },\n  \"status\": \"pending\",\n  \"expires-at\": \"2025-08-01T13:00:00Z\",\n  \"mechanism\": {\n    \"identifier\": \"http-post-bytes\",\n    \"file_url\": \"...\",\n    \"attestations_url\": \"...\"\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e클라이언트에게 다음 상태 업데이트를 위해 언제 폴링해야 하는지 알려주기 위해 \u003ccode\u003eRetry-After\u003c/code\u003e 응답 헤더가 존재해야 합니다.\u003c/p\u003e\n\u003cp\u003e요청 JSON과 동일한 형식을 가진 \u003ccode\u003emeta\u003c/code\u003e 키 외에, 성공 응답은 다음과 같은 키를 가집니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elinks\u003c/code\u003e: 이 세션과 관련된 URL을 키에 매핑하는 사전입니다. 자세한 내용은 아래에 제공됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estatus\u003c/code\u003e: \u003ccode\u003epending\u003c/code\u003e, \u003ccode\u003eprocessing\u003c/code\u003e, \u003ccode\u003ecomplete\u003c/code\u003e, \u003ccode\u003eerror\u003c/code\u003e, 및 \u003ccode\u003ecanceled\u003c/code\u003e 중 유효한 값을 가진 문자열로, 파일 업로드 세션의 현재 상태를 나타냅니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eexpires-at\u003c/code\u003e: 서버가 이 파일 업로드 세션을 언제 만료할지를 나타내는 ISO8601 형식의 타임스탬프 문자열입니다. 클라이언트가 세션을 취소하거나 완료하지 않는 한 세션은 최소한 이 시간까지 활성 상태를 유지해야 합니다. 서버는 이 만료 시간을 연장할 수 있지만, 절대 앞당겨서는 안 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emechanism\u003c/code\u003e: 클라이언트와 서버가 협상한 지원 메커니즘에 필요한 세부 정보를 포함하는 매핑입니다. 이 매핑은 선택된 파일 업로드 메커니즘의 식별자 문자열에 매핑되는 \u003ccode\u003eidentifier\u003c/code\u003e 키를 포함해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e파일 업로드 세션 링크 (File Upload Session Links)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e성공 JSON의 \u003ccode\u003elinks\u003c/code\u003e 키에 대해 다음 하위 키가 유효합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epublishing-session\u003c/code\u003e: 상위 퍼블리싱 세션에 대한 작업을 수행할 수 있는 엔드포인트.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efile-upload-session\u003c/code\u003e: 이 파일 업로드 세션에 대한 작업을 수행할 수 있는 엔드포인트로, 파일 업로드 세션 취소 및 폐기, 현재 파일 업로드 세션 상태 쿼리, 파일 업로드 세션 수명 연장 요청 (서버가 지원하는 경우)을 포함합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e파일 업로드 세션 완료 (Complete a File Upload Session)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e파일 업로드 세션을 완료하려면 (이는 파일 업로드 메커니즘이 실행되었고 오류를 생성하지 않았음을 나타냄), 클라이언트는 파일 업로드 세션 생성 응답 본문의 \u003ccode\u003efile-upload-session\u003c/code\u003e 링크로 POST 요청을 발행합니다.\u003c/p\u003e\n\u003cp\u003e요청은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"meta\": {\n    \"api-version\": \"2.0\"\n  },\n  \"action\": \"complete\",\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서버가 파일 업로드 세션을 즉시 완료할 수 있는 경우, 그렇게 하고 \u003ccode\u003e201 Created\u003c/code\u003e 응답을 반환하고 파일 업로드 세션의 상태를 \u003ccode\u003ecomplete\u003c/code\u003e로 설정할 수 있습니다. 즉시 완료할 수 없는 경우 (예: 단일 HTTP 요청에서 합리적인 시간보다 오래 걸릴 수 있는 유효성 검사가 필요한 경우), \u003ccode\u003e202 Accepted\u003c/code\u003e 응답을 반환하고 파일 업로드 세션의 상태를 \u003ccode\u003eprocessing\u003c/code\u003e으로 설정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e어떤 경우든, 서버는 파일 업로드 세션 상태 URL을 가리키는 \u003ccode\u003eLocation\u003c/code\u003e 헤더를 포함해야 합니다.\u003c/p\u003e\n\u003cp\u003e서버는 클라이언트가 파일 업로드 세션 상태 URL을 폴링하여 상태 변경을 확인할 수 있도록 허용해야 합니다. 서버가 \u003ccode\u003e202 Accepted\u003c/code\u003e로 응답하면, 클라이언트는 파일 업로드 세션 상태 URL을 폴링하여 상태 변경을 확인할 수 있습니다. 클라이언트는 파일 업로드 세션 상태 응답의 \u003ccode\u003eRetry-After\u003c/code\u003e 헤더 값을 존중해야 합니다.\u003c/p\u003e\n\u003cp\u003e오류가 발생하면 \"Errors\" 섹션에 설명된 대로 적절한 \u003ccode\u003e4xx\u003c/code\u003e 코드가 반환되어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e취소 및 삭제 (Cancellation and Deletion)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e클라이언트는 진행 중인 파일 업로드 세션을 취소하거나 완전히 업로드된 파일을 삭제할 수 있습니다. 두 경우 모두 클라이언트는 삭제하려는 파일의 파일 업로드 세션 URL로 DELETE 요청을 발행하여 이를 수행합니다.\u003c/p\u003e\n\u003cp\u003e성공적인 삭제 요청은 \u003ccode\u003e204 No Content\u003c/code\u003e로 응답해야 합니다.\u003c/p\u003e\n\u003cp\u003e취소 또는 삭제되면 클라이언트는 이전 파일 업로드 세션 리소스 또는 관련 파일 업로드 메커니즘이 재사용될 수 있다고 가정해서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e부분적 또는 완전히 업로드된 파일 교체 (Replacing a Partially or Fully Uploaded File)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e세션 파일을 교체하려면 파일 업로드가 이전에 완료되었거나 취소되었거나 삭제되었어야 합니다. 해당 파일의 업로드가 진행 중인 경우에는 파일을 교체할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e세션 파일을 교체하려면 클라이언트는 교체하려는 파일의 업로드 리소스 URL로 DELETE를 발행하여 진행 중인 업로드를 취소하고 삭제해야 합니다. 이 후, 전체 파일 업로드 시퀀스를 다시 시작하여 새 파일 업로드를 시작할 수 있습니다. 이는 새로운 업로드 리소스 URL을 검색하기 위해 메타데이터 요청을 다시 제공하는 것을 의미합니다. 클라이언트는 삭제 후 이전 업로드 리소스 URL이 재사용될 수 있다고 가정해서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e세션 상태 (Session Status)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e언제든지 클라이언트는 각각 세션 생성 응답 본문 또는 파일 업로드 세션 생성 응답 본문에 제공된 \u003ccode\u003epublishing-session\u003c/code\u003e 링크 또는 \u003ccode\u003efile-upload-session\u003c/code\u003e 링크로 GET 요청을 발행하여 세션의 상태를 쿼리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e서버는 이 GET 요청에 대해 초기 퍼블리싱 세션 또는 파일 업로드 세션을 생성했을 때와 동일한 퍼블리싱 세션 생성 응답 본문 또는 파일 업로드 세션 생성 응답 본문으로 응답합니다. 단, \u003ccode\u003estatus\u003c/code\u003e, \u003ccode\u003eexpires-at\u003c/code\u003e, 또는 \u003ccode\u003efiles\u003c/code\u003e에 대한 변경 사항이 반영됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e세션 연장 (Session Extension)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e서버는 클라이언트가 세션을 연장하도록 허용할 수 있지만, 전체 수명과 허용되는 연장 횟수는 서버에 맡겨집니다. 세션을 연장하려면, 클라이언트는 각각 퍼블리싱 세션 생성 응답 본문 또는 파일 업로드 세션 생성 응답 본문에 제공된 \u003ccode\u003epublishing-session\u003c/code\u003e 링크 또는 \u003ccode\u003efile-upload-session\u003c/code\u003e 링크로 POST 요청을 발행합니다.\u003c/p\u003e\n\u003cp\u003e요청은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \"meta\": {\n    \"api-version\": \"2.0\"\n  },\n  \"action\": \"extend\",\n  \"extend-for\": 3600\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지정된 초 단위 숫자는 현재 세션을 추가로 연장할 시간 (초)에 대한 서버에 대한 제안일 뿐입니다. 예를 들어, 클라이언트가 현재 세션을 한 시간 더 연장하려면 \u003ccode\u003eextend-for\u003c/code\u003e는 \u003ccode\u003e3600\u003c/code\u003e이 됩니다. 성공적인 연장 시, 서버는 초기 퍼블리싱 세션 또는 파일 업로드 세션을 생성했을 때와 동일한 퍼블리싱 세션 생성 응답 본문 또는 파일 업로드 세션 생성 응답 본문으로 응답합니다. 단, \u003ccode\u003estatus\u003c/code\u003e, \u003ccode\u003eexpires-at\u003c/code\u003e, 또는 \u003ccode\u003efiles\u003c/code\u003e에 대한 변경 사항이 반영됩니다.\u003c/p\u003e\n\u003cp\u003e서버가 요청된 시간 (초)만큼 세션을 연장하기를 거부하더라도 성공 응답을 반환하며, \u003ccode\u003eexpires-at\u003c/code\u003e 키는 단순히 세션의 현재 만료 시간을 반영합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e스테이지 미리 보기 (Stage Previews)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e퍼블리싱되기 전에 스테이징된 릴리스를 미리 볼 수 있는 기능은 이 PEP의 중요한 기능이며, 릴리스가 대중에게 공개되기 전에 추가적인 최종 테스트 수준을 가능하게 합니다. 인덱스는 퍼블리싱 세션이 생성될 때 반환되는 \u003ccode\u003elinks\u003c/code\u003e 키의 \u003ccode\u003estage\u003c/code\u003e 하위 키에 제공된 URL을 통해 이 기능을 제공할 수 있습니다. \u003ccode\u003estage\u003c/code\u003e URL은 \u003ccode\u003e--extra-index-url\u003c/code\u003e 플래그를 이 값으로 설정하여 \u003ccode\u003epip\u003c/code\u003e와 같은 설치 프로그램에 전달할 수 있습니다. 이 플래그를 여러 값으로 반복하여 여러 스테이지를 미리 볼 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e지원되는 경우, 인덱스는 스테이징된 릴리스를 설치 프로그램 도구에 노출하는 뷰를 반환하여 최종 테스트를 위해 구축된 가상 환경에 다운로드하고 설치할 수 있도록 합니다. 이 옵션을 사용하면 기존 설치 프로그램이 설치 프로그램 도구에 변경 사항 없이 스테이징된 릴리스를 미리 볼 수 있습니다. 이 사용자 경험의 세부 사항은 설치 프로그램 도구 유지 관리자에게 맡겨집니다.\u003c/p\u003e\n\u003ch4\u003e파일 업로드 메커니즘 (File Upload Mechanisms)\u003c/h4\u003e\n\u003cp\u003e서버는 필수 파일 업로드 메커니즘을 구현해야 합니다. 이러한 메커니즘은 서버별 구현이 없는 경우 대체 (fallback) 역할을 합니다.\u003c/p\u003e\n\u003cp\u003e업로드 API의 각 주 버전은 최소 하나의 필수 파일 업로드 메커니즘을 지정해야 합니다.\u003c/p\u003e\n\u003cp\u003e주 버전 업데이트 없이는 새로운 필수 메커니즘을 추가하거나 기존 필수 메커니즘을 제거해서는 안 됩니다. 추가되거나 제거되는 서버별 또는 실험적 메커니즘은 이 사양의 주 또는 부 버전 번호를 변경해서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e필수 파일 업로드 메커니즘 (Required File Upload Mechanisms)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ehttp-post-bytes\u003c/code\u003e\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e업로드 API 버전 2.0을 준수하는 서버는 \u003ccode\u003ehttp-post-bytes\u003c/code\u003e 메커니즘을 지원해야 합니다.\u003c/li\u003e\n\u003cli\u003e이 메커니즘은 Upload 2.0 프로토콜 엔드포인트의 나머지 부분과 동일한 인증 체계를 사용해야 합니다.\u003c/li\u003e\n\u003cli\u003e클라이언트는 파일 업로드 세션 생성 응답 본문의 \u003ccode\u003emechanism\u003c/code\u003e 맵 내 \u003ccode\u003ehttp-post-bytes\u003c/code\u003e 맵에 반환된 \u003ccode\u003efile_url\u003c/code\u003e로 POST 요청을 제출하여 이 메커니즘을 실행합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003eContent-Type: application/octet-stream\n\u0026#x3C;binary contents of the file to upload\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e서버는 파일에 대한 디지털 증명 (digital attestations) 업로드를 지원할 수 있습니다 (PEP 740 참조). 이 지원은 파일 업로드 세션 생성 응답 본문의 \u003ccode\u003emechanism\u003c/code\u003e 맵 내 \u003ccode\u003ehttp-post-bytes\u003c/code\u003e 맵에 \u003ccode\u003eattestations_url\u003c/code\u003e 키를 포함하여 표시됩니다. 증명은 파일 업로드 세션 완료 전에 \u003ccode\u003eattestations_url\u003c/code\u003e로 업로드되어야 합니다.\u003c/li\u003e\n\u003cli\u003e증명을 업로드하려면, 클라이언트는 증명 객체의 JSON 배열을 포함하는 POST 요청을 \u003ccode\u003eattestations_url\u003c/code\u003e로 제출합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003eContent-Type: application/json\n[{\"version\": 1, \"verification_material\": {...}, \"envelope\": {...}},...]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e서버별 파일 업로드 메커니즘 (Server Specific File Upload Mechanisms)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e주어진 서버는 임의의 수의 서버별 메커니즘을 구현할 수 있으며, 사용법을 문서화할 책임이 있습니다.\u003c/p\u003e\n\u003cp\u003e서버별 구현 파일 업로드 메커니즘 식별자는 세 부분으로 구성됩니다:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u0026#x3C;prefix\u003e-\u0026#x3C;operator identifier\u003e-\u0026#x3C;implementation identifier\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e서버별 구현은 \u003ccode\u003evnd\u003c/code\u003e를 접두사로 사용해야 합니다. 운영자 식별자 (operator identifier)는 서버 운영자를 명확하게 식별하고, 다른 잘 알려진 인덱스와 고유하며, 영숫자 문자 \u003ccode\u003e[a-z0-9]\u003c/code\u003e만 포함해야 합니다. 구현 식별자 (implementation identifier)는 기본 구현을 간결하게 설명하고 영숫자 문자 \u003ccode\u003e[a-z0-9]\u003c/code\u003e와 \u003ccode\u003e-\u003c/code\u003e만 포함해야 합니다.\u003c/p\u003e\n\u003cp\u003e서버 운영자가 업로드 메커니즘에 중대한 변경 (breaking changes)을 해야 할 때, 기존 메커니즘을 수정하는 대신 새로운 메커니즘 식별자를 생성해야 합니다. 권장되는 패턴은 구현 식별자에 \u003ccode\u003e-v1\u003c/code\u003e, \u003ccode\u003e-v2\u003c/code\u003e 등과 같은 버전 접미사를 추가하는 것입니다. 이를 통해 클라이언트는 새로운 버전을 명시적으로 선택하면서 기존 클라이언트와의 하위 호환성을 유지할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cp\u003e| File Upload Mechanism string         | Server Operator | Mechanism description                                  |\n| :----------------------------------- | :-------------- | :----------------------------------------------------- |\n| \u003ccode\u003evnd-pypi-s3multipart-presigned\u003c/code\u003e     | PyPI            | S3 multipart upload via pre-signed URL                 |\n| \u003ccode\u003evnd-pypi-s3multipart-presigned-v2\u003c/code\u003e  | PyPI            | S3 multipart upload via pre-signed URL version 2       |\n| \u003ccode\u003evnd-pypi-http-fetch\u003c/code\u003e                | PyPI            | File delivered by instructing server to fetch from a URL via HTTP request |\n| \u003ccode\u003evnd-acmecorp-http-fetch\u003c/code\u003e            | Acme Corp       | File delivered by instructing server to fetch from a URL via HTTP request |\n| \u003ccode\u003evnd-acmecorp-postal\u003c/code\u003e                | Acme Corp       | File delivered via postal mail                         |\n| \u003ccode\u003evnd-widgetinc-stream-v1\u003c/code\u003e            | Widget Inc.     | Streaming upload protocol version 1                    |\n| \u003ccode\u003evnd-widgetinc-stream-v2\u003c/code\u003e            | Widget Inc.     | Streaming upload protocol version 2                    |\n| \u003ccode\u003evnd-madscience-quantumentanglement\u003c/code\u003e | Mad Science Labs| Upload via quantum entanglement                        |\u003c/p\u003e\n\u003cp\u003e서버가 다른 서버의 구현 동작과 정확히 일치시키려는 경우, 해당 구현의 파일 업로드 메커니즘 이름으로 응답할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003eFAQ\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003ePyPI가 기존 업로드 API 지원을 중단할 계획이라는 의미입니까?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e현재 PyPI는 기존 업로드 API 지원을 중단할 구체적인 계획이 없습니다.\u003c/p\u003e\n\u003cp\u003ePEP 691과는 달리, 그렇게 하는 데 상당한 이점이 있으므로, 레거시 업로드 API 지원이 미래의 어느 시점에 (책임 있게) 사용 중단되고 제거될 가능성이 있습니다. 그러한 미래의 사용 중단 계획은 이 PEP의 범위를 명시적으로 벗어납니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUpload 2.0 API를 사용하여 프로젝트 이름을 예약할 수 있습니까?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e예! 릴리스를 위해 파일을 업로드할 준비가 되지 않았더라도 프로젝트 이름을 예약할 수 있습니다 (물론 이름이 아직 존재하지 않는다고 가정).\u003c/p\u003e\n\u003cp\u003e이를 위해 새로운 퍼블리싱 세션을 생성한 다음, 파일을 업로드하지 않고 세션을 퍼블리싱하십시오. \u003ccode\u003ecreate session\u003c/code\u003e 요청의 JSON 본문에서 \u003ccode\u003eversion\u003c/code\u003e 키는 필수이지만, 플레이스홀더 버전 번호 \"0.0.0\"을 사용하면 됩니다.\u003c/p\u003e\n\u003cp\u003e세션을 생성한 사용자가 새 프로젝트의 소유자가 됩니다.\u003c/p\u003e\n\u003ch3\u003e공개 질문 (Open Questions)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eUpload 2.0 프로토콜 확장 (Extensions to the Upload 2.0 Protocol)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e이 PEP 검토 중에 업로드 처리 완료에 대한 비동기 웹훅 알림과 같은 기능이 논의되었습니다. 업로드 프로토콜의 기능 확장 개념이 논의되었는데, 이는 구현자가 비동기 알림 또는 웹훅과 같은 선택적 기능에 대한 지원을 광고할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e이 아이디어는 그러한 확장 프로토콜을 설계하고 Upload 2.0이 출시될 때 생태계의 과도한 파편화를 야기하지 않도록 보장하는 데 따르는 복잡성 때문에 보류되었습니다.\u003c/p\u003e\n\u003cp\u003eUpload 2.0 운영 경험이 쌓이면 업로드 프로토콜의 향후 개정에서 이러한 확장을 탐색해야 합니다.\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 라이선스에 따라 제공됩니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Draft] PEP 694 - Upload 2.0 API for Python Package Indexes\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 10:23:36+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>