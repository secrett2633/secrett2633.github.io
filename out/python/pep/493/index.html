<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/773b243a13a00265.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/app/layout-fa159ef0265a0843.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2215<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 493 - HTTPS verification migration tools for Python 2.7</h1><div class="page__meta"><time dateTime="2025-09-26 22:38:56+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0493/">PEP 493 - HTTPS verification migration tools for Python 2.7</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 10-May-2015</p>
</blockquote>
<h1>PEP 493 – Python 2.7용 HTTPS 검증 마이그레이션 도구</h1>
<ul>
<li><strong>작성자:</strong> Alyssa Coghlan, Robert Kuska, Marc-André Lemburg</li>
<li><strong>BDFL 위임자:</strong> Barry Warsaw</li>
<li><strong>상태:</strong> Final (최종)</li>
<li><strong>유형:</strong> Standards Track (표준 트랙)</li>
<li><strong>생성일:</strong> 2015년 5월 10일</li>
<li><strong>Python 버전:</strong> 2.7.12</li>
<li><strong>해결:</strong> Python-Dev message</li>
</ul>
<h2>초록 (Abstract)</h2>
<p>PEP 476은 클라이언트 모듈에서 Python의 기본 HTTPS 인증서 처리 방식을 웹 브라우저의 인증서 처리 방식과 일치시키기 위해, 클라이언트가 접속하려는 서버에 속하는 인증서가 수신되었는지 검증하도록 업데이트했습니다. Python 2.7 장기 유지보수 시리즈가 이 변경사항의 범위에 포함된다고 판단되어, 새로운 동작은 Python 2.7.9 유지보수 릴리스에 도입되었습니다.</p>
<p>이로 인해 영향을 받는 Python 2.7 유지보수 릴리스의 채택에 상당한 장벽이 생겼습니다. 따라서 이 PEP는 시스템 관리자 및 다른 사용자들이 HTTPS 클라이언트 모듈에서 서버 인증서 검증 여부를 결정하는 것과 최신 Python 2.7 유지보수 릴리스로 업데이트하는 결정을 더 쉽게 분리할 수 있도록 Python 2.7에 특화된 추가 기능을 제안합니다.</p>
<h2>배경 (Rationale)</h2>
<p>PEP 476은 HTTPS URL의 의미론에 대한 웹 브라우저의 기대치에 맞춰 Python의 기본 동작을 변경했습니다. Python 2.7.9 및 3.4.3부터 표준 라이브러리의 HTTPS 클라이언트는 기본적으로 서버 인증서를 검증합니다.</p>
<p>그러나 이러한 변경은 자체 서명 인증서(self-signed certificates)에 의존하는 사설 인트라넷을 운영하거나 새로운 기본 인증서 검증 설정에서 문제를 겪는 인프라 관리자에게 문제를 일으키기도 합니다.</p>
<p>이러한 상황을 관리하기 위해 웹 브라우저는 사용자에게 서버의 인증서를 브라우저의 인증서 저장소에 추가할 수 있도록 "클릭 스루(click through)" 경고를 제공합니다. <code>curl</code> 및 <code>wget</code>과 같은 네트워크 클라이언트 도구는 인증서 확인을 완전히 끌 수 있는 옵션(각각 <code>curl --insecure</code> 및 <code>wget --no-check-certificate</code>)을 제공합니다.</p>
<p>기술 스택의 다른 계층에서는 SELinux 및 AppArmor와 같은 Linux 보안 모듈이 배포판 벤더에 의해 기본적으로 활성화되지만, 이를 끌 수 있는 비교적 간단한 메커니즘을 제공합니다.</p>
<p>현재, 전체 프로세스에 대해 Python의 기본 인증서 확인을 비활성화하는 편리한 메커니즘은 존재하지 않습니다.</p>
<p>PEP 476은 <code>ssl</code> 모듈을 몽키 패치(monkeypatching)하여 이전 동작을 복원하는 방식으로 프로세스 전체에 걸쳐 이전 설정으로 되돌리는 방법을 다루면서 이 문제를 해결하려고 시도했습니다. 하지만 시스템 관리자가 Standard Operating Environment 정의에서 이 기능을 기본적으로 비활성화할 수 있도록 제안된 <code>sitecustomize.py</code> 기반 기술은 적어도 일부 경우에 불충분한 것으로 판명되었습니다. 이 PEP의 초기 생성으로 이어진 특정 사례는 Linux 배포자가 업스트림 CPython 2.7 릴리스를 직접 사용하는 것보다 사용자에게 더 원활한 마이그레이션 경로를 제공하려는 경우였지만, 임베디드 Python 런타임 및 기타 사용자 수준 Python 설치를 업데이트하는 데 있어서 다른 잠재적인 문제점들도 지적되었습니다.</p>
<p>상호 호환되지 않는 다양한 마이그레이션 기술이 난립하는 것을 방지하기 위해, 이 PEP는 HTTPS 클라이언트 모듈에서 인증서 검증을 건너뛰는 과거 동작으로 프로세스를 더 쉽게 되돌릴 수 있도록 Python 2.7.12에 추가될 기능을 제안합니다. 또한 이러한 기능을 Python 2.7.9 이전 버전으로 백포팅(backporting)하는 재배포자(redistributors)를 위한 추가 권장 사항도 제공합니다.</p>
<h2>대안 (Alternatives)</h2>
<p>명확한 업스트림 지침 및 권장 사항이 없는 경우에도, 상업적 재배포자는 고객의 이익을 위해 자체적인 설계 결정을 내릴 것입니다. 사용 가능한 주요 접근 방식은 다음과 같습니다.</p>
<ul>
<li>PEP 476에 정의된 메커니즘 외에 표준 라이브러리 HTTPS 클라이언트에서 검증되지 않은 호스트 이름에서 검증된 호스트 이름으로 마이그레이션하는 데 추가 지원을 제공하지 않으면서 새로운 Python 2.7.x 릴리스에 계속 리베이스(rebase)하는 것.</li>
<li>Python 2에서 Python 3으로 업그레이드할 때 HTTPS 연결의 기본 처리 방식 변경사항의 가용성을 제한하는 것.</li>
<li>Linux 배포판 공급업체의 경우, 새 운영 체제 버전으로 업그레이드할 때 HTTPS 연결의 기본 처리 방식 변경사항의 가용성을 제한하는 것.</li>
<li>이 PEP의 공식 상태와 관계없이, 이 PEP에 설명된 백포팅 제안 중 하나 또는 둘 모두를 구현하는 것.</li>
</ul>
<h2>범위 제한 (Scope Limitations)</h2>
<p>이러한 변경사항은 Python 2.7 환경에서 새로운 기본 인증서 처리 동작으로의 전환을 관리하는 데 도움이 되는 도구로서만 제안됩니다. Python 3의 새로운 기능으로는 제안되지 않습니다. 이 문제는 애플리케이션 자체를 업데이트할 수 없는 대부분의 클라이언트 애플리케이션이 Python 2 애플리케이션일 것으로 예상되기 때문입니다.</p>
<p>미래의 Python 3 버전에서 보안 프로토콜에 대한 기본 인증서 처리를 프로토콜별로 구성할 수 있도록 하는 것이 바람직할 수 있지만, 해당 질문은 이 PEP의 범위를 벗어납니다.</p>
<h2>기능 감지 요구 사항 (Requirements for capability detection)</h2>
<p>이 PEP의 제안은 이전 Python 버전으로의 백포팅을 용이하게 하는 것을 목표로 하므로, Python 버전 번호를 기능을 감지하는 신뢰할 수 있는 수단으로 사용할 수 없습니다. 대신 다음 기술을 사용하여 기능의 존재 여부를 확인할 수 있도록 설계되었습니다.</p>
<pre><code class="language-bash">python -c "import ssl; ssl.&#x3C;_relevant_attribute>"
</code></pre>
<p>관련 기능이 없는 경우 <code>AttributeError</code> (따라서 0이 아닌 반환 코드)로 실패할 것입니다.</p>
<p>이 PEP에 의해 정의된 기능 감지 속성(attribute)은 다음과 같습니다.</p>
<ul>
<li><code>ssl._https_verify_certificates</code>: 런타임 구성 API</li>
<li><code>ssl._https_verify_envvar</code>: 환경 변수 기반 구성</li>
<li><code>ssl._cert_verification_config</code>: 파일 기반 구성 (PEP 476 선택 사항)</li>
</ul>
<p>마커 속성(marker attributes)은 이러한 기능의 구현 의존적이고 보안에 민감한 특성을 나타내기 위해 밑줄로 시작합니다.</p>
<h2>기능: 구성 API (Feature: Configuration API)</h2>
<p>이 변경사항은 CPython 2.7.12 및 이후 CPython 2.7.x 릴리스에 포함될 것을 제안합니다. 이는 표준 라이브러리 클라이언트 라이브러리에서 HTTPS 인증서의 기본 처리를 지정하는 새로운 <code>ssl._https_verify_certificates()</code> 함수로 구성됩니다.</p>
<p>이 변경사항을 Python 3으로 포트하는 것은 제안되지 않으므로, 인증서 검증 건너뛰기를 지원해야 하는 Python 3 애플리케이션은 자체적인 적절한 보안 컨텍스트를 정의해야 할 것입니다.</p>
<h3>기능 감지 (Feature detection)</h3>
<p>이 기능과 관련된 <code>ssl</code> 모듈의 마커 속성은 <code>ssl._https_verify_certificates</code> 함수 자체입니다.</p>
<h3>사양 (Specification)</h3>
<p><code>ssl._https_verify_certificates</code> 함수는 다음과 같이 작동할 것입니다.</p>
<pre><code class="language-python">def _https_verify_certificates(enable=True):
    """Verify server HTTPS certificates by default?"""
    global _create_default_https_context
    if enable:
        _create_default_https_context = create_default_context
    else:
        _create_default_https_context = _create_unverified_context
</code></pre>
<p>인수 없이 호출되거나 <code>enable</code>이 True 값으로 설정된 경우, 표준 라이브러리 클라이언트 모듈은 이후 기본적으로 HTTPS 인증서를 검증합니다. 그렇지 않으면 검증을 건너뜁니다.</p>
<p><code>enable</code>이 False 값으로 설정된 경우, 표준 라이브러리 클라이언트 모듈은 이후 기본적으로 HTTPS 인증서 검증을 건너뜁니다.</p>
<h3>보안 고려 사항 (Security Considerations)</h3>
<p>이 기능이 포함되면 보안에 민감한 애플리케이션이 다음과 같은 순방향 호환 스니펫(forward-compatible snippet)을 코드에 포함할 수 있게 됩니다.</p>
<pre><code class="language-python">if hasattr(ssl, "_https_verify_certificates"):
    ssl._https_verify_certificates()
</code></pre>
<p>일부 개발자는 <code>ssl._https_verify_certificates(enable=False)</code>를 사용하여 인증서 확인을 해제할 수도 있습니다. 영향을 받는 내부 API를 몽키 패치하는 것이 이미 가능했기 때문에, 이는 새로운 주요 보안 문제를 야기하지 않습니다.</p>
<h2>기능: 환경 변수 기반 구성 (Feature: environment based configuration)</h2>
<p>이 변경사항은 CPython 2.7.12 및 이후 CPython 2.7.x 릴리스에 포함될 것을 제안합니다. 애플리케이션 소스 코드를 수정하지 않고도(바이트코드 전용 애플리케이션 배포의 경우 소스 코드를 사용할 수 없을 수도 있음) 기본 검증을 비활성화하기 위해 '0'으로 설정할 수 있는 새로운 <code>PYTHONHTTPSVERIFY</code> 환경 변수로 구성됩니다.</p>
<p>이 변경사항을 Python 3으로 포트하는 것은 제안되지 않으므로, 인증서 검증 건너뛰기를 지원해야 하는 Python 3 애플리케이션은 자체적인 적절한 보안 컨텍스트를 정의해야 할 것입니다.</p>
<h3>기능 감지 (Feature detection)</h3>
<p>이 기능과 관련된 <code>ssl</code> 모듈의 마커 속성은 다음입니다.</p>
<ul>
<li><code>ssl._https_verify_envvar</code> 속성은 기본 동작에 영향을 미치는 환경 변수의 이름을 제공합니다.</li>
</ul>
<p>이는 기능의 존재 여부를 쉽게 감지할 수 있을 뿐만 아니라, 관련 환경 변수 이름을 프로그래밍 방식으로 확인할 수 있도록 합니다.</p>
<h3>사양 (Specification)</h3>
<p><code>ssl.create_default_context</code>를 항상 기본값으로 사용하는 대신, <code>ssl</code> 모듈은 다음과 같이 수정될 것입니다.</p>
<ul>
<li>모듈이 Python 프로세스에 처음 임포트될 때 <code>PYTHONHTTPSVERIFY</code> 환경 변수를 읽습니다.</li>
<li>이 환경 변수가 존재하고 '0'으로 설정되어 있으면 <code>ssl._create_default_https_context</code> 함수를 <code>ssl._create_unverified_context</code>의 별칭으로 설정합니다.</li>
<li>그렇지 않으면 <code>ssl._create_default_https_context</code> 함수를 평소와 같이 <code>ssl.create_default_context</code>의 별칭으로 설정합니다.</li>
</ul>
<h3>예시 구현 (Example implementation)</h3>
<pre><code class="language-python">_https_verify_envvar = 'PYTHONHTTPSVERIFY'
def _get_https_context_factory():
    if not sys.flags.ignore_environment:
        config_setting = os.environ.get(_https_verify_envvar)
        if config_setting == '0':
            return _create_unverified_context
    return create_default_context

_create_default_https_context = _get_https_context_factory()
</code></pre>
<h3>보안 고려 사항 (Security Considerations)</h3>
<p>Python 3.4.3+ 및 Python 2.7.9->2.7.11의 동작과 비교할 때, 이 접근 방식은 기본 보안 설정에 대한 새로운 다운그레이드 공격(downgrade attack)을 도입합니다. 이는 충분히 결단력 있는 공격자가 Python을 CPython 2.7.8 및 이전 릴리스에서 사용된 기본 동작으로 되돌릴 수 있게 할 잠재적인 위험을 야기합니다.</p>
<p>이러한 공격 표면의 약간의 증가는 다음과 같은 주요 이유가 됩니다.</p>
<ul>
<li>보안에 민감한 애플리케이션은 여전히 자체 SSL 컨텍스트를 정의해야 합니다.</li>
<li>이 PEP에 설명된 마이그레이션 기능은 Python 3에 추가되지 않습니다.</li>
</ul>
<p>그러나 이러한 공격을 수행하려면 <code>ssl</code> 모듈이 임포트되기 전에 Python 프로세스의 실행 환경을 수정할 수 있는 능력이 필요하다는 점도 명심해야 합니다. 파일 시스템의 어떤 부분(예: <code>/tmp</code>)에도 쓸 수 있는 능력과 결합하여, 그러한 접근 권한을 가진 공격자는 이미 기본 OpenSSL 구현, 동적 라이브러리 로더 및 기타 잠재적으로 보안에 민감한 구성 요소의 동작을 수정할 수 있을 것입니다.</p>
<h3>Python 가상 환경과의 상호 작용 (Interaction with Python virtual environments)</h3>
<p>기본 설정은 프로세스 환경에서 직접 읽히므로, 인터프리터가 활성화된 Python 가상 환경 내에서 실행되는지 여부와 관계없이 동일하게 작동합니다.</p>
<h2>참조 구현 (Reference Implementation)</h2>
<p>위의 두 기능을 구현하는 Python 2.7용 패치는 관련 트래커 이슈에 첨부되어 있습니다.</p>
<h2>이전 Python 버전으로 이 PEP 백포팅 (Backporting this PEP to earlier Python versions)</h2>
<p>이 PEP가 승인되면, 상업적 Python 재배포자는 전체 Python 설치의 기본 동작에 대한 PEP 476 변경 사항을 백포팅하지 않고도 이 PEP에 정의된 프로세스별 구성 메커니즘을 Python 2.7.9보다 오래된 기본 버전으로 백포팅할 수 있습니다.</p>
<p>이러한 백포팅은 <code>PYTHONHTTPSVERIFY</code>가 전혀 설정되지 않았을 때의 기본 동작에서만 이 PEP에 제안된 메커니즘과 다를 것입니다. 이 경우 기본적으로 인증서 검증을 건너뛰는 동작이 유지됩니다.</p>
<p>이 경우, <code>PYTHONHTTPSVERIFY</code> 환경 변수가 정의되어 있고 '0'이 아닌 다른 값으로 설정되어 있으면 HTTPS 인증서 검증이 활성화되어야 합니다.</p>
<h3>기능 감지 (Feature detection)</h3>
<p>이 상황이 적용됨을 나타내는 특정 속성은 없습니다. 대신, <code>ssl._https_verify_certificates</code> 및 <code>ssl._https_verify_envvar</code> 속성이 명목상 Python 2.7.12보다 오래된 Python 버전에 존재하는 것으로 나타납니다.</p>
<h3>사양 (Specification)</h3>
<p>이 백포트를 구현하는 것은 PEP 466, 476 및 이 PEP의 변경 사항을 백포팅하는 것을 포함하며, <code>ssl</code> 모듈에서 <code>PYTHONHTTPSVERIFY</code> 환경 변수 처리 방식에 다음 변경 사항이 적용됩니다.</p>
<ul>
<li>모듈이 Python 프로세스에 처음 임포트될 때 <code>PYTHONHTTPSVERIFY</code> 환경 변수를 읽습니다.</li>
<li>이 환경 변수가 존재하고 '0'이 아닌 다른 값으로 설정되어 있으면 <code>ssl._create_default_https_context</code> 함수를 <code>ssl.create_default_context</code>의 별칭으로 설정합니다.</li>
<li>그렇지 않으면 <code>ssl._create_default_https_context</code> 함수를 <code>ssl._create_unverified_context</code>의 별칭으로 설정합니다.</li>
</ul>
<h3>예시 구현 (Example implementation)</h3>
<pre><code class="language-python">_https_verify_envvar = 'PYTHONHTTPSVERIFY'
def _get_https_context_factory():
    if not sys.flags.ignore_environment:
        config_setting = os.environ.get(_https_verify_envvar)
        if config_setting != '0':
            return create_default_context
    return _create_unverified_context

_create_default_https_context = _get_https_context_factory()

def _disable_https_default_verification():
    """HTTPS 인증서 검증을 기본적으로 건너뜁니다."""
    global _create_default_https_context
    _create_default_https_context = _create_unverified_context
</code></pre>
<h3>보안 고려 사항 (Security Considerations)</h3>
<p>이 변경 사항은 표준 라이브러리 HTTPS 클라이언트에서 현재 기본적으로 인증서 검증을 건너뛰는 모든 Python 버전에 대해 엄격한 보안 업그레이드가 될 것입니다. 고려해야 할 기술적 절충점은 보안 관련 사항보다는 주로 필요한 PEP 466 백포트의 규모와 관련이 있습니다.</p>
<h3>Python 가상 환경과의 상호 작용 (Interaction with Python virtual environments)</h3>
<p>기본 설정은 프로세스 환경에서 직접 읽히므로, 인터프리터가 활성화된 Python 가상 환경 내에서 실행되는지 여부와 관계없이 동일하게 작동합니다.</p>
<h2>이전 Python 버전으로 PEP 476 백포팅 (Backporting PEP 476 to earlier Python versions)</h2>
<p>위에 설명된 백포팅 접근 방식은 Python 2.7 설치의 기본 HTTPS 인증서 검증 동작을 수정하지 않습니다. 즉, 인증서 검증은 여전히 연결별(per-connection) 또는 프로세스별(per-process)로 선택해야 합니다.</p>
<p>하위 호환성을 손상시키지 않으면서 전체 설치의 기본 동작을 수정할 수 있도록, Red Hat은 Red Hat Enterprise Linux 7.2 이상 버전의 시스템 Python 2.7 설치를 위한 구성 메커니즘을 설계했으며, 이는 다음을 제공합니다.</p>
<ul>
<li>HTTPS 인증서 검증 활성화 결정과 기능이 처음 백포트된 운영 체제 버전으로 업그레이드 결정이 독립적으로 이루어질 수 있도록 하는 옵트인(opt-in) 모델.</li>
<li>시스템 관리자가 시스템 Python 설치에서 직접 실행되는 Python 애플리케이션 및 스크립트의 기본 동작을 설정할 수 있는 기능.</li>
<li>재배포자가 향후 특정 시점에 새로운 설치의 기본 동작을 변경하는 것을 고려할 수 있도록 하며, 기본적으로 HTTPS 인증서 검증을 건너뛰도록 명시적으로 구성된 기존 설치에 영향을 미치지 않도록 하는 기능.</li>
</ul>
<p>이 변경사항은 Python 2.7의 이전 릴리스에 대한 백포트에만 영향을 미치므로, 업스트림 CPython에 포함될 것을 제안하지 않고, 대신 사용자에게 유사한 기능을 제공하기로 선택한 다른 재배포자들을 위한 권장 사항으로 제공됩니다.</p>
<p>이 PEP는 이 특정 변경 사항이 좋은 아이디어인지 아닌지에 대해 입장을 취하지 않습니다. 오히려, 재배포자가 Python 2.7.9보다 오래된 버전의 Python에서 기본 동작을 구성 가능하게 만드는 길을 선택한다면, 재배포자들 간에 일관된 접근 방식을 유지하는 것이 사용자에게 이로울 것이라고 제안합니다.</p>
<p>그러나 이 접근 방식은 Python 2.7.9 이상을 제공한다고 광고하는 Python 설치에는 사용해서는 안 됩니다. 대부분의 Python 사용자는 그러한 모든 환경이 기본적으로 HTTPS 인증서를 검증할 것이라는 합리적인 기대를 가질 것이기 때문입니다.</p>
<h3>기능 감지 (Feature detection)</h3>
<p>이 기능과 관련된 <code>ssl</code> 모듈의 마커 속성은 다음과 같습니다.</p>
<ul>
<li><code>_cert_verification_config = '&#x3C;configuration file path>'</code></li>
</ul>
<p>이는 기능의 존재 여부를 쉽게 감지할 수 있을 뿐만 아니라, 관련 구성 파일 이름을 프로그래밍 방식으로 확인할 수 있도록 합니다.</p>
<h3>Python 표준 라이브러리에 대한 권장 수정 사항 (Recommended modifications to the Python standard library)</h3>
<p>PEP 476 수정 사항을 이전 포인트 릴리스로 백포팅하기 위한 권장 접근 방식은 Python 2.7.9 이상에서 구현된 기본 PEP 476 동작과 관련하여 다음 변경 사항을 구현하는 것입니다.</p>
<ul>
<li><code>ssl</code> 모듈이 Python 프로세스에 처음 임포트될 때 시스템 전체 구성 파일을 읽도록 수정합니다.</li>
<li>이 구성 파일이 없는 경우 사용할 플랫폼 기본 동작(HTTPS 인증서 검증 또는 비검증)을 정의합니다.</li>
<li>다음 세 가지 작동 모드 간의 선택을 지원합니다.
<ul>
<li>HTTPS 인증서 검증이 활성화되도록 합니다.</li>
<li>HTTPS 인증서 검증이 비활성화되도록 합니다.</li>
<li>이 Python 버전을 제공하는 재배포자에게 결정을 위임합니다.</li>
</ul>
</li>
<li>주어진 구성 설정에 따라 <code>ssl._create_default_https_context</code> 함수를 <code>ssl.create_default_context</code> 또는 <code>ssl._create_unverified_context</code>의 별칭으로 설정합니다.</li>
</ul>
<h3>권장 파일 위치 (Recommended file location)</h3>
<p>PEP 작성자들은 Windows, Mac OS X 또는 *BSD 시스템을 대상으로 하는 장기 지원 릴리스를 제공하는 벤더를 알지 못하므로, 이 접근 방식은 현재 Linux 시스템 Python 설치에 대해서만 구체적으로 정의되어 있습니다.</p>
<p>Linux 시스템에서 권장되는 구성 파일 이름은 <code>/etc/python/cert-verification.cfg</code>입니다.</p>
<p><code>.cfg</code> 파일 이름 확장자는 Python 3 표준 라이브러리의 <code>venv</code> 모듈에서 사용되는 <code>pyvenv.cfg</code>와의 일관성을 위해 권장됩니다.</p>
<h3>권장 파일 형식 (Recommended file format)</h3>
<p>구성 파일은 단일 섹션 <code>[https]</code>를 포함하는 <code>ConfigParser</code> ini 스타일 형식을 사용해야 하며, 이 섹션에는 <code>verify</code>라는 필수 설정이 포함되어야 합니다.</p>
<p>제안된 섹션 이름은 영향을 받는 클라이언트 API에 전달되는 "https" URL 스키마에서 가져왔습니다.</p>
<p><code>verify</code>에 허용되는 값은 다음과 같습니다.</p>
<ul>
<li><code>enable</code>: HTTPS 인증서 검증이 기본적으로 활성화되도록 합니다.</li>
<li><code>disable</code>: HTTPS 인증서 검증이 기본적으로 비활성화되도록 합니다.</li>
<li><code>platform_default</code>: 이 특정 Python 버전을 제공하는 재배포자에게 결정을 위임합니다.</li>
</ul>
<p><code>[https]</code> 섹션 또는 <code>verify</code> 설정이 없거나 <code>verify</code> 설정이 알 수 없는 값으로 설정된 경우, 구성 파일이 없는 것으로 처리해야 합니다.</p>
<h3>예시 구현 (Example implementation)</h3>
<pre><code class="language-python">_cert_verification_config = '/etc/python/cert-verification.cfg'
def _get_https_context_factory():
    # 기본 동작에 대한 시스템 전체 재정의를 확인합니다.
    context_factories = {
        'enable': create_default_context,
        'disable': _create_unverified_context,
        'platform_default': _create_unverified_context, # 지금은 :)
    }
    import ConfigParser
    config = ConfigParser.RawConfigParser()
    config.read(_cert_verification_config)
    try:
        verify_mode = config.get('https', 'verify')
    except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
        verify_mode = 'platform_default'
    default_factory = context_factories.get('platform_default')
    return context_factories.get(verify_mode, default_factory)

_create_default_https_context = _get_https_context_factory()
</code></pre>
<h3>보안 고려 사항 (Security Considerations)</h3>
<p>이 백포트 사례에 대한 특정 권장 사항은 다음과 같은 잠긴 구성에서 실행되는 프로세스라도, 특권이 있는 보안에 민감한 프로세스에 대해 작동하도록 설계되었습니다.</p>
<ul>
<li>일반 사용자 디렉토리가 아닌 잠긴 관리자 제어 디렉토리에서 실행 (<code>sys.path[0]</code> 기반 권한 상승 공격 방지).</li>
<li><code>-E</code> 스위치를 사용하여 실행 (<code>PYTHON*</code> 환경 변수 기반 권한 상승 공격 방지).</li>
<li><code>-s</code> 스위치를 사용하여 실행 (사용자 사이트 디렉토리 기반 권한 상승 공격 방지).</li>
<li><code>-S</code> 스위치를 사용하여 실행 (<code>sitecustomize</code> 기반 권한 상승 공격 방지).</li>
</ul>
<p>이 접근 방식을 사용할 때 HTTPS 검증이 설치 전체에서 꺼지는 유일한 이유는 다음과 같습니다.</p>
<ul>
<li>최종 사용자가 업스트림 CPython을 직접 실행하는 대신 재배포자가 제공한 CPython 버전을 실행하고 있습니다.</li>
<li>해당 재배포자가 업스트림 프로젝트에서 제공하는 것보다 HTTPS 인증서 검증을 기본적으로 사용하도록 더 원활한 마이그레이션 경로를 제공하기로 결정했습니다.</li>
<li>재배포자 또는 로컬 인프라 관리자가 (적어도 현재로서는) 2.7.9 이전의 기본 동작을 유지하는 것이 적절하다고 판단했습니다.</li>
</ul>
<p>환경 변수 대신 관리자 제어 구성 파일을 사용하는 것은 <code>-E</code> 스위치로 실행되는 애플리케이션에 대해서도 더 원활한 마이그레이션 경로를 제공하는 필수적인 기능을 합니다.</p>
<h3>Python 가상 환경과의 상호 작용 (Interaction with Python virtual environments)</h3>
<p>이 설정은 인터프리터 설치에 의해 범위가 지정되며, 인터프리터가 활성화된 Python 가상 환경 내에서 실행되는지 여부와 관계없이 해당 인터프리터를 사용하는 모든 Python 프로세스에 영향을 미칩니다.</p>
<h3>이 권장 사항의 기원 (Origins of this recommendation)</h3>
<p>이 권장 사항은 이 PEP의 2015년 7월 초판에 게시되고 이 KnowledgeBase 문서에 자세히 설명된 대로, Red Hat Enterprise Linux 7.2에 채택된 백포팅 접근 방식을 기반으로 합니다. Python 2.7.5용 이 백포트를 구현하는 Red Hat의 패치는 CentOS git 리포지토리에서 찾을 수 있습니다.</p>
<h2>결합된 기능 백포트를 위한 권장 사항 (Recommendation for combined feature backports)</h2>
<p>재배포자가 이 PEP의 환경 변수 기반 구성 설정을 파일 기반 PEP 476 백포트도 구현하는 수정된 Python 버전으로 백포팅하기로 선택하는 경우, 환경 변수가 시스템 전체 구성 설정보다 우선해야 합니다. 이렇게 하면 설치 전체의 기본 동작과 관계없이 특정 사용자 또는 애플리케이션에 대해 설정을 변경할 수 있습니다.</p>
<h3>예시 구현 (Example implementation)</h3>
<pre><code class="language-python">_https_verify_envvar = 'PYTHONHTTPSVERIFY'
_cert_verification_config = '/etc/python/cert-verification.cfg'

def _get_https_context_factory():
    # 기본 동작에 대한 환경 변수 재정의를 확인합니다.
    if not sys.flags.ignore_environment:
        config_setting = os.environ.get(_https_verify_envvar)
        if config_setting is not None:
            if config_setting == '0':
                return _create_unverified_context
            return create_default_context

    # 기본 동작에 대한 시스템 전체 재정의를 확인합니다.
    context_factories = {
        'enable': create_default_context,
        'disable': _create_unverified_context,
        'platform_default': _create_unverified_context, # 지금은 :)
    }
    import ConfigParser
    config = ConfigParser.RawConfigParser()
    config.read(_cert_verification_config)
    try:
        verify_mode = config.get('https', 'verify')
    except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
        verify_mode = 'platform_default'
    default_factory = context_factories.get('platform_default')
    return context_factories.get(verify_mode, default_factory)

_create_default_https_context = _get_https_context_factory()
</code></pre>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 공개 도메인에 배치되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/492/">[Final] PEP 492 - Coroutines with async and await syntax</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 493 - HTTPS verification migration tools for Python 2.7</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/494/">[Final] PEP 494 - Python 3.6 Release Schedule</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/773b243a13a00265.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"185\",\"static/chunks/app/layout-fa159ef0265a0843.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/493\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/773b243a13a00265.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"q5uHuVDyt3FPCtp0uxl7W\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/493/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/493\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"493\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/493\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"default\"]\ne:T7116,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0493/\"\u003ePEP 493 - HTTPS verification migration tools for Python 2.7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 10-May-2015\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 493 – Python 2.7용 HTTPS 검증 마이그레이션 도구\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Alyssa Coghlan, Robert Kuska, Marc-André Lemburg\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBDFL 위임자:\u003c/strong\u003e Barry Warsaw\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final (최종)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track (표준 트랙)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2015년 5월 10일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 2.7.12\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e해결:\u003c/strong\u003e Python-Dev message\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003ePEP 476은 클라이언트 모듈에서 Python의 기본 HTTPS 인증서 처리 방식을 웹 브라우저의 인증서 처리 방식과 일치시키기 위해, 클라이언트가 접속하려는 서버에 속하는 인증서가 수신되었는지 검증하도록 업데이트했습니다. Python 2.7 장기 유지보수 시리즈가 이 변경사항의 범위에 포함된다고 판단되어, 새로운 동작은 Python 2.7.9 유지보수 릴리스에 도입되었습니다.\u003c/p\u003e\n\u003cp\u003e이로 인해 영향을 받는 Python 2.7 유지보수 릴리스의 채택에 상당한 장벽이 생겼습니다. 따라서 이 PEP는 시스템 관리자 및 다른 사용자들이 HTTPS 클라이언트 모듈에서 서버 인증서 검증 여부를 결정하는 것과 최신 Python 2.7 유지보수 릴리스로 업데이트하는 결정을 더 쉽게 분리할 수 있도록 Python 2.7에 특화된 추가 기능을 제안합니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003ePEP 476은 HTTPS URL의 의미론에 대한 웹 브라우저의 기대치에 맞춰 Python의 기본 동작을 변경했습니다. Python 2.7.9 및 3.4.3부터 표준 라이브러리의 HTTPS 클라이언트는 기본적으로 서버 인증서를 검증합니다.\u003c/p\u003e\n\u003cp\u003e그러나 이러한 변경은 자체 서명 인증서(self-signed certificates)에 의존하는 사설 인트라넷을 운영하거나 새로운 기본 인증서 검증 설정에서 문제를 겪는 인프라 관리자에게 문제를 일으키기도 합니다.\u003c/p\u003e\n\u003cp\u003e이러한 상황을 관리하기 위해 웹 브라우저는 사용자에게 서버의 인증서를 브라우저의 인증서 저장소에 추가할 수 있도록 \"클릭 스루(click through)\" 경고를 제공합니다. \u003ccode\u003ecurl\u003c/code\u003e 및 \u003ccode\u003ewget\u003c/code\u003e과 같은 네트워크 클라이언트 도구는 인증서 확인을 완전히 끌 수 있는 옵션(각각 \u003ccode\u003ecurl --insecure\u003c/code\u003e 및 \u003ccode\u003ewget --no-check-certificate\u003c/code\u003e)을 제공합니다.\u003c/p\u003e\n\u003cp\u003e기술 스택의 다른 계층에서는 SELinux 및 AppArmor와 같은 Linux 보안 모듈이 배포판 벤더에 의해 기본적으로 활성화되지만, 이를 끌 수 있는 비교적 간단한 메커니즘을 제공합니다.\u003c/p\u003e\n\u003cp\u003e현재, 전체 프로세스에 대해 Python의 기본 인증서 확인을 비활성화하는 편리한 메커니즘은 존재하지 않습니다.\u003c/p\u003e\n\u003cp\u003ePEP 476은 \u003ccode\u003essl\u003c/code\u003e 모듈을 몽키 패치(monkeypatching)하여 이전 동작을 복원하는 방식으로 프로세스 전체에 걸쳐 이전 설정으로 되돌리는 방법을 다루면서 이 문제를 해결하려고 시도했습니다. 하지만 시스템 관리자가 Standard Operating Environment 정의에서 이 기능을 기본적으로 비활성화할 수 있도록 제안된 \u003ccode\u003esitecustomize.py\u003c/code\u003e 기반 기술은 적어도 일부 경우에 불충분한 것으로 판명되었습니다. 이 PEP의 초기 생성으로 이어진 특정 사례는 Linux 배포자가 업스트림 CPython 2.7 릴리스를 직접 사용하는 것보다 사용자에게 더 원활한 마이그레이션 경로를 제공하려는 경우였지만, 임베디드 Python 런타임 및 기타 사용자 수준 Python 설치를 업데이트하는 데 있어서 다른 잠재적인 문제점들도 지적되었습니다.\u003c/p\u003e\n\u003cp\u003e상호 호환되지 않는 다양한 마이그레이션 기술이 난립하는 것을 방지하기 위해, 이 PEP는 HTTPS 클라이언트 모듈에서 인증서 검증을 건너뛰는 과거 동작으로 프로세스를 더 쉽게 되돌릴 수 있도록 Python 2.7.12에 추가될 기능을 제안합니다. 또한 이러한 기능을 Python 2.7.9 이전 버전으로 백포팅(backporting)하는 재배포자(redistributors)를 위한 추가 권장 사항도 제공합니다.\u003c/p\u003e\n\u003ch2\u003e대안 (Alternatives)\u003c/h2\u003e\n\u003cp\u003e명확한 업스트림 지침 및 권장 사항이 없는 경우에도, 상업적 재배포자는 고객의 이익을 위해 자체적인 설계 결정을 내릴 것입니다. 사용 가능한 주요 접근 방식은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePEP 476에 정의된 메커니즘 외에 표준 라이브러리 HTTPS 클라이언트에서 검증되지 않은 호스트 이름에서 검증된 호스트 이름으로 마이그레이션하는 데 추가 지원을 제공하지 않으면서 새로운 Python 2.7.x 릴리스에 계속 리베이스(rebase)하는 것.\u003c/li\u003e\n\u003cli\u003ePython 2에서 Python 3으로 업그레이드할 때 HTTPS 연결의 기본 처리 방식 변경사항의 가용성을 제한하는 것.\u003c/li\u003e\n\u003cli\u003eLinux 배포판 공급업체의 경우, 새 운영 체제 버전으로 업그레이드할 때 HTTPS 연결의 기본 처리 방식 변경사항의 가용성을 제한하는 것.\u003c/li\u003e\n\u003cli\u003e이 PEP의 공식 상태와 관계없이, 이 PEP에 설명된 백포팅 제안 중 하나 또는 둘 모두를 구현하는 것.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e범위 제한 (Scope Limitations)\u003c/h2\u003e\n\u003cp\u003e이러한 변경사항은 Python 2.7 환경에서 새로운 기본 인증서 처리 동작으로의 전환을 관리하는 데 도움이 되는 도구로서만 제안됩니다. Python 3의 새로운 기능으로는 제안되지 않습니다. 이 문제는 애플리케이션 자체를 업데이트할 수 없는 대부분의 클라이언트 애플리케이션이 Python 2 애플리케이션일 것으로 예상되기 때문입니다.\u003c/p\u003e\n\u003cp\u003e미래의 Python 3 버전에서 보안 프로토콜에 대한 기본 인증서 처리를 프로토콜별로 구성할 수 있도록 하는 것이 바람직할 수 있지만, 해당 질문은 이 PEP의 범위를 벗어납니다.\u003c/p\u003e\n\u003ch2\u003e기능 감지 요구 사항 (Requirements for capability detection)\u003c/h2\u003e\n\u003cp\u003e이 PEP의 제안은 이전 Python 버전으로의 백포팅을 용이하게 하는 것을 목표로 하므로, Python 버전 번호를 기능을 감지하는 신뢰할 수 있는 수단으로 사용할 수 없습니다. 대신 다음 기술을 사용하여 기능의 존재 여부를 확인할 수 있도록 설계되었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epython -c \"import ssl; ssl.\u0026#x3C;_relevant_attribute\u003e\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e관련 기능이 없는 경우 \u003ccode\u003eAttributeError\u003c/code\u003e (따라서 0이 아닌 반환 코드)로 실패할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 PEP에 의해 정의된 기능 감지 속성(attribute)은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003essl._https_verify_certificates\u003c/code\u003e: 런타임 구성 API\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003essl._https_verify_envvar\u003c/code\u003e: 환경 변수 기반 구성\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003essl._cert_verification_config\u003c/code\u003e: 파일 기반 구성 (PEP 476 선택 사항)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e마커 속성(marker attributes)은 이러한 기능의 구현 의존적이고 보안에 민감한 특성을 나타내기 위해 밑줄로 시작합니다.\u003c/p\u003e\n\u003ch2\u003e기능: 구성 API (Feature: Configuration API)\u003c/h2\u003e\n\u003cp\u003e이 변경사항은 CPython 2.7.12 및 이후 CPython 2.7.x 릴리스에 포함될 것을 제안합니다. 이는 표준 라이브러리 클라이언트 라이브러리에서 HTTPS 인증서의 기본 처리를 지정하는 새로운 \u003ccode\u003essl._https_verify_certificates()\u003c/code\u003e 함수로 구성됩니다.\u003c/p\u003e\n\u003cp\u003e이 변경사항을 Python 3으로 포트하는 것은 제안되지 않으므로, 인증서 검증 건너뛰기를 지원해야 하는 Python 3 애플리케이션은 자체적인 적절한 보안 컨텍스트를 정의해야 할 것입니다.\u003c/p\u003e\n\u003ch3\u003e기능 감지 (Feature detection)\u003c/h3\u003e\n\u003cp\u003e이 기능과 관련된 \u003ccode\u003essl\u003c/code\u003e 모듈의 마커 속성은 \u003ccode\u003essl._https_verify_certificates\u003c/code\u003e 함수 자체입니다.\u003c/p\u003e\n\u003ch3\u003e사양 (Specification)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003essl._https_verify_certificates\u003c/code\u003e 함수는 다음과 같이 작동할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef _https_verify_certificates(enable=True):\n    \"\"\"Verify server HTTPS certificates by default?\"\"\"\n    global _create_default_https_context\n    if enable:\n        _create_default_https_context = create_default_context\n    else:\n        _create_default_https_context = _create_unverified_context\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e인수 없이 호출되거나 \u003ccode\u003eenable\u003c/code\u003e이 True 값으로 설정된 경우, 표준 라이브러리 클라이언트 모듈은 이후 기본적으로 HTTPS 인증서를 검증합니다. 그렇지 않으면 검증을 건너뜁니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eenable\u003c/code\u003e이 False 값으로 설정된 경우, 표준 라이브러리 클라이언트 모듈은 이후 기본적으로 HTTPS 인증서 검증을 건너뜁니다.\u003c/p\u003e\n\u003ch3\u003e보안 고려 사항 (Security Considerations)\u003c/h3\u003e\n\u003cp\u003e이 기능이 포함되면 보안에 민감한 애플리케이션이 다음과 같은 순방향 호환 스니펫(forward-compatible snippet)을 코드에 포함할 수 있게 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif hasattr(ssl, \"_https_verify_certificates\"):\n    ssl._https_verify_certificates()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e일부 개발자는 \u003ccode\u003essl._https_verify_certificates(enable=False)\u003c/code\u003e를 사용하여 인증서 확인을 해제할 수도 있습니다. 영향을 받는 내부 API를 몽키 패치하는 것이 이미 가능했기 때문에, 이는 새로운 주요 보안 문제를 야기하지 않습니다.\u003c/p\u003e\n\u003ch2\u003e기능: 환경 변수 기반 구성 (Feature: environment based configuration)\u003c/h2\u003e\n\u003cp\u003e이 변경사항은 CPython 2.7.12 및 이후 CPython 2.7.x 릴리스에 포함될 것을 제안합니다. 애플리케이션 소스 코드를 수정하지 않고도(바이트코드 전용 애플리케이션 배포의 경우 소스 코드를 사용할 수 없을 수도 있음) 기본 검증을 비활성화하기 위해 '0'으로 설정할 수 있는 새로운 \u003ccode\u003ePYTHONHTTPSVERIFY\u003c/code\u003e 환경 변수로 구성됩니다.\u003c/p\u003e\n\u003cp\u003e이 변경사항을 Python 3으로 포트하는 것은 제안되지 않으므로, 인증서 검증 건너뛰기를 지원해야 하는 Python 3 애플리케이션은 자체적인 적절한 보안 컨텍스트를 정의해야 할 것입니다.\u003c/p\u003e\n\u003ch3\u003e기능 감지 (Feature detection)\u003c/h3\u003e\n\u003cp\u003e이 기능과 관련된 \u003ccode\u003essl\u003c/code\u003e 모듈의 마커 속성은 다음입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003essl._https_verify_envvar\u003c/code\u003e 속성은 기본 동작에 영향을 미치는 환경 변수의 이름을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 기능의 존재 여부를 쉽게 감지할 수 있을 뿐만 아니라, 관련 환경 변수 이름을 프로그래밍 방식으로 확인할 수 있도록 합니다.\u003c/p\u003e\n\u003ch3\u003e사양 (Specification)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003essl.create_default_context\u003c/code\u003e를 항상 기본값으로 사용하는 대신, \u003ccode\u003essl\u003c/code\u003e 모듈은 다음과 같이 수정될 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모듈이 Python 프로세스에 처음 임포트될 때 \u003ccode\u003ePYTHONHTTPSVERIFY\u003c/code\u003e 환경 변수를 읽습니다.\u003c/li\u003e\n\u003cli\u003e이 환경 변수가 존재하고 '0'으로 설정되어 있으면 \u003ccode\u003essl._create_default_https_context\u003c/code\u003e 함수를 \u003ccode\u003essl._create_unverified_context\u003c/code\u003e의 별칭으로 설정합니다.\u003c/li\u003e\n\u003cli\u003e그렇지 않으면 \u003ccode\u003essl._create_default_https_context\u003c/code\u003e 함수를 평소와 같이 \u003ccode\u003essl.create_default_context\u003c/code\u003e의 별칭으로 설정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e예시 구현 (Example implementation)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_https_verify_envvar = 'PYTHONHTTPSVERIFY'\ndef _get_https_context_factory():\n    if not sys.flags.ignore_environment:\n        config_setting = os.environ.get(_https_verify_envvar)\n        if config_setting == '0':\n            return _create_unverified_context\n    return create_default_context\n\n_create_default_https_context = _get_https_context_factory()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e보안 고려 사항 (Security Considerations)\u003c/h3\u003e\n\u003cp\u003ePython 3.4.3+ 및 Python 2.7.9-\u003e2.7.11의 동작과 비교할 때, 이 접근 방식은 기본 보안 설정에 대한 새로운 다운그레이드 공격(downgrade attack)을 도입합니다. 이는 충분히 결단력 있는 공격자가 Python을 CPython 2.7.8 및 이전 릴리스에서 사용된 기본 동작으로 되돌릴 수 있게 할 잠재적인 위험을 야기합니다.\u003c/p\u003e\n\u003cp\u003e이러한 공격 표면의 약간의 증가는 다음과 같은 주요 이유가 됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e보안에 민감한 애플리케이션은 여전히 자체 SSL 컨텍스트를 정의해야 합니다.\u003c/li\u003e\n\u003cli\u003e이 PEP에 설명된 마이그레이션 기능은 Python 3에 추가되지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그러나 이러한 공격을 수행하려면 \u003ccode\u003essl\u003c/code\u003e 모듈이 임포트되기 전에 Python 프로세스의 실행 환경을 수정할 수 있는 능력이 필요하다는 점도 명심해야 합니다. 파일 시스템의 어떤 부분(예: \u003ccode\u003e/tmp\u003c/code\u003e)에도 쓸 수 있는 능력과 결합하여, 그러한 접근 권한을 가진 공격자는 이미 기본 OpenSSL 구현, 동적 라이브러리 로더 및 기타 잠재적으로 보안에 민감한 구성 요소의 동작을 수정할 수 있을 것입니다.\u003c/p\u003e\n\u003ch3\u003ePython 가상 환경과의 상호 작용 (Interaction with Python virtual environments)\u003c/h3\u003e\n\u003cp\u003e기본 설정은 프로세스 환경에서 직접 읽히므로, 인터프리터가 활성화된 Python 가상 환경 내에서 실행되는지 여부와 관계없이 동일하게 작동합니다.\u003c/p\u003e\n\u003ch2\u003e참조 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003e위의 두 기능을 구현하는 Python 2.7용 패치는 관련 트래커 이슈에 첨부되어 있습니다.\u003c/p\u003e\n\u003ch2\u003e이전 Python 버전으로 이 PEP 백포팅 (Backporting this PEP to earlier Python versions)\u003c/h2\u003e\n\u003cp\u003e이 PEP가 승인되면, 상업적 Python 재배포자는 전체 Python 설치의 기본 동작에 대한 PEP 476 변경 사항을 백포팅하지 않고도 이 PEP에 정의된 프로세스별 구성 메커니즘을 Python 2.7.9보다 오래된 기본 버전으로 백포팅할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 백포팅은 \u003ccode\u003ePYTHONHTTPSVERIFY\u003c/code\u003e가 전혀 설정되지 않았을 때의 기본 동작에서만 이 PEP에 제안된 메커니즘과 다를 것입니다. 이 경우 기본적으로 인증서 검증을 건너뛰는 동작이 유지됩니다.\u003c/p\u003e\n\u003cp\u003e이 경우, \u003ccode\u003ePYTHONHTTPSVERIFY\u003c/code\u003e 환경 변수가 정의되어 있고 '0'이 아닌 다른 값으로 설정되어 있으면 HTTPS 인증서 검증이 활성화되어야 합니다.\u003c/p\u003e\n\u003ch3\u003e기능 감지 (Feature detection)\u003c/h3\u003e\n\u003cp\u003e이 상황이 적용됨을 나타내는 특정 속성은 없습니다. 대신, \u003ccode\u003essl._https_verify_certificates\u003c/code\u003e 및 \u003ccode\u003essl._https_verify_envvar\u003c/code\u003e 속성이 명목상 Python 2.7.12보다 오래된 Python 버전에 존재하는 것으로 나타납니다.\u003c/p\u003e\n\u003ch3\u003e사양 (Specification)\u003c/h3\u003e\n\u003cp\u003e이 백포트를 구현하는 것은 PEP 466, 476 및 이 PEP의 변경 사항을 백포팅하는 것을 포함하며, \u003ccode\u003essl\u003c/code\u003e 모듈에서 \u003ccode\u003ePYTHONHTTPSVERIFY\u003c/code\u003e 환경 변수 처리 방식에 다음 변경 사항이 적용됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모듈이 Python 프로세스에 처음 임포트될 때 \u003ccode\u003ePYTHONHTTPSVERIFY\u003c/code\u003e 환경 변수를 읽습니다.\u003c/li\u003e\n\u003cli\u003e이 환경 변수가 존재하고 '0'이 아닌 다른 값으로 설정되어 있으면 \u003ccode\u003essl._create_default_https_context\u003c/code\u003e 함수를 \u003ccode\u003essl.create_default_context\u003c/code\u003e의 별칭으로 설정합니다.\u003c/li\u003e\n\u003cli\u003e그렇지 않으면 \u003ccode\u003essl._create_default_https_context\u003c/code\u003e 함수를 \u003ccode\u003essl._create_unverified_context\u003c/code\u003e의 별칭으로 설정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e예시 구현 (Example implementation)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_https_verify_envvar = 'PYTHONHTTPSVERIFY'\ndef _get_https_context_factory():\n    if not sys.flags.ignore_environment:\n        config_setting = os.environ.get(_https_verify_envvar)\n        if config_setting != '0':\n            return create_default_context\n    return _create_unverified_context\n\n_create_default_https_context = _get_https_context_factory()\n\ndef _disable_https_default_verification():\n    \"\"\"HTTPS 인증서 검증을 기본적으로 건너뜁니다.\"\"\"\n    global _create_default_https_context\n    _create_default_https_context = _create_unverified_context\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e보안 고려 사항 (Security Considerations)\u003c/h3\u003e\n\u003cp\u003e이 변경 사항은 표준 라이브러리 HTTPS 클라이언트에서 현재 기본적으로 인증서 검증을 건너뛰는 모든 Python 버전에 대해 엄격한 보안 업그레이드가 될 것입니다. 고려해야 할 기술적 절충점은 보안 관련 사항보다는 주로 필요한 PEP 466 백포트의 규모와 관련이 있습니다.\u003c/p\u003e\n\u003ch3\u003ePython 가상 환경과의 상호 작용 (Interaction with Python virtual environments)\u003c/h3\u003e\n\u003cp\u003e기본 설정은 프로세스 환경에서 직접 읽히므로, 인터프리터가 활성화된 Python 가상 환경 내에서 실행되는지 여부와 관계없이 동일하게 작동합니다.\u003c/p\u003e\n\u003ch2\u003e이전 Python 버전으로 PEP 476 백포팅 (Backporting PEP 476 to earlier Python versions)\u003c/h2\u003e\n\u003cp\u003e위에 설명된 백포팅 접근 방식은 Python 2.7 설치의 기본 HTTPS 인증서 검증 동작을 수정하지 않습니다. 즉, 인증서 검증은 여전히 연결별(per-connection) 또는 프로세스별(per-process)로 선택해야 합니다.\u003c/p\u003e\n\u003cp\u003e하위 호환성을 손상시키지 않으면서 전체 설치의 기본 동작을 수정할 수 있도록, Red Hat은 Red Hat Enterprise Linux 7.2 이상 버전의 시스템 Python 2.7 설치를 위한 구성 메커니즘을 설계했으며, 이는 다음을 제공합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHTTPS 인증서 검증 활성화 결정과 기능이 처음 백포트된 운영 체제 버전으로 업그레이드 결정이 독립적으로 이루어질 수 있도록 하는 옵트인(opt-in) 모델.\u003c/li\u003e\n\u003cli\u003e시스템 관리자가 시스템 Python 설치에서 직접 실행되는 Python 애플리케이션 및 스크립트의 기본 동작을 설정할 수 있는 기능.\u003c/li\u003e\n\u003cli\u003e재배포자가 향후 특정 시점에 새로운 설치의 기본 동작을 변경하는 것을 고려할 수 있도록 하며, 기본적으로 HTTPS 인증서 검증을 건너뛰도록 명시적으로 구성된 기존 설치에 영향을 미치지 않도록 하는 기능.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 변경사항은 Python 2.7의 이전 릴리스에 대한 백포트에만 영향을 미치므로, 업스트림 CPython에 포함될 것을 제안하지 않고, 대신 사용자에게 유사한 기능을 제공하기로 선택한 다른 재배포자들을 위한 권장 사항으로 제공됩니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 이 특정 변경 사항이 좋은 아이디어인지 아닌지에 대해 입장을 취하지 않습니다. 오히려, 재배포자가 Python 2.7.9보다 오래된 버전의 Python에서 기본 동작을 구성 가능하게 만드는 길을 선택한다면, 재배포자들 간에 일관된 접근 방식을 유지하는 것이 사용자에게 이로울 것이라고 제안합니다.\u003c/p\u003e\n\u003cp\u003e그러나 이 접근 방식은 Python 2.7.9 이상을 제공한다고 광고하는 Python 설치에는 사용해서는 안 됩니다. 대부분의 Python 사용자는 그러한 모든 환경이 기본적으로 HTTPS 인증서를 검증할 것이라는 합리적인 기대를 가질 것이기 때문입니다.\u003c/p\u003e\n\u003ch3\u003e기능 감지 (Feature detection)\u003c/h3\u003e\n\u003cp\u003e이 기능과 관련된 \u003ccode\u003essl\u003c/code\u003e 모듈의 마커 속성은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e_cert_verification_config = '\u0026#x3C;configuration file path\u003e'\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 기능의 존재 여부를 쉽게 감지할 수 있을 뿐만 아니라, 관련 구성 파일 이름을 프로그래밍 방식으로 확인할 수 있도록 합니다.\u003c/p\u003e\n\u003ch3\u003ePython 표준 라이브러리에 대한 권장 수정 사항 (Recommended modifications to the Python standard library)\u003c/h3\u003e\n\u003cp\u003ePEP 476 수정 사항을 이전 포인트 릴리스로 백포팅하기 위한 권장 접근 방식은 Python 2.7.9 이상에서 구현된 기본 PEP 476 동작과 관련하여 다음 변경 사항을 구현하는 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003essl\u003c/code\u003e 모듈이 Python 프로세스에 처음 임포트될 때 시스템 전체 구성 파일을 읽도록 수정합니다.\u003c/li\u003e\n\u003cli\u003e이 구성 파일이 없는 경우 사용할 플랫폼 기본 동작(HTTPS 인증서 검증 또는 비검증)을 정의합니다.\u003c/li\u003e\n\u003cli\u003e다음 세 가지 작동 모드 간의 선택을 지원합니다.\n\u003cul\u003e\n\u003cli\u003eHTTPS 인증서 검증이 활성화되도록 합니다.\u003c/li\u003e\n\u003cli\u003eHTTPS 인증서 검증이 비활성화되도록 합니다.\u003c/li\u003e\n\u003cli\u003e이 Python 버전을 제공하는 재배포자에게 결정을 위임합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e주어진 구성 설정에 따라 \u003ccode\u003essl._create_default_https_context\u003c/code\u003e 함수를 \u003ccode\u003essl.create_default_context\u003c/code\u003e 또는 \u003ccode\u003essl._create_unverified_context\u003c/code\u003e의 별칭으로 설정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e권장 파일 위치 (Recommended file location)\u003c/h3\u003e\n\u003cp\u003ePEP 작성자들은 Windows, Mac OS X 또는 *BSD 시스템을 대상으로 하는 장기 지원 릴리스를 제공하는 벤더를 알지 못하므로, 이 접근 방식은 현재 Linux 시스템 Python 설치에 대해서만 구체적으로 정의되어 있습니다.\u003c/p\u003e\n\u003cp\u003eLinux 시스템에서 권장되는 구성 파일 이름은 \u003ccode\u003e/etc/python/cert-verification.cfg\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e.cfg\u003c/code\u003e 파일 이름 확장자는 Python 3 표준 라이브러리의 \u003ccode\u003evenv\u003c/code\u003e 모듈에서 사용되는 \u003ccode\u003epyvenv.cfg\u003c/code\u003e와의 일관성을 위해 권장됩니다.\u003c/p\u003e\n\u003ch3\u003e권장 파일 형식 (Recommended file format)\u003c/h3\u003e\n\u003cp\u003e구성 파일은 단일 섹션 \u003ccode\u003e[https]\u003c/code\u003e를 포함하는 \u003ccode\u003eConfigParser\u003c/code\u003e ini 스타일 형식을 사용해야 하며, 이 섹션에는 \u003ccode\u003everify\u003c/code\u003e라는 필수 설정이 포함되어야 합니다.\u003c/p\u003e\n\u003cp\u003e제안된 섹션 이름은 영향을 받는 클라이언트 API에 전달되는 \"https\" URL 스키마에서 가져왔습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003everify\u003c/code\u003e에 허용되는 값은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eenable\u003c/code\u003e: HTTPS 인증서 검증이 기본적으로 활성화되도록 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edisable\u003c/code\u003e: HTTPS 인증서 검증이 기본적으로 비활성화되도록 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eplatform_default\u003c/code\u003e: 이 특정 Python 버전을 제공하는 재배포자에게 결정을 위임합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e[https]\u003c/code\u003e 섹션 또는 \u003ccode\u003everify\u003c/code\u003e 설정이 없거나 \u003ccode\u003everify\u003c/code\u003e 설정이 알 수 없는 값으로 설정된 경우, 구성 파일이 없는 것으로 처리해야 합니다.\u003c/p\u003e\n\u003ch3\u003e예시 구현 (Example implementation)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_cert_verification_config = '/etc/python/cert-verification.cfg'\ndef _get_https_context_factory():\n    # 기본 동작에 대한 시스템 전체 재정의를 확인합니다.\n    context_factories = {\n        'enable': create_default_context,\n        'disable': _create_unverified_context,\n        'platform_default': _create_unverified_context, # 지금은 :)\n    }\n    import ConfigParser\n    config = ConfigParser.RawConfigParser()\n    config.read(_cert_verification_config)\n    try:\n        verify_mode = config.get('https', 'verify')\n    except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):\n        verify_mode = 'platform_default'\n    default_factory = context_factories.get('platform_default')\n    return context_factories.get(verify_mode, default_factory)\n\n_create_default_https_context = _get_https_context_factory()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e보안 고려 사항 (Security Considerations)\u003c/h3\u003e\n\u003cp\u003e이 백포트 사례에 대한 특정 권장 사항은 다음과 같은 잠긴 구성에서 실행되는 프로세스라도, 특권이 있는 보안에 민감한 프로세스에 대해 작동하도록 설계되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일반 사용자 디렉토리가 아닌 잠긴 관리자 제어 디렉토리에서 실행 (\u003ccode\u003esys.path[0]\u003c/code\u003e 기반 권한 상승 공격 방지).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-E\u003c/code\u003e 스위치를 사용하여 실행 (\u003ccode\u003ePYTHON*\u003c/code\u003e 환경 변수 기반 권한 상승 공격 방지).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-s\u003c/code\u003e 스위치를 사용하여 실행 (사용자 사이트 디렉토리 기반 권한 상승 공격 방지).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-S\u003c/code\u003e 스위치를 사용하여 실행 (\u003ccode\u003esitecustomize\u003c/code\u003e 기반 권한 상승 공격 방지).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 접근 방식을 사용할 때 HTTPS 검증이 설치 전체에서 꺼지는 유일한 이유는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e최종 사용자가 업스트림 CPython을 직접 실행하는 대신 재배포자가 제공한 CPython 버전을 실행하고 있습니다.\u003c/li\u003e\n\u003cli\u003e해당 재배포자가 업스트림 프로젝트에서 제공하는 것보다 HTTPS 인증서 검증을 기본적으로 사용하도록 더 원활한 마이그레이션 경로를 제공하기로 결정했습니다.\u003c/li\u003e\n\u003cli\u003e재배포자 또는 로컬 인프라 관리자가 (적어도 현재로서는) 2.7.9 이전의 기본 동작을 유지하는 것이 적절하다고 판단했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e환경 변수 대신 관리자 제어 구성 파일을 사용하는 것은 \u003ccode\u003e-E\u003c/code\u003e 스위치로 실행되는 애플리케이션에 대해서도 더 원활한 마이그레이션 경로를 제공하는 필수적인 기능을 합니다.\u003c/p\u003e\n\u003ch3\u003ePython 가상 환경과의 상호 작용 (Interaction with Python virtual environments)\u003c/h3\u003e\n\u003cp\u003e이 설정은 인터프리터 설치에 의해 범위가 지정되며, 인터프리터가 활성화된 Python 가상 환경 내에서 실행되는지 여부와 관계없이 해당 인터프리터를 사용하는 모든 Python 프로세스에 영향을 미칩니다.\u003c/p\u003e\n\u003ch3\u003e이 권장 사항의 기원 (Origins of this recommendation)\u003c/h3\u003e\n\u003cp\u003e이 권장 사항은 이 PEP의 2015년 7월 초판에 게시되고 이 KnowledgeBase 문서에 자세히 설명된 대로, Red Hat Enterprise Linux 7.2에 채택된 백포팅 접근 방식을 기반으로 합니다. Python 2.7.5용 이 백포트를 구현하는 Red Hat의 패치는 CentOS git 리포지토리에서 찾을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e결합된 기능 백포트를 위한 권장 사항 (Recommendation for combined feature backports)\u003c/h2\u003e\n\u003cp\u003e재배포자가 이 PEP의 환경 변수 기반 구성 설정을 파일 기반 PEP 476 백포트도 구현하는 수정된 Python 버전으로 백포팅하기로 선택하는 경우, 환경 변수가 시스템 전체 구성 설정보다 우선해야 합니다. 이렇게 하면 설치 전체의 기본 동작과 관계없이 특정 사용자 또는 애플리케이션에 대해 설정을 변경할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e예시 구현 (Example implementation)\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_https_verify_envvar = 'PYTHONHTTPSVERIFY'\n_cert_verification_config = '/etc/python/cert-verification.cfg'\n\ndef _get_https_context_factory():\n    # 기본 동작에 대한 환경 변수 재정의를 확인합니다.\n    if not sys.flags.ignore_environment:\n        config_setting = os.environ.get(_https_verify_envvar)\n        if config_setting is not None:\n            if config_setting == '0':\n                return _create_unverified_context\n            return create_default_context\n\n    # 기본 동작에 대한 시스템 전체 재정의를 확인합니다.\n    context_factories = {\n        'enable': create_default_context,\n        'disable': _create_unverified_context,\n        'platform_default': _create_unverified_context, # 지금은 :)\n    }\n    import ConfigParser\n    config = ConfigParser.RawConfigParser()\n    config.read(_cert_verification_config)\n    try:\n        verify_mode = config.get('https', 'verify')\n    except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):\n        verify_mode = 'platform_default'\n    default_factory = context_factories.get('platform_default')\n    return context_factories.get(verify_mode, default_factory)\n\n_create_default_https_context = _get_https_context_factory()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 공개 도메인에 배치되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2215,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 493 - HTTPS verification migration tools for Python 2.7\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:38:56+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/493/\",\"postId\":\"2025-09-26-pep-0493-https-verification-migration-tools-for-python-2-7\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/492/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 492 - Coroutines with async and await syntax\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 493 - HTTPS verification migration tools for Python 2.7\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/494/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 494 - Python 3.6 Release Schedule\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>