<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-19cfc001fdac3337.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1098<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Deferred] PEP 267 - Optimized Access to Module Namespaces</h1><div class="page__meta"><time dateTime="2025-09-26 17:50:38+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0267/">PEP 267 - Optimized Access to Module Namespaces</a></p>
<p><strong>상태:</strong> Deferred | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 23-May-2001</p>
</blockquote>
<h1>PEP 267 – 모듈 네임스페이스에 대한 접근 최적화</h1>
<ul>
<li><strong>작성자:</strong> Jeremy Hylton</li>
<li><strong>상태:</strong> 연기됨 (Deferred)</li>
<li><strong>유형:</strong> 표준 트랙 (Standards Track)</li>
<li><strong>생성일:</strong> 2001년 5월 23일</li>
<li><strong>Python 버전:</strong> 2.2</li>
</ul>
<h2>연기 (Deferral)</h2>
<p>이 PEP는 좋은 아이디어임에도 불구하고, PEP 266 및 PEP 280과의 차이점을 조율하고 구현할 사람이 나타나지 않아 연기되었습니다.</p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 전역(global) 모듈 네임스페이스와 내장(builtin) 네임스페이스의 새로운 구현을 제안하며, 이는 이름 분석 속도를 향상시킵니다. 이 구현은 대부분의 네임스페이스 연산에 객체 포인터(object pointers) 배열을 사용합니다. 컴파일러는 컴파일 시점에 전역 변수와 모듈 속성(module attributes)에 대한 인덱스(indices)를 할당합니다.</p>
<p>현재 구현은 이러한 네임스페이스를 딕셔너리(dictionaries)로 표현합니다. 전역 이름은 사용될 때마다 딕셔너리 조회를 발생시키고, 내장 이름은 두 번의 딕셔너리 조회(전역 네임스페이스에서의 실패한 조회와 내장 네임스페이스에서의 두 번째 조회)를 발생시킵니다.</p>
<p>이 새로운 구현은 모듈 레벨 함수와 변수를 사용하는 Python 코드의 속도를 높일 것입니다. 또한 이러한 이름에 대한 접근 속도를 높이기 위해 발전했던 어색한 코딩 스타일을 제거할 것입니다.</p>
<p>전역 및 내장 네임스페이스는 컴파일러가 감지할 수 없는 방식으로 동적으로 수정될 수 있기 때문에 이 구현은 복잡해질 것입니다. (예: 모듈이 임포트된 후 스크립트에 의해 모듈의 네임스페이스가 수정되는 경우) 결과적으로, 이 구현은 이러한 동적 기능을 보존하기 위해 여러 보조 데이터 구조를 유지해야 합니다.</p>
<h2>서론 (Introduction)</h2>
<p>이 PEP는 컴파일 시점에 알려진 모듈 변수에 대한 접근을 최적화하는 모듈 객체의 속성 접근(attribute access)에 대한 새로운 구현을 제안합니다. 모듈은 이러한 변수들을 배열에 저장하고, 배열 오프셋(array offsets)을 사용하여 속성을 조회하는 인터페이스를 제공할 것입니다. 전역 변수, 내장 변수, 그리고 임포트된 모듈의 속성에 대해 컴파일러는 빠른 접근을 위해 배열 오프셋을 사용하는 코드를 생성할 것입니다.</p>
<p>이 구현은 내장 이름의 가시성(visibility)에 영향을 미치는 방식으로 런타임에 모듈 네임스페이스를 수정하는 기능을 포함하여, 모듈 네임스페이스에 대한 기존의 의미론(semantics)을 보존할 것입니다.</p>
<h2>DLict 설계 (DLict design)</h2>
<p>네임스페이스는 때때로 <code>dlict</code>라고 불리는 데이터 구조를 사용하여 구현됩니다. <code>dlict</code>는 일부 딕셔너리 엔트리(entries)에 대해 번호가 매겨진 슬롯(numbered slots)을 갖는 딕셔너리입니다. 허용 가능한 성능을 달성하려면 이 타입은 C로 구현되어야 합니다. 새로운 타입-클래스 통합(type-class unification) 작업으로 인해 비교적 쉽게 구현될 수 있습니다. <code>DLict</code>는 일부 키에 대해 대체 저장 모듈을 가진 딕셔너리의 서브클래스(subclass)일 것으로 예상됩니다.</p>
<p>기본 설계를 설명하기 위해 Python 구현이 포함되어 있습니다:</p>
<pre><code class="language-python">"""A dictionary-list hybrid"""
import types
class DLict:
    def __init__(self, names):
        assert isinstance(names, types.DictType)
        self.names = {} # Stores name -> index mapping
        self.list = [None] * size # Array for indexed slots
        self.empty = [1] * size # Tracks if an indexed slot is empty
        self.dict = {} # Regular dictionary for non-indexed names or dynamic additions
        self.size = 0

    def __getitem__(self, name):
        i = self.names.get(name)
        if i is None:
            return self.dict[name]
        if self.empty[i] is not None:
            raise KeyError, name
        return self.list[i]

    def __setitem__(self, name, val):
        i = self.names.get(name)
        if i is None:
            self.dict[name] = val
        else:
            self.empty[i] = None
            self.list[i] = val
            self.size += 1

    def __delitem__(self, name):
        i = self.names.get(name)
        if i is None:
            del self.dict[name]
        else:
            if self.empty[i] is not None:
                raise KeyError, name
            self.empty[i] = 1
            self.list[i] = None
            self.size -= 1

    def keys(self):
        if self.dict:
            return self.names.keys() + self.dict.keys()
        else:
            return self.names.keys()

    def values(self):
        if self.dict:
            return self.names.values() + self.dict.values()
        else:
            return self.names.values()

    def items(self):
        # NOTE: Original PEP's items() implementation is incorrect.
        # It should combine items from both 'names' and 'dict' based on current values.
        # The provided sample code combines names.items() + dict.items()
        # but also combines names.items() when self.dict is empty, which is inconsistent.
        # For simplicity, I'll keep the original provided structure.
        if self.dict:
            return self.names.items() # This is likely a typo in the original PEP
        else:
            return self.names.items() + self.dict.items() # This is also likely a typo, should be from 'self.list' for indexed items

    def __len__(self):
        return self.size + len(self.dict)

    def __cmp__(self, dlict):
        c = cmp(self.names, dlict.names)
        if c != 0: return c
        c = cmp(self.size, dlict.size)
        if c != 0: return c
        for i in range(len(self.names)):
            c = cmp(self.empty[i], dlict.empty[i])
            if c != 0: return c
            if self.empty[i] is None:
                c = cmp(self.list[i], dlict.empty[i]) # This comparison looks incorrect, comparing value to empty flag
                if c != 0: return c
        return cmp(self.dict, dlict.dict)

    def clear(self):
        self.dict.clear()
        for i in range(len(self.names)):
            if self.empty[i] is None:
                self.empty[i] = 1
                self.list[i] = None

    def update(self):
        pass # Not implemented in the example

    def load(self, index):
        """dlict-special method to support indexed access"""
        if self.empty[index] is None:
            return self.list[index]
        else:
            raise KeyError, index

    def store(self, index, val):
        """dlict-special method to support indexed access"""
        self.empty[index] = None
        self.list[index] = val

    def delete(self, index):
        """dlict-special method to support indexed access"""
        self.empty[index] = 1
        self.list[index] = None
</code></pre>
<h2>컴파일러 문제 (Compiler issues)</h2>
<p>컴파일러는 현재 모듈의 모든 전역 변수 이름을 수집합니다. 이들은 모듈 레벨에서 바인딩되거나, <code>global</code>로 선언된 클래스 또는 함수 본문 내에서 바인딩된 이름들입니다.</p>
<p>컴파일러는 각 전역 이름에 대해 인덱스를 할당하고, 전역 변수들의 이름과 인덱스를 모듈의 코드 객체(code object)에 추가할 것입니다. 그러면 각 코드 객체는 자신이 정의된 모듈에 취소할 수 없게 바인딩될 것입니다. (이것이 미묘한 문제를 일으킬지는 확실하지 않습니다.)</p>
<p>임포트된 모듈의 속성에 대해서는 모듈이 간접(indirection) 레코드를 저장할 것입니다. 내부적으로 모듈은 정의하는 모듈에 대한 포인터와 정의하는 모듈의 전역 변수 배열 내 속성의 오프셋(offset)을 저장합니다. 오프셋은 이름이 처음 조회될 때 초기화됩니다.</p>
<h2>런타임 모델 (Runtime model)</h2>
<p>Python VM은 모듈 레벨 배열을 통해 전역 변수와 모듈 속성에 접근하기 위한 새로운 Opcode (옵코드)로 확장될 것입니다.</p>
<p>함수 객체는 모듈 레벨의 전역 배열에 대한 접근을 제공하기 위해 자신을 정의한 모듈을 가리켜야 할 것입니다.</p>
<p><code>dlict</code>에 저장된 모듈 속성(이를 정적 속성(static attributes)이라고 부름)의 경우, <code>get/delattr</code> 구현은 기존의 이름 기반 인터페이스를 사용하여 이러한 속성에 대한 접근을 추적해야 합니다. 만약 정적 속성이 동적으로 업데이트되면 (예: <code>mod.__dict__["foo"] = 2</code>), 구현은 백업 딕셔너리 대신 배열 슬롯을 업데이트해야 합니다.</p>
<h2>하위 호환성 (Backwards compatibility)</h2>
<p><code>dlict</code>는 슬롯이 현재 사용 중인지 여부에 대한 메타 정보(meta-information)를 유지해야 할 것입니다. 또한 내장 네임스페이스에 대한 포인터도 유지해야 합니다. 이름이 현재 전역 네임스페이스에서 사용되지 않는 경우, 조회는 내장 네임스페이스로 실패하여 넘어갈 것입니다.</p>
<p>반대의 경우, 각 모듈은 내장 이름을 가리는 전역 이름이 동적으로 추가되었는지 확인하는 내장 네임스페이스를 위한 특별한 접근자(accessor) 함수가 필요할 수 있습니다. 이 검사는 모듈의 <code>dlict</code>에 동적 변경이 있었을 때, 즉 컴파일 시점에 발견되지 않은 이름이 바인딩되었을 때만 발생합니다.</p>
<p>이러한 메커니즘은 모듈의 전역 네임스페이스가 런타임에 특이한 방식으로 수정되지 않는 일반적인 경우에는 거의 또는 전혀 비용이 들지 않을 것입니다. 전역 이름을 가지고 특이한 작업을 하는 모듈에 대해서는 오버헤드를 추가하겠지만, 이는 흔치 않은 관행이며 장려할 가치가 없는 행위일 가능성이 높습니다.</p>
<p>향후 Python 버전에서는 전역 네임스페이스에 대한 동적 추가를 비활성화하는 것이 바람직할 수도 있습니다. 그렇게 된다면, 새로운 구현은 경고를 제공할 수 있습니다.</p>
<h2>관련 PEP (Related PEPs)</h2>
<ul>
<li>
<p><strong>PEP 266, Optimizing Global Variable/Attribute Access:</strong> 전역 변수 및 객체 속성에 대한 접근을 최적화하기 위한 다른 메커니즘을 제안합니다. 이 메커니즘은 <code>TRACK_OBJECT</code> 및 <code>UNTRACK_OBJECT</code>라는 두 개의 새로운 Opcode를 사용하여 전역 또는 객체 속성을 별칭(aliases)하는 로컬 변수 배열에 슬롯을 생성합니다. 별칭된 객체가 재바인딩(rebound)되면, 재바인딩 연산은 별칭을 업데이트해야 합니다.</p>
<p>객체 추적(object tracking) 접근 방식은 모듈뿐만 아니라 더 넓은 범위의 객체에 적용됩니다. 또한 런타임 비용이 더 높을 수 있습니다. 왜냐하면 전역 변수나 객체 속성을 사용하는 각 함수는 객체에 대한 관심을 등록하고 종료 시 등록을 해제하기 위해 추가 Opcode를 실행해야 하기 때문입니다. 등록 비용은 명확하지 않지만, 콜백 목록을 유지하기 위한 동적으로 크기 조정 가능한 데이터 구조를 포함할 것으로 예상됩니다.</p>
<p>여기서 제안하는 구현은 별칭을 생성하지 않으므로 등록의 필요성을 피합니다. 대신 전역 변수나 모듈 속성을 참조하는 함수가 원래 바인딩이 저장된 위치에 대한 포인터를 유지하도록 허용합니다. 두 번째 장점은 초기 조회가 함수 호출당 한 번이 아니라 모듈당 한 번 수행된다는 것입니다.</p>
</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 공개 도메인(public domain)에 배포되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-19cfc001fdac3337.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/267\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"FeyCvJug7In7AgUZlfHUx\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/267/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/267\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"267\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/267\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T324c,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0267/\"\u003ePEP 267 - Optimized Access to Module Namespaces\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Deferred | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 23-May-2001\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 267 – 모듈 네임스페이스에 대한 접근 최적화\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Jeremy Hylton\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 연기됨 (Deferred)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e 표준 트랙 (Standards Track)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2001년 5월 23일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 2.2\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e연기 (Deferral)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 좋은 아이디어임에도 불구하고, PEP 266 및 PEP 280과의 차이점을 조율하고 구현할 사람이 나타나지 않아 연기되었습니다.\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 전역(global) 모듈 네임스페이스와 내장(builtin) 네임스페이스의 새로운 구현을 제안하며, 이는 이름 분석 속도를 향상시킵니다. 이 구현은 대부분의 네임스페이스 연산에 객체 포인터(object pointers) 배열을 사용합니다. 컴파일러는 컴파일 시점에 전역 변수와 모듈 속성(module attributes)에 대한 인덱스(indices)를 할당합니다.\u003c/p\u003e\n\u003cp\u003e현재 구현은 이러한 네임스페이스를 딕셔너리(dictionaries)로 표현합니다. 전역 이름은 사용될 때마다 딕셔너리 조회를 발생시키고, 내장 이름은 두 번의 딕셔너리 조회(전역 네임스페이스에서의 실패한 조회와 내장 네임스페이스에서의 두 번째 조회)를 발생시킵니다.\u003c/p\u003e\n\u003cp\u003e이 새로운 구현은 모듈 레벨 함수와 변수를 사용하는 Python 코드의 속도를 높일 것입니다. 또한 이러한 이름에 대한 접근 속도를 높이기 위해 발전했던 어색한 코딩 스타일을 제거할 것입니다.\u003c/p\u003e\n\u003cp\u003e전역 및 내장 네임스페이스는 컴파일러가 감지할 수 없는 방식으로 동적으로 수정될 수 있기 때문에 이 구현은 복잡해질 것입니다. (예: 모듈이 임포트된 후 스크립트에 의해 모듈의 네임스페이스가 수정되는 경우) 결과적으로, 이 구현은 이러한 동적 기능을 보존하기 위해 여러 보조 데이터 구조를 유지해야 합니다.\u003c/p\u003e\n\u003ch2\u003e서론 (Introduction)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 컴파일 시점에 알려진 모듈 변수에 대한 접근을 최적화하는 모듈 객체의 속성 접근(attribute access)에 대한 새로운 구현을 제안합니다. 모듈은 이러한 변수들을 배열에 저장하고, 배열 오프셋(array offsets)을 사용하여 속성을 조회하는 인터페이스를 제공할 것입니다. 전역 변수, 내장 변수, 그리고 임포트된 모듈의 속성에 대해 컴파일러는 빠른 접근을 위해 배열 오프셋을 사용하는 코드를 생성할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 구현은 내장 이름의 가시성(visibility)에 영향을 미치는 방식으로 런타임에 모듈 네임스페이스를 수정하는 기능을 포함하여, 모듈 네임스페이스에 대한 기존의 의미론(semantics)을 보존할 것입니다.\u003c/p\u003e\n\u003ch2\u003eDLict 설계 (DLict design)\u003c/h2\u003e\n\u003cp\u003e네임스페이스는 때때로 \u003ccode\u003edlict\u003c/code\u003e라고 불리는 데이터 구조를 사용하여 구현됩니다. \u003ccode\u003edlict\u003c/code\u003e는 일부 딕셔너리 엔트리(entries)에 대해 번호가 매겨진 슬롯(numbered slots)을 갖는 딕셔너리입니다. 허용 가능한 성능을 달성하려면 이 타입은 C로 구현되어야 합니다. 새로운 타입-클래스 통합(type-class unification) 작업으로 인해 비교적 쉽게 구현될 수 있습니다. \u003ccode\u003eDLict\u003c/code\u003e는 일부 키에 대해 대체 저장 모듈을 가진 딕셔너리의 서브클래스(subclass)일 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e기본 설계를 설명하기 위해 Python 구현이 포함되어 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\"\"\"A dictionary-list hybrid\"\"\"\r\nimport types\r\nclass DLict:\r\n    def __init__(self, names):\r\n        assert isinstance(names, types.DictType)\r\n        self.names = {} # Stores name -\u003e index mapping\r\n        self.list = [None] * size # Array for indexed slots\r\n        self.empty = [1] * size # Tracks if an indexed slot is empty\r\n        self.dict = {} # Regular dictionary for non-indexed names or dynamic additions\r\n        self.size = 0\r\n\r\n    def __getitem__(self, name):\r\n        i = self.names.get(name)\r\n        if i is None:\r\n            return self.dict[name]\r\n        if self.empty[i] is not None:\r\n            raise KeyError, name\r\n        return self.list[i]\r\n\r\n    def __setitem__(self, name, val):\r\n        i = self.names.get(name)\r\n        if i is None:\r\n            self.dict[name] = val\r\n        else:\r\n            self.empty[i] = None\r\n            self.list[i] = val\r\n            self.size += 1\r\n\r\n    def __delitem__(self, name):\r\n        i = self.names.get(name)\r\n        if i is None:\r\n            del self.dict[name]\r\n        else:\r\n            if self.empty[i] is not None:\r\n                raise KeyError, name\r\n            self.empty[i] = 1\r\n            self.list[i] = None\r\n            self.size -= 1\r\n\r\n    def keys(self):\r\n        if self.dict:\r\n            return self.names.keys() + self.dict.keys()\r\n        else:\r\n            return self.names.keys()\r\n\r\n    def values(self):\r\n        if self.dict:\r\n            return self.names.values() + self.dict.values()\r\n        else:\r\n            return self.names.values()\r\n\r\n    def items(self):\r\n        # NOTE: Original PEP's items() implementation is incorrect.\r\n        # It should combine items from both 'names' and 'dict' based on current values.\r\n        # The provided sample code combines names.items() + dict.items()\r\n        # but also combines names.items() when self.dict is empty, which is inconsistent.\r\n        # For simplicity, I'll keep the original provided structure.\r\n        if self.dict:\r\n            return self.names.items() # This is likely a typo in the original PEP\r\n        else:\r\n            return self.names.items() + self.dict.items() # This is also likely a typo, should be from 'self.list' for indexed items\r\n\r\n    def __len__(self):\r\n        return self.size + len(self.dict)\r\n\r\n    def __cmp__(self, dlict):\r\n        c = cmp(self.names, dlict.names)\r\n        if c != 0: return c\r\n        c = cmp(self.size, dlict.size)\r\n        if c != 0: return c\r\n        for i in range(len(self.names)):\r\n            c = cmp(self.empty[i], dlict.empty[i])\r\n            if c != 0: return c\r\n            if self.empty[i] is None:\r\n                c = cmp(self.list[i], dlict.empty[i]) # This comparison looks incorrect, comparing value to empty flag\r\n                if c != 0: return c\r\n        return cmp(self.dict, dlict.dict)\r\n\r\n    def clear(self):\r\n        self.dict.clear()\r\n        for i in range(len(self.names)):\r\n            if self.empty[i] is None:\r\n                self.empty[i] = 1\r\n                self.list[i] = None\r\n\r\n    def update(self):\r\n        pass # Not implemented in the example\r\n\r\n    def load(self, index):\r\n        \"\"\"dlict-special method to support indexed access\"\"\"\r\n        if self.empty[index] is None:\r\n            return self.list[index]\r\n        else:\r\n            raise KeyError, index\r\n\r\n    def store(self, index, val):\r\n        \"\"\"dlict-special method to support indexed access\"\"\"\r\n        self.empty[index] = None\r\n        self.list[index] = val\r\n\r\n    def delete(self, index):\r\n        \"\"\"dlict-special method to support indexed access\"\"\"\r\n        self.empty[index] = 1\r\n        self.list[index] = None\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e컴파일러 문제 (Compiler issues)\u003c/h2\u003e\n\u003cp\u003e컴파일러는 현재 모듈의 모든 전역 변수 이름을 수집합니다. 이들은 모듈 레벨에서 바인딩되거나, \u003ccode\u003eglobal\u003c/code\u003e로 선언된 클래스 또는 함수 본문 내에서 바인딩된 이름들입니다.\u003c/p\u003e\n\u003cp\u003e컴파일러는 각 전역 이름에 대해 인덱스를 할당하고, 전역 변수들의 이름과 인덱스를 모듈의 코드 객체(code object)에 추가할 것입니다. 그러면 각 코드 객체는 자신이 정의된 모듈에 취소할 수 없게 바인딩될 것입니다. (이것이 미묘한 문제를 일으킬지는 확실하지 않습니다.)\u003c/p\u003e\n\u003cp\u003e임포트된 모듈의 속성에 대해서는 모듈이 간접(indirection) 레코드를 저장할 것입니다. 내부적으로 모듈은 정의하는 모듈에 대한 포인터와 정의하는 모듈의 전역 변수 배열 내 속성의 오프셋(offset)을 저장합니다. 오프셋은 이름이 처음 조회될 때 초기화됩니다.\u003c/p\u003e\n\u003ch2\u003e런타임 모델 (Runtime model)\u003c/h2\u003e\n\u003cp\u003ePython VM은 모듈 레벨 배열을 통해 전역 변수와 모듈 속성에 접근하기 위한 새로운 Opcode (옵코드)로 확장될 것입니다.\u003c/p\u003e\n\u003cp\u003e함수 객체는 모듈 레벨의 전역 배열에 대한 접근을 제공하기 위해 자신을 정의한 모듈을 가리켜야 할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edlict\u003c/code\u003e에 저장된 모듈 속성(이를 정적 속성(static attributes)이라고 부름)의 경우, \u003ccode\u003eget/delattr\u003c/code\u003e 구현은 기존의 이름 기반 인터페이스를 사용하여 이러한 속성에 대한 접근을 추적해야 합니다. 만약 정적 속성이 동적으로 업데이트되면 (예: \u003ccode\u003emod.__dict__[\"foo\"] = 2\u003c/code\u003e), 구현은 백업 딕셔너리 대신 배열 슬롯을 업데이트해야 합니다.\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards compatibility)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003edlict\u003c/code\u003e는 슬롯이 현재 사용 중인지 여부에 대한 메타 정보(meta-information)를 유지해야 할 것입니다. 또한 내장 네임스페이스에 대한 포인터도 유지해야 합니다. 이름이 현재 전역 네임스페이스에서 사용되지 않는 경우, 조회는 내장 네임스페이스로 실패하여 넘어갈 것입니다.\u003c/p\u003e\n\u003cp\u003e반대의 경우, 각 모듈은 내장 이름을 가리는 전역 이름이 동적으로 추가되었는지 확인하는 내장 네임스페이스를 위한 특별한 접근자(accessor) 함수가 필요할 수 있습니다. 이 검사는 모듈의 \u003ccode\u003edlict\u003c/code\u003e에 동적 변경이 있었을 때, 즉 컴파일 시점에 발견되지 않은 이름이 바인딩되었을 때만 발생합니다.\u003c/p\u003e\n\u003cp\u003e이러한 메커니즘은 모듈의 전역 네임스페이스가 런타임에 특이한 방식으로 수정되지 않는 일반적인 경우에는 거의 또는 전혀 비용이 들지 않을 것입니다. 전역 이름을 가지고 특이한 작업을 하는 모듈에 대해서는 오버헤드를 추가하겠지만, 이는 흔치 않은 관행이며 장려할 가치가 없는 행위일 가능성이 높습니다.\u003c/p\u003e\n\u003cp\u003e향후 Python 버전에서는 전역 네임스페이스에 대한 동적 추가를 비활성화하는 것이 바람직할 수도 있습니다. 그렇게 된다면, 새로운 구현은 경고를 제공할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e관련 PEP (Related PEPs)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePEP 266, Optimizing Global Variable/Attribute Access:\u003c/strong\u003e 전역 변수 및 객체 속성에 대한 접근을 최적화하기 위한 다른 메커니즘을 제안합니다. 이 메커니즘은 \u003ccode\u003eTRACK_OBJECT\u003c/code\u003e 및 \u003ccode\u003eUNTRACK_OBJECT\u003c/code\u003e라는 두 개의 새로운 Opcode를 사용하여 전역 또는 객체 속성을 별칭(aliases)하는 로컬 변수 배열에 슬롯을 생성합니다. 별칭된 객체가 재바인딩(rebound)되면, 재바인딩 연산은 별칭을 업데이트해야 합니다.\u003c/p\u003e\n\u003cp\u003e객체 추적(object tracking) 접근 방식은 모듈뿐만 아니라 더 넓은 범위의 객체에 적용됩니다. 또한 런타임 비용이 더 높을 수 있습니다. 왜냐하면 전역 변수나 객체 속성을 사용하는 각 함수는 객체에 대한 관심을 등록하고 종료 시 등록을 해제하기 위해 추가 Opcode를 실행해야 하기 때문입니다. 등록 비용은 명확하지 않지만, 콜백 목록을 유지하기 위한 동적으로 크기 조정 가능한 데이터 구조를 포함할 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e여기서 제안하는 구현은 별칭을 생성하지 않으므로 등록의 필요성을 피합니다. 대신 전역 변수나 모듈 속성을 참조하는 함수가 원래 바인딩이 저장된 위치에 대한 포인터를 유지하도록 허용합니다. 두 번째 장점은 초기 조회가 함수 호출당 한 번이 아니라 모듈당 한 번 수행된다는 것입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 공개 도메인(public domain)에 배포되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1098,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Deferred] PEP 267 - Optimized Access to Module Namespaces\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 17:50:38+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>