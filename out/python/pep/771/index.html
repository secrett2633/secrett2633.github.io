<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/edf391eeca43d999.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-ad5f81b531af48c1.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1962<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Draft] PEP 771 - Default Extras for Python Software Packages</h1><div class="page__meta"><time dateTime="2025-09-27 13:52:58+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0771/">PEP 771 - Default Extras for Python Software Packages</a></p>
<p><strong>상태:</strong> Draft | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 13-Jan-2025</p>
</blockquote>
<h2>PEP 771 – Python 소프트웨어 패키지를 위한 기본 Extras</h2>
<h3>초록 (Abstract)</h3>
<p>PEP 508은 패키지 의존성을 선언하기 위한 미니 언어(mini-language)를 정의합니다. 이 언어의 한 가지 특징은 <code>extras</code>를 지정할 수 있다는 것입니다. <code>extras</code>는 배포판의 선택적 구성 요소로, 사용될 경우 추가 의존성을 설치합니다. 이 PEP는 명시적으로 제공되지 않을 경우 하나 이상의 <code>extras</code>가 기본적으로 설치되도록 하는 메커니즘을 제안합니다.</p>
<h3>동기 (Motivation)</h3>
<p>기본 <code>extras</code>에 대한 다양한 사용 사례와 이 PEP에서 가능한 해결책들은 DPO 스레드에서 광범위하게 논의되었습니다. 이는 크게 두 가지 경우로 나뉘며, 본 PEP의 동기가 됩니다.</p>
<h4>권장되지만 필수는 아닌 의존성 (Recommended but not required dependencies)</h4>
<p>패키지 관리자는 종종 패키지의 기능이나 성능을 확장하는 선택적 의존성을 선언하기 위해 <code>extras</code>를 사용합니다. 어떤 의존성이 필수이고 어떤 의존성이 <code>extras</code>로 분류되어야 하는지 결정하기 어려울 때가 있습니다. 대부분의 기능이 기본적으로 제공되기를 선호하는 일반 사용자들의 요구와, 크고 선택적인 의존성 없이 최소한의 설치를 원하는 사용자들의 요구 사이에서 균형을 찾아야 합니다.</p>
<p>기존 Python 패키징 인프라를 사용한 한 가지 해결책은 패키지 관리자가 예를 들어 <code>recommended</code>라는 <code>extra</code>를 정의하여 모든 필수적이지 않지만 제안되는 의존성을 포함하도록 하는 것입니다. 그러면 사용자에게 <code>package[recommended]</code>를 사용하여 패키지를 설치하도록 안내하고, 더 많은 제어를 원하는 사용자는 <code>package</code>를 사용할 수 있습니다. 그러나 실제로는 많은 사용자가 <code>[recommended]</code> 구문을 알지 못하여, 일반적인 설치를 위해 이를 알아야 하는 부담을 지게 됩니다. 권장되는 의존성이 기본적으로 설치되면서도 사용자가 더 최소한의 설치를 요청할 수 있는 방법을 제공하는 것은 이러한 사용 사례를 만족시킬 것이며, 이 PEP는 이에 대한 해결책을 설명합니다.</p>
<p>이 패턴을 보여주는 패키지 예시는 다음과 같습니다.</p>
<ul>
<li><code>astropy</code>: <code>astropy[recommended]</code></li>
<li><code>sunpy</code>: <code>sunpy[all]</code></li>
<li><code>fastapi</code>: <code>fastapi[standard]</code></li>
</ul>
<h4>여러 백엔드 또는 프론트엔드를 지원하는 패키지 (Packages supporting multiple backends or frontends)</h4>
<p><code>extras</code>를 사용하는 또 다른 일반적인 사용 사례는 다양한 백엔드 또는 프론트엔드와 각 백엔드/프론트엔드에 필요한 의존성을 정의하는 것입니다. 패키지는 기능하기 위해 최소한 하나의 백엔드나 프론트엔드가 설치되어야 하지만, 어떤 백엔드/프론트엔드가 설치될지에 대해서는 유연할 수 있습니다. 구체적인 예시는 다음과 같습니다.</p>
<ul>
<li><code>PyQt5</code>, <code>PyQt6</code>, <code>PySide2</code>, 또는 <code>PySide6</code>로 제공될 수 있는 Qt 프론트엔드 라이브러리.</li>
<li>MySQL, PostgreSQL, SQLite와 같은 백엔드 데이터베이스.</li>
</ul>
<p>현재 패키징 표준에서는, 관리자가 백엔드나 프론트엔드 중 하나를 필수로 지정하거나, 사용자에게 항상 <code>package[backend]</code>와 같이 <code>extras</code>를 명시하도록 요구해야 합니다. 이로 인해 사용자가 단순히 <code>package</code>만 설치할 경우 사용할 수 없는 설치가 될 위험이 있습니다. 하나 이상의 기본 백엔드나 프론트엔드를 지정하고 이러한 기본값을 재정의할 수 있는 방법을 제공하는 것은 사용자에게 훨씬 더 나은 경험을 제공할 것이며, 이 PEP에 설명된 접근 방식은 이를 가능하게 할 것입니다.</p>
<p>이 PEP는 패키지가 정확히 하나의 프론트엔드나 백엔드 패키지를 요구하는 경우와 같이, 충돌하거나 호환되지 않는 <code>extras</code>를 허용하지 않는 문제를 해결하는 것을 목표로 하지 않습니다. 현재 Python 패키징 인프라에는 충돌하거나 호환되지 않는 <code>extras</code>의 설치를 금지하는 메커니즘이 없으며, 이 PEP는 이를 변경하지 않습니다.</p>
<p>작동을 위해 최소한 하나의 백엔드 또는 프론트엔드를 요구하고 기본 <code>extra</code>를 권장하는 패키지 예시는 다음과 같습니다.</p>
<ul>
<li><code>kivy</code>: <code>kivy[base]</code></li>
<li><code>napari</code>: <code>napari[all]</code></li>
<li><code>glueviz</code>: <code>glueviz[qt]</code></li>
</ul>
<p>이 세 가지 경우 모두에서, <code>extras</code> 없이 패키지를 설치하면 설치가 제대로 작동하지 않으며, 이는 이러한 패키지들의 흔히 보고되는 지원 문제입니다.</p>
<h3>근거 (Rationale)</h3>
<p>여러 해 동안 커뮤니티에서 많은 가능한 해결책들이 광범위하게 논의되었습니다. 아래에 제시된 해결책은 다음 세 가지 기준을 모두 충족하는 유일한 방안입니다.</p>
<ul>
<li>옵트인(opt-in) 솔루션으로, 패키지 관리자가 사용 여부를 선택할 수 있습니다.</li>
<li>"동기(Motivation)" 섹션에서 설명된 두 가지 주요 사용 사례를 모두 수용할 수 있을 만큼 충분히 유연합니다.</li>
<li>PEP 508의 구문을 재사용합니다.</li>
</ul>
<h3>명세 (Specification)</h3>
<h4><code>Default-Extra</code> 메타데이터 필드</h4>
<p>코어 패키지 메타데이터에 새로운 다중 사용(multiple-use) 메타데이터 필드인 <code>Default-Extra</code>가 추가됩니다. 이 필드의 각 항목은 패키지가 명시적으로 <code>extras</code> 없이 설치될 때 자동으로 포함될 <code>extra</code>를 지정하는 문자열이어야 합니다.</p>
<p><code>Provides-Extra</code> 항목에 이미 지정된 항목만 <code>Default-Extra</code> 항목에 사용될 수 있습니다.</p>
<p>예시:</p>
<pre><code>Default-Extra: recommended
Default-Extra: backend1
Default-Extra: backend2
Default-Extra: backend3
</code></pre>
<p>이것은 코어 패키지 메타데이터에 새로운 필드를 도입하므로, <code>Metadata-Version</code>을 다음 마이너 버전 (작성 시점 2.5)으로 올려야 합니다.</p>
<h4><code>[project]</code> 메타데이터 테이블의 새 키</h4>
<p>PEP 621에서 원래 정의되었고 현재 PyPA 명세에서 정의된 <code>[project]</code> 메타데이터 테이블에 새로운 키가 추가됩니다. 이 키의 이름은 <code>default-optional-dependency-keys</code>이며, 다음 설명을 가집니다.</p>
<ul>
<li>TOML 타입: 문자열 배열 (Array of strings)</li>
<li>해당 코어 메타데이터 필드: <code>Default-Extra</code></li>
</ul>
<p><code>default-optional-dependency-keys</code>의 각 문자열은 <code>optional-dependencies</code>에 정의된 <code>extra</code>의 이름이어야 하며, 이 배열의 각 <code>extra</code>는 코어 패키지 메타데이터의 일치하는 <code>Default-Extra</code> 항목으로 변환됩니다. 이전 섹션에서 제시된 <code>Default-Extra</code> 항목 예시를 생성하는 유효한 사용 예시는 다음과 같습니다.</p>
<pre><code class="language-toml">[project]
default-optional-dependency-keys = [
    "recommended",
]
</code></pre>
<p>그리고:</p>
<pre><code class="language-toml">[project]
default-optional-dependency-keys = [
    "backend1",
    "backend2",
    "backend3"
]
</code></pre>
<h4>기본 <code>extras</code> 재정의 (Overriding default extras)</h4>
<p>의존성 명세에서 <code>extras</code>가 명시적으로 주어지면, 기본 <code>extras</code>는 무시됩니다. 그렇지 않으면 기본 <code>extras</code>가 설치됩니다.</p>
<p>예를 들어, 패키지가 <code>extra1</code>을 기본 <code>extra</code>로 정의하고 <code>extra2</code>를 비기본 <code>extra</code>로 정의한 경우, 사용자가 다음과 같이 패키지를 설치하면:</p>
<pre><code class="language-bash">$ pip install package
</code></pre>
<p>기본 <code>extra1</code> 의존성이 포함됩니다. 만약 사용자가 대신 다음과 같이 패키지를 설치하면:</p>
<pre><code class="language-bash">$ pip install package[extra2]
</code></pre>
<p><code>extra2</code>가 설치되지만, 기본 <code>extra1</code>은 무시됩니다.</p>
<p>설치 명령이나 의존성 트리에서 동일한 패키지가 여러 번 지정되는 경우, 패키지의 인스턴스 중 하나라도 <code>extras</code>가 지정되지 않은 경우 기본 <code>extras</code>가 설치되어야 합니다. 예를 들어, <code>package</code>가 의존성 트리에서 여러 번 나타나는 패키지 <code>spam</code>을 설치하는 경우:</p>
<pre><code>spam
├── tomato
│   ├── package[extra2]
└── egg
    └── package
</code></pre>
<p><code>package</code>가 최소한 한 번 <code>extras</code>가 지정되지 않은 채로 나타나므로, 기본 <code>extra</code>가 설치되어야 합니다.</p>
<p><code>package[]</code>와 같이 비어 있는 <code>extras</code> 세트는 어떤 기본 <code>extras</code>도 설치하지 않아야 함을 의미하는 것으로 해석되어야 합니다 (단, <code>package</code>가 의존성 트리의 다른 곳에 나타나는 경우는 예외이며, 이 경우 위에서 언급한 대로 기본 <code>extra</code>가 설치됩니다). 이것은 패키지의 최소 설치를 얻는 보편적인 방법을 제공할 것입니다.</p>
<p><code>pip</code>와 같은 일부 도구는 현재 인식할 수 없는 <code>extras</code>를 무시하고 사용자에게 <code>extra</code>가 인식되지 않았음을 알리는 경고를 발생시킵니다. 예를 들어:</p>
<pre><code class="language-bash">$ pip install package[non-existent-extra]
WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'
...
</code></pre>
<p>이러한 방식으로 동작하는 도구(오류를 발생시키는 대신)의 경우, 의존성 명세에서 <code>extra</code>가 유효하지 않은 것으로 인식되면 무시되어야 합니다. 그리고 지정된 모든 <code>extras</code>가 유효하지 않은 경우, 이는 <code>package</code>가 아닌 <code>package[]</code>와 동일한 것으로 간주되어야 하며, 어떤 기본 <code>extras</code>도 설치하지 않아야 합니다.</p>
<p>마지막으로, (또한 "Relying on tooling to deselect any default extras" 섹션에서 논의된 바와 같이) 패키지 설치 도구는 위 동작을 제어하기 위한 자체 옵션을 구현할 수 있습니다. 예를 들어, 이러한 패키지가 의존성 트리의 어디에 나타나든 관계없이 일부 또는 모든 패키지에 대한 기본 <code>extras</code>를 비활성화하는 옵션을 구현할 수 있습니다. 이러한 도구별 옵션이 구현되는 경우, 도구 개발자는 이를 옵트인(opt-in) 방식으로 만들어야 하며, 사용자는 위에 명시된 PEP 771 동작을 기본으로 경험해야 합니다.</p>
<h3>예시 (Examples)</h3>
<p>이 섹션에서는 "동기" 섹션에서 설명된 사용 사례와, 위에 설명된 명세를 사용하여 이를 어떻게 해결할 수 있는지 살펴봅니다.</p>
<h4>권장되는 의존성 및 최소 설치 (Recommended dependencies and minimal installations)</h4>
<p>먼저, 기본적으로 권장되지만 엄격하게 필수는 아닌 의존성을 설치하고, 필요한 의존성만 설치하는 방법도 제공하려는 패키지의 경우를 고려합니다.</p>
<p>이를 위해 패키지 관리자는 권장되지만 필수는 아닌 의존성을 포함하는 <code>recommended</code>라는 <code>extra</code>를 정의하고, 이를 기본 <code>extra</code>로 포함하도록 선택할 것입니다.</p>
<pre><code class="language-toml">[project]
default-optional-dependency-keys = [ "recommended" ]

[project.optional-dependencies]
recommended = [
    "package1",
    "package2"
]
</code></pre>
<p>이 패키지가 <code>package</code>라고 불린다면, <code>package</code>를 설치하는 사용자는 <code>package[recommended]</code>와 동일한 결과를 얻게 됩니다. 사용자는 대안으로 <code>package[]</code>를 설치하여 기본 <code>extras</code> 없이 패키지를 설치할 수 있습니다.</p>
<p>"동기" 섹션의 구체적인 패키지 예시 중 하나인 <code>astropy</code> 패키지는 <code>recommended</code> <code>extra</code>를 정의하며, 사용자는 현재 기본 설치 지침에서 이를 설치하도록 안내받습니다. 이 PEP를 통해 <code>recommended</code> <code>extra</code>는 기본 <code>extra</code>로 선언될 수 있습니다.</p>
<pre><code class="language-toml">[project]
default-optional-dependency-keys = [ "recommended" ]

[project.optional-dependencies]
recommended = [
    "scipy",
    "..."
]
</code></pre>
<p>이는 다음 설치 명령이:</p>
<pre><code class="language-bash">$ pip install astropy
</code></pre>
<p><code>scipy</code>와 같은 선택적이지만 권장되는 의존성을 설치할 것임을 의미합니다. 최소 설치를 원하는 고급 사용자는 다음을 사용할 수 있습니다.</p>
<pre><code class="language-bash">$ pip install astropy[]
</code></pre>
<h4>최소한 하나의 백엔드 또는 프론트엔드를 요구하는 패키지 (Packages requiring at least one backend or frontend)</h4>
<p>"동기" 섹션에서 설명한 바와 같이, 일부 패키지는 여러 백엔드 및/또는 프론트엔드를 지원할 수 있으며, 어떤 경우에는 항상 최소한 하나의 백엔드 또는 프론트엔드 패키지가 설치되도록 하는 것이 바람직할 수 있습니다. 그렇지 않으면 패키지를 사용할 수 없기 때문입니다. 구체적인 예로는 GUI 라이브러리가 있어야 사용할 수 있지만 다른 라이브러리를 지원할 수 있는 GUI 애플리케이션, 또는 여러 계산 백엔드에 의존할 수 있지만 최소한 하나는 설치되어야 하는 패키지가 있습니다.</p>
<p>이 경우, 패키지 관리자는 각 백엔드 또는 프론트엔드에 대한 <code>extra</code>를 정의하고 기본값을 제공하도록 선택할 수 있습니다.</p>
<pre><code class="language-toml">[project]
default-optional-dependency-keys = [ "backend1" ]

[project.optional-dependencies]
backend1 = [
    "package1",
    "package2"
]
backend2 = [
    "package3"
]
</code></pre>
<p>패키지가 예를 들어 여러 백엔드를 동시에 지원할 수 있고, 일부 백엔드가 항상 설치되어야 한다면, 이들에 대한 의존성은 기본 <code>extras</code> 메커니즘을 사용하는 대신 필수 의존성으로 제공되어야 합니다.</p>
<p>"동기" 섹션에서 언급된 구체적인 예시 중 하나인 <code>napari</code> 패키지는 <code>PyQt5</code>, <code>PyQt6</code>, <code>PySide2</code>, 또는 <code>PySide6</code> 중 하나를 사용할 수 있으며, 사용자는 현재 이 중 하나가 설치되도록 <code>napari[all]</code>을 명시적으로 지정하거나, <code>napari[pyqt5]</code>와 같이 특정 프론트엔드 패키지를 명시적으로 지정해야 합니다. <code>extras</code> 없이 <code>napari</code>를 설치하면 작동하지 않는 패키지가 됩니다. 이 PEP를 통해 <code>napari</code>는 다음 구성을 정의할 수 있습니다.</p>
<pre><code class="language-toml">[project]
default-optional-dependency-keys = [ "pyqt5" ]

[project.optional-dependencies]
pyqt5 = [
    "PyQt5",
    "..."
]
pyside2 = [
    "PySide2",
    "..."
]
pyqt6 = [
    "PyQt6",
    "..."
]
pyside6 = [
    "PySide6",
    "..."
]
</code></pre>
<p>이는 다음 설치 명령이:</p>
<pre><code class="language-bash">$ pip install napari
</code></pre>
<p>별도의 설정 없이 작동하지만, 사용자가 예를 들어 <code>napari[pyside6]</code>와 같이 프론트엔드를 명시적으로 지정할 수 있는 메커니즘은 여전히 존재할 것임을 의미합니다.</p>
<h4>기본 <code>extras</code>를 제거하지 않는 <code>extras</code> 지원 (Supporting extras that should not remove default extras)</h4>
<p>여기서 고려하는 추가적인 경우는 패키지 관리자가 기본 <code>extras</code>를 제거하지 않고 사용자가 비기본 <code>extras</code>를 옵트인(opt-in)할 수 있도록 지원하고자 하는 경우입니다. 본질적으로 그들은 다음을 원할 수 있습니다.</p>
<ul>
<li><code>package[]</code>는 <code>extras</code> 없이 설치합니다.</li>
<li><code>package</code>는 권장 의존성(권장 <code>extra</code>에 있는)을 설치합니다.</li>
<li><code>package[alternative]</code>는 기본 <code>extras</code>를 설치하지 않지만, 대안적인 선택적 의존성 세트(대안 <code>extra</code>에 있는)를 설치합니다.</li>
<li><code>package[additional]</code>은 권장 의존성과 추가 의존성(추가 <code>extra</code>에 있는)을 모두 설치합니다.</li>
</ul>
<p>이는 예를 들어 다음을 통해 달성될 수 있습니다.</p>
<pre><code class="language-toml">[project]
default-optional-dependency-keys = [ "recommended" ]

[project.optional-dependencies]
recommended = [
    "package1",
    "package2"
]
alternative = [
    "package3"
]
additional = [
    "package[recommended]", # 패키지 자체를 참조하여 기본 extra를 포함
    "package4"
]
</code></pre>
<p>패키지가 <code>extras</code>에서 자신을 참조하는 기능은 기존 Python 패키징 도구에 의해 지원됩니다.</p>
<p>다시 한번 구체적인 예시로 <code>astropy</code>를 고려하면, 이 PEP를 통해 <code>recommended</code> <code>extra</code>를 정의할 수 있습니다 ("권장되는 의존성 및 최소 설치" 섹션에서 설명된 바와 같이). 그러나 <code>jupyter</code>와 같은 다른 <code>extras</code>도 정의하는데, 이는 Jupyter 기반 환경 내에서 사용자 경험을 향상시키는 패키지를 추가합니다. 이 <code>extra</code>를 선택하는 사용자도 여전히 권장되는 의존성을 설치하기를 원할 수 있습니다. 이 경우 다음 구성이 이 문제를 해결할 것입니다.</p>
<pre><code class="language-toml">[project]
default-optional-dependency-keys = [ "recommended" ]

[project.optional-dependencies]
recommended = [
    "scipy",
    "..."
]
jupyter = [
    "astropy[recommended]", # astropy 자체를 참조하여 'recommended' extra를 포함
    "ipywidgets",
    "..."
]
</code></pre>
<p>다음과 같이 설치하는 사용자:</p>
<pre><code class="language-bash">$ pip install astropy[jupyter]
</code></pre>
<p>그러면 <code>astropy[recommended, jupyter]</code>와 동일한 것을 얻게 됩니다.</p>
<h4>여러 종류의 기본값을 가진 패키지 (Packages with multiple kinds of defaults)</h4>
<p>어떤 경우에는 패키지에 여러 종류의 기본값이 필요할 수 있습니다. 예를 들어, "최소한 하나의 백엔드 또는 프론트엔드를 요구하는 패키지" 섹션에서 백엔드 또는 프론트엔드를 가진 패키지의 경우를 고려했지만, 어떤 경우에는 패키지가 백엔드와 프론트엔드를 모두 지원해야 할 수 있으며, 하나 이상의 기본 프론트엔드와 하나 이상의 기본 백엔드를 지정하기를 원할 수 있습니다.</p>
<p>이상적으로는 다음 동작을 원할 수 있습니다.</p>
<ul>
<li><code>$ pip install package</code> # 기본 백엔드와 프론트엔드를 설치합니다.</li>
<li><code>$ pip install package[]</code> # 백엔드나 프론트엔드를 설치하지 않습니다.</li>
<li><code>$ pip install package[backend1]</code> # <code>backend1</code>과 기본 프론트엔드를 설치합니다.</li>
<li><code>$ pip install package[frontend2]</code> # <code>frontend2</code>와 기본 백엔드를 설치합니다.</li>
<li><code>$ pip install package[backend1, frontend2]</code> # <code>backend1</code>과 <code>frontend2</code>를 설치합니다.</li>
</ul>
<p>그러나 이 PEP는 복잡성을 추가하기 때문에, 예를 들어 <code>backend1</code>이 지정된 경우 기본 백엔드는 비활성화되지만 기본 프론트엔드는 활성화되는 메커니즘을 제공하지 않기로 선택했습니다.</p>
<p>관리자는 대신 지금은 백엔드 또는 프론트엔드가 명시적으로 지정된 경우 백엔드와 프론트엔드 모두를 지정해야 함을 문서화해야 합니다. 그러나 이를 원하는 사용자의 발견 가능성(discoverability)은 문제가 되지 않을 것입니다. 사용자는 어떤 백엔드나 프론트엔드를 사용할 수 있는지 알아보기 위해 어차피 문서를 읽어야 하므로, 백엔드와 프론트엔드에 대한 <code>extras</code>를 올바르게 사용하는 방법을 동시에 보여줄 수 있습니다.</p>
<p>사용자 편의성을 높이는 한 가지 옵션은 관리자가 예를 들어 <code>defaultbackend</code> 및 <code>defaultfrontend</code>라는 <code>extras</code>를 만들고, 이들이 기본 백엔드와 프론트엔드를 설치하도록 하는 것입니다. 그런 다음 사용자에게 다음을 권장할 수 있습니다.</p>
<pre><code class="language-bash">$ pip install package # 기본 백엔드와 프론트엔드를 설치합니다.
$ pip install package[] # 백엔드나 프론트엔드를 설치하지 않습니다.
$ pip install package[backend1, defaultfrontend] # backend1과 기본 프론트엔드를 설치합니다.
$ pip install package[defaultbackend, frontend2] # frontend2와 기본 백엔드를 설치합니다.
$ pip install package[backend1, frontend2] # backend1과 frontend2를 설치합니다.
</code></pre>
<p>이를 통해 (원하는 경우) 사용자는 시간이 지나면서 기본 백엔드가 변경되더라도 권장되는 백엔드를 얻을 수 있습니다.</p>
<p>미래에 더 나은 해결책을 구현하려는 열망이 있다면, 이 PEP가 이를 배제하지는 않는다고 생각합니다. 예를 들어, 미래에는 <code>extra</code>가 어떤 기본 <code>extras</code>를 비활성화하는지 지정하는 기능을 추가할 수 있으며, 이 부분이 지정되지 않으면 명시적으로 지정된 <code>extras</code>가 모든 기본 <code>extras</code>를 비활성화할 수 있습니다 (이 PEP와 일치).</p>
<h3>하위 호환성 (Backward Compatibility)</h3>
<h4>기본 <code>extras</code>를 사용하지 않는 패키지 (Packages not using default extras)</h4>
<p>패키징 생태계의 도구에 이 PEP에 대한 지원이 추가되면, 기본 <code>extras</code>를 사용하지 않는 패키지는 그대로 작동하며 호환성 문제는 없을 것입니다.</p>
<h4>기본 <code>extras</code>를 사용하는 패키지 (Packages using default extras)</h4>
<p>패키지가 기본 <code>extras</code>를 정의하기 시작하면, 이러한 기본값은 이 PEP를 구현하는 최신 버전의 패키징 도구에서만 적용됩니다. 그러나 해당 패키지는 이전 패키징 도구에서도 설치 가능하며, 주요 차이점은 이전 패키징 도구를 사용할 때 기본 <code>extras</code>가 자동으로 설치되지 않는다는 것입니다.</p>
<p>"How to teach this" 섹션에서 설명된 바와 같이, 패키지 작성자는 사용자 기반에 따라 <code>default extra</code> 기능을 언제, 어떻게 채택할지 신중하게 평가해야 합니다. 일부 작업(예: 필수 의존성을 기본 <code>extra</code>로 이동)은 상당수의 사용자가 <code>default extras</code>를 지원하지 않는 이전 패키지 설치 도구를 여전히 사용하고 있다면 사용자에게 문제가 발생할 수 있습니다. 이러한 의미에서 패키지 작성자는 이 기능이 특정 방식으로 사용될 경우 사용자에게 하위 호환성 문제를 일으킬 수 있음을 인지하고, 사용자에게 미치는 영향을 최소화할 책임이 있습니다.</p>
<h4>패키징 관련 도구 (Packaging-related tools)</h4>
<p>가장 중요한 하위 호환성 측면은 패키징 도구가 <code>extras</code>에 대해 가지고 있는 가정과 관련이 있습니다. 특히, 이 PEP는 <code>extras</code>가 더 이상 의존성 트리에 의존성을 추가하는 측면에서만 배타적으로 추가적인 것이 아니며, 일부 <code>extras</code>를 지정하면 더 적은 의존성이 설치될 수 있다는 가정을 변경합니다.</p>
<p>동작 변경의 구체적인 예시는 <code>pip</code>에서 볼 수 있습니다. <code>numpy</code>에 필수 의존성이 있고, <code>scipy</code>를 포함하는 <code>recommended</code>라는 기본 <code>extra</code>를 가진 <code>package</code>라는 패키지를 고려해봅시다. 사용자가 <code>package[]</code>를 설치하면 <code>package</code>와 <code>numpy</code>만 설치됩니다. 사용자가 다음과 같이 실행하면:</p>
<pre><code class="language-bash">$ pip freeze > requirements.txt
</code></pre>
<p><code>requirements.txt</code>에는 예를 들어 다음과 같이 포함될 것입니다.</p>
<pre><code>package==1.0.2
numpy==2.1.0
</code></pre>
<p>그러나 사용자가 이 파일을 사용하여 요구 사항을 설치하면:</p>
<pre><code class="language-bash">$ pip install -r requirements.txt
</code></pre>
<p><code>pip</code>는 <code>package</code> (기본 <code>extra</code>를 포함)와 <code>numpy</code>를 설치할 것이므로, 최종 환경에는 <code>scipy</code>가 포함될 것입니다. 이 특정 경우의 해결책은 사용자가 의존성 트리를 해결하지 않기 위해 <code>pip install</code>에 <code>--no-deps</code>를 전달하는 것이지만, 여기서 요점은 <code>extra</code>가 미칠 수 있는 영향에 대한 가정의 변경으로 인해 패키징 도구의 동작에 변화가 있을 수 있음을 보여주는 것입니다.</p>
<p>최근 승인된 PEP 751은 미래에 <code>pip freeze</code> 출력 및 다른 도구와 같은 대안을 대체할 새로운 파일 형식을 정의한다는 점에 주목할 가치가 있습니다. 새 파일 형식은 파일 내 패키지가 의존성을 해결하지 않고 설치되도록 설계되었으며, 이는 이 PEP에 명시된 <code>default extras</code>와 완전히 호환되며, 위에서 언급된 <code>pip freeze</code> / <code>pip install -r</code> 문제를 피할 것입니다.</p>
<h3>보안 영향 (Security Implications)</h3>
<p>이 PEP에 대한 알려진 보안 영향은 없습니다.</p>
<h3>교육 방법 (How to teach this)</h3>
<p>이 섹션에서는 이 PEP의 구현과 관련하여 커뮤니티의 다양한 그룹에 제공되어야 할 정보를 설명합니다. 아래 설명된 일부 측면은 PEP가 패키징 도구에 완전히 구현되기 전에도 관련성이 있을 것이며, 이는 향후 잠재적인 전환을 용이하게 하기 위해 미리 할 수 있는 준비가 있기 때문입니다. 아래에 다루는 그룹은 다음과 같습니다.</p>
<ul>
<li>패키지 최종 사용자 (Package end users)</li>
<li>패키지 작성자 (Package authors)</li>
<li>패키징 저장소 관리자 (Packaging repository maintainers)</li>
</ul>
<h4>패키지 최종 사용자 (Package end users)</h4>
<p>패키지 사용자에게는 패키지에 어떤 <code>extras</code>를 사용할 수 있고 어떻게 동작하는지 보여주는 명확한 설치 지침이 제공되어야 합니다. 예를 들어, 기본적으로 일부 권장되는 의존성 또는 주어진 프론트엔드나 백엔드가 설치되며, 사용 가능한 옵션에 따라 이를 어떻게 제외하거나 기본값을 재정의하는지 설명해야 합니다.</p>
<h4>패키지 작성자 (Package authors)</h4>
<p><code>extras</code>를 정의하는 메커니즘과 이를 사용해야 하는 관련 규칙은 명확하지만, 패키지 작성자는 역호환성을 의도치 않게 깨뜨리지 않기 위해 이 기능을 자신의 패키지에 적용하기 전에 여러 가지 사항을 신중하게 고려해야 합니다.</p>
<h5>이전 버전의 패키지 설치 도구 지원 (Supporting older versions of package installers)</h5>
<p><code>pip</code> 또는 <code>uv</code>와 같은 패키지 설치 도구는 <code>default extras</code>에 대한 지원을 동시에 구현하지 않을 수 있으며, 일단 구현되면 패키지 작성자는 최신 버전의 패키지 설치 도구를 사용하지 않는 사용자를 계속 지원하기를 원할 가능성이 높습니다. 이 경우 다음 권장 사항이 적용됩니다.</p>
<ul>
<li>패키지를 필수 의존성에서 기본 <code>extra</code>로 이동하는 것은 호환성을 깨는 변경(breaking change)이 될 것입니다. 왜냐하면 이전 버전의 패키지 설치 도구는 <code>default extras</code> 개념을 인식하지 못하고, 더 적은 의존성으로 패키지를 설치하게 되어, 해당 의존성에 의존했을 사용자에게 영향을 미칠 수 있기 때문입니다. 따라서, 이미 자리 잡은 패키지에서 의존성을 필수에서 기본 <code>extra</code>로 변경하는 것은 개발자가 이 PEP를 구현하는 설치 도구를 사용하는 사용자만을 지원하려는 경우에만 미래에 이루어져야 합니다.</li>
<li>기존 <code>extra</code>를 기본값으로 만드는 것은 더 안전할 것입니다. 예를 들어 <code>astropy</code>의 <code>recommended</code>를 기본 <code>extra</code>로 만드는 것과 같습니다. 그러나 이전 버전의 패키지 설치 도구를 사용하는 사용자를 지원하기 위해서는, 가능한 한 오랫동안 (대부분의/모든 사용자가 이 PEP를 구현하는 패키지 설치 도구를 사용하고 있다는 것이 명확해질 때까지) 문서에 <code>extra</code>를 명시적으로 언급해야 합니다. <code>extra</code>를 명시적으로 언급하는 것을 유지하는 데에는 단점이 없지만, 이는 문서를 읽지 않는 (상당한 비중을 차지할 수 있는) 최신 도구를 사용하는 사용자들이 기본적으로 권장 의존성을 얻기 시작하도록 보장할 것입니다.</li>
<li>이 PEP 이전에는 <code>package[]</code>가 <code>package</code>와 동일했기 때문에, 작성자는 <code>package[]</code>를 최소 설치를 얻는 하위 호환 가능한 보편적인 방법으로 문서화할 수 있습니다. <code>default extras</code>를 정의하는 패키지의 경우, <code>package[]</code>를 설치하면 <code>pip</code>와 같은 이전 버전의 패키징 도구를 사용하더라도 항상 최소 설치를 제공할 것입니다. 또한 특정 패키지에 <code>default extras</code>가 도입되기 전의 패키지 릴리스도 <code>package[]</code>로 설치할 수 있습니다 (이 경우 <code>package</code>와 동일합니다). <code>default extras</code>를 정의하지 않는 패키지의 경우, <code>package[]</code>는 계속해서 <code>package</code>와 동일할 것입니다.</li>
</ul>
<h5>많은 기본 의존성 추가 피하기 (Avoiding the addition of many default dependencies)</h5>
<p>작성자는 이러한 의존성을 제외할 수 있는 방법을 제공할 수 있기 때문에 많은 의존성을 기본적으로 포함하려는 유혹을 느낄 수 있습니다. 그러나 작성자는 불필요하게 설치를 부풀리고 의존성 트리를 복잡하게 만들지 않도록 기본적으로 포함되는 내용을 신중하게 고려할 것을 권장합니다. <code>default extras</code>를 사용한다고 해서 모든 <code>extras</code>가 기본값이어야 하는 것은 아니며, 사용자가 비기본 <code>extras</code>를 명시적으로 옵트인할 여지는 여전히 있습니다.</p>
<p><code>Default extras</code>는 일반적으로 필수 의존성과 동일한 "무게"로 취급되어야 합니다. 패키지가 널리 사용될 때, <code>default extra</code>를 도입하면 해당 <code>extra</code>의 의존성이 전이적으로(transitively) 포함됩니다. 이는 모든 다운스트림 패키지가 최소 설치 명세를 사용하여 명시적으로 옵트아웃하도록 업데이트되지 않는 한 그렇습니다.</p>
<p>예를 들어, <code>pytest</code> 패키지는 현재 약 1,500개의 플러그인이 의존하고 있습니다. 만약 <code>pytest</code>가 <code>default extra</code>를 추가하고 해당 플러그인들이 그에 따라 업데이트되지 않으면, 플러그인을 설치할 때 <code>default extras</code>의 의존성이 포함될 것입니다. 이것이 <code>default extras</code> 사용을 배제하는 것은 아니지만, <code>default extras</code>의 추가는 다운스트림 영향에 대한 신중한 평가를 필요로 합니다.</p>
<h5>기본 <code>extras</code> 상속 (Inheriting from default extras)</h5>
<p>패키지 작성자가 <code>extra</code>를 기본적으로 설치되도록 선택하는 경우, 사용자가 다른 <code>extra</code>를 명시적으로 지정하면 "기본 <code>extras</code>를 제거하지 않는 <code>extras</code> 지원"에서 설명된 접근 방식을 사용하지 않는 한 기본 <code>extra</code>가 설치되지 않을 수 있음을 인식하는 것이 중요합니다.</p>
<p>서로 교환 가능한 백엔드와 같은 경우에는 <code>extra</code>가 명시적으로 지정되면 기본값을 무시하는 것이 올바른 일입니다. 그러나 다른 경우에는, 최소 설치를 허용하면서 권장 의존성을 포함하기 위해 <code>default extras</code>를 사용하는 것과 같이, 다른 많은 <code>extras</code>가 기본 <code>extras</code>를 명시적으로 '상속'해야 할 수 있으므로, 패키지 작성자는 어떤 경우에 <code>default extras</code>가 설치되기를 원하는지 신중하게 고려해야 합니다.</p>
<h5>호환되지 않는 <code>extras</code> (Incompatible extras)</h5>
<p>어떤 경우에는 패키지에 상호 호환되지 않는 <code>extras</code>가 있을 수 있습니다. 이 경우, 다른 <code>extra</code>와 호환되지 않을 수 있는 의존성을 포함하는 <code>extra</code>에 대해 <code>default extra</code> 기능을 사용하지 않는 것을 권장합니다.</p>
<p><code>package[A]</code>와 <code>package[B]</code> <code>extras</code>를 가진 패키지를 고려해봅시다. 사용자는 이미 현재 <code>package[A]</code>와 <code>package[B]</code> 또는 <code>package[A,B]</code>를 설치하려고 시도할 수 있으며, 이는 설치 오류를 초래할 수 있지만, 적어도 두 <code>extras</code>가 모두 설치되고 있다는 것이 명확할 것입니다. 그러나 <code>A</code>를 기본 <code>extra</code>로 만들면 직관적이지 않은 문제가 발생할 수 있습니다. 사용자는 다음을 실행할 수 있습니다.</p>
<pre><code class="language-bash">$ pip install package # 이것은 package[A]를 설치합니다
$ pip install package[B]
</code></pre>
<p>그리고 <code>A</code>와 <code>B</code>가 명시적으로 동시에 설치된 적이 없더라도 설치 오류로 끝날 수 있습니다. 이러한 이유로, 문제가 발생할 가능성이 있는 의존성에 대해 <code>default extras</code>를 사용하지 않는 것을 권장합니다.</p>
<h5>순환 의존성 (Circular dependencies)</h5>
<p>작성자는 순환 의존성이 존재할 때 특별한 주의를 기울여야 합니다. 예를 들어, 다음 의존성 트리를 고려해봅시다.</p>
<pre><code>package1
└── package2
    └── package1
</code></pre>
<p>만약 <code>package1</code>에 <code>recommended</code>라는 기본 <code>extra</code>가 있다면:</p>
<pre><code class="language-bash">$ pip install package1[]
</code></pre>
<p><code>package2</code>가 계속해서 <code>package1</code>에 의존하는 경우 (지정된 <code>extras</code> 없이) <code>recommended</code> <code>extra</code>가 여전히 설치될 것입니다. 이는 의존성 트리를 다음으로 변경함으로써 해결될 수 있습니다.</p>
<pre><code>package1
└── package2
    └── package1[]
</code></pre>
<p>(단, <code>package2</code>가 <code>package1</code>의 <code>extra</code> 의존성에 의해 제공되는 기능에 실제로 의존하지 않는다고 가정합니다). 따라서 작성자는 <code>package2</code>의 작성자와 조율하여 마이그레이션 계획을 신중하게 고려해야 합니다.</p>
<h5><code>default extras</code>를 가진 패키지 문서화 (Documenting packages with default extras)</h5>
<p><code>default extras</code>가 어떻게 사용되든 관계없이, 패키지 작성자는 패키지 문서가 <code>extras</code>를 어떻게 사용해야 하는지 명확하게 설명하도록 해야 합니다. '모범 사례' 문서에는 다음이 언급되어야 합니다.</p>
<ul>
<li><code>package</code>를 설치하는 것은 <code>package[&#x3C;default extras>]</code>와 동일할 것입니다.</li>
<li><code>package[]</code>를 설치하는 것은 최소/필수 의존성만 포함할 것이지만, <code>package</code>가 의존성 트리의 다른 곳에 나타나는 경우 선택적 의존성이 설치되지 않음을 보장하지는 않습니다.</li>
<li>사용 가능한 다른 선택적 <code>extras</code>가 무엇이며, 이들이 기본 <code>extras</code>를 비활성화하는지 여부 (이는 "기본 <code>extras</code>를 제거하지 않는 <code>extras</code> 지원"에서 설명된 대로 제어될 수 있음).</li>
<li>예를 들어 기본 백엔드와 프론트엔드를 가질 수 있는 패키지에 대한 특정 지침 (이는 "여러 종류의 기본값을 가진 패키지"에서 설명된 대로).</li>
</ul>
<h4>패키징 저장소 관리자 (Packaging repository maintainers)</h4>
<p><code>conda</code>, <code>Homebrew</code>, <code>apt</code>, <code>yum</code>과 같은 Linux 패키지 설치 도구 등 다양한 배포판을 위해 Python 라이브러리를 재패키징하는 개인에게 미치는 영향을 고려해야 합니다. 모든 패키지 배포판이 설명된 접근 방식과 일치하는 메커니즘을 가지고 있는 것은 아닙니다. 사실, <code>conda</code>와 같은 일부 배포판은 <code>extras</code> 개념조차 없습니다.</p>
<p>여기서 고려해야 할 두 가지 경우가 있습니다.</p>
<ul>
<li><code>conda-forge</code> 레시피의 일부와 같이 수동으로 재패키징하는 경우, 특히 <code>extras</code>에 해당하는 것이 없는 경우, <code>default extras</code>의 도입은 큰 영향을 미치지 않을 것입니다. 왜냐하면 어떤 의존성을 포함할지 이미 수동으로 결정해야 하기 때문입니다 (예를 들어, "동기" 섹션에서 언급된 <code>astropy</code> 패키지의 <code>conda-forge</code> 레시피는 사용자가 달리 명시적으로 요청할 방법이 없기 때문에 모든 권장 의존성을 기본적으로 포함합니다).</li>
<li>자동화된 방식으로 재패키징하는 경우, 배포판 관리자는 <code>default extras</code>를 어떻게 처리할지 신중하게 고려해야 하며, 이는 상당한 양의 작업과 논의를 의미할 수 있습니다.</li>
</ul>
<p>이와 같은 PEP가 다양한 패키지 배포판 각각을 상세히 고려하는 것은 불가능합니다. 그러나 궁극적으로 <code>default extras</code>는 패키지 작성자가 대부분의 사용자를 위해 자신의 패키지가 어떻게 설치되기를 원하는지를 나타내는 것으로 이해되어야 하며, 이는 <code>default extras</code>를 수동으로 또는 자동으로 처리하는 방법에 대한 결정에 정보를 제공해야 합니다.</p>
<h3>참조 구현 (Reference Implementation)</h3>
<p>다음 저장소에는 <code>default extras</code>를 사용하는 완전히 작동하는 데모 패키지가 포함되어 있습니다.</p>
<ul>
<li><a href="https://github.com/wheel-next/pep_771">https://github.com/wheel-next/pep_771</a></li>
</ul>
<p>이는 여러 패키지의 수정된 브랜치를 사용하며, 다음 링크는 해당 브랜치입니다.</p>
<ul>
<li><a href="https://github.com/pypa/setuptools/tree/pep771">Setuptools</a></li>
<li><a href="https://github.com/pypa/pip/tree/pep771">pip</a></li>
<li><a href="https://github.com/python/importlib_metadata/tree/pep771">importlib_metadata</a></li>
</ul>
<p>또한, 이 브랜치에는 수정된 <code>Flit</code> 패키지 버전이 포함되어 있습니다.</p>
<p>위 구현은 현재 개념 증명(proof-of-concept)이며, 기존 변경 사항은 아직 관련 관리자들의 검토를 거치지 않았습니다. 그럼에도 불구하고, 관심 있는 관리자들이 시도해 볼 수 있을 만큼 충분히 기능적입니다.</p>
<h3>거부된 아이디어 (Rejected Ideas)</h3>
<h4>권장 설치를 위한 메타 패키지 사용 (Using a meta-package for recommended installations)</h4>
<p>기존 패키징 도구 및 인프라를 사용하여, 일부 사용자에게는 최소 설치를 제공하고 일반 사용자에게는 기본 비최소 설치(예: 권장 의존성 또는 기본 백엔드 포함)를 제공하려는 패키지 관리자는 기술적으로 이미 이를 달성할 수 있습니다. 이는 하나의 패키지 대신 두 개의 패키지를 배포할 의향이 있다면 가능합니다. 예를 들어, 최소 의존성을 가진 주 패키지인 <code>package-core</code>와, 선택적 의존성이 활성화된 <code>package-core</code>에 의존하는 메타 패키지 <code>package</code>입니다.</p>
<p>"동기" 섹션의 구체적인 예시를 다시 들어보면, <code>astropy</code> 패키지는 <code>recommended</code> <code>extra</code>를 정의하며, 사용자는 현재 기본 설치 지침에서 이를 설치하도록 안내받습니다. 원칙적으로 기존 <code>astropy</code> 패키지를 <code>astropy-core</code> 등으로 이름을 바꾸고, 새로운 <code>astropy</code> 패키지를 생성하여 다음 의존성 섹션을 포함하는 메타 패키지로 만들 수 있습니다.</p>
<pre><code class="language-toml">dependencies = [ "astropy-core[recommended]" ]
</code></pre>
<p>사용자가 <code>astropy</code> 메타 패키지에 버전 제약을 걸거나 고정(pin)하기를 원할 수 있으므로 (예: <code>astropy>5.0</code>), 메타 패키지는 코어 패키지와 동일한 버전을 따라야 하며, 의존성 섹션에서 엄격한 고정(strict pinning)을 사용해야 합니다. 예를 들어:</p>
<pre><code class="language-toml">version = "7.1.0"
dependencies = [ "astropy-core[recommended]==7.1.0" ]
</code></pre>
<p>이 아이디어는 기술적으로 이미 실현 가능하기 때문에 매력적으로 보일 수 있습니다. 그러나 실제로는 많은 프로젝트가 여러 가지 이유로 이를 선택하지 않았으며, 이제 이를 살펴보겠습니다. 이 중 일부는 미래의 새로운 프로젝트에는 적용되지 않을 수 있지만, 일부는 모든 프로젝트(오래된 프로젝트와 새로운 프로젝트 모두)에 적용됩니다.</p>
<h5>패키지 이름과 모듈 이름 불일치 (Mismatch between package and module name)</h5>
<p>메타 패키지 접근 방식을 사용하려는 패키지의 경우, 이름 지정과 관련하여 두 가지 주요 옵션이 있습니다.</p>
<ol>
<li>
<p><strong>첫 번째 옵션</strong> 은 기존 패키지를 그대로 유지하는 것입니다. 즉, <code>package</code>가 최소 설치를 제공하고, <code>package-all</code>과 같은 다른 이름으로 새 메타 패키지를 만드는 것입니다. 그러나 이는 이 PEP를 처음 동기 부여했던 문제 중 하나인 "사용자들이 종종 <code>package[recommended]</code>와 같은 것을 할 수 있다는 것을 알지 못한다"는 문제와 동일하게, <code>package-all</code>이 존재한다는 것을 깨닫지 못할 수 있다는 점에서 고통받습니다. 이는 다시 한번 일반 사용자에게 이를 발견해야 하는 부담을 지우며, 일부 부담을 고급 사용자에게로 옮기지 못합니다.</p>
</li>
<li>
<p><strong>두 번째 옵션</strong> 은 기존 패키지의 이름을 <code>package-core</code> 등으로 변경하고, 새 메타 패키지의 이름을 <code>package</code>로 하는 것입니다. 이는 첫 번째 옵션보다 낫지만, <code>package-core</code>가 <code>package</code> 모듈을 제공하고 <code>package</code>는 어떤 모듈도 제공하지 않는다는 점에서 패키지 이름과 모듈 이름 사이에 직관적이지 않은 불일치를 초래하므로 이상적이지 않습니다. 이것이 혼란을 야기하는 이유의 예시는 일반 사용자가 <code>package</code> 모듈을 제거하는 것이 예를 들어 다음과 같이 수행될 것이라고 생각할 수 있다는 것입니다.</p>
<pre><code class="language-bash">$ pip uninstall package
</code></pre>
<p>그러나 이것은 사실이 아닐 것이며 (<code>package</code> 모듈은 여전히 작동할 것입니다), 이 사용자는 <code>package-core</code> 패키지가 존재한다는 사실조차 명확하게 알지 못할 수 있습니다.</p>
</li>
</ol>
<h5>다중 저장소 또는 모노레포 (Multiple repositories or monorepos)</h5>
<p>이 접근 방식은 하나 대신 두 개의 저장소를 유지하거나, 두 패키지를 모두 포함하는 모노레포(monorepo)를 사용하는 것을 필요로 합니다. 두 옵션 모두 이상적이지 않습니다.</p>
<ul>
<li><strong>두 개의 저장소로 분할</strong> 하는 것은 관리자에게 장기적으로 추가적인 부담을 지웁니다. 관리자는 버전뿐만 아니라 <code>extras</code>와 같은 다른 측면에서도 이들이 동기화되도록 확인해야 합니다 (메타데이터 동기화에서 논의될 예정). 또한 "패키지 이름과 모듈 이름 불일치"에서 언급된 이름 지정 문제는 여기에서 추가적인 복잡성을 가집니다. 저장소 이름이 패키지와 일치하는 경우, 이전 패키지 저장소의 체크아웃을 가진 모든 사용자는 원격 URL 또는 <code>git clone</code> URL을 <code>package-core</code> 저장소를 가리키도록 업데이트해야 합니다. 대안은 <code>package-core</code> 패키지를 포함하도록 패키지 저장소를 보존하고, 메타 패키지에 다른 이름을 가지도록 하는 것이지만, 이는 혼란을 야기할 수 있습니다.</li>
<li><strong>모노레포로 전환</strong> 하는 것은 일부 프로젝트에게는 상당한 변화일 수 있으며, 도구들이 기본적으로 단일 저장소가 단일 패키지에 해당한다고 가정하는 것은 드문 일이 아닙니다. 비록 이러한 도구들이 모노레포와 작동하도록 구성될 수 있지만, 이는 관리자에게 추가적인 부담입니다. 또한, 주 패키지가 모노레포 내의 하위 디렉토리로 이동되는 경우, 예를 들어 저장소 URL에서 패키지를 <code>pip install</code>하는 모든 사용자는 이를 하위 디렉토리에서 설치하도록 조정해야 하며 (저장소 URL에 <code>subdirectory=</code> 추가), 이전 레이아웃을 가정하는 기존 워크플로우는 작동하지 않게 됩니다.</li>
</ul>
<h5>최소 패키지에 의존 (Depending on the minimal package)</h5>
<p>분할이 이루어진 첫 번째 버전보다 오래된 패키지 버전에 의존해야 하는 패키지는 최소 패키지에 쉽게 의존할 수 없을 것입니다. 이 PEP의 주요 제안에서는 다운스트림 사용자가 예를 들어 <code>package[]>version</code>에 의존할 수 있지만 (여기서 <code>version</code>은 <code>default extras</code> 도입 이전의 버전), 분할 접근 방식으로는 다운스트림 사용자가 예를 들어 <code>package-core>version</code>에 의존할 수 없을 것입니다. 왜냐하면 <code>package-core</code>는 이전에 존재하지 않았기 때문입니다.</p>
<p>이에 대한 가능한 해결책은 개발자가 패키지의 모든 이전 버전에 대해 no-op 메타데이터 패키지를 출시하는 것이지만, 이는 관리자에게 상당한 추가 부담입니다.</p>
<h5>제거 (Uninstallation)</h5>
<p>"패키지 이름과 모듈 이름 불일치"에서 이름 지정 문제를 언급할 때 암시했듯이, 패키지 제거는 사용자가 예상하는 방식으로 더 이상 작동하지 않을 것입니다. 사용자가 다음을 실행하면:</p>
<pre><code class="language-bash">$ pip uninstall package
</code></pre>
<p><code>package-core</code>가 여전히 남아 있겠지만, 사용자는 이를 깨닫지 못할 수 있습니다. 이는 혼란스러울 뿐만 아니라, 실제로는 많은 기존 워크플로우에 영향을 미칠 수 있는 호환성을 깨는 변경(breaking change)입니다.</p>
<h5>패키지 배포판 (Package distributions)</h5>
<p>하나 대신 두 개의 패키지를 가지는 것은 단순히 하나 대신 두 개의 패키지가 릴리스되어야 한다는 사실 때문에 패키지 배포판의 장기 유지보수 비용을 증가시킬 것이며, 어떤 경우에는 각 릴리스마다 추가적인 수작업을 초래할 것입니다.</p>
<h5>메타데이터 동기화 (Synchronizing metadata)</h5>
<p>주요 패키지와 메타 패키지 간에 동기화 상태를 유지하는 것이 중요한 주요 메타데이터는 버전입니다. 코어 패키지의 새 릴리스가 있을 때마다 메타 패키지는 버전이 업데이트되어야 하며, 의존성 섹션의 코어 패키지에 대한 버전 고정(version pinning)도 업데이트되어야 합니다.</p>
<p>또한, 코어 패키지에 정의된 모든 <code>extras</code>는 메타 패키지에서 재정의되고 동기화 상태를 유지해야 합니다. 예를 들어, <code>package</code>가 <code>additional</code> <code>extra</code>를 정의하는 경우, 사용자는 여전히 <code>package[additional]</code>를 설치할 수 있어야 하지만, <code>package-core</code> 패키지를 설치하는 사용자도 <code>package-core[additional]</code>를 수행할 수 있는 옵션이 있어야 합니다.</p>
<p>동기화해야 할 다른 메타데이터에는 예를 들어 작성자 정보 및 프로젝트 URL이 포함됩니다.</p>
<h5>요약 (Summary)</h5>
<p>전반적으로, 이 해결책은 초기 설정 및 전환(이는 이미 대규모 기존 프로젝트에는 엄청난 부담이 될 수 있음)뿐만 아니라 장기 유지보수 측면에서도 상당히 높은 유지보수 부담을 의미할 것입니다. 이는 또한 사용자 워크플로우를 깨뜨릴 가능성도 있습니다 (특히 저장소 문제 및 제거와 관련하여). 이러한 모든 이유로, 이 PEP의 현재 제안에 대한 설득력 있는 대안으로 간주하지 않습니다.</p>
<h4><code>extras</code> 선택 해제를 위한 구문 (Syntax for deselecting extras)</h4>
<p>주요 경쟁 접근 방식 중 하나는 다음과 같았습니다. 어떤 <code>extras</code>라도 명시적으로 제공되면 기본값이 선택 해제되는 대신, 기본 <code>extras</code>는 명시적으로 선택 해제되어야 한다는 것입니다.</p>
<p>이 그림에서 <code>extras</code> 선택 해제를 위한 새로운 구문이 PEP 508에 정의된 미니 언어의 확장으로 도입될 것입니다. 패키지가 <code>default extras</code>를 정의하는 경우, 사용자는 <code>extra</code> 이름 앞에 마이너스 부호(<code>-</code>)를 사용하여 이러한 기본값에서 옵트아웃할 수 있습니다. 제안된 구문 업데이트는 다음과 같았을 것입니다.</p>
<pre><code>extras_list = (-)?identifier (wsp* ',' wsp* (-)?identifier)*
</code></pre>
<p>이 새로운 구문의 유효한 예시는 다음과 같습니다.</p>
<pre><code>package[-recommended]
package[-backend1, backend2]
package[pdf, -svg]
</code></pre>
<p>그러나 이 접근 방식에는 두 가지 주요 문제가 있습니다.</p>
<ol>
<li><code>extra</code>와 그 부정된 버전이 동일한 의존성 명세에 모두 존재하는 경우 (예: <code>package[pdf, -pdf]</code>) 또는 의존성 트리에 <code>package[pdf]</code>와 <code>package[-pdf]</code>가 모두 포함된 경우와 같은 모서리 사례를 해석하는 방법에 대한 여러 규칙을 정의해야 하며, 이러한 규칙은 사용자에게 직관적이지 않을 것입니다.</li>
<li>더 중요하게는, 이는 의존성 명세에 새로운 구문을 도입할 것입니다. 이는 어떤 패키지가 새 구문을 사용하여 의존성을 정의하면, 해당 패키지와 이에 의존하는 다른 모든 패키지가 기존 패키징 도구로 더 이상 설치될 수 없게 되어, 주요 하위 호환성 문제가 될 것임을 의미합니다.</li>
</ol>
<p>이러한 이유로 이 대안은 최종 제안에 포함되지 않았습니다.</p>
<h4><code>extras_require</code>에 특별 항목 추가 (Adding a special entry in extras_require)</h4>
<p>새로운 <code>Default-Extra</code> 메타데이터 필드를 도입하는 대안으로 탐색된 잠재적인 해결책은 '특별한' 이름을 가진 <code>extra</code>를 활용하는 것이었습니다.</p>
<p>한 가지 예시는 빈 문자열을 사용하는 것이었습니다.</p>
<pre><code>Provides-Extra:
Requires-Dist: numpy ; extra == ''
</code></pre>
<p>이 아이디어는 '빈' <code>extras</code>의 일부로 설치되는 의존성이 다른 <code>extra</code>가 지정되지 않은 경우에만 설치된다는 것이었습니다. 이에 대한 구현이 <a href="https://github.com/pypa/setuptools/pull/1503">https://github.com/pypa/setuptools/pull/1503</a>에서 제안되었지만, 기존 사용과의 호환성을 깨뜨리지 않고는 작동시킬 방법이 없다는 것이 밝혀졌습니다. 예를 들어, <code>setup.py</code> 파일을 통해 <code>Setuptools</code>를 사용하는 패키지는 다음을 수행할 수 있습니다.</p>
<pre><code class="language-python">setup(
    ...
    extras_require={'': ['package_a']},
)
</code></pre>
<p>이는 유효하며 <code>package_a</code>가 <code>install_requires</code>에 정의된 것과 동일하므로, 빈 문자열의 의미를 변경하면 호환성이 깨집니다.</p>
<p>또한, 다른 어떤 문자열(예: <code>'default'</code>)도 특별한 문자열로 사용될 수 없습니다. 왜냐하면 하위 호환 가능한 유효한 <code>extra</code> 이름이 될 모든 문자열은 이미 기존 패키지에서 사용되고 있을 수 있기 때문입니다.</p>
<p>특별한 <code>None</code> Python 변수를 사용하는 제안도 있었지만, 다시 말하지만 이는 불가능합니다. <code>setup.py</code> 파일에서는 <code>None</code>을 사용할 수 있지만, <code>setup.cfg</code>나 <code>pyproject.toml</code>과 같은 선언형 파일에서는 불가능하며, 더 나아가 <code>extras</code> 이름은 궁극적으로 패키지 메타데이터에서 문자열로 변환되어야 합니다. 다음이 있는 경우:</p>
<pre><code>Provides-Extra: None
</code></pre>
<p>이는 이미 Python 패키지에서 <code>extra</code> 이름으로 사용될 수 있는 문자열 <code>'None'</code>과 구별할 수 없을 것입니다. 만약 문자열이 아닌 '특별한' <code>extras</code> 이름을 허용하도록 코어 메타데이터 구문을 수정한다면, 코어 메타데이터 명세를 수정하는 것으로 돌아가는 것이므로, <code>Default-Extra</code>를 도입하는 것보다 나을 것이 없습니다.</p>
<h4>도구에 의존하여 기본 <code>extras</code> 선택 해제 (Relying on tooling to deselect any default extras)</h4>
<p><code>extras</code>를 선택 해제하는 또 다른 옵션은 패키징 도구 수준에서 이를 구현하는 것이었습니다. 예를 들어, <code>pip</code>는 다음과 같은 옵션을 포함할 수 있습니다.</p>
<pre><code class="language-bash">$ pip install package --no-default-extras
</code></pre>
<p>이 옵션은 <code>--no-binary</code> 옵션과 유사하게 모든 패키지 또는 특정 패키지에 적용될 수 있습니다. 예를 들어:</p>
<pre><code class="language-bash">$ pip install package --no-default-extras :all:
</code></pre>
<p>이 접근 방식의 장점은 <code>default extras</code>를 지원하는 도구가 <code>extras</code>를 선택 해제하는 것도 지원할 수 있다는 것입니다. 이 접근 방식은 <code>apt</code> 도구의 <code>--no-install-recommends</code> 옵션과 유사할 것입니다.</p>
<p>그러나 이 해결책은 그 자체로 이상적이지 않습니다. 왜냐하면 패키지가 자체적으로 특정 의존성의 <code>default extras</code>가 필요하지 않다고 지정하는 것을 허용하지 않기 때문입니다. 또한 대규모 의존성 트리에서 모든 <code>default extras</code>를 비활성화할 수 있는 사용자에게 위험을 초래하여, 트리 내의 어느 지점에서든 <code>default extras</code>에 의존하는 패키지를 손상시킬 수 있습니다.</p>
<p>그럼에도 불구하고, 이 PEP는 이 접근 방식을 금지하지 않으며, 이러한 종류의 옵션을 지원할지 여부는 다양한 패키징 도구의 관리자에게 달려 있습니다. 이는 최소한 의존성 트리에서 <code>default extras</code>가 의존하는 지점을 식별하려는 패키지 관리자에게 유용할 수 있는 플래그입니다. 그러나 지원되는 경우, 이 플래그를 사용하는 것이 기능적인 환경을 보장하지 않는다는 점을 명확히 해야 합니다.</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 라이선스 하에 배포됩니다.</p>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/770/">[Accepted] PEP 770 - Improving measurability of Python packages with Software Bill-of-Materials</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Draft] PEP 771 - Default Extras for Python Software Packages</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/772/">[Draft] PEP 772 - Packaging Council governance process</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/edf391eeca43d999.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-ad5f81b531af48c1.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/771\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/edf391eeca43d999.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"ogGio3genoY6eym-8SYbg\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/771/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/771\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"771\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/771\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:Te633,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0771/\"\u003ePEP 771 - Default Extras for Python Software Packages\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Draft | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 13-Jan-2025\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 771 – Python 소프트웨어 패키지를 위한 기본 Extras\u003c/h2\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003ePEP 508은 패키지 의존성을 선언하기 위한 미니 언어(mini-language)를 정의합니다. 이 언어의 한 가지 특징은 \u003ccode\u003eextras\u003c/code\u003e를 지정할 수 있다는 것입니다. \u003ccode\u003eextras\u003c/code\u003e는 배포판의 선택적 구성 요소로, 사용될 경우 추가 의존성을 설치합니다. 이 PEP는 명시적으로 제공되지 않을 경우 하나 이상의 \u003ccode\u003eextras\u003c/code\u003e가 기본적으로 설치되도록 하는 메커니즘을 제안합니다.\u003c/p\u003e\n\u003ch3\u003e동기 (Motivation)\u003c/h3\u003e\n\u003cp\u003e기본 \u003ccode\u003eextras\u003c/code\u003e에 대한 다양한 사용 사례와 이 PEP에서 가능한 해결책들은 DPO 스레드에서 광범위하게 논의되었습니다. 이는 크게 두 가지 경우로 나뉘며, 본 PEP의 동기가 됩니다.\u003c/p\u003e\n\u003ch4\u003e권장되지만 필수는 아닌 의존성 (Recommended but not required dependencies)\u003c/h4\u003e\n\u003cp\u003e패키지 관리자는 종종 패키지의 기능이나 성능을 확장하는 선택적 의존성을 선언하기 위해 \u003ccode\u003eextras\u003c/code\u003e를 사용합니다. 어떤 의존성이 필수이고 어떤 의존성이 \u003ccode\u003eextras\u003c/code\u003e로 분류되어야 하는지 결정하기 어려울 때가 있습니다. 대부분의 기능이 기본적으로 제공되기를 선호하는 일반 사용자들의 요구와, 크고 선택적인 의존성 없이 최소한의 설치를 원하는 사용자들의 요구 사이에서 균형을 찾아야 합니다.\u003c/p\u003e\n\u003cp\u003e기존 Python 패키징 인프라를 사용한 한 가지 해결책은 패키지 관리자가 예를 들어 \u003ccode\u003erecommended\u003c/code\u003e라는 \u003ccode\u003eextra\u003c/code\u003e를 정의하여 모든 필수적이지 않지만 제안되는 의존성을 포함하도록 하는 것입니다. 그러면 사용자에게 \u003ccode\u003epackage[recommended]\u003c/code\u003e를 사용하여 패키지를 설치하도록 안내하고, 더 많은 제어를 원하는 사용자는 \u003ccode\u003epackage\u003c/code\u003e를 사용할 수 있습니다. 그러나 실제로는 많은 사용자가 \u003ccode\u003e[recommended]\u003c/code\u003e 구문을 알지 못하여, 일반적인 설치를 위해 이를 알아야 하는 부담을 지게 됩니다. 권장되는 의존성이 기본적으로 설치되면서도 사용자가 더 최소한의 설치를 요청할 수 있는 방법을 제공하는 것은 이러한 사용 사례를 만족시킬 것이며, 이 PEP는 이에 대한 해결책을 설명합니다.\u003c/p\u003e\n\u003cp\u003e이 패턴을 보여주는 패키지 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eastropy\u003c/code\u003e: \u003ccode\u003eastropy[recommended]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esunpy\u003c/code\u003e: \u003ccode\u003esunpy[all]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efastapi\u003c/code\u003e: \u003ccode\u003efastapi[standard]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e여러 백엔드 또는 프론트엔드를 지원하는 패키지 (Packages supporting multiple backends or frontends)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eextras\u003c/code\u003e를 사용하는 또 다른 일반적인 사용 사례는 다양한 백엔드 또는 프론트엔드와 각 백엔드/프론트엔드에 필요한 의존성을 정의하는 것입니다. 패키지는 기능하기 위해 최소한 하나의 백엔드나 프론트엔드가 설치되어야 하지만, 어떤 백엔드/프론트엔드가 설치될지에 대해서는 유연할 수 있습니다. 구체적인 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyQt5\u003c/code\u003e, \u003ccode\u003ePyQt6\u003c/code\u003e, \u003ccode\u003ePySide2\u003c/code\u003e, 또는 \u003ccode\u003ePySide6\u003c/code\u003e로 제공될 수 있는 Qt 프론트엔드 라이브러리.\u003c/li\u003e\n\u003cli\u003eMySQL, PostgreSQL, SQLite와 같은 백엔드 데이터베이스.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e현재 패키징 표준에서는, 관리자가 백엔드나 프론트엔드 중 하나를 필수로 지정하거나, 사용자에게 항상 \u003ccode\u003epackage[backend]\u003c/code\u003e와 같이 \u003ccode\u003eextras\u003c/code\u003e를 명시하도록 요구해야 합니다. 이로 인해 사용자가 단순히 \u003ccode\u003epackage\u003c/code\u003e만 설치할 경우 사용할 수 없는 설치가 될 위험이 있습니다. 하나 이상의 기본 백엔드나 프론트엔드를 지정하고 이러한 기본값을 재정의할 수 있는 방법을 제공하는 것은 사용자에게 훨씬 더 나은 경험을 제공할 것이며, 이 PEP에 설명된 접근 방식은 이를 가능하게 할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 패키지가 정확히 하나의 프론트엔드나 백엔드 패키지를 요구하는 경우와 같이, 충돌하거나 호환되지 않는 \u003ccode\u003eextras\u003c/code\u003e를 허용하지 않는 문제를 해결하는 것을 목표로 하지 않습니다. 현재 Python 패키징 인프라에는 충돌하거나 호환되지 않는 \u003ccode\u003eextras\u003c/code\u003e의 설치를 금지하는 메커니즘이 없으며, 이 PEP는 이를 변경하지 않습니다.\u003c/p\u003e\n\u003cp\u003e작동을 위해 최소한 하나의 백엔드 또는 프론트엔드를 요구하고 기본 \u003ccode\u003eextra\u003c/code\u003e를 권장하는 패키지 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ekivy\u003c/code\u003e: \u003ccode\u003ekivy[base]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enapari\u003c/code\u003e: \u003ccode\u003enapari[all]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eglueviz\u003c/code\u003e: \u003ccode\u003eglueviz[qt]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 세 가지 경우 모두에서, \u003ccode\u003eextras\u003c/code\u003e 없이 패키지를 설치하면 설치가 제대로 작동하지 않으며, 이는 이러한 패키지들의 흔히 보고되는 지원 문제입니다.\u003c/p\u003e\n\u003ch3\u003e근거 (Rationale)\u003c/h3\u003e\n\u003cp\u003e여러 해 동안 커뮤니티에서 많은 가능한 해결책들이 광범위하게 논의되었습니다. 아래에 제시된 해결책은 다음 세 가지 기준을 모두 충족하는 유일한 방안입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e옵트인(opt-in) 솔루션으로, 패키지 관리자가 사용 여부를 선택할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\"동기(Motivation)\" 섹션에서 설명된 두 가지 주요 사용 사례를 모두 수용할 수 있을 만큼 충분히 유연합니다.\u003c/li\u003e\n\u003cli\u003ePEP 508의 구문을 재사용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003ch4\u003e\u003ccode\u003eDefault-Extra\u003c/code\u003e 메타데이터 필드\u003c/h4\u003e\n\u003cp\u003e코어 패키지 메타데이터에 새로운 다중 사용(multiple-use) 메타데이터 필드인 \u003ccode\u003eDefault-Extra\u003c/code\u003e가 추가됩니다. 이 필드의 각 항목은 패키지가 명시적으로 \u003ccode\u003eextras\u003c/code\u003e 없이 설치될 때 자동으로 포함될 \u003ccode\u003eextra\u003c/code\u003e를 지정하는 문자열이어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eProvides-Extra\u003c/code\u003e 항목에 이미 지정된 항목만 \u003ccode\u003eDefault-Extra\u003c/code\u003e 항목에 사용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDefault-Extra: recommended\r\nDefault-Extra: backend1\r\nDefault-Extra: backend2\r\nDefault-Extra: backend3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 코어 패키지 메타데이터에 새로운 필드를 도입하므로, \u003ccode\u003eMetadata-Version\u003c/code\u003e을 다음 마이너 버전 (작성 시점 2.5)으로 올려야 합니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003e[project]\u003c/code\u003e 메타데이터 테이블의 새 키\u003c/h4\u003e\n\u003cp\u003ePEP 621에서 원래 정의되었고 현재 PyPA 명세에서 정의된 \u003ccode\u003e[project]\u003c/code\u003e 메타데이터 테이블에 새로운 키가 추가됩니다. 이 키의 이름은 \u003ccode\u003edefault-optional-dependency-keys\u003c/code\u003e이며, 다음 설명을 가집니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTOML 타입: 문자열 배열 (Array of strings)\u003c/li\u003e\n\u003cli\u003e해당 코어 메타데이터 필드: \u003ccode\u003eDefault-Extra\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003edefault-optional-dependency-keys\u003c/code\u003e의 각 문자열은 \u003ccode\u003eoptional-dependencies\u003c/code\u003e에 정의된 \u003ccode\u003eextra\u003c/code\u003e의 이름이어야 하며, 이 배열의 각 \u003ccode\u003eextra\u003c/code\u003e는 코어 패키지 메타데이터의 일치하는 \u003ccode\u003eDefault-Extra\u003c/code\u003e 항목으로 변환됩니다. 이전 섹션에서 제시된 \u003ccode\u003eDefault-Extra\u003c/code\u003e 항목 예시를 생성하는 유효한 사용 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e[project]\r\ndefault-optional-dependency-keys = [\r\n    \"recommended\",\r\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e[project]\r\ndefault-optional-dependency-keys = [\r\n    \"backend1\",\r\n    \"backend2\",\r\n    \"backend3\"\r\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e기본 \u003ccode\u003eextras\u003c/code\u003e 재정의 (Overriding default extras)\u003c/h4\u003e\n\u003cp\u003e의존성 명세에서 \u003ccode\u003eextras\u003c/code\u003e가 명시적으로 주어지면, 기본 \u003ccode\u003eextras\u003c/code\u003e는 무시됩니다. 그렇지 않으면 기본 \u003ccode\u003eextras\u003c/code\u003e가 설치됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 패키지가 \u003ccode\u003eextra1\u003c/code\u003e을 기본 \u003ccode\u003eextra\u003c/code\u003e로 정의하고 \u003ccode\u003eextra2\u003c/code\u003e를 비기본 \u003ccode\u003eextra\u003c/code\u003e로 정의한 경우, 사용자가 다음과 같이 패키지를 설치하면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install package\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기본 \u003ccode\u003eextra1\u003c/code\u003e 의존성이 포함됩니다. 만약 사용자가 대신 다음과 같이 패키지를 설치하면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install package[extra2]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eextra2\u003c/code\u003e가 설치되지만, 기본 \u003ccode\u003eextra1\u003c/code\u003e은 무시됩니다.\u003c/p\u003e\n\u003cp\u003e설치 명령이나 의존성 트리에서 동일한 패키지가 여러 번 지정되는 경우, 패키지의 인스턴스 중 하나라도 \u003ccode\u003eextras\u003c/code\u003e가 지정되지 않은 경우 기본 \u003ccode\u003eextras\u003c/code\u003e가 설치되어야 합니다. 예를 들어, \u003ccode\u003epackage\u003c/code\u003e가 의존성 트리에서 여러 번 나타나는 패키지 \u003ccode\u003espam\u003c/code\u003e을 설치하는 경우:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003espam\r\n├── tomato\r\n│   ├── package[extra2]\r\n└── egg\r\n    └── package\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epackage\u003c/code\u003e가 최소한 한 번 \u003ccode\u003eextras\u003c/code\u003e가 지정되지 않은 채로 나타나므로, 기본 \u003ccode\u003eextra\u003c/code\u003e가 설치되어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epackage[]\u003c/code\u003e와 같이 비어 있는 \u003ccode\u003eextras\u003c/code\u003e 세트는 어떤 기본 \u003ccode\u003eextras\u003c/code\u003e도 설치하지 않아야 함을 의미하는 것으로 해석되어야 합니다 (단, \u003ccode\u003epackage\u003c/code\u003e가 의존성 트리의 다른 곳에 나타나는 경우는 예외이며, 이 경우 위에서 언급한 대로 기본 \u003ccode\u003eextra\u003c/code\u003e가 설치됩니다). 이것은 패키지의 최소 설치를 얻는 보편적인 방법을 제공할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epip\u003c/code\u003e와 같은 일부 도구는 현재 인식할 수 없는 \u003ccode\u003eextras\u003c/code\u003e를 무시하고 사용자에게 \u003ccode\u003eextra\u003c/code\u003e가 인식되지 않았음을 알리는 경고를 발생시킵니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install package[non-existent-extra]\r\nWARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\r\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 방식으로 동작하는 도구(오류를 발생시키는 대신)의 경우, 의존성 명세에서 \u003ccode\u003eextra\u003c/code\u003e가 유효하지 않은 것으로 인식되면 무시되어야 합니다. 그리고 지정된 모든 \u003ccode\u003eextras\u003c/code\u003e가 유효하지 않은 경우, 이는 \u003ccode\u003epackage\u003c/code\u003e가 아닌 \u003ccode\u003epackage[]\u003c/code\u003e와 동일한 것으로 간주되어야 하며, 어떤 기본 \u003ccode\u003eextras\u003c/code\u003e도 설치하지 않아야 합니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, (또한 \"Relying on tooling to deselect any default extras\" 섹션에서 논의된 바와 같이) 패키지 설치 도구는 위 동작을 제어하기 위한 자체 옵션을 구현할 수 있습니다. 예를 들어, 이러한 패키지가 의존성 트리의 어디에 나타나든 관계없이 일부 또는 모든 패키지에 대한 기본 \u003ccode\u003eextras\u003c/code\u003e를 비활성화하는 옵션을 구현할 수 있습니다. 이러한 도구별 옵션이 구현되는 경우, 도구 개발자는 이를 옵트인(opt-in) 방식으로 만들어야 하며, 사용자는 위에 명시된 PEP 771 동작을 기본으로 경험해야 합니다.\u003c/p\u003e\n\u003ch3\u003e예시 (Examples)\u003c/h3\u003e\n\u003cp\u003e이 섹션에서는 \"동기\" 섹션에서 설명된 사용 사례와, 위에 설명된 명세를 사용하여 이를 어떻게 해결할 수 있는지 살펴봅니다.\u003c/p\u003e\n\u003ch4\u003e권장되는 의존성 및 최소 설치 (Recommended dependencies and minimal installations)\u003c/h4\u003e\n\u003cp\u003e먼저, 기본적으로 권장되지만 엄격하게 필수는 아닌 의존성을 설치하고, 필요한 의존성만 설치하는 방법도 제공하려는 패키지의 경우를 고려합니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 패키지 관리자는 권장되지만 필수는 아닌 의존성을 포함하는 \u003ccode\u003erecommended\u003c/code\u003e라는 \u003ccode\u003eextra\u003c/code\u003e를 정의하고, 이를 기본 \u003ccode\u003eextra\u003c/code\u003e로 포함하도록 선택할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e[project]\r\ndefault-optional-dependency-keys = [ \"recommended\" ]\r\n\r\n[project.optional-dependencies]\r\nrecommended = [\r\n    \"package1\",\r\n    \"package2\"\r\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 패키지가 \u003ccode\u003epackage\u003c/code\u003e라고 불린다면, \u003ccode\u003epackage\u003c/code\u003e를 설치하는 사용자는 \u003ccode\u003epackage[recommended]\u003c/code\u003e와 동일한 결과를 얻게 됩니다. 사용자는 대안으로 \u003ccode\u003epackage[]\u003c/code\u003e를 설치하여 기본 \u003ccode\u003eextras\u003c/code\u003e 없이 패키지를 설치할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\"동기\" 섹션의 구체적인 패키지 예시 중 하나인 \u003ccode\u003eastropy\u003c/code\u003e 패키지는 \u003ccode\u003erecommended\u003c/code\u003e \u003ccode\u003eextra\u003c/code\u003e를 정의하며, 사용자는 현재 기본 설치 지침에서 이를 설치하도록 안내받습니다. 이 PEP를 통해 \u003ccode\u003erecommended\u003c/code\u003e \u003ccode\u003eextra\u003c/code\u003e는 기본 \u003ccode\u003eextra\u003c/code\u003e로 선언될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e[project]\r\ndefault-optional-dependency-keys = [ \"recommended\" ]\r\n\r\n[project.optional-dependencies]\r\nrecommended = [\r\n    \"scipy\",\r\n    \"...\"\r\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 다음 설치 명령이:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install astropy\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003escipy\u003c/code\u003e와 같은 선택적이지만 권장되는 의존성을 설치할 것임을 의미합니다. 최소 설치를 원하는 고급 사용자는 다음을 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install astropy[]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e최소한 하나의 백엔드 또는 프론트엔드를 요구하는 패키지 (Packages requiring at least one backend or frontend)\u003c/h4\u003e\n\u003cp\u003e\"동기\" 섹션에서 설명한 바와 같이, 일부 패키지는 여러 백엔드 및/또는 프론트엔드를 지원할 수 있으며, 어떤 경우에는 항상 최소한 하나의 백엔드 또는 프론트엔드 패키지가 설치되도록 하는 것이 바람직할 수 있습니다. 그렇지 않으면 패키지를 사용할 수 없기 때문입니다. 구체적인 예로는 GUI 라이브러리가 있어야 사용할 수 있지만 다른 라이브러리를 지원할 수 있는 GUI 애플리케이션, 또는 여러 계산 백엔드에 의존할 수 있지만 최소한 하나는 설치되어야 하는 패키지가 있습니다.\u003c/p\u003e\n\u003cp\u003e이 경우, 패키지 관리자는 각 백엔드 또는 프론트엔드에 대한 \u003ccode\u003eextra\u003c/code\u003e를 정의하고 기본값을 제공하도록 선택할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e[project]\r\ndefault-optional-dependency-keys = [ \"backend1\" ]\r\n\r\n[project.optional-dependencies]\r\nbackend1 = [\r\n    \"package1\",\r\n    \"package2\"\r\n]\r\nbackend2 = [\r\n    \"package3\"\r\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e패키지가 예를 들어 여러 백엔드를 동시에 지원할 수 있고, 일부 백엔드가 항상 설치되어야 한다면, 이들에 대한 의존성은 기본 \u003ccode\u003eextras\u003c/code\u003e 메커니즘을 사용하는 대신 필수 의존성으로 제공되어야 합니다.\u003c/p\u003e\n\u003cp\u003e\"동기\" 섹션에서 언급된 구체적인 예시 중 하나인 \u003ccode\u003enapari\u003c/code\u003e 패키지는 \u003ccode\u003ePyQt5\u003c/code\u003e, \u003ccode\u003ePyQt6\u003c/code\u003e, \u003ccode\u003ePySide2\u003c/code\u003e, 또는 \u003ccode\u003ePySide6\u003c/code\u003e 중 하나를 사용할 수 있으며, 사용자는 현재 이 중 하나가 설치되도록 \u003ccode\u003enapari[all]\u003c/code\u003e을 명시적으로 지정하거나, \u003ccode\u003enapari[pyqt5]\u003c/code\u003e와 같이 특정 프론트엔드 패키지를 명시적으로 지정해야 합니다. \u003ccode\u003eextras\u003c/code\u003e 없이 \u003ccode\u003enapari\u003c/code\u003e를 설치하면 작동하지 않는 패키지가 됩니다. 이 PEP를 통해 \u003ccode\u003enapari\u003c/code\u003e는 다음 구성을 정의할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e[project]\r\ndefault-optional-dependency-keys = [ \"pyqt5\" ]\r\n\r\n[project.optional-dependencies]\r\npyqt5 = [\r\n    \"PyQt5\",\r\n    \"...\"\r\n]\r\npyside2 = [\r\n    \"PySide2\",\r\n    \"...\"\r\n]\r\npyqt6 = [\r\n    \"PyQt6\",\r\n    \"...\"\r\n]\r\npyside6 = [\r\n    \"PySide6\",\r\n    \"...\"\r\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 다음 설치 명령이:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install napari\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e별도의 설정 없이 작동하지만, 사용자가 예를 들어 \u003ccode\u003enapari[pyside6]\u003c/code\u003e와 같이 프론트엔드를 명시적으로 지정할 수 있는 메커니즘은 여전히 존재할 것임을 의미합니다.\u003c/p\u003e\n\u003ch4\u003e기본 \u003ccode\u003eextras\u003c/code\u003e를 제거하지 않는 \u003ccode\u003eextras\u003c/code\u003e 지원 (Supporting extras that should not remove default extras)\u003c/h4\u003e\n\u003cp\u003e여기서 고려하는 추가적인 경우는 패키지 관리자가 기본 \u003ccode\u003eextras\u003c/code\u003e를 제거하지 않고 사용자가 비기본 \u003ccode\u003eextras\u003c/code\u003e를 옵트인(opt-in)할 수 있도록 지원하고자 하는 경우입니다. 본질적으로 그들은 다음을 원할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epackage[]\u003c/code\u003e는 \u003ccode\u003eextras\u003c/code\u003e 없이 설치합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epackage\u003c/code\u003e는 권장 의존성(권장 \u003ccode\u003eextra\u003c/code\u003e에 있는)을 설치합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epackage[alternative]\u003c/code\u003e는 기본 \u003ccode\u003eextras\u003c/code\u003e를 설치하지 않지만, 대안적인 선택적 의존성 세트(대안 \u003ccode\u003eextra\u003c/code\u003e에 있는)를 설치합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epackage[additional]\u003c/code\u003e은 권장 의존성과 추가 의존성(추가 \u003ccode\u003eextra\u003c/code\u003e에 있는)을 모두 설치합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 예를 들어 다음을 통해 달성될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e[project]\r\ndefault-optional-dependency-keys = [ \"recommended\" ]\r\n\r\n[project.optional-dependencies]\r\nrecommended = [\r\n    \"package1\",\r\n    \"package2\"\r\n]\r\nalternative = [\r\n    \"package3\"\r\n]\r\nadditional = [\r\n    \"package[recommended]\", # 패키지 자체를 참조하여 기본 extra를 포함\r\n    \"package4\"\r\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e패키지가 \u003ccode\u003eextras\u003c/code\u003e에서 자신을 참조하는 기능은 기존 Python 패키징 도구에 의해 지원됩니다.\u003c/p\u003e\n\u003cp\u003e다시 한번 구체적인 예시로 \u003ccode\u003eastropy\u003c/code\u003e를 고려하면, 이 PEP를 통해 \u003ccode\u003erecommended\u003c/code\u003e \u003ccode\u003eextra\u003c/code\u003e를 정의할 수 있습니다 (\"권장되는 의존성 및 최소 설치\" 섹션에서 설명된 바와 같이). 그러나 \u003ccode\u003ejupyter\u003c/code\u003e와 같은 다른 \u003ccode\u003eextras\u003c/code\u003e도 정의하는데, 이는 Jupyter 기반 환경 내에서 사용자 경험을 향상시키는 패키지를 추가합니다. 이 \u003ccode\u003eextra\u003c/code\u003e를 선택하는 사용자도 여전히 권장되는 의존성을 설치하기를 원할 수 있습니다. 이 경우 다음 구성이 이 문제를 해결할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003e[project]\r\ndefault-optional-dependency-keys = [ \"recommended\" ]\r\n\r\n[project.optional-dependencies]\r\nrecommended = [\r\n    \"scipy\",\r\n    \"...\"\r\n]\r\njupyter = [\r\n    \"astropy[recommended]\", # astropy 자체를 참조하여 'recommended' extra를 포함\r\n    \"ipywidgets\",\r\n    \"...\"\r\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 같이 설치하는 사용자:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install astropy[jupyter]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 \u003ccode\u003eastropy[recommended, jupyter]\u003c/code\u003e와 동일한 것을 얻게 됩니다.\u003c/p\u003e\n\u003ch4\u003e여러 종류의 기본값을 가진 패키지 (Packages with multiple kinds of defaults)\u003c/h4\u003e\n\u003cp\u003e어떤 경우에는 패키지에 여러 종류의 기본값이 필요할 수 있습니다. 예를 들어, \"최소한 하나의 백엔드 또는 프론트엔드를 요구하는 패키지\" 섹션에서 백엔드 또는 프론트엔드를 가진 패키지의 경우를 고려했지만, 어떤 경우에는 패키지가 백엔드와 프론트엔드를 모두 지원해야 할 수 있으며, 하나 이상의 기본 프론트엔드와 하나 이상의 기본 백엔드를 지정하기를 원할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이상적으로는 다음 동작을 원할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e$ pip install package\u003c/code\u003e # 기본 백엔드와 프론트엔드를 설치합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$ pip install package[]\u003c/code\u003e # 백엔드나 프론트엔드를 설치하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$ pip install package[backend1]\u003c/code\u003e # \u003ccode\u003ebackend1\u003c/code\u003e과 기본 프론트엔드를 설치합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$ pip install package[frontend2]\u003c/code\u003e # \u003ccode\u003efrontend2\u003c/code\u003e와 기본 백엔드를 설치합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$ pip install package[backend1, frontend2]\u003c/code\u003e # \u003ccode\u003ebackend1\u003c/code\u003e과 \u003ccode\u003efrontend2\u003c/code\u003e를 설치합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그러나 이 PEP는 복잡성을 추가하기 때문에, 예를 들어 \u003ccode\u003ebackend1\u003c/code\u003e이 지정된 경우 기본 백엔드는 비활성화되지만 기본 프론트엔드는 활성화되는 메커니즘을 제공하지 않기로 선택했습니다.\u003c/p\u003e\n\u003cp\u003e관리자는 대신 지금은 백엔드 또는 프론트엔드가 명시적으로 지정된 경우 백엔드와 프론트엔드 모두를 지정해야 함을 문서화해야 합니다. 그러나 이를 원하는 사용자의 발견 가능성(discoverability)은 문제가 되지 않을 것입니다. 사용자는 어떤 백엔드나 프론트엔드를 사용할 수 있는지 알아보기 위해 어차피 문서를 읽어야 하므로, 백엔드와 프론트엔드에 대한 \u003ccode\u003eextras\u003c/code\u003e를 올바르게 사용하는 방법을 동시에 보여줄 수 있습니다.\u003c/p\u003e\n\u003cp\u003e사용자 편의성을 높이는 한 가지 옵션은 관리자가 예를 들어 \u003ccode\u003edefaultbackend\u003c/code\u003e 및 \u003ccode\u003edefaultfrontend\u003c/code\u003e라는 \u003ccode\u003eextras\u003c/code\u003e를 만들고, 이들이 기본 백엔드와 프론트엔드를 설치하도록 하는 것입니다. 그런 다음 사용자에게 다음을 권장할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install package # 기본 백엔드와 프론트엔드를 설치합니다.\r\n$ pip install package[] # 백엔드나 프론트엔드를 설치하지 않습니다.\r\n$ pip install package[backend1, defaultfrontend] # backend1과 기본 프론트엔드를 설치합니다.\r\n$ pip install package[defaultbackend, frontend2] # frontend2와 기본 백엔드를 설치합니다.\r\n$ pip install package[backend1, frontend2] # backend1과 frontend2를 설치합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 통해 (원하는 경우) 사용자는 시간이 지나면서 기본 백엔드가 변경되더라도 권장되는 백엔드를 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e미래에 더 나은 해결책을 구현하려는 열망이 있다면, 이 PEP가 이를 배제하지는 않는다고 생각합니다. 예를 들어, 미래에는 \u003ccode\u003eextra\u003c/code\u003e가 어떤 기본 \u003ccode\u003eextras\u003c/code\u003e를 비활성화하는지 지정하는 기능을 추가할 수 있으며, 이 부분이 지정되지 않으면 명시적으로 지정된 \u003ccode\u003eextras\u003c/code\u003e가 모든 기본 \u003ccode\u003eextras\u003c/code\u003e를 비활성화할 수 있습니다 (이 PEP와 일치).\u003c/p\u003e\n\u003ch3\u003e하위 호환성 (Backward Compatibility)\u003c/h3\u003e\n\u003ch4\u003e기본 \u003ccode\u003eextras\u003c/code\u003e를 사용하지 않는 패키지 (Packages not using default extras)\u003c/h4\u003e\n\u003cp\u003e패키징 생태계의 도구에 이 PEP에 대한 지원이 추가되면, 기본 \u003ccode\u003eextras\u003c/code\u003e를 사용하지 않는 패키지는 그대로 작동하며 호환성 문제는 없을 것입니다.\u003c/p\u003e\n\u003ch4\u003e기본 \u003ccode\u003eextras\u003c/code\u003e를 사용하는 패키지 (Packages using default extras)\u003c/h4\u003e\n\u003cp\u003e패키지가 기본 \u003ccode\u003eextras\u003c/code\u003e를 정의하기 시작하면, 이러한 기본값은 이 PEP를 구현하는 최신 버전의 패키징 도구에서만 적용됩니다. 그러나 해당 패키지는 이전 패키징 도구에서도 설치 가능하며, 주요 차이점은 이전 패키징 도구를 사용할 때 기본 \u003ccode\u003eextras\u003c/code\u003e가 자동으로 설치되지 않는다는 것입니다.\u003c/p\u003e\n\u003cp\u003e\"How to teach this\" 섹션에서 설명된 바와 같이, 패키지 작성자는 사용자 기반에 따라 \u003ccode\u003edefault extra\u003c/code\u003e 기능을 언제, 어떻게 채택할지 신중하게 평가해야 합니다. 일부 작업(예: 필수 의존성을 기본 \u003ccode\u003eextra\u003c/code\u003e로 이동)은 상당수의 사용자가 \u003ccode\u003edefault extras\u003c/code\u003e를 지원하지 않는 이전 패키지 설치 도구를 여전히 사용하고 있다면 사용자에게 문제가 발생할 수 있습니다. 이러한 의미에서 패키지 작성자는 이 기능이 특정 방식으로 사용될 경우 사용자에게 하위 호환성 문제를 일으킬 수 있음을 인지하고, 사용자에게 미치는 영향을 최소화할 책임이 있습니다.\u003c/p\u003e\n\u003ch4\u003e패키징 관련 도구 (Packaging-related tools)\u003c/h4\u003e\n\u003cp\u003e가장 중요한 하위 호환성 측면은 패키징 도구가 \u003ccode\u003eextras\u003c/code\u003e에 대해 가지고 있는 가정과 관련이 있습니다. 특히, 이 PEP는 \u003ccode\u003eextras\u003c/code\u003e가 더 이상 의존성 트리에 의존성을 추가하는 측면에서만 배타적으로 추가적인 것이 아니며, 일부 \u003ccode\u003eextras\u003c/code\u003e를 지정하면 더 적은 의존성이 설치될 수 있다는 가정을 변경합니다.\u003c/p\u003e\n\u003cp\u003e동작 변경의 구체적인 예시는 \u003ccode\u003epip\u003c/code\u003e에서 볼 수 있습니다. \u003ccode\u003enumpy\u003c/code\u003e에 필수 의존성이 있고, \u003ccode\u003escipy\u003c/code\u003e를 포함하는 \u003ccode\u003erecommended\u003c/code\u003e라는 기본 \u003ccode\u003eextra\u003c/code\u003e를 가진 \u003ccode\u003epackage\u003c/code\u003e라는 패키지를 고려해봅시다. 사용자가 \u003ccode\u003epackage[]\u003c/code\u003e를 설치하면 \u003ccode\u003epackage\u003c/code\u003e와 \u003ccode\u003enumpy\u003c/code\u003e만 설치됩니다. 사용자가 다음과 같이 실행하면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip freeze \u003e requirements.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003erequirements.txt\u003c/code\u003e에는 예를 들어 다음과 같이 포함될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage==1.0.2\r\nnumpy==2.1.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 사용자가 이 파일을 사용하여 요구 사항을 설치하면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install -r requirements.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epip\u003c/code\u003e는 \u003ccode\u003epackage\u003c/code\u003e (기본 \u003ccode\u003eextra\u003c/code\u003e를 포함)와 \u003ccode\u003enumpy\u003c/code\u003e를 설치할 것이므로, 최종 환경에는 \u003ccode\u003escipy\u003c/code\u003e가 포함될 것입니다. 이 특정 경우의 해결책은 사용자가 의존성 트리를 해결하지 않기 위해 \u003ccode\u003epip install\u003c/code\u003e에 \u003ccode\u003e--no-deps\u003c/code\u003e를 전달하는 것이지만, 여기서 요점은 \u003ccode\u003eextra\u003c/code\u003e가 미칠 수 있는 영향에 대한 가정의 변경으로 인해 패키징 도구의 동작에 변화가 있을 수 있음을 보여주는 것입니다.\u003c/p\u003e\n\u003cp\u003e최근 승인된 PEP 751은 미래에 \u003ccode\u003epip freeze\u003c/code\u003e 출력 및 다른 도구와 같은 대안을 대체할 새로운 파일 형식을 정의한다는 점에 주목할 가치가 있습니다. 새 파일 형식은 파일 내 패키지가 의존성을 해결하지 않고 설치되도록 설계되었으며, 이는 이 PEP에 명시된 \u003ccode\u003edefault extras\u003c/code\u003e와 완전히 호환되며, 위에서 언급된 \u003ccode\u003epip freeze\u003c/code\u003e / \u003ccode\u003epip install -r\u003c/code\u003e 문제를 피할 것입니다.\u003c/p\u003e\n\u003ch3\u003e보안 영향 (Security Implications)\u003c/h3\u003e\n\u003cp\u003e이 PEP에 대한 알려진 보안 영향은 없습니다.\u003c/p\u003e\n\u003ch3\u003e교육 방법 (How to teach this)\u003c/h3\u003e\n\u003cp\u003e이 섹션에서는 이 PEP의 구현과 관련하여 커뮤니티의 다양한 그룹에 제공되어야 할 정보를 설명합니다. 아래 설명된 일부 측면은 PEP가 패키징 도구에 완전히 구현되기 전에도 관련성이 있을 것이며, 이는 향후 잠재적인 전환을 용이하게 하기 위해 미리 할 수 있는 준비가 있기 때문입니다. 아래에 다루는 그룹은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e패키지 최종 사용자 (Package end users)\u003c/li\u003e\n\u003cli\u003e패키지 작성자 (Package authors)\u003c/li\u003e\n\u003cli\u003e패키징 저장소 관리자 (Packaging repository maintainers)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e패키지 최종 사용자 (Package end users)\u003c/h4\u003e\n\u003cp\u003e패키지 사용자에게는 패키지에 어떤 \u003ccode\u003eextras\u003c/code\u003e를 사용할 수 있고 어떻게 동작하는지 보여주는 명확한 설치 지침이 제공되어야 합니다. 예를 들어, 기본적으로 일부 권장되는 의존성 또는 주어진 프론트엔드나 백엔드가 설치되며, 사용 가능한 옵션에 따라 이를 어떻게 제외하거나 기본값을 재정의하는지 설명해야 합니다.\u003c/p\u003e\n\u003ch4\u003e패키지 작성자 (Package authors)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eextras\u003c/code\u003e를 정의하는 메커니즘과 이를 사용해야 하는 관련 규칙은 명확하지만, 패키지 작성자는 역호환성을 의도치 않게 깨뜨리지 않기 위해 이 기능을 자신의 패키지에 적용하기 전에 여러 가지 사항을 신중하게 고려해야 합니다.\u003c/p\u003e\n\u003ch5\u003e이전 버전의 패키지 설치 도구 지원 (Supporting older versions of package installers)\u003c/h5\u003e\n\u003cp\u003e\u003ccode\u003epip\u003c/code\u003e 또는 \u003ccode\u003euv\u003c/code\u003e와 같은 패키지 설치 도구는 \u003ccode\u003edefault extras\u003c/code\u003e에 대한 지원을 동시에 구현하지 않을 수 있으며, 일단 구현되면 패키지 작성자는 최신 버전의 패키지 설치 도구를 사용하지 않는 사용자를 계속 지원하기를 원할 가능성이 높습니다. 이 경우 다음 권장 사항이 적용됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e패키지를 필수 의존성에서 기본 \u003ccode\u003eextra\u003c/code\u003e로 이동하는 것은 호환성을 깨는 변경(breaking change)이 될 것입니다. 왜냐하면 이전 버전의 패키지 설치 도구는 \u003ccode\u003edefault extras\u003c/code\u003e 개념을 인식하지 못하고, 더 적은 의존성으로 패키지를 설치하게 되어, 해당 의존성에 의존했을 사용자에게 영향을 미칠 수 있기 때문입니다. 따라서, 이미 자리 잡은 패키지에서 의존성을 필수에서 기본 \u003ccode\u003eextra\u003c/code\u003e로 변경하는 것은 개발자가 이 PEP를 구현하는 설치 도구를 사용하는 사용자만을 지원하려는 경우에만 미래에 이루어져야 합니다.\u003c/li\u003e\n\u003cli\u003e기존 \u003ccode\u003eextra\u003c/code\u003e를 기본값으로 만드는 것은 더 안전할 것입니다. 예를 들어 \u003ccode\u003eastropy\u003c/code\u003e의 \u003ccode\u003erecommended\u003c/code\u003e를 기본 \u003ccode\u003eextra\u003c/code\u003e로 만드는 것과 같습니다. 그러나 이전 버전의 패키지 설치 도구를 사용하는 사용자를 지원하기 위해서는, 가능한 한 오랫동안 (대부분의/모든 사용자가 이 PEP를 구현하는 패키지 설치 도구를 사용하고 있다는 것이 명확해질 때까지) 문서에 \u003ccode\u003eextra\u003c/code\u003e를 명시적으로 언급해야 합니다. \u003ccode\u003eextra\u003c/code\u003e를 명시적으로 언급하는 것을 유지하는 데에는 단점이 없지만, 이는 문서를 읽지 않는 (상당한 비중을 차지할 수 있는) 최신 도구를 사용하는 사용자들이 기본적으로 권장 의존성을 얻기 시작하도록 보장할 것입니다.\u003c/li\u003e\n\u003cli\u003e이 PEP 이전에는 \u003ccode\u003epackage[]\u003c/code\u003e가 \u003ccode\u003epackage\u003c/code\u003e와 동일했기 때문에, 작성자는 \u003ccode\u003epackage[]\u003c/code\u003e를 최소 설치를 얻는 하위 호환 가능한 보편적인 방법으로 문서화할 수 있습니다. \u003ccode\u003edefault extras\u003c/code\u003e를 정의하는 패키지의 경우, \u003ccode\u003epackage[]\u003c/code\u003e를 설치하면 \u003ccode\u003epip\u003c/code\u003e와 같은 이전 버전의 패키징 도구를 사용하더라도 항상 최소 설치를 제공할 것입니다. 또한 특정 패키지에 \u003ccode\u003edefault extras\u003c/code\u003e가 도입되기 전의 패키지 릴리스도 \u003ccode\u003epackage[]\u003c/code\u003e로 설치할 수 있습니다 (이 경우 \u003ccode\u003epackage\u003c/code\u003e와 동일합니다). \u003ccode\u003edefault extras\u003c/code\u003e를 정의하지 않는 패키지의 경우, \u003ccode\u003epackage[]\u003c/code\u003e는 계속해서 \u003ccode\u003epackage\u003c/code\u003e와 동일할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5\u003e많은 기본 의존성 추가 피하기 (Avoiding the addition of many default dependencies)\u003c/h5\u003e\n\u003cp\u003e작성자는 이러한 의존성을 제외할 수 있는 방법을 제공할 수 있기 때문에 많은 의존성을 기본적으로 포함하려는 유혹을 느낄 수 있습니다. 그러나 작성자는 불필요하게 설치를 부풀리고 의존성 트리를 복잡하게 만들지 않도록 기본적으로 포함되는 내용을 신중하게 고려할 것을 권장합니다. \u003ccode\u003edefault extras\u003c/code\u003e를 사용한다고 해서 모든 \u003ccode\u003eextras\u003c/code\u003e가 기본값이어야 하는 것은 아니며, 사용자가 비기본 \u003ccode\u003eextras\u003c/code\u003e를 명시적으로 옵트인할 여지는 여전히 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eDefault extras\u003c/code\u003e는 일반적으로 필수 의존성과 동일한 \"무게\"로 취급되어야 합니다. 패키지가 널리 사용될 때, \u003ccode\u003edefault extra\u003c/code\u003e를 도입하면 해당 \u003ccode\u003eextra\u003c/code\u003e의 의존성이 전이적으로(transitively) 포함됩니다. 이는 모든 다운스트림 패키지가 최소 설치 명세를 사용하여 명시적으로 옵트아웃하도록 업데이트되지 않는 한 그렇습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003epytest\u003c/code\u003e 패키지는 현재 약 1,500개의 플러그인이 의존하고 있습니다. 만약 \u003ccode\u003epytest\u003c/code\u003e가 \u003ccode\u003edefault extra\u003c/code\u003e를 추가하고 해당 플러그인들이 그에 따라 업데이트되지 않으면, 플러그인을 설치할 때 \u003ccode\u003edefault extras\u003c/code\u003e의 의존성이 포함될 것입니다. 이것이 \u003ccode\u003edefault extras\u003c/code\u003e 사용을 배제하는 것은 아니지만, \u003ccode\u003edefault extras\u003c/code\u003e의 추가는 다운스트림 영향에 대한 신중한 평가를 필요로 합니다.\u003c/p\u003e\n\u003ch5\u003e기본 \u003ccode\u003eextras\u003c/code\u003e 상속 (Inheriting from default extras)\u003c/h5\u003e\n\u003cp\u003e패키지 작성자가 \u003ccode\u003eextra\u003c/code\u003e를 기본적으로 설치되도록 선택하는 경우, 사용자가 다른 \u003ccode\u003eextra\u003c/code\u003e를 명시적으로 지정하면 \"기본 \u003ccode\u003eextras\u003c/code\u003e를 제거하지 않는 \u003ccode\u003eextras\u003c/code\u003e 지원\"에서 설명된 접근 방식을 사용하지 않는 한 기본 \u003ccode\u003eextra\u003c/code\u003e가 설치되지 않을 수 있음을 인식하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e서로 교환 가능한 백엔드와 같은 경우에는 \u003ccode\u003eextra\u003c/code\u003e가 명시적으로 지정되면 기본값을 무시하는 것이 올바른 일입니다. 그러나 다른 경우에는, 최소 설치를 허용하면서 권장 의존성을 포함하기 위해 \u003ccode\u003edefault extras\u003c/code\u003e를 사용하는 것과 같이, 다른 많은 \u003ccode\u003eextras\u003c/code\u003e가 기본 \u003ccode\u003eextras\u003c/code\u003e를 명시적으로 '상속'해야 할 수 있으므로, 패키지 작성자는 어떤 경우에 \u003ccode\u003edefault extras\u003c/code\u003e가 설치되기를 원하는지 신중하게 고려해야 합니다.\u003c/p\u003e\n\u003ch5\u003e호환되지 않는 \u003ccode\u003eextras\u003c/code\u003e (Incompatible extras)\u003c/h5\u003e\n\u003cp\u003e어떤 경우에는 패키지에 상호 호환되지 않는 \u003ccode\u003eextras\u003c/code\u003e가 있을 수 있습니다. 이 경우, 다른 \u003ccode\u003eextra\u003c/code\u003e와 호환되지 않을 수 있는 의존성을 포함하는 \u003ccode\u003eextra\u003c/code\u003e에 대해 \u003ccode\u003edefault extra\u003c/code\u003e 기능을 사용하지 않는 것을 권장합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epackage[A]\u003c/code\u003e와 \u003ccode\u003epackage[B]\u003c/code\u003e \u003ccode\u003eextras\u003c/code\u003e를 가진 패키지를 고려해봅시다. 사용자는 이미 현재 \u003ccode\u003epackage[A]\u003c/code\u003e와 \u003ccode\u003epackage[B]\u003c/code\u003e 또는 \u003ccode\u003epackage[A,B]\u003c/code\u003e를 설치하려고 시도할 수 있으며, 이는 설치 오류를 초래할 수 있지만, 적어도 두 \u003ccode\u003eextras\u003c/code\u003e가 모두 설치되고 있다는 것이 명확할 것입니다. 그러나 \u003ccode\u003eA\u003c/code\u003e를 기본 \u003ccode\u003eextra\u003c/code\u003e로 만들면 직관적이지 않은 문제가 발생할 수 있습니다. 사용자는 다음을 실행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install package # 이것은 package[A]를 설치합니다\r\n$ pip install package[B]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 \u003ccode\u003eA\u003c/code\u003e와 \u003ccode\u003eB\u003c/code\u003e가 명시적으로 동시에 설치된 적이 없더라도 설치 오류로 끝날 수 있습니다. 이러한 이유로, 문제가 발생할 가능성이 있는 의존성에 대해 \u003ccode\u003edefault extras\u003c/code\u003e를 사용하지 않는 것을 권장합니다.\u003c/p\u003e\n\u003ch5\u003e순환 의존성 (Circular dependencies)\u003c/h5\u003e\n\u003cp\u003e작성자는 순환 의존성이 존재할 때 특별한 주의를 기울여야 합니다. 예를 들어, 다음 의존성 트리를 고려해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage1\r\n└── package2\r\n    └── package1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 \u003ccode\u003epackage1\u003c/code\u003e에 \u003ccode\u003erecommended\u003c/code\u003e라는 기본 \u003ccode\u003eextra\u003c/code\u003e가 있다면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install package1[]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epackage2\u003c/code\u003e가 계속해서 \u003ccode\u003epackage1\u003c/code\u003e에 의존하는 경우 (지정된 \u003ccode\u003eextras\u003c/code\u003e 없이) \u003ccode\u003erecommended\u003c/code\u003e \u003ccode\u003eextra\u003c/code\u003e가 여전히 설치될 것입니다. 이는 의존성 트리를 다음으로 변경함으로써 해결될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage1\r\n└── package2\r\n    └── package1[]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(단, \u003ccode\u003epackage2\u003c/code\u003e가 \u003ccode\u003epackage1\u003c/code\u003e의 \u003ccode\u003eextra\u003c/code\u003e 의존성에 의해 제공되는 기능에 실제로 의존하지 않는다고 가정합니다). 따라서 작성자는 \u003ccode\u003epackage2\u003c/code\u003e의 작성자와 조율하여 마이그레이션 계획을 신중하게 고려해야 합니다.\u003c/p\u003e\n\u003ch5\u003e\u003ccode\u003edefault extras\u003c/code\u003e를 가진 패키지 문서화 (Documenting packages with default extras)\u003c/h5\u003e\n\u003cp\u003e\u003ccode\u003edefault extras\u003c/code\u003e가 어떻게 사용되든 관계없이, 패키지 작성자는 패키지 문서가 \u003ccode\u003eextras\u003c/code\u003e를 어떻게 사용해야 하는지 명확하게 설명하도록 해야 합니다. '모범 사례' 문서에는 다음이 언급되어야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epackage\u003c/code\u003e를 설치하는 것은 \u003ccode\u003epackage[\u0026#x3C;default extras\u003e]\u003c/code\u003e와 동일할 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epackage[]\u003c/code\u003e를 설치하는 것은 최소/필수 의존성만 포함할 것이지만, \u003ccode\u003epackage\u003c/code\u003e가 의존성 트리의 다른 곳에 나타나는 경우 선택적 의존성이 설치되지 않음을 보장하지는 않습니다.\u003c/li\u003e\n\u003cli\u003e사용 가능한 다른 선택적 \u003ccode\u003eextras\u003c/code\u003e가 무엇이며, 이들이 기본 \u003ccode\u003eextras\u003c/code\u003e를 비활성화하는지 여부 (이는 \"기본 \u003ccode\u003eextras\u003c/code\u003e를 제거하지 않는 \u003ccode\u003eextras\u003c/code\u003e 지원\"에서 설명된 대로 제어될 수 있음).\u003c/li\u003e\n\u003cli\u003e예를 들어 기본 백엔드와 프론트엔드를 가질 수 있는 패키지에 대한 특정 지침 (이는 \"여러 종류의 기본값을 가진 패키지\"에서 설명된 대로).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e패키징 저장소 관리자 (Packaging repository maintainers)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003econda\u003c/code\u003e, \u003ccode\u003eHomebrew\u003c/code\u003e, \u003ccode\u003eapt\u003c/code\u003e, \u003ccode\u003eyum\u003c/code\u003e과 같은 Linux 패키지 설치 도구 등 다양한 배포판을 위해 Python 라이브러리를 재패키징하는 개인에게 미치는 영향을 고려해야 합니다. 모든 패키지 배포판이 설명된 접근 방식과 일치하는 메커니즘을 가지고 있는 것은 아닙니다. 사실, \u003ccode\u003econda\u003c/code\u003e와 같은 일부 배포판은 \u003ccode\u003eextras\u003c/code\u003e 개념조차 없습니다.\u003c/p\u003e\n\u003cp\u003e여기서 고려해야 할 두 가지 경우가 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econda-forge\u003c/code\u003e 레시피의 일부와 같이 수동으로 재패키징하는 경우, 특히 \u003ccode\u003eextras\u003c/code\u003e에 해당하는 것이 없는 경우, \u003ccode\u003edefault extras\u003c/code\u003e의 도입은 큰 영향을 미치지 않을 것입니다. 왜냐하면 어떤 의존성을 포함할지 이미 수동으로 결정해야 하기 때문입니다 (예를 들어, \"동기\" 섹션에서 언급된 \u003ccode\u003eastropy\u003c/code\u003e 패키지의 \u003ccode\u003econda-forge\u003c/code\u003e 레시피는 사용자가 달리 명시적으로 요청할 방법이 없기 때문에 모든 권장 의존성을 기본적으로 포함합니다).\u003c/li\u003e\n\u003cli\u003e자동화된 방식으로 재패키징하는 경우, 배포판 관리자는 \u003ccode\u003edefault extras\u003c/code\u003e를 어떻게 처리할지 신중하게 고려해야 하며, 이는 상당한 양의 작업과 논의를 의미할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이와 같은 PEP가 다양한 패키지 배포판 각각을 상세히 고려하는 것은 불가능합니다. 그러나 궁극적으로 \u003ccode\u003edefault extras\u003c/code\u003e는 패키지 작성자가 대부분의 사용자를 위해 자신의 패키지가 어떻게 설치되기를 원하는지를 나타내는 것으로 이해되어야 하며, 이는 \u003ccode\u003edefault extras\u003c/code\u003e를 수동으로 또는 자동으로 처리하는 방법에 대한 결정에 정보를 제공해야 합니다.\u003c/p\u003e\n\u003ch3\u003e참조 구현 (Reference Implementation)\u003c/h3\u003e\n\u003cp\u003e다음 저장소에는 \u003ccode\u003edefault extras\u003c/code\u003e를 사용하는 완전히 작동하는 데모 패키지가 포함되어 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/wheel-next/pep_771\"\u003ehttps://github.com/wheel-next/pep_771\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 여러 패키지의 수정된 브랜치를 사용하며, 다음 링크는 해당 브랜치입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/pypa/setuptools/tree/pep771\"\u003eSetuptools\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/pypa/pip/tree/pep771\"\u003epip\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/python/importlib_metadata/tree/pep771\"\u003eimportlib_metadata\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한, 이 브랜치에는 수정된 \u003ccode\u003eFlit\u003c/code\u003e 패키지 버전이 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e위 구현은 현재 개념 증명(proof-of-concept)이며, 기존 변경 사항은 아직 관련 관리자들의 검토를 거치지 않았습니다. 그럼에도 불구하고, 관심 있는 관리자들이 시도해 볼 수 있을 만큼 충분히 기능적입니다.\u003c/p\u003e\n\u003ch3\u003e거부된 아이디어 (Rejected Ideas)\u003c/h3\u003e\n\u003ch4\u003e권장 설치를 위한 메타 패키지 사용 (Using a meta-package for recommended installations)\u003c/h4\u003e\n\u003cp\u003e기존 패키징 도구 및 인프라를 사용하여, 일부 사용자에게는 최소 설치를 제공하고 일반 사용자에게는 기본 비최소 설치(예: 권장 의존성 또는 기본 백엔드 포함)를 제공하려는 패키지 관리자는 기술적으로 이미 이를 달성할 수 있습니다. 이는 하나의 패키지 대신 두 개의 패키지를 배포할 의향이 있다면 가능합니다. 예를 들어, 최소 의존성을 가진 주 패키지인 \u003ccode\u003epackage-core\u003c/code\u003e와, 선택적 의존성이 활성화된 \u003ccode\u003epackage-core\u003c/code\u003e에 의존하는 메타 패키지 \u003ccode\u003epackage\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e\"동기\" 섹션의 구체적인 예시를 다시 들어보면, \u003ccode\u003eastropy\u003c/code\u003e 패키지는 \u003ccode\u003erecommended\u003c/code\u003e \u003ccode\u003eextra\u003c/code\u003e를 정의하며, 사용자는 현재 기본 설치 지침에서 이를 설치하도록 안내받습니다. 원칙적으로 기존 \u003ccode\u003eastropy\u003c/code\u003e 패키지를 \u003ccode\u003eastropy-core\u003c/code\u003e 등으로 이름을 바꾸고, 새로운 \u003ccode\u003eastropy\u003c/code\u003e 패키지를 생성하여 다음 의존성 섹션을 포함하는 메타 패키지로 만들 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003edependencies = [ \"astropy-core[recommended]\" ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사용자가 \u003ccode\u003eastropy\u003c/code\u003e 메타 패키지에 버전 제약을 걸거나 고정(pin)하기를 원할 수 있으므로 (예: \u003ccode\u003eastropy\u003e5.0\u003c/code\u003e), 메타 패키지는 코어 패키지와 동일한 버전을 따라야 하며, 의존성 섹션에서 엄격한 고정(strict pinning)을 사용해야 합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-toml\"\u003eversion = \"7.1.0\"\r\ndependencies = [ \"astropy-core[recommended]==7.1.0\" ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 아이디어는 기술적으로 이미 실현 가능하기 때문에 매력적으로 보일 수 있습니다. 그러나 실제로는 많은 프로젝트가 여러 가지 이유로 이를 선택하지 않았으며, 이제 이를 살펴보겠습니다. 이 중 일부는 미래의 새로운 프로젝트에는 적용되지 않을 수 있지만, 일부는 모든 프로젝트(오래된 프로젝트와 새로운 프로젝트 모두)에 적용됩니다.\u003c/p\u003e\n\u003ch5\u003e패키지 이름과 모듈 이름 불일치 (Mismatch between package and module name)\u003c/h5\u003e\n\u003cp\u003e메타 패키지 접근 방식을 사용하려는 패키지의 경우, 이름 지정과 관련하여 두 가지 주요 옵션이 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e첫 번째 옵션\u003c/strong\u003e 은 기존 패키지를 그대로 유지하는 것입니다. 즉, \u003ccode\u003epackage\u003c/code\u003e가 최소 설치를 제공하고, \u003ccode\u003epackage-all\u003c/code\u003e과 같은 다른 이름으로 새 메타 패키지를 만드는 것입니다. 그러나 이는 이 PEP를 처음 동기 부여했던 문제 중 하나인 \"사용자들이 종종 \u003ccode\u003epackage[recommended]\u003c/code\u003e와 같은 것을 할 수 있다는 것을 알지 못한다\"는 문제와 동일하게, \u003ccode\u003epackage-all\u003c/code\u003e이 존재한다는 것을 깨닫지 못할 수 있다는 점에서 고통받습니다. 이는 다시 한번 일반 사용자에게 이를 발견해야 하는 부담을 지우며, 일부 부담을 고급 사용자에게로 옮기지 못합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e두 번째 옵션\u003c/strong\u003e 은 기존 패키지의 이름을 \u003ccode\u003epackage-core\u003c/code\u003e 등으로 변경하고, 새 메타 패키지의 이름을 \u003ccode\u003epackage\u003c/code\u003e로 하는 것입니다. 이는 첫 번째 옵션보다 낫지만, \u003ccode\u003epackage-core\u003c/code\u003e가 \u003ccode\u003epackage\u003c/code\u003e 모듈을 제공하고 \u003ccode\u003epackage\u003c/code\u003e는 어떤 모듈도 제공하지 않는다는 점에서 패키지 이름과 모듈 이름 사이에 직관적이지 않은 불일치를 초래하므로 이상적이지 않습니다. 이것이 혼란을 야기하는 이유의 예시는 일반 사용자가 \u003ccode\u003epackage\u003c/code\u003e 모듈을 제거하는 것이 예를 들어 다음과 같이 수행될 것이라고 생각할 수 있다는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip uninstall package\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 이것은 사실이 아닐 것이며 (\u003ccode\u003epackage\u003c/code\u003e 모듈은 여전히 작동할 것입니다), 이 사용자는 \u003ccode\u003epackage-core\u003c/code\u003e 패키지가 존재한다는 사실조차 명확하게 알지 못할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5\u003e다중 저장소 또는 모노레포 (Multiple repositories or monorepos)\u003c/h5\u003e\n\u003cp\u003e이 접근 방식은 하나 대신 두 개의 저장소를 유지하거나, 두 패키지를 모두 포함하는 모노레포(monorepo)를 사용하는 것을 필요로 합니다. 두 옵션 모두 이상적이지 않습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e두 개의 저장소로 분할\u003c/strong\u003e 하는 것은 관리자에게 장기적으로 추가적인 부담을 지웁니다. 관리자는 버전뿐만 아니라 \u003ccode\u003eextras\u003c/code\u003e와 같은 다른 측면에서도 이들이 동기화되도록 확인해야 합니다 (메타데이터 동기화에서 논의될 예정). 또한 \"패키지 이름과 모듈 이름 불일치\"에서 언급된 이름 지정 문제는 여기에서 추가적인 복잡성을 가집니다. 저장소 이름이 패키지와 일치하는 경우, 이전 패키지 저장소의 체크아웃을 가진 모든 사용자는 원격 URL 또는 \u003ccode\u003egit clone\u003c/code\u003e URL을 \u003ccode\u003epackage-core\u003c/code\u003e 저장소를 가리키도록 업데이트해야 합니다. 대안은 \u003ccode\u003epackage-core\u003c/code\u003e 패키지를 포함하도록 패키지 저장소를 보존하고, 메타 패키지에 다른 이름을 가지도록 하는 것이지만, 이는 혼란을 야기할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e모노레포로 전환\u003c/strong\u003e 하는 것은 일부 프로젝트에게는 상당한 변화일 수 있으며, 도구들이 기본적으로 단일 저장소가 단일 패키지에 해당한다고 가정하는 것은 드문 일이 아닙니다. 비록 이러한 도구들이 모노레포와 작동하도록 구성될 수 있지만, 이는 관리자에게 추가적인 부담입니다. 또한, 주 패키지가 모노레포 내의 하위 디렉토리로 이동되는 경우, 예를 들어 저장소 URL에서 패키지를 \u003ccode\u003epip install\u003c/code\u003e하는 모든 사용자는 이를 하위 디렉토리에서 설치하도록 조정해야 하며 (저장소 URL에 \u003ccode\u003esubdirectory=\u003c/code\u003e 추가), 이전 레이아웃을 가정하는 기존 워크플로우는 작동하지 않게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5\u003e최소 패키지에 의존 (Depending on the minimal package)\u003c/h5\u003e\n\u003cp\u003e분할이 이루어진 첫 번째 버전보다 오래된 패키지 버전에 의존해야 하는 패키지는 최소 패키지에 쉽게 의존할 수 없을 것입니다. 이 PEP의 주요 제안에서는 다운스트림 사용자가 예를 들어 \u003ccode\u003epackage[]\u003eversion\u003c/code\u003e에 의존할 수 있지만 (여기서 \u003ccode\u003eversion\u003c/code\u003e은 \u003ccode\u003edefault extras\u003c/code\u003e 도입 이전의 버전), 분할 접근 방식으로는 다운스트림 사용자가 예를 들어 \u003ccode\u003epackage-core\u003eversion\u003c/code\u003e에 의존할 수 없을 것입니다. 왜냐하면 \u003ccode\u003epackage-core\u003c/code\u003e는 이전에 존재하지 않았기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이에 대한 가능한 해결책은 개발자가 패키지의 모든 이전 버전에 대해 no-op 메타데이터 패키지를 출시하는 것이지만, 이는 관리자에게 상당한 추가 부담입니다.\u003c/p\u003e\n\u003ch5\u003e제거 (Uninstallation)\u003c/h5\u003e\n\u003cp\u003e\"패키지 이름과 모듈 이름 불일치\"에서 이름 지정 문제를 언급할 때 암시했듯이, 패키지 제거는 사용자가 예상하는 방식으로 더 이상 작동하지 않을 것입니다. 사용자가 다음을 실행하면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip uninstall package\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epackage-core\u003c/code\u003e가 여전히 남아 있겠지만, 사용자는 이를 깨닫지 못할 수 있습니다. 이는 혼란스러울 뿐만 아니라, 실제로는 많은 기존 워크플로우에 영향을 미칠 수 있는 호환성을 깨는 변경(breaking change)입니다.\u003c/p\u003e\n\u003ch5\u003e패키지 배포판 (Package distributions)\u003c/h5\u003e\n\u003cp\u003e하나 대신 두 개의 패키지를 가지는 것은 단순히 하나 대신 두 개의 패키지가 릴리스되어야 한다는 사실 때문에 패키지 배포판의 장기 유지보수 비용을 증가시킬 것이며, 어떤 경우에는 각 릴리스마다 추가적인 수작업을 초래할 것입니다.\u003c/p\u003e\n\u003ch5\u003e메타데이터 동기화 (Synchronizing metadata)\u003c/h5\u003e\n\u003cp\u003e주요 패키지와 메타 패키지 간에 동기화 상태를 유지하는 것이 중요한 주요 메타데이터는 버전입니다. 코어 패키지의 새 릴리스가 있을 때마다 메타 패키지는 버전이 업데이트되어야 하며, 의존성 섹션의 코어 패키지에 대한 버전 고정(version pinning)도 업데이트되어야 합니다.\u003c/p\u003e\n\u003cp\u003e또한, 코어 패키지에 정의된 모든 \u003ccode\u003eextras\u003c/code\u003e는 메타 패키지에서 재정의되고 동기화 상태를 유지해야 합니다. 예를 들어, \u003ccode\u003epackage\u003c/code\u003e가 \u003ccode\u003eadditional\u003c/code\u003e \u003ccode\u003eextra\u003c/code\u003e를 정의하는 경우, 사용자는 여전히 \u003ccode\u003epackage[additional]\u003c/code\u003e를 설치할 수 있어야 하지만, \u003ccode\u003epackage-core\u003c/code\u003e 패키지를 설치하는 사용자도 \u003ccode\u003epackage-core[additional]\u003c/code\u003e를 수행할 수 있는 옵션이 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e동기화해야 할 다른 메타데이터에는 예를 들어 작성자 정보 및 프로젝트 URL이 포함됩니다.\u003c/p\u003e\n\u003ch5\u003e요약 (Summary)\u003c/h5\u003e\n\u003cp\u003e전반적으로, 이 해결책은 초기 설정 및 전환(이는 이미 대규모 기존 프로젝트에는 엄청난 부담이 될 수 있음)뿐만 아니라 장기 유지보수 측면에서도 상당히 높은 유지보수 부담을 의미할 것입니다. 이는 또한 사용자 워크플로우를 깨뜨릴 가능성도 있습니다 (특히 저장소 문제 및 제거와 관련하여). 이러한 모든 이유로, 이 PEP의 현재 제안에 대한 설득력 있는 대안으로 간주하지 않습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eextras\u003c/code\u003e 선택 해제를 위한 구문 (Syntax for deselecting extras)\u003c/h4\u003e\n\u003cp\u003e주요 경쟁 접근 방식 중 하나는 다음과 같았습니다. 어떤 \u003ccode\u003eextras\u003c/code\u003e라도 명시적으로 제공되면 기본값이 선택 해제되는 대신, 기본 \u003ccode\u003eextras\u003c/code\u003e는 명시적으로 선택 해제되어야 한다는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 그림에서 \u003ccode\u003eextras\u003c/code\u003e 선택 해제를 위한 새로운 구문이 PEP 508에 정의된 미니 언어의 확장으로 도입될 것입니다. 패키지가 \u003ccode\u003edefault extras\u003c/code\u003e를 정의하는 경우, 사용자는 \u003ccode\u003eextra\u003c/code\u003e 이름 앞에 마이너스 부호(\u003ccode\u003e-\u003c/code\u003e)를 사용하여 이러한 기본값에서 옵트아웃할 수 있습니다. 제안된 구문 업데이트는 다음과 같았을 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eextras_list = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 새로운 구문의 유효한 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage[-recommended]\r\npackage[-backend1, backend2]\r\npackage[pdf, -svg]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 이 접근 방식에는 두 가지 주요 문제가 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eextra\u003c/code\u003e와 그 부정된 버전이 동일한 의존성 명세에 모두 존재하는 경우 (예: \u003ccode\u003epackage[pdf, -pdf]\u003c/code\u003e) 또는 의존성 트리에 \u003ccode\u003epackage[pdf]\u003c/code\u003e와 \u003ccode\u003epackage[-pdf]\u003c/code\u003e가 모두 포함된 경우와 같은 모서리 사례를 해석하는 방법에 대한 여러 규칙을 정의해야 하며, 이러한 규칙은 사용자에게 직관적이지 않을 것입니다.\u003c/li\u003e\n\u003cli\u003e더 중요하게는, 이는 의존성 명세에 새로운 구문을 도입할 것입니다. 이는 어떤 패키지가 새 구문을 사용하여 의존성을 정의하면, 해당 패키지와 이에 의존하는 다른 모든 패키지가 기존 패키징 도구로 더 이상 설치될 수 없게 되어, 주요 하위 호환성 문제가 될 것임을 의미합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이러한 이유로 이 대안은 최종 제안에 포함되지 않았습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eextras_require\u003c/code\u003e에 특별 항목 추가 (Adding a special entry in extras_require)\u003c/h4\u003e\n\u003cp\u003e새로운 \u003ccode\u003eDefault-Extra\u003c/code\u003e 메타데이터 필드를 도입하는 대안으로 탐색된 잠재적인 해결책은 '특별한' 이름을 가진 \u003ccode\u003eextra\u003c/code\u003e를 활용하는 것이었습니다.\u003c/p\u003e\n\u003cp\u003e한 가지 예시는 빈 문자열을 사용하는 것이었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eProvides-Extra:\r\nRequires-Dist: numpy ; extra == ''\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 아이디어는 '빈' \u003ccode\u003eextras\u003c/code\u003e의 일부로 설치되는 의존성이 다른 \u003ccode\u003eextra\u003c/code\u003e가 지정되지 않은 경우에만 설치된다는 것이었습니다. 이에 대한 구현이 \u003ca href=\"https://github.com/pypa/setuptools/pull/1503\"\u003ehttps://github.com/pypa/setuptools/pull/1503\u003c/a\u003e에서 제안되었지만, 기존 사용과의 호환성을 깨뜨리지 않고는 작동시킬 방법이 없다는 것이 밝혀졌습니다. 예를 들어, \u003ccode\u003esetup.py\u003c/code\u003e 파일을 통해 \u003ccode\u003eSetuptools\u003c/code\u003e를 사용하는 패키지는 다음을 수행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esetup(\r\n    ...\r\n    extras_require={'': ['package_a']},\r\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 유효하며 \u003ccode\u003epackage_a\u003c/code\u003e가 \u003ccode\u003einstall_requires\u003c/code\u003e에 정의된 것과 동일하므로, 빈 문자열의 의미를 변경하면 호환성이 깨집니다.\u003c/p\u003e\n\u003cp\u003e또한, 다른 어떤 문자열(예: \u003ccode\u003e'default'\u003c/code\u003e)도 특별한 문자열로 사용될 수 없습니다. 왜냐하면 하위 호환 가능한 유효한 \u003ccode\u003eextra\u003c/code\u003e 이름이 될 모든 문자열은 이미 기존 패키지에서 사용되고 있을 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e특별한 \u003ccode\u003eNone\u003c/code\u003e Python 변수를 사용하는 제안도 있었지만, 다시 말하지만 이는 불가능합니다. \u003ccode\u003esetup.py\u003c/code\u003e 파일에서는 \u003ccode\u003eNone\u003c/code\u003e을 사용할 수 있지만, \u003ccode\u003esetup.cfg\u003c/code\u003e나 \u003ccode\u003epyproject.toml\u003c/code\u003e과 같은 선언형 파일에서는 불가능하며, 더 나아가 \u003ccode\u003eextras\u003c/code\u003e 이름은 궁극적으로 패키지 메타데이터에서 문자열로 변환되어야 합니다. 다음이 있는 경우:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eProvides-Extra: None\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 이미 Python 패키지에서 \u003ccode\u003eextra\u003c/code\u003e 이름으로 사용될 수 있는 문자열 \u003ccode\u003e'None'\u003c/code\u003e과 구별할 수 없을 것입니다. 만약 문자열이 아닌 '특별한' \u003ccode\u003eextras\u003c/code\u003e 이름을 허용하도록 코어 메타데이터 구문을 수정한다면, 코어 메타데이터 명세를 수정하는 것으로 돌아가는 것이므로, \u003ccode\u003eDefault-Extra\u003c/code\u003e를 도입하는 것보다 나을 것이 없습니다.\u003c/p\u003e\n\u003ch4\u003e도구에 의존하여 기본 \u003ccode\u003eextras\u003c/code\u003e 선택 해제 (Relying on tooling to deselect any default extras)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eextras\u003c/code\u003e를 선택 해제하는 또 다른 옵션은 패키징 도구 수준에서 이를 구현하는 것이었습니다. 예를 들어, \u003ccode\u003epip\u003c/code\u003e는 다음과 같은 옵션을 포함할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install package --no-default-extras\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 옵션은 \u003ccode\u003e--no-binary\u003c/code\u003e 옵션과 유사하게 모든 패키지 또는 특정 패키지에 적용될 수 있습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ pip install package --no-default-extras :all:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 접근 방식의 장점은 \u003ccode\u003edefault extras\u003c/code\u003e를 지원하는 도구가 \u003ccode\u003eextras\u003c/code\u003e를 선택 해제하는 것도 지원할 수 있다는 것입니다. 이 접근 방식은 \u003ccode\u003eapt\u003c/code\u003e 도구의 \u003ccode\u003e--no-install-recommends\u003c/code\u003e 옵션과 유사할 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 이 해결책은 그 자체로 이상적이지 않습니다. 왜냐하면 패키지가 자체적으로 특정 의존성의 \u003ccode\u003edefault extras\u003c/code\u003e가 필요하지 않다고 지정하는 것을 허용하지 않기 때문입니다. 또한 대규모 의존성 트리에서 모든 \u003ccode\u003edefault extras\u003c/code\u003e를 비활성화할 수 있는 사용자에게 위험을 초래하여, 트리 내의 어느 지점에서든 \u003ccode\u003edefault extras\u003c/code\u003e에 의존하는 패키지를 손상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그럼에도 불구하고, 이 PEP는 이 접근 방식을 금지하지 않으며, 이러한 종류의 옵션을 지원할지 여부는 다양한 패키징 도구의 관리자에게 달려 있습니다. 이는 최소한 의존성 트리에서 \u003ccode\u003edefault extras\u003c/code\u003e가 의존하는 지점을 식별하려는 패키지 관리자에게 유용할 수 있는 플래그입니다. 그러나 지원되는 경우, 이 플래그를 사용하는 것이 기능적인 환경을 보장하지 않는다는 점을 명확히 해야 합니다.\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 라이선스 하에 배포됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1962,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Draft] PEP 771 - Default Extras for Python Software Packages\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 13:52:58+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/770/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Accepted] PEP 770 - Improving measurability of Python packages with Software Bill-of-Materials\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Draft] PEP 771 - Default Extras for Python Software Packages\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/772/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Draft] PEP 772 - Packaging Council governance process\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>