<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 698 - Override Decorator for Static Typing</h1><div class="page__meta"><time dateTime="2025-09-27 13:05:19+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0698/">PEP 698 - Override Decorator for Static Typing</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 05-Sep-2022</p>
</blockquote>
<h1>PEP 698 – 정적 타이핑을 위한 Override 데코레이터</h1>
<h2>초록 (Abstract)</h2>
<p>이 PEP는 Python 타입 시스템에 <code>@override</code> 데코레이터를 추가할 것을 제안합니다. 이 데코레이터를 통해 타입 검사기는(type checkers) 기본 클래스(base class)가 파생 클래스(derived class)에 의해 상속되는 메서드를 변경할 때 발생하는 버그를 방지할 수 있습니다.</p>
<h2>동기 (Motivation)</h2>
<p>타입 검사기의 주요 목적은 리팩터링(refactoring)이나 변경 사항이 코드 내의 기존 의미론적 구조를 깨뜨릴 때 플래그를 지정하여, 사용자가 코드에 대한 수동 감사(manual audit) 없이도 프로젝트 전체에서 문제를 식별하고 수정할 수 있도록 돕는 것입니다.</p>
<h3>안전한 리팩터링 (Safe Refactoring)</h3>
<p>Python의 타입 시스템은 오버라이드된 함수(overridden function)의 API가 변경될 때 일관성을 유지하기 위해 변경해야 할 호출 지점(call sites)을 식별하는 방법을 제공하지 않습니다. 이로 인해 코드 리팩터링 및 변환이 더 위험해집니다.</p>
<p>다음의 간단한 상속 구조를 고려해봅시다.</p>
<pre><code class="language-python">class Parent:
    def foo(self, x: int) -> int:
        return x

class Child(Parent):
    def foo(self, x: int) -> int:
        return x + 1

def parent_callsite(parent: Parent) -> None:
    parent.foo(1)

def child_callsite(child: Child) -> None:
    child.foo(1)
</code></pre>
<p>만약 슈퍼클래스(superclass)의 오버라이드된 메서드 이름이 바뀌거나 삭제되면, 타입 검사기는 기본 타입(base type)을 직접 다루는 호출 지점만 업데이트하라고 알려줄 것입니다. 그러나 타입 검사기는 우리가 변경한 내용을 볼 수 없고 새로운 코드만 볼 수 있으므로, 자식 클래스(child classes)에서도 동일한 메서드 이름을 변경해야 한다는 것을 알 수 있는 방법이 없습니다.</p>
<p>다음 코드는 버그를 유발할 가능성이 있지만, 타입 검사기는 이를 문제없이 수용할 것입니다.</p>
<pre><code class="language-python">class Parent:
    # 이 메서드 이름을 변경
    def new_foo(self, x: int) -> int:
        return x

class Child(Parent):
    # 이 (변경되지 않은) 메서드는 `foo`를 오버라이드했지만 `new_foo`와는 무관함
    def foo(self, x: int) -> int:
        return x + 1

def parent_callsite(parent: Parent) -> None:
    # Child 인스턴스를 전달하면 이제 Parent.new_foo가 실행됨 - 아마도 버그
    parent.new_foo(1)

def child_callsite(child: Child) -> None:
    # 여기서는 아마도 new_foo를 호출하려 했을 것임. 대신 메서드가 분기됨
    child.foo(1)
</code></pre>
<p>이 코드는 타입 검사를 통과하지만, 두 가지 잠재적인 버그의 원인이 있습니다.</p>
<ol>
<li><code>Child</code> 인스턴스를 <code>parent_callsite</code> 함수에 전달하면, <code>Child.foo</code> 대신 <code>Parent.new_foo</code>의 구현이 호출됩니다. 이는 아마도 버그일 것입니다. 커스텀 동작이 필요 없었다면 애초에 <code>Child.foo</code>를 작성하지 않았을 것이기 때문입니다. 우리의 시스템은 <code>Child.foo</code>가 <code>Parent.foo</code>와 유사하게 동작할 것이라고 의존하고 있었을 것입니다.</li>
<li>이 문제를 조기에 발견하지 못하면 메서드가 분기(fork)되고, 미래의 리팩터링에서는 <code>new_foo</code>의 주요 변경 사항이 <code>Child.foo</code>도 업데이트해야 한다는 것을 아무도 깨닫지 못하여 나중에 큰 버그로 이어질 수 있습니다.</li>
</ol>
<p>잘못 리팩터링된 코드는 타입-안전(type-safe)하지만, 우리가 의도한 바가 아닐 수 있으며 시스템이 잘못 동작하게 할 수 있습니다. 이 버그는 새로운 코드가 예외를 발생시키지 않고 실행될 가능성이 높기 때문에 추적하기 어려울 수 있습니다. 테스트는 문제를 발견할 가능성이 적으며, 사일런트 오류(silent errors)는 프로덕션 환경에서 추적하는 데 더 오랜 시간이 걸릴 수 있습니다.</p>
<p>이러한 잘못된 리팩터링으로 인해 여러 타입 지정 코드베이스에서 생산 중단(production outages)이 발생한 사례가 있습니다. 이것이 타입 시스템에 <code>@override</code> 데코레이터를 추가하는 주된 동기이며, 이를 통해 개발자는 <code>Parent.foo</code>와 <code>Child.foo</code> 간의 관계를 표현하여 타입 검사기가 문제를 감지할 수 있도록 합니다.</p>
<h2>이론적 근거 (Rationale)</h2>
<h3>서브클래스 구현의 명확성 증가 (Subclass Implementations Become More Explicit)</h3>
<p>명시적인 오버라이드는 암시적인 오버라이드보다 익숙하지 않은 코드를 읽기 쉽게 만들 것이라고 믿습니다. <code>@override</code>를 사용하는 서브클래스의 구현을 읽는 개발자는 어떤 메서드가 일부 기본 클래스의 기능을 오버라이드하는지 즉시 확인할 수 있습니다. 이 데코레이터가 없으면, 이를 빠르게 알아내는 유일한 방법은 정적 분석 도구(static analysis tool)를 사용하는 것입니다.</p>
<h3>다른 언어 및 런타임 라이브러리의 선례 (Precedent in Other Languages and Runtime Libraries)</h3>
<h4>다른 언어의 정적 오버라이드 검사 (Static Override Checks in Other Languages)</h4>
<p>많은 인기 있는 프로그래밍 언어가 오버라이드 검사를 지원합니다. 예를 들면 다음과 같습니다.</p>
<ul>
<li>C++: <code>override</code></li>
<li>C#: <code>override</code></li>
<li>Hack: <code>&#x3C;&#x3C;__Override>></code></li>
<li>Java: <code>@Override</code></li>
<li>Kotlin: <code>override</code></li>
<li>Scala: <code>override</code></li>
<li>Swift: <code>override</code></li>
<li>TypeScript: <code>override</code></li>
</ul>
<h4>Python의 런타임 오버라이드 검사 (Runtime Override Checks in Python)</h4>
<p>현재 <code>@overrides</code> (주의: 원문에는 <code>[sic]</code>으로 표기되어 있으나, 라이브러리 이름은 <code>overrides</code>로 명시됨) 및 <code>@final</code> 데코레이터를 제공하고 런타임에 이를 강제하는 Overrides 라이브러리가 있습니다.</p>
<p>PEP 591은 Overrides 라이브러리와 동일한 의미론을 가진 <code>@final</code> 데코레이터를 추가했습니다. 그러나 런타임 라이브러리의 오버라이드 구성 요소는 정적으로 전혀 지원되지 않아, 혼합/일치 지원(mix/matched support)에 대한 혼란을 가중시켰습니다.</p>
<p>정적 검사에서 <code>@override</code>에 대한 지원을 제공하는 것은 다음과 같은 이유로 가치를 더할 것입니다.</p>
<ul>
<li>버그를 더 일찍, 종종 에디터 내에서 잡을 수 있습니다.</li>
<li>정적 검사는 런타임 검사와 달리 성능 오버헤드(performance overhead)가 없습니다.</li>
<li>자동화된 테스트 없이는 감지되지 않을 수 있는, 거의 사용되지 않는 모듈에서도 버그가 빠르게 잡힐 것입니다.</li>
</ul>
<h3>단점 (Disadvantages)</h3>
<p><code>@override</code>를 사용하면 코드가 더 장황해질 수 있습니다 (more verbose).</p>
<h2>명세 (Specification)</h2>
<p>타입 검사기는 <code>@typing.override</code>로 데코레이트된 메서드를 만나면, 해당 메서드가 일부 조상 클래스(ancestor class)에서 호환되는 메서드나 속성(attribute)을 오버라이드하지 않는 한 타입 오류로 처리해야 합니다.</p>
<pre><code class="language-python">from typing import override

class Parent:
    def foo(self) -> int:
        return 1
    def bar(self, x: str) -> str:
        return x

class Child(Parent):
    @override
    def foo(self) -> int:
        return 2

    @override
    def baz(self) -> int:
        # 타입 검사 오류: 조상 클래스에 일치하는 시그니처가 없음
        return 1
</code></pre>
<p><code>@override</code> 데코레이터는 타입 검사기가 메서드를 유효한 오버라이드로 간주하는 모든 곳에서 허용되어야 하며, 이는 일반적으로 일반 메서드뿐만 아니라 <code>@property</code>, <code>@staticmethod</code>, <code>@classmethod</code>도 포함합니다.</p>
<h3>오버라이드 호환성에 대한 새로운 규칙 없음 (No New Rules for Override Compatibility)</h3>
<p>이 PEP는 새로운 <code>@override</code> 데코레이터의 처리에만 전적으로 초점을 맞추며, 이는 데코레이트된 메서드가 조상 클래스의 일부 속성을 오버라이드해야 한다고 명시합니다. 이 PEP는 이러한 메서드의 타입 시그니처(type signatures)에 관한 새로운 규칙을 제안하지 않습니다.</p>
<h3>프로젝트별 엄격한 강제 (Strict Enforcement Per-Project)</h3>
<p><code>@override</code> 데코레이터는 검사기가 개발자에게 부모 클래스를 오버라이드하는 메서드에 데코레이터를 사용하도록 요구하는 엄격 모드(strict mode)를 선택할 수 있게 할 때 가장 유용하다고 믿습니다. 엄격한 강제는 하위 호환성을 위해 옵트인(opt-in)이어야 합니다.</p>
<h4>동기 (Motivation)</h4>
<p><code>@override</code>가 필요한 엄격 모드의 주된 이유는, 개발자들이 프로젝트 전체에서 <code>@override</code> 데코레이터가 사용된다는 것을 알 때만 리팩터링이 오버라이드-안전하다(override-safe)고 신뢰할 수 있기 때문입니다.</p>
<p>엄격 모드를 사용해야만 잡을 수 있는 오버라이드와 관련된 또 다른 종류의 버그가 있습니다.</p>
<p>다음 코드를 고려해봅시다.</p>
<pre><code class="language-python">class Parent:
    pass

class Child(Parent):
    def foo(self) -> int:
        return 2
</code></pre>
<p>이 코드를 다음과 같이 리팩터링했다고 상상해봅시다.</p>
<pre><code class="language-python">class Parent:
    def foo(self) -> int: # 이 메서드는 새로 추가됨
        return 1

class Child(Parent):
    def foo(self) -> int: # 이제 이것은 오버라이드임!
        return 2

def call_foo(parent: Parent) -> int:
    return parent.foo() # 이것은 Child.foo를 호출할 수 있으며, 이는 예상치 못한 동작일 수 있음.
</code></pre>
<p>여기서 코드의 의미론이 변경되었으며, 이는 두 가지 문제를 유발할 수 있습니다.</p>
<ol>
<li>코드 변경 작성자가 <code>Child.foo</code>가 이미 존재한다는 사실을 몰랐다면 (대규모 코드베이스에서는 매우 흔한 일), <code>call_foo</code>가 항상 <code>Parent.foo</code>를 호출하지 않는다는 것을 보고 놀랄 수 있습니다.</li>
<li>코드베이스 작성자가 서브클래스에서 오버라이드를 작성할 때 수동으로 모든 곳에 <code>@override</code>를 적용하려고 했다면, <code>Child.foo</code>가 <code>@override</code>를 필요로 한다는 사실을 놓칠 가능성이 높습니다.</li>
</ol>
<p>언뜻 보기에는 이러한 종류의 변경이 발생할 가능성이 낮아 보일 수 있지만, 하나 이상의 서브클래스에 개발자들이 나중에 기본 클래스에 속한다고 생각하는 기능이 있을 경우 실제로 자주 발생할 수 있습니다.</p>
<p>엄격 모드를 사용하면 이런 일이 발생할 때마다 개발자에게 항상 경고할 것입니다.</p>
<h4>선례 (Precedent)</h4>
<p>조사한 대부분의 타입 지정 객체 지향 프로그래밍 언어는 프로젝트 전체에서 명시적인 오버라이드를 요구하는 쉬운 방법을 가지고 있습니다.</p>
<ul>
<li>C#, Kotlin, Scala, Swift는 항상 명시적인 오버라이드를 요구합니다.</li>
<li>TypeScript는 명시적인 오버라이드를 강제하는 <code>--no-implicit-override</code> 플래그를 가지고 있습니다.</li>
<li>Hack과 Java에서는 타입 검사기가 항상 오버라이드를 옵트인으로 처리하지만, 널리 사용되는 린터(linters)는 명시적인 오버라이드가 누락되었을 경우 경고할 수 있습니다.</li>
</ul>
<h3>하위 호환성 (Backward Compatibility)</h3>
<p>기본적으로 <code>@override</code> 데코레이터는 옵트인(opt-in) 방식입니다. 이를 사용하지 않는 코드베이스는 추가적인 타입 안전성 없이 이전과 동일하게 타입 검사가 이루어집니다.</p>
<h3>런타임 동작 (Runtime Behavior)</h3>
<h4>가능한 경우 <code>__override__ = True</code> 설정 (Set <code>__override__ = True</code> when possible)</h4>
<p>런타임에 <code>@typing.override</code>는 인수에 <code>__override__</code> 속성(값 <code>True</code>)을 추가하기 위해 최선의 노력을 다할 것입니다. "최선의 노력(best-effort)"이란 속성을 추가하려고 시도하겠지만, 실패할 경우 (예를 들어 입력이 고정 슬롯(fixed slots)을 가진 디스크립터 타입(descriptor type)인 경우) 인수를 있는 그대로 반환할 것임을 의미합니다.</p>
<p>이는 <code>@typing.final</code> 데코레이터가 하는 것과 정확히 동일하며, 동기도 유사합니다. 이는 런타임 라이브러리가 <code>@override</code>를 사용할 수 있는 기능을 제공합니다. 구체적인 예로, 런타임 라이브러리는 <code>__override__</code>를 확인하여 부모 메서드 독스트링(docstring)을 사용하여 자식 클래스 메서드의 <code>__doc__</code> 속성을 자동으로 채울 수 있습니다.</p>
<h4><code>__override__</code> 설정의 한계 (Limitations of setting <code>__override__</code>)</h4>
<p>위에서 설명했듯이, <code>__override__</code> 추가는 런타임에 실패할 수 있으며, 이 경우 인수를 있는 그대로 반환할 것입니다.</p>
<p>또한, 작동하는 경우에도 여러 데코레이터와 올바르게 작업하는 것이 사용자에게 어려울 수 있습니다. 최종 출력에 <code>__override__</code> 속성이 성공적으로 설정되도록 하려면 각 데코레이터의 구현을 이해해야 하기 때문입니다.</p>
<ul>
<li><code>@override</code> 데코레이터는 <code>functools.lru_cache</code>와 같이 래퍼 함수(wrapper functions)를 사용하는 일반 데코레이터보다 나중에 실행되어야 합니다. 가장 바깥쪽 래퍼에 <code>__override__</code>를 설정하기 위함입니다. 즉, 다른 모든 데코레이터 위에 위치해야 합니다.</li>
<li>그러나 <code>@override</code>는 <code>@property</code>, <code>@staticmethod</code>, <code>@classmethod</code>와 같은 많은 특수 디스크립터 기반 데코레이터보다 먼저 실행되어야 합니다. 위에서 논의했듯이, 어떤 경우에는 (예: 고정 슬롯이 있는 디스크립터 또는 래핑(wrap)하는 디스크립터) <code>__override__</code> 속성을 전혀 설정할 수 없을 수도 있습니다.</li>
</ul>
<p>결과적으로 <code>__override__</code> 설정에 대한 런타임 지원은 최선 노력(best effort)에 불과하며, 타입 검사기가 데코레이터의 순서를 검증할 것이라고는 예상하지 않습니다.</p>
<h2>거부된 대안 (Rejected Alternatives)</h2>
<h3>안전을 위해 통합 개발 환경(IDE)에 의존 (Rely on Integrated Development Environments for safety)</h3>
<p>최신 IDE는 메서드 이름을 변경할 때 서브클래스를 자동으로 업데이트하는 기능을 제공합니다. 그러나 이는 여러 가지 이유로 불충분하다고 봅니다.</p>
<ul>
<li>코드베이스가 여러 프로젝트로 분할된 경우, IDE는 도움이 되지 않으며 의존성(dependencies)을 업그레이드할 때 버그가 나타납니다. 타입 검사기는 의존성에서 발생하는 파괴적인 변경 사항(breaking changes)을 빠르게 잡는 방법입니다.</li>
<li>모든 개발자가 이러한 IDE를 사용하는 것은 아닙니다. 그리고 라이브러리 유지보수자(maintainers)는 IDE를 사용하더라도 풀 리퀘스트(pull request) 작성자가 동일한 IDE를 사용한다고 가정할 필요가 없습니다. 우리는 개발자의 편집기 선택에 대해 아무것도 가정하지 않고 지속적 통합(continuous integration)에서 문제를 감지할 수 있는 것을 선호합니다.</li>
</ul>
<h3>런타임 강제 (Runtime enforcement)</h3>
<p><code>@overrides.overrides</code>가 오늘날 하는 방식과 유사하게 <code>@typing.override</code>가 런타임에 오버라이드 안전성을 강제하도록 하는 방안을 고려했습니다.</p>
<p>이는 네 가지 이유로 거부되었습니다.</p>
<ol>
<li>정적 타입 검사를 사용하는 사용자에게는 이것이 어떤 이점을 가져다줄지 명확하지 않습니다.</li>
<li>최소한의 성능 오버헤드가 발생하여 런타임 강제로 인해 프로젝트 가져오기(import)가 느려질 수 있습니다. <code>@overrides.overrides</code> 구현은 약 100 마이크로초가 걸리며, 이는 빠르지만 백만 줄 이상의 코드베이스에서는 1초 이상 추가 초기화 시간이 될 수 있습니다. 이는 <code>@typing.override</code>가 가장 유용할 것이라고 생각하는 바로 그 지점입니다.</li>
<li>구현에 잘 작동하지 않는 엣지 케이스(edge cases)가 있을 수 있습니다 (이러한 클로즈드 소스 라이브러리 중 하나의 유지보수자로부터 이것이 문제였다는 이야기를 들었습니다). 우리는 정적 강제가 간단하고 신뢰할 수 있을 것이라고 예상합니다.</li>
<li>우리가 아는 구현 접근 방식은 간단하지 않습니다. 데코레이터는 클래스 평가가 완료되기 전에 실행되므로, 우리가 아는 옵션은 호출자의 바이트코드(bytecode)를 검사하거나 (Overrides 라이브러리가 하는 방식) 메타클래스(metaclass) 기반 접근 방식을 사용하는 것입니다. 어느 쪽도 이상적으로 보이지 않습니다.</li>
</ol>
<h3>서브클래스에 명시적 오버라이드를 강제하기 위해 기본 클래스 표시 (Mark a base class to force explicit overrides on subclasses)</h3>
<p>클래스 데코레이터 <code>@require_explicit_overrides</code>를 포함하는 방안을 고려했습니다. 이는 기본 클래스가 모든 서브클래스가 메서드 오버라이드에 <code>@override</code> 데코레이터를 사용해야 한다고 선언하는 방법을 제공했을 것입니다. Overrides 라이브러리에는 런타임 검사에서 유사한 동작을 제공하는 믹스인 클래스(mixin class) <code>EnforceExplicitOverrides</code>가 있습니다.</p>
<p>이 제안은 대규모 코드베이스의 소유자가 <code>@override</code>로부터 가장 큰 이점을 얻을 것이라고 예상하며, 이러한 사용 사례에서는 명시적인 <code>@override</code>가 요구되는 엄격 모드(Strict Enforcement Per-Project 섹션 참조)가 기본 클래스를 표시하는 방법보다 더 많은 이점을 제공하기 때문에 채택되지 않았습니다.</p>
<p>또한, 추가적인 타입 안전성이 <code>@override</code> 사용의 추가적인 상용구(boilerplate) 가치가 없다고 생각하는 프로젝트 작성자는 그렇게 하도록 강요되어서는 안 된다고 믿습니다. 선택적 엄격 모드는 프로젝트 소유자의 결정에 맡기는 반면, 라이브러리에서 <code>@require_explicit_overrides</code>를 사용하면 프로젝트 소유자가 원하지 않더라도 <code>@override</code>를 사용하도록 강요하게 됩니다.</p>
<h3>오버라이드되는 조상 클래스 이름 포함 (Include the name of the ancestor class being overridden)</h3>
<p><code>@override</code> 호출자가 오버라이드되는 메서드가 정의되어야 하는 특정 조상 클래스를 지정할 수 있도록 하는 방안을 고려했습니다.</p>
<pre><code class="language-python">class Parent0:
    def foo(self) -> int:
        return 1
class Parent1:
    def bar(self) -> int:
        return 1

class Child(Parent0, Parent1):
    @override(Parent0) # 괜찮음, Parent0이 foo를 정의함
    def foo(self) -> int:
        return 2

    @override(Parent0) # 타입 오류, Parent0이 bar를 정의하지 않음
    def bar(self) -> int:
        return 2
</code></pre>
<p>이는 깊은 상속 트리(deep inheritance trees)에서 오버라이드 구조를 더 명확하게 해주기 때문에 코드 가독성에 유용할 수 있습니다. 또한, 오버라이드되는 메서드가 한 기본 클래스에서 다른 기본 클래스로 이동할 때마다 개발자가 오버라이드 구현이 여전히 의미 있는지 확인하도록 유도하여 버그를 잡을 수도 있습니다.</p>
<p>다음과 같은 이유로 이 제안은 채택되지 않았습니다.</p>
<ul>
<li>이를 지원하면 <code>@override</code> 자체와 이를 위한 타입 검사기 지원의 구현 복잡성이 증가하므로, 상당한 이점이 있어야 했습니다. 우리는 이것이 거의 사용되지 않고 상대적으로 적은 버그를 잡을 것이라고 믿습니다.</li>
<li>Overrides 패키지의 작성자는 초기 버전의 라이브러리에 이 기능이 포함되어 있었지만 거의 유용하지 않았고 이점이 거의 없었다고 언급했습니다. 제거된 후에는 사용자로부터 이 기능에 대한 요청이 없었습니다.</li>
</ul>
<h2>참조 구현 (Reference Implementation)</h2>
<p>Pyre에서 개념 증명(proof of concept)이 구현되었습니다.</p>
<ul>
<li><code>@pyre_extensions.override</code> 데코레이터는 오버라이드를 표시할 수 있습니다.</li>
<li>Pyre는 이 PEP에 명시된 대로 이 데코레이터를 타입 검사할 수 있습니다.</li>
</ul>
<hr>
<p><strong>중요</strong>: 이 PEP는 역사적인 문서입니다. 최신 사양 및 문서는 <code>@override</code> 및 <code>@typing.override</code>를 참조하십시오. 표준 타이핑 사양은 <a href="https://typing.readthedocs.io/en/latest/">typing specs site</a>에서 유지 관리되며, 런타임 타이핑 동작은 <a href="https://docs.python.org/3/library/typing.html">CPython documentation</a>에 설명되어 있습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/698\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/698/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/698\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"698\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/698\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T59c6,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0698/\"\u003ePEP 698 - Override Decorator for Static Typing\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 05-Sep-2022\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 698 – 정적 타이핑을 위한 Override 데코레이터\u003c/h1\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 Python 타입 시스템에 \u003ccode\u003e@override\u003c/code\u003e 데코레이터를 추가할 것을 제안합니다. 이 데코레이터를 통해 타입 검사기는(type checkers) 기본 클래스(base class)가 파생 클래스(derived class)에 의해 상속되는 메서드를 변경할 때 발생하는 버그를 방지할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e타입 검사기의 주요 목적은 리팩터링(refactoring)이나 변경 사항이 코드 내의 기존 의미론적 구조를 깨뜨릴 때 플래그를 지정하여, 사용자가 코드에 대한 수동 감사(manual audit) 없이도 프로젝트 전체에서 문제를 식별하고 수정할 수 있도록 돕는 것입니다.\u003c/p\u003e\n\u003ch3\u003e안전한 리팩터링 (Safe Refactoring)\u003c/h3\u003e\n\u003cp\u003ePython의 타입 시스템은 오버라이드된 함수(overridden function)의 API가 변경될 때 일관성을 유지하기 위해 변경해야 할 호출 지점(call sites)을 식별하는 방법을 제공하지 않습니다. 이로 인해 코드 리팩터링 및 변환이 더 위험해집니다.\u003c/p\u003e\n\u003cp\u003e다음의 간단한 상속 구조를 고려해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Parent:\n    def foo(self, x: int) -\u003e int:\n        return x\n\nclass Child(Parent):\n    def foo(self, x: int) -\u003e int:\n        return x + 1\n\ndef parent_callsite(parent: Parent) -\u003e None:\n    parent.foo(1)\n\ndef child_callsite(child: Child) -\u003e None:\n    child.foo(1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 슈퍼클래스(superclass)의 오버라이드된 메서드 이름이 바뀌거나 삭제되면, 타입 검사기는 기본 타입(base type)을 직접 다루는 호출 지점만 업데이트하라고 알려줄 것입니다. 그러나 타입 검사기는 우리가 변경한 내용을 볼 수 없고 새로운 코드만 볼 수 있으므로, 자식 클래스(child classes)에서도 동일한 메서드 이름을 변경해야 한다는 것을 알 수 있는 방법이 없습니다.\u003c/p\u003e\n\u003cp\u003e다음 코드는 버그를 유발할 가능성이 있지만, 타입 검사기는 이를 문제없이 수용할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Parent:\n    # 이 메서드 이름을 변경\n    def new_foo(self, x: int) -\u003e int:\n        return x\n\nclass Child(Parent):\n    # 이 (변경되지 않은) 메서드는 `foo`를 오버라이드했지만 `new_foo`와는 무관함\n    def foo(self, x: int) -\u003e int:\n        return x + 1\n\ndef parent_callsite(parent: Parent) -\u003e None:\n    # Child 인스턴스를 전달하면 이제 Parent.new_foo가 실행됨 - 아마도 버그\n    parent.new_foo(1)\n\ndef child_callsite(child: Child) -\u003e None:\n    # 여기서는 아마도 new_foo를 호출하려 했을 것임. 대신 메서드가 분기됨\n    child.foo(1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 타입 검사를 통과하지만, 두 가지 잠재적인 버그의 원인이 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eChild\u003c/code\u003e 인스턴스를 \u003ccode\u003eparent_callsite\u003c/code\u003e 함수에 전달하면, \u003ccode\u003eChild.foo\u003c/code\u003e 대신 \u003ccode\u003eParent.new_foo\u003c/code\u003e의 구현이 호출됩니다. 이는 아마도 버그일 것입니다. 커스텀 동작이 필요 없었다면 애초에 \u003ccode\u003eChild.foo\u003c/code\u003e를 작성하지 않았을 것이기 때문입니다. 우리의 시스템은 \u003ccode\u003eChild.foo\u003c/code\u003e가 \u003ccode\u003eParent.foo\u003c/code\u003e와 유사하게 동작할 것이라고 의존하고 있었을 것입니다.\u003c/li\u003e\n\u003cli\u003e이 문제를 조기에 발견하지 못하면 메서드가 분기(fork)되고, 미래의 리팩터링에서는 \u003ccode\u003enew_foo\u003c/code\u003e의 주요 변경 사항이 \u003ccode\u003eChild.foo\u003c/code\u003e도 업데이트해야 한다는 것을 아무도 깨닫지 못하여 나중에 큰 버그로 이어질 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e잘못 리팩터링된 코드는 타입-안전(type-safe)하지만, 우리가 의도한 바가 아닐 수 있으며 시스템이 잘못 동작하게 할 수 있습니다. 이 버그는 새로운 코드가 예외를 발생시키지 않고 실행될 가능성이 높기 때문에 추적하기 어려울 수 있습니다. 테스트는 문제를 발견할 가능성이 적으며, 사일런트 오류(silent errors)는 프로덕션 환경에서 추적하는 데 더 오랜 시간이 걸릴 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 잘못된 리팩터링으로 인해 여러 타입 지정 코드베이스에서 생산 중단(production outages)이 발생한 사례가 있습니다. 이것이 타입 시스템에 \u003ccode\u003e@override\u003c/code\u003e 데코레이터를 추가하는 주된 동기이며, 이를 통해 개발자는 \u003ccode\u003eParent.foo\u003c/code\u003e와 \u003ccode\u003eChild.foo\u003c/code\u003e 간의 관계를 표현하여 타입 검사기가 문제를 감지할 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003e이론적 근거 (Rationale)\u003c/h2\u003e\n\u003ch3\u003e서브클래스 구현의 명확성 증가 (Subclass Implementations Become More Explicit)\u003c/h3\u003e\n\u003cp\u003e명시적인 오버라이드는 암시적인 오버라이드보다 익숙하지 않은 코드를 읽기 쉽게 만들 것이라고 믿습니다. \u003ccode\u003e@override\u003c/code\u003e를 사용하는 서브클래스의 구현을 읽는 개발자는 어떤 메서드가 일부 기본 클래스의 기능을 오버라이드하는지 즉시 확인할 수 있습니다. 이 데코레이터가 없으면, 이를 빠르게 알아내는 유일한 방법은 정적 분석 도구(static analysis tool)를 사용하는 것입니다.\u003c/p\u003e\n\u003ch3\u003e다른 언어 및 런타임 라이브러리의 선례 (Precedent in Other Languages and Runtime Libraries)\u003c/h3\u003e\n\u003ch4\u003e다른 언어의 정적 오버라이드 검사 (Static Override Checks in Other Languages)\u003c/h4\u003e\n\u003cp\u003e많은 인기 있는 프로그래밍 언어가 오버라이드 검사를 지원합니다. 예를 들면 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC++: \u003ccode\u003eoverride\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eC#: \u003ccode\u003eoverride\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eHack: \u003ccode\u003e\u0026#x3C;\u0026#x3C;__Override\u003e\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eJava: \u003ccode\u003e@Override\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eKotlin: \u003ccode\u003eoverride\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eScala: \u003ccode\u003eoverride\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSwift: \u003ccode\u003eoverride\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eTypeScript: \u003ccode\u003eoverride\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003ePython의 런타임 오버라이드 검사 (Runtime Override Checks in Python)\u003c/h4\u003e\n\u003cp\u003e현재 \u003ccode\u003e@overrides\u003c/code\u003e (주의: 원문에는 \u003ccode\u003e[sic]\u003c/code\u003e으로 표기되어 있으나, 라이브러리 이름은 \u003ccode\u003eoverrides\u003c/code\u003e로 명시됨) 및 \u003ccode\u003e@final\u003c/code\u003e 데코레이터를 제공하고 런타임에 이를 강제하는 Overrides 라이브러리가 있습니다.\u003c/p\u003e\n\u003cp\u003ePEP 591은 Overrides 라이브러리와 동일한 의미론을 가진 \u003ccode\u003e@final\u003c/code\u003e 데코레이터를 추가했습니다. 그러나 런타임 라이브러리의 오버라이드 구성 요소는 정적으로 전혀 지원되지 않아, 혼합/일치 지원(mix/matched support)에 대한 혼란을 가중시켰습니다.\u003c/p\u003e\n\u003cp\u003e정적 검사에서 \u003ccode\u003e@override\u003c/code\u003e에 대한 지원을 제공하는 것은 다음과 같은 이유로 가치를 더할 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e버그를 더 일찍, 종종 에디터 내에서 잡을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e정적 검사는 런타임 검사와 달리 성능 오버헤드(performance overhead)가 없습니다.\u003c/li\u003e\n\u003cli\u003e자동화된 테스트 없이는 감지되지 않을 수 있는, 거의 사용되지 않는 모듈에서도 버그가 빠르게 잡힐 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e단점 (Disadvantages)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e@override\u003c/code\u003e를 사용하면 코드가 더 장황해질 수 있습니다 (more verbose).\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003cp\u003e타입 검사기는 \u003ccode\u003e@typing.override\u003c/code\u003e로 데코레이트된 메서드를 만나면, 해당 메서드가 일부 조상 클래스(ancestor class)에서 호환되는 메서드나 속성(attribute)을 오버라이드하지 않는 한 타입 오류로 처리해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import override\n\nclass Parent:\n    def foo(self) -\u003e int:\n        return 1\n    def bar(self, x: str) -\u003e str:\n        return x\n\nclass Child(Parent):\n    @override\n    def foo(self) -\u003e int:\n        return 2\n\n    @override\n    def baz(self) -\u003e int:\n        # 타입 검사 오류: 조상 클래스에 일치하는 시그니처가 없음\n        return 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e@override\u003c/code\u003e 데코레이터는 타입 검사기가 메서드를 유효한 오버라이드로 간주하는 모든 곳에서 허용되어야 하며, 이는 일반적으로 일반 메서드뿐만 아니라 \u003ccode\u003e@property\u003c/code\u003e, \u003ccode\u003e@staticmethod\u003c/code\u003e, \u003ccode\u003e@classmethod\u003c/code\u003e도 포함합니다.\u003c/p\u003e\n\u003ch3\u003e오버라이드 호환성에 대한 새로운 규칙 없음 (No New Rules for Override Compatibility)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 새로운 \u003ccode\u003e@override\u003c/code\u003e 데코레이터의 처리에만 전적으로 초점을 맞추며, 이는 데코레이트된 메서드가 조상 클래스의 일부 속성을 오버라이드해야 한다고 명시합니다. 이 PEP는 이러한 메서드의 타입 시그니처(type signatures)에 관한 새로운 규칙을 제안하지 않습니다.\u003c/p\u003e\n\u003ch3\u003e프로젝트별 엄격한 강제 (Strict Enforcement Per-Project)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e@override\u003c/code\u003e 데코레이터는 검사기가 개발자에게 부모 클래스를 오버라이드하는 메서드에 데코레이터를 사용하도록 요구하는 엄격 모드(strict mode)를 선택할 수 있게 할 때 가장 유용하다고 믿습니다. 엄격한 강제는 하위 호환성을 위해 옵트인(opt-in)이어야 합니다.\u003c/p\u003e\n\u003ch4\u003e동기 (Motivation)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003e@override\u003c/code\u003e가 필요한 엄격 모드의 주된 이유는, 개발자들이 프로젝트 전체에서 \u003ccode\u003e@override\u003c/code\u003e 데코레이터가 사용된다는 것을 알 때만 리팩터링이 오버라이드-안전하다(override-safe)고 신뢰할 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e엄격 모드를 사용해야만 잡을 수 있는 오버라이드와 관련된 또 다른 종류의 버그가 있습니다.\u003c/p\u003e\n\u003cp\u003e다음 코드를 고려해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Parent:\n    pass\n\nclass Child(Parent):\n    def foo(self) -\u003e int:\n        return 2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드를 다음과 같이 리팩터링했다고 상상해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Parent:\n    def foo(self) -\u003e int: # 이 메서드는 새로 추가됨\n        return 1\n\nclass Child(Parent):\n    def foo(self) -\u003e int: # 이제 이것은 오버라이드임!\n        return 2\n\ndef call_foo(parent: Parent) -\u003e int:\n    return parent.foo() # 이것은 Child.foo를 호출할 수 있으며, 이는 예상치 못한 동작일 수 있음.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 코드의 의미론이 변경되었으며, 이는 두 가지 문제를 유발할 수 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e코드 변경 작성자가 \u003ccode\u003eChild.foo\u003c/code\u003e가 이미 존재한다는 사실을 몰랐다면 (대규모 코드베이스에서는 매우 흔한 일), \u003ccode\u003ecall_foo\u003c/code\u003e가 항상 \u003ccode\u003eParent.foo\u003c/code\u003e를 호출하지 않는다는 것을 보고 놀랄 수 있습니다.\u003c/li\u003e\n\u003cli\u003e코드베이스 작성자가 서브클래스에서 오버라이드를 작성할 때 수동으로 모든 곳에 \u003ccode\u003e@override\u003c/code\u003e를 적용하려고 했다면, \u003ccode\u003eChild.foo\u003c/code\u003e가 \u003ccode\u003e@override\u003c/code\u003e를 필요로 한다는 사실을 놓칠 가능성이 높습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e언뜻 보기에는 이러한 종류의 변경이 발생할 가능성이 낮아 보일 수 있지만, 하나 이상의 서브클래스에 개발자들이 나중에 기본 클래스에 속한다고 생각하는 기능이 있을 경우 실제로 자주 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e엄격 모드를 사용하면 이런 일이 발생할 때마다 개발자에게 항상 경고할 것입니다.\u003c/p\u003e\n\u003ch4\u003e선례 (Precedent)\u003c/h4\u003e\n\u003cp\u003e조사한 대부분의 타입 지정 객체 지향 프로그래밍 언어는 프로젝트 전체에서 명시적인 오버라이드를 요구하는 쉬운 방법을 가지고 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC#, Kotlin, Scala, Swift는 항상 명시적인 오버라이드를 요구합니다.\u003c/li\u003e\n\u003cli\u003eTypeScript는 명시적인 오버라이드를 강제하는 \u003ccode\u003e--no-implicit-override\u003c/code\u003e 플래그를 가지고 있습니다.\u003c/li\u003e\n\u003cli\u003eHack과 Java에서는 타입 검사기가 항상 오버라이드를 옵트인으로 처리하지만, 널리 사용되는 린터(linters)는 명시적인 오버라이드가 누락되었을 경우 경고할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e하위 호환성 (Backward Compatibility)\u003c/h3\u003e\n\u003cp\u003e기본적으로 \u003ccode\u003e@override\u003c/code\u003e 데코레이터는 옵트인(opt-in) 방식입니다. 이를 사용하지 않는 코드베이스는 추가적인 타입 안전성 없이 이전과 동일하게 타입 검사가 이루어집니다.\u003c/p\u003e\n\u003ch3\u003e런타임 동작 (Runtime Behavior)\u003c/h3\u003e\n\u003ch4\u003e가능한 경우 \u003ccode\u003e__override__ = True\u003c/code\u003e 설정 (Set \u003ccode\u003e__override__ = True\u003c/code\u003e when possible)\u003c/h4\u003e\n\u003cp\u003e런타임에 \u003ccode\u003e@typing.override\u003c/code\u003e는 인수에 \u003ccode\u003e__override__\u003c/code\u003e 속성(값 \u003ccode\u003eTrue\u003c/code\u003e)을 추가하기 위해 최선의 노력을 다할 것입니다. \"최선의 노력(best-effort)\"이란 속성을 추가하려고 시도하겠지만, 실패할 경우 (예를 들어 입력이 고정 슬롯(fixed slots)을 가진 디스크립터 타입(descriptor type)인 경우) 인수를 있는 그대로 반환할 것임을 의미합니다.\u003c/p\u003e\n\u003cp\u003e이는 \u003ccode\u003e@typing.final\u003c/code\u003e 데코레이터가 하는 것과 정확히 동일하며, 동기도 유사합니다. 이는 런타임 라이브러리가 \u003ccode\u003e@override\u003c/code\u003e를 사용할 수 있는 기능을 제공합니다. 구체적인 예로, 런타임 라이브러리는 \u003ccode\u003e__override__\u003c/code\u003e를 확인하여 부모 메서드 독스트링(docstring)을 사용하여 자식 클래스 메서드의 \u003ccode\u003e__doc__\u003c/code\u003e 속성을 자동으로 채울 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003e__override__\u003c/code\u003e 설정의 한계 (Limitations of setting \u003ccode\u003e__override__\u003c/code\u003e)\u003c/h4\u003e\n\u003cp\u003e위에서 설명했듯이, \u003ccode\u003e__override__\u003c/code\u003e 추가는 런타임에 실패할 수 있으며, 이 경우 인수를 있는 그대로 반환할 것입니다.\u003c/p\u003e\n\u003cp\u003e또한, 작동하는 경우에도 여러 데코레이터와 올바르게 작업하는 것이 사용자에게 어려울 수 있습니다. 최종 출력에 \u003ccode\u003e__override__\u003c/code\u003e 속성이 성공적으로 설정되도록 하려면 각 데코레이터의 구현을 이해해야 하기 때문입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e@override\u003c/code\u003e 데코레이터는 \u003ccode\u003efunctools.lru_cache\u003c/code\u003e와 같이 래퍼 함수(wrapper functions)를 사용하는 일반 데코레이터보다 나중에 실행되어야 합니다. 가장 바깥쪽 래퍼에 \u003ccode\u003e__override__\u003c/code\u003e를 설정하기 위함입니다. 즉, 다른 모든 데코레이터 위에 위치해야 합니다.\u003c/li\u003e\n\u003cli\u003e그러나 \u003ccode\u003e@override\u003c/code\u003e는 \u003ccode\u003e@property\u003c/code\u003e, \u003ccode\u003e@staticmethod\u003c/code\u003e, \u003ccode\u003e@classmethod\u003c/code\u003e와 같은 많은 특수 디스크립터 기반 데코레이터보다 먼저 실행되어야 합니다. 위에서 논의했듯이, 어떤 경우에는 (예: 고정 슬롯이 있는 디스크립터 또는 래핑(wrap)하는 디스크립터) \u003ccode\u003e__override__\u003c/code\u003e 속성을 전혀 설정할 수 없을 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e결과적으로 \u003ccode\u003e__override__\u003c/code\u003e 설정에 대한 런타임 지원은 최선 노력(best effort)에 불과하며, 타입 검사기가 데코레이터의 순서를 검증할 것이라고는 예상하지 않습니다.\u003c/p\u003e\n\u003ch2\u003e거부된 대안 (Rejected Alternatives)\u003c/h2\u003e\n\u003ch3\u003e안전을 위해 통합 개발 환경(IDE)에 의존 (Rely on Integrated Development Environments for safety)\u003c/h3\u003e\n\u003cp\u003e최신 IDE는 메서드 이름을 변경할 때 서브클래스를 자동으로 업데이트하는 기능을 제공합니다. 그러나 이는 여러 가지 이유로 불충분하다고 봅니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e코드베이스가 여러 프로젝트로 분할된 경우, IDE는 도움이 되지 않으며 의존성(dependencies)을 업그레이드할 때 버그가 나타납니다. 타입 검사기는 의존성에서 발생하는 파괴적인 변경 사항(breaking changes)을 빠르게 잡는 방법입니다.\u003c/li\u003e\n\u003cli\u003e모든 개발자가 이러한 IDE를 사용하는 것은 아닙니다. 그리고 라이브러리 유지보수자(maintainers)는 IDE를 사용하더라도 풀 리퀘스트(pull request) 작성자가 동일한 IDE를 사용한다고 가정할 필요가 없습니다. 우리는 개발자의 편집기 선택에 대해 아무것도 가정하지 않고 지속적 통합(continuous integration)에서 문제를 감지할 수 있는 것을 선호합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e런타임 강제 (Runtime enforcement)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e@overrides.overrides\u003c/code\u003e가 오늘날 하는 방식과 유사하게 \u003ccode\u003e@typing.override\u003c/code\u003e가 런타임에 오버라이드 안전성을 강제하도록 하는 방안을 고려했습니다.\u003c/p\u003e\n\u003cp\u003e이는 네 가지 이유로 거부되었습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e정적 타입 검사를 사용하는 사용자에게는 이것이 어떤 이점을 가져다줄지 명확하지 않습니다.\u003c/li\u003e\n\u003cli\u003e최소한의 성능 오버헤드가 발생하여 런타임 강제로 인해 프로젝트 가져오기(import)가 느려질 수 있습니다. \u003ccode\u003e@overrides.overrides\u003c/code\u003e 구현은 약 100 마이크로초가 걸리며, 이는 빠르지만 백만 줄 이상의 코드베이스에서는 1초 이상 추가 초기화 시간이 될 수 있습니다. 이는 \u003ccode\u003e@typing.override\u003c/code\u003e가 가장 유용할 것이라고 생각하는 바로 그 지점입니다.\u003c/li\u003e\n\u003cli\u003e구현에 잘 작동하지 않는 엣지 케이스(edge cases)가 있을 수 있습니다 (이러한 클로즈드 소스 라이브러리 중 하나의 유지보수자로부터 이것이 문제였다는 이야기를 들었습니다). 우리는 정적 강제가 간단하고 신뢰할 수 있을 것이라고 예상합니다.\u003c/li\u003e\n\u003cli\u003e우리가 아는 구현 접근 방식은 간단하지 않습니다. 데코레이터는 클래스 평가가 완료되기 전에 실행되므로, 우리가 아는 옵션은 호출자의 바이트코드(bytecode)를 검사하거나 (Overrides 라이브러리가 하는 방식) 메타클래스(metaclass) 기반 접근 방식을 사용하는 것입니다. 어느 쪽도 이상적으로 보이지 않습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e서브클래스에 명시적 오버라이드를 강제하기 위해 기본 클래스 표시 (Mark a base class to force explicit overrides on subclasses)\u003c/h3\u003e\n\u003cp\u003e클래스 데코레이터 \u003ccode\u003e@require_explicit_overrides\u003c/code\u003e를 포함하는 방안을 고려했습니다. 이는 기본 클래스가 모든 서브클래스가 메서드 오버라이드에 \u003ccode\u003e@override\u003c/code\u003e 데코레이터를 사용해야 한다고 선언하는 방법을 제공했을 것입니다. Overrides 라이브러리에는 런타임 검사에서 유사한 동작을 제공하는 믹스인 클래스(mixin class) \u003ccode\u003eEnforceExplicitOverrides\u003c/code\u003e가 있습니다.\u003c/p\u003e\n\u003cp\u003e이 제안은 대규모 코드베이스의 소유자가 \u003ccode\u003e@override\u003c/code\u003e로부터 가장 큰 이점을 얻을 것이라고 예상하며, 이러한 사용 사례에서는 명시적인 \u003ccode\u003e@override\u003c/code\u003e가 요구되는 엄격 모드(Strict Enforcement Per-Project 섹션 참조)가 기본 클래스를 표시하는 방법보다 더 많은 이점을 제공하기 때문에 채택되지 않았습니다.\u003c/p\u003e\n\u003cp\u003e또한, 추가적인 타입 안전성이 \u003ccode\u003e@override\u003c/code\u003e 사용의 추가적인 상용구(boilerplate) 가치가 없다고 생각하는 프로젝트 작성자는 그렇게 하도록 강요되어서는 안 된다고 믿습니다. 선택적 엄격 모드는 프로젝트 소유자의 결정에 맡기는 반면, 라이브러리에서 \u003ccode\u003e@require_explicit_overrides\u003c/code\u003e를 사용하면 프로젝트 소유자가 원하지 않더라도 \u003ccode\u003e@override\u003c/code\u003e를 사용하도록 강요하게 됩니다.\u003c/p\u003e\n\u003ch3\u003e오버라이드되는 조상 클래스 이름 포함 (Include the name of the ancestor class being overridden)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e@override\u003c/code\u003e 호출자가 오버라이드되는 메서드가 정의되어야 하는 특정 조상 클래스를 지정할 수 있도록 하는 방안을 고려했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Parent0:\n    def foo(self) -\u003e int:\n        return 1\nclass Parent1:\n    def bar(self) -\u003e int:\n        return 1\n\nclass Child(Parent0, Parent1):\n    @override(Parent0) # 괜찮음, Parent0이 foo를 정의함\n    def foo(self) -\u003e int:\n        return 2\n\n    @override(Parent0) # 타입 오류, Parent0이 bar를 정의하지 않음\n    def bar(self) -\u003e int:\n        return 2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 깊은 상속 트리(deep inheritance trees)에서 오버라이드 구조를 더 명확하게 해주기 때문에 코드 가독성에 유용할 수 있습니다. 또한, 오버라이드되는 메서드가 한 기본 클래스에서 다른 기본 클래스로 이동할 때마다 개발자가 오버라이드 구현이 여전히 의미 있는지 확인하도록 유도하여 버그를 잡을 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e다음과 같은 이유로 이 제안은 채택되지 않았습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이를 지원하면 \u003ccode\u003e@override\u003c/code\u003e 자체와 이를 위한 타입 검사기 지원의 구현 복잡성이 증가하므로, 상당한 이점이 있어야 했습니다. 우리는 이것이 거의 사용되지 않고 상대적으로 적은 버그를 잡을 것이라고 믿습니다.\u003c/li\u003e\n\u003cli\u003eOverrides 패키지의 작성자는 초기 버전의 라이브러리에 이 기능이 포함되어 있었지만 거의 유용하지 않았고 이점이 거의 없었다고 언급했습니다. 제거된 후에는 사용자로부터 이 기능에 대한 요청이 없었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e참조 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003ePyre에서 개념 증명(proof of concept)이 구현되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e@pyre_extensions.override\u003c/code\u003e 데코레이터는 오버라이드를 표시할 수 있습니다.\u003c/li\u003e\n\u003cli\u003ePyre는 이 PEP에 명시된 대로 이 데코레이터를 타입 검사할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e중요\u003c/strong\u003e: 이 PEP는 역사적인 문서입니다. 최신 사양 및 문서는 \u003ccode\u003e@override\u003c/code\u003e 및 \u003ccode\u003e@typing.override\u003c/code\u003e를 참조하십시오. 표준 타이핑 사양은 \u003ca href=\"https://typing.readthedocs.io/en/latest/\"\u003etyping specs site\u003c/a\u003e에서 유지 관리되며, 런타임 타이핑 동작은 \u003ca href=\"https://docs.python.org/3/library/typing.html\"\u003eCPython documentation\u003c/a\u003e에 설명되어 있습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 698 - Override Decorator for Static Typing\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 13:05:19+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>