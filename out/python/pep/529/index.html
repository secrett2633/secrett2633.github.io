<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 529 - Change Windows filesystem encoding to UTF-8</h1><div class="page__meta"><time dateTime="2025-09-26 23:20:53+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0529/">PEP 529 - Change Windows filesystem encoding to UTF-8</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 27-Aug-2016</p>
</blockquote>
<h1>PEP 529 – Windows 파일 시스템 인코딩을 UTF-8로 변경</h1>
<ul>
<li><strong>작성자:</strong> Steve Dower</li>
<li><strong>상태:</strong> 최종 (Final)</li>
<li><strong>유형:</strong> 표준 트랙 (Standards Track)</li>
<li><strong>생성일:</strong> 2016년 8월 27일</li>
<li><strong>Python 버전:</strong> 3.6</li>
<li><strong>최종 이력:</strong> 2016년 9월 1일, 2016년 9월 4일</li>
<li><strong>결정:</strong> Python-Dev 메시지</li>
</ul>
<h2>요약 (Abstract)</h2>
<p>역사적으로 Python은 Windows 운영 체제와 상호 작용할 때, 주로 C Runtime 함수를 통해 ANSI API를 사용했습니다. 그러나 이 방법은 UTF-16 API에 비해 오랫동안 권장되지 않았습니다. 운영 체제 내부에서는 모든 텍스트가 UTF-16으로 표현되며, ANSI API는 활성 코드 페이지(active code page)를 사용하여 인코딩 및 디코딩을 수행합니다. 자세한 내용은 "Naming Files, Paths, and Namespaces" 문서를 참조하십시오.</p>
<p>이 PEP는 Windows에서 기본 파일 시스템 인코딩을 <code>utf-8</code>으로 변경하고, 모든 파일 시스템 함수가 파일 시스템 경로에 대해 Unicode API를 사용하도록 제안합니다. 이 변경은 경로를 나타내기 위해 문자열(<code>str</code>)을 사용하는 코드에는 영향을 미치지 않지만, 경로에 바이트(<code>bytes</code>)를 사용하는 코드의 경우 이제 Windows 파일 시스템의 모든 유효한 경로를 정확하게 왕복(round-trip)할 수 있게 됩니다. 현재는 Unicode (OS 내부)와 bytes (Python 내부) 간의 변환이 정보 손실(lossy)을 일으키며, 사용자의 활성 코드 페이지(active code page) 범위 밖의 문자는 왕복에 실패할 수 있었습니다.</p>
<p>주목할 점은, 이 변경이 파일 내용의 인코딩에는 영향을 미치지 않는다는 것입니다. 파일 내용은 계속해서 <code>locale.getpreferredencoding()</code> (텍스트 파일의 경우) 또는 일반 <code>bytes</code> (바이너리 파일의 경우)를 기본값으로 사용합니다. 이 변경은 사용자가 Python에 <code>bytes</code> 객체를 경로 이름으로 전달하여 운영 체제에 전달할 때 사용되는 인코딩에만 영향을 미칩니다.</p>
<h2>배경 (Background)</h2>
<p>파일 시스템 경로는 파일 시스템에 의해 결정된 인코딩을 가진 텍스트로 거의 보편적으로 표현됩니다. Python에서는 <code>os</code> 및 <code>io</code> 모듈과 같은 여러 인터페이스를 통해 이러한 경로를 노출합니다. 경로는 파일 시스템에서 애플리케이션으로 (예: <code>os.listdir()</code>), 또는 애플리케이션에서 파일 시스템으로 (예: <code>os.unlink()</code>) 양방향으로 전달될 수 있습니다.</p>
<p>경로가 파일 시스템과 애플리케이션 간에 전달될 때, <code>bytes</code> 객체로 직접 전달되거나, <code>os.fsencode()</code> 및 <code>os.fsdecode()</code>를 사용하거나, <code>sys.getfilesystemencoding()</code>을 사용하여 명시적인 인코딩을 통해 <code>str</code>로 변환됩니다. <code>sys.getfilesystemencoding()</code>으로 문자열을 인코딩한 결과는 기본 파일 시스템의 기본 형식으로 된 <code>bytes</code> 객체입니다.</p>
<p>Windows에서 파일 시스템의 기본 형식은 <code>utf-16-le</code>입니다. 파일 시스템에 접근하기 위한 권장 플랫폼 API는 모두 이 형식으로 인코딩된 텍스트를 받거나 반환합니다. 그러나 Windows NT 이전 (그리고 아마도 더 이전)에는 기본 형식이 구성 가능한 머신 옵션이었고, 이 형식을 수용하기 위한 별도의 API 세트가 존재했습니다. 이 옵션 (활성 코드 페이지)과 이러한 API (<code>*A 함수</code>)는 하위 호환성을 위해 최신 Windows 버전에도 여전히 존재하지만, 새로운 기능은 종종 <code>utf-16-le</code> API (<code>*W 함수</code>)만 가집니다.</p>
<p>Python에서는 경로에 사용되는 모든 문자를 정확하게 왕복할 수 있으므로 <code>str</code> 사용이 권장됩니다 (POSIX에서는 <code>surrogateescape</code> 처리, Windows에서는 <code>str</code>이 기본 표현에 매핑되기 때문). Windows에서 <code>bytes</code>는 경로에 사용되는 모든 문자를 왕복할 수 없는데, 이는 Python이 내부적으로 <code>*A</code> 함수를 사용하며 인코딩이 "활성 코드 페이지에 따르기" 때문입니다. 활성 코드 페이지는 모든 Unicode 문자를 나타낼 수 없으므로, 경로를 <code>bytes</code>로 변환할 때 경고나 표시 없이 정보 손실이 발생할 수 있습니다.</p>
<p>다음은 이를 시연하는 예시입니다.</p>
<pre><code class="language-python">>>> open('test\uAB00.txt', 'wb').close()
>>> import glob
>>> glob.glob('test*')
['test\uab00.txt']
>>> glob.glob(b'test*')
[b'test?.txt']
</code></pre>
<p><code>glob</code>에 대한 두 번째 호출에서 Unicode 문자가 '?'로 대체되었는데, 이는 해당 경로를 파일 시스템에 다시 전달할 경우 <code>FileNotFoundError</code>를 발생시킨다는 의미입니다. <code>os.listdir()</code> 또는 매개변수 유형과 반환 유형을 일치시키는 모든 함수에서도 동일한 결과를 관찰할 수 있습니다.</p>
<p>모든 곳에서 <code>str</code>을 사용하는 것이 사용자에게 접근 가능한 해결책 중 하나이지만, POSIX 시스템은 <code>bytes</code>가 정식 표현(canonical representation)이므로 <code>bytes</code>만 사용할 때 일반적으로 데이터 손실이 발생하지 않습니다. 특정 표준에 의해 인코딩이 "올바르지 않더라도" 파일 시스템은 <code>bytes</code>를 다시 파일에 매핑합니다. 이를 활용하면 디코딩 및 재인코딩 비용을 피할 수 있어 (이론적으로, 그리고 POSIX에서만) <code>b'.'</code>를 사용하는 것이 <code>'.'</code>를 사용하는 것보다 더 빠를 수 있습니다.</p>
<pre><code class="language-python">>>> for f in os.listdir(b'.'):
... os.stat(f)
...
</code></pre>
<p>결과적으로 POSIX에 초점을 맞춘 라이브러리 작성자는 경로를 <code>bytes</code>로 표현하는 것을 선호합니다. 일부 작성자에게는 이미 올바르게 인코딩된 <code>bytes</code>를 받을 수 있다는 편의성 때문이고, 다른 일부는 Python 2에서 코드를 포팅하는 것을 단순화하려는 시도 때문입니다. 그러나 <code>bytes</code>의 정확성 가정은 Unicode가 정식 표현인 Windows에는 적용되지 않으며, 오류가 발생할 수 있습니다. 이러한 잠재적인 데이터 손실 때문에 Windows에서 <code>bytes</code> 경로 사용은 Python 3.3에서 더 이상 사용되지 않도록(deprecated) 지정되었습니다. 위의 모든 코드 스니펫은 Windows에서 Deprecation Warning을 생성합니다.</p>
<h2>제안 (Proposal)</h2>
<p>현재 기본 파일 시스템 인코딩은 활성 코드 페이지를 사용하는 메타 인코더인 'mbcs'입니다. 그러나 <code>bytes</code>가 파일 시스템에 전달될 때 <code>*A</code> API를 거치며 운영 체제가 인코딩을 처리합니다. 이 경우 경로는 Python이 재정의하거나 변경할 기회 없이 항상 'mbcs:replace'와 동일하게 인코딩됩니다.</p>
<p>이 제안은 <code>*A</code> API의 모든 사용을 제거하고 <code>*W</code> API만 호출하도록 합니다. Windows가 경로를 <code>str</code>로 Python에 반환할 때, <code>utf-16-le</code>에서 디코딩되어 텍스트로 반환됩니다 (최소 표현이 무엇이든). Python 코드가 경로를 <code>bytes</code>로 요청할 때, 경로는 <code>surrogatepass</code>를 사용하여 <code>utf-16-le</code>에서 <code>utf-8</code>로 트랜스코딩됩니다 (Windows는 서로게이트 쌍을 유효성 검사하지 않으므로 파일 이름에 유효하지 않은 서로게이트가 있을 수 있습니다). 마찬가지로 경로가 <code>bytes</code>로 제공될 때, <code>utf-8</code>에서 <code>utf-16-le</code>로 트랜스코딩되어 <code>*W</code> API에 전달됩니다.</p>
<p><code>utf-8</code> 사용은 이전 동작으로 되돌리는 "레거시 모드" 플래그 제공 외에는 구성할 수 없습니다.</p>
<p><code>surrogateescape</code> 오류 모드는 여기에서 적용되지 않습니다. 이는 의미 없는 <code>bytes</code>를 유지하는 것에 대한 문제가 아니기 때문입니다. 운영 체제에서 반환된 모든 경로는 유효한 Unicode일 것이며, 사용자가 생성한 유효하지 않은 경로는 디코딩 오류를 발생시켜야 합니다 (현재는 <code>OSError</code> 또는 서브클래스를 발생시킬 것입니다).</p>
<p><code>utf-8</code> <code>bytes</code> (대신 <code>utf-16-le</code> <code>bytes</code>가 아닌) 선택은 경로 이름의 왕복 기능을 보장하고 ASCII 호환 인코딩을 가정할 때 기본 조작 (예: <code>os.path</code> 모듈 사용)을 허용하기 위함입니다. <code>utf-16-le</code>를 인코딩으로 사용하는 것이 더 순수하지만, 해결되는 문제보다 더 많은 문제를 야기할 것입니다.</p>
<p>이 변경은 또한 Windows에서 <code>bytes</code> 경로 사용에 대한 deprecation을 해제합니다. <code>bytes</code>를 경로로 사용하는 의미론에 대한 변경은 필요하지 않습니다. 이전과 마찬가지로, <code>sys.getfilesystemencoding()</code>에서 반환되는 인코딩으로 인코딩되어야 합니다.</p>
<h2>구체적인 변경 사항 (Specific Changes)</h2>
<h3><code>sys.getfilesystemencoding</code> 업데이트</h3>
<p><code>Py_FileSystemDefaultEncoding</code>의 기본값을 제거하고 <code>initfsencoding()</code>에서 <code>utf-8</code>로 설정합니다. 레거시 모드 스위치가 활성화된 경우에는 <code>mbcs</code>로 설정합니다.</p>
<p><code>PyUnicode_DecodeFSDefaultAndSize()</code> 및 <code>PyUnicode_EncodeFSDefault()</code>의 구현을 업데이트하여 <code>utf-8</code> 코덱을 사용하도록 합니다. 레거시 모드 스위치가 활성화된 경우에는 기존 <code>mbcs</code> 코덱을 사용합니다.</p>
<h3><code>sys.getfilesystemencodeerrors</code> 추가</h3>
<p>오류 모드가 이제 <code>surrogatepass</code>와 <code>replace</code> 사이에서 변경될 수 있으므로, 수동으로 인코딩을 수행하는 Python 코드도 현재 오류 모드에 접근할 수 있어야 합니다. 여기에는 현재 코덱을 기반으로 오류 모드를 가정하는 <code>os.fsencode()</code> 및 <code>os.fsdecode()</code>의 구현이 포함됩니다.</p>
<p>기존 <code>Py_FileSystemDefaultEncoding</code>과 유사하게 공개 <code>Py_FileSystemDefaultEncodeErrors</code>를 추가합니다. Windows의 기본값은 <code>surrogatepass</code>이거나 레거시 모드에서는 <code>replace</code>가 됩니다. 다른 모든 플랫폼의 기본값은 <code>surrogateescape</code>가 됩니다.</p>
<p>현재 오류 모드를 반환하는 공개 <code>sys.getfilesystemencodeerrors()</code> 함수를 추가합니다.</p>
<p><code>PyUnicode_DecodeFSDefaultAndSize()</code> 및 <code>PyUnicode_EncodeFSDefault()</code>의 구현을 업데이트하여 상수 문자열 대신 오류 모드 변수를 사용하도록 합니다.</p>
<p><code>os.fsencode()</code> 및 <code>os.fsdecode()</code>의 구현을 업데이트하여 모드를 가정하는 대신 <code>sys.getfilesystemencodeerrors()</code>를 사용하도록 합니다.</p>
<h3><code>path_converter</code> 업데이트</h3>
<p><code>path_converter</code>를 업데이트하여 <code>bytes</code> 또는 <code>buffer</code> 객체를 항상 <code>PyUnicode_DecodeFSDefaultAndSize()</code>를 사용하여 텍스트로 디코딩하도록 합니다.</p>
<p><code>narrow</code> 필드를 <code>char*</code> 문자열에서 원래 객체가 <code>bytes</code>였는지 여부를 나타내는 플래그로 변경합니다. 이는 원래 제공된 것과 동일한 유형을 사용하여 경로를 반환해야 하는 함수에 필요합니다.</p>
<h3>사용되지 않는 ANSI 코드 제거</h3>
<p><code>narrow</code> 필드를 사용하는 모든 코드 경로를 제거합니다. 이 경로는 더 이상 호출자가 접근할 수 없습니다. 이들은 <code>posixmodule.c</code> 내에서만 사용됩니다. 경로의 다른 사용은 <code>bytes</code> 경로 사용을 디코딩 및 <code>*W</code> API 사용으로 대체해야 합니다.</p>
<h3>레거시 모드 추가 (Add legacy mode)</h3>
<p>환경 변수 <code>PYTHONLEGACYWINDOWSFSENCODING</code> 또는 <code>sys._enablelegacywindowsfsencoding()</code> 함수 호출을 통해 활성화되는 레거시 모드 플래그를 추가합니다. 함수 호출은 플래그를 활성화하는 데만 사용될 수 있으며, 프로그램 초기화에 가능한 한 가깝게 사용해야 합니다. Python이 실행 중인 동안에는 레거시 모드를 비활성화할 수 없습니다.</p>
<p>이 플래그가 설정되면 기본 파일 시스템 인코딩은 <code>utf-8</code> 대신 <code>mbcs</code>로 설정되고, 오류 모드는 <code>surrogatepass</code> 대신 <code>replace</code>로 설정됩니다. 경로는 계속해서 와이드 문자(wide characters)로 디코딩되고 <code>*W</code> API만 호출되지만, Python에 전달되고 Python에서 수신되는 <code>bytes</code>는 이 변경 이전과 동일하게 인코딩됩니다.</p>
<h3>Windows에서 bytes 경로 사용에 대한 deprecation 해제 (Undeprecate bytes paths on Windows)</h3>
<p>Windows에서 <code>bytes</code>를 경로로 사용하는 것은 현재 deprecated 되어 있습니다. 이 제안에서는 더 이상 그렇지 않으며, <code>bytes</code>로 인코딩된 경로는 사용자의 활성 코드 페이지 대신 <code>sys.getfilesystemencoding()</code>에서 반환되는 것을 사용해야 한다고 발표할 것입니다.</p>
<h3>베타 실험 (Beta experiment)</h3>
<p>이 변경의 영향을 확인하기 위해, 3.6.0b1에 잠정적으로 적용하고 3.6.0b4 이전에 최종 결정을 내릴 것을 제안합니다.</p>
<p>실험 기간 동안, 디코딩 및 인코딩 예외 메시지는 활성 온라인 토론 링크를 포함하도록 확장되어 문제 보고를 장려할 것입니다.</p>
<p>3.6.0b4에서 기능을 되돌리기로 결정되면, 구현 변경은 레거시 모드 플래그를 영구적으로 활성화하고, 환경 변수를 <code>PYTHONWINDOWSUTF8FSENCODING</code>으로, 함수를 <code>sys._enablewindowsutf8fsencoding()</code>으로 변경하여 기능을 비활성화하는 대신 사례별로 활성화할 수 있도록 할 것입니다.</p>
<p>호환성 문제로 인해 3.6에서 변경을 실행할 수 없는 경우, Python 3.x의 어떤 후기 버전에서도 변경을 실행할 수 없을 것으로 예상됩니다.</p>
<h3>영향을 받는 모듈 (Affected Modules)</h3>
<p>이 PEP는 경로 이름을 운영 체제에 전달하거나 <code>sys.getfilesystemencoding()</code>을 사용하는 Python 내의 모든 모듈을 암묵적으로 포함합니다.</p>
<p>3.6.0a4 기준으로 다음 모듈은 수정이 필요합니다.</p>
<ul>
<li><code>os</code></li>
<li><code>_overlapped</code></li>
<li><code>_socket</code></li>
<li><code>subprocess</code></li>
<li><code>zipimport</code></li>
</ul>
<p>다음 모듈은 <code>sys.getfilesystemencoding()</code>을 사용하지만 수정이 필요하지 않습니다.</p>
<ul>
<li><code>gc</code> (이미 <code>bytes</code>를 <code>utf-8</code>로 가정합니다)</li>
<li><code>grp</code> (Windows용으로 컴파일되지 않습니다)</li>
<li><code>http.server</code> (전송된 데이터에 코덱 이름을 올바르게 포함합니다)</li>
<li><code>idlelib.editor</code> (필요하지 않을 것입니다; 대체 처리 기능이 있습니다)</li>
<li><code>nis</code> (Windows용으로 컴파일되지 않습니다)</li>
<li><code>pwd</code> (Windows용으로 컴파일되지 않습니다)</li>
<li><code>spwd</code> (Windows용으로 컴파일되지 않습니다)</li>
<li><code>_ssl</code> (ASCII 상수에만 사용됩니다)</li>
<li><code>tarfile</code> (Windows에서 사용되지 않는 코드입니다)</li>
<li><code>_tkinter</code> (이미 <code>bytes</code>를 <code>utf-8</code>로 가정합니다)</li>
<li><code>wsgiref</code> (알 수 없는 환경의 기본 인코딩으로 가정됩니다)</li>
<li><code>zipapp</code> (Windows에서 사용되지 않는 코드입니다)</li>
</ul>
<p>다음 네이티브 코드는 인코딩 또는 디코딩 함수 중 하나를 사용하지만 수정이 필요하지 않습니다.</p>
<ul>
<li><code>Parser/parsetok.c</code> (문서에 이미 <code>sys.getfilesystemencoding()</code>이 지정되어 있습니다)</li>
<li><code>Python/ast.c</code> (문서에 이미 <code>sys.getfilesystemencoding()</code>이 지정되어 있습니다)</li>
<li><code>Python/compile.c</code> (문서화되지 않았지만 Python 파일 시스템 인코딩이 암시되어 있습니다)</li>
<li><code>Python/errors.c</code> (문서에 이미 <code>os.fsdecode()</code>가 지정되어 있습니다)</li>
<li><code>Python/fileutils.c</code> (Windows에서 사용되지 않는 코드입니다)</li>
<li><code>Python/future.c</code> (문서화되지 않았지만 Python 파일 시스템 인코딩이 암시되어 있습니다)</li>
<li><code>Python/import.c</code> (문서에 이미 <code>utf-8</code>이 지정되어 있습니다)</li>
<li><code>Python/importdl.c</code> (Windows에서 사용되지 않는 코드입니다)</li>
<li><code>Python/pythonrun.c</code> (문서에 이미 <code>sys.getfilesystemencoding()</code>이 지정되어 있습니다)</li>
<li><code>Python/symtable.c</code> (문서화되지 않았지만 Python 파일 시스템 인코딩이 암시되어 있습니다)</li>
<li><code>Python/thread.c</code> (Windows에서 사용되지 않는 코드입니다)</li>
<li><code>Python/traceback.c</code> (문자열 비교를 위해 올바르게 인코딩됩니다)</li>
<li><code>Python/_warnings.c</code> (문서에 이미 <code>os.fsdecode()</code>가 지정되어 있습니다)</li>
</ul>
<h2>거부된 대안 (Rejected Alternatives)</h2>
<h3>'strict mbcs' 디코딩 사용</h3>
<p>이 대안은 본질적으로 제안된 변경과 동일하지만, <code>sys.getfilesystemencoding()</code>을 <code>utf-8</code> 대신 <code>mbcs</code>로 변경합니다 (이는 활성 코드 페이지에 동적으로 매핑됩니다).</p>
<p>이 접근 방식은 <code>*W</code> API로만 사용 가능한 새로운 기능을 사용할 수 있게 하고, 인코딩/디코딩 오류 감지도 가능하게 합니다. 예를 들어, Unicode 문자를 '?'로 자동으로 대체하는 대신 경고하거나 작업을 실패하게 만들 수 있습니다.</p>
<p>제안된 해결책과 비교할 때, 이는 일부 새로운 기능을 활성화할 수 있지만 처음에 설명된 문제 중 어떤 것도 해결하지 못합니다. 새로운 런타임 오류는 일부 문제를 더 명확하게 만들고 수정으로 이어질 수 있지만, 이는 라이브러리 관리자가 Windows를 지원하고 파일 시스템 경로를 문자열로 처리하기 위한 별도의 코드 경로를 추가하는 데 관심이 있는 경우에 한정됩니다.</p>
<p>엄격한 오류 없이 인코딩을 <code>mbcs</code>로 만드는 것은 레거시 모드 스위치가 기본적으로 활성화된 것과 동일합니다. 실제 코드에서 상당한 문제가 발생하고 deprecation 기간을 연장해야 할 필요가 있지만, 여전히 CPython 소스의 단순화를 원하는 경우 가능한 조치입니다.</p>
<h3>Windows에서 bytes 경로 사용을 오류로 처리</h3>
<p>Windows에서 <code>bytes</code> 경로 사용을 완전히 막음으로써 사용자가 인코딩 문제를 겪지 않도록 합니다.</p>
<p>그러나 이 PEP의 동기는 POSIX에서 작성된 코드가 Windows에서도 올바르게 작동할 가능성을 높이는 것입니다. 이 대안은 반대 방향으로 나아가 그러한 코드를 완전히 호환되지 않게 만들 것입니다. 이는 사용자에게 어떤 식으로든 이점을 제공하지 않으므로 거부합니다.</p>
<h3>모든 플랫폼에서 bytes 경로 사용을 오류로 처리</h3>
<p>모든 플랫폼에서 <code>bytes</code> 경로 사용을 deprecated하고 비활성화함으로써, 코드가 원래 작성된 위치와 상관없이 사용자가 인코딩 문제를 겪는 것을 방지합니다. Windows 이외의 플랫폼에서는 현재 경고가 없으므로 완전한 deprecation 주기가 필요할 것입니다.</p>
<p>이는 일반적으로 Python 개발자들에게 적대적인 조치로 간주될 가능성이 높으므로 현재는 거부됩니다.</p>
<h2>잠재적으로 문제가 발생할 수 있는 코드 (Code that may break)</h2>
<p>다음 코드 패턴은 이 변경으로 인해 문제가 발생하거나 다른 동작을 보일 수 있습니다. 이러한 각 예시는 크로스 플랫폼 사용을 염두에 둔 코드에서 취약했을 것입니다. 제안된 수정 사항은 모든 플랫폼과 여러 Python 버전에서 경로 인코딩 문제를 처리하는 가장 호환 가능한 방법을 보여줍니다.</p>
<p>참고: 이 모든 예시는 Python 3.3 이상에서 deprecation 경고를 생성합니다.</p>
<h3>경계 간 인코딩 관리 실패</h3>
<p>프로토콜 경계를 넘을 때 인코딩을 관리하지 않는 코드는 현재 우연히 작동할 수 있지만, 인코딩이 변경될 때 문제가 발생할 수 있습니다. <code>filename</code>의 소스는 아래 두 번째 예시에서와 같이 <code>bytes</code> 객체를 반환하는 모든 함수가 될 수 있습니다.</p>
<pre><code class="language-python">>>> filename = open('filename_in_mbcs.txt', 'rb').read()
>>> text = open(filename, 'r').read()
</code></pre>
<p>이 코드를 수정하려면, <code>filename</code>의 <code>bytes</code> 인코딩을 파일에서 읽을 때 또는 값을 사용하기 전에 지정해야 합니다.</p>
<pre><code class="language-python">>>> # Fix 1: 파일을 텍스트로 엽니다 (기본 인코딩)
>>> filename = open('filename_in_mbcs.txt', 'r').read()
>>> text = open(filename, 'r').read()
>>> # Fix 2: 파일을 텍스트로 엽니다 (명시적 인코딩)
>>> filename = open('filename_in_mbcs.txt', 'r', encoding='mbcs').read()
>>> text = open(filename, 'r').read()
>>> # Fix 3: 경로를 명시적으로 디코딩합니다
>>> filename = open('filename_in_mbcs.txt', 'rb').read()
>>> text = open(filename.decode('mbcs'), 'r').read()
</code></pre>
<p><code>filename</code>의 생성자가 <code>filename</code>의 사용자와 분리된 경우, 인코딩은 포함해야 할 중요한 정보입니다.</p>
<pre><code class="language-python">>>> some_object.filename = r'C:\Users\Steve\Documents\my_file.txt'.encode('mbcs')
>>> filename = some_object.filename
>>> type(filename)
&#x3C;class 'bytes'>
>>> text = open(filename, 'r').read()
</code></pre>
<p>이 코드를 운영 체제 및 Python 버전 전반에 걸쳐 최고의 호환성을 위해 수정하려면 <code>filename</code>을 <code>str</code>로 노출해야 합니다.</p>
<pre><code class="language-python">>>> # Fix 1: str로 노출
>>> some_object.filename = r'C:\Users\Steve\Documents\my_file.txt'
>>> filename = some_object.filename
>>> type(filename)
&#x3C;class 'str'>
>>> text = open(filename, 'r').read()
</code></pre>
<p>또는 경로에 사용된 인코딩을 사용자에게 제공해야 합니다. <code>os.fsencode()</code> (또는 <code>sys.getfilesystemencoding()</code>)를 지정하는 것은 허용 가능한 선택이며, 정확한 인코딩을 가진 새 속성을 추가할 수도 있습니다.</p>
<pre><code class="language-python">>>> # Fix 2: fsencode 사용
>>> some_object.filename = os.fsencode(r'C:\Users\Steve\Documents\my_file.txt')
>>> filename = some_object.filename
>>> type(filename)
&#x3C;class 'bytes'>
>>> text = open(filename, 'r').read()
>>> # Fix 3: 명시적 인코딩으로 노출
>>> some_object.filename = r'C:\Users\Steve\Documents\my_file.txt'.encode('cp437')
>>> some_object.filename_encoding = 'cp437'
>>> filename = some_object.filename
>>> type(filename)
&#x3C;class 'bytes'>
>>> filename = filename.decode(some_object.filename_encoding)
>>> type(filename)
&#x3C;class 'str'>
>>> text = open(filename, 'r').read()
</code></pre>
<h3>'mbcs'를 명시적으로 사용</h3>
<p>파일 시스템 API에 전달하기 전에 'mbcs'를 사용하여 텍스트를 명시적으로 인코딩하는 코드는 이제 잘못 인코딩된 <code>bytes</code>를 전달합니다. 이 예시에서 <code>filename</code>의 소스는 <code>str</code>인 한 중요하지 않습니다.</p>
<pre><code class="language-python">>>> filename = open('files.txt', 'r').readline().rstrip()
>>> text = open(filename.encode('mbcs'), 'r')
</code></pre>
<p>이 코드를 수정하려면 문자열을 명시적인 인코딩 없이 전달하거나 <code>os.fsencode()</code>를 사용해야 합니다.</p>
<pre><code class="language-python">>>> # Fix 1: 문자열을 인코딩하지 않습니다
>>> filename = open('files.txt', 'r').readline().rstrip()
>>> text = open(filename, 'r')
>>> # Fix 2: 올바른 인코딩 사용
>>> filename = open('files.txt', 'r').readline().rstrip()
>>> text = open(os.fsencode(filename), 'r')
</code></pre>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/529\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/529/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/529\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"529\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/529\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T6643,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0529/\"\u003ePEP 529 - Change Windows filesystem encoding to UTF-8\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 27-Aug-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 529 – Windows 파일 시스템 인코딩을 UTF-8로 변경\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Steve Dower\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 최종 (Final)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e 표준 트랙 (Standards Track)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2016년 8월 27일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.6\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e최종 이력:\u003c/strong\u003e 2016년 9월 1일, 2016년 9월 4일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e결정:\u003c/strong\u003e Python-Dev 메시지\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e역사적으로 Python은 Windows 운영 체제와 상호 작용할 때, 주로 C Runtime 함수를 통해 ANSI API를 사용했습니다. 그러나 이 방법은 UTF-16 API에 비해 오랫동안 권장되지 않았습니다. 운영 체제 내부에서는 모든 텍스트가 UTF-16으로 표현되며, ANSI API는 활성 코드 페이지(active code page)를 사용하여 인코딩 및 디코딩을 수행합니다. 자세한 내용은 \"Naming Files, Paths, and Namespaces\" 문서를 참조하십시오.\u003c/p\u003e\n\u003cp\u003e이 PEP는 Windows에서 기본 파일 시스템 인코딩을 \u003ccode\u003eutf-8\u003c/code\u003e으로 변경하고, 모든 파일 시스템 함수가 파일 시스템 경로에 대해 Unicode API를 사용하도록 제안합니다. 이 변경은 경로를 나타내기 위해 문자열(\u003ccode\u003estr\u003c/code\u003e)을 사용하는 코드에는 영향을 미치지 않지만, 경로에 바이트(\u003ccode\u003ebytes\u003c/code\u003e)를 사용하는 코드의 경우 이제 Windows 파일 시스템의 모든 유효한 경로를 정확하게 왕복(round-trip)할 수 있게 됩니다. 현재는 Unicode (OS 내부)와 bytes (Python 내부) 간의 변환이 정보 손실(lossy)을 일으키며, 사용자의 활성 코드 페이지(active code page) 범위 밖의 문자는 왕복에 실패할 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e주목할 점은, 이 변경이 파일 내용의 인코딩에는 영향을 미치지 않는다는 것입니다. 파일 내용은 계속해서 \u003ccode\u003elocale.getpreferredencoding()\u003c/code\u003e (텍스트 파일의 경우) 또는 일반 \u003ccode\u003ebytes\u003c/code\u003e (바이너리 파일의 경우)를 기본값으로 사용합니다. 이 변경은 사용자가 Python에 \u003ccode\u003ebytes\u003c/code\u003e 객체를 경로 이름으로 전달하여 운영 체제에 전달할 때 사용되는 인코딩에만 영향을 미칩니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Background)\u003c/h2\u003e\n\u003cp\u003e파일 시스템 경로는 파일 시스템에 의해 결정된 인코딩을 가진 텍스트로 거의 보편적으로 표현됩니다. Python에서는 \u003ccode\u003eos\u003c/code\u003e 및 \u003ccode\u003eio\u003c/code\u003e 모듈과 같은 여러 인터페이스를 통해 이러한 경로를 노출합니다. 경로는 파일 시스템에서 애플리케이션으로 (예: \u003ccode\u003eos.listdir()\u003c/code\u003e), 또는 애플리케이션에서 파일 시스템으로 (예: \u003ccode\u003eos.unlink()\u003c/code\u003e) 양방향으로 전달될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e경로가 파일 시스템과 애플리케이션 간에 전달될 때, \u003ccode\u003ebytes\u003c/code\u003e 객체로 직접 전달되거나, \u003ccode\u003eos.fsencode()\u003c/code\u003e 및 \u003ccode\u003eos.fsdecode()\u003c/code\u003e를 사용하거나, \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e을 사용하여 명시적인 인코딩을 통해 \u003ccode\u003estr\u003c/code\u003e로 변환됩니다. \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e으로 문자열을 인코딩한 결과는 기본 파일 시스템의 기본 형식으로 된 \u003ccode\u003ebytes\u003c/code\u003e 객체입니다.\u003c/p\u003e\n\u003cp\u003eWindows에서 파일 시스템의 기본 형식은 \u003ccode\u003eutf-16-le\u003c/code\u003e입니다. 파일 시스템에 접근하기 위한 권장 플랫폼 API는 모두 이 형식으로 인코딩된 텍스트를 받거나 반환합니다. 그러나 Windows NT 이전 (그리고 아마도 더 이전)에는 기본 형식이 구성 가능한 머신 옵션이었고, 이 형식을 수용하기 위한 별도의 API 세트가 존재했습니다. 이 옵션 (활성 코드 페이지)과 이러한 API (\u003ccode\u003e*A 함수\u003c/code\u003e)는 하위 호환성을 위해 최신 Windows 버전에도 여전히 존재하지만, 새로운 기능은 종종 \u003ccode\u003eutf-16-le\u003c/code\u003e API (\u003ccode\u003e*W 함수\u003c/code\u003e)만 가집니다.\u003c/p\u003e\n\u003cp\u003ePython에서는 경로에 사용되는 모든 문자를 정확하게 왕복할 수 있으므로 \u003ccode\u003estr\u003c/code\u003e 사용이 권장됩니다 (POSIX에서는 \u003ccode\u003esurrogateescape\u003c/code\u003e 처리, Windows에서는 \u003ccode\u003estr\u003c/code\u003e이 기본 표현에 매핑되기 때문). Windows에서 \u003ccode\u003ebytes\u003c/code\u003e는 경로에 사용되는 모든 문자를 왕복할 수 없는데, 이는 Python이 내부적으로 \u003ccode\u003e*A\u003c/code\u003e 함수를 사용하며 인코딩이 \"활성 코드 페이지에 따르기\" 때문입니다. 활성 코드 페이지는 모든 Unicode 문자를 나타낼 수 없으므로, 경로를 \u003ccode\u003ebytes\u003c/code\u003e로 변환할 때 경고나 표시 없이 정보 손실이 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 이를 시연하는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e open('test\\uAB00.txt', 'wb').close()\n\u003e\u003e\u003e import glob\n\u003e\u003e\u003e glob.glob('test*')\n['test\\uab00.txt']\n\u003e\u003e\u003e glob.glob(b'test*')\n[b'test?.txt']\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eglob\u003c/code\u003e에 대한 두 번째 호출에서 Unicode 문자가 '?'로 대체되었는데, 이는 해당 경로를 파일 시스템에 다시 전달할 경우 \u003ccode\u003eFileNotFoundError\u003c/code\u003e를 발생시킨다는 의미입니다. \u003ccode\u003eos.listdir()\u003c/code\u003e 또는 매개변수 유형과 반환 유형을 일치시키는 모든 함수에서도 동일한 결과를 관찰할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e모든 곳에서 \u003ccode\u003estr\u003c/code\u003e을 사용하는 것이 사용자에게 접근 가능한 해결책 중 하나이지만, POSIX 시스템은 \u003ccode\u003ebytes\u003c/code\u003e가 정식 표현(canonical representation)이므로 \u003ccode\u003ebytes\u003c/code\u003e만 사용할 때 일반적으로 데이터 손실이 발생하지 않습니다. 특정 표준에 의해 인코딩이 \"올바르지 않더라도\" 파일 시스템은 \u003ccode\u003ebytes\u003c/code\u003e를 다시 파일에 매핑합니다. 이를 활용하면 디코딩 및 재인코딩 비용을 피할 수 있어 (이론적으로, 그리고 POSIX에서만) \u003ccode\u003eb'.'\u003c/code\u003e를 사용하는 것이 \u003ccode\u003e'.'\u003c/code\u003e를 사용하는 것보다 더 빠를 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e for f in os.listdir(b'.'):\n... os.stat(f)\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과적으로 POSIX에 초점을 맞춘 라이브러리 작성자는 경로를 \u003ccode\u003ebytes\u003c/code\u003e로 표현하는 것을 선호합니다. 일부 작성자에게는 이미 올바르게 인코딩된 \u003ccode\u003ebytes\u003c/code\u003e를 받을 수 있다는 편의성 때문이고, 다른 일부는 Python 2에서 코드를 포팅하는 것을 단순화하려는 시도 때문입니다. 그러나 \u003ccode\u003ebytes\u003c/code\u003e의 정확성 가정은 Unicode가 정식 표현인 Windows에는 적용되지 않으며, 오류가 발생할 수 있습니다. 이러한 잠재적인 데이터 손실 때문에 Windows에서 \u003ccode\u003ebytes\u003c/code\u003e 경로 사용은 Python 3.3에서 더 이상 사용되지 않도록(deprecated) 지정되었습니다. 위의 모든 코드 스니펫은 Windows에서 Deprecation Warning을 생성합니다.\u003c/p\u003e\n\u003ch2\u003e제안 (Proposal)\u003c/h2\u003e\n\u003cp\u003e현재 기본 파일 시스템 인코딩은 활성 코드 페이지를 사용하는 메타 인코더인 'mbcs'입니다. 그러나 \u003ccode\u003ebytes\u003c/code\u003e가 파일 시스템에 전달될 때 \u003ccode\u003e*A\u003c/code\u003e API를 거치며 운영 체제가 인코딩을 처리합니다. 이 경우 경로는 Python이 재정의하거나 변경할 기회 없이 항상 'mbcs:replace'와 동일하게 인코딩됩니다.\u003c/p\u003e\n\u003cp\u003e이 제안은 \u003ccode\u003e*A\u003c/code\u003e API의 모든 사용을 제거하고 \u003ccode\u003e*W\u003c/code\u003e API만 호출하도록 합니다. Windows가 경로를 \u003ccode\u003estr\u003c/code\u003e로 Python에 반환할 때, \u003ccode\u003eutf-16-le\u003c/code\u003e에서 디코딩되어 텍스트로 반환됩니다 (최소 표현이 무엇이든). Python 코드가 경로를 \u003ccode\u003ebytes\u003c/code\u003e로 요청할 때, 경로는 \u003ccode\u003esurrogatepass\u003c/code\u003e를 사용하여 \u003ccode\u003eutf-16-le\u003c/code\u003e에서 \u003ccode\u003eutf-8\u003c/code\u003e로 트랜스코딩됩니다 (Windows는 서로게이트 쌍을 유효성 검사하지 않으므로 파일 이름에 유효하지 않은 서로게이트가 있을 수 있습니다). 마찬가지로 경로가 \u003ccode\u003ebytes\u003c/code\u003e로 제공될 때, \u003ccode\u003eutf-8\u003c/code\u003e에서 \u003ccode\u003eutf-16-le\u003c/code\u003e로 트랜스코딩되어 \u003ccode\u003e*W\u003c/code\u003e API에 전달됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eutf-8\u003c/code\u003e 사용은 이전 동작으로 되돌리는 \"레거시 모드\" 플래그 제공 외에는 구성할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esurrogateescape\u003c/code\u003e 오류 모드는 여기에서 적용되지 않습니다. 이는 의미 없는 \u003ccode\u003ebytes\u003c/code\u003e를 유지하는 것에 대한 문제가 아니기 때문입니다. 운영 체제에서 반환된 모든 경로는 유효한 Unicode일 것이며, 사용자가 생성한 유효하지 않은 경로는 디코딩 오류를 발생시켜야 합니다 (현재는 \u003ccode\u003eOSError\u003c/code\u003e 또는 서브클래스를 발생시킬 것입니다).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eutf-8\u003c/code\u003e \u003ccode\u003ebytes\u003c/code\u003e (대신 \u003ccode\u003eutf-16-le\u003c/code\u003e \u003ccode\u003ebytes\u003c/code\u003e가 아닌) 선택은 경로 이름의 왕복 기능을 보장하고 ASCII 호환 인코딩을 가정할 때 기본 조작 (예: \u003ccode\u003eos.path\u003c/code\u003e 모듈 사용)을 허용하기 위함입니다. \u003ccode\u003eutf-16-le\u003c/code\u003e를 인코딩으로 사용하는 것이 더 순수하지만, 해결되는 문제보다 더 많은 문제를 야기할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 변경은 또한 Windows에서 \u003ccode\u003ebytes\u003c/code\u003e 경로 사용에 대한 deprecation을 해제합니다. \u003ccode\u003ebytes\u003c/code\u003e를 경로로 사용하는 의미론에 대한 변경은 필요하지 않습니다. 이전과 마찬가지로, \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e에서 반환되는 인코딩으로 인코딩되어야 합니다.\u003c/p\u003e\n\u003ch2\u003e구체적인 변경 사항 (Specific Changes)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003esys.getfilesystemencoding\u003c/code\u003e 업데이트\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ePy_FileSystemDefaultEncoding\u003c/code\u003e의 기본값을 제거하고 \u003ccode\u003einitfsencoding()\u003c/code\u003e에서 \u003ccode\u003eutf-8\u003c/code\u003e로 설정합니다. 레거시 모드 스위치가 활성화된 경우에는 \u003ccode\u003embcs\u003c/code\u003e로 설정합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyUnicode_DecodeFSDefaultAndSize()\u003c/code\u003e 및 \u003ccode\u003ePyUnicode_EncodeFSDefault()\u003c/code\u003e의 구현을 업데이트하여 \u003ccode\u003eutf-8\u003c/code\u003e 코덱을 사용하도록 합니다. 레거시 모드 스위치가 활성화된 경우에는 기존 \u003ccode\u003embcs\u003c/code\u003e 코덱을 사용합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003esys.getfilesystemencodeerrors\u003c/code\u003e 추가\u003c/h3\u003e\n\u003cp\u003e오류 모드가 이제 \u003ccode\u003esurrogatepass\u003c/code\u003e와 \u003ccode\u003ereplace\u003c/code\u003e 사이에서 변경될 수 있으므로, 수동으로 인코딩을 수행하는 Python 코드도 현재 오류 모드에 접근할 수 있어야 합니다. 여기에는 현재 코덱을 기반으로 오류 모드를 가정하는 \u003ccode\u003eos.fsencode()\u003c/code\u003e 및 \u003ccode\u003eos.fsdecode()\u003c/code\u003e의 구현이 포함됩니다.\u003c/p\u003e\n\u003cp\u003e기존 \u003ccode\u003ePy_FileSystemDefaultEncoding\u003c/code\u003e과 유사하게 공개 \u003ccode\u003ePy_FileSystemDefaultEncodeErrors\u003c/code\u003e를 추가합니다. Windows의 기본값은 \u003ccode\u003esurrogatepass\u003c/code\u003e이거나 레거시 모드에서는 \u003ccode\u003ereplace\u003c/code\u003e가 됩니다. 다른 모든 플랫폼의 기본값은 \u003ccode\u003esurrogateescape\u003c/code\u003e가 됩니다.\u003c/p\u003e\n\u003cp\u003e현재 오류 모드를 반환하는 공개 \u003ccode\u003esys.getfilesystemencodeerrors()\u003c/code\u003e 함수를 추가합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyUnicode_DecodeFSDefaultAndSize()\u003c/code\u003e 및 \u003ccode\u003ePyUnicode_EncodeFSDefault()\u003c/code\u003e의 구현을 업데이트하여 상수 문자열 대신 오류 모드 변수를 사용하도록 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eos.fsencode()\u003c/code\u003e 및 \u003ccode\u003eos.fsdecode()\u003c/code\u003e의 구현을 업데이트하여 모드를 가정하는 대신 \u003ccode\u003esys.getfilesystemencodeerrors()\u003c/code\u003e를 사용하도록 합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003epath_converter\u003c/code\u003e 업데이트\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epath_converter\u003c/code\u003e를 업데이트하여 \u003ccode\u003ebytes\u003c/code\u003e 또는 \u003ccode\u003ebuffer\u003c/code\u003e 객체를 항상 \u003ccode\u003ePyUnicode_DecodeFSDefaultAndSize()\u003c/code\u003e를 사용하여 텍스트로 디코딩하도록 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enarrow\u003c/code\u003e 필드를 \u003ccode\u003echar*\u003c/code\u003e 문자열에서 원래 객체가 \u003ccode\u003ebytes\u003c/code\u003e였는지 여부를 나타내는 플래그로 변경합니다. 이는 원래 제공된 것과 동일한 유형을 사용하여 경로를 반환해야 하는 함수에 필요합니다.\u003c/p\u003e\n\u003ch3\u003e사용되지 않는 ANSI 코드 제거\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003enarrow\u003c/code\u003e 필드를 사용하는 모든 코드 경로를 제거합니다. 이 경로는 더 이상 호출자가 접근할 수 없습니다. 이들은 \u003ccode\u003eposixmodule.c\u003c/code\u003e 내에서만 사용됩니다. 경로의 다른 사용은 \u003ccode\u003ebytes\u003c/code\u003e 경로 사용을 디코딩 및 \u003ccode\u003e*W\u003c/code\u003e API 사용으로 대체해야 합니다.\u003c/p\u003e\n\u003ch3\u003e레거시 모드 추가 (Add legacy mode)\u003c/h3\u003e\n\u003cp\u003e환경 변수 \u003ccode\u003ePYTHONLEGACYWINDOWSFSENCODING\u003c/code\u003e 또는 \u003ccode\u003esys._enablelegacywindowsfsencoding()\u003c/code\u003e 함수 호출을 통해 활성화되는 레거시 모드 플래그를 추가합니다. 함수 호출은 플래그를 활성화하는 데만 사용될 수 있으며, 프로그램 초기화에 가능한 한 가깝게 사용해야 합니다. Python이 실행 중인 동안에는 레거시 모드를 비활성화할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e이 플래그가 설정되면 기본 파일 시스템 인코딩은 \u003ccode\u003eutf-8\u003c/code\u003e 대신 \u003ccode\u003embcs\u003c/code\u003e로 설정되고, 오류 모드는 \u003ccode\u003esurrogatepass\u003c/code\u003e 대신 \u003ccode\u003ereplace\u003c/code\u003e로 설정됩니다. 경로는 계속해서 와이드 문자(wide characters)로 디코딩되고 \u003ccode\u003e*W\u003c/code\u003e API만 호출되지만, Python에 전달되고 Python에서 수신되는 \u003ccode\u003ebytes\u003c/code\u003e는 이 변경 이전과 동일하게 인코딩됩니다.\u003c/p\u003e\n\u003ch3\u003eWindows에서 bytes 경로 사용에 대한 deprecation 해제 (Undeprecate bytes paths on Windows)\u003c/h3\u003e\n\u003cp\u003eWindows에서 \u003ccode\u003ebytes\u003c/code\u003e를 경로로 사용하는 것은 현재 deprecated 되어 있습니다. 이 제안에서는 더 이상 그렇지 않으며, \u003ccode\u003ebytes\u003c/code\u003e로 인코딩된 경로는 사용자의 활성 코드 페이지 대신 \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e에서 반환되는 것을 사용해야 한다고 발표할 것입니다.\u003c/p\u003e\n\u003ch3\u003e베타 실험 (Beta experiment)\u003c/h3\u003e\n\u003cp\u003e이 변경의 영향을 확인하기 위해, 3.6.0b1에 잠정적으로 적용하고 3.6.0b4 이전에 최종 결정을 내릴 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e실험 기간 동안, 디코딩 및 인코딩 예외 메시지는 활성 온라인 토론 링크를 포함하도록 확장되어 문제 보고를 장려할 것입니다.\u003c/p\u003e\n\u003cp\u003e3.6.0b4에서 기능을 되돌리기로 결정되면, 구현 변경은 레거시 모드 플래그를 영구적으로 활성화하고, 환경 변수를 \u003ccode\u003ePYTHONWINDOWSUTF8FSENCODING\u003c/code\u003e으로, 함수를 \u003ccode\u003esys._enablewindowsutf8fsencoding()\u003c/code\u003e으로 변경하여 기능을 비활성화하는 대신 사례별로 활성화할 수 있도록 할 것입니다.\u003c/p\u003e\n\u003cp\u003e호환성 문제로 인해 3.6에서 변경을 실행할 수 없는 경우, Python 3.x의 어떤 후기 버전에서도 변경을 실행할 수 없을 것으로 예상됩니다.\u003c/p\u003e\n\u003ch3\u003e영향을 받는 모듈 (Affected Modules)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 경로 이름을 운영 체제에 전달하거나 \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e을 사용하는 Python 내의 모든 모듈을 암묵적으로 포함합니다.\u003c/p\u003e\n\u003cp\u003e3.6.0a4 기준으로 다음 모듈은 수정이 필요합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eos\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_overlapped\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_socket\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esubprocess\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ezipimport\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 모듈은 \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e을 사용하지만 수정이 필요하지 않습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egc\u003c/code\u003e (이미 \u003ccode\u003ebytes\u003c/code\u003e를 \u003ccode\u003eutf-8\u003c/code\u003e로 가정합니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egrp\u003c/code\u003e (Windows용으로 컴파일되지 않습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehttp.server\u003c/code\u003e (전송된 데이터에 코덱 이름을 올바르게 포함합니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eidlelib.editor\u003c/code\u003e (필요하지 않을 것입니다; 대체 처리 기능이 있습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enis\u003c/code\u003e (Windows용으로 컴파일되지 않습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epwd\u003c/code\u003e (Windows용으로 컴파일되지 않습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003espwd\u003c/code\u003e (Windows용으로 컴파일되지 않습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_ssl\u003c/code\u003e (ASCII 상수에만 사용됩니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etarfile\u003c/code\u003e (Windows에서 사용되지 않는 코드입니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_tkinter\u003c/code\u003e (이미 \u003ccode\u003ebytes\u003c/code\u003e를 \u003ccode\u003eutf-8\u003c/code\u003e로 가정합니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewsgiref\u003c/code\u003e (알 수 없는 환경의 기본 인코딩으로 가정됩니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ezipapp\u003c/code\u003e (Windows에서 사용되지 않는 코드입니다)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 네이티브 코드는 인코딩 또는 디코딩 함수 중 하나를 사용하지만 수정이 필요하지 않습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eParser/parsetok.c\u003c/code\u003e (문서에 이미 \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e이 지정되어 있습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/ast.c\u003c/code\u003e (문서에 이미 \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e이 지정되어 있습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/compile.c\u003c/code\u003e (문서화되지 않았지만 Python 파일 시스템 인코딩이 암시되어 있습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/errors.c\u003c/code\u003e (문서에 이미 \u003ccode\u003eos.fsdecode()\u003c/code\u003e가 지정되어 있습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/fileutils.c\u003c/code\u003e (Windows에서 사용되지 않는 코드입니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/future.c\u003c/code\u003e (문서화되지 않았지만 Python 파일 시스템 인코딩이 암시되어 있습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/import.c\u003c/code\u003e (문서에 이미 \u003ccode\u003eutf-8\u003c/code\u003e이 지정되어 있습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/importdl.c\u003c/code\u003e (Windows에서 사용되지 않는 코드입니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/pythonrun.c\u003c/code\u003e (문서에 이미 \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e이 지정되어 있습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/symtable.c\u003c/code\u003e (문서화되지 않았지만 Python 파일 시스템 인코딩이 암시되어 있습니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/thread.c\u003c/code\u003e (Windows에서 사용되지 않는 코드입니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/traceback.c\u003c/code\u003e (문자열 비교를 위해 올바르게 인코딩됩니다)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/_warnings.c\u003c/code\u003e (문서에 이미 \u003ccode\u003eos.fsdecode()\u003c/code\u003e가 지정되어 있습니다)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e거부된 대안 (Rejected Alternatives)\u003c/h2\u003e\n\u003ch3\u003e'strict mbcs' 디코딩 사용\u003c/h3\u003e\n\u003cp\u003e이 대안은 본질적으로 제안된 변경과 동일하지만, \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e을 \u003ccode\u003eutf-8\u003c/code\u003e 대신 \u003ccode\u003embcs\u003c/code\u003e로 변경합니다 (이는 활성 코드 페이지에 동적으로 매핑됩니다).\u003c/p\u003e\n\u003cp\u003e이 접근 방식은 \u003ccode\u003e*W\u003c/code\u003e API로만 사용 가능한 새로운 기능을 사용할 수 있게 하고, 인코딩/디코딩 오류 감지도 가능하게 합니다. 예를 들어, Unicode 문자를 '?'로 자동으로 대체하는 대신 경고하거나 작업을 실패하게 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e제안된 해결책과 비교할 때, 이는 일부 새로운 기능을 활성화할 수 있지만 처음에 설명된 문제 중 어떤 것도 해결하지 못합니다. 새로운 런타임 오류는 일부 문제를 더 명확하게 만들고 수정으로 이어질 수 있지만, 이는 라이브러리 관리자가 Windows를 지원하고 파일 시스템 경로를 문자열로 처리하기 위한 별도의 코드 경로를 추가하는 데 관심이 있는 경우에 한정됩니다.\u003c/p\u003e\n\u003cp\u003e엄격한 오류 없이 인코딩을 \u003ccode\u003embcs\u003c/code\u003e로 만드는 것은 레거시 모드 스위치가 기본적으로 활성화된 것과 동일합니다. 실제 코드에서 상당한 문제가 발생하고 deprecation 기간을 연장해야 할 필요가 있지만, 여전히 CPython 소스의 단순화를 원하는 경우 가능한 조치입니다.\u003c/p\u003e\n\u003ch3\u003eWindows에서 bytes 경로 사용을 오류로 처리\u003c/h3\u003e\n\u003cp\u003eWindows에서 \u003ccode\u003ebytes\u003c/code\u003e 경로 사용을 완전히 막음으로써 사용자가 인코딩 문제를 겪지 않도록 합니다.\u003c/p\u003e\n\u003cp\u003e그러나 이 PEP의 동기는 POSIX에서 작성된 코드가 Windows에서도 올바르게 작동할 가능성을 높이는 것입니다. 이 대안은 반대 방향으로 나아가 그러한 코드를 완전히 호환되지 않게 만들 것입니다. 이는 사용자에게 어떤 식으로든 이점을 제공하지 않으므로 거부합니다.\u003c/p\u003e\n\u003ch3\u003e모든 플랫폼에서 bytes 경로 사용을 오류로 처리\u003c/h3\u003e\n\u003cp\u003e모든 플랫폼에서 \u003ccode\u003ebytes\u003c/code\u003e 경로 사용을 deprecated하고 비활성화함으로써, 코드가 원래 작성된 위치와 상관없이 사용자가 인코딩 문제를 겪는 것을 방지합니다. Windows 이외의 플랫폼에서는 현재 경고가 없으므로 완전한 deprecation 주기가 필요할 것입니다.\u003c/p\u003e\n\u003cp\u003e이는 일반적으로 Python 개발자들에게 적대적인 조치로 간주될 가능성이 높으므로 현재는 거부됩니다.\u003c/p\u003e\n\u003ch2\u003e잠재적으로 문제가 발생할 수 있는 코드 (Code that may break)\u003c/h2\u003e\n\u003cp\u003e다음 코드 패턴은 이 변경으로 인해 문제가 발생하거나 다른 동작을 보일 수 있습니다. 이러한 각 예시는 크로스 플랫폼 사용을 염두에 둔 코드에서 취약했을 것입니다. 제안된 수정 사항은 모든 플랫폼과 여러 Python 버전에서 경로 인코딩 문제를 처리하는 가장 호환 가능한 방법을 보여줍니다.\u003c/p\u003e\n\u003cp\u003e참고: 이 모든 예시는 Python 3.3 이상에서 deprecation 경고를 생성합니다.\u003c/p\u003e\n\u003ch3\u003e경계 간 인코딩 관리 실패\u003c/h3\u003e\n\u003cp\u003e프로토콜 경계를 넘을 때 인코딩을 관리하지 않는 코드는 현재 우연히 작동할 수 있지만, 인코딩이 변경될 때 문제가 발생할 수 있습니다. \u003ccode\u003efilename\u003c/code\u003e의 소스는 아래 두 번째 예시에서와 같이 \u003ccode\u003ebytes\u003c/code\u003e 객체를 반환하는 모든 함수가 될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e filename = open('filename_in_mbcs.txt', 'rb').read()\n\u003e\u003e\u003e text = open(filename, 'r').read()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드를 수정하려면, \u003ccode\u003efilename\u003c/code\u003e의 \u003ccode\u003ebytes\u003c/code\u003e 인코딩을 파일에서 읽을 때 또는 값을 사용하기 전에 지정해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e # Fix 1: 파일을 텍스트로 엽니다 (기본 인코딩)\n\u003e\u003e\u003e filename = open('filename_in_mbcs.txt', 'r').read()\n\u003e\u003e\u003e text = open(filename, 'r').read()\n\u003e\u003e\u003e # Fix 2: 파일을 텍스트로 엽니다 (명시적 인코딩)\n\u003e\u003e\u003e filename = open('filename_in_mbcs.txt', 'r', encoding='mbcs').read()\n\u003e\u003e\u003e text = open(filename, 'r').read()\n\u003e\u003e\u003e # Fix 3: 경로를 명시적으로 디코딩합니다\n\u003e\u003e\u003e filename = open('filename_in_mbcs.txt', 'rb').read()\n\u003e\u003e\u003e text = open(filename.decode('mbcs'), 'r').read()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efilename\u003c/code\u003e의 생성자가 \u003ccode\u003efilename\u003c/code\u003e의 사용자와 분리된 경우, 인코딩은 포함해야 할 중요한 정보입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e some_object.filename = r'C:\\Users\\Steve\\Documents\\my_file.txt'.encode('mbcs')\n\u003e\u003e\u003e filename = some_object.filename\n\u003e\u003e\u003e type(filename)\n\u0026#x3C;class 'bytes'\u003e\n\u003e\u003e\u003e text = open(filename, 'r').read()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드를 운영 체제 및 Python 버전 전반에 걸쳐 최고의 호환성을 위해 수정하려면 \u003ccode\u003efilename\u003c/code\u003e을 \u003ccode\u003estr\u003c/code\u003e로 노출해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e # Fix 1: str로 노출\n\u003e\u003e\u003e some_object.filename = r'C:\\Users\\Steve\\Documents\\my_file.txt'\n\u003e\u003e\u003e filename = some_object.filename\n\u003e\u003e\u003e type(filename)\n\u0026#x3C;class 'str'\u003e\n\u003e\u003e\u003e text = open(filename, 'r').read()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 경로에 사용된 인코딩을 사용자에게 제공해야 합니다. \u003ccode\u003eos.fsencode()\u003c/code\u003e (또는 \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e)를 지정하는 것은 허용 가능한 선택이며, 정확한 인코딩을 가진 새 속성을 추가할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e # Fix 2: fsencode 사용\n\u003e\u003e\u003e some_object.filename = os.fsencode(r'C:\\Users\\Steve\\Documents\\my_file.txt')\n\u003e\u003e\u003e filename = some_object.filename\n\u003e\u003e\u003e type(filename)\n\u0026#x3C;class 'bytes'\u003e\n\u003e\u003e\u003e text = open(filename, 'r').read()\n\u003e\u003e\u003e # Fix 3: 명시적 인코딩으로 노출\n\u003e\u003e\u003e some_object.filename = r'C:\\Users\\Steve\\Documents\\my_file.txt'.encode('cp437')\n\u003e\u003e\u003e some_object.filename_encoding = 'cp437'\n\u003e\u003e\u003e filename = some_object.filename\n\u003e\u003e\u003e type(filename)\n\u0026#x3C;class 'bytes'\u003e\n\u003e\u003e\u003e filename = filename.decode(some_object.filename_encoding)\n\u003e\u003e\u003e type(filename)\n\u0026#x3C;class 'str'\u003e\n\u003e\u003e\u003e text = open(filename, 'r').read()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e'mbcs'를 명시적으로 사용\u003c/h3\u003e\n\u003cp\u003e파일 시스템 API에 전달하기 전에 'mbcs'를 사용하여 텍스트를 명시적으로 인코딩하는 코드는 이제 잘못 인코딩된 \u003ccode\u003ebytes\u003c/code\u003e를 전달합니다. 이 예시에서 \u003ccode\u003efilename\u003c/code\u003e의 소스는 \u003ccode\u003estr\u003c/code\u003e인 한 중요하지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e filename = open('files.txt', 'r').readline().rstrip()\n\u003e\u003e\u003e text = open(filename.encode('mbcs'), 'r')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드를 수정하려면 문자열을 명시적인 인코딩 없이 전달하거나 \u003ccode\u003eos.fsencode()\u003c/code\u003e를 사용해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e # Fix 1: 문자열을 인코딩하지 않습니다\n\u003e\u003e\u003e filename = open('files.txt', 'r').readline().rstrip()\n\u003e\u003e\u003e text = open(filename, 'r')\n\u003e\u003e\u003e # Fix 2: 올바른 인코딩 사용\n\u003e\u003e\u003e filename = open('files.txt', 'r').readline().rstrip()\n\u003e\u003e\u003e text = open(os.fsencode(filename), 'r')\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 529 - Change Windows filesystem encoding to UTF-8\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:20:53+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>