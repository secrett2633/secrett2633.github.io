<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-287dd7aad5349a53.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1599<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 443 - Single-dispatch generic functions</h1><div class="page__meta"><time dateTime="2025-09-26 21:55:16+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0443/">PEP 443 - Single-dispatch generic functions</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 22-May-2013</p>
</blockquote>
<h1>PEP 443: Single-dispatch Generic Functions</h1>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 <code>functools</code> 표준 라이브러리 모듈에 "단일 디스패치 제네릭 함수(single-dispatch generic functions)"라고 알려진 간단한 형태의 제네릭 프로그래밍을 제공하는 새로운 메커니즘을 제안합니다.</p>
<p>**제네릭 함수(Generic function)**는 서로 다른 타입(type)에 대해 동일한 연산을 구현하는 여러 함수로 구성됩니다. 호출 시 어떤 구현을 사용할지는 디스패치(dispatch) 알고리즘에 의해 결정됩니다. 특히, 단일 인자(single argument)의 타입에 따라 구현이 선택될 때 이를 **단일 디스패치(single dispatch)**라고 합니다.</p>
<h2>배경 및 목표 (Rationale and Goals)</h2>
<p>Python은 <code>len()</code>, <code>iter()</code>, <code>pprint.pprint()</code>, <code>copy.copy()</code> 등 다양한 내장 및 표준 라이브러리 제네릭 함수를 제공해왔습니다. 그러나 현재는 다음과 같은 문제점이 있습니다:</p>
<ul>
<li>개발자가 새로운 제네릭 함수를 생성하는 간단하거나 직접적인 방법이 없습니다.</li>
<li>기존 제네릭 함수에 메서드를 추가하는 표준적인 방법이 없습니다. (예: 일부는 등록 함수를 사용하고, 다른 일부는 <code>__special__</code> 메서드 정의를 요구하며, 경우에 따라 몽키 패치(monkeypatching)가 필요합니다.)</li>
</ul>
<p>또한, Python 코드에서 객체에 대해 무엇을 할지 결정하기 위해 수신된 인자의 타입을 검사하는 것이 일반적인 안티 패턴(anti-pattern)입니다. 예를 들어, 어떤 타입의 객체 또는 해당 타입 객체의 시퀀스를 받아들이고 싶을 때, 현재는 타입 검사를 통해 처리하는 것이 "명백한 방법"이지만, 이는 취약하고 확장성이 떨어집니다.</p>
<p><code>Abstract Base Classes (ABC)</code>는 현재 동작을 쉽게 파악할 수 있도록 돕지만, 새로운 동작을 추가하는 데는 도움이 되지 않습니다. 이미 작성된 라이브러리를 사용하는 개발자는 해당 코드가 자신의 객체를 처리하는 방식을 변경할 수 없을 수 있으며, 특히 서드 파티(third-party)에서 생성된 객체를 사용하는 경우 더욱 그렇습니다.</p>
<p>따라서 이 PEP는 데코레이터(decorator)를 사용하여 동적 오버로딩(dynamic overloading)을 처리하기 위한 통일된 API를 제안합니다.</p>
<h2>사용자 API (User API)</h2>
<p>제네릭 함수를 정의하려면 <code>@singledispatch</code> 데코레이터를 사용합니다. 디스패치는 첫 번째 인자의 타입에 따라 발생합니다.</p>
<pre><code class="language-python">from functools import singledispatch

@singledispatch
def fun(arg, verbose=False):
    if verbose:
        print("Let me just say,", end=" ")
    print(arg)
</code></pre>
<p>오버로드(overloaded)된 구현을 함수에 추가하려면 제네릭 함수의 <code>register()</code> 속성을 사용합니다. 이는 타입 파라미터(type parameter)를 받고 해당 타입에 대한 연산을 구현하는 함수를 데코레이트하는 데코레이터입니다.</p>
<pre><code class="language-python">@fun.register(int)
def _(arg, verbose=False):
    if verbose:
        print("Strength in numbers, eh?", end=" ")
    print(arg)

@fun.register(list)
def _(arg, verbose=False):
    if verbose:
        print("Enumerate this:")
    for i, elem in enumerate(arg):
        print(i, elem)
</code></pre>
<p>람다(lambda) 함수나 이미 존재하는 함수를 등록하려면 <code>register()</code> 속성을 함수 형태로 사용할 수 있습니다.</p>
<pre><code class="language-python">def nothing(arg, verbose=False):
    print("Nothing.")

fun.register(type(None), nothing)
</code></pre>
<p><code>register()</code> 속성은 데코레이트되지 않은 함수를 반환합니다. 이를 통해 데코레이터 스태킹(stacking), 피클링(pickling), 그리고 각 변형에 대한 독립적인 단위 테스트(unit test) 생성이 가능합니다.</p>
<pre><code class="language-python">from decimal import Decimal

@fun.register(float)
@fun.register(Decimal)
def fun_num(arg, verbose=False):
    if verbose:
        print("Half of your number:", end=" ")
    print(arg / 2)

fun_num is fun # False
</code></pre>
<p>호출될 때, 제네릭 함수는 첫 번째 인자의 타입에 따라 디스패치됩니다.</p>
<pre><code class="language-python">fun("Hello, world.")
# Hello, world.
fun("test.", verbose=True)
# Let me just say, test. test.
fun(42, verbose=True)
# Strength in numbers, eh? 42
fun(['spam', 'spam', 'eggs', 'spam'], verbose=True)
# Enumerate this:
# 0 spam
# 1 spam
# 2 eggs
# 3 spam
fun(None)
# Nothing.
fun(1.23)
# 0.615
</code></pre>
<p>특정 타입에 대한 등록된 구현이 없는 경우, 해당 타입의 메서드 결정 순서(Method Resolution Order, MRO)를 사용하여 더 일반적인 구현을 찾습니다. <code>@singledispatch</code>로 데코레이트된 원본 함수는 <code>object</code> 타입에 등록되어 있으며, 이는 더 나은 구현이 없을 때 사용됩니다.</p>
<p>주어진 타입에 대해 제네릭 함수가 어떤 구현을 선택할지 확인하려면 <code>dispatch()</code> 속성을 사용합니다.</p>
<pre><code class="language-python">fun.dispatch(float)
# &#x3C;function fun_num at 0x...>
fun.dispatch(dict) # 기본 구현
# &#x3C;function fun at 0x...>
</code></pre>
<p>모든 등록된 구현에 접근하려면 읽기 전용 <code>registry</code> 속성을 사용합니다.</p>
<pre><code class="language-python">fun.registry.keys()
# dict_keys([&#x3C;class 'NoneType'>, &#x3C;class 'int'>, &#x3C;class 'object'>, &#x3C;class 'decimal.Decimal'>, &#x3C;class 'list'>, &#x3C;class 'float'>])
fun.registry[float]
# &#x3C;function fun_num at 0x...>
fun.registry[object]
# &#x3C;function fun at 0x...>
</code></pre>
<p>제안된 API는 설명하고 사용하기 쉬우며 <code>functools</code> 모듈의 기존 멤버들과 일관성을 유지하기 위해 의도적으로 제한적이고 독자적인 의견을 담고 있습니다.</p>
<h2>구현 노트 (Implementation Notes)</h2>
<p>이 PEP에서 설명하는 기능은 <code>pkgutil</code> 표준 라이브러리 모듈에 <code>simplegeneric</code>으로 이미 구현되어 있습니다. 이 구현이 성숙했기 때문에, 대부분 그대로 옮겨지는 것이 목표입니다.</p>
<p>디스패치 타입은 데코레이터 인자(argument)로 지정됩니다. 함수 어노테이션(annotation)을 사용하는 대안적인 형태가 고려되었으나, 표준 라이브러리의 범위를 벗어나고 어노테이션 사용에 대한 모범 사례가 여전히 논의 중이므로 포함이 거부되었습니다.</p>
<p>현재 <code>pkgutil.simplegeneric</code> 구현을 기반으로 하며, <code>Abstract Base Classes</code>에 가상 서브클래스(virtual subclass)를 등록하는 규칙에 따라 디스패치 레지스트리(registry)는 스레드 안전(thread-safe)하지 않습니다.</p>
<h2>Abstract Base Classes (추상 기본 클래스)</h2>
<p><code>pkgutil.simplegeneric</code> 구현은 여러 형태의 MRO에 의존했습니다. <code>@singledispatch</code>는 old-style 클래스 및 Zope의 <code>ExtensionClasses</code>에 대한 특별한 처리를 제거하고, 더 중요하게는 <code>Abstract Base Classes (ABC)</code>에 대한 지원을 도입합니다.</p>
<p>제네릭 함수 구현이 ABC에 등록될 때, 디스패치 알고리즘은 제공된 인자의 MRO에 관련 ABC를 포함하는 확장된 형태의 C3 선형화(linearization)로 전환됩니다. 이 알고리즘은 ABC가 기능적으로 도입되는 지점, 즉 <code>issubclass(cls, abc)</code>가 클래스 자체에 대해 <code>True</code>를 반환하지만 모든 직접적인 기본 클래스에 대해서는 <code>False</code>를 반환하는 위치에 ABC를 삽입합니다.</p>
<p>이 작동 방식은 상당히 느리지만, 모든 디스패치 결정은 캐시됩니다. 캐시는 제네릭 함수에 새로운 구현을 등록하거나 사용자 코드가 ABC에 <code>register()</code>를 호출하여 암시적으로 서브클래스화할 때 무효화됩니다. 이러한 경우, 모호한 디스패치 상황이 발생할 수 있습니다. 예를 들어, <code>Iterable</code>과 <code>Container</code> 모두에 <code>P</code> 클래스가 등록되었을 때, <code>singledispatch</code>는 <code>RuntimeError: Ambiguous dispatch</code> 예외를 발생시킵니다.</p>
<p>하지만 클래스 정의 시 하나 이상의 ABC가 명시적으로 기본 클래스로 제공된 경우에는 이러한 예외가 발생하지 않으며, 디스패치는 MRO 순서대로 이루어집니다.</p>
<p><code>__len__()</code> 또는 <code>__contains__()</code>와 같은 특수 메서드의 존재로부터 ABC의 서브클래스화가 추론될 때도 유사한 충돌이 발생할 수 있습니다.</p>
<h2>사용 패턴 (Usage Patterns)</h2>
<p>이 PEP는 제네릭으로 명시적으로 표시된 함수에 대해서만 동작 확장을 제안합니다. 기본 클래스 메서드가 서브클래스에 의해 오버라이드(override)될 수 있는 것처럼, 함수도 주어진 타입에 대한 커스텀 기능을 제공하기 위해 오버로드될 수 있습니다.</p>
<p>범용 오버로딩(Universal overloading)이 임의의 오버로딩을 의미하지는 않습니다. 실제 프로그램에서 제네릭 함수 사용은 매우 예측 가능한 패턴을 따르며, 등록된 구현은 일반적인 경우 쉽게 발견할 수 있습니다.</p>
<p>모듈이 새로운 제네릭 연산을 정의하는 경우, 일반적으로 기존 타입에 필요한 구현도 같은 곳에 정의합니다. 마찬가지로, 모듈이 새로운 타입을 정의하는 경우, 해당 타입과 관련된 제네릭 함수에 대한 구현을 정의합니다. 결과적으로, 대부분의 등록된 구현은 오버로드되는 함수 또는 새로 정의된 타입 옆에서 찾을 수 있습니다.</p>
<p>함수나 해당 타입이 없는 모듈에 구현이 등록되는 경우는 드뭅니다.</p>
<p>앞서 언급했듯이, 단일 디스패치 제네릭은 표준 라이브러리 전반에 걸쳐 이미 널리 사용되고 있습니다. 이를 위한 깔끔하고 표준적인 방법은 사용자 확장성(user extensibility)을 동시에 열어주면서, 이러한 커스텀 구현을 공통된 하나로 리팩토링(refactor)하는 길을 제공합니다.</p>
<h2>대안적 접근 방식 (Alternative approaches)</h2>
<ul>
<li><strong>PEP 3124 (Phillip J. Eby):</strong> 임의의 규칙 세트 기반 오버로딩(기본 구현은 인자 타입에 따라 디스패치), 인터페이스, 적응 및 메서드 결합을 포함하는 완전한 솔루션을 제안했습니다. PEAK-Rules는 이 PEP의 개념에 대한 참조 구현입니다. 이러한 광범위한 접근 방식은 본질적으로 복잡하여 합의에 도달하기 어렵습니다. 반면 이 PEP는 이해하기 쉬운 단일 기능에 중점을 둡니다.</li>
<li><strong>다중 인자 디스패치:</strong> 2005년 Artima 기사에서 Guido van Rossum은 함수의 모든 인자 타입에 따라 디스패치하는 제네릭 함수 구현을 제시했습니다. Andrey Popp의 <code>generic</code> 패키지와 David Mertz의 <code>gnosis.magic.multimethods</code>에서도 동일한 접근 방식을 선택했습니다. 하지만 Fredrik Lundh의 의견처럼 "함수가 어떤 코드를 실행해야 할지 분류하기 위해 수많은 로직으로 API를 설계한다면, API 설계를 다른 사람에게 넘겨야 할 것"이라는 관점에 동의합니다. 즉, 이 PEP에서 제안하는 단일 인자 접근 방식은 구현하기 더 쉬울 뿐만 아니라, 더 복잡한 상태에 대한 디스패치가 안티 패턴임을 명확하게 전달합니다. 또한 객체 지향 프로그래밍의 친숙한 메서드 디스패치 메커니즘과 직접적으로 일치한다는 장점도 있습니다.</li>
<li><strong>PyPy의 RPython <code>extendabletype</code>:</strong> 이는 클래스를 외부에서 확장할 수 있게 하는 메타클래스(metaclass)입니다. <code>pairtype()</code> 및 <code>pair()</code> 팩토리와 함께 단일 디스패치 제네릭의 한 형태를 제공합니다.</li>
</ul>
<h2>감사의 글 (Acknowledgements)</h2>
<p>Phillip J. Eby의 PEP 3124 및 PEAK-Rules 작업 외에도, <code>pkgutil.simplegeneric</code>을 <code>functools</code> API의 일부로 노출할 것을 제안한 Paul Moore의 원래 이슈, 멀티메서드에 대한 Guido van Rossum의 기사, 그리고 일반적인 <code>pprint</code> 재작성에 대한 Raymond Hettinger와의 논의 등이 영향을 미쳤습니다. 이 PEP를 만들고 초기 피드백을 제공해준 Alyssa Coghlan에게 감사드립니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-287dd7aad5349a53.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/443\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"UDStqnFgkjod-k9ijxbnd\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/443/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/443\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"443\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/443\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T3530,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0443/\"\u003ePEP 443 - Single-dispatch generic functions\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 22-May-2013\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 443: Single-dispatch Generic Functions\u003c/h1\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003efunctools\u003c/code\u003e 표준 라이브러리 모듈에 \"단일 디스패치 제네릭 함수(single-dispatch generic functions)\"라고 알려진 간단한 형태의 제네릭 프로그래밍을 제공하는 새로운 메커니즘을 제안합니다.\u003c/p\u003e\n\u003cp\u003e**제네릭 함수(Generic function)**는 서로 다른 타입(type)에 대해 동일한 연산을 구현하는 여러 함수로 구성됩니다. 호출 시 어떤 구현을 사용할지는 디스패치(dispatch) 알고리즘에 의해 결정됩니다. 특히, 단일 인자(single argument)의 타입에 따라 구현이 선택될 때 이를 **단일 디스패치(single dispatch)**라고 합니다.\u003c/p\u003e\n\u003ch2\u003e배경 및 목표 (Rationale and Goals)\u003c/h2\u003e\n\u003cp\u003ePython은 \u003ccode\u003elen()\u003c/code\u003e, \u003ccode\u003eiter()\u003c/code\u003e, \u003ccode\u003epprint.pprint()\u003c/code\u003e, \u003ccode\u003ecopy.copy()\u003c/code\u003e 등 다양한 내장 및 표준 라이브러리 제네릭 함수를 제공해왔습니다. 그러나 현재는 다음과 같은 문제점이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e개발자가 새로운 제네릭 함수를 생성하는 간단하거나 직접적인 방법이 없습니다.\u003c/li\u003e\n\u003cli\u003e기존 제네릭 함수에 메서드를 추가하는 표준적인 방법이 없습니다. (예: 일부는 등록 함수를 사용하고, 다른 일부는 \u003ccode\u003e__special__\u003c/code\u003e 메서드 정의를 요구하며, 경우에 따라 몽키 패치(monkeypatching)가 필요합니다.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한, Python 코드에서 객체에 대해 무엇을 할지 결정하기 위해 수신된 인자의 타입을 검사하는 것이 일반적인 안티 패턴(anti-pattern)입니다. 예를 들어, 어떤 타입의 객체 또는 해당 타입 객체의 시퀀스를 받아들이고 싶을 때, 현재는 타입 검사를 통해 처리하는 것이 \"명백한 방법\"이지만, 이는 취약하고 확장성이 떨어집니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eAbstract Base Classes (ABC)\u003c/code\u003e는 현재 동작을 쉽게 파악할 수 있도록 돕지만, 새로운 동작을 추가하는 데는 도움이 되지 않습니다. 이미 작성된 라이브러리를 사용하는 개발자는 해당 코드가 자신의 객체를 처리하는 방식을 변경할 수 없을 수 있으며, 특히 서드 파티(third-party)에서 생성된 객체를 사용하는 경우 더욱 그렇습니다.\u003c/p\u003e\n\u003cp\u003e따라서 이 PEP는 데코레이터(decorator)를 사용하여 동적 오버로딩(dynamic overloading)을 처리하기 위한 통일된 API를 제안합니다.\u003c/p\u003e\n\u003ch2\u003e사용자 API (User API)\u003c/h2\u003e\n\u003cp\u003e제네릭 함수를 정의하려면 \u003ccode\u003e@singledispatch\u003c/code\u003e 데코레이터를 사용합니다. 디스패치는 첫 번째 인자의 타입에 따라 발생합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom functools import singledispatch\n\n@singledispatch\ndef fun(arg, verbose=False):\n    if verbose:\n        print(\"Let me just say,\", end=\" \")\n    print(arg)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e오버로드(overloaded)된 구현을 함수에 추가하려면 제네릭 함수의 \u003ccode\u003eregister()\u003c/code\u003e 속성을 사용합니다. 이는 타입 파라미터(type parameter)를 받고 해당 타입에 대한 연산을 구현하는 함수를 데코레이트하는 데코레이터입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@fun.register(int)\ndef _(arg, verbose=False):\n    if verbose:\n        print(\"Strength in numbers, eh?\", end=\" \")\n    print(arg)\n\n@fun.register(list)\ndef _(arg, verbose=False):\n    if verbose:\n        print(\"Enumerate this:\")\n    for i, elem in enumerate(arg):\n        print(i, elem)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e람다(lambda) 함수나 이미 존재하는 함수를 등록하려면 \u003ccode\u003eregister()\u003c/code\u003e 속성을 함수 형태로 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef nothing(arg, verbose=False):\n    print(\"Nothing.\")\n\nfun.register(type(None), nothing)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eregister()\u003c/code\u003e 속성은 데코레이트되지 않은 함수를 반환합니다. 이를 통해 데코레이터 스태킹(stacking), 피클링(pickling), 그리고 각 변형에 대한 독립적인 단위 테스트(unit test) 생성이 가능합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom decimal import Decimal\n\n@fun.register(float)\n@fun.register(Decimal)\ndef fun_num(arg, verbose=False):\n    if verbose:\n        print(\"Half of your number:\", end=\" \")\n    print(arg / 2)\n\nfun_num is fun # False\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e호출될 때, 제네릭 함수는 첫 번째 인자의 타입에 따라 디스패치됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efun(\"Hello, world.\")\n# Hello, world.\nfun(\"test.\", verbose=True)\n# Let me just say, test. test.\nfun(42, verbose=True)\n# Strength in numbers, eh? 42\nfun(['spam', 'spam', 'eggs', 'spam'], verbose=True)\n# Enumerate this:\n# 0 spam\n# 1 spam\n# 2 eggs\n# 3 spam\nfun(None)\n# Nothing.\nfun(1.23)\n# 0.615\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e특정 타입에 대한 등록된 구현이 없는 경우, 해당 타입의 메서드 결정 순서(Method Resolution Order, MRO)를 사용하여 더 일반적인 구현을 찾습니다. \u003ccode\u003e@singledispatch\u003c/code\u003e로 데코레이트된 원본 함수는 \u003ccode\u003eobject\u003c/code\u003e 타입에 등록되어 있으며, 이는 더 나은 구현이 없을 때 사용됩니다.\u003c/p\u003e\n\u003cp\u003e주어진 타입에 대해 제네릭 함수가 어떤 구현을 선택할지 확인하려면 \u003ccode\u003edispatch()\u003c/code\u003e 속성을 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efun.dispatch(float)\n# \u0026#x3C;function fun_num at 0x...\u003e\nfun.dispatch(dict) # 기본 구현\n# \u0026#x3C;function fun at 0x...\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 등록된 구현에 접근하려면 읽기 전용 \u003ccode\u003eregistry\u003c/code\u003e 속성을 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efun.registry.keys()\n# dict_keys([\u0026#x3C;class 'NoneType'\u003e, \u0026#x3C;class 'int'\u003e, \u0026#x3C;class 'object'\u003e, \u0026#x3C;class 'decimal.Decimal'\u003e, \u0026#x3C;class 'list'\u003e, \u0026#x3C;class 'float'\u003e])\nfun.registry[float]\n# \u0026#x3C;function fun_num at 0x...\u003e\nfun.registry[object]\n# \u0026#x3C;function fun at 0x...\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제안된 API는 설명하고 사용하기 쉬우며 \u003ccode\u003efunctools\u003c/code\u003e 모듈의 기존 멤버들과 일관성을 유지하기 위해 의도적으로 제한적이고 독자적인 의견을 담고 있습니다.\u003c/p\u003e\n\u003ch2\u003e구현 노트 (Implementation Notes)\u003c/h2\u003e\n\u003cp\u003e이 PEP에서 설명하는 기능은 \u003ccode\u003epkgutil\u003c/code\u003e 표준 라이브러리 모듈에 \u003ccode\u003esimplegeneric\u003c/code\u003e으로 이미 구현되어 있습니다. 이 구현이 성숙했기 때문에, 대부분 그대로 옮겨지는 것이 목표입니다.\u003c/p\u003e\n\u003cp\u003e디스패치 타입은 데코레이터 인자(argument)로 지정됩니다. 함수 어노테이션(annotation)을 사용하는 대안적인 형태가 고려되었으나, 표준 라이브러리의 범위를 벗어나고 어노테이션 사용에 대한 모범 사례가 여전히 논의 중이므로 포함이 거부되었습니다.\u003c/p\u003e\n\u003cp\u003e현재 \u003ccode\u003epkgutil.simplegeneric\u003c/code\u003e 구현을 기반으로 하며, \u003ccode\u003eAbstract Base Classes\u003c/code\u003e에 가상 서브클래스(virtual subclass)를 등록하는 규칙에 따라 디스패치 레지스트리(registry)는 스레드 안전(thread-safe)하지 않습니다.\u003c/p\u003e\n\u003ch2\u003eAbstract Base Classes (추상 기본 클래스)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003epkgutil.simplegeneric\u003c/code\u003e 구현은 여러 형태의 MRO에 의존했습니다. \u003ccode\u003e@singledispatch\u003c/code\u003e는 old-style 클래스 및 Zope의 \u003ccode\u003eExtensionClasses\u003c/code\u003e에 대한 특별한 처리를 제거하고, 더 중요하게는 \u003ccode\u003eAbstract Base Classes (ABC)\u003c/code\u003e에 대한 지원을 도입합니다.\u003c/p\u003e\n\u003cp\u003e제네릭 함수 구현이 ABC에 등록될 때, 디스패치 알고리즘은 제공된 인자의 MRO에 관련 ABC를 포함하는 확장된 형태의 C3 선형화(linearization)로 전환됩니다. 이 알고리즘은 ABC가 기능적으로 도입되는 지점, 즉 \u003ccode\u003eissubclass(cls, abc)\u003c/code\u003e가 클래스 자체에 대해 \u003ccode\u003eTrue\u003c/code\u003e를 반환하지만 모든 직접적인 기본 클래스에 대해서는 \u003ccode\u003eFalse\u003c/code\u003e를 반환하는 위치에 ABC를 삽입합니다.\u003c/p\u003e\n\u003cp\u003e이 작동 방식은 상당히 느리지만, 모든 디스패치 결정은 캐시됩니다. 캐시는 제네릭 함수에 새로운 구현을 등록하거나 사용자 코드가 ABC에 \u003ccode\u003eregister()\u003c/code\u003e를 호출하여 암시적으로 서브클래스화할 때 무효화됩니다. 이러한 경우, 모호한 디스패치 상황이 발생할 수 있습니다. 예를 들어, \u003ccode\u003eIterable\u003c/code\u003e과 \u003ccode\u003eContainer\u003c/code\u003e 모두에 \u003ccode\u003eP\u003c/code\u003e 클래스가 등록되었을 때, \u003ccode\u003esingledispatch\u003c/code\u003e는 \u003ccode\u003eRuntimeError: Ambiguous dispatch\u003c/code\u003e 예외를 발생시킵니다.\u003c/p\u003e\n\u003cp\u003e하지만 클래스 정의 시 하나 이상의 ABC가 명시적으로 기본 클래스로 제공된 경우에는 이러한 예외가 발생하지 않으며, 디스패치는 MRO 순서대로 이루어집니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__len__()\u003c/code\u003e 또는 \u003ccode\u003e__contains__()\u003c/code\u003e와 같은 특수 메서드의 존재로부터 ABC의 서브클래스화가 추론될 때도 유사한 충돌이 발생할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e사용 패턴 (Usage Patterns)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 제네릭으로 명시적으로 표시된 함수에 대해서만 동작 확장을 제안합니다. 기본 클래스 메서드가 서브클래스에 의해 오버라이드(override)될 수 있는 것처럼, 함수도 주어진 타입에 대한 커스텀 기능을 제공하기 위해 오버로드될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e범용 오버로딩(Universal overloading)이 임의의 오버로딩을 의미하지는 않습니다. 실제 프로그램에서 제네릭 함수 사용은 매우 예측 가능한 패턴을 따르며, 등록된 구현은 일반적인 경우 쉽게 발견할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e모듈이 새로운 제네릭 연산을 정의하는 경우, 일반적으로 기존 타입에 필요한 구현도 같은 곳에 정의합니다. 마찬가지로, 모듈이 새로운 타입을 정의하는 경우, 해당 타입과 관련된 제네릭 함수에 대한 구현을 정의합니다. 결과적으로, 대부분의 등록된 구현은 오버로드되는 함수 또는 새로 정의된 타입 옆에서 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e함수나 해당 타입이 없는 모듈에 구현이 등록되는 경우는 드뭅니다.\u003c/p\u003e\n\u003cp\u003e앞서 언급했듯이, 단일 디스패치 제네릭은 표준 라이브러리 전반에 걸쳐 이미 널리 사용되고 있습니다. 이를 위한 깔끔하고 표준적인 방법은 사용자 확장성(user extensibility)을 동시에 열어주면서, 이러한 커스텀 구현을 공통된 하나로 리팩토링(refactor)하는 길을 제공합니다.\u003c/p\u003e\n\u003ch2\u003e대안적 접근 방식 (Alternative approaches)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePEP 3124 (Phillip J. Eby):\u003c/strong\u003e 임의의 규칙 세트 기반 오버로딩(기본 구현은 인자 타입에 따라 디스패치), 인터페이스, 적응 및 메서드 결합을 포함하는 완전한 솔루션을 제안했습니다. PEAK-Rules는 이 PEP의 개념에 대한 참조 구현입니다. 이러한 광범위한 접근 방식은 본질적으로 복잡하여 합의에 도달하기 어렵습니다. 반면 이 PEP는 이해하기 쉬운 단일 기능에 중점을 둡니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e다중 인자 디스패치:\u003c/strong\u003e 2005년 Artima 기사에서 Guido van Rossum은 함수의 모든 인자 타입에 따라 디스패치하는 제네릭 함수 구현을 제시했습니다. Andrey Popp의 \u003ccode\u003egeneric\u003c/code\u003e 패키지와 David Mertz의 \u003ccode\u003egnosis.magic.multimethods\u003c/code\u003e에서도 동일한 접근 방식을 선택했습니다. 하지만 Fredrik Lundh의 의견처럼 \"함수가 어떤 코드를 실행해야 할지 분류하기 위해 수많은 로직으로 API를 설계한다면, API 설계를 다른 사람에게 넘겨야 할 것\"이라는 관점에 동의합니다. 즉, 이 PEP에서 제안하는 단일 인자 접근 방식은 구현하기 더 쉬울 뿐만 아니라, 더 복잡한 상태에 대한 디스패치가 안티 패턴임을 명확하게 전달합니다. 또한 객체 지향 프로그래밍의 친숙한 메서드 디스패치 메커니즘과 직접적으로 일치한다는 장점도 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePyPy의 RPython \u003ccode\u003eextendabletype\u003c/code\u003e:\u003c/strong\u003e 이는 클래스를 외부에서 확장할 수 있게 하는 메타클래스(metaclass)입니다. \u003ccode\u003epairtype()\u003c/code\u003e 및 \u003ccode\u003epair()\u003c/code\u003e 팩토리와 함께 단일 디스패치 제네릭의 한 형태를 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e감사의 글 (Acknowledgements)\u003c/h2\u003e\n\u003cp\u003ePhillip J. Eby의 PEP 3124 및 PEAK-Rules 작업 외에도, \u003ccode\u003epkgutil.simplegeneric\u003c/code\u003e을 \u003ccode\u003efunctools\u003c/code\u003e API의 일부로 노출할 것을 제안한 Paul Moore의 원래 이슈, 멀티메서드에 대한 Guido van Rossum의 기사, 그리고 일반적인 \u003ccode\u003epprint\u003c/code\u003e 재작성에 대한 Raymond Hettinger와의 논의 등이 영향을 미쳤습니다. 이 PEP를 만들고 초기 피드백을 제공해준 Alyssa Coghlan에게 감사드립니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1599,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 443 - Single-dispatch generic functions\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 21:55:16+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>