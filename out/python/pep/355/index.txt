3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-1a135130af3e1cae.js","185","static/chunks/app/layout-c3e2e457f12fb6f6.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js"],""]
4:["slug","python/pep/355","c"]
0:["8N6icDw00Cy0kKVlExSq2",[[["",{"children":[["slug","python/pep/355","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"355\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/355","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e975486d410ad4e9.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T6d68,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0355/">PEP 355 - Path - Object oriented filesystem paths</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 24-Jan-2006</p>
</blockquote>
<p>PEP 355 – Path: 객체 지향 파일 시스템 경로 (거부됨)</p>
<h2>개요</h2>
<p>이 문서는 Python Enhancement Proposal (PEP) 355의 내용을 한국어로 번역하고 요약한 것입니다. PEP 355는 파일 시스템 경로를 객체 지향 방식으로 처리하기 위한 새로운 <code>Path</code> 클래스를 <code>os</code> 모듈에 추가할 것을 제안했습니다. 하지만 이 PEP는 최종적으로 거부되었습니다.</p>
<h2>거부 고지 (Rejection Notice)</h2>
<p>이 PEP는 현재 형태로 거부되었습니다. 제안된 <code>Path</code> 클래스는 너무 많은 기능을 포함하는 "만물상(kitchen sink)" 형태였으며, 경로를 사용하는 모든 기능을 단일 클래스의 메서드로 구현하는 방식은 안티패턴으로 간주되었습니다. (예: <code>open()</code>이나 <code>execfile()</code> 같은 기능은 왜 포함되지 않았는가?) <code>str</code>을 상속받는 것은 특히 나쁜 아이디어였습니다. 많은 문자열(string) 작업이 경로(path)에 적용될 때 의미가 없기 때문입니다. 이 PEP는 오랫동안 보류되어 왔으며, 논의가 간헐적으로 재점화되었으나, 이제 이 PEP를 종결할 때가 되었다고 결정되었습니다. 덜 과장된 제안이라면 더 받아들여질 수도 있을 것입니다.</p>
<h2>Abstract (요약)</h2>
<p>이 PEP는 <code>os</code> 모듈에 새로운 <code>Path</code> 클래스를 추가하여 경로를 객체 지향 방식으로 처리할 것을 제안합니다. 또한, 관련 함수의 "약한" Deprecation (비활성화 권고)에 대해서도 논의하고 권고합니다.</p>
<h2>Background (배경)</h2>
<p>이 PEP에서 제시된 아이디어는 최근의 것이 아니라, 수년 동안 Python 커뮤니티에서 논의되어 왔습니다. 많은 이들이 <code>os.path</code> 모듈에서 제공하는 파일 경로 조작 API가 부적절하다고 느꼈습니다. <code>Path</code> 객체에 대한 첫 번째 제안은 2001년 Just van Rossum이 python-dev에서 제기했습니다. 2003년, Jason Orendorff는 경로를 객체로 표현하는 최초의 공개 구현인 "path module" 버전 1.0을 발표했습니다.</p>
<p><code>path</code> 모듈은 빠르게 인기를 얻었고, <code>path</code> 모듈을 Python 표준 라이브러리에 포함시키려는 수많은 시도가 있었습니다.</p>
<p>이 PEP는 <code>path</code> 모듈에 대해 사람들이 표현한 아이디어와 제안을 요약하고, 수정된 버전이 표준 라이브러리에 포함되어야 한다고 제안합니다.</p>
<h2>Motivation (동기)</h2>
<p>파일 시스템 경로를 다루는 것은 모든 프로그래밍 언어에서 흔한 작업이며, Python과 같은 고급 언어에서는 매우 일반적입니다. 이 작업에 대한 좋은 지원이 필요한 이유는 다음과 같습니다:</p>
<ul>
<li>거의 모든 프로그램이 파일을 액세스하기 위해 경로를 사용합니다. 자주 수행되는 작업은 가능한 한 직관적이고 쉽게 수행될 수 있어야 합니다.</li>
<li>이는 Python을 복잡한 셸 스크립트를 대체하기에 더 좋은 언어로 만듭니다.</li>
<li>현재 Python은 경로를 처리하기 위해 여러 모듈에 흩어져 있는 많은 함수들을 가지고 있습니다. 이로 인해 초보자와 숙련된 개발자 모두에게 올바른 메서드를 선택하기 어렵습니다.</li>
</ul>
<p><code>Path</code> 클래스는 현재의 일반적인 방식에 비해 다음과 같은 개선 사항을 제공합니다:</p>
<ul>
<li>하나의 "통합된(unified)" 객체가 이전 함수의 모든 기능을 제공합니다.</li>
<li><strong>Subclassability (하위 클래스화 가능성)</strong>: <code>Path</code> 객체는 파일 시스템 경로 외의 다른 경로를 지원하도록 확장될 수 있습니다. 프로그래머는 새로운 API를 배울 필요 없이 <code>Path</code>에 대한 지식을 재사용하여 확장된 클래스를 다룰 수 있습니다.</li>
<li>모든 관련 기능이 한곳에 있기 때문에, 올바른 접근 방식을 배우기 쉽고, 여러 모듈을 뒤져서 올바른 함수를 찾을 필요가 없습니다.</li>
<li>Python은 객체 지향 언어입니다. 파일, <code>datetime</code>, 소켓(socket)과 마찬가지로 경로는 객체이며, 단순히 함수에 전달되는 문자열이 아닙니다. <code>Path</code> 객체는 본질적으로 Pythonic한 아이디어입니다.</li>
<li><code>Path</code>는 속성(properties)을 활용합니다. 속성은 더 읽고 쉬운 코드를 만듭니:
<pre><code> if imgpath.ext == 'jpg':
     jpegdecode(imgpath)
</code></pre>
이것은 다음보다 낫습니다:
<pre><code> if os.path.splitexit(imgpath)[1] == 'jpg':
     jpegdecode(imgpath)
</code></pre>
</li>
</ul>
<h2>Rationale (설계 원칙)</h2>
<p>다음은 설계의 주요 요점입니다:</p>
<ul>
<li><code>Path</code>는 <code>str</code>을 상속하므로, 문자열 경로명을 기대하는 모든 코드는 수정될 필요가 없으며 기존 코드가 손상되지 않습니다.</li>
<li><code>Path</code> 객체는 <code>Path.cwd()</code> 클래스 메서드를 사용하거나, 경로를 나타내는 문자열로 클래스를 인스턴스화하거나, <code>Path(".")</code>와 동등한 기본 생성자를 사용하여 생성할 수 있습니다.</li>
<li><code>Path</code>는 일반적인 경로명 조작, 패턴 확장, 패턴 일치(matching) 및 복사를 포함한 다른 고수준 파일 작업을 제공합니다. 기본적으로 <code>Path</code>는 파일 내용 조작을 제외한 모든 경로 관련 기능을 제공합니다. 파일 내용 조작에는 파일 객체가 더 적합합니다.</li>
<li>플랫폼 비호환성은 시스템별 메서드를 인스턴스화하지 않음으로써 처리됩니다.</li>
</ul>
<h2>Specification (세부 사양)</h2>
<p><code>Path</code> 클래스는 다음과 같은 공개 인터페이스를 정의합니다 (참조 구현에서 docstring을 추출하고 간결하게 줄였습니다. 자세한 내용은 참조 구현을 참조하십시오).</p>
<pre><code class="language-python">class Path(str):
    # Special Python methods:
    def __new__(cls, *args) => Path
        """
        *args를 연결하여 새 Path 객체를 생성합니다.
        *args는 Path 객체 또는 문자열만 포함할 수 있습니다.
        *args가 비어 있으면 Path(os.curdir)가 생성됩니다.
        """
    def __repr__(self): ...
    def __add__(self, more): ...
    def __radd__(self, other): ...

    # Alternative constructor.
    def cwd(cls): ...

    # Operations on path strings:
    def abspath(self) => Path
        """자신의 절대 경로를 새 Path 객체로 반환합니다."""
    def normcase(self): ...
    def normpath(self): ...
    def realpath(self): ...
    def expanduser(self): ...
    def expandvars(self): ...
    def basename(self): ...
    def expand(self): ...
    def splitpath(self) => (Path, str)
        """p.splitpath() -> (p.parent, p.name)을 반환합니다."""
    def stripext(self) => Path
        """p.stripext() -> 경로에서 하나의 파일 확장자를 제거합니다."""
    def splitunc(self): ... # 각주 [1] 참조
    def splitall(self): ...
    def relpath(self): ...
    def relpathto(self, dest): ...

    # Properties about the path:
    parent => Path
        """이 Path의 부모 디렉토리를 새 Path 객체로 반환합니다."""
    name => str
        """전체 경로 없이 파일 또는 디렉토리의 이름을 반환합니다."""
    ext => str
        """파일 확장자 또는 Path가 확장자 없는 파일이나 디렉토리를 참조하는 경우 빈 문자열."""
    drive => str
        """드라이브 지정자. 드라이브 지정자를 사용하지 않는 시스템에서는 항상 비어 있습니다."""
    namebase => str
        """path.name과 동일하지만 하나의 파일 확장자가 제거됩니다."""
    uncshare # 각주 [1] 참조

    # Operations that return lists of paths:
    def listdir(self, pattern = None): ...
    def dirs(self, pattern = None): ...
    def files(self, pattern = None): ...
    def walk(self, pattern = None): ...
    def walkdirs(self, pattern = None): ...
    def walkfiles(self, pattern = None): ...
    def match(self, pattern) => bool
        """self.name이 주어진 패턴과 일치하면 True를 반환합니다."""
    def matchcase(self, pattern) => bool
        """match()와 유사하지만 대소문자를 구분하지 않는 파일 시스템에서도 대소문자 구분을 보장합니다."""
    def glob(self, pattern):

    # Methods for retrieving information about the filesystem path:
    def exists(self): ...
    def isabs(self): ...
    def isdir(self): ...
    def isfile(self): ...
    def islink(self): ...
    def ismount(self): ...
    def samefile(self, other): ... # 각주 [1] 참조
    def atime(self): ... """파일의 마지막 접근 시간."""
    def mtime(self): ... """파일의 마지막 수정 시간."""
    def ctime(self): ... """
        일부 시스템(예: Unix)에서는 마지막 변경 시간,
        다른 시스템(예: Windows)에서는 Path의 생성 시간인 시스템의 ctime을 반환합니다.
        """
    def size(self): ...
    def access(self, mode): ... # 각주 [1] 참조
    def stat(self): ...
    def lstat(self): ...
    def statvfs(self): ... # 각주 [1] 참조
    def pathconf(self, name): ... # 각주 [1] 참조

    # Methods for manipulating information about the filesystem path.
    def utime(self, times) => None
    def chmod(self, mode) => None
    def chown(self, uid, gid) => None # 각주 [1] 참조
    def rename(self, new) => None
    def renames(self, new) => None

    # Create/delete operations on directories
    def mkdir(self, mode = 0o777): ...
    def makedirs(self, mode = 0o777): ...
    def rmdir(self): ...
    def removedirs(self): ...

    # Modifying operations on files
    def touch(self): ...
    def remove(self): ...
    def unlink(self): ...

    # Modifying operations on links
    def link(self, newpath): ...
    def symlink(self, newlink): ...
    def readlink(self): ...
    def readlinkabs(self): ...

    # High-level functions from shutil
    def copyfile(self, dst): ...
    def copymode(self, dst): ...
    def copystat(self, dst): ...
    def copy(self, dst): ...
    def copy2(self, dst): ...
    def copytree(self, dst, symlinks = True): ...
    def move(self, dst): ...
    def rmtree(self, ignore_errors = False, onerror = None): ...

    # Special stuff from os
    def chroot(self): ... # 각주 [1] 참조
    def startfile(self): ... # 각주 [1] 참조
</code></pre>
<p>각주: 이 메서드는 모든 플랫폼에서 사용 가능하다고 보장되지 않습니다.</p>
<h2>Replacing older functions with the Path class (기존 함수를 <code>Path</code> 클래스로 대체하기)</h2>
<p>이 섹션에서 "a ==> b"는 b가 a를 대체할 수 있음을 의미합니다.
다음 예제에서는 <code>from path import Path</code>로 <code>Path</code> 클래스가 임포트되었다고 가정합니다.</p>
<p><code>os.path.join</code> 대체:</p>
<pre><code class="language-python">os.path.join(os.getcwd(), "foobar")    ==> Path(Path.cwd(), "foobar")
os.path.join("foo", "bar", "baz")      ==> Path("foo", "bar", "baz")
</code></pre>
<p><code>os.path.splitext</code> 대체:</p>
<pre><code class="language-python">fname = "Python2.4.tar.gz"
os.path.splitext(fname)[1]            ==> fname = Path("Python2.4.tar.gz")
                                          fname.ext
</code></pre>
<p>두 부분을 모두 원한다면:</p>
<pre><code class="language-python">fname = "Python2.4.tar.gz"
base, ext = os.path.splitext(fname)   ==> fname = Path("Python2.4.tar.gz")
                                          base, ext = fname.namebase, fname.ext
</code></pre>
<p><code>glob.glob</code> 대체:</p>
<pre><code class="language-python">lib_dir = "/lib"
libs = glob.glob(os.path.join(lib_dir, "*s.o")) ==> lib_dir = Path("/lib")
                                                    libs = lib_dir.files("*.so")
</code></pre>
<h2>Deprecations (비활성화 권고)</h2>
<p>이 모듈을 표준 라이브러리에 도입하면 여러 기존 모듈 및 함수의 "약한" 비활성화 권고가 필요합니다. 이 모듈과 함수들은 너무 널리 사용되므로, <code>DeprecationWarning</code>을 생성하는 방식으로 완전히 비활성화할 수는 없습니다. 여기서 "약한 비활성화 권고"는 문서에만 명시하는 것을 의미합니다.</p>
<p>아래 표는 비활성화 권고되어야 할 기존 기능을 나열합니다.</p>
<p>| Path method/property | Deprecates function               |
| :------------------- | :-------------------------------- |
| <code>normcase()</code>         | <code>os.path.normcase()</code>              |
| <code>normpath()</code>         | <code>os.path.normpath()</code>              |
| <code>realpath()</code>         | <code>os.path.realpath()</code>              |
| <code>expanduser()</code>       | <code>os.path.expanduser()</code>            |
| <code>expandvars()</code>       | <code>os.path.expandvars()</code>            |
| <code>parent</code>             | <code>os.path.dirname()</code>               |
| <code>name</code>               | <code>os.path.basename()</code>              |
| <code>splitpath()</code>        | <code>os.path.split()</code>                 |
| <code>drive</code>              | <code>os.path.splitdrive()</code>            |
| <code>ext</code>                | <code>os.path.splitext()</code>              |
| <code>splitunc()</code>         | <code>os.path.splitunc()</code>              |
| <code>__new__()</code>          | <code>os.path.join()</code>, <code>os.curdir</code>     |
| <code>listdir()</code>          | <code>os.listdir()</code> <code>[fnmatch.filter()]</code> |
| <code>match()</code>            | <code>fnmatch.fnmatch()</code>               |
| <code>matchcase()</code>        | <code>fnmatch.fnmatchcase()</code>           |
| <code>glob()</code>             | <code>glob.glob()</code>                     |
| <code>exists()</code>           | <code>os.path.exists()</code>                |
| <code>isabs()</code>            | <code>os.path.isabs()</code>                 |
| <code>isdir()</code>            | <code>os.path.isdir()</code>                 |
| <code>isfile()</code>           | <code>os.path.isfile()</code>                |
| <code>islink()</code>           | <code>os.path.islink()</code>                |
| <code>ismount()</code>          | <code>os.path.ismount()</code>               |
| <code>samefile()</code>         | <code>os.path.samefile()</code>              |
| <code>atime()</code>            | <code>os.path.getatime()</code>              |
| <code>ctime()</code>            | <code>os.path.getctime()</code>              |
| <code>mtime()</code>            | <code>os.path.getmtime()</code>              |
| <code>size()</code>             | <code>os.path.getsize()</code>               |
| <code>cwd()</code>              | <code>os.getcwd()</code>                     |
| <code>access()</code>           | <code>os.access()</code>                     |
| <code>stat()</code>             | <code>os.stat()</code>                       |
| <code>lstat()</code>            | <code>os.lstat()</code>                      |
| <code>statvfs()</code>          | <code>os.statvfs()</code>                    |
| <code>pathconf()</code>         | <code>os.pathconf()</code>                   |
| <code>utime()</code>            | <code>os.utime()</code>                      |
| <code>chmod()</code>            | <code>os.chmod()</code>                      |
| <code>chown()</code>            | <code>os.chown()</code>                      |
| <code>rename()</code>           | <code>os.rename()</code>                     |
| <code>renames()</code>          | <code>os.renames()</code>                    |
| <code>mkdir()</code>            | <code>os.mkdir()</code>                      |
| <code>makedirs()</code>         | <code>os.makedirs()</code>                   |
| <code>rmdir()</code>            | <code>os.rmdir()</code>                      |
| <code>removedirs()</code>       | <code>os.removedirs()</code>                 |
| <code>remove()</code>           | <code>os.remove()</code>                     |
| <code>unlink()</code>           | <code>os.unlink()</code>                     |
| <code>link()</code>             | <code>os.link()</code>                       |
| <code>symlink()</code>          | <code>os.symlink()</code>                    |
| <code>readlink()</code>         | <code>os.readlink()</code>                   |
| <code>chroot()</code>           | <code>os.chroot()</code>                     |
| <code>startfile()</code>        | <code>os.startfile()</code>                  |
| <code>copyfile()</code>         | <code>shutil.copyfile()</code>               |
| <code>copymode()</code>         | <code>shutil.copymode()</code>               |
| <code>copystat()</code>         | <code>shutil.copystat()</code>               |
| <code>copy()</code>             | <code>shutil.copy()</code>                   |
| <code>copy2()</code>            | <code>shutil.copy2()</code>                  |
| <code>copytree()</code>         | <code>shutil.copytree()</code>               |
| <code>move()</code>             | <code>shutil.move()</code>                   |
| <code>rmtree()</code>           | <code>shutil.rmtree()</code>                 |</p>
<p><code>Path</code> 클래스는 <code>os.path</code>, <code>shutil</code>, <code>fnmatch</code>, <code>glob</code> 전체와 <code>os</code> 모듈의 상당 부분을 비활성화 권고합니다.</p>
<h2>Closed Issues (해결된 문제)</h2>
<p>이 PEP가 python-dev에 처음 등장한 이후 여러 논쟁적인 문제가 해결되었습니다:</p>
<ul>
<li><code>__div__()</code> 메서드가 제거되었습니다. <code>/</code>(나누기) 연산자를 오버로딩하는 것은 "지나친 마법(too much magic)"일 수 있으며, 경로 연결이 나누기로 보일 수 있습니다. 필요하다면 BDFL(Benevolent Dictator For Life)의 결정에 따라 나중에 다시 추가될 수 있습니다. 대신 <code>__new__()</code>는 <code>Path</code>와 문자열 객체 모두를 받아들이는 <code>*args</code> 인수를 받게 되었습니다. <code>*args</code>는 <code>os.path.join()</code>을 사용하여 연결되며, 이 함수는 <code>Path</code> 객체를 구성하는 데 사용됩니다. 이러한 변경으로 문제가 있던 <code>joinpath()</code> 메서드는 쓸모없어져 제거되었습니다.</li>
<li><code>getatime()/atime</code>, <code>getctime()/ctime</code>, <code>getmtime()/mtime</code>, <code>getsize()/size</code> 메서드와 속성은 서로 중복되었습니다. 이들은 <code>atime()</code>, <code>ctime()</code>, <code>mtime()</code>, <code>size()</code>로 병합되었습니다. 이들이 속성 대신 메서드인 이유는 예상치 못하게 변경될 가능성이 있기 때문입니다. 다음 예제는 항상 어설션(assertion)을 통과한다고 보장할 수 없습니다:
<pre><code class="language-python">p = Path("foobar")
s = p.size()
assert p.size() == s
</code></pre>
</li>
</ul>
<h2>Open Issues (미해결 문제)</h2>
<p>Jason Orendorff의 <code>path</code> 모듈의 일부 기능은 생략되었습니다:</p>
<ul>
<li>경로를 여는 함수는 내장 <code>open()</code> 함수로 더 잘 처리됩니다.</li>
<li>전체 파일을 읽고 쓰는 함수는 파일 객체의 <code>read()</code> 및 <code>write()</code> 메서드로 더 잘 처리됩니다.</li>
<li><code>chdir()</code> 함수는 포함할 가치가 있을 수 있습니다.</li>
<li>비활성화 권고(deprecation) 일정이 설정되어야 합니다. <code>Path</code>는 얼마나 많은 기능을 구현해야 할까요? 기존 기능 중 얼마나 많은 부분을 언제 비활성화 권고해야 할까요?</li>
<li>이름은 분명히 "path" 또는 "Path"여야 하지만, 어디에 위치해야 할까요? 자체 모듈에 있을까요, 아니면 <code>os</code>에 있을까요?</li>
<li><code>Path</code>가 <code>str</code> 또는 <code>unicode</code>를 상속하기 때문에, 다음과 같은 비마법적(non-magic) 공개 메서드가 <code>Path</code> 객체에서 사용 가능합니다:
<code>capitalize()</code>, <code>center()</code>, <code>count()</code>, <code>decode()</code>, <code>encode()</code>, <code>endswith()</code>, <code>expandtabs()</code>, <code>find()</code>, <code>index()</code>, <code>isalnum()</code>, <code>isalpha()</code>, <code>isdigit()</code>, <code>islower()</code>, <code>isspace()</code>, <code>istitle()</code>, <code>isupper()</code>, <code>join()</code>, <code>ljust()</code>, <code>lower()</code>, <code>lstrip()</code>, <code>replace()</code>, <code>rfind()</code>, <code>rindex()</code>, <code>rjust()</code>, <code>rsplit()</code>, <code>rstrip()</code>, <code>split()</code>, <code>splitlines()</code>, <code>startswith()</code>, <code>strip()</code>, <code>swapcase()</code>, <code>title()</code>, <code>translate()</code>, <code>upper()</code>, <code>zfill()</code>
python-dev에서는 이러한 상속이 합리적인지에 대해 논쟁이 있었습니다. 대부분의 논의자들은 파일 시스템 경로의 맥락에서 대부분의 문자열 메서드가 의미가 없으며, 단지 불필요한 부담일 뿐이라고 말했습니다. 다른 의견은 문자열을 상속하는 것이 매우 편리하며, <code>Path</code> 객체에 대해 코드를 "그냥 작동하도록" 만들 수 있어서 적응할 필요가 없다는 것이었습니다.
문제 중 하나는 Python 수준에서 객체가 <code>str</code> 또는 <code>unicode</code>를 상속하지 않는 한, 내장 함수 <code>open()</code> (및 문자열 또는 버퍼를 기대하는 다른 내장 함수)에 전달할 수 있을 만큼 "문자열과 유사하게" 만들 방법이 없다는 것입니다. 따라서 문자열을 상속하지 않으려면 CPython 코어를 변경해야 합니다.</li>
<li>이 새로운 모듈이 대체하려는 함수와 모듈들 (<code>os.path</code>, <code>shutil</code>, <code>fnmatch</code>, <code>glob</code>, 그리고 <code>os</code>의 일부)은 하위 호환성을 유지하기 위해 미래의 Python 버전에서도 오랫동안 사용 가능할 것으로 예상됩니다.</li>
</ul>
<h2>Reference Implementation (참조 구현)</h2>
<p>현재 <code>Path</code> 클래스는 표준 라이브러리 모듈인 <code>fnmatch</code>, <code>glob</code>, <code>os</code>, <code>os.path</code>, <code>shutil</code>에 대한 얇은 래퍼(thin wrapper)로 구현되어 있습니다. 이 PEP의 의도는 앞서 언급된 모듈의 기능을 <code>Path</code>로 옮기고, 이들을 비활성화 권고하는 것입니다.</p>
<p>자세한 내용과 구현은 다음을 참조하십시오:
http://wiki.python.org/moin/PathModule</p>
<h2>Examples (예시)</h2>
<p>이 섹션에서 "a ==> b"는 b가 a를 대체할 수 있음을 의미합니다.</p>
<p>디렉토리 내의 모든 Python 파일을 실행 가능하게 만들기:</p>
<pre><code class="language-python">DIR = '/usr/home/guido/bin'
for f in os.listdir(DIR):
    if f.endswith('.py'):
        path = os.path.join(DIR, f)
        os.chmod(path, 0o755)
==>
for f in Path('/usr/home/guido/bin').files("*.py"):
    f.chmod(0o755)
</code></pre>
<p>Emacs 백업 파일 삭제:</p>
<pre><code class="language-python">def delete_backups(arg, dirname, names):
    for name in names:
        if name.endswith('~'):
            os.remove(os.path.join(dirname, name))
os.path.walk(os.environ['HOME'], delete_backups, None)
==>
d = Path(os.environ['HOME'])
for f in d.walkfiles('*~'):
    f.remove()
</code></pre>
<p>파일의 상대 경로 찾기:</p>
<pre><code class="language-python">b = Path('/users/peter/')
a = Path('/users/peter/synergy/tiki.txt')
a.relpathto(b)
</code></pre>
<p>경로를 디렉토리와 파일명으로 분할:</p>
<pre><code class="language-python">os.path.split("/path/to/foo/bar.txt")
==>
Path("/path/to/foo/bar.txt").splitpath()
</code></pre>
<p>현재 디렉토리 트리에서 모든 Python 스크립트 나열:</p>
<pre><code class="language-python">list(Path().walkfiles("*.py"))
</code></pre>
<h2>References and Footnotes (참조 및 각주)</h2>
<ul>
<li>이 메서드는 모든 플랫폼에서 사용 가능하다고 보장되지 않습니다.</li>
<li>“(idea) subclassable string: path object?”, van Rossum, 2001.
<code>https://mail.python.org/pipermail/python-dev/2001-August/016663.html</code></li>
<li>“path module v1.0 released”, Orendorff, 2003.
<code>https://mail.python.org/pipermail/python-announce-list/2003-January/001984.html</code></li>
<li>“Some RFE for review”, Birkenfeld, 2005.
<code>https://mail.python.org/pipermail/python-dev/2005-June/054438.html</code></li>
<li>“path module”, Orendorff, 2003.
<code>https://mail.python.org/pipermail/python-list/2003-July/174289.html</code></li>
<li>“PRE-PEP: new Path class”, Roth, 2004.
<code>https://mail.python.org/pipermail/python-list/2004-January/201672.html</code></li>
<li><code>http://wiki.python.org/moin/PathClass</code></li>
</ul>
<h2>Copyright (저작권)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.
최종 수정: 2025-02-01 08:59:27 GMT
Source: <code>https://github.com/python/peps/blob/main/peps/pep-0355.rst</code></p>
<hr>
<p><strong>주의:</strong> 이 PEP는 최종적으로 거부되었으며, 제안된 <code>Path</code> 클래스는 Python 표준 라이브러리에 포함되지 않았습니다. 하지만 이 PEP에서 다루는 아이디어와 문제점은 이후 <code>pathlib</code> 모듈과 같은 다른 솔루션의 개발에 영향을 미쳤습니다.</p>
<pre><code>
## References and Footnotes (참조 및 각주)
*   이 메서드는 모든 플랫폼에서 사용 가능하다고 보장되지 않습니다.
*   “(idea) subclassable string: path object?”, van Rossum, 2001.
    `https://mail.python.org/pipermail/python-dev/2001-August/016663.html`
*   “path module v1.0 released”, Orendorff, 2003.
    `https://mail.python.org/pipermail/python-announce-list/2003-January/001984.html`
*   “Some RFE for review”, Birkenfeld, 2005.
    `https://mail.python.org/pipermail/python-dev/2005-June/054438.html`
*   “path module”, Orendorff, 2003.
    `https://mail.python.org/pipermail/python-list/2003-July/174289.html`
*   “PRE-PEP: new Path class”, Roth, 2004.
    `https://mail.python.org/pipermail/python-list/2004-January/201672.html`
*   `http://wiki.python.org/moin/PathClass`

## Copyright (저작권)
이 문서는 퍼블릭 도메인에 공개되었습니다.
최종 수정: 2025-02-01 08:59:27 GMT
Source: `https://github.com/python/peps/blob/main/peps/pep-0355.rst`

---
**주의:** 이 PEP는 최종적으로 거부되었으며, 제안된 `Path` 클래스는 Python 표준 라이브러리에 포함되지 않았습니다. 하지만 이 PEP에서 다루는 아이디어와 문제점은 이후 `pathlib` 모듈과 같은 다른 솔루션의 개발에 영향을 미쳤습니다.


> ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.
</code></pre>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1318,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Rejected] PEP 355 - Path - Object oriented filesystem paths"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-27 01:12:42+0900","children":"2025년 9월 27일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 27일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}]]
1:null
