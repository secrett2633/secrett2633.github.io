<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d6cea809dcbae606.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-0395f68b8cc78a20.js" async=""></script><script src="/_next/static/chunks/23-706b53707bbf0661.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-467e37449c5a68fc.js" async=""></script><script src="/_next/static/chunks/app/layout-e359f205e3380aec.js" async=""></script><script src="/_next/static/chunks/app/page-90c91ef098171651.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2420<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 355 - Path - Object oriented filesystem paths</h1><div class="page__meta"><time dateTime="2025-09-27 01:12:42+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0355/">PEP 355 - Path - Object oriented filesystem paths</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 24-Jan-2006</p>
</blockquote>
<p>PEP 355 – Path: 객체 지향 파일 시스템 경로 (거부됨)</p>
<h2>개요</h2>
<p>이 문서는 Python Enhancement Proposal (PEP) 355의 내용을 한국어로 번역하고 요약한 것입니다. PEP 355는 파일 시스템 경로를 객체 지향 방식으로 처리하기 위한 새로운 <code>Path</code> 클래스를 <code>os</code> 모듈에 추가할 것을 제안했습니다. 하지만 이 PEP는 최종적으로 거부되었습니다.</p>
<h2>거부 고지 (Rejection Notice)</h2>
<p>이 PEP는 현재 형태로 거부되었습니다. 제안된 <code>Path</code> 클래스는 너무 많은 기능을 포함하는 "만물상(kitchen sink)" 형태였으며, 경로를 사용하는 모든 기능을 단일 클래스의 메서드로 구현하는 방식은 안티패턴으로 간주되었습니다. (예: <code>open()</code>이나 <code>execfile()</code> 같은 기능은 왜 포함되지 않았는가?) <code>str</code>을 상속받는 것은 특히 나쁜 아이디어였습니다. 많은 문자열(string) 작업이 경로(path)에 적용될 때 의미가 없기 때문입니다. 이 PEP는 오랫동안 보류되어 왔으며, 논의가 간헐적으로 재점화되었으나, 이제 이 PEP를 종결할 때가 되었다고 결정되었습니다. 덜 과장된 제안이라면 더 받아들여질 수도 있을 것입니다.</p>
<h2>Abstract (요약)</h2>
<p>이 PEP는 <code>os</code> 모듈에 새로운 <code>Path</code> 클래스를 추가하여 경로를 객체 지향 방식으로 처리할 것을 제안합니다. 또한, 관련 함수의 "약한" Deprecation (비활성화 권고)에 대해서도 논의하고 권고합니다.</p>
<h2>Background (배경)</h2>
<p>이 PEP에서 제시된 아이디어는 최근의 것이 아니라, 수년 동안 Python 커뮤니티에서 논의되어 왔습니다. 많은 이들이 <code>os.path</code> 모듈에서 제공하는 파일 경로 조작 API가 부적절하다고 느꼈습니다. <code>Path</code> 객체에 대한 첫 번째 제안은 2001년 Just van Rossum이 python-dev에서 제기했습니다. 2003년, Jason Orendorff는 경로를 객체로 표현하는 최초의 공개 구현인 "path module" 버전 1.0을 발표했습니다.</p>
<p><code>path</code> 모듈은 빠르게 인기를 얻었고, <code>path</code> 모듈을 Python 표준 라이브러리에 포함시키려는 수많은 시도가 있었습니다.</p>
<p>이 PEP는 <code>path</code> 모듈에 대해 사람들이 표현한 아이디어와 제안을 요약하고, 수정된 버전이 표준 라이브러리에 포함되어야 한다고 제안합니다.</p>
<h2>Motivation (동기)</h2>
<p>파일 시스템 경로를 다루는 것은 모든 프로그래밍 언어에서 흔한 작업이며, Python과 같은 고급 언어에서는 매우 일반적입니다. 이 작업에 대한 좋은 지원이 필요한 이유는 다음과 같습니다:</p>
<ul>
<li>거의 모든 프로그램이 파일을 액세스하기 위해 경로를 사용합니다. 자주 수행되는 작업은 가능한 한 직관적이고 쉽게 수행될 수 있어야 합니다.</li>
<li>이는 Python을 복잡한 셸 스크립트를 대체하기에 더 좋은 언어로 만듭니다.</li>
<li>현재 Python은 경로를 처리하기 위해 여러 모듈에 흩어져 있는 많은 함수들을 가지고 있습니다. 이로 인해 초보자와 숙련된 개발자 모두에게 올바른 메서드를 선택하기 어렵습니다.</li>
</ul>
<p><code>Path</code> 클래스는 현재의 일반적인 방식에 비해 다음과 같은 개선 사항을 제공합니다:</p>
<ul>
<li>하나의 "통합된(unified)" 객체가 이전 함수의 모든 기능을 제공합니다.</li>
<li><strong>Subclassability (하위 클래스화 가능성)</strong> : <code>Path</code> 객체는 파일 시스템 경로 외의 다른 경로를 지원하도록 확장될 수 있습니다. 프로그래머는 새로운 API를 배울 필요 없이 <code>Path</code>에 대한 지식을 재사용하여 확장된 클래스를 다룰 수 있습니다.</li>
<li>모든 관련 기능이 한곳에 있기 때문에, 올바른 접근 방식을 배우기 쉽고, 여러 모듈을 뒤져서 올바른 함수를 찾을 필요가 없습니다.</li>
<li>Python은 객체 지향 언어입니다. 파일, <code>datetime</code>, 소켓(socket)과 마찬가지로 경로는 객체이며, 단순히 함수에 전달되는 문자열이 아닙니다. <code>Path</code> 객체는 본질적으로 Pythonic한 아이디어입니다.</li>
<li><code>Path</code>는 속성(properties)을 활용합니다. 속성은 더 읽고 쉬운 코드를 만듭니:
<pre><code> if imgpath.ext == 'jpg':
     jpegdecode(imgpath)
</code></pre>
이것은 다음보다 낫습니다:
<pre><code> if os.path.splitexit(imgpath)[1] == 'jpg':
     jpegdecode(imgpath)
</code></pre>
</li>
</ul>
<h2>Rationale (설계 원칙)</h2>
<p>다음은 설계의 주요 요점입니다:</p>
<ul>
<li><code>Path</code>는 <code>str</code>을 상속하므로, 문자열 경로명을 기대하는 모든 코드는 수정될 필요가 없으며 기존 코드가 손상되지 않습니다.</li>
<li><code>Path</code> 객체는 <code>Path.cwd()</code> 클래스 메서드를 사용하거나, 경로를 나타내는 문자열로 클래스를 인스턴스화하거나, <code>Path(".")</code>와 동등한 기본 생성자를 사용하여 생성할 수 있습니다.</li>
<li><code>Path</code>는 일반적인 경로명 조작, 패턴 확장, 패턴 일치(matching) 및 복사를 포함한 다른 고수준 파일 작업을 제공합니다. 기본적으로 <code>Path</code>는 파일 내용 조작을 제외한 모든 경로 관련 기능을 제공합니다. 파일 내용 조작에는 파일 객체가 더 적합합니다.</li>
<li>플랫폼 비호환성은 시스템별 메서드를 인스턴스화하지 않음으로써 처리됩니다.</li>
</ul>
<h2>Specification (세부 사양)</h2>
<p><code>Path</code> 클래스는 다음과 같은 공개 인터페이스를 정의합니다 (참조 구현에서 docstring을 추출하고 간결하게 줄였습니다. 자세한 내용은 참조 구현을 참조하십시오).</p>
<pre><code class="language-python">class Path(str):
    # Special Python methods:
    def __new__(cls, *args) => Path
        """
        *args를 연결하여 새 Path 객체를 생성합니다.
        *args는 Path 객체 또는 문자열만 포함할 수 있습니다.
        *args가 비어 있으면 Path(os.curdir)가 생성됩니다.
        """
    def __repr__(self): ...
    def __add__(self, more): ...
    def __radd__(self, other): ...

    # Alternative constructor.
    def cwd(cls): ...

    # Operations on path strings:
    def abspath(self) => Path
        """자신의 절대 경로를 새 Path 객체로 반환합니다."""
    def normcase(self): ...
    def normpath(self): ...
    def realpath(self): ...
    def expanduser(self): ...
    def expandvars(self): ...
    def basename(self): ...
    def expand(self): ...
    def splitpath(self) => (Path, str)
        """p.splitpath() -> (p.parent, p.name)을 반환합니다."""
    def stripext(self) => Path
        """p.stripext() -> 경로에서 하나의 파일 확장자를 제거합니다."""
    def splitunc(self): ... # 각주 [1] 참조
    def splitall(self): ...
    def relpath(self): ...
    def relpathto(self, dest): ...

    # Properties about the path:
    parent => Path
        """이 Path의 부모 디렉토리를 새 Path 객체로 반환합니다."""
    name => str
        """전체 경로 없이 파일 또는 디렉토리의 이름을 반환합니다."""
    ext => str
        """파일 확장자 또는 Path가 확장자 없는 파일이나 디렉토리를 참조하는 경우 빈 문자열."""
    drive => str
        """드라이브 지정자. 드라이브 지정자를 사용하지 않는 시스템에서는 항상 비어 있습니다."""
    namebase => str
        """path.name과 동일하지만 하나의 파일 확장자가 제거됩니다."""
    uncshare # 각주 [1] 참조

    # Operations that return lists of paths:
    def listdir(self, pattern = None): ...
    def dirs(self, pattern = None): ...
    def files(self, pattern = None): ...
    def walk(self, pattern = None): ...
    def walkdirs(self, pattern = None): ...
    def walkfiles(self, pattern = None): ...
    def match(self, pattern) => bool
        """self.name이 주어진 패턴과 일치하면 True를 반환합니다."""
    def matchcase(self, pattern) => bool
        """match()와 유사하지만 대소문자를 구분하지 않는 파일 시스템에서도 대소문자 구분을 보장합니다."""
    def glob(self, pattern):

    # Methods for retrieving information about the filesystem path:
    def exists(self): ...
    def isabs(self): ...
    def isdir(self): ...
    def isfile(self): ...
    def islink(self): ...
    def ismount(self): ...
    def samefile(self, other): ... # 각주 [1] 참조
    def atime(self): ... """파일의 마지막 접근 시간."""
    def mtime(self): ... """파일의 마지막 수정 시간."""
    def ctime(self): ... """
        일부 시스템(예: Unix)에서는 마지막 변경 시간,
        다른 시스템(예: Windows)에서는 Path의 생성 시간인 시스템의 ctime을 반환합니다.
        """
    def size(self): ...
    def access(self, mode): ... # 각주 [1] 참조
    def stat(self): ...
    def lstat(self): ...
    def statvfs(self): ... # 각주 [1] 참조
    def pathconf(self, name): ... # 각주 [1] 참조

    # Methods for manipulating information about the filesystem path.
    def utime(self, times) => None
    def chmod(self, mode) => None
    def chown(self, uid, gid) => None # 각주 [1] 참조
    def rename(self, new) => None
    def renames(self, new) => None

    # Create/delete operations on directories
    def mkdir(self, mode = 0o777): ...
    def makedirs(self, mode = 0o777): ...
    def rmdir(self): ...
    def removedirs(self): ...

    # Modifying operations on files
    def touch(self): ...
    def remove(self): ...
    def unlink(self): ...

    # Modifying operations on links
    def link(self, newpath): ...
    def symlink(self, newlink): ...
    def readlink(self): ...
    def readlinkabs(self): ...

    # High-level functions from shutil
    def copyfile(self, dst): ...
    def copymode(self, dst): ...
    def copystat(self, dst): ...
    def copy(self, dst): ...
    def copy2(self, dst): ...
    def copytree(self, dst, symlinks = True): ...
    def move(self, dst): ...
    def rmtree(self, ignore_errors = False, onerror = None): ...

    # Special stuff from os
    def chroot(self): ... # 각주 [1] 참조
    def startfile(self): ... # 각주 [1] 참조
</code></pre>
<p>각주: 이 메서드는 모든 플랫폼에서 사용 가능하다고 보장되지 않습니다.</p>
<h2>Replacing older functions with the Path class (기존 함수를 <code>Path</code> 클래스로 대체하기)</h2>
<p>이 섹션에서 "a ==> b"는 b가 a를 대체할 수 있음을 의미합니다.
다음 예제에서는 <code>from path import Path</code>로 <code>Path</code> 클래스가 임포트되었다고 가정합니다.</p>
<p><code>os.path.join</code> 대체:</p>
<pre><code class="language-python">os.path.join(os.getcwd(), "foobar")    ==> Path(Path.cwd(), "foobar")
os.path.join("foo", "bar", "baz")      ==> Path("foo", "bar", "baz")
</code></pre>
<p><code>os.path.splitext</code> 대체:</p>
<pre><code class="language-python">fname = "Python2.4.tar.gz"
os.path.splitext(fname)[1]            ==> fname = Path("Python2.4.tar.gz")
                                          fname.ext
</code></pre>
<p>두 부분을 모두 원한다면:</p>
<pre><code class="language-python">fname = "Python2.4.tar.gz"
base, ext = os.path.splitext(fname)   ==> fname = Path("Python2.4.tar.gz")
                                          base, ext = fname.namebase, fname.ext
</code></pre>
<p><code>glob.glob</code> 대체:</p>
<pre><code class="language-python">lib_dir = "/lib"
libs = glob.glob(os.path.join(lib_dir, "*s.o")) ==> lib_dir = Path("/lib")
                                                    libs = lib_dir.files("*.so")
</code></pre>
<h2>Deprecations (비활성화 권고)</h2>
<p>이 모듈을 표준 라이브러리에 도입하면 여러 기존 모듈 및 함수의 "약한" 비활성화 권고가 필요합니다. 이 모듈과 함수들은 너무 널리 사용되므로, <code>DeprecationWarning</code>을 생성하는 방식으로 완전히 비활성화할 수는 없습니다. 여기서 "약한 비활성화 권고"는 문서에만 명시하는 것을 의미합니다.</p>
<p>아래 표는 비활성화 권고되어야 할 기존 기능을 나열합니다.</p>
<p>| Path method/property | Deprecates function               |
| :------------------- | :-------------------------------- |
| <code>normcase()</code>         | <code>os.path.normcase()</code>              |
| <code>normpath()</code>         | <code>os.path.normpath()</code>              |
| <code>realpath()</code>         | <code>os.path.realpath()</code>              |
| <code>expanduser()</code>       | <code>os.path.expanduser()</code>            |
| <code>expandvars()</code>       | <code>os.path.expandvars()</code>            |
| <code>parent</code>             | <code>os.path.dirname()</code>               |
| <code>name</code>               | <code>os.path.basename()</code>              |
| <code>splitpath()</code>        | <code>os.path.split()</code>                 |
| <code>drive</code>              | <code>os.path.splitdrive()</code>            |
| <code>ext</code>                | <code>os.path.splitext()</code>              |
| <code>splitunc()</code>         | <code>os.path.splitunc()</code>              |
| <code>__new__()</code>          | <code>os.path.join()</code>, <code>os.curdir</code>     |
| <code>listdir()</code>          | <code>os.listdir()</code> <code>[fnmatch.filter()]</code> |
| <code>match()</code>            | <code>fnmatch.fnmatch()</code>               |
| <code>matchcase()</code>        | <code>fnmatch.fnmatchcase()</code>           |
| <code>glob()</code>             | <code>glob.glob()</code>                     |
| <code>exists()</code>           | <code>os.path.exists()</code>                |
| <code>isabs()</code>            | <code>os.path.isabs()</code>                 |
| <code>isdir()</code>            | <code>os.path.isdir()</code>                 |
| <code>isfile()</code>           | <code>os.path.isfile()</code>                |
| <code>islink()</code>           | <code>os.path.islink()</code>                |
| <code>ismount()</code>          | <code>os.path.ismount()</code>               |
| <code>samefile()</code>         | <code>os.path.samefile()</code>              |
| <code>atime()</code>            | <code>os.path.getatime()</code>              |
| <code>ctime()</code>            | <code>os.path.getctime()</code>              |
| <code>mtime()</code>            | <code>os.path.getmtime()</code>              |
| <code>size()</code>             | <code>os.path.getsize()</code>               |
| <code>cwd()</code>              | <code>os.getcwd()</code>                     |
| <code>access()</code>           | <code>os.access()</code>                     |
| <code>stat()</code>             | <code>os.stat()</code>                       |
| <code>lstat()</code>            | <code>os.lstat()</code>                      |
| <code>statvfs()</code>          | <code>os.statvfs()</code>                    |
| <code>pathconf()</code>         | <code>os.pathconf()</code>                   |
| <code>utime()</code>            | <code>os.utime()</code>                      |
| <code>chmod()</code>            | <code>os.chmod()</code>                      |
| <code>chown()</code>            | <code>os.chown()</code>                      |
| <code>rename()</code>           | <code>os.rename()</code>                     |
| <code>renames()</code>          | <code>os.renames()</code>                    |
| <code>mkdir()</code>            | <code>os.mkdir()</code>                      |
| <code>makedirs()</code>         | <code>os.makedirs()</code>                   |
| <code>rmdir()</code>            | <code>os.rmdir()</code>                      |
| <code>removedirs()</code>       | <code>os.removedirs()</code>                 |
| <code>remove()</code>           | <code>os.remove()</code>                     |
| <code>unlink()</code>           | <code>os.unlink()</code>                     |
| <code>link()</code>             | <code>os.link()</code>                       |
| <code>symlink()</code>          | <code>os.symlink()</code>                    |
| <code>readlink()</code>         | <code>os.readlink()</code>                   |
| <code>chroot()</code>           | <code>os.chroot()</code>                     |
| <code>startfile()</code>        | <code>os.startfile()</code>                  |
| <code>copyfile()</code>         | <code>shutil.copyfile()</code>               |
| <code>copymode()</code>         | <code>shutil.copymode()</code>               |
| <code>copystat()</code>         | <code>shutil.copystat()</code>               |
| <code>copy()</code>             | <code>shutil.copy()</code>                   |
| <code>copy2()</code>            | <code>shutil.copy2()</code>                  |
| <code>copytree()</code>         | <code>shutil.copytree()</code>               |
| <code>move()</code>             | <code>shutil.move()</code>                   |
| <code>rmtree()</code>           | <code>shutil.rmtree()</code>                 |</p>
<p><code>Path</code> 클래스는 <code>os.path</code>, <code>shutil</code>, <code>fnmatch</code>, <code>glob</code> 전체와 <code>os</code> 모듈의 상당 부분을 비활성화 권고합니다.</p>
<h2>Closed Issues (해결된 문제)</h2>
<p>이 PEP가 python-dev에 처음 등장한 이후 여러 논쟁적인 문제가 해결되었습니다:</p>
<ul>
<li><code>__div__()</code> 메서드가 제거되었습니다. <code>/</code>(나누기) 연산자를 오버로딩하는 것은 "지나친 마법(too much magic)"일 수 있으며, 경로 연결이 나누기로 보일 수 있습니다. 필요하다면 BDFL(Benevolent Dictator For Life)의 결정에 따라 나중에 다시 추가될 수 있습니다. 대신 <code>__new__()</code>는 <code>Path</code>와 문자열 객체 모두를 받아들이는 <code>*args</code> 인수를 받게 되었습니다. <code>*args</code>는 <code>os.path.join()</code>을 사용하여 연결되며, 이 함수는 <code>Path</code> 객체를 구성하는 데 사용됩니다. 이러한 변경으로 문제가 있던 <code>joinpath()</code> 메서드는 쓸모없어져 제거되었습니다.</li>
<li><code>getatime()/atime</code>, <code>getctime()/ctime</code>, <code>getmtime()/mtime</code>, <code>getsize()/size</code> 메서드와 속성은 서로 중복되었습니다. 이들은 <code>atime()</code>, <code>ctime()</code>, <code>mtime()</code>, <code>size()</code>로 병합되었습니다. 이들이 속성 대신 메서드인 이유는 예상치 못하게 변경될 가능성이 있기 때문입니다. 다음 예제는 항상 어설션(assertion)을 통과한다고 보장할 수 없습니다:
<pre><code class="language-python">p = Path("foobar")
s = p.size()
assert p.size() == s
</code></pre>
</li>
</ul>
<h2>Open Issues (미해결 문제)</h2>
<p>Jason Orendorff의 <code>path</code> 모듈의 일부 기능은 생략되었습니다:</p>
<ul>
<li>경로를 여는 함수는 내장 <code>open()</code> 함수로 더 잘 처리됩니다.</li>
<li>전체 파일을 읽고 쓰는 함수는 파일 객체의 <code>read()</code> 및 <code>write()</code> 메서드로 더 잘 처리됩니다.</li>
<li><code>chdir()</code> 함수는 포함할 가치가 있을 수 있습니다.</li>
<li>비활성화 권고(deprecation) 일정이 설정되어야 합니다. <code>Path</code>는 얼마나 많은 기능을 구현해야 할까요? 기존 기능 중 얼마나 많은 부분을 언제 비활성화 권고해야 할까요?</li>
<li>이름은 분명히 "path" 또는 "Path"여야 하지만, 어디에 위치해야 할까요? 자체 모듈에 있을까요, 아니면 <code>os</code>에 있을까요?</li>
<li><code>Path</code>가 <code>str</code> 또는 <code>unicode</code>를 상속하기 때문에, 다음과 같은 비마법적(non-magic) 공개 메서드가 <code>Path</code> 객체에서 사용 가능합니다:
<code>capitalize()</code>, <code>center()</code>, <code>count()</code>, <code>decode()</code>, <code>encode()</code>, <code>endswith()</code>, <code>expandtabs()</code>, <code>find()</code>, <code>index()</code>, <code>isalnum()</code>, <code>isalpha()</code>, <code>isdigit()</code>, <code>islower()</code>, <code>isspace()</code>, <code>istitle()</code>, <code>isupper()</code>, <code>join()</code>, <code>ljust()</code>, <code>lower()</code>, <code>lstrip()</code>, <code>replace()</code>, <code>rfind()</code>, <code>rindex()</code>, <code>rjust()</code>, <code>rsplit()</code>, <code>rstrip()</code>, <code>split()</code>, <code>splitlines()</code>, <code>startswith()</code>, <code>strip()</code>, <code>swapcase()</code>, <code>title()</code>, <code>translate()</code>, <code>upper()</code>, <code>zfill()</code>
python-dev에서는 이러한 상속이 합리적인지에 대해 논쟁이 있었습니다. 대부분의 논의자들은 파일 시스템 경로의 맥락에서 대부분의 문자열 메서드가 의미가 없으며, 단지 불필요한 부담일 뿐이라고 말했습니다. 다른 의견은 문자열을 상속하는 것이 매우 편리하며, <code>Path</code> 객체에 대해 코드를 "그냥 작동하도록" 만들 수 있어서 적응할 필요가 없다는 것이었습니다.
문제 중 하나는 Python 수준에서 객체가 <code>str</code> 또는 <code>unicode</code>를 상속하지 않는 한, 내장 함수 <code>open()</code> (및 문자열 또는 버퍼를 기대하는 다른 내장 함수)에 전달할 수 있을 만큼 "문자열과 유사하게" 만들 방법이 없다는 것입니다. 따라서 문자열을 상속하지 않으려면 CPython 코어를 변경해야 합니다.</li>
<li>이 새로운 모듈이 대체하려는 함수와 모듈들 (<code>os.path</code>, <code>shutil</code>, <code>fnmatch</code>, <code>glob</code>, 그리고 <code>os</code>의 일부)은 하위 호환성을 유지하기 위해 미래의 Python 버전에서도 오랫동안 사용 가능할 것으로 예상됩니다.</li>
</ul>
<h2>Reference Implementation (참조 구현)</h2>
<p>현재 <code>Path</code> 클래스는 표준 라이브러리 모듈인 <code>fnmatch</code>, <code>glob</code>, <code>os</code>, <code>os.path</code>, <code>shutil</code>에 대한 얇은 래퍼(thin wrapper)로 구현되어 있습니다. 이 PEP의 의도는 앞서 언급된 모듈의 기능을 <code>Path</code>로 옮기고, 이들을 비활성화 권고하는 것입니다.</p>
<p>자세한 내용과 구현은 다음을 참조하십시오:
http://wiki.python.org/moin/PathModule</p>
<h2>Examples (예시)</h2>
<p>이 섹션에서 "a ==> b"는 b가 a를 대체할 수 있음을 의미합니다.</p>
<p>디렉토리 내의 모든 Python 파일을 실행 가능하게 만들기:</p>
<pre><code class="language-python">DIR = '/usr/home/guido/bin'
for f in os.listdir(DIR):
    if f.endswith('.py'):
        path = os.path.join(DIR, f)
        os.chmod(path, 0o755)
==>
for f in Path('/usr/home/guido/bin').files("*.py"):
    f.chmod(0o755)
</code></pre>
<p>Emacs 백업 파일 삭제:</p>
<pre><code class="language-python">def delete_backups(arg, dirname, names):
    for name in names:
        if name.endswith('~'):
            os.remove(os.path.join(dirname, name))
os.path.walk(os.environ['HOME'], delete_backups, None)
==>
d = Path(os.environ['HOME'])
for f in d.walkfiles('*~'):
    f.remove()
</code></pre>
<p>파일의 상대 경로 찾기:</p>
<pre><code class="language-python">b = Path('/users/peter/')
a = Path('/users/peter/synergy/tiki.txt')
a.relpathto(b)
</code></pre>
<p>경로를 디렉토리와 파일명으로 분할:</p>
<pre><code class="language-python">os.path.split("/path/to/foo/bar.txt")
==>
Path("/path/to/foo/bar.txt").splitpath()
</code></pre>
<p>현재 디렉토리 트리에서 모든 Python 스크립트 나열:</p>
<pre><code class="language-python">list(Path().walkfiles("*.py"))
</code></pre>
<h2>References and Footnotes (참조 및 각주)</h2>
<ul>
<li>이 메서드는 모든 플랫폼에서 사용 가능하다고 보장되지 않습니다.</li>
<li>“(idea) subclassable string: path object?”, van Rossum, 2001.
<code>https://mail.python.org/pipermail/python-dev/2001-August/016663.html</code></li>
<li>“path module v1.0 released”, Orendorff, 2003.
<code>https://mail.python.org/pipermail/python-announce-list/2003-January/001984.html</code></li>
<li>“Some RFE for review”, Birkenfeld, 2005.
<code>https://mail.python.org/pipermail/python-dev/2005-June/054438.html</code></li>
<li>“path module”, Orendorff, 2003.
<code>https://mail.python.org/pipermail/python-list/2003-July/174289.html</code></li>
<li>“PRE-PEP: new Path class”, Roth, 2004.
<code>https://mail.python.org/pipermail/python-list/2004-January/201672.html</code></li>
<li><code>http://wiki.python.org/moin/PathClass</code></li>
</ul>
<h2>Copyright (저작권)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.
최종 수정: 2025-02-01 08:59:27 GMT
Source: <code>https://github.com/python/peps/blob/main/peps/pep-0355.rst</code></p>
<hr>
<p><strong>주의:</strong> 이 PEP는 최종적으로 거부되었으며, 제안된 <code>Path</code> 클래스는 Python 표준 라이브러리에 포함되지 않았습니다. 하지만 이 PEP에서 다루는 아이디어와 문제점은 이후 <code>pathlib</code> 모듈과 같은 다른 솔루션의 개발에 영향을 미쳤습니다.</p>
<pre><code>
## References and Footnotes (참조 및 각주)
*   이 메서드는 모든 플랫폼에서 사용 가능하다고 보장되지 않습니다.
*   “(idea) subclassable string: path object?”, van Rossum, 2001.
    `https://mail.python.org/pipermail/python-dev/2001-August/016663.html`
*   “path module v1.0 released”, Orendorff, 2003.
    `https://mail.python.org/pipermail/python-announce-list/2003-January/001984.html`
*   “Some RFE for review”, Birkenfeld, 2005.
    `https://mail.python.org/pipermail/python-dev/2005-June/054438.html`
*   “path module”, Orendorff, 2003.
    `https://mail.python.org/pipermail/python-list/2003-July/174289.html`
*   “PRE-PEP: new Path class”, Roth, 2004.
    `https://mail.python.org/pipermail/python-list/2004-January/201672.html`
*   `http://wiki.python.org/moin/PathClass`

## Copyright (저작권)
이 문서는 퍼블릭 도메인에 공개되었습니다.
최종 수정: 2025-02-01 08:59:27 GMT
Source: `https://github.com/python/peps/blob/main/peps/pep-0355.rst`

---
**주의:** 이 PEP는 최종적으로 거부되었으며, 제안된 `Path` 클래스는 Python 표준 라이브러리에 포함되지 않았습니다. 하지만 이 PEP에서 다루는 아이디어와 문제점은 이후 `pathlib` 모듈과 같은 다른 솔루션의 개발에 영향을 미쳤습니다.


> ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.
</code></pre>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/343/">[Final] PEP 343 - The “with” Statement</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Rejected] PEP 355 - Path - Object oriented filesystem paths</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/630/">[Final] PEP 630 - Isolating Extension Modules</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d6cea809dcbae606.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-e359f205e3380aec.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"931\",\"static/chunks/app/page-90c91ef098171651.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/355\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d6cea809dcbae606.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"vlNzklkFwxZlDtaCTE3RF\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/355/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/355\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"355\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/355\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"default\"]\ne:T6c78,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0355/\"\u003ePEP 355 - Path - Object oriented filesystem paths\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 24-Jan-2006\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 355 – Path: 객체 지향 파일 시스템 경로 (거부됨)\u003c/p\u003e\n\u003ch2\u003e개요\u003c/h2\u003e\n\u003cp\u003e이 문서는 Python Enhancement Proposal (PEP) 355의 내용을 한국어로 번역하고 요약한 것입니다. PEP 355는 파일 시스템 경로를 객체 지향 방식으로 처리하기 위한 새로운 \u003ccode\u003ePath\u003c/code\u003e 클래스를 \u003ccode\u003eos\u003c/code\u003e 모듈에 추가할 것을 제안했습니다. 하지만 이 PEP는 최종적으로 거부되었습니다.\u003c/p\u003e\n\u003ch2\u003e거부 고지 (Rejection Notice)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 현재 형태로 거부되었습니다. 제안된 \u003ccode\u003ePath\u003c/code\u003e 클래스는 너무 많은 기능을 포함하는 \"만물상(kitchen sink)\" 형태였으며, 경로를 사용하는 모든 기능을 단일 클래스의 메서드로 구현하는 방식은 안티패턴으로 간주되었습니다. (예: \u003ccode\u003eopen()\u003c/code\u003e이나 \u003ccode\u003eexecfile()\u003c/code\u003e 같은 기능은 왜 포함되지 않았는가?) \u003ccode\u003estr\u003c/code\u003e을 상속받는 것은 특히 나쁜 아이디어였습니다. 많은 문자열(string) 작업이 경로(path)에 적용될 때 의미가 없기 때문입니다. 이 PEP는 오랫동안 보류되어 왔으며, 논의가 간헐적으로 재점화되었으나, 이제 이 PEP를 종결할 때가 되었다고 결정되었습니다. 덜 과장된 제안이라면 더 받아들여질 수도 있을 것입니다.\u003c/p\u003e\n\u003ch2\u003eAbstract (요약)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003eos\u003c/code\u003e 모듈에 새로운 \u003ccode\u003ePath\u003c/code\u003e 클래스를 추가하여 경로를 객체 지향 방식으로 처리할 것을 제안합니다. 또한, 관련 함수의 \"약한\" Deprecation (비활성화 권고)에 대해서도 논의하고 권고합니다.\u003c/p\u003e\n\u003ch2\u003eBackground (배경)\u003c/h2\u003e\n\u003cp\u003e이 PEP에서 제시된 아이디어는 최근의 것이 아니라, 수년 동안 Python 커뮤니티에서 논의되어 왔습니다. 많은 이들이 \u003ccode\u003eos.path\u003c/code\u003e 모듈에서 제공하는 파일 경로 조작 API가 부적절하다고 느꼈습니다. \u003ccode\u003ePath\u003c/code\u003e 객체에 대한 첫 번째 제안은 2001년 Just van Rossum이 python-dev에서 제기했습니다. 2003년, Jason Orendorff는 경로를 객체로 표현하는 최초의 공개 구현인 \"path module\" 버전 1.0을 발표했습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epath\u003c/code\u003e 모듈은 빠르게 인기를 얻었고, \u003ccode\u003epath\u003c/code\u003e 모듈을 Python 표준 라이브러리에 포함시키려는 수많은 시도가 있었습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003epath\u003c/code\u003e 모듈에 대해 사람들이 표현한 아이디어와 제안을 요약하고, 수정된 버전이 표준 라이브러리에 포함되어야 한다고 제안합니다.\u003c/p\u003e\n\u003ch2\u003eMotivation (동기)\u003c/h2\u003e\n\u003cp\u003e파일 시스템 경로를 다루는 것은 모든 프로그래밍 언어에서 흔한 작업이며, Python과 같은 고급 언어에서는 매우 일반적입니다. 이 작업에 대한 좋은 지원이 필요한 이유는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e거의 모든 프로그램이 파일을 액세스하기 위해 경로를 사용합니다. 자주 수행되는 작업은 가능한 한 직관적이고 쉽게 수행될 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e이는 Python을 복잡한 셸 스크립트를 대체하기에 더 좋은 언어로 만듭니다.\u003c/li\u003e\n\u003cli\u003e현재 Python은 경로를 처리하기 위해 여러 모듈에 흩어져 있는 많은 함수들을 가지고 있습니다. 이로 인해 초보자와 숙련된 개발자 모두에게 올바른 메서드를 선택하기 어렵습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ePath\u003c/code\u003e 클래스는 현재의 일반적인 방식에 비해 다음과 같은 개선 사항을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e하나의 \"통합된(unified)\" 객체가 이전 함수의 모든 기능을 제공합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSubclassability (하위 클래스화 가능성)\u003c/strong\u003e : \u003ccode\u003ePath\u003c/code\u003e 객체는 파일 시스템 경로 외의 다른 경로를 지원하도록 확장될 수 있습니다. 프로그래머는 새로운 API를 배울 필요 없이 \u003ccode\u003ePath\u003c/code\u003e에 대한 지식을 재사용하여 확장된 클래스를 다룰 수 있습니다.\u003c/li\u003e\n\u003cli\u003e모든 관련 기능이 한곳에 있기 때문에, 올바른 접근 방식을 배우기 쉽고, 여러 모듈을 뒤져서 올바른 함수를 찾을 필요가 없습니다.\u003c/li\u003e\n\u003cli\u003ePython은 객체 지향 언어입니다. 파일, \u003ccode\u003edatetime\u003c/code\u003e, 소켓(socket)과 마찬가지로 경로는 객체이며, 단순히 함수에 전달되는 문자열이 아닙니다. \u003ccode\u003ePath\u003c/code\u003e 객체는 본질적으로 Pythonic한 아이디어입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePath\u003c/code\u003e는 속성(properties)을 활용합니다. 속성은 더 읽고 쉬운 코드를 만듭니:\n\u003cpre\u003e\u003ccode\u003e if imgpath.ext == 'jpg':\n     jpegdecode(imgpath)\n\u003c/code\u003e\u003c/pre\u003e\n이것은 다음보다 낫습니다:\n\u003cpre\u003e\u003ccode\u003e if os.path.splitexit(imgpath)[1] == 'jpg':\n     jpegdecode(imgpath)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eRationale (설계 원칙)\u003c/h2\u003e\n\u003cp\u003e다음은 설계의 주요 요점입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePath\u003c/code\u003e는 \u003ccode\u003estr\u003c/code\u003e을 상속하므로, 문자열 경로명을 기대하는 모든 코드는 수정될 필요가 없으며 기존 코드가 손상되지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePath\u003c/code\u003e 객체는 \u003ccode\u003ePath.cwd()\u003c/code\u003e 클래스 메서드를 사용하거나, 경로를 나타내는 문자열로 클래스를 인스턴스화하거나, \u003ccode\u003ePath(\".\")\u003c/code\u003e와 동등한 기본 생성자를 사용하여 생성할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePath\u003c/code\u003e는 일반적인 경로명 조작, 패턴 확장, 패턴 일치(matching) 및 복사를 포함한 다른 고수준 파일 작업을 제공합니다. 기본적으로 \u003ccode\u003ePath\u003c/code\u003e는 파일 내용 조작을 제외한 모든 경로 관련 기능을 제공합니다. 파일 내용 조작에는 파일 객체가 더 적합합니다.\u003c/li\u003e\n\u003cli\u003e플랫폼 비호환성은 시스템별 메서드를 인스턴스화하지 않음으로써 처리됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eSpecification (세부 사양)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ePath\u003c/code\u003e 클래스는 다음과 같은 공개 인터페이스를 정의합니다 (참조 구현에서 docstring을 추출하고 간결하게 줄였습니다. 자세한 내용은 참조 구현을 참조하십시오).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Path(str):\n    # Special Python methods:\n    def __new__(cls, *args) =\u003e Path\n        \"\"\"\n        *args를 연결하여 새 Path 객체를 생성합니다.\n        *args는 Path 객체 또는 문자열만 포함할 수 있습니다.\n        *args가 비어 있으면 Path(os.curdir)가 생성됩니다.\n        \"\"\"\n    def __repr__(self): ...\n    def __add__(self, more): ...\n    def __radd__(self, other): ...\n\n    # Alternative constructor.\n    def cwd(cls): ...\n\n    # Operations on path strings:\n    def abspath(self) =\u003e Path\n        \"\"\"자신의 절대 경로를 새 Path 객체로 반환합니다.\"\"\"\n    def normcase(self): ...\n    def normpath(self): ...\n    def realpath(self): ...\n    def expanduser(self): ...\n    def expandvars(self): ...\n    def basename(self): ...\n    def expand(self): ...\n    def splitpath(self) =\u003e (Path, str)\n        \"\"\"p.splitpath() -\u003e (p.parent, p.name)을 반환합니다.\"\"\"\n    def stripext(self) =\u003e Path\n        \"\"\"p.stripext() -\u003e 경로에서 하나의 파일 확장자를 제거합니다.\"\"\"\n    def splitunc(self): ... # 각주 [1] 참조\n    def splitall(self): ...\n    def relpath(self): ...\n    def relpathto(self, dest): ...\n\n    # Properties about the path:\n    parent =\u003e Path\n        \"\"\"이 Path의 부모 디렉토리를 새 Path 객체로 반환합니다.\"\"\"\n    name =\u003e str\n        \"\"\"전체 경로 없이 파일 또는 디렉토리의 이름을 반환합니다.\"\"\"\n    ext =\u003e str\n        \"\"\"파일 확장자 또는 Path가 확장자 없는 파일이나 디렉토리를 참조하는 경우 빈 문자열.\"\"\"\n    drive =\u003e str\n        \"\"\"드라이브 지정자. 드라이브 지정자를 사용하지 않는 시스템에서는 항상 비어 있습니다.\"\"\"\n    namebase =\u003e str\n        \"\"\"path.name과 동일하지만 하나의 파일 확장자가 제거됩니다.\"\"\"\n    uncshare # 각주 [1] 참조\n\n    # Operations that return lists of paths:\n    def listdir(self, pattern = None): ...\n    def dirs(self, pattern = None): ...\n    def files(self, pattern = None): ...\n    def walk(self, pattern = None): ...\n    def walkdirs(self, pattern = None): ...\n    def walkfiles(self, pattern = None): ...\n    def match(self, pattern) =\u003e bool\n        \"\"\"self.name이 주어진 패턴과 일치하면 True를 반환합니다.\"\"\"\n    def matchcase(self, pattern) =\u003e bool\n        \"\"\"match()와 유사하지만 대소문자를 구분하지 않는 파일 시스템에서도 대소문자 구분을 보장합니다.\"\"\"\n    def glob(self, pattern):\n\n    # Methods for retrieving information about the filesystem path:\n    def exists(self): ...\n    def isabs(self): ...\n    def isdir(self): ...\n    def isfile(self): ...\n    def islink(self): ...\n    def ismount(self): ...\n    def samefile(self, other): ... # 각주 [1] 참조\n    def atime(self): ... \"\"\"파일의 마지막 접근 시간.\"\"\"\n    def mtime(self): ... \"\"\"파일의 마지막 수정 시간.\"\"\"\n    def ctime(self): ... \"\"\"\n        일부 시스템(예: Unix)에서는 마지막 변경 시간,\n        다른 시스템(예: Windows)에서는 Path의 생성 시간인 시스템의 ctime을 반환합니다.\n        \"\"\"\n    def size(self): ...\n    def access(self, mode): ... # 각주 [1] 참조\n    def stat(self): ...\n    def lstat(self): ...\n    def statvfs(self): ... # 각주 [1] 참조\n    def pathconf(self, name): ... # 각주 [1] 참조\n\n    # Methods for manipulating information about the filesystem path.\n    def utime(self, times) =\u003e None\n    def chmod(self, mode) =\u003e None\n    def chown(self, uid, gid) =\u003e None # 각주 [1] 참조\n    def rename(self, new) =\u003e None\n    def renames(self, new) =\u003e None\n\n    # Create/delete operations on directories\n    def mkdir(self, mode = 0o777): ...\n    def makedirs(self, mode = 0o777): ...\n    def rmdir(self): ...\n    def removedirs(self): ...\n\n    # Modifying operations on files\n    def touch(self): ...\n    def remove(self): ...\n    def unlink(self): ...\n\n    # Modifying operations on links\n    def link(self, newpath): ...\n    def symlink(self, newlink): ...\n    def readlink(self): ...\n    def readlinkabs(self): ...\n\n    # High-level functions from shutil\n    def copyfile(self, dst): ...\n    def copymode(self, dst): ...\n    def copystat(self, dst): ...\n    def copy(self, dst): ...\n    def copy2(self, dst): ...\n    def copytree(self, dst, symlinks = True): ...\n    def move(self, dst): ...\n    def rmtree(self, ignore_errors = False, onerror = None): ...\n\n    # Special stuff from os\n    def chroot(self): ... # 각주 [1] 참조\n    def startfile(self): ... # 각주 [1] 참조\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e각주: 이 메서드는 모든 플랫폼에서 사용 가능하다고 보장되지 않습니다.\u003c/p\u003e\n\u003ch2\u003eReplacing older functions with the Path class (기존 함수를 \u003ccode\u003ePath\u003c/code\u003e 클래스로 대체하기)\u003c/h2\u003e\n\u003cp\u003e이 섹션에서 \"a ==\u003e b\"는 b가 a를 대체할 수 있음을 의미합니다.\n다음 예제에서는 \u003ccode\u003efrom path import Path\u003c/code\u003e로 \u003ccode\u003ePath\u003c/code\u003e 클래스가 임포트되었다고 가정합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eos.path.join\u003c/code\u003e 대체:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eos.path.join(os.getcwd(), \"foobar\")    ==\u003e Path(Path.cwd(), \"foobar\")\nos.path.join(\"foo\", \"bar\", \"baz\")      ==\u003e Path(\"foo\", \"bar\", \"baz\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eos.path.splitext\u003c/code\u003e 대체:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efname = \"Python2.4.tar.gz\"\nos.path.splitext(fname)[1]            ==\u003e fname = Path(\"Python2.4.tar.gz\")\n                                          fname.ext\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 부분을 모두 원한다면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efname = \"Python2.4.tar.gz\"\nbase, ext = os.path.splitext(fname)   ==\u003e fname = Path(\"Python2.4.tar.gz\")\n                                          base, ext = fname.namebase, fname.ext\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eglob.glob\u003c/code\u003e 대체:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elib_dir = \"/lib\"\nlibs = glob.glob(os.path.join(lib_dir, \"*s.o\")) ==\u003e lib_dir = Path(\"/lib\")\n                                                    libs = lib_dir.files(\"*.so\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eDeprecations (비활성화 권고)\u003c/h2\u003e\n\u003cp\u003e이 모듈을 표준 라이브러리에 도입하면 여러 기존 모듈 및 함수의 \"약한\" 비활성화 권고가 필요합니다. 이 모듈과 함수들은 너무 널리 사용되므로, \u003ccode\u003eDeprecationWarning\u003c/code\u003e을 생성하는 방식으로 완전히 비활성화할 수는 없습니다. 여기서 \"약한 비활성화 권고\"는 문서에만 명시하는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e아래 표는 비활성화 권고되어야 할 기존 기능을 나열합니다.\u003c/p\u003e\n\u003cp\u003e| Path method/property | Deprecates function               |\n| :------------------- | :-------------------------------- |\n| \u003ccode\u003enormcase()\u003c/code\u003e         | \u003ccode\u003eos.path.normcase()\u003c/code\u003e              |\n| \u003ccode\u003enormpath()\u003c/code\u003e         | \u003ccode\u003eos.path.normpath()\u003c/code\u003e              |\n| \u003ccode\u003erealpath()\u003c/code\u003e         | \u003ccode\u003eos.path.realpath()\u003c/code\u003e              |\n| \u003ccode\u003eexpanduser()\u003c/code\u003e       | \u003ccode\u003eos.path.expanduser()\u003c/code\u003e            |\n| \u003ccode\u003eexpandvars()\u003c/code\u003e       | \u003ccode\u003eos.path.expandvars()\u003c/code\u003e            |\n| \u003ccode\u003eparent\u003c/code\u003e             | \u003ccode\u003eos.path.dirname()\u003c/code\u003e               |\n| \u003ccode\u003ename\u003c/code\u003e               | \u003ccode\u003eos.path.basename()\u003c/code\u003e              |\n| \u003ccode\u003esplitpath()\u003c/code\u003e        | \u003ccode\u003eos.path.split()\u003c/code\u003e                 |\n| \u003ccode\u003edrive\u003c/code\u003e              | \u003ccode\u003eos.path.splitdrive()\u003c/code\u003e            |\n| \u003ccode\u003eext\u003c/code\u003e                | \u003ccode\u003eos.path.splitext()\u003c/code\u003e              |\n| \u003ccode\u003esplitunc()\u003c/code\u003e         | \u003ccode\u003eos.path.splitunc()\u003c/code\u003e              |\n| \u003ccode\u003e__new__()\u003c/code\u003e          | \u003ccode\u003eos.path.join()\u003c/code\u003e, \u003ccode\u003eos.curdir\u003c/code\u003e     |\n| \u003ccode\u003elistdir()\u003c/code\u003e          | \u003ccode\u003eos.listdir()\u003c/code\u003e \u003ccode\u003e[fnmatch.filter()]\u003c/code\u003e |\n| \u003ccode\u003ematch()\u003c/code\u003e            | \u003ccode\u003efnmatch.fnmatch()\u003c/code\u003e               |\n| \u003ccode\u003ematchcase()\u003c/code\u003e        | \u003ccode\u003efnmatch.fnmatchcase()\u003c/code\u003e           |\n| \u003ccode\u003eglob()\u003c/code\u003e             | \u003ccode\u003eglob.glob()\u003c/code\u003e                     |\n| \u003ccode\u003eexists()\u003c/code\u003e           | \u003ccode\u003eos.path.exists()\u003c/code\u003e                |\n| \u003ccode\u003eisabs()\u003c/code\u003e            | \u003ccode\u003eos.path.isabs()\u003c/code\u003e                 |\n| \u003ccode\u003eisdir()\u003c/code\u003e            | \u003ccode\u003eos.path.isdir()\u003c/code\u003e                 |\n| \u003ccode\u003eisfile()\u003c/code\u003e           | \u003ccode\u003eos.path.isfile()\u003c/code\u003e                |\n| \u003ccode\u003eislink()\u003c/code\u003e           | \u003ccode\u003eos.path.islink()\u003c/code\u003e                |\n| \u003ccode\u003eismount()\u003c/code\u003e          | \u003ccode\u003eos.path.ismount()\u003c/code\u003e               |\n| \u003ccode\u003esamefile()\u003c/code\u003e         | \u003ccode\u003eos.path.samefile()\u003c/code\u003e              |\n| \u003ccode\u003eatime()\u003c/code\u003e            | \u003ccode\u003eos.path.getatime()\u003c/code\u003e              |\n| \u003ccode\u003ectime()\u003c/code\u003e            | \u003ccode\u003eos.path.getctime()\u003c/code\u003e              |\n| \u003ccode\u003emtime()\u003c/code\u003e            | \u003ccode\u003eos.path.getmtime()\u003c/code\u003e              |\n| \u003ccode\u003esize()\u003c/code\u003e             | \u003ccode\u003eos.path.getsize()\u003c/code\u003e               |\n| \u003ccode\u003ecwd()\u003c/code\u003e              | \u003ccode\u003eos.getcwd()\u003c/code\u003e                     |\n| \u003ccode\u003eaccess()\u003c/code\u003e           | \u003ccode\u003eos.access()\u003c/code\u003e                     |\n| \u003ccode\u003estat()\u003c/code\u003e             | \u003ccode\u003eos.stat()\u003c/code\u003e                       |\n| \u003ccode\u003elstat()\u003c/code\u003e            | \u003ccode\u003eos.lstat()\u003c/code\u003e                      |\n| \u003ccode\u003estatvfs()\u003c/code\u003e          | \u003ccode\u003eos.statvfs()\u003c/code\u003e                    |\n| \u003ccode\u003epathconf()\u003c/code\u003e         | \u003ccode\u003eos.pathconf()\u003c/code\u003e                   |\n| \u003ccode\u003eutime()\u003c/code\u003e            | \u003ccode\u003eos.utime()\u003c/code\u003e                      |\n| \u003ccode\u003echmod()\u003c/code\u003e            | \u003ccode\u003eos.chmod()\u003c/code\u003e                      |\n| \u003ccode\u003echown()\u003c/code\u003e            | \u003ccode\u003eos.chown()\u003c/code\u003e                      |\n| \u003ccode\u003erename()\u003c/code\u003e           | \u003ccode\u003eos.rename()\u003c/code\u003e                     |\n| \u003ccode\u003erenames()\u003c/code\u003e          | \u003ccode\u003eos.renames()\u003c/code\u003e                    |\n| \u003ccode\u003emkdir()\u003c/code\u003e            | \u003ccode\u003eos.mkdir()\u003c/code\u003e                      |\n| \u003ccode\u003emakedirs()\u003c/code\u003e         | \u003ccode\u003eos.makedirs()\u003c/code\u003e                   |\n| \u003ccode\u003ermdir()\u003c/code\u003e            | \u003ccode\u003eos.rmdir()\u003c/code\u003e                      |\n| \u003ccode\u003eremovedirs()\u003c/code\u003e       | \u003ccode\u003eos.removedirs()\u003c/code\u003e                 |\n| \u003ccode\u003eremove()\u003c/code\u003e           | \u003ccode\u003eos.remove()\u003c/code\u003e                     |\n| \u003ccode\u003eunlink()\u003c/code\u003e           | \u003ccode\u003eos.unlink()\u003c/code\u003e                     |\n| \u003ccode\u003elink()\u003c/code\u003e             | \u003ccode\u003eos.link()\u003c/code\u003e                       |\n| \u003ccode\u003esymlink()\u003c/code\u003e          | \u003ccode\u003eos.symlink()\u003c/code\u003e                    |\n| \u003ccode\u003ereadlink()\u003c/code\u003e         | \u003ccode\u003eos.readlink()\u003c/code\u003e                   |\n| \u003ccode\u003echroot()\u003c/code\u003e           | \u003ccode\u003eos.chroot()\u003c/code\u003e                     |\n| \u003ccode\u003estartfile()\u003c/code\u003e        | \u003ccode\u003eos.startfile()\u003c/code\u003e                  |\n| \u003ccode\u003ecopyfile()\u003c/code\u003e         | \u003ccode\u003eshutil.copyfile()\u003c/code\u003e               |\n| \u003ccode\u003ecopymode()\u003c/code\u003e         | \u003ccode\u003eshutil.copymode()\u003c/code\u003e               |\n| \u003ccode\u003ecopystat()\u003c/code\u003e         | \u003ccode\u003eshutil.copystat()\u003c/code\u003e               |\n| \u003ccode\u003ecopy()\u003c/code\u003e             | \u003ccode\u003eshutil.copy()\u003c/code\u003e                   |\n| \u003ccode\u003ecopy2()\u003c/code\u003e            | \u003ccode\u003eshutil.copy2()\u003c/code\u003e                  |\n| \u003ccode\u003ecopytree()\u003c/code\u003e         | \u003ccode\u003eshutil.copytree()\u003c/code\u003e               |\n| \u003ccode\u003emove()\u003c/code\u003e             | \u003ccode\u003eshutil.move()\u003c/code\u003e                   |\n| \u003ccode\u003ermtree()\u003c/code\u003e           | \u003ccode\u003eshutil.rmtree()\u003c/code\u003e                 |\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePath\u003c/code\u003e 클래스는 \u003ccode\u003eos.path\u003c/code\u003e, \u003ccode\u003eshutil\u003c/code\u003e, \u003ccode\u003efnmatch\u003c/code\u003e, \u003ccode\u003eglob\u003c/code\u003e 전체와 \u003ccode\u003eos\u003c/code\u003e 모듈의 상당 부분을 비활성화 권고합니다.\u003c/p\u003e\n\u003ch2\u003eClosed Issues (해결된 문제)\u003c/h2\u003e\n\u003cp\u003e이 PEP가 python-dev에 처음 등장한 이후 여러 논쟁적인 문제가 해결되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__div__()\u003c/code\u003e 메서드가 제거되었습니다. \u003ccode\u003e/\u003c/code\u003e(나누기) 연산자를 오버로딩하는 것은 \"지나친 마법(too much magic)\"일 수 있으며, 경로 연결이 나누기로 보일 수 있습니다. 필요하다면 BDFL(Benevolent Dictator For Life)의 결정에 따라 나중에 다시 추가될 수 있습니다. 대신 \u003ccode\u003e__new__()\u003c/code\u003e는 \u003ccode\u003ePath\u003c/code\u003e와 문자열 객체 모두를 받아들이는 \u003ccode\u003e*args\u003c/code\u003e 인수를 받게 되었습니다. \u003ccode\u003e*args\u003c/code\u003e는 \u003ccode\u003eos.path.join()\u003c/code\u003e을 사용하여 연결되며, 이 함수는 \u003ccode\u003ePath\u003c/code\u003e 객체를 구성하는 데 사용됩니다. 이러한 변경으로 문제가 있던 \u003ccode\u003ejoinpath()\u003c/code\u003e 메서드는 쓸모없어져 제거되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egetatime()/atime\u003c/code\u003e, \u003ccode\u003egetctime()/ctime\u003c/code\u003e, \u003ccode\u003egetmtime()/mtime\u003c/code\u003e, \u003ccode\u003egetsize()/size\u003c/code\u003e 메서드와 속성은 서로 중복되었습니다. 이들은 \u003ccode\u003eatime()\u003c/code\u003e, \u003ccode\u003ectime()\u003c/code\u003e, \u003ccode\u003emtime()\u003c/code\u003e, \u003ccode\u003esize()\u003c/code\u003e로 병합되었습니다. 이들이 속성 대신 메서드인 이유는 예상치 못하게 변경될 가능성이 있기 때문입니다. 다음 예제는 항상 어설션(assertion)을 통과한다고 보장할 수 없습니다:\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ep = Path(\"foobar\")\ns = p.size()\nassert p.size() == s\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eOpen Issues (미해결 문제)\u003c/h2\u003e\n\u003cp\u003eJason Orendorff의 \u003ccode\u003epath\u003c/code\u003e 모듈의 일부 기능은 생략되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e경로를 여는 함수는 내장 \u003ccode\u003eopen()\u003c/code\u003e 함수로 더 잘 처리됩니다.\u003c/li\u003e\n\u003cli\u003e전체 파일을 읽고 쓰는 함수는 파일 객체의 \u003ccode\u003eread()\u003c/code\u003e 및 \u003ccode\u003ewrite()\u003c/code\u003e 메서드로 더 잘 처리됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echdir()\u003c/code\u003e 함수는 포함할 가치가 있을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e비활성화 권고(deprecation) 일정이 설정되어야 합니다. \u003ccode\u003ePath\u003c/code\u003e는 얼마나 많은 기능을 구현해야 할까요? 기존 기능 중 얼마나 많은 부분을 언제 비활성화 권고해야 할까요?\u003c/li\u003e\n\u003cli\u003e이름은 분명히 \"path\" 또는 \"Path\"여야 하지만, 어디에 위치해야 할까요? 자체 모듈에 있을까요, 아니면 \u003ccode\u003eos\u003c/code\u003e에 있을까요?\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePath\u003c/code\u003e가 \u003ccode\u003estr\u003c/code\u003e 또는 \u003ccode\u003eunicode\u003c/code\u003e를 상속하기 때문에, 다음과 같은 비마법적(non-magic) 공개 메서드가 \u003ccode\u003ePath\u003c/code\u003e 객체에서 사용 가능합니다:\n\u003ccode\u003ecapitalize()\u003c/code\u003e, \u003ccode\u003ecenter()\u003c/code\u003e, \u003ccode\u003ecount()\u003c/code\u003e, \u003ccode\u003edecode()\u003c/code\u003e, \u003ccode\u003eencode()\u003c/code\u003e, \u003ccode\u003eendswith()\u003c/code\u003e, \u003ccode\u003eexpandtabs()\u003c/code\u003e, \u003ccode\u003efind()\u003c/code\u003e, \u003ccode\u003eindex()\u003c/code\u003e, \u003ccode\u003eisalnum()\u003c/code\u003e, \u003ccode\u003eisalpha()\u003c/code\u003e, \u003ccode\u003eisdigit()\u003c/code\u003e, \u003ccode\u003eislower()\u003c/code\u003e, \u003ccode\u003eisspace()\u003c/code\u003e, \u003ccode\u003eistitle()\u003c/code\u003e, \u003ccode\u003eisupper()\u003c/code\u003e, \u003ccode\u003ejoin()\u003c/code\u003e, \u003ccode\u003eljust()\u003c/code\u003e, \u003ccode\u003elower()\u003c/code\u003e, \u003ccode\u003elstrip()\u003c/code\u003e, \u003ccode\u003ereplace()\u003c/code\u003e, \u003ccode\u003erfind()\u003c/code\u003e, \u003ccode\u003erindex()\u003c/code\u003e, \u003ccode\u003erjust()\u003c/code\u003e, \u003ccode\u003ersplit()\u003c/code\u003e, \u003ccode\u003erstrip()\u003c/code\u003e, \u003ccode\u003esplit()\u003c/code\u003e, \u003ccode\u003esplitlines()\u003c/code\u003e, \u003ccode\u003estartswith()\u003c/code\u003e, \u003ccode\u003estrip()\u003c/code\u003e, \u003ccode\u003eswapcase()\u003c/code\u003e, \u003ccode\u003etitle()\u003c/code\u003e, \u003ccode\u003etranslate()\u003c/code\u003e, \u003ccode\u003eupper()\u003c/code\u003e, \u003ccode\u003ezfill()\u003c/code\u003e\npython-dev에서는 이러한 상속이 합리적인지에 대해 논쟁이 있었습니다. 대부분의 논의자들은 파일 시스템 경로의 맥락에서 대부분의 문자열 메서드가 의미가 없으며, 단지 불필요한 부담일 뿐이라고 말했습니다. 다른 의견은 문자열을 상속하는 것이 매우 편리하며, \u003ccode\u003ePath\u003c/code\u003e 객체에 대해 코드를 \"그냥 작동하도록\" 만들 수 있어서 적응할 필요가 없다는 것이었습니다.\n문제 중 하나는 Python 수준에서 객체가 \u003ccode\u003estr\u003c/code\u003e 또는 \u003ccode\u003eunicode\u003c/code\u003e를 상속하지 않는 한, 내장 함수 \u003ccode\u003eopen()\u003c/code\u003e (및 문자열 또는 버퍼를 기대하는 다른 내장 함수)에 전달할 수 있을 만큼 \"문자열과 유사하게\" 만들 방법이 없다는 것입니다. 따라서 문자열을 상속하지 않으려면 CPython 코어를 변경해야 합니다.\u003c/li\u003e\n\u003cli\u003e이 새로운 모듈이 대체하려는 함수와 모듈들 (\u003ccode\u003eos.path\u003c/code\u003e, \u003ccode\u003eshutil\u003c/code\u003e, \u003ccode\u003efnmatch\u003c/code\u003e, \u003ccode\u003eglob\u003c/code\u003e, 그리고 \u003ccode\u003eos\u003c/code\u003e의 일부)은 하위 호환성을 유지하기 위해 미래의 Python 버전에서도 오랫동안 사용 가능할 것으로 예상됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eReference Implementation (참조 구현)\u003c/h2\u003e\n\u003cp\u003e현재 \u003ccode\u003ePath\u003c/code\u003e 클래스는 표준 라이브러리 모듈인 \u003ccode\u003efnmatch\u003c/code\u003e, \u003ccode\u003eglob\u003c/code\u003e, \u003ccode\u003eos\u003c/code\u003e, \u003ccode\u003eos.path\u003c/code\u003e, \u003ccode\u003eshutil\u003c/code\u003e에 대한 얇은 래퍼(thin wrapper)로 구현되어 있습니다. 이 PEP의 의도는 앞서 언급된 모듈의 기능을 \u003ccode\u003ePath\u003c/code\u003e로 옮기고, 이들을 비활성화 권고하는 것입니다.\u003c/p\u003e\n\u003cp\u003e자세한 내용과 구현은 다음을 참조하십시오:\nhttp://wiki.python.org/moin/PathModule\u003c/p\u003e\n\u003ch2\u003eExamples (예시)\u003c/h2\u003e\n\u003cp\u003e이 섹션에서 \"a ==\u003e b\"는 b가 a를 대체할 수 있음을 의미합니다.\u003c/p\u003e\n\u003cp\u003e디렉토리 내의 모든 Python 파일을 실행 가능하게 만들기:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eDIR = '/usr/home/guido/bin'\nfor f in os.listdir(DIR):\n    if f.endswith('.py'):\n        path = os.path.join(DIR, f)\n        os.chmod(path, 0o755)\n==\u003e\nfor f in Path('/usr/home/guido/bin').files(\"*.py\"):\n    f.chmod(0o755)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEmacs 백업 파일 삭제:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef delete_backups(arg, dirname, names):\n    for name in names:\n        if name.endswith('~'):\n            os.remove(os.path.join(dirname, name))\nos.path.walk(os.environ['HOME'], delete_backups, None)\n==\u003e\nd = Path(os.environ['HOME'])\nfor f in d.walkfiles('*~'):\n    f.remove()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e파일의 상대 경로 찾기:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eb = Path('/users/peter/')\na = Path('/users/peter/synergy/tiki.txt')\na.relpathto(b)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e경로를 디렉토리와 파일명으로 분할:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eos.path.split(\"/path/to/foo/bar.txt\")\n==\u003e\nPath(\"/path/to/foo/bar.txt\").splitpath()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 디렉토리 트리에서 모든 Python 스크립트 나열:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elist(Path().walkfiles(\"*.py\"))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eReferences and Footnotes (참조 및 각주)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e이 메서드는 모든 플랫폼에서 사용 가능하다고 보장되지 않습니다.\u003c/li\u003e\n\u003cli\u003e“(idea) subclassable string: path object?”, van Rossum, 2001.\n\u003ccode\u003ehttps://mail.python.org/pipermail/python-dev/2001-August/016663.html\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e“path module v1.0 released”, Orendorff, 2003.\n\u003ccode\u003ehttps://mail.python.org/pipermail/python-announce-list/2003-January/001984.html\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e“Some RFE for review”, Birkenfeld, 2005.\n\u003ccode\u003ehttps://mail.python.org/pipermail/python-dev/2005-June/054438.html\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e“path module”, Orendorff, 2003.\n\u003ccode\u003ehttps://mail.python.org/pipermail/python-list/2003-July/174289.html\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e“PRE-PEP: new Path class”, Roth, 2004.\n\u003ccode\u003ehttps://mail.python.org/pipermail/python-list/2004-January/201672.html\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehttp://wiki.python.org/moin/PathClass\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCopyright (저작권)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\n최종 수정: 2025-02-01 08:59:27 GMT\nSource: \u003ccode\u003ehttps://github.com/python/peps/blob/main/peps/pep-0355.rst\u003c/code\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e주의:\u003c/strong\u003e 이 PEP는 최종적으로 거부되었으며, 제안된 \u003ccode\u003ePath\u003c/code\u003e 클래스는 Python 표준 라이브러리에 포함되지 않았습니다. 하지만 이 PEP에서 다루는 아이디어와 문제점은 이후 \u003ccode\u003epathlib\u003c/code\u003e 모듈과 같은 다른 솔루션의 개발에 영향을 미쳤습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n## References and Footnotes (참조 및 각주)\n*   이 메서드는 모든 플랫폼에서 사용 가능하다고 보장되지 않습니다.\n*   “(idea) subclassable string: path object?”, van Rossum, 2001.\n    `https://mail.python.org/pipermail/python-dev/2001-August/016663.html`\n*   “path module v1.0 released”, Orendorff, 2003.\n    `https://mail.python.org/pipermail/python-announce-list/2003-January/001984.html`\n*   “Some RFE for review”, Birkenfeld, 2005.\n    `https://mail.python.org/pipermail/python-dev/2005-June/054438.html`\n*   “path module”, Orendorff, 2003.\n    `https://mail.python.org/pipermail/python-list/2003-July/174289.html`\n*   “PRE-PEP: new Path class”, Roth, 2004.\n    `https://mail.python.org/pipermail/python-list/2004-January/201672.html`\n*   `http://wiki.python.org/moin/PathClass`\n\n## Copyright (저작권)\n이 문서는 퍼블릭 도메인에 공개되었습니다.\n최종 수정: 2025-02-01 08:59:27 GMT\nSource: `https://github.com/python/peps/blob/main/peps/pep-0355.rst`\n\n---\n**주의:** 이 PEP는 최종적으로 거부되었으며, 제안된 `Path` 클래스는 Python 표준 라이브러리에 포함되지 않았습니다. 하지만 이 PEP에서 다루는 아이디어와 문제점은 이후 `pathlib` 모듈과 같은 다른 솔루션의 개발에 영향을 미쳤습니다.\n\n\n\u003e ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\n\u003c/code\u003e\u003c/pre\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2420,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 355 - Path - Object oriented filesystem paths\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 01:12:42+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/355/\",\"postId\":\"2025-09-27-pep-0355-path-object-oriented-filesystem-paths\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/343/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 343 - The “with” Statement\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Rejected] PEP 355 - Path - Object oriented filesystem paths\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/630/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 630 - Isolating Extension Modules\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>