<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d6cea809dcbae606.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-0395f68b8cc78a20.js" async=""></script><script src="/_next/static/chunks/23-706b53707bbf0661.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-467e37449c5a68fc.js" async=""></script><script src="/_next/static/chunks/app/layout-bb929596377d30e0.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2353<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Superseded] PEP 509 - Add a private version to dict</h1><div class="page__meta"><time dateTime="2025-09-26 22:55:06+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0509/">PEP 509 - Add a private version to dict</a></p>
<p><strong>상태:</strong> Superseded | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 04-Jan-2016</p>
</blockquote>
<h1>PEP 509 – dict에 Private 버전 추가</h1>
<h2>초록 (Abstract)</h2>
<p>이 PEP는 내장 <code>dict</code> 타입에 새로운 private 버전을 추가할 것을 제안합니다. 이 버전은 각 딕셔너리 생성 시, 그리고 각 딕셔너리 변경 시마다 증가하여, 네임스페이스(namespace)에 대한 빠른 가드(guard)를 구현하는 데 사용됩니다.</p>
<h2>배경 (Rationale)</h2>
<p>Python에서 내장 <code>dict</code> 타입은 다양한 명령어에서 사용됩니다. 예를 들어, <code>LOAD_GLOBAL</code> 명령어는 전역 네임스페이스나 내장(builtins) 네임스페이스에서 변수를 찾습니다 (두 번의 <code>dict</code> 조회). Python은 <code>builtins</code> 네임스페이스, <code>globals</code> 네임스페이스, 타입 네임스페이스, 인스턴스 네임스페이스 등에서 <code>dict</code>를 활용합니다. (함수의) 로컬 네임스페이스는 일반적으로 배열로 최적화되지만, <code>dict</code>가 될 수도 있습니다.</p>
<p>Python은 거의 모든 것이 런타임에 수정될 수 있기 때문에 최적화하기 어렵습니다. 내장 함수, 함수 코드, 전역 변수, 로컬 변수 등이 변경될 수 있기 때문입니다. Python의 의미론(semantics)을 존중하면서 최적화를 구현하려면 "무언가가 변경될 때"를 감지해야 합니다. 이러한 검사를 "가드(guards)"라고 부릅니다.</p>
<p>최적화의 속도 향상은 가드 검사의 속도에 달려 있습니다. 이 PEP는 네임스페이스에 대한 빠른 가드를 구현하기 위해 딕셔너리에 private 버전을 추가할 것을 제안합니다.</p>
<p>대부분의 네임스페이스에서 딕셔너리 버전이 변경되지 않는 일반적인 경우, 딕셔너리 조회를 건너뛸 수 있습니다. 버전은 전역적으로(globally) 고유하므로, 버전을 확인하는 것만으로 네임스페이스 딕셔너리가 새 딕셔너리로 교체되지 않았는지 확인할 수 있습니다.</p>
<p>딕셔너리 버전이 변경되지 않을 때, 가드의 성능은 감시하는 딕셔너리 엔트리의 수에 의존하지 않습니다. 복잡도는 O(1)입니다.</p>
<p>최적화의 예시로, 전역 변수의 값을 함수 상수로 복사하는 것을 들 수 있습니다. 이 최적화는 전역 변수가 복사된 후 수정되었는지 확인하기 위해 전역 변수에 대한 가드를 필요로 합니다. 전역 변수가 수정되지 않으면, 함수는 캐시된 복사본을 사용합니다. 전역 변수가 수정되면, 함수는 일반 조회를 사용하고, 다음 함수 호출에 대한 가드 검사 오버헤드를 제거하기 위해 함수를 역최적화(deoptimize)할 수도 있습니다.</p>
<p>함수를 전문화하기 위한 가드의 구체적인 사용법과 Python 정적 최적화 도구에 대한 더 일반적인 배경은 <a href="https://peps.python.org/pep-0510/">PEP 510 – Specialized functions with guards</a>를 참조하세요.</p>
<h2>가드 예시 (Guard example)</h2>
<p>가상의 <code>dict_get_version(dict)</code> 함수를 사용하여 딕셔너리 엔트리가 수정되었는지 (생성, 업데이트 또는 삭제) 확인하는 빠른 가드의 의사 코드(pseudo-code)는 다음과 같습니다.</p>
<pre><code class="language-python">UNSET = object()

class GuardDictKey:
    def __init__(self, dict, key):
        self.dict = dict
        self.key = key
        self.value = dict.get(key, UNSET)
        self.version = dict_get_version(dict)

    def check(self):
        """딕셔너리 엔트리가 변경되지 않았고 딕셔너리가 교체되지 않았다면 True를 반환합니다."""
        # 딕셔너리의 버전을 읽습니다.
        version = dict_get_version(self.dict)
        if version == self.version:
            # 빠른 경로(Fast-path): 딕셔너리 조회 생략
            return True

        # 딕셔너리에서 값을 조회합니다.
        value = self.dict.get(self.key, UNSET)
        if value is self.value:
            # 다른 키가 수정되었습니다:
            # 새 딕셔너리 버전을 캐시합니다.
            self.version = version
            return True

        # 키가 수정되었습니다.
        return False
</code></pre>
<h2><code>dict</code> 버전 활용 (Usage of the dict version)</h2>
<h3>메서드 호출 속도 향상 (Speedup method calls)</h3>
<p>Yury Selivanov는 메서드 호출을 최적화하는 패치를 작성했습니다. 이 패치는 "ceval에 opcode별 캐시 구현" 패치에 의존하며, 이 패치는 <code>globals</code> 딕셔너리 또는 <code>builtins</code> 딕셔너리가 수정된 경우 캐시를 무효화하기 위해 딕셔너리 버전을 필요로 합니다.</p>
<p>캐시는 딕셔너리 버전이 전역적으로 고유해야 합니다. 예를 들어, <code>exec()</code> 함수를 <code>globals</code> 매개변수와 함께 사용하여 한 네임스페이스에서 함수를 정의하고 다른 네임스페이스에서 호출하는 것이 가능합니다. 이 경우 <code>globals</code> 딕셔너리가 교체되므로 캐시도 무효화되어야 합니다.</p>
<h3>가드를 이용한 특수화된 함수 (Specialized functions using guards)</h3>
<p>PEP 510은 가드를 사용한 특수화된 함수를 지원하는 API를 제안합니다. 이는 Python의 의미론을 깨지 않고 Python을 위한 정적 최적화 도구를 구현할 수 있게 합니다.</p>
<p>FAT Python 프로젝트의 <code>fatoptimizer</code>는 정적 Python 최적화 도구의 한 예입니다. 이 도구는 네임스페이스에 대한 가드를 필요로 하는 많은 최적화를 구현합니다.</p>
<ul>
<li>순수(pure) <code>builtins</code> 호출: <code>len("abc")</code>를 <code>3</code>으로 대체하려면, <code>builtins.__dict__['len']</code>과 <code>globals()['len']</code>에 대한 가드가 필요합니다.</li>
<li>루프 언롤링(Loop unrolling): <code>for i in range(...): ...</code>와 같은 루프를 언롤링하려면, <code>builtins.__dict__['range']</code>와 <code>globals()['range']</code>에 대한 가드가 필요합니다.</li>
</ul>
<h3>Pyjion</h3>
<p>Pyjion의 두 주요 개발자 중 한 명인 Brett Cannon에 따르면, Pyjion은 최적화를 구현하기 위해 딕셔너리 버전의 이점을 얻을 수 있습니다. Pyjion은 CoreCLR (Microsoft .NET Core 런타임) 기반의 Python용 JIT 컴파일러입니다.</p>
<h3>Cython</h3>
<p>Cython도 최적화를 구현하기 위해 딕셔너리 버전의 이점을 얻을 수 있습니다. Cython은 Python 프로그래밍 언어와 확장된 Cython 프로그래밍 언어 모두를 위한 최적화 정적 컴파일러입니다.</p>
<h3>Unladen Swallow</h3>
<p>딕셔너리 버전이 명시적으로 언급되지는 않았지만, <code>globals</code> 및 <code>builtins</code> 조회 최적화는 Unladen Swallow 계획의 일부였습니다. (출처: Unladen Swallow ProjectPlan). Unladen Swallow는 LLVM으로 구현된 JIT 컴파일러를 추가한 CPython 2.6.1의 포크였습니다. 이 프로젝트는 2011년에 중단되었습니다.</p>
<h2>변경 사항 (Changes)</h2>
<p><code>PyDictObject</code> 구조체에 C 타입 <code>PY_UINT64_T</code> (64비트 부호 없는 정수)를 가진 <code>ma_version_tag</code> 필드를 추가합니다. 또한 전역 딕셔너리 버전도 추가합니다.</p>
<p>딕셔너리가 생성될 때마다 전역 버전은 증가하고 딕셔너리 버전은 전역 버전으로 초기화됩니다.</p>
<p>딕셔너리 내용이 수정될 때마다 전역 버전은 증가하고 딕셔너리 버전으로 복사되어야 합니다. 내용을 수정할 수 있는 딕셔너리 메서드는 다음과 같습니다.</p>
<ul>
<li><code>clear()</code></li>
<li><code>pop(key)</code></li>
<li><code>popitem()</code></li>
<li><code>setdefault(key, value)</code></li>
<li><code>__delitem__(key)</code></li>
<li><code>__setitem__(key, value)</code></li>
<li><code>update(...)</code></li>
</ul>
<p>딕셔너리 메서드가 내용을 변경하지 않을 때 버전을 증가시킬지 여부는 Python 구현에 맡겨집니다. Python 구현은 가드에서 딕셔너리 조회를 피하기 위해 버전을 증가시키지 않기로 결정할 수 있습니다. 딕셔너리 메서드가 내용을 변경하지 않는 경우의 예시는 다음과 같습니다.</p>
<ul>
<li><code>clear()</code>: 딕셔너리가 이미 비어 있는 경우</li>
<li><code>pop(key)</code>: 키가 존재하지 않는 경우</li>
<li><code>popitem()</code>: 딕셔너리가 비어 있는 경우</li>
<li><code>setdefault(key, value)</code>: 키가 이미 존재하는 경우</li>
<li><code>__delitem__(key)</code>: 키가 존재하지 않는 경우</li>
<li><code>__setitem__(key, value)</code>: 새 값이 현재 값과 동일한 경우</li>
<li><code>update()</code>: 인자 없이 호출되거나 새 값이 현재 값과 동일한 경우</li>
</ul>
<p>키를 이전 값과 동일한 새 값으로 설정하는 것도 딕셔너리 내용을 수정하는 작업으로 간주됩니다.</p>
<p>두 개의 서로 다른 빈 딕셔너리는 버전만으로 딕셔너리를 식별할 수 있도록 다른 버전을 가져야 합니다. 이는 딕셔너리에 대한 강력한 참조(strong reference)를 저장하지 않고도 네임스페이스가 교체되지 않았는지 가드에서 확인할 수 있게 합니다. 빌린 참조(borrowed reference)를 사용하는 것은 작동하지 않습니다. 이전 딕셔너리가 파괴되면 새 딕셔너리가 동일한 메모리 주소에 할당될 수 있기 때문입니다. 참고로 딕셔너리는 약한 참조(weak references)를 지원하지 않습니다.</p>
<p>버전 증가는 원자적(atomic)이어야 합니다. CPython에서는 GIL(Global Interpreter Lock)이 이미 <code>dict</code> 메서드를 보호하여 변경 사항을 원자적으로 만듭니다.</p>
<p>가상의 <code>dict_get_version(dict)</code> 함수를 사용하는 예시는 다음과 같습니다.</p>
<pre><code class="language-python">>>> d = {}
>>> dict_get_version(d)
100
>>> d['key'] = 'value'
>>> dict_get_version(d)
101
>>> d['key'] = 'new value'
>>> dict_get_version(d)
102
>>> del d['key']
>>> dict_get_version(d)
103
</code></pre>
<p>이 필드는 정수 오버플로우(integer overflow) 후에 잘못될 수 있는 <code>version &#x3C;= old_version</code> 대신 <code>version_tag == old_version_tag</code>를 사용하여 비교하도록 제안하기 위해 <code>ma_version</code> 대신 <code>ma_version_tag</code>로 명명되었습니다.</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p><code>PyDictObject</code> 구조체는 안정적인 ABI(Application Binary Interface)의 일부가 아니며, 새 딕셔너리 버전이 Python 스코프에 노출되지 않으므로 변경 사항은 하위 호환됩니다.</p>
<h2>구현 및 성능 (Implementation and Performance)</h2>
<p>이 PEP를 구현하는 패치는 <a href="https://bugs.python.org/issue26058">issue #26058: PEP 509: Add ma_version_tag to PyDictObject</a>에 포함되어 있습니다.</p>
<p><code>pybench</code> 및 <code>timeit</code> 마이크로벤치마크에서 이 패치는 딕셔너리 작업에 오버헤드를 추가하지 않는 것으로 보입니다. 예를 들어, 다음 <code>timeit</code> 마이크로벤치마크는 변경 전후 모두 318나노초가 걸립니다.</p>
<pre><code class="language-bash">python3.6 -m timeit 'd={1: 0}; d=0; d=0; d=0; del d; del d; d.clear()'
</code></pre>
<p>버전이 변경되지 않을 때 <code>PyDict_GetItem()</code>은 딕셔너리 조회에 14.8ns가 걸리는 반면, 가드 검사는 3.8ns만 걸립니다. 또한 가드는 여러 키를 감시할 수 있습니다. 예를 들어, 함수에서 10개의 전역 변수를 사용하는 최적화의 경우, 10번의 딕셔너리 조회는 148ns가 소요되지만, 버전이 변경되지 않을 때 가드는 여전히 3.8ns만 소요됩니다 (39배 빠름).</p>
<p><code>fat</code> 모듈은 이러한 가드를 구현합니다. <code>fat.GuardDict</code>는 딕셔너리 버전을 기반으로 합니다.</p>
<h2>정수 오버플로우 (Integer overflow)</h2>
<p>구현은 버전을 저장하기 위해 C 타입 <code>PY_UINT64_T</code>를 사용합니다. 이는 64비트 부호 없는 정수입니다. C 코드는 <code>version++</code>를 사용합니다. C 표준에 따라 정수 오버플로우 시 버전은 0으로 래핑됩니다 (그리고 계속 증가합니다).</p>
<p>정수 오버플로우 후, 감시하던 딕셔너리 키가 수정되었음에도 불구하고 가드가 성공할 수 있습니다. 이 버그는 이전 가드 검사 이후 정확히 2^64번의 딕셔너리 생성 또는 수정이 있었을 때만 가드 검사에서 발생합니다.</p>
<p>딕셔너리가 1나노초마다 수정된다고 가정하면, 2^64번의 수정은 584년 이상 걸립니다. 32비트 버전을 사용하면 4초밖에 걸리지 않습니다. 그래서 32비트 시스템에서도 64비트 부호 없는 타입이 사용됩니다. C 레벨에서의 딕셔너리 조회는 14.8ns가 걸립니다.</p>
<p>584년에 한 번 발생하는 버그의 위험은 허용 가능합니다.</p>
<h2>대안 (Alternatives)</h2>
<h3>Python 레벨에서 읽기 전용 <code>__version__</code> 속성으로 버전 노출 (Expose the version at Python level as a read-only <code>__version__</code> property)</h3>
<p>이 PEP의 첫 번째 버전은 딕셔너리 버전을 Python 레벨에서 읽기 전용 <code>__version__</code> 속성으로 노출하고, <code>collections.UserDict</code>에도 이 속성을 추가할 것을 제안했습니다 (이 타입은 <code>dict</code> API를 모방해야 하므로).</p>
<p>여기에는 여러 가지 문제가 있습니다.</p>
<ul>
<li>
<p>일관성을 유지하고 예기치 않은 문제를 피하려면 모든 매핑(mapping) 타입에 버전을 추가해야 합니다. 실제로 버전은 <code>dict</code> 타입에서만 필요하므로, 새로운 매핑 타입을 구현하는 것은 이점 없이 추가 작업만 필요하게 됩니다.</p>
</li>
<li>
<p>모든 Python 구현이 이 새로운 속성을 구현해야 하며, 다른 구현들은 딕셔너리 버전을 전혀 사용하지 않을 수도 있는데 더 많은 작업을 부여하게 됩니다.</p>
</li>
<li>
<p>Python 레벨에서 딕셔너리 버전을 노출하면 성능에 대한 잘못된 가정을 초래할 수 있습니다. Python 레벨에서 <code>dict.__version__</code>을 확인하는 것은 딕셔너리 조회보다 빠르지 않습니다. Python에서 딕셔너리 조회는 48.7ns의 비용이 들고, 버전 확인은 47.5ns의 비용이 들므로 차이는 1.2ns (3%)에 불과합니다.</p>
<pre><code class="language-bash">$ python3.6 -m timeit -s 'd = {str(i):i for i in range(100)}' 'd["33"] == 33'
10000000 loops, best of 3: 0.0487 usec per loop
$ python3.6 -m timeit -s 'd = {str(i):i for i in range(100)}' 'd.__version__ == 100'
10000000 loops, best of 3: 0.0475 usec per loop
</code></pre>
</li>
<li>
<p><code>__version__</code>은 정수 오버플로우 시 래핑될 수 있습니다. 이는 오류를 유발하기 쉽습니다. <code>dict.__version__ &#x3C;= guard_version</code>은 잘못되었고, 정수 오버플로우에 대한 버그 위험을 줄이기 위해 (실제로 정수 오버플로우가 발생할 가능성은 낮지만) <code>dict.__version__ == guard_version</code>을 대신 사용해야 합니다.</p>
</li>
</ul>
<p>속성 이름에 대한 필수적인 'bikeshedding'(사소한 것에 대한 불필요한 논쟁)이 있었습니다.</p>
<ul>
<li><code>__cache_token__</code>: Alyssa Coghlan이 제안한 이름으로, <code>abc.get_cache_token()</code>에서 유래했습니다.</li>
<li><code>__version__</code></li>
<li><code>__version_tag__</code></li>
<li><code>__timestamp__</code></li>
</ul>
<h3>각 딕셔너리 엔트리에 버전 추가 (Add a version to each dict entry)</h3>
<p>딕셔너리당 하나의 버전은 값이 예상보다 오래 살아있게 만들 수 있는 강력한 참조(strong reference)를 유지해야 합니다. 각 딕셔너리 엔트리에 버전을 추가하면, 가드는 값에 대한 강력한 참조를 피하기 위해 엔트리 버전 (단순한 정수)만 저장할 수 있습니다. 딕셔너리와 키에 대한 강력한 참조만 필요합니다.</p>
<p>변경 사항: <code>PyDictKeyEntry</code> 구조체에 <code>me_version_tag</code> 필드를 추가합니다. 이 필드는 C 타입 <code>PY_UINT64_T</code>를 가집니다. 키가 생성되거나 수정될 때, 엔트리 버전은 모든 변경 (생성, 수정, 삭제) 시 증가하는 딕셔너리 버전으로 설정됩니다.</p>
<p>가상의 <code>dict_get_version(dict)</code> 및 <code>dict_get_entry_version(dict)</code> 함수를 사용하여 딕셔너리 키가 수정되었는지 확인하는 빠른 가드의 의사 코드는 다음과 같습니다.</p>
<pre><code class="language-python">UNSET = object()

class GuardDictKey:
    def __init__(self, dict, key):
        self.dict = dict
        self.key = key
        self.dict_version = dict_get_version(dict)
        self.entry_version = dict_get_entry_version(dict, key)

    def check(self):
        """딕셔너리 엔트리가 변경되지 않았고 딕셔너리가 교체되지 않았다면 True를 반환합니다."""
        # 딕셔너리의 버전을 읽습니다.
        dict_version = dict_get_version(self.dict)
        if dict_version == self.version: # 여기서 self.version 대신 self.dict_version이어야 할 것으로 보입니다 (원문 오류).
            # 빠른 경로(Fast-path): 딕셔너리 조회 생략
            return True

        # 엔트리 버전을 읽기 위해 딕셔너리에서 조회합니다.
        entry_version = get_dict_key_version(dict, key) # 여기서 get_dict_key_version 대신 dict_get_entry_version이어야 할 것으로 보입니다 (원문 오류).
        if entry_version == self.entry_version:
            # 다른 키가 수정되었습니다:
            # 새 딕셔너리 버전을 캐시합니다.
            self.dict_version = dict_version
            self.entry_version = entry_version
            return True

        # 키가 수정되었습니다.
        return False
</code></pre>
<p>이 옵션의 주요 단점은 메모리 사용량에 미치는 영향입니다. 이는 각 딕셔너리 엔트리의 크기를 증가시키므로, 오버헤드는 버킷(사용되든 안 되든 딕셔너리 엔트리)의 수에 따라 달라집니다. 예를 들어, 64비트 시스템에서는 각 딕셔너리 엔트리의 크기를 8바이트 증가시킵니다.</p>
<p>Python에서는 메모리 사용량이 중요하며, 이를 줄이는 추세입니다. 예시:</p>
<ul>
<li>PEP 393 – Flexible String Representation</li>
<li>PEP 412 – Key-Sharing Dictionary</li>
</ul>
<h3>새로운 <code>dict</code> 하위 타입 추가 (Add a new dict subtype)</h3>
<p>새로운 <code>verdict</code> 타입을 <code>dict</code>의 하위 타입으로 추가하는 것을 제안합니다. 가드가 필요할 때, <code>dict</code> 대신 네임스페이스 (모듈 네임스페이스, 타입 네임스페이스, 인스턴스 네임스페이스 등)에 <code>verdict</code>를 사용합니다.</p>
<p>가드가 사용되지 않을 때 오버헤드 (CPU, 메모리 사용량)를 추가하지 않도록 <code>dict</code> 타입은 변경하지 않고 둡니다.</p>
<p>기술적인 문제: CPython 코어를 포함하여 야생(wild)에는 정확한 <code>dict</code> 타입을 예상하는 많은 C 코드가 있습니다. 문제점:</p>
<ul>
<li><code>exec()</code>는 <code>globals</code> 및 <code>locals</code>에 <code>dict</code>를 필요로 합니다. 많은 코드가 <code>globals={}</code>를 사용합니다. 호출자가 <code>globals</code> 매개변수가 수정될 것으로 예상하기 때문에 <code>dict</code>를 <code>dict</code> 하위 타입으로 캐스팅하는 것은 불가능합니다 (<code>dict</code>는 가변(mutable)입니다).</li>
<li>C 함수는 객체가 <code>dict</code> 하위 타입인 경우 <code>PyObject_xxx()</code> 함수를 호출하는 대신 <code>PyDict_xxx()</code> 함수를 직접 호출합니다.</li>
<li>일부 함수가 정확한 <code>dict</code> 타입을 요구하는 반면, <code>PyDict_CheckExact()</code> 검사는 <code>dict</code> 하위 타입에서 실패합니다.</li>
<li><code>Python/ceval.c</code>는 네임스페이스에 대한 <code>dict</code> 하위 타입을 완전히 지원하지 않습니다.</li>
</ul>
<p><code>exec()</code> 문제는 블로커(blocker) 문제입니다.</p>
<p>다른 문제점:</p>
<ul>
<li>가비지 컬렉터(garbage collector)는 <code>dict</code> 인스턴스의 "untrack"를 위한 특별한 코드를 가지고 있습니다. <code>dict</code> 하위 타입이 네임스페이스에 사용되면 가비지 컬렉터가 일부 참조 순환(reference cycles)을 끊지 못할 수 있습니다.</li>
<li>일부 함수에는 <code>dict</code>에 대한 빠른 경로(fast-path)가 있으며, 이는 <code>dict</code> 하위 타입에서는 사용되지 않으므로 Python을 약간 느리게 만들 수 있습니다.</li>
</ul>
<h2>선행 연구 (Prior Art)</h2>
<h3>메서드 캐시 및 타입 버전 태그 (Method cache and type version tag)</h3>
<p>2007년에 Armin Rigo는 메서드 캐시를 구현하는 패치를 작성했습니다. 이는 Python 2.6에 병합되었습니다. 이 패치는 "타입 속성 캐시 버전 태그"(<code>tp_version_tag</code>)와 타입에 "유효한 버전 태그" 플래그 (<code>PyTypeObject</code> 구조체)를 추가합니다.</p>
<p>타입 버전 태그는 Python 레벨에 노출되지 않습니다.</p>
<p>버전 태그는 C 타입 <code>unsigned int</code>를 가집니다. 캐시는 모든 타입이 공유하는 4096개의 엔트리로 구성된 전역 해시 테이블입니다. 캐시는 "빠르게 만들고, 확정적이며 낮은 메모리 사용량을 가지며, 무효화하기 쉽도록" 전역적입니다. 각 캐시 엔트리는 버전 태그를 가집니다. 전역 버전 태그는 다음 버전 태그를 생성하는 데 사용되며, 이 역시 C 타입 <code>unsigned int</code>를 가집니다.</p>
<p>기본적으로 타입은 버전 태그가 유효하지 않음을 나타내기 위해 "유효한 버전 태그" 플래그가 지워집니다. 타입의 첫 번째 메서드가 캐시될 때, 버전 태그와 "유효한 버전 태그" 플래그가 설정됩니다. 타입이 수정되면, 해당 타입과 그 서브클래스의 "유효한 버전 태그" 플래그가 지워집니다. 나중에 이러한 타입의 캐시 엔트리가 사용될 때, 해당 엔트리는 버전 태그가 오래되었기 때문에 제거됩니다.</p>
<p>정수 오버플로우 시 전체 캐시가 지워지고 전역 버전 태그는 0으로 재설정됩니다.</p>
<p>메서드 캐시 (<a href="https://bugs.python.org/issue1685986">issue #1685986</a>) 및 Python 2.6용으로 업데이트된 Armin의 메서드 캐시 최적화 (<a href="https://bugs.python.org/issue1700288">issue #1700288</a>)를 참조하세요.</p>
<h3>Globals / builtins 캐시 (Globals / builtins cache)</h3>
<p>2010년에 Antoine Pitrou는 <code>PyDictObject</code> 구조체 (<code>dict</code> 타입)에 private <code>ma_version</code> 필드를 추가하는 Globals / builtins 캐시 (<a href="https://bugs.python.org/issue10401">issue #10401</a>)를 제안했습니다. 이 필드는 C 타입 <code>Py_ssize_t</code>를 가집니다.</p>
<p>이 패치는 함수와 프레임에 "전역 및 내장 캐시"를 추가하고, <code>LOAD_GLOBAL</code> 및 <code>STORE_GLOBAL</code> 명령어를 캐시를 사용하도록 변경합니다.</p>
<p><code>PyDictObject</code> 구조체에 대한 변경 사항은 이 PEP와 매우 유사합니다.</p>
<h3>Cached globals+builtins lookup (캐시된 전역+내장 조회)</h3>
<p>2006년에 Andrea Griffini는 Cached globals+builtins lookup 최적화를 구현하는 패치를 제안했습니다. 이 패치는 <code>PyDictObject</code> 구조체 (<code>dict</code> 타입)에 private <code>timestamp</code> 필드를 추가하며, 이 필드는 C 타입 <code>size_t</code>를 가집니다.</p>
<p>python-dev 메일링 리스트의 토론: <a href="https://mail.python.org/pipermail/python-dev/2006-December/070285.html">About dictionary lookup caching (December 2006)</a>.</p>
<h3>Guard against changing dict during iteration (반복 중 딕셔너리 변경 방지)</h3>
<p>2013년에 Serhiy Storchaka는 반복 중 딕셔너리 변경 방지 (<a href="https://bugs.python.org/issue19332">issue #19332</a>)를 제안했습니다. 이는 <code>PyDictObject</code> 구조체 (<code>dict</code> 타입)에 <code>ma_count</code> 필드를 추가하며, 이 필드는 C 타입 <code>size_t</code>를 가집니다. 이 필드는 딕셔너리가 수정될 때마다 증가합니다.</p>
<h3>PySizer</h3>
<p>PySizer: Python용 메모리 프로파일러, Nick Smallbone의 Google Summer of Code 2005 프로젝트.</p>
<p>이 프로젝트는 CPython 2.4용 패치를 가지고 있으며, 딕셔너리 엔트리에 <code>key_time</code> 및 <code>value_time</code> 필드를 추가합니다. 이는 딕셔너리용 전역 프로세스 전체 카운터를 사용하며, 딕셔너리가 수정될 때마다 증가합니다. 이 시간은 자식 객체가 부모 객체에 처음 나타난 시기를 결정하는 데 사용됩니다.</p>
<h2>논의 (Discussion)</h2>
<p>메일링 리스트 토론 스레드.</p>
<ul>
<li><a href="https://mail.python.org/pipermail/python-dev/2016-April/144062.html">python-dev: Updated PEP 509</a></li>
<li><a href="https://mail.python.org/pipermail/python-dev/2016-April/143926.html">python-dev: RFC: PEP 509: Add a private version to dict</a></li>
<li><a href="https://mail.python.org/pipermail/python-dev/2016-January/142999.html">python-dev: PEP 509: Add a private version to dict (January 2016)</a></li>
<li><a href="https://mail.python.org/pipermail/python-ideas/2016-January/037746.html">python-ideas: RFC: PEP: Add dict.<strong>version</strong> (January 2016)</a></li>
</ul>
<h2>수락 (Acceptance)</h2>
<p>이 PEP는 2016년 9월 7일 Guido van Rossum에 의해 수락되었습니다. 이 PEP의 구현은 이후 저장소에 커밋되었습니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 공용 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/508/">[Final] PEP 508 - Dependency specification for Python Software Packages</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Superseded] PEP 509 - Add a private version to dict</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/510/">[Rejected] PEP 510 - Specialize functions with guards</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d6cea809dcbae606.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"185\",\"static/chunks/app/layout-bb929596377d30e0.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/509\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d6cea809dcbae606.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"aIY0iLmQmvh4xdeXIovMZ\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/509/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/509\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"509\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/509\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-467e37449c5a68fc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-dfe24a3bbd58f9b9.js\"],\"default\"]\ne:T69a2,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0509/\"\u003ePEP 509 - Add a private version to dict\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Superseded | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 04-Jan-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 509 – dict에 Private 버전 추가\u003c/h1\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 내장 \u003ccode\u003edict\u003c/code\u003e 타입에 새로운 private 버전을 추가할 것을 제안합니다. 이 버전은 각 딕셔너리 생성 시, 그리고 각 딕셔너리 변경 시마다 증가하여, 네임스페이스(namespace)에 대한 빠른 가드(guard)를 구현하는 데 사용됩니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003ePython에서 내장 \u003ccode\u003edict\u003c/code\u003e 타입은 다양한 명령어에서 사용됩니다. 예를 들어, \u003ccode\u003eLOAD_GLOBAL\u003c/code\u003e 명령어는 전역 네임스페이스나 내장(builtins) 네임스페이스에서 변수를 찾습니다 (두 번의 \u003ccode\u003edict\u003c/code\u003e 조회). Python은 \u003ccode\u003ebuiltins\u003c/code\u003e 네임스페이스, \u003ccode\u003eglobals\u003c/code\u003e 네임스페이스, 타입 네임스페이스, 인스턴스 네임스페이스 등에서 \u003ccode\u003edict\u003c/code\u003e를 활용합니다. (함수의) 로컬 네임스페이스는 일반적으로 배열로 최적화되지만, \u003ccode\u003edict\u003c/code\u003e가 될 수도 있습니다.\u003c/p\u003e\n\u003cp\u003ePython은 거의 모든 것이 런타임에 수정될 수 있기 때문에 최적화하기 어렵습니다. 내장 함수, 함수 코드, 전역 변수, 로컬 변수 등이 변경될 수 있기 때문입니다. Python의 의미론(semantics)을 존중하면서 최적화를 구현하려면 \"무언가가 변경될 때\"를 감지해야 합니다. 이러한 검사를 \"가드(guards)\"라고 부릅니다.\u003c/p\u003e\n\u003cp\u003e최적화의 속도 향상은 가드 검사의 속도에 달려 있습니다. 이 PEP는 네임스페이스에 대한 빠른 가드를 구현하기 위해 딕셔너리에 private 버전을 추가할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e대부분의 네임스페이스에서 딕셔너리 버전이 변경되지 않는 일반적인 경우, 딕셔너리 조회를 건너뛸 수 있습니다. 버전은 전역적으로(globally) 고유하므로, 버전을 확인하는 것만으로 네임스페이스 딕셔너리가 새 딕셔너리로 교체되지 않았는지 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e딕셔너리 버전이 변경되지 않을 때, 가드의 성능은 감시하는 딕셔너리 엔트리의 수에 의존하지 않습니다. 복잡도는 O(1)입니다.\u003c/p\u003e\n\u003cp\u003e최적화의 예시로, 전역 변수의 값을 함수 상수로 복사하는 것을 들 수 있습니다. 이 최적화는 전역 변수가 복사된 후 수정되었는지 확인하기 위해 전역 변수에 대한 가드를 필요로 합니다. 전역 변수가 수정되지 않으면, 함수는 캐시된 복사본을 사용합니다. 전역 변수가 수정되면, 함수는 일반 조회를 사용하고, 다음 함수 호출에 대한 가드 검사 오버헤드를 제거하기 위해 함수를 역최적화(deoptimize)할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e함수를 전문화하기 위한 가드의 구체적인 사용법과 Python 정적 최적화 도구에 대한 더 일반적인 배경은 \u003ca href=\"https://peps.python.org/pep-0510/\"\u003ePEP 510 – Specialized functions with guards\u003c/a\u003e를 참조하세요.\u003c/p\u003e\n\u003ch2\u003e가드 예시 (Guard example)\u003c/h2\u003e\n\u003cp\u003e가상의 \u003ccode\u003edict_get_version(dict)\u003c/code\u003e 함수를 사용하여 딕셔너리 엔트리가 수정되었는지 (생성, 업데이트 또는 삭제) 확인하는 빠른 가드의 의사 코드(pseudo-code)는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eUNSET = object()\n\nclass GuardDictKey:\n    def __init__(self, dict, key):\n        self.dict = dict\n        self.key = key\n        self.value = dict.get(key, UNSET)\n        self.version = dict_get_version(dict)\n\n    def check(self):\n        \"\"\"딕셔너리 엔트리가 변경되지 않았고 딕셔너리가 교체되지 않았다면 True를 반환합니다.\"\"\"\n        # 딕셔너리의 버전을 읽습니다.\n        version = dict_get_version(self.dict)\n        if version == self.version:\n            # 빠른 경로(Fast-path): 딕셔너리 조회 생략\n            return True\n\n        # 딕셔너리에서 값을 조회합니다.\n        value = self.dict.get(self.key, UNSET)\n        if value is self.value:\n            # 다른 키가 수정되었습니다:\n            # 새 딕셔너리 버전을 캐시합니다.\n            self.version = version\n            return True\n\n        # 키가 수정되었습니다.\n        return False\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e\u003ccode\u003edict\u003c/code\u003e 버전 활용 (Usage of the dict version)\u003c/h2\u003e\n\u003ch3\u003e메서드 호출 속도 향상 (Speedup method calls)\u003c/h3\u003e\n\u003cp\u003eYury Selivanov는 메서드 호출을 최적화하는 패치를 작성했습니다. 이 패치는 \"ceval에 opcode별 캐시 구현\" 패치에 의존하며, 이 패치는 \u003ccode\u003eglobals\u003c/code\u003e 딕셔너리 또는 \u003ccode\u003ebuiltins\u003c/code\u003e 딕셔너리가 수정된 경우 캐시를 무효화하기 위해 딕셔너리 버전을 필요로 합니다.\u003c/p\u003e\n\u003cp\u003e캐시는 딕셔너리 버전이 전역적으로 고유해야 합니다. 예를 들어, \u003ccode\u003eexec()\u003c/code\u003e 함수를 \u003ccode\u003eglobals\u003c/code\u003e 매개변수와 함께 사용하여 한 네임스페이스에서 함수를 정의하고 다른 네임스페이스에서 호출하는 것이 가능합니다. 이 경우 \u003ccode\u003eglobals\u003c/code\u003e 딕셔너리가 교체되므로 캐시도 무효화되어야 합니다.\u003c/p\u003e\n\u003ch3\u003e가드를 이용한 특수화된 함수 (Specialized functions using guards)\u003c/h3\u003e\n\u003cp\u003ePEP 510은 가드를 사용한 특수화된 함수를 지원하는 API를 제안합니다. 이는 Python의 의미론을 깨지 않고 Python을 위한 정적 최적화 도구를 구현할 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003eFAT Python 프로젝트의 \u003ccode\u003efatoptimizer\u003c/code\u003e는 정적 Python 최적화 도구의 한 예입니다. 이 도구는 네임스페이스에 대한 가드를 필요로 하는 많은 최적화를 구현합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e순수(pure) \u003ccode\u003ebuiltins\u003c/code\u003e 호출: \u003ccode\u003elen(\"abc\")\u003c/code\u003e를 \u003ccode\u003e3\u003c/code\u003e으로 대체하려면, \u003ccode\u003ebuiltins.__dict__['len']\u003c/code\u003e과 \u003ccode\u003eglobals()['len']\u003c/code\u003e에 대한 가드가 필요합니다.\u003c/li\u003e\n\u003cli\u003e루프 언롤링(Loop unrolling): \u003ccode\u003efor i in range(...): ...\u003c/code\u003e와 같은 루프를 언롤링하려면, \u003ccode\u003ebuiltins.__dict__['range']\u003c/code\u003e와 \u003ccode\u003eglobals()['range']\u003c/code\u003e에 대한 가드가 필요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ePyjion\u003c/h3\u003e\n\u003cp\u003ePyjion의 두 주요 개발자 중 한 명인 Brett Cannon에 따르면, Pyjion은 최적화를 구현하기 위해 딕셔너리 버전의 이점을 얻을 수 있습니다. Pyjion은 CoreCLR (Microsoft .NET Core 런타임) 기반의 Python용 JIT 컴파일러입니다.\u003c/p\u003e\n\u003ch3\u003eCython\u003c/h3\u003e\n\u003cp\u003eCython도 최적화를 구현하기 위해 딕셔너리 버전의 이점을 얻을 수 있습니다. Cython은 Python 프로그래밍 언어와 확장된 Cython 프로그래밍 언어 모두를 위한 최적화 정적 컴파일러입니다.\u003c/p\u003e\n\u003ch3\u003eUnladen Swallow\u003c/h3\u003e\n\u003cp\u003e딕셔너리 버전이 명시적으로 언급되지는 않았지만, \u003ccode\u003eglobals\u003c/code\u003e 및 \u003ccode\u003ebuiltins\u003c/code\u003e 조회 최적화는 Unladen Swallow 계획의 일부였습니다. (출처: Unladen Swallow ProjectPlan). Unladen Swallow는 LLVM으로 구현된 JIT 컴파일러를 추가한 CPython 2.6.1의 포크였습니다. 이 프로젝트는 2011년에 중단되었습니다.\u003c/p\u003e\n\u003ch2\u003e변경 사항 (Changes)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ePyDictObject\u003c/code\u003e 구조체에 C 타입 \u003ccode\u003ePY_UINT64_T\u003c/code\u003e (64비트 부호 없는 정수)를 가진 \u003ccode\u003ema_version_tag\u003c/code\u003e 필드를 추가합니다. 또한 전역 딕셔너리 버전도 추가합니다.\u003c/p\u003e\n\u003cp\u003e딕셔너리가 생성될 때마다 전역 버전은 증가하고 딕셔너리 버전은 전역 버전으로 초기화됩니다.\u003c/p\u003e\n\u003cp\u003e딕셔너리 내용이 수정될 때마다 전역 버전은 증가하고 딕셔너리 버전으로 복사되어야 합니다. 내용을 수정할 수 있는 딕셔너리 메서드는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eclear()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epop(key)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epopitem()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esetdefault(key, value)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__delitem__(key)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__setitem__(key, value)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eupdate(...)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e딕셔너리 메서드가 내용을 변경하지 않을 때 버전을 증가시킬지 여부는 Python 구현에 맡겨집니다. Python 구현은 가드에서 딕셔너리 조회를 피하기 위해 버전을 증가시키지 않기로 결정할 수 있습니다. 딕셔너리 메서드가 내용을 변경하지 않는 경우의 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eclear()\u003c/code\u003e: 딕셔너리가 이미 비어 있는 경우\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epop(key)\u003c/code\u003e: 키가 존재하지 않는 경우\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epopitem()\u003c/code\u003e: 딕셔너리가 비어 있는 경우\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esetdefault(key, value)\u003c/code\u003e: 키가 이미 존재하는 경우\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__delitem__(key)\u003c/code\u003e: 키가 존재하지 않는 경우\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__setitem__(key, value)\u003c/code\u003e: 새 값이 현재 값과 동일한 경우\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eupdate()\u003c/code\u003e: 인자 없이 호출되거나 새 값이 현재 값과 동일한 경우\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e키를 이전 값과 동일한 새 값으로 설정하는 것도 딕셔너리 내용을 수정하는 작업으로 간주됩니다.\u003c/p\u003e\n\u003cp\u003e두 개의 서로 다른 빈 딕셔너리는 버전만으로 딕셔너리를 식별할 수 있도록 다른 버전을 가져야 합니다. 이는 딕셔너리에 대한 강력한 참조(strong reference)를 저장하지 않고도 네임스페이스가 교체되지 않았는지 가드에서 확인할 수 있게 합니다. 빌린 참조(borrowed reference)를 사용하는 것은 작동하지 않습니다. 이전 딕셔너리가 파괴되면 새 딕셔너리가 동일한 메모리 주소에 할당될 수 있기 때문입니다. 참고로 딕셔너리는 약한 참조(weak references)를 지원하지 않습니다.\u003c/p\u003e\n\u003cp\u003e버전 증가는 원자적(atomic)이어야 합니다. CPython에서는 GIL(Global Interpreter Lock)이 이미 \u003ccode\u003edict\u003c/code\u003e 메서드를 보호하여 변경 사항을 원자적으로 만듭니다.\u003c/p\u003e\n\u003cp\u003e가상의 \u003ccode\u003edict_get_version(dict)\u003c/code\u003e 함수를 사용하는 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e d = {}\n\u003e\u003e\u003e dict_get_version(d)\n100\n\u003e\u003e\u003e d['key'] = 'value'\n\u003e\u003e\u003e dict_get_version(d)\n101\n\u003e\u003e\u003e d['key'] = 'new value'\n\u003e\u003e\u003e dict_get_version(d)\n102\n\u003e\u003e\u003e del d['key']\n\u003e\u003e\u003e dict_get_version(d)\n103\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 필드는 정수 오버플로우(integer overflow) 후에 잘못될 수 있는 \u003ccode\u003eversion \u0026#x3C;= old_version\u003c/code\u003e 대신 \u003ccode\u003eversion_tag == old_version_tag\u003c/code\u003e를 사용하여 비교하도록 제안하기 위해 \u003ccode\u003ema_version\u003c/code\u003e 대신 \u003ccode\u003ema_version_tag\u003c/code\u003e로 명명되었습니다.\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ePyDictObject\u003c/code\u003e 구조체는 안정적인 ABI(Application Binary Interface)의 일부가 아니며, 새 딕셔너리 버전이 Python 스코프에 노출되지 않으므로 변경 사항은 하위 호환됩니다.\u003c/p\u003e\n\u003ch2\u003e구현 및 성능 (Implementation and Performance)\u003c/h2\u003e\n\u003cp\u003e이 PEP를 구현하는 패치는 \u003ca href=\"https://bugs.python.org/issue26058\"\u003eissue #26058: PEP 509: Add ma_version_tag to PyDictObject\u003c/a\u003e에 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epybench\u003c/code\u003e 및 \u003ccode\u003etimeit\u003c/code\u003e 마이크로벤치마크에서 이 패치는 딕셔너리 작업에 오버헤드를 추가하지 않는 것으로 보입니다. 예를 들어, 다음 \u003ccode\u003etimeit\u003c/code\u003e 마이크로벤치마크는 변경 전후 모두 318나노초가 걸립니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epython3.6 -m timeit 'd={1: 0}; d=0; d=0; d=0; del d; del d; d.clear()'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e버전이 변경되지 않을 때 \u003ccode\u003ePyDict_GetItem()\u003c/code\u003e은 딕셔너리 조회에 14.8ns가 걸리는 반면, 가드 검사는 3.8ns만 걸립니다. 또한 가드는 여러 키를 감시할 수 있습니다. 예를 들어, 함수에서 10개의 전역 변수를 사용하는 최적화의 경우, 10번의 딕셔너리 조회는 148ns가 소요되지만, 버전이 변경되지 않을 때 가드는 여전히 3.8ns만 소요됩니다 (39배 빠름).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efat\u003c/code\u003e 모듈은 이러한 가드를 구현합니다. \u003ccode\u003efat.GuardDict\u003c/code\u003e는 딕셔너리 버전을 기반으로 합니다.\u003c/p\u003e\n\u003ch2\u003e정수 오버플로우 (Integer overflow)\u003c/h2\u003e\n\u003cp\u003e구현은 버전을 저장하기 위해 C 타입 \u003ccode\u003ePY_UINT64_T\u003c/code\u003e를 사용합니다. 이는 64비트 부호 없는 정수입니다. C 코드는 \u003ccode\u003eversion++\u003c/code\u003e를 사용합니다. C 표준에 따라 정수 오버플로우 시 버전은 0으로 래핑됩니다 (그리고 계속 증가합니다).\u003c/p\u003e\n\u003cp\u003e정수 오버플로우 후, 감시하던 딕셔너리 키가 수정되었음에도 불구하고 가드가 성공할 수 있습니다. 이 버그는 이전 가드 검사 이후 정확히 2^64번의 딕셔너리 생성 또는 수정이 있었을 때만 가드 검사에서 발생합니다.\u003c/p\u003e\n\u003cp\u003e딕셔너리가 1나노초마다 수정된다고 가정하면, 2^64번의 수정은 584년 이상 걸립니다. 32비트 버전을 사용하면 4초밖에 걸리지 않습니다. 그래서 32비트 시스템에서도 64비트 부호 없는 타입이 사용됩니다. C 레벨에서의 딕셔너리 조회는 14.8ns가 걸립니다.\u003c/p\u003e\n\u003cp\u003e584년에 한 번 발생하는 버그의 위험은 허용 가능합니다.\u003c/p\u003e\n\u003ch2\u003e대안 (Alternatives)\u003c/h2\u003e\n\u003ch3\u003ePython 레벨에서 읽기 전용 \u003ccode\u003e__version__\u003c/code\u003e 속성으로 버전 노출 (Expose the version at Python level as a read-only \u003ccode\u003e__version__\u003c/code\u003e property)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 첫 번째 버전은 딕셔너리 버전을 Python 레벨에서 읽기 전용 \u003ccode\u003e__version__\u003c/code\u003e 속성으로 노출하고, \u003ccode\u003ecollections.UserDict\u003c/code\u003e에도 이 속성을 추가할 것을 제안했습니다 (이 타입은 \u003ccode\u003edict\u003c/code\u003e API를 모방해야 하므로).\u003c/p\u003e\n\u003cp\u003e여기에는 여러 가지 문제가 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e일관성을 유지하고 예기치 않은 문제를 피하려면 모든 매핑(mapping) 타입에 버전을 추가해야 합니다. 실제로 버전은 \u003ccode\u003edict\u003c/code\u003e 타입에서만 필요하므로, 새로운 매핑 타입을 구현하는 것은 이점 없이 추가 작업만 필요하게 됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e모든 Python 구현이 이 새로운 속성을 구현해야 하며, 다른 구현들은 딕셔너리 버전을 전혀 사용하지 않을 수도 있는데 더 많은 작업을 부여하게 됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePython 레벨에서 딕셔너리 버전을 노출하면 성능에 대한 잘못된 가정을 초래할 수 있습니다. Python 레벨에서 \u003ccode\u003edict.__version__\u003c/code\u003e을 확인하는 것은 딕셔너리 조회보다 빠르지 않습니다. Python에서 딕셔너리 조회는 48.7ns의 비용이 들고, 버전 확인은 47.5ns의 비용이 들므로 차이는 1.2ns (3%)에 불과합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ python3.6 -m timeit -s 'd = {str(i):i for i in range(100)}' 'd[\"33\"] == 33'\n10000000 loops, best of 3: 0.0487 usec per loop\n$ python3.6 -m timeit -s 'd = {str(i):i for i in range(100)}' 'd.__version__ == 100'\n10000000 loops, best of 3: 0.0475 usec per loop\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e__version__\u003c/code\u003e은 정수 오버플로우 시 래핑될 수 있습니다. 이는 오류를 유발하기 쉽습니다. \u003ccode\u003edict.__version__ \u0026#x3C;= guard_version\u003c/code\u003e은 잘못되었고, 정수 오버플로우에 대한 버그 위험을 줄이기 위해 (실제로 정수 오버플로우가 발생할 가능성은 낮지만) \u003ccode\u003edict.__version__ == guard_version\u003c/code\u003e을 대신 사용해야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e속성 이름에 대한 필수적인 'bikeshedding'(사소한 것에 대한 불필요한 논쟁)이 있었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__cache_token__\u003c/code\u003e: Alyssa Coghlan이 제안한 이름으로, \u003ccode\u003eabc.get_cache_token()\u003c/code\u003e에서 유래했습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__version__\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__version_tag__\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__timestamp__\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e각 딕셔너리 엔트리에 버전 추가 (Add a version to each dict entry)\u003c/h3\u003e\n\u003cp\u003e딕셔너리당 하나의 버전은 값이 예상보다 오래 살아있게 만들 수 있는 강력한 참조(strong reference)를 유지해야 합니다. 각 딕셔너리 엔트리에 버전을 추가하면, 가드는 값에 대한 강력한 참조를 피하기 위해 엔트리 버전 (단순한 정수)만 저장할 수 있습니다. 딕셔너리와 키에 대한 강력한 참조만 필요합니다.\u003c/p\u003e\n\u003cp\u003e변경 사항: \u003ccode\u003ePyDictKeyEntry\u003c/code\u003e 구조체에 \u003ccode\u003eme_version_tag\u003c/code\u003e 필드를 추가합니다. 이 필드는 C 타입 \u003ccode\u003ePY_UINT64_T\u003c/code\u003e를 가집니다. 키가 생성되거나 수정될 때, 엔트리 버전은 모든 변경 (생성, 수정, 삭제) 시 증가하는 딕셔너리 버전으로 설정됩니다.\u003c/p\u003e\n\u003cp\u003e가상의 \u003ccode\u003edict_get_version(dict)\u003c/code\u003e 및 \u003ccode\u003edict_get_entry_version(dict)\u003c/code\u003e 함수를 사용하여 딕셔너리 키가 수정되었는지 확인하는 빠른 가드의 의사 코드는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eUNSET = object()\n\nclass GuardDictKey:\n    def __init__(self, dict, key):\n        self.dict = dict\n        self.key = key\n        self.dict_version = dict_get_version(dict)\n        self.entry_version = dict_get_entry_version(dict, key)\n\n    def check(self):\n        \"\"\"딕셔너리 엔트리가 변경되지 않았고 딕셔너리가 교체되지 않았다면 True를 반환합니다.\"\"\"\n        # 딕셔너리의 버전을 읽습니다.\n        dict_version = dict_get_version(self.dict)\n        if dict_version == self.version: # 여기서 self.version 대신 self.dict_version이어야 할 것으로 보입니다 (원문 오류).\n            # 빠른 경로(Fast-path): 딕셔너리 조회 생략\n            return True\n\n        # 엔트리 버전을 읽기 위해 딕셔너리에서 조회합니다.\n        entry_version = get_dict_key_version(dict, key) # 여기서 get_dict_key_version 대신 dict_get_entry_version이어야 할 것으로 보입니다 (원문 오류).\n        if entry_version == self.entry_version:\n            # 다른 키가 수정되었습니다:\n            # 새 딕셔너리 버전을 캐시합니다.\n            self.dict_version = dict_version\n            self.entry_version = entry_version\n            return True\n\n        # 키가 수정되었습니다.\n        return False\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 옵션의 주요 단점은 메모리 사용량에 미치는 영향입니다. 이는 각 딕셔너리 엔트리의 크기를 증가시키므로, 오버헤드는 버킷(사용되든 안 되든 딕셔너리 엔트리)의 수에 따라 달라집니다. 예를 들어, 64비트 시스템에서는 각 딕셔너리 엔트리의 크기를 8바이트 증가시킵니다.\u003c/p\u003e\n\u003cp\u003ePython에서는 메모리 사용량이 중요하며, 이를 줄이는 추세입니다. 예시:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePEP 393 – Flexible String Representation\u003c/li\u003e\n\u003cli\u003ePEP 412 – Key-Sharing Dictionary\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e새로운 \u003ccode\u003edict\u003c/code\u003e 하위 타입 추가 (Add a new dict subtype)\u003c/h3\u003e\n\u003cp\u003e새로운 \u003ccode\u003everdict\u003c/code\u003e 타입을 \u003ccode\u003edict\u003c/code\u003e의 하위 타입으로 추가하는 것을 제안합니다. 가드가 필요할 때, \u003ccode\u003edict\u003c/code\u003e 대신 네임스페이스 (모듈 네임스페이스, 타입 네임스페이스, 인스턴스 네임스페이스 등)에 \u003ccode\u003everdict\u003c/code\u003e를 사용합니다.\u003c/p\u003e\n\u003cp\u003e가드가 사용되지 않을 때 오버헤드 (CPU, 메모리 사용량)를 추가하지 않도록 \u003ccode\u003edict\u003c/code\u003e 타입은 변경하지 않고 둡니다.\u003c/p\u003e\n\u003cp\u003e기술적인 문제: CPython 코어를 포함하여 야생(wild)에는 정확한 \u003ccode\u003edict\u003c/code\u003e 타입을 예상하는 많은 C 코드가 있습니다. 문제점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eexec()\u003c/code\u003e는 \u003ccode\u003eglobals\u003c/code\u003e 및 \u003ccode\u003elocals\u003c/code\u003e에 \u003ccode\u003edict\u003c/code\u003e를 필요로 합니다. 많은 코드가 \u003ccode\u003eglobals={}\u003c/code\u003e를 사용합니다. 호출자가 \u003ccode\u003eglobals\u003c/code\u003e 매개변수가 수정될 것으로 예상하기 때문에 \u003ccode\u003edict\u003c/code\u003e를 \u003ccode\u003edict\u003c/code\u003e 하위 타입으로 캐스팅하는 것은 불가능합니다 (\u003ccode\u003edict\u003c/code\u003e는 가변(mutable)입니다).\u003c/li\u003e\n\u003cli\u003eC 함수는 객체가 \u003ccode\u003edict\u003c/code\u003e 하위 타입인 경우 \u003ccode\u003ePyObject_xxx()\u003c/code\u003e 함수를 호출하는 대신 \u003ccode\u003ePyDict_xxx()\u003c/code\u003e 함수를 직접 호출합니다.\u003c/li\u003e\n\u003cli\u003e일부 함수가 정확한 \u003ccode\u003edict\u003c/code\u003e 타입을 요구하는 반면, \u003ccode\u003ePyDict_CheckExact()\u003c/code\u003e 검사는 \u003ccode\u003edict\u003c/code\u003e 하위 타입에서 실패합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/ceval.c\u003c/code\u003e는 네임스페이스에 대한 \u003ccode\u003edict\u003c/code\u003e 하위 타입을 완전히 지원하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eexec()\u003c/code\u003e 문제는 블로커(blocker) 문제입니다.\u003c/p\u003e\n\u003cp\u003e다른 문제점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e가비지 컬렉터(garbage collector)는 \u003ccode\u003edict\u003c/code\u003e 인스턴스의 \"untrack\"를 위한 특별한 코드를 가지고 있습니다. \u003ccode\u003edict\u003c/code\u003e 하위 타입이 네임스페이스에 사용되면 가비지 컬렉터가 일부 참조 순환(reference cycles)을 끊지 못할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e일부 함수에는 \u003ccode\u003edict\u003c/code\u003e에 대한 빠른 경로(fast-path)가 있으며, 이는 \u003ccode\u003edict\u003c/code\u003e 하위 타입에서는 사용되지 않으므로 Python을 약간 느리게 만들 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e선행 연구 (Prior Art)\u003c/h2\u003e\n\u003ch3\u003e메서드 캐시 및 타입 버전 태그 (Method cache and type version tag)\u003c/h3\u003e\n\u003cp\u003e2007년에 Armin Rigo는 메서드 캐시를 구현하는 패치를 작성했습니다. 이는 Python 2.6에 병합되었습니다. 이 패치는 \"타입 속성 캐시 버전 태그\"(\u003ccode\u003etp_version_tag\u003c/code\u003e)와 타입에 \"유효한 버전 태그\" 플래그 (\u003ccode\u003ePyTypeObject\u003c/code\u003e 구조체)를 추가합니다.\u003c/p\u003e\n\u003cp\u003e타입 버전 태그는 Python 레벨에 노출되지 않습니다.\u003c/p\u003e\n\u003cp\u003e버전 태그는 C 타입 \u003ccode\u003eunsigned int\u003c/code\u003e를 가집니다. 캐시는 모든 타입이 공유하는 4096개의 엔트리로 구성된 전역 해시 테이블입니다. 캐시는 \"빠르게 만들고, 확정적이며 낮은 메모리 사용량을 가지며, 무효화하기 쉽도록\" 전역적입니다. 각 캐시 엔트리는 버전 태그를 가집니다. 전역 버전 태그는 다음 버전 태그를 생성하는 데 사용되며, 이 역시 C 타입 \u003ccode\u003eunsigned int\u003c/code\u003e를 가집니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 타입은 버전 태그가 유효하지 않음을 나타내기 위해 \"유효한 버전 태그\" 플래그가 지워집니다. 타입의 첫 번째 메서드가 캐시될 때, 버전 태그와 \"유효한 버전 태그\" 플래그가 설정됩니다. 타입이 수정되면, 해당 타입과 그 서브클래스의 \"유효한 버전 태그\" 플래그가 지워집니다. 나중에 이러한 타입의 캐시 엔트리가 사용될 때, 해당 엔트리는 버전 태그가 오래되었기 때문에 제거됩니다.\u003c/p\u003e\n\u003cp\u003e정수 오버플로우 시 전체 캐시가 지워지고 전역 버전 태그는 0으로 재설정됩니다.\u003c/p\u003e\n\u003cp\u003e메서드 캐시 (\u003ca href=\"https://bugs.python.org/issue1685986\"\u003eissue #1685986\u003c/a\u003e) 및 Python 2.6용으로 업데이트된 Armin의 메서드 캐시 최적화 (\u003ca href=\"https://bugs.python.org/issue1700288\"\u003eissue #1700288\u003c/a\u003e)를 참조하세요.\u003c/p\u003e\n\u003ch3\u003eGlobals / builtins 캐시 (Globals / builtins cache)\u003c/h3\u003e\n\u003cp\u003e2010년에 Antoine Pitrou는 \u003ccode\u003ePyDictObject\u003c/code\u003e 구조체 (\u003ccode\u003edict\u003c/code\u003e 타입)에 private \u003ccode\u003ema_version\u003c/code\u003e 필드를 추가하는 Globals / builtins 캐시 (\u003ca href=\"https://bugs.python.org/issue10401\"\u003eissue #10401\u003c/a\u003e)를 제안했습니다. 이 필드는 C 타입 \u003ccode\u003ePy_ssize_t\u003c/code\u003e를 가집니다.\u003c/p\u003e\n\u003cp\u003e이 패치는 함수와 프레임에 \"전역 및 내장 캐시\"를 추가하고, \u003ccode\u003eLOAD_GLOBAL\u003c/code\u003e 및 \u003ccode\u003eSTORE_GLOBAL\u003c/code\u003e 명령어를 캐시를 사용하도록 변경합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyDictObject\u003c/code\u003e 구조체에 대한 변경 사항은 이 PEP와 매우 유사합니다.\u003c/p\u003e\n\u003ch3\u003eCached globals+builtins lookup (캐시된 전역+내장 조회)\u003c/h3\u003e\n\u003cp\u003e2006년에 Andrea Griffini는 Cached globals+builtins lookup 최적화를 구현하는 패치를 제안했습니다. 이 패치는 \u003ccode\u003ePyDictObject\u003c/code\u003e 구조체 (\u003ccode\u003edict\u003c/code\u003e 타입)에 private \u003ccode\u003etimestamp\u003c/code\u003e 필드를 추가하며, 이 필드는 C 타입 \u003ccode\u003esize_t\u003c/code\u003e를 가집니다.\u003c/p\u003e\n\u003cp\u003epython-dev 메일링 리스트의 토론: \u003ca href=\"https://mail.python.org/pipermail/python-dev/2006-December/070285.html\"\u003eAbout dictionary lookup caching (December 2006)\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eGuard against changing dict during iteration (반복 중 딕셔너리 변경 방지)\u003c/h3\u003e\n\u003cp\u003e2013년에 Serhiy Storchaka는 반복 중 딕셔너리 변경 방지 (\u003ca href=\"https://bugs.python.org/issue19332\"\u003eissue #19332\u003c/a\u003e)를 제안했습니다. 이는 \u003ccode\u003ePyDictObject\u003c/code\u003e 구조체 (\u003ccode\u003edict\u003c/code\u003e 타입)에 \u003ccode\u003ema_count\u003c/code\u003e 필드를 추가하며, 이 필드는 C 타입 \u003ccode\u003esize_t\u003c/code\u003e를 가집니다. 이 필드는 딕셔너리가 수정될 때마다 증가합니다.\u003c/p\u003e\n\u003ch3\u003ePySizer\u003c/h3\u003e\n\u003cp\u003ePySizer: Python용 메모리 프로파일러, Nick Smallbone의 Google Summer of Code 2005 프로젝트.\u003c/p\u003e\n\u003cp\u003e이 프로젝트는 CPython 2.4용 패치를 가지고 있으며, 딕셔너리 엔트리에 \u003ccode\u003ekey_time\u003c/code\u003e 및 \u003ccode\u003evalue_time\u003c/code\u003e 필드를 추가합니다. 이는 딕셔너리용 전역 프로세스 전체 카운터를 사용하며, 딕셔너리가 수정될 때마다 증가합니다. 이 시간은 자식 객체가 부모 객체에 처음 나타난 시기를 결정하는 데 사용됩니다.\u003c/p\u003e\n\u003ch2\u003e논의 (Discussion)\u003c/h2\u003e\n\u003cp\u003e메일링 리스트 토론 스레드.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://mail.python.org/pipermail/python-dev/2016-April/144062.html\"\u003epython-dev: Updated PEP 509\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://mail.python.org/pipermail/python-dev/2016-April/143926.html\"\u003epython-dev: RFC: PEP 509: Add a private version to dict\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://mail.python.org/pipermail/python-dev/2016-January/142999.html\"\u003epython-dev: PEP 509: Add a private version to dict (January 2016)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://mail.python.org/pipermail/python-ideas/2016-January/037746.html\"\u003epython-ideas: RFC: PEP: Add dict.\u003cstrong\u003eversion\u003c/strong\u003e (January 2016)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e수락 (Acceptance)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 2016년 9월 7일 Guido van Rossum에 의해 수락되었습니다. 이 PEP의 구현은 이후 저장소에 커밋되었습니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 공용 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2353,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Superseded] PEP 509 - Add a private version to dict\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:55:06+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/509/\",\"postId\":\"2025-09-26-pep-0509-add-a-private-version-to-dict\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/508/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 508 - Dependency specification for Python Software Packages\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Superseded] PEP 509 - Add a private version to dict\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/510/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 510 - Specialize functions with guards\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>