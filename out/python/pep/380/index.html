<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 380 - Syntax for Delegating to a Subgenerator</h1><div class="page__meta"><time dateTime="2025-09-26 21:02:19+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0380/">PEP 380 - Syntax for Delegating to a Subgenerator</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 13-Feb-2009</p>
</blockquote>
<h1>PEP 380 – 서브제너레이터 위임 문법 (Syntax for Delegating to a Subgenerator)</h1>
<ul>
<li><strong>작성자:</strong> Gregory Ewing</li>
<li><strong>상태:</strong> 최종 (Final)</li>
<li><strong>유형:</strong> 표준 트랙 (Standards Track)</li>
<li><strong>생성일:</strong> 2009년 2월 13일</li>
<li><strong>Python 버전:</strong> 3.3</li>
<li><strong>해결:</strong> Python-Dev 메시지</li>
</ul>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 제너레이터가 자신의 작업 일부를 다른 제너레이터에게 위임(delegate)할 수 있는 새로운 문법을 제안합니다. 이 문법을 통해 <code>yield</code>를 포함하는 코드 섹션을 별도의 제너레이터로 분리(factor out)하여 재사용할 수 있게 됩니다. 또한, 서브제너레이터는 값을 가지고 <code>return</code>할 수 있으며, 이 반환 값은 위임하는 제너레이터(delegating generator)에게 제공됩니다.</p>
<p>새로운 문법은 한 제너레이터가 다른 제너레이터가 생성한 값을 재-yield할 때 최적화할 수 있는 기회도 제공합니다.</p>
<h2>PEP 승인 (PEP Acceptance)</h2>
<p>Guido van Rossum은 2011년 6월 26일에 이 PEP를 공식적으로 승인했습니다.</p>
<h2>동기 (Motivation)</h2>
<p>Python의 제너레이터는 코루틴(coroutine)의 한 형태이지만, 즉각적인 호출자(immediate caller)에게만 <code>yield</code>할 수 있다는 한계가 있었습니다. 이는 <code>yield</code>를 포함하는 코드 조각을 다른 코드처럼 별도의 함수로 분리할 수 없다는 것을 의미합니다. 이러한 분리를 시도하면 호출된 함수 자체가 제너레이터가 되고, 이 두 번째 제너레이터를 명시적으로 순회(iterate)하며 생성되는 모든 값을 재-yield해야 합니다.</p>
<p>단순히 값을 yield하는 것만 고려한다면, 다음과 같은 루프를 사용하여 큰 어려움 없이 수행할 수 있습니다.</p>
<pre><code class="language-python">for v in g:
    yield v
</code></pre>
<p>그러나 서브제너레이터가 <code>send()</code>, <code>throw()</code>, <code>close()</code> 호출의 경우 호출자와 제대로 상호작용하려면 상황이 훨씬 복잡해집니다. 아래에서 보겠지만, 필요한 코드는 매우 복잡하며 모든 엣지 케이스를 올바르게 처리하기 어렵습니다.</p>
<p>이 문제를 해결하기 위해 새로운 문법이 제안됩니다. 가장 간단한 사용 사례에서는 위의 <code>for</code> 루프와 동일하지만, 제너레이터의 모든 동작 범위를 처리하고 제너레이터 코드를 간단하고 직관적인 방식으로 리팩토링할 수 있도록 합니다.</p>
<h2>제안 (Proposal)</h2>
<p>제너레이터의 본문에서 다음과 같은 새로운 표현식 문법이 허용됩니다.</p>
<pre><code class="language-python">yield from &#x3C;expr>
</code></pre>
<p>여기서 <code>&#x3C;expr></code>은 이터러블(iterable)로 평가되는 표현식이며, 이터러블에서 이터레이터(iterator)가 추출됩니다. 이 이터레이터는 소진될 때까지 실행되며, 이 시간 동안 <code>yield from</code> 표현식을 포함하는 제너레이터(즉, "위임하는 제너레이터")의 호출자에게 직접 값을 yield하고 받습니다.</p>
<p>또한, 이터레이터가 다른 제너레이터인 경우, 서브제너레이터는 값을 가지고 <code>return</code> 문을 실행할 수 있으며, 이 값은 <code>yield from</code> 표현식의 값이 됩니다.</p>
<p><code>yield from</code> 표현식의 전체 의미론은 제너레이터 프로토콜(generator protocol) 관점에서 다음과 같이 설명할 수 있습니다.</p>
<ul>
<li>이터레이터가 yield하는 모든 값은 호출자에게 직접 전달됩니다.</li>
<li><code>send()</code>를 사용하여 위임하는 제너레이터로 보내진 모든 값은 이터레이터에게 직접 전달됩니다.
<ul>
<li>보내진 값이 <code>None</code>이면 이터레이터의 <code>__next__()</code> 메서드가 호출됩니다.</li>
<li>보내진 값이 <code>None</code>이 아니면 이터레이터의 <code>send()</code> 메서드가 호출됩니다.</li>
<li>호출이 <code>StopIteration</code>을 발생시키면 위임하는 제너레이터가 재개됩니다.</li>
<li>다른 예외는 위임하는 제너레이터로 전파됩니다.</li>
</ul>
</li>
<li><code>GeneratorExit</code> 외의 예외가 위임하는 제너레이터로 <code>throw</code>되면, 이터레이터의 <code>throw()</code> 메서드로 전달됩니다.
<ul>
<li>호출이 <code>StopIteration</code>을 발생시키면 위임하는 제너레이터가 재개됩니다.</li>
<li>다른 예외는 위임하는 제너레이터로 전파됩니다.</li>
</ul>
</li>
<li><code>GeneratorExit</code> 예외가 위임하는 제너레이터로 <code>throw</code>되거나, 위임하는 제너레이터의 <code>close()</code> 메서드가 호출되면, 이터레이터에 <code>close()</code> 메서드가 있는 경우 이터레이터의 <code>close()</code> 메서드가 호출됩니다.
<ul>
<li>이 호출이 예외를 발생시키면, 위임하는 제너레이터로 전파됩니다.</li>
<li>그렇지 않으면 <code>GeneratorExit</code>가 위임하는 제너레이터에서 발생합니다.</li>
</ul>
</li>
<li><code>yield from</code> 표현식의 값은 이터레이터가 종료될 때 발생하는 <code>StopIteration</code> 예외의 첫 번째 인자입니다.</li>
<li>제너레이터에서 <code>return expr</code>은 제너레이터 종료 시 <code>StopIteration(expr)</code>이 발생하도록 합니다.</li>
</ul>
<h3>StopIteration 개선 사항 (Enhancements to StopIteration)</h3>
<p>편의를 위해 <code>StopIteration</code> 예외에는 첫 번째 인자를 담는 <code>value</code> 속성이 부여됩니다. 인자가 없으면 <code>None</code>이 됩니다.</p>
<h3>형식 의미론 (Formal Semantics)</h3>
<p>이 섹션에서는 Python 3 문법이 사용됩니다.</p>
<pre><code class="language-python">RESULT = yield from EXPR
</code></pre>
<p>문은 의미론적으로 다음과 동등합니다.</p>
<pre><code class="language-python">_i = iter(EXPR)
try:
    _y = next(_i)
except StopIteration as _e:
    _r = _e.value
else:
    while 1:
        try:
            _s = yield _y
        except GeneratorExit as _e:
            try:
                _m = _i.close
            except AttributeError:
                pass
            else:
                _m()
            raise _e
        except BaseException as _e:
            _x = sys.exc_info()
            try:
                _m = _i.throw
            except AttributeError:
                raise _e
            else:
                try:
                    _y = _m(*_x)
                except StopIteration as _e:
                    _r = _e.value
                    break
        else:
            try:
                if _s is None:
                    _y = next(_i)
                else:
                    _y = _i.send(_s)
            except StopIteration as _e:
                _r = _e.value
                break
    RESULT = _r
</code></pre>
<p>제너레이터에서 <code>return value</code> 문은 의미론적으로 다음과 동등합니다.</p>
<pre><code class="language-python">raise StopIteration(value)
</code></pre>
<p>다만, 현재와 마찬가지로 이 예외는 반환하는 제너레이터 내의 <code>except</code> 절에 의해 포착될 수 없습니다.</p>
<p><code>StopIteration</code> 예외는 다음과 같이 정의된 것처럼 동작합니다.</p>
<pre><code class="language-python">class StopIteration(Exception):
    def __init__(self, *args):
        if len(args) > 0:
            self.value = args[0]
        else:
            self.value = None
        Exception.__init__(self, *args)
</code></pre>
<h2>근거 (Rationale)</h2>
<h3>리팩토링 원칙 (The Refactoring Principle)</h3>
<p>위에 제시된 의미론의 대부분은 제너레이터 코드를 리팩토링할 수 있도록 하려는 염원에서 비롯됩니다. 하나 이상의 <code>yield</code> 표현식을 포함하는 코드 섹션을 가져와 별도의 함수로 이동하고(주변 스코프의 변수 참조를 처리하는 일반적인 기술 등을 사용하여), <code>yield from</code> 표현식을 사용하여 새 함수를 호출할 수 있어야 합니다.</p>
<p>결과적으로 생성된 복합 제너레이터의 동작은 <code>__next__()</code>, <code>send()</code>, <code>throw()</code>, <code>close()</code> 호출을 포함한 모든 상황에서 합리적으로 가능한 한 원래의 리팩토링되지 않은 제너레이터와 동일해야 합니다.</p>
<p>제너레이터 이외의 서브이터레이터(subiterator)의 경우 의미론은 제너레이터 케이스의 합리적인 일반화로 선택되었습니다.</p>
<p>제안된 의미론은 리팩토링과 관련하여 다음과 같은 제약이 있습니다.</p>
<ul>
<li><code>GeneratorExit</code>를 포착하고 나중에 다시 발생시키지 않는 코드 블록은 정확히 동일한 동작을 유지하면서 분리될 수 없습니다.</li>
<li><code>StopIteration</code> 예외가 위임하는 제너레이터로 <code>throw</code>되는 경우, 분리된 코드가 분리되지 않은 코드와 다르게 동작할 수 있습니다.</li>
</ul>
<p>이러한 사용 사례는 거의 없거나 존재하지 않으므로, 이를 지원하는 데 필요한 추가적인 복잡성을 감수할 가치가 없다고 판단되었습니다.</p>
<h3>종료 처리 (Finalization)</h3>
<p><code>yield from</code>에서 일시 중단된 위임하는 제너레이터를 <code>close()</code> 메서드를 호출하여 명시적으로 종료할 때 서브이터레이터도 종료해야 하는지에 대한 논쟁이 있었습니다. 그렇게 하는 것에 반대하는 주장은 다른 곳에 서브이터레이터에 대한 참조가 존재할 경우 서브이터레이터가 조기에 종료될 수 있다는 것이었습니다.</p>
<p>비-참조 카운팅(non-refcounting) Python 구현을 고려한 결과, 이 명시적 종료를 수행해야 한다는 결정이 내려졌습니다. 이는 분리된 제너레이터를 명시적으로 닫는 것이 모든 Python 구현에서 분리되지 않은 제너레이터를 닫는 것과 동일한 효과를 갖도록 하기 위함입니다.</p>
<p>대부분의 사용 사례에서 서브이터레이터는 공유되지 않을 것이라는 가정이 있습니다. 공유된 서브이터레이터의 드문 경우는 <code>throw()</code> 및 <code>close()</code> 호출을 차단하는 래퍼(wrapper)를 사용하거나, <code>yield from</code>이 아닌 다른 수단을 사용하여 서브이터레이터를 호출함으로써 해결할 수 있습니다.</p>
<h3>스레드로서의 제너레이터 (Generators as Threads)</h3>
<p>제너레이터가 값을 반환할 수 있도록 하는 동기는 경량 스레드(lightweight threads)를 구현하기 위해 제너레이터를 사용하는 것과 관련이 있습니다. 그런 방식으로 제너레이터를 사용할 때, 경량 스레드에 의해 수행되는 계산을 여러 함수에 분산시키기를 원하는 것은 합리적입니다. 서브제너레이터를 일반 함수처럼 호출하여 매개변수를 전달하고 반환 값을 받을 수 있기를 바랍니다.</p>
<p>제안된 문법을 사용하면, 일반 함수 <code>f</code>에 대한 <code>y = f(x)</code>와 같은 문을 위임 호출 <code>y = yield from g(x)</code>로 변환할 수 있습니다. 여기서 <code>g</code>는 제너레이터입니다. <code>g</code>를 <code>yield</code> 문을 사용하여 일시 중단될 수 있는 일반 함수로 생각함으로써 결과 코드의 동작을 추론할 수 있습니다.</p>
<p>이러한 방식으로 제너레이터를 스레드로 사용할 때, 일반적으로 <code>yield</code>를 통해 전달되거나 나가는 값에는 관심이 없습니다. 그러나 스레드가 항목의 생산자 또는 소비자로 간주되는 사용 사례도 있습니다. <code>yield from</code> 표현식을 사용하면 스레드의 로직을 원하는 만큼 많은 함수에 분산시킬 수 있으며, 항목의 생산 또는 소비는 어떤 하위 함수에서든 발생하고, 해당 항목은 궁극적인 원본 또는 대상으로 자동으로 라우팅됩니다.</p>
<p><code>throw()</code> 및 <code>close()</code>와 관련하여, 외부에서 스레드로 예외가 <code>throw</code>되면 가장 안쪽의 제너레이터(스레드가 일시 중단된 곳)에서 먼저 발생해야 하고 거기서부터 바깥쪽으로 전파되어야 하며, <code>close()</code>를 호출하여 외부에서 스레드가 종료되면 활성 제너레이터의 체인이 가장 안쪽에서부터 바깥쪽으로 종료되어야 한다는 것은 합리적인 기대입니다.</p>
<h3>문법 (Syntax)</h3>
<p>제안된 특정 문법은 의미를 암시하는 동시에 새로운 키워드를 도입하지 않고 일반 <code>yield</code>와는 다른 점이 분명하게 드러나도록 선택되었습니다.</p>
<h3>최적화 (Optimisations)</h3>
<p>특수화된 문법을 사용하면 제너레이터 체인이 길어질 때 최적화 가능성이 열립니다. 이러한 체인은 예를 들어, 트리 구조를 재귀적으로 순회할 때 발생할 수 있습니다. <code>__next__()</code> 호출 및 yield된 값을 체인 아래로, 위로 전달하는 오버헤드는 최악의 경우 O(n) 연산을 O(n**2)로 만들 수 있습니다.</p>
<p>가능한 전략은 제너레이터 객체에 위임될 제너레이터를 담는 슬롯을 추가하는 것입니다. 제너레이터에서 <code>__next__()</code> 또는 <code>send()</code> 호출이 이루어지면, 이 슬롯을 먼저 확인하고 비어 있지 않으면 참조하는 제너레이터가 대신 재개됩니다. <code>StopIteration</code>이 발생하면 슬롯이 지워지고 주 제너레이터가 재개됩니다.</p>
<p>이는 위임 오버헤드를 Python 코드 실행 없이 C 함수 호출 체인으로 줄일 수 있습니다. 가능한 개선 사항은 루프에서 전체 제너레이터 체인을 순회하고 끝에 있는 제너레이터를 직접 재개하는 것이지만, 이때 <code>StopIteration</code> 처리가 더 복잡해집니다.</p>
<h3>StopIteration을 이용한 값 반환 (Use of StopIteration to return values)</h3>
<p>제너레이터의 반환 값을 되돌려줄 수 있는 다양한 방법이 있습니다. 일부 대안으로는 제너레이터-이터레이터 객체의 속성으로 저장하거나, 서브제너레이터에 대한 <code>close()</code> 호출의 값으로 반환하는 것이 포함됩니다. 그러나 제안된 메커니즘은 몇 가지 이유로 매력적입니다.</p>
<ul>
<li><code>StopIteration</code> 예외의 일반화를 사용하면 다른 종류의 이터레이터가 추가 속성이나 <code>close()</code> 메서드를 추가할 필요 없이 프로토콜에 참여하기 쉽습니다.</li>
<li>서브제너레이터에서 반환 값이 사용 가능해지는 시점이 예외가 발생하는 시점과 동일하기 때문에 구현이 간단해집니다. 나중에 지연하면 반환 값을 어딘가에 저장해야 합니다.</li>
</ul>
<h2>거부된 아이디어 (Rejected Ideas)</h2>
<p>일부 아이디어는 논의되었으나 거부되었습니다.</p>
<ul>
<li>
<p><strong>제안:</strong> <code>__next__()</code>에 대한 초기 호출을 방지하거나 지정된 값으로 <code>send()</code> 호출로 대체하는 방법이 있어야 하며, 이는 초기 <code>__next__()</code>가 자동으로 수행되도록 래핑된 제너레이터 사용을 지원하려는 의도였습니다.</p>
<ul>
<li><strong>해결:</strong> 이 제안의 범위를 벗어납니다. 이러한 제너레이터는 <code>yield from</code>과 함께 사용되어서는 안 됩니다.</li>
</ul>
</li>
<li>
<p><strong>제안:</strong> 서브이터레이터를 닫는 것이 값을 가진 <code>StopIteration</code>을 발생시키면, 위임하는 제너레이터에 대한 <code>close()</code> 호출에서 해당 값을 반환합니다.</p>
<ul>
<li>이 기능의 동기는 제너레이터로 보내지는 값 스트림의 끝을 제너레이터를 닫음으로써 알릴 수 있도록 하기 위함입니다. 제너레이터는 <code>GeneratorExit</code>를 포착하고, 계산을 완료하며, 결과를 반환하고, 이 결과는 <code>close()</code> 호출의 반환 값이 됩니다.</li>
<li><strong>해결:</strong> <code>close()</code> 및 <code>GeneratorExit</code>의 이러한 사용은 bail-out 및 정리 메커니즘으로서의 현재 역할과 호환되지 않습니다. 이는 위임하는 제너레이터를 닫을 때, 서브제너레이터가 닫힌 후 <code>GeneratorExit</code>를 다시 발생시키는 대신 위임하는 제너레이터가 재개되어야 함을 요구합니다. 그러나 이는 허용될 수 없습니다. 왜냐하면 <code>close()</code>가 정리 목적으로 호출되는 경우 위임하는 제너레이터가 제대로 종료되도록 보장하지 못할 것이기 때문입니다.</li>
<li>소비자에게 값의 끝을 알리는 것은 센티넬(sentinel) 값 전송 또는 생산자와 소비자 간에 합의된 예외 발생과 같은 다른 수단으로 더 잘 다루어집니다. 그러면 소비자는 센티넬 또는 예외를 감지하고 계산을 완료하고 정상적으로 반환함으로써 응답할 수 있습니다. 이러한 방식은 위임(delegation)이 있을 때 올바르게 동작합니다.</li>
</ul>
</li>
<li>
<p><strong>제안:</strong> <code>close()</code>가 값을 반환하지 않는 경우, <code>None</code>이 아닌 값을 가진 <code>StopIteration</code>이 발생하면 예외를 발생시킵니다.</p>
<ul>
<li><strong>해결:</strong> 그렇게 할 명확한 이유가 없습니다. 반환 값을 무시하는 것은 Python의 다른 곳에서는 오류로 간주되지 않습니다.</li>
</ul>
</li>
</ul>
<h2>비판 (Criticisms)</h2>
<p>이 제안에 따르면, <code>yield from</code> 표현식의 값은 일반 <code>yield</code> 표현식의 값과는 매우 다른 방식으로 파생됩니다. 이는 <code>yield</code>라는 단어를 포함하지 않는 다른 문법이 더 적절할 수 있음을 시사하지만, 아직까지 수용 가능한 대안은 제안되지 않았습니다. 거부된 대안으로는 <code>call</code>, <code>delegate</code>, <code>gcall</code> 등이 있습니다.</p>
<p>서브제너레이터에서 <code>return</code> 이외의 다른 메커니즘을 사용하여 <code>yield from</code> 표현식으로 반환되는 값을 설정해야 한다는 제안이 있었습니다. 그러나 이는 서브제너레이터를 일시 중단 가능한 함수로 생각할 수 있다는 목표에 방해가 될 것입니다. 왜냐하면 다른 함수와 동일한 방식으로 값을 반환할 수 없기 때문입니다.</p>
<p>반환 값을 전달하기 위해 예외를 사용하는 것은 "예외 남용"으로 비판받았지만, 이 주장에 대한 구체적인 정당화는 없었습니다. 어쨌든, 이것은 단지 제안된 구현 중 하나일 뿐입니다. 제안의 본질적인 기능을 잃지 않고 다른 메커니즘을 사용할 수도 있습니다.</p>
<p>값을 반환하기 위해 <code>StopIteration</code> 대신 <code>GeneratorReturn</code>과 같은 다른 예외를 사용해야 한다는 제안도 있었습니다. 그러나 이에 대한 설득력 있는 실제적인 이유는 제시되지 않았으며, <code>StopIteration</code>에 <code>value</code> 속성을 추가한 것이 반환 값을 추출하는 데 발생할 수 있는 모든 어려움을 완화합니다. 또한, 다른 예외를 사용하면 일반 함수와 달리 제너레이터에서 값을 갖지 않는 <code>return</code>이 <code>return None</code>과 동등하지 않게 될 것입니다.</p>
<h2>대안 제안 (Alternative Proposals)</h2>
<p>이와 유사한 제안은 이전에도 있었으며, 일부는 <code>yield from</code> 대신 <code>yield *</code> 문법을 사용했습니다. <code>yield *</code>는 더 간결하지만, 일반 <code>yield</code>와 너무 비슷해 보이고 코드를 읽을 때 차이점을 간과할 수 있다는 주장이 있었습니다.</p>
<p>작성자의 지식으로는 이전 제안들은 값 yield에만 초점을 맞추었으며, 따라서 그들이 대체하는 두 줄짜리 <code>for</code> 루프가 새로운 문법을 정당화할 만큼 충분히 번거롭지 않다는 비판을 받았습니다. 이 제안은 전체 제너레이터 프로토콜을 다룸으로써 훨씬 더 많은 이점을 제공합니다.</p>
<h2>추가 자료 (Additional Material)</h2>
<p>제안된 문법 사용 예시와 위에 설명된 첫 번째 최적화를 기반으로 한 프로토타입 구현이 제공됩니다.</p>
<ul>
<li><strong>예시 및 구현:</strong> Python 3.3용으로 업데이트된 구현 버전은 <a href="https://bugs.python.org/issue11682">트래커 이슈 #11682</a>에서 확인할 수 있습니다.</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.</p>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/380\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/380/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/380\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"380\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/380\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T555d,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0380/\"\u003ePEP 380 - Syntax for Delegating to a Subgenerator\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 13-Feb-2009\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 380 – 서브제너레이터 위임 문법 (Syntax for Delegating to a Subgenerator)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Gregory Ewing\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 최종 (Final)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e 표준 트랙 (Standards Track)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2009년 2월 13일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.3\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e해결:\u003c/strong\u003e Python-Dev 메시지\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 제너레이터가 자신의 작업 일부를 다른 제너레이터에게 위임(delegate)할 수 있는 새로운 문법을 제안합니다. 이 문법을 통해 \u003ccode\u003eyield\u003c/code\u003e를 포함하는 코드 섹션을 별도의 제너레이터로 분리(factor out)하여 재사용할 수 있게 됩니다. 또한, 서브제너레이터는 값을 가지고 \u003ccode\u003ereturn\u003c/code\u003e할 수 있으며, 이 반환 값은 위임하는 제너레이터(delegating generator)에게 제공됩니다.\u003c/p\u003e\n\u003cp\u003e새로운 문법은 한 제너레이터가 다른 제너레이터가 생성한 값을 재-yield할 때 최적화할 수 있는 기회도 제공합니다.\u003c/p\u003e\n\u003ch2\u003ePEP 승인 (PEP Acceptance)\u003c/h2\u003e\n\u003cp\u003eGuido van Rossum은 2011년 6월 26일에 이 PEP를 공식적으로 승인했습니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003ePython의 제너레이터는 코루틴(coroutine)의 한 형태이지만, 즉각적인 호출자(immediate caller)에게만 \u003ccode\u003eyield\u003c/code\u003e할 수 있다는 한계가 있었습니다. 이는 \u003ccode\u003eyield\u003c/code\u003e를 포함하는 코드 조각을 다른 코드처럼 별도의 함수로 분리할 수 없다는 것을 의미합니다. 이러한 분리를 시도하면 호출된 함수 자체가 제너레이터가 되고, 이 두 번째 제너레이터를 명시적으로 순회(iterate)하며 생성되는 모든 값을 재-yield해야 합니다.\u003c/p\u003e\n\u003cp\u003e단순히 값을 yield하는 것만 고려한다면, 다음과 같은 루프를 사용하여 큰 어려움 없이 수행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor v in g:\n    yield v\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 서브제너레이터가 \u003ccode\u003esend()\u003c/code\u003e, \u003ccode\u003ethrow()\u003c/code\u003e, \u003ccode\u003eclose()\u003c/code\u003e 호출의 경우 호출자와 제대로 상호작용하려면 상황이 훨씬 복잡해집니다. 아래에서 보겠지만, 필요한 코드는 매우 복잡하며 모든 엣지 케이스를 올바르게 처리하기 어렵습니다.\u003c/p\u003e\n\u003cp\u003e이 문제를 해결하기 위해 새로운 문법이 제안됩니다. 가장 간단한 사용 사례에서는 위의 \u003ccode\u003efor\u003c/code\u003e 루프와 동일하지만, 제너레이터의 모든 동작 범위를 처리하고 제너레이터 코드를 간단하고 직관적인 방식으로 리팩토링할 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003e제안 (Proposal)\u003c/h2\u003e\n\u003cp\u003e제너레이터의 본문에서 다음과 같은 새로운 표현식 문법이 허용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eyield from \u0026#x3C;expr\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003e\u0026#x3C;expr\u003e\u003c/code\u003e은 이터러블(iterable)로 평가되는 표현식이며, 이터러블에서 이터레이터(iterator)가 추출됩니다. 이 이터레이터는 소진될 때까지 실행되며, 이 시간 동안 \u003ccode\u003eyield from\u003c/code\u003e 표현식을 포함하는 제너레이터(즉, \"위임하는 제너레이터\")의 호출자에게 직접 값을 yield하고 받습니다.\u003c/p\u003e\n\u003cp\u003e또한, 이터레이터가 다른 제너레이터인 경우, 서브제너레이터는 값을 가지고 \u003ccode\u003ereturn\u003c/code\u003e 문을 실행할 수 있으며, 이 값은 \u003ccode\u003eyield from\u003c/code\u003e 표현식의 값이 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eyield from\u003c/code\u003e 표현식의 전체 의미론은 제너레이터 프로토콜(generator protocol) 관점에서 다음과 같이 설명할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이터레이터가 yield하는 모든 값은 호출자에게 직접 전달됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esend()\u003c/code\u003e를 사용하여 위임하는 제너레이터로 보내진 모든 값은 이터레이터에게 직접 전달됩니다.\n\u003cul\u003e\n\u003cli\u003e보내진 값이 \u003ccode\u003eNone\u003c/code\u003e이면 이터레이터의 \u003ccode\u003e__next__()\u003c/code\u003e 메서드가 호출됩니다.\u003c/li\u003e\n\u003cli\u003e보내진 값이 \u003ccode\u003eNone\u003c/code\u003e이 아니면 이터레이터의 \u003ccode\u003esend()\u003c/code\u003e 메서드가 호출됩니다.\u003c/li\u003e\n\u003cli\u003e호출이 \u003ccode\u003eStopIteration\u003c/code\u003e을 발생시키면 위임하는 제너레이터가 재개됩니다.\u003c/li\u003e\n\u003cli\u003e다른 예외는 위임하는 제너레이터로 전파됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGeneratorExit\u003c/code\u003e 외의 예외가 위임하는 제너레이터로 \u003ccode\u003ethrow\u003c/code\u003e되면, 이터레이터의 \u003ccode\u003ethrow()\u003c/code\u003e 메서드로 전달됩니다.\n\u003cul\u003e\n\u003cli\u003e호출이 \u003ccode\u003eStopIteration\u003c/code\u003e을 발생시키면 위임하는 제너레이터가 재개됩니다.\u003c/li\u003e\n\u003cli\u003e다른 예외는 위임하는 제너레이터로 전파됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGeneratorExit\u003c/code\u003e 예외가 위임하는 제너레이터로 \u003ccode\u003ethrow\u003c/code\u003e되거나, 위임하는 제너레이터의 \u003ccode\u003eclose()\u003c/code\u003e 메서드가 호출되면, 이터레이터에 \u003ccode\u003eclose()\u003c/code\u003e 메서드가 있는 경우 이터레이터의 \u003ccode\u003eclose()\u003c/code\u003e 메서드가 호출됩니다.\n\u003cul\u003e\n\u003cli\u003e이 호출이 예외를 발생시키면, 위임하는 제너레이터로 전파됩니다.\u003c/li\u003e\n\u003cli\u003e그렇지 않으면 \u003ccode\u003eGeneratorExit\u003c/code\u003e가 위임하는 제너레이터에서 발생합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eyield from\u003c/code\u003e 표현식의 값은 이터레이터가 종료될 때 발생하는 \u003ccode\u003eStopIteration\u003c/code\u003e 예외의 첫 번째 인자입니다.\u003c/li\u003e\n\u003cli\u003e제너레이터에서 \u003ccode\u003ereturn expr\u003c/code\u003e은 제너레이터 종료 시 \u003ccode\u003eStopIteration(expr)\u003c/code\u003e이 발생하도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStopIteration 개선 사항 (Enhancements to StopIteration)\u003c/h3\u003e\n\u003cp\u003e편의를 위해 \u003ccode\u003eStopIteration\u003c/code\u003e 예외에는 첫 번째 인자를 담는 \u003ccode\u003evalue\u003c/code\u003e 속성이 부여됩니다. 인자가 없으면 \u003ccode\u003eNone\u003c/code\u003e이 됩니다.\u003c/p\u003e\n\u003ch3\u003e형식 의미론 (Formal Semantics)\u003c/h3\u003e\n\u003cp\u003e이 섹션에서는 Python 3 문법이 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eRESULT = yield from EXPR\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e문은 의미론적으로 다음과 동등합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e_i = iter(EXPR)\ntry:\n    _y = next(_i)\nexcept StopIteration as _e:\n    _r = _e.value\nelse:\n    while 1:\n        try:\n            _s = yield _y\n        except GeneratorExit as _e:\n            try:\n                _m = _i.close\n            except AttributeError:\n                pass\n            else:\n                _m()\n            raise _e\n        except BaseException as _e:\n            _x = sys.exc_info()\n            try:\n                _m = _i.throw\n            except AttributeError:\n                raise _e\n            else:\n                try:\n                    _y = _m(*_x)\n                except StopIteration as _e:\n                    _r = _e.value\n                    break\n        else:\n            try:\n                if _s is None:\n                    _y = next(_i)\n                else:\n                    _y = _i.send(_s)\n            except StopIteration as _e:\n                _r = _e.value\n                break\n    RESULT = _r\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제너레이터에서 \u003ccode\u003ereturn value\u003c/code\u003e 문은 의미론적으로 다음과 동등합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eraise StopIteration(value)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다만, 현재와 마찬가지로 이 예외는 반환하는 제너레이터 내의 \u003ccode\u003eexcept\u003c/code\u003e 절에 의해 포착될 수 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eStopIteration\u003c/code\u003e 예외는 다음과 같이 정의된 것처럼 동작합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass StopIteration(Exception):\n    def __init__(self, *args):\n        if len(args) \u003e 0:\n            self.value = args[0]\n        else:\n            self.value = None\n        Exception.__init__(self, *args)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003ch3\u003e리팩토링 원칙 (The Refactoring Principle)\u003c/h3\u003e\n\u003cp\u003e위에 제시된 의미론의 대부분은 제너레이터 코드를 리팩토링할 수 있도록 하려는 염원에서 비롯됩니다. 하나 이상의 \u003ccode\u003eyield\u003c/code\u003e 표현식을 포함하는 코드 섹션을 가져와 별도의 함수로 이동하고(주변 스코프의 변수 참조를 처리하는 일반적인 기술 등을 사용하여), \u003ccode\u003eyield from\u003c/code\u003e 표현식을 사용하여 새 함수를 호출할 수 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e결과적으로 생성된 복합 제너레이터의 동작은 \u003ccode\u003e__next__()\u003c/code\u003e, \u003ccode\u003esend()\u003c/code\u003e, \u003ccode\u003ethrow()\u003c/code\u003e, \u003ccode\u003eclose()\u003c/code\u003e 호출을 포함한 모든 상황에서 합리적으로 가능한 한 원래의 리팩토링되지 않은 제너레이터와 동일해야 합니다.\u003c/p\u003e\n\u003cp\u003e제너레이터 이외의 서브이터레이터(subiterator)의 경우 의미론은 제너레이터 케이스의 합리적인 일반화로 선택되었습니다.\u003c/p\u003e\n\u003cp\u003e제안된 의미론은 리팩토링과 관련하여 다음과 같은 제약이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eGeneratorExit\u003c/code\u003e를 포착하고 나중에 다시 발생시키지 않는 코드 블록은 정확히 동일한 동작을 유지하면서 분리될 수 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eStopIteration\u003c/code\u003e 예외가 위임하는 제너레이터로 \u003ccode\u003ethrow\u003c/code\u003e되는 경우, 분리된 코드가 분리되지 않은 코드와 다르게 동작할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 사용 사례는 거의 없거나 존재하지 않으므로, 이를 지원하는 데 필요한 추가적인 복잡성을 감수할 가치가 없다고 판단되었습니다.\u003c/p\u003e\n\u003ch3\u003e종료 처리 (Finalization)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eyield from\u003c/code\u003e에서 일시 중단된 위임하는 제너레이터를 \u003ccode\u003eclose()\u003c/code\u003e 메서드를 호출하여 명시적으로 종료할 때 서브이터레이터도 종료해야 하는지에 대한 논쟁이 있었습니다. 그렇게 하는 것에 반대하는 주장은 다른 곳에 서브이터레이터에 대한 참조가 존재할 경우 서브이터레이터가 조기에 종료될 수 있다는 것이었습니다.\u003c/p\u003e\n\u003cp\u003e비-참조 카운팅(non-refcounting) Python 구현을 고려한 결과, 이 명시적 종료를 수행해야 한다는 결정이 내려졌습니다. 이는 분리된 제너레이터를 명시적으로 닫는 것이 모든 Python 구현에서 분리되지 않은 제너레이터를 닫는 것과 동일한 효과를 갖도록 하기 위함입니다.\u003c/p\u003e\n\u003cp\u003e대부분의 사용 사례에서 서브이터레이터는 공유되지 않을 것이라는 가정이 있습니다. 공유된 서브이터레이터의 드문 경우는 \u003ccode\u003ethrow()\u003c/code\u003e 및 \u003ccode\u003eclose()\u003c/code\u003e 호출을 차단하는 래퍼(wrapper)를 사용하거나, \u003ccode\u003eyield from\u003c/code\u003e이 아닌 다른 수단을 사용하여 서브이터레이터를 호출함으로써 해결할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e스레드로서의 제너레이터 (Generators as Threads)\u003c/h3\u003e\n\u003cp\u003e제너레이터가 값을 반환할 수 있도록 하는 동기는 경량 스레드(lightweight threads)를 구현하기 위해 제너레이터를 사용하는 것과 관련이 있습니다. 그런 방식으로 제너레이터를 사용할 때, 경량 스레드에 의해 수행되는 계산을 여러 함수에 분산시키기를 원하는 것은 합리적입니다. 서브제너레이터를 일반 함수처럼 호출하여 매개변수를 전달하고 반환 값을 받을 수 있기를 바랍니다.\u003c/p\u003e\n\u003cp\u003e제안된 문법을 사용하면, 일반 함수 \u003ccode\u003ef\u003c/code\u003e에 대한 \u003ccode\u003ey = f(x)\u003c/code\u003e와 같은 문을 위임 호출 \u003ccode\u003ey = yield from g(x)\u003c/code\u003e로 변환할 수 있습니다. 여기서 \u003ccode\u003eg\u003c/code\u003e는 제너레이터입니다. \u003ccode\u003eg\u003c/code\u003e를 \u003ccode\u003eyield\u003c/code\u003e 문을 사용하여 일시 중단될 수 있는 일반 함수로 생각함으로써 결과 코드의 동작을 추론할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 방식으로 제너레이터를 스레드로 사용할 때, 일반적으로 \u003ccode\u003eyield\u003c/code\u003e를 통해 전달되거나 나가는 값에는 관심이 없습니다. 그러나 스레드가 항목의 생산자 또는 소비자로 간주되는 사용 사례도 있습니다. \u003ccode\u003eyield from\u003c/code\u003e 표현식을 사용하면 스레드의 로직을 원하는 만큼 많은 함수에 분산시킬 수 있으며, 항목의 생산 또는 소비는 어떤 하위 함수에서든 발생하고, 해당 항목은 궁극적인 원본 또는 대상으로 자동으로 라우팅됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ethrow()\u003c/code\u003e 및 \u003ccode\u003eclose()\u003c/code\u003e와 관련하여, 외부에서 스레드로 예외가 \u003ccode\u003ethrow\u003c/code\u003e되면 가장 안쪽의 제너레이터(스레드가 일시 중단된 곳)에서 먼저 발생해야 하고 거기서부터 바깥쪽으로 전파되어야 하며, \u003ccode\u003eclose()\u003c/code\u003e를 호출하여 외부에서 스레드가 종료되면 활성 제너레이터의 체인이 가장 안쪽에서부터 바깥쪽으로 종료되어야 한다는 것은 합리적인 기대입니다.\u003c/p\u003e\n\u003ch3\u003e문법 (Syntax)\u003c/h3\u003e\n\u003cp\u003e제안된 특정 문법은 의미를 암시하는 동시에 새로운 키워드를 도입하지 않고 일반 \u003ccode\u003eyield\u003c/code\u003e와는 다른 점이 분명하게 드러나도록 선택되었습니다.\u003c/p\u003e\n\u003ch3\u003e최적화 (Optimisations)\u003c/h3\u003e\n\u003cp\u003e특수화된 문법을 사용하면 제너레이터 체인이 길어질 때 최적화 가능성이 열립니다. 이러한 체인은 예를 들어, 트리 구조를 재귀적으로 순회할 때 발생할 수 있습니다. \u003ccode\u003e__next__()\u003c/code\u003e 호출 및 yield된 값을 체인 아래로, 위로 전달하는 오버헤드는 최악의 경우 O(n) 연산을 O(n**2)로 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e가능한 전략은 제너레이터 객체에 위임될 제너레이터를 담는 슬롯을 추가하는 것입니다. 제너레이터에서 \u003ccode\u003e__next__()\u003c/code\u003e 또는 \u003ccode\u003esend()\u003c/code\u003e 호출이 이루어지면, 이 슬롯을 먼저 확인하고 비어 있지 않으면 참조하는 제너레이터가 대신 재개됩니다. \u003ccode\u003eStopIteration\u003c/code\u003e이 발생하면 슬롯이 지워지고 주 제너레이터가 재개됩니다.\u003c/p\u003e\n\u003cp\u003e이는 위임 오버헤드를 Python 코드 실행 없이 C 함수 호출 체인으로 줄일 수 있습니다. 가능한 개선 사항은 루프에서 전체 제너레이터 체인을 순회하고 끝에 있는 제너레이터를 직접 재개하는 것이지만, 이때 \u003ccode\u003eStopIteration\u003c/code\u003e 처리가 더 복잡해집니다.\u003c/p\u003e\n\u003ch3\u003eStopIteration을 이용한 값 반환 (Use of StopIteration to return values)\u003c/h3\u003e\n\u003cp\u003e제너레이터의 반환 값을 되돌려줄 수 있는 다양한 방법이 있습니다. 일부 대안으로는 제너레이터-이터레이터 객체의 속성으로 저장하거나, 서브제너레이터에 대한 \u003ccode\u003eclose()\u003c/code\u003e 호출의 값으로 반환하는 것이 포함됩니다. 그러나 제안된 메커니즘은 몇 가지 이유로 매력적입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eStopIteration\u003c/code\u003e 예외의 일반화를 사용하면 다른 종류의 이터레이터가 추가 속성이나 \u003ccode\u003eclose()\u003c/code\u003e 메서드를 추가할 필요 없이 프로토콜에 참여하기 쉽습니다.\u003c/li\u003e\n\u003cli\u003e서브제너레이터에서 반환 값이 사용 가능해지는 시점이 예외가 발생하는 시점과 동일하기 때문에 구현이 간단해집니다. 나중에 지연하면 반환 값을 어딘가에 저장해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e거부된 아이디어 (Rejected Ideas)\u003c/h2\u003e\n\u003cp\u003e일부 아이디어는 논의되었으나 거부되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e제안:\u003c/strong\u003e \u003ccode\u003e__next__()\u003c/code\u003e에 대한 초기 호출을 방지하거나 지정된 값으로 \u003ccode\u003esend()\u003c/code\u003e 호출로 대체하는 방법이 있어야 하며, 이는 초기 \u003ccode\u003e__next__()\u003c/code\u003e가 자동으로 수행되도록 래핑된 제너레이터 사용을 지원하려는 의도였습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e해결:\u003c/strong\u003e 이 제안의 범위를 벗어납니다. 이러한 제너레이터는 \u003ccode\u003eyield from\u003c/code\u003e과 함께 사용되어서는 안 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e제안:\u003c/strong\u003e 서브이터레이터를 닫는 것이 값을 가진 \u003ccode\u003eStopIteration\u003c/code\u003e을 발생시키면, 위임하는 제너레이터에 대한 \u003ccode\u003eclose()\u003c/code\u003e 호출에서 해당 값을 반환합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 기능의 동기는 제너레이터로 보내지는 값 스트림의 끝을 제너레이터를 닫음으로써 알릴 수 있도록 하기 위함입니다. 제너레이터는 \u003ccode\u003eGeneratorExit\u003c/code\u003e를 포착하고, 계산을 완료하며, 결과를 반환하고, 이 결과는 \u003ccode\u003eclose()\u003c/code\u003e 호출의 반환 값이 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e해결:\u003c/strong\u003e \u003ccode\u003eclose()\u003c/code\u003e 및 \u003ccode\u003eGeneratorExit\u003c/code\u003e의 이러한 사용은 bail-out 및 정리 메커니즘으로서의 현재 역할과 호환되지 않습니다. 이는 위임하는 제너레이터를 닫을 때, 서브제너레이터가 닫힌 후 \u003ccode\u003eGeneratorExit\u003c/code\u003e를 다시 발생시키는 대신 위임하는 제너레이터가 재개되어야 함을 요구합니다. 그러나 이는 허용될 수 없습니다. 왜냐하면 \u003ccode\u003eclose()\u003c/code\u003e가 정리 목적으로 호출되는 경우 위임하는 제너레이터가 제대로 종료되도록 보장하지 못할 것이기 때문입니다.\u003c/li\u003e\n\u003cli\u003e소비자에게 값의 끝을 알리는 것은 센티넬(sentinel) 값 전송 또는 생산자와 소비자 간에 합의된 예외 발생과 같은 다른 수단으로 더 잘 다루어집니다. 그러면 소비자는 센티넬 또는 예외를 감지하고 계산을 완료하고 정상적으로 반환함으로써 응답할 수 있습니다. 이러한 방식은 위임(delegation)이 있을 때 올바르게 동작합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e제안:\u003c/strong\u003e \u003ccode\u003eclose()\u003c/code\u003e가 값을 반환하지 않는 경우, \u003ccode\u003eNone\u003c/code\u003e이 아닌 값을 가진 \u003ccode\u003eStopIteration\u003c/code\u003e이 발생하면 예외를 발생시킵니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e해결:\u003c/strong\u003e 그렇게 할 명확한 이유가 없습니다. 반환 값을 무시하는 것은 Python의 다른 곳에서는 오류로 간주되지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e비판 (Criticisms)\u003c/h2\u003e\n\u003cp\u003e이 제안에 따르면, \u003ccode\u003eyield from\u003c/code\u003e 표현식의 값은 일반 \u003ccode\u003eyield\u003c/code\u003e 표현식의 값과는 매우 다른 방식으로 파생됩니다. 이는 \u003ccode\u003eyield\u003c/code\u003e라는 단어를 포함하지 않는 다른 문법이 더 적절할 수 있음을 시사하지만, 아직까지 수용 가능한 대안은 제안되지 않았습니다. 거부된 대안으로는 \u003ccode\u003ecall\u003c/code\u003e, \u003ccode\u003edelegate\u003c/code\u003e, \u003ccode\u003egcall\u003c/code\u003e 등이 있습니다.\u003c/p\u003e\n\u003cp\u003e서브제너레이터에서 \u003ccode\u003ereturn\u003c/code\u003e 이외의 다른 메커니즘을 사용하여 \u003ccode\u003eyield from\u003c/code\u003e 표현식으로 반환되는 값을 설정해야 한다는 제안이 있었습니다. 그러나 이는 서브제너레이터를 일시 중단 가능한 함수로 생각할 수 있다는 목표에 방해가 될 것입니다. 왜냐하면 다른 함수와 동일한 방식으로 값을 반환할 수 없기 때문입니다.\u003c/p\u003e\n\u003cp\u003e반환 값을 전달하기 위해 예외를 사용하는 것은 \"예외 남용\"으로 비판받았지만, 이 주장에 대한 구체적인 정당화는 없었습니다. 어쨌든, 이것은 단지 제안된 구현 중 하나일 뿐입니다. 제안의 본질적인 기능을 잃지 않고 다른 메커니즘을 사용할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e값을 반환하기 위해 \u003ccode\u003eStopIteration\u003c/code\u003e 대신 \u003ccode\u003eGeneratorReturn\u003c/code\u003e과 같은 다른 예외를 사용해야 한다는 제안도 있었습니다. 그러나 이에 대한 설득력 있는 실제적인 이유는 제시되지 않았으며, \u003ccode\u003eStopIteration\u003c/code\u003e에 \u003ccode\u003evalue\u003c/code\u003e 속성을 추가한 것이 반환 값을 추출하는 데 발생할 수 있는 모든 어려움을 완화합니다. 또한, 다른 예외를 사용하면 일반 함수와 달리 제너레이터에서 값을 갖지 않는 \u003ccode\u003ereturn\u003c/code\u003e이 \u003ccode\u003ereturn None\u003c/code\u003e과 동등하지 않게 될 것입니다.\u003c/p\u003e\n\u003ch2\u003e대안 제안 (Alternative Proposals)\u003c/h2\u003e\n\u003cp\u003e이와 유사한 제안은 이전에도 있었으며, 일부는 \u003ccode\u003eyield from\u003c/code\u003e 대신 \u003ccode\u003eyield *\u003c/code\u003e 문법을 사용했습니다. \u003ccode\u003eyield *\u003c/code\u003e는 더 간결하지만, 일반 \u003ccode\u003eyield\u003c/code\u003e와 너무 비슷해 보이고 코드를 읽을 때 차이점을 간과할 수 있다는 주장이 있었습니다.\u003c/p\u003e\n\u003cp\u003e작성자의 지식으로는 이전 제안들은 값 yield에만 초점을 맞추었으며, 따라서 그들이 대체하는 두 줄짜리 \u003ccode\u003efor\u003c/code\u003e 루프가 새로운 문법을 정당화할 만큼 충분히 번거롭지 않다는 비판을 받았습니다. 이 제안은 전체 제너레이터 프로토콜을 다룸으로써 훨씬 더 많은 이점을 제공합니다.\u003c/p\u003e\n\u003ch2\u003e추가 자료 (Additional Material)\u003c/h2\u003e\n\u003cp\u003e제안된 문법 사용 예시와 위에 설명된 첫 번째 최적화를 기반으로 한 프로토타입 구현이 제공됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e예시 및 구현:\u003c/strong\u003e Python 3.3용으로 업데이트된 구현 버전은 \u003ca href=\"https://bugs.python.org/issue11682\"\u003e트래커 이슈 #11682\u003c/a\u003e에서 확인할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)으로 지정되었습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 380 - Syntax for Delegating to a Subgenerator\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 21:02:19+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>