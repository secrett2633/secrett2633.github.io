<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/773b243a13a00265.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-61c2b369a48bb953.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/app/layout-c3297246cbd80ae3.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-7dac10d45f5cfdfc.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2224<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 352 - Required Superclass for Exceptions</h1><div class="page__meta"><time dateTime="2025-09-26 18:59:06+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0352/">PEP 352 - Required Superclass for Exceptions</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 27-Oct-2005</p>
</blockquote>
<h1>PEP 352 – 예외를 위한 필수 슈퍼클래스 (Required Superclass for Exceptions)</h1>
<ul>
<li><strong>작성자:</strong> Brett Cannon, Guido van Rossum</li>
<li><strong>상태:</strong> Final (최종)</li>
<li><strong>유형:</strong> Standards Track (표준 트랙)</li>
<li><strong>작성일:</strong> 2005년 10월 27일</li>
<li><strong>Python 버전:</strong> 2.5</li>
<li><strong>번역 목표:</strong> 이 PEP의 제안 내용, 도입 배경, 그리고 실제 Python 사용에 미치는 영향을 한국어 사용자가 명확하게 이해할 수 있도록 돕습니다.</li>
</ul>
<h2>요약 (Abstract)</h2>
<p>Python 2.4 이하 버전에서는 어떤 (클래식) 클래스든 예외로 발생시킬 수 있었습니다. Python 2.5에서는 새로운 스타일 클래스(new-style classes)도 허용할 계획이었는데, 이는 문제를 더욱 악화시킬 수 있었습니다. 즉, 모든 클래스(또는 인스턴스)를 예외로 발생시킬 수 있다는 의미가 됩니다. 이는 예외의 인터페이스에 대한 어떤 보장도 할 수 없게 만들었기 때문에 문제였습니다. 이 PEP는 모든 예외로 발생하는 객체가 반드시 상속해야 하는 새로운 슈퍼클래스(superclass)를 도입할 것을 제안합니다. 이러한 제한을 두면 예외를 위한 표준 인터페이스가 존재하게 되어 신뢰할 수 있게 됩니다. 또한, 모든 예외가 준수해야 할 알려진 계층 구조를 갖게 됩니다.</p>
<p>특정 인터페이스에 특정 기본 클래스를 요구하는 것이 Python답지 않다고 반박할 수도 있습니다. 하지만 예외의 경우, 충분히 합리적인 이유가 있습니다 (이는 <code>python-dev</code> 커뮤니티에서 일반적으로 동의되었습니다): 계층 구조를 요구하면 <code>except BaseException:</code> 대신 <code>except *:</code> 와 같이 작성하는 것이 가능해져서 모든 예외를 명시적으로 잡으려는 코드에 도움이 됩니다.</p>
<p>예외를 위한 새로운 슈퍼클래스를 도입하는 것은 예외 계층 구조를 더 좋게 재구성할 기회도 제공합니다. 현재 상태에서는 내장(built-in) 네임스페이스에 있는 모든 예외는 <code>Exception</code>을 상속합니다. 이는 <code>KeyboardInterrupt</code>와 <code>SystemExit</code>라는 두 가지 예외를 포함하는데, 이들은 종종 애플리케이션의 예외 처리에서 제외되어야 할 필요가 있다는 점에서 문제가 됩니다. 일반적으로 트레이스백(traceback) 없이 인터프리터를 종료하는 기본 동작이 애플리케이션이 수행할 수 있는 어떤 동작보다 더 바람직하기 때문입니다 (Python의 대화형 명령 루프를 에뮬레이트하는 애플리케이션은 예외일 수 있습니다). 이 두 예외가 <code>Exception</code> 대신 공통 슈퍼클래스로부터 상속받도록 변경하면, 사람들이 과도하게 넓지 않은 <code>except</code> 절을 작성하여 전파되어야 할 예외를 잡지 않도록 쉽게 할 수 있습니다.</p>
<p>이 PEP는 PEP 348의 이전 작업을 기반으로 합니다.</p>
<h2>공통 슈퍼클래스 요구 (Requiring a Common Superclass)</h2>
<p>이 PEP는 새로운 스타일 클래스이며 <code>args</code>라는 단일 속성을 가지는 <code>BaseException</code>이라는 새로운 예외를 도입할 것을 제안합니다. 다음은 Python 3.0에서 예외가 작동할 코드입니다 (Python 2.x에서의 작동 방식은 "Transition Plan" 섹션에서 다룹니다):</p>
<pre><code class="language-python">class BaseException(object):
    """예외 계층 구조의 기반을 나타내는 슈퍼클래스입니다.
    생성자에 전달된 모든 인수를 포함하는 'args' 속성을 제공합니다.
    하지만 권장되는 방식은 단일 문자열 인수만 생성자에 전달하는 것입니다.
    """
    def __init__(self, *args):
        self.args = args

    def __str__(self):
        if len(self.args) == 1:
            return str(self.args)
        else:
            return str(self.args)

    def __repr__(self):
        return "%s(*%s)" % (self.__class__.__name__, repr(self.args))
</code></pre>
<p>하위 호환성(backwards-compatibility)을 위해 <code>args</code>에 전달될 수 있는 내용에는 제한이 없습니다. 하지만 실제로는 단일 문자열 인수만 사용해야 합니다. 이렇게 하면 예외의 문자열 표현이 사람이 읽을 수 있는 유용한 메시지가 됩니다. 이것이 <code>__str__</code> 메서드가 길이가 1인 <code>args</code> 값을 특별 처리하는 이유입니다. 프로그래밍 정보(예: 오류 코드 번호)는 서브클래스에 별도의 속성으로 저장되어야 합니다.</p>
<p><code>raise</code> 문은 전달되는 모든 객체가 <code>BaseException</code>을 상속해야 하도록 변경될 것입니다. 이는 모든 예외가 <code>BaseException</code>을 기반으로 하는 단일 계층 구조 내에 있도록 보장합니다. 또한 <code>BaseException</code>으로부터 상속되는 기본 인터페이스를 보장합니다. <code>raise</code>에 대한 변경 사항은 Python 3.0부터 적용될 것입니다 (아래 "Transition Plan" 참조).</p>
<p><code>BaseException</code>이 예외 계층 구조의 루트(root)가 되면서, <code>Exception</code>은 이제 <code>BaseException</code>으로부터 상속받게 됩니다.</p>
<h2>예외 계층 구조 변경 (Exception Hierarchy Changes)</h2>
<p>예외 계층 구조가 이제 기본적인 루트를 가지게 되어 더욱 중요해졌으므로, 기존 계층 구조의 변경이 필요합니다. 현재로서는 오류를 알리고 인터프리터가 종료되어서는 안 된다고 의미하는 모든 예외를 잡으려면, <code>except</code> 절에 두 가지 예외를 제외한 모든 예외를 구체적으로 지정하거나, 두 예외를 따로 잡은 다음 다시 <code>raise</code>하고 다른 모든 예외는 bare <code>except</code> 절로 넘어가도록 해야 합니다:</p>
<pre><code class="language-python">except (KeyboardInterrupt, SystemExit):
    raise
except:
    ...
</code></pre>
<p>이는 불필요하게 명시적입니다. 이 PEP는 <code>KeyboardInterrupt</code>와 <code>SystemExit</code>가 <code>BaseException</code>으로부터 직접 상속받도록 이동할 것을 제안합니다.</p>
<ul>
<li><code>BaseException</code>
<ul>
<li><code>KeyboardInterrupt</code></li>
<li><code>SystemExit</code></li>
<li><code>Exception</code>
<ul>
<li>(현재의 모든 다른 내장 예외들)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>이렇게 하면 <code>Exception</code>을 잡는 것이 더 합리적이 됩니다. 이는 오류를 나타내는 예외만 잡게 됩니다. 인터프리터가 종료되어야 함을 알리는 예외는 잡히지 않으므로 전파되어 인터프리터가 종료될 수 있도록 합니다.</p>
<p>사용자들이 인터럽트 키(일반적으로 Ctrl-C)를 누르면 애플리케이션이 종료될 것으로 예상하기 때문에 <code>KeyboardInterrupt</code>가 이동되었습니다. 만약 사람들이 지나치게 넓은 <code>except</code> 절을 가지고 있다면 예상되는 동작이 발생하지 않습니다.</p>
<p><code>SystemExit</code>도 유사한 이유로 이동되었습니다. <code>sys.exit()</code>가 호출될 때 예외가 발생하므로, 인터프리터는 일반적으로 종료될 수 있어야 합니다. 불행히도 지나치게 넓은 <code>except</code> 절은 명시적으로 요청된 종료가 발생하지 않도록 막을 수 있습니다.</p>
<p>사람들이 대부분의 경우 <code>Exception</code>을 잡도록 하기 위해, 문서와 튜토리얼의 여러 부분이 프로그래머들이 <code>Exception</code>을 사용하도록 강력하게 권장하도록 업데이트되어야 합니다. <code>KeyboardInterrupt</code>와 <code>SystemExit</code>는 거의 항상 전파되도록 허용되어야 한다는 사실에 기반하여, bare <code>except</code> 절 또는 <code>BaseException</code>을 직접 잡는 것은 권장되지 않아야 합니다.</p>
<h2>전환 계획 (Transition Plan)</h2>
<p>Python에 대한 의미론적 변경이 제안되므로 전환 계획이 필요합니다. 목표는 Python 3.0에서 새로운 의미론이 사용되도록 하면서도 2.x 코드에 대한 원활한 전환을 제공하는 것입니다. 계획에 언급된 모든 사용 중단(deprecation)은 초기 사용 중단 이후 버전부터 의미론의 제거로 이어질 것입니다.</p>
<p>다음은 2.x 시리즈에서 구현된 <code>BaseException</code>입니다:</p>
<pre><code class="language-python">class BaseException(object):
    """예외 계층 구조의 기반을 나타내는 슈퍼클래스입니다.
    __getitem__ 메서드는 하위 호환성을 위해 제공되며 언젠가 사용 중단될 것입니다.
    'message' 속성도 사용 중단됩니다.
    """
    def __init__(self, *args):
        self.args = args

    def __str__(self):
        return str(self.args if len(self.args) &#x3C;= 1 else self.args)

    def __repr__(self):
        func_args = repr(self.args)
        if self.args else "()"
        return self.__class__.__name__ + func_args

    def __getitem__(self, index):
        """인스턴스화 시 전달된 인수에 대한 인덱스입니다.
        하위 호환성을 위해 제공되며 사용 중단될 것입니다.
        """
        return self.args[index]

    def _get_message(self):
        """'message' 속성을 위한 메서드입니다."""
        warnings.warn("the 'message' attribute has been deprecated "
                      "since Python 2.6")
        return self.args if len(self.args) == 1 else ''

    message = property(_get_message, doc="access the 'message' attribute; "
                                         "deprecated and provided only for "
                                         "backwards-compatibility")
</code></pre>
<p>Python 2.9에서의 기능 사용 중단은 선택 사항입니다. 이는 Python 2.9(2.x 시리즈의 마지막 버전으로 예정)가 3.0에 없을 기능을 적극적으로 사용 중단할지 여부가 현재로서는 알려지지 않았기 때문입니다. 2.9와 3.0 사이에 너무 큰 차이가 있어서 2.9가 경고 측면에서 너무 "시끄러울" 수 있기 때문에 2.9에서는 사용 중단 경고가 사용되지 않을 수도 있습니다. 따라서 Python 2.9에 대한 제안된 사용 중단 경고는 해당 버전 개발이 시작될 때 재검토되어 여전히 필요한지 여부가 결정될 것입니다.</p>
<p><strong>Python 2.5 [완료]</strong></p>
<ul>
<li>모든 표준 예외가 new-style 클래스가 됨 [완료]</li>
<li><code>BaseException</code> 도입 [완료]</li>
<li><code>Exception</code>, <code>KeyboardInterrupt</code>, <code>SystemExit</code>가 <code>BaseException</code>으로부터 상속받음 [완료]</li>
<li>문자열 예외(raising string exceptions) 사용 중단 [완료]</li>
</ul>
<p><strong>Python 2.6 [완료]</strong></p>
<ul>
<li>문자열 예외(catching string exceptions) 잡기 사용 중단 [완료]</li>
<li><code>message</code> 속성 사용 중단 (Retracted Ideas 참조) [완료]</li>
</ul>
<p><strong>Python 2.7 [완료]</strong></p>
<ul>
<li><code>BaseException</code>을 상속하지 않는 예외 발생 사용 중단</li>
</ul>
<p><strong>Python 3.0 [완료]</strong></p>
<ul>
<li>위에서 사용 중단된 모든 것 제거:
<ul>
<li>문자열 예외 (발생 및 잡기 모두) [완료]</li>
<li>모든 예외는 <code>BaseException</code>을 상속해야 함 [완료]</li>
<li><code>__getitem__</code>, <code>message</code> 제거 [완료]</li>
</ul>
</li>
</ul>
<h2>철회된 아이디어 (Retracted Ideas)</h2>
<p>Python 2.5에 구현되었던 이 PEP의 이전 버전에는 <code>BaseException</code>에 'message' 속성이 포함되어 있었습니다. 그 목적은 <code>BaseException</code>이 단일 인수만 받도록 전환을 시작하는 것이었습니다. 이는 인터페이스를 강화하고 사람들이 예외와 함께 임의의 정보를 <code>args</code>에 모두 밀어넣는 대신 서브클래스의 속성에 저장하도록 강제하기 위함이었습니다.</p>
<p>불행히도, PyCon 2007 스프린트에서 Python 3.0의 <code>args</code> 속성 제거를 구현하는 동안, 이 전환이 매우 고통스럽다는 것이 발견되었습니다. 특히 C 확장 모듈의 경우 더욱 그러했습니다. <code>message</code> 속성을 Python 2.6에서 사용 중단하고 (Python 2.7 및 Python 3.0에서 제거) Python 3.0에서 <code>BaseException</code>의 다중 인수 지원을 제거하고 단일 인수를 받는 것을 선호하는 장기적인 전환 전략을 고려하는 것이 더 낫다고 결정되었습니다. 따라서 <code>message</code>의 도입과 <code>args</code>의 원래 사용 중단은 철회되었습니다.</p>
<h2>참고 자료 (References)</h2>
<ul>
<li>
<p>[1] <code>python-dev</code> Summary for 2004-08-01 through 2004-08-15</p>
<ul>
<li><a href="http://www.python.org/dev/summary/2004-08-01_2004-08-15.html#an-exception-is-an-exception-unless-it-doesn-t-inherit-from-exception">http://www.python.org/dev/summary/2004-08-01_2004-08-15.html#an-exception-is-an-exception-unless-it-doesn-t-inherit-from-exception</a></li>
</ul>
</li>
<li>
<p>[2] <code>python-3000</code> email (“How far to go with cleaning up exceptions”)</p>
<ul>
<li><a href="https://mail.python.org/pipermail/python-3000/2007-March/005911.html">https://mail.python.org/pipermail/python-3000/2007-March/005911.html</a></li>
</ul>
</li>
<li>
<p>New-style exceptions 관련 이슈: <code>python/cpython#41459</code></p>
</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<pre><code>```
# PEP 352 – 예외를 위한 필수 슈퍼클래스 (Required Superclass for Exceptions)

*   **작성자:** Brett Cannon, Guido van Rossum
*   **상태:** Final (최종)
*   **유형:** Standards Track (표준 트랙)
*   **작성일:** 2005년 10월 27일
*   **Python 버전:** 2.5
*   **번역 목표:** 이 PEP의 제안 내용, 도입 배경, 그리고 실제 Python 사용에 미치는 영향을 한국어 사용자가 명확하게 이해할 수 있도록 돕습니다.

## 요약 (Abstract)

Python 2.4 이하 버전에서는 어떤 (클래식) 클래스든 예외로 발생시킬 수 있었습니다. Python 2.5에서는 새로운 스타일 클래스(new-style classes)도 허용할 계획이었는데, 이는 문제를 더욱 악화시킬 수 있었습니다. 즉, 모든 클래스(또는 인스턴스)를 예외로 발생시킬 수 있다는 의미가 됩니다. 이는 예외의 인터페이스에 대한 어떤 보장도 할 수 없게 만들었기 때문에 문제였습니다. 이 PEP는 모든 예외로 발생하는 객체가 반드시 상속해야 하는 새로운 슈퍼클래스(superclass)를 도입할 것을 제안합니다. 이러한 제한을 두면 예외를 위한 표준 인터페이스가 존재하게 되어 신뢰할 수 있게 됩니다. 또한, 모든 예외가 준수해야 할 알려진 계층 구조를 갖게 됩니다.

특정 인터페이스에 특정 기본 클래스를 요구하는 것이 Python답지 않다고 반박할 수도 있습니다. 하지만 예외의 경우, 충분히 합리적인 이유가 있습니다 (이는 `python-dev` 커뮤니티에서 일반적으로 동의되었습니다): 계층 구조를 요구하면 `except BaseException:` 대신 `except *:` 와 같이 작성하는 것이 가능해져서 모든 예외를 명시적으로 잡으려는 코드에 도움이 됩니다.

예외를 위한 새로운 슈퍼클래스를 도입하는 것은 예외 계층 구조를 더 좋게 재구성할 기회도 제공합니다. 현재 상태에서는 내장(built-in) 네임스페이스에 있는 모든 예외는 `Exception`을 상속합니다. 이는 `KeyboardInterrupt`와 `SystemExit`라는 두 가지 예외를 포함하는데, 이들은 종종 애플리케이션의 예외 처리에서 제외되어야 할 필요가 있다는 점에서 문제가 됩니다. 일반적으로 트레이스백(traceback) 없이 인터프리터를 종료하는 기본 동작이 애플리케이션이 수행할 수 있는 어떤 동작보다 더 바람직하기 때문입니다 (Python의 대화형 명령 루프를 에뮬레이트하는 애플리케이션은 예외일 수 있습니다). 이 두 예외가 `Exception` 대신 공통 슈퍼클래스로부터 상속받도록 변경하면, 사람들이 과도하게 넓지 않은 `except` 절을 작성하여 전파되어야 할 예외를 잡지 않도록 쉽게 할 수 있습니다.

이 PEP는 PEP 348의 이전 작업을 기반으로 합니다.

## 공통 슈퍼클래스 요구 (Requiring a Common Superclass)

이 PEP는 새로운 스타일 클래스이며 `args`라는 단일 속성을 가지는 `BaseException`이라는 새로운 예외를 도입할 것을 제안합니다. 다음은 Python 3.0에서 예외가 작동할 코드입니다 (Python 2.x에서의 작동 방식은 "Transition Plan" 섹션에서 다룹니다):

```python
class BaseException(object):
    """예외 계층 구조의 기반을 나타내는 슈퍼클래스입니다.
    생성자에 전달된 모든 인수를 포함하는 'args' 속성을 제공합니다.
    하지만 권장되는 방식은 단일 문자열 인수만 생성자에 전달하는 것입니다.
    """
    def __init__(self, *args):
        self.args = args

    def __str__(self):
        if len(self.args) == 1:
            return str(self.args[0])
        else:
            return str(self.args)

    def __repr__(self):
        return "%s(*%s)" % (self.__class__.__name__, repr(self.args))
```

하위 호환성(backwards-compatibility)을 위해 `args`에 전달될 수 있는 내용에는 제한이 없습니다. 하지만 실제로는 단일 문자열 인수만 사용해야 합니다. 이렇게 하면 예외의 문자열 표현이 사람이 읽을 수 있는 유용한 메시지가 됩니다. 이것이 `__str__` 메서드가 길이가 1인 `args` 값을 특별 처리하는 이유입니다. 프로그래밍 정보(예: 오류 코드 번호)는 서브클래스에 별도의 속성으로 저장되어야 합니다.

`raise` 문은 전달되는 모든 객체가 `BaseException`을 상속해야 하도록 변경될 것입니다. 이는 모든 예외가 `BaseException`을 기반으로 하는 단일 계층 구조 내에 있도록 보장합니다. 또한 `BaseException`으로부터 상속되는 기본 인터페이스를 보장합니다. `raise`에 대한 변경 사항은 Python 3.0부터 적용될 것입니다 (아래 "Transition Plan" 참조).

`BaseException`이 예외 계층 구조의 루트(root)가 되면서, `Exception`은 이제 `BaseException`으로부터 상속받게 됩니다.

## 예외 계층 구조 변경 (Exception Hierarchy Changes)

예외 계층 구조가 이제 기본적인 루트를 가지게 되어 더욱 중요해졌으므로, 기존 계층 구조의 변경이 필요합니다. 현재로서는 오류를 알리고 인터프리터가 종료되어서는 안 된다고 의미하는 모든 예외를 잡으려면, `except` 절에 두 가지 예외를 제외한 모든 예외를 구체적으로 지정하거나, 두 예외를 따로 잡은 다음 다시 `raise`하고 다른 모든 예외는 bare `except` 절로 넘어가도록 해야 합니다:

```python
except (KeyboardInterrupt, SystemExit):
    raise
except:
    ...
```

이는 불필요하게 명시적입니다. 이 PEP는 `KeyboardInterrupt`와 `SystemExit`가 `BaseException`으로부터 직접 상속받도록 이동할 것을 제안합니다.

*   `BaseException`
    *   `KeyboardInterrupt`
    *   `SystemExit`
    *   `Exception`
        *   (현재의 모든 다른 내장 예외들)

이렇게 하면 `Exception`을 잡는 것이 더 합리적이 됩니다. 이는 오류를 나타내는 예외만 잡게 됩니다. 인터프리터가 종료되어야 함을 알리는 예외는 잡히지 않으므로 전파되어 인터프리터가 종료될 수 있도록 합니다.

사용자들이 인터럽트 키(일반적으로 Ctrl-C)를 누르면 애플리케이션이 종료될 것으로 예상하기 때문에 `KeyboardInterrupt`가 이동되었습니다. 만약 사람들이 지나치게 넓은 `except` 절을 가지고 있다면 예상되는 동작이 발생하지 않습니다.

`SystemExit`도 유사한 이유로 이동되었습니다. `sys.exit()`가 호출될 때 예외가 발생하므로, 인터프리터는 일반적으로 종료될 수 있어야 합니다. 불행히도 지나치게 넓은 `except` 절은 명시적으로 요청된 종료가 발생하지 않도록 막을 수 있습니다.

사람들이 대부분의 경우 `Exception`을 잡도록 하기 위해, 문서와 튜토리얼의 여러 부분이 프로그래머들이 `Exception`을 사용하도록 강력하게 권장하도록 업데이트되어야 합니다. `KeyboardInterrupt`와 `SystemExit`는 거의 항상 전파되도록 허용되어야 한다는 사실에 기반하여, bare `except` 절 또는 `BaseException`을 직접 잡는 것은 권장되지 않아야 합니다.

## 전환 계획 (Transition Plan)

Python에 대한 의미론적 변경이 제안되므로 전환 계획이 필요합니다. 목표는 Python 3.0에서 새로운 의미론이 사용되도록 하면서도 2.x 코드에 대한 원활한 전환을 제공하는 것입니다. 계획에 언급된 모든 사용 중단(deprecation)은 초기 사용 중단 이후 버전부터 의미론의 제거로 이어질 것입니다.

다음은 2.x 시리즈에서 구현된 `BaseException`입니다:

```python
class BaseException(object):
    """예외 계층 구조의 기반을 나타내는 슈퍼클래스입니다.
    __getitem__ 메서드는 하위 호환성을 위해 제공되며 언젠가 사용 중단될 것입니다.
    'message' 속성도 사용 중단됩니다.
    """
    def __init__(self, *args):
        self.args = args

    def __str__(self):
        return str(self.args[0] if len(self.args) &#x3C;= 1 else self.args)

    def __repr__(self):
        func_args = repr(self.args)
        if self.args else "()"
        return self.__class__.__name__ + func_args

    def __getitem__(self, index):
        """인스턴스화 시 전달된 인수에 대한 인덱스입니다.
        하위 호환성을 위해 제공되며 사용 중단될 것입니다.
        """
        return self.args[index]

    def _get_message(self):
        """'message' 속성을 위한 메서드입니다."""
        warnings.warn("the 'message' attribute has been deprecated "
                      "since Python 2.6")
        return self.args[0] if len(self.args) == 1 else ''

    message = property(_get_message, doc="access the 'message' attribute; "
                                         "deprecated and provided only for "
                                         "backwards-compatibility")
```

Python 2.9에서의 기능 사용 중단은 선택 사항입니다. 이는 Python 2.9(2.x 시리즈의 마지막 버전으로 예정)가 3.0에 없을 기능을 적극적으로 사용 중단할지 여부가 현재로서는 알려지지 않았기 때문입니다. 2.9와 3.0 사이에 너무 큰 차이가 있어서 2.9가 경고 측면에서 너무 "시끄러울" 수 있기 때문에 2.9에서는 사용 중단 경고가 사용되지 않을 수도 있습니다. 따라서 Python 2.9에 대한 제안된 사용 중단 경고는 해당 버전 개발이 시작될 때 재검토되어 여전히 필요한지 여부가 결정될 것입니다.

**Python 2.5 [완료]**
*   모든 표준 예외가 new-style 클래스가 됨 [완료]
*   `BaseException` 도입 [완료]
*   `Exception`, `KeyboardInterrupt`, `SystemExit`가 `BaseException`으로부터 상속받음 [완료]
*   문자열 예외(raising string exceptions) 사용 중단 [완료]

**Python 2.6 [완료]**
*   문자열 예외(catching string exceptions) 잡기 사용 중단 [완료]
*   `message` 속성 사용 중단 (Retracted Ideas 참조) [완료]

**Python 2.7 [완료]**
*   `BaseException`을 상속하지 않는 예외 발생 사용 중단

**Python 3.0 [완료]**
*   위에서 사용 중단된 모든 것 제거:
    *   문자열 예외 (발생 및 잡기 모두) [완료]
    *   모든 예외는 `BaseException`을 상속해야 함 [완료]
    *   `__getitem__`, `message` 제거 [완료]

## 철회된 아이디어 (Retracted Ideas)

Python 2.5에 구현되었던 이 PEP의 이전 버전에는 `BaseException`에 'message' 속성이 포함되어 있었습니다. 그 목적은 `BaseException`이 단일 인수만 받도록 전환을 시작하는 것이었습니다. 이는 인터페이스를 강화하고 사람들이 예외와 함께 임의의 정보를 `args`에 모두 밀어넣는 대신 서브클래스의 속성에 저장하도록 강제하기 위함이었습니다.

불행히도, PyCon 2007 스프린트에서 Python 3.0의 `args` 속성 제거를 구현하는 동안, 이 전환이 매우 고통스럽다는 것이 발견되었습니다. 특히 C 확장 모듈의 경우 더욱 그러했습니다. `message` 속성을 Python 2.6에서 사용 중단하고 (Python 2.7 및 Python 3.0에서 제거) Python 3.0에서 `BaseException`의 다중 인수 지원을 제거하고 단일 인수를 받는 것을 선호하는 장기적인 전환 전략을 고려하는 것이 더 낫다고 결정되었습니다. 따라서 `message`의 도입과 `args`의 원래 사용 중단은 철회되었습니다.

## 참고 자료 (References)

*   `python-dev` Summary for 2004-08-01 through 2004-08-15
    *   &#x3C;http://www.python.org/dev/summary/2004-08-01_2004-08-15.html#an-exception-is-an-exception-unless-it-doesn-t-inherit-from-exception>
*   `python-3000` email (“How far to go with cleaning up exceptions”)
    *   &#x3C;https://mail.python.org/pipermail/python-3000/2007-March/005911.html>

*   New-style exceptions 관련 이슈: `python/cpython#41459`

## 저작권 (Copyright)

이 문서는 퍼블릭 도메인에 공개되었습니다.

> ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.
</code></pre>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/351/">[Rejected] PEP 351 - The freeze protocol</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 352 - Required Superclass for Exceptions</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/353/">[Final] PEP 353 - Using ssize_t as the index type</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-61c2b369a48bb953.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/773b243a13a00265.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"185\",\"static/chunks/app/layout-c3297246cbd80ae3.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-7dac10d45f5cfdfc.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/352\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/773b243a13a00265.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"QRk123GkENE0bgAxJMWB7\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/352/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/352\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"352\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/352\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"e:I[646,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-7dac10d45f5cfdfc.js\"],\"default\"]\nd:T6911,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0352/\"\u003ePEP 352 - Required Superclass for Exceptions\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 27-Oct-2005\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 352 – 예외를 위한 필수 슈퍼클래스 (Required Superclass for Exceptions)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Brett Cannon, Guido van Rossum\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final (최종)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track (표준 트랙)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e작성일:\u003c/strong\u003e 2005년 10월 27일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 2.5\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e번역 목표:\u003c/strong\u003e 이 PEP의 제안 내용, 도입 배경, 그리고 실제 Python 사용에 미치는 영향을 한국어 사용자가 명확하게 이해할 수 있도록 돕습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003ePython 2.4 이하 버전에서는 어떤 (클래식) 클래스든 예외로 발생시킬 수 있었습니다. Python 2.5에서는 새로운 스타일 클래스(new-style classes)도 허용할 계획이었는데, 이는 문제를 더욱 악화시킬 수 있었습니다. 즉, 모든 클래스(또는 인스턴스)를 예외로 발생시킬 수 있다는 의미가 됩니다. 이는 예외의 인터페이스에 대한 어떤 보장도 할 수 없게 만들었기 때문에 문제였습니다. 이 PEP는 모든 예외로 발생하는 객체가 반드시 상속해야 하는 새로운 슈퍼클래스(superclass)를 도입할 것을 제안합니다. 이러한 제한을 두면 예외를 위한 표준 인터페이스가 존재하게 되어 신뢰할 수 있게 됩니다. 또한, 모든 예외가 준수해야 할 알려진 계층 구조를 갖게 됩니다.\u003c/p\u003e\n\u003cp\u003e특정 인터페이스에 특정 기본 클래스를 요구하는 것이 Python답지 않다고 반박할 수도 있습니다. 하지만 예외의 경우, 충분히 합리적인 이유가 있습니다 (이는 \u003ccode\u003epython-dev\u003c/code\u003e 커뮤니티에서 일반적으로 동의되었습니다): 계층 구조를 요구하면 \u003ccode\u003eexcept BaseException:\u003c/code\u003e 대신 \u003ccode\u003eexcept *:\u003c/code\u003e 와 같이 작성하는 것이 가능해져서 모든 예외를 명시적으로 잡으려는 코드에 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e예외를 위한 새로운 슈퍼클래스를 도입하는 것은 예외 계층 구조를 더 좋게 재구성할 기회도 제공합니다. 현재 상태에서는 내장(built-in) 네임스페이스에 있는 모든 예외는 \u003ccode\u003eException\u003c/code\u003e을 상속합니다. 이는 \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e와 \u003ccode\u003eSystemExit\u003c/code\u003e라는 두 가지 예외를 포함하는데, 이들은 종종 애플리케이션의 예외 처리에서 제외되어야 할 필요가 있다는 점에서 문제가 됩니다. 일반적으로 트레이스백(traceback) 없이 인터프리터를 종료하는 기본 동작이 애플리케이션이 수행할 수 있는 어떤 동작보다 더 바람직하기 때문입니다 (Python의 대화형 명령 루프를 에뮬레이트하는 애플리케이션은 예외일 수 있습니다). 이 두 예외가 \u003ccode\u003eException\u003c/code\u003e 대신 공통 슈퍼클래스로부터 상속받도록 변경하면, 사람들이 과도하게 넓지 않은 \u003ccode\u003eexcept\u003c/code\u003e 절을 작성하여 전파되어야 할 예외를 잡지 않도록 쉽게 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 PEP 348의 이전 작업을 기반으로 합니다.\u003c/p\u003e\n\u003ch2\u003e공통 슈퍼클래스 요구 (Requiring a Common Superclass)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 새로운 스타일 클래스이며 \u003ccode\u003eargs\u003c/code\u003e라는 단일 속성을 가지는 \u003ccode\u003eBaseException\u003c/code\u003e이라는 새로운 예외를 도입할 것을 제안합니다. 다음은 Python 3.0에서 예외가 작동할 코드입니다 (Python 2.x에서의 작동 방식은 \"Transition Plan\" 섹션에서 다룹니다):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass BaseException(object):\r\n    \"\"\"예외 계층 구조의 기반을 나타내는 슈퍼클래스입니다.\r\n    생성자에 전달된 모든 인수를 포함하는 'args' 속성을 제공합니다.\r\n    하지만 권장되는 방식은 단일 문자열 인수만 생성자에 전달하는 것입니다.\r\n    \"\"\"\r\n    def __init__(self, *args):\r\n        self.args = args\r\n\r\n    def __str__(self):\r\n        if len(self.args) == 1:\r\n            return str(self.args)\r\n        else:\r\n            return str(self.args)\r\n\r\n    def __repr__(self):\r\n        return \"%s(*%s)\" % (self.__class__.__name__, repr(self.args))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하위 호환성(backwards-compatibility)을 위해 \u003ccode\u003eargs\u003c/code\u003e에 전달될 수 있는 내용에는 제한이 없습니다. 하지만 실제로는 단일 문자열 인수만 사용해야 합니다. 이렇게 하면 예외의 문자열 표현이 사람이 읽을 수 있는 유용한 메시지가 됩니다. 이것이 \u003ccode\u003e__str__\u003c/code\u003e 메서드가 길이가 1인 \u003ccode\u003eargs\u003c/code\u003e 값을 특별 처리하는 이유입니다. 프로그래밍 정보(예: 오류 코드 번호)는 서브클래스에 별도의 속성으로 저장되어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eraise\u003c/code\u003e 문은 전달되는 모든 객체가 \u003ccode\u003eBaseException\u003c/code\u003e을 상속해야 하도록 변경될 것입니다. 이는 모든 예외가 \u003ccode\u003eBaseException\u003c/code\u003e을 기반으로 하는 단일 계층 구조 내에 있도록 보장합니다. 또한 \u003ccode\u003eBaseException\u003c/code\u003e으로부터 상속되는 기본 인터페이스를 보장합니다. \u003ccode\u003eraise\u003c/code\u003e에 대한 변경 사항은 Python 3.0부터 적용될 것입니다 (아래 \"Transition Plan\" 참조).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBaseException\u003c/code\u003e이 예외 계층 구조의 루트(root)가 되면서, \u003ccode\u003eException\u003c/code\u003e은 이제 \u003ccode\u003eBaseException\u003c/code\u003e으로부터 상속받게 됩니다.\u003c/p\u003e\n\u003ch2\u003e예외 계층 구조 변경 (Exception Hierarchy Changes)\u003c/h2\u003e\n\u003cp\u003e예외 계층 구조가 이제 기본적인 루트를 가지게 되어 더욱 중요해졌으므로, 기존 계층 구조의 변경이 필요합니다. 현재로서는 오류를 알리고 인터프리터가 종료되어서는 안 된다고 의미하는 모든 예외를 잡으려면, \u003ccode\u003eexcept\u003c/code\u003e 절에 두 가지 예외를 제외한 모든 예외를 구체적으로 지정하거나, 두 예외를 따로 잡은 다음 다시 \u003ccode\u003eraise\u003c/code\u003e하고 다른 모든 예외는 bare \u003ccode\u003eexcept\u003c/code\u003e 절로 넘어가도록 해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eexcept (KeyboardInterrupt, SystemExit):\r\n    raise\r\nexcept:\r\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 불필요하게 명시적입니다. 이 PEP는 \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e와 \u003ccode\u003eSystemExit\u003c/code\u003e가 \u003ccode\u003eBaseException\u003c/code\u003e으로부터 직접 상속받도록 이동할 것을 제안합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eBaseException\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eKeyboardInterrupt\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSystemExit\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eException\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e(현재의 모든 다른 내장 예외들)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 하면 \u003ccode\u003eException\u003c/code\u003e을 잡는 것이 더 합리적이 됩니다. 이는 오류를 나타내는 예외만 잡게 됩니다. 인터프리터가 종료되어야 함을 알리는 예외는 잡히지 않으므로 전파되어 인터프리터가 종료될 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e사용자들이 인터럽트 키(일반적으로 Ctrl-C)를 누르면 애플리케이션이 종료될 것으로 예상하기 때문에 \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e가 이동되었습니다. 만약 사람들이 지나치게 넓은 \u003ccode\u003eexcept\u003c/code\u003e 절을 가지고 있다면 예상되는 동작이 발생하지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSystemExit\u003c/code\u003e도 유사한 이유로 이동되었습니다. \u003ccode\u003esys.exit()\u003c/code\u003e가 호출될 때 예외가 발생하므로, 인터프리터는 일반적으로 종료될 수 있어야 합니다. 불행히도 지나치게 넓은 \u003ccode\u003eexcept\u003c/code\u003e 절은 명시적으로 요청된 종료가 발생하지 않도록 막을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e사람들이 대부분의 경우 \u003ccode\u003eException\u003c/code\u003e을 잡도록 하기 위해, 문서와 튜토리얼의 여러 부분이 프로그래머들이 \u003ccode\u003eException\u003c/code\u003e을 사용하도록 강력하게 권장하도록 업데이트되어야 합니다. \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e와 \u003ccode\u003eSystemExit\u003c/code\u003e는 거의 항상 전파되도록 허용되어야 한다는 사실에 기반하여, bare \u003ccode\u003eexcept\u003c/code\u003e 절 또는 \u003ccode\u003eBaseException\u003c/code\u003e을 직접 잡는 것은 권장되지 않아야 합니다.\u003c/p\u003e\n\u003ch2\u003e전환 계획 (Transition Plan)\u003c/h2\u003e\n\u003cp\u003ePython에 대한 의미론적 변경이 제안되므로 전환 계획이 필요합니다. 목표는 Python 3.0에서 새로운 의미론이 사용되도록 하면서도 2.x 코드에 대한 원활한 전환을 제공하는 것입니다. 계획에 언급된 모든 사용 중단(deprecation)은 초기 사용 중단 이후 버전부터 의미론의 제거로 이어질 것입니다.\u003c/p\u003e\n\u003cp\u003e다음은 2.x 시리즈에서 구현된 \u003ccode\u003eBaseException\u003c/code\u003e입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass BaseException(object):\r\n    \"\"\"예외 계층 구조의 기반을 나타내는 슈퍼클래스입니다.\r\n    __getitem__ 메서드는 하위 호환성을 위해 제공되며 언젠가 사용 중단될 것입니다.\r\n    'message' 속성도 사용 중단됩니다.\r\n    \"\"\"\r\n    def __init__(self, *args):\r\n        self.args = args\r\n\r\n    def __str__(self):\r\n        return str(self.args if len(self.args) \u0026#x3C;= 1 else self.args)\r\n\r\n    def __repr__(self):\r\n        func_args = repr(self.args)\r\n        if self.args else \"()\"\r\n        return self.__class__.__name__ + func_args\r\n\r\n    def __getitem__(self, index):\r\n        \"\"\"인스턴스화 시 전달된 인수에 대한 인덱스입니다.\r\n        하위 호환성을 위해 제공되며 사용 중단될 것입니다.\r\n        \"\"\"\r\n        return self.args[index]\r\n\r\n    def _get_message(self):\r\n        \"\"\"'message' 속성을 위한 메서드입니다.\"\"\"\r\n        warnings.warn(\"the 'message' attribute has been deprecated \"\r\n                      \"since Python 2.6\")\r\n        return self.args if len(self.args) == 1 else ''\r\n\r\n    message = property(_get_message, doc=\"access the 'message' attribute; \"\r\n                                         \"deprecated and provided only for \"\r\n                                         \"backwards-compatibility\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 2.9에서의 기능 사용 중단은 선택 사항입니다. 이는 Python 2.9(2.x 시리즈의 마지막 버전으로 예정)가 3.0에 없을 기능을 적극적으로 사용 중단할지 여부가 현재로서는 알려지지 않았기 때문입니다. 2.9와 3.0 사이에 너무 큰 차이가 있어서 2.9가 경고 측면에서 너무 \"시끄러울\" 수 있기 때문에 2.9에서는 사용 중단 경고가 사용되지 않을 수도 있습니다. 따라서 Python 2.9에 대한 제안된 사용 중단 경고는 해당 버전 개발이 시작될 때 재검토되어 여전히 필요한지 여부가 결정될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePython 2.5 [완료]\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모든 표준 예외가 new-style 클래스가 됨 [완료]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBaseException\u003c/code\u003e 도입 [완료]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eException\u003c/code\u003e, \u003ccode\u003eKeyboardInterrupt\u003c/code\u003e, \u003ccode\u003eSystemExit\u003c/code\u003e가 \u003ccode\u003eBaseException\u003c/code\u003e으로부터 상속받음 [완료]\u003c/li\u003e\n\u003cli\u003e문자열 예외(raising string exceptions) 사용 중단 [완료]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003ePython 2.6 [완료]\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e문자열 예외(catching string exceptions) 잡기 사용 중단 [완료]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emessage\u003c/code\u003e 속성 사용 중단 (Retracted Ideas 참조) [완료]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003ePython 2.7 [완료]\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eBaseException\u003c/code\u003e을 상속하지 않는 예외 발생 사용 중단\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003ePython 3.0 [완료]\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e위에서 사용 중단된 모든 것 제거:\n\u003cul\u003e\n\u003cli\u003e문자열 예외 (발생 및 잡기 모두) [완료]\u003c/li\u003e\n\u003cli\u003e모든 예외는 \u003ccode\u003eBaseException\u003c/code\u003e을 상속해야 함 [완료]\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__getitem__\u003c/code\u003e, \u003ccode\u003emessage\u003c/code\u003e 제거 [완료]\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e철회된 아이디어 (Retracted Ideas)\u003c/h2\u003e\n\u003cp\u003ePython 2.5에 구현되었던 이 PEP의 이전 버전에는 \u003ccode\u003eBaseException\u003c/code\u003e에 'message' 속성이 포함되어 있었습니다. 그 목적은 \u003ccode\u003eBaseException\u003c/code\u003e이 단일 인수만 받도록 전환을 시작하는 것이었습니다. 이는 인터페이스를 강화하고 사람들이 예외와 함께 임의의 정보를 \u003ccode\u003eargs\u003c/code\u003e에 모두 밀어넣는 대신 서브클래스의 속성에 저장하도록 강제하기 위함이었습니다.\u003c/p\u003e\n\u003cp\u003e불행히도, PyCon 2007 스프린트에서 Python 3.0의 \u003ccode\u003eargs\u003c/code\u003e 속성 제거를 구현하는 동안, 이 전환이 매우 고통스럽다는 것이 발견되었습니다. 특히 C 확장 모듈의 경우 더욱 그러했습니다. \u003ccode\u003emessage\u003c/code\u003e 속성을 Python 2.6에서 사용 중단하고 (Python 2.7 및 Python 3.0에서 제거) Python 3.0에서 \u003ccode\u003eBaseException\u003c/code\u003e의 다중 인수 지원을 제거하고 단일 인수를 받는 것을 선호하는 장기적인 전환 전략을 고려하는 것이 더 낫다고 결정되었습니다. 따라서 \u003ccode\u003emessage\u003c/code\u003e의 도입과 \u003ccode\u003eargs\u003c/code\u003e의 원래 사용 중단은 철회되었습니다.\u003c/p\u003e\n\u003ch2\u003e참고 자료 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e[1] \u003ccode\u003epython-dev\u003c/code\u003e Summary for 2004-08-01 through 2004-08-15\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://www.python.org/dev/summary/2004-08-01_2004-08-15.html#an-exception-is-an-exception-unless-it-doesn-t-inherit-from-exception\"\u003ehttp://www.python.org/dev/summary/2004-08-01_2004-08-15.html#an-exception-is-an-exception-unless-it-doesn-t-inherit-from-exception\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e[2] \u003ccode\u003epython-3000\u003c/code\u003e email (“How far to go with cleaning up exceptions”)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://mail.python.org/pipermail/python-3000/2007-March/005911.html\"\u003ehttps://mail.python.org/pipermail/python-3000/2007-March/005911.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNew-style exceptions 관련 이슈: \u003ccode\u003epython/cpython#41459\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e```\r\n# PEP 352 – 예외를 위한 필수 슈퍼클래스 (Required Superclass for Exceptions)\r\n\r\n*   **작성자:** Brett Cannon, Guido van Rossum\r\n*   **상태:** Final (최종)\r\n*   **유형:** Standards Track (표준 트랙)\r\n*   **작성일:** 2005년 10월 27일\r\n*   **Python 버전:** 2.5\r\n*   **번역 목표:** 이 PEP의 제안 내용, 도입 배경, 그리고 실제 Python 사용에 미치는 영향을 한국어 사용자가 명확하게 이해할 수 있도록 돕습니다.\r\n\r\n## 요약 (Abstract)\r\n\r\nPython 2.4 이하 버전에서는 어떤 (클래식) 클래스든 예외로 발생시킬 수 있었습니다. Python 2.5에서는 새로운 스타일 클래스(new-style classes)도 허용할 계획이었는데, 이는 문제를 더욱 악화시킬 수 있었습니다. 즉, 모든 클래스(또는 인스턴스)를 예외로 발생시킬 수 있다는 의미가 됩니다. 이는 예외의 인터페이스에 대한 어떤 보장도 할 수 없게 만들었기 때문에 문제였습니다. 이 PEP는 모든 예외로 발생하는 객체가 반드시 상속해야 하는 새로운 슈퍼클래스(superclass)를 도입할 것을 제안합니다. 이러한 제한을 두면 예외를 위한 표준 인터페이스가 존재하게 되어 신뢰할 수 있게 됩니다. 또한, 모든 예외가 준수해야 할 알려진 계층 구조를 갖게 됩니다.\r\n\r\n특정 인터페이스에 특정 기본 클래스를 요구하는 것이 Python답지 않다고 반박할 수도 있습니다. 하지만 예외의 경우, 충분히 합리적인 이유가 있습니다 (이는 `python-dev` 커뮤니티에서 일반적으로 동의되었습니다): 계층 구조를 요구하면 `except BaseException:` 대신 `except *:` 와 같이 작성하는 것이 가능해져서 모든 예외를 명시적으로 잡으려는 코드에 도움이 됩니다.\r\n\r\n예외를 위한 새로운 슈퍼클래스를 도입하는 것은 예외 계층 구조를 더 좋게 재구성할 기회도 제공합니다. 현재 상태에서는 내장(built-in) 네임스페이스에 있는 모든 예외는 `Exception`을 상속합니다. 이는 `KeyboardInterrupt`와 `SystemExit`라는 두 가지 예외를 포함하는데, 이들은 종종 애플리케이션의 예외 처리에서 제외되어야 할 필요가 있다는 점에서 문제가 됩니다. 일반적으로 트레이스백(traceback) 없이 인터프리터를 종료하는 기본 동작이 애플리케이션이 수행할 수 있는 어떤 동작보다 더 바람직하기 때문입니다 (Python의 대화형 명령 루프를 에뮬레이트하는 애플리케이션은 예외일 수 있습니다). 이 두 예외가 `Exception` 대신 공통 슈퍼클래스로부터 상속받도록 변경하면, 사람들이 과도하게 넓지 않은 `except` 절을 작성하여 전파되어야 할 예외를 잡지 않도록 쉽게 할 수 있습니다.\r\n\r\n이 PEP는 PEP 348의 이전 작업을 기반으로 합니다.\r\n\r\n## 공통 슈퍼클래스 요구 (Requiring a Common Superclass)\r\n\r\n이 PEP는 새로운 스타일 클래스이며 `args`라는 단일 속성을 가지는 `BaseException`이라는 새로운 예외를 도입할 것을 제안합니다. 다음은 Python 3.0에서 예외가 작동할 코드입니다 (Python 2.x에서의 작동 방식은 \"Transition Plan\" 섹션에서 다룹니다):\r\n\r\n```python\r\nclass BaseException(object):\r\n    \"\"\"예외 계층 구조의 기반을 나타내는 슈퍼클래스입니다.\r\n    생성자에 전달된 모든 인수를 포함하는 'args' 속성을 제공합니다.\r\n    하지만 권장되는 방식은 단일 문자열 인수만 생성자에 전달하는 것입니다.\r\n    \"\"\"\r\n    def __init__(self, *args):\r\n        self.args = args\r\n\r\n    def __str__(self):\r\n        if len(self.args) == 1:\r\n            return str(self.args[0])\r\n        else:\r\n            return str(self.args)\r\n\r\n    def __repr__(self):\r\n        return \"%s(*%s)\" % (self.__class__.__name__, repr(self.args))\r\n```\r\n\r\n하위 호환성(backwards-compatibility)을 위해 `args`에 전달될 수 있는 내용에는 제한이 없습니다. 하지만 실제로는 단일 문자열 인수만 사용해야 합니다. 이렇게 하면 예외의 문자열 표현이 사람이 읽을 수 있는 유용한 메시지가 됩니다. 이것이 `__str__` 메서드가 길이가 1인 `args` 값을 특별 처리하는 이유입니다. 프로그래밍 정보(예: 오류 코드 번호)는 서브클래스에 별도의 속성으로 저장되어야 합니다.\r\n\r\n`raise` 문은 전달되는 모든 객체가 `BaseException`을 상속해야 하도록 변경될 것입니다. 이는 모든 예외가 `BaseException`을 기반으로 하는 단일 계층 구조 내에 있도록 보장합니다. 또한 `BaseException`으로부터 상속되는 기본 인터페이스를 보장합니다. `raise`에 대한 변경 사항은 Python 3.0부터 적용될 것입니다 (아래 \"Transition Plan\" 참조).\r\n\r\n`BaseException`이 예외 계층 구조의 루트(root)가 되면서, `Exception`은 이제 `BaseException`으로부터 상속받게 됩니다.\r\n\r\n## 예외 계층 구조 변경 (Exception Hierarchy Changes)\r\n\r\n예외 계층 구조가 이제 기본적인 루트를 가지게 되어 더욱 중요해졌으므로, 기존 계층 구조의 변경이 필요합니다. 현재로서는 오류를 알리고 인터프리터가 종료되어서는 안 된다고 의미하는 모든 예외를 잡으려면, `except` 절에 두 가지 예외를 제외한 모든 예외를 구체적으로 지정하거나, 두 예외를 따로 잡은 다음 다시 `raise`하고 다른 모든 예외는 bare `except` 절로 넘어가도록 해야 합니다:\r\n\r\n```python\r\nexcept (KeyboardInterrupt, SystemExit):\r\n    raise\r\nexcept:\r\n    ...\r\n```\r\n\r\n이는 불필요하게 명시적입니다. 이 PEP는 `KeyboardInterrupt`와 `SystemExit`가 `BaseException`으로부터 직접 상속받도록 이동할 것을 제안합니다.\r\n\r\n*   `BaseException`\r\n    *   `KeyboardInterrupt`\r\n    *   `SystemExit`\r\n    *   `Exception`\r\n        *   (현재의 모든 다른 내장 예외들)\r\n\r\n이렇게 하면 `Exception`을 잡는 것이 더 합리적이 됩니다. 이는 오류를 나타내는 예외만 잡게 됩니다. 인터프리터가 종료되어야 함을 알리는 예외는 잡히지 않으므로 전파되어 인터프리터가 종료될 수 있도록 합니다.\r\n\r\n사용자들이 인터럽트 키(일반적으로 Ctrl-C)를 누르면 애플리케이션이 종료될 것으로 예상하기 때문에 `KeyboardInterrupt`가 이동되었습니다. 만약 사람들이 지나치게 넓은 `except` 절을 가지고 있다면 예상되는 동작이 발생하지 않습니다.\r\n\r\n`SystemExit`도 유사한 이유로 이동되었습니다. `sys.exit()`가 호출될 때 예외가 발생하므로, 인터프리터는 일반적으로 종료될 수 있어야 합니다. 불행히도 지나치게 넓은 `except` 절은 명시적으로 요청된 종료가 발생하지 않도록 막을 수 있습니다.\r\n\r\n사람들이 대부분의 경우 `Exception`을 잡도록 하기 위해, 문서와 튜토리얼의 여러 부분이 프로그래머들이 `Exception`을 사용하도록 강력하게 권장하도록 업데이트되어야 합니다. `KeyboardInterrupt`와 `SystemExit`는 거의 항상 전파되도록 허용되어야 한다는 사실에 기반하여, bare `except` 절 또는 `BaseException`을 직접 잡는 것은 권장되지 않아야 합니다.\r\n\r\n## 전환 계획 (Transition Plan)\r\n\r\nPython에 대한 의미론적 변경이 제안되므로 전환 계획이 필요합니다. 목표는 Python 3.0에서 새로운 의미론이 사용되도록 하면서도 2.x 코드에 대한 원활한 전환을 제공하는 것입니다. 계획에 언급된 모든 사용 중단(deprecation)은 초기 사용 중단 이후 버전부터 의미론의 제거로 이어질 것입니다.\r\n\r\n다음은 2.x 시리즈에서 구현된 `BaseException`입니다:\r\n\r\n```python\r\nclass BaseException(object):\r\n    \"\"\"예외 계층 구조의 기반을 나타내는 슈퍼클래스입니다.\r\n    __getitem__ 메서드는 하위 호환성을 위해 제공되며 언젠가 사용 중단될 것입니다.\r\n    'message' 속성도 사용 중단됩니다.\r\n    \"\"\"\r\n    def __init__(self, *args):\r\n        self.args = args\r\n\r\n    def __str__(self):\r\n        return str(self.args[0] if len(self.args) \u0026#x3C;= 1 else self.args)\r\n\r\n    def __repr__(self):\r\n        func_args = repr(self.args)\r\n        if self.args else \"()\"\r\n        return self.__class__.__name__ + func_args\r\n\r\n    def __getitem__(self, index):\r\n        \"\"\"인스턴스화 시 전달된 인수에 대한 인덱스입니다.\r\n        하위 호환성을 위해 제공되며 사용 중단될 것입니다.\r\n        \"\"\"\r\n        return self.args[index]\r\n\r\n    def _get_message(self):\r\n        \"\"\"'message' 속성을 위한 메서드입니다.\"\"\"\r\n        warnings.warn(\"the 'message' attribute has been deprecated \"\r\n                      \"since Python 2.6\")\r\n        return self.args[0] if len(self.args) == 1 else ''\r\n\r\n    message = property(_get_message, doc=\"access the 'message' attribute; \"\r\n                                         \"deprecated and provided only for \"\r\n                                         \"backwards-compatibility\")\r\n```\r\n\r\nPython 2.9에서의 기능 사용 중단은 선택 사항입니다. 이는 Python 2.9(2.x 시리즈의 마지막 버전으로 예정)가 3.0에 없을 기능을 적극적으로 사용 중단할지 여부가 현재로서는 알려지지 않았기 때문입니다. 2.9와 3.0 사이에 너무 큰 차이가 있어서 2.9가 경고 측면에서 너무 \"시끄러울\" 수 있기 때문에 2.9에서는 사용 중단 경고가 사용되지 않을 수도 있습니다. 따라서 Python 2.9에 대한 제안된 사용 중단 경고는 해당 버전 개발이 시작될 때 재검토되어 여전히 필요한지 여부가 결정될 것입니다.\r\n\r\n**Python 2.5 [완료]**\r\n*   모든 표준 예외가 new-style 클래스가 됨 [완료]\r\n*   `BaseException` 도입 [완료]\r\n*   `Exception`, `KeyboardInterrupt`, `SystemExit`가 `BaseException`으로부터 상속받음 [완료]\r\n*   문자열 예외(raising string exceptions) 사용 중단 [완료]\r\n\r\n**Python 2.6 [완료]**\r\n*   문자열 예외(catching string exceptions) 잡기 사용 중단 [완료]\r\n*   `message` 속성 사용 중단 (Retracted Ideas 참조) [완료]\r\n\r\n**Python 2.7 [완료]**\r\n*   `BaseException`을 상속하지 않는 예외 발생 사용 중단\r\n\r\n**Python 3.0 [완료]**\r\n*   위에서 사용 중단된 모든 것 제거:\r\n    *   문자열 예외 (발생 및 잡기 모두) [완료]\r\n    *   모든 예외는 `BaseException`을 상속해야 함 [완료]\r\n    *   `__getitem__`, `message` 제거 [완료]\r\n\r\n## 철회된 아이디어 (Retracted Ideas)\r\n\r\nPython 2.5에 구현되었던 이 PEP의 이전 버전에는 `BaseException`에 'message' 속성이 포함되어 있었습니다. 그 목적은 `BaseException`이 단일 인수만 받도록 전환을 시작하는 것이었습니다. 이는 인터페이스를 강화하고 사람들이 예외와 함께 임의의 정보를 `args`에 모두 밀어넣는 대신 서브클래스의 속성에 저장하도록 강제하기 위함이었습니다.\r\n\r\n불행히도, PyCon 2007 스프린트에서 Python 3.0의 `args` 속성 제거를 구현하는 동안, 이 전환이 매우 고통스럽다는 것이 발견되었습니다. 특히 C 확장 모듈의 경우 더욱 그러했습니다. `message` 속성을 Python 2.6에서 사용 중단하고 (Python 2.7 및 Python 3.0에서 제거) Python 3.0에서 `BaseException`의 다중 인수 지원을 제거하고 단일 인수를 받는 것을 선호하는 장기적인 전환 전략을 고려하는 것이 더 낫다고 결정되었습니다. 따라서 `message`의 도입과 `args`의 원래 사용 중단은 철회되었습니다.\r\n\r\n## 참고 자료 (References)\r\n\r\n*   `python-dev` Summary for 2004-08-01 through 2004-08-15\r\n    *   \u0026#x3C;http://www.python.org/dev/summary/2004-08-01_2004-08-15.html#an-exception-is-an-exception-unless-it-doesn-t-inherit-from-exception\u003e\r\n*   `python-3000` email (“How far to go with cleaning up exceptions”)\r\n    *   \u0026#x3C;https://mail.python.org/pipermail/python-3000/2007-March/005911.html\u003e\r\n\r\n*   New-style exceptions 관련 이슈: `python/cpython#41459`\r\n\r\n## 저작권 (Copyright)\r\n\r\n이 문서는 퍼블릭 도메인에 공개되었습니다.\r\n\r\n\u003e ⚠️ **알림:** 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\n\u003c/code\u003e\u003c/pre\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2224,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 352 - Required Superclass for Exceptions\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 18:59:06+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Le\",null,{\"postPermalink\":\"/python/pep/352/\",\"postId\":\"2025-09-26-pep-0352-required-superclass-for-exceptions\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/351/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 351 - The freeze protocol\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 352 - Required Superclass for Exceptions\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/353/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 353 - Using ssize_t as the index type\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>