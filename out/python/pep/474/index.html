<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-19cfc001fdac3337.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1098<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Withdrawn] PEP 474 - Creating forge.python.org</h1><div class="page__meta"><time dateTime="2025-09-26 22:21:06+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0474/">PEP 474 - Creating forge.python.org</a></p>
<p><strong>상태:</strong> Withdrawn | <strong>유형:</strong> Process | <strong>작성일:</strong> 19-Jul-2014</p>
</blockquote>
<h1>PEP 474 – forge.python.org 생성</h1>
<h2>개요</h2>
<p>이 PEP (Python Enhancement Proposal)는 새로운 PSF(Python Software Foundation) 제공 리소스인 <code>forge.python.org</code>를 설정하여, 새로운 기여자(contributor)들이 더 쉽게 접근하고, 핵심 개발자(core developer)들이 관리하기 더 용이한 방식으로 다양한 지원 저장소(supporting repositories) (예: Python Enhancement Proposals 저장소)를 유지 관리하는 것을 제안합니다.</p>
<p>이 PEP는 CPython 자체의 핵심 개발 워크플로우에는 어떠한 변경도 제안하지 않습니다. (관련 내용은 PEP 462를 참조하십시오.)</p>
<h2>PEP 철회</h2>
<p>이 PEP는 저자에 의해 철회되었으며, GitLab 기반 제안인 PEP 507을 지지합니다.
만약 다른 사람이 이 PEP를 이어서 추진하고 싶다면, <code>core-workflow</code> 메일링 리스트에 연락하십시오.</p>
<h2>제안</h2>
<p>이 PEP는 자체 호스팅(self-hosted) Kallithea 코드 저장소 관리 시스템의 인스턴스를 "forge.python.org"로 배포할 것을 제안합니다.</p>
<p>개별 저장소(예: 개발자 가이드 또는 PEP 저장소)는 기존 <code>hg.python.org</code> 인프라에서 새로운 <code>forge.python.org</code> 인프라로 개별적으로 마이그레이션될 수 있습니다. 각 마이그레이션은 <code>hg.python.org</code>에 읽기 전용 미러를 유지할지, 아니면 새 위치로 완전히 마이그레이션할지 결정해야 합니다.</p>
<p><code>hg.python.org</code>에 읽기 전용 미러를 지원하는 것 외에도, <code>forge.python.org</code>는 GitHub 및 BitBucket과 같은 인기 있는 독점 호스팅 사이트에 미러를 호스팅하는 것도 목표로 합니다. 목표는 이들 사이트에 익숙한 사용자들이 선호하는 워크플로우를 사용하여 Pull Request를 제출하고 논의할 수 있도록 하고, <code>forge.python.org</code>가 이러한 기여(contribution)를 마스터 저장소로 자동으로 가져오도록 하는 것입니다.</p>
<p>상업적으로 지원되는 "오픈 소스 프로젝트를 위한 무료" 저장소 호스팅 서비스의 가용성과 인기를 고려할 때, 이것은 임의의 Python 프로젝트를 위한 일반적인 호스팅 사이트가 아닙니다. 초기 초점은 특히 CPython 및 현재 <code>hg.python.org</code>에서 호스팅되는 다른 저장소에 맞춰질 것입니다. 미래에는 <code>python.org</code> Django 애플리케이션의 저장소와 같이 현재 외부에서 호스팅되고 있는 다른 PSF 관리 저장소를 통합하여 Pull Request 기반 워크플로우에 접근할 수 있도록 확장될 가능성이 있습니다. 초기 마이그레이션과 마찬가지로, 이러한 미래의 마이그레이션도 각 저장소의 주요 사용자의 선호도를 고려하여 개별적으로 검토될 것입니다.</p>
<h2>근거</h2>
<p>현재 <code>hg.python.org</code>는 핵심 CPython 저장소뿐만 아니라, CPython 개발자 가이드 및 Python Enhancement Proposals와 같은 다른 저장소와 핵심 개발자 실험을 위한 다양한 "샌드박스(sandbox)" 저장소도 호스팅하고 있습니다.</p>
<p>GitHub 및 BitBucket과 같은 코드 호스팅 사이트에서 인기를 얻은 간단한 "Pull Request" 스타일 워크플로우는 다양한 CPython 릴리스의 병렬 유지 관리 및 개발에 필요한 복잡한 브랜칭 모델에는 적합하지 않지만, 독점 호스팅 사이트로 옮기고 싶지 않은 CPython 주변의 여러 보조 프로젝트에는 잘 맞습니다.</p>
<p>PSF에서 제공하는 소프트웨어 포지(forge)에 제안된 주요 요구 사항은 다음과 같습니다.</p>
<ul>
<li>간단한 "Pull Request" 스타일 워크플로우를 지원해야 합니다.</li>
<li>간단한 변경을 위한 온라인 편집을 지원해야 합니다.</li>
<li>활발한 개발 조직(커뮤니티 또는 상업)의 지원을 받아야 합니다.</li>
<li>지속적인 비용 없이 PSF 인프라에 마스터 저장소의 자체 호스팅을 지원해야 합니다.</li>
</ul>
<p>이 제안에 의해 충족되지만, 충분히 설득력 있는 대안이 제시되면 협상될 수 있는 추가 권장 요구 사항은 다음과 같습니다.</p>
<ul>
<li>Python으로 작성된 완전한 오픈 소스 애플리케이션이어야 합니다.</li>
<li>Mercurial을 지원해야 합니다. (기존 도구와의 일관성을 위해)</li>
<li>Git을 지원해야 합니다. (선호하는 사용자에게 옵션을 제공하기 위해)</li>
<li>Git 및 Mercurial 클라이언트 사용자가 동일한 저장소에서 투명하게 협업할 수 있도록 허용해야 합니다.</li>
<li>GitHub 및 BitBucket 사용자가 해당 도구에서 제공하는 표준 Pull Request 워크플로우를 사용하여 제안된 변경 사항을 제출할 수 있도록 허용해야 합니다.</li>
<li>PEP 462에서 제안된 핵심 검토자 모델로의 잠재적인 경로를 제공하는 것을 포함하여, CPython 핵심 개발의 요구 사항을 충족하기 위한 사용자 정의에 개방적이어야 합니다.</li>
</ul>
<p>지속적인 비용 없이 자체 호스팅을 선호하는 것은 GitHub 및 BitBucket과 같은 "무료" 제공업체뿐만 아니라 다양한 독점 소스 코드 관리 서비스를 배제합니다.</p>
<p>Mercurial 지원에 대한 선호는 GitHub뿐만 아니라 GitLab 및 Gitorious와 같은 Git 전용 솔루션도 배제합니다.</p>
<p>온라인 편집 지원에 대한 엄격한 요구 사항은 Apache Allura/HgForge 조합을 배제합니다.</p>
<p>완전한 오픈 소스 솔루션에 대한 선호는 RhodeCode를 배제합니다.</p>
<p>이 제안의 저자가 고려한 다양한 옵션 중에서, Kallithea SCM이 <code>forge.python.org</code> 서비스의 제안된 기반으로 남습니다.</p>
<p>Kallithea는 Software Freedom Conservancy의 후원 아래 개발되고 있는 완전한 GPLv3 애플리케이션입니다. Conservancy는 Kallithea 코드베이스가 GPLv3에 따라 완전히 유효하게 라이선스되었음을 확인했습니다. 초기 Kallithea 커뮤니티를 구축하는 역할 외에도, Conservancy는 Mercurial 및 Git 프로젝트의 법적 본거지이기도 합니다. Python 사용자에게 익숙할 수 있는 다른 SFC 회원 프로젝트로는 Twisted, Gevent, BuildBot 및 PyPy가 있습니다.</p>
<h2>예상되는 이점</h2>
<p>Kallithea를 <code>forge.python.org</code>로 배포하는 주요 이점은 개발자 가이드 및 PEP 저장소와 같은 지원 저장소를 Pull Request 및 온라인 편집을 사용하여 관리할 수 있다는 것입니다. 이는 다른 사용자가 제안한 업데이트를 적용하기 위해 PEP 편집자 및 다른 핵심 개발자들이 중개자 역할을 해야 하는 현재 워크플로우보다 훨씬 간단할 것입니다.</p>
<p>더 풍부한 관리 기능은 사용자에게 전체 설치에 대한 일반적인 접근 권한을 부여하지 않고도 협업 목적으로 특정 저장소에 대한 접근 권한을 부여하는 것을 훨씬 쉽게 만들 것입니다. 이는 핵심 개발자 접근 권한 부여와 관련된 전면적인 결정(all-or-nothing decision)이 아니라, 신뢰를 점진적으로 더 쉽게 부여하고 얻을 수 있게 함으로써 진입 장벽을 낮추는 데 도움이 됩니다.</p>
<h2>지속 가능한 엔지니어링 고려 사항</h2>
<p>현재 워크플로우에서도 CPython 자체는 세계에서 가장 큰 오픈 소스 프로젝트 중 하나입니다. 그러나 CPython의 워크플로우 인프라를 구성하는 프로젝트에 대한 기여를 장려하는 데는 훨씬 덜 효과적이었습니다.</p>
<p>따라서 이 제안의 핵심 구성 요소는 Kallithea SCM을 사용하여 작업하는 데 대한 장벽을 낮추기 위해 업스트림 Kallithea 커뮤니티와 적극적으로 협력하고, <code>forge.python.org</code> 서비스가 PSF의 인프라 자동화와 깔끔하게 통합되도록 PSF 인프라 팀과 협력하는 것입니다.</p>
<p>이 접근 방식은 여러 가지 주요 이점을 제공하는 것을 목표로 합니다.</p>
<ul>
<li>이 서비스 유지 관리에 기여하는 사람들이 가용 시간 내에서 최대한 생산성을 높일 수 있도록 합니다.</li>
<li>이 서비스 유지 관리에 참여하기로 선택한 자원봉사자들에게 매력적인 전문 개발 기회를 제공합니다.</li>
<li>Kallithea 프로젝트 자체가 채택, 배포 및 관리가 가능한 한 쉽게 만들어서 다른 잠재 사용자들에게 더욱 매력적으로 만듭니다.</li>
<li>위의 이점으로 인해 업스트림 Kallithea 커뮤니티와 CPython 인프라 커뮤니티 모두에서 충분한 기여자(contributor)를 유치하여 <code>forge.python.org</code> 서비스가 변화하는 개발자 기대를 효과적으로 충족하도록 발전할 수 있도록 합니다.</li>
</ul>
<p>이러한 지속 가능한 엔지니어링 문제를 해결하기 위한 몇 가지 초기 단계가 이미 수행되었습니다.</p>
<ul>
<li>Tymoteusz Jankowski는 Donald Stufft와 함께 PSF의 Salt 기반 인프라 자동화를 사용하여 Kallithea를 배포하는 데 필요한 작업을 논의했습니다.</li>
<li>Graham Dumpleton과 저자는 Red Hat의 오픈 소스 호스팅 서비스인 OpenShift Online의 무료 티어에 데모 Kallithea 인스턴스를 쉽게 배포하는 작업을 진행했습니다.</li>
</ul>
<p>다음 주요 단계는 Windows, Mac OS X 및 Linux의 기여자(contributor)가 자신의 시스템 작동에 방해받지 않고 Kallithea 테스트를 로컬에서 실행할 수 있는 로컬 개발 워크플로우를 고안하는 것입니다. 현재 계획된 접근 방식은 테스트 목적으로 로컬 VM을 실행하는 개발자를 위해 특별히 고안된 인기 있는 자동화된 가상 머신 관리 시스템인 Vagrant에 중점을 두는 것입니다.</p>
<p>이러한 워크플로우 제안이 Kallithea에 잘 작동한다면, Roundup, BuildBot, 그리고 주요 <code>python.org</code> 웹사이트를 포함한 다른 PSF 및 CPython 인프라 서비스를 지원하는 업스트림 프로젝트에서도 사용을 제안할 가치가 있을 수 있습니다.</p>
<h2>개인적인 동기</h2>
<p>2015년 7월 현재, 저는 Red Hat에서 소프트웨어 개발 워크플로우 디자이너이자 프로세스 아키텍트(process architect)로 일하고 있으며, Fedora의 업스트림 개발자 경험에 중점을 두고 있습니다. 이러한 경험의 두 가지 핵심 요소는 많은 웹 서비스 개발자에게 익숙할 것입니다: 로컬 컨테이너 관리를 위한 Docker와 크로스 플랫폼 로컬 개발 VM 관리를 위한 Vagrant. 이러한 기술을 여러 업스트림 컨텍스트에 적용하는 데 시간을 할애하는 것은 Fedora에 잘 통합되어 있지만, 다른 Linux 배포판, Windows, Mac OS X에서도 쉽게 사용할 수 있는 좋은 소프트웨어 개발 경험을 제공하기 위해 무엇이 잘 작동하고 무엇이 여전히 개선이 필요한지에 대한 추가 통찰력을 제공하는 데 도움이 됩니다.</p>
<p>특히 코드 검토(code review) 워크플로우와 관련하여, 제가 경력 동안 사용한 주요 코드 검토 워크플로우 관리 도구는 Gerrit (세분화된 접근 제어 기능을 갖춘 다단계 코드 검토용), GitHub 및 BitBucket (기본 Pull Request 기반 워크플로우용), 그리고 Rietveld (CPython의 선택적 사전 커밋 검토용)입니다.</p>
<p>Kallithea는 현재 저장소 호스팅 및 코드 검토 관리 플랫폼을 결합한 프로젝트이지만, 온라인 병합을 제공함으로써 둘을 직접 통합하지는 않습니다. 이는 GitHub/BitBucket Pull Request 모델의 낮은 진입 장벽 이점과 Gerrit의 멘토링 및 작업 인계 이점을 Kallithea에 대한 온라인 코드 병합 모델을 정의하는 데 업스트림 Kallithea 개발자들과 협력하여 융합할 기회를 만듭니다.</p>
<h2>기술적 우려 사항 및 과제</h2>
<p>CPython 인프라에 새로운 서비스를 도입하는 것은 여러 가지 흥미로운 기술적 우려 사항과 과제를 제시합니다. 이 섹션에서는 가장 중요한 몇 가지를 다룹니다.</p>
<h3>서비스 호스팅</h3>
<p>이 PEP의 기본 입장은 새로운 <code>forge.python.org</code> 서비스가 기존 PSF Salt 인프라에 통합되어 PSF의 Rackspace 클라우드 인프라에서 호스팅될 것이라는 것입니다.</p>
<p>그러나 다른 호스팅 옵션도 고려될 것입니다. 특히 Google Container Engine 또는 Red Hat OpenShift Online 서비스의 차세대 버전에서 Kubernetes 호스팅 웹 서비스로 배포될 가능성이 있으며, <code>GCEPersistentDisk</code> 또는 오픈 소스 GlusterFS 분산 파일 시스템을 사용하여 소스 코드 저장소를 보관하는 방안도 있습니다.</p>
<h3>지속적인 인프라 유지 관리</h3>
<p>지속적인 인프라 유지 관리는 PSF 내에서 우려되는 영역입니다. 현재 Fedora Infrastructure Apprentice 또는 GNOME Infrastructure Apprentice 프로그램과 동등한 시스템 관리자 멘토십 프로그램이 부족하기 때문입니다.</p>
<p>대신 시스템은 주로 개발자들이 개발 관련 기여 외에 파트타임 활동으로 유지 관리하는 경향이 있습니다. 이는 개발(새로운 기능을 제공하거나 더 나은 사용자 경험을 제공하거나 기존 문제를 해결하기 위해 서비스를 변경하는 것)보다 운영(기존 시스템을 잘 작동시키는 것)에 더 관심 있는 사람들을 모집하는 대신입니다.</p>
<p>저는 미래에 PSF가 그러한 프로그램을 운영하기를 개인적으로 바라지만, 그러한 프로그램을 설정하는 것이 실현 가능한 단기 목표라고 생각하지 않습니다. 그러나 OpenStack 및 Salt와 같은 현대적인 인프라 기술의 PSF 기존 사용을 더 많은 서비스로 확장하고 컨테이너 및 컨테이너 플랫폼의 잠재적 이점을 탐색하기 시작함으로써 그러한 프로그램의 기반을 계속 마련하는 것은 실현 가능하다고 생각합니다.</p>
<p>또한 ManageIQ와 같은 오픈 소스 클라우드 관리 플랫폼이 Rackspace, Google, Amazon 및 기타 서비스 전반에 걸쳐 발생하는 "클라우드 확산" 문제를 더 잘 제어하는 데 도움이 될 수 있는지 여부에 대해서도 알아볼 계획입니다.</p>
<h3>사용자 계정 관리</h3>
<p>이상적으로는 Kallithea, Roundup/Rietveld, PyPI 및 새로운 <code>python.org</code> 사이트의 백엔드를 포함한 모든 <code>python.org</code> 서비스에 걸쳐 단일 계정을 제공할 수 있기를 원합니다. 그러나 실제로 이를 구현하는 것은 이 PEP와는 별개의 인프라 프로젝트가 될 것입니다.</p>
<p><code>forge.python.org</code>의 초기 출시를 위해 PSF 인프라 내에 또 다른 ID 사일로(identity silo)를 만들 가능성이 높습니다. 잠재적으로 더 나은 대안은 Kallithea에 <code>python-social-auth</code> 지원을 추가하는 것이지만, 실제로 그렇게 하는 것은 서비스의 초기 출시를 위한 요구 사항은 아닙니다. (주요 기술적 우려 사항은 Kallithea가 아직 Pyramid로 포팅되지 않은 Pylons 애플리케이션이므로, 통합을 위해서는 <code>python-social-auth</code>에 Pylons 백엔드를 추가하거나 Kallithea에서 Pyramid 마이그레이션을 시작해야 한다는 것입니다).</p>
<h3>Mercurial 저장소에 대한 기존 SSH 접근 및 링크 끊김</h3>
<p>이 PEP는 기존 <code>hg.python.org</code> 설치를 그대로 두고, 새로운 호스트에 Kallithea를 설정할 것을 제안합니다. 이 접근 방식은 CPython 자체의 개발(및 새 소프트웨어 포지로 마이그레이션하지 않는 다른 프로젝트)을 방해할 위험을 최소화하지만, 기존 저장소의 마이그레이션을 더 혼란스럽게 만듭니다 (기존 체크아웃이 중단되기 때문입니다).</p>
<h3>Roundup과의 통합</h3>
<p>Kallithea는 구성 가능한 이슈 트래커(issue tracker) 통합을 제공합니다. 이는 <code>forge.python.org</code> 서비스의 초기 출시 전에 <code>bugs.python.org</code>의 Roundup 이슈 트래커와 통합되도록 적절하게 설정되어야 합니다.</p>
<h3>GitHub 및 BitBucket에서 Pull Request 수락</h3>
<p><code>forge.python.org</code>의 초기 출시에서는 <code>hg.python.org</code> 및 기타 서비스 모두에 읽기 전용 미러(mirror) 게시를 지원할 것입니다. 이는 커밋 훅(commit hook)으로 구현할 수 있는 비교적 간단한 작업이기 때문입니다.</p>
<p>외부 서비스에서 Pull Request를 수락하고, 이를 <code>forge.python.org</code>의 마스터 저장소로 제출하는 것으로 미러링하는 것은 매우 바람직한 기능이지만, 더 복잡한 문제이며 <code>forge.python.org</code> 서비스의 초기 출시에는 포함되지 않을 가능성이 높습니다.</p>
<h3>투명한 Git 및 Mercurial 상호 운용성</h3>
<p>Kallithea의 Git 및 Mercurial 모두에 대한 기본 지원은 개발자가 <code>forge.python.org</code>에 호스팅된 저장소와 상호 작용하기 위해 선호하는 클라이언트를 사용하는 것을 비교적 간단하게 만들 수 있는 기회를 제공합니다.</p>
<p>이러한 투명한 상호 운용성은 아직 존재하지 않지만, 자체 다중-VCS(Version Control System) 저장소 호스팅 서비스를 운영함으로써, 상업적 이익이 아닐 가능성이 있는 기능을 제공하기 위해 독점 제공업체를 수동적으로 기다리는 대신, 이 기능을 현실화할 기회를 제공합니다. 오픈 소스 커뮤니티와 상업 제공업체 간에는 이 특정 영역에서 인센티브의 상당한 불일치가 있습니다. VCS 클라이언트 선택을 제공하는 것이 잠재적 기여자에게 특정 도구 선택을 강요하는 독단적인 결정을 프로젝트가 할 필요성을 없앰으로써 커뮤니션 마찰을 크게 줄일 수 있음에도 불구하고, 개발자 선호도와 관계없이 도구 선택을 위에서 아래로 강제하는 것이 현재 GitHub 및 Atlassian의 유료 고객을 생산하는 기업 및 기타 조직 환경에서 여전히 표준입니다.</p>
<p>수락 전에 투명한 상호 운용성이 없는 경우, 이 PEP는 <code>forge.python.org</code>에 호스팅된 Mercurial 저장소에 대한 Pull Request를 생성하기 위한 Git 사용자용 CPython 개발자 가이드 섹션에 포함될 특정 권장 사항을 제안해야 합니다.</p>
<h2>파일럿 목표 및 타임라인</h2>
<p>이 제안은 CPython 개발 워크플로우의 다양한 측면에 대한 Brett Cannon의 현재 개선 제안 평가의 일부입니다. 그 타임라인의 주요 날짜는 다음과 같습니다.</p>
<ul>
<li>2월 1일: 제안 초안 발행 (Kallithea의 경우, 이 PEP)</li>
<li>4월 8일: Python Language Summit에서 최종 제안 논의</li>
<li>5월 1일: Brett의 제안 수락 결정</li>
<li>9월 13일: Python 3.5 릴리스, Python 3.6에 새로운 워크플로우 채택</li>
</ul>
<p>이 제안이 추가 개발을 위해 선택되면, 다음 파일럿 배포(pilot deployment)부터 시작할 것을 제안합니다.</p>
<ul>
<li>최소한 개발자 가이드 및 PEP 저장소를 포함하는 <code>kallithea-pilot.python.org</code>에서 운영되는 참조 구현. 이는 "일회용(throwaway)" 인스턴스로, 핵심 개발자 및 다른 기여자(contributor)들이 저장소 히스토리에 대한 장기적인 결과에 대해 걱정하지 않고 자유롭게 실험할 수 있도록 합니다.</li>
<li>GitHub 및 BitBucket에 Kallithea 호스팅 저장소의 읽기 전용 라이브 미러. 파일럿 서비스 자체와 마찬가지로, 이들은 파일럿 기간 종료 후 폐기될 임시 저장소입니다.</li>
<li>이러한 미러를 사용하여 Kallithea 호스팅 Mercurial 저장소에 대한 Pull Request를 생성하는 방법에 대한 명확한 문서.</li>
<li>코드 검토 댓글 및 커밋 메시지의 이슈 참조를 <code>bugs.python.org</code>의 해당 이슈에 자동으로 연결.</li>
<li>Kallithea 기반 PEP 편집 및 제출 워크플로우를 설명하는 PEP 1에 대한 초안 업데이트.</li>
</ul>
<p>다음 항목들은 프로덕션 마이그레이션에 필요하지만, 파일럿의 일부로 업데이트된 구현을 시도할 명확한 방법은 없는 것으로 보입니다.</p>
<ul>
<li>PEP 게시 프로세스 및 개발자 가이드 게시 프로세스를 재배치된 Mercurial 저장소를 기반으로 조정.</li>
</ul>
<p>다음 항목들은 전체 워크플로우 개선 프로세스의 목표가 되겠지만, 9월에 새 서비스를 초기 채택하는 데 "바람직하지만 필수는 아님"으로 간주됩니다 (이 제안이 선택되고 제안된 파일럿 배포가 성공적인 경우).</p>
<ul>
<li><code>python-social-auth</code>를 사용하여 PSF 호스팅 Kallithea 인스턴스에 대한 인증 허용.</li>
<li>GitHub 및 BitBucket Pull Request 워크플로우를 사용하여 주 Kallithea 저장소에 Pull Request 제출 허용.</li>
<li>Kallithea 호스팅 저장소 및 Pull Request를 기반으로 BuildBot 실행을 쉽게 트리거 허용 (PEP 462 구현 전에는 주 CPython 저장소보다는 샌드박스 저장소와 함께 사용하기 위한 것임).</li>
</ul>
<h2>CPython 핵심 개발에 대한 미래 영향</h2>
<p>주 CPython 개발 저장소의 워크플로우 요구 사항은 이 PEP에서 논의되는 저장소의 요구 사항보다 훨씬 복잡합니다. 이러한 우려 사항은 PEP 462에서 더 자세히 다룹니다.</p>
<p>Guido의 권고에 따라 Rietveld를 더 활발하게 유지 관리되는 코드 검토 시스템으로 교체하기 위해, 현재 제 계획은 그 PEP를 Kallithea를 제안된 접착 계층(glue layer)으로 사용하여 다시 작성하고, 향상된 Kallithea Pull Request가 궁극적으로 이슈 트래커에 패치 파일을 직접 업로드하는 현재 관행을 대체하는 것입니다.</p>
<p>저는 또한 Pierre Yves-David와 함께 CPython 핵심 개발 워크플로우의 일부 측면을 자동화하는 사용자 정의 Mercurial 확장을 개발하기 시작했습니다.</p>
<h2>저작권</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<h1>PEP 474 – forge.python.org 생성</h1>
<h2>개요</h2>
<p>이 PEP (Python Enhancement Proposal)는 새로운 PSF(Python Software Foundation) 제공 리소스인 <code>forge.python.org</code>를 설정하여, 새로운 기여자(contributor)들이 더 쉽게 접근하고, 핵심 개발자(core developer)들이 관리하기 더 용이한 방식으로 다양한 지원 저장소(supporting repositories) (예: Python Enhancement Proposals 저장소)를 유지 관리하는 것을 제안합니다.</p>
<p>이 PEP는 CPython 자체의 핵심 개발 워크플로우에는 어떠한 변경도 제안하지 않습니다. (관련 내용은 PEP 462를 참조하십시오.)</p>
<h2>PEP 철회</h2>
<p>이 PEP는 저자에 의해 철회되었으며, GitLab 기반 제안인 PEP 507을 지지합니다.
만약 다른 사람이 이 PEP를 이어서 추진하고 싶다면, <code>core-workflow</code> 메일링 리스트에 연락하십시오.</p>
<h2>제안</h2>
<p>이 PEP는 자체 호스팅(self-hosted) Kallithea 코드 저장소 관리 시스템의 인스턴스를 "forge.python.org"로 배포할 것을 제안합니다.</p>
<p>개별 저장소(예: 개발자 가이드 또는 PEP 저장소)는 기존 <code>hg.python.org</code> 인프라에서 새로운 <code>forge.python.org</code> 인프라로 개별적으로 마이그레이션될 수 있습니다. 각 마이그레이션은 <code>hg.python.org</code>에 읽기 전용 미러를 유지할지, 아니면 새 위치로 완전히 마이그레이션할지 결정해야 합니다.</p>
<p><code>hg.python.org</code>에 읽기 전용 미러를 지원하는 것 외에도, <code>forge.python.org</code>는 GitHub 및 BitBucket과 같은 인기 있는 독점 호스팅 사이트에 미러를 호스팅하는 것도 목표로 합니다. 목표는 이들 사이트에 익숙한 사용자들이 선호하는 워크플로우를 사용하여 Pull Request를 제출하고 논의할 수 있도록 하고, <code>forge.python.org</code>가 이러한 기여(contribution)를 마스터 저장소로 자동으로 가져오도록 하는 것입니다.</p>
<p>상업적으로 지원되는 "오픈 소스 프로젝트를 위한 무료" 저장소 호스팅 서비스의 가용성과 인기를 고려할 때, 이것은 임의의 Python 프로젝트를 위한 일반적인 호스팅 사이트가 아닙니다. 초기 초점은 특히 CPython 및 현재 <code>hg.python.org</code>에서 호스팅되는 다른 저장소에 맞춰질 것입니다. 미래에는 <code>python.org</code> Django 애플리케이션의 저장소와 같이 현재 외부에서 호스팅되고 있는 다른 PSF 관리 저장소를 통합하여 Pull Request 기반 워크플로우에 접근할 수 있도록 확장될 가능성이 있습니다. 초기 마이그레이션과 마찬가지로, 이러한 미래의 마이그레이션도 각 저장소의 주요 사용자의 선호도를 고려하여 개별적으로 검토될 것입니다.</p>
<h2>근거</h2>
<p>현재 <code>hg.python.org</code>는 핵심 CPython 저장소뿐만 아니라, CPython 개발자 가이드 및 Python Enhancement Proposals와 같은 다른 저장소와 핵심 개발자 실험을 위한 다양한 "샌드박스(sandbox)" 저장소도 호스팅하고 있습니다.</p>
<p>GitHub 및 BitBucket과 같은 코드 호스팅 사이트에서 인기를 얻은 간단한 "Pull Request" 스타일 워크플로우는 다양한 CPython 릴리스의 병렬 유지 관리 및 개발에 필요한 복잡한 브랜칭 모델에는 적합하지 않지만, 독점 호스팅 사이트로 옮기고 싶지 않은 CPython 주변의 여러 보조 프로젝트에는 잘 맞습니다.</p>
<p>PSF에서 제공하는 소프트웨어 포지(forge)에 제안된 주요 요구 사항은 다음과 같습니다.</p>
<ul>
<li>간단한 "Pull Request" 스타일 워크플로우를 지원해야 합니다.</li>
<li>간단한 변경을 위한 온라인 편집을 지원해야 합니다.</li>
<li>활발한 개발 조직(커뮤니티 또는 상업)의 지원을 받아야 합니다.</li>
<li>지속적인 비용 없이 PSF 인프라에 마스터 저장소의 자체 호스팅을 지원해야 합니다.</li>
</ul>
<p>이 제안에 의해 충족되지만, 충분히 설득력 있는 대안이 제시되면 협상될 수 있는 추가 권장 요구 사항은 다음과 같습니다.</p>
<ul>
<li>Python으로 작성된 완전한 오픈 소스 애플리케이션이어야 합니다.</li>
<li>Mercurial을 지원해야 합니다. (기존 도구와의 일관성을 위해)</li>
<li>Git을 지원해야 합니다. (선호하는 사용자에게 옵션을 제공하기 위해)</li>
<li>Git 및 Mercurial 클라이언트 사용자가 동일한 저장소에서 투명하게 협업할 수 있도록 허용해야 합니다.</li>
<li>GitHub 및 BitBucket 사용자가 해당 도구에서 제공하는 표준 Pull Request 워크플로우를 사용하여 제안된 변경 사항을 제출할 수 있도록 허용해야 합니다.</li>
<li>PEP 462에서 제안된 핵심 검토자 모델로의 잠재적인 경로를 제공하는 것을 포함하여, CPython 핵심 개발의 요구 사항을 충족하기 위한 사용자 정의에 개방적이어야 합니다.</li>
</ul>
<p>지속적인 비용 없이 자체 호스팅을 선호하는 것은 GitHub 및 BitBucket과 같은 "무료" 제공업체뿐만 아니라 다양한 독점 소스 코드 관리 서비스를 배제합니다.</p>
<p>Mercurial 지원에 대한 선호는 GitHub뿐만 아니라 GitLab 및 Gitorious와 같은 Git 전용 솔루션도 배제합니다.</p>
<p>온라인 편집 지원에 대한 엄격한 요구 사항은 Apache Allura/HgForge 조합을 배제합니다.</p>
<p>완전한 오픈 소스 솔루션에 대한 선호는 RhodeCode를 배제합니다.</p>
<p>이 제안의 저자가 고려한 다양한 옵션 중에서, Kallithea SCM이 <code>forge.python.org</code> 서비스의 제안된 기반으로 남습니다.</p>
<p>Kallithea는 Software Freedom Conservancy의 후원 아래 개발되고 있는 완전한 GPLv3 애플리케이션입니다. Conservancy는 Kallithea 코드베이스가 GPLv3에 따라 완전히 유효하게 라이선스되었음을 확인했습니다. 초기 Kallithea 커뮤니티를 구축하는 역할 외에도, Conservancy는 Mercurial 및 Git 프로젝트의 법적 본거지이기도 합니다. Python 사용자에게 익숙할 수 있는 다른 SFC 회원 프로젝트로는 Twisted, Gevent, BuildBot 및 PyPy가 있습니다.</p>
<h2>예상되는 이점</h2>
<p>Kallithea를 <code>forge.python.org</code>로 배포하는 주요 이점은 개발자 가이드 및 PEP 저장소와 같은 지원 저장소를 Pull Request 및 온라인 편집을 사용하여 관리할 수 있다는 것입니다. 이는 다른 사용자가 제안한 업데이트를 적용하기 위해 PEP 편집자 및 다른 핵심 개발자들이 중개자 역할을 해야 하는 현재 워크플로우보다 훨씬 간단할 것입니다.</p>
<p>더 풍부한 관리 기능은 사용자에게 전체 설치에 대한 일반적인 접근 권한을 부여하지 않고도 협업 목적으로 특정 저장소에 대한 접근 권한을 부여하는 것을 훨씬 쉽게 만들 것입니다. 이는 핵심 개발자 접근 권한 부여와 관련된 전면적인 결정(all-or-nothing decision)이 아니라, 신뢰를 점진적으로 더 쉽게 부여하고 얻을 수 있게 함으로써 진입 장벽을 낮추는 데 도움이 됩니다.</p>
<h2>지속 가능한 엔지니어링 고려 사항</h2>
<p>현재 워크플로우에서도 CPython 자체는 세계에서 가장 큰 오픈 소스 프로젝트 중 하나입니다. 그러나 CPython의 워크플로우 인프라를 구성하는 프로젝트에 대한 기여를 장려하는 데는 훨씬 덜 효과적이었습니다.</p>
<p>따라서 이 제안의 핵심 구성 요소는 Kallithea SCM을 사용하여 작업하는 데 대한 장벽을 낮추기 위해 업스트림 Kallithea 커뮤니티와 적극적으로 협력하고, <code>forge.python.org</code> 서비스가 PSF의 인프라 자동화와 깔끔하게 통합되도록 PSF 인프라 팀과 협력하는 것입니다.</p>
<p>이 접근 방식은 여러 가지 주요 이점을 제공하는 것을 목표로 합니다.</p>
<ul>
<li>이 서비스 유지 관리에 기여하는 사람들이 가용 시간 내에서 최대한 생산성을 높일 수 있도록 합니다.</li>
<li>이 서비스 유지 관리에 참여하기로 선택한 자원봉사자들에게 매력적인 전문 개발 기회를 제공합니다.</li>
<li>Kallithea 프로젝트 자체가 채택, 배포 및 관리가 가능한 한 쉽게 만들어서 다른 잠재 사용자들에게 더욱 매력적으로 만듭니다.</li>
<li>위의 이점으로 인해 업스트림 Kallithea 커뮤니티와 CPython 인프라 커뮤니티 모두에서 충분한 기여자(contributor)를 유치하여 <code>forge.python.org</code> 서비스가 변화하는 개발자 기대를 효과적으로 충족하도록 발전할 수 있도록 합니다.</li>
</ul>
<p>이러한 지속 가능한 엔지니어링 문제를 해결하기 위한 몇 가지 초기 단계가 이미 수행되었습니다.</p>
<ul>
<li>Tymoteusz Jankowski는 Donald Stufft와 함께 PSF의 Salt 기반 인프라 자동화를 사용하여 Kallithea를 배포하는 데 필요한 작업을 논의했습니다.</li>
<li>Graham Dumpleton과 저자는 Red Hat의 오픈 소스 호스팅 서비스인 OpenShift Online의 무료 티어에 데모 Kallithea 인스턴스를 쉽게 배포하는 작업을 진행했습니다.</li>
</ul>
<p>다음 주요 단계는 Windows, Mac OS X 및 Linux의 기여자(contributor)가 자신의 시스템 작동에 방해받지 않고 Kallithea 테스트를 로컬에서 실행할 수 있는 로컬 개발 워크플로우를 고안하는 것입니다. 현재 계획된 접근 방식은 테스트 목적으로 로컬 VM을 실행하는 개발자를 위해 특별히 고안된 인기 있는 자동화된 가상 머신 관리 시스템인 Vagrant에 중점을 두는 것입니다.</p>
<p>이러한 워크플로우 제안이 Kallithea에 잘 작동한다면, Roundup, BuildBot, 그리고 주요 <code>python.org</code> 웹사이트를 포함한 다른 PSF 및 CPython 인프라 서비스를 지원하는 업스트림 프로젝트에서도 사용을 제안할 가치가 있을 수 있습니다.</p>
<h2>개인적인 동기</h2>
<p>2015년 7월 현재, 저는 Red Hat에서 소프트웨어 개발 워크플로우 디자이너이자 프로세스 아키텍트(process architect)로 일하고 있으며, Fedora의 업스트림 개발자 경험에 중점을 두고 있습니다. 이러한 경험의 두 가지 핵심 요소는 많은 웹 서비스 개발자에게 익숙할 것입니다: 로컬 컨테이너 관리를 위한 Docker와 크로스 플랫폼 로컬 개발 VM 관리를 위한 Vagrant. 이러한 기술을 여러 업스트림 컨텍스트에 적용하는 데 시간을 할애하는 것은 Fedora에 잘 통합되어 있지만, 다른 Linux 배포판, Windows, Mac OS X에서도 쉽게 사용할 수 있는 좋은 소프트웨어 개발 경험을 제공하기 위해 무엇이 잘 작동하고 무엇이 여전히 개선이 필요한지에 대한 추가 통찰력을 제공하는 데 도움이 됩니다.</p>
<p>특히 코드 검토(code review) 워크플로우와 관련하여, 제가 경력 동안 사용한 주요 코드 검토 워크플로우 관리 도구는 Gerrit (세분화된 접근 제어 기능을 갖춘 다단계 코드 검토용), GitHub 및 BitBucket (기본 Pull Request 기반 워크플로우용), 그리고 Rietveld (CPython의 선택적 사전 커밋 검토용)입니다.</p>
<p>Kallithea는 현재 저장소 호스팅 및 코드 검토 관리 플랫폼을 결합한 프로젝트이지만, 온라인 병합을 제공함으로써 둘을 직접 통합하지는 않습니다. 이는 GitHub/BitBucket Pull Request 모델의 낮은 진입 장벽 이점과 Gerrit의 멘토링 및 작업 인계 이점을 Kallithea에 대한 온라인 코드 병합 모델을 정의하는 데 업스트림 Kallithea 개발자들과 협력하여 융합할 기회를 만듭니다.</p>
<h2>기술적 우려 사항 및 과제</h2>
<p>CPython 인프라에 새로운 서비스를 도입하는 것은 여러 가지 흥미로운 기술적 우려 사항과 과제를 제시합니다. 이 섹션에서는 가장 중요한 몇 가지를 다룹니다.</p>
<h3>서비스 호스팅</h3>
<p>이 PEP의 기본 입장은 새로운 <code>forge.python.org</code> 서비스가 기존 PSF Salt 인프라에 통합되어 PSF의 Rackspace 클라우드 인프라에서 호스팅될 것이라는 것입니다.</p>
<p>그러나 다른 호스팅 옵션도 고려될 것입니다. 특히 Google Container Engine 또는 Red Hat OpenShift Online 서비스의 차세대 버전에서 Kubernetes 호스팅 웹 서비스로 배포될 가능성이 있으며, <code>GCEPersistentDisk</code> 또는 오픈 소스 GlusterFS 분산 파일 시스템을 사용하여 소스 코드 저장소를 보관하는 방안도 있습니다.</p>
<h3>지속적인 인프라 유지 관리</h3>
<p>지속적인 인프라 유지 관리는 PSF 내에서 우려되는 영역입니다. 현재 Fedora Infrastructure Apprentice 또는 GNOME Infrastructure Apprentice 프로그램과 동등한 시스템 관리자 멘토십 프로그램이 부족하기 때문입니다.</p>
<p>대신 시스템은 주로 개발자들이 개발 관련 기여 외에 파트타임 활동으로 유지 관리하는 경향이 있습니다. 이는 개발(새로운 기능을 제공하거나 더 나은 사용자 경험을 제공하거나 기존 문제를 해결하기 위해 서비스를 변경하는 것)보다 운영(기존 시스템을 잘 작동시키는 것)에 더 관심 있는 사람들을 모집하는 대신입니다.</p>
<p>저는 미래에 PSF가 그러한 프로그램을 운영하기를 개인적으로 바라지만, 그러한 프로그램을 설정하는 것이 실현 가능한 단기 목표라고 생각하지 않습니다. 그러나 OpenStack 및 Salt와 같은 현대적인 인프라 기술의 PSF 기존 사용을 더 많은 서비스로 확장하고 컨테이너 및 컨테이너 플랫폼의 잠재적 이점을 탐색하기 시작함으로써 그러한 프로그램의 기반을 계속 마련하는 것은 실현 가능하다고 생각합니다.</p>
<p>또한 ManageIQ와 같은 오픈 소스 클라우드 관리 플랫폼이 Rackspace, Google, Amazon 및 기타 서비스 전반에 걸쳐 발생하는 "클라우드 확산" 문제를 더 잘 제어하는 데 도움이 될 수 있는지 여부에 대해서도 알아볼 계획입니다.</p>
<h3>사용자 계정 관리</h3>
<p>이상적으로는 Kallithea, Roundup/Rietveld, PyPI 및 새로운 <code>python.org</code> 사이트의 백엔드를 포함한 모든 <code>python.org</code> 서비스에 걸쳐 단일 계정을 제공할 수 있기를 원합니다. 그러나 실제로 이를 구현하는 것은 이 PEP와는 별개의 인프라 프로젝트가 될 것입니다.</p>
<p><code>forge.python.org</code>의 초기 출시를 위해 PSF 인프라 내에 또 다른 ID 사일로(identity silo)를 만들 가능성이 높습니다. 잠재적으로 더 나은 대안은 Kallithea에 <code>python-social-auth</code> 지원을 추가하는 것이지만, 실제로 그렇게 하는 것은 서비스의 초기 출시를 위한 요구 사항은 아닙니다. (주요 기술적 우려 사항은 Kallithea가 아직 Pyramid로 포팅되지 않은 Pylons 애플리케이션이므로, 통합을 위해서는 <code>python-social-auth</code>에 Pylons 백엔드를 추가하거나 Kallithea에서 Pyramid 마이그레이션을 시작해야 한다는 것입니다).</p>
<h3>Mercurial 저장소에 대한 기존 SSH 접근 및 링크 끊김</h3>
<p>이 PEP는 기존 <code>hg.python.org</code> 설치를 그대로 두고, 새로운 호스트에 Kallithea를 설정할 것을 제안합니다. 이 접근 방식은 CPython 자체의 개발(및 새 소프트웨어 포지로 마이그레이션하지 않는 다른 프로젝트)을 방해할 위험을 최소화하지만, 기존 저장소의 마이그레이션을 더 혼란스럽게 만듭니다 (기존 체크아웃이 중단되기 때문입니다).</p>
<h3>Roundup과의 통합</h3>
<p>Kallithea는 구성 가능한 이슈 트래커(issue tracker) 통합을 제공합니다. 이는 <code>forge.python.org</code> 서비스의 초기 출시 전에 <code>bugs.python.org</code>의 Roundup 이슈 트래커와 통합되도록 적절하게 설정되어야 합니다.</p>
<h3>GitHub 및 BitBucket에서 Pull Request 수락</h3>
<p><code>forge.python.org</code>의 초기 출시에서는 <code>hg.python.org</code> 및 기타 서비스 모두에 읽기 전용 미러(mirror) 게시를 지원할 것입니다. 이는 커밋 훅(commit hook)으로 구현할 수 있는 비교적 간단한 작업이기 때문입니다.</p>
<p>외부 서비스에서 Pull Request를 수락하고, 이를 <code>forge.python.org</code>의 마스터 저장소로 제출하는 것으로 미러링하는 것은 매우 바람직한 기능이지만, 더 복잡한 문제이며 <code>forge.python.org</code> 서비스의 초기 출시에는 포함되지 않을 가능성이 높습니다.</p>
<h3>투명한 Git 및 Mercurial 상호 운용성</h3>
<p>Kallithea의 Git 및 Mercurial 모두에 대한 기본 지원은 개발자가 <code>forge.python.org</code>에 호스팅된 저장소와 상호 작용하기 위해 선호하는 클라이언트를 사용하는 것을 비교적 간단하게 만들 수 있는 기회를 제공합니다.</p>
<p>이러한 투명한 상호 운용성은 아직 존재하지 않지만, 자체 다중-VCS(Version Control System) 저장소 호스팅 서비스를 운영함으로써, 상업적 이익이 아닐 가능성이 있는 기능을 제공하기 위해 독점 제공업체를 수동적으로 기다리는 대신, 이 기능을 현실화할 기회를 제공합니다. 오픈 소스 커뮤니티와 상업 제공업체 간에는 이 특정 영역에서 인센티브의 상당한 불일치가 있습니다. VCS 클라이언트 선택을 제공하는 것이 잠재적 기여자에게 특정 도구 선택을 강요하는 독단적인 결정을 프로젝트가 할 필요성을 없앰으로써 커뮤니션 마찰을 크게 줄일 수 있음에도 불구하고, 개발자 선호도와 관계없이 도구 선택을 위에서 아래로 강제하는 것이 현재 GitHub 및 Atlassian의 유료 고객을 생산하는 기업 및 기타 조직 환경에서 여전히 표준입니다.</p>
<p>수락 전에 투명한 상호 운용성이 없는 경우, 이 PEP는 <code>forge.python.org</code>에 호스팅된 Mercurial 저장소에 대한 Pull Request를 생성하기 위한 Git 사용자용 CPython 개발자 가이드 섹션에 포함될 특정 권장 사항을 제안해야 합니다.</p>
<h2>파일럿 목표 및 타임라인</h2>
<p>이 제안은 CPython 개발 워크플로우의 다양한 측면에 대한 Brett Cannon의 현재 개선 제안 평가의 일부입니다. 그 타임라인의 주요 날짜는 다음과 같습니다.</p>
<ul>
<li>2월 1일: 제안 초안 발행 (Kallithea의 경우, 이 PEP)</li>
<li>4월 8일: Python Language Summit에서 최종 제안 논의</li>
<li>5월 1일: Brett의 제안 수락 결정</li>
<li>9월 13일: Python 3.5 릴리스, Python 3.6에 새로운 워크플로우 채택</li>
</ul>
<p>이 제안이 추가 개발을 위해 선택되면, 다음 파일럿 배포(pilot deployment)부터 시작할 것을 제안합니다.</p>
<ul>
<li>최소한 개발자 가이드 및 PEP 저장소를 포함하는 <code>kallithea-pilot.python.org</code>에서 운영되는 참조 구현. 이는 "일회용(throwaway)" 인스턴스로, 핵심 개발자 및 다른 기여자(contributor)들이 저장소 히스토리에 대한 장기적인 결과에 대해 걱정하지 않고 자유롭게 실험할 수 있도록 합니다.</li>
<li>GitHub 및 BitBucket에 Kallithea 호스팅 저장소의 읽기 전용 라이브 미러. 파일럿 서비스 자체와 마찬가지로, 이들은 파일럿 기간 종료 후 폐기될 임시 저장소입니다.</li>
<li>이러한 미러를 사용하여 Kallithea 호스팅 Mercurial 저장소에 대한 Pull Request를 생성하는 방법에 대한 명확한 문서.</li>
<li>코드 검토 댓글 및 커밋 메시지의 이슈 참조를 <code>bugs.python.org</code>의 해당 이슈에 자동으로 연결.</li>
<li>Kallithea 기반 PEP 편집 및 제출 워크플로우를 설명하는 PEP 1에 대한 초안 업데이트.</li>
</ul>
<p>다음 항목들은 프로덕션 마이그레이션에 필요하지만, 파일럿의 일부로 업데이트된 구현을 시도할 명확한 방법은 없는 것으로 보입니다.</p>
<ul>
<li>PEP 게시 프로세스 및 개발자 가이드 게시 프로세스를 재배치된 Mercurial 저장소를 기반으로 조정.</li>
</ul>
<p>다음 항목들은 전체 워크플로우 개선 프로세스의 목표가 되겠지만, 9월에 새 서비스를 초기 채택하는 데 "바람직하지만 필수는 아님"으로 간주됩니다 (이 제안이 선택되고 제안된 파일럿 배포가 성공적인 경우).</p>
<ul>
<li><code>python-social-auth</code>를 사용하여 PSF 호스팅 Kallithea 인스턴스에 대한 인증 허용.</li>
<li>GitHub 및 BitBucket Pull Request 워크플로우를 사용하여 주 Kallithea 저장소에 Pull Request 제출 허용.</li>
<li>Kallithea 호스팅 저장소 및 Pull Request를 기반으로 BuildBot 실행을 쉽게 트리거 허용 (PEP 462 구현 전에는 주 CPython 저장소보다는 샌드박스 저장소와 함께 사용하기 위한 것임).</li>
</ul>
<h2>CPython 핵심 개발에 대한 미래 영향</h2>
<p>주 CPython 개발 저장소의 워크플로우 요구 사항은 이 PEP에서 논의되는 저장소의 요구 사항보다 훨씬 복잡합니다. 이러한 우려 사항은 PEP 462에서 더 자세히 다룹니다.</p>
<p>Guido의 권고에 따라 Rietveld를 더 활발하게 유지 관리되는 코드 검토 시스템으로 교체하기 위해, 현재 제 계획은 그 PEP를 Kallithea를 제안된 접착 계층(glue layer)으로 사용하여 다시 작성하고, 향상된 Kallithea Pull Request가 궁극적으로 이슈 트래커에 패치 파일을 직접 업로드하는 현재 관행을 대체하는 것입니다.</p>
<p>저는 또한 Pierre Yves-David와 함께 CPython 핵심 개발 워크플로우의 일부 측면을 자동화하는 사용자 정의 Mercurial 확장을 개발하기 시작했습니다.</p>
<h2>저작권</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-19cfc001fdac3337.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/474\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"FeyCvJug7In7AgUZlfHUx\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/474/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/474\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"474\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/474\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:Tb30e,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0474/\"\u003ePEP 474 - Creating forge.python.org\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Withdrawn | \u003cstrong\u003e유형:\u003c/strong\u003e Process | \u003cstrong\u003e작성일:\u003c/strong\u003e 19-Jul-2014\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 474 – forge.python.org 생성\u003c/h1\u003e\n\u003ch2\u003e개요\u003c/h2\u003e\n\u003cp\u003e이 PEP (Python Enhancement Proposal)는 새로운 PSF(Python Software Foundation) 제공 리소스인 \u003ccode\u003eforge.python.org\u003c/code\u003e를 설정하여, 새로운 기여자(contributor)들이 더 쉽게 접근하고, 핵심 개발자(core developer)들이 관리하기 더 용이한 방식으로 다양한 지원 저장소(supporting repositories) (예: Python Enhancement Proposals 저장소)를 유지 관리하는 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 CPython 자체의 핵심 개발 워크플로우에는 어떠한 변경도 제안하지 않습니다. (관련 내용은 PEP 462를 참조하십시오.)\u003c/p\u003e\n\u003ch2\u003ePEP 철회\u003c/h2\u003e\n\u003cp\u003e이 PEP는 저자에 의해 철회되었으며, GitLab 기반 제안인 PEP 507을 지지합니다.\r\n만약 다른 사람이 이 PEP를 이어서 추진하고 싶다면, \u003ccode\u003ecore-workflow\u003c/code\u003e 메일링 리스트에 연락하십시오.\u003c/p\u003e\n\u003ch2\u003e제안\u003c/h2\u003e\n\u003cp\u003e이 PEP는 자체 호스팅(self-hosted) Kallithea 코드 저장소 관리 시스템의 인스턴스를 \"forge.python.org\"로 배포할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e개별 저장소(예: 개발자 가이드 또는 PEP 저장소)는 기존 \u003ccode\u003ehg.python.org\u003c/code\u003e 인프라에서 새로운 \u003ccode\u003eforge.python.org\u003c/code\u003e 인프라로 개별적으로 마이그레이션될 수 있습니다. 각 마이그레이션은 \u003ccode\u003ehg.python.org\u003c/code\u003e에 읽기 전용 미러를 유지할지, 아니면 새 위치로 완전히 마이그레이션할지 결정해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehg.python.org\u003c/code\u003e에 읽기 전용 미러를 지원하는 것 외에도, \u003ccode\u003eforge.python.org\u003c/code\u003e는 GitHub 및 BitBucket과 같은 인기 있는 독점 호스팅 사이트에 미러를 호스팅하는 것도 목표로 합니다. 목표는 이들 사이트에 익숙한 사용자들이 선호하는 워크플로우를 사용하여 Pull Request를 제출하고 논의할 수 있도록 하고, \u003ccode\u003eforge.python.org\u003c/code\u003e가 이러한 기여(contribution)를 마스터 저장소로 자동으로 가져오도록 하는 것입니다.\u003c/p\u003e\n\u003cp\u003e상업적으로 지원되는 \"오픈 소스 프로젝트를 위한 무료\" 저장소 호스팅 서비스의 가용성과 인기를 고려할 때, 이것은 임의의 Python 프로젝트를 위한 일반적인 호스팅 사이트가 아닙니다. 초기 초점은 특히 CPython 및 현재 \u003ccode\u003ehg.python.org\u003c/code\u003e에서 호스팅되는 다른 저장소에 맞춰질 것입니다. 미래에는 \u003ccode\u003epython.org\u003c/code\u003e Django 애플리케이션의 저장소와 같이 현재 외부에서 호스팅되고 있는 다른 PSF 관리 저장소를 통합하여 Pull Request 기반 워크플로우에 접근할 수 있도록 확장될 가능성이 있습니다. 초기 마이그레이션과 마찬가지로, 이러한 미래의 마이그레이션도 각 저장소의 주요 사용자의 선호도를 고려하여 개별적으로 검토될 것입니다.\u003c/p\u003e\n\u003ch2\u003e근거\u003c/h2\u003e\n\u003cp\u003e현재 \u003ccode\u003ehg.python.org\u003c/code\u003e는 핵심 CPython 저장소뿐만 아니라, CPython 개발자 가이드 및 Python Enhancement Proposals와 같은 다른 저장소와 핵심 개발자 실험을 위한 다양한 \"샌드박스(sandbox)\" 저장소도 호스팅하고 있습니다.\u003c/p\u003e\n\u003cp\u003eGitHub 및 BitBucket과 같은 코드 호스팅 사이트에서 인기를 얻은 간단한 \"Pull Request\" 스타일 워크플로우는 다양한 CPython 릴리스의 병렬 유지 관리 및 개발에 필요한 복잡한 브랜칭 모델에는 적합하지 않지만, 독점 호스팅 사이트로 옮기고 싶지 않은 CPython 주변의 여러 보조 프로젝트에는 잘 맞습니다.\u003c/p\u003e\n\u003cp\u003ePSF에서 제공하는 소프트웨어 포지(forge)에 제안된 주요 요구 사항은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e간단한 \"Pull Request\" 스타일 워크플로우를 지원해야 합니다.\u003c/li\u003e\n\u003cli\u003e간단한 변경을 위한 온라인 편집을 지원해야 합니다.\u003c/li\u003e\n\u003cli\u003e활발한 개발 조직(커뮤니티 또는 상업)의 지원을 받아야 합니다.\u003c/li\u003e\n\u003cli\u003e지속적인 비용 없이 PSF 인프라에 마스터 저장소의 자체 호스팅을 지원해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 제안에 의해 충족되지만, 충분히 설득력 있는 대안이 제시되면 협상될 수 있는 추가 권장 요구 사항은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePython으로 작성된 완전한 오픈 소스 애플리케이션이어야 합니다.\u003c/li\u003e\n\u003cli\u003eMercurial을 지원해야 합니다. (기존 도구와의 일관성을 위해)\u003c/li\u003e\n\u003cli\u003eGit을 지원해야 합니다. (선호하는 사용자에게 옵션을 제공하기 위해)\u003c/li\u003e\n\u003cli\u003eGit 및 Mercurial 클라이언트 사용자가 동일한 저장소에서 투명하게 협업할 수 있도록 허용해야 합니다.\u003c/li\u003e\n\u003cli\u003eGitHub 및 BitBucket 사용자가 해당 도구에서 제공하는 표준 Pull Request 워크플로우를 사용하여 제안된 변경 사항을 제출할 수 있도록 허용해야 합니다.\u003c/li\u003e\n\u003cli\u003ePEP 462에서 제안된 핵심 검토자 모델로의 잠재적인 경로를 제공하는 것을 포함하여, CPython 핵심 개발의 요구 사항을 충족하기 위한 사용자 정의에 개방적이어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e지속적인 비용 없이 자체 호스팅을 선호하는 것은 GitHub 및 BitBucket과 같은 \"무료\" 제공업체뿐만 아니라 다양한 독점 소스 코드 관리 서비스를 배제합니다.\u003c/p\u003e\n\u003cp\u003eMercurial 지원에 대한 선호는 GitHub뿐만 아니라 GitLab 및 Gitorious와 같은 Git 전용 솔루션도 배제합니다.\u003c/p\u003e\n\u003cp\u003e온라인 편집 지원에 대한 엄격한 요구 사항은 Apache Allura/HgForge 조합을 배제합니다.\u003c/p\u003e\n\u003cp\u003e완전한 오픈 소스 솔루션에 대한 선호는 RhodeCode를 배제합니다.\u003c/p\u003e\n\u003cp\u003e이 제안의 저자가 고려한 다양한 옵션 중에서, Kallithea SCM이 \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스의 제안된 기반으로 남습니다.\u003c/p\u003e\n\u003cp\u003eKallithea는 Software Freedom Conservancy의 후원 아래 개발되고 있는 완전한 GPLv3 애플리케이션입니다. Conservancy는 Kallithea 코드베이스가 GPLv3에 따라 완전히 유효하게 라이선스되었음을 확인했습니다. 초기 Kallithea 커뮤니티를 구축하는 역할 외에도, Conservancy는 Mercurial 및 Git 프로젝트의 법적 본거지이기도 합니다. Python 사용자에게 익숙할 수 있는 다른 SFC 회원 프로젝트로는 Twisted, Gevent, BuildBot 및 PyPy가 있습니다.\u003c/p\u003e\n\u003ch2\u003e예상되는 이점\u003c/h2\u003e\n\u003cp\u003eKallithea를 \u003ccode\u003eforge.python.org\u003c/code\u003e로 배포하는 주요 이점은 개발자 가이드 및 PEP 저장소와 같은 지원 저장소를 Pull Request 및 온라인 편집을 사용하여 관리할 수 있다는 것입니다. 이는 다른 사용자가 제안한 업데이트를 적용하기 위해 PEP 편집자 및 다른 핵심 개발자들이 중개자 역할을 해야 하는 현재 워크플로우보다 훨씬 간단할 것입니다.\u003c/p\u003e\n\u003cp\u003e더 풍부한 관리 기능은 사용자에게 전체 설치에 대한 일반적인 접근 권한을 부여하지 않고도 협업 목적으로 특정 저장소에 대한 접근 권한을 부여하는 것을 훨씬 쉽게 만들 것입니다. 이는 핵심 개발자 접근 권한 부여와 관련된 전면적인 결정(all-or-nothing decision)이 아니라, 신뢰를 점진적으로 더 쉽게 부여하고 얻을 수 있게 함으로써 진입 장벽을 낮추는 데 도움이 됩니다.\u003c/p\u003e\n\u003ch2\u003e지속 가능한 엔지니어링 고려 사항\u003c/h2\u003e\n\u003cp\u003e현재 워크플로우에서도 CPython 자체는 세계에서 가장 큰 오픈 소스 프로젝트 중 하나입니다. 그러나 CPython의 워크플로우 인프라를 구성하는 프로젝트에 대한 기여를 장려하는 데는 훨씬 덜 효과적이었습니다.\u003c/p\u003e\n\u003cp\u003e따라서 이 제안의 핵심 구성 요소는 Kallithea SCM을 사용하여 작업하는 데 대한 장벽을 낮추기 위해 업스트림 Kallithea 커뮤니티와 적극적으로 협력하고, \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스가 PSF의 인프라 자동화와 깔끔하게 통합되도록 PSF 인프라 팀과 협력하는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 접근 방식은 여러 가지 주요 이점을 제공하는 것을 목표로 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 서비스 유지 관리에 기여하는 사람들이 가용 시간 내에서 최대한 생산성을 높일 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003e이 서비스 유지 관리에 참여하기로 선택한 자원봉사자들에게 매력적인 전문 개발 기회를 제공합니다.\u003c/li\u003e\n\u003cli\u003eKallithea 프로젝트 자체가 채택, 배포 및 관리가 가능한 한 쉽게 만들어서 다른 잠재 사용자들에게 더욱 매력적으로 만듭니다.\u003c/li\u003e\n\u003cli\u003e위의 이점으로 인해 업스트림 Kallithea 커뮤니티와 CPython 인프라 커뮤니티 모두에서 충분한 기여자(contributor)를 유치하여 \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스가 변화하는 개발자 기대를 효과적으로 충족하도록 발전할 수 있도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 지속 가능한 엔지니어링 문제를 해결하기 위한 몇 가지 초기 단계가 이미 수행되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTymoteusz Jankowski는 Donald Stufft와 함께 PSF의 Salt 기반 인프라 자동화를 사용하여 Kallithea를 배포하는 데 필요한 작업을 논의했습니다.\u003c/li\u003e\n\u003cli\u003eGraham Dumpleton과 저자는 Red Hat의 오픈 소스 호스팅 서비스인 OpenShift Online의 무료 티어에 데모 Kallithea 인스턴스를 쉽게 배포하는 작업을 진행했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 주요 단계는 Windows, Mac OS X 및 Linux의 기여자(contributor)가 자신의 시스템 작동에 방해받지 않고 Kallithea 테스트를 로컬에서 실행할 수 있는 로컬 개발 워크플로우를 고안하는 것입니다. 현재 계획된 접근 방식은 테스트 목적으로 로컬 VM을 실행하는 개발자를 위해 특별히 고안된 인기 있는 자동화된 가상 머신 관리 시스템인 Vagrant에 중점을 두는 것입니다.\u003c/p\u003e\n\u003cp\u003e이러한 워크플로우 제안이 Kallithea에 잘 작동한다면, Roundup, BuildBot, 그리고 주요 \u003ccode\u003epython.org\u003c/code\u003e 웹사이트를 포함한 다른 PSF 및 CPython 인프라 서비스를 지원하는 업스트림 프로젝트에서도 사용을 제안할 가치가 있을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e개인적인 동기\u003c/h2\u003e\n\u003cp\u003e2015년 7월 현재, 저는 Red Hat에서 소프트웨어 개발 워크플로우 디자이너이자 프로세스 아키텍트(process architect)로 일하고 있으며, Fedora의 업스트림 개발자 경험에 중점을 두고 있습니다. 이러한 경험의 두 가지 핵심 요소는 많은 웹 서비스 개발자에게 익숙할 것입니다: 로컬 컨테이너 관리를 위한 Docker와 크로스 플랫폼 로컬 개발 VM 관리를 위한 Vagrant. 이러한 기술을 여러 업스트림 컨텍스트에 적용하는 데 시간을 할애하는 것은 Fedora에 잘 통합되어 있지만, 다른 Linux 배포판, Windows, Mac OS X에서도 쉽게 사용할 수 있는 좋은 소프트웨어 개발 경험을 제공하기 위해 무엇이 잘 작동하고 무엇이 여전히 개선이 필요한지에 대한 추가 통찰력을 제공하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e특히 코드 검토(code review) 워크플로우와 관련하여, 제가 경력 동안 사용한 주요 코드 검토 워크플로우 관리 도구는 Gerrit (세분화된 접근 제어 기능을 갖춘 다단계 코드 검토용), GitHub 및 BitBucket (기본 Pull Request 기반 워크플로우용), 그리고 Rietveld (CPython의 선택적 사전 커밋 검토용)입니다.\u003c/p\u003e\n\u003cp\u003eKallithea는 현재 저장소 호스팅 및 코드 검토 관리 플랫폼을 결합한 프로젝트이지만, 온라인 병합을 제공함으로써 둘을 직접 통합하지는 않습니다. 이는 GitHub/BitBucket Pull Request 모델의 낮은 진입 장벽 이점과 Gerrit의 멘토링 및 작업 인계 이점을 Kallithea에 대한 온라인 코드 병합 모델을 정의하는 데 업스트림 Kallithea 개발자들과 협력하여 융합할 기회를 만듭니다.\u003c/p\u003e\n\u003ch2\u003e기술적 우려 사항 및 과제\u003c/h2\u003e\n\u003cp\u003eCPython 인프라에 새로운 서비스를 도입하는 것은 여러 가지 흥미로운 기술적 우려 사항과 과제를 제시합니다. 이 섹션에서는 가장 중요한 몇 가지를 다룹니다.\u003c/p\u003e\n\u003ch3\u003e서비스 호스팅\u003c/h3\u003e\n\u003cp\u003e이 PEP의 기본 입장은 새로운 \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스가 기존 PSF Salt 인프라에 통합되어 PSF의 Rackspace 클라우드 인프라에서 호스팅될 것이라는 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 다른 호스팅 옵션도 고려될 것입니다. 특히 Google Container Engine 또는 Red Hat OpenShift Online 서비스의 차세대 버전에서 Kubernetes 호스팅 웹 서비스로 배포될 가능성이 있으며, \u003ccode\u003eGCEPersistentDisk\u003c/code\u003e 또는 오픈 소스 GlusterFS 분산 파일 시스템을 사용하여 소스 코드 저장소를 보관하는 방안도 있습니다.\u003c/p\u003e\n\u003ch3\u003e지속적인 인프라 유지 관리\u003c/h3\u003e\n\u003cp\u003e지속적인 인프라 유지 관리는 PSF 내에서 우려되는 영역입니다. 현재 Fedora Infrastructure Apprentice 또는 GNOME Infrastructure Apprentice 프로그램과 동등한 시스템 관리자 멘토십 프로그램이 부족하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e대신 시스템은 주로 개발자들이 개발 관련 기여 외에 파트타임 활동으로 유지 관리하는 경향이 있습니다. 이는 개발(새로운 기능을 제공하거나 더 나은 사용자 경험을 제공하거나 기존 문제를 해결하기 위해 서비스를 변경하는 것)보다 운영(기존 시스템을 잘 작동시키는 것)에 더 관심 있는 사람들을 모집하는 대신입니다.\u003c/p\u003e\n\u003cp\u003e저는 미래에 PSF가 그러한 프로그램을 운영하기를 개인적으로 바라지만, 그러한 프로그램을 설정하는 것이 실현 가능한 단기 목표라고 생각하지 않습니다. 그러나 OpenStack 및 Salt와 같은 현대적인 인프라 기술의 PSF 기존 사용을 더 많은 서비스로 확장하고 컨테이너 및 컨테이너 플랫폼의 잠재적 이점을 탐색하기 시작함으로써 그러한 프로그램의 기반을 계속 마련하는 것은 실현 가능하다고 생각합니다.\u003c/p\u003e\n\u003cp\u003e또한 ManageIQ와 같은 오픈 소스 클라우드 관리 플랫폼이 Rackspace, Google, Amazon 및 기타 서비스 전반에 걸쳐 발생하는 \"클라우드 확산\" 문제를 더 잘 제어하는 데 도움이 될 수 있는지 여부에 대해서도 알아볼 계획입니다.\u003c/p\u003e\n\u003ch3\u003e사용자 계정 관리\u003c/h3\u003e\n\u003cp\u003e이상적으로는 Kallithea, Roundup/Rietveld, PyPI 및 새로운 \u003ccode\u003epython.org\u003c/code\u003e 사이트의 백엔드를 포함한 모든 \u003ccode\u003epython.org\u003c/code\u003e 서비스에 걸쳐 단일 계정을 제공할 수 있기를 원합니다. 그러나 실제로 이를 구현하는 것은 이 PEP와는 별개의 인프라 프로젝트가 될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eforge.python.org\u003c/code\u003e의 초기 출시를 위해 PSF 인프라 내에 또 다른 ID 사일로(identity silo)를 만들 가능성이 높습니다. 잠재적으로 더 나은 대안은 Kallithea에 \u003ccode\u003epython-social-auth\u003c/code\u003e 지원을 추가하는 것이지만, 실제로 그렇게 하는 것은 서비스의 초기 출시를 위한 요구 사항은 아닙니다. (주요 기술적 우려 사항은 Kallithea가 아직 Pyramid로 포팅되지 않은 Pylons 애플리케이션이므로, 통합을 위해서는 \u003ccode\u003epython-social-auth\u003c/code\u003e에 Pylons 백엔드를 추가하거나 Kallithea에서 Pyramid 마이그레이션을 시작해야 한다는 것입니다).\u003c/p\u003e\n\u003ch3\u003eMercurial 저장소에 대한 기존 SSH 접근 및 링크 끊김\u003c/h3\u003e\n\u003cp\u003e이 PEP는 기존 \u003ccode\u003ehg.python.org\u003c/code\u003e 설치를 그대로 두고, 새로운 호스트에 Kallithea를 설정할 것을 제안합니다. 이 접근 방식은 CPython 자체의 개발(및 새 소프트웨어 포지로 마이그레이션하지 않는 다른 프로젝트)을 방해할 위험을 최소화하지만, 기존 저장소의 마이그레이션을 더 혼란스럽게 만듭니다 (기존 체크아웃이 중단되기 때문입니다).\u003c/p\u003e\n\u003ch3\u003eRoundup과의 통합\u003c/h3\u003e\n\u003cp\u003eKallithea는 구성 가능한 이슈 트래커(issue tracker) 통합을 제공합니다. 이는 \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스의 초기 출시 전에 \u003ccode\u003ebugs.python.org\u003c/code\u003e의 Roundup 이슈 트래커와 통합되도록 적절하게 설정되어야 합니다.\u003c/p\u003e\n\u003ch3\u003eGitHub 및 BitBucket에서 Pull Request 수락\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eforge.python.org\u003c/code\u003e의 초기 출시에서는 \u003ccode\u003ehg.python.org\u003c/code\u003e 및 기타 서비스 모두에 읽기 전용 미러(mirror) 게시를 지원할 것입니다. 이는 커밋 훅(commit hook)으로 구현할 수 있는 비교적 간단한 작업이기 때문입니다.\u003c/p\u003e\n\u003cp\u003e외부 서비스에서 Pull Request를 수락하고, 이를 \u003ccode\u003eforge.python.org\u003c/code\u003e의 마스터 저장소로 제출하는 것으로 미러링하는 것은 매우 바람직한 기능이지만, 더 복잡한 문제이며 \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스의 초기 출시에는 포함되지 않을 가능성이 높습니다.\u003c/p\u003e\n\u003ch3\u003e투명한 Git 및 Mercurial 상호 운용성\u003c/h3\u003e\n\u003cp\u003eKallithea의 Git 및 Mercurial 모두에 대한 기본 지원은 개발자가 \u003ccode\u003eforge.python.org\u003c/code\u003e에 호스팅된 저장소와 상호 작용하기 위해 선호하는 클라이언트를 사용하는 것을 비교적 간단하게 만들 수 있는 기회를 제공합니다.\u003c/p\u003e\n\u003cp\u003e이러한 투명한 상호 운용성은 아직 존재하지 않지만, 자체 다중-VCS(Version Control System) 저장소 호스팅 서비스를 운영함으로써, 상업적 이익이 아닐 가능성이 있는 기능을 제공하기 위해 독점 제공업체를 수동적으로 기다리는 대신, 이 기능을 현실화할 기회를 제공합니다. 오픈 소스 커뮤니티와 상업 제공업체 간에는 이 특정 영역에서 인센티브의 상당한 불일치가 있습니다. VCS 클라이언트 선택을 제공하는 것이 잠재적 기여자에게 특정 도구 선택을 강요하는 독단적인 결정을 프로젝트가 할 필요성을 없앰으로써 커뮤니션 마찰을 크게 줄일 수 있음에도 불구하고, 개발자 선호도와 관계없이 도구 선택을 위에서 아래로 강제하는 것이 현재 GitHub 및 Atlassian의 유료 고객을 생산하는 기업 및 기타 조직 환경에서 여전히 표준입니다.\u003c/p\u003e\n\u003cp\u003e수락 전에 투명한 상호 운용성이 없는 경우, 이 PEP는 \u003ccode\u003eforge.python.org\u003c/code\u003e에 호스팅된 Mercurial 저장소에 대한 Pull Request를 생성하기 위한 Git 사용자용 CPython 개발자 가이드 섹션에 포함될 특정 권장 사항을 제안해야 합니다.\u003c/p\u003e\n\u003ch2\u003e파일럿 목표 및 타임라인\u003c/h2\u003e\n\u003cp\u003e이 제안은 CPython 개발 워크플로우의 다양한 측면에 대한 Brett Cannon의 현재 개선 제안 평가의 일부입니다. 그 타임라인의 주요 날짜는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e2월 1일: 제안 초안 발행 (Kallithea의 경우, 이 PEP)\u003c/li\u003e\n\u003cli\u003e4월 8일: Python Language Summit에서 최종 제안 논의\u003c/li\u003e\n\u003cli\u003e5월 1일: Brett의 제안 수락 결정\u003c/li\u003e\n\u003cli\u003e9월 13일: Python 3.5 릴리스, Python 3.6에 새로운 워크플로우 채택\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 제안이 추가 개발을 위해 선택되면, 다음 파일럿 배포(pilot deployment)부터 시작할 것을 제안합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e최소한 개발자 가이드 및 PEP 저장소를 포함하는 \u003ccode\u003ekallithea-pilot.python.org\u003c/code\u003e에서 운영되는 참조 구현. 이는 \"일회용(throwaway)\" 인스턴스로, 핵심 개발자 및 다른 기여자(contributor)들이 저장소 히스토리에 대한 장기적인 결과에 대해 걱정하지 않고 자유롭게 실험할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003eGitHub 및 BitBucket에 Kallithea 호스팅 저장소의 읽기 전용 라이브 미러. 파일럿 서비스 자체와 마찬가지로, 이들은 파일럿 기간 종료 후 폐기될 임시 저장소입니다.\u003c/li\u003e\n\u003cli\u003e이러한 미러를 사용하여 Kallithea 호스팅 Mercurial 저장소에 대한 Pull Request를 생성하는 방법에 대한 명확한 문서.\u003c/li\u003e\n\u003cli\u003e코드 검토 댓글 및 커밋 메시지의 이슈 참조를 \u003ccode\u003ebugs.python.org\u003c/code\u003e의 해당 이슈에 자동으로 연결.\u003c/li\u003e\n\u003cli\u003eKallithea 기반 PEP 편집 및 제출 워크플로우를 설명하는 PEP 1에 대한 초안 업데이트.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 항목들은 프로덕션 마이그레이션에 필요하지만, 파일럿의 일부로 업데이트된 구현을 시도할 명확한 방법은 없는 것으로 보입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePEP 게시 프로세스 및 개발자 가이드 게시 프로세스를 재배치된 Mercurial 저장소를 기반으로 조정.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 항목들은 전체 워크플로우 개선 프로세스의 목표가 되겠지만, 9월에 새 서비스를 초기 채택하는 데 \"바람직하지만 필수는 아님\"으로 간주됩니다 (이 제안이 선택되고 제안된 파일럿 배포가 성공적인 경우).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epython-social-auth\u003c/code\u003e를 사용하여 PSF 호스팅 Kallithea 인스턴스에 대한 인증 허용.\u003c/li\u003e\n\u003cli\u003eGitHub 및 BitBucket Pull Request 워크플로우를 사용하여 주 Kallithea 저장소에 Pull Request 제출 허용.\u003c/li\u003e\n\u003cli\u003eKallithea 호스팅 저장소 및 Pull Request를 기반으로 BuildBot 실행을 쉽게 트리거 허용 (PEP 462 구현 전에는 주 CPython 저장소보다는 샌드박스 저장소와 함께 사용하기 위한 것임).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCPython 핵심 개발에 대한 미래 영향\u003c/h2\u003e\n\u003cp\u003e주 CPython 개발 저장소의 워크플로우 요구 사항은 이 PEP에서 논의되는 저장소의 요구 사항보다 훨씬 복잡합니다. 이러한 우려 사항은 PEP 462에서 더 자세히 다룹니다.\u003c/p\u003e\n\u003cp\u003eGuido의 권고에 따라 Rietveld를 더 활발하게 유지 관리되는 코드 검토 시스템으로 교체하기 위해, 현재 제 계획은 그 PEP를 Kallithea를 제안된 접착 계층(glue layer)으로 사용하여 다시 작성하고, 향상된 Kallithea Pull Request가 궁극적으로 이슈 트래커에 패치 파일을 직접 업로드하는 현재 관행을 대체하는 것입니다.\u003c/p\u003e\n\u003cp\u003e저는 또한 Pierre Yves-David와 함께 CPython 핵심 개발 워크플로우의 일부 측면을 자동화하는 사용자 정의 Mercurial 확장을 개발하기 시작했습니다.\u003c/p\u003e\n\u003ch2\u003e저작권\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003ch1\u003ePEP 474 – forge.python.org 생성\u003c/h1\u003e\n\u003ch2\u003e개요\u003c/h2\u003e\n\u003cp\u003e이 PEP (Python Enhancement Proposal)는 새로운 PSF(Python Software Foundation) 제공 리소스인 \u003ccode\u003eforge.python.org\u003c/code\u003e를 설정하여, 새로운 기여자(contributor)들이 더 쉽게 접근하고, 핵심 개발자(core developer)들이 관리하기 더 용이한 방식으로 다양한 지원 저장소(supporting repositories) (예: Python Enhancement Proposals 저장소)를 유지 관리하는 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 CPython 자체의 핵심 개발 워크플로우에는 어떠한 변경도 제안하지 않습니다. (관련 내용은 PEP 462를 참조하십시오.)\u003c/p\u003e\n\u003ch2\u003ePEP 철회\u003c/h2\u003e\n\u003cp\u003e이 PEP는 저자에 의해 철회되었으며, GitLab 기반 제안인 PEP 507을 지지합니다.\r\n만약 다른 사람이 이 PEP를 이어서 추진하고 싶다면, \u003ccode\u003ecore-workflow\u003c/code\u003e 메일링 리스트에 연락하십시오.\u003c/p\u003e\n\u003ch2\u003e제안\u003c/h2\u003e\n\u003cp\u003e이 PEP는 자체 호스팅(self-hosted) Kallithea 코드 저장소 관리 시스템의 인스턴스를 \"forge.python.org\"로 배포할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e개별 저장소(예: 개발자 가이드 또는 PEP 저장소)는 기존 \u003ccode\u003ehg.python.org\u003c/code\u003e 인프라에서 새로운 \u003ccode\u003eforge.python.org\u003c/code\u003e 인프라로 개별적으로 마이그레이션될 수 있습니다. 각 마이그레이션은 \u003ccode\u003ehg.python.org\u003c/code\u003e에 읽기 전용 미러를 유지할지, 아니면 새 위치로 완전히 마이그레이션할지 결정해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehg.python.org\u003c/code\u003e에 읽기 전용 미러를 지원하는 것 외에도, \u003ccode\u003eforge.python.org\u003c/code\u003e는 GitHub 및 BitBucket과 같은 인기 있는 독점 호스팅 사이트에 미러를 호스팅하는 것도 목표로 합니다. 목표는 이들 사이트에 익숙한 사용자들이 선호하는 워크플로우를 사용하여 Pull Request를 제출하고 논의할 수 있도록 하고, \u003ccode\u003eforge.python.org\u003c/code\u003e가 이러한 기여(contribution)를 마스터 저장소로 자동으로 가져오도록 하는 것입니다.\u003c/p\u003e\n\u003cp\u003e상업적으로 지원되는 \"오픈 소스 프로젝트를 위한 무료\" 저장소 호스팅 서비스의 가용성과 인기를 고려할 때, 이것은 임의의 Python 프로젝트를 위한 일반적인 호스팅 사이트가 아닙니다. 초기 초점은 특히 CPython 및 현재 \u003ccode\u003ehg.python.org\u003c/code\u003e에서 호스팅되는 다른 저장소에 맞춰질 것입니다. 미래에는 \u003ccode\u003epython.org\u003c/code\u003e Django 애플리케이션의 저장소와 같이 현재 외부에서 호스팅되고 있는 다른 PSF 관리 저장소를 통합하여 Pull Request 기반 워크플로우에 접근할 수 있도록 확장될 가능성이 있습니다. 초기 마이그레이션과 마찬가지로, 이러한 미래의 마이그레이션도 각 저장소의 주요 사용자의 선호도를 고려하여 개별적으로 검토될 것입니다.\u003c/p\u003e\n\u003ch2\u003e근거\u003c/h2\u003e\n\u003cp\u003e현재 \u003ccode\u003ehg.python.org\u003c/code\u003e는 핵심 CPython 저장소뿐만 아니라, CPython 개발자 가이드 및 Python Enhancement Proposals와 같은 다른 저장소와 핵심 개발자 실험을 위한 다양한 \"샌드박스(sandbox)\" 저장소도 호스팅하고 있습니다.\u003c/p\u003e\n\u003cp\u003eGitHub 및 BitBucket과 같은 코드 호스팅 사이트에서 인기를 얻은 간단한 \"Pull Request\" 스타일 워크플로우는 다양한 CPython 릴리스의 병렬 유지 관리 및 개발에 필요한 복잡한 브랜칭 모델에는 적합하지 않지만, 독점 호스팅 사이트로 옮기고 싶지 않은 CPython 주변의 여러 보조 프로젝트에는 잘 맞습니다.\u003c/p\u003e\n\u003cp\u003ePSF에서 제공하는 소프트웨어 포지(forge)에 제안된 주요 요구 사항은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e간단한 \"Pull Request\" 스타일 워크플로우를 지원해야 합니다.\u003c/li\u003e\n\u003cli\u003e간단한 변경을 위한 온라인 편집을 지원해야 합니다.\u003c/li\u003e\n\u003cli\u003e활발한 개발 조직(커뮤니티 또는 상업)의 지원을 받아야 합니다.\u003c/li\u003e\n\u003cli\u003e지속적인 비용 없이 PSF 인프라에 마스터 저장소의 자체 호스팅을 지원해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 제안에 의해 충족되지만, 충분히 설득력 있는 대안이 제시되면 협상될 수 있는 추가 권장 요구 사항은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePython으로 작성된 완전한 오픈 소스 애플리케이션이어야 합니다.\u003c/li\u003e\n\u003cli\u003eMercurial을 지원해야 합니다. (기존 도구와의 일관성을 위해)\u003c/li\u003e\n\u003cli\u003eGit을 지원해야 합니다. (선호하는 사용자에게 옵션을 제공하기 위해)\u003c/li\u003e\n\u003cli\u003eGit 및 Mercurial 클라이언트 사용자가 동일한 저장소에서 투명하게 협업할 수 있도록 허용해야 합니다.\u003c/li\u003e\n\u003cli\u003eGitHub 및 BitBucket 사용자가 해당 도구에서 제공하는 표준 Pull Request 워크플로우를 사용하여 제안된 변경 사항을 제출할 수 있도록 허용해야 합니다.\u003c/li\u003e\n\u003cli\u003ePEP 462에서 제안된 핵심 검토자 모델로의 잠재적인 경로를 제공하는 것을 포함하여, CPython 핵심 개발의 요구 사항을 충족하기 위한 사용자 정의에 개방적이어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e지속적인 비용 없이 자체 호스팅을 선호하는 것은 GitHub 및 BitBucket과 같은 \"무료\" 제공업체뿐만 아니라 다양한 독점 소스 코드 관리 서비스를 배제합니다.\u003c/p\u003e\n\u003cp\u003eMercurial 지원에 대한 선호는 GitHub뿐만 아니라 GitLab 및 Gitorious와 같은 Git 전용 솔루션도 배제합니다.\u003c/p\u003e\n\u003cp\u003e온라인 편집 지원에 대한 엄격한 요구 사항은 Apache Allura/HgForge 조합을 배제합니다.\u003c/p\u003e\n\u003cp\u003e완전한 오픈 소스 솔루션에 대한 선호는 RhodeCode를 배제합니다.\u003c/p\u003e\n\u003cp\u003e이 제안의 저자가 고려한 다양한 옵션 중에서, Kallithea SCM이 \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스의 제안된 기반으로 남습니다.\u003c/p\u003e\n\u003cp\u003eKallithea는 Software Freedom Conservancy의 후원 아래 개발되고 있는 완전한 GPLv3 애플리케이션입니다. Conservancy는 Kallithea 코드베이스가 GPLv3에 따라 완전히 유효하게 라이선스되었음을 확인했습니다. 초기 Kallithea 커뮤니티를 구축하는 역할 외에도, Conservancy는 Mercurial 및 Git 프로젝트의 법적 본거지이기도 합니다. Python 사용자에게 익숙할 수 있는 다른 SFC 회원 프로젝트로는 Twisted, Gevent, BuildBot 및 PyPy가 있습니다.\u003c/p\u003e\n\u003ch2\u003e예상되는 이점\u003c/h2\u003e\n\u003cp\u003eKallithea를 \u003ccode\u003eforge.python.org\u003c/code\u003e로 배포하는 주요 이점은 개발자 가이드 및 PEP 저장소와 같은 지원 저장소를 Pull Request 및 온라인 편집을 사용하여 관리할 수 있다는 것입니다. 이는 다른 사용자가 제안한 업데이트를 적용하기 위해 PEP 편집자 및 다른 핵심 개발자들이 중개자 역할을 해야 하는 현재 워크플로우보다 훨씬 간단할 것입니다.\u003c/p\u003e\n\u003cp\u003e더 풍부한 관리 기능은 사용자에게 전체 설치에 대한 일반적인 접근 권한을 부여하지 않고도 협업 목적으로 특정 저장소에 대한 접근 권한을 부여하는 것을 훨씬 쉽게 만들 것입니다. 이는 핵심 개발자 접근 권한 부여와 관련된 전면적인 결정(all-or-nothing decision)이 아니라, 신뢰를 점진적으로 더 쉽게 부여하고 얻을 수 있게 함으로써 진입 장벽을 낮추는 데 도움이 됩니다.\u003c/p\u003e\n\u003ch2\u003e지속 가능한 엔지니어링 고려 사항\u003c/h2\u003e\n\u003cp\u003e현재 워크플로우에서도 CPython 자체는 세계에서 가장 큰 오픈 소스 프로젝트 중 하나입니다. 그러나 CPython의 워크플로우 인프라를 구성하는 프로젝트에 대한 기여를 장려하는 데는 훨씬 덜 효과적이었습니다.\u003c/p\u003e\n\u003cp\u003e따라서 이 제안의 핵심 구성 요소는 Kallithea SCM을 사용하여 작업하는 데 대한 장벽을 낮추기 위해 업스트림 Kallithea 커뮤니티와 적극적으로 협력하고, \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스가 PSF의 인프라 자동화와 깔끔하게 통합되도록 PSF 인프라 팀과 협력하는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 접근 방식은 여러 가지 주요 이점을 제공하는 것을 목표로 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 서비스 유지 관리에 기여하는 사람들이 가용 시간 내에서 최대한 생산성을 높일 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003e이 서비스 유지 관리에 참여하기로 선택한 자원봉사자들에게 매력적인 전문 개발 기회를 제공합니다.\u003c/li\u003e\n\u003cli\u003eKallithea 프로젝트 자체가 채택, 배포 및 관리가 가능한 한 쉽게 만들어서 다른 잠재 사용자들에게 더욱 매력적으로 만듭니다.\u003c/li\u003e\n\u003cli\u003e위의 이점으로 인해 업스트림 Kallithea 커뮤니티와 CPython 인프라 커뮤니티 모두에서 충분한 기여자(contributor)를 유치하여 \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스가 변화하는 개발자 기대를 효과적으로 충족하도록 발전할 수 있도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 지속 가능한 엔지니어링 문제를 해결하기 위한 몇 가지 초기 단계가 이미 수행되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTymoteusz Jankowski는 Donald Stufft와 함께 PSF의 Salt 기반 인프라 자동화를 사용하여 Kallithea를 배포하는 데 필요한 작업을 논의했습니다.\u003c/li\u003e\n\u003cli\u003eGraham Dumpleton과 저자는 Red Hat의 오픈 소스 호스팅 서비스인 OpenShift Online의 무료 티어에 데모 Kallithea 인스턴스를 쉽게 배포하는 작업을 진행했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 주요 단계는 Windows, Mac OS X 및 Linux의 기여자(contributor)가 자신의 시스템 작동에 방해받지 않고 Kallithea 테스트를 로컬에서 실행할 수 있는 로컬 개발 워크플로우를 고안하는 것입니다. 현재 계획된 접근 방식은 테스트 목적으로 로컬 VM을 실행하는 개발자를 위해 특별히 고안된 인기 있는 자동화된 가상 머신 관리 시스템인 Vagrant에 중점을 두는 것입니다.\u003c/p\u003e\n\u003cp\u003e이러한 워크플로우 제안이 Kallithea에 잘 작동한다면, Roundup, BuildBot, 그리고 주요 \u003ccode\u003epython.org\u003c/code\u003e 웹사이트를 포함한 다른 PSF 및 CPython 인프라 서비스를 지원하는 업스트림 프로젝트에서도 사용을 제안할 가치가 있을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e개인적인 동기\u003c/h2\u003e\n\u003cp\u003e2015년 7월 현재, 저는 Red Hat에서 소프트웨어 개발 워크플로우 디자이너이자 프로세스 아키텍트(process architect)로 일하고 있으며, Fedora의 업스트림 개발자 경험에 중점을 두고 있습니다. 이러한 경험의 두 가지 핵심 요소는 많은 웹 서비스 개발자에게 익숙할 것입니다: 로컬 컨테이너 관리를 위한 Docker와 크로스 플랫폼 로컬 개발 VM 관리를 위한 Vagrant. 이러한 기술을 여러 업스트림 컨텍스트에 적용하는 데 시간을 할애하는 것은 Fedora에 잘 통합되어 있지만, 다른 Linux 배포판, Windows, Mac OS X에서도 쉽게 사용할 수 있는 좋은 소프트웨어 개발 경험을 제공하기 위해 무엇이 잘 작동하고 무엇이 여전히 개선이 필요한지에 대한 추가 통찰력을 제공하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e특히 코드 검토(code review) 워크플로우와 관련하여, 제가 경력 동안 사용한 주요 코드 검토 워크플로우 관리 도구는 Gerrit (세분화된 접근 제어 기능을 갖춘 다단계 코드 검토용), GitHub 및 BitBucket (기본 Pull Request 기반 워크플로우용), 그리고 Rietveld (CPython의 선택적 사전 커밋 검토용)입니다.\u003c/p\u003e\n\u003cp\u003eKallithea는 현재 저장소 호스팅 및 코드 검토 관리 플랫폼을 결합한 프로젝트이지만, 온라인 병합을 제공함으로써 둘을 직접 통합하지는 않습니다. 이는 GitHub/BitBucket Pull Request 모델의 낮은 진입 장벽 이점과 Gerrit의 멘토링 및 작업 인계 이점을 Kallithea에 대한 온라인 코드 병합 모델을 정의하는 데 업스트림 Kallithea 개발자들과 협력하여 융합할 기회를 만듭니다.\u003c/p\u003e\n\u003ch2\u003e기술적 우려 사항 및 과제\u003c/h2\u003e\n\u003cp\u003eCPython 인프라에 새로운 서비스를 도입하는 것은 여러 가지 흥미로운 기술적 우려 사항과 과제를 제시합니다. 이 섹션에서는 가장 중요한 몇 가지를 다룹니다.\u003c/p\u003e\n\u003ch3\u003e서비스 호스팅\u003c/h3\u003e\n\u003cp\u003e이 PEP의 기본 입장은 새로운 \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스가 기존 PSF Salt 인프라에 통합되어 PSF의 Rackspace 클라우드 인프라에서 호스팅될 것이라는 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 다른 호스팅 옵션도 고려될 것입니다. 특히 Google Container Engine 또는 Red Hat OpenShift Online 서비스의 차세대 버전에서 Kubernetes 호스팅 웹 서비스로 배포될 가능성이 있으며, \u003ccode\u003eGCEPersistentDisk\u003c/code\u003e 또는 오픈 소스 GlusterFS 분산 파일 시스템을 사용하여 소스 코드 저장소를 보관하는 방안도 있습니다.\u003c/p\u003e\n\u003ch3\u003e지속적인 인프라 유지 관리\u003c/h3\u003e\n\u003cp\u003e지속적인 인프라 유지 관리는 PSF 내에서 우려되는 영역입니다. 현재 Fedora Infrastructure Apprentice 또는 GNOME Infrastructure Apprentice 프로그램과 동등한 시스템 관리자 멘토십 프로그램이 부족하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e대신 시스템은 주로 개발자들이 개발 관련 기여 외에 파트타임 활동으로 유지 관리하는 경향이 있습니다. 이는 개발(새로운 기능을 제공하거나 더 나은 사용자 경험을 제공하거나 기존 문제를 해결하기 위해 서비스를 변경하는 것)보다 운영(기존 시스템을 잘 작동시키는 것)에 더 관심 있는 사람들을 모집하는 대신입니다.\u003c/p\u003e\n\u003cp\u003e저는 미래에 PSF가 그러한 프로그램을 운영하기를 개인적으로 바라지만, 그러한 프로그램을 설정하는 것이 실현 가능한 단기 목표라고 생각하지 않습니다. 그러나 OpenStack 및 Salt와 같은 현대적인 인프라 기술의 PSF 기존 사용을 더 많은 서비스로 확장하고 컨테이너 및 컨테이너 플랫폼의 잠재적 이점을 탐색하기 시작함으로써 그러한 프로그램의 기반을 계속 마련하는 것은 실현 가능하다고 생각합니다.\u003c/p\u003e\n\u003cp\u003e또한 ManageIQ와 같은 오픈 소스 클라우드 관리 플랫폼이 Rackspace, Google, Amazon 및 기타 서비스 전반에 걸쳐 발생하는 \"클라우드 확산\" 문제를 더 잘 제어하는 데 도움이 될 수 있는지 여부에 대해서도 알아볼 계획입니다.\u003c/p\u003e\n\u003ch3\u003e사용자 계정 관리\u003c/h3\u003e\n\u003cp\u003e이상적으로는 Kallithea, Roundup/Rietveld, PyPI 및 새로운 \u003ccode\u003epython.org\u003c/code\u003e 사이트의 백엔드를 포함한 모든 \u003ccode\u003epython.org\u003c/code\u003e 서비스에 걸쳐 단일 계정을 제공할 수 있기를 원합니다. 그러나 실제로 이를 구현하는 것은 이 PEP와는 별개의 인프라 프로젝트가 될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eforge.python.org\u003c/code\u003e의 초기 출시를 위해 PSF 인프라 내에 또 다른 ID 사일로(identity silo)를 만들 가능성이 높습니다. 잠재적으로 더 나은 대안은 Kallithea에 \u003ccode\u003epython-social-auth\u003c/code\u003e 지원을 추가하는 것이지만, 실제로 그렇게 하는 것은 서비스의 초기 출시를 위한 요구 사항은 아닙니다. (주요 기술적 우려 사항은 Kallithea가 아직 Pyramid로 포팅되지 않은 Pylons 애플리케이션이므로, 통합을 위해서는 \u003ccode\u003epython-social-auth\u003c/code\u003e에 Pylons 백엔드를 추가하거나 Kallithea에서 Pyramid 마이그레이션을 시작해야 한다는 것입니다).\u003c/p\u003e\n\u003ch3\u003eMercurial 저장소에 대한 기존 SSH 접근 및 링크 끊김\u003c/h3\u003e\n\u003cp\u003e이 PEP는 기존 \u003ccode\u003ehg.python.org\u003c/code\u003e 설치를 그대로 두고, 새로운 호스트에 Kallithea를 설정할 것을 제안합니다. 이 접근 방식은 CPython 자체의 개발(및 새 소프트웨어 포지로 마이그레이션하지 않는 다른 프로젝트)을 방해할 위험을 최소화하지만, 기존 저장소의 마이그레이션을 더 혼란스럽게 만듭니다 (기존 체크아웃이 중단되기 때문입니다).\u003c/p\u003e\n\u003ch3\u003eRoundup과의 통합\u003c/h3\u003e\n\u003cp\u003eKallithea는 구성 가능한 이슈 트래커(issue tracker) 통합을 제공합니다. 이는 \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스의 초기 출시 전에 \u003ccode\u003ebugs.python.org\u003c/code\u003e의 Roundup 이슈 트래커와 통합되도록 적절하게 설정되어야 합니다.\u003c/p\u003e\n\u003ch3\u003eGitHub 및 BitBucket에서 Pull Request 수락\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eforge.python.org\u003c/code\u003e의 초기 출시에서는 \u003ccode\u003ehg.python.org\u003c/code\u003e 및 기타 서비스 모두에 읽기 전용 미러(mirror) 게시를 지원할 것입니다. 이는 커밋 훅(commit hook)으로 구현할 수 있는 비교적 간단한 작업이기 때문입니다.\u003c/p\u003e\n\u003cp\u003e외부 서비스에서 Pull Request를 수락하고, 이를 \u003ccode\u003eforge.python.org\u003c/code\u003e의 마스터 저장소로 제출하는 것으로 미러링하는 것은 매우 바람직한 기능이지만, 더 복잡한 문제이며 \u003ccode\u003eforge.python.org\u003c/code\u003e 서비스의 초기 출시에는 포함되지 않을 가능성이 높습니다.\u003c/p\u003e\n\u003ch3\u003e투명한 Git 및 Mercurial 상호 운용성\u003c/h3\u003e\n\u003cp\u003eKallithea의 Git 및 Mercurial 모두에 대한 기본 지원은 개발자가 \u003ccode\u003eforge.python.org\u003c/code\u003e에 호스팅된 저장소와 상호 작용하기 위해 선호하는 클라이언트를 사용하는 것을 비교적 간단하게 만들 수 있는 기회를 제공합니다.\u003c/p\u003e\n\u003cp\u003e이러한 투명한 상호 운용성은 아직 존재하지 않지만, 자체 다중-VCS(Version Control System) 저장소 호스팅 서비스를 운영함으로써, 상업적 이익이 아닐 가능성이 있는 기능을 제공하기 위해 독점 제공업체를 수동적으로 기다리는 대신, 이 기능을 현실화할 기회를 제공합니다. 오픈 소스 커뮤니티와 상업 제공업체 간에는 이 특정 영역에서 인센티브의 상당한 불일치가 있습니다. VCS 클라이언트 선택을 제공하는 것이 잠재적 기여자에게 특정 도구 선택을 강요하는 독단적인 결정을 프로젝트가 할 필요성을 없앰으로써 커뮤니션 마찰을 크게 줄일 수 있음에도 불구하고, 개발자 선호도와 관계없이 도구 선택을 위에서 아래로 강제하는 것이 현재 GitHub 및 Atlassian의 유료 고객을 생산하는 기업 및 기타 조직 환경에서 여전히 표준입니다.\u003c/p\u003e\n\u003cp\u003e수락 전에 투명한 상호 운용성이 없는 경우, 이 PEP는 \u003ccode\u003eforge.python.org\u003c/code\u003e에 호스팅된 Mercurial 저장소에 대한 Pull Request를 생성하기 위한 Git 사용자용 CPython 개발자 가이드 섹션에 포함될 특정 권장 사항을 제안해야 합니다.\u003c/p\u003e\n\u003ch2\u003e파일럿 목표 및 타임라인\u003c/h2\u003e\n\u003cp\u003e이 제안은 CPython 개발 워크플로우의 다양한 측면에 대한 Brett Cannon의 현재 개선 제안 평가의 일부입니다. 그 타임라인의 주요 날짜는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e2월 1일: 제안 초안 발행 (Kallithea의 경우, 이 PEP)\u003c/li\u003e\n\u003cli\u003e4월 8일: Python Language Summit에서 최종 제안 논의\u003c/li\u003e\n\u003cli\u003e5월 1일: Brett의 제안 수락 결정\u003c/li\u003e\n\u003cli\u003e9월 13일: Python 3.5 릴리스, Python 3.6에 새로운 워크플로우 채택\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 제안이 추가 개발을 위해 선택되면, 다음 파일럿 배포(pilot deployment)부터 시작할 것을 제안합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e최소한 개발자 가이드 및 PEP 저장소를 포함하는 \u003ccode\u003ekallithea-pilot.python.org\u003c/code\u003e에서 운영되는 참조 구현. 이는 \"일회용(throwaway)\" 인스턴스로, 핵심 개발자 및 다른 기여자(contributor)들이 저장소 히스토리에 대한 장기적인 결과에 대해 걱정하지 않고 자유롭게 실험할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003eGitHub 및 BitBucket에 Kallithea 호스팅 저장소의 읽기 전용 라이브 미러. 파일럿 서비스 자체와 마찬가지로, 이들은 파일럿 기간 종료 후 폐기될 임시 저장소입니다.\u003c/li\u003e\n\u003cli\u003e이러한 미러를 사용하여 Kallithea 호스팅 Mercurial 저장소에 대한 Pull Request를 생성하는 방법에 대한 명확한 문서.\u003c/li\u003e\n\u003cli\u003e코드 검토 댓글 및 커밋 메시지의 이슈 참조를 \u003ccode\u003ebugs.python.org\u003c/code\u003e의 해당 이슈에 자동으로 연결.\u003c/li\u003e\n\u003cli\u003eKallithea 기반 PEP 편집 및 제출 워크플로우를 설명하는 PEP 1에 대한 초안 업데이트.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 항목들은 프로덕션 마이그레이션에 필요하지만, 파일럿의 일부로 업데이트된 구현을 시도할 명확한 방법은 없는 것으로 보입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePEP 게시 프로세스 및 개발자 가이드 게시 프로세스를 재배치된 Mercurial 저장소를 기반으로 조정.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 항목들은 전체 워크플로우 개선 프로세스의 목표가 되겠지만, 9월에 새 서비스를 초기 채택하는 데 \"바람직하지만 필수는 아님\"으로 간주됩니다 (이 제안이 선택되고 제안된 파일럿 배포가 성공적인 경우).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epython-social-auth\u003c/code\u003e를 사용하여 PSF 호스팅 Kallithea 인스턴스에 대한 인증 허용.\u003c/li\u003e\n\u003cli\u003eGitHub 및 BitBucket Pull Request 워크플로우를 사용하여 주 Kallithea 저장소에 Pull Request 제출 허용.\u003c/li\u003e\n\u003cli\u003eKallithea 호스팅 저장소 및 Pull Request를 기반으로 BuildBot 실행을 쉽게 트리거 허용 (PEP 462 구현 전에는 주 CPython 저장소보다는 샌드박스 저장소와 함께 사용하기 위한 것임).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCPython 핵심 개발에 대한 미래 영향\u003c/h2\u003e\n\u003cp\u003e주 CPython 개발 저장소의 워크플로우 요구 사항은 이 PEP에서 논의되는 저장소의 요구 사항보다 훨씬 복잡합니다. 이러한 우려 사항은 PEP 462에서 더 자세히 다룹니다.\u003c/p\u003e\n\u003cp\u003eGuido의 권고에 따라 Rietveld를 더 활발하게 유지 관리되는 코드 검토 시스템으로 교체하기 위해, 현재 제 계획은 그 PEP를 Kallithea를 제안된 접착 계층(glue layer)으로 사용하여 다시 작성하고, 향상된 Kallithea Pull Request가 궁극적으로 이슈 트래커에 패치 파일을 직접 업로드하는 현재 관행을 대체하는 것입니다.\u003c/p\u003e\n\u003cp\u003e저는 또한 Pierre Yves-David와 함께 CPython 핵심 개발 워크플로우의 일부 측면을 자동화하는 사용자 정의 Mercurial 확장을 개발하기 시작했습니다.\u003c/p\u003e\n\u003ch2\u003e저작권\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1098,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Withdrawn] PEP 474 - Creating forge.python.org\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:21:06+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>