<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Draft] PEP 744 - JIT Compilation</h1><div class="page__meta"><time dateTime="2025-09-27 13:34:20+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0744/">PEP 744 - JIT Compilation</a></p>
<p><strong>상태:</strong> Draft | <strong>유형:</strong> Informational | <strong>작성일:</strong> 11-Apr-2024</p>
</blockquote>
<p>PEP 744: JIT Compilation</p>
<h2>요약 (Abstract)</h2>
<p>최근 CPython의 메인 개발 브랜치에 실험적인 JIT(Just-In-Time) 컴파일러가 병합되었습니다. 이 PEP는 JIT 컴파일러의 도입 배경, 설계 결정, 현재 구현 상태, 그리고 CPython의 영구적인 비실험적 기능으로 만들기 위한 향후 계획을 요약합니다. 이 문서는 JIT의 작동 방식에 대한 포괄적인 설명보다는, 선택된 접근 방식의 장단점과 도입 이후 제기된 질문에 답변하는 데 중점을 둡니다.</p>
<h2>도입 배경 (Motivation)</h2>
<p>기존 CPython은 파이썬 코드를 바이트코드로 컴파일한 후 런타임에 인터프리트(interpret)하는 방식으로 실행했습니다. Python 3.11부터 "specializing adaptive interpreter" (PEP 659)가 도입되어 런타임에 바이트코드 명령어를 타입 특화된 버전으로 재작성하여 상당한 성능 향상을 이루었지만, 개별 바이트코드 명령어의 경계로 인해 최적화 잠재력은 제한적이었습니다. Python 3.12부터는 C-like DSL(Domain-Specific Language)을 사용하여 인터프리터가 생성되며, 이는 유지보수를 용이하게 하고 새로운 실행 방식을 가능하게 합니다.</p>
<p>Python 3.13부터는 마이크로-옵(micro-op) 번역, 최적화 및 실행 메커니즘이 모든 CPython 빌드에 포함되었으나 기본적으로 비활성화되어 있습니다. 인터프리터의 오버헤드가 크기 때문입니다. 이 병목 현상을 극복하기 위한 가장 확실한 전략은 이러한 최적화된 트레이스(traces)를 정적으로 컴파일하는 것입니다. 이는 여러 간접적인 호출 및 인터프리테이션으로 인한 오버헤드를 줄일 수 있는 기회를 제공합니다. 기존 최적화 파이프라인이 런타임 프로파일링 정보를 많이 사용하므로, 코드를 미리 컴파일하는 것보다 실행 "직전"에 최적화된 마이크로-옵을 컴파일하는 JIT 방식이 가장 유망한 접근 방식으로 간주됩니다.</p>
<h2>근거 (Rationale)</h2>
<p>JIT 컴파일러는 단순히 "더 빠르게" 만드는 마법이 아닙니다. 단일 플랫폼을 위한 최적화 컴파일러를 개발하고 유지보수하는 것은 매우 복잡하고 비용이 많이 드는 작업입니다. LLVM과 같은 기존 컴파일러 프레임워크를 사용하면 작업이 단순해질 수 있지만, 런타임 의존성이 증가하고 JIT 컴파일 오버헤드가 높아지는 단점이 있습니다.</p>
<p>파이썬 코드를 런타임에 성공적으로 컴파일하려면 고품질의 파이썬 특정 최적화와 최적화된 프로그램에 대한 효율적인 머신 코드(machine code)의 빠른 생성이 모두 필요합니다. CPython 코어 개발팀은 전자에 필요한 기술과 경험을 가지고 있으며, "copy-and-patch" 컴파일 방식이 후자에 대한 매력적인 해결책을 제공합니다. Copy-and-patch는 인터프리터의 나머지 부분을 생성하는 데 사용되는 동일한 DSL에서 고품질 템플릿 JIT 컴파일러를 생성할 수 있게 합니다. 이는 CPython 유지보수자가 바이트코드 정의를 편집하는 것만으로도 JIT 백엔드를 모든 JIT 지원 플랫폼에서 한 번에 "무료로" 업데이트할 수 있다는 큰 이점이 있습니다.</p>
<p>JIT 컴파일러는 인터프리터의 나머지 부분과 마찬가지로 빌드 타임(build time)에 생성되며 런타임 의존성이 없습니다. 광범위한 플랫폼을 지원하며 상대적으로 낮은 유지보수 부담을 가집니다. 현재 구현은 약 900줄의 빌드 타임 파이썬 코드와 500줄의 런타임 C 코드로 구성됩니다.</p>
<h2>명세 (Specification)</h2>
<p>JIT는 현재 기본 빌드 구성의 일부가 아니며, 예측 가능한 미래에도 그럴 가능성이 높습니다 (공식 바이너리에는 포함될 수 있음). JIT가 비실험적 기능이 되기 위한 조건은 다음과 같습니다.</p>
<ul>
<li>적어도 하나의 인기 있는 플랫폼에서 의미 있는 성능 향상(현실적으로 약 5% 수준)을 제공해야 합니다.</li>
<li>최소한의 방해로 빌드, 배포 및 배치가 가능해야 합니다.</li>
<li>Steering Council이 요청 시, 비활성화된 경우보다 활성화된 경우 커뮤니티에 더 많은 가치를 제공한다고 판단해야 합니다 (유지보수 부담, 메모리 사용량 또는 대체 설계의 실현 가능성과 같은 절충안 고려).</li>
</ul>
<p>이러한 기준은 시작점으로 간주되며 시간이 지남에 따라 확장될 수 있습니다. JIT가 비실험적이 되기 전까지는 프로덕션에서 사용해서는 안 되며, 경고 없이 언제든지 중단되거나 제거될 수 있습니다. JIT가 비실험적이지 않게 되면 <code>--enable-optimizations</code> 또는 <code>--with-lto</code>와 같은 다른 빌드 옵션과 동일하게 처리됩니다.</p>
<h2>지원 (Support)</h2>
<p>JIT는 PEP 11의 현재 Tier 1 플랫폼, 대부분의 Tier 2 플랫폼 및 하나의 Tier 3 플랫폼에서 개발되었습니다. CPython의 <code>main</code> 브랜치는 다음 플랫폼에서 JIT에 대한 릴리스 및 디버그 빌드를 CI로 구축하고 테스트합니다.</p>
<ul>
<li><code>aarch64-apple-darwin/clang</code></li>
<li><code>aarch64-pc-windows/msvc</code></li>
<li><code>aarch64-unknown-linux-gnu/clang</code></li>
<li><code>aarch64-unknown-linux-gnu/gcc</code></li>
<li><code>i686-pc-windows-msvc/msvc</code></li>
<li><code>x86_64-apple-darwin/clang</code></li>
<li><code>x86_64-pc-windows-msvc/msvc</code></li>
<li><code>x86_64-unknown-linux-gnu/clang</code></li>
<li><code>x86_64-unknown-linux-gnu/gcc</code></li>
</ul>
<p>일부 플랫폼은 JIT 지원을 받지 못할 수도 있습니다 (예: <code>powerpc64le-unknown-linux-gnu/gcc</code>, <code>wasm32-unknown-wasi/clang</code>).</p>
<p>JIT 지원이 추가되면 PEP 11에 명시된 대로 신뢰할 수 있는 CI/빌드봇을 가져야 하며, Tier 1 및 Tier 2 플랫폼에서의 JIT 실패는 릴리스를 차단해야 합니다. JIT 지원 제거는 하위 호환성(backwards-incompatible) 변경으로 간주되지 않지만, 합리적인 경우 PEP 387에 설명된 일반적인 Deprecation 프로세스를 따라야 합니다.</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>현재 인터프리터와 JIT 백엔드가 동일한 명세(specification)에서 생성되기 때문에 파이썬 코드의 동작은 완전히 변경되지 않아야 합니다. 테스트 중에 발견되고 수정된 관찰 가능한 차이점은 copy-and-patch 단계의 버그보다는 기존 마이크로-옵 번역 및 최적화 단계의 버그인 경향이 있었습니다.</p>
<h2>디버깅 (Debugging)</h2>
<p>파이썬 코드를 프로파일링하고 디버깅하는 도구는 계속 잘 작동합니다. 여기에는 <code>sys.monitoring</code>, <code>sys.settrace</code>, <code>sys.setprofile</code>과 같은 파이썬 제공 기능을 사용하는 인-프로세스(in-process) 도구와 인터프리터 상태에서 파이썬 프레임을 탐색하는 아웃-오브-프로세스(out-of-process) 도구가 포함됩니다.</p>
<p>그러나 C 코드용 프로파일러 및 디버거는 현재 JIT 프레임을 통해 추적할 수 없는 것으로 보입니다. 리프 프레임(leaf frames)으로 작업하는 것은 가능하지만 (JIT 자체를 디버깅하는 방식), JIT 프레임에 적절한 디버깅 정보가 없기 때문에 유용성이 제한적입니다. 이는 해결해야 할 문제이지만, 현재로서는 우선순위가 높지 않습니다.</p>
<h2>보안 영향 (Security Implications)</h2>
<p>이 JIT는 다른 JIT와 마찬가지로 런타임에 대량의 실행 가능한 데이터(executable data)를 생성합니다. 이는 악의적인 행위자가 이 데이터의 내용에 영향을 미칠 수 있다면 임의의 코드(arbitrary code)를 실행할 수 있으므로 CPython에 잠재적인 새로운 공격 표면을 도입합니다. 이는 JIT 컴파일러의 잘 알려진 취약점입니다.</p>
<p>이러한 위험을 완화하기 위해 JIT는 모범 사례를 염두에 두고 작성되었습니다. 특히, 해당 데이터는 쓰기 가능한 상태로 유지되는 동안 JIT 컴파일러에 의해 프로그램의 다른 부분에 노출되지 않으며, 데이터가 쓰기 가능하고 실행 가능한 상태가 동시에 되는 지점은 없습니다. 템플릿 기반 JIT의 특성 또한 생성될 수 있는 코드의 종류를 심각하게 제한하여 성공적인 익스플로잇(exploit) 가능성을 더욱 줄입니다. 추가 예방 조치로, 템플릿 자체는 정적 읽기 전용 메모리에 저장됩니다.</p>
<h2>Apple Silicon</h2>
<p>macOS 릴리스는 Hardened Runtime에 JIT Entitlement를 활성화해야 할 것으로 보입니다. 이는 파이썬 설치를 더 어렵게 만들지는 않지만, 릴리스 관리자가 수행해야 할 추가 단계를 추가할 수 있습니다.</p>
<h2>교육 방법 (How to Teach This)</h2>
<ul>
<li><strong>파이썬 프로그래머 또는 최종 사용자:</strong> 아무것도 변경되지 않습니다. JIT가 실험적 기능인 동안에는 JIT가 활성화된 CPython 인터프리터를 배포받지 않을 것입니다. 비실험적이 되면 약간 더 나은 성능과 약간 더 높은 메모리 사용량을 느낄 수 있지만, 다른 변경 사항은 관찰할 수 없을 것입니다.</li>
<li><strong>서드파티 패키지 유지보수자:</strong> 아무것도 변경되지 않습니다. API 또는 ABI 변경 사항이 없으며 JIT는 서드파티 코드에 노출되지 않습니다.</li>
<li><strong>파이썬 코드 프로파일링 또는 디버깅:</strong> 아무것도 변경되지 않습니다. 모든 파이썬 프로파일링 및 트레이싱 기능은 유지됩니다.</li>
<li><strong>C 코드 프로파일링 또는 디버깅:</strong> 현재 JIT 프레임을 통한 추적 기능이 제한적입니다. 전체 C 호출 스택(call stack)을 관찰해야 하는 경우 문제가 발생할 수 있습니다.</li>
<li><strong>자체 파이썬 인터프리터 컴파일:</strong> JIT를 빌드하고 싶지 않다면 무시해도 됩니다. 그렇지 않으면 호환되는 버전의 LLVM을 설치하고 빌드 스크립트에 적절한 플래그를 전달해야 합니다. 빌드에 최대 1분 더 걸릴 수 있습니다.</li>
<li><strong>CPython (또는 CPython 포크) 유지보수자:</strong>
<ul>
<li><strong>바이트코드 정의 또는 메인 인터프리터 루프 변경:</strong> 일반적으로 JIT는 큰 불편을 주지 않을 것입니다. 더 큰 변경 사항(새로운 지역 변수 추가, 오류 처리 변경 등)은 JIT를 생성하는 데 사용되는 C 템플릿에 변경이 필요할 수 있습니다.</li>
<li><strong>JIT 자체 작업:</strong> 파이썬 빌드 스크립트, JIT를 생성하는 데 사용되는 C 템플릿, JIT의 런타임 부분을 구성하는 C 코드를 정기적으로 수정하게 될 것입니다. 어셈블리에 익숙하고 컴파일러 관련 과정을 수강했으며 링커에 대한 블로그 게시물을 읽어본 것이 좋습니다.</li>
<li><strong>CPython의 다른 부분 유지보수:</strong> 아무것도 변경되지 않습니다.</li>
</ul>
</li>
</ul>
<h2>참고 구현 (Reference Implementation)</h2>
<p>주요 구현 부분은 다음과 같습니다.</p>
<ul>
<li><code>Tools/jit/README.md</code>: JIT 빌드 지침</li>
<li><code>Python/jit.c</code>: JIT 컴파일러의 전체 런타임 부분</li>
<li><code>jit_stencils.h</code>: JIT 생성 템플릿 예시</li>
<li><code>Tools/jit/template.c</code>: JIT 템플릿을 생성하기 위해 컴파일되는 코드</li>
<li><code>Tools/jit/_targets.py</code>: 빌드 시 템플릿을 컴파일하고 파싱하는 코드</li>
</ul>
<h2>채택되지 않은 아이디어 (Rejected Ideas)</h2>
<h3>CPython 외부에서 유지보수 (Maintain it outside of CPython)</h3>
<p>JIT를 CPython 외부에서 유지보수하는 것이 가능할 수 있지만, 구현이 인터프리터의 나머지 부분과 너무 밀접하게 연결되어 있어 최신 상태로 유지하는 것이 실제 JIT를 개발하는 것보다 더 어려울 것입니다. 또한, 별도의 JIT 프로젝트 릴리스는 특정 CPython 프리릴리스 및 패치 릴리스와 일치해야 하므로 디버깅 노력을 복잡하게 만들 것입니다. JIT가 이미 상당히 안정적이고 궁극적인 목표는 CPython의 비실험적 부분이 되는 것이므로, <code>main</code>에 유지하는 것이 최선의 방법으로 보입니다.</p>
<h3>기본적으로 활성화 (Turn it on by default)</h3>
<p>JIT가 기본적으로 활성화되어야 한다는 제안도 있었지만, 현재 JIT는 기존 특화 인터프리터(specializing interpreter)만큼 빠릅니다. 이는 미약하게 들릴 수 있지만, 상당한 성과이며 이 접근 방식이 추가 개발을 위해 <code>main</code>에 병합될 만큼 충분히 실행 가능하다고 간주된 주된 이유입니다. JIT가 기존 마이크로-옵 인터프리터에 비해 상당한 이점을 제공하지만, 항상 활성화되었을 때 명확한 이점을 제공하는 것은 아닙니다(특히 메모리 소비 증가 및 추가 빌드 타임 의존성을 고려할 때).</p>
<h3>여러 컴파일러 툴체인 지원 (Support multiple compiler toolchains)</h3>
<p>Clang은 CPython의 JIT 컴파일에 대한 continuation-passing-style 접근 방식에 필요한 보장된 테일 콜(guaranteed tail calls, <code>musttail</code>)을 지원하는 유일한 C 컴파일러이기 때문에 특별히 필요합니다. LLVM은 또한 JIT 빌드 프로세스에 필요한 다른 기능(객체 파일 파싱 및 역어셈블리 유틸리티)을 포함하며, 추가 툴체인은 추가적인 테스트 및 유지보수 부담을 초래하므로 현재는 하나의 툴체인(Clang)의 주요 버전만 지원하는 것이 편리합니다.</p>
<h3>기본 인터프리터의 바이트코드 컴파일 (Compile the base interpreter's bytecode)</h3>
<p>대부분의 copy-and-patch 선행 기술은 이를 빠른 베이스라인 JIT로 사용하지만, CPython의 JIT는 최적화된 마이크로-옵 트레이스를 컴파일하는 데 이 기술을 사용합니다. 새로운 JIT는 현재 다른 동적 언어 런타임의 "베이스라인" 및 "최적화" 컴파일러 계층 사이에 위치합니다. 이는 CPython이 특화 적응형 인터프리터를 사용하여 런타임 프로파일링 정보를 수집하여 코드의 "핫" 경로를 감지하고 최적화하기 때문입니다. 일반 바이트코드를 copy-and-patch를 사용하여 컴파일하는 것이 가능하지만(초기 프로토타입은 마이크로-옵 인터프리터보다 먼저 이것을 정확히 수행했음), 더 세분화된 마이크로-옵 형식만큼 충분한 최적화 잠재력을 제공하지 않는 것으로 보입니다.</p>
<h3>GPU 지원 추가 (Add GPU support)</h3>
<p>JIT는 현재 CPU 전용입니다. Numba와 같은 JIT와 달리 NumPy 배열 계산을 CUDA GPU로 오프로드하지 않습니다. 이러한 종류의 특수 작업을 가속화하기 위한 풍부한 도구 생태계가 이미 존재하며, CPython의 JIT는 이를 대체하기 위한 것이 아닙니다. 대신, 더 깊은 GPU 통합의 이점을 얻을 가능성이 적은 범용 파이썬 코드의 성능을 향상시키는 것을 목표로 합니다.</p>
<h2>미해결 문제 (Open Issues)</h2>
<h3>속도 (Speed)</h3>
<p>현재 JIT는 대부분의 플랫폼에서 기존 특화 인터프리터만큼 빠릅니다. 상당한 성능 향상을 제공하는 것이 JIT의 모든 동기이므로, 이를 개선하는 것이 현재 최우선 과제입니다. 여러 제안된 개선 사항이 이미 진행 중이며, 이 작업은 GH-115802에서 추적되고 있습니다.</p>
<h3>메모리 (Memory)</h3>
<p>실행 가능한 머신 코드를 위해 추가 메모리를 할당하므로 JIT는 런타임에 기존 인터프리터보다 더 많은 메모리를 사용합니다. 공식 벤치마크에 따르면 JIT는 현재 기본 인터프리터보다 약 10-20% 더 많은 메모리를 사용합니다. 아직 JIT의 메모리 사용량을 최적화하기 위한 많은 노력이 기울여지지 않았으므로, 이러한 수치는 시간이 지남에 따라 줄어들 최대치를 나타낼 가능성이 높습니다. 이는 중간 우선순위이며 GH-116017에서 추적되고 있습니다.</p>
<h3>의존성 (Dependencies)</h3>
<p>현재 JIT는 빌드 타임에 LLVM에 의존합니다. LLVM은 개별 마이크로-옵 명령어를 머신 코드 블롭(blobs)으로 컴파일하는 데 사용되며, 이들은 JIT의 템플릿을 형성하기 위해 함께 링크됩니다. JIT는 LLVM에 대한 런타임 의존성이 없으므로 최종 사용자에게 의존성으로 전혀 노출되지 않습니다. JIT를 빌드하면 플랫폼에 따라 빌드 프로세스에 3초에서 60초가 추가됩니다. JIT의 생성된 파일은 Git에 의해 추적되지 않습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/744\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/744/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/744\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"744\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/744\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T4537,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0744/\"\u003ePEP 744 - JIT Compilation\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Draft | \u003cstrong\u003e유형:\u003c/strong\u003e Informational | \u003cstrong\u003e작성일:\u003c/strong\u003e 11-Apr-2024\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 744: JIT Compilation\u003c/p\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e최근 CPython의 메인 개발 브랜치에 실험적인 JIT(Just-In-Time) 컴파일러가 병합되었습니다. 이 PEP는 JIT 컴파일러의 도입 배경, 설계 결정, 현재 구현 상태, 그리고 CPython의 영구적인 비실험적 기능으로 만들기 위한 향후 계획을 요약합니다. 이 문서는 JIT의 작동 방식에 대한 포괄적인 설명보다는, 선택된 접근 방식의 장단점과 도입 이후 제기된 질문에 답변하는 데 중점을 둡니다.\u003c/p\u003e\n\u003ch2\u003e도입 배경 (Motivation)\u003c/h2\u003e\n\u003cp\u003e기존 CPython은 파이썬 코드를 바이트코드로 컴파일한 후 런타임에 인터프리트(interpret)하는 방식으로 실행했습니다. Python 3.11부터 \"specializing adaptive interpreter\" (PEP 659)가 도입되어 런타임에 바이트코드 명령어를 타입 특화된 버전으로 재작성하여 상당한 성능 향상을 이루었지만, 개별 바이트코드 명령어의 경계로 인해 최적화 잠재력은 제한적이었습니다. Python 3.12부터는 C-like DSL(Domain-Specific Language)을 사용하여 인터프리터가 생성되며, 이는 유지보수를 용이하게 하고 새로운 실행 방식을 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003ePython 3.13부터는 마이크로-옵(micro-op) 번역, 최적화 및 실행 메커니즘이 모든 CPython 빌드에 포함되었으나 기본적으로 비활성화되어 있습니다. 인터프리터의 오버헤드가 크기 때문입니다. 이 병목 현상을 극복하기 위한 가장 확실한 전략은 이러한 최적화된 트레이스(traces)를 정적으로 컴파일하는 것입니다. 이는 여러 간접적인 호출 및 인터프리테이션으로 인한 오버헤드를 줄일 수 있는 기회를 제공합니다. 기존 최적화 파이프라인이 런타임 프로파일링 정보를 많이 사용하므로, 코드를 미리 컴파일하는 것보다 실행 \"직전\"에 최적화된 마이크로-옵을 컴파일하는 JIT 방식이 가장 유망한 접근 방식으로 간주됩니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003eJIT 컴파일러는 단순히 \"더 빠르게\" 만드는 마법이 아닙니다. 단일 플랫폼을 위한 최적화 컴파일러를 개발하고 유지보수하는 것은 매우 복잡하고 비용이 많이 드는 작업입니다. LLVM과 같은 기존 컴파일러 프레임워크를 사용하면 작업이 단순해질 수 있지만, 런타임 의존성이 증가하고 JIT 컴파일 오버헤드가 높아지는 단점이 있습니다.\u003c/p\u003e\n\u003cp\u003e파이썬 코드를 런타임에 성공적으로 컴파일하려면 고품질의 파이썬 특정 최적화와 최적화된 프로그램에 대한 효율적인 머신 코드(machine code)의 빠른 생성이 모두 필요합니다. CPython 코어 개발팀은 전자에 필요한 기술과 경험을 가지고 있으며, \"copy-and-patch\" 컴파일 방식이 후자에 대한 매력적인 해결책을 제공합니다. Copy-and-patch는 인터프리터의 나머지 부분을 생성하는 데 사용되는 동일한 DSL에서 고품질 템플릿 JIT 컴파일러를 생성할 수 있게 합니다. 이는 CPython 유지보수자가 바이트코드 정의를 편집하는 것만으로도 JIT 백엔드를 모든 JIT 지원 플랫폼에서 한 번에 \"무료로\" 업데이트할 수 있다는 큰 이점이 있습니다.\u003c/p\u003e\n\u003cp\u003eJIT 컴파일러는 인터프리터의 나머지 부분과 마찬가지로 빌드 타임(build time)에 생성되며 런타임 의존성이 없습니다. 광범위한 플랫폼을 지원하며 상대적으로 낮은 유지보수 부담을 가집니다. 현재 구현은 약 900줄의 빌드 타임 파이썬 코드와 500줄의 런타임 C 코드로 구성됩니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003cp\u003eJIT는 현재 기본 빌드 구성의 일부가 아니며, 예측 가능한 미래에도 그럴 가능성이 높습니다 (공식 바이너리에는 포함될 수 있음). JIT가 비실험적 기능이 되기 위한 조건은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e적어도 하나의 인기 있는 플랫폼에서 의미 있는 성능 향상(현실적으로 약 5% 수준)을 제공해야 합니다.\u003c/li\u003e\n\u003cli\u003e최소한의 방해로 빌드, 배포 및 배치가 가능해야 합니다.\u003c/li\u003e\n\u003cli\u003eSteering Council이 요청 시, 비활성화된 경우보다 활성화된 경우 커뮤니티에 더 많은 가치를 제공한다고 판단해야 합니다 (유지보수 부담, 메모리 사용량 또는 대체 설계의 실현 가능성과 같은 절충안 고려).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 기준은 시작점으로 간주되며 시간이 지남에 따라 확장될 수 있습니다. JIT가 비실험적이 되기 전까지는 프로덕션에서 사용해서는 안 되며, 경고 없이 언제든지 중단되거나 제거될 수 있습니다. JIT가 비실험적이지 않게 되면 \u003ccode\u003e--enable-optimizations\u003c/code\u003e 또는 \u003ccode\u003e--with-lto\u003c/code\u003e와 같은 다른 빌드 옵션과 동일하게 처리됩니다.\u003c/p\u003e\n\u003ch2\u003e지원 (Support)\u003c/h2\u003e\n\u003cp\u003eJIT는 PEP 11의 현재 Tier 1 플랫폼, 대부분의 Tier 2 플랫폼 및 하나의 Tier 3 플랫폼에서 개발되었습니다. CPython의 \u003ccode\u003emain\u003c/code\u003e 브랜치는 다음 플랫폼에서 JIT에 대한 릴리스 및 디버그 빌드를 CI로 구축하고 테스트합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eaarch64-apple-darwin/clang\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaarch64-pc-windows/msvc\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaarch64-unknown-linux-gnu/clang\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaarch64-unknown-linux-gnu/gcc\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ei686-pc-windows-msvc/msvc\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex86_64-apple-darwin/clang\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex86_64-pc-windows-msvc/msvc\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex86_64-unknown-linux-gnu/clang\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex86_64-unknown-linux-gnu/gcc\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e일부 플랫폼은 JIT 지원을 받지 못할 수도 있습니다 (예: \u003ccode\u003epowerpc64le-unknown-linux-gnu/gcc\u003c/code\u003e, \u003ccode\u003ewasm32-unknown-wasi/clang\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eJIT 지원이 추가되면 PEP 11에 명시된 대로 신뢰할 수 있는 CI/빌드봇을 가져야 하며, Tier 1 및 Tier 2 플랫폼에서의 JIT 실패는 릴리스를 차단해야 합니다. JIT 지원 제거는 하위 호환성(backwards-incompatible) 변경으로 간주되지 않지만, 합리적인 경우 PEP 387에 설명된 일반적인 Deprecation 프로세스를 따라야 합니다.\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e현재 인터프리터와 JIT 백엔드가 동일한 명세(specification)에서 생성되기 때문에 파이썬 코드의 동작은 완전히 변경되지 않아야 합니다. 테스트 중에 발견되고 수정된 관찰 가능한 차이점은 copy-and-patch 단계의 버그보다는 기존 마이크로-옵 번역 및 최적화 단계의 버그인 경향이 있었습니다.\u003c/p\u003e\n\u003ch2\u003e디버깅 (Debugging)\u003c/h2\u003e\n\u003cp\u003e파이썬 코드를 프로파일링하고 디버깅하는 도구는 계속 잘 작동합니다. 여기에는 \u003ccode\u003esys.monitoring\u003c/code\u003e, \u003ccode\u003esys.settrace\u003c/code\u003e, \u003ccode\u003esys.setprofile\u003c/code\u003e과 같은 파이썬 제공 기능을 사용하는 인-프로세스(in-process) 도구와 인터프리터 상태에서 파이썬 프레임을 탐색하는 아웃-오브-프로세스(out-of-process) 도구가 포함됩니다.\u003c/p\u003e\n\u003cp\u003e그러나 C 코드용 프로파일러 및 디버거는 현재 JIT 프레임을 통해 추적할 수 없는 것으로 보입니다. 리프 프레임(leaf frames)으로 작업하는 것은 가능하지만 (JIT 자체를 디버깅하는 방식), JIT 프레임에 적절한 디버깅 정보가 없기 때문에 유용성이 제한적입니다. 이는 해결해야 할 문제이지만, 현재로서는 우선순위가 높지 않습니다.\u003c/p\u003e\n\u003ch2\u003e보안 영향 (Security Implications)\u003c/h2\u003e\n\u003cp\u003e이 JIT는 다른 JIT와 마찬가지로 런타임에 대량의 실행 가능한 데이터(executable data)를 생성합니다. 이는 악의적인 행위자가 이 데이터의 내용에 영향을 미칠 수 있다면 임의의 코드(arbitrary code)를 실행할 수 있으므로 CPython에 잠재적인 새로운 공격 표면을 도입합니다. 이는 JIT 컴파일러의 잘 알려진 취약점입니다.\u003c/p\u003e\n\u003cp\u003e이러한 위험을 완화하기 위해 JIT는 모범 사례를 염두에 두고 작성되었습니다. 특히, 해당 데이터는 쓰기 가능한 상태로 유지되는 동안 JIT 컴파일러에 의해 프로그램의 다른 부분에 노출되지 않으며, 데이터가 쓰기 가능하고 실행 가능한 상태가 동시에 되는 지점은 없습니다. 템플릿 기반 JIT의 특성 또한 생성될 수 있는 코드의 종류를 심각하게 제한하여 성공적인 익스플로잇(exploit) 가능성을 더욱 줄입니다. 추가 예방 조치로, 템플릿 자체는 정적 읽기 전용 메모리에 저장됩니다.\u003c/p\u003e\n\u003ch2\u003eApple Silicon\u003c/h2\u003e\n\u003cp\u003emacOS 릴리스는 Hardened Runtime에 JIT Entitlement를 활성화해야 할 것으로 보입니다. 이는 파이썬 설치를 더 어렵게 만들지는 않지만, 릴리스 관리자가 수행해야 할 추가 단계를 추가할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e교육 방법 (How to Teach This)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e파이썬 프로그래머 또는 최종 사용자:\u003c/strong\u003e 아무것도 변경되지 않습니다. JIT가 실험적 기능인 동안에는 JIT가 활성화된 CPython 인터프리터를 배포받지 않을 것입니다. 비실험적이 되면 약간 더 나은 성능과 약간 더 높은 메모리 사용량을 느낄 수 있지만, 다른 변경 사항은 관찰할 수 없을 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e서드파티 패키지 유지보수자:\u003c/strong\u003e 아무것도 변경되지 않습니다. API 또는 ABI 변경 사항이 없으며 JIT는 서드파티 코드에 노출되지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e파이썬 코드 프로파일링 또는 디버깅:\u003c/strong\u003e 아무것도 변경되지 않습니다. 모든 파이썬 프로파일링 및 트레이싱 기능은 유지됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eC 코드 프로파일링 또는 디버깅:\u003c/strong\u003e 현재 JIT 프레임을 통한 추적 기능이 제한적입니다. 전체 C 호출 스택(call stack)을 관찰해야 하는 경우 문제가 발생할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e자체 파이썬 인터프리터 컴파일:\u003c/strong\u003e JIT를 빌드하고 싶지 않다면 무시해도 됩니다. 그렇지 않으면 호환되는 버전의 LLVM을 설치하고 빌드 스크립트에 적절한 플래그를 전달해야 합니다. 빌드에 최대 1분 더 걸릴 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCPython (또는 CPython 포크) 유지보수자:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e바이트코드 정의 또는 메인 인터프리터 루프 변경:\u003c/strong\u003e 일반적으로 JIT는 큰 불편을 주지 않을 것입니다. 더 큰 변경 사항(새로운 지역 변수 추가, 오류 처리 변경 등)은 JIT를 생성하는 데 사용되는 C 템플릿에 변경이 필요할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eJIT 자체 작업:\u003c/strong\u003e 파이썬 빌드 스크립트, JIT를 생성하는 데 사용되는 C 템플릿, JIT의 런타임 부분을 구성하는 C 코드를 정기적으로 수정하게 될 것입니다. 어셈블리에 익숙하고 컴파일러 관련 과정을 수강했으며 링커에 대한 블로그 게시물을 읽어본 것이 좋습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCPython의 다른 부분 유지보수:\u003c/strong\u003e 아무것도 변경되지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e참고 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003e주요 구현 부분은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTools/jit/README.md\u003c/code\u003e: JIT 빌드 지침\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/jit.c\u003c/code\u003e: JIT 컴파일러의 전체 런타임 부분\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejit_stencils.h\u003c/code\u003e: JIT 생성 템플릿 예시\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTools/jit/template.c\u003c/code\u003e: JIT 템플릿을 생성하기 위해 컴파일되는 코드\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTools/jit/_targets.py\u003c/code\u003e: 빌드 시 템플릿을 컴파일하고 파싱하는 코드\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e채택되지 않은 아이디어 (Rejected Ideas)\u003c/h2\u003e\n\u003ch3\u003eCPython 외부에서 유지보수 (Maintain it outside of CPython)\u003c/h3\u003e\n\u003cp\u003eJIT를 CPython 외부에서 유지보수하는 것이 가능할 수 있지만, 구현이 인터프리터의 나머지 부분과 너무 밀접하게 연결되어 있어 최신 상태로 유지하는 것이 실제 JIT를 개발하는 것보다 더 어려울 것입니다. 또한, 별도의 JIT 프로젝트 릴리스는 특정 CPython 프리릴리스 및 패치 릴리스와 일치해야 하므로 디버깅 노력을 복잡하게 만들 것입니다. JIT가 이미 상당히 안정적이고 궁극적인 목표는 CPython의 비실험적 부분이 되는 것이므로, \u003ccode\u003emain\u003c/code\u003e에 유지하는 것이 최선의 방법으로 보입니다.\u003c/p\u003e\n\u003ch3\u003e기본적으로 활성화 (Turn it on by default)\u003c/h3\u003e\n\u003cp\u003eJIT가 기본적으로 활성화되어야 한다는 제안도 있었지만, 현재 JIT는 기존 특화 인터프리터(specializing interpreter)만큼 빠릅니다. 이는 미약하게 들릴 수 있지만, 상당한 성과이며 이 접근 방식이 추가 개발을 위해 \u003ccode\u003emain\u003c/code\u003e에 병합될 만큼 충분히 실행 가능하다고 간주된 주된 이유입니다. JIT가 기존 마이크로-옵 인터프리터에 비해 상당한 이점을 제공하지만, 항상 활성화되었을 때 명확한 이점을 제공하는 것은 아닙니다(특히 메모리 소비 증가 및 추가 빌드 타임 의존성을 고려할 때).\u003c/p\u003e\n\u003ch3\u003e여러 컴파일러 툴체인 지원 (Support multiple compiler toolchains)\u003c/h3\u003e\n\u003cp\u003eClang은 CPython의 JIT 컴파일에 대한 continuation-passing-style 접근 방식에 필요한 보장된 테일 콜(guaranteed tail calls, \u003ccode\u003emusttail\u003c/code\u003e)을 지원하는 유일한 C 컴파일러이기 때문에 특별히 필요합니다. LLVM은 또한 JIT 빌드 프로세스에 필요한 다른 기능(객체 파일 파싱 및 역어셈블리 유틸리티)을 포함하며, 추가 툴체인은 추가적인 테스트 및 유지보수 부담을 초래하므로 현재는 하나의 툴체인(Clang)의 주요 버전만 지원하는 것이 편리합니다.\u003c/p\u003e\n\u003ch3\u003e기본 인터프리터의 바이트코드 컴파일 (Compile the base interpreter's bytecode)\u003c/h3\u003e\n\u003cp\u003e대부분의 copy-and-patch 선행 기술은 이를 빠른 베이스라인 JIT로 사용하지만, CPython의 JIT는 최적화된 마이크로-옵 트레이스를 컴파일하는 데 이 기술을 사용합니다. 새로운 JIT는 현재 다른 동적 언어 런타임의 \"베이스라인\" 및 \"최적화\" 컴파일러 계층 사이에 위치합니다. 이는 CPython이 특화 적응형 인터프리터를 사용하여 런타임 프로파일링 정보를 수집하여 코드의 \"핫\" 경로를 감지하고 최적화하기 때문입니다. 일반 바이트코드를 copy-and-patch를 사용하여 컴파일하는 것이 가능하지만(초기 프로토타입은 마이크로-옵 인터프리터보다 먼저 이것을 정확히 수행했음), 더 세분화된 마이크로-옵 형식만큼 충분한 최적화 잠재력을 제공하지 않는 것으로 보입니다.\u003c/p\u003e\n\u003ch3\u003eGPU 지원 추가 (Add GPU support)\u003c/h3\u003e\n\u003cp\u003eJIT는 현재 CPU 전용입니다. Numba와 같은 JIT와 달리 NumPy 배열 계산을 CUDA GPU로 오프로드하지 않습니다. 이러한 종류의 특수 작업을 가속화하기 위한 풍부한 도구 생태계가 이미 존재하며, CPython의 JIT는 이를 대체하기 위한 것이 아닙니다. 대신, 더 깊은 GPU 통합의 이점을 얻을 가능성이 적은 범용 파이썬 코드의 성능을 향상시키는 것을 목표로 합니다.\u003c/p\u003e\n\u003ch2\u003e미해결 문제 (Open Issues)\u003c/h2\u003e\n\u003ch3\u003e속도 (Speed)\u003c/h3\u003e\n\u003cp\u003e현재 JIT는 대부분의 플랫폼에서 기존 특화 인터프리터만큼 빠릅니다. 상당한 성능 향상을 제공하는 것이 JIT의 모든 동기이므로, 이를 개선하는 것이 현재 최우선 과제입니다. 여러 제안된 개선 사항이 이미 진행 중이며, 이 작업은 GH-115802에서 추적되고 있습니다.\u003c/p\u003e\n\u003ch3\u003e메모리 (Memory)\u003c/h3\u003e\n\u003cp\u003e실행 가능한 머신 코드를 위해 추가 메모리를 할당하므로 JIT는 런타임에 기존 인터프리터보다 더 많은 메모리를 사용합니다. 공식 벤치마크에 따르면 JIT는 현재 기본 인터프리터보다 약 10-20% 더 많은 메모리를 사용합니다. 아직 JIT의 메모리 사용량을 최적화하기 위한 많은 노력이 기울여지지 않았으므로, 이러한 수치는 시간이 지남에 따라 줄어들 최대치를 나타낼 가능성이 높습니다. 이는 중간 우선순위이며 GH-116017에서 추적되고 있습니다.\u003c/p\u003e\n\u003ch3\u003e의존성 (Dependencies)\u003c/h3\u003e\n\u003cp\u003e현재 JIT는 빌드 타임에 LLVM에 의존합니다. LLVM은 개별 마이크로-옵 명령어를 머신 코드 블롭(blobs)으로 컴파일하는 데 사용되며, 이들은 JIT의 템플릿을 형성하기 위해 함께 링크됩니다. JIT는 LLVM에 대한 런타임 의존성이 없으므로 최종 사용자에게 의존성으로 전혀 노출되지 않습니다. JIT를 빌드하면 플랫폼에 따라 빌드 프로세스에 3초에서 60초가 추가됩니다. JIT의 생성된 파일은 Git에 의해 추적되지 않습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Draft] PEP 744 - JIT Compilation\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 13:34:20+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>