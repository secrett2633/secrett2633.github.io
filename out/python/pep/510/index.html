<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/da5e1dc2b9a7c5bb.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-aecaf5ac7a84facf.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-e3ea38185bb36cd2.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 510 - Specialize functions with guards</h1><div class="page__meta"><time dateTime="2025-09-26 22:55:51+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0510/">PEP 510 - Specialize functions with guards</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 04-Jan-2016</p>
</blockquote>
<h2>PEP 510 – 가드(Guards)를 통한 함수 특수화 (Specialize functions with guards)</h2>
<ul>
<li><strong>작성자</strong>: Victor Stinner</li>
<li><strong>상태</strong>: <strong>거부됨 (Rejected)</strong></li>
<li><strong>유형</strong>: Standards Track</li>
<li><strong>작성일</strong>: 2016년 1월 4일</li>
<li><strong>Python 버전</strong>: 3.6</li>
</ul>
<hr>
<h3>거부 통지 (Rejection Notice)</h3>
<p>이 PEP는 저자에 의해 거부되었습니다. 제안된 설계가 눈에 띄는 속도 향상을 보여주지 못했으며, 가장 발전되고 복잡한 최적화를 구현할 시간이 부족했기 때문입니다.</p>
<h3>요약 (Abstract)</h3>
<p>이 PEP는 순수 Python 함수를 특수화(specialize)하기 위해 Python C API에 함수를 추가하는 것을 제안합니다. 이는 가드(guards)를 사용하여 특수화된 코드(specialized codes)를 추가하는 것으로, Python의 의미론(semantics)을 준수하면서 정적 최적화 도구를 구현할 수 있게 합니다.</p>
<h3>제안 배경 (Rationale)</h3>
<h4>Python의 의미론 (Python semantics)</h4>
<p>Python은 거의 모든 것이 변경 가능(mutable)하기 때문에 최적화하기 어렵습니다. 내장 함수(builtin functions), 함수 코드, 전역 변수(global variables), 지역 변수(local variables) 등이 런타임에 수정될 수 있습니다. Python의 의미론을 존중하면서 최적화를 구현하려면 "무언가가 변경되었을 때"를 감지해야 하며, 이러한 검사를 "가드(guards)"라고 부릅니다.</p>
<p>이 PEP는 함수에 가드를 가진 특수화된 코드를 추가하기 위한 공개 API를 Python C API에 추가할 것을 제안합니다. 함수가 호출될 때, 아무것도 변경되지 않았다면 특수화된 코드가 사용되고, 그렇지 않으면 원래의 바이트코드(bytecode)가 사용됩니다.</p>
<p>가드가 Python의 의미론 대부분을 준수하는 데 도움이 되지만, 정확한 동작에 미묘한 변경 없이 Python을 최적화하기는 어렵습니다. CPython은 오랜 역사를 가지고 있으며 많은 애플리케이션이 구현 세부 사항에 의존하고 있습니다. "모든 것이 변경 가능"이라는 특성과 성능 사이에서 타협점을 찾아야 합니다.</p>
<p>옵티마이저(optimizer)를 작성하는 것은 이 PEP의 범위를 벗어납니다.</p>
<h4>왜 JIT 컴파일러(JIT compiler)가 아닌가?</h4>
<p>현재 활발히 개발 중인 여러 Python JIT 컴파일러가 있습니다:</p>
<ul>
<li>PyPy</li>
<li>Pyston</li>
<li>Numba</li>
<li>Pyjion</li>
</ul>
<p>Numba는 수치 계산에 특화되어 있습니다. Pyston과 Pyjion은 아직 초기 단계입니다. PyPy는 가장 완벽한 Python 인터프리터로, 일반적으로 마이크로-벤치마크와 많은 매크로-벤치마크에서 CPython보다 빠르며 CPython과의 호환성이 매우 좋습니다 (Python 의미론을 존중합니다). 그럼에도 불구하고 Python JIT 컴파일러에는 CPython 대신 널리 사용되지 못하게 하는 문제점들이 있습니다.</p>
<p>numpy, PyGTK, PyQt, PySide, wxPython과 같은 많은 인기 라이브러리는 C 또는 C++로 구현되었으며 Python C API를 사용합니다. 작은 메모리 사용량(memory footprint)과 더 나은 성능을 위해, Python JIT 컴파일러는 더 빠른 가비지 컬렉터(garbage collector)를 사용하기 위해 레퍼런스 카운팅(reference counting)을 사용하지 않으며, CPython 객체의 C 구조체를 사용하지 않고 메모리 할당을 다르게 관리합니다. PyPy는 Python C API를 에뮬레이션하는 <code>cpyext</code> 모듈을 가지고 있지만, CPython보다 성능이 떨어지고 전체 Python C API를 지원하지 않습니다.</p>
<p>새로운 기능은 CPython에서 먼저 개발됩니다. 2016년 1월 기준으로, 최신 CPython 안정 버전은 3.5인 반면, PyPy는 Python 2.7과 3.2만 지원하고, Pyston은 Python 2.7만 지원합니다.</p>
<p>PyPy가 Python과 매우 좋은 호환성을 가지고 있음에도 불구하고, 일부 모듈은 여전히 PyPy와 호환되지 않습니다 (PyPy 호환성 Wiki 참조). Python C API의 불완전한 지원이 이 문제의 일부입니다. 또한 PyPy와 CPython 사이에는 레퍼런스 카운팅과 같은 미묘한 차이가 있습니다. 예를 들어, 객체 소멸자(destructors)는 PyPy에서 항상 호출되지만, CPython보다 "나중에" 호출될 수 있습니다. 컨텍스트 매니저(context managers)를 사용하면 리소스 해제 시점을 제어하는 데 도움이 됩니다.</p>
<p>PyPy가 광범위한 벤치마크에서 CPython보다 훨씬 빠르지만, 일부 사용자는 특정 사용 사례에서 CPython보다 성능이 떨어지거나 불안정한 성능을 보고하기도 합니다.</p>
<p>Python이 1분 미만으로 실행되는 프로그램의 스크립팅 언어로 사용될 때, JIT 컴파일러는 시작 시간이 더 길고 코드를 최적화하는 데 시간이 걸리기 때문에 더 느릴 수 있습니다. 예를 들어, 대부분의 Mercurial 명령어는 몇 초밖에 걸리지 않습니다.</p>
<p>Numba는 이제 선행 컴파일(ahead of time compilation)을 지원하지만, 인자(arguments) 타입을 지정하기 위해 데코레이터(decorator)가 필요하며 수치 타입만 지원합니다.</p>
<p>CPython 3.5는 거의 최적화가 없습니다. 피프홀 옵티마이저(peephole optimizer)는 기본적인 최적화만 구현합니다. 정적 컴파일러(static compiler)는 CPython 3.5와 PyPy 사이의 타협점입니다.</p>
<p><em>참고: Unladen Swallow 프로젝트도 있었지만, 2011년에 중단되었습니다.</em></p>
<h3>예시 (Examples)</h3>
<p>이 예시들은 중요한 속도 향상을 약속하는 강력한 최적화를 보여주기 위함이 아니라, 원리를 설명하기 위해 짧고 이해하기 쉽게 작성되었습니다.</p>
<h4>가상의 <code>myoptimizer</code> 모듈 (Hypothetical myoptimizer module)</h4>
<p>이 PEP의 예시들은 다음 함수와 타입을 제공하는 가상의 <code>myoptimizer</code> 모듈을 사용합니다:</p>
<ul>
<li><code>specialize(func, code, guards)</code>: 함수 <code>func</code>에 가드 <code>guards</code>를 가진 특수화된 코드 <code>code</code>를 추가합니다.</li>
<li><code>get_specialized(func)</code>: 특수화된 코드 목록을 <code>(code, guards)</code> 튜플 리스트로 가져옵니다. 여기서 <code>code</code>는 호출 가능(callable) 객체 또는 코드 객체이며, <code>guards</code>는 가드 리스트입니다.</li>
<li><code>GuardBuiltins(name)</code>: <code>builtins.__dict__[name]</code>과 <code>globals()[name]</code>을 감시하는 가드입니다. <code>builtins.__dict__[name]</code>이 교체되거나 <code>globals()[name]</code>이 설정되면 가드는 실패합니다.</li>
</ul>
<h4>바이트코드 사용 (Using bytecode)</h4>
<p>순수 내장 함수 <code>chr(65)</code>에 대한 호출을 결과인 <code>"A"</code>로 대체하는 특수화된 바이트코드를 추가하는 예시입니다.</p>
<pre><code class="language-python">import myoptimizer

def func():
    return chr(65)

def fast_func():
    return "A"

myoptimizer.specialize(func, fast_func.__code__, [myoptimizer.GuardBuiltins("chr")])
del fast_func
</code></pre>
<p>가드의 동작을 보여주는 예시:</p>
<pre><code class="language-python">print("func(): %s" % func())
print("#specialized: %s" % len(myoptimizer.get_specialized(func)))

import builtins
builtins.chr = lambda obj: "mock" # builtins.chr 변경

print("func(): %s" % func())
print("#specialized: %s" % len(myoptimizer.get_specialized(func)))
</code></pre>
<p>출력:</p>
<pre><code>func(): A
#specialized: 1

func(): mock
#specialized: 0
</code></pre>
<p>첫 번째 호출은 문자열 <code>"A"</code>를 반환하는 특수화된 바이트코드를 사용합니다. 두 번째 호출은 내장 <code>chr()</code> 함수가 교체되었기 때문에 특수화된 코드를 제거하고, <code>chr(65)</code>를 호출하는 원래 바이트코드를 실행합니다.</p>
<p>마이크로-벤치마크에서 특수화된 바이트코드 호출은 88 ns가 걸렸고, 원본 함수는 145 ns (+57 ns)가 걸렸습니다. 즉, 1.6배 빨랐습니다.</p>
<h4>내장 함수 사용 (Using builtin function)</h4>
<p><code>chr(obj)</code>를 호출하는 바이트코드 대신 C 내장 <code>chr()</code> 함수를 특수화된 코드로 추가하는 예시입니다.</p>
<pre><code class="language-python">import myoptimizer

def func(arg):
    return chr(arg)

myoptimizer.specialize(func, chr, [myoptimizer.GuardBuiltins("chr")])
</code></pre>
<p>가드의 동작을 보여주는 예시:</p>
<pre><code class="language-python">print("func(65): %s" % func(65))
print("#specialized: %s" % len(myoptimizer.get_specialized(func)))

import builtins
builtins.chr = lambda obj: "mock" # builtins.chr 변경

print("func(65): %s" % func(65))
print("#specialized: %s" % len(myoptimizer.get_specialized(func)))
</code></pre>
<p>출력:</p>
<pre><code>func(): A
#specialized: 1

func(): mock
#specialized: 0
</code></pre>
<p>첫 번째 호출은 C 내장 <code>chr()</code> 함수를 호출합니다 (Python 프레임을 생성하지 않음). 두 번째 호출은 내장 <code>chr()</code> 함수가 교체되었기 때문에 특수화된 코드를 제거하고 원래 바이트코드를 실행합니다.</p>
<p>마이크로-벤치마크에서 C 내장 함수 호출은 95 ns가 걸렸고, 원래 바이트코드는 155 ns (+60 ns)가 걸렸습니다. 즉, 1.6배 빨랐습니다. <code>chr(65)</code>를 직접 호출하는 것은 76 ns가 걸립니다.</p>
<h4>특수화된 코드 선택 (Choose the specialized code)</h4>
<p>순수 Python 함수를 호출하기 위해 특수화된 코드를 선택하는 의사 코드(pseudo-code):</p>
<pre><code class="language-python">def call_func(func, args, kwargs):
    specialized = myoptimizer.get_specialized(func)
    nspecialized = len(specialized)
    index = 0
    while index &#x3C; nspecialized:
        specialized_code, guards = specialized[index]
        for guard in guards:
            check = guard(args, kwargs)
            if check:
                break
        if not check: # 모든 가드가 성공: 특수화된 코드를 사용
            return specialized_code
        elif check == 1: # 가드가 일시적으로 실패: 다음 특수화된 코드를 시도
            index += 1
        else: # assert check == 2: 가드가 항상 실패: 특수화된 코드를 제거
            del specialized[index]
    # 각 특수화된 코드의 가드가 실패했거나, 함수에 특수화된 코드가 없는 경우,
    # 원래 바이트코드 사용
    code = func.__code__
    # ...
</code></pre>
<h3>변경 사항 (Changes)</h3>
<p>Python C API에 대한 변경 사항은 다음과 같습니다:</p>
<ul>
<li><code>PyFuncGuardObject</code> 객체와 <code>PyFuncGuard_Type</code> 타입을 추가합니다.</li>
<li><code>PySpecializedCode</code> 구조체를 추가합니다.</li>
<li><code>PyFunctionObject</code> 구조체에 다음 필드를 추가합니다:
<ul>
<li><code>Py_ssize_t nb_specialized;</code></li>
<li><code>PySpecializedCode *specialized;</code></li>
</ul>
</li>
<li>다음 함수 메서드를 추가합니다:
<ul>
<li><code>PyFunction_Specialize()</code></li>
<li><code>PyFunction_GetSpecializedCodes()</code></li>
<li><code>PyFunction_GetSpecializedCode()</code></li>
<li><code>PyFunction_RemoveSpecialized()</code></li>
<li><code>PyFunction_RemoveAllSpecialized()</code></li>
</ul>
</li>
</ul>
<p>이러한 함수와 타입 중 Python 레벨에 노출되는 것은 없습니다. 이 모든 추가 사항은 안정적인 ABI(stable ABI)에서 명시적으로 제외됩니다.</p>
<p>함수 코드가 교체될 때 (<code>func.__code__ = new_code</code>), 모든 특수화된 코드와 가드는 제거됩니다.</p>
<h4>함수 가드 (Function guard)</h4>
<p>함수 가드 객체를 추가합니다:</p>
<pre><code class="language-c">typedef struct {
    PyObject ob_base;
    int (*init) (PyObject *guard, PyObject *func);
    int (*check) (PyObject *guard, PyObject **stack, int na, int nk);
} PyFuncGuardObject;
</code></pre>
<p><code>init()</code> 함수는 가드를 초기화합니다:</p>
<ul>
<li>성공 시 0을 반환합니다.</li>
<li>가드가 항상 실패할 경우 1을 반환합니다: <code>PyFunction_Specialize()</code>는 특수화된 코드를 무시해야 합니다.</li>
<li>오류 발생 시 예외를 발생시키고 -1을 반환합니다.</li>
</ul>
<p><code>check()</code> 함수는 가드를 검사합니다:</p>
<ul>
<li>성공 시 0을 반환합니다.</li>
<li>가드가 일시적으로 실패한 경우 1을 반환합니다.</li>
<li>가드가 항상 실패할 경우 2를 반환합니다: 특수화된 코드를 제거해야 합니다.</li>
<li>오류 발생 시 예외를 발생시키고 -1을 반환합니다.</li>
</ul>
<p><code>stack</code>은 인자(arguments)의 배열입니다: 인덱스된 인자들 다음에 키워드 인자들의 <code>(key, value)</code> 쌍이 옵니다. <code>na</code>는 인덱스된 인자들의 개수입니다. <code>nk</code>는 키워드 인자들의 개수입니다 ( <code>(key, value)</code> 쌍의 개수). <code>stack</code>은 <code>na + nk * 2</code>개의 객체를 포함합니다.</p>
<h4>특수화된 코드 (Specialized code)</h4>
<p>특수화된 코드 구조체를 추가합니다:</p>
<pre><code class="language-c">typedef struct {
    PyObject *code; /* 호출 가능(callable) 객체 또는 코드 객체 */
    Py_ssize_t nb_guard;
    PyObject **guards; /* PyFuncGuardObject 객체들 */
} PySpecializedCode;
</code></pre>
<h4>함수 메서드 (Function methods)</h4>
<ul>
<li>
<p><code>PyFunction_Specialize(PyObject *func, PyObject *code, PyObject *guards)</code>
함수를 특수화하고, 가드를 가진 특수화된 코드를 추가하는 함수 메서드입니다.
<code>code</code>가 Python 함수인 경우, <code>code</code> 함수의 코드 객체가 특수화된 코드로 사용됩니다. 특수화된 Python 함수는 동일한 기본 매개변수(parameter defaults)와 키워드 매개변수 기본값을 가져야 하며, 특수화된 코드를 가져서는 안 됩니다.
<code>code</code>가 Python 함수 또는 코드 객체인 경우, 새로운 코드 객체가 생성되고 <code>func</code>의 코드 객체의 코드 이름과 첫 번째 줄 번호가 복사됩니다. 특수화된 코드는 동일한 Cell 변수(cell variables)와 Free 변수(free variables)를 가져야 합니다.
결과:</p>
<ul>
<li>성공 시 0을 반환합니다.</li>
<li>특수화가 무시된 경우 1을 반환합니다.</li>
<li>오류 발생 시 예외를 발생시키고 -1을 반환합니다.</li>
</ul>
</li>
<li>
<p><code>PyFunction_GetSpecializedCodes(PyObject *func)</code>
특수화된 코드 목록을 가져오는 함수 메서드입니다.
<code>code</code>가 호출 가능 객체 또는 코드 객체이고 <code>guards</code>가 <code>PyFuncGuard</code> 객체 목록인 <code>(code, guards)</code> 튜플 리스트를 반환합니다. 오류 발생 시 예외를 발생시키고 <code>NULL</code>을 반환합니다.</p>
</li>
<li>
<p><code>PyFunction_GetSpecializedCode(PyObject *func, PyObject **stack, int na, int nk)</code>
가드를 검사하여 특수화된 코드를 선택하는 함수 메서드입니다.
<code>stack</code>, <code>na</code>, <code>nk</code> 인자에 대해서는 가드의 <code>check()</code> 함수를 참조하십시오. 성공 시 호출 가능 객체 또는 코드 객체를 반환합니다. 오류 발생 시 예외를 발생시키고 <code>NULL</code>을 반환합니다.</p>
</li>
<li>
<p><code>PyFunction_RemoveSpecialized(PyObject *func, Py_ssize_t index)</code>
인덱스로 특수화된 코드와 해당 가드를 제거하는 함수 메서드입니다.
성공 시 또는 인덱스가 존재하지 않을 경우 0을 반환합니다. 오류 발생 시 예외를 발생시키고 -1을 반환합니다.</p>
</li>
<li>
<p><code>PyFunction_RemoveAllSpecialized(PyObject *func)</code>
함수의 모든 특수화된 코드와 가드를 제거하는 함수 메서드입니다.
성공 시 0을 반환합니다. <code>func</code>가 함수가 아닐 경우 예외를 발생시키고 -1을 반환합니다.</p>
</li>
</ul>
<h3>벤치마크 (Benchmark)</h3>
<p><code>python3.6 -m timeit -s 'def f(): pass' 'f()'</code> 에 대한 마이크로-벤치마크 (3회 실행 중 최적):</p>
<ul>
<li>원본 Python: 79 ns</li>
<li>패치된 Python: 79 ns</li>
</ul>
<p>이 마이크로-벤치마크에 따르면, 특수화 없이 Python 함수를 호출하는 데는 오버헤드가 없습니다.</p>
<h3>구현 (Implementation)</h3>
<p>이 PEP를 구현하는 패치는 이슈 #26098: PEP 510: Specialize functions with guards에 포함되어 있습니다.</p>
<h3>다른 Python 구현체 (Other implementations of Python)</h3>
<p>이 PEP는 Python C API에 대한 변경 사항만 포함하며, Python API는 변경되지 않습니다. 다른 Python 구현체는 새로운 추가 사항을 구현하지 않거나, 추가된 함수를 <code>no-op</code> (아무 작업도 하지 않는)으로 구현할 자유가 있습니다. 예를 들면 다음과 같습니다:</p>
<ul>
<li><code>PyFunction_Specialize()</code>: 항상 1을 반환합니다 (특수화가 무시됨).</li>
<li><code>PyFunction_GetSpecializedCodes()</code>: 항상 빈 리스트를 반환합니다.</li>
<li><code>PyFunction_GetSpecializedCode()</code>: 기존의 <code>PyFunction_GET_CODE()</code> 매크로처럼 함수 코드 객체를 반환합니다.</li>
</ul>
<h3>논의 (Discussion)</h3>
<p><code>python-ideas</code> 메일링 리스트의 스레드: RFC: PEP: Specialized functions with guards.</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인(public domain)에 있습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-aecaf5ac7a84facf.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-e3ea38185bb36cd2.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/510\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"x02Anhkwgp1He7ftuyAhh\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/510/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/510\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"510\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/510\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T489b,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0510/\"\u003ePEP 510 - Specialize functions with guards\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 04-Jan-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 510 – 가드(Guards)를 통한 함수 특수화 (Specialize functions with guards)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자\u003c/strong\u003e: Victor Stinner\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태\u003c/strong\u003e: \u003cstrong\u003e거부됨 (Rejected)\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형\u003c/strong\u003e: Standards Track\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e작성일\u003c/strong\u003e: 2016년 1월 4일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전\u003c/strong\u003e: 3.6\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e거부 통지 (Rejection Notice)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 저자에 의해 거부되었습니다. 제안된 설계가 눈에 띄는 속도 향상을 보여주지 못했으며, 가장 발전되고 복잡한 최적화를 구현할 시간이 부족했기 때문입니다.\u003c/p\u003e\n\u003ch3\u003e요약 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 순수 Python 함수를 특수화(specialize)하기 위해 Python C API에 함수를 추가하는 것을 제안합니다. 이는 가드(guards)를 사용하여 특수화된 코드(specialized codes)를 추가하는 것으로, Python의 의미론(semantics)을 준수하면서 정적 최적화 도구를 구현할 수 있게 합니다.\u003c/p\u003e\n\u003ch3\u003e제안 배경 (Rationale)\u003c/h3\u003e\n\u003ch4\u003ePython의 의미론 (Python semantics)\u003c/h4\u003e\n\u003cp\u003ePython은 거의 모든 것이 변경 가능(mutable)하기 때문에 최적화하기 어렵습니다. 내장 함수(builtin functions), 함수 코드, 전역 변수(global variables), 지역 변수(local variables) 등이 런타임에 수정될 수 있습니다. Python의 의미론을 존중하면서 최적화를 구현하려면 \"무언가가 변경되었을 때\"를 감지해야 하며, 이러한 검사를 \"가드(guards)\"라고 부릅니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 함수에 가드를 가진 특수화된 코드를 추가하기 위한 공개 API를 Python C API에 추가할 것을 제안합니다. 함수가 호출될 때, 아무것도 변경되지 않았다면 특수화된 코드가 사용되고, 그렇지 않으면 원래의 바이트코드(bytecode)가 사용됩니다.\u003c/p\u003e\n\u003cp\u003e가드가 Python의 의미론 대부분을 준수하는 데 도움이 되지만, 정확한 동작에 미묘한 변경 없이 Python을 최적화하기는 어렵습니다. CPython은 오랜 역사를 가지고 있으며 많은 애플리케이션이 구현 세부 사항에 의존하고 있습니다. \"모든 것이 변경 가능\"이라는 특성과 성능 사이에서 타협점을 찾아야 합니다.\u003c/p\u003e\n\u003cp\u003e옵티마이저(optimizer)를 작성하는 것은 이 PEP의 범위를 벗어납니다.\u003c/p\u003e\n\u003ch4\u003e왜 JIT 컴파일러(JIT compiler)가 아닌가?\u003c/h4\u003e\n\u003cp\u003e현재 활발히 개발 중인 여러 Python JIT 컴파일러가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePyPy\u003c/li\u003e\n\u003cli\u003ePyston\u003c/li\u003e\n\u003cli\u003eNumba\u003c/li\u003e\n\u003cli\u003ePyjion\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNumba는 수치 계산에 특화되어 있습니다. Pyston과 Pyjion은 아직 초기 단계입니다. PyPy는 가장 완벽한 Python 인터프리터로, 일반적으로 마이크로-벤치마크와 많은 매크로-벤치마크에서 CPython보다 빠르며 CPython과의 호환성이 매우 좋습니다 (Python 의미론을 존중합니다). 그럼에도 불구하고 Python JIT 컴파일러에는 CPython 대신 널리 사용되지 못하게 하는 문제점들이 있습니다.\u003c/p\u003e\n\u003cp\u003enumpy, PyGTK, PyQt, PySide, wxPython과 같은 많은 인기 라이브러리는 C 또는 C++로 구현되었으며 Python C API를 사용합니다. 작은 메모리 사용량(memory footprint)과 더 나은 성능을 위해, Python JIT 컴파일러는 더 빠른 가비지 컬렉터(garbage collector)를 사용하기 위해 레퍼런스 카운팅(reference counting)을 사용하지 않으며, CPython 객체의 C 구조체를 사용하지 않고 메모리 할당을 다르게 관리합니다. PyPy는 Python C API를 에뮬레이션하는 \u003ccode\u003ecpyext\u003c/code\u003e 모듈을 가지고 있지만, CPython보다 성능이 떨어지고 전체 Python C API를 지원하지 않습니다.\u003c/p\u003e\n\u003cp\u003e새로운 기능은 CPython에서 먼저 개발됩니다. 2016년 1월 기준으로, 최신 CPython 안정 버전은 3.5인 반면, PyPy는 Python 2.7과 3.2만 지원하고, Pyston은 Python 2.7만 지원합니다.\u003c/p\u003e\n\u003cp\u003ePyPy가 Python과 매우 좋은 호환성을 가지고 있음에도 불구하고, 일부 모듈은 여전히 PyPy와 호환되지 않습니다 (PyPy 호환성 Wiki 참조). Python C API의 불완전한 지원이 이 문제의 일부입니다. 또한 PyPy와 CPython 사이에는 레퍼런스 카운팅과 같은 미묘한 차이가 있습니다. 예를 들어, 객체 소멸자(destructors)는 PyPy에서 항상 호출되지만, CPython보다 \"나중에\" 호출될 수 있습니다. 컨텍스트 매니저(context managers)를 사용하면 리소스 해제 시점을 제어하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003ePyPy가 광범위한 벤치마크에서 CPython보다 훨씬 빠르지만, 일부 사용자는 특정 사용 사례에서 CPython보다 성능이 떨어지거나 불안정한 성능을 보고하기도 합니다.\u003c/p\u003e\n\u003cp\u003ePython이 1분 미만으로 실행되는 프로그램의 스크립팅 언어로 사용될 때, JIT 컴파일러는 시작 시간이 더 길고 코드를 최적화하는 데 시간이 걸리기 때문에 더 느릴 수 있습니다. 예를 들어, 대부분의 Mercurial 명령어는 몇 초밖에 걸리지 않습니다.\u003c/p\u003e\n\u003cp\u003eNumba는 이제 선행 컴파일(ahead of time compilation)을 지원하지만, 인자(arguments) 타입을 지정하기 위해 데코레이터(decorator)가 필요하며 수치 타입만 지원합니다.\u003c/p\u003e\n\u003cp\u003eCPython 3.5는 거의 최적화가 없습니다. 피프홀 옵티마이저(peephole optimizer)는 기본적인 최적화만 구현합니다. 정적 컴파일러(static compiler)는 CPython 3.5와 PyPy 사이의 타협점입니다.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e참고: Unladen Swallow 프로젝트도 있었지만, 2011년에 중단되었습니다.\u003c/em\u003e\u003c/p\u003e\n\u003ch3\u003e예시 (Examples)\u003c/h3\u003e\n\u003cp\u003e이 예시들은 중요한 속도 향상을 약속하는 강력한 최적화를 보여주기 위함이 아니라, 원리를 설명하기 위해 짧고 이해하기 쉽게 작성되었습니다.\u003c/p\u003e\n\u003ch4\u003e가상의 \u003ccode\u003emyoptimizer\u003c/code\u003e 모듈 (Hypothetical myoptimizer module)\u003c/h4\u003e\n\u003cp\u003e이 PEP의 예시들은 다음 함수와 타입을 제공하는 가상의 \u003ccode\u003emyoptimizer\u003c/code\u003e 모듈을 사용합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003especialize(func, code, guards)\u003c/code\u003e: 함수 \u003ccode\u003efunc\u003c/code\u003e에 가드 \u003ccode\u003eguards\u003c/code\u003e를 가진 특수화된 코드 \u003ccode\u003ecode\u003c/code\u003e를 추가합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eget_specialized(func)\u003c/code\u003e: 특수화된 코드 목록을 \u003ccode\u003e(code, guards)\u003c/code\u003e 튜플 리스트로 가져옵니다. 여기서 \u003ccode\u003ecode\u003c/code\u003e는 호출 가능(callable) 객체 또는 코드 객체이며, \u003ccode\u003eguards\u003c/code\u003e는 가드 리스트입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGuardBuiltins(name)\u003c/code\u003e: \u003ccode\u003ebuiltins.__dict__[name]\u003c/code\u003e과 \u003ccode\u003eglobals()[name]\u003c/code\u003e을 감시하는 가드입니다. \u003ccode\u003ebuiltins.__dict__[name]\u003c/code\u003e이 교체되거나 \u003ccode\u003eglobals()[name]\u003c/code\u003e이 설정되면 가드는 실패합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e바이트코드 사용 (Using bytecode)\u003c/h4\u003e\n\u003cp\u003e순수 내장 함수 \u003ccode\u003echr(65)\u003c/code\u003e에 대한 호출을 결과인 \u003ccode\u003e\"A\"\u003c/code\u003e로 대체하는 특수화된 바이트코드를 추가하는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport myoptimizer\r\n\r\ndef func():\r\n    return chr(65)\r\n\r\ndef fast_func():\r\n    return \"A\"\r\n\r\nmyoptimizer.specialize(func, fast_func.__code__, [myoptimizer.GuardBuiltins(\"chr\")])\r\ndel fast_func\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e가드의 동작을 보여주는 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eprint(\"func(): %s\" % func())\r\nprint(\"#specialized: %s\" % len(myoptimizer.get_specialized(func)))\r\n\r\nimport builtins\r\nbuiltins.chr = lambda obj: \"mock\" # builtins.chr 변경\r\n\r\nprint(\"func(): %s\" % func())\r\nprint(\"#specialized: %s\" % len(myoptimizer.get_specialized(func)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e출력:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc(): A\r\n#specialized: 1\r\n\r\nfunc(): mock\r\n#specialized: 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 호출은 문자열 \u003ccode\u003e\"A\"\u003c/code\u003e를 반환하는 특수화된 바이트코드를 사용합니다. 두 번째 호출은 내장 \u003ccode\u003echr()\u003c/code\u003e 함수가 교체되었기 때문에 특수화된 코드를 제거하고, \u003ccode\u003echr(65)\u003c/code\u003e를 호출하는 원래 바이트코드를 실행합니다.\u003c/p\u003e\n\u003cp\u003e마이크로-벤치마크에서 특수화된 바이트코드 호출은 88 ns가 걸렸고, 원본 함수는 145 ns (+57 ns)가 걸렸습니다. 즉, 1.6배 빨랐습니다.\u003c/p\u003e\n\u003ch4\u003e내장 함수 사용 (Using builtin function)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003echr(obj)\u003c/code\u003e를 호출하는 바이트코드 대신 C 내장 \u003ccode\u003echr()\u003c/code\u003e 함수를 특수화된 코드로 추가하는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport myoptimizer\r\n\r\ndef func(arg):\r\n    return chr(arg)\r\n\r\nmyoptimizer.specialize(func, chr, [myoptimizer.GuardBuiltins(\"chr\")])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e가드의 동작을 보여주는 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eprint(\"func(65): %s\" % func(65))\r\nprint(\"#specialized: %s\" % len(myoptimizer.get_specialized(func)))\r\n\r\nimport builtins\r\nbuiltins.chr = lambda obj: \"mock\" # builtins.chr 변경\r\n\r\nprint(\"func(65): %s\" % func(65))\r\nprint(\"#specialized: %s\" % len(myoptimizer.get_specialized(func)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e출력:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc(): A\r\n#specialized: 1\r\n\r\nfunc(): mock\r\n#specialized: 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 호출은 C 내장 \u003ccode\u003echr()\u003c/code\u003e 함수를 호출합니다 (Python 프레임을 생성하지 않음). 두 번째 호출은 내장 \u003ccode\u003echr()\u003c/code\u003e 함수가 교체되었기 때문에 특수화된 코드를 제거하고 원래 바이트코드를 실행합니다.\u003c/p\u003e\n\u003cp\u003e마이크로-벤치마크에서 C 내장 함수 호출은 95 ns가 걸렸고, 원래 바이트코드는 155 ns (+60 ns)가 걸렸습니다. 즉, 1.6배 빨랐습니다. \u003ccode\u003echr(65)\u003c/code\u003e를 직접 호출하는 것은 76 ns가 걸립니다.\u003c/p\u003e\n\u003ch4\u003e특수화된 코드 선택 (Choose the specialized code)\u003c/h4\u003e\n\u003cp\u003e순수 Python 함수를 호출하기 위해 특수화된 코드를 선택하는 의사 코드(pseudo-code):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef call_func(func, args, kwargs):\r\n    specialized = myoptimizer.get_specialized(func)\r\n    nspecialized = len(specialized)\r\n    index = 0\r\n    while index \u0026#x3C; nspecialized:\r\n        specialized_code, guards = specialized[index]\r\n        for guard in guards:\r\n            check = guard(args, kwargs)\r\n            if check:\r\n                break\r\n        if not check: # 모든 가드가 성공: 특수화된 코드를 사용\r\n            return specialized_code\r\n        elif check == 1: # 가드가 일시적으로 실패: 다음 특수화된 코드를 시도\r\n            index += 1\r\n        else: # assert check == 2: 가드가 항상 실패: 특수화된 코드를 제거\r\n            del specialized[index]\r\n    # 각 특수화된 코드의 가드가 실패했거나, 함수에 특수화된 코드가 없는 경우,\r\n    # 원래 바이트코드 사용\r\n    code = func.__code__\r\n    # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e변경 사항 (Changes)\u003c/h3\u003e\n\u003cp\u003ePython C API에 대한 변경 사항은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyFuncGuardObject\u003c/code\u003e 객체와 \u003ccode\u003ePyFuncGuard_Type\u003c/code\u003e 타입을 추가합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePySpecializedCode\u003c/code\u003e 구조체를 추가합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyFunctionObject\u003c/code\u003e 구조체에 다음 필드를 추가합니다:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePy_ssize_t nb_specialized;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePySpecializedCode *specialized;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e다음 함수 메서드를 추가합니다:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyFunction_Specialize()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyFunction_GetSpecializedCodes()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyFunction_GetSpecializedCode()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyFunction_RemoveSpecialized()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyFunction_RemoveAllSpecialized()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 함수와 타입 중 Python 레벨에 노출되는 것은 없습니다. 이 모든 추가 사항은 안정적인 ABI(stable ABI)에서 명시적으로 제외됩니다.\u003c/p\u003e\n\u003cp\u003e함수 코드가 교체될 때 (\u003ccode\u003efunc.__code__ = new_code\u003c/code\u003e), 모든 특수화된 코드와 가드는 제거됩니다.\u003c/p\u003e\n\u003ch4\u003e함수 가드 (Function guard)\u003c/h4\u003e\n\u003cp\u003e함수 가드 객체를 추가합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct {\r\n    PyObject ob_base;\r\n    int (*init) (PyObject *guard, PyObject *func);\r\n    int (*check) (PyObject *guard, PyObject **stack, int na, int nk);\r\n} PyFuncGuardObject;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003einit()\u003c/code\u003e 함수는 가드를 초기화합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e성공 시 0을 반환합니다.\u003c/li\u003e\n\u003cli\u003e가드가 항상 실패할 경우 1을 반환합니다: \u003ccode\u003ePyFunction_Specialize()\u003c/code\u003e는 특수화된 코드를 무시해야 합니다.\u003c/li\u003e\n\u003cli\u003e오류 발생 시 예외를 발생시키고 -1을 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003echeck()\u003c/code\u003e 함수는 가드를 검사합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e성공 시 0을 반환합니다.\u003c/li\u003e\n\u003cli\u003e가드가 일시적으로 실패한 경우 1을 반환합니다.\u003c/li\u003e\n\u003cli\u003e가드가 항상 실패할 경우 2를 반환합니다: 특수화된 코드를 제거해야 합니다.\u003c/li\u003e\n\u003cli\u003e오류 발생 시 예외를 발생시키고 -1을 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003estack\u003c/code\u003e은 인자(arguments)의 배열입니다: 인덱스된 인자들 다음에 키워드 인자들의 \u003ccode\u003e(key, value)\u003c/code\u003e 쌍이 옵니다. \u003ccode\u003ena\u003c/code\u003e는 인덱스된 인자들의 개수입니다. \u003ccode\u003enk\u003c/code\u003e는 키워드 인자들의 개수입니다 ( \u003ccode\u003e(key, value)\u003c/code\u003e 쌍의 개수). \u003ccode\u003estack\u003c/code\u003e은 \u003ccode\u003ena + nk * 2\u003c/code\u003e개의 객체를 포함합니다.\u003c/p\u003e\n\u003ch4\u003e특수화된 코드 (Specialized code)\u003c/h4\u003e\n\u003cp\u003e특수화된 코드 구조체를 추가합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct {\r\n    PyObject *code; /* 호출 가능(callable) 객체 또는 코드 객체 */\r\n    Py_ssize_t nb_guard;\r\n    PyObject **guards; /* PyFuncGuardObject 객체들 */\r\n} PySpecializedCode;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e함수 메서드 (Function methods)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePyFunction_Specialize(PyObject *func, PyObject *code, PyObject *guards)\u003c/code\u003e\r\n함수를 특수화하고, 가드를 가진 특수화된 코드를 추가하는 함수 메서드입니다.\r\n\u003ccode\u003ecode\u003c/code\u003e가 Python 함수인 경우, \u003ccode\u003ecode\u003c/code\u003e 함수의 코드 객체가 특수화된 코드로 사용됩니다. 특수화된 Python 함수는 동일한 기본 매개변수(parameter defaults)와 키워드 매개변수 기본값을 가져야 하며, 특수화된 코드를 가져서는 안 됩니다.\r\n\u003ccode\u003ecode\u003c/code\u003e가 Python 함수 또는 코드 객체인 경우, 새로운 코드 객체가 생성되고 \u003ccode\u003efunc\u003c/code\u003e의 코드 객체의 코드 이름과 첫 번째 줄 번호가 복사됩니다. 특수화된 코드는 동일한 Cell 변수(cell variables)와 Free 변수(free variables)를 가져야 합니다.\r\n결과:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e성공 시 0을 반환합니다.\u003c/li\u003e\n\u003cli\u003e특수화가 무시된 경우 1을 반환합니다.\u003c/li\u003e\n\u003cli\u003e오류 발생 시 예외를 발생시키고 -1을 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePyFunction_GetSpecializedCodes(PyObject *func)\u003c/code\u003e\r\n특수화된 코드 목록을 가져오는 함수 메서드입니다.\r\n\u003ccode\u003ecode\u003c/code\u003e가 호출 가능 객체 또는 코드 객체이고 \u003ccode\u003eguards\u003c/code\u003e가 \u003ccode\u003ePyFuncGuard\u003c/code\u003e 객체 목록인 \u003ccode\u003e(code, guards)\u003c/code\u003e 튜플 리스트를 반환합니다. 오류 발생 시 예외를 발생시키고 \u003ccode\u003eNULL\u003c/code\u003e을 반환합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePyFunction_GetSpecializedCode(PyObject *func, PyObject **stack, int na, int nk)\u003c/code\u003e\r\n가드를 검사하여 특수화된 코드를 선택하는 함수 메서드입니다.\r\n\u003ccode\u003estack\u003c/code\u003e, \u003ccode\u003ena\u003c/code\u003e, \u003ccode\u003enk\u003c/code\u003e 인자에 대해서는 가드의 \u003ccode\u003echeck()\u003c/code\u003e 함수를 참조하십시오. 성공 시 호출 가능 객체 또는 코드 객체를 반환합니다. 오류 발생 시 예외를 발생시키고 \u003ccode\u003eNULL\u003c/code\u003e을 반환합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePyFunction_RemoveSpecialized(PyObject *func, Py_ssize_t index)\u003c/code\u003e\r\n인덱스로 특수화된 코드와 해당 가드를 제거하는 함수 메서드입니다.\r\n성공 시 또는 인덱스가 존재하지 않을 경우 0을 반환합니다. 오류 발생 시 예외를 발생시키고 -1을 반환합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePyFunction_RemoveAllSpecialized(PyObject *func)\u003c/code\u003e\r\n함수의 모든 특수화된 코드와 가드를 제거하는 함수 메서드입니다.\r\n성공 시 0을 반환합니다. \u003ccode\u003efunc\u003c/code\u003e가 함수가 아닐 경우 예외를 발생시키고 -1을 반환합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e벤치마크 (Benchmark)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epython3.6 -m timeit -s 'def f(): pass' 'f()'\u003c/code\u003e 에 대한 마이크로-벤치마크 (3회 실행 중 최적):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e원본 Python: 79 ns\u003c/li\u003e\n\u003cli\u003e패치된 Python: 79 ns\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 마이크로-벤치마크에 따르면, 특수화 없이 Python 함수를 호출하는 데는 오버헤드가 없습니다.\u003c/p\u003e\n\u003ch3\u003e구현 (Implementation)\u003c/h3\u003e\n\u003cp\u003e이 PEP를 구현하는 패치는 이슈 #26098: PEP 510: Specialize functions with guards에 포함되어 있습니다.\u003c/p\u003e\n\u003ch3\u003e다른 Python 구현체 (Other implementations of Python)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 Python C API에 대한 변경 사항만 포함하며, Python API는 변경되지 않습니다. 다른 Python 구현체는 새로운 추가 사항을 구현하지 않거나, 추가된 함수를 \u003ccode\u003eno-op\u003c/code\u003e (아무 작업도 하지 않는)으로 구현할 자유가 있습니다. 예를 들면 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyFunction_Specialize()\u003c/code\u003e: 항상 1을 반환합니다 (특수화가 무시됨).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyFunction_GetSpecializedCodes()\u003c/code\u003e: 항상 빈 리스트를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyFunction_GetSpecializedCode()\u003c/code\u003e: 기존의 \u003ccode\u003ePyFunction_GET_CODE()\u003c/code\u003e 매크로처럼 함수 코드 객체를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e논의 (Discussion)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003epython-ideas\u003c/code\u003e 메일링 리스트의 스레드: RFC: PEP: Specialized functions with guards.\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 있습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 510 - Specialize functions with guards\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:55:51+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>