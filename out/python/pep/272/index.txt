3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","185","static/chunks/app/layout-29f3b81c3a382114.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js"],""]
4:["slug","python/pep/272","c"]
0:["vurCQsCzY_vgt4Jj6xcPJ",[[["",{"children":[["slug","python/pep/272","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"272\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/272","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/773b243a13a00265.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
a:I[646,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js"],"default"]
9:T2ad5,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0272/">PEP 272 - API for Block Encryption Algorithms v1.0</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Informational | <strong>작성일:</strong> 18-Sep-2001</p>
</blockquote>
<p>파이썬 PEP 272: 블록 암호화 알고리즘을 위한 API v1.0</p>
<h2>개요</h2>
<p>이 문서는 DES 또는 Rijndael과 같은 비밀 키(secret-key) 블록 암호화 알고리즘을 위한 표준 API를 정의합니다. 이를 통해 다양한 알고리즘 및 구현 간의 전환을 용이하게 합니다.</p>
<h2>소개</h2>
<p>암호화 알고리즘은 가변 키(key)에 따라 입력 데이터(평문, plaintext)를 변환하여 암호문(ciphertext)을 생성합니다. 이 변환은 키를 아는 경우에만 쉽게 되돌릴 수 있습니다. 키는 매우 큰 가능한 키 공간에서 선택된 비트(bit) 시퀀스입니다. 암호화 알고리즘에는 블록 암호(block ciphers)와 스트림 암호(stream ciphers)의 두 가지 유형이 있습니다.</p>
<p>블록 암호는 고정된 크기(자주 8 또는 16 바이트)의 멀티바이트 입력을 암호화하며, 다양한 피드백 모드(feedback modes)로 작동할 수 있습니다. 이 PEP에서 지원되는 피드백 모드는 다음과 같습니다:</p>
<p>| 숫자 | 상수        | 설명              |
|----|-------------|-------------------|
| 1  | <code>MODE_ECB</code>  | Electronic Code Book |
| 2  | <code>MODE_CBC</code>  | Cipher Block Chaining |
| 3  | <code>MODE_CFB</code>  | Cipher Feedback   |
| 5  | <code>MODE_OFB</code>  | Output Feedback   |
| 6  | <code>MODE_CTR</code>  | Counter           |</p>
<p>이러한 모드는 NIST 발행물 SP 800-38A에 설명된 대로 구현되어야 합니다. 처음 세 가지 피드백 모드에 대한 설명은 Bruce Schneier의 저서 Applied Cryptography에서도 찾을 수 있습니다.</p>
<p>참고로 숫자 4는 RFC 2440("OpenPGP Message Format")에 설명된 CFB의 변형인 <code>MODE_PGP</code>를 위해 예약되어 있습니다. 이 모드는 모든 블록 암호화에 필수적으로 요구될 만큼 중요하게 간주되지는 않지만, 지원하는 것은 좋은 추가 기능입니다.</p>
<p>엄밀히 말해 스트림 암호는 데이터를 비트 단위로 암호화합니다. 실제로 스트림 암호는 문자 단위로 작동합니다. 이 PEP는 블록 암호에 대한 인터페이스를 지정하는 것을 목표로 하며, 스트림 암호는 <code>block_size</code>를 1로 고정함으로써 여기에 설명된 인터페이스를 지원할 수 있습니다. 또한 피드백 모드는 스트림 암호에 적합하지 않으므로, 유일하게 합리적인 피드백 모드는 <code>ECB</code> 모드가 될 것입니다.</p>
<h2>사양 (Specification)</h2>
<p>암호화 모듈은 이 PEP에 설명된 것 외에 추가 함수, 메서드 및 속성을 추가할 수 있습니다. 그러나 모듈이 이 PEP 준수를 주장하려면 이 PEP에 설명된 모든 기능이 존재해야 합니다.</p>
<p>비밀 키(secret-key) 암호화 모듈은 다음 함수를 정의해야 합니다:</p>
<p><code>new(key, mode, [IV], **kwargs)</code></p>
<p>이 함수는 문자열 <code>key</code>에 포함된 비밀 키를 사용하고 위에 표에 있는 상수 중 하나여야 하는 피드백 모드 <code>mode</code>를 사용하여 암호화 객체(ciphering object)를 반환합니다.</p>
<p><code>mode</code>가 <code>MODE_CBC</code> 또는 <code>MODE_CFB</code>인 경우, <code>IV</code>는 반드시 제공되어야 하며, 블록 크기와 동일한 길이의 문자열이어야 합니다. <code>IV</code> 값을 제공하지 않으면 <code>ValueError</code> 예외가 발생합니다.</p>
<p>알고리즘에 따라 모듈은 이 함수에 추가 키워드 인수(keyword arguments)를 지원할 수 있습니다. 이 PEP에서 지정하는 일부 키워드 인수도 있으며, 모듈은 추가 키워드 인수를 자유롭게 추가할 수 있습니다. 주어진 키워드에 대해 값이 제공되지 않으면 안전한 기본값(secure default value)이 사용되어야 합니다. 예를 들어, 알고리즘이 1에서 16 사이의 라운드(rounds) 수를 선택할 수 있고, 1라운드 암호화는 안전하지 않으며 8라운드 암호화가 안전하다고 여겨진다면, <code>rounds</code>의 기본값은 8 이상이어야 합니다. (모듈 구현자는 이 예에서 16과 같이 매우 느리지만 안전한 값을 선택할 수도 있습니다. 이 결정은 구현자에게 달려 있습니다).</p>
<p>다음 표는 이 PEP에 의해 정의된 키워드 인수들을 나열합니다:</p>
<p>| 키워드       | 의미                                                                    |
|------------|-------------------------------------------------------------------------|
| <code>counter</code>  | 카운터 블록을 반환하는 호출 가능한 객체 (<code>CTR</code> 모드 전용)                  |
| <code>rounds</code>   | 사용할 암호화 라운드 수                                                 |
| <code>segment_size</code> | 데이터 및 암호문 세그먼트의 크기 (비트 단위; <code>CFB</code> 모드 전용) |</p>
<p><code>Counter</code> 피드백 모드는 출력을 생성하는 데 사용되는 카운터(counters)라고 불리는 입력 블록 시퀀스를 필요로 합니다. <code>mode</code>가 <code>MODE_CTR</code>일 때, <code>counter</code> 키워드 인수는 반드시 제공되어야 하며, 그 값은 함수나 메서드와 같은 호출 가능한 객체(callable object)여야 합니다. 이 호출 가능한 객체에 대한 연속적인 호출은 <code>block_size</code> 길이의 반복되지 않는 문자열 시퀀스를 반환해야 합니다. (NIST 발행물의 부록 B는 이러한 시퀀스를 생성하는 방법을 제공하지만, 이는 이 PEP의 범위를 벗어납니다).</p>
<p><code>CFB</code> 모드는 <code>segment_size</code> 비트 길이의 평문 및 암호문 세그먼트에서 작동합니다. 따라서 이 모드를 사용할 때는 입력 및 출력 문자열의 길이가 <code>segment_size</code> 비트의 배수여야 합니다. <code>segment_size</code>는 1에서 <code>block_size</code> * 8 사이의 정수여야 합니다 (8을 곱하는 이유는 <code>block_size</code>가 바이트 단위로 측정되기 때문입니다). 이 매개변수의 기본값은 <code>block_size</code> * 8이어야 합니다. 구현자는 단순화를 위해 <code>segment_size</code>를 8의 배수로 제한할 수 있지만, 일반성을 위해 임의의 값을 지원하는 것이 권장됩니다.</p>
<p>비밀 키 암호화 모듈은 두 가지 변수를 정의해야 합니다:</p>
<ul>
<li><code>block_size</code>: 정수 값으로, 이 모듈이 암호화하는 블록의 크기를 바이트 단위로 측정합니다. 모든 피드백 모드에서 <code>encrypt()</code> 및 <code>decrypt()</code>에 전달되는 문자열의 길이는 블록 크기의 배수여야 합니다.</li>
<li><code>key_size</code>: 정수 값으로, 이 모듈이 요구하는 키의 크기를 바이트 단위로 측정합니다. <code>key_size</code>가 <code>None</code>이면, 알고리즘은 가변 길이 키를 허용합니다. 이는 모듈이 임의의 길이의 키를 허용하거나, 16, 24, 또는 32 바이트와 같이 몇 가지 다른 가능한 길이를 가질 수 있음을 의미할 수 있습니다. 길이 0의 키(즉, null 문자열 <code>''</code>)는 가변 길이 키로 전달할 수 없습니다.</li>
</ul>
<p>암호 객체(Cipher objects)는 두 가지 속성을 가져야 합니다:</p>
<ul>
<li><code>block_size</code>: 이 객체에 의해 암호화되는 블록의 크기와 동일한 정수 값입니다. 가변 블록 크기를 가진 알고리즘의 경우, 이 값은 이 객체에 대해 선택된 블록 크기와 같습니다.</li>
<li><code>IV</code>: 암호 피드백 모드를 시작하는 데 사용될 초기 값(initial value)을 포함합니다. 항상 정확히 한 블록 길이의 문자열입니다. 문자열을 암호화하거나 복호화한 후, 이 값은 수정된 피드백 텍스트를 반영하도록 업데이트됩니다. 이는 읽기 전용이며, 새 값을 할당할 수 없습니다.</li>
</ul>
<p>암호 객체는 다음 메서드를 요구합니다:</p>
<ul>
<li><code>decrypt(string)</code>: 객체의 키 종속 데이터와 적절한 피드백 모드를 사용하여 <code>string</code>을 복호화합니다. 문자열의 길이는 알고리즘의 블록 크기 또는 <code>CFB</code> 모드의 경우 세그먼트 크기의 정확한 배수여야 합니다. 평문(plaintext)을 포함하는 문자열을 반환합니다.</li>
<li><code>encrypt(string)</code>: 객체의 키 종속 데이터와 적절한 피드백 모드를 사용하여 비어있지 않은 문자열을 암호화합니다. 문자열의 길이는 알고리즘의 블록 크기 또는 <code>CFB</code> 모드의 경우 세그먼트 크기의 정확한 배수여야 합니다. 암호문(ciphertext)을 포함하는 문자열을 반환합니다.</li>
</ul>
<p>다음은 'DES'라는 모듈을 사용한 예시입니다:</p>
<pre><code class="language-python">>>> import DES
>>> obj = DES.new('abcdefgh', DES.MODE_ECB)
>>> plaintext = "Guido van Rossum is a space alien."
>>> len(plaintext)
34
>>> obj.encrypt(plaintext)
Traceback (innermost last):
  File "&#x3C;stdin>", line 1, in ?
ValueError: Strings for DES must be a multiple of 8 in length
>>> ciphertext = obj.encrypt(plaintext + 'XXXXXX') # 패딩 추가 (Add padding)
>>> ciphertext
'\021,\343Nq\214DY\337T\342pA\372\255\311s\210\363,\300j\330\250\312\347\342I\3215w\03561\303dgb/\006'
>>> obj.decrypt(ciphertext)
'Guido van Rossum is a space alien.XXXXXX'
</code></pre>
<h2>변경 사항 (Changes)</h2>
<ul>
<li><strong>2002년 4월:</strong> 스트림 암호에 대한 참조를 제거하고, PEP 제목을 변경했으며, 피드백 모드 상수에 <code>MODE_</code> 접두사를 붙였습니다. <code>PGP</code> 피드백 모드를 제거하고, <code>CTR</code> 및 <code>OFB</code> 피드백 모드를 추가했습니다. 숫자가 바이트 단위로 측정되는지 비트 단위로 측정되는지를 명확히 했습니다.</li>
<li><strong>2002년 9월:</strong> "arbitrary-length" 대신 "variable-length keys"를 사용하여 키 길이 논의를 명확히 했습니다.</li>
</ul>
<h2>감사의 글 (Acknowledgements)</h2>
<p>이 PEP에 대한 의견을 주신 python-crypto 목록 독자들에게 감사드립니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)에 있습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",2279,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 272 - API for Block Encryption Algorithms v1.0"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 17:52:18+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}],["$","$La",null,{"postPermalink":"/python/pep/272/","postId":"2025-09-26-pep-0272-api-for-block-encryption-algorithms-v1-0"}],["$","section",null,{"className":"mt-12 border-t border-gray-200 pt-8","children":[["$","h3",null,{"className":"text-base font-semibold text-gray-900 mb-4","children":["Python"," 의 다른글"]}],["$","ul",null,{"className":"space-y-2 text-sm","children":[["$","li",null,{"className":"text-gray-500","children":["이전글"," ",["$","$L7",null,{"href":"/python/pep/271/","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Rejected] PEP 271 - Prefixing sys.path by command line option"}]]}],["$","li",null,{"className":"text-gray-900 font-semibold","children":["현재글 : ","[Final] PEP 272 - API for Block Encryption Algorithms v1.0"]}],["$","li",null,{"className":"text-gray-500","children":["다음글"," ",["$","$L7",null,{"href":"/python/pep/273/","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Final] PEP 273 - Import Modules from Zip Archives"}]]}]]}]]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://blog.secrett2633.cloud/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://blog.secrett2633.cloud/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","22",{"name":"next-size-adjust"}]]
1:null
