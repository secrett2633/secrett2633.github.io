<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 651 - Robust Stack Overflow Handling</h1><div class="page__meta"><time dateTime="2025-09-27 01:41:16+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0651/">PEP 651 - Robust Stack Overflow Handling</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 18-Jan-2021</p>
</blockquote>
<h1>PEP 651 – 견고한 스택 오버플로우 처리</h1>
<ul>
<li><strong>작성자:</strong> Mark Shannon</li>
<li><strong>상태:</strong> 거절됨 (Rejected)</li>
<li><strong>유형:</strong> 표준 트랙 (Standards Track)</li>
<li><strong>생성일:</strong> 2021년 1월 18일</li>
<li><strong>최종 수정일:</strong> 2025년 2월 1일</li>
</ul>
<h2>거절 공지 (Rejection Notice)</h2>
<p>이 PEP는 Python Steering Council에 의해 거절되었습니다.</p>
<h2>초록 (Abstract)</h2>
<p>이 PEP는 Python이 머신 스택 오버플로우(machine stack overflow)를 제어 불능 재귀(runaway recursion)와 다르게 처리해야 한다고 제안합니다. 이를 통해 프로그램이 필요에 따라 최대 재귀 깊이(maximum recursion depth)를 설정하고, 추가적인 안전 보장(safety guarantees)을 제공할 수 있습니다.</p>
<p>이 PEP가 수락된다면, 다음 프로그램은 안전하게 완료될 것입니다.</p>
<pre><code class="language-python">sys.setrecursionlimit(1_000_000)
def f(n):
    if n:
        f(n-1)
f(500_000)
</code></pre>
<p>그리고 다음 프로그램은 VM 충돌 없이 <code>StackOverflow</code> 예외를 발생시킬 것입니다.</p>
<pre><code class="language-python">sys.setrecursionlimit(1_000_000)
class X:
    def __add__(self, other):
        return self + other
X() + 1
</code></pre>
<h2>동기 (Motivation)</h2>
<p>CPython은 제어 불능 재귀와 C 스택 오버플로우를 모두 방지하기 위해 단일 재귀 깊이 카운터(recursion depth counter)를 사용합니다. 그러나 제어 불능 재귀와 머신 스택 오버플로우는 서로 다른 문제입니다. 머신 스택 오버플로우를 허용하는 것은 잠재적인 보안 취약점이 될 수 있지만, 재귀 깊이를 제한하는 것은 Python에서 일부 알고리즘의 사용을 막을 수 있습니다.</p>
<p>현재, 프로그램이 깊은 재귀를 필요로 하는 경우, 정확하게 실행하는 데 필요한 최소값과 메모리 보호 오류(memory protection error)를 피하기 위한 최대값 사이에서 허용되는 최대 재귀 깊이를 관리해야 합니다.</p>
<p>C 스택 오버플로우 검사와 재귀 깊이 검사를 분리함으로써, 순수 Python 프로그램은 필요한 재귀 수준을 사용하여 안전하게 실행될 수 있습니다.</p>
<h2>근거 (Rationale)</h2>
<p>CPython은 현재 가상 머신(Virtual Machine)의 잠재적으로 위험한 스택 오버플로우와 Python 프로그램의 제어 불능 재귀를 막기 위해 단일 제한(single limit)에 의존하고 있습니다. 이는 C 스택과 Python 호출 스택(call stacks)을 결합(couples)하는 구현의 결과입니다. 이 결합을 해제함으로써 CPython의 유용성(usability)과 안전성(safety)을 모두 향상시킬 수 있습니다.</p>
<p>재귀 제한은 제어 불능 재귀로부터 보호하기 위해 존재하며, 가상 머신의 무결성(integrity)은 이에 의존해서는 안 됩니다. 마찬가지로 재귀는 구현 세부 사항(implementation details)에 의해 제한되어서는 안 됩니다.</p>
<h2>명세 (Specification)</h2>
<p><code>StackOverflow</code>와 <code>RecursionOverflow</code>라는 두 개의 새로운 예외 클래스가 추가될 예정이며, 둘 다 <code>RecursionError</code>의 서브클래스가 될 것입니다.</p>
<h3><code>StackOverflow</code> 예외</h3>
<p>인터프리터 또는 내장 모듈 코드가 C 스택이 안전 한계에 도달했거나 가까워지고 있다고 판단할 때마다 <code>StackOverflow</code> 예외가 발생합니다. <code>StackOverflow</code>는 <code>RecursionError</code>의 서브클래스이므로, <code>RecursionError</code>를 처리하는 모든 코드는 <code>StackOverflow</code>도 처리할 것입니다.</p>
<h3><code>RecursionOverflow</code> 예외</h3>
<p>Python 함수 호출이 재귀 제한을 초과할 때 <code>RecursionOverflow</code> 예외가 발생합니다. 이는 현재 <code>RecursionError</code>를 발생시키는 동작에서 약간의 변경입니다. <code>RecursionOverflow</code>는 <code>RecursionError</code>의 서브클래스이므로, <code>RecursionError</code>를 처리하는 모든 코드는 이전처럼 계속 작동할 것입니다.</p>
<h3>Python 스택과 C 스택 분리 (Decoupling the Python stack from the C stack)</h3>
<p>위의 보장을 제공하고 이전에 작동했던 모든 프로그램이 계속 작동하도록 보장하려면, Python 스택과 C 스택을 분리해야 합니다. 즉, Python 함수에서 Python 함수를 호출할 때 C 스택 공간을 소비하지 않아야 합니다. 내장 함수(builtin functions)를 호출하거나 내장 함수로부터 호출할 때는 계속 C 스택 공간을 소비합니다.</p>
<p>C 스택의 크기는 구현에 따라 정의되며, 머신마다 다를 수 있습니다. 심지어 스레드(threads)마다 다를 수도 있습니다. 그러나 이전 기본값으로 재귀 제한이 설정되었을 때 실행될 수 있었던 모든 코드는 계속 실행될 것이라는 기대가 있습니다.</p>
<p>Python의 많은 연산은 C 레벨에서 어떤 종류의 호출을 수행합니다. 이들 대부분은 계속 C 스택을 소비하며, 통제되지 않은 재귀가 발생하면 <code>StackOverflow</code> 예외가 발생할 것입니다.</p>
<h2>다른 구현 (Other Implementations)</h2>
<p>다른 구현(예: PyPy, Jython)은 재귀 제한이 어떤 값으로 설정되더라도 안전하게 실패해야 합니다.</p>
<p>구현이 Python 스택을 기본 VM 또는 하드웨어 스택과 결합하는 경우, 재귀 제한을 초과하지만 기본 스택이 오버플로우되지 않을 때 <code>RecursionOverflow</code> 예외를 발생시켜야 합니다. 기본 스택이 오버플로우되거나 오버플로우에 가까운 경우, <code>StackOverflow</code> 예외가 발생해야 합니다.</p>
<h2>C-API</h2>
<p>새로운 함수 <code>Py_CheckStackDepth()</code>가 추가될 예정이며, <code>Py_EnterRecursiveCall()</code>의 동작이 약간 수정될 것입니다.</p>
<h3><code>Py_CheckStackDepth()</code></h3>
<p><code>int Py_CheckStackDepth(const char *where)</code>는 C 스택 오버플로우의 즉각적인 위험이 없을 경우 <code>0</code>을 반환합니다. C 스택이 오버플로우에 가까운 경우 <code>-1</code>을 반환하고 예외를 설정합니다. <code>where</code> 매개변수는 <code>Py_EnterRecursiveCall()</code>의 <code>where</code> 매개변수와 같은 방식으로 예외 메시지에 사용됩니다.</p>
<h3><code>Py_EnterRecursiveCall()</code></h3>
<p><code>Py_EnterRecursiveCall()</code>은 현재 기능을 수행하기 전에 <code>Py_CheckStackDepth()</code>를 호출하도록 수정될 것입니다.</p>
<h3><code>PyLeaveRecursiveCall()</code></h3>
<p><code>Py_LeaveRecursiveCall()</code>은 변경되지 않고 유지될 것입니다.</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>이 기능은 Python 레벨에서 완전히 하위 호환됩니다. 머신 코드 디버거(machine-code debuggers)와 같은 일부 낮은 수준의 도구는 수정이 필요할 것입니다. 예를 들어, Python용 gdb 스크립트는 C 프레임당 하나 이상의 Python 프레임이 있을 수 있음을 인지해야 할 것입니다.</p>
<p><code>Py_EnterRecursiveCall()</code>, <code>PyLeaveRecursiveCall()</code> 함수 쌍을 사용하는 C 코드는 계속 올바르게 작동할 것입니다. 또한, <code>Py_EnterRecursiveCall()</code>은 <code>StackOverflow</code> 예외를 발생시킬 수 있습니다.</p>
<p>새로운 코드는 재귀 제한과 관련하여 Python 함수 호출로 간주되기를 원하지 않는 한 <code>Py_CheckStackDepth()</code> 함수를 사용해야 합니다.</p>
<p>Cython 생성 함수와 같은 "Python과 유사한(python-like)" 코드는 <code>Py_EnterRecursiveCall()</code>을 사용하고, 다른 코드는 <code>Py_CheckStackDepth()</code>를 사용할 것을 권장합니다.</p>
<h2>보안 영향 (Security Implications)</h2>
<p>재귀를 통해 CPython 가상 머신을 충돌시키는 것이 더 이상 불가능해질 것입니다.</p>
<h2>성능 영향 (Performance Impact)</h2>
<p>성능 영향은 중요하지 않을 것으로 예상됩니다.</p>
<p>필요한 추가 로직은 성능에 매우 작은 부정적인 영향을 미칠 것입니다. C 스택 사용 감소로 인한 참조 지역성(locality of reference) 향상은 작은 긍정적인 영향을 미칠 것입니다.</p>
<p>전반적인 효과가 긍정적일지 부정적일지 예측하기 어렵지만, 순 효과는 측정하기에는 너무 작을 가능성이 높습니다.</p>
<h2>구현 (Implementation)</h2>
<h3>C 스택 소비 모니터링 (Monitoring C stack consumption)</h3>
<p>C 스택 오버플로우가 임박했는지 측정하는 것은 어렵습니다. 따라서 보수적으로 접근해야 합니다. 스택의 안전한 경계(safe bounds)를 결정해야 하는데, 이는 이식성 있는 C 코드(portable C code)에서는 불가능합니다.</p>
<p>주요 플랫폼의 경우, 플랫폼별 API를 사용하여 정확한 스택 경계를 제공할 것입니다. 그러나 마이너 플랫폼의 경우 어느 정도 추측이 필요할 수 있습니다. 이는 좋지 않게 들릴 수 있지만, <code>_PyEval_EvalFrameDefault</code>에서 <code>_PyEval_EvalFrameDefault</code>로 이어지는 호출 체인에 필요한 스택 공간의 최소 1000배가 C 스택 크기라고 추측하는 현재 상황보다 나쁘지 않습니다.</p>
<p>이는 일부 경우에 가능한 재귀 양이 줄어들 수 있음을 의미합니다. 그러나 일반적으로 많은 호출이 C 스택을 사용하지 않으므로 가능한 재귀 양은 증가해야 합니다.</p>
<p>C 스택에 대한 제한을 결정하는 일반적인 접근 방식은 호출 체인에서 가능한 한 빨리 현재 C 프레임 내의 주소를 얻는 것입니다. 그 다음, 해당 주소에 상수를 더하여 제한을 추측할 수 있습니다.</p>
<h3>C 스택을 소비하지 않는 Python-to-Python 호출 (Making Python-to-Python calls without consuming the C stack)</h3>
<p>인터프리터 내의 호출은 <code>CALL_FUNCTION</code>, <code>CALL_FUNCTION_KW</code>, <code>CALL_FUNCTION_EX</code>, <code>CALL_METHOD</code> 명령에 의해 처리됩니다. 이러한 명령에 대한 코드는 Python 함수 또는 메서드가 호출될 때 C에서 호출을 수행하는 대신, 인터프리터가 호출 대상의 프레임(callee's frame)을 설정하고 평소처럼 해석을 계속하도록 수정될 것입니다.</p>
<p><code>RETURN_VALUE</code> 명령은 역 작업을 수행하며, 현재 프레임이 인터프리터의 엔트리 프레임(entry frame)일 때는 평소처럼 반환됩니다.</p>
<h2>거절된 아이디어 (Rejected Ideas)</h2>
<p>현재까지 없음.</p>
<h2>미해결 문제 (Open Issues)</h2>
<p>현재까지 없음.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain) 또는 CC0-1.0-Universal 라이선스(둘 중 더 허용적인 것) 하에 배포됩니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/651\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/651/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/651\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"651\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/651\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T2da9,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0651/\"\u003ePEP 651 - Robust Stack Overflow Handling\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 18-Jan-2021\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 651 – 견고한 스택 오버플로우 처리\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Mark Shannon\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 거절됨 (Rejected)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e 표준 트랙 (Standards Track)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2021년 1월 18일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e최종 수정일:\u003c/strong\u003e 2025년 2월 1일\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e거절 공지 (Rejection Notice)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 Python Steering Council에 의해 거절되었습니다.\u003c/p\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 Python이 머신 스택 오버플로우(machine stack overflow)를 제어 불능 재귀(runaway recursion)와 다르게 처리해야 한다고 제안합니다. 이를 통해 프로그램이 필요에 따라 최대 재귀 깊이(maximum recursion depth)를 설정하고, 추가적인 안전 보장(safety guarantees)을 제공할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP가 수락된다면, 다음 프로그램은 안전하게 완료될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esys.setrecursionlimit(1_000_000)\ndef f(n):\n    if n:\n        f(n-1)\nf(500_000)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 다음 프로그램은 VM 충돌 없이 \u003ccode\u003eStackOverflow\u003c/code\u003e 예외를 발생시킬 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esys.setrecursionlimit(1_000_000)\nclass X:\n    def __add__(self, other):\n        return self + other\nX() + 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003eCPython은 제어 불능 재귀와 C 스택 오버플로우를 모두 방지하기 위해 단일 재귀 깊이 카운터(recursion depth counter)를 사용합니다. 그러나 제어 불능 재귀와 머신 스택 오버플로우는 서로 다른 문제입니다. 머신 스택 오버플로우를 허용하는 것은 잠재적인 보안 취약점이 될 수 있지만, 재귀 깊이를 제한하는 것은 Python에서 일부 알고리즘의 사용을 막을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e현재, 프로그램이 깊은 재귀를 필요로 하는 경우, 정확하게 실행하는 데 필요한 최소값과 메모리 보호 오류(memory protection error)를 피하기 위한 최대값 사이에서 허용되는 최대 재귀 깊이를 관리해야 합니다.\u003c/p\u003e\n\u003cp\u003eC 스택 오버플로우 검사와 재귀 깊이 검사를 분리함으로써, 순수 Python 프로그램은 필요한 재귀 수준을 사용하여 안전하게 실행될 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003eCPython은 현재 가상 머신(Virtual Machine)의 잠재적으로 위험한 스택 오버플로우와 Python 프로그램의 제어 불능 재귀를 막기 위해 단일 제한(single limit)에 의존하고 있습니다. 이는 C 스택과 Python 호출 스택(call stacks)을 결합(couples)하는 구현의 결과입니다. 이 결합을 해제함으로써 CPython의 유용성(usability)과 안전성(safety)을 모두 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e재귀 제한은 제어 불능 재귀로부터 보호하기 위해 존재하며, 가상 머신의 무결성(integrity)은 이에 의존해서는 안 됩니다. 마찬가지로 재귀는 구현 세부 사항(implementation details)에 의해 제한되어서는 안 됩니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eStackOverflow\u003c/code\u003e와 \u003ccode\u003eRecursionOverflow\u003c/code\u003e라는 두 개의 새로운 예외 클래스가 추가될 예정이며, 둘 다 \u003ccode\u003eRecursionError\u003c/code\u003e의 서브클래스가 될 것입니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eStackOverflow\u003c/code\u003e 예외\u003c/h3\u003e\n\u003cp\u003e인터프리터 또는 내장 모듈 코드가 C 스택이 안전 한계에 도달했거나 가까워지고 있다고 판단할 때마다 \u003ccode\u003eStackOverflow\u003c/code\u003e 예외가 발생합니다. \u003ccode\u003eStackOverflow\u003c/code\u003e는 \u003ccode\u003eRecursionError\u003c/code\u003e의 서브클래스이므로, \u003ccode\u003eRecursionError\u003c/code\u003e를 처리하는 모든 코드는 \u003ccode\u003eStackOverflow\u003c/code\u003e도 처리할 것입니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eRecursionOverflow\u003c/code\u003e 예외\u003c/h3\u003e\n\u003cp\u003ePython 함수 호출이 재귀 제한을 초과할 때 \u003ccode\u003eRecursionOverflow\u003c/code\u003e 예외가 발생합니다. 이는 현재 \u003ccode\u003eRecursionError\u003c/code\u003e를 발생시키는 동작에서 약간의 변경입니다. \u003ccode\u003eRecursionOverflow\u003c/code\u003e는 \u003ccode\u003eRecursionError\u003c/code\u003e의 서브클래스이므로, \u003ccode\u003eRecursionError\u003c/code\u003e를 처리하는 모든 코드는 이전처럼 계속 작동할 것입니다.\u003c/p\u003e\n\u003ch3\u003ePython 스택과 C 스택 분리 (Decoupling the Python stack from the C stack)\u003c/h3\u003e\n\u003cp\u003e위의 보장을 제공하고 이전에 작동했던 모든 프로그램이 계속 작동하도록 보장하려면, Python 스택과 C 스택을 분리해야 합니다. 즉, Python 함수에서 Python 함수를 호출할 때 C 스택 공간을 소비하지 않아야 합니다. 내장 함수(builtin functions)를 호출하거나 내장 함수로부터 호출할 때는 계속 C 스택 공간을 소비합니다.\u003c/p\u003e\n\u003cp\u003eC 스택의 크기는 구현에 따라 정의되며, 머신마다 다를 수 있습니다. 심지어 스레드(threads)마다 다를 수도 있습니다. 그러나 이전 기본값으로 재귀 제한이 설정되었을 때 실행될 수 있었던 모든 코드는 계속 실행될 것이라는 기대가 있습니다.\u003c/p\u003e\n\u003cp\u003ePython의 많은 연산은 C 레벨에서 어떤 종류의 호출을 수행합니다. 이들 대부분은 계속 C 스택을 소비하며, 통제되지 않은 재귀가 발생하면 \u003ccode\u003eStackOverflow\u003c/code\u003e 예외가 발생할 것입니다.\u003c/p\u003e\n\u003ch2\u003e다른 구현 (Other Implementations)\u003c/h2\u003e\n\u003cp\u003e다른 구현(예: PyPy, Jython)은 재귀 제한이 어떤 값으로 설정되더라도 안전하게 실패해야 합니다.\u003c/p\u003e\n\u003cp\u003e구현이 Python 스택을 기본 VM 또는 하드웨어 스택과 결합하는 경우, 재귀 제한을 초과하지만 기본 스택이 오버플로우되지 않을 때 \u003ccode\u003eRecursionOverflow\u003c/code\u003e 예외를 발생시켜야 합니다. 기본 스택이 오버플로우되거나 오버플로우에 가까운 경우, \u003ccode\u003eStackOverflow\u003c/code\u003e 예외가 발생해야 합니다.\u003c/p\u003e\n\u003ch2\u003eC-API\u003c/h2\u003e\n\u003cp\u003e새로운 함수 \u003ccode\u003ePy_CheckStackDepth()\u003c/code\u003e가 추가될 예정이며, \u003ccode\u003ePy_EnterRecursiveCall()\u003c/code\u003e의 동작이 약간 수정될 것입니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ePy_CheckStackDepth()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eint Py_CheckStackDepth(const char *where)\u003c/code\u003e는 C 스택 오버플로우의 즉각적인 위험이 없을 경우 \u003ccode\u003e0\u003c/code\u003e을 반환합니다. C 스택이 오버플로우에 가까운 경우 \u003ccode\u003e-1\u003c/code\u003e을 반환하고 예외를 설정합니다. \u003ccode\u003ewhere\u003c/code\u003e 매개변수는 \u003ccode\u003ePy_EnterRecursiveCall()\u003c/code\u003e의 \u003ccode\u003ewhere\u003c/code\u003e 매개변수와 같은 방식으로 예외 메시지에 사용됩니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ePy_EnterRecursiveCall()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ePy_EnterRecursiveCall()\u003c/code\u003e은 현재 기능을 수행하기 전에 \u003ccode\u003ePy_CheckStackDepth()\u003c/code\u003e를 호출하도록 수정될 것입니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ePyLeaveRecursiveCall()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ePy_LeaveRecursiveCall()\u003c/code\u003e은 변경되지 않고 유지될 것입니다.\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e이 기능은 Python 레벨에서 완전히 하위 호환됩니다. 머신 코드 디버거(machine-code debuggers)와 같은 일부 낮은 수준의 도구는 수정이 필요할 것입니다. 예를 들어, Python용 gdb 스크립트는 C 프레임당 하나 이상의 Python 프레임이 있을 수 있음을 인지해야 할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePy_EnterRecursiveCall()\u003c/code\u003e, \u003ccode\u003ePyLeaveRecursiveCall()\u003c/code\u003e 함수 쌍을 사용하는 C 코드는 계속 올바르게 작동할 것입니다. 또한, \u003ccode\u003ePy_EnterRecursiveCall()\u003c/code\u003e은 \u003ccode\u003eStackOverflow\u003c/code\u003e 예외를 발생시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e새로운 코드는 재귀 제한과 관련하여 Python 함수 호출로 간주되기를 원하지 않는 한 \u003ccode\u003ePy_CheckStackDepth()\u003c/code\u003e 함수를 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003eCython 생성 함수와 같은 \"Python과 유사한(python-like)\" 코드는 \u003ccode\u003ePy_EnterRecursiveCall()\u003c/code\u003e을 사용하고, 다른 코드는 \u003ccode\u003ePy_CheckStackDepth()\u003c/code\u003e를 사용할 것을 권장합니다.\u003c/p\u003e\n\u003ch2\u003e보안 영향 (Security Implications)\u003c/h2\u003e\n\u003cp\u003e재귀를 통해 CPython 가상 머신을 충돌시키는 것이 더 이상 불가능해질 것입니다.\u003c/p\u003e\n\u003ch2\u003e성능 영향 (Performance Impact)\u003c/h2\u003e\n\u003cp\u003e성능 영향은 중요하지 않을 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e필요한 추가 로직은 성능에 매우 작은 부정적인 영향을 미칠 것입니다. C 스택 사용 감소로 인한 참조 지역성(locality of reference) 향상은 작은 긍정적인 영향을 미칠 것입니다.\u003c/p\u003e\n\u003cp\u003e전반적인 효과가 긍정적일지 부정적일지 예측하기 어렵지만, 순 효과는 측정하기에는 너무 작을 가능성이 높습니다.\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003ch3\u003eC 스택 소비 모니터링 (Monitoring C stack consumption)\u003c/h3\u003e\n\u003cp\u003eC 스택 오버플로우가 임박했는지 측정하는 것은 어렵습니다. 따라서 보수적으로 접근해야 합니다. 스택의 안전한 경계(safe bounds)를 결정해야 하는데, 이는 이식성 있는 C 코드(portable C code)에서는 불가능합니다.\u003c/p\u003e\n\u003cp\u003e주요 플랫폼의 경우, 플랫폼별 API를 사용하여 정확한 스택 경계를 제공할 것입니다. 그러나 마이너 플랫폼의 경우 어느 정도 추측이 필요할 수 있습니다. 이는 좋지 않게 들릴 수 있지만, \u003ccode\u003e_PyEval_EvalFrameDefault\u003c/code\u003e에서 \u003ccode\u003e_PyEval_EvalFrameDefault\u003c/code\u003e로 이어지는 호출 체인에 필요한 스택 공간의 최소 1000배가 C 스택 크기라고 추측하는 현재 상황보다 나쁘지 않습니다.\u003c/p\u003e\n\u003cp\u003e이는 일부 경우에 가능한 재귀 양이 줄어들 수 있음을 의미합니다. 그러나 일반적으로 많은 호출이 C 스택을 사용하지 않으므로 가능한 재귀 양은 증가해야 합니다.\u003c/p\u003e\n\u003cp\u003eC 스택에 대한 제한을 결정하는 일반적인 접근 방식은 호출 체인에서 가능한 한 빨리 현재 C 프레임 내의 주소를 얻는 것입니다. 그 다음, 해당 주소에 상수를 더하여 제한을 추측할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003eC 스택을 소비하지 않는 Python-to-Python 호출 (Making Python-to-Python calls without consuming the C stack)\u003c/h3\u003e\n\u003cp\u003e인터프리터 내의 호출은 \u003ccode\u003eCALL_FUNCTION\u003c/code\u003e, \u003ccode\u003eCALL_FUNCTION_KW\u003c/code\u003e, \u003ccode\u003eCALL_FUNCTION_EX\u003c/code\u003e, \u003ccode\u003eCALL_METHOD\u003c/code\u003e 명령에 의해 처리됩니다. 이러한 명령에 대한 코드는 Python 함수 또는 메서드가 호출될 때 C에서 호출을 수행하는 대신, 인터프리터가 호출 대상의 프레임(callee's frame)을 설정하고 평소처럼 해석을 계속하도록 수정될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eRETURN_VALUE\u003c/code\u003e 명령은 역 작업을 수행하며, 현재 프레임이 인터프리터의 엔트리 프레임(entry frame)일 때는 평소처럼 반환됩니다.\u003c/p\u003e\n\u003ch2\u003e거절된 아이디어 (Rejected Ideas)\u003c/h2\u003e\n\u003cp\u003e현재까지 없음.\u003c/p\u003e\n\u003ch2\u003e미해결 문제 (Open Issues)\u003c/h2\u003e\n\u003cp\u003e현재까지 없음.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain) 또는 CC0-1.0-Universal 라이선스(둘 중 더 허용적인 것) 하에 배포됩니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 651 - Robust Stack Overflow Handling\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 01:41:16+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>