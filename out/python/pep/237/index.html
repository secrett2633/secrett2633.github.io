<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 237 - Unifying Long Integers and Integers</h1><div class="page__meta"><time dateTime="2025-09-26 17:06:31+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0237/">PEP 237 - Unifying Long Integers and Integers</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 11-Mar-2001</p>
</blockquote>
<h1>PEP 237 – Long Integers와 Integers의 통합</h1>
<ul>
<li><strong>작성자:</strong> Moshe Zadka, Guido van Rossum</li>
<li><strong>상태:</strong> Final (최종)</li>
<li><strong>유형:</strong> Standards Track (표준 트랙)</li>
<li><strong>작성일:</strong> 2001년 3월 11일</li>
<li><strong>Python 버전:</strong> 2.2</li>
<li><strong>개정 이력:</strong> 2001년 3월 16일, 2001년 8월 14일, 2001년 8월 23일</li>
</ul>
<h2>초록 (Abstract)</h2>
<p>현재 Python은 두 가지 종류의 정수(integer)를 구분합니다: C <code>long</code> 타입의 크기(일반적으로 32 또는 64비트)에 제한되는 일반 <code>int</code> (또는 <code>short int</code>)와, 가용 메모리에 의해서만 제한되는 <code>long int</code>입니다. <code>short int</code>에 대한 연산 결과가 C <code>long</code>의 범위에 맞지 않으면 오류를 발생시킵니다. 이 외에도 몇 가지 다른 차이점이 있습니다. 이 PEP는 Python 사용자 관점에서 이 두 가지 타입의 대부분의 의미론적 차이를 없애고, 이들을 통합할 것을 제안합니다.</p>
<h2>배경 (Rationale)</h2>
<p>많은 프로그램에서 나중에 더 큰 숫자를 다룰 필요가 생기며, 알고리즘을 변경하는 것은 번거로운 일입니다. 모든 산술 연산이 <code>long int</code>를 사용하여 수행될 경우, 필요하지 않을 때도 성능 저하가 발생할 수 있습니다.</p>
<p>머신의 워드(word) 크기가 언어에 노출되는 것은 이식성(portability)을 저해합니다. 예를 들어, Python 소스 파일과 <code>.pyc</code> 파일은 이 문제 때문에 32비트 및 64비트 머신 간에 이식 가능하지 않습니다.</p>
<p>대부분의 애플리케이션에서 불필요한 세부 사항은 Python 사용자로부터 숨겨져야 한다는 일반적인 바람도 있습니다. 예를 들어, C에서는 명시적인 메모리 할당이 Python에서는 자동화되어 문자열, 리스트 등에서 무제한 크기의 편리함을 제공합니다. 이러한 편리함을 숫자로 확장하는 것은 합리적입니다.</p>
<p>이는 새로운 Python 프로그래머(프로그래밍 자체에 새로 접하는 사람이든 아니든)가 언어를 사용하기 시작하기 전에 배워야 할 것을 하나 줄여줄 것입니다.</p>
<h2>구현 (Implementation)</h2>
<p>초기에는 두 가지 대체 구현 방안이 제안되었습니다 (각 저자가 하나씩).</p>
<ol>
<li><code>PyInt</code> 타입의 C <code>long</code> 슬롯을 <code>union</code> 타입으로 변경하여, 작은 숫자와 큰 숫자를 모두 처리할 수 있도록 하는 방안. 모든 <code>PyInt</code> 함수는 이 <code>union</code>의 특정 비트를 확인하여 어떤 연산을 사용할지 결정합니다.</li>
<li>기존 <code>short int</code> 및 <code>long int</code> 타입을 유지하되, 연산 결과가 <code>short int</code>로 표현될 수 없을 때 <code>OverflowError</code>를 발생시키는 대신 <code>long int</code>를 반환하도록 합니다. <code>int</code>와 <code>long</code> 구현 타입의 추상 베이스 타입인 새로운 <code>integer</code> 타입을 도입할 수 있습니다. 이는 <code>if isinstance(i, integer): ...</code> 와 같이 한 번의 테스트로 정수 여부를 확인할 수 있도록 합니다.</li>
</ol>
<p>고려 끝에 두 번째 구현 계획이 채택되었습니다. 이는 구현이 훨씬 쉽고, C API 수준에서 하위 호환성을 유지하며, 과도기적 조치로서 부분적으로 구현될 수 있기 때문입니다.</p>
<h2>비호환성 (Incompatibilities)</h2>
<p>다음 연산들은 <code>short int</code>와 <code>long int</code>에 대해 (보통 미묘하게) 다른 의미론을 가지며, 이 중 하나는 변경되어야 합니다. 이는 철저한 목록입니다.</p>
<ul>
<li><strong>산술 연산자:</strong> 현재 <code>&#x3C;&#x3C;</code>를 제외한 모든 <code>short int</code> 산술 연산자는 결과가 <code>short int</code>로 표현될 수 없을 때 <code>OverflowError</code>를 발생시킵니다. 이는 <code>long int</code>를 대신 반환하도록 변경됩니다. <code>x+y</code>, <code>x-y</code>, <code>x*y</code>, <code>x**y</code>, <code>divmod(x, y)</code>, <code>x/y</code>, <code>x%y</code>, <code>-x</code> 등이 영향을 받습니다.</li>
<li><strong>좌측 시프트 (<code>x &#x3C;&#x3C; n</code>):</strong> 현재 <code>short int</code>의 경우 비트 손실이 발생할 수 있습니다. 이는 <code>short int</code>를 반환하면 비트가 손실될 경우 (부호 변경도 비트 손실의 특별한 경우로 간주) 시프트된 모든 비트를 포함하는 <code>long int</code>를 반환하도록 변경됩니다.</li>
<li><strong>16진수 (<code>hex</code>) 및 8진수 (<code>oct</code>) 리터럴:</strong> 현재 <code>short int</code>에 대한 16진수 및 8진수 리터럴은 음수 값을 지정할 수 있습니다 (예: 32비트 머신에서 <code>0xffffffff == -1</code>). 이는 <code>0xffffffffL</code> (2^32-1)과 같도록 변경됩니다.</li>
<li><strong>문자열 포매팅 (<code>%u</code>, <code>%x</code>, <code>%X</code>, <code>%o</code>):</strong> 현재 <code>%u</code>, <code>%x</code>, <code>%X</code>, <code>%o</code> 문자열 포매팅 연산자와 <code>hex()</code>, <code>oct()</code> 내장 함수는 음수에 대해 다르게 동작합니다. 음수 <code>short int</code>는 부호 없는 C <code>long</code>으로 포매팅되는 반면, 음수 <code>long int</code>는 마이너스 부호와 함께 포매팅됩니다. 이는 모든 경우에 <code>long int</code> 의미론을 사용하도록 변경됩니다 (단, 현재 <code>long int</code>의 <code>hex()</code> 및 <code>oct()</code> 출력에 붙는 <code>L</code> 접미사는 제외). 이는 <code>%u</code>가 <code>%d</code>의 별칭이 되며, 결국 제거될 것임을 의미합니다.</li>
<li><strong><code>repr()</code>:</strong> 현재 <code>long int</code>의 <code>repr()</code>은 <code>L</code>로 끝나는 문자열을 반환하지만, <code>short int</code>의 <code>repr()</code>은 그렇지 않습니다. <code>L</code> 접미사는 제거될 예정이며, Python 3.0 이전에 제거되지는 않을 것입니다.</li>
<li><strong><code>long</code> 피연산자와의 연산:</strong> 현재 <code>long</code> 피연산자와의 연산은 절대로 <code>short int</code>를 반환하지 않습니다. 이는 일부 최적화를 허용하기 위해 변경될 수 있습니다. (아직 변경된 사항은 없으며, 계획된 사항도 없습니다.)</li>
<li><strong><code>type(x).__name__</code>:</strong> <code>type(x).__name__</code>의 표현식은 <code>x</code>가 <code>short int</code>인지 <code>long int</code>인지에 따라 달라집니다. 구현 대안 2가 선택되었으므로 이 차이는 유지됩니다. (Python 3.0에서는 이 차이를 사용자 코드에 노출하는 것이 성가시고, 두 타입 간의 차이가 덜 보이게 되므로 이 차이를 숨기는 트릭을 사용할 수 있을 것입니다.)</li>
<li><strong><code>marshal</code>, <code>pickle</code>, <code>cPickle</code> 모듈:</strong> <code>long</code> 및 <code>short int</code>는 <code>marshal</code> 모듈과 <code>pickle</code>, <code>cPickle</code> 모듈에 의해 다르게 처리됩니다. 이 차이는 유지됩니다 (최소한 Python 3.0까지).</li>
<li><strong>정수 인터닝 (Interning):</strong> 작은 값을 가진 <code>short int</code> (일반적으로 -1에서 99 사이)는 인터닝(interning)됩니다. 즉, 결과가 이러한 값을 가질 때마다 동일한 값을 가진 기존 <code>short int</code>가 반환됩니다. <code>long int</code>의 동일한 값에는 적용되지 않습니다. 이 차이는 유지됩니다. (이 인터닝이 보장되는 것은 아니므로, 이것이 의미론적 차이인지에 대해서는 논란의 여지가 있습니다. 하지만 이 인터닝 때문에 <code>short int</code> 비교에 <code>is</code>를 사용하는 코드가 존재할 수 있으며, 이러한 코드는 <code>long int</code>와 함께 사용될 경우 실패할 수 있습니다.)</li>
</ul>
<h2>리터럴 (Literals)</h2>
<p>정수 리터럴 끝의 <code>L</code> 접미사는 더 이상 의미를 갖지 않게 되며, 결국에는 불법화될 것입니다. 컴파일러는 오로지 값에 따라 적절한 타입을 선택할 것입니다. (Python 3.0 이전까지는 리터럴을 <code>long</code>으로 강제하지만, <code>L</code> 접미사가 없는 리터럴도 <code>short int</code>로 표현할 수 없는 경우 <code>long</code>이 될 수 있습니다.)</p>
<h2>내장 함수 (Built-in Functions)</h2>
<p><code>int()</code> 함수는 인자 값에 따라 <code>short int</code> 또는 <code>long int</code>를 반환할 것입니다. Python 3.0에서는 <code>long()</code> 함수가 <code>int()</code> 함수를 호출할 것입니다. 그 전까지는 계속해서 결과를 <code>long int</code>로 강제하지만, 그 외에는 <code>int()</code>와 동일하게 작동할 것입니다. 내장 이름 <code>long</code>은 <code>long</code> 구현 타입을 나타내기 위해 언어에 남아있을 것입니다 (Python 3.0에서 완전히 제거되지 않는 한), 하지만 필요할 때 자동으로 <code>long</code>을 반환하므로 <code>int()</code> 함수를 사용하는 것이 여전히 권장됩니다.</p>
<h2>C API</h2>
<p>C API는 변경되지 않습니다. C 코드는 여전히 <code>short int</code>와 <code>long int</code>의 차이를 인지해야 합니다. (<code>PyArg_Parse*()</code> API는 이미 C <code>int</code> 또는 <code>long</code>으로 표현 가능한 범위 내의 <code>long int</code>를 받아들이므로, C <code>int</code> 또는 <code>long</code> 인자를 받는 함수는 Python <code>long</code>을 처리하는 것에 대해 걱정할 필요가 없을 것입니다.)</p>
<h2>전환 (Transition)</h2>
<p>전환은 세 가지 주요 단계로 구성됩니다.</p>
<ul>
<li><strong>단계 1 (Python 2.2):</strong> 현재 <code>OverflowError</code>를 발생시키는 <code>short int</code> 연산은 대신 <code>long int</code> 값을 반환합니다. 이 단계의 유일한 변경 사항입니다. 리터럴은 여전히 <code>short int</code>와 <code>long int</code>를 구분합니다. 위에서 언급된 다른 의미론적 차이점 ( <code>&#x3C;&#x3C;</code>의 동작 포함)은 유지됩니다. 이 단계는 현재 <code>OverflowError</code>를 발생시키는 상황만 변경하므로, 기존 코드를 손상시키지 않을 것으로 예상됩니다. 극단적인 하위 호환성을 우려하는 경우, 명령줄 옵션이나 <code>warnings</code> 모듈을 통해 경고 또는 오류를 발생시킬 수 있지만, 기본적으로는 비활성화됩니다.</li>
<li><strong>단계 2 (Python 2.3 - 2A, Python 2.4 - 2B):</strong>
<ul>
<li><strong>단계 2A:</strong> 나머지 의미론적 차이점을 해결합니다. 모든 경우에 <code>long int</code> 의미론이 우선합니다. 이는 일부 기존 코드를 손상시킬 수 있는 하위 비호환성을 야기하므로, 향후 <code>future statement</code> 및/또는 경고, 그리고 장기간의 전환 기간이 필요할 수 있습니다. <code>L</code> 접미사는 입력 및 <code>repr()</code>에서 <code>long</code>에 계속 사용됩니다.</li>
<li><strong>단계 2B:</strong> 2단계에서 숫자 결과가 변경될 연산(특히 <code>hex()</code> 및 <code>oct()</code>, <code>%u</code>, <code>%x</code>, <code>%X</code>, <code>%o</code>, <code>[sys.maxint+1, sys.maxint*2+1]</code> 범위의 16진수 및 8진수 리터럴, 비트를 잃는 좌측 시프트)에 대한 경고가 활성화됩니다. 이러한 연산에 대한 새로운 의미론이 구현됩니다. 이전과 다른 결과를 주는 연산은 경고를 발생시키지 않습니다.</li>
</ul>
</li>
<li><strong>단계 3 (Python 3.0):</strong> <code>repr()</code>에서 <code>L</code> 접미사가 제거되고, 입력에서 불법화됩니다. (가능하다면 <code>long</code> 타입이 완전히 사라집니다.) <code>hex()</code> 및 <code>oct()</code>에서도 <code>L</code> 접미사가 제거됩니다.</li>
</ul>
<p><strong>단계 1</strong>은 Python 2.2에서 구현되었습니다.
<strong>단계 2</strong>는 점진적으로 구현되었으며, 2A는 Python 2.3에서, 2B는 Python 2.4에서 구현되었습니다.
<strong>단계 3</strong>은 Python 3.0에서 구현되었습니다 (Python 2.4 출시 후 최소 2년).</p>
<h2>OverflowWarning</h2>
<p>현재 <code>OverflowError</code>를 발생시키는 상황에서 생성되는 경고를 지시하는 규칙은 다음과 같습니다. 이는 전환 1단계에 적용됩니다. 역사적으로, 1단계가 Python 2.2에서, 2A단계가 Python 2.3에서 완료되었음에도 불구하고, <code>OverflowWarning</code>이 Python 2.3에서도 계속 생성된다는 사실을 아무도 눈치채지 못했습니다. 이는 마침내 Python 2.4에서 비활성화되었습니다.</p>
<p>Python 내장 <code>OverflowWarning</code>과 해당 C API <code>PyExc_OverflowWarning</code>은 Python 2.4에서는 더 이상 생성되거나 사용되지 않지만, Python 2.5까지 사용자 코드의 (가능성이 낮은) 경우를 위해 남아있을 것입니다.</p>
<p>새로운 경고 카테고리인 <code>OverflowWarning</code>이 도입되었습니다. 이는 내장 이름입니다. <code>int</code> 결과가 오버플로우되면, 연산을 나타내는 메시지 (예: "integer addition")와 함께 <code>OverflowWarning</code> 경고가 발행됩니다. 이는 <code>sys.stderr</code>에 경고 메시지를 표시하거나 예외를 발생시킬 수 있으며, 이 모든 것은 <code>-W</code> 명령줄 옵션과 <code>warnings</code> 모듈에 의해 제어됩니다. <code>OverflowWarning</code>은 기본적으로 무시됩니다.</p>
<p><code>OverflowWarning</code>은 <code>-W</code> 명령줄 옵션 또는 <code>warnings.filterwarnings()</code> 호출을 통해 모든 경고와 마찬가지로 제어할 수 있습니다.
예를 들어:</p>
<pre><code class="language-bash">python -Wdefault::OverflowWarning
</code></pre>
<p>특정 소스 라인에서 처음 발생할 때 <code>OverflowWarning</code>이 표시되도록 합니다.</p>
<pre><code class="language-bash">python -Werror::OverflowWarning
</code></pre>
<p><code>OverflowWarning</code>이 발생할 때마다 예외로 전환되도록 합니다.</p>
<p>다음 코드는 프로그램 내부에서 경고를 활성화합니다.</p>
<pre><code class="language-python">import warnings
warnings.filterwarnings("default", "", OverflowWarning)
</code></pre>
<p><code>-W</code> 옵션에 대해서는 python man 페이지를, <code>filterwarnings()</code>에 대해서는 <code>warnings</code> 모듈 문서를 참조하십시오.</p>
<p><code>OverflowWarning</code>이 오류로 전환되면 <code>OverflowError</code>로 대체됩니다. 이는 하위 호환성을 위해 필요합니다. 경고가 예외로 전환되지 않는 한, 연산 결과 (예: <code>x+y</code>)는 인수를 <code>long int</code>로 변환한 후 재계산됩니다.</p>
<h2>예시 (Example)</h2>
<p><code>long int</code>를 정수를 취하는 C 함수나 내장 연산에 전달하면, 값이 범위 내에 있는 한 <code>short int</code>와 동일하게 처리됩니다 (<code>PyArg_ParseTuple()</code> 구현 방식 덕분입니다). <code>long</code> 값이 맞지 않으면 여전히 <code>OverflowError</code>가 발생합니다.</p>
<p>예를 들어:</p>
<pre><code class="language-python">def fact(n):
    if n &#x3C;= 1:
        return 1
    return n * fact(n - 1)

A = "ABCDEFGHIJKLMNOPQ"
n = input("Gimme an int: ")
print(A[fact(n) % 17])
</code></pre>
<p><code>n >= 13</code>일 때, 이 코드는 현재 <code>OverflowError</code>를 발생시킵니다 (사용자가 입력의 일부로 <code>L</code> 접미사를 입력하지 않는 한), 계산된 인덱스가 항상 <code>range(17)</code> 내에 있더라도 말입니다. 새로운 접근 방식에서는 이 코드가 올바르게 작동할 것입니다. 인덱스는 <code>long int</code>로 계산되지만, 그 값은 범위 내에 있을 것입니다.</p>
<h2>해결된 문제 (Resolved Issues)</h2>
<p>이전에 미해결이었던 다음 문제들이 해결되었습니다.</p>
<ul>
<li><strong><code>hex()</code> 및 <code>oct()</code>의 <code>L</code> 접미사:</strong> <code>long</code>에 적용되는 <code>hex()</code> 및 <code>oct()</code>는 Python 3000까지 <code>L</code> 접미사를 계속 생성합니다.</li>
<li><strong><code>sys.maxint</code>:</strong> <code>sys.maxint</code>는 <code>short int</code>와 <code>long int</code>의 구분이 여전히 관련이 있는 경우 (예: 값의 타입을 검사할 때) 여전히 유효하므로 유지됩니다.</li>
<li><strong><code>%u</code> 제거 여부:</strong> 완전히 제거됩니다.</li>
<li><strong><code>&#x3C;&#x3C;</code> 비트 잘림 경고:</strong> <code>&#x3C;&#x3C;</code>가 정수를 잘라내지 않는 것에 대해 경고해야 합니다. (예)</li>
<li><strong>오버플로우 경고의 이식 가능한 최대 크기:</strong> 아닙니다. (no)</li>
</ul>
<h2>구현 현황 (Implementation)</h2>
<p>Python 2.x 라인에 대한 구현 작업은 완료되었습니다. 1단계는 Python 2.2와 함께, 2A단계는 Python 2.3과 함께, 2B단계는 Python 2.4와 함께 릴리스되었습니다 (이미 CVS에 있습니다).</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/237\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"e6YNzZ2BVZ8NBZ6boXfWj\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/237/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/237\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"237\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/237\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T472f,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0237/\"\u003ePEP 237 - Unifying Long Integers and Integers\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 11-Mar-2001\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 237 – Long Integers와 Integers의 통합\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Moshe Zadka, Guido van Rossum\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final (최종)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track (표준 트랙)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e작성일:\u003c/strong\u003e 2001년 3월 11일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 2.2\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e개정 이력:\u003c/strong\u003e 2001년 3월 16일, 2001년 8월 14일, 2001년 8월 23일\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003e현재 Python은 두 가지 종류의 정수(integer)를 구분합니다: C \u003ccode\u003elong\u003c/code\u003e 타입의 크기(일반적으로 32 또는 64비트)에 제한되는 일반 \u003ccode\u003eint\u003c/code\u003e (또는 \u003ccode\u003eshort int\u003c/code\u003e)와, 가용 메모리에 의해서만 제한되는 \u003ccode\u003elong int\u003c/code\u003e입니다. \u003ccode\u003eshort int\u003c/code\u003e에 대한 연산 결과가 C \u003ccode\u003elong\u003c/code\u003e의 범위에 맞지 않으면 오류를 발생시킵니다. 이 외에도 몇 가지 다른 차이점이 있습니다. 이 PEP는 Python 사용자 관점에서 이 두 가지 타입의 대부분의 의미론적 차이를 없애고, 이들을 통합할 것을 제안합니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003e많은 프로그램에서 나중에 더 큰 숫자를 다룰 필요가 생기며, 알고리즘을 변경하는 것은 번거로운 일입니다. 모든 산술 연산이 \u003ccode\u003elong int\u003c/code\u003e를 사용하여 수행될 경우, 필요하지 않을 때도 성능 저하가 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e머신의 워드(word) 크기가 언어에 노출되는 것은 이식성(portability)을 저해합니다. 예를 들어, Python 소스 파일과 \u003ccode\u003e.pyc\u003c/code\u003e 파일은 이 문제 때문에 32비트 및 64비트 머신 간에 이식 가능하지 않습니다.\u003c/p\u003e\n\u003cp\u003e대부분의 애플리케이션에서 불필요한 세부 사항은 Python 사용자로부터 숨겨져야 한다는 일반적인 바람도 있습니다. 예를 들어, C에서는 명시적인 메모리 할당이 Python에서는 자동화되어 문자열, 리스트 등에서 무제한 크기의 편리함을 제공합니다. 이러한 편리함을 숫자로 확장하는 것은 합리적입니다.\u003c/p\u003e\n\u003cp\u003e이는 새로운 Python 프로그래머(프로그래밍 자체에 새로 접하는 사람이든 아니든)가 언어를 사용하기 시작하기 전에 배워야 할 것을 하나 줄여줄 것입니다.\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e초기에는 두 가지 대체 구현 방안이 제안되었습니다 (각 저자가 하나씩).\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003ePyInt\u003c/code\u003e 타입의 C \u003ccode\u003elong\u003c/code\u003e 슬롯을 \u003ccode\u003eunion\u003c/code\u003e 타입으로 변경하여, 작은 숫자와 큰 숫자를 모두 처리할 수 있도록 하는 방안. 모든 \u003ccode\u003ePyInt\u003c/code\u003e 함수는 이 \u003ccode\u003eunion\u003c/code\u003e의 특정 비트를 확인하여 어떤 연산을 사용할지 결정합니다.\u003c/li\u003e\n\u003cli\u003e기존 \u003ccode\u003eshort int\u003c/code\u003e 및 \u003ccode\u003elong int\u003c/code\u003e 타입을 유지하되, 연산 결과가 \u003ccode\u003eshort int\u003c/code\u003e로 표현될 수 없을 때 \u003ccode\u003eOverflowError\u003c/code\u003e를 발생시키는 대신 \u003ccode\u003elong int\u003c/code\u003e를 반환하도록 합니다. \u003ccode\u003eint\u003c/code\u003e와 \u003ccode\u003elong\u003c/code\u003e 구현 타입의 추상 베이스 타입인 새로운 \u003ccode\u003einteger\u003c/code\u003e 타입을 도입할 수 있습니다. 이는 \u003ccode\u003eif isinstance(i, integer): ...\u003c/code\u003e 와 같이 한 번의 테스트로 정수 여부를 확인할 수 있도록 합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e고려 끝에 두 번째 구현 계획이 채택되었습니다. 이는 구현이 훨씬 쉽고, C API 수준에서 하위 호환성을 유지하며, 과도기적 조치로서 부분적으로 구현될 수 있기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e비호환성 (Incompatibilities)\u003c/h2\u003e\n\u003cp\u003e다음 연산들은 \u003ccode\u003eshort int\u003c/code\u003e와 \u003ccode\u003elong int\u003c/code\u003e에 대해 (보통 미묘하게) 다른 의미론을 가지며, 이 중 하나는 변경되어야 합니다. 이는 철저한 목록입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e산술 연산자:\u003c/strong\u003e 현재 \u003ccode\u003e\u0026#x3C;\u0026#x3C;\u003c/code\u003e를 제외한 모든 \u003ccode\u003eshort int\u003c/code\u003e 산술 연산자는 결과가 \u003ccode\u003eshort int\u003c/code\u003e로 표현될 수 없을 때 \u003ccode\u003eOverflowError\u003c/code\u003e를 발생시킵니다. 이는 \u003ccode\u003elong int\u003c/code\u003e를 대신 반환하도록 변경됩니다. \u003ccode\u003ex+y\u003c/code\u003e, \u003ccode\u003ex-y\u003c/code\u003e, \u003ccode\u003ex*y\u003c/code\u003e, \u003ccode\u003ex**y\u003c/code\u003e, \u003ccode\u003edivmod(x, y)\u003c/code\u003e, \u003ccode\u003ex/y\u003c/code\u003e, \u003ccode\u003ex%y\u003c/code\u003e, \u003ccode\u003e-x\u003c/code\u003e 등이 영향을 받습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e좌측 시프트 (\u003ccode\u003ex \u0026#x3C;\u0026#x3C; n\u003c/code\u003e):\u003c/strong\u003e 현재 \u003ccode\u003eshort int\u003c/code\u003e의 경우 비트 손실이 발생할 수 있습니다. 이는 \u003ccode\u003eshort int\u003c/code\u003e를 반환하면 비트가 손실될 경우 (부호 변경도 비트 손실의 특별한 경우로 간주) 시프트된 모든 비트를 포함하는 \u003ccode\u003elong int\u003c/code\u003e를 반환하도록 변경됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e16진수 (\u003ccode\u003ehex\u003c/code\u003e) 및 8진수 (\u003ccode\u003eoct\u003c/code\u003e) 리터럴:\u003c/strong\u003e 현재 \u003ccode\u003eshort int\u003c/code\u003e에 대한 16진수 및 8진수 리터럴은 음수 값을 지정할 수 있습니다 (예: 32비트 머신에서 \u003ccode\u003e0xffffffff == -1\u003c/code\u003e). 이는 \u003ccode\u003e0xffffffffL\u003c/code\u003e (2^32-1)과 같도록 변경됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e문자열 포매팅 (\u003ccode\u003e%u\u003c/code\u003e, \u003ccode\u003e%x\u003c/code\u003e, \u003ccode\u003e%X\u003c/code\u003e, \u003ccode\u003e%o\u003c/code\u003e):\u003c/strong\u003e 현재 \u003ccode\u003e%u\u003c/code\u003e, \u003ccode\u003e%x\u003c/code\u003e, \u003ccode\u003e%X\u003c/code\u003e, \u003ccode\u003e%o\u003c/code\u003e 문자열 포매팅 연산자와 \u003ccode\u003ehex()\u003c/code\u003e, \u003ccode\u003eoct()\u003c/code\u003e 내장 함수는 음수에 대해 다르게 동작합니다. 음수 \u003ccode\u003eshort int\u003c/code\u003e는 부호 없는 C \u003ccode\u003elong\u003c/code\u003e으로 포매팅되는 반면, 음수 \u003ccode\u003elong int\u003c/code\u003e는 마이너스 부호와 함께 포매팅됩니다. 이는 모든 경우에 \u003ccode\u003elong int\u003c/code\u003e 의미론을 사용하도록 변경됩니다 (단, 현재 \u003ccode\u003elong int\u003c/code\u003e의 \u003ccode\u003ehex()\u003c/code\u003e 및 \u003ccode\u003eoct()\u003c/code\u003e 출력에 붙는 \u003ccode\u003eL\u003c/code\u003e 접미사는 제외). 이는 \u003ccode\u003e%u\u003c/code\u003e가 \u003ccode\u003e%d\u003c/code\u003e의 별칭이 되며, 결국 제거될 것임을 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003erepr()\u003c/code\u003e:\u003c/strong\u003e 현재 \u003ccode\u003elong int\u003c/code\u003e의 \u003ccode\u003erepr()\u003c/code\u003e은 \u003ccode\u003eL\u003c/code\u003e로 끝나는 문자열을 반환하지만, \u003ccode\u003eshort int\u003c/code\u003e의 \u003ccode\u003erepr()\u003c/code\u003e은 그렇지 않습니다. \u003ccode\u003eL\u003c/code\u003e 접미사는 제거될 예정이며, Python 3.0 이전에 제거되지는 않을 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003elong\u003c/code\u003e 피연산자와의 연산:\u003c/strong\u003e 현재 \u003ccode\u003elong\u003c/code\u003e 피연산자와의 연산은 절대로 \u003ccode\u003eshort int\u003c/code\u003e를 반환하지 않습니다. 이는 일부 최적화를 허용하기 위해 변경될 수 있습니다. (아직 변경된 사항은 없으며, 계획된 사항도 없습니다.)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003etype(x).__name__\u003c/code\u003e:\u003c/strong\u003e \u003ccode\u003etype(x).__name__\u003c/code\u003e의 표현식은 \u003ccode\u003ex\u003c/code\u003e가 \u003ccode\u003eshort int\u003c/code\u003e인지 \u003ccode\u003elong int\u003c/code\u003e인지에 따라 달라집니다. 구현 대안 2가 선택되었으므로 이 차이는 유지됩니다. (Python 3.0에서는 이 차이를 사용자 코드에 노출하는 것이 성가시고, 두 타입 간의 차이가 덜 보이게 되므로 이 차이를 숨기는 트릭을 사용할 수 있을 것입니다.)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003emarshal\u003c/code\u003e, \u003ccode\u003epickle\u003c/code\u003e, \u003ccode\u003ecPickle\u003c/code\u003e 모듈:\u003c/strong\u003e \u003ccode\u003elong\u003c/code\u003e 및 \u003ccode\u003eshort int\u003c/code\u003e는 \u003ccode\u003emarshal\u003c/code\u003e 모듈과 \u003ccode\u003epickle\u003c/code\u003e, \u003ccode\u003ecPickle\u003c/code\u003e 모듈에 의해 다르게 처리됩니다. 이 차이는 유지됩니다 (최소한 Python 3.0까지).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e정수 인터닝 (Interning):\u003c/strong\u003e 작은 값을 가진 \u003ccode\u003eshort int\u003c/code\u003e (일반적으로 -1에서 99 사이)는 인터닝(interning)됩니다. 즉, 결과가 이러한 값을 가질 때마다 동일한 값을 가진 기존 \u003ccode\u003eshort int\u003c/code\u003e가 반환됩니다. \u003ccode\u003elong int\u003c/code\u003e의 동일한 값에는 적용되지 않습니다. 이 차이는 유지됩니다. (이 인터닝이 보장되는 것은 아니므로, 이것이 의미론적 차이인지에 대해서는 논란의 여지가 있습니다. 하지만 이 인터닝 때문에 \u003ccode\u003eshort int\u003c/code\u003e 비교에 \u003ccode\u003eis\u003c/code\u003e를 사용하는 코드가 존재할 수 있으며, 이러한 코드는 \u003ccode\u003elong int\u003c/code\u003e와 함께 사용될 경우 실패할 수 있습니다.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e리터럴 (Literals)\u003c/h2\u003e\n\u003cp\u003e정수 리터럴 끝의 \u003ccode\u003eL\u003c/code\u003e 접미사는 더 이상 의미를 갖지 않게 되며, 결국에는 불법화될 것입니다. 컴파일러는 오로지 값에 따라 적절한 타입을 선택할 것입니다. (Python 3.0 이전까지는 리터럴을 \u003ccode\u003elong\u003c/code\u003e으로 강제하지만, \u003ccode\u003eL\u003c/code\u003e 접미사가 없는 리터럴도 \u003ccode\u003eshort int\u003c/code\u003e로 표현할 수 없는 경우 \u003ccode\u003elong\u003c/code\u003e이 될 수 있습니다.)\u003c/p\u003e\n\u003ch2\u003e내장 함수 (Built-in Functions)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eint()\u003c/code\u003e 함수는 인자 값에 따라 \u003ccode\u003eshort int\u003c/code\u003e 또는 \u003ccode\u003elong int\u003c/code\u003e를 반환할 것입니다. Python 3.0에서는 \u003ccode\u003elong()\u003c/code\u003e 함수가 \u003ccode\u003eint()\u003c/code\u003e 함수를 호출할 것입니다. 그 전까지는 계속해서 결과를 \u003ccode\u003elong int\u003c/code\u003e로 강제하지만, 그 외에는 \u003ccode\u003eint()\u003c/code\u003e와 동일하게 작동할 것입니다. 내장 이름 \u003ccode\u003elong\u003c/code\u003e은 \u003ccode\u003elong\u003c/code\u003e 구현 타입을 나타내기 위해 언어에 남아있을 것입니다 (Python 3.0에서 완전히 제거되지 않는 한), 하지만 필요할 때 자동으로 \u003ccode\u003elong\u003c/code\u003e을 반환하므로 \u003ccode\u003eint()\u003c/code\u003e 함수를 사용하는 것이 여전히 권장됩니다.\u003c/p\u003e\n\u003ch2\u003eC API\u003c/h2\u003e\n\u003cp\u003eC API는 변경되지 않습니다. C 코드는 여전히 \u003ccode\u003eshort int\u003c/code\u003e와 \u003ccode\u003elong int\u003c/code\u003e의 차이를 인지해야 합니다. (\u003ccode\u003ePyArg_Parse*()\u003c/code\u003e API는 이미 C \u003ccode\u003eint\u003c/code\u003e 또는 \u003ccode\u003elong\u003c/code\u003e으로 표현 가능한 범위 내의 \u003ccode\u003elong int\u003c/code\u003e를 받아들이므로, C \u003ccode\u003eint\u003c/code\u003e 또는 \u003ccode\u003elong\u003c/code\u003e 인자를 받는 함수는 Python \u003ccode\u003elong\u003c/code\u003e을 처리하는 것에 대해 걱정할 필요가 없을 것입니다.)\u003c/p\u003e\n\u003ch2\u003e전환 (Transition)\u003c/h2\u003e\n\u003cp\u003e전환은 세 가지 주요 단계로 구성됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e단계 1 (Python 2.2):\u003c/strong\u003e 현재 \u003ccode\u003eOverflowError\u003c/code\u003e를 발생시키는 \u003ccode\u003eshort int\u003c/code\u003e 연산은 대신 \u003ccode\u003elong int\u003c/code\u003e 값을 반환합니다. 이 단계의 유일한 변경 사항입니다. 리터럴은 여전히 \u003ccode\u003eshort int\u003c/code\u003e와 \u003ccode\u003elong int\u003c/code\u003e를 구분합니다. 위에서 언급된 다른 의미론적 차이점 ( \u003ccode\u003e\u0026#x3C;\u0026#x3C;\u003c/code\u003e의 동작 포함)은 유지됩니다. 이 단계는 현재 \u003ccode\u003eOverflowError\u003c/code\u003e를 발생시키는 상황만 변경하므로, 기존 코드를 손상시키지 않을 것으로 예상됩니다. 극단적인 하위 호환성을 우려하는 경우, 명령줄 옵션이나 \u003ccode\u003ewarnings\u003c/code\u003e 모듈을 통해 경고 또는 오류를 발생시킬 수 있지만, 기본적으로는 비활성화됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e단계 2 (Python 2.3 - 2A, Python 2.4 - 2B):\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e단계 2A:\u003c/strong\u003e 나머지 의미론적 차이점을 해결합니다. 모든 경우에 \u003ccode\u003elong int\u003c/code\u003e 의미론이 우선합니다. 이는 일부 기존 코드를 손상시킬 수 있는 하위 비호환성을 야기하므로, 향후 \u003ccode\u003efuture statement\u003c/code\u003e 및/또는 경고, 그리고 장기간의 전환 기간이 필요할 수 있습니다. \u003ccode\u003eL\u003c/code\u003e 접미사는 입력 및 \u003ccode\u003erepr()\u003c/code\u003e에서 \u003ccode\u003elong\u003c/code\u003e에 계속 사용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e단계 2B:\u003c/strong\u003e 2단계에서 숫자 결과가 변경될 연산(특히 \u003ccode\u003ehex()\u003c/code\u003e 및 \u003ccode\u003eoct()\u003c/code\u003e, \u003ccode\u003e%u\u003c/code\u003e, \u003ccode\u003e%x\u003c/code\u003e, \u003ccode\u003e%X\u003c/code\u003e, \u003ccode\u003e%o\u003c/code\u003e, \u003ccode\u003e[sys.maxint+1, sys.maxint*2+1]\u003c/code\u003e 범위의 16진수 및 8진수 리터럴, 비트를 잃는 좌측 시프트)에 대한 경고가 활성화됩니다. 이러한 연산에 대한 새로운 의미론이 구현됩니다. 이전과 다른 결과를 주는 연산은 경고를 발생시키지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e단계 3 (Python 3.0):\u003c/strong\u003e \u003ccode\u003erepr()\u003c/code\u003e에서 \u003ccode\u003eL\u003c/code\u003e 접미사가 제거되고, 입력에서 불법화됩니다. (가능하다면 \u003ccode\u003elong\u003c/code\u003e 타입이 완전히 사라집니다.) \u003ccode\u003ehex()\u003c/code\u003e 및 \u003ccode\u003eoct()\u003c/code\u003e에서도 \u003ccode\u003eL\u003c/code\u003e 접미사가 제거됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e단계 1\u003c/strong\u003e은 Python 2.2에서 구현되었습니다.\r\n\u003cstrong\u003e단계 2\u003c/strong\u003e는 점진적으로 구현되었으며, 2A는 Python 2.3에서, 2B는 Python 2.4에서 구현되었습니다.\r\n\u003cstrong\u003e단계 3\u003c/strong\u003e은 Python 3.0에서 구현되었습니다 (Python 2.4 출시 후 최소 2년).\u003c/p\u003e\n\u003ch2\u003eOverflowWarning\u003c/h2\u003e\n\u003cp\u003e현재 \u003ccode\u003eOverflowError\u003c/code\u003e를 발생시키는 상황에서 생성되는 경고를 지시하는 규칙은 다음과 같습니다. 이는 전환 1단계에 적용됩니다. 역사적으로, 1단계가 Python 2.2에서, 2A단계가 Python 2.3에서 완료되었음에도 불구하고, \u003ccode\u003eOverflowWarning\u003c/code\u003e이 Python 2.3에서도 계속 생성된다는 사실을 아무도 눈치채지 못했습니다. 이는 마침내 Python 2.4에서 비활성화되었습니다.\u003c/p\u003e\n\u003cp\u003ePython 내장 \u003ccode\u003eOverflowWarning\u003c/code\u003e과 해당 C API \u003ccode\u003ePyExc_OverflowWarning\u003c/code\u003e은 Python 2.4에서는 더 이상 생성되거나 사용되지 않지만, Python 2.5까지 사용자 코드의 (가능성이 낮은) 경우를 위해 남아있을 것입니다.\u003c/p\u003e\n\u003cp\u003e새로운 경고 카테고리인 \u003ccode\u003eOverflowWarning\u003c/code\u003e이 도입되었습니다. 이는 내장 이름입니다. \u003ccode\u003eint\u003c/code\u003e 결과가 오버플로우되면, 연산을 나타내는 메시지 (예: \"integer addition\")와 함께 \u003ccode\u003eOverflowWarning\u003c/code\u003e 경고가 발행됩니다. 이는 \u003ccode\u003esys.stderr\u003c/code\u003e에 경고 메시지를 표시하거나 예외를 발생시킬 수 있으며, 이 모든 것은 \u003ccode\u003e-W\u003c/code\u003e 명령줄 옵션과 \u003ccode\u003ewarnings\u003c/code\u003e 모듈에 의해 제어됩니다. \u003ccode\u003eOverflowWarning\u003c/code\u003e은 기본적으로 무시됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eOverflowWarning\u003c/code\u003e은 \u003ccode\u003e-W\u003c/code\u003e 명령줄 옵션 또는 \u003ccode\u003ewarnings.filterwarnings()\u003c/code\u003e 호출을 통해 모든 경고와 마찬가지로 제어할 수 있습니다.\r\n예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epython -Wdefault::OverflowWarning\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e특정 소스 라인에서 처음 발생할 때 \u003ccode\u003eOverflowWarning\u003c/code\u003e이 표시되도록 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003epython -Werror::OverflowWarning\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eOverflowWarning\u003c/code\u003e이 발생할 때마다 예외로 전환되도록 합니다.\u003c/p\u003e\n\u003cp\u003e다음 코드는 프로그램 내부에서 경고를 활성화합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport warnings\r\nwarnings.filterwarnings(\"default\", \"\", OverflowWarning)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e-W\u003c/code\u003e 옵션에 대해서는 python man 페이지를, \u003ccode\u003efilterwarnings()\u003c/code\u003e에 대해서는 \u003ccode\u003ewarnings\u003c/code\u003e 모듈 문서를 참조하십시오.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eOverflowWarning\u003c/code\u003e이 오류로 전환되면 \u003ccode\u003eOverflowError\u003c/code\u003e로 대체됩니다. 이는 하위 호환성을 위해 필요합니다. 경고가 예외로 전환되지 않는 한, 연산 결과 (예: \u003ccode\u003ex+y\u003c/code\u003e)는 인수를 \u003ccode\u003elong int\u003c/code\u003e로 변환한 후 재계산됩니다.\u003c/p\u003e\n\u003ch2\u003e예시 (Example)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003elong int\u003c/code\u003e를 정수를 취하는 C 함수나 내장 연산에 전달하면, 값이 범위 내에 있는 한 \u003ccode\u003eshort int\u003c/code\u003e와 동일하게 처리됩니다 (\u003ccode\u003ePyArg_ParseTuple()\u003c/code\u003e 구현 방식 덕분입니다). \u003ccode\u003elong\u003c/code\u003e 값이 맞지 않으면 여전히 \u003ccode\u003eOverflowError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef fact(n):\r\n    if n \u0026#x3C;= 1:\r\n        return 1\r\n    return n * fact(n - 1)\r\n\r\nA = \"ABCDEFGHIJKLMNOPQ\"\r\nn = input(\"Gimme an int: \")\r\nprint(A[fact(n) % 17])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003en \u003e= 13\u003c/code\u003e일 때, 이 코드는 현재 \u003ccode\u003eOverflowError\u003c/code\u003e를 발생시킵니다 (사용자가 입력의 일부로 \u003ccode\u003eL\u003c/code\u003e 접미사를 입력하지 않는 한), 계산된 인덱스가 항상 \u003ccode\u003erange(17)\u003c/code\u003e 내에 있더라도 말입니다. 새로운 접근 방식에서는 이 코드가 올바르게 작동할 것입니다. 인덱스는 \u003ccode\u003elong int\u003c/code\u003e로 계산되지만, 그 값은 범위 내에 있을 것입니다.\u003c/p\u003e\n\u003ch2\u003e해결된 문제 (Resolved Issues)\u003c/h2\u003e\n\u003cp\u003e이전에 미해결이었던 다음 문제들이 해결되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ehex()\u003c/code\u003e 및 \u003ccode\u003eoct()\u003c/code\u003e의 \u003ccode\u003eL\u003c/code\u003e 접미사:\u003c/strong\u003e \u003ccode\u003elong\u003c/code\u003e에 적용되는 \u003ccode\u003ehex()\u003c/code\u003e 및 \u003ccode\u003eoct()\u003c/code\u003e는 Python 3000까지 \u003ccode\u003eL\u003c/code\u003e 접미사를 계속 생성합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003esys.maxint\u003c/code\u003e:\u003c/strong\u003e \u003ccode\u003esys.maxint\u003c/code\u003e는 \u003ccode\u003eshort int\u003c/code\u003e와 \u003ccode\u003elong int\u003c/code\u003e의 구분이 여전히 관련이 있는 경우 (예: 값의 타입을 검사할 때) 여전히 유효하므로 유지됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e%u\u003c/code\u003e 제거 여부:\u003c/strong\u003e 완전히 제거됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e\u0026#x3C;\u0026#x3C;\u003c/code\u003e 비트 잘림 경고:\u003c/strong\u003e \u003ccode\u003e\u0026#x3C;\u0026#x3C;\u003c/code\u003e가 정수를 잘라내지 않는 것에 대해 경고해야 합니다. (예)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e오버플로우 경고의 이식 가능한 최대 크기:\u003c/strong\u003e 아닙니다. (no)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e구현 현황 (Implementation)\u003c/h2\u003e\n\u003cp\u003ePython 2.x 라인에 대한 구현 작업은 완료되었습니다. 1단계는 Python 2.2와 함께, 2A단계는 Python 2.3과 함께, 2B단계는 Python 2.4와 함께 릴리스되었습니다 (이미 CVS에 있습니다).\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 237 - Unifying Long Integers and Integers\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 17:06:31+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>