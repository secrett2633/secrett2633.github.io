<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 214 - Extended Print Statement</h1><div class="page__meta"><time dateTime="2025-09-26 16:31:25+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0214/">PEP 214 - Extended Print Statement</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 24-Jul-2000</p>
</blockquote>
<h2>PEP 214 – <code>print</code> 문 확장 (Extended Print Statement)</h2>
<h3>개요</h3>
<p>이 PEP (Python Enhancement Proposal)는 Python의 표준 <code>print</code> 문을 확장하여 기본 <code>sys.stdout</code> 대신 모든 파일류(file-like) 객체로 출력을 보낼 수 있는 새로운 구문을 도입합니다. 이는 Python 2.0에 채택되었으며, 특정 출력 스트림으로 인쇄해야 할 필요가 있을 때 유용하게 사용될 수 있습니다.</p>
<h3>제안 (Proposal)</h3>
<p>이 제안은 <code>print</code> 문에 출력 대상 파일(output file target)을 선택적으로 지정할 수 있는 구문 확장을 소개합니다.</p>
<p><strong>사용 예시:</strong></p>
<pre><code class="language-python">print >> mylogfile, 'this message goes to my log file'
</code></pre>
<p>확장된 <code>print</code> 문의 정식 구문은 다음과 같습니다.</p>
<pre><code>print_stmt: ... | '>>' test [ (',' test)+ [','] ] )
</code></pre>
<p>여기서 <code>...</code>는 기존 <code>print_stmt</code> 구문이 변경되지 않았음을 나타냅니다. 확장된 형식에서 <code>>></code> 바로 뒤에 오는 표현식은 <code>write()</code> 메서드를 가진 객체(즉, 파일류 객체)를 반환해야 합니다.</p>
<p><strong>동등한 문장:</strong></p>
<pre><code class="language-python">print 'hello world'
print >> sys.stdout, 'hello world'
</code></pre>
<p>두 문장 모두 동일하게 작동합니다.</p>
<p>또한, 다음 두 문장도 동등합니다.</p>
<pre><code class="language-python">print
print >> sys.stdout
</code></pre>
<p>반면, 다음 두 문장은 문법 오류(syntax error)입니다.</p>
<pre><code class="language-python">print ,
print >> sys.stdout,
</code></pre>
<h3>정당성 (Justification)</h3>
<p><code>print</code>는 Python의 키워드이며, 언어 참조 설명서의 6.6절에 설명된 <code>print</code> 문을 소개합니다. <code>print</code> 문은 다음과 같은 특징을 가집니다.</p>
<ul>
<li>항목을 자동으로 문자열로 변환합니다.</li>
<li>항목 사이에 자동으로 공백을 삽입합니다.</li>
<li>문장이 쉼표(<code>,</code>)로 끝나지 않는 한 개행 문자(newline)를 추가합니다.</li>
</ul>
<p><code>print</code> 문이 수행하는 포맷팅은 제한적입니다. 출력에 대한 더 많은 제어를 위해서는 <code>sys.stdout.write()</code>와 문자열 보간(string interpolation)을 함께 사용할 수 있습니다.</p>
<p><code>print</code> 문은 기본적으로 <code>sys.stdout</code>으로 출력됩니다. <code>sys.stdout</code>은 <code>write()</code> 메서드를 가진 파일류 객체여야 하지만, 표준 출력(standard output)이 아닌 다른 파일로 출력을 리디렉션하기 위해 다시 바인딩(rebind)될 수 있습니다. 일반적인 관용구(idiom)는 다음과 같습니다.</p>
<pre><code class="language-python">save_stdout = sys.stdout
try:
    sys.stdout = mylogfile
    print 'this message goes to my log file'
finally:
    sys.stdout = save_stdout
</code></pre>
<p>이 방식의 문제는 바인딩이 전역적(global)이어서 <code>try:</code> 절 내부의 모든 문장에 영향을 미친다는 것입니다. 예를 들어, 실제로 <code>stdout</code>으로 출력하려던 함수 호출이 추가되면, 이 출력도 로그 파일로 리디렉션됩니다.</p>
<p>또한, 이 방식은 여러 출력 스트림으로 출력을 번갈아 보내기에는 매우 불편하며, <code>try/except</code> 또는 <code>try/finally</code> 절과 같은 코드 작성을 복잡하게 만듭니다.</p>
<h3>참조 구현 (Reference Implementation)</h3>
<p>Python 2.0 소스 트리에 대한 패치 형태의 참조 구현은 SourceForge의 패치 관리자에서 확인할 수 있습니다. 이 접근 방식은 <code>PRINT_ITEM_TO</code>와 <code>PRINT_NEWLINE_TO</code>라는 두 개의 새로운 opcode를 추가하는데, 이 opcode들은 스택(stack) 상단에서 파일류 객체를 팝(pop)하여 <code>sys.stdout</code> 대신 출력 스트림으로 사용합니다. 이 참조 구현은 Python 2.0에 채택되었습니다.</p>
<h3>대안적 접근 방식 (Alternative Approaches)</h3>
<p>이 구문 변경에 대한 대안으로 Python 구문 변경이 필요 없는 방식이 제안되었습니다 (원래 Moshe Zadka). <code>writeln()</code> 함수가 제공될 수 있으며 (내장 함수로도 가능), 몇 가지 추가 기능을 가진 확장된 <code>print</code>와 매우 유사하게 작동합니다.</p>
<pre><code class="language-python">def writeln(*args, **kws):
    import sys
    file = sys.stdout
    sep = ' '
    end = '\n'
    if kws.has_key('file'):
        file = kws['file']
        del kws['file']
    if kws.has_key('nl'):
        if not kws['nl']:
            end = ' '
        del kws['nl']
    if kws.has_key('sep'):
        sep = kws['sep']
        del kws['sep']
    if kws:
        raise TypeError('unexpected keywords')
    file.write(sep.join(map(str, args)) + end)
</code></pre>
<p><code>writeln()</code>은 세 개의 선택적 키워드 인자(keyword arguments)를 받습니다. 이 제안의 맥락에서 관련 있는 인자는 <code>write()</code> 메서드를 가진 파일류 객체로 설정될 수 있는 <code>file</code>입니다.</p>
<p>따라서, <code>print >> mylogfile, 'this goes to my log file'</code>은 다음과 같이 작성될 수 있습니다.</p>
<pre><code class="language-python">writeln('this goes to my log file', file=mylogfile)
</code></pre>
<p><code>writeln()</code>은 <code>nl</code> 키워드 인자를 통해 개행 문자를 추가할지 여부를 지정하고, <code>sep</code> 인자를 통해 각 항목 사이에 출력할 구분자를 지정하는 추가 기능을 가지고 있습니다.</p>
<h3>BDFL의 추가 정당성 (More Justification by the BDFL)</h3>
<p>이 제안은 뉴스그룹에서 이의가 제기되었습니다. 일부는 <code>>></code> 기호를 싫어하며 다른 기호를 선호했습니다.</p>
<p><strong>이의 제기:</strong> 왜 다른 기호들을 사용하지 않는가? (<code>print in stderr</code>, <code>print + stderr</code>, <code>print[stderr]</code>, <code>print to stderr</code> 등)
<strong>응답:</strong> 특별한 기호(<code>print &#x3C;symbol> expression</code>)를 사용하려면, Python 파서는 해당 기호가 이미 표현식을 시작할 수 있는 기호가 아니어야 합니다. 그렇지 않으면 어떤 형태의 <code>print</code> 문이 사용되는지 결정할 수 없습니다. 이는 식별자가 표현식을 시작할 수 있기 때문에 "<code>import as</code>"에 사용된 "컨텍스트에서만 키워드 트릭(keyword only in context trick)"을 사용할 수 없음을 의미합니다. 이는 <code>+stderr</code>, <code>[stderr]</code>, <code>to stderr</code>를 제외시키고, <code>>></code>와 같은 이항 연산자 기호나 현재 이곳에서 불법인 다른 잡다한 기호(예: <code>import</code>)를 남깁니다.
<code>'print in file'</code>과 <code>'print >> file'</code> 중에서 선택해야 한다면, <code>>></code>를 선택할 것입니다. 부분적으로는 <code>'in'</code>이 새로운 발명품일 것이고 (다른 언어에서 사용하는 것을 알지 못함), <code>'>>'</code>는 <code>sh</code>, <code>awk</code>, Perl, C++에서 사용되기 때문입니다. 또한, <code>>></code>는 알파벳이 아니므로 더 눈에 띄어 독자의 주의를 끌 가능성이 높습니다.</p>
<p><strong>이의 제기:</strong> 파일과 나머지 항목 사이에 쉼표가 있어야 하는 이유는 무엇인가?
<strong>응답:</strong> 파일을 다음 표현식과 분리하는 쉼표는 필수적입니다! 파일이 단순히 단일 단어가 아닌 임의의 표현식이 되기를 원할 것입니다. (<code>print >>sys.stderr</code>와 같이 작성할 수 있기를 원할 것입니다.) 표현식이 없으면 파서는 해당 표현식이 어디서 끝나고 다음 표현식이 어디서 시작하는지 구별할 수 없을 것입니다.</p>
<p><strong>이의 제기:</strong> 왜 구문 확장이 필요한가? <code>writeln(file, item, …)</code>으로는 충분하지 않은가?
<strong>응답:</strong> 우선, <code>print</code> 문의 한 가지 기능인 마지막 개행을 억제하는 후행 쉼표(trailing comma)가 부족합니다. <code>'print a,'</code>가 여전히 <code>'sys.stdout.write(a)'</code>와 동등하지 않다는 점에 유의하십시오. <code>print</code>는 항목 사이에 공백을 삽입하고 임의의 객체를 인자로 받습니다. <code>write()</code>는 공백을 삽입하지 않으며 단일 문자열을 요구합니다.
<code>print</code> 문에 대한 확장을 고려할 때, 한 차원(출력이 어디로 가는지)에서는 새로운 기능을 추가하지만 다른 차원(항목 사이의 공백, 후행 개행 선택 여부)에서는 기능을 제거하는 함수나 메서드를 추가하는 것은 올바르지 않습니다. 다양한 경우를 처리하기 위해 많은 메서드나 함수를 추가할 수도 있지만, 이는 불필요한 혼란을 가중시킬 뿐이며, <code>print</code> 문을 완전히 비권장(deprecate)하는 경우에만 의미가 있을 것입니다.
이 논쟁은 사실 <code>print</code>가 문(statement)이 아닌 함수나 메서드였어야 하는지에 대한 것이라고 생각합니다. 함수 진영에 있다면, 기존 <code>print</code> 문에 특수 구문을 추가하는 것을 좋아하지 않을 것입니다. 새로운 구문에 대한 반대는 주로 <code>print</code> 문이 애초에 나쁜 생각이었다고 생각하는 사람들로부터 나온다고 짐작합니다.
약 10년 전, 가장 기본적인 출력 형태를 함수로 만들지 문으로 만들지 스스로 고민했습니다. 기본적으로 <code>'print(item, …)'</code>와 <code>'print item, …'</code> 중에서 결정하려 했습니다. <code>print</code>는 초기에 가르쳐야 하고 초보자가 작성하는 프로그램에서 매우 중요하기 때문에 문으로 만들기로 결정했습니다. 또한, 많은 것들의 선구자였던 ABC가 그것을 문으로 만들었기 때문입니다. ABC와 Python의 상호작용에서 전형적인 움직임으로, 저는 이름을 WRITE에서 <code>print</code>로 바꾸고, 개행을 추가하기 위한 추가 구문(ABC는 후행 슬래시를 사용하여 개행을 나타냄)을 요구하는 것에서 개행을 억제하기 위한 추가 구문(후행 쉼표)을 요구하는 것으로 개행 추가 규칙을 역전시켰습니다. 저는 항목들이 출력 시 공백으로 구분되는 기능을 유지했습니다.</p>
<p><strong>전체 예시:</strong> ABC에서 <code>WRITE 1</code> <code>WRITE 2/</code>는 Python에서 <code>print 1,</code> <code>print 2</code>와 동일한 효과를 가지며, 결과적으로 "1 2\n"을 출력합니다.</p>
<p>저는 문으로 선택한 것이 100% 옳았는지 확신하지 못하지만 (ABC는 부작용이 있는 모든 것에 문법을 사용해야 하는 설득력 있는 이유가 있었지만, Python은 이런 관습이 없음), 틀렸다고 확신하지도 않습니다. 저는 <code>print</code> 문의 간결함을 분명히 좋아합니다. 어쨌든, 저는 <code>print</code> 문을 비권장할 준비가 되어 있지 않으며, 지난 몇 년 동안 파일을 지정하는 옵션에 대한 많은 요청이 있었습니다.</p>
<p><strong>이의 제기:</strong> 왜 <code>>></code> 대신 <code>></code>를 사용하지 않는가?
<strong>응답:</strong> DOS 및 Unix 사용자에게 <code>>></code>는 "추가(append)"를, <code>></code>는 "덮어쓰기(overwrite)"를 제안합니다. 의미론적으로는 "추가"에 가장 가깝습니다. 또한, C++ 프로그래머에게 <code>>></code>와 <code>&#x3C;&#x3C;</code>는 I/O 연산자입니다.</p>
<p><strong>이의 제기:</strong> 하지만 C++에서 <code>>></code>는 입력이고 <code>&#x3C;&#x3C;</code>는 출력이다!
<strong>응답:</strong> 중요하지 않습니다. C++은 분명히 Unix에서 가져와서 화살표 방향을 바꿨습니다. 중요한 것은 출력의 경우 화살표가 파일을 가리킨다는 것입니다.</p>
<p><strong>이의 제기:</strong> <code>print >> file</code>이 할 수 있는 모든 것을 <code>println()</code> 함수로 설계할 수 있을 텐데, 왜 그것으로는 충분하지 않은가?
<strong>응답:</strong> 저는 이것을 간단한 프로그래밍 연습의 관점에서 생각합니다. 초보 프로그래머에게 곱셈표를 출력하는 함수를 작성하도록 요청받았다고 가정해 봅시다. 합리적인 해결책은 다음과 같습니다.</p>
<pre><code class="language-python">def tables(n):
    for j in range(1, n+1):
        for i in range(1, n+1):
            print i, 'x', j, '=', i*j
        print # 줄 바꿈
</code></pre>
<p>이제 두 번째 연습으로 다른 파일에 출력하는 것을 추가해야 한다고 가정해 봅시다. 새로운 구문을 사용하면 프로그래머는 <code>print >> file,</code>이라는 한 가지 새로운 것만 배우면 됩니다. 답은 다음과 같습니다.</p>
<pre><code class="language-python">def tables(n, file=sys.stdout):
    for j in range(1, n+1):
        for i in range(1, n+1):
            print >> file, i, 'x', j, '=', i*j
        print >> file # 줄 바꿈
</code></pre>
<p><code>print</code> 문과 <code>println()</code> 함수만 있다면, 프로그래머는 먼저 <code>println()</code>에 대해 배우고, 원본 프로그램을 <code>println()</code>을 사용하도록 변환해야 합니다.</p>
<pre><code class="language-python">def tables(n):
    for j in range(1, n+1):
        for i in range(1, n+1):
            println(i, 'x', j, '=', i*j)
        println()
</code></pre>
<p>그리고 나서 <code>file</code> 키워드 인자에 대해 배워야 합니다.</p>
<pre><code class="language-python">def tables(n, file=sys.stdout):
    for j in range(1, n+1):
        for i in range(1, n+1):
            println(i, 'x', j, '=', i*j, file=sys.stdout)
        println(file=sys.stdout)
</code></pre>
<p>따라서, 변환 경로가 더 깁니다.
<code>(1) print</code> → <code>(2) print >> file</code>
vs.
<code>(1) print</code> → <code>(2) println()</code> → <code>(3) println(file=...)</code></p>
<p><strong>참고:</strong> <code>file</code> 인자를 컴파일 시점에 <code>sys.stdout</code>으로 기본 설정하는 것은 잘못된 것입니다. 호출자가 <code>sys.stdout</code>에 할당한 후 파일을 지정하지 않고 <code>tables()</code>를 사용하면 제대로 작동하지 않기 때문입니다. 이는 흔한 문제이며 (<code>println()</code> 함수에서도 발생할 수 있습니다). 지금까지의 표준 해결책은 다음과 같습니다.</p>
<pre><code class="language-python">def tables(n, file=None):
    if file is None:
        file = sys.stdout
    for j in range(1, n+1):
        for i in range(1, n+1):
            print >> file, i, 'x', j, '=', i*j
        print >> file
</code></pre>
<p>저는 구현에 기능을 추가했는데 (<code>println()</code>에도 권장), <code>file</code> 인자가 <code>None</code>이면 <code>sys.stdout</code>이 자동으로 사용됩니다. 따라서,
<code>print >> None, foo bar</code> (또는 <code>x</code>의 값이 <code>None</code>인 변수 <code>x</code>를 사용하는 <code>print >> x</code>)는 <code>print foo, bar</code>와 같은 의미입니다. <code>tables()</code> 함수는 다음과 같이 작성될 수 있습니다.</p>
<pre><code class="language-python">def tables(n, file=None):
    for j in range(1, n+1):
        for i in range(1, n+1):
            print >> file, i, 'x', j, '=', i*j
        print >> file
</code></pre>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/214\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"e6YNzZ2BVZ8NBZ6boXfWj\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/214/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/214\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"214\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/214\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T4016,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0214/\"\u003ePEP 214 - Extended Print Statement\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 24-Jul-2000\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 214 – \u003ccode\u003eprint\u003c/code\u003e 문 확장 (Extended Print Statement)\u003c/h2\u003e\n\u003ch3\u003e개요\u003c/h3\u003e\n\u003cp\u003e이 PEP (Python Enhancement Proposal)는 Python의 표준 \u003ccode\u003eprint\u003c/code\u003e 문을 확장하여 기본 \u003ccode\u003esys.stdout\u003c/code\u003e 대신 모든 파일류(file-like) 객체로 출력을 보낼 수 있는 새로운 구문을 도입합니다. 이는 Python 2.0에 채택되었으며, 특정 출력 스트림으로 인쇄해야 할 필요가 있을 때 유용하게 사용될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e제안 (Proposal)\u003c/h3\u003e\n\u003cp\u003e이 제안은 \u003ccode\u003eprint\u003c/code\u003e 문에 출력 대상 파일(output file target)을 선택적으로 지정할 수 있는 구문 확장을 소개합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e사용 예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eprint \u003e\u003e mylogfile, 'this message goes to my log file'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e확장된 \u003ccode\u003eprint\u003c/code\u003e 문의 정식 구문은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprint_stmt: ... | '\u003e\u003e' test [ (',' test)+ [','] ] )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003e...\u003c/code\u003e는 기존 \u003ccode\u003eprint_stmt\u003c/code\u003e 구문이 변경되지 않았음을 나타냅니다. 확장된 형식에서 \u003ccode\u003e\u003e\u003e\u003c/code\u003e 바로 뒤에 오는 표현식은 \u003ccode\u003ewrite()\u003c/code\u003e 메서드를 가진 객체(즉, 파일류 객체)를 반환해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e동등한 문장:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eprint 'hello world'\r\nprint \u003e\u003e sys.stdout, 'hello world'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 문장 모두 동일하게 작동합니다.\u003c/p\u003e\n\u003cp\u003e또한, 다음 두 문장도 동등합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eprint\r\nprint \u003e\u003e sys.stdout\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e반면, 다음 두 문장은 문법 오류(syntax error)입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eprint ,\r\nprint \u003e\u003e sys.stdout,\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e정당성 (Justification)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eprint\u003c/code\u003e는 Python의 키워드이며, 언어 참조 설명서의 6.6절에 설명된 \u003ccode\u003eprint\u003c/code\u003e 문을 소개합니다. \u003ccode\u003eprint\u003c/code\u003e 문은 다음과 같은 특징을 가집니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e항목을 자동으로 문자열로 변환합니다.\u003c/li\u003e\n\u003cli\u003e항목 사이에 자동으로 공백을 삽입합니다.\u003c/li\u003e\n\u003cli\u003e문장이 쉼표(\u003ccode\u003e,\u003c/code\u003e)로 끝나지 않는 한 개행 문자(newline)를 추가합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eprint\u003c/code\u003e 문이 수행하는 포맷팅은 제한적입니다. 출력에 대한 더 많은 제어를 위해서는 \u003ccode\u003esys.stdout.write()\u003c/code\u003e와 문자열 보간(string interpolation)을 함께 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprint\u003c/code\u003e 문은 기본적으로 \u003ccode\u003esys.stdout\u003c/code\u003e으로 출력됩니다. \u003ccode\u003esys.stdout\u003c/code\u003e은 \u003ccode\u003ewrite()\u003c/code\u003e 메서드를 가진 파일류 객체여야 하지만, 표준 출력(standard output)이 아닌 다른 파일로 출력을 리디렉션하기 위해 다시 바인딩(rebind)될 수 있습니다. 일반적인 관용구(idiom)는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esave_stdout = sys.stdout\r\ntry:\r\n    sys.stdout = mylogfile\r\n    print 'this message goes to my log file'\r\nfinally:\r\n    sys.stdout = save_stdout\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 방식의 문제는 바인딩이 전역적(global)이어서 \u003ccode\u003etry:\u003c/code\u003e 절 내부의 모든 문장에 영향을 미친다는 것입니다. 예를 들어, 실제로 \u003ccode\u003estdout\u003c/code\u003e으로 출력하려던 함수 호출이 추가되면, 이 출력도 로그 파일로 리디렉션됩니다.\u003c/p\u003e\n\u003cp\u003e또한, 이 방식은 여러 출력 스트림으로 출력을 번갈아 보내기에는 매우 불편하며, \u003ccode\u003etry/except\u003c/code\u003e 또는 \u003ccode\u003etry/finally\u003c/code\u003e 절과 같은 코드 작성을 복잡하게 만듭니다.\u003c/p\u003e\n\u003ch3\u003e참조 구현 (Reference Implementation)\u003c/h3\u003e\n\u003cp\u003ePython 2.0 소스 트리에 대한 패치 형태의 참조 구현은 SourceForge의 패치 관리자에서 확인할 수 있습니다. 이 접근 방식은 \u003ccode\u003ePRINT_ITEM_TO\u003c/code\u003e와 \u003ccode\u003ePRINT_NEWLINE_TO\u003c/code\u003e라는 두 개의 새로운 opcode를 추가하는데, 이 opcode들은 스택(stack) 상단에서 파일류 객체를 팝(pop)하여 \u003ccode\u003esys.stdout\u003c/code\u003e 대신 출력 스트림으로 사용합니다. 이 참조 구현은 Python 2.0에 채택되었습니다.\u003c/p\u003e\n\u003ch3\u003e대안적 접근 방식 (Alternative Approaches)\u003c/h3\u003e\n\u003cp\u003e이 구문 변경에 대한 대안으로 Python 구문 변경이 필요 없는 방식이 제안되었습니다 (원래 Moshe Zadka). \u003ccode\u003ewriteln()\u003c/code\u003e 함수가 제공될 수 있으며 (내장 함수로도 가능), 몇 가지 추가 기능을 가진 확장된 \u003ccode\u003eprint\u003c/code\u003e와 매우 유사하게 작동합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef writeln(*args, **kws):\r\n    import sys\r\n    file = sys.stdout\r\n    sep = ' '\r\n    end = '\\n'\r\n    if kws.has_key('file'):\r\n        file = kws['file']\r\n        del kws['file']\r\n    if kws.has_key('nl'):\r\n        if not kws['nl']:\r\n            end = ' '\r\n        del kws['nl']\r\n    if kws.has_key('sep'):\r\n        sep = kws['sep']\r\n        del kws['sep']\r\n    if kws:\r\n        raise TypeError('unexpected keywords')\r\n    file.write(sep.join(map(str, args)) + end)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ewriteln()\u003c/code\u003e은 세 개의 선택적 키워드 인자(keyword arguments)를 받습니다. 이 제안의 맥락에서 관련 있는 인자는 \u003ccode\u003ewrite()\u003c/code\u003e 메서드를 가진 파일류 객체로 설정될 수 있는 \u003ccode\u003efile\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cp\u003e따라서, \u003ccode\u003eprint \u003e\u003e mylogfile, 'this goes to my log file'\u003c/code\u003e은 다음과 같이 작성될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ewriteln('this goes to my log file', file=mylogfile)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ewriteln()\u003c/code\u003e은 \u003ccode\u003enl\u003c/code\u003e 키워드 인자를 통해 개행 문자를 추가할지 여부를 지정하고, \u003ccode\u003esep\u003c/code\u003e 인자를 통해 각 항목 사이에 출력할 구분자를 지정하는 추가 기능을 가지고 있습니다.\u003c/p\u003e\n\u003ch3\u003eBDFL의 추가 정당성 (More Justification by the BDFL)\u003c/h3\u003e\n\u003cp\u003e이 제안은 뉴스그룹에서 이의가 제기되었습니다. 일부는 \u003ccode\u003e\u003e\u003e\u003c/code\u003e 기호를 싫어하며 다른 기호를 선호했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이의 제기:\u003c/strong\u003e 왜 다른 기호들을 사용하지 않는가? (\u003ccode\u003eprint in stderr\u003c/code\u003e, \u003ccode\u003eprint + stderr\u003c/code\u003e, \u003ccode\u003eprint[stderr]\u003c/code\u003e, \u003ccode\u003eprint to stderr\u003c/code\u003e 등)\r\n\u003cstrong\u003e응답:\u003c/strong\u003e 특별한 기호(\u003ccode\u003eprint \u0026#x3C;symbol\u003e expression\u003c/code\u003e)를 사용하려면, Python 파서는 해당 기호가 이미 표현식을 시작할 수 있는 기호가 아니어야 합니다. 그렇지 않으면 어떤 형태의 \u003ccode\u003eprint\u003c/code\u003e 문이 사용되는지 결정할 수 없습니다. 이는 식별자가 표현식을 시작할 수 있기 때문에 \"\u003ccode\u003eimport as\u003c/code\u003e\"에 사용된 \"컨텍스트에서만 키워드 트릭(keyword only in context trick)\"을 사용할 수 없음을 의미합니다. 이는 \u003ccode\u003e+stderr\u003c/code\u003e, \u003ccode\u003e[stderr]\u003c/code\u003e, \u003ccode\u003eto stderr\u003c/code\u003e를 제외시키고, \u003ccode\u003e\u003e\u003e\u003c/code\u003e와 같은 이항 연산자 기호나 현재 이곳에서 불법인 다른 잡다한 기호(예: \u003ccode\u003eimport\u003c/code\u003e)를 남깁니다.\r\n\u003ccode\u003e'print in file'\u003c/code\u003e과 \u003ccode\u003e'print \u003e\u003e file'\u003c/code\u003e 중에서 선택해야 한다면, \u003ccode\u003e\u003e\u003e\u003c/code\u003e를 선택할 것입니다. 부분적으로는 \u003ccode\u003e'in'\u003c/code\u003e이 새로운 발명품일 것이고 (다른 언어에서 사용하는 것을 알지 못함), \u003ccode\u003e'\u003e\u003e'\u003c/code\u003e는 \u003ccode\u003esh\u003c/code\u003e, \u003ccode\u003eawk\u003c/code\u003e, Perl, C++에서 사용되기 때문입니다. 또한, \u003ccode\u003e\u003e\u003e\u003c/code\u003e는 알파벳이 아니므로 더 눈에 띄어 독자의 주의를 끌 가능성이 높습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이의 제기:\u003c/strong\u003e 파일과 나머지 항목 사이에 쉼표가 있어야 하는 이유는 무엇인가?\r\n\u003cstrong\u003e응답:\u003c/strong\u003e 파일을 다음 표현식과 분리하는 쉼표는 필수적입니다! 파일이 단순히 단일 단어가 아닌 임의의 표현식이 되기를 원할 것입니다. (\u003ccode\u003eprint \u003e\u003esys.stderr\u003c/code\u003e와 같이 작성할 수 있기를 원할 것입니다.) 표현식이 없으면 파서는 해당 표현식이 어디서 끝나고 다음 표현식이 어디서 시작하는지 구별할 수 없을 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이의 제기:\u003c/strong\u003e 왜 구문 확장이 필요한가? \u003ccode\u003ewriteln(file, item, …)\u003c/code\u003e으로는 충분하지 않은가?\r\n\u003cstrong\u003e응답:\u003c/strong\u003e 우선, \u003ccode\u003eprint\u003c/code\u003e 문의 한 가지 기능인 마지막 개행을 억제하는 후행 쉼표(trailing comma)가 부족합니다. \u003ccode\u003e'print a,'\u003c/code\u003e가 여전히 \u003ccode\u003e'sys.stdout.write(a)'\u003c/code\u003e와 동등하지 않다는 점에 유의하십시오. \u003ccode\u003eprint\u003c/code\u003e는 항목 사이에 공백을 삽입하고 임의의 객체를 인자로 받습니다. \u003ccode\u003ewrite()\u003c/code\u003e는 공백을 삽입하지 않으며 단일 문자열을 요구합니다.\r\n\u003ccode\u003eprint\u003c/code\u003e 문에 대한 확장을 고려할 때, 한 차원(출력이 어디로 가는지)에서는 새로운 기능을 추가하지만 다른 차원(항목 사이의 공백, 후행 개행 선택 여부)에서는 기능을 제거하는 함수나 메서드를 추가하는 것은 올바르지 않습니다. 다양한 경우를 처리하기 위해 많은 메서드나 함수를 추가할 수도 있지만, 이는 불필요한 혼란을 가중시킬 뿐이며, \u003ccode\u003eprint\u003c/code\u003e 문을 완전히 비권장(deprecate)하는 경우에만 의미가 있을 것입니다.\r\n이 논쟁은 사실 \u003ccode\u003eprint\u003c/code\u003e가 문(statement)이 아닌 함수나 메서드였어야 하는지에 대한 것이라고 생각합니다. 함수 진영에 있다면, 기존 \u003ccode\u003eprint\u003c/code\u003e 문에 특수 구문을 추가하는 것을 좋아하지 않을 것입니다. 새로운 구문에 대한 반대는 주로 \u003ccode\u003eprint\u003c/code\u003e 문이 애초에 나쁜 생각이었다고 생각하는 사람들로부터 나온다고 짐작합니다.\r\n약 10년 전, 가장 기본적인 출력 형태를 함수로 만들지 문으로 만들지 스스로 고민했습니다. 기본적으로 \u003ccode\u003e'print(item, …)'\u003c/code\u003e와 \u003ccode\u003e'print item, …'\u003c/code\u003e 중에서 결정하려 했습니다. \u003ccode\u003eprint\u003c/code\u003e는 초기에 가르쳐야 하고 초보자가 작성하는 프로그램에서 매우 중요하기 때문에 문으로 만들기로 결정했습니다. 또한, 많은 것들의 선구자였던 ABC가 그것을 문으로 만들었기 때문입니다. ABC와 Python의 상호작용에서 전형적인 움직임으로, 저는 이름을 WRITE에서 \u003ccode\u003eprint\u003c/code\u003e로 바꾸고, 개행을 추가하기 위한 추가 구문(ABC는 후행 슬래시를 사용하여 개행을 나타냄)을 요구하는 것에서 개행을 억제하기 위한 추가 구문(후행 쉼표)을 요구하는 것으로 개행 추가 규칙을 역전시켰습니다. 저는 항목들이 출력 시 공백으로 구분되는 기능을 유지했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e전체 예시:\u003c/strong\u003e ABC에서 \u003ccode\u003eWRITE 1\u003c/code\u003e \u003ccode\u003eWRITE 2/\u003c/code\u003e는 Python에서 \u003ccode\u003eprint 1,\u003c/code\u003e \u003ccode\u003eprint 2\u003c/code\u003e와 동일한 효과를 가지며, 결과적으로 \"1 2\\n\"을 출력합니다.\u003c/p\u003e\n\u003cp\u003e저는 문으로 선택한 것이 100% 옳았는지 확신하지 못하지만 (ABC는 부작용이 있는 모든 것에 문법을 사용해야 하는 설득력 있는 이유가 있었지만, Python은 이런 관습이 없음), 틀렸다고 확신하지도 않습니다. 저는 \u003ccode\u003eprint\u003c/code\u003e 문의 간결함을 분명히 좋아합니다. 어쨌든, 저는 \u003ccode\u003eprint\u003c/code\u003e 문을 비권장할 준비가 되어 있지 않으며, 지난 몇 년 동안 파일을 지정하는 옵션에 대한 많은 요청이 있었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이의 제기:\u003c/strong\u003e 왜 \u003ccode\u003e\u003e\u003e\u003c/code\u003e 대신 \u003ccode\u003e\u003e\u003c/code\u003e를 사용하지 않는가?\r\n\u003cstrong\u003e응답:\u003c/strong\u003e DOS 및 Unix 사용자에게 \u003ccode\u003e\u003e\u003e\u003c/code\u003e는 \"추가(append)\"를, \u003ccode\u003e\u003e\u003c/code\u003e는 \"덮어쓰기(overwrite)\"를 제안합니다. 의미론적으로는 \"추가\"에 가장 가깝습니다. 또한, C++ 프로그래머에게 \u003ccode\u003e\u003e\u003e\u003c/code\u003e와 \u003ccode\u003e\u0026#x3C;\u0026#x3C;\u003c/code\u003e는 I/O 연산자입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이의 제기:\u003c/strong\u003e 하지만 C++에서 \u003ccode\u003e\u003e\u003e\u003c/code\u003e는 입력이고 \u003ccode\u003e\u0026#x3C;\u0026#x3C;\u003c/code\u003e는 출력이다!\r\n\u003cstrong\u003e응답:\u003c/strong\u003e 중요하지 않습니다. C++은 분명히 Unix에서 가져와서 화살표 방향을 바꿨습니다. 중요한 것은 출력의 경우 화살표가 파일을 가리킨다는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이의 제기:\u003c/strong\u003e \u003ccode\u003eprint \u003e\u003e file\u003c/code\u003e이 할 수 있는 모든 것을 \u003ccode\u003eprintln()\u003c/code\u003e 함수로 설계할 수 있을 텐데, 왜 그것으로는 충분하지 않은가?\r\n\u003cstrong\u003e응답:\u003c/strong\u003e 저는 이것을 간단한 프로그래밍 연습의 관점에서 생각합니다. 초보 프로그래머에게 곱셈표를 출력하는 함수를 작성하도록 요청받았다고 가정해 봅시다. 합리적인 해결책은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef tables(n):\r\n    for j in range(1, n+1):\r\n        for i in range(1, n+1):\r\n            print i, 'x', j, '=', i*j\r\n        print # 줄 바꿈\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 두 번째 연습으로 다른 파일에 출력하는 것을 추가해야 한다고 가정해 봅시다. 새로운 구문을 사용하면 프로그래머는 \u003ccode\u003eprint \u003e\u003e file,\u003c/code\u003e이라는 한 가지 새로운 것만 배우면 됩니다. 답은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef tables(n, file=sys.stdout):\r\n    for j in range(1, n+1):\r\n        for i in range(1, n+1):\r\n            print \u003e\u003e file, i, 'x', j, '=', i*j\r\n        print \u003e\u003e file # 줄 바꿈\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eprint\u003c/code\u003e 문과 \u003ccode\u003eprintln()\u003c/code\u003e 함수만 있다면, 프로그래머는 먼저 \u003ccode\u003eprintln()\u003c/code\u003e에 대해 배우고, 원본 프로그램을 \u003ccode\u003eprintln()\u003c/code\u003e을 사용하도록 변환해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef tables(n):\r\n    for j in range(1, n+1):\r\n        for i in range(1, n+1):\r\n            println(i, 'x', j, '=', i*j)\r\n        println()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 나서 \u003ccode\u003efile\u003c/code\u003e 키워드 인자에 대해 배워야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef tables(n, file=sys.stdout):\r\n    for j in range(1, n+1):\r\n        for i in range(1, n+1):\r\n            println(i, 'x', j, '=', i*j, file=sys.stdout)\r\n        println(file=sys.stdout)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e따라서, 변환 경로가 더 깁니다.\r\n\u003ccode\u003e(1) print\u003c/code\u003e → \u003ccode\u003e(2) print \u003e\u003e file\u003c/code\u003e\r\nvs.\r\n\u003ccode\u003e(1) print\u003c/code\u003e → \u003ccode\u003e(2) println()\u003c/code\u003e → \u003ccode\u003e(3) println(file=...)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e \u003ccode\u003efile\u003c/code\u003e 인자를 컴파일 시점에 \u003ccode\u003esys.stdout\u003c/code\u003e으로 기본 설정하는 것은 잘못된 것입니다. 호출자가 \u003ccode\u003esys.stdout\u003c/code\u003e에 할당한 후 파일을 지정하지 않고 \u003ccode\u003etables()\u003c/code\u003e를 사용하면 제대로 작동하지 않기 때문입니다. 이는 흔한 문제이며 (\u003ccode\u003eprintln()\u003c/code\u003e 함수에서도 발생할 수 있습니다). 지금까지의 표준 해결책은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef tables(n, file=None):\r\n    if file is None:\r\n        file = sys.stdout\r\n    for j in range(1, n+1):\r\n        for i in range(1, n+1):\r\n            print \u003e\u003e file, i, 'x', j, '=', i*j\r\n        print \u003e\u003e file\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e저는 구현에 기능을 추가했는데 (\u003ccode\u003eprintln()\u003c/code\u003e에도 권장), \u003ccode\u003efile\u003c/code\u003e 인자가 \u003ccode\u003eNone\u003c/code\u003e이면 \u003ccode\u003esys.stdout\u003c/code\u003e이 자동으로 사용됩니다. 따라서,\r\n\u003ccode\u003eprint \u003e\u003e None, foo bar\u003c/code\u003e (또는 \u003ccode\u003ex\u003c/code\u003e의 값이 \u003ccode\u003eNone\u003c/code\u003e인 변수 \u003ccode\u003ex\u003c/code\u003e를 사용하는 \u003ccode\u003eprint \u003e\u003e x\u003c/code\u003e)는 \u003ccode\u003eprint foo, bar\u003c/code\u003e와 같은 의미입니다. \u003ccode\u003etables()\u003c/code\u003e 함수는 다음과 같이 작성될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef tables(n, file=None):\r\n    for j in range(1, n+1):\r\n        for i in range(1, n+1):\r\n            print \u003e\u003e file, i, 'x', j, '=', i*j\r\n        print \u003e\u003e file\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 214 - Extended Print Statement\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 16:31:25+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>