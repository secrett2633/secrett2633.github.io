3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-0249a4ed84fdbe73.js","185","static/chunks/app/layout-c3e2e457f12fb6f6.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-ce60b0a6591d04ed.js"],""]
4:["slug","python/pep/806","c"]
0:["e6YNzZ2BVZ8NBZ6boXfWj",[[["",{"children":[["slug","python/pep/806","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"806\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/806","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e975486d410ad4e9.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T3a63,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0806/">PEP 806 - Mixed sync/async context managers with precise async marking</a></p>
<p><strong>상태:</strong> Draft | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 05-Sep-2025</p>
</blockquote>
<p>PEP 806 – 혼합 동기/비동기 컨텍스트 관리자 (정확한 비동기 표기법)</p>
<h2>초록 (Abstract)</h2>
<p>현재 Python에서는 <code>with</code> 또는 <code>async with</code> 문을 사용하여 여러 컨텍스트 관리자를 한 번에 처리할 수 있지만, 이들은 각각 동기(synchronous) 또는 비동기(asynchronous) 컨텍스트 관리자로만 구성되어야 합니다. 동기 컨텍스트 관리자와 비동기 컨텍스트 관리자를 함께 사용해야 하는 경우, 개발자는 깊게 중첩된 문장을 사용하거나 <code>AsyncExitStack</code>과 같은 위험한 우회 방법을 사용해야 했습니다.</p>
<p>이 PEP는 단일 <code>with</code> 문에서 동기 및 비동기 컨텍스트 관리자를 모두 허용하며, 개별 비동기 컨텍스트 관리자에 <code>async</code> 키워드를 접두사로 붙이는 방식을 제안합니다. 이 변경은 불필요한 중첩을 없애고 코드 가독성을 향상시키며, 비동기 코드의 명시성을 유지하면서 사용 편의성을 개선합니다.</p>
<h2>동기 (Motivation)</h2>
<p>최신 Python 애플리케이션은 동기 및 비동기 컨텍스트 관리자를 혼합하여 여러 리소스를 획득해야 하는 경우가 많습니다. 모든 컨텍스트 관리자가 동기이거나 모든 컨텍스트 관리자가 비동기인 경우에는 단일 문으로 여러 컨텍스트 관리자를 처리할 수 있지만, 둘을 혼합하면 "지옥의 계단(staircase of doom)"과 같은 과도한 들여쓰기가 발생합니다.</p>
<p>예시:</p>
<pre><code class="language-python">async def process_data():
    async with acquire_lock() as lock:
        with temp_directory() as tmpdir:
            async with connect_to_db(cache=tmpdir) as db:
                with open('config.json', encoding='utf-8') as f:
                    # 실제 로직을 시작하기 전에 16칸 깊이로 들여쓰기 됨
                    config = json.load(f)
                    await db.execute(config['query'])
                    # ... 더 많은 처리
</code></pre>
<p>이러한 과도한 들여쓰기는 컨텍스트 관리자의 바람직한 의미에도 불구하고 사용을 저해합니다.</p>
<p>이 PEP가 적용되면 위 함수는 다음과 같이 작성할 수 있습니다:</p>
<pre><code class="language-python">async def process_data():
    with (
        async acquire_lock() as lock,
        temp_directory() as tmpdir,
        async connect_to_db(cache=tmpdir) as db,
        open('config.json', encoding='utf-8') as f,
    ):
        config = json.load(f)
        await db.execute(config['query'])
        # ... 더 많은 처리
</code></pre>
<p>이 간결한 대안은 동기 및 비동기 컨텍스트 관리자 간에 전환할 때마다 새로운 수준의 들여쓰기를 강제하지 않습니다. 동시에, 기존 키워드만 사용하여 현재 구문보다 <code>async</code> 키워드로 비동기 코드를 더 정확하게 구별합니다.</p>
<p><code>async with</code> 문의 사용이 중단되는 것을 제안하지 않으며, 단일 라인 문에서는 <code>async with</code>의 계속 사용을 지지합니다. 이는 <code>async</code>가 비동기 컨텍스트 관리자를 여는 각 라인의 첫 번째 비공백 토큰이 되도록 하기 위함입니다.</p>
<p>하지만 이 제안은 <code>with async some_ctx()</code>를 허용하여, 단일 코드 스타일의 강제보다는 일관된 구문 설계를 중요하게 생각합니다. 이는 스타일 가이드, 린터, 포매터 등에 의해 처리될 것으로 예상됩니다.</p>
<h2>실제 영향 (Real-World Impact)</h2>
<p>이 개선 사항은 Python 개발자들이 일상적으로 겪는 어려움을 해결합니다. 한 산업 코드베이스를 조사한 결과, 만 개 이상의 함수에 적어도 하나의 비동기 컨텍스트 관리자가 포함되어 있었으며, 이 중 19%는 동기 컨텍스트 관리자도 포함하고 있었습니다. 비동기 함수는 비동기 컨텍스트 관리자를 포함하는 것만큼 동기 컨텍스트 관리자를 약 3분의 2 정도 자주 포함합니다.</p>
<p><code>with</code>와 <code>async with</code> 문을 모두 포함하는 함수의 39%는 제안된 구문으로 즉시 전환할 수 있었지만, 이는 동기 컨텍스트 관리자의 회피 및 '기각된 아이디어(Rejected Ideas)' 섹션에 나열된 우회책 사용으로 인한 느슨한 하한선입니다. 무작위 함수 샘플을 검사한 결과, 이 PEP가 수락된다면 컨텍스트 관리자를 포함하는 비동기 함수의 20%에서 50% 사이가 <code>with async</code>를 사용할 것으로 추정됩니다.</p>
<p>더 넓은 생태계에서는 이 비율이 5%에서 20% 범위로 낮아질 것으로 예상됩니다. 조사된 코드베이스는 Trio와 함께 구조화된 동시성을 사용하며, PEP 533 및 PEP 789에서 논의된 문제를 완화하기 위해 컨텍스트 관리자를 광범위하게 사용합니다.</p>
<h2>이론적 근거 (Rationale)</h2>
<p>비동기 데이터베이스 연결이나 API 클라이언트, 동기 파일 작업과 같은 혼합 동기/비동기 컨텍스트 관리자는 최신 Python 애플리케이션에서 흔히 사용됩니다. 현재 구문은 개발자에게 깊게 중첩된 코드 또는 <code>AsyncExitStack</code>과 같은 오류 발생 가능성이 있는 우회책 중에서 선택하도록 강요합니다.</p>
<p>이 PEP는 기존 패턴을 기반으로 한 최소한의 구문 변경으로 이 문제를 해결합니다. 개별 컨텍스트 관리자를 <code>async</code>로 표시할 수 있게 함으로써, 불필요한 중첩을 없애면서도 비동기 코드에 대한 Python의 명시적인 접근 방식을 유지합니다.</p>
<p>구현은 문법 설탕(syntactic sugar)으로, 런타임 오버헤드가 전혀 발생하지 않도록 합니다. 새로운 구문은 개발자가 현재 작성하는 것과 동일한 중첩된 <code>with</code> 및 <code>async with</code> 문으로 역변환(desugar)됩니다. 이 접근 방식은 새로운 프로토콜, 기존 컨텍스트 관리자에 대한 변경, 또는 이해해야 할 새로운 런타임 동작을 요구하지 않습니다.</p>
<h2>명세 (Specification)</h2>
<p><code>with (..., async ...):</code> 구문은 현재의 다중 컨텍스트 <code>with</code> 문과 동일한 방식으로 컨텍스트 관리자 시퀀스로 역변환됩니다. 단, <code>async</code> 키워드가 접두사로 붙은 컨텍스트 관리자는 <code>__aenter__</code> / <code>__aexit__</code> 프로토콜을 사용합니다.</p>
<p><code>with</code> 문만 수정됩니다. <code>async with async ctx():</code>는 문법 오류입니다.</p>
<p><code>ast.withitem</code> 노드는 <code>ast.comprehension</code>의 기존 <code>is_async</code> 속성을 따라 새로운 <code>is_async</code> 정수 속성을 얻습니다. <code>async with</code> 문 항목의 경우, 이 속성은 항상 <code>1</code>입니다. 일반 <code>with</code> 문 항목의 경우, <code>async</code> 키워드가 있으면 속성이 <code>1</code>이고, 그렇지 않으면 <code>0</code>입니다. 이를 통해 AST는 기존 AST 처리 도구와의 하위 호환성을 유지하면서 어떤 컨텍스트 관리자가 비동기 프로토콜을 사용해야 하는지 정확하게 표현할 수 있습니다.</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>이 변경은 완전히 하위 호환됩니다. 유일하게 관찰 가능한 차이점은 이전에 <code>SyntaxError</code>를 발생시키던 특정 구문이 이제 성공적으로 실행된다는 것입니다.</p>
<p>컨텍스트 관리자를 구현하는 라이브러리(표준 라이브러리 및 서드 파티)는 수정 없이 새로운 구문에서 작동합니다. 소스 코드와 직접 작동하는 라이브러리 및 도구는 새로운 구문과 마찬가지로 사소한 업데이트가 필요할 것입니다.</p>
<h2>가르치는 방법 (How to Teach This)</h2>
<p><code>async with</code>와 함께 또는 직후에 "혼합 컨텍스트 관리자(mixed context managers)"를 소개하는 것을 권장합니다. 예를 들어, 튜토리얼은 다음을 다룰 수 있습니다:</p>
<ul>
<li><strong>기본 컨텍스트 관리자:</strong> 단일 <code>with</code> 문으로 시작합니다.</li>
<li><strong>다중 컨텍스트 관리자:</strong> 현재의 쉼표 구문을 보여줍니다.</li>
<li><strong>비동기 컨텍스트 관리자:</strong> <code>async with</code>를 소개합니다.</li>
<li><strong>혼합 컨텍스트:</strong> "각 비동기 컨텍스트 관리자를 <code>async</code>로 표시합니다".</li>
</ul>
<h2>기각된 아이디어 (Rejected Ideas)</h2>
<h3>우회책: <code>as_acm()</code> 래퍼 (Workaround: an <code>as_acm()</code> wrapper)</h3>
<p>동기 컨텍스트 관리자를 비동기 컨텍스트 관리자로 래핑하는 헬퍼 함수를 구현하는 것은 쉽습니다. 예를 들어:</p>
<pre><code class="language-python">@contextmanager
async def as_acm(sync_cm):
    with sync_cm as result:
        await sleep(0)
        yield result

async with (
    acquire_lock(),
    as_acm(open('file')) as f,
):
    ...
</code></pre>
<p>이는 거의 모든 코드에 권장되는 우회책입니다. 그러나 취소를 허용하기 위해 비동기 런타임으로 다시 호출하는 것(예: <code>await sleep(0)</code> 실행)이 바람직하지 않은 경우가 있습니다. 다른 한편으로, <code>await sleep(0)</code>을 생략하면 구문적 <code>await</code> / <code>async for</code> / <code>async with</code>가 항상 비동기 런타임으로 다시 호출(또는 예외 발생)한다는 추이적 속성이 깨집니다. 현재 이 속성을 강제하는 코드베이스는 거의 없지만, 이는 교착 상태(deadlock)를 방지하는 데 필수적이며, 따라서 생태계의 더 깔끔한 기반을 선호합니다.</p>
<h3>우회책: <code>AsyncExitStack</code> 사용 (Workaround: using <code>AsyncExitStack</code>)</h3>
<p><code>AsyncExitStack</code>은 동기 및/또는 비동기 컨텍스트 관리자의 명시적 진입을 허용하는 강력한 저수준 인터페이스를 제공합니다.</p>
<pre><code class="language-python">async with contextlib.AsyncExitStack() as stack:
    await stack.enter_async_context(acquire_lock())
    f = stack.enter_context(open('file', encoding='utf-8'))
    ...
</code></pre>
<p>그러나 <code>AsyncExitStack</code>은 상당한 복잡성과 오류 가능성을 초래합니다. 구문적으로 컨텍스트 관리자를 사용하는 것이 보장하는 속성(예: '후입선출(last-in, first-out)' 순서)을 위반하기 쉽습니다.</p>
<h3>우회책: <code>AsyncExitStack</code> 기반 헬퍼 (Workaround: AsyncExitStack -based helper)</h3>
<p><code>AsyncExitStack</code>의 직접적인 사용으로 인한 단점 중 일부를 피하는 <code>multicontext()</code> 래퍼를 구현할 수도 있습니다.</p>
<pre><code class="language-python">async with multicontext(
    acquire_lock(),
    open('file'),
) as (f, _):
    ...
</code></pre>
<p>하지만 이 헬퍼는 <code>as</code> 절의 지역성을 깨뜨려, 의도치 않게 yield된 변수를 잘못 할당하기 쉽게 만듭니다 (코드 샘플에서와 같이). 또한 태그가 지정된 유니온(tagged union)과 같은 것을 사용하여 동기 컨텍스트 관리자와 비동기 컨텍스트 관리자를 구별해야 하거나(예: <code>async_ @ acquire_lock()</code> 작동) 또는 동기 및 비동기 컨텍스트 관리자 프로토콜을 모두 구현하는 객체에 대해 무엇을 할지 추측해야 합니다. 마지막으로, <code>contextlib.nested()</code>가 다중 인자 <code>with</code> 문을 선호하여 폐기된 이유가 되었던 예외 처리에 대한 오류 발생 가능성이 있는 의미를 가집니다.</p>
<h3>구문: <code>async with sync_cm, async_cm:</code> 허용 (Syntax: allow <code>async with sync_cm, async_cm:</code>)</h3>
<p>이 제안의 초기 초안은 적어도 하나의 비동기 컨텍스트 관리자가 있는 경우, 컨텍스트 관리자를 혼합할 때 전체 문장에 <code>async with</code>를 사용했습니다.</p>
<pre><code class="language-python"># 기각된 접근 방식
async with (
    acquire_lock(),
    open('config.json') as f, # 실제로는 동기, 놀랍게도!
):
    ...
</code></pre>
<p><code>async</code> 컨텍스트 관리자를 요구하는 것은 구문/스케줄러 링크를 유지하지만, 미래 코드 변경에 눈에 띄지 않는 제약을 가하는 대가를 치릅니다. 여러 컨텍스트 관리자 중 하나를 제거하면, 그것이 마지막 비동기 컨텍스트 관리자였을 경우 런타임 오류가 발생할 수 있습니다.</p>
<p>명시적인 것이 암시적인 것보다 낫습니다 (<code>Explicit is better than implicit</code>).</p>
<h3>구문: 단일 라인 <code>with async ...</code> 금지 (Syntax: ban single-line <code>with async ...</code>)</h3>
<p>제안된 구문은 제한될 수 있습니다. 예를 들어, <code>async</code>를 괄호로 묶인 다중 컨텍스트 <code>with</code> 문의 라인 첫 번째 토큰으로만 배치하도록 할 수 있습니다. 이것이 실제로 권장되는 사용 방식이며, 대부분의 사용이 이 패턴을 따를 것으로 예상됩니다.</p>
<p><code>async with ctx():</code> 또는 <code>with async ctx():</code> 둘 중 하나를 작성할 수 있는 옵션은 모호성으로 인해 약간의 혼란을 야기할 수 있지만, 구문을 통해 선호하는 스타일을 강제하는 것은 Python을 배우는 것을 더 혼란스럽게 만들 것이라고 생각하며, 따라서 간단한 구문 규칙과 커뮤니티의 사용법에 대한 관습을 선호합니다.</p>
<p>예를 들어, 다음 코드 샘플 중 어느 시점(있다면)에서 구문이 허용되지 않아야 하는지는 명확하지 않다고 생각합니다:</p>
<pre><code class="language-python">with (
    sync_context() as foo,
    async a_context() as bar,
):
    ...
with (
    sync_context() as foo,
    async a_context()
):
    ...
with (
    # sync_context() as foo,
    async a_context()
):
    ...
with (async a_context()):
    ...
with async a_context():
    ...
</code></pre>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1214,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Draft] PEP 806 - Mixed sync/async context managers with precise async marking"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-27 14:10:48+0900","children":"2025년 9월 27일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 27일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}]]
1:null
