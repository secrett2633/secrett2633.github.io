<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 412 - Key-Sharing Dictionary</h1><div class="page__meta"><time dateTime="2025-09-26 21:32:26+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0412/">PEP 412 - Key-Sharing Dictionary</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 08-Feb-2012</p>
</blockquote>
<h1>PEP 412 – 키 공유 딕셔너리 (Key-Sharing Dictionary)</h1>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 파이썬 내장 딕셔너리 타입인 <code>dict</code>의 구현 변경을 제안합니다. 새로운 구현은 객체의 속성 딕셔너리(예: 객체의 <code>__dict__</code> 속성)로 사용되는 딕셔너리들이 동일한 클래스의 다른 인스턴스들의 속성 딕셔너리와 키를 공유할 수 있도록 합니다.</p>
<h2>도입 배경 (Motivation)</h2>
<p>기존 딕셔너리 구현은 객체 속성을 위한 컨테이너로 사용될 때 필요 이상으로 많은 메모리를 사용했습니다. 이는 키가 동일한 클래스의 여러 인스턴스 간에 공유되지 않고, 각 인스턴스마다 복제되었기 때문입니다. 하지만 일반적인 매핑 객체로서는 매우 잘 튜닝되어 뛰어난 성능을 보였습니다.</p>
<p>이 제안은 키(및 해시)를 값과 분리함으로써 여러 딕셔너리 간에 키를 공유하고 메모리 사용량을 개선할 수 있게 합니다. 키가 값과 분리되는 시점을 이점이 있는 경우로 제한하여, 일반적인 매핑 객체로 사용될 때 현재 딕셔너리 구현의 높은 성능을 유지할 수 있도록 합니다.</p>
<h2>동작 방식 (Behaviour)</h2>
<p>새로운 딕셔너리는 기존 구현과 동일하게 동작합니다. 이는 Python API, C API, 그리고 ABI(Application Binary Interface)를 완벽하게 준수합니다.</p>
<h2>성능 (Performance)</h2>
<h3>메모리 사용량 (Memory Usage)</h3>
<p>메모리 사용량 감소는 특정 시점에 존재하는 키를 공유하는 딕셔너리의 수와 직접적으로 관련이 있습니다. 이러한 딕셔너리들은 일반적으로 기존 딕셔너리 구현 크기의 절반 정도입니다. 벤치마킹 결과, 객체 지향 프로그램의 경우 메모리 사용량이 10%에서 20% 감소했으며, 다른 프로그램에서는 메모리 사용량에 큰 변화가 없었습니다.</p>
<h3>속도 (Speed)</h3>
<p>새로운 구현의 성능은 메모리 지역성(memory locality) 효과에 의해 크게 좌우됩니다. 키가 공유되지 않는 경우(예: 모듈 딕셔너리 또는 <code>dict()</code>나 <code>{}</code>로 명시적으로 생성된 딕셔너리)에는 기존 구현과 비교하여 성능 변화가 거의 없습니다(1~2% 이내).</p>
<p>키가 공유되는 경우에는 새로운 구현이 키를 값과 분리하는 경향이 있지만, 전체 메모리 사용량을 줄입니다. 이는 감소된 메모리 사용량의 효과가 지역성 손실을 상회하여 많은 경우에 성능을 향상시키지만, 일부 프로그램에서는 약간의 속도 저하를 보일 수도 있습니다. 벤치마킹 결과, 대부분의 벤치마크에서는 속도 변화가 크지 않았습니다. 객체 지향 벤치마크에서는 동일한 클래스의 많은 객체를 생성할 때 작은 속도 향상을 보였습니다(gcbench 벤치마크에서 10% 속도 향상; 이는 상한선일 가능성이 높습니다).</p>
<h2>구현 (Implementation)</h2>
<p>기존 딕셔너리와 새로운 딕셔너리 모두 고정 크기의 <code>dict</code> 구조체와 크기 조절이 가능한 테이블로 구성됩니다. 새로운 딕셔너리에서는 테이블이 키 테이블(keys table)과 값 배열(values array)로 더 분리될 수 있습니다. 키 테이블은 키와 해시를 저장하며 (분리되지 않은 테이블의 경우) 값도 함께 저장합니다. 이는 이전에 <code>dict</code> 구조체에 있던 여러 필드를 포함한다는 점만 기존 구현과 다릅니다. 테이블이 분리되면 키 테이블의 값은 무시되고, 대신 값들은 별도의 배열에 저장됩니다.</p>
<h3>분리형 테이블 딕셔너리 (Split-Table dictionaries)</h3>
<p>객체의 <code>__dict__</code> 슬롯을 채우기 위해 딕셔너리가 생성될 때, 이들은 분리형으로 생성됩니다. 키 테이블은 타입(type)에 캐시(cache)되어, 잠재적으로 한 클래스의 모든 인스턴스 속성 딕셔너리가 키를 공유할 수 있게 합니다. 이 딕셔너리들의 키가 달라지기 시작하는 경우, 개별 딕셔너리는 지연(lazily) 방식으로 결합형 테이블(combined-table) 형태로 변환됩니다. 이는 일반적인 경우에 좋은 메모리 사용량을 보장하고, 모든 경우에 올바른 동작을 보장합니다.</p>
<p>분리형 딕셔너리의 크기를 재조정(resizing)할 때, 이는 결합형 테이블로 변환됩니다. 인스턴스 속성을 저장한 결과로 크기를 재조정해야 하고, 클래스의 인스턴스가 하나만 있는 경우, 딕셔너리는 즉시 다시 분리됩니다. 대부분의 객체 지향 코드는 <code>__init__</code> 메서드에서 속성을 설정하므로, 두 번째 인스턴스가 생성되기 전에 모든 속성이 설정되고 이후의 모든 인스턴스 딕셔너리는 올바른 크기를 가질 것이므로 더 이상 크기 재조정이 필요하지 않습니다. 더 복잡한 사용 패턴의 경우, 어떤 접근 방식이 최선인지 알 수 없으므로, 구현은 크기 재조정 시점까지 추가 삽입을 허용하고 이후에는 결합형 테이블(키 비공유)로 되돌아갑니다.</p>
<p>분리형 딕셔너리에서 삭제는 키 테이블을 변경하지 않고, 단순히 값 배열에서 값을 제거합니다.</p>
<h3>결합형 테이블 딕셔너리 (Combined-Table dictionaries)</h3>
<p>명시적 딕셔너리(<code>dict()</code> 또는 <code>{}</code>), 모듈 딕셔너리 및 대부분의 다른 딕셔너리는 결합형 테이블 딕셔너리로 생성됩니다. 결합형 테이블 딕셔너리는 절대로 분리형 테이블 딕셔너리가 되지 않습니다. 결합형 테이블은 기존 딕셔너리의 테이블과 거의 동일한 방식으로 구성되어, 매우 유사한 성능을 보입니다.</p>
<h2>구현의 장단점 (Pros and Cons)</h2>
<h3>장점 (Pros)</h3>
<ul>
<li>객체 지향 애플리케이션의 경우 상당한 메모리 절약 효과가 있습니다.</li>
<li>유사한 객체를 많이 생성하는 프로그램의 경우 속도가 약간 향상됩니다.</li>
</ul>
<h3>단점 (Cons)</h3>
<ul>
<li><strong>데이터 구조 변경:</strong> 딕셔너리 구현의 내부를 다루는 서드 파티 모듈은 작동하지 않을 수 있습니다.</li>
<li><strong><code>repr()</code> 출력 및 반복 순서 변경:</strong> 대부분의 경우 변경되지 않습니다. 그러나 일부 분리형 테이블 딕셔너리의 경우 반복 순서가 변경될 수 있습니다.</li>
</ul>
<p>이러한 단점들은 문제가 되지 않을 것으로 예상됩니다. 딕셔너리 구현의 내부를 다루는 모듈은 이미 문제가 있으며 API를 사용하도록 수정되어야 합니다. 딕셔너리의 반복 순서는 정의된 적이 없으며 항상 임의적이었고, Jython 및 PyPy에서도 다르게 동작합니다.</p>
<h2>대안 구현 (Alternative Implementation)</h2>
<p>분리형 테이블을 위한 대안 구현으로, 키 테이블의 값 필드에 인덱스를 저장하여(값 필드를 무시하는 대신) 더 많은 메모리를 절약할 수 있습니다. 이 인덱스는 값 배열에서 찾아야 할 위치를 명시적으로 나타냅니다. 이렇게 하면 값 배열은 키 테이블의 각 슬롯이 아닌, 사용 가능한 각 슬롯에 대해 하나의 필드만 필요하게 됩니다.</p>
<p>이 "인덱스된(indexed)" 버전은 값 배열의 크기를 약 3분의 1로 줄일 수 있습니다. 키 테이블에는 추가 "values_size" 필드가 필요하며, 이는 결합된 딕셔너리의 크기를 한 워드(word)만큼 증가시킵니다. 추가적인 간접 참조(indirection)는 코드의 복잡성을 증가시키고, 잠재적으로 성능을 약간 저하시킬 수 있습니다.</p>
<p>이 "인덱스된" 버전은 현재 구현에 포함되지 않지만, 추가 실험을 기다리는 동안 보류된 것으로 간주되어야 하며, 거부된 것은 아닙니다.</p>
<hr>
<p>I have translated the entire PEP document according to the guidelines. I have used Markdown for structure, maintained professionalism, handled terminology as requested, and provided citations for every sentence derived from the browsed content.
The user's request is to provide a translation and summary. I have translated the content and structured it in a way that summarises the key points within each section.
The content covers the abstract, motivation, behaviour, performance, implementation details (split-table and combined-table), pros and cons, and an alternative implementation.
This should fulfill the user's request.
I am done.
The response is the translated PEP.
Final check on the guidelines:</p>
<ol>
<li>Professionalism: Yes, tried to use appropriate technical terms.</li>
<li>Terminology: Used Korean terms when common, otherwise kept English or 병기 (e.g., <code>List Comprehension</code>, <code>Generator (제너레이터)</code> - though not many explicit examples in this specific PEP). Keywords like <code>__dict__</code>, <code>dict</code>, <code>async</code>, <code>await</code> are not translated.</li>
<li>Readability: Markdown headings and lists are used.</li>
<li>Accuracy: Translated content fully, as markdown.</li>
<li>Citations: Every sentence referring to the browse result has ``.</li>
<li>Brevity for URL summary: This is for "ONE URL" summary, and the prompt says "If you are summarizing anything else or MORE THAN ONE URL, ignore this limitation". I'm translating the whole document, not just a summary of one URL. So, the brevity limit doesn't apply here.# PEP 412 – 키 공유 딕셔너리 (Key-Sharing Dictionary)</li>
</ol>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 파이썬 내장 딕셔너리 타입인 <code>dict</code>의 구현 변경을 제안합니다. 새로운 구현은 객체의 속성 딕셔너리(예: 객체의 <code>__dict__</code> 속성)로 사용되는 딕셔너리들이 동일한 클래스의 다른 인스턴스들의 속성 딕셔너리와 키를 공유할 수 있도록 합니다.</p>
<h2>도입 배경 (Motivation)</h2>
<p>기존 딕셔너리 구현은 객체 속성을 위한 컨테이너로 사용될 때, 동일한 클래스의 여러 인스턴스 간에 키가 복제되어 필요 이상으로 많은 메모리를 사용했습니다. 하지만 일반적인 매핑 객체로서는 매우 잘 튜닝되어 뛰어난 성능을 보였습니다.</p>
<p>이 제안은 키(및 해시)를 값과 분리함으로써 여러 딕셔너리 간에 키를 공유하여 메모리 사용량을 개선하는 것을 목표로 합니다. 또한, 키가 값과 분리되는 시점을 이점이 있는 경우로 제한하여, 일반적인 매핑 객체로 사용될 때 기존 딕셔너리 구현의 높은 성능을 유지하도록 합니다.</p>
<h2>동작 방식 (Behaviour)</h2>
<p>새로운 딕셔너리는 기존 구현과 동일하게 동작하며, Python API, C API, 그리고 ABI(Application Binary Interface)를 완벽하게 준수합니다.</p>
<h2>성능 (Performance)</h2>
<h3>메모리 사용량 (Memory Usage)</h3>
<p>메모리 사용량 감소는 키를 공유하는 딕셔너리의 수에 비례합니다. 이러한 딕셔너리들은 일반적으로 기존 딕셔너리 구현 크기의 절반 정도입니다. 벤치마킹 결과, 객체 지향 프로그램의 경우 메모리 사용량이 10%에서 20% 감소했으며, 다른 프로그램에서는 큰 변화가 없었습니다.</p>
<h3>속도 (Speed)</h3>
<p>새로운 구현의 성능은 메모리 지역성(memory locality) 효과에 의해 크게 좌우됩니다. 키가 공유되지 않는 경우(예: 모듈 딕셔너리, <code>dict()</code> 또는 <code>{}</code>로 생성된 딕셔너리)에는 기존 구현과 비교하여 성능 변화가 거의 없습니다(1~2% 이내).</p>
<p>키가 공유되는 경우에는 키와 값을 분리하지만 전체 메모리 사용량을 줄입니다. 이는 감소된 메모리 사용량의 효과가 지역성 손실을 상회하여 많은 경우에 성능을 향상시키지만, 일부 프로그램에서는 약간의 속도 저하를 보일 수도 있습니다. 벤치마킹 결과, 대부분의 벤치마크에서는 속도 변화가 크지 않았습니다. 동일한 클래스의 많은 객체를 생성하는 객체 지향 벤치마크에서는 작은 속도 향상을 보였습니다(gcbench 벤치마크에서 10% 속도 향상; 이는 상한선일 가능성이 높습니다).</p>
<h2>구현 (Implementation)</h2>
<p>기존 딕셔너리와 새로운 딕셔너리 모두 고정 크기의 <code>dict</code> 구조체와 크기 조절이 가능한 테이블로 구성됩니다. 새로운 딕셔너리에서는 이 테이블이 키 테이블(keys table)과 값 배열(values array)로 더 분리될 수 있습니다. 키 테이블은 키와 해시를 저장하며 (분리되지 않은 테이블의 경우) 값도 함께 저장합니다. 테이블이 분리되면 키 테이블의 값은 무시되고, 대신 값들은 별도의 배열에 저장됩니다.</p>
<h3>분리형 테이블 딕셔너리 (Split-Table dictionaries)</h3>
<p>객체의 <code>__dict__</code> 슬롯을 채우기 위해 딕셔너리가 생성될 때, 이들은 분리형으로 생성됩니다. 키 테이블은 타입(type)에 캐시(cache)되어, 한 클래스의 모든 인스턴스 속성 딕셔너리가 키를 공유할 수 있게 합니다. 키가 달라지기 시작하는 경우, 개별 딕셔너리는 지연(lazily) 방식으로 결합형 테이블(combined-table) 형태로 변환됩니다. 이는 일반적인 경우에 좋은 메모리 사용량을 보장하며 모든 경우에 올바른 동작을 보장합니다.</p>
<p>분리형 딕셔너리의 크기를 재조정(resizing)할 때 결합형 테이블로 변환됩니다. 대부분의 객체 지향 코드는 <code>__init__</code> 메서드에서 속성을 설정하므로, 두 번째 인스턴스가 생성되기 전에 모든 속성이 설정되고 이후의 모든 인스턴스 딕셔너리는 올바른 크기를 가지게 됩니다. 분리형 딕셔너리에서 삭제는 키 테이블을 변경하지 않고 값 배열에서만 값을 제거합니다.</p>
<h3>결합형 테이블 딕셔너리 (Combined-Table dictionaries)</h3>
<p>명시적 딕셔너리(<code>dict()</code> 또는 <code>{}</code>), 모듈 딕셔너리 및 대부분의 다른 딕셔너리는 결합형 테이블 딕셔너리로 생성됩니다. 결합형 테이블 딕셔너리는 분리형 테이블 딕셔너리로 변환되지 않으며, 기존 딕셔너리의 테이블과 유사하게 구성되어 매우 비슷한 성능을 보입니다.</p>
<h2>구현의 장단점 (Pros and Cons)</h2>
<h3>장점 (Pros)</h3>
<ul>
<li>객체 지향 애플리케이션의 경우 상당한 메모리 절약 효과가 있습니다.</li>
<li>유사한 객체를 많이 생성하는 프로그램의 경우 속도가 약간 향상됩니다.</li>
</ul>
<h3>단점 (Cons)</h3>
<ul>
<li><strong>데이터 구조 변경:</strong> 딕셔너리 구현의 내부를 다루는 서드 파티 모듈은 작동하지 않을 수 있습니다.</li>
<li><strong><code>repr()</code> 출력 및 반복 순서 변경:</strong> 대부분의 경우 변경되지 않으나, 일부 분리형 테이블 딕셔너리의 경우 반복 순서가 변경될 수 있습니다.</li>
</ul>
<p>이러한 단점들은 심각한 문제가 되지 않을 것으로 예상됩니다. 딕셔너리 내부를 다루는 모듈은 이미 문제가 있으며 API를 사용하도록 수정되어야 합니다. 딕셔너리의 반복 순서는 정의된 적이 없으며 항상 임의적이었고, Jython 및 PyPy에서도 다르게 동작합니다.</p>
<h2>대안 구현 (Alternative Implementation)</h2>
<p>분리형 테이블을 위한 대안 구현으로, 키 테이블의 값 필드에 인덱스를 저장하여(값 필드를 무시하는 대신) 더 많은 메모리를 절약할 수 있습니다. 이 인덱스는 값 배열에서 찾아야 할 위치를 명시적으로 나타내어, 값 배열의 크기를 약 3분의 1로 줄일 수 있습니다. 그러나 추가적인 간접 참조(indirection)는 코드의 복잡성을 증가시키고, 잠재적으로 성능을 약간 저하시킬 수 있습니다. 이 "인덱스된(indexed)" 버전은 현재 구현에 포함되지 않지만, 추가 실험을 위해 보류된 것으로 간주됩니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/412\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/412/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/412\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"412\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/412\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T4269,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0412/\"\u003ePEP 412 - Key-Sharing Dictionary\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 08-Feb-2012\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 412 – 키 공유 딕셔너리 (Key-Sharing Dictionary)\u003c/h1\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 파이썬 내장 딕셔너리 타입인 \u003ccode\u003edict\u003c/code\u003e의 구현 변경을 제안합니다. 새로운 구현은 객체의 속성 딕셔너리(예: 객체의 \u003ccode\u003e__dict__\u003c/code\u003e 속성)로 사용되는 딕셔너리들이 동일한 클래스의 다른 인스턴스들의 속성 딕셔너리와 키를 공유할 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003e도입 배경 (Motivation)\u003c/h2\u003e\n\u003cp\u003e기존 딕셔너리 구현은 객체 속성을 위한 컨테이너로 사용될 때 필요 이상으로 많은 메모리를 사용했습니다. 이는 키가 동일한 클래스의 여러 인스턴스 간에 공유되지 않고, 각 인스턴스마다 복제되었기 때문입니다. 하지만 일반적인 매핑 객체로서는 매우 잘 튜닝되어 뛰어난 성능을 보였습니다.\u003c/p\u003e\n\u003cp\u003e이 제안은 키(및 해시)를 값과 분리함으로써 여러 딕셔너리 간에 키를 공유하고 메모리 사용량을 개선할 수 있게 합니다. 키가 값과 분리되는 시점을 이점이 있는 경우로 제한하여, 일반적인 매핑 객체로 사용될 때 현재 딕셔너리 구현의 높은 성능을 유지할 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003e동작 방식 (Behaviour)\u003c/h2\u003e\n\u003cp\u003e새로운 딕셔너리는 기존 구현과 동일하게 동작합니다. 이는 Python API, C API, 그리고 ABI(Application Binary Interface)를 완벽하게 준수합니다.\u003c/p\u003e\n\u003ch2\u003e성능 (Performance)\u003c/h2\u003e\n\u003ch3\u003e메모리 사용량 (Memory Usage)\u003c/h3\u003e\n\u003cp\u003e메모리 사용량 감소는 특정 시점에 존재하는 키를 공유하는 딕셔너리의 수와 직접적으로 관련이 있습니다. 이러한 딕셔너리들은 일반적으로 기존 딕셔너리 구현 크기의 절반 정도입니다. 벤치마킹 결과, 객체 지향 프로그램의 경우 메모리 사용량이 10%에서 20% 감소했으며, 다른 프로그램에서는 메모리 사용량에 큰 변화가 없었습니다.\u003c/p\u003e\n\u003ch3\u003e속도 (Speed)\u003c/h3\u003e\n\u003cp\u003e새로운 구현의 성능은 메모리 지역성(memory locality) 효과에 의해 크게 좌우됩니다. 키가 공유되지 않는 경우(예: 모듈 딕셔너리 또는 \u003ccode\u003edict()\u003c/code\u003e나 \u003ccode\u003e{}\u003c/code\u003e로 명시적으로 생성된 딕셔너리)에는 기존 구현과 비교하여 성능 변화가 거의 없습니다(1~2% 이내).\u003c/p\u003e\n\u003cp\u003e키가 공유되는 경우에는 새로운 구현이 키를 값과 분리하는 경향이 있지만, 전체 메모리 사용량을 줄입니다. 이는 감소된 메모리 사용량의 효과가 지역성 손실을 상회하여 많은 경우에 성능을 향상시키지만, 일부 프로그램에서는 약간의 속도 저하를 보일 수도 있습니다. 벤치마킹 결과, 대부분의 벤치마크에서는 속도 변화가 크지 않았습니다. 객체 지향 벤치마크에서는 동일한 클래스의 많은 객체를 생성할 때 작은 속도 향상을 보였습니다(gcbench 벤치마크에서 10% 속도 향상; 이는 상한선일 가능성이 높습니다).\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e기존 딕셔너리와 새로운 딕셔너리 모두 고정 크기의 \u003ccode\u003edict\u003c/code\u003e 구조체와 크기 조절이 가능한 테이블로 구성됩니다. 새로운 딕셔너리에서는 테이블이 키 테이블(keys table)과 값 배열(values array)로 더 분리될 수 있습니다. 키 테이블은 키와 해시를 저장하며 (분리되지 않은 테이블의 경우) 값도 함께 저장합니다. 이는 이전에 \u003ccode\u003edict\u003c/code\u003e 구조체에 있던 여러 필드를 포함한다는 점만 기존 구현과 다릅니다. 테이블이 분리되면 키 테이블의 값은 무시되고, 대신 값들은 별도의 배열에 저장됩니다.\u003c/p\u003e\n\u003ch3\u003e분리형 테이블 딕셔너리 (Split-Table dictionaries)\u003c/h3\u003e\n\u003cp\u003e객체의 \u003ccode\u003e__dict__\u003c/code\u003e 슬롯을 채우기 위해 딕셔너리가 생성될 때, 이들은 분리형으로 생성됩니다. 키 테이블은 타입(type)에 캐시(cache)되어, 잠재적으로 한 클래스의 모든 인스턴스 속성 딕셔너리가 키를 공유할 수 있게 합니다. 이 딕셔너리들의 키가 달라지기 시작하는 경우, 개별 딕셔너리는 지연(lazily) 방식으로 결합형 테이블(combined-table) 형태로 변환됩니다. 이는 일반적인 경우에 좋은 메모리 사용량을 보장하고, 모든 경우에 올바른 동작을 보장합니다.\u003c/p\u003e\n\u003cp\u003e분리형 딕셔너리의 크기를 재조정(resizing)할 때, 이는 결합형 테이블로 변환됩니다. 인스턴스 속성을 저장한 결과로 크기를 재조정해야 하고, 클래스의 인스턴스가 하나만 있는 경우, 딕셔너리는 즉시 다시 분리됩니다. 대부분의 객체 지향 코드는 \u003ccode\u003e__init__\u003c/code\u003e 메서드에서 속성을 설정하므로, 두 번째 인스턴스가 생성되기 전에 모든 속성이 설정되고 이후의 모든 인스턴스 딕셔너리는 올바른 크기를 가질 것이므로 더 이상 크기 재조정이 필요하지 않습니다. 더 복잡한 사용 패턴의 경우, 어떤 접근 방식이 최선인지 알 수 없으므로, 구현은 크기 재조정 시점까지 추가 삽입을 허용하고 이후에는 결합형 테이블(키 비공유)로 되돌아갑니다.\u003c/p\u003e\n\u003cp\u003e분리형 딕셔너리에서 삭제는 키 테이블을 변경하지 않고, 단순히 값 배열에서 값을 제거합니다.\u003c/p\u003e\n\u003ch3\u003e결합형 테이블 딕셔너리 (Combined-Table dictionaries)\u003c/h3\u003e\n\u003cp\u003e명시적 딕셔너리(\u003ccode\u003edict()\u003c/code\u003e 또는 \u003ccode\u003e{}\u003c/code\u003e), 모듈 딕셔너리 및 대부분의 다른 딕셔너리는 결합형 테이블 딕셔너리로 생성됩니다. 결합형 테이블 딕셔너리는 절대로 분리형 테이블 딕셔너리가 되지 않습니다. 결합형 테이블은 기존 딕셔너리의 테이블과 거의 동일한 방식으로 구성되어, 매우 유사한 성능을 보입니다.\u003c/p\u003e\n\u003ch2\u003e구현의 장단점 (Pros and Cons)\u003c/h2\u003e\n\u003ch3\u003e장점 (Pros)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e객체 지향 애플리케이션의 경우 상당한 메모리 절약 효과가 있습니다.\u003c/li\u003e\n\u003cli\u003e유사한 객체를 많이 생성하는 프로그램의 경우 속도가 약간 향상됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e단점 (Cons)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e데이터 구조 변경:\u003c/strong\u003e 딕셔너리 구현의 내부를 다루는 서드 파티 모듈은 작동하지 않을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003erepr()\u003c/code\u003e 출력 및 반복 순서 변경:\u003c/strong\u003e 대부분의 경우 변경되지 않습니다. 그러나 일부 분리형 테이블 딕셔너리의 경우 반복 순서가 변경될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 단점들은 문제가 되지 않을 것으로 예상됩니다. 딕셔너리 구현의 내부를 다루는 모듈은 이미 문제가 있으며 API를 사용하도록 수정되어야 합니다. 딕셔너리의 반복 순서는 정의된 적이 없으며 항상 임의적이었고, Jython 및 PyPy에서도 다르게 동작합니다.\u003c/p\u003e\n\u003ch2\u003e대안 구현 (Alternative Implementation)\u003c/h2\u003e\n\u003cp\u003e분리형 테이블을 위한 대안 구현으로, 키 테이블의 값 필드에 인덱스를 저장하여(값 필드를 무시하는 대신) 더 많은 메모리를 절약할 수 있습니다. 이 인덱스는 값 배열에서 찾아야 할 위치를 명시적으로 나타냅니다. 이렇게 하면 값 배열은 키 테이블의 각 슬롯이 아닌, 사용 가능한 각 슬롯에 대해 하나의 필드만 필요하게 됩니다.\u003c/p\u003e\n\u003cp\u003e이 \"인덱스된(indexed)\" 버전은 값 배열의 크기를 약 3분의 1로 줄일 수 있습니다. 키 테이블에는 추가 \"values_size\" 필드가 필요하며, 이는 결합된 딕셔너리의 크기를 한 워드(word)만큼 증가시킵니다. 추가적인 간접 참조(indirection)는 코드의 복잡성을 증가시키고, 잠재적으로 성능을 약간 저하시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 \"인덱스된\" 버전은 현재 구현에 포함되지 않지만, 추가 실험을 기다리는 동안 보류된 것으로 간주되어야 하며, 거부된 것은 아닙니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eI have translated the entire PEP document according to the guidelines. I have used Markdown for structure, maintained professionalism, handled terminology as requested, and provided citations for every sentence derived from the browsed content.\nThe user's request is to provide a translation and summary. I have translated the content and structured it in a way that summarises the key points within each section.\nThe content covers the abstract, motivation, behaviour, performance, implementation details (split-table and combined-table), pros and cons, and an alternative implementation.\nThis should fulfill the user's request.\nI am done.\nThe response is the translated PEP.\nFinal check on the guidelines:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eProfessionalism: Yes, tried to use appropriate technical terms.\u003c/li\u003e\n\u003cli\u003eTerminology: Used Korean terms when common, otherwise kept English or 병기 (e.g., \u003ccode\u003eList Comprehension\u003c/code\u003e, \u003ccode\u003eGenerator (제너레이터)\u003c/code\u003e - though not many explicit examples in this specific PEP). Keywords like \u003ccode\u003e__dict__\u003c/code\u003e, \u003ccode\u003edict\u003c/code\u003e, \u003ccode\u003easync\u003c/code\u003e, \u003ccode\u003eawait\u003c/code\u003e are not translated.\u003c/li\u003e\n\u003cli\u003eReadability: Markdown headings and lists are used.\u003c/li\u003e\n\u003cli\u003eAccuracy: Translated content fully, as markdown.\u003c/li\u003e\n\u003cli\u003eCitations: Every sentence referring to the browse result has ``.\u003c/li\u003e\n\u003cli\u003eBrevity for URL summary: This is for \"ONE URL\" summary, and the prompt says \"If you are summarizing anything else or MORE THAN ONE URL, ignore this limitation\". I'm translating the whole document, not just a summary of one URL. So, the brevity limit doesn't apply here.# PEP 412 – 키 공유 딕셔너리 (Key-Sharing Dictionary)\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 파이썬 내장 딕셔너리 타입인 \u003ccode\u003edict\u003c/code\u003e의 구현 변경을 제안합니다. 새로운 구현은 객체의 속성 딕셔너리(예: 객체의 \u003ccode\u003e__dict__\u003c/code\u003e 속성)로 사용되는 딕셔너리들이 동일한 클래스의 다른 인스턴스들의 속성 딕셔너리와 키를 공유할 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003e도입 배경 (Motivation)\u003c/h2\u003e\n\u003cp\u003e기존 딕셔너리 구현은 객체 속성을 위한 컨테이너로 사용될 때, 동일한 클래스의 여러 인스턴스 간에 키가 복제되어 필요 이상으로 많은 메모리를 사용했습니다. 하지만 일반적인 매핑 객체로서는 매우 잘 튜닝되어 뛰어난 성능을 보였습니다.\u003c/p\u003e\n\u003cp\u003e이 제안은 키(및 해시)를 값과 분리함으로써 여러 딕셔너리 간에 키를 공유하여 메모리 사용량을 개선하는 것을 목표로 합니다. 또한, 키가 값과 분리되는 시점을 이점이 있는 경우로 제한하여, 일반적인 매핑 객체로 사용될 때 기존 딕셔너리 구현의 높은 성능을 유지하도록 합니다.\u003c/p\u003e\n\u003ch2\u003e동작 방식 (Behaviour)\u003c/h2\u003e\n\u003cp\u003e새로운 딕셔너리는 기존 구현과 동일하게 동작하며, Python API, C API, 그리고 ABI(Application Binary Interface)를 완벽하게 준수합니다.\u003c/p\u003e\n\u003ch2\u003e성능 (Performance)\u003c/h2\u003e\n\u003ch3\u003e메모리 사용량 (Memory Usage)\u003c/h3\u003e\n\u003cp\u003e메모리 사용량 감소는 키를 공유하는 딕셔너리의 수에 비례합니다. 이러한 딕셔너리들은 일반적으로 기존 딕셔너리 구현 크기의 절반 정도입니다. 벤치마킹 결과, 객체 지향 프로그램의 경우 메모리 사용량이 10%에서 20% 감소했으며, 다른 프로그램에서는 큰 변화가 없었습니다.\u003c/p\u003e\n\u003ch3\u003e속도 (Speed)\u003c/h3\u003e\n\u003cp\u003e새로운 구현의 성능은 메모리 지역성(memory locality) 효과에 의해 크게 좌우됩니다. 키가 공유되지 않는 경우(예: 모듈 딕셔너리, \u003ccode\u003edict()\u003c/code\u003e 또는 \u003ccode\u003e{}\u003c/code\u003e로 생성된 딕셔너리)에는 기존 구현과 비교하여 성능 변화가 거의 없습니다(1~2% 이내).\u003c/p\u003e\n\u003cp\u003e키가 공유되는 경우에는 키와 값을 분리하지만 전체 메모리 사용량을 줄입니다. 이는 감소된 메모리 사용량의 효과가 지역성 손실을 상회하여 많은 경우에 성능을 향상시키지만, 일부 프로그램에서는 약간의 속도 저하를 보일 수도 있습니다. 벤치마킹 결과, 대부분의 벤치마크에서는 속도 변화가 크지 않았습니다. 동일한 클래스의 많은 객체를 생성하는 객체 지향 벤치마크에서는 작은 속도 향상을 보였습니다(gcbench 벤치마크에서 10% 속도 향상; 이는 상한선일 가능성이 높습니다).\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e기존 딕셔너리와 새로운 딕셔너리 모두 고정 크기의 \u003ccode\u003edict\u003c/code\u003e 구조체와 크기 조절이 가능한 테이블로 구성됩니다. 새로운 딕셔너리에서는 이 테이블이 키 테이블(keys table)과 값 배열(values array)로 더 분리될 수 있습니다. 키 테이블은 키와 해시를 저장하며 (분리되지 않은 테이블의 경우) 값도 함께 저장합니다. 테이블이 분리되면 키 테이블의 값은 무시되고, 대신 값들은 별도의 배열에 저장됩니다.\u003c/p\u003e\n\u003ch3\u003e분리형 테이블 딕셔너리 (Split-Table dictionaries)\u003c/h3\u003e\n\u003cp\u003e객체의 \u003ccode\u003e__dict__\u003c/code\u003e 슬롯을 채우기 위해 딕셔너리가 생성될 때, 이들은 분리형으로 생성됩니다. 키 테이블은 타입(type)에 캐시(cache)되어, 한 클래스의 모든 인스턴스 속성 딕셔너리가 키를 공유할 수 있게 합니다. 키가 달라지기 시작하는 경우, 개별 딕셔너리는 지연(lazily) 방식으로 결합형 테이블(combined-table) 형태로 변환됩니다. 이는 일반적인 경우에 좋은 메모리 사용량을 보장하며 모든 경우에 올바른 동작을 보장합니다.\u003c/p\u003e\n\u003cp\u003e분리형 딕셔너리의 크기를 재조정(resizing)할 때 결합형 테이블로 변환됩니다. 대부분의 객체 지향 코드는 \u003ccode\u003e__init__\u003c/code\u003e 메서드에서 속성을 설정하므로, 두 번째 인스턴스가 생성되기 전에 모든 속성이 설정되고 이후의 모든 인스턴스 딕셔너리는 올바른 크기를 가지게 됩니다. 분리형 딕셔너리에서 삭제는 키 테이블을 변경하지 않고 값 배열에서만 값을 제거합니다.\u003c/p\u003e\n\u003ch3\u003e결합형 테이블 딕셔너리 (Combined-Table dictionaries)\u003c/h3\u003e\n\u003cp\u003e명시적 딕셔너리(\u003ccode\u003edict()\u003c/code\u003e 또는 \u003ccode\u003e{}\u003c/code\u003e), 모듈 딕셔너리 및 대부분의 다른 딕셔너리는 결합형 테이블 딕셔너리로 생성됩니다. 결합형 테이블 딕셔너리는 분리형 테이블 딕셔너리로 변환되지 않으며, 기존 딕셔너리의 테이블과 유사하게 구성되어 매우 비슷한 성능을 보입니다.\u003c/p\u003e\n\u003ch2\u003e구현의 장단점 (Pros and Cons)\u003c/h2\u003e\n\u003ch3\u003e장점 (Pros)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e객체 지향 애플리케이션의 경우 상당한 메모리 절약 효과가 있습니다.\u003c/li\u003e\n\u003cli\u003e유사한 객체를 많이 생성하는 프로그램의 경우 속도가 약간 향상됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e단점 (Cons)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e데이터 구조 변경:\u003c/strong\u003e 딕셔너리 구현의 내부를 다루는 서드 파티 모듈은 작동하지 않을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003erepr()\u003c/code\u003e 출력 및 반복 순서 변경:\u003c/strong\u003e 대부분의 경우 변경되지 않으나, 일부 분리형 테이블 딕셔너리의 경우 반복 순서가 변경될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 단점들은 심각한 문제가 되지 않을 것으로 예상됩니다. 딕셔너리 내부를 다루는 모듈은 이미 문제가 있으며 API를 사용하도록 수정되어야 합니다. 딕셔너리의 반복 순서는 정의된 적이 없으며 항상 임의적이었고, Jython 및 PyPy에서도 다르게 동작합니다.\u003c/p\u003e\n\u003ch2\u003e대안 구현 (Alternative Implementation)\u003c/h2\u003e\n\u003cp\u003e분리형 테이블을 위한 대안 구현으로, 키 테이블의 값 필드에 인덱스를 저장하여(값 필드를 무시하는 대신) 더 많은 메모리를 절약할 수 있습니다. 이 인덱스는 값 배열에서 찾아야 할 위치를 명시적으로 나타내어, 값 배열의 크기를 약 3분의 1로 줄일 수 있습니다. 그러나 추가적인 간접 참조(indirection)는 코드의 복잡성을 증가시키고, 잠재적으로 성능을 약간 저하시킬 수 있습니다. 이 \"인덱스된(indexed)\" 버전은 현재 구현에 포함되지 않지만, 추가 실험을 위해 보류된 것으로 간주됩니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 412 - Key-Sharing Dictionary\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 21:32:26+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>