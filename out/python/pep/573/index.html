<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 573 - Module State Access from C Extension Methods</h1><div class="page__meta"><time dateTime="2025-09-26 23:59:37+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0573/">PEP 573 - Module State Access from C Extension Methods</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 02-Jun-2016</p>
</blockquote>
<h2>PEP 573 – C 확장 메서드에서 모듈 상태 접근</h2>
<h3>개요 (Abstract)</h3>
<p>이 PEP(Python Enhancement Proposal) 573은 CPython 확장 메서드(C Extension Methods)가 자신이 정의된 모듈의 상태와 같은 컨텍스트에 접근할 수 있는 방법을 추가할 것을 제안합니다. 이를 통해 확장 메서드는 <code>PyState_FindModule</code> 함수를 사용하지 않고 직접 포인터 역참조를 통해 모듈 상태를 조회할 수 있게 됩니다. 이는 프로세스 전역 상태(process global state) 대신 모듈 범위 상태(module-scoped state)를 사용할 때 발생하는 성능 저하를 줄이거나 없애는 효과를 가져옵니다.</p>
<p>이 제안은 PEP 3121 (확장 모듈 초기화 및 종료) 및 PEP 489 (다단계 확장 모듈 초기화) 채택에 남아있던 주요 장애물 중 하나를 해결합니다. PEP 3121과 PEP 489가 다루기 시작한 문제들을 완전히 해결하기 위한 추가적인 단계이지만, 모든 남아있는 문제를 해결하려는 것은 아닙니다. 특히, <code>nb_add</code>와 같은 슬롯 메서드(slot methods)에서 모듈 상태에 접근하는 문제는 이 PEP에서 다루지 않습니다.</p>
<h3>용어 (Terminology)</h3>
<ul>
<li><strong>프로세스 전역 상태 (Process-Global State)</strong>: C 수준의 정적 변수입니다. 매우 낮은 수준의 메모리 저장소이므로 신중하게 관리해야 합니다.</li>
<li><strong>모듈별 상태 (Per-module State)</strong>: 모듈 객체의 초기화 과정에서 동적으로 할당되는 모듈 객체에 로컬한 상태입니다. 이는 다른 모듈 인스턴스(다른 서브 인터프리터의 인스턴스 포함)로부터 상태를 격리합니다. <code>PyModule_GetState()</code>를 통해 접근합니다.</li>
<li><strong>정적 타입 (Static Type)</strong>: C 수준의 정적 변수로 정의된 타입 객체, 즉 컴파일된 타입 객체입니다. 정적 타입은 모듈 인스턴스 간에 공유되어야 하며, 자신이 속한 모듈에 대한 정보를 가지고 있지 않습니다. 정적 타입은 <code>__dict__</code>를 가지지 않습니다(인스턴스는 가질 수 있음).</li>
<li><strong>힙 타입 (Heap Type)</strong>: 런타임에 생성되는 타입 객체입니다.</li>
<li><strong>정의 클래스 (Defining Class)</strong>: 메서드(바운드 또는 언바운드)의 정의 클래스는 메서드가 정의된 클래스입니다. 단순히 기본 클래스에서 메서드를 상속받은 클래스는 정의 클래스가 아닙니다. 예를 들어, <code>int</code>는 <code>True.to_bytes</code>, <code>True.__floor__</code>, <code>int.__repr__</code>의 정의 클래스입니다. C에서는 해당 <code>tp_methods</code> 또는 "tp slots" 항목으로 정의된 클래스입니다. Python에서 정의된 메서드의 경우, 정의 클래스는 <code>__class__</code> 클로저 셀에 저장됩니다.</li>
<li><strong>C-API</strong>: Python 문서에 설명된 "Python/C API"를 의미합니다. CPython이 C-API를 구현하지만, 다른 구현체도 존재합니다.</li>
</ul>
<h3>제안 배경 (Rationale)</h3>
<p>PEP 489는 확장 모듈을 초기화하는 새로운 방법을 도입하여, 이를 구현하는 확장 모듈에 여러 이점을 제공했습니다.</p>
<ul>
<li>확장 모듈이 Python 모듈과 유사하게 동작합니다.</li>
<li>확장 모듈은 기존 모듈 객체로 쉽게 로드될 수 있어, <code>runpy</code> 또는 확장 모듈 재로드를 가능하게 하는 시스템을 지원할 수 있습니다.</li>
<li>동일한 확장으로부터 여러 모듈을 로드하는 것이 가능해져, 단일 인터프리터에서 모듈 격리(적절한 서브 인터프리터 지원을 위한 핵심 기능)를 테스트할 수 있습니다.</li>
</ul>
<p>PEP 489 채택의 가장 큰 장애물은 확장 타입의 메서드에서 모듈 상태에 접근하는 것을 허용하는 것이었습니다. 현재 확장 메서드에서 이 상태에 접근하는 방법은 <code>PyState_FindModule</code>을 통해 모듈을 조회하는 것입니다(확장 모듈의 모듈 수준 함수와 달리, 이들은 모듈 참조를 인수로 받음). 그러나 <code>PyState_FindModule</code>은 스레드 로컬 상태를 쿼리하여 C 수준의 프로세스 전역 접근에 비해 상대적으로 비용이 많이 들고, 결과적으로 모듈 작성자가 이를 사용하는 것을 꺼리게 만듭니다.</p>
<p>또한, <code>PyState_FindModule</code>은 각 서브 인터프리터에서 주어진 <code>PyModuleDef</code>에 해당하는 모듈이 최대 하나라는 가정에 의존합니다. 이 가정은 PEP 489의 다단계 초기화를 사용하는 모듈에는 적용되지 않으므로, 이러한 모듈에서는 <code>PyState_FindModule</code>을 사용할 수 없습니다. 확장 메서드에서 모듈 수준 상태에 접근하기 위한 더 빠르고 안전한 방법이 필요합니다.</p>
<h4>배경 (Background)</h4>
<p>Python 메서드의 구현은 다음 정보 중 하나 이상에 접근해야 할 수 있습니다.</p>
<ul>
<li>호출되는 인스턴스(<code>self</code>)</li>
<li>기본 함수</li>
<li>정의 클래스(메서드가 정의된 클래스)</li>
<li>해당 모듈</li>
<li>모듈 상태</li>
</ul>
<p>Python 코드에서는 다음과 같이 Python 수준의 동등한 값을 검색할 수 있습니다.</p>
<pre><code class="language-python">import sys
class Foo:
    def meth(self):
        instance = self
        module_globals = globals()
        module_object = sys.modules[__name__] # (1)
        underlying_function = Foo.meth # (1)
        defining_class = Foo # (1)
        defining_class = __class__ # (2)
</code></pre>
<p>참고: 정의 클래스는 <code>type(self)</code>가 아닙니다. <code>type(self)</code>는 <code>Foo</code>의 서브클래스일 수 있기 때문입니다.</p>
<p>(1)로 표시된 문장은 함수의 <code>__globals__</code>를 통한 이름 기반 조회에 암묵적으로 의존합니다. Python 코드에서 이는 함수 정의가 실행될 때 <code>__globals__</code>가 적절하게 설정되고, 네임스페이스가 조작되어 다른 객체를 반환하더라도 최악의 경우 예외가 발생하므로 가능합니다. <code>__class__</code> 클로저(2)는 정의 클래스를 얻는 더 안전한 방법이지만, 여전히 <code>__closure__</code>가 적절하게 설정되어야 합니다.</p>
<p>반대로, 확장 메서드는 일반적으로 일반 C 함수로 구현됩니다. 이는 메서드가 인자와 C 수준의 스레드 로컬 및 프로세스 전역 상태에만 접근할 수 있음을 의미합니다. 전통적으로 많은 확장 모듈은 공유 상태를 C 수준의 프로세스 전역 변수에 저장하여 다음과 같은 경우에 문제를 일으켰습니다.</p>
<ul>
<li>동일한 프로세스에서 여러 초기화/종료 주기 실행</li>
<li>모듈 재로드(예: 조건부 임포트 테스트)</li>
<li>서브 인터프리터에서 확장 모듈 로드</li>
</ul>
<p>PEP 3121은 <code>PyState_FindModule</code> API를 제공하여 이를 해결하려고 시도했지만, 확장 메서드(모듈 수준 함수와 달리)의 경우 여전히 심각한 문제가 있었습니다.</p>
<ul>
<li>C 수준의 프로세스 전역 상태에 직접 접근하는 것보다 현저히 느립니다.</li>
<li>모듈 재로드를 안정적으로 처리하지 못하는 프로세스 전역 상태에 대한 본질적인 의존성이 여전히 존재합니다.</li>
</ul>
<p>또한, 모듈 상태와 같은 C 수준의 구조체를 조회할 때 예상치 못한 객체 레이아웃을 제공하면 인터프리터가 충돌할 수 있으므로, 확장 메서드가 예상하는 종류의 객체를 받도록 보장하는 것이 훨씬 더 중요합니다.</p>
<h4>제안 (Proposal)</h4>
<p>현재 바운드 확장 메서드(<code>PyCFunction</code> 또는 <code>PyCFunctionWithKeywords</code>)는 <code>self</code>와 (해당하는 경우) 제공된 위치 및 키워드 인자만 받습니다. 모듈 수준 확장 함수는 <code>self</code> 인자를 통해 정의 모듈 객체에 접근할 수 있지만, 확장 타입의 메서드는 그렇지 않습니다. 메서드는 <code>self</code>를 통해 바운드 인스턴스를 받으므로, 정의 클래스나 모듈 수준 상태에 직접 접근할 수 없습니다.</p>
<p>위에 설명된 추가적인 모듈 수준 컨텍스트는 두 가지 변경 사항으로 제공될 수 있습니다. 두 가지 추가 사항 모두 선택 사항입니다. 확장 작성자는 이를 사용하기 위해 옵트인(opt-in)해야 합니다.</p>
<ol>
<li>힙 타입 객체에 모듈에 대한 포인터를 추가합니다.</li>
<li>기본 C 함수에 정의 클래스를 전달합니다.</li>
</ol>
<p>CPython에서 정의 클래스는 내장 메서드 객체(<code>PyCFunctionObject</code>)가 생성될 때 쉽게 사용할 수 있으므로, <code>PyCFunctionObject</code>를 확장하는 새로운 구조체에 저장할 수 있습니다. 모듈 상태는 <code>PyModule_GetState</code>를 통해 모듈 객체에서 검색할 수 있습니다.</p>
<p>이 제안은 모듈별 상태에 접근해야 하는 메서드를 가진 모든 타입이 정적 타입이 아닌 힙 타입이어야 함을 의미합니다. 이는 단일 확장으로부터 여러 모듈 객체를 로드하는 것을 지원하는 데 필요합니다. C 수준 전역 변수인 정적 타입은 자신이 속한 모듈 객체에 대한 정보를 가지고 있지 않습니다.</p>
<h4>슬롯 메서드 (Slot methods)</h4>
<p>위의 변경 사항은 <code>tp_iter</code> 또는 <code>nb_add</code>와 같은 슬롯 메서드에는 적용되지 않습니다. 슬롯 메서드의 문제는 C-API가 고정되어 있어 정의 클래스를 전달하기 위해 단순히 새로운 인자를 추가할 수 없다는 것입니다. 이 문제에 대해 두 가지 가능한 해결책이 제안되었습니다.</p>
<ol>
<li>MRO를 탐색하여 클래스를 조회합니다. 이는 잠재적으로 비용이 많이 들지만, 성능이 문제가 되지 않는 경우(예: 모듈 수준 예외 발생 시) 사용할 수 있습니다.</li>
<li>각 슬롯의 정의 클래스에 대한 포인터를 별도의 테이블인 <code>__typeslots__</code>에 저장합니다. 이는 기술적으로 가능하고 빠르지만, 상당히 침범적입니다.</li>
</ol>
<p>이 문제에 영향을 받는 모듈은 스레드 로컬 상태 또는 PEP 567 컨텍스트 변수를 캐싱 메커니즘으로 사용하거나, 자체적인 재로드 친화적인 조회 캐싱 스키마를 정의할 수도 있습니다. 이 문제를 일반적​​으로 해결하는 것은 향후 PEP로 미뤄집니다.</p>
<h3>명세 (Specification)</h3>
<h4>힙 타입에 모듈 참조 추가 (Adding module references to heap types)</h4>
<p>모듈을 생성하기 위한 새로운 팩토리 메서드가 C-API에 추가될 것입니다.</p>
<pre><code class="language-c">PyObject* PyType_FromModuleAndSpec(PyObject *module, PyType_Spec *spec, PyObject *bases)
</code></pre>
<p>이 함수는 <code>PyType_FromSpecWithBases</code>와 동일하게 작동하며, 추가적으로 제공된 모듈 객체를 새 타입과 연결합니다. (CPython에서는 아래에 설명된 <code>ht_module</code>을 설정합니다.)</p>
<p>또한, 접근자 <code>PyObject * PyType_GetModule(PyTypeObject *)</code>가 제공될 것입니다. 이 함수는 타입에 연결된 모듈이 설정되어 있으면 해당 모듈을 반환하고, 그렇지 않으면 <code>TypeError</code>를 설정하고 <code>NULL</code>을 반환합니다. 정적 타입이 주어지면 항상 <code>TypeError</code>를 설정하고 <code>NULL</code>을 반환합니다.</p>
<p>CPython에서 이를 구현하기 위해 <code>PyHeapTypeObject</code> 구조체에 <code>PyObject *ht_module</code>이라는 새 멤버가 추가되어 연결된 모듈에 대한 포인터를 저장합니다. 기본적으로 <code>NULL</code>이며, 타입 객체가 생성된 후에는 수정되어서는 안 됩니다. <code>ht_module</code> 멤버는 서브클래스에 의해 상속되지 않습니다. 필요한 각 개별 타입에 대해 <code>PyType_FromSpecWithBases</code>를 사용하여 설정해야 합니다.</p>
<p>일반적으로 <code>ht_module</code>이 설정된 클래스를 생성하면 클래스와 모듈을 포함하는 순환 참조(reference cycle)가 생성됩니다. 모듈을 해체하는 작업은 성능에 민감한 작업이 아니며, 모듈 수준 함수도 일반적으로 순환 참조를 생성하므로 이는 문제가 되지 않습니다. 함수의 <code>f_globals</code>를 통해 함수 순환을 끊는 기존의 "모든 모듈 전역 변수를 <code>None</code>으로 설정"하는 코드는 <code>ht_module</code>을 통한 새로운 순환도 끊을 것입니다.</p>
<h4>확장 메서드에 정의 클래스 전달 (Passing the defining class to extension methods)</h4>
<p><code>PyMethodDef.ml_flags</code>에 사용될 새로운 시그니처 플래그 <code>METH_METHOD</code>가 추가될 것입니다. 개념적으로 이는 함수 시그니처에 <code>defining_class</code>를 추가합니다. 초기 구현을 쉽게 하기 위해 이 플래그는 <code>(METH_FASTCALL | METH_KEYWORDS | METH_METHOD)</code>로만 사용할 수 있습니다. (<code>METH_O</code> 또는 단순 <code>METH_FASTCALL</code>과 같은 다른 플래그와는 함께 사용할 수 없지만, <code>METH_CLASS</code> 또는 <code>METH_STATIC</code>과 결합될 수 있습니다.)</p>
<p>이 플래그 조합을 사용하여 정의된 메서드에 대한 C 함수는 <code>PyCMethod</code>라는 새로운 C 시그니처를 사용하여 호출될 것입니다.</p>
<pre><code class="language-c">PyObject *PyCMethod(PyObject *self, PyTypeObject *defining_class, PyObject *const *args, size_t nargsf, PyObject *kwnames)
</code></pre>
<p><code>METH_VARARGS | METH_METHOD</code>와 같은 추가 조합은 나중에(또는 이 PEP의 초기 구현에서도) 추가될 수 있습니다. 그러나 <code>METH_METHOD</code>는 항상 추가 플래그여야 합니다. 즉, 정의 클래스는 필요할 때만 전달되어야 합니다.</p>
<p>CPython에서는 추가 정보를 저장하기 위해 <code>PyCFunctionObject</code>를 확장하는 새로운 구조체가 추가될 것입니다.</p>
<pre><code class="language-c">typedef struct {
    PyCFunctionObject func;
    PyTypeObject *mm_class; /* C 함수에 'defining_class' 인자로 전달됨 */
} PyCMethodObject;
</code></pre>
<p><code>PyCFunction</code> 구현은 <code>METH_METHOD</code> 플래그가 설정된 것을 발견하면 <code>mm_class</code>를 <code>PyCMethod</code> C 함수로 전달할 것입니다. <code>mm_class</code>에 더 쉽게 접근할 수 있도록 새로운 매크로 <code>PyCFunction_GET_CLASS(cls)</code>가 추가될 것입니다.</p>
<p>C 메서드는 정의 클래스/모듈에 대한 접근이 필요하지 않은 경우 다른 <code>METH_*</code> 시그니처를 계속 사용할 수 있습니다. <code>METH_METHOD</code>가 설정되지 않은 경우 <code>PyCMethodObject</code>로 캐스팅하는 것은 유효하지 않습니다.</p>
<h4>Argument Clinic</h4>
<p><code>Argument Clinic</code>을 사용하여 메서드에 정의 클래스를 전달하는 것을 지원하기 위해, <code>defining_class</code>라는 새로운 컨버터가 CPython의 <code>Argument Clinic</code> 도구에 추가될 것입니다. 각 메서드는 이 컨버터를 사용하는 인자를 하나만 가질 수 있으며, <code>self</code> 뒤에 오거나, <code>self</code>가 사용되지 않는 경우 첫 번째 인자로 와야 합니다. 이 인자는 <code>PyTypeObject *</code> 타입이 될 것입니다.</p>
<p>사용될 때, <code>Argument Clinic</code>은 <code>METH_FASTCALL | METH_KEYWORDS | METH_METHOD</code>를 호출 규칙으로 선택할 것입니다. 이 인자는 <code>__text_signature__</code>에 나타나지 않을 것입니다. 새로운 컨버터는 <code>METH_METHOD</code> 규칙을 사용할 수 없는 <code>__init__</code> 및 <code>__new__</code> 메서드와는 초기에는 호환되지 않을 것입니다.</p>
<h4>헬퍼 (Helpers)</h4>
<p>힙 타입에서 모듈별 상태에 접근하는 것은 매우 일반적인 작업입니다. 이를 더 쉽게 하기 위해 헬퍼 함수가 추가될 것입니다.</p>
<pre><code class="language-c">void *PyType_GetModuleState(PyObject *type)
</code></pre>
<p>이 함수는 힙 타입을 인자로 받고, 성공하면 힙 타입이 속한 모듈의 상태에 대한 포인터를 반환합니다. 실패 시 두 가지 시나리오가 발생할 수 있습니다. 비-타입 객체나 모듈이 없는 타입이 전달되면 <code>TypeError</code>가 설정되고 <code>NULL</code>이 반환됩니다. 모듈이 발견되면, <code>NULL</code>일 수도 있는 상태에 대한 포인터가 예외 설정 없이 반환됩니다.</p>
<h4>초기 구현에서 변환될 모듈 (Modules Converted in the Initial Implementation)</h4>
<p>접근 방식을 검증하기 위해 초기 구현 과정에서 <code>_elementtree</code> 모듈이 수정될 것입니다.</p>
<h3>API 변경 및 추가 요약 (Summary of API Changes and Additions)</h3>
<p>Python C-API에 다음이 추가될 것입니다.</p>
<ul>
<li><code>PyType_FromModuleAndSpec</code> 함수</li>
<li><code>PyType_GetModule</code> 함수</li>
<li><code>PyType_GetModuleState</code> 함수</li>
<li><code>METH_METHOD</code> 호출 플래그</li>
<li><code>PyCMethod</code> 함수 시그니처</li>
</ul>
<p>다음 추가 사항은 CPython 구현 세부 사항으로 추가되며 문서화되지 않을 것입니다.</p>
<ul>
<li><code>PyCFunction_GET_CLASS</code> 매크로</li>
<li><code>PyCMethodObject</code> 구조체</li>
<li><code>_heaptypeobject</code>의 <code>ht_module</code> 멤버</li>
<li><code>Argument Clinic</code>의 <code>defining_class</code> 컨버터</li>
</ul>
<h3>하위 호환성 (Backwards Compatibility)</h3>
<p>모든 힙 타입에 새로운 포인터 하나가 추가됩니다. 다른 모든 변경 사항은 새로운 함수와 구조체를 추가하거나 개인 구현 세부 사항을 변경하는 것입니다.</p>
<h3>구현 (Implementation)</h3>
<p>초기 구현은 GitHub 리포지토리에서 확인할 수 있으며, 패치셋은에 있습니다.</p>
<h3>가능한 향후 확장 (Possible Future Extensions)</h3>
<h4>슬롯 메서드 (Slot methods)</h4>
<p>슬롯 메서드에 정의 클래스(또는 모듈 상태)를 전달하는 방법이 미래에 추가될 수 있습니다. 이 PEP의 이전 버전은 특정 함수에 대한 슬롯을 정의하는 클래스를 MRO에서 검색하여 정의 클래스를 결정하는 헬퍼 함수를 제안했습니다. 그러나 이 접근 방식은 클래스가 변경되는 경우(힙 타입의 경우 Python 코드에서 가능) 실패할 수 있습니다. 이 문제의 해결은 향후 논의로 남겨져 있습니다.</p>
<h4>모듈 참조를 포함하는 타입의 쉬운 생성 (Easy creation of types with module references)</h4>
<p><code>PyType_FromModuleAndSpec</code>를 호출하는 것보다 훨씬 쉽게 힙 타입을 생성할 수 있도록 PEP 489 실행 슬롯 타입을 추가하는 것이 가능할 수 있습니다. 이는 향후 PEP로 남겨져 있습니다.</p>
<p>제한된 API에서 정적 예외 타입을 생성하는 좋은 방법을 추가하는 것이 좋을 수 있습니다. 이러한 예외 타입은 서브 인터프리터 간에 공유될 수 있지만, 특정 모듈 상태 없이 인스턴스화될 수 있습니다. 이것 또한 가능한 향후 논의로 남겨져 있습니다.</p>
<h4>최적화 (Optimization)</h4>
<p>여기서 제안된 대로 <code>METH_METHOD</code> 플래그로 정의된 메서드는 하나의 특정 시그니처만 지원합니다. 성능상의 이유로 다른 시그니처가 필요한 것으로 판명되면 추가될 수 있습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/573\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/573/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/573\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"573\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/573\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T5068,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0573/\"\u003ePEP 573 - Module State Access from C Extension Methods\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 02-Jun-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 573 – C 확장 메서드에서 모듈 상태 접근\u003c/h2\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP(Python Enhancement Proposal) 573은 CPython 확장 메서드(C Extension Methods)가 자신이 정의된 모듈의 상태와 같은 컨텍스트에 접근할 수 있는 방법을 추가할 것을 제안합니다. 이를 통해 확장 메서드는 \u003ccode\u003ePyState_FindModule\u003c/code\u003e 함수를 사용하지 않고 직접 포인터 역참조를 통해 모듈 상태를 조회할 수 있게 됩니다. 이는 프로세스 전역 상태(process global state) 대신 모듈 범위 상태(module-scoped state)를 사용할 때 발생하는 성능 저하를 줄이거나 없애는 효과를 가져옵니다.\u003c/p\u003e\n\u003cp\u003e이 제안은 PEP 3121 (확장 모듈 초기화 및 종료) 및 PEP 489 (다단계 확장 모듈 초기화) 채택에 남아있던 주요 장애물 중 하나를 해결합니다. PEP 3121과 PEP 489가 다루기 시작한 문제들을 완전히 해결하기 위한 추가적인 단계이지만, 모든 남아있는 문제를 해결하려는 것은 아닙니다. 특히, \u003ccode\u003enb_add\u003c/code\u003e와 같은 슬롯 메서드(slot methods)에서 모듈 상태에 접근하는 문제는 이 PEP에서 다루지 않습니다.\u003c/p\u003e\n\u003ch3\u003e용어 (Terminology)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e프로세스 전역 상태 (Process-Global State)\u003c/strong\u003e: C 수준의 정적 변수입니다. 매우 낮은 수준의 메모리 저장소이므로 신중하게 관리해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e모듈별 상태 (Per-module State)\u003c/strong\u003e: 모듈 객체의 초기화 과정에서 동적으로 할당되는 모듈 객체에 로컬한 상태입니다. 이는 다른 모듈 인스턴스(다른 서브 인터프리터의 인스턴스 포함)로부터 상태를 격리합니다. \u003ccode\u003ePyModule_GetState()\u003c/code\u003e를 통해 접근합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e정적 타입 (Static Type)\u003c/strong\u003e: C 수준의 정적 변수로 정의된 타입 객체, 즉 컴파일된 타입 객체입니다. 정적 타입은 모듈 인스턴스 간에 공유되어야 하며, 자신이 속한 모듈에 대한 정보를 가지고 있지 않습니다. 정적 타입은 \u003ccode\u003e__dict__\u003c/code\u003e를 가지지 않습니다(인스턴스는 가질 수 있음).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e힙 타입 (Heap Type)\u003c/strong\u003e: 런타임에 생성되는 타입 객체입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e정의 클래스 (Defining Class)\u003c/strong\u003e: 메서드(바운드 또는 언바운드)의 정의 클래스는 메서드가 정의된 클래스입니다. 단순히 기본 클래스에서 메서드를 상속받은 클래스는 정의 클래스가 아닙니다. 예를 들어, \u003ccode\u003eint\u003c/code\u003e는 \u003ccode\u003eTrue.to_bytes\u003c/code\u003e, \u003ccode\u003eTrue.__floor__\u003c/code\u003e, \u003ccode\u003eint.__repr__\u003c/code\u003e의 정의 클래스입니다. C에서는 해당 \u003ccode\u003etp_methods\u003c/code\u003e 또는 \"tp slots\" 항목으로 정의된 클래스입니다. Python에서 정의된 메서드의 경우, 정의 클래스는 \u003ccode\u003e__class__\u003c/code\u003e 클로저 셀에 저장됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eC-API\u003c/strong\u003e: Python 문서에 설명된 \"Python/C API\"를 의미합니다. CPython이 C-API를 구현하지만, 다른 구현체도 존재합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e제안 배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003ePEP 489는 확장 모듈을 초기화하는 새로운 방법을 도입하여, 이를 구현하는 확장 모듈에 여러 이점을 제공했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e확장 모듈이 Python 모듈과 유사하게 동작합니다.\u003c/li\u003e\n\u003cli\u003e확장 모듈은 기존 모듈 객체로 쉽게 로드될 수 있어, \u003ccode\u003erunpy\u003c/code\u003e 또는 확장 모듈 재로드를 가능하게 하는 시스템을 지원할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e동일한 확장으로부터 여러 모듈을 로드하는 것이 가능해져, 단일 인터프리터에서 모듈 격리(적절한 서브 인터프리터 지원을 위한 핵심 기능)를 테스트할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePEP 489 채택의 가장 큰 장애물은 확장 타입의 메서드에서 모듈 상태에 접근하는 것을 허용하는 것이었습니다. 현재 확장 메서드에서 이 상태에 접근하는 방법은 \u003ccode\u003ePyState_FindModule\u003c/code\u003e을 통해 모듈을 조회하는 것입니다(확장 모듈의 모듈 수준 함수와 달리, 이들은 모듈 참조를 인수로 받음). 그러나 \u003ccode\u003ePyState_FindModule\u003c/code\u003e은 스레드 로컬 상태를 쿼리하여 C 수준의 프로세스 전역 접근에 비해 상대적으로 비용이 많이 들고, 결과적으로 모듈 작성자가 이를 사용하는 것을 꺼리게 만듭니다.\u003c/p\u003e\n\u003cp\u003e또한, \u003ccode\u003ePyState_FindModule\u003c/code\u003e은 각 서브 인터프리터에서 주어진 \u003ccode\u003ePyModuleDef\u003c/code\u003e에 해당하는 모듈이 최대 하나라는 가정에 의존합니다. 이 가정은 PEP 489의 다단계 초기화를 사용하는 모듈에는 적용되지 않으므로, 이러한 모듈에서는 \u003ccode\u003ePyState_FindModule\u003c/code\u003e을 사용할 수 없습니다. 확장 메서드에서 모듈 수준 상태에 접근하기 위한 더 빠르고 안전한 방법이 필요합니다.\u003c/p\u003e\n\u003ch4\u003e배경 (Background)\u003c/h4\u003e\n\u003cp\u003ePython 메서드의 구현은 다음 정보 중 하나 이상에 접근해야 할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e호출되는 인스턴스(\u003ccode\u003eself\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e기본 함수\u003c/li\u003e\n\u003cli\u003e정의 클래스(메서드가 정의된 클래스)\u003c/li\u003e\n\u003cli\u003e해당 모듈\u003c/li\u003e\n\u003cli\u003e모듈 상태\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePython 코드에서는 다음과 같이 Python 수준의 동등한 값을 검색할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport sys\nclass Foo:\n    def meth(self):\n        instance = self\n        module_globals = globals()\n        module_object = sys.modules[__name__] # (1)\n        underlying_function = Foo.meth # (1)\n        defining_class = Foo # (1)\n        defining_class = __class__ # (2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고: 정의 클래스는 \u003ccode\u003etype(self)\u003c/code\u003e가 아닙니다. \u003ccode\u003etype(self)\u003c/code\u003e는 \u003ccode\u003eFoo\u003c/code\u003e의 서브클래스일 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e(1)로 표시된 문장은 함수의 \u003ccode\u003e__globals__\u003c/code\u003e를 통한 이름 기반 조회에 암묵적으로 의존합니다. Python 코드에서 이는 함수 정의가 실행될 때 \u003ccode\u003e__globals__\u003c/code\u003e가 적절하게 설정되고, 네임스페이스가 조작되어 다른 객체를 반환하더라도 최악의 경우 예외가 발생하므로 가능합니다. \u003ccode\u003e__class__\u003c/code\u003e 클로저(2)는 정의 클래스를 얻는 더 안전한 방법이지만, 여전히 \u003ccode\u003e__closure__\u003c/code\u003e가 적절하게 설정되어야 합니다.\u003c/p\u003e\n\u003cp\u003e반대로, 확장 메서드는 일반적으로 일반 C 함수로 구현됩니다. 이는 메서드가 인자와 C 수준의 스레드 로컬 및 프로세스 전역 상태에만 접근할 수 있음을 의미합니다. 전통적으로 많은 확장 모듈은 공유 상태를 C 수준의 프로세스 전역 변수에 저장하여 다음과 같은 경우에 문제를 일으켰습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e동일한 프로세스에서 여러 초기화/종료 주기 실행\u003c/li\u003e\n\u003cli\u003e모듈 재로드(예: 조건부 임포트 테스트)\u003c/li\u003e\n\u003cli\u003e서브 인터프리터에서 확장 모듈 로드\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePEP 3121은 \u003ccode\u003ePyState_FindModule\u003c/code\u003e API를 제공하여 이를 해결하려고 시도했지만, 확장 메서드(모듈 수준 함수와 달리)의 경우 여전히 심각한 문제가 있었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC 수준의 프로세스 전역 상태에 직접 접근하는 것보다 현저히 느립니다.\u003c/li\u003e\n\u003cli\u003e모듈 재로드를 안정적으로 처리하지 못하는 프로세스 전역 상태에 대한 본질적인 의존성이 여전히 존재합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한, 모듈 상태와 같은 C 수준의 구조체를 조회할 때 예상치 못한 객체 레이아웃을 제공하면 인터프리터가 충돌할 수 있으므로, 확장 메서드가 예상하는 종류의 객체를 받도록 보장하는 것이 훨씬 더 중요합니다.\u003c/p\u003e\n\u003ch4\u003e제안 (Proposal)\u003c/h4\u003e\n\u003cp\u003e현재 바운드 확장 메서드(\u003ccode\u003ePyCFunction\u003c/code\u003e 또는 \u003ccode\u003ePyCFunctionWithKeywords\u003c/code\u003e)는 \u003ccode\u003eself\u003c/code\u003e와 (해당하는 경우) 제공된 위치 및 키워드 인자만 받습니다. 모듈 수준 확장 함수는 \u003ccode\u003eself\u003c/code\u003e 인자를 통해 정의 모듈 객체에 접근할 수 있지만, 확장 타입의 메서드는 그렇지 않습니다. 메서드는 \u003ccode\u003eself\u003c/code\u003e를 통해 바운드 인스턴스를 받으므로, 정의 클래스나 모듈 수준 상태에 직접 접근할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e위에 설명된 추가적인 모듈 수준 컨텍스트는 두 가지 변경 사항으로 제공될 수 있습니다. 두 가지 추가 사항 모두 선택 사항입니다. 확장 작성자는 이를 사용하기 위해 옵트인(opt-in)해야 합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e힙 타입 객체에 모듈에 대한 포인터를 추가합니다.\u003c/li\u003e\n\u003cli\u003e기본 C 함수에 정의 클래스를 전달합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eCPython에서 정의 클래스는 내장 메서드 객체(\u003ccode\u003ePyCFunctionObject\u003c/code\u003e)가 생성될 때 쉽게 사용할 수 있으므로, \u003ccode\u003ePyCFunctionObject\u003c/code\u003e를 확장하는 새로운 구조체에 저장할 수 있습니다. 모듈 상태는 \u003ccode\u003ePyModule_GetState\u003c/code\u003e를 통해 모듈 객체에서 검색할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 제안은 모듈별 상태에 접근해야 하는 메서드를 가진 모든 타입이 정적 타입이 아닌 힙 타입이어야 함을 의미합니다. 이는 단일 확장으로부터 여러 모듈 객체를 로드하는 것을 지원하는 데 필요합니다. C 수준 전역 변수인 정적 타입은 자신이 속한 모듈 객체에 대한 정보를 가지고 있지 않습니다.\u003c/p\u003e\n\u003ch4\u003e슬롯 메서드 (Slot methods)\u003c/h4\u003e\n\u003cp\u003e위의 변경 사항은 \u003ccode\u003etp_iter\u003c/code\u003e 또는 \u003ccode\u003enb_add\u003c/code\u003e와 같은 슬롯 메서드에는 적용되지 않습니다. 슬롯 메서드의 문제는 C-API가 고정되어 있어 정의 클래스를 전달하기 위해 단순히 새로운 인자를 추가할 수 없다는 것입니다. 이 문제에 대해 두 가지 가능한 해결책이 제안되었습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eMRO를 탐색하여 클래스를 조회합니다. 이는 잠재적으로 비용이 많이 들지만, 성능이 문제가 되지 않는 경우(예: 모듈 수준 예외 발생 시) 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e각 슬롯의 정의 클래스에 대한 포인터를 별도의 테이블인 \u003ccode\u003e__typeslots__\u003c/code\u003e에 저장합니다. 이는 기술적으로 가능하고 빠르지만, 상당히 침범적입니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 문제에 영향을 받는 모듈은 스레드 로컬 상태 또는 PEP 567 컨텍스트 변수를 캐싱 메커니즘으로 사용하거나, 자체적인 재로드 친화적인 조회 캐싱 스키마를 정의할 수도 있습니다. 이 문제를 일반적​​으로 해결하는 것은 향후 PEP로 미뤄집니다.\u003c/p\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003ch4\u003e힙 타입에 모듈 참조 추가 (Adding module references to heap types)\u003c/h4\u003e\n\u003cp\u003e모듈을 생성하기 위한 새로운 팩토리 메서드가 C-API에 추가될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003ePyObject* PyType_FromModuleAndSpec(PyObject *module, PyType_Spec *spec, PyObject *bases)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 \u003ccode\u003ePyType_FromSpecWithBases\u003c/code\u003e와 동일하게 작동하며, 추가적으로 제공된 모듈 객체를 새 타입과 연결합니다. (CPython에서는 아래에 설명된 \u003ccode\u003eht_module\u003c/code\u003e을 설정합니다.)\u003c/p\u003e\n\u003cp\u003e또한, 접근자 \u003ccode\u003ePyObject * PyType_GetModule(PyTypeObject *)\u003c/code\u003e가 제공될 것입니다. 이 함수는 타입에 연결된 모듈이 설정되어 있으면 해당 모듈을 반환하고, 그렇지 않으면 \u003ccode\u003eTypeError\u003c/code\u003e를 설정하고 \u003ccode\u003eNULL\u003c/code\u003e을 반환합니다. 정적 타입이 주어지면 항상 \u003ccode\u003eTypeError\u003c/code\u003e를 설정하고 \u003ccode\u003eNULL\u003c/code\u003e을 반환합니다.\u003c/p\u003e\n\u003cp\u003eCPython에서 이를 구현하기 위해 \u003ccode\u003ePyHeapTypeObject\u003c/code\u003e 구조체에 \u003ccode\u003ePyObject *ht_module\u003c/code\u003e이라는 새 멤버가 추가되어 연결된 모듈에 대한 포인터를 저장합니다. 기본적으로 \u003ccode\u003eNULL\u003c/code\u003e이며, 타입 객체가 생성된 후에는 수정되어서는 안 됩니다. \u003ccode\u003eht_module\u003c/code\u003e 멤버는 서브클래스에 의해 상속되지 않습니다. 필요한 각 개별 타입에 대해 \u003ccode\u003ePyType_FromSpecWithBases\u003c/code\u003e를 사용하여 설정해야 합니다.\u003c/p\u003e\n\u003cp\u003e일반적으로 \u003ccode\u003eht_module\u003c/code\u003e이 설정된 클래스를 생성하면 클래스와 모듈을 포함하는 순환 참조(reference cycle)가 생성됩니다. 모듈을 해체하는 작업은 성능에 민감한 작업이 아니며, 모듈 수준 함수도 일반적으로 순환 참조를 생성하므로 이는 문제가 되지 않습니다. 함수의 \u003ccode\u003ef_globals\u003c/code\u003e를 통해 함수 순환을 끊는 기존의 \"모든 모듈 전역 변수를 \u003ccode\u003eNone\u003c/code\u003e으로 설정\"하는 코드는 \u003ccode\u003eht_module\u003c/code\u003e을 통한 새로운 순환도 끊을 것입니다.\u003c/p\u003e\n\u003ch4\u003e확장 메서드에 정의 클래스 전달 (Passing the defining class to extension methods)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ePyMethodDef.ml_flags\u003c/code\u003e에 사용될 새로운 시그니처 플래그 \u003ccode\u003eMETH_METHOD\u003c/code\u003e가 추가될 것입니다. 개념적으로 이는 함수 시그니처에 \u003ccode\u003edefining_class\u003c/code\u003e를 추가합니다. 초기 구현을 쉽게 하기 위해 이 플래그는 \u003ccode\u003e(METH_FASTCALL | METH_KEYWORDS | METH_METHOD)\u003c/code\u003e로만 사용할 수 있습니다. (\u003ccode\u003eMETH_O\u003c/code\u003e 또는 단순 \u003ccode\u003eMETH_FASTCALL\u003c/code\u003e과 같은 다른 플래그와는 함께 사용할 수 없지만, \u003ccode\u003eMETH_CLASS\u003c/code\u003e 또는 \u003ccode\u003eMETH_STATIC\u003c/code\u003e과 결합될 수 있습니다.)\u003c/p\u003e\n\u003cp\u003e이 플래그 조합을 사용하여 정의된 메서드에 대한 C 함수는 \u003ccode\u003ePyCMethod\u003c/code\u003e라는 새로운 C 시그니처를 사용하여 호출될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003ePyObject *PyCMethod(PyObject *self, PyTypeObject *defining_class, PyObject *const *args, size_t nargsf, PyObject *kwnames)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eMETH_VARARGS | METH_METHOD\u003c/code\u003e와 같은 추가 조합은 나중에(또는 이 PEP의 초기 구현에서도) 추가될 수 있습니다. 그러나 \u003ccode\u003eMETH_METHOD\u003c/code\u003e는 항상 추가 플래그여야 합니다. 즉, 정의 클래스는 필요할 때만 전달되어야 합니다.\u003c/p\u003e\n\u003cp\u003eCPython에서는 추가 정보를 저장하기 위해 \u003ccode\u003ePyCFunctionObject\u003c/code\u003e를 확장하는 새로운 구조체가 추가될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct {\n    PyCFunctionObject func;\n    PyTypeObject *mm_class; /* C 함수에 'defining_class' 인자로 전달됨 */\n} PyCMethodObject;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ePyCFunction\u003c/code\u003e 구현은 \u003ccode\u003eMETH_METHOD\u003c/code\u003e 플래그가 설정된 것을 발견하면 \u003ccode\u003emm_class\u003c/code\u003e를 \u003ccode\u003ePyCMethod\u003c/code\u003e C 함수로 전달할 것입니다. \u003ccode\u003emm_class\u003c/code\u003e에 더 쉽게 접근할 수 있도록 새로운 매크로 \u003ccode\u003ePyCFunction_GET_CLASS(cls)\u003c/code\u003e가 추가될 것입니다.\u003c/p\u003e\n\u003cp\u003eC 메서드는 정의 클래스/모듈에 대한 접근이 필요하지 않은 경우 다른 \u003ccode\u003eMETH_*\u003c/code\u003e 시그니처를 계속 사용할 수 있습니다. \u003ccode\u003eMETH_METHOD\u003c/code\u003e가 설정되지 않은 경우 \u003ccode\u003ePyCMethodObject\u003c/code\u003e로 캐스팅하는 것은 유효하지 않습니다.\u003c/p\u003e\n\u003ch4\u003eArgument Clinic\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eArgument Clinic\u003c/code\u003e을 사용하여 메서드에 정의 클래스를 전달하는 것을 지원하기 위해, \u003ccode\u003edefining_class\u003c/code\u003e라는 새로운 컨버터가 CPython의 \u003ccode\u003eArgument Clinic\u003c/code\u003e 도구에 추가될 것입니다. 각 메서드는 이 컨버터를 사용하는 인자를 하나만 가질 수 있으며, \u003ccode\u003eself\u003c/code\u003e 뒤에 오거나, \u003ccode\u003eself\u003c/code\u003e가 사용되지 않는 경우 첫 번째 인자로 와야 합니다. 이 인자는 \u003ccode\u003ePyTypeObject *\u003c/code\u003e 타입이 될 것입니다.\u003c/p\u003e\n\u003cp\u003e사용될 때, \u003ccode\u003eArgument Clinic\u003c/code\u003e은 \u003ccode\u003eMETH_FASTCALL | METH_KEYWORDS | METH_METHOD\u003c/code\u003e를 호출 규칙으로 선택할 것입니다. 이 인자는 \u003ccode\u003e__text_signature__\u003c/code\u003e에 나타나지 않을 것입니다. 새로운 컨버터는 \u003ccode\u003eMETH_METHOD\u003c/code\u003e 규칙을 사용할 수 없는 \u003ccode\u003e__init__\u003c/code\u003e 및 \u003ccode\u003e__new__\u003c/code\u003e 메서드와는 초기에는 호환되지 않을 것입니다.\u003c/p\u003e\n\u003ch4\u003e헬퍼 (Helpers)\u003c/h4\u003e\n\u003cp\u003e힙 타입에서 모듈별 상태에 접근하는 것은 매우 일반적인 작업입니다. 이를 더 쉽게 하기 위해 헬퍼 함수가 추가될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid *PyType_GetModuleState(PyObject *type)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 힙 타입을 인자로 받고, 성공하면 힙 타입이 속한 모듈의 상태에 대한 포인터를 반환합니다. 실패 시 두 가지 시나리오가 발생할 수 있습니다. 비-타입 객체나 모듈이 없는 타입이 전달되면 \u003ccode\u003eTypeError\u003c/code\u003e가 설정되고 \u003ccode\u003eNULL\u003c/code\u003e이 반환됩니다. 모듈이 발견되면, \u003ccode\u003eNULL\u003c/code\u003e일 수도 있는 상태에 대한 포인터가 예외 설정 없이 반환됩니다.\u003c/p\u003e\n\u003ch4\u003e초기 구현에서 변환될 모듈 (Modules Converted in the Initial Implementation)\u003c/h4\u003e\n\u003cp\u003e접근 방식을 검증하기 위해 초기 구현 과정에서 \u003ccode\u003e_elementtree\u003c/code\u003e 모듈이 수정될 것입니다.\u003c/p\u003e\n\u003ch3\u003eAPI 변경 및 추가 요약 (Summary of API Changes and Additions)\u003c/h3\u003e\n\u003cp\u003ePython C-API에 다음이 추가될 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyType_FromModuleAndSpec\u003c/code\u003e 함수\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyType_GetModule\u003c/code\u003e 함수\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyType_GetModuleState\u003c/code\u003e 함수\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMETH_METHOD\u003c/code\u003e 호출 플래그\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyCMethod\u003c/code\u003e 함수 시그니처\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 추가 사항은 CPython 구현 세부 사항으로 추가되며 문서화되지 않을 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyCFunction_GET_CLASS\u003c/code\u003e 매크로\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyCMethodObject\u003c/code\u003e 구조체\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e_heaptypeobject\u003c/code\u003e의 \u003ccode\u003eht_module\u003c/code\u003e 멤버\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eArgument Clinic\u003c/code\u003e의 \u003ccode\u003edefining_class\u003c/code\u003e 컨버터\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e하위 호환성 (Backwards Compatibility)\u003c/h3\u003e\n\u003cp\u003e모든 힙 타입에 새로운 포인터 하나가 추가됩니다. 다른 모든 변경 사항은 새로운 함수와 구조체를 추가하거나 개인 구현 세부 사항을 변경하는 것입니다.\u003c/p\u003e\n\u003ch3\u003e구현 (Implementation)\u003c/h3\u003e\n\u003cp\u003e초기 구현은 GitHub 리포지토리에서 확인할 수 있으며, 패치셋은에 있습니다.\u003c/p\u003e\n\u003ch3\u003e가능한 향후 확장 (Possible Future Extensions)\u003c/h3\u003e\n\u003ch4\u003e슬롯 메서드 (Slot methods)\u003c/h4\u003e\n\u003cp\u003e슬롯 메서드에 정의 클래스(또는 모듈 상태)를 전달하는 방법이 미래에 추가될 수 있습니다. 이 PEP의 이전 버전은 특정 함수에 대한 슬롯을 정의하는 클래스를 MRO에서 검색하여 정의 클래스를 결정하는 헬퍼 함수를 제안했습니다. 그러나 이 접근 방식은 클래스가 변경되는 경우(힙 타입의 경우 Python 코드에서 가능) 실패할 수 있습니다. 이 문제의 해결은 향후 논의로 남겨져 있습니다.\u003c/p\u003e\n\u003ch4\u003e모듈 참조를 포함하는 타입의 쉬운 생성 (Easy creation of types with module references)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ePyType_FromModuleAndSpec\u003c/code\u003e를 호출하는 것보다 훨씬 쉽게 힙 타입을 생성할 수 있도록 PEP 489 실행 슬롯 타입을 추가하는 것이 가능할 수 있습니다. 이는 향후 PEP로 남겨져 있습니다.\u003c/p\u003e\n\u003cp\u003e제한된 API에서 정적 예외 타입을 생성하는 좋은 방법을 추가하는 것이 좋을 수 있습니다. 이러한 예외 타입은 서브 인터프리터 간에 공유될 수 있지만, 특정 모듈 상태 없이 인스턴스화될 수 있습니다. 이것 또한 가능한 향후 논의로 남겨져 있습니다.\u003c/p\u003e\n\u003ch4\u003e최적화 (Optimization)\u003c/h4\u003e\n\u003cp\u003e여기서 제안된 대로 \u003ccode\u003eMETH_METHOD\u003c/code\u003e 플래그로 정의된 메서드는 하나의 특정 시그니처만 지원합니다. 성능상의 이유로 다른 시그니처가 필요한 것으로 판명되면 추가될 수 있습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 573 - Module State Access from C Extension Methods\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:59:37+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>