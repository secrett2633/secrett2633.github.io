<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-19cfc001fdac3337.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1098<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 384 - Defining a Stable ABI</h1><div class="page__meta"><time dateTime="2025-09-26 21:04:32+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0384/">PEP 384 - Defining a Stable ABI</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 17-May-2009</p>
</blockquote>
<p>PEP 384 – 안정적인 ABI 정의 (Defining a Stable ABI)</p>
<p>이 문서는 Python 3의 수명 주기 동안 안정적으로 유지되며, 여러 Python 버전 간에 바이너리 호환성을 보장하는 API 함수 집합인 "안정적인 ABI"를 정의할 것을 제안합니다. 안정적인 ABI를 사용하는 확장 모듈과 Python 임베딩 애플리케이션은 재컴파일 없이도 서로 다른 Python 기능 릴리스에서 작동할 수 있습니다.</p>
<p><strong>중요:</strong> 이 PEP는 역사적인 문서입니다. 최신 공식 문서는 C API 안정성 (사용자 문서) 및 Python의 C API 변경 (개발 문서)에서 확인할 수 있습니다.</p>
<hr>
<h2>초록 (Abstract)</h2>
<p>현재 Python은 각 기능 릴리스마다 Windows에서 Python DLL의 새 이름을 도입하며, Unix에서는 확장 모듈에 대한 비호환성을 유발할 수 있습니다. 이 PEP는 Python 3의 수명 동안 안정적으로 유지되고 버전 간에 바이너리 호환성을 유지하는 안정적인 API 함수 집합을 정의할 것을 제안합니다. 확장 모듈 및 Python을 임베딩하는 애플리케이션은 이 안정적인 ABI에만 의존한다면 서로 다른 기능 릴리스에서도 작동할 수 있습니다.</p>
<h2>도입 배경 (Rationale)</h2>
<p>ABI 비호환성의 주된 원인은 메모리 내 구조체의 레이아웃 변경입니다. 예를 들어, Python 2.x 수명 주기 동안 문자열 내부화(interning) 방식이나 객체 크기를 나타내는 데 사용되는 데이터 유형이 변경되었습니다. 그 결과, 문자열, 리스트, 튜플의 필드에 직접 접근하는 확장 모듈은 재컴파일 없이 새로운 인터프리터 버전에 로드될 경우 작동하지 않게 됩니다. 필드 오프셋이 변경되어 확장 모듈이 잘못된 데이터에 접근할 수 있기 때문입니다.</p>
<p>일부 비호환성은 프레임 또는 코드 객체와 같은 인터프리터의 내부 객체에만 영향을 미칩니다. 이러한 변경 사항으로 인해 <code>PYTHON_API_VERSION</code>을 변경해야 했습니다. Linux에서는 ABI 변경이 큰 문제가 되지 않는 경우가 많지만, Windows에서는 여러 Python 버전의 동시 설치가 일반적이며, 확장 모듈은 최종 사용자가 아닌 개발자에 의해 컴파일됩니다. 이러한 ABI 비호환성 위험을 줄이기 위해 Python은 각 기능 릴리스마다 <code>pythonXY.dll</code>이라는 새 DLL 이름을 도입해왔습니다.</p>
<p>이 PEP를 통해 바이너리 확장 모듈이 특정 Python 기능 릴리스에 의존하는 것을 줄이고, Python을 임베딩하는 애플리케이션이 여러 릴리스에서 작동할 수 있도록 할 예정입니다.</p>
<h2>사양 (Specification)</h2>
<p>ABI 사양은 두 부분으로 나뉩니다: ABI와 함께 사용할 수 있는 함수(그룹)를 지정하는 API 사양과, 링크할 라이브러리를 지정하는 링키지(linkage) 사양입니다. 실제 ABI(메모리 내 구조체 레이아웃, 함수 호출 규약)는 명시적으로 지정되지 않고 컴파일러에 의해 암시됩니다.</p>
<h3>용어 (Terminology)</h3>
<p>이 ABI를 사용하려는 애플리케이션 및 확장 모듈은 여기에서부터 "애플리케이션"으로 통칭됩니다.</p>
<h3>헤더 파일 및 전처리기 정의 (Header Files and Preprocessor Definitions)</h3>
<p>애플리케이션은 <code>Python.h</code> (다른 시스템 헤더보다 먼저 포함) 또는 선택적으로 <code>pyconfig.h</code> 다음에 <code>Python.h</code>만 포함해야 합니다.
애플리케이션 컴파일 시, 전처리기 매크로 <code>Py_LIMITED_API</code>가 정의되어야 합니다. 이렇게 하면 ABI의 일부가 아닌 모든 정의가 숨겨집니다.</p>
<h3>구조체 (Structures)</h3>
<p>다음 구조체 및 구조체 필드만 애플리케이션에서 접근 가능합니다:</p>
<ul>
<li><code>PyObject</code> (<code>ob_refcnt</code>, <code>ob_type</code>)</li>
<li><code>PyVarObject</code> (<code>ob_base</code>, <code>ob_size</code>)</li>
<li><code>PyMethodDef</code> (<code>ml_name</code>, <code>ml_meth</code>, <code>ml_flags</code>, <code>ml_doc</code>)</li>
<li><code>PyMemberDef</code> (<code>name</code>, <code>type</code>, <code>offset</code>, <code>flags</code>, <code>doc</code>)</li>
<li><code>PyGetSetDef</code> (<code>name</code>, <code>get</code>, <code>set</code>, <code>doc</code>, <code>closure</code>)</li>
<li><code>PyModuleDefBase</code> (<code>ob_base</code>, <code>m_init</code>, <code>m_index</code>, <code>m_copy</code>)</li>
<li><code>PyModuleDef</code> (<code>m_base</code>, <code>m_name</code>, <code>m_doc</code>, <code>m_size</code>, <code>m_methods</code>, <code>m_traverse</code>, <code>m_clear</code>, <code>m_free</code>)</li>
<li><code>PyStructSequence_Field</code> (<code>name</code>, <code>doc</code>)</li>
<li><code>PyStructSequence_Desc</code> (<code>name</code>, <code>doc</code>, <code>fields</code>, <code>sequence</code>)</li>
<li><code>PyType_Slot</code> (아래 참조)</li>
<li><code>PyType_Spec</code> (아래 참조)</li>
</ul>
<p>이 필드들에 대한 접근자 매크로 (<code>Py_REFCNT</code>, <code>Py_TYPE</code>, <code>Py_SIZE</code>)도 애플리케이션에서 사용 가능합니다.</p>
<p>다음 유형들은 사용 가능하지만, 불투명(opaque, 즉 불완전한) 타입입니다:
<code>PyThreadState</code>, <code>PyInterpreterState</code>, <code>struct _frame</code>, <code>struct symtable</code>, <code>struct _node</code>, <code>PyWeakReference</code>, <code>PyLongObject</code>, <code>PyTypeObject</code>.</p>
<h3>타입 객체 (Type Objects)</h3>
<p>타입 객체의 구조는 애플리케이션에서 사용할 수 없습니다. 이 ABI를 사용하는 애플리케이션에서는 "정적(static)" 타입 객체를 선언하는 것이 더 이상 불가능합니다. 대신, 타입 객체는 동적으로 생성됩니다.</p>
<p>타입을 쉽게 생성하기 위해 (특히 함수 포인터를 쉽게 채울 수 있도록), 다음 구조체와 함수가 제공됩니다:</p>
<pre><code class="language-c">typedef struct{
    int slot;  /* slot id, see below */
    void *pfunc; /* function pointer */
} PyType_Slot;

typedef struct{
    const char* name;
    int basicsize;
    int itemsize;
    unsigned int flags;
    PyType_Slot *slots; /* terminated by slot==0. */
} PyType_Spec;

PyObject* PyType_FromSpec(PyType_Spec*);
</code></pre>
<p><code>slot</code>을 지정하려면 고유한 slot ID가 제공되어야 합니다. 새로운 Python 버전은 새로운 slot ID를 도입할 수 있지만, slot ID는 재활용되지 않습니다. Slot은 사용 중단(deprecated)될 수 있지만, Python 3.x 내내 계속 지원됩니다.</p>
<p>slot ID는 Python 3.1에서 포인터를 포함하는 구조체의 필드 이름처럼 명명되며, <code>Py_</code> 접두사가 추가됩니다 (예: <code>tp_dealloc</code> 대신 <code>Py_tp_dealloc</code>).</p>
<p>다음 필드는 타입 정의 시 설정할 수 없습니다:
<code>tp_dict</code>, <code>tp_mro</code>, <code>tp_cache</code>, <code>tp_subclasses</code>, <code>tp_weaklist</code>, <code>tp_print</code>, <code>tp_weaklistoffset</code>, <code>tp_dictoffset</code>.</p>
<h3>typedefs</h3>
<p>위에 나열된 구조체에 대한 <code>typedef</code> 외에도, 다음 <code>typedef</code>가 제공됩니다. 이들이 ABI에 포함된다는 것은 기본 유형이 플랫폼에서 변경되지 않아야 함을 의미합니다 (플랫폼 간에는 다를 수 있음).
<code>Py_uintptr_t</code>, <code>Py_intptr_t</code>, <code>Py_ssize_t</code>, <code>unaryfunc</code>, <code>binaryfunc</code>, <code>ternaryfunc</code>, <code>inquiry</code>, <code>lenfunc</code>, <code>ssizeargfunc</code>, <code>ssizessizeargfunc</code>, <code>ssizeobjargproc</code>, <code>ssizessizeobjargproc</code>, <code>objobjargproc</code>, <code>objobjproc</code>, <code>visitproc</code>, <code>traverseproc</code>, <code>destructor</code>, <code>getattrfunc</code>, <code>getattrofunc</code>, <code>setattrfunc</code>, <code>setattrofunc</code>, <code>reprfunc</code>, <code>hashfunc</code>, <code>richcmpfunc</code>, <code>getiterfunc</code>, <code>iternextfunc</code>, <code>descrgetfunc</code>, <code>descrsetfunc</code>, <code>initproc</code>, <code>newfunc</code>, <code>allocfunc</code>, <code>PyCFunction</code>, <code>PyCFunctionWithKeywords</code>, <code>PyNoArgsFunction</code>, <code>PyCapsule_Destructor</code>, <code>getter</code>, <code>setter</code>, <code>PyOS_sighandler_t</code>, <code>PyGILState_STATE</code>, <code>Py_UCS4</code>.</p>
<p>특히 <code>Py_UNICODE</code>는 <code>typedef</code>로 사용할 수 없습니다. 동일한 Python 버전에서도 동일한 플랫폼에서 <code>Py_UNICODE</code>의 다른 정의를 사용할 수 있기 때문입니다 (좁은 또는 넓은 코드 단위를 사용하는지에 따라 다름). Unicode 문자열의 내용에 접근해야 하는 애플리케이션은 이를 <code>wchar_t</code>로 변환할 수 있습니다.</p>
<h3>함수 및 함수와 유사한 매크로 (Functions and function-like Macros)</h3>
<p>별도로 제외되지 않는 한 모든 함수를 사용할 수 있습니다. 함수가 문서화되었는지 여부는 중요하지 않습니다.</p>
<p>함수와 유사한 매크로 (특히 필드 접근 매크로)는 애플리케이션에서 계속 사용할 수 있지만, 함수 호출로 대체됩니다 (정의가 다양한 <code>_Check</code> 매크로와 같이 ABI의 기능만을 참조하는 경우가 아니라면).</p>
<p>ABI 함수 선언은 매개변수나 반환 타입을 변경하지 않습니다. 시그니처 변경이 필요한 경우 새로운 함수가 도입됩니다. 새 함수가 소스 호환성이 있다면 (예: 반환 타입만 변경되는 경우), 애플리케이션이 재컴파일될 때 새 함수로 호출을 리디렉션하기 위해 별칭 매크로가 추가될 수 있습니다.</p>
<p>이전 함수의 계속된 제공이 불가능할 경우, 사용 중단(deprecated) 후 제거될 수 있으며, 해당 함수를 사용하는 애플리케이션은 작동을 멈출 수 있습니다.</p>
<h3>제외된 함수 (Excluded Functions)</h3>
<p><code>_Py</code>로 시작하는 모든 함수는 애플리케이션에서 사용할 수 없습니다. 또한, <code>node*</code>와 같이 애플리케이션에서 사용할 수 없는 매개변수 유형을 예상하는 모든 함수 (예: <code>PyAST_FromNode</code>)는 ABI에서 제외됩니다.</p>
<p>다음 헤더 파일에 선언된 함수는 ABI의 일부가 아닙니다:
<code>bytes_methods.h</code>, <code>cellobject.h</code>, <code>classobject.h</code>, <code>code.h</code>, <code>compile.h</code>, <code>datetime.h</code>, <code>dtoa.h</code>, <code>frameobject.h</code>, <code>funcobject.h</code>, <code>genobject.h</code>, <code>longintrepr.h</code>, <code>parsetok.h</code>, <code>pyarena.h</code>, <code>pyatomic.h</code>, <code>pyctype.h</code>, <code>pydebug.h</code>, <code>pytime.h</code>, <code>symtable.h</code>, <code>token.h</code>, <code>ucnhash.h</code>.</p>
<p>또한, Windows에서 Microsoft C 런타임 DLL의 특정 버전에 의존하는 것을 피하기 위해 <code>FILE*</code>를 예상하는 함수는 ABI의 일부가 아닙니다.</p>
<p>모듈 및 타입 초기화/종료 함수 (<code>PyByteArray_Init</code>, <code>PyOS_FiniInterrupts</code> 및 <code>_Fini</code> 또는 <code>_ClearFreeList</code>로 끝나는 모든 함수)는 사용할 수 없습니다.</p>
<p>인터프리터 구현 세부 사항을 다루는 여러 함수도 사용할 수 없습니다:
<code>PyInterpreterState_Head</code>, <code>PyInterpreterState_Next</code>, <code>PyInterpreterState_ThreadHead</code>, <code>PyThreadState_Next</code>, <code>Py_SubversionRevision</code>, <code>Py_SubversionShortBranch</code>.</p>
<p><code>PyStructSequence_InitType</code>는 호출자가 정적 타입 객체를 제공해야 하므로 사용할 수 없습니다.</p>
<p><code>Py_FatalError</code>는 <code>pydebug.h</code>에서 다른 헤더 파일 (예: <code>pyerrors.h</code>)로 이동됩니다.</p>
<p>사용 가능한 함수의 정확한 목록은 <code>python3.dll</code>에 대한 Windows 모듈 정의 파일에 나와 있습니다.</p>
<h3>전역 변수 (Global Variables)</h3>
<p>타입과 예외를 나타내는 전역 변수는 애플리케이션에서 사용할 수 있습니다. 또한, 매크로에서 참조되는 선택된 전역 변수 (<code>Py_True</code> 및 <code>Py_False</code> 등)도 사용할 수 있습니다.</p>
<p>전역 변수 정의의 전체 목록은 <code>python3.def</code> 파일에 나와 있으며, <code>DATA</code>로 선언된 항목이 변수를 나타냅니다.</p>
<h3>기타 매크로 (Other Macros)</h3>
<p>심볼릭 상수를 정의하는 모든 매크로는 애플리케이션에서 사용할 수 있으며, 숫자 값은 변경되지 않습니다.
또한, 다음 매크로를 사용할 수 있습니다:
<code>Py_BEGIN_ALLOW_THREADS</code>, <code>Py_BLOCK_THREADS</code>, <code>Py_UNBLOCK_THREADS</code>, <code>Py_END_ALLOW_THREADS</code>.</p>
<h3>버퍼 인터페이스 (The Buffer Interface)</h3>
<p><code>Py_buffer</code> 구조체의 안정성이 현재로서는 명확하지 않으므로, 버퍼 인터페이스 (<code>Py_buffer</code> 타입, <code>bf_getbuffer</code> 및 <code>bf_releasebuffer</code> 타입 슬롯 등)는 ABI에서 생략되었습니다. 향후 릴리스에서 ABI에 포함될 수 있습니다.</p>
<h3>시그니처 변경 (Signature Changes)</h3>
<p>현재 특정 구조체를 예상하는 여러 함수가 있지만, 호출자는 일반적으로 <code>PyObject*</code>를 사용합니다. 이 함수들은 매개변수로 <code>PyObject*</code>를 예상하도록 변경되었습니다. 이는 현재 매개변수 타입으로 명시적 캐스팅을 하는 애플리케이션에서 경고를 유발할 수 있습니다. 해당 함수는 <code>PySlice_GetIndices</code>, <code>PySlice_GetIndicesEx</code>, <code>PyUnicode_AsWideChar</code>, <code>PyEval_EvalCode</code>입니다.</p>
<h3>링키지 (Linkage)</h3>
<p>Windows에서는 애플리케이션이 <code>python3.dll</code>에 링크해야 하며, 임포트 라이브러리 <code>python3.lib</code>가 제공될 것입니다. 이 DLL은 <code>/export</code> 링커 옵션을 통해 모든 API 함수를 전체 인터프리터 DLL, 즉 <code>python3y.dll</code>로 리디렉션합니다.</p>
<p>Unix 시스템에서는 ABI가 일반적으로 Python 실행 파일 자체에 의해 제공됩니다. 확장 모듈이 <code>Py_LIMITED_API</code>로 컴파일된 경우, <code>PyModule_Create</code>는 API 버전으로 3을 전달하도록 변경됩니다. API 버전에 대한 버전 검사는 3 또는 현재 <code>PYTHON_API_VERSION</code>을 준수하는 것으로 받아들입니다. Python이 공유 라이브러리로 컴파일된 경우, <code>libpython3.so</code>와 <code>libpython3.y.so</code> 둘 다로 설치됩니다. 이 PEP를 따르는 애플리케이션은 전자에 링크해야 합니다 (확장 모듈은 <code>libpython</code> 공유 객체 없이 런타임 링킹에 의존하여 계속 링크할 수 있음). ABI 버전은 <code>PYTHON_ABI_VERSION</code>으로 심볼릭하게 사용할 수 있습니다.</p>
<p>또한 Unix에서는 확장 모듈 파일 이름에 <code>abi&#x3C;PYTHON_ABI_VERSION></code> 태그가 허용됩니다. 이러한 방식으로 이름이 지정된 파일이 실제로 제한된 API로 제한되는지에 대한 검사는 수행되지 않으며, <code>distutils</code> 코드 동결로 인해 <code>distutils</code>에 이러한 파일 빌드 지원이 추가되지 않을 것입니다.</p>
<h2>구현 전략 (Implementation Strategy)</h2>
<p>이 PEP는 브랜치에서 구현되어 사용자가 모듈이 ABI를 준수하는지 확인할 수 있도록 합니다. 사용자가 타입 정의를 다시 작성할 필요가 없도록, 타입 정의를 포함하는 C 소스 코드를 변환하는 스크립트가 제공될 것입니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-19cfc001fdac3337.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/384\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"FeyCvJug7In7AgUZlfHUx\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/384/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/384\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"384\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/384\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T40dc,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0384/\"\u003ePEP 384 - Defining a Stable ABI\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 17-May-2009\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 384 – 안정적인 ABI 정의 (Defining a Stable ABI)\u003c/p\u003e\n\u003cp\u003e이 문서는 Python 3의 수명 주기 동안 안정적으로 유지되며, 여러 Python 버전 간에 바이너리 호환성을 보장하는 API 함수 집합인 \"안정적인 ABI\"를 정의할 것을 제안합니다. 안정적인 ABI를 사용하는 확장 모듈과 Python 임베딩 애플리케이션은 재컴파일 없이도 서로 다른 Python 기능 릴리스에서 작동할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e중요:\u003c/strong\u003e 이 PEP는 역사적인 문서입니다. 최신 공식 문서는 C API 안정성 (사용자 문서) 및 Python의 C API 변경 (개발 문서)에서 확인할 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e초록 (Abstract)\u003c/h2\u003e\n\u003cp\u003e현재 Python은 각 기능 릴리스마다 Windows에서 Python DLL의 새 이름을 도입하며, Unix에서는 확장 모듈에 대한 비호환성을 유발할 수 있습니다. 이 PEP는 Python 3의 수명 동안 안정적으로 유지되고 버전 간에 바이너리 호환성을 유지하는 안정적인 API 함수 집합을 정의할 것을 제안합니다. 확장 모듈 및 Python을 임베딩하는 애플리케이션은 이 안정적인 ABI에만 의존한다면 서로 다른 기능 릴리스에서도 작동할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e도입 배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003eABI 비호환성의 주된 원인은 메모리 내 구조체의 레이아웃 변경입니다. 예를 들어, Python 2.x 수명 주기 동안 문자열 내부화(interning) 방식이나 객체 크기를 나타내는 데 사용되는 데이터 유형이 변경되었습니다. 그 결과, 문자열, 리스트, 튜플의 필드에 직접 접근하는 확장 모듈은 재컴파일 없이 새로운 인터프리터 버전에 로드될 경우 작동하지 않게 됩니다. 필드 오프셋이 변경되어 확장 모듈이 잘못된 데이터에 접근할 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e일부 비호환성은 프레임 또는 코드 객체와 같은 인터프리터의 내부 객체에만 영향을 미칩니다. 이러한 변경 사항으로 인해 \u003ccode\u003ePYTHON_API_VERSION\u003c/code\u003e을 변경해야 했습니다. Linux에서는 ABI 변경이 큰 문제가 되지 않는 경우가 많지만, Windows에서는 여러 Python 버전의 동시 설치가 일반적이며, 확장 모듈은 최종 사용자가 아닌 개발자에 의해 컴파일됩니다. 이러한 ABI 비호환성 위험을 줄이기 위해 Python은 각 기능 릴리스마다 \u003ccode\u003epythonXY.dll\u003c/code\u003e이라는 새 DLL 이름을 도입해왔습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP를 통해 바이너리 확장 모듈이 특정 Python 기능 릴리스에 의존하는 것을 줄이고, Python을 임베딩하는 애플리케이션이 여러 릴리스에서 작동할 수 있도록 할 예정입니다.\u003c/p\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003cp\u003eABI 사양은 두 부분으로 나뉩니다: ABI와 함께 사용할 수 있는 함수(그룹)를 지정하는 API 사양과, 링크할 라이브러리를 지정하는 링키지(linkage) 사양입니다. 실제 ABI(메모리 내 구조체 레이아웃, 함수 호출 규약)는 명시적으로 지정되지 않고 컴파일러에 의해 암시됩니다.\u003c/p\u003e\n\u003ch3\u003e용어 (Terminology)\u003c/h3\u003e\n\u003cp\u003e이 ABI를 사용하려는 애플리케이션 및 확장 모듈은 여기에서부터 \"애플리케이션\"으로 통칭됩니다.\u003c/p\u003e\n\u003ch3\u003e헤더 파일 및 전처리기 정의 (Header Files and Preprocessor Definitions)\u003c/h3\u003e\n\u003cp\u003e애플리케이션은 \u003ccode\u003ePython.h\u003c/code\u003e (다른 시스템 헤더보다 먼저 포함) 또는 선택적으로 \u003ccode\u003epyconfig.h\u003c/code\u003e 다음에 \u003ccode\u003ePython.h\u003c/code\u003e만 포함해야 합니다.\r\n애플리케이션 컴파일 시, 전처리기 매크로 \u003ccode\u003ePy_LIMITED_API\u003c/code\u003e가 정의되어야 합니다. 이렇게 하면 ABI의 일부가 아닌 모든 정의가 숨겨집니다.\u003c/p\u003e\n\u003ch3\u003e구조체 (Structures)\u003c/h3\u003e\n\u003cp\u003e다음 구조체 및 구조체 필드만 애플리케이션에서 접근 가능합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyObject\u003c/code\u003e (\u003ccode\u003eob_refcnt\u003c/code\u003e, \u003ccode\u003eob_type\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyVarObject\u003c/code\u003e (\u003ccode\u003eob_base\u003c/code\u003e, \u003ccode\u003eob_size\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyMethodDef\u003c/code\u003e (\u003ccode\u003eml_name\u003c/code\u003e, \u003ccode\u003eml_meth\u003c/code\u003e, \u003ccode\u003eml_flags\u003c/code\u003e, \u003ccode\u003eml_doc\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyMemberDef\u003c/code\u003e (\u003ccode\u003ename\u003c/code\u003e, \u003ccode\u003etype\u003c/code\u003e, \u003ccode\u003eoffset\u003c/code\u003e, \u003ccode\u003eflags\u003c/code\u003e, \u003ccode\u003edoc\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyGetSetDef\u003c/code\u003e (\u003ccode\u003ename\u003c/code\u003e, \u003ccode\u003eget\u003c/code\u003e, \u003ccode\u003eset\u003c/code\u003e, \u003ccode\u003edoc\u003c/code\u003e, \u003ccode\u003eclosure\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyModuleDefBase\u003c/code\u003e (\u003ccode\u003eob_base\u003c/code\u003e, \u003ccode\u003em_init\u003c/code\u003e, \u003ccode\u003em_index\u003c/code\u003e, \u003ccode\u003em_copy\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyModuleDef\u003c/code\u003e (\u003ccode\u003em_base\u003c/code\u003e, \u003ccode\u003em_name\u003c/code\u003e, \u003ccode\u003em_doc\u003c/code\u003e, \u003ccode\u003em_size\u003c/code\u003e, \u003ccode\u003em_methods\u003c/code\u003e, \u003ccode\u003em_traverse\u003c/code\u003e, \u003ccode\u003em_clear\u003c/code\u003e, \u003ccode\u003em_free\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyStructSequence_Field\u003c/code\u003e (\u003ccode\u003ename\u003c/code\u003e, \u003ccode\u003edoc\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyStructSequence_Desc\u003c/code\u003e (\u003ccode\u003ename\u003c/code\u003e, \u003ccode\u003edoc\u003c/code\u003e, \u003ccode\u003efields\u003c/code\u003e, \u003ccode\u003esequence\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyType_Slot\u003c/code\u003e (아래 참조)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyType_Spec\u003c/code\u003e (아래 참조)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 필드들에 대한 접근자 매크로 (\u003ccode\u003ePy_REFCNT\u003c/code\u003e, \u003ccode\u003ePy_TYPE\u003c/code\u003e, \u003ccode\u003ePy_SIZE\u003c/code\u003e)도 애플리케이션에서 사용 가능합니다.\u003c/p\u003e\n\u003cp\u003e다음 유형들은 사용 가능하지만, 불투명(opaque, 즉 불완전한) 타입입니다:\r\n\u003ccode\u003ePyThreadState\u003c/code\u003e, \u003ccode\u003ePyInterpreterState\u003c/code\u003e, \u003ccode\u003estruct _frame\u003c/code\u003e, \u003ccode\u003estruct symtable\u003c/code\u003e, \u003ccode\u003estruct _node\u003c/code\u003e, \u003ccode\u003ePyWeakReference\u003c/code\u003e, \u003ccode\u003ePyLongObject\u003c/code\u003e, \u003ccode\u003ePyTypeObject\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003e타입 객체 (Type Objects)\u003c/h3\u003e\n\u003cp\u003e타입 객체의 구조는 애플리케이션에서 사용할 수 없습니다. 이 ABI를 사용하는 애플리케이션에서는 \"정적(static)\" 타입 객체를 선언하는 것이 더 이상 불가능합니다. 대신, 타입 객체는 동적으로 생성됩니다.\u003c/p\u003e\n\u003cp\u003e타입을 쉽게 생성하기 위해 (특히 함수 포인터를 쉽게 채울 수 있도록), 다음 구조체와 함수가 제공됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct{\r\n    int slot;  /* slot id, see below */\r\n    void *pfunc; /* function pointer */\r\n} PyType_Slot;\r\n\r\ntypedef struct{\r\n    const char* name;\r\n    int basicsize;\r\n    int itemsize;\r\n    unsigned int flags;\r\n    PyType_Slot *slots; /* terminated by slot==0. */\r\n} PyType_Spec;\r\n\r\nPyObject* PyType_FromSpec(PyType_Spec*);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eslot\u003c/code\u003e을 지정하려면 고유한 slot ID가 제공되어야 합니다. 새로운 Python 버전은 새로운 slot ID를 도입할 수 있지만, slot ID는 재활용되지 않습니다. Slot은 사용 중단(deprecated)될 수 있지만, Python 3.x 내내 계속 지원됩니다.\u003c/p\u003e\n\u003cp\u003eslot ID는 Python 3.1에서 포인터를 포함하는 구조체의 필드 이름처럼 명명되며, \u003ccode\u003ePy_\u003c/code\u003e 접두사가 추가됩니다 (예: \u003ccode\u003etp_dealloc\u003c/code\u003e 대신 \u003ccode\u003ePy_tp_dealloc\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003e다음 필드는 타입 정의 시 설정할 수 없습니다:\r\n\u003ccode\u003etp_dict\u003c/code\u003e, \u003ccode\u003etp_mro\u003c/code\u003e, \u003ccode\u003etp_cache\u003c/code\u003e, \u003ccode\u003etp_subclasses\u003c/code\u003e, \u003ccode\u003etp_weaklist\u003c/code\u003e, \u003ccode\u003etp_print\u003c/code\u003e, \u003ccode\u003etp_weaklistoffset\u003c/code\u003e, \u003ccode\u003etp_dictoffset\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003etypedefs\u003c/h3\u003e\n\u003cp\u003e위에 나열된 구조체에 대한 \u003ccode\u003etypedef\u003c/code\u003e 외에도, 다음 \u003ccode\u003etypedef\u003c/code\u003e가 제공됩니다. 이들이 ABI에 포함된다는 것은 기본 유형이 플랫폼에서 변경되지 않아야 함을 의미합니다 (플랫폼 간에는 다를 수 있음).\r\n\u003ccode\u003ePy_uintptr_t\u003c/code\u003e, \u003ccode\u003ePy_intptr_t\u003c/code\u003e, \u003ccode\u003ePy_ssize_t\u003c/code\u003e, \u003ccode\u003eunaryfunc\u003c/code\u003e, \u003ccode\u003ebinaryfunc\u003c/code\u003e, \u003ccode\u003eternaryfunc\u003c/code\u003e, \u003ccode\u003einquiry\u003c/code\u003e, \u003ccode\u003elenfunc\u003c/code\u003e, \u003ccode\u003essizeargfunc\u003c/code\u003e, \u003ccode\u003essizessizeargfunc\u003c/code\u003e, \u003ccode\u003essizeobjargproc\u003c/code\u003e, \u003ccode\u003essizessizeobjargproc\u003c/code\u003e, \u003ccode\u003eobjobjargproc\u003c/code\u003e, \u003ccode\u003eobjobjproc\u003c/code\u003e, \u003ccode\u003evisitproc\u003c/code\u003e, \u003ccode\u003etraverseproc\u003c/code\u003e, \u003ccode\u003edestructor\u003c/code\u003e, \u003ccode\u003egetattrfunc\u003c/code\u003e, \u003ccode\u003egetattrofunc\u003c/code\u003e, \u003ccode\u003esetattrfunc\u003c/code\u003e, \u003ccode\u003esetattrofunc\u003c/code\u003e, \u003ccode\u003ereprfunc\u003c/code\u003e, \u003ccode\u003ehashfunc\u003c/code\u003e, \u003ccode\u003erichcmpfunc\u003c/code\u003e, \u003ccode\u003egetiterfunc\u003c/code\u003e, \u003ccode\u003eiternextfunc\u003c/code\u003e, \u003ccode\u003edescrgetfunc\u003c/code\u003e, \u003ccode\u003edescrsetfunc\u003c/code\u003e, \u003ccode\u003einitproc\u003c/code\u003e, \u003ccode\u003enewfunc\u003c/code\u003e, \u003ccode\u003eallocfunc\u003c/code\u003e, \u003ccode\u003ePyCFunction\u003c/code\u003e, \u003ccode\u003ePyCFunctionWithKeywords\u003c/code\u003e, \u003ccode\u003ePyNoArgsFunction\u003c/code\u003e, \u003ccode\u003ePyCapsule_Destructor\u003c/code\u003e, \u003ccode\u003egetter\u003c/code\u003e, \u003ccode\u003esetter\u003c/code\u003e, \u003ccode\u003ePyOS_sighandler_t\u003c/code\u003e, \u003ccode\u003ePyGILState_STATE\u003c/code\u003e, \u003ccode\u003ePy_UCS4\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e특히 \u003ccode\u003ePy_UNICODE\u003c/code\u003e는 \u003ccode\u003etypedef\u003c/code\u003e로 사용할 수 없습니다. 동일한 Python 버전에서도 동일한 플랫폼에서 \u003ccode\u003ePy_UNICODE\u003c/code\u003e의 다른 정의를 사용할 수 있기 때문입니다 (좁은 또는 넓은 코드 단위를 사용하는지에 따라 다름). Unicode 문자열의 내용에 접근해야 하는 애플리케이션은 이를 \u003ccode\u003ewchar_t\u003c/code\u003e로 변환할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e함수 및 함수와 유사한 매크로 (Functions and function-like Macros)\u003c/h3\u003e\n\u003cp\u003e별도로 제외되지 않는 한 모든 함수를 사용할 수 있습니다. 함수가 문서화되었는지 여부는 중요하지 않습니다.\u003c/p\u003e\n\u003cp\u003e함수와 유사한 매크로 (특히 필드 접근 매크로)는 애플리케이션에서 계속 사용할 수 있지만, 함수 호출로 대체됩니다 (정의가 다양한 \u003ccode\u003e_Check\u003c/code\u003e 매크로와 같이 ABI의 기능만을 참조하는 경우가 아니라면).\u003c/p\u003e\n\u003cp\u003eABI 함수 선언은 매개변수나 반환 타입을 변경하지 않습니다. 시그니처 변경이 필요한 경우 새로운 함수가 도입됩니다. 새 함수가 소스 호환성이 있다면 (예: 반환 타입만 변경되는 경우), 애플리케이션이 재컴파일될 때 새 함수로 호출을 리디렉션하기 위해 별칭 매크로가 추가될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이전 함수의 계속된 제공이 불가능할 경우, 사용 중단(deprecated) 후 제거될 수 있으며, 해당 함수를 사용하는 애플리케이션은 작동을 멈출 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e제외된 함수 (Excluded Functions)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e_Py\u003c/code\u003e로 시작하는 모든 함수는 애플리케이션에서 사용할 수 없습니다. 또한, \u003ccode\u003enode*\u003c/code\u003e와 같이 애플리케이션에서 사용할 수 없는 매개변수 유형을 예상하는 모든 함수 (예: \u003ccode\u003ePyAST_FromNode\u003c/code\u003e)는 ABI에서 제외됩니다.\u003c/p\u003e\n\u003cp\u003e다음 헤더 파일에 선언된 함수는 ABI의 일부가 아닙니다:\r\n\u003ccode\u003ebytes_methods.h\u003c/code\u003e, \u003ccode\u003ecellobject.h\u003c/code\u003e, \u003ccode\u003eclassobject.h\u003c/code\u003e, \u003ccode\u003ecode.h\u003c/code\u003e, \u003ccode\u003ecompile.h\u003c/code\u003e, \u003ccode\u003edatetime.h\u003c/code\u003e, \u003ccode\u003edtoa.h\u003c/code\u003e, \u003ccode\u003eframeobject.h\u003c/code\u003e, \u003ccode\u003efuncobject.h\u003c/code\u003e, \u003ccode\u003egenobject.h\u003c/code\u003e, \u003ccode\u003elongintrepr.h\u003c/code\u003e, \u003ccode\u003eparsetok.h\u003c/code\u003e, \u003ccode\u003epyarena.h\u003c/code\u003e, \u003ccode\u003epyatomic.h\u003c/code\u003e, \u003ccode\u003epyctype.h\u003c/code\u003e, \u003ccode\u003epydebug.h\u003c/code\u003e, \u003ccode\u003epytime.h\u003c/code\u003e, \u003ccode\u003esymtable.h\u003c/code\u003e, \u003ccode\u003etoken.h\u003c/code\u003e, \u003ccode\u003eucnhash.h\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e또한, Windows에서 Microsoft C 런타임 DLL의 특정 버전에 의존하는 것을 피하기 위해 \u003ccode\u003eFILE*\u003c/code\u003e를 예상하는 함수는 ABI의 일부가 아닙니다.\u003c/p\u003e\n\u003cp\u003e모듈 및 타입 초기화/종료 함수 (\u003ccode\u003ePyByteArray_Init\u003c/code\u003e, \u003ccode\u003ePyOS_FiniInterrupts\u003c/code\u003e 및 \u003ccode\u003e_Fini\u003c/code\u003e 또는 \u003ccode\u003e_ClearFreeList\u003c/code\u003e로 끝나는 모든 함수)는 사용할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e인터프리터 구현 세부 사항을 다루는 여러 함수도 사용할 수 없습니다:\r\n\u003ccode\u003ePyInterpreterState_Head\u003c/code\u003e, \u003ccode\u003ePyInterpreterState_Next\u003c/code\u003e, \u003ccode\u003ePyInterpreterState_ThreadHead\u003c/code\u003e, \u003ccode\u003ePyThreadState_Next\u003c/code\u003e, \u003ccode\u003ePy_SubversionRevision\u003c/code\u003e, \u003ccode\u003ePy_SubversionShortBranch\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyStructSequence_InitType\u003c/code\u003e는 호출자가 정적 타입 객체를 제공해야 하므로 사용할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePy_FatalError\u003c/code\u003e는 \u003ccode\u003epydebug.h\u003c/code\u003e에서 다른 헤더 파일 (예: \u003ccode\u003epyerrors.h\u003c/code\u003e)로 이동됩니다.\u003c/p\u003e\n\u003cp\u003e사용 가능한 함수의 정확한 목록은 \u003ccode\u003epython3.dll\u003c/code\u003e에 대한 Windows 모듈 정의 파일에 나와 있습니다.\u003c/p\u003e\n\u003ch3\u003e전역 변수 (Global Variables)\u003c/h3\u003e\n\u003cp\u003e타입과 예외를 나타내는 전역 변수는 애플리케이션에서 사용할 수 있습니다. 또한, 매크로에서 참조되는 선택된 전역 변수 (\u003ccode\u003ePy_True\u003c/code\u003e 및 \u003ccode\u003ePy_False\u003c/code\u003e 등)도 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e전역 변수 정의의 전체 목록은 \u003ccode\u003epython3.def\u003c/code\u003e 파일에 나와 있으며, \u003ccode\u003eDATA\u003c/code\u003e로 선언된 항목이 변수를 나타냅니다.\u003c/p\u003e\n\u003ch3\u003e기타 매크로 (Other Macros)\u003c/h3\u003e\n\u003cp\u003e심볼릭 상수를 정의하는 모든 매크로는 애플리케이션에서 사용할 수 있으며, 숫자 값은 변경되지 않습니다.\r\n또한, 다음 매크로를 사용할 수 있습니다:\r\n\u003ccode\u003ePy_BEGIN_ALLOW_THREADS\u003c/code\u003e, \u003ccode\u003ePy_BLOCK_THREADS\u003c/code\u003e, \u003ccode\u003ePy_UNBLOCK_THREADS\u003c/code\u003e, \u003ccode\u003ePy_END_ALLOW_THREADS\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003e버퍼 인터페이스 (The Buffer Interface)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ePy_buffer\u003c/code\u003e 구조체의 안정성이 현재로서는 명확하지 않으므로, 버퍼 인터페이스 (\u003ccode\u003ePy_buffer\u003c/code\u003e 타입, \u003ccode\u003ebf_getbuffer\u003c/code\u003e 및 \u003ccode\u003ebf_releasebuffer\u003c/code\u003e 타입 슬롯 등)는 ABI에서 생략되었습니다. 향후 릴리스에서 ABI에 포함될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e시그니처 변경 (Signature Changes)\u003c/h3\u003e\n\u003cp\u003e현재 특정 구조체를 예상하는 여러 함수가 있지만, 호출자는 일반적으로 \u003ccode\u003ePyObject*\u003c/code\u003e를 사용합니다. 이 함수들은 매개변수로 \u003ccode\u003ePyObject*\u003c/code\u003e를 예상하도록 변경되었습니다. 이는 현재 매개변수 타입으로 명시적 캐스팅을 하는 애플리케이션에서 경고를 유발할 수 있습니다. 해당 함수는 \u003ccode\u003ePySlice_GetIndices\u003c/code\u003e, \u003ccode\u003ePySlice_GetIndicesEx\u003c/code\u003e, \u003ccode\u003ePyUnicode_AsWideChar\u003c/code\u003e, \u003ccode\u003ePyEval_EvalCode\u003c/code\u003e입니다.\u003c/p\u003e\n\u003ch3\u003e링키지 (Linkage)\u003c/h3\u003e\n\u003cp\u003eWindows에서는 애플리케이션이 \u003ccode\u003epython3.dll\u003c/code\u003e에 링크해야 하며, 임포트 라이브러리 \u003ccode\u003epython3.lib\u003c/code\u003e가 제공될 것입니다. 이 DLL은 \u003ccode\u003e/export\u003c/code\u003e 링커 옵션을 통해 모든 API 함수를 전체 인터프리터 DLL, 즉 \u003ccode\u003epython3y.dll\u003c/code\u003e로 리디렉션합니다.\u003c/p\u003e\n\u003cp\u003eUnix 시스템에서는 ABI가 일반적으로 Python 실행 파일 자체에 의해 제공됩니다. 확장 모듈이 \u003ccode\u003ePy_LIMITED_API\u003c/code\u003e로 컴파일된 경우, \u003ccode\u003ePyModule_Create\u003c/code\u003e는 API 버전으로 3을 전달하도록 변경됩니다. API 버전에 대한 버전 검사는 3 또는 현재 \u003ccode\u003ePYTHON_API_VERSION\u003c/code\u003e을 준수하는 것으로 받아들입니다. Python이 공유 라이브러리로 컴파일된 경우, \u003ccode\u003elibpython3.so\u003c/code\u003e와 \u003ccode\u003elibpython3.y.so\u003c/code\u003e 둘 다로 설치됩니다. 이 PEP를 따르는 애플리케이션은 전자에 링크해야 합니다 (확장 모듈은 \u003ccode\u003elibpython\u003c/code\u003e 공유 객체 없이 런타임 링킹에 의존하여 계속 링크할 수 있음). ABI 버전은 \u003ccode\u003ePYTHON_ABI_VERSION\u003c/code\u003e으로 심볼릭하게 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한 Unix에서는 확장 모듈 파일 이름에 \u003ccode\u003eabi\u0026#x3C;PYTHON_ABI_VERSION\u003e\u003c/code\u003e 태그가 허용됩니다. 이러한 방식으로 이름이 지정된 파일이 실제로 제한된 API로 제한되는지에 대한 검사는 수행되지 않으며, \u003ccode\u003edistutils\u003c/code\u003e 코드 동결로 인해 \u003ccode\u003edistutils\u003c/code\u003e에 이러한 파일 빌드 지원이 추가되지 않을 것입니다.\u003c/p\u003e\n\u003ch2\u003e구현 전략 (Implementation Strategy)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 브랜치에서 구현되어 사용자가 모듈이 ABI를 준수하는지 확인할 수 있도록 합니다. 사용자가 타입 정의를 다시 작성할 필요가 없도록, 타입 정의를 포함하는 C 소스 코드를 변환하는 스크립트가 제공될 것입니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1098,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 384 - Defining a Stable ABI\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 21:04:32+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>