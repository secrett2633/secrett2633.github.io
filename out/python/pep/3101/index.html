<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 3101 - Advanced String Formatting</h1><div class="page__meta"><time dateTime="2025-09-27 14:16:14+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-3101/">PEP 3101 - Advanced String Formatting</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 16-Apr-2006</p>
</blockquote>
<h2>PEP 3101 – 고급 문자열 포매팅</h2>
<h3>초록 (Abstract)</h3>
<p>이 PEP(Python Enhancement Proposal)는 기존의 '%' 문자열 포매팅 연산자를 대체하기 위한 새로운 내장 문자열 포매팅 시스템을 제안합니다.</p>
<h3>도입 배경 (Rationale)</h3>
<p>Python은 현재 두 가지 문자열 보간(interpolation) 방식을 제공합니다:</p>
<ol>
<li>문자열에 대한 '%' 연산자.</li>
<li><code>string.Template</code> 모듈.</li>
</ol>
<p>이 PEP의 주요 범위는 내장 문자열 포매팅 연산자(즉, 내장 문자열 타입의 메서드)에 대한 제안과 관련이 있습니다.</p>
<p>'%' 연산자는 이항 연산자(binary operator)라는 한계가 있으며, 따라서 최대 두 개의 인자만 취할 수 있습니다. 그중 하나는 이미 포맷 문자열(format string)에 할당되어, 나머지 모든 변수는 남은 인자 하나에 담겨야 합니다. 현재 관행은 두 번째 인자로 딕셔너리(dictionary)나 튜플(tuple)을 사용하는 것이지만, 많은 사람들이 지적했듯이 이것은 유연성이 부족합니다. "전부 또는 전무(all or nothing)" 접근 방식(즉, 위치 인자만 사용하거나, 이름 있는(named) 인자만 사용해야 하는 것)은 너무 제약적이라고 여겨집니다.</p>
<p>이 제안과 <code>string.Template</code> 사이에 일부 중복이 있지만, 각각이 서로 다른 요구를 충족하며 하나가 다른 하나를 불필요하게 만들지 않는다고 여겨집니다. 이 제안은 '%' 연산자처럼 한 번만 사용되는 작은 문자열에 효율적인 메커니즘을 위한 것입니다. 따라서 예를 들어, 문자열을 템플릿으로 컴파일하는 것은 이 제안에서 고려되지 않지만, 제안은 포맷 문자열과 API를 정의하여 효율적인 템플릿 패키지가 문법과 일부 기본 포매팅 코드를 재사용할 수 있도록 합니다.</p>
<h3>명세 (Specification)</h3>
<p>이 명세는 다음 부분들로 구성됩니다:</p>
<ul>
<li>내장 <code>str</code> 클래스에 추가될 새로운 포매팅 메서드의 명세.</li>
<li>기본 포매팅 엔진을 추가 옵션과 함께 사용할 수 있도록 <code>string</code> 모듈에 추가될 함수 및 플래그 값의 명세.</li>
<li>포맷 문자열을 위한 새로운 문법의 명세.</li>
<li>객체의 포매팅 및 변환을 제어하는 새로운 특수 메서드 집합의 명세.</li>
<li>사용자 정의 포매팅 클래스를 위한 API 명세.</li>
<li>포매팅 오류 처리 방식의 명세.</li>
</ul>
<p><strong>문자열 인코딩에 대한 참고:</strong> Python 3.0 맥락에서 이 PEP를 논의할 때는 모든 문자열이 유니코드(unicode) 문자열이며, 이 문서에서 'string'이라는 단어는 일반적으로 Python 3.0 문자열(Python 2.x의 <code>unicode</code> 객체와 동일)을 지칭한다고 가정합니다.</p>
<p>Python 2.x 맥락에서는 이 문서에서 'string'이라는 단어가 일반 문자열 객체 또는 유니코드 객체일 수 있는 객체를 지칭합니다. 이 PEP에 설명된 모든 함수 호출 인터페이스는 문자열과 유니코드 객체 모두에 사용될 수 있으며, 모든 경우에 올바른 출력 문자열 타입을 추론하기에 충분한 정보가 있습니다 (즉, 두 개의 분리된 API가 필요하지 않습니다). 모든 경우에 포맷 문자열의 타입이 우선합니다. 즉, 변환 결과는 항상 입력 포맷 문자열과 동일한 문자 표현을 포함하는 객체가 됩니다.</p>
<h4>문자열 메서드 (String Methods)</h4>
<p>내장 <code>str</code> 클래스(및 2.6 버전의 <code>unicode</code> 클래스)는 임의의 수의 위치(positional) 및 키워드(keyword) 인자를 받는 새로운 <code>format</code> 메서드를 얻게 됩니다:</p>
<pre><code class="language-python">"The story of {0}, {1}, and {c}".format(a, b, c=d)
</code></pre>
<p>포맷 문자열 내에서 각 위치 인자는 0부터 시작하는 숫자로 식별됩니다. 위 예시에서 'a'는 인자 0이고 'b'는 인자 1입니다. 각 키워드 인자는 해당 키워드 이름으로 식별되므로, 위 예시에서 'c'는 세 번째 인자를 참조하는 데 사용됩니다.</p>
<p>또한, 단일 값을 포매팅하는 전역 내장 함수 <code>format</code>이 있습니다:</p>
<pre><code class="language-python">print(format(10.0, "7.3g"))
</code></pre>
<p>이 함수는 나중에 설명됩니다.</p>
<h4>포맷 문자열 (Format Strings)</h4>
<p>포맷 문자열은 문자 데이터와 마크업이 혼합되어 구성됩니다.</p>
<ul>
<li><strong>문자 데이터(Character data):</strong> 포맷 문자열에서 출력 문자열로 변경 없이 전달되는 데이터입니다.</li>
<li><strong>마크업(Markup):</strong> 포맷 문자열에서 출력으로 직접 전달되지 않지만, 대신 포맷 엔진에 출력 문자열에서 마크업 대신 무엇을 넣어야 하는지 설명하는 '치환 필드(replacement fields)'를 정의하는 데 사용됩니다.</li>
</ul>
<p>중괄호(<code>{}</code>)는 문자열 내에서 치환 필드를 나타내는 데 사용됩니다:</p>
<pre><code class="language-python">"My name is {0}".format('Fred')
</code></pre>
<p>이것의 결과는 다음 문자열이 됩니다:</p>
<pre><code>"My name is Fred"
</code></pre>
<p>중괄호는 이중으로 사용하여 이스케이프(escape)할 수 있습니다:</p>
<pre><code class="language-python">"My name is {0} :-{{}}".format('Fred')
</code></pre>
<p>이것은 다음을 생성합니다:</p>
<pre><code>"My name is Fred :-{}"
</code></pre>
<p>중괄호 안의 요소는 '필드(field)'라고 불립니다. 필드는 '필드 이름(field name)'(단순하거나 복합적일 수 있음)과 선택적인 '포맷 지정자(format specifier)'로 구성됩니다.</p>
<h4>단순 및 복합 필드 이름 (Simple and Compound Field Names)</h4>
<p>단순 필드 이름은 이름 또는 숫자입니다. 숫자이면 유효한 10진수 정수여야 하고, 이름이면 유효한 Python 식별자(identifier)여야 합니다. 숫자는 위치 인자를 식별하는 데 사용되고, 이름은 키워드 인자를 식별하는 데 사용됩니다.</p>
<p>복합 필드 이름은 표현식에서 여러 단순 필드 이름의 조합입니다:</p>
<pre><code class="language-python">"My name is {0.name}".format(open('out.txt', 'w'))
</code></pre>
<p>이 예시는 필드 표현식에서 <code>getattr</code> 또는 '점(dot)' 연산자를 사용하는 것을 보여줍니다. 점 연산자는 입력 값의 속성(attribute)을 필드 값으로 지정할 수 있도록 합니다.</p>
<p>다른 일부 프로그래밍 언어와 달리, 포맷 문자열에 임의의 표현식(arbitrary expressions)을 포함할 수 없습니다. 이것은 의도적인 설계입니다. 사용할 수 있는 표현식의 종류는 의도적으로 제한됩니다. 두 가지 연산자만 지원됩니다: '.' (<code>getattr</code>) 연산자, 그리고 '[]' (<code>getitem</code>) 연산자. 이러한 연산자를 허용하는 이유는 일반적으로 비정상적인 코드가 아닌 경우 부작용(side effects)이 없기 때문입니다.</p>
<p><code>getitem</code> 문법의 예시:</p>
<pre><code class="language-python">"My name is {0[name]}".format(dict(name='Fred'))
</code></pre>
<p>포맷 문자열 내에서 <code>getitem</code>의 사용은 일반적인 사용법보다 훨씬 제한적이라는 점에 유의해야 합니다. 위 예시에서 문자열 'name'은 실제로 리터럴 문자열 'name'이며, 'name'이라는 변수가 아닙니다. 항목 키를 파싱하는 규칙은 매우 간단합니다. 숫자로 시작하면 숫자로 취급하고, 그렇지 않으면 문자열로 사용됩니다.</p>
<p>키는 따옴표로 구분되지 않으므로 포맷 문자열 내에서 임의의 딕셔너리 키(예: 문자열 "10" 또는 ":-]")를 지정할 수 없습니다.</p>
<p><strong>구현 참고:</strong> 이 제안의 구현은 단순하거나 점으로 구분된 이름이 유효한 Python 식별자여야 한다는 규칙을 강제할 필요가 없습니다. 대신, 기본 객체의 <code>getattr</code> 함수가 식별자가 유효하지 않은 경우 예외를 발생시키도록 할 것입니다. <code>str.format()</code> 함수는 식별자가 언제 "완료"되는지 (즉, '.', ']', '}' 등을 찾아서) 파악하려고만 시도하는 최소한의 파서(parser)를 가질 것입니다.</p>
<h4>포맷 지정자 (Format Specifiers)</h4>
<p>각 필드는 해당 필드의 형식을 조정하는 데 사용될 수 있는 선택적인 '포맷 지정자' 집합을 지정할 수 있습니다. 포맷 지정자는 콜론(<code>:</code>) 문자로 구분되어 필드 이름 뒤에 옵니다:</p>
<pre><code class="language-python">"My name is {0:8}".format('Fred')
</code></pre>
<p>포맷 지정자의 의미와 문법은 포매팅되는 객체의 타입에 따라 다르지만, 이를 오버라이드하지 않는 모든 객체에 사용되는 표준 포맷 지정자 집합이 있습니다.</p>
<p>포맷 지정자는 그 자체로 치환 필드를 포함할 수 있습니다. 예를 들어, 필드 너비가 그 자체로 매개변수인 필드는 다음과 같이 지정할 수 있습니다:</p>
<pre><code class="language-python">"{0:{1}}".format(a, b)
</code></pre>
<p>이러한 '내부' 치환 필드는 치환 필드의 포맷 지정자 부분에서만 발생할 수 있습니다. 내부 치환 필드는 그 자체로 포맷 지정자를 가질 수 없습니다. 이는 또한 치환 필드가 임의의 깊이로 중첩될 수 없음을 의미합니다.</p>
<p>끝에 있는 이중 '}}'는 일반적으로 이스케이프되지만, 이 경우에는 이스케이프되지 않습니다. 그 이유는 이스케이프를 위한 '{{' 및 '}}' 문법은 포맷 필드 외부에서 사용될 때만 적용되기 때문입니다. 포맷 필드 내에서는 중괄호 문자가 항상 일반적인 의미를 가집니다.</p>
<p>클래스가 표준 포맷 지정자를 오버라이드할 수 있으므로 포맷 지정자의 문법은 개방형입니다. 이러한 경우 <code>str.format()</code> 메서드는 첫 번째 콜론과 일치하는 중괄호 사이의 모든 문자를 관련 기본 포매팅 메서드로 전달하기만 합니다.</p>
<h4>표준 포맷 지정자 (Standard Format Specifiers)</h4>
<p>객체가 자체 포맷 지정자를 정의하지 않으면, 표준 포맷 지정자 집합이 사용됩니다. 이들은 기존 '%' 연산자에서 사용되는 포맷 지정자와 개념적으로 유사하지만, 여러 가지 차이점도 있습니다.</p>
<p>표준 포맷 지정자의 일반적인 형식은 다음과 같습니다:</p>
<pre><code>[[fill]align][sign][#][0][minimumwidth][.precision][type]
</code></pre>
<p>대괄호(<code>[]</code>)는 선택적인 요소를 나타냅니다.</p>
<p>선택적 정렬(align) 플래그는 다음 중 하나일 수 있습니다:</p>
<ul>
<li><code>'&#x3C;'</code>: 사용 가능한 공간 내에서 필드를 왼쪽 정렬하도록 강제합니다 (이것이 기본값입니다).</li>
<li><code>'>'</code>: 사용 가능한 공간 내에서 필드를 오른쪽 정렬하도록 강제합니다.</li>
<li><code>'='</code>: 패딩을 부호(있는 경우) 뒤에 오지만 숫자 앞에 오도록 강제합니다. 이는 <code>'+000000120'</code> 형태의 필드를 인쇄하는 데 사용됩니다. 이 정렬 옵션은 숫자 타입에만 유효합니다.</li>
<li><code>'^'</code>: 사용 가능한 공간 내에서 필드를 가운데 정렬하도록 강제합니다.</li>
</ul>
<p>최소 필드 너비가 정의되지 않으면 필드 너비는 항상 데이터를 채우는 크기와 동일하므로 이 경우 정렬 옵션은 의미가 없습니다.</p>
<p>선택적 'fill' 문자는 필드를 최소 너비로 채우는 데 사용될 문자를 정의합니다. fill 문자가 있는 경우 정렬 플래그 뒤에 와야 합니다.</p>
<p>'sign' 옵션은 숫자 타입에만 유효하며 다음 중 하나일 수 있습니다:</p>
<ul>
<li><code>'+'</code>: 양수와 음수 모두에 부호가 사용되어야 함을 나타냅니다.</li>
<li><code>'-'</code>: 음수에만 부호가 사용되어야 함을 나타냅니다 (이것이 기본 동작입니다).</li>
<li><code>' '</code>: 양수에 선행 공백이 사용되어야 함을 나타냅니다.</li>
</ul>
<p>'#' 문자가 있으면 정수는 포매팅을 위해 '대체 형식(alternate form)'을 사용합니다. 이는 이진수, 8진수, 16진수 출력이 각각 '0b', '0o', '0x'로 접두사가 붙는다는 의미입니다.</p>
<p><code>width</code>는 최소 필드 너비를 정의하는 10진수 정수입니다. 지정하지 않으면 필드 너비는 내용에 따라 결정됩니다.</p>
<p>너비 필드 앞에 0(<code>'0'</code>) 문자가 오면 제로 패딩(zero-padding)이 활성화됩니다. 이는 정렬 타입이 <code>'='</code>이고 채움 문자가 <code>'0'</code>인 것과 동일합니다.</p>
<p><code>precision</code>은 부동 소수점 변환에서 소수점 이하 몇 자리를 표시해야 하는지를 나타내는 10진수입니다. 비숫자 타입의 경우 이 필드는 최대 필드 크기(즉, 필드 내용에서 몇 문자가 사용될지)를 나타냅니다. 정수 변환의 경우 precision은 무시됩니다.</p>
<p>마지막으로, <code>type</code>은 데이터가 어떻게 표현되어야 할지를 결정합니다.</p>
<p>사용 가능한 정수(Integer) 표현 타입은 다음과 같습니다:</p>
<ul>
<li><code>'b'</code>: 이진수(Binary). 숫자를 2진수로 출력합니다.</li>
<li><code>'c'</code>: 문자(Character). 숫자를 출력하기 전에 해당 유니코드 문자로 변환합니다.</li>
<li><code>'d'</code>: 10진수 정수(Decimal Integer). 숫자를 10진수로 출력합니다.</li>
<li><code>'o'</code>: 8진수 형식(Octal format). 숫자를 8진수로 출력합니다.</li>
<li><code>'x'</code>: 16진수 형식(Hex format). 숫자를 16진수로 출력하며, 9를 초과하는 숫자는 소문자로 표시합니다.</li>
<li><code>'X'</code>: 16진수 형식(Hex format). 숫자를 16진수로 출력하며, 9를 초과하는 숫자는 대문자로 표시합니다.</li>
<li><code>'n'</code>: 숫자(Number). <code>'d'</code>와 동일하지만, 현재 로케일(locale) 설정을 사용하여 적절한 숫자 구분 기호를 삽입합니다.</li>
<li><code>''</code> (None): <code>'d'</code>와 동일합니다.</li>
</ul>
<p>사용 가능한 부동 소수점(Floating Point) 표현 타입은 다음과 같습니다:</p>
<ul>
<li><code>'e'</code>: 지수 표기법(Exponent notation). 숫자를 과학적 표기법으로 출력하며, 'e' 문자를 사용하여 지수를 나타냅니다.</li>
<li><code>'E'</code>: 지수 표기법(Exponent notation). <code>'e'</code>와 동일하지만 숫자를 대문자로 변환합니다.</li>
<li><code>'f'</code>: 고정 소수점(Fixed point). 숫자를 고정 소수점 숫자로 표시합니다.</li>
<li><code>'F'</code>: 고정 소수점(Fixed point). <code>'f'</code>와 동일하지만 숫자를 대문자로 변환합니다.</li>
<li><code>'g'</code>: 일반 형식(General format). 숫자가 너무 크지 않은 경우 고정 소수점 숫자로 출력하며, 너무 큰 경우 <code>'e'</code> 지수 표기법으로 전환합니다.</li>
<li><code>'G'</code>: 일반 형식(General format). <code>'g'</code>와 동일하지만 숫자가 너무 커지면 <code>'E'</code>로 전환합니다.</li>
<li><code>'n'</code>: 숫자(Number). <code>'g'</code>와 동일하지만, 현재 로케일 설정을 사용하여 적절한 숫자 구분 기호를 삽입합니다.</li>
<li><code>'%'</code>: 백분율(Percentage). 숫자에 100을 곱하고 고정('f') 형식으로 표시한 다음 퍼센트 기호를 붙입니다.</li>
<li><code>''</code> (None): <code>'g'</code>와 유사하지만, 소수점 이하에 최소 한 자리 숫자를 출력합니다.</li>
</ul>
<p>객체는 표준 포맷 지정자를 대체하기 위해 자체 포맷 지정자를 정의할 수 있습니다. 예를 들어, <code>datetime</code> 클래스는 <code>strftime()</code> 함수의 인자와 유사한 포맷 지정자를 가질 수 있습니다:</p>
<pre><code class="language-python">"Today is: {0:%a %b %d %H:%M:%S %Y}".format(datetime.now())
</code></pre>
<p>모든 내장 타입에 대해 빈 포맷 명세는 <code>str(value)</code>와 동일한 결과를 생성합니다. 자체 포맷 지정자를 정의하는 객체도 이 규칙을 따르도록 권장됩니다.</p>
<h4>명시적 변환 플래그 (Explicit Conversion Flag)</h4>
<p>명시적 변환 플래그는 포맷 필드 값을 포매팅하기 전에 변환하는 데 사용됩니다. 이는 타입별 포매팅 동작을 오버라이드하고, 값을 더 일반적인 타입인 것처럼 포매팅하는 데 사용될 수 있습니다. 현재 두 가지 명시적 변환 플래그가 인식됩니다:</p>
<ul>
<li><code>!r</code>: <code>repr()</code>을 사용하여 값을 문자열로 변환합니다.</li>
<li><code>!s</code>: <code>str()</code>을 사용하여 값을 문자열로 변환합니다.</li>
</ul>
<p>이러한 플래그는 포맷 지정자 앞에 위치합니다:</p>
<pre><code class="language-python">"{0!r:20}".format("Hello")
</code></pre>
<p>위 예시에서 문자열 "Hello"는 따옴표와 함께 최소 20자 너비의 필드에 출력됩니다.</p>
<p>사용자 정의 <code>Formatter</code> 클래스는 추가적인 변환 플래그를 정의할 수 있습니다. 내장 포매터는 잘못된 변환 플래그가 지정되면 <code>ValueError</code>를 발생시킵니다.</p>
<h4>타입별 포매팅 제어 (Controlling Formatting on a Per-Type Basis)</h4>
<p>각 Python 타입은 <code>__format__</code> 메서드를 정의하여 해당 인스턴스의 포매팅을 제어할 수 있습니다. <code>__format__</code> 메서드는 포맷 지정자를 해석하고, 값을 포매팅하며, 결과 문자열을 반환하는 역할을 합니다.</p>
<p>새로운 전역 내장 함수 <code>format</code>은 <code>len()</code> 및 <code>str()</code>이 각각의 특수 메서드를 호출하는 방식과 유사하게 이 특수 메서드를 단순히 호출합니다:</p>
<pre><code class="language-python">def format(value, format_spec):
    return value.__format__(format_spec)
</code></pre>
<p>이 함수를 "None" 값으로 호출해도 안전합니다 (Python에서 "None" 값은 객체이며 메서드를 가질 수 있기 때문입니다).</p>
<p><code>str</code>, <code>int</code>, <code>float</code>, <code>object</code>를 포함한 여러 내장 타입은 <code>__format__</code> 메서드를 정의합니다. 이는 이러한 타입 중 하나에서 파생되면 클래스가 자체적으로 포매팅하는 방법을 알게 됨을 의미합니다.</p>
<p><code>object.__format__</code> 메서드는 가장 간단합니다: 단순히 객체를 문자열로 변환한 다음 <code>format</code>을 다시 호출합니다:</p>
<pre><code class="language-python">class object:
    def __format__(self, format_spec):
        return format(str(self), format_spec)
</code></pre>
<p><code>int</code> 및 <code>float</code>의 <code>__format__</code> 메서드는 포맷 지정자를 기반으로 숫자 포매팅을 수행합니다. 경우에 따라 이러한 포매팅 연산은 다른 타입으로 위임될 수 있습니다. 예를 들어, <code>int</code> 포매터가 <code>'f'</code> (즉, 'float') 포맷 타입을 보는 경우, 단순히 값을 float으로 캐스팅하고 <code>format()</code>을 다시 호출할 수 있습니다.</p>
<p>어떤 클래스든 <code>__format__</code> 메서드를 오버라이드하여 해당 타입에 대한 사용자 정의 포매팅을 제공할 수 있습니다:</p>
<pre><code class="language-python">class AST:
    def __format__(self, format_spec):
        ...
</code></pre>
<p><strong>Python 2.x에 대한 참고:</strong> <code>format_spec</code> 인자는 원본 포맷 문자열의 타입에 따라 문자열 객체 또는 유니코드 객체가 됩니다. <code>__format__</code> 메서드는 <code>specifiers</code> 매개변수의 타입을 테스트하여 문자열 또는 유니코드 객체를 반환할지 결정해야 합니다. 올바른 타입의 객체를 반환하는 것은 <code>__format__</code> 메서드의 책임입니다.</p>
<p>위에서 언급된 '명시적 변환' 플래그는 <code>__format__</code> 메서드에 전달되지 않습니다. 대신, 플래그에 의해 지정된 변환은 <code>__format__</code>을 호출하기 전에 수행될 것으로 예상됩니다.</p>
<h4>사용자 정의 포매팅 (User-Defined Formatting)</h4>
<p>타입별로 필드의 포매팅을 사용자 정의하는 것만으로는 충분하지 않을 때가 있을 것입니다. 예를 들어, 값이 사용 가능한 공간에 맞지 않을 때 '#' 해시 마크를 표시하는 스프레드시트 애플리케이션이 있습니다.</p>
<p>더 강력하고 유연한 포매팅을 위해, <code>string</code> 모듈에 있는 <code>Formatter</code> 클래스를 통해 기본 포맷 엔진에 접근할 수 있습니다. 이 클래스는 일반 <code>str.format</code> 메서드를 통해 접근할 수 없는 추가 옵션을 취합니다.</p>
<p>애플리케이션은 <code>Formatter</code> 클래스를 서브클래싱하여 자체 사용자 정의 포매팅 동작을 생성할 수 있습니다.</p>
<p>이 PEP는 <code>Formatter</code> 클래스에 의해 정의된 모든 메서드와 속성을 정확하게 명세하려고 시도하지 않습니다. 대신, 그것들은 초기 구현에서 정의되고 문서화될 것입니다. 그러나 이 PEP는 <code>Formatter</code> 클래스에 대한 일반적인 요구 사항을 명세할 것이며, 이는 아래에 나열되어 있습니다.</p>
<p><code>string.format()</code>이 포매팅을 위해 <code>Formatter</code> 클래스를 직접 사용하지 않더라도, 둘 다 동일한 기본 구현을 사용합니다. <code>string.format()</code>이 <code>Formatter</code> 클래스를 직접 사용하지 않는 이유는 "string"이 내장 타입이므로 모든 메서드가 C로 구현되어야 하는 반면, <code>Formatter</code>는 Python 클래스이기 때문입니다. <code>Formatter</code>는 <code>string.format()</code>에서 사용되는 것과 동일한 C 함수에 대한 확장 가능한 래퍼(wrapper)를 제공합니다.</p>
<h4>Formatter 메서드 (Formatter Methods)</h4>
<p><code>Formatter</code> 클래스는 초기화 인자를 받지 않습니다:</p>
<pre><code class="language-python">fmt = Formatter()
</code></pre>
<p><code>Formatter</code> 클래스의 공개 API 메서드는 다음과 같습니다:</p>
<ul>
<li><code>format(format_string, *args, **kwargs)</code></li>
<li><code>vformat(format_string, args, kwargs)</code></li>
</ul>
<p><code>format</code>은 주요 API 메서드입니다. 이는 포맷 템플릿과 임의의 위치 및 키워드 인자 집합을 받습니다. <code>format</code>은 <code>vformat</code>을 호출하는 단순한 래퍼입니다.</p>
<p><code>vformat</code>은 실제 포매팅 작업을 수행하는 함수입니다. 이는 <code>*args</code> 및 <code>**kwds</code> 문법을 사용하여 딕셔너리를 개별 인자로 언패킹(unpacking)하고 다시 패킹(repacking)하는 대신, 미리 정의된 인자 딕셔너리를 전달하려는 경우를 위해 별도의 함수로 노출됩니다. <code>vformat</code>은 포맷 템플릿 문자열을 문자 데이터와 치환 필드로 분할하는 작업을 수행합니다. 적절하게 <code>get_positional</code> 및 <code>get_index</code> 메서드를 호출합니다 (아래 설명).</p>
<p><code>Formatter</code>는 다음 오버라이드 가능한 메서드를 정의합니다:</p>
<ul>
<li><code>get_value(key, args, kwargs)</code></li>
<li><code>check_unused_args(used_args, args, kwargs)</code></li>
<li><code>format_field(value, format_spec)</code></li>
</ul>
<p><code>get_value</code>는 주어진 필드 값을 검색하는 데 사용됩니다. <code>key</code> 인자는 정수 또는 문자열이 됩니다. 정수이면 <code>args</code>의 위치 인자 인덱스를 나타내고, 문자열이면 <code>kwargs</code>의 이름 있는 인자를 나타냅니다.</p>
<p><code>args</code> 매개변수는 <code>vformat</code>에 대한 위치 인자 리스트로 설정되고, <code>kwargs</code> 매개변수는 위치 인자의 딕셔너리로 설정됩니다.</p>
<p>복합 필드 이름의 경우, 이러한 함수는 필드 이름의 첫 번째 구성 요소에 대해서만 호출됩니다. 후속 구성 요소는 일반 속성 및 인덱싱(indexing) 연산을 통해 처리됩니다.</p>
<p>예를 들어, 필드 표현식 '0.name'은 'key' 인자로 0을 사용하여 <code>get_value</code>가 호출되도록 합니다. 'name' 속성은 <code>get_value</code>가 반환된 후 내장 <code>getattr</code> 함수를 호출하여 찾아집니다.</p>
<p>인덱스나 키워드가 존재하지 않는 항목을 참조하면 <code>IndexError</code>/<code>KeyError</code>가 발생해야 합니다.</p>
<p><code>check_unused_args</code>는 원하는 경우 사용되지 않는 인자(unused arguments) 검사를 구현하는 데 사용됩니다. 이 함수의 인자는 포맷 문자열에서 실제로 참조된 모든 인자 키(위치 인자의 경우 정수, 이름 있는 인자의 경우 문자열)의 집합과 <code>vformat</code>에 전달된 <code>args</code> 및 <code>kwargs</code>에 대한 참조입니다. 사용되지 않는 인자 집합은 이러한 매개변수로부터 계산될 수 있습니다. <code>check_unused_args</code>는 검사가 실패하면 예외를 발생시키는 것으로 가정합니다.</p>
<p><code>format_field</code>는 단순히 전역 <code>format</code> 내장 함수를 호출합니다. 이 메서드는 서브클래스가 이를 오버라이드할 수 있도록 제공됩니다.</p>
<p>이러한 함수들이 서로 어떻게 관련되는지 더 잘 이해하기 위해 <code>vformat</code>의 일반적인 동작을 설명하는 의사 코드(pseudocode)는 다음과 같습니다:</p>
<pre><code class="language-python">def vformat(format_string, args, kwargs):
    # 출력 버퍼 및 사용된 인자 집합
    buffer = StringIO.StringIO()
    used_args = set()

    # 토큰은 포맷 필드 또는 리터럴 문자열입니다
    for token in self.parse(format_string):
        if is_format_field(token):
            # 토큰을 필드 값과 포맷 지정자로 분할
            field_spec, _, format_spec = token.partition(":")
            # 명시적 타입 변환 확인
            explicit, _, field_spec = field_spec.rpartition("!")

            # 'first_part'는 첫 번째 '.' 또는 '[' 이전 부분입니다.
            # 'get_first_part'가 문법에 따라 int 또는 string을 반환한다고 가정합니다.
            first_part = get_first_part(field_spec)
            value = self.get_value(first_part, args, kwargs)

            # 이 인자를 사용했다는 사실을 기록
            used_args.add(first_part)

            # [subfield] 또는 .subfield 처리. 'components'가 첫 번째 부분을
            # 제외한 다양한 서브필드의 이터레이터(iterator)를 반환한다고 가정합니다.
            for comp in components(field_spec):
                value = resolve_subfield(value, comp)

            # 명시적 타입 변환 처리
            if explicit == 'r':
                value = repr(value)
            elif explicit == 's':
                value = str(value)

            # 전역 'format' 함수를 호출하고 변환된 값을 출력 버퍼에 씁니다.
            buffer.write(self.format_field(value, format_spec))
        else:
            buffer.write(token)

    self.check_unused_args(used_args, args, kwargs)
    return buffer.getvalue()
</code></pre>
<p><code>Formatter</code> 클래스의 실제 알고리즘(C로 구현될 것임)은 여기에 제시된 것과 다를 수 있다는 점에 유의하십시오. (실제 구현은 '클래스'가 아닐 가능성이 높습니다. 오히려 <code>vformat</code>은 다른 오버라이드 가능한 메서드를 인자로 받는 C 함수를 호출할 수 있습니다.) 이 코드 예제의 주요 목적은 오버라이드 가능한 메서드가 호출되는 순서를 설명하는 것입니다.</p>
<h4>포매터 사용자 정의 (Customizing Formatters)</h4>
<p>이 섹션에서는 <code>Formatter</code> 객체를 사용자 정의하는 몇 가지 일반적인 방법을 설명합니다.</p>
<p>대체 포맷-문자열 문법을 지원하기 위해 <code>vformat</code> 메서드를 오버라이드하여 포맷 문자열이 파싱되는 방식을 변경할 수 있습니다.</p>
<p>일반적인 요구 사항 중 하나는 '기본(default)' 네임스페이스(namespace)를 지원하는 것입니다. 이렇게 하면 <code>format()</code> 메서드에 키워드 인자를 전달할 필요 없이 기존 네임스페이스의 값을 사용할 수 있습니다. 이는 다음과 같이 <code>get_value()</code>를 오버라이드하여 쉽게 수행할 수 있습니다:</p>
<pre><code class="language-python">class NamespaceFormatter(Formatter):
    def __init__(self, namespace={}):
        Formatter.__init__(self)
        self.namespace = namespace

    def get_value(self, key, args, kwds):
        if isinstance(key, str):
            try:
                # 명시적으로 전달된 인자를 먼저 확인
                return kwds[key]
            except KeyError:
                return self.namespace[key]
        else:
            Formatter.get_value(key, args, kwds)
</code></pre>
<p>이를 사용하여 예를 들어 전역 변수에 접근할 수 있는 포매팅 함수를 쉽게 만들 수 있습니다:</p>
<pre><code class="language-python">fmt = NamespaceFormatter(globals())
greeting = "hello"
print(fmt.format("{greeting}, world!"))
</code></pre>
<p><code>locals()</code> 딕셔너리를 사용하여 로컬 딕셔너리에 접근하는 유사한 기술을 사용할 수 있습니다.</p>
<p>호출 스택(calling stack)을 스누핑(snooping)하여 로컬 변수와 전역 변수 모두에 자동으로 접근할 수 있는 '스마트' 네임스페이스 포매터를 만드는 것도 가능합니다. Python의 다른 버전과의 호환성 필요성 때문에 이러한 기능은 표준 라이브러리에 포함되지 않겠지만, 누군가가 이를 위한 레시피(recipe)를 만들고 게시할 것으로 예상됩니다.</p>
<p>또 다른 유형의 사용자 정의는 <code>format_field</code> 메서드를 오버라이드하여 내장 타입이 포매팅되는 방식을 변경하는 것입니다. (내장 타입이 아닌 경우, 해당 타입에 <code>__format__</code> 특수 메서드를 정의하면 됩니다.) 예를 들어, 필요할 때 과학적 표기법으로 출력하도록 숫자의 포매팅을 오버라이드할 수 있습니다.</p>
<h4>오류 처리 (Error handling)</h4>
<p>포매팅 중에 발생할 수 있는 예외는 두 가지 종류입니다: 포매터 코드 자체에서 생성된 예외와 사용자 코드(예: 필드 객체의 <code>getattr</code> 함수)에서 생성된 예외.</p>
<p>일반적으로 포매터 코드 자체에서 생성된 예외는 <code>ValueError</code> 유형입니다. 즉, 포맷 문자열의 실제 "값"에 오류가 있습니다. (항상 그런 것은 아닙니다. 예를 들어, <code>string.format()</code> 함수에 첫 번째 매개변수로 문자열이 아닌 것이 전달되면 <code>TypeError</code>가 발생할 수 있습니다.)</p>
<p>내부적으로 생성된 이러한 <code>ValueError</code> 예외와 관련된 텍스트는 예외의 특성뿐만 아니라 포맷 문자열 내의 예외 위치를 나타냅니다.</p>
<p>사용자 코드에서 생성된 예외의 경우, 예외가 발생한 문자열 내의 위치를 결정하는 데 도움이 되도록 트레이스 기록(trace record)과 더미 프레임(dummy frame)이 트레이스백(traceback) 스택에 추가됩니다. 삽입된 트레이스백은 오류가 다음 위치에서 발생했음을 나타냅니다:</p>
<pre><code>File "&#x3C;format_string>;", line XX, in column_YY
</code></pre>
<p>여기서 <code>XX</code>와 <code>YY</code>는 각각 문자열 내의 줄 및 문자 위치 정보를 나타냅니다.</p>
<h3>대체 문법 (Alternate Syntax)</h3>
<p>당연히 가장 논쟁적인 문제 중 하나는 포맷 문자열의 문법, 특히 필드를 나타내는 데 사용되는 마크업 규칙입니다.</p>
<p>다양한 제안들을 모두 나열하려고 하기보다는, 이미 가장 널리 사용되는 것들을 다루겠습니다.</p>
<ul>
<li>
<p><strong>셸 변수 문법:</strong> <code>$name</code> 및 <code>$(name)</code> (또는 일부 변형에서 <code>${name}</code>). 이것은 아마도 가장 오래된 관습이며, Perl 및 다른 많은 곳에서 사용됩니다. 중괄호 없이 사용될 때는 유효하지 않은 문자를 찾을 때까지 어휘적으로 스캔하여 변수의 길이가 결정됩니다. 이 방식은 일반적으로 보간(interpolation)이 암시적인 경우, 즉 어떤 문자열이든 보간 변수를 포함할 수 있고 특별한 대체 함수를 호출할 필요가 없는 환경에서 사용됩니다. 이러한 경우, 보간 동작이 우연히 발생하는 것을 방지하는 것이 중요하므로 '$'(다른 경우에는 비교적 드물게 사용되는 문자)가 동작이 발생해야 할 때를 알리는 데 사용됩니다. 그러나 저자의 의견으로는 포매팅이 명시적으로 호출되는 경우, 우발적인 보간을 방지하기 위해 덜 주의를 기울여도 되며, 이 경우 더 가볍고 덜 다루기 힘든 문법을 사용할 수 있다고 합니다.</p>
</li>
<li>
<p><strong><code>printf</code> 및 그 사촌들(<code>%</code>):</strong> 필드 인덱스를 추가하여 필드를 순서와 상관없이 보간할 수 있는 변형을 포함합니다.</p>
</li>
<li>
<p><strong>다른 중괄호 전용 변형:</strong> MUD(Multi-User Dungeons)와 같은 다양한 MUSH는 문자열 보간을 위해 대괄호(예: <code>[name]</code>)를 사용했습니다. Microsoft .Net 라이브러리는 중괄호(<code>{}</code>)와 이 제안의 문법과 매우 유사한 문법을 사용하지만, 포맷 지정자의 문법은 상당히 다릅니다.</p>
</li>
<li>
<p><strong>백쿼팅(Backquoting):</strong> 이 방법은 최소한의 문법적 혼란이라는 장점이 있지만, 함수 호출 문법의 많은 장점(예: 복잡한 표현식 인자, 사용자 정의 포매터 등)이 부족합니다. 다른 변형으로는 Ruby의 <code>#{}</code>, PHP의 <code>{$name}</code> 등이 있습니다.</p>
</li>
</ul>
<p>문법의 몇 가지 특정 측면은 추가적인 설명이 필요합니다:</p>
<ol>
<li><strong>이스케이프를 위한 백슬래시 문자:</strong> 이 PEP의 초기 버전은 중괄호를 이스케이프하기 위해 이중화보다는 백슬래시를 사용했습니다. 이것은 <code>\n</code>과 같은 표준 백슬래시 시퀀스를 따르지 않는 Python 문자열 리터럴의 백슬래시가 수정되지 않고 남아 있었기 때문에 작동했습니다. 그러나 이것은 상당한 혼란을 야기했고, 여러 재귀적 이스케이프(예: 중괄호 앞에 리터럴 백슬래시를 두기 위한 <code>\\\\{</code>)의 잠재적인 상황으로 이어졌습니다.</li>
<li><strong>포맷 지정자 구분 기호로 콜론(<code>:</code>) 문자 사용:</strong> 이것은 단순히 .Net이 사용하는 방식이기 때문에 선택되었습니다.</li>
</ol>
<h3>대체 기능 제안 (Alternate Feature Proposals)</h3>
<ul>
<li><strong>속성 접근 제한:</strong> PEP의 이전 버전은 선행 밑줄로 시작하는 속성(예: <code>{0}._private</code>)에 대한 접근을 제한했습니다. 그러나 이것은 디버깅 시 유용한 기능이므로 제거되었습니다.</li>
<li>일부 개발자들은 <code>getattr</code> 및 <code>getitem</code> 접근 기능을 완전히 제거해야 한다고 제안했습니다. 그러나 이는 단일 인자로 큰 딕셔너리를 전달하고 (<code>**kwargs</code> 문법을 사용하여 개별 키워드 인자로 플래트닝하지 않고) 포맷 문자열이 딕셔너리 항목을 개별적으로 참조할 수 있는 기능을 강력히 요구하는 다른 개발자 집단의 요구 사항과 충돌했습니다.</li>
<li>포맷 문자열에서 허용되는 표현식 집합을 확장하자는 제안도 있었습니다. 그러나 이는 대부분의 경우 포매팅 함수에 전달되기 전에 매개변수에 동일한 표현식을 실행함으로써 동일한 효과를 얻을 수 있으므로 TOOWTDI(There's Only One Way To Do It) 정신에 어긋나는 것으로 간주되었습니다. 데이터가 풍부한 환경에서 임의의 포매팅을 수행하는 데 포맷 문자열이 사용되는 경우, Genshi 또는 Cheetah와 같이 이 목적에 특화된 템플릿 엔진을 사용하는 것이 권장됩니다.</li>
<li>다른 많은 기능들은 <code>Formatter</code>를 서브클래싱하여 쉽게 구현할 수 있었기 때문에 기본 구현에 기능을 내장하는 대신 고려되고 거부되었습니다. 여기에는 대체 문법, 포맷 문자열 내 주석 등이 포함됩니다.</li>
</ul>
<h3>보안 고려 사항 (Security Considerations)</h3>
<p>역사적으로 문자열 포매팅은 웹 기반 애플리케이션에서 흔히 발생하는 보안 취약점의 원천이었으며, 특히 문자열 포매팅 시스템이 포맷 문자열에 임의의 표현식을 포함할 수 있도록 허용하는 경우 더욱 그렇습니다.</p>
<p>잠재적인 보안 취약점을 만들지 않는 방식으로 문자열 포매팅을 사용하는 가장 좋은 방법은 신뢰할 수 없는 소스에서 온 포맷 문자열을 절대 사용하지 않는 것입니다.</p>
<p>그렇지 않은 경우, 다음으로 좋은 접근 방식은 문자열 포매팅에 부작용이 없도록 하는 것입니다. Python의 개방적인 특성 때문에 비자명한(non-trivial) 작업이 이러한 속성을 가짐을 보장하는 것은 불가능합니다. 이 PEP는 포맷 문자열의 표현식 유형을 가시적인 부작용이 드물고 Python 개발자 문화에서 강력히 권장되지 않는 것으로 제한합니다. 예를 들어, 속성 접근은 허용됩니다. 왜냐하면 속성 접근 자체만으로 가시적인 부작용이 있는 코드를 작성하는 것은 비정상적(pathological)으로 간주되기 때문입니다 (코드가 보이지 않는 부작용 - 예를 들어 더 빠른 조회를 위한 캐시 항목 생성 - 을 가지는지 여부는 관련이 없습니다).</p>
<h3>샘플 구현 (Sample Implementation)</h3>
<p>이 PEP의 초기 버전 구현은 Patrick Maupin과 Eric V. Smith에 의해 생성되었으며, <code>pep3101</code> 샌드박스에서 찾을 수 있습니다:
<a href="http://svn.python.org/view/sandbox/trunk/pep3101/">http://svn.python.org/view/sandbox/trunk/pep3101/</a></p>
<h3>하위 호환성 (Backwards Compatibility)</h3>
<p>기존 메커니즘을 그대로 두어 하위 호환성을 유지할 수 있습니다. 새로운 시스템은 기존 문자열 포매팅 기술의 메서드 이름과 충돌하지 않으므로, 이전 시스템이 더 이상 사용되지 않을 때까지 두 시스템이 공존할 수 있습니다.</p>
<h3>참조 (References)</h3>
<ul>
<li>Python Library Reference - String formatting operations: <a href="http://docs.python.org/library/stdtypes.html#string-formatting-operations">http://docs.python.org/library/stdtypes.html#string-formatting-operations</a></li>
<li>Python Library References - Template strings: <a href="http://docs.python.org/library/string.html#string.Template">http://docs.python.org/library/string.html#string.Template</a></li>
<li>[Python-3000] String formatting operations in python 3k: <a href="https://mail.python.org/pipermail/python-3000/2006-April/000285.html">https://mail.python.org/pipermail/python-3000/2006-April/000285.html</a></li>
<li>Composite Formatting - [.Net Framework Developer's Guide]: <a href="http://msdn.microsoft.com/library/en-us/cpguide/html/cpconcompositeformatting.asp?frame=true">http://msdn.microsoft.com/library/en-us/cpguide/html/cpconcompositeformatting.asp?frame=true</a></li>
<li>Genshi templating engine: <a href="http://genshi.edgewall.org/">http://genshi.edgewall.org/</a></li>
<li>Cheetah - The Python-Powered Template Engine: <a href="http://www.cheetahtemplate.org/">http://www.cheetahtemplate.org/</a></li>
</ul>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.
Last modified: 2025-02-01 08:59:27 GMT
Source: <a href="https://github.com/python/peps/blob/main/peps/pep-3101.rst">https://github.com/python/peps/blob/main/peps/pep-3101.rst</a></p>
<p>여기서 <code>XX</code>와 <code>YY</code>는 각각 문자열 내의 줄 및 문자 위치 정보를 나타냅니다. [cite: 1]</p>
<h3>대체 문법 (Alternate Syntax)</h3>
<p>당연히 가장 논쟁적인 문제 중 하나는 포맷 문자열의 문법, 특히 필드를 나타내는 데 사용되는 마크업 규칙입니다. [cite: 1]</p>
<p>다양한 제안들을 모두 나열하려고 하기보다는, 이미 가장 널리 사용되는 것들을 다루겠습니다. [cite: 1]</p>
<ul>
<li>
<p><strong>셸 변수 문법:</strong> <code>$name</code> 및 <code>$(name)</code> (또는 일부 변형에서 <code>${name}</code>). 이것은 아마도 가장 오래된 관습이며, Perl 및 다른 많은 곳에서 사용됩니다. 중괄호 없이 사용될 때는 유효하지 않은 문자를 찾을 때까지 어휘적으로 스캔하여 변수의 길이가 결정됩니다. 이 방식은 일반적으로 보간(interpolation)이 암시적인 경우, 즉 어떤 문자열이든 보간 변수를 포함할 수 있고 특별한 대체 함수를 호출할 필요가 없는 환경에서 사용됩니다. 이러한 경우, 보간 동작이 우연히 발생하는 것을 방지하는 것이 중요하므로 '$'(다른 경우에는 비교적 드물게 사용되는 문자)가 동작이 발생해야 할 때를 알리는 데 사용됩니다. 그러나 저자의 의견으로는 포매팅이 명시적으로 호출되는 경우, 우발적인 보간을 방지하기 위해 덜 주의를 기울여도 되며, 이 경우 더 가볍고 덜 다루기 힘든 문법을 사용할 수 있다고 합니다. [cite: 1]</p>
</li>
<li>
<p><strong><code>printf</code> 및 그 사촌들(<code>%</code>):</strong> 필드 인덱스를 추가하여 필드를 순서와 상관없이 보간할 수 있는 변형을 포함합니다. [cite: 1]</p>
</li>
<li>
<p><strong>다른 중괄호 전용 변형:</strong> MUD(Multi-User Dungeons)와 같은 다양한 MUSH는 문자열 보간을 위해 대괄호(예: <code>[name]</code>)를 사용했습니다. Microsoft .Net 라이브러리는 중괄호(<code>{}</code>)와 이 제안의 문법과 매우 유사한 문법을 사용하지만, 포맷 지정자의 문법은 상당히 다릅니다. [cite: 4, 1]</p>
</li>
<li>
<p><strong>백쿼팅(Backquoting):</strong> 이 방법은 최소한의 문법적 혼란이라는 장점이 있지만, 함수 호출 문법의 많은 장점(예: 복잡한 표현식 인자, 사용자 정의 포매터 등)이 부족합니다. 다른 변형으로는 Ruby의 <code>#{}</code>, PHP의 <code>{$name}</code> 등이 있습니다. [cite: 1]</p>
</li>
</ul>
<p>문법의 몇 가지 특정 측면은 추가적인 설명이 필요합니다: [cite: 1]</p>
<ol>
<li><strong>이스케이프를 위한 백슬래시 문자:</strong> 이 PEP의 초기 버전은 중괄호를 이스케이프하기 위해 이중화보다는 백슬래시를 사용했습니다. 이것은 <code>\n</code>과 같은 표준 백슬래시 시퀀스를 따르지 않는 Python 문자열 리터럴의 백슬래시가 수정되지 않고 남아 있었기 때문에 작동했습니다. 그러나 이것은 상당한 혼란을 야기했고, 여러 재귀적 이스케이프(예: 중괄호 앞에 리터럴 백슬래시를 두기 위한 <code>\\\\{</code>)의 잠재적인 상황으로 이어졌습니다. [cite: 1]</li>
<li><strong>포맷 지정자 구분 기호로 콜론(<code>:</code>) 문자 사용:</strong> 이것은 단순히 .Net이 사용하는 방식이기 때문에 선택되었습니다. [cite: 1]</li>
</ol>
<h3>대체 기능 제안 (Alternate Feature Proposals)</h3>
<ul>
<li><strong>속성 접근 제한:</strong> PEP의 이전 버전은 선행 밑줄로 시작하는 속성(예: <code>{0}._private</code>)에 대한 접근을 제한했습니다. 그러나 이것은 디버깅 시 유용한 기능이므로 제거되었습니다. [cite: 1]</li>
<li>일부 개발자들은 <code>getattr</code> 및 <code>getitem</code> 접근 기능을 완전히 제거해야 한다고 제안했습니다. 그러나 이는 단일 인자로 큰 딕셔너리를 전달하고 (<code>**kwargs</code> 문법을 사용하여 개별 키워드 인자로 플래트닝하지 않고) 포맷 문자열이 딕셔너리 항목을 개별적으로 참조할 수 있는 기능을 강력히 요구하는 다른 개발자 집단의 요구 사항과 충돌했습니다. [cite: 1]</li>
<li>포맷 문자열에서 허용되는 표현식 집합을 확장하자는 제안도 있었습니다. 그러나 이는 대부분의 경우 포매팅 함수에 전달되기 전에 매개변수에 동일한 표현식을 실행함으로써 동일한 효과를 얻을 수 있으므로 TOOWTDI(There's Only One Way To Do It) 정신에 어긋나는 것으로 간주되었습니다. 데이터가 풍부한 환경에서 임의의 포매팅을 수행하는 데 포맷 문자열이 사용되는 경우, Genshi [cite: 5, 1] 또는 Cheetah [cite: 6, 1]와 같이 이 목적에 특화된 템플릿 엔진을 사용하는 것이 권장됩니다. [cite: 1]</li>
<li>다른 많은 기능들은 <code>Formatter</code>를 서브클래싱하여 쉽게 구현할 수 있었기 때문에 기본 구현에 기능을 내장하는 대신 고려되고 거부되었습니다. 여기에는 대체 문법, 포맷 문자열 내 주석 등이 포함됩니다. [cite: 1]</li>
</ul>
<h3>보안 고려 사항 (Security Considerations)</h3>
<p>역사적으로 문자열 포매팅은 웹 기반 애플리케이션에서 흔히 발생하는 보안 취약점의 원천이었으며, 특히 문자열 포매팅 시스템이 포맷 문자열에 임의의 표현식을 포함할 수 있도록 허용하는 경우 더욱 그렇습니다. [cite: 1]</p>
<p>잠재적인 보안 취약점을 만들지 않는 방식으로 문자열 포매팅을 사용하는 가장 좋은 방법은 신뢰할 수 없는 소스에서 온 포맷 문자열을 절대 사용하지 않는 것입니다. [cite: 1]</p>
<p>그렇지 않은 경우, 다음으로 좋은 접근 방식은 문자열 포매팅에 부작용이 없도록 하는 것입니다. Python의 개방적인 특성 때문에 비자명한(non-trivial) 작업이 이러한 속성을 가짐을 보장하는 것은 불가능합니다. 이 PEP는 포맷 문자열의 표현식 유형을 가시적인 부작용이 드물고 Python 개발자 문화에서 강력히 권장되지 않는 것으로 제한합니다. 예를 들어, 속성 접근은 허용됩니다. 왜냐하면 속성 접근 자체만으로 가시적인 부작용이 있는 코드를 작성하는 것은 비정상적(pathological)으로 간주되기 때문입니다 (코드가 보이지 않는 부작용 - 예를 들어 더 빠른 조회를 위한 캐시 항목 생성 - 을 가지는지 여부는 관련이 없습니다). [cite: 1]</p>
<h3>샘플 구현 (Sample Implementation)</h3>
<p>이 PEP의 초기 버전 구현은 Patrick Maupin과 Eric V. Smith에 의해 생성되었으며, <code>pep3101</code> 샌드박스에서 찾을 수 있습니다: [cite: 1]
<a href="http://svn.python.org/view/sandbox/trunk/pep3101/">http://svn.python.org/view/sandbox/trunk/pep3101/</a> [cite: 1]</p>
<h3>하위 호환성 (Backwards Compatibility)</h3>
<p>기존 메커니즘을 그대로 두어 하위 호환성을 유지할 수 있습니다. 새로운 시스템은 기존 문자열 포매팅 기술의 메서드 이름과 충돌하지 않으므로, 이전 시스템이 더 이상 사용되지 않을 때까지 두 시스템이 공존할 수 있습니다. [cite: 1]</p>
<h3>참조 (References)</h3>
<ul>
<li>[1] Python Library Reference - String formatting operations: <a href="http://docs.python.org/library/stdtypes.html#string-formatting-operations">http://docs.python.org/library/stdtypes.html#string-formatting-operations</a> [cite: 1]</li>
<li>[2] Python Library References - Template strings: <a href="http://docs.python.org/library/string.html#string.Template">http://docs.python.org/library/string.html#string.Template</a> [cite: 1]</li>
<li>[3] [Python-3000] String formatting operations in python 3k: <a href="https://mail.python.org/pipermail/python-3000/2006-April/000285.html">https://mail.python.org/pipermail/python-3000/2006-April/000285.html</a> [cite: 1]</li>
<li>[4] Composite Formatting - [.Net Framework Developer's Guide]: <a href="http://msdn.microsoft.com/library/en-us/cpguide/html/cpconcompositeformatting.asp?frame=true">http://msdn.microsoft.com/library/en-us/cpguide/html/cpconcompositeformatting.asp?frame=true</a> [cite: 1]</li>
<li>[5] Genshi templating engine: <a href="http://genshi.edgewall.org/">http://genshi.edgewall.org/</a> [cite: 1]</li>
<li>[6] Cheetah - The Python-Powered Template Engine: <a href="http://www.cheetahtemplate.org/">http://www.cheetahtemplate.org/</a> [cite: 1]</li>
</ul>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다. [cite: 1]
Last modified: 2025-02-01 08:59:27 GMT [cite: 1]
Source: <a href="https://github.com/python/peps/blob/main/peps/pep-3101.rst">https://github.com/python/peps/blob/main/peps/pep-3101.rst</a> [cite: 1]</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/3101\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/3101/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/3101\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"3101\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/3101\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:Tc60c,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-3101/\"\u003ePEP 3101 - Advanced String Formatting\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 16-Apr-2006\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 3101 – 고급 문자열 포매팅\u003c/h2\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP(Python Enhancement Proposal)는 기존의 '%' 문자열 포매팅 연산자를 대체하기 위한 새로운 내장 문자열 포매팅 시스템을 제안합니다.\u003c/p\u003e\n\u003ch3\u003e도입 배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003ePython은 현재 두 가지 문자열 보간(interpolation) 방식을 제공합니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e문자열에 대한 '%' 연산자.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estring.Template\u003c/code\u003e 모듈.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 PEP의 주요 범위는 내장 문자열 포매팅 연산자(즉, 내장 문자열 타입의 메서드)에 대한 제안과 관련이 있습니다.\u003c/p\u003e\n\u003cp\u003e'%' 연산자는 이항 연산자(binary operator)라는 한계가 있으며, 따라서 최대 두 개의 인자만 취할 수 있습니다. 그중 하나는 이미 포맷 문자열(format string)에 할당되어, 나머지 모든 변수는 남은 인자 하나에 담겨야 합니다. 현재 관행은 두 번째 인자로 딕셔너리(dictionary)나 튜플(tuple)을 사용하는 것이지만, 많은 사람들이 지적했듯이 이것은 유연성이 부족합니다. \"전부 또는 전무(all or nothing)\" 접근 방식(즉, 위치 인자만 사용하거나, 이름 있는(named) 인자만 사용해야 하는 것)은 너무 제약적이라고 여겨집니다.\u003c/p\u003e\n\u003cp\u003e이 제안과 \u003ccode\u003estring.Template\u003c/code\u003e 사이에 일부 중복이 있지만, 각각이 서로 다른 요구를 충족하며 하나가 다른 하나를 불필요하게 만들지 않는다고 여겨집니다. 이 제안은 '%' 연산자처럼 한 번만 사용되는 작은 문자열에 효율적인 메커니즘을 위한 것입니다. 따라서 예를 들어, 문자열을 템플릿으로 컴파일하는 것은 이 제안에서 고려되지 않지만, 제안은 포맷 문자열과 API를 정의하여 효율적인 템플릿 패키지가 문법과 일부 기본 포매팅 코드를 재사용할 수 있도록 합니다.\u003c/p\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003cp\u003e이 명세는 다음 부분들로 구성됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e내장 \u003ccode\u003estr\u003c/code\u003e 클래스에 추가될 새로운 포매팅 메서드의 명세.\u003c/li\u003e\n\u003cli\u003e기본 포매팅 엔진을 추가 옵션과 함께 사용할 수 있도록 \u003ccode\u003estring\u003c/code\u003e 모듈에 추가될 함수 및 플래그 값의 명세.\u003c/li\u003e\n\u003cli\u003e포맷 문자열을 위한 새로운 문법의 명세.\u003c/li\u003e\n\u003cli\u003e객체의 포매팅 및 변환을 제어하는 새로운 특수 메서드 집합의 명세.\u003c/li\u003e\n\u003cli\u003e사용자 정의 포매팅 클래스를 위한 API 명세.\u003c/li\u003e\n\u003cli\u003e포매팅 오류 처리 방식의 명세.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e문자열 인코딩에 대한 참고:\u003c/strong\u003e Python 3.0 맥락에서 이 PEP를 논의할 때는 모든 문자열이 유니코드(unicode) 문자열이며, 이 문서에서 'string'이라는 단어는 일반적으로 Python 3.0 문자열(Python 2.x의 \u003ccode\u003eunicode\u003c/code\u003e 객체와 동일)을 지칭한다고 가정합니다.\u003c/p\u003e\n\u003cp\u003ePython 2.x 맥락에서는 이 문서에서 'string'이라는 단어가 일반 문자열 객체 또는 유니코드 객체일 수 있는 객체를 지칭합니다. 이 PEP에 설명된 모든 함수 호출 인터페이스는 문자열과 유니코드 객체 모두에 사용될 수 있으며, 모든 경우에 올바른 출력 문자열 타입을 추론하기에 충분한 정보가 있습니다 (즉, 두 개의 분리된 API가 필요하지 않습니다). 모든 경우에 포맷 문자열의 타입이 우선합니다. 즉, 변환 결과는 항상 입력 포맷 문자열과 동일한 문자 표현을 포함하는 객체가 됩니다.\u003c/p\u003e\n\u003ch4\u003e문자열 메서드 (String Methods)\u003c/h4\u003e\n\u003cp\u003e내장 \u003ccode\u003estr\u003c/code\u003e 클래스(및 2.6 버전의 \u003ccode\u003eunicode\u003c/code\u003e 클래스)는 임의의 수의 위치(positional) 및 키워드(keyword) 인자를 받는 새로운 \u003ccode\u003eformat\u003c/code\u003e 메서드를 얻게 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\"The story of {0}, {1}, and {c}\".format(a, b, c=d)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e포맷 문자열 내에서 각 위치 인자는 0부터 시작하는 숫자로 식별됩니다. 위 예시에서 'a'는 인자 0이고 'b'는 인자 1입니다. 각 키워드 인자는 해당 키워드 이름으로 식별되므로, 위 예시에서 'c'는 세 번째 인자를 참조하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e또한, 단일 값을 포매팅하는 전역 내장 함수 \u003ccode\u003eformat\u003c/code\u003e이 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eprint(format(10.0, \"7.3g\"))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 나중에 설명됩니다.\u003c/p\u003e\n\u003ch4\u003e포맷 문자열 (Format Strings)\u003c/h4\u003e\n\u003cp\u003e포맷 문자열은 문자 데이터와 마크업이 혼합되어 구성됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e문자 데이터(Character data):\u003c/strong\u003e 포맷 문자열에서 출력 문자열로 변경 없이 전달되는 데이터입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e마크업(Markup):\u003c/strong\u003e 포맷 문자열에서 출력으로 직접 전달되지 않지만, 대신 포맷 엔진에 출력 문자열에서 마크업 대신 무엇을 넣어야 하는지 설명하는 '치환 필드(replacement fields)'를 정의하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e중괄호(\u003ccode\u003e{}\u003c/code\u003e)는 문자열 내에서 치환 필드를 나타내는 데 사용됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\"My name is {0}\".format('Fred')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것의 결과는 다음 문자열이 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\"My name is Fred\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e중괄호는 이중으로 사용하여 이스케이프(escape)할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\"My name is {0} :-{{}}\".format('Fred')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 다음을 생성합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\"My name is Fred :-{}\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e중괄호 안의 요소는 '필드(field)'라고 불립니다. 필드는 '필드 이름(field name)'(단순하거나 복합적일 수 있음)과 선택적인 '포맷 지정자(format specifier)'로 구성됩니다.\u003c/p\u003e\n\u003ch4\u003e단순 및 복합 필드 이름 (Simple and Compound Field Names)\u003c/h4\u003e\n\u003cp\u003e단순 필드 이름은 이름 또는 숫자입니다. 숫자이면 유효한 10진수 정수여야 하고, 이름이면 유효한 Python 식별자(identifier)여야 합니다. 숫자는 위치 인자를 식별하는 데 사용되고, 이름은 키워드 인자를 식별하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e복합 필드 이름은 표현식에서 여러 단순 필드 이름의 조합입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\"My name is {0.name}\".format(open('out.txt', 'w'))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시는 필드 표현식에서 \u003ccode\u003egetattr\u003c/code\u003e 또는 '점(dot)' 연산자를 사용하는 것을 보여줍니다. 점 연산자는 입력 값의 속성(attribute)을 필드 값으로 지정할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e다른 일부 프로그래밍 언어와 달리, 포맷 문자열에 임의의 표현식(arbitrary expressions)을 포함할 수 없습니다. 이것은 의도적인 설계입니다. 사용할 수 있는 표현식의 종류는 의도적으로 제한됩니다. 두 가지 연산자만 지원됩니다: '.' (\u003ccode\u003egetattr\u003c/code\u003e) 연산자, 그리고 '[]' (\u003ccode\u003egetitem\u003c/code\u003e) 연산자. 이러한 연산자를 허용하는 이유는 일반적으로 비정상적인 코드가 아닌 경우 부작용(side effects)이 없기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egetitem\u003c/code\u003e 문법의 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\"My name is {0[name]}\".format(dict(name='Fred'))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e포맷 문자열 내에서 \u003ccode\u003egetitem\u003c/code\u003e의 사용은 일반적인 사용법보다 훨씬 제한적이라는 점에 유의해야 합니다. 위 예시에서 문자열 'name'은 실제로 리터럴 문자열 'name'이며, 'name'이라는 변수가 아닙니다. 항목 키를 파싱하는 규칙은 매우 간단합니다. 숫자로 시작하면 숫자로 취급하고, 그렇지 않으면 문자열로 사용됩니다.\u003c/p\u003e\n\u003cp\u003e키는 따옴표로 구분되지 않으므로 포맷 문자열 내에서 임의의 딕셔너리 키(예: 문자열 \"10\" 또는 \":-]\")를 지정할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e구현 참고:\u003c/strong\u003e 이 제안의 구현은 단순하거나 점으로 구분된 이름이 유효한 Python 식별자여야 한다는 규칙을 강제할 필요가 없습니다. 대신, 기본 객체의 \u003ccode\u003egetattr\u003c/code\u003e 함수가 식별자가 유효하지 않은 경우 예외를 발생시키도록 할 것입니다. \u003ccode\u003estr.format()\u003c/code\u003e 함수는 식별자가 언제 \"완료\"되는지 (즉, '.', ']', '}' 등을 찾아서) 파악하려고만 시도하는 최소한의 파서(parser)를 가질 것입니다.\u003c/p\u003e\n\u003ch4\u003e포맷 지정자 (Format Specifiers)\u003c/h4\u003e\n\u003cp\u003e각 필드는 해당 필드의 형식을 조정하는 데 사용될 수 있는 선택적인 '포맷 지정자' 집합을 지정할 수 있습니다. 포맷 지정자는 콜론(\u003ccode\u003e:\u003c/code\u003e) 문자로 구분되어 필드 이름 뒤에 옵니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\"My name is {0:8}\".format('Fred')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e포맷 지정자의 의미와 문법은 포매팅되는 객체의 타입에 따라 다르지만, 이를 오버라이드하지 않는 모든 객체에 사용되는 표준 포맷 지정자 집합이 있습니다.\u003c/p\u003e\n\u003cp\u003e포맷 지정자는 그 자체로 치환 필드를 포함할 수 있습니다. 예를 들어, 필드 너비가 그 자체로 매개변수인 필드는 다음과 같이 지정할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\"{0:{1}}\".format(a, b)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 '내부' 치환 필드는 치환 필드의 포맷 지정자 부분에서만 발생할 수 있습니다. 내부 치환 필드는 그 자체로 포맷 지정자를 가질 수 없습니다. 이는 또한 치환 필드가 임의의 깊이로 중첩될 수 없음을 의미합니다.\u003c/p\u003e\n\u003cp\u003e끝에 있는 이중 '}}'는 일반적으로 이스케이프되지만, 이 경우에는 이스케이프되지 않습니다. 그 이유는 이스케이프를 위한 '{{' 및 '}}' 문법은 포맷 필드 외부에서 사용될 때만 적용되기 때문입니다. 포맷 필드 내에서는 중괄호 문자가 항상 일반적인 의미를 가집니다.\u003c/p\u003e\n\u003cp\u003e클래스가 표준 포맷 지정자를 오버라이드할 수 있으므로 포맷 지정자의 문법은 개방형입니다. 이러한 경우 \u003ccode\u003estr.format()\u003c/code\u003e 메서드는 첫 번째 콜론과 일치하는 중괄호 사이의 모든 문자를 관련 기본 포매팅 메서드로 전달하기만 합니다.\u003c/p\u003e\n\u003ch4\u003e표준 포맷 지정자 (Standard Format Specifiers)\u003c/h4\u003e\n\u003cp\u003e객체가 자체 포맷 지정자를 정의하지 않으면, 표준 포맷 지정자 집합이 사용됩니다. 이들은 기존 '%' 연산자에서 사용되는 포맷 지정자와 개념적으로 유사하지만, 여러 가지 차이점도 있습니다.\u003c/p\u003e\n\u003cp\u003e표준 포맷 지정자의 일반적인 형식은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[[fill]align][sign][#][0][minimumwidth][.precision][type]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e대괄호(\u003ccode\u003e[]\u003c/code\u003e)는 선택적인 요소를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e선택적 정렬(align) 플래그는 다음 중 하나일 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e'\u0026#x3C;'\u003c/code\u003e: 사용 가능한 공간 내에서 필드를 왼쪽 정렬하도록 강제합니다 (이것이 기본값입니다).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'\u003e'\u003c/code\u003e: 사용 가능한 공간 내에서 필드를 오른쪽 정렬하도록 강제합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'='\u003c/code\u003e: 패딩을 부호(있는 경우) 뒤에 오지만 숫자 앞에 오도록 강제합니다. 이는 \u003ccode\u003e'+000000120'\u003c/code\u003e 형태의 필드를 인쇄하는 데 사용됩니다. 이 정렬 옵션은 숫자 타입에만 유효합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'^'\u003c/code\u003e: 사용 가능한 공간 내에서 필드를 가운데 정렬하도록 강제합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e최소 필드 너비가 정의되지 않으면 필드 너비는 항상 데이터를 채우는 크기와 동일하므로 이 경우 정렬 옵션은 의미가 없습니다.\u003c/p\u003e\n\u003cp\u003e선택적 'fill' 문자는 필드를 최소 너비로 채우는 데 사용될 문자를 정의합니다. fill 문자가 있는 경우 정렬 플래그 뒤에 와야 합니다.\u003c/p\u003e\n\u003cp\u003e'sign' 옵션은 숫자 타입에만 유효하며 다음 중 하나일 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e'+'\u003c/code\u003e: 양수와 음수 모두에 부호가 사용되어야 함을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'-'\u003c/code\u003e: 음수에만 부호가 사용되어야 함을 나타냅니다 (이것이 기본 동작입니다).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e' '\u003c/code\u003e: 양수에 선행 공백이 사용되어야 함을 나타냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e'#' 문자가 있으면 정수는 포매팅을 위해 '대체 형식(alternate form)'을 사용합니다. 이는 이진수, 8진수, 16진수 출력이 각각 '0b', '0o', '0x'로 접두사가 붙는다는 의미입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewidth\u003c/code\u003e는 최소 필드 너비를 정의하는 10진수 정수입니다. 지정하지 않으면 필드 너비는 내용에 따라 결정됩니다.\u003c/p\u003e\n\u003cp\u003e너비 필드 앞에 0(\u003ccode\u003e'0'\u003c/code\u003e) 문자가 오면 제로 패딩(zero-padding)이 활성화됩니다. 이는 정렬 타입이 \u003ccode\u003e'='\u003c/code\u003e이고 채움 문자가 \u003ccode\u003e'0'\u003c/code\u003e인 것과 동일합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprecision\u003c/code\u003e은 부동 소수점 변환에서 소수점 이하 몇 자리를 표시해야 하는지를 나타내는 10진수입니다. 비숫자 타입의 경우 이 필드는 최대 필드 크기(즉, 필드 내용에서 몇 문자가 사용될지)를 나타냅니다. 정수 변환의 경우 precision은 무시됩니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, \u003ccode\u003etype\u003c/code\u003e은 데이터가 어떻게 표현되어야 할지를 결정합니다.\u003c/p\u003e\n\u003cp\u003e사용 가능한 정수(Integer) 표현 타입은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e'b'\u003c/code\u003e: 이진수(Binary). 숫자를 2진수로 출력합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'c'\u003c/code\u003e: 문자(Character). 숫자를 출력하기 전에 해당 유니코드 문자로 변환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'd'\u003c/code\u003e: 10진수 정수(Decimal Integer). 숫자를 10진수로 출력합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'o'\u003c/code\u003e: 8진수 형식(Octal format). 숫자를 8진수로 출력합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'x'\u003c/code\u003e: 16진수 형식(Hex format). 숫자를 16진수로 출력하며, 9를 초과하는 숫자는 소문자로 표시합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'X'\u003c/code\u003e: 16진수 형식(Hex format). 숫자를 16진수로 출력하며, 9를 초과하는 숫자는 대문자로 표시합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'n'\u003c/code\u003e: 숫자(Number). \u003ccode\u003e'd'\u003c/code\u003e와 동일하지만, 현재 로케일(locale) 설정을 사용하여 적절한 숫자 구분 기호를 삽입합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e''\u003c/code\u003e (None): \u003ccode\u003e'd'\u003c/code\u003e와 동일합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e사용 가능한 부동 소수점(Floating Point) 표현 타입은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e'e'\u003c/code\u003e: 지수 표기법(Exponent notation). 숫자를 과학적 표기법으로 출력하며, 'e' 문자를 사용하여 지수를 나타냅니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'E'\u003c/code\u003e: 지수 표기법(Exponent notation). \u003ccode\u003e'e'\u003c/code\u003e와 동일하지만 숫자를 대문자로 변환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'f'\u003c/code\u003e: 고정 소수점(Fixed point). 숫자를 고정 소수점 숫자로 표시합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'F'\u003c/code\u003e: 고정 소수점(Fixed point). \u003ccode\u003e'f'\u003c/code\u003e와 동일하지만 숫자를 대문자로 변환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'g'\u003c/code\u003e: 일반 형식(General format). 숫자가 너무 크지 않은 경우 고정 소수점 숫자로 출력하며, 너무 큰 경우 \u003ccode\u003e'e'\u003c/code\u003e 지수 표기법으로 전환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'G'\u003c/code\u003e: 일반 형식(General format). \u003ccode\u003e'g'\u003c/code\u003e와 동일하지만 숫자가 너무 커지면 \u003ccode\u003e'E'\u003c/code\u003e로 전환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'n'\u003c/code\u003e: 숫자(Number). \u003ccode\u003e'g'\u003c/code\u003e와 동일하지만, 현재 로케일 설정을 사용하여 적절한 숫자 구분 기호를 삽입합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'%'\u003c/code\u003e: 백분율(Percentage). 숫자에 100을 곱하고 고정('f') 형식으로 표시한 다음 퍼센트 기호를 붙입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e''\u003c/code\u003e (None): \u003ccode\u003e'g'\u003c/code\u003e와 유사하지만, 소수점 이하에 최소 한 자리 숫자를 출력합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e객체는 표준 포맷 지정자를 대체하기 위해 자체 포맷 지정자를 정의할 수 있습니다. 예를 들어, \u003ccode\u003edatetime\u003c/code\u003e 클래스는 \u003ccode\u003estrftime()\u003c/code\u003e 함수의 인자와 유사한 포맷 지정자를 가질 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\"Today is: {0:%a %b %d %H:%M:%S %Y}\".format(datetime.now())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 내장 타입에 대해 빈 포맷 명세는 \u003ccode\u003estr(value)\u003c/code\u003e와 동일한 결과를 생성합니다. 자체 포맷 지정자를 정의하는 객체도 이 규칙을 따르도록 권장됩니다.\u003c/p\u003e\n\u003ch4\u003e명시적 변환 플래그 (Explicit Conversion Flag)\u003c/h4\u003e\n\u003cp\u003e명시적 변환 플래그는 포맷 필드 값을 포매팅하기 전에 변환하는 데 사용됩니다. 이는 타입별 포매팅 동작을 오버라이드하고, 값을 더 일반적인 타입인 것처럼 포매팅하는 데 사용될 수 있습니다. 현재 두 가지 명시적 변환 플래그가 인식됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e!r\u003c/code\u003e: \u003ccode\u003erepr()\u003c/code\u003e을 사용하여 값을 문자열로 변환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e!s\u003c/code\u003e: \u003ccode\u003estr()\u003c/code\u003e을 사용하여 값을 문자열로 변환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 플래그는 포맷 지정자 앞에 위치합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\"{0!r:20}\".format(\"Hello\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예시에서 문자열 \"Hello\"는 따옴표와 함께 최소 20자 너비의 필드에 출력됩니다.\u003c/p\u003e\n\u003cp\u003e사용자 정의 \u003ccode\u003eFormatter\u003c/code\u003e 클래스는 추가적인 변환 플래그를 정의할 수 있습니다. 내장 포매터는 잘못된 변환 플래그가 지정되면 \u003ccode\u003eValueError\u003c/code\u003e를 발생시킵니다.\u003c/p\u003e\n\u003ch4\u003e타입별 포매팅 제어 (Controlling Formatting on a Per-Type Basis)\u003c/h4\u003e\n\u003cp\u003e각 Python 타입은 \u003ccode\u003e__format__\u003c/code\u003e 메서드를 정의하여 해당 인스턴스의 포매팅을 제어할 수 있습니다. \u003ccode\u003e__format__\u003c/code\u003e 메서드는 포맷 지정자를 해석하고, 값을 포매팅하며, 결과 문자열을 반환하는 역할을 합니다.\u003c/p\u003e\n\u003cp\u003e새로운 전역 내장 함수 \u003ccode\u003eformat\u003c/code\u003e은 \u003ccode\u003elen()\u003c/code\u003e 및 \u003ccode\u003estr()\u003c/code\u003e이 각각의 특수 메서드를 호출하는 방식과 유사하게 이 특수 메서드를 단순히 호출합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef format(value, format_spec):\n    return value.__format__(format_spec)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수를 \"None\" 값으로 호출해도 안전합니다 (Python에서 \"None\" 값은 객체이며 메서드를 가질 수 있기 때문입니다).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estr\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003eobject\u003c/code\u003e를 포함한 여러 내장 타입은 \u003ccode\u003e__format__\u003c/code\u003e 메서드를 정의합니다. 이는 이러한 타입 중 하나에서 파생되면 클래스가 자체적으로 포매팅하는 방법을 알게 됨을 의미합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eobject.__format__\u003c/code\u003e 메서드는 가장 간단합니다: 단순히 객체를 문자열로 변환한 다음 \u003ccode\u003eformat\u003c/code\u003e을 다시 호출합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass object:\n    def __format__(self, format_spec):\n        return format(str(self), format_spec)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eint\u003c/code\u003e 및 \u003ccode\u003efloat\u003c/code\u003e의 \u003ccode\u003e__format__\u003c/code\u003e 메서드는 포맷 지정자를 기반으로 숫자 포매팅을 수행합니다. 경우에 따라 이러한 포매팅 연산은 다른 타입으로 위임될 수 있습니다. 예를 들어, \u003ccode\u003eint\u003c/code\u003e 포매터가 \u003ccode\u003e'f'\u003c/code\u003e (즉, 'float') 포맷 타입을 보는 경우, 단순히 값을 float으로 캐스팅하고 \u003ccode\u003eformat()\u003c/code\u003e을 다시 호출할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e어떤 클래스든 \u003ccode\u003e__format__\u003c/code\u003e 메서드를 오버라이드하여 해당 타입에 대한 사용자 정의 포매팅을 제공할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass AST:\n    def __format__(self, format_spec):\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ePython 2.x에 대한 참고:\u003c/strong\u003e \u003ccode\u003eformat_spec\u003c/code\u003e 인자는 원본 포맷 문자열의 타입에 따라 문자열 객체 또는 유니코드 객체가 됩니다. \u003ccode\u003e__format__\u003c/code\u003e 메서드는 \u003ccode\u003especifiers\u003c/code\u003e 매개변수의 타입을 테스트하여 문자열 또는 유니코드 객체를 반환할지 결정해야 합니다. 올바른 타입의 객체를 반환하는 것은 \u003ccode\u003e__format__\u003c/code\u003e 메서드의 책임입니다.\u003c/p\u003e\n\u003cp\u003e위에서 언급된 '명시적 변환' 플래그는 \u003ccode\u003e__format__\u003c/code\u003e 메서드에 전달되지 않습니다. 대신, 플래그에 의해 지정된 변환은 \u003ccode\u003e__format__\u003c/code\u003e을 호출하기 전에 수행될 것으로 예상됩니다.\u003c/p\u003e\n\u003ch4\u003e사용자 정의 포매팅 (User-Defined Formatting)\u003c/h4\u003e\n\u003cp\u003e타입별로 필드의 포매팅을 사용자 정의하는 것만으로는 충분하지 않을 때가 있을 것입니다. 예를 들어, 값이 사용 가능한 공간에 맞지 않을 때 '#' 해시 마크를 표시하는 스프레드시트 애플리케이션이 있습니다.\u003c/p\u003e\n\u003cp\u003e더 강력하고 유연한 포매팅을 위해, \u003ccode\u003estring\u003c/code\u003e 모듈에 있는 \u003ccode\u003eFormatter\u003c/code\u003e 클래스를 통해 기본 포맷 엔진에 접근할 수 있습니다. 이 클래스는 일반 \u003ccode\u003estr.format\u003c/code\u003e 메서드를 통해 접근할 수 없는 추가 옵션을 취합니다.\u003c/p\u003e\n\u003cp\u003e애플리케이션은 \u003ccode\u003eFormatter\u003c/code\u003e 클래스를 서브클래싱하여 자체 사용자 정의 포매팅 동작을 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003eFormatter\u003c/code\u003e 클래스에 의해 정의된 모든 메서드와 속성을 정확하게 명세하려고 시도하지 않습니다. 대신, 그것들은 초기 구현에서 정의되고 문서화될 것입니다. 그러나 이 PEP는 \u003ccode\u003eFormatter\u003c/code\u003e 클래스에 대한 일반적인 요구 사항을 명세할 것이며, 이는 아래에 나열되어 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estring.format()\u003c/code\u003e이 포매팅을 위해 \u003ccode\u003eFormatter\u003c/code\u003e 클래스를 직접 사용하지 않더라도, 둘 다 동일한 기본 구현을 사용합니다. \u003ccode\u003estring.format()\u003c/code\u003e이 \u003ccode\u003eFormatter\u003c/code\u003e 클래스를 직접 사용하지 않는 이유는 \"string\"이 내장 타입이므로 모든 메서드가 C로 구현되어야 하는 반면, \u003ccode\u003eFormatter\u003c/code\u003e는 Python 클래스이기 때문입니다. \u003ccode\u003eFormatter\u003c/code\u003e는 \u003ccode\u003estring.format()\u003c/code\u003e에서 사용되는 것과 동일한 C 함수에 대한 확장 가능한 래퍼(wrapper)를 제공합니다.\u003c/p\u003e\n\u003ch4\u003eFormatter 메서드 (Formatter Methods)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eFormatter\u003c/code\u003e 클래스는 초기화 인자를 받지 않습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efmt = Formatter()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eFormatter\u003c/code\u003e 클래스의 공개 API 메서드는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eformat(format_string, *args, **kwargs)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evformat(format_string, args, kwargs)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eformat\u003c/code\u003e은 주요 API 메서드입니다. 이는 포맷 템플릿과 임의의 위치 및 키워드 인자 집합을 받습니다. \u003ccode\u003eformat\u003c/code\u003e은 \u003ccode\u003evformat\u003c/code\u003e을 호출하는 단순한 래퍼입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003evformat\u003c/code\u003e은 실제 포매팅 작업을 수행하는 함수입니다. 이는 \u003ccode\u003e*args\u003c/code\u003e 및 \u003ccode\u003e**kwds\u003c/code\u003e 문법을 사용하여 딕셔너리를 개별 인자로 언패킹(unpacking)하고 다시 패킹(repacking)하는 대신, 미리 정의된 인자 딕셔너리를 전달하려는 경우를 위해 별도의 함수로 노출됩니다. \u003ccode\u003evformat\u003c/code\u003e은 포맷 템플릿 문자열을 문자 데이터와 치환 필드로 분할하는 작업을 수행합니다. 적절하게 \u003ccode\u003eget_positional\u003c/code\u003e 및 \u003ccode\u003eget_index\u003c/code\u003e 메서드를 호출합니다 (아래 설명).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eFormatter\u003c/code\u003e는 다음 오버라이드 가능한 메서드를 정의합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eget_value(key, args, kwargs)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echeck_unused_args(used_args, args, kwargs)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eformat_field(value, format_spec)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eget_value\u003c/code\u003e는 주어진 필드 값을 검색하는 데 사용됩니다. \u003ccode\u003ekey\u003c/code\u003e 인자는 정수 또는 문자열이 됩니다. 정수이면 \u003ccode\u003eargs\u003c/code\u003e의 위치 인자 인덱스를 나타내고, 문자열이면 \u003ccode\u003ekwargs\u003c/code\u003e의 이름 있는 인자를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eargs\u003c/code\u003e 매개변수는 \u003ccode\u003evformat\u003c/code\u003e에 대한 위치 인자 리스트로 설정되고, \u003ccode\u003ekwargs\u003c/code\u003e 매개변수는 위치 인자의 딕셔너리로 설정됩니다.\u003c/p\u003e\n\u003cp\u003e복합 필드 이름의 경우, 이러한 함수는 필드 이름의 첫 번째 구성 요소에 대해서만 호출됩니다. 후속 구성 요소는 일반 속성 및 인덱싱(indexing) 연산을 통해 처리됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 필드 표현식 '0.name'은 'key' 인자로 0을 사용하여 \u003ccode\u003eget_value\u003c/code\u003e가 호출되도록 합니다. 'name' 속성은 \u003ccode\u003eget_value\u003c/code\u003e가 반환된 후 내장 \u003ccode\u003egetattr\u003c/code\u003e 함수를 호출하여 찾아집니다.\u003c/p\u003e\n\u003cp\u003e인덱스나 키워드가 존재하지 않는 항목을 참조하면 \u003ccode\u003eIndexError\u003c/code\u003e/\u003ccode\u003eKeyError\u003c/code\u003e가 발생해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003echeck_unused_args\u003c/code\u003e는 원하는 경우 사용되지 않는 인자(unused arguments) 검사를 구현하는 데 사용됩니다. 이 함수의 인자는 포맷 문자열에서 실제로 참조된 모든 인자 키(위치 인자의 경우 정수, 이름 있는 인자의 경우 문자열)의 집합과 \u003ccode\u003evformat\u003c/code\u003e에 전달된 \u003ccode\u003eargs\u003c/code\u003e 및 \u003ccode\u003ekwargs\u003c/code\u003e에 대한 참조입니다. 사용되지 않는 인자 집합은 이러한 매개변수로부터 계산될 수 있습니다. \u003ccode\u003echeck_unused_args\u003c/code\u003e는 검사가 실패하면 예외를 발생시키는 것으로 가정합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eformat_field\u003c/code\u003e는 단순히 전역 \u003ccode\u003eformat\u003c/code\u003e 내장 함수를 호출합니다. 이 메서드는 서브클래스가 이를 오버라이드할 수 있도록 제공됩니다.\u003c/p\u003e\n\u003cp\u003e이러한 함수들이 서로 어떻게 관련되는지 더 잘 이해하기 위해 \u003ccode\u003evformat\u003c/code\u003e의 일반적인 동작을 설명하는 의사 코드(pseudocode)는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef vformat(format_string, args, kwargs):\n    # 출력 버퍼 및 사용된 인자 집합\n    buffer = StringIO.StringIO()\n    used_args = set()\n\n    # 토큰은 포맷 필드 또는 리터럴 문자열입니다\n    for token in self.parse(format_string):\n        if is_format_field(token):\n            # 토큰을 필드 값과 포맷 지정자로 분할\n            field_spec, _, format_spec = token.partition(\":\")\n            # 명시적 타입 변환 확인\n            explicit, _, field_spec = field_spec.rpartition(\"!\")\n\n            # 'first_part'는 첫 번째 '.' 또는 '[' 이전 부분입니다.\n            # 'get_first_part'가 문법에 따라 int 또는 string을 반환한다고 가정합니다.\n            first_part = get_first_part(field_spec)\n            value = self.get_value(first_part, args, kwargs)\n\n            # 이 인자를 사용했다는 사실을 기록\n            used_args.add(first_part)\n\n            # [subfield] 또는 .subfield 처리. 'components'가 첫 번째 부분을\n            # 제외한 다양한 서브필드의 이터레이터(iterator)를 반환한다고 가정합니다.\n            for comp in components(field_spec):\n                value = resolve_subfield(value, comp)\n\n            # 명시적 타입 변환 처리\n            if explicit == 'r':\n                value = repr(value)\n            elif explicit == 's':\n                value = str(value)\n\n            # 전역 'format' 함수를 호출하고 변환된 값을 출력 버퍼에 씁니다.\n            buffer.write(self.format_field(value, format_spec))\n        else:\n            buffer.write(token)\n\n    self.check_unused_args(used_args, args, kwargs)\n    return buffer.getvalue()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eFormatter\u003c/code\u003e 클래스의 실제 알고리즘(C로 구현될 것임)은 여기에 제시된 것과 다를 수 있다는 점에 유의하십시오. (실제 구현은 '클래스'가 아닐 가능성이 높습니다. 오히려 \u003ccode\u003evformat\u003c/code\u003e은 다른 오버라이드 가능한 메서드를 인자로 받는 C 함수를 호출할 수 있습니다.) 이 코드 예제의 주요 목적은 오버라이드 가능한 메서드가 호출되는 순서를 설명하는 것입니다.\u003c/p\u003e\n\u003ch4\u003e포매터 사용자 정의 (Customizing Formatters)\u003c/h4\u003e\n\u003cp\u003e이 섹션에서는 \u003ccode\u003eFormatter\u003c/code\u003e 객체를 사용자 정의하는 몇 가지 일반적인 방법을 설명합니다.\u003c/p\u003e\n\u003cp\u003e대체 포맷-문자열 문법을 지원하기 위해 \u003ccode\u003evformat\u003c/code\u003e 메서드를 오버라이드하여 포맷 문자열이 파싱되는 방식을 변경할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e일반적인 요구 사항 중 하나는 '기본(default)' 네임스페이스(namespace)를 지원하는 것입니다. 이렇게 하면 \u003ccode\u003eformat()\u003c/code\u003e 메서드에 키워드 인자를 전달할 필요 없이 기존 네임스페이스의 값을 사용할 수 있습니다. 이는 다음과 같이 \u003ccode\u003eget_value()\u003c/code\u003e를 오버라이드하여 쉽게 수행할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass NamespaceFormatter(Formatter):\n    def __init__(self, namespace={}):\n        Formatter.__init__(self)\n        self.namespace = namespace\n\n    def get_value(self, key, args, kwds):\n        if isinstance(key, str):\n            try:\n                # 명시적으로 전달된 인자를 먼저 확인\n                return kwds[key]\n            except KeyError:\n                return self.namespace[key]\n        else:\n            Formatter.get_value(key, args, kwds)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 사용하여 예를 들어 전역 변수에 접근할 수 있는 포매팅 함수를 쉽게 만들 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efmt = NamespaceFormatter(globals())\ngreeting = \"hello\"\nprint(fmt.format(\"{greeting}, world!\"))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003elocals()\u003c/code\u003e 딕셔너리를 사용하여 로컬 딕셔너리에 접근하는 유사한 기술을 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e호출 스택(calling stack)을 스누핑(snooping)하여 로컬 변수와 전역 변수 모두에 자동으로 접근할 수 있는 '스마트' 네임스페이스 포매터를 만드는 것도 가능합니다. Python의 다른 버전과의 호환성 필요성 때문에 이러한 기능은 표준 라이브러리에 포함되지 않겠지만, 누군가가 이를 위한 레시피(recipe)를 만들고 게시할 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e또 다른 유형의 사용자 정의는 \u003ccode\u003eformat_field\u003c/code\u003e 메서드를 오버라이드하여 내장 타입이 포매팅되는 방식을 변경하는 것입니다. (내장 타입이 아닌 경우, 해당 타입에 \u003ccode\u003e__format__\u003c/code\u003e 특수 메서드를 정의하면 됩니다.) 예를 들어, 필요할 때 과학적 표기법으로 출력하도록 숫자의 포매팅을 오버라이드할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003e오류 처리 (Error handling)\u003c/h4\u003e\n\u003cp\u003e포매팅 중에 발생할 수 있는 예외는 두 가지 종류입니다: 포매터 코드 자체에서 생성된 예외와 사용자 코드(예: 필드 객체의 \u003ccode\u003egetattr\u003c/code\u003e 함수)에서 생성된 예외.\u003c/p\u003e\n\u003cp\u003e일반적으로 포매터 코드 자체에서 생성된 예외는 \u003ccode\u003eValueError\u003c/code\u003e 유형입니다. 즉, 포맷 문자열의 실제 \"값\"에 오류가 있습니다. (항상 그런 것은 아닙니다. 예를 들어, \u003ccode\u003estring.format()\u003c/code\u003e 함수에 첫 번째 매개변수로 문자열이 아닌 것이 전달되면 \u003ccode\u003eTypeError\u003c/code\u003e가 발생할 수 있습니다.)\u003c/p\u003e\n\u003cp\u003e내부적으로 생성된 이러한 \u003ccode\u003eValueError\u003c/code\u003e 예외와 관련된 텍스트는 예외의 특성뿐만 아니라 포맷 문자열 내의 예외 위치를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e사용자 코드에서 생성된 예외의 경우, 예외가 발생한 문자열 내의 위치를 결정하는 데 도움이 되도록 트레이스 기록(trace record)과 더미 프레임(dummy frame)이 트레이스백(traceback) 스택에 추가됩니다. 삽입된 트레이스백은 오류가 다음 위치에서 발생했음을 나타냅니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFile \"\u0026#x3C;format_string\u003e;\", line XX, in column_YY\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003eXX\u003c/code\u003e와 \u003ccode\u003eYY\u003c/code\u003e는 각각 문자열 내의 줄 및 문자 위치 정보를 나타냅니다.\u003c/p\u003e\n\u003ch3\u003e대체 문법 (Alternate Syntax)\u003c/h3\u003e\n\u003cp\u003e당연히 가장 논쟁적인 문제 중 하나는 포맷 문자열의 문법, 특히 필드를 나타내는 데 사용되는 마크업 규칙입니다.\u003c/p\u003e\n\u003cp\u003e다양한 제안들을 모두 나열하려고 하기보다는, 이미 가장 널리 사용되는 것들을 다루겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e셸 변수 문법:\u003c/strong\u003e \u003ccode\u003e$name\u003c/code\u003e 및 \u003ccode\u003e$(name)\u003c/code\u003e (또는 일부 변형에서 \u003ccode\u003e${name}\u003c/code\u003e). 이것은 아마도 가장 오래된 관습이며, Perl 및 다른 많은 곳에서 사용됩니다. 중괄호 없이 사용될 때는 유효하지 않은 문자를 찾을 때까지 어휘적으로 스캔하여 변수의 길이가 결정됩니다. 이 방식은 일반적으로 보간(interpolation)이 암시적인 경우, 즉 어떤 문자열이든 보간 변수를 포함할 수 있고 특별한 대체 함수를 호출할 필요가 없는 환경에서 사용됩니다. 이러한 경우, 보간 동작이 우연히 발생하는 것을 방지하는 것이 중요하므로 '$'(다른 경우에는 비교적 드물게 사용되는 문자)가 동작이 발생해야 할 때를 알리는 데 사용됩니다. 그러나 저자의 의견으로는 포매팅이 명시적으로 호출되는 경우, 우발적인 보간을 방지하기 위해 덜 주의를 기울여도 되며, 이 경우 더 가볍고 덜 다루기 힘든 문법을 사용할 수 있다고 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eprintf\u003c/code\u003e 및 그 사촌들(\u003ccode\u003e%\u003c/code\u003e):\u003c/strong\u003e 필드 인덱스를 추가하여 필드를 순서와 상관없이 보간할 수 있는 변형을 포함합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e다른 중괄호 전용 변형:\u003c/strong\u003e MUD(Multi-User Dungeons)와 같은 다양한 MUSH는 문자열 보간을 위해 대괄호(예: \u003ccode\u003e[name]\u003c/code\u003e)를 사용했습니다. Microsoft .Net 라이브러리는 중괄호(\u003ccode\u003e{}\u003c/code\u003e)와 이 제안의 문법과 매우 유사한 문법을 사용하지만, 포맷 지정자의 문법은 상당히 다릅니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e백쿼팅(Backquoting):\u003c/strong\u003e 이 방법은 최소한의 문법적 혼란이라는 장점이 있지만, 함수 호출 문법의 많은 장점(예: 복잡한 표현식 인자, 사용자 정의 포매터 등)이 부족합니다. 다른 변형으로는 Ruby의 \u003ccode\u003e#{}\u003c/code\u003e, PHP의 \u003ccode\u003e{$name}\u003c/code\u003e 등이 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e문법의 몇 가지 특정 측면은 추가적인 설명이 필요합니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e이스케이프를 위한 백슬래시 문자:\u003c/strong\u003e 이 PEP의 초기 버전은 중괄호를 이스케이프하기 위해 이중화보다는 백슬래시를 사용했습니다. 이것은 \u003ccode\u003e\\n\u003c/code\u003e과 같은 표준 백슬래시 시퀀스를 따르지 않는 Python 문자열 리터럴의 백슬래시가 수정되지 않고 남아 있었기 때문에 작동했습니다. 그러나 이것은 상당한 혼란을 야기했고, 여러 재귀적 이스케이프(예: 중괄호 앞에 리터럴 백슬래시를 두기 위한 \u003ccode\u003e\\\\\\\\{\u003c/code\u003e)의 잠재적인 상황으로 이어졌습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e포맷 지정자 구분 기호로 콜론(\u003ccode\u003e:\u003c/code\u003e) 문자 사용:\u003c/strong\u003e 이것은 단순히 .Net이 사용하는 방식이기 때문에 선택되었습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e대체 기능 제안 (Alternate Feature Proposals)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e속성 접근 제한:\u003c/strong\u003e PEP의 이전 버전은 선행 밑줄로 시작하는 속성(예: \u003ccode\u003e{0}._private\u003c/code\u003e)에 대한 접근을 제한했습니다. 그러나 이것은 디버깅 시 유용한 기능이므로 제거되었습니다.\u003c/li\u003e\n\u003cli\u003e일부 개발자들은 \u003ccode\u003egetattr\u003c/code\u003e 및 \u003ccode\u003egetitem\u003c/code\u003e 접근 기능을 완전히 제거해야 한다고 제안했습니다. 그러나 이는 단일 인자로 큰 딕셔너리를 전달하고 (\u003ccode\u003e**kwargs\u003c/code\u003e 문법을 사용하여 개별 키워드 인자로 플래트닝하지 않고) 포맷 문자열이 딕셔너리 항목을 개별적으로 참조할 수 있는 기능을 강력히 요구하는 다른 개발자 집단의 요구 사항과 충돌했습니다.\u003c/li\u003e\n\u003cli\u003e포맷 문자열에서 허용되는 표현식 집합을 확장하자는 제안도 있었습니다. 그러나 이는 대부분의 경우 포매팅 함수에 전달되기 전에 매개변수에 동일한 표현식을 실행함으로써 동일한 효과를 얻을 수 있으므로 TOOWTDI(There's Only One Way To Do It) 정신에 어긋나는 것으로 간주되었습니다. 데이터가 풍부한 환경에서 임의의 포매팅을 수행하는 데 포맷 문자열이 사용되는 경우, Genshi 또는 Cheetah와 같이 이 목적에 특화된 템플릿 엔진을 사용하는 것이 권장됩니다.\u003c/li\u003e\n\u003cli\u003e다른 많은 기능들은 \u003ccode\u003eFormatter\u003c/code\u003e를 서브클래싱하여 쉽게 구현할 수 있었기 때문에 기본 구현에 기능을 내장하는 대신 고려되고 거부되었습니다. 여기에는 대체 문법, 포맷 문자열 내 주석 등이 포함됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e보안 고려 사항 (Security Considerations)\u003c/h3\u003e\n\u003cp\u003e역사적으로 문자열 포매팅은 웹 기반 애플리케이션에서 흔히 발생하는 보안 취약점의 원천이었으며, 특히 문자열 포매팅 시스템이 포맷 문자열에 임의의 표현식을 포함할 수 있도록 허용하는 경우 더욱 그렇습니다.\u003c/p\u003e\n\u003cp\u003e잠재적인 보안 취약점을 만들지 않는 방식으로 문자열 포매팅을 사용하는 가장 좋은 방법은 신뢰할 수 없는 소스에서 온 포맷 문자열을 절대 사용하지 않는 것입니다.\u003c/p\u003e\n\u003cp\u003e그렇지 않은 경우, 다음으로 좋은 접근 방식은 문자열 포매팅에 부작용이 없도록 하는 것입니다. Python의 개방적인 특성 때문에 비자명한(non-trivial) 작업이 이러한 속성을 가짐을 보장하는 것은 불가능합니다. 이 PEP는 포맷 문자열의 표현식 유형을 가시적인 부작용이 드물고 Python 개발자 문화에서 강력히 권장되지 않는 것으로 제한합니다. 예를 들어, 속성 접근은 허용됩니다. 왜냐하면 속성 접근 자체만으로 가시적인 부작용이 있는 코드를 작성하는 것은 비정상적(pathological)으로 간주되기 때문입니다 (코드가 보이지 않는 부작용 - 예를 들어 더 빠른 조회를 위한 캐시 항목 생성 - 을 가지는지 여부는 관련이 없습니다).\u003c/p\u003e\n\u003ch3\u003e샘플 구현 (Sample Implementation)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 초기 버전 구현은 Patrick Maupin과 Eric V. Smith에 의해 생성되었으며, \u003ccode\u003epep3101\u003c/code\u003e 샌드박스에서 찾을 수 있습니다:\n\u003ca href=\"http://svn.python.org/view/sandbox/trunk/pep3101/\"\u003ehttp://svn.python.org/view/sandbox/trunk/pep3101/\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e하위 호환성 (Backwards Compatibility)\u003c/h3\u003e\n\u003cp\u003e기존 메커니즘을 그대로 두어 하위 호환성을 유지할 수 있습니다. 새로운 시스템은 기존 문자열 포매팅 기술의 메서드 이름과 충돌하지 않으므로, 이전 시스템이 더 이상 사용되지 않을 때까지 두 시스템이 공존할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e참조 (References)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePython Library Reference - String formatting operations: \u003ca href=\"http://docs.python.org/library/stdtypes.html#string-formatting-operations\"\u003ehttp://docs.python.org/library/stdtypes.html#string-formatting-operations\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePython Library References - Template strings: \u003ca href=\"http://docs.python.org/library/string.html#string.Template\"\u003ehttp://docs.python.org/library/string.html#string.Template\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[Python-3000] String formatting operations in python 3k: \u003ca href=\"https://mail.python.org/pipermail/python-3000/2006-April/000285.html\"\u003ehttps://mail.python.org/pipermail/python-3000/2006-April/000285.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eComposite Formatting - [.Net Framework Developer's Guide]: \u003ca href=\"http://msdn.microsoft.com/library/en-us/cpguide/html/cpconcompositeformatting.asp?frame=true\"\u003ehttp://msdn.microsoft.com/library/en-us/cpguide/html/cpconcompositeformatting.asp?frame=true\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eGenshi templating engine: \u003ca href=\"http://genshi.edgewall.org/\"\u003ehttp://genshi.edgewall.org/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eCheetah - The Python-Powered Template Engine: \u003ca href=\"http://www.cheetahtemplate.org/\"\u003ehttp://www.cheetahtemplate.org/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\nLast modified: 2025-02-01 08:59:27 GMT\nSource: \u003ca href=\"https://github.com/python/peps/blob/main/peps/pep-3101.rst\"\u003ehttps://github.com/python/peps/blob/main/peps/pep-3101.rst\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e여기서 \u003ccode\u003eXX\u003c/code\u003e와 \u003ccode\u003eYY\u003c/code\u003e는 각각 문자열 내의 줄 및 문자 위치 정보를 나타냅니다. [cite: 1]\u003c/p\u003e\n\u003ch3\u003e대체 문법 (Alternate Syntax)\u003c/h3\u003e\n\u003cp\u003e당연히 가장 논쟁적인 문제 중 하나는 포맷 문자열의 문법, 특히 필드를 나타내는 데 사용되는 마크업 규칙입니다. [cite: 1]\u003c/p\u003e\n\u003cp\u003e다양한 제안들을 모두 나열하려고 하기보다는, 이미 가장 널리 사용되는 것들을 다루겠습니다. [cite: 1]\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e셸 변수 문법:\u003c/strong\u003e \u003ccode\u003e$name\u003c/code\u003e 및 \u003ccode\u003e$(name)\u003c/code\u003e (또는 일부 변형에서 \u003ccode\u003e${name}\u003c/code\u003e). 이것은 아마도 가장 오래된 관습이며, Perl 및 다른 많은 곳에서 사용됩니다. 중괄호 없이 사용될 때는 유효하지 않은 문자를 찾을 때까지 어휘적으로 스캔하여 변수의 길이가 결정됩니다. 이 방식은 일반적으로 보간(interpolation)이 암시적인 경우, 즉 어떤 문자열이든 보간 변수를 포함할 수 있고 특별한 대체 함수를 호출할 필요가 없는 환경에서 사용됩니다. 이러한 경우, 보간 동작이 우연히 발생하는 것을 방지하는 것이 중요하므로 '$'(다른 경우에는 비교적 드물게 사용되는 문자)가 동작이 발생해야 할 때를 알리는 데 사용됩니다. 그러나 저자의 의견으로는 포매팅이 명시적으로 호출되는 경우, 우발적인 보간을 방지하기 위해 덜 주의를 기울여도 되며, 이 경우 더 가볍고 덜 다루기 힘든 문법을 사용할 수 있다고 합니다. [cite: 1]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eprintf\u003c/code\u003e 및 그 사촌들(\u003ccode\u003e%\u003c/code\u003e):\u003c/strong\u003e 필드 인덱스를 추가하여 필드를 순서와 상관없이 보간할 수 있는 변형을 포함합니다. [cite: 1]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e다른 중괄호 전용 변형:\u003c/strong\u003e MUD(Multi-User Dungeons)와 같은 다양한 MUSH는 문자열 보간을 위해 대괄호(예: \u003ccode\u003e[name]\u003c/code\u003e)를 사용했습니다. Microsoft .Net 라이브러리는 중괄호(\u003ccode\u003e{}\u003c/code\u003e)와 이 제안의 문법과 매우 유사한 문법을 사용하지만, 포맷 지정자의 문법은 상당히 다릅니다. [cite: 4, 1]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e백쿼팅(Backquoting):\u003c/strong\u003e 이 방법은 최소한의 문법적 혼란이라는 장점이 있지만, 함수 호출 문법의 많은 장점(예: 복잡한 표현식 인자, 사용자 정의 포매터 등)이 부족합니다. 다른 변형으로는 Ruby의 \u003ccode\u003e#{}\u003c/code\u003e, PHP의 \u003ccode\u003e{$name}\u003c/code\u003e 등이 있습니다. [cite: 1]\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e문법의 몇 가지 특정 측면은 추가적인 설명이 필요합니다: [cite: 1]\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e이스케이프를 위한 백슬래시 문자:\u003c/strong\u003e 이 PEP의 초기 버전은 중괄호를 이스케이프하기 위해 이중화보다는 백슬래시를 사용했습니다. 이것은 \u003ccode\u003e\\n\u003c/code\u003e과 같은 표준 백슬래시 시퀀스를 따르지 않는 Python 문자열 리터럴의 백슬래시가 수정되지 않고 남아 있었기 때문에 작동했습니다. 그러나 이것은 상당한 혼란을 야기했고, 여러 재귀적 이스케이프(예: 중괄호 앞에 리터럴 백슬래시를 두기 위한 \u003ccode\u003e\\\\\\\\{\u003c/code\u003e)의 잠재적인 상황으로 이어졌습니다. [cite: 1]\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e포맷 지정자 구분 기호로 콜론(\u003ccode\u003e:\u003c/code\u003e) 문자 사용:\u003c/strong\u003e 이것은 단순히 .Net이 사용하는 방식이기 때문에 선택되었습니다. [cite: 1]\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e대체 기능 제안 (Alternate Feature Proposals)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e속성 접근 제한:\u003c/strong\u003e PEP의 이전 버전은 선행 밑줄로 시작하는 속성(예: \u003ccode\u003e{0}._private\u003c/code\u003e)에 대한 접근을 제한했습니다. 그러나 이것은 디버깅 시 유용한 기능이므로 제거되었습니다. [cite: 1]\u003c/li\u003e\n\u003cli\u003e일부 개발자들은 \u003ccode\u003egetattr\u003c/code\u003e 및 \u003ccode\u003egetitem\u003c/code\u003e 접근 기능을 완전히 제거해야 한다고 제안했습니다. 그러나 이는 단일 인자로 큰 딕셔너리를 전달하고 (\u003ccode\u003e**kwargs\u003c/code\u003e 문법을 사용하여 개별 키워드 인자로 플래트닝하지 않고) 포맷 문자열이 딕셔너리 항목을 개별적으로 참조할 수 있는 기능을 강력히 요구하는 다른 개발자 집단의 요구 사항과 충돌했습니다. [cite: 1]\u003c/li\u003e\n\u003cli\u003e포맷 문자열에서 허용되는 표현식 집합을 확장하자는 제안도 있었습니다. 그러나 이는 대부분의 경우 포매팅 함수에 전달되기 전에 매개변수에 동일한 표현식을 실행함으로써 동일한 효과를 얻을 수 있으므로 TOOWTDI(There's Only One Way To Do It) 정신에 어긋나는 것으로 간주되었습니다. 데이터가 풍부한 환경에서 임의의 포매팅을 수행하는 데 포맷 문자열이 사용되는 경우, Genshi [cite: 5, 1] 또는 Cheetah [cite: 6, 1]와 같이 이 목적에 특화된 템플릿 엔진을 사용하는 것이 권장됩니다. [cite: 1]\u003c/li\u003e\n\u003cli\u003e다른 많은 기능들은 \u003ccode\u003eFormatter\u003c/code\u003e를 서브클래싱하여 쉽게 구현할 수 있었기 때문에 기본 구현에 기능을 내장하는 대신 고려되고 거부되었습니다. 여기에는 대체 문법, 포맷 문자열 내 주석 등이 포함됩니다. [cite: 1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e보안 고려 사항 (Security Considerations)\u003c/h3\u003e\n\u003cp\u003e역사적으로 문자열 포매팅은 웹 기반 애플리케이션에서 흔히 발생하는 보안 취약점의 원천이었으며, 특히 문자열 포매팅 시스템이 포맷 문자열에 임의의 표현식을 포함할 수 있도록 허용하는 경우 더욱 그렇습니다. [cite: 1]\u003c/p\u003e\n\u003cp\u003e잠재적인 보안 취약점을 만들지 않는 방식으로 문자열 포매팅을 사용하는 가장 좋은 방법은 신뢰할 수 없는 소스에서 온 포맷 문자열을 절대 사용하지 않는 것입니다. [cite: 1]\u003c/p\u003e\n\u003cp\u003e그렇지 않은 경우, 다음으로 좋은 접근 방식은 문자열 포매팅에 부작용이 없도록 하는 것입니다. Python의 개방적인 특성 때문에 비자명한(non-trivial) 작업이 이러한 속성을 가짐을 보장하는 것은 불가능합니다. 이 PEP는 포맷 문자열의 표현식 유형을 가시적인 부작용이 드물고 Python 개발자 문화에서 강력히 권장되지 않는 것으로 제한합니다. 예를 들어, 속성 접근은 허용됩니다. 왜냐하면 속성 접근 자체만으로 가시적인 부작용이 있는 코드를 작성하는 것은 비정상적(pathological)으로 간주되기 때문입니다 (코드가 보이지 않는 부작용 - 예를 들어 더 빠른 조회를 위한 캐시 항목 생성 - 을 가지는지 여부는 관련이 없습니다). [cite: 1]\u003c/p\u003e\n\u003ch3\u003e샘플 구현 (Sample Implementation)\u003c/h3\u003e\n\u003cp\u003e이 PEP의 초기 버전 구현은 Patrick Maupin과 Eric V. Smith에 의해 생성되었으며, \u003ccode\u003epep3101\u003c/code\u003e 샌드박스에서 찾을 수 있습니다: [cite: 1]\n\u003ca href=\"http://svn.python.org/view/sandbox/trunk/pep3101/\"\u003ehttp://svn.python.org/view/sandbox/trunk/pep3101/\u003c/a\u003e [cite: 1]\u003c/p\u003e\n\u003ch3\u003e하위 호환성 (Backwards Compatibility)\u003c/h3\u003e\n\u003cp\u003e기존 메커니즘을 그대로 두어 하위 호환성을 유지할 수 있습니다. 새로운 시스템은 기존 문자열 포매팅 기술의 메서드 이름과 충돌하지 않으므로, 이전 시스템이 더 이상 사용되지 않을 때까지 두 시스템이 공존할 수 있습니다. [cite: 1]\u003c/p\u003e\n\u003ch3\u003e참조 (References)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e[1] Python Library Reference - String formatting operations: \u003ca href=\"http://docs.python.org/library/stdtypes.html#string-formatting-operations\"\u003ehttp://docs.python.org/library/stdtypes.html#string-formatting-operations\u003c/a\u003e [cite: 1]\u003c/li\u003e\n\u003cli\u003e[2] Python Library References - Template strings: \u003ca href=\"http://docs.python.org/library/string.html#string.Template\"\u003ehttp://docs.python.org/library/string.html#string.Template\u003c/a\u003e [cite: 1]\u003c/li\u003e\n\u003cli\u003e[3] [Python-3000] String formatting operations in python 3k: \u003ca href=\"https://mail.python.org/pipermail/python-3000/2006-April/000285.html\"\u003ehttps://mail.python.org/pipermail/python-3000/2006-April/000285.html\u003c/a\u003e [cite: 1]\u003c/li\u003e\n\u003cli\u003e[4] Composite Formatting - [.Net Framework Developer's Guide]: \u003ca href=\"http://msdn.microsoft.com/library/en-us/cpguide/html/cpconcompositeformatting.asp?frame=true\"\u003ehttp://msdn.microsoft.com/library/en-us/cpguide/html/cpconcompositeformatting.asp?frame=true\u003c/a\u003e [cite: 1]\u003c/li\u003e\n\u003cli\u003e[5] Genshi templating engine: \u003ca href=\"http://genshi.edgewall.org/\"\u003ehttp://genshi.edgewall.org/\u003c/a\u003e [cite: 1]\u003c/li\u003e\n\u003cli\u003e[6] Cheetah - The Python-Powered Template Engine: \u003ca href=\"http://www.cheetahtemplate.org/\"\u003ehttp://www.cheetahtemplate.org/\u003c/a\u003e [cite: 1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다. [cite: 1]\nLast modified: 2025-02-01 08:59:27 GMT [cite: 1]\nSource: \u003ca href=\"https://github.com/python/peps/blob/main/peps/pep-3101.rst\"\u003ehttps://github.com/python/peps/blob/main/peps/pep-3101.rst\u003c/a\u003e [cite: 1]\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 3101 - Advanced String Formatting\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 14:16:14+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>