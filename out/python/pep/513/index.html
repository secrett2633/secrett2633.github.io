<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Superseded] PEP 513 - A Platform Tag for Portable Linux Built Distributions</h1><div class="page__meta"><time dateTime="2025-09-26 23:03:09+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0513/">PEP 513 - A Platform Tag for Portable Linux Built Distributions</a></p>
<p><strong>상태:</strong> Superseded | <strong>유형:</strong> Informational | <strong>작성일:</strong> 19-Jan-2016</p>
</blockquote>
<h2>PEP 513 – 휴대용 Linux 빌드 배포판을 위한 플랫폼 태그</h2>
<h3>개요 (Abstract)</h3>
<p>이 PEP(Python Enhancement Proposal)는 Python 패키지 빌드 배포판, 특히 <code>wheels</code>를 위한 새로운 플랫폼 태그인 <code>manylinux1_{x86_64,i686}</code> 생성을 제안합니다. 이 태그를 사용하는 <code>wheels</code>는 표준화되고 제한된 Linux 커널 및 핵심 사용자 공간 ABI(Application Binary Interface)의 하위 집합에만 외부 종속성을 가집니다. PyPI(Python Package Index)가 이 플랫폼 태그를 가진 <code>wheels</code>의 업로드 및 배포를 지원하고, <code>pip</code>는 호환 가능한 플랫폼에서 이 패키지들을 다운로드 및 설치할 수 있도록 지원하는 것을 목표로 합니다.</p>
<h3>배경 (Rationale)</h3>
<p>현재 Windows 및 OS X용 바이너리 Python 확장을 배포하는 것은 간단합니다. 개발자들은 <code>wheels</code> (PEP 427, PEP 491)를 빌드하여 <code>win32</code> 또는 <code>macosx_10_6_intel</code>과 같은 플랫폼 태그를 할당하고 PyPI에 업로드합니다. 사용자들은 <code>pip</code>와 같은 도구를 사용하여 이 <code>wheels</code>를 다운로드하고 설치할 수 있습니다.</p>
<p>그러나 Linux의 경우 상황이 훨씬 복잡합니다. 일반적으로 한 Linux 배포판에서 빌드된 컴파일된 Python 확장 모듈은 다른 Linux 배포판에서는 작동하지 않거나, 심지어 동일한 Linux 배포판을 실행하는 다른 시스템에서도 시스템 라이브러리가 다르면 작동하지 않을 수 있습니다.</p>
<p>PEP 425 플랫폼 태그를 사용하는 빌드 도구는 특정 Linux 배포판이나 설치된 시스템 라이브러리에 대한 정보를 추적하지 않고, 모든 <code>wheels</code>에 <code>linux_i686</code> 또는 <code>linux_x86_64</code>와 같이 너무 모호한 태그를 할당합니다. 이러한 불확실성 때문에 한 머신에서 컴파일된 <code>linux</code> 태그가 붙은 빌드 배포판이 다른 머신에서 제대로 작동할 것이라는 기대가 없으며, 이러한 이유로 PyPI는 Linux용 <code>wheels</code> 업로드를 허용하지 않았습니다.</p>
<p>어떤 Linux 시스템에서도 작동할 수 있는 <code>wheel</code> 패키지를 컴파일할 수 있다면 이상적일 것입니다. 그러나 PC에서 Android, 그리고 커스텀 <code>libc</code>를 사용하는 임베디드 시스템에 이르기까지 Linux 시스템의 엄청난 다양성 때문에 이는 일반적으로 보장될 수 없습니다.</p>
<p>대신, 이 PEP는 실제로 널리 사용되는 모든 데스크톱 및 서버 배포판을 포함하여 많은 Linux 시스템에서 호환될 만큼 충분한 커널 및 핵심 사용자 공간 ABI의 표준 하위 집합을 정의합니다. Enthought의 Canopy 및 Continuum Analytics의 Anaconda와 같은 회사들이 Linux용으로 이처럼 널리 이식 가능한 사전 컴파일된 Python 확장 모듈을 배포해왔기 때문에 이것이 가능하다는 것을 알고 있습니다.</p>
<p>이 회사들로부터 얻은 호환성 교훈을 바탕으로, 바이너리 Python <code>wheels</code>에서 사용할 <code>manylinux1</code> 플랫폼 태그를 정의하고, 이러한 <code>manylinux1 wheels</code>의 구축을 돕기 위한 초기 도구 구현을 소개합니다.</p>
<h3>Linux 바이너리 비호환성의 주요 원인 (Key Causes of Inter-Linux Binary Incompatibility)</h3>
<p><code>wheel</code> 패키지가 많은 Linux 플랫폼에서 작동하도록 보장하는 표준을 올바르게 정의하려면, Linux에서 사전 컴파이된 이식성이 저해되는 근본적인 원인(Root Causes)을 이해해야 합니다. 두 가지 주요 원인은 사용자 시스템에 존재하지 않는 공유 라이브러리에 대한 종속성과 <code>glibc</code>와 같은 특정 코어 라이브러리의 특정 버전에 대한 종속성입니다.</p>
<h4>외부 공유 라이브러리 (External Shared Libraries)</h4>
<p>대부분의 데스크톱 및 서버 Linux 배포판에는 시스템 디렉터리(<code>(/usr/lib)</code>)에 설치된 공유 라이브러리의 설치를 관리하는 시스템 패키지 관리자(<code>APT</code>, <code>yum</code>, <code>pacman</code> 등)가 함께 제공됩니다. 대부분의 복잡한 Python 확장 기능은 이러한 공유 라이브러리 중 하나 이상에 의존하며, 따라서 사용자가 패키지 관리자를 사용하거나 <code>LD_LIBRARY_PATH</code>와 같은 환경 변수를 설정하여 적절한 라이브러리(및 그 적절한 버전)를 설치한 시스템에서만 제대로 작동합니다.</p>
<h4>코어 공유 라이브러리 버전 관리 (Versioning of Core Shared Libraries)</h4>
<p>Python 확장 모듈 개발자가 외부 공유 라이브러리를 사용하지 않으려 하더라도, 모듈은 일반적으로 GNU C 라이브러리인 <code>glibc</code>에 대한 동적 런타임 종속성을 가집니다. <code>glibc</code>를 정적으로 링크하는 것이 가능하더라도, <code>dlopen()</code>과 같은 일부 중요한 C 함수는 <code>glibc</code>를 정적으로 링크하는 코드에서 호출할 수 없기 때문에 일반적으로 좋지 않은 방법입니다. 실제로 시스템에서 제공하는 <code>glibc</code>에 대한 런타임 공유 라이브러리 종속성은 피할 수 없습니다.</p>
<p>GNU C 라이브러리의 유지 관리자는 하위 호환성을 위해 엄격한 심볼 버전 관리 체계를 따릅니다. 이를 통해 이전 버전의 <code>glibc</code>에 대해 컴파일된 바이너리가 최신 <code>glibc</code>를 가진 시스템에서 실행될 수 있도록 보장합니다. 반대는 일반적으로 사실이 아닙니다. 최신 Linux 배포판에서 컴파일된 바이너리는 이전 시스템에서 사용할 수 없는 <code>glibc</code>의 버전 관리된 함수에 의존하는 경향이 있습니다.</p>
<p>이것은 일반적으로 최신 Linux 배포판에서 컴파일된 <code>wheels</code>가 이식성이 떨어지는 것을 방지합니다.</p>
<h3>manylinux1 정책 (The manylinux1 policy)</h3>
<p>이러한 이유로 광범위한 이식성을 달성하기 위해 Python <code>wheels</code>는 다음 조건을 충족해야 합니다.</p>
<ul>
<li>극히 제한된 외부 공유 라이브러리 집합에만 의존해야 합니다.</li>
<li>해당 외부 공유 라이브러리에서 "오래된" 심볼 버전에만 의존해야 합니다.</li>
<li>광범위하게 호환되는 커널 ABI에만 의존해야 합니다.</li>
</ul>
<p><code>manylinux1</code> 플랫폼 태그를 얻으려면 Python <code>wheel</code>은 다음 조건을 모두 충족해야 합니다.</p>
<p>(a) 다음 목록에 있는 <code>SONAME</code>을 가진 라이브러리에만 링크하는 바이너리 실행 파일 및 컴파일된 코드를 포함해야 합니다.</p>
<pre><code>libpanelw.so.5 libncursesw.so.5 libgcc_s.so.1 libstdc++.so.6 libm.so.6 libdl.so.2 librt.so.1 libc.so.6 libnsl.so.1 libutil.so.1 libpthread.so.0 libresolv.so.2 libX11.so.6 libXext.so.6 libXrender.so.1 libICE.so.6 libSM.so.6 libGL.so.1 libgobject-2.0.so.0 libgthread-2.0.so.0 libglib-2.0.so.0
</code></pre>
<p>(b) CentOS 5.11 시스템에서 작동해야 하며, 이 시스템에는 시스템 패키지 관리자가 제공하는 위 라이브러리 버전이 포함되어야 합니다.</p>
<p><code>libcrypt.so.1</code>은 Fedora 30이 <code>libcrypt.so.2</code>와 함께 릴리스된 후 화이트리스트에서 소급적으로 제거되었습니다.</p>
<p>CentOS 5는 <code>x86_64</code> 및 <code>i686</code> 아키텍처에서만 사용할 수 있으므로, 현재 <code>manylinux1</code> 정책에서 지원하는 유일한 아키텍처입니다.</p>
<p>Debian 기반 시스템에서 이러한 라이브러리는 <code>libncurses5</code>, <code>libgcc1</code>, <code>libstdc++6</code>, <code>libc6</code>, <code>libx11-6</code>, <code>libxext6</code>, <code>libxrender1</code>, <code>libice6</code>, <code>libsm6</code>, <code>libgl1-mesa-glx</code>, <code>libglib2.0-0</code> 패키지에 의해 제공됩니다.
RPM 기반 시스템에서 이러한 라이브러리는 <code>ncurses</code>, <code>libgcc</code>, <code>libstdc++</code>, <code>glibc</code>, <code>libXext</code>, <code>libXrender</code>, <code>libICE</code>, <code>libSM</code>, <code>mesa-libGL</code>, <code>glib2</code> 패키지에 의해 제공됩니다.</p>
<p>이 목록은 Canopy 및 Anaconda 배포판의 외부 공유 라이브러리 종속성을 확인하여 컴파일되었습니다. 이 두 배포판은 가장 인기 있는 다양한 Python 모듈을 포함하며, 실제로 다양한 Linux 시스템에서 작동하는 것으로 확인되었습니다.</p>
<p>위에서 허용된 많은 시스템 라이브러리는 하위 호환성을 위해 심볼 버전 관리 체계를 사용합니다. CentOS 5.11 버전의 이러한 라이브러리와 함께 제공되는 최신 심볼 버전은 다음과 같습니다.</p>
<ul>
<li><code>GLIBC_2.5</code></li>
<li><code>CXXABI_3.4.8</code></li>
<li><code>GLIBCXX_3.4.9</code></li>
<li><code>GCC_4.2.0</code></li>
</ul>
<p>따라서 요구 사항 (b)의 결과로, 위 공유 라이브러리의 버전 관리된 심볼에 의존하는 모든 <code>wheel</code>은 다음 버전의 심볼에만 의존할 수 있습니다.</p>
<ul>
<li><code>GLIBC &#x3C;= 2.5</code></li>
<li><code>CXXABI &#x3C;= 3.4.8</code></li>
<li><code>GLIBCXX &#x3C;= 3.4.9</code></li>
<li><code>GCC &#x3C;= 4.2.0</code></li>
</ul>
<p>이러한 권장 사항은 2016년 1월의 관련 논의 결과입니다.</p>
<p><code>pip</code> 또는 PyPI가 이 정책의 세부 사항을 확인하고 강제하려고 시도해서는 안 된다는 점에 유의하십시오(기존 플랫폼 태그(<code>win32</code> 등)의 세부 사항을 확인하고 강제하지 않는 것과 마찬가지입니다). 위 텍스트는 (a) 패키지 빌더에게 조언으로, (b) 특정 <code>wheel</code>이 일부 시스템에서 작동하지 않을 경우 책임을 할당하는 방법으로 제공됩니다. 만약 <code>wheel</code>이 위 정책을 만족하면 이는 사양 또는 설치 도구의 버그입니다. 정책을 만족하지 않으면 <code>wheel</code>의 버그입니다. 이 접근 방식의 유용한 결과 중 하나는 더 많은 경험을 쌓으면서 추가 업데이트 및 조정의 가능성을 열어둔다는 것입니다. 예를 들어, 동일한 시스템을 대상으로 하고 동일한 <code>manylinux1</code> 플랫폼 태그를 사용하는 "manylinux 1.1" 정책(따라서 <code>pip</code> 또는 PyPI에 추가 변경이 필요 없음)을 가질 수 있지만, 문제가 있는 것으로 판명된 라이브러리를 제거하거나 안전한 것으로 판명된 라이브러리를 추가하도록 위 목록을 조정할 수 있습니다.</p>
<h4>libpythonX.Y.so.1</h4>
<p><code>libpythonX.Y.so.1</code>은 <code>manylinux1</code> 확장이 링크할 수 있는 라이브러리 목록에 없습니다. 거의 모든 경우에 <code>libpythonX.Y.so.1</code>에 명시적으로 링크할 필요가 없습니다. ELF 링킹 방식에 따르면, 인터프리터에 로드되는 확장 모듈은 확장이 <code>libpython</code>에 명시적으로 링크되었는지 여부와 관계없이 인터프리터의 모든 심볼에 자동으로 접근할 수 있습니다. 또한, <code>libpython</code>에 명시적으로 링크하면 Python이 <code>--enable-shared</code> 없이 빌드된 일반적인 구성에서 문제가 발생합니다. 특히 Debian 및 Ubuntu 시스템에서 <code>apt install pythonX.Y</code>는 <code>libpythonX.Y.so.1</code>을 설치하지도 않으므로, <code>libpythonX.Y.so.1</code>에 의존하는 <code>wheel</code>은 가져오기(import)에 실패할 수 있습니다.</p>
<p>이러한 방식으로 링크된 확장이 작동하지 않을 수 있는 한 가지 상황은, 호스트 프로그램(예: <code>apache2</code>)이 <code>dlopen()</code>을 사용하여 CPython 인터프리터를 내장하는 모듈(예: <code>mod_wsgi</code>)을 로드하고, 호스트 프로그램이 <code>dlopen()</code>에 <code>RTLD_GLOBAL</code> 플래그를 전달하지 않을 때입니다. 이 경우 내장된 CPython은 <code>libpythonX.Y.so.1</code>에 명시적으로 링크되지 않은 확장 모듈을 로드할 수 없습니다. 다행히 <code>apache2</code>는 <code>RTLD_GLOBAL</code> 플래그를 설정하며, 우리가 찾을 수 있었던 CPython을 <code>dlopen</code> 플러그인을 통해 내장하는 다른 모든 프로그램도 마찬가지이므로, 실제로 심각한 문제는 아닌 것으로 보입니다. Debian/Ubuntu와의 비호환성은 다소 모호한 예외 상황과의 이론적인 비호환성보다 더 큰 문제입니다.</p>
<p>이것은 <code>manylinux1</code>의 범위를 넘어서는 다소 복잡하고 미묘한 문제입니다. 더 자세한 논의는를 참조하십시오.</p>
<h4>UCS-2 vs UCS-4 빌드 (UCS-2 vs UCS-4 builds)</h4>
<p>CPython 2.x의 모든 버전과 CPython 3.0-3.2는 <code>--enable-unicode=ucs2</code> 구성 플래그를 사용하는 빌드는 유니코드 데이터를 UCS-2(실제로는 UTF-16) 형식으로 저장하고, <code>--enable-unicode=ucs4</code> 구성 플래그를 사용하는 빌드는 UCS-4 형식으로 저장하는 두 가지 ABI 비호환 모드로 빌드할 수 있습니다. (CPython 3.3 이상은 항상 UCS-4를 지원하는 다른 저장 방식을 사용합니다.) UCS-2 <code>wheels</code>가 UCS-4 CPython에 설치되지 않도록 하려면 어떤 조치가 필요합니다.</p>
<p>이 PEP의 이전 버전에는 이러한 이전 CPython 버전을 대상으로 하는 <code>manylinux1 wheels</code>가 항상 UCS-4 ABI를 사용해야 한다는 요구 사항이 포함되어 있었습니다. 그러나 PEP가 처음 수락되고 구현되는 과정에서 <code>pip</code>와 <code>wheel</code>은 관련 CPython 버전에 대한 ABI 호환성의 이 측면을 추적하고 확인하는 일류(first-class) 지원을 얻었으며, 이는 더 나은 해결책입니다. 따라서 이제 <code>manylinux1</code> 플랫폼 태그를 모든 ABI 태그와 함께 사용할 수 있도록 허용합니다. 그러나 호환성을 유지하려면 모든 <code>manylinux1 wheels</code>에 비 trivial한 ABI 태그가 포함되도록 하는 것이 중요합니다. 예를 들어, UCS-4 CPython에 대해 빌드된 <code>wheel</code>은 다음과 같은 이름을 가질 수 있습니다.</p>
<pre><code>PKG-VERSION-cp27-cp27mu-manylinux1_x86_64.whl
^^^^^^ 좋음!
</code></pre>
<p>UCS-2 ABI에 대해 빌드된 <code>wheel</code>은 다음과 같은 이름을 가질 수 있습니다.</p>
<pre><code>PKG-VERSION-cp27-cp27m-manylinux1_x86_64.whl
^^^^^ 괜찮음!
</code></pre>
<p>하지만 다음과 같은 이름의 <code>wheel</code>은 절대 안 됩니다.</p>
<pre><code>PKG-VERSION-cp27-none-manylinux1_x86_64.whl
^^^^ 나쁨! 이렇게 하지 마세요!
</code></pre>
<p>이 <code>wheel</code>은 UCS-2 및 UCS-4 빌드와 동시에 호환된다고 주장하는데, 이는 잘못된 것입니다.</p>
<p>참고로, UCS-4 ABI가 Linux CPython 배포판에서 훨씬 더 널리 퍼져 있는 것으로 보입니다.</p>
<h4>fpectl 빌드 vs. no fpectl 빌드 (fpectl builds vs. no fpectl builds)</h4>
<p>CPython의 모든 기존 버전은 <code>configure</code> 플래그 <code>--with-fpectl</code>을 사용하거나 사용하지 않고 빌드할 수 있습니다. 이 플래그는 CPython ABI를 변경하는 것으로 나타났습니다. <code>no-fpectl</code> CPython에 대해 빌드된 확장은 <code>yes-fpectl</code> CPython과 항상 호환되지만, 역은 반드시 사실이 아닙니다. (증상: 가져오기(import) 시 <code>PyFPE_jbuf</code>라는 정의되지 않은 심볼에 대한 오류 발생).</p>
<p>따라서 최대 호환성을 위해 <code>manylinux1 wheels</code>를 빌드하는 데 사용되는 CPython은 <code>--with-fpectl</code> 플래그 없이 컴파일되어야 하며, <code>manylinux1</code> 확장 기능은 <code>PyFPE_jbuf</code> 심볼을 참조해서는 안 됩니다.</p>
<h3>호환되는 <code>Wheels</code> 컴파일 (Compilation of Compliant Wheels)</h3>
<p><code>glibc</code>, <code>libgcc</code>, <code>libstdc++</code>가 심볼 버전 관리를 관리하는 방식 때문에, 실제로 대부분의 개발자가 일상 작업에 사용하는 컴파일러 툴체인은 <code>manylinux1</code> 호환 <code>wheels</code>를 빌드할 수 없습니다. 따라서 <code>pip wheel</code> / <code>bdist_wheel</code>의 기본 동작을 변경하지 않습니다. 이들은 계속해서 일반 <code>linux_*</code> 플랫폼 태그를 생성할 것이며, <code>manylinux1</code> 태그가 붙은 <code>wheels</code>를 생성하려는 개발자는 두 번째 후처리 단계에서 태그를 변경해야 합니다.</p>
<p><code>manylinux1</code> 표준을 충족하는 <code>wheels</code> 컴파일을 지원하기 위해 두 가지 도구의 초기 초안을 제공합니다.</p>
<h4>Docker 이미지 (Docker Image)</h4>
<p>첫 번째 도구는 CentOS 5.11 기반의 Docker 이미지입니다. 이 이미지는 <code>manylinux1 wheels</code>를 컴파일하기 위한 사용하기 쉬운 자체 포함 빌드 상자로 권장됩니다. 더 최근에 출시된 Linux 배포판에서 컴파일하면 일반적으로 너무 새로운 버전 관리된 심볼에 대한 종속성이 도입됩니다. 이 이미지는 완전한 컴파일러 스위트(<code>gcc</code>, <code>g++</code>, <code>gfortran 4.8.2</code>)와 최신 Python 및 <code>pip</code> 릴리스와 함께 제공됩니다.</p>
<h4>Auditwheel</h4>
<p>두 번째 도구는 <code>auditwheel</code>이라는 명령줄 실행 파일로, 패키지 관리자가 타사 외부 종속성을 처리하는 데 도움이 될 수 있습니다.</p>
<p>위 정책을 충족하는 방식으로 타사 외부 라이브러리를 사용하는 <code>wheels</code>를 빌드하는 방법은 최소 세 가지가 있습니다.</p>
<ol>
<li>타사 라이브러리를 정적으로 링크할 수 있습니다.</li>
<li>타사 공유 라이브러리를 <code>wheel</code>이 의존하는 PyPI의 별도 패키지로 배포할 수 있습니다.</li>
<li>타사 공유 라이브러리를 <code>wheel</code> 라이브러리 내부에 번들로 제공하고 상대 경로로 링크할 수 있습니다.</li>
</ol>
<p>이러한 모든 옵션은 다른 패키지 및 커뮤니티에서 효과적으로 사용될 수 있는 유효한 옵션입니다. 정적 링크는 일반적으로 빌드 시스템에 패키지별 수정이 필요하며, PyPI에 타사 종속성을 배포하려면 패키지 사용자 커뮤니티의 일부 조정이 필요할 수 있습니다.</p>
<p>이러한 옵션에 대한 종종 자동적인 대안으로 <code>auditwheel</code>을 소개합니다. 이 도구는 <code>wheel</code> 내부의 모든 ELF 파일을 검사하여 버전 관리된 심볼 또는 외부 공유 라이브러리에 대한 종속성을 확인하고 <code>manylinux1</code> 정책과의 일치를 검증합니다. 여기에는 호환되는 <code>wheels</code>에 새 플랫폼 태그를 추가하는 기능이 포함됩니다. 더 중요한 것은 <code>auditwheel</code>은 외부 공유 라이브러리에 의존하는 <code>wheels</code>를 시스템에서 <code>wheel</code> 자체로 해당 공유 라이브러리를 복사하고, 런타임에 이러한 라이브러리가 선택되도록 적절한 RPATH 항목을 수정하여 자동으로 <code>wheels</code>를 수정하는 기능을 가지고 있다는 것입니다. 이는 빌드 시스템 변경 없이 라이브러리가 정적으로 링크된 것과 유사한 결과를 달성합니다. 패키지 관리자는 번들링이 정적 링크와 마찬가지로 저작권 문제를 야기할 수 있음을 유의해야 합니다.</p>
<h3>Linux의 번들 <code>Wheels</code> (Bundled Wheels on Linux)</h3>
<p><code>manylinux1 wheels</code> 내에서 타사 라이브러리 종속성을 처리하는 여러 가지 접근 방식을 인정하지만, <code>manylinux1</code> 정책은 외부 종속성을 번들링하는 것을 권장하며, 이는 많은 Linux 배포판의 시스템 패키지 관리자의 패키지 관리 정책과 상반되는 관행입니다. 이의 주요 목적은 크로스-배포판(cross-distro) 호환성입니다. 또한 PyPI의 <code>manylinux1 wheels</code>는 시스템 패키지 관리자를 통해 제공되는 Python 패키지와는 다른 틈새시장을 차지합니다.</p>
<p>이 PEP에서 일반적인 Linux 배포판의 번들 해제 정책에서 벗어나도록 권장하는 결정은 다음 우려 사항에 따라 이루어졌습니다.</p>
<ul>
<li>자동화된 지속적인 통합(Continuous Integration) 및 배포(Deployment) 파이프라인 시대에는 새로운 버전을 게시하고 종속성을 업데이트하는 것이 이러한 정책이 정의되었을 때보다 쉽습니다.</li>
<li><code>pip</code> 사용자는 사전 빌드된 <code>wheel</code> 파일을 사용하는 대신 로컬 빌드를 강제하고 싶다면 여전히 <code>--no-binary</code> 옵션을 자유롭게 사용할 수 있습니다.</li>
<li>현대적인 컨테이너 기반 배포 및 "불변 인프라(Immutable Infrastructure)" 모델의 인기는 어차피 애플리케이션 계층에서 상당한 번들링을 포함합니다.</li>
<li>PyPI를 통한 번들 <code>wheels</code> 배포는 현재 Windows 및 OS X에서는 일반적입니다.</li>
<li>이 PEP는 미래에 특정 Linux 배포판에 대해 더 목표 지향적인 바이너리를 제공할 가능성을 배제하지 않습니다.</li>
</ul>
<p>이 PEP에 설명된 모델은 크로스 플랫폼 Python 패키지에 가장 이상적으로 적합합니다. 왜냐하면 이미 정적 Windows 및 OS X <code>wheels</code>를 만드는 데 수행하는 작업의 대부분을 재사용할 수 있기 때문입니다. 우리는 Linux의 고유한 패키지 관리 기능과 더 긴밀하게 상호 작용하고 특정 배포판의 작은 집합만 대상으로 하려는 Linux 특정 패키지에는 덜 최적화되어 있다는 것을 인정합니다.</p>
<h3>보안 영향 (Security Implications)</h3>
<p>Linux에서 중앙 집중식 라이브러리에 대한 종속성의 장점 중 하나는 버그 수정 및 보안 업데이트가 시스템 전체에 배포될 수 있으며, 이러한 라이브러리에 의존하는 애플리케이션은 기본 라이브러리가 업데이트될 때 이러한 패치의 영향을 자동으로 받는다는 것입니다. 이는 네트워크를 통한 통신 또는 암호화와 관련된 패키지의 보안 업데이트에 특히 중요할 수 있습니다.</p>
<p>OpenSSL과 같은 보안에 중요한 라이브러리를 번들링하여 PyPI를 통해 배포되는 <code>manylinux1 wheels</code>는 공개된 취약점 및 패치에 대한 신속한 업데이트의 책임을 지게 됩니다. 이는 플랫폼에 시스템 패키지 관리자가 없기 때문에 일반적으로 종속성을 번들링하는 Windows용 바이너리 <code>wheels</code> 배포의 보안 영향과 밀접하게 유사합니다. 특히 안정적인 ABI가 없기 때문에 OpenSSL은 <code>manylinux1</code> 프로필에 포함될 수 없습니다.</p>
<h3>설치자를 위한 플랫폼 감지 (Platform Detection for Installers)</h3>
<p>위에서 <code>wheel</code>이 <code>manylinux1</code> 호환이라는 것이 무엇을 의미하는지 정의했습니다. 여기서는 Python 설치가 <code>manylinux1</code> 호환이라는 것이 무엇을 의미하는지 논의합니다. 특히 이는 <code>pip</code>와 같은 도구가 <code>manylinux1</code> 태그가 붙은 <code>wheels</code>를 설치 대상으로 고려해야 할지 결정할 때 중요합니다.</p>
<p><code>manylinux1</code> 프로필은 이미 널리 사용되는 상업용 Python 배포판의 수천 명의 사용자에게 작동하는 것으로 알려져 있으므로, 설치 도구는 특별한 이유가 없는 한 시스템이 호환된다고 가정하는 쪽으로 기울어져야 한다고 제안합니다.</p>
<p>실제로 발생할 수 있는 잠재적인 비호환성의 네 가지 주요 원인을 알고 있습니다.</p>
<ul>
<li>결국 미래에는 이 프로필과 호환되지 않는 배포판이 존재할 수 있습니다(예: 프로필의 라이브러리 중 하나가 하위 호환되지 않는 방식으로 ABI를 변경하는 경우).</li>
<li>너무 오래된 Linux 배포판(예: RHEL 4)</li>
<li><code>glibc</code>를 사용하지 않는 Linux 배포판(예: <code>musl libc</code> 기반의 Alpine Linux 또는 Android)</li>
</ul>
<p>이러한 문제에 대처하기 위해 두 가지 접근 방식을 제안합니다. 잠재적인 미래 비호환성을 처리하기 위해, Python 배포자가 특정 Python 설치가 <code>manylinux1</code>와 확실히 호환되는지 또는 호환되지 않는지 알리는 메커니즘을 표준화합니다. 이는 <code>_manylinux</code>라는 모듈을 설치하고 <code>manylinux1_compatible</code> 속성을 설정하여 수행됩니다. 이러한 모듈을 표준 라이브러리에 추가하는 것은 제안하지 않습니다. 이는 배포자와 설치 도구가 만나기 위한 잘 알려진 이름일 뿐입니다. 그러나 배포자가 이 모듈을 추가하는 경우, <code>site-packages/</code> 디렉터리보다는 표준 라이브러리에 추가해야 합니다. 왜냐하면 표준 라이브러리는 <code>virtualenvs</code>에 의해 상속되고(<code>virtualenvs</code>에 상속되기를 원함), <code>site-packages/</code>는 일반적으로 그렇지 않기 때문입니다.</p>
<p>그런 다음 기존 Python 배포판에 대한 마지막 두 가지 경우를 처리하기 위해 <code>glibc</code>의 존재 및 버전을 확인하는 간단하고 신뢰할 수 있는 방법을 제안합니다(기본적으로 전체 배포판의 "연령"에 대한 "시계"로 사용).</p>
<p>구체적으로 제안하는 알고리즘은 다음과 같습니다.</p>
<pre><code class="language-python">def is_manylinux1_compatible():
    # Only Linux, and only x86-64 / i686
    from distutils.util import get_platform
    if get_platform() not in ["linux-x86_64", "linux-i686"]:
        return False

    # Check for presence of _manylinux module
    try:
        import _manylinux
        return bool(_manylinux.manylinux1_compatible)
    except (ImportError, AttributeError):
        # Fall through to heuristic check below
        pass

    # Check glibc version. CentOS 5 uses glibc 2.5.
    return have_compatible_glibc(2, 5)

def have_compatible_glibc(major, minimum_minor):
    import ctypes
    process_namespace = ctypes.CDLL(None)
    try:
        gnu_get_libc_version = process_namespace.gnu_get_libc_version
    except AttributeError:
        # Symbol doesn't exist -> therefore, we are not linked to
        # glibc.
        return False

    # Call gnu_get_libc_version, which returns a string like "2.5".
    gnu_get_libc_version.restype = ctypes.c_char_p
    version_str = gnu_get_libc_version()

    # py2 / py3 compatibility: if not isinstance(version_str, str):
    if not isinstance(version_str, str):
        version_str = version_str.decode("ascii")

    # Parse string and check against requested version.
    version = [int(piece) for piece in version_str.split(".")]
    assert len(version) == 2
    if major != version[0]:
        return False
    if minimum_minor > version[1]:
        return False
    return True
</code></pre>
<p><strong>거부된 대안:</strong> 우리는 또한 <code>(/etc/python/compatibility.cfg)</code>와 같은 구성 파일을 사용하는 것을 고려했습니다. 이 방법의 문제점은 단일 파일 시스템에 각기 고유한 ABI 프로필을 가진 여러 다른 인터프리터 환경이 포함될 수 있다는 것입니다. 시스템에 설치된 <code>x86_64 CPython</code>의 <code>manylinux1</code> 호환성이 사용자 설치 <code>i686 PyPy</code>의 <code>manylinux1</code> 호환성에 대해 많은 것을 알려주지 않을 수 있습니다. 이 구성 정보를 Python 환경 자체 내에 배치하면 올바른 바이너리에 계속 연결되어 있고 조회 코드가 크게 단순화됩니다.</p>
<p>우리는 또한 호환 가능한 것으로 간주되어야 하는 모든 플랫폼 태그 목록과 그 선호도 순서를 포함하는 더 정교한 구조를 사용하는 것도 고려했습니다. 예를 들어 <code>_binary_compat.compatible = ["manylinux1_x86_64", "centos5_x86_64", "linux_x86_64"]</code>와 같습니다. 그러나 이것은 몇 가지 복잡성을 야기합니다. 예를 들어, "manylinux1을 지원하지 않음"(또는 결국 <code>manylinux2</code> 등) 상태와 "manylinux1 지원 여부를 명시적으로 지정하지 않음" 상태를 구별할 수 있어야 하는데, 이는 위 표현에서 완전히 명확하지 않습니다. 또한 현재 유일하게 가능한 플랫폼 태그가 <code>manylinux1</code>과 <code>linux</code>라는 점을 감안할 때 선호도 순서와 관련하여 실제로 필요한 기능이 무엇인지 전혀 명확하지 않습니다. 따라서 Linux가 더 많은 플랫폼 태그를 얻게 될 때 별도의 PEP에서 더 완전한 해결책을 보류하고 있습니다.</p>
<p>라이브러리 호환성 검사를 위해 훨씬 더 정교한 검사(예: 커널 버전 확인, <code>manylinux1</code> 프로필에 나열된 모든 개별 라이브러리 검색 및 버전 확인 등)도 고려했지만, 궁극적으로 이는 사용자에게 실제로 도움이 되기보다는 혼란스러운 버그를 유발할 가능성이 더 높다고 판단했습니다. (예: 다른 배포판은 이러한 라이브러리를 실제로 어디에 두는지 다르며, 검사 코드가 올바른 경로 검색을 사용하지 못하면 쉽게 잘못된 답변을 반환할 수 있습니다.)</p>
<h3>PyPI 지원 (PyPI Support)</h3>
<p>PyPI는 <code>manylinux1</code> 플랫폼 태그를 포함하는 <code>wheels</code>의 업로드를 허용해야 합니다. PyPI는 <code>manylinux1</code> 플랫폼 태그를 포함하는 <code>wheels</code>가 이 문서에 설명된 <code>manylinux1</code> 정책을 준수하는지 공식적으로 확인하려고 시도해서는 안 됩니다. 이러한 검증 작업은 <code>auditwheel</code>과 같이 별도로 개발된 다른 도구에 맡겨야 합니다.</p>
<h3>거부된 대안 (Rejected Alternatives)</h3>
<p>한 가지 대안은 각 Linux 배포판(및 각 버전)에 대해 별도의 플랫폼 태그를 제공하는 것이었습니다. 예를 들어 <code>RHEL6</code>, <code>ubuntu14_10</code>, <code>debian_jessie</code> 등입니다. 이 제안의 어떤 내용도 미래에 이러한 플랫폼 태그를 추가할 가능성이나, <code>wheels</code>가 외부 시스템 설치 패키지에 대한 종속성을 선언할 수 있도록 하는 <code>wheel</code> 메타데이터에 대한 추가 확장을 배제하지 않습니다. 그러나 이러한 확장은 이 제안보다 훨씬 더 많은 작업을 필요로 하며, 모든 일반적인 Linux 배포판을 포괄하기 위해 여러 빌드 환경을 유지하고 여러 <code>wheels</code>를 빌드해야 하는 것을 선호하지 않는 패키지 개발자에게 여전히 좋게 평가되지 않을 수 있습니다. 따라서 우리는 그러한 제안들을 이 PEP의 범위를 벗어나는 것으로 간주합니다.</p>
<h3>향후 업데이트 (Future updates)</h3>
<p>미래의 어느 시점에는 더 현대적인 기준 환경(아마도 CentOS 6 기반)을 지정하는 <code>manylinux2</code>가 있을 것이고, 언젠가는 <code>manylinux3</code> 등이 있을 것으로 예상하지만, 초기 <code>manylinux1</code> 제안에 대한 더 많은 경험을 얻을 때까지는 이러한 사양을 연기합니다.</p>
<h3>참조 (References)</h3>
<p>PEP 513은 다음 자료들을 참조합니다.</p>
<ul>
<li>Enthought Canopy Python Distribution (https://store.enthought.com/downloads/)</li>
<li>Continuum Analytics Anaconda Python Distribution (https://www.continuum.io/downloads)</li>
<li>CentOS 5.11 Release Notes (https://wiki.centos.org/Manuals/ReleaseNotes/CentOS5.11)</li>
<li>manylinux-discuss mailing list discussion (https://groups.google.com/forum/#!topic/manylinux-discuss/-4l3rrjfr9U)</li>
<li>distutils-sig discussion (https://mail.python.org/pipermail/distutils-sig/2016-January/027997.html)</li>
<li>distutils-sig discussion (https://mail.python.org/pipermail/distutils-sig/2016-February/028275.html)</li>
<li>github issue discussion (https://github.com/pypa/manylinux/issues/30)</li>
<li>python bug tracker discussion (https://bugs.python.org/issue21536)</li>
<li>manylinux1 docker images (Source: https://github.com/pypa/manylinux; x86-64: https://quay.io/repository/pypa/manylinux1_x86_64; x86-32: https://quay.io/repository/pypa/manylinux1_i686)</li>
<li>auditwheel tool (https://pypi.python.org/pypi/auditwheel)</li>
<li>Fedora Bundled Software Policy (https://fedoraproject.org/wiki/Bundled_Software_policy)</li>
<li>Debian Policy Manual – 4.13: Convenience copies of code (https://www.debian.org/doc/debian-policy/ch-source.html#s-embeddedfiles)</li>
<li>numpy bug report: https://github.com/numpy/numpy/issues/8415#issuecomment-269095235</li>
</ul>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.
Source: https://github.com/python/peps/blob/main/peps/pep-0513.rst
최종 수정: 2025-02-01 08:59:27 GMT</p>
<p><strong>거부된 대안:</strong> 우리는 또한 <code>(/etc/python/compatibility.cfg)</code>와 같은 구성 파일을 사용하는 것을 고려했습니다. 이 방법의 문제점은 단일 파일 시스템에 각기 고유한 ABI 프로필을 가진 여러 다른 인터프리터 환경이 포함될 수 있다는 것입니다. 시스템에 설치된 <code>x86_64 CPython</code>의 <code>manylinux1</code> 호환성이 사용자 설치 <code>i686 PyPy</code>의 <code>manylinux1</code> 호환성에 대해 많은 것을 알려주지 않을 수 있습니다. 이 구성 정보를 Python 환경 자체 내에 배치하면 올바른 바이너리에 계속 연결되어 있고 조회 코드가 크게 단순화됩니다.</p>
<p>우리는 또한 호환 가능한 것으로 간주되어야 하는 모든 플랫폼 태그 목록과 그 선호도 순서를 포함하는 더 정교한 구조를 사용하는 것도 고려했습니다. 예를 들어 <code>_binary_compat.compatible = ["manylinux1_x86_64", "centos5_x86_64", "linux_x86_64"]</code>와 같습니다. 그러나 이것은 몇 가지 복잡성을 야기합니다. 예를 들어, "manylinux1을 지원하지 않음"(또는 결국 <code>manylinux2</code> 등) 상태와 "manylinux1 지원 여부를 명시적으로 지정하지 않음" 상태를 구별할 수 있어야 하는데, 이는 위 표현에서 완전히 명확하지 않습니다. 또한 현재 유일하게 가능한 플랫폼 태그가 <code>manylinux1</code>과 <code>linux</code>라는 점을 감안할 때 선호도 순서와 관련하여 실제로 필요한 기능이 무엇인지 전혀 명확하지 않습니다. 따라서 Linux가 더 많은 플랫폼 태그를 얻게 될 때 별도의 PEP에서 더 완전한 해결책을 보류하고 있습니다.</p>
<p>라이브러리 호환성 검사를 위해 훨씬 더 정교한 검사(예: 커널 버전 확인, <code>manylinux1</code> 프로필에 나열된 모든 개별 라이브러리 검색 및 버전 확인 등)도 고려했지만, 궁극적으로 이는 사용자에게 실제로 도움이 되기보다는 혼란스러운 버그를 유발할 가능성이 더 높다고 판단했습니다. (예: 다른 배포판은 이러한 라이브러리를 실제로 어디에 두는지 다르며, 검사 코드가 올바른 경로 검색을 사용하지 못하면 쉽게 잘못된 답변을 반환할 수 있습니다.)</p>
<h3>PyPI 지원 (PyPI Support)</h3>
<p>PyPI는 <code>manylinux1</code> 플랫폼 태그를 포함하는 <code>wheels</code>의 업로드를 허용해야 합니다. PyPI는 <code>manylinux1</code> 플랫폼 태그를 포함하는 <code>wheels</code>가 이 문서에 설명된 <code>manylinux1</code> 정책을 준수하는지 공식적으로 확인하려고 시도해서는 안 됩니다. 이러한 검증 작업은 <code>auditwheel</code>과 같이 별도로 개발된 다른 도구에 맡겨야 합니다.</p>
<h3>거부된 대안 (Rejected Alternatives)</h3>
<p>한 가지 대안은 각 Linux 배포판(및 각 버전)에 대해 별도의 플랫폼 태그를 제공하는 것이었습니다. 예를 들어 <code>RHEL6</code>, <code>ubuntu14_10</code>, <code>debian_jessie</code> 등입니다. 이 제안의 어떤 내용도 미래에 이러한 플랫폼 태그를 추가할 가능성이나, <code>wheels</code>가 외부 시스템 설치 패키지에 대한 종속성을 선언할 수 있도록 하는 <code>wheel</code> 메타데이터에 대한 추가 확장을 배제하지 않습니다. 그러나 이러한 확장은 이 제안보다 훨씬 더 많은 작업을 필요로 하며, 모든 일반적인 Linux 배포판을 포괄하기 위해 여러 빌드 환경을 유지하고 여러 <code>wheels</code>를 빌드해야 하는 것을 선호하지 않는 패키지 개발자에게 여전히 좋게 평가되지 않을 수 있습니다. 따라서 우리는 그러한 제안들을 이 PEP의 범위를 벗어나는 것으로 간주합니다.</p>
<h3>향후 업데이트 (Future updates)</h3>
<p>미래의 어느 시점에는 더 현대적인 기준 환경(아마도 CentOS 6 기반)을 지정하는 <code>manylinux2</code>가 있을 것이고, 언젠가는 <code>manylinux3</code> 등이 있을 것으로 예상하지만, 초기 <code>manylinux1</code> 제안에 대한 더 많은 경험을 얻을 때까지는 이러한 사양을 연기합니다.</p>
<h3>참조 (References)</h3>
<p>PEP 513은 다음 자료들을 참조합니다.</p>
<ul>
<li>Enthought Canopy Python Distribution (https://store.enthought.com/downloads/)</li>
<li>Continuum Analytics Anaconda Python Distribution (https://www.continuum.io/downloads)</li>
<li>CentOS 5.11 Release Notes (https://wiki.centos.org/Manuals/ReleaseNotes/CentOS5.11)</li>
<li>manylinux-discuss mailing list discussion (https://groups.google.com/forum/#!topic/manylinux-discuss/-4l3rrjfr9U)</li>
<li>distutils-sig discussion (https://mail.python.org/pipermail/distutils-sig/2016-January/027997.html)</li>
<li>distutils-sig discussion (https://mail.python.org/pipermail/distutils-sig/2016-February/028275.html)</li>
<li>github issue discussion (https://github.com/pypa/manylinux/issues/30)</li>
<li>python bug tracker discussion (https://bugs.python.org/issue21536)</li>
<li>manylinux1 docker images (Source: https://github.com/pypa/manylinux; x86-64: https://quay.io/repository/pypa/manylinux1_x86_64; x86-32: https://quay.io/repository/pypa/manylinux1_i686)</li>
<li>auditwheel tool (https://pypi.python.org/pypi/auditwheel)</li>
<li>Fedora Bundled Software Policy (https://fedoraproject.org/wiki/Bundled_Software_policy)</li>
<li>Debian Policy Manual – 4.13: Convenience copies of code (https://www.debian.org/doc/debian-policy/ch-source.html#s-embeddedfiles)</li>
<li>numpy bug report: https://github.com/numpy/numpy/issues/8415#issuecomment-269095235</li>
</ul>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.
Source: https://github.com/python/peps/blob/main/peps/pep-0513.rst
최종 수정: 2025-02-01 08:59:27 GMT</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/513\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"jf5MDuRUbMNVvRN9tv5rq\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/513/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/513\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"513\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/513\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T9d3d,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0513/\"\u003ePEP 513 - A Platform Tag for Portable Linux Built Distributions\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Superseded | \u003cstrong\u003e유형:\u003c/strong\u003e Informational | \u003cstrong\u003e작성일:\u003c/strong\u003e 19-Jan-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 513 – 휴대용 Linux 빌드 배포판을 위한 플랫폼 태그\u003c/h2\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP(Python Enhancement Proposal)는 Python 패키지 빌드 배포판, 특히 \u003ccode\u003ewheels\u003c/code\u003e를 위한 새로운 플랫폼 태그인 \u003ccode\u003emanylinux1_{x86_64,i686}\u003c/code\u003e 생성을 제안합니다. 이 태그를 사용하는 \u003ccode\u003ewheels\u003c/code\u003e는 표준화되고 제한된 Linux 커널 및 핵심 사용자 공간 ABI(Application Binary Interface)의 하위 집합에만 외부 종속성을 가집니다. PyPI(Python Package Index)가 이 플랫폼 태그를 가진 \u003ccode\u003ewheels\u003c/code\u003e의 업로드 및 배포를 지원하고, \u003ccode\u003epip\u003c/code\u003e는 호환 가능한 플랫폼에서 이 패키지들을 다운로드 및 설치할 수 있도록 지원하는 것을 목표로 합니다.\u003c/p\u003e\n\u003ch3\u003e배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003e현재 Windows 및 OS X용 바이너리 Python 확장을 배포하는 것은 간단합니다. 개발자들은 \u003ccode\u003ewheels\u003c/code\u003e (PEP 427, PEP 491)를 빌드하여 \u003ccode\u003ewin32\u003c/code\u003e 또는 \u003ccode\u003emacosx_10_6_intel\u003c/code\u003e과 같은 플랫폼 태그를 할당하고 PyPI에 업로드합니다. 사용자들은 \u003ccode\u003epip\u003c/code\u003e와 같은 도구를 사용하여 이 \u003ccode\u003ewheels\u003c/code\u003e를 다운로드하고 설치할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 Linux의 경우 상황이 훨씬 복잡합니다. 일반적으로 한 Linux 배포판에서 빌드된 컴파일된 Python 확장 모듈은 다른 Linux 배포판에서는 작동하지 않거나, 심지어 동일한 Linux 배포판을 실행하는 다른 시스템에서도 시스템 라이브러리가 다르면 작동하지 않을 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePEP 425 플랫폼 태그를 사용하는 빌드 도구는 특정 Linux 배포판이나 설치된 시스템 라이브러리에 대한 정보를 추적하지 않고, 모든 \u003ccode\u003ewheels\u003c/code\u003e에 \u003ccode\u003elinux_i686\u003c/code\u003e 또는 \u003ccode\u003elinux_x86_64\u003c/code\u003e와 같이 너무 모호한 태그를 할당합니다. 이러한 불확실성 때문에 한 머신에서 컴파일된 \u003ccode\u003elinux\u003c/code\u003e 태그가 붙은 빌드 배포판이 다른 머신에서 제대로 작동할 것이라는 기대가 없으며, 이러한 이유로 PyPI는 Linux용 \u003ccode\u003ewheels\u003c/code\u003e 업로드를 허용하지 않았습니다.\u003c/p\u003e\n\u003cp\u003e어떤 Linux 시스템에서도 작동할 수 있는 \u003ccode\u003ewheel\u003c/code\u003e 패키지를 컴파일할 수 있다면 이상적일 것입니다. 그러나 PC에서 Android, 그리고 커스텀 \u003ccode\u003elibc\u003c/code\u003e를 사용하는 임베디드 시스템에 이르기까지 Linux 시스템의 엄청난 다양성 때문에 이는 일반적으로 보장될 수 없습니다.\u003c/p\u003e\n\u003cp\u003e대신, 이 PEP는 실제로 널리 사용되는 모든 데스크톱 및 서버 배포판을 포함하여 많은 Linux 시스템에서 호환될 만큼 충분한 커널 및 핵심 사용자 공간 ABI의 표준 하위 집합을 정의합니다. Enthought의 Canopy 및 Continuum Analytics의 Anaconda와 같은 회사들이 Linux용으로 이처럼 널리 이식 가능한 사전 컴파일된 Python 확장 모듈을 배포해왔기 때문에 이것이 가능하다는 것을 알고 있습니다.\u003c/p\u003e\n\u003cp\u003e이 회사들로부터 얻은 호환성 교훈을 바탕으로, 바이너리 Python \u003ccode\u003ewheels\u003c/code\u003e에서 사용할 \u003ccode\u003emanylinux1\u003c/code\u003e 플랫폼 태그를 정의하고, 이러한 \u003ccode\u003emanylinux1 wheels\u003c/code\u003e의 구축을 돕기 위한 초기 도구 구현을 소개합니다.\u003c/p\u003e\n\u003ch3\u003eLinux 바이너리 비호환성의 주요 원인 (Key Causes of Inter-Linux Binary Incompatibility)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ewheel\u003c/code\u003e 패키지가 많은 Linux 플랫폼에서 작동하도록 보장하는 표준을 올바르게 정의하려면, Linux에서 사전 컴파이된 이식성이 저해되는 근본적인 원인(Root Causes)을 이해해야 합니다. 두 가지 주요 원인은 사용자 시스템에 존재하지 않는 공유 라이브러리에 대한 종속성과 \u003ccode\u003eglibc\u003c/code\u003e와 같은 특정 코어 라이브러리의 특정 버전에 대한 종속성입니다.\u003c/p\u003e\n\u003ch4\u003e외부 공유 라이브러리 (External Shared Libraries)\u003c/h4\u003e\n\u003cp\u003e대부분의 데스크톱 및 서버 Linux 배포판에는 시스템 디렉터리(\u003ccode\u003e(/usr/lib)\u003c/code\u003e)에 설치된 공유 라이브러리의 설치를 관리하는 시스템 패키지 관리자(\u003ccode\u003eAPT\u003c/code\u003e, \u003ccode\u003eyum\u003c/code\u003e, \u003ccode\u003epacman\u003c/code\u003e 등)가 함께 제공됩니다. 대부분의 복잡한 Python 확장 기능은 이러한 공유 라이브러리 중 하나 이상에 의존하며, 따라서 사용자가 패키지 관리자를 사용하거나 \u003ccode\u003eLD_LIBRARY_PATH\u003c/code\u003e와 같은 환경 변수를 설정하여 적절한 라이브러리(및 그 적절한 버전)를 설치한 시스템에서만 제대로 작동합니다.\u003c/p\u003e\n\u003ch4\u003e코어 공유 라이브러리 버전 관리 (Versioning of Core Shared Libraries)\u003c/h4\u003e\n\u003cp\u003ePython 확장 모듈 개발자가 외부 공유 라이브러리를 사용하지 않으려 하더라도, 모듈은 일반적으로 GNU C 라이브러리인 \u003ccode\u003eglibc\u003c/code\u003e에 대한 동적 런타임 종속성을 가집니다. \u003ccode\u003eglibc\u003c/code\u003e를 정적으로 링크하는 것이 가능하더라도, \u003ccode\u003edlopen()\u003c/code\u003e과 같은 일부 중요한 C 함수는 \u003ccode\u003eglibc\u003c/code\u003e를 정적으로 링크하는 코드에서 호출할 수 없기 때문에 일반적으로 좋지 않은 방법입니다. 실제로 시스템에서 제공하는 \u003ccode\u003eglibc\u003c/code\u003e에 대한 런타임 공유 라이브러리 종속성은 피할 수 없습니다.\u003c/p\u003e\n\u003cp\u003eGNU C 라이브러리의 유지 관리자는 하위 호환성을 위해 엄격한 심볼 버전 관리 체계를 따릅니다. 이를 통해 이전 버전의 \u003ccode\u003eglibc\u003c/code\u003e에 대해 컴파일된 바이너리가 최신 \u003ccode\u003eglibc\u003c/code\u003e를 가진 시스템에서 실행될 수 있도록 보장합니다. 반대는 일반적으로 사실이 아닙니다. 최신 Linux 배포판에서 컴파일된 바이너리는 이전 시스템에서 사용할 수 없는 \u003ccode\u003eglibc\u003c/code\u003e의 버전 관리된 함수에 의존하는 경향이 있습니다.\u003c/p\u003e\n\u003cp\u003e이것은 일반적으로 최신 Linux 배포판에서 컴파일된 \u003ccode\u003ewheels\u003c/code\u003e가 이식성이 떨어지는 것을 방지합니다.\u003c/p\u003e\n\u003ch3\u003emanylinux1 정책 (The manylinux1 policy)\u003c/h3\u003e\n\u003cp\u003e이러한 이유로 광범위한 이식성을 달성하기 위해 Python \u003ccode\u003ewheels\u003c/code\u003e는 다음 조건을 충족해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e극히 제한된 외부 공유 라이브러리 집합에만 의존해야 합니다.\u003c/li\u003e\n\u003cli\u003e해당 외부 공유 라이브러리에서 \"오래된\" 심볼 버전에만 의존해야 합니다.\u003c/li\u003e\n\u003cli\u003e광범위하게 호환되는 커널 ABI에만 의존해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003emanylinux1\u003c/code\u003e 플랫폼 태그를 얻으려면 Python \u003ccode\u003ewheel\u003c/code\u003e은 다음 조건을 모두 충족해야 합니다.\u003c/p\u003e\n\u003cp\u003e(a) 다음 목록에 있는 \u003ccode\u003eSONAME\u003c/code\u003e을 가진 라이브러리에만 링크하는 바이너리 실행 파일 및 컴파일된 코드를 포함해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elibpanelw.so.5 libncursesw.so.5 libgcc_s.so.1 libstdc++.so.6 libm.so.6 libdl.so.2 librt.so.1 libc.so.6 libnsl.so.1 libutil.so.1 libpthread.so.0 libresolv.so.2 libX11.so.6 libXext.so.6 libXrender.so.1 libICE.so.6 libSM.so.6 libGL.so.1 libgobject-2.0.so.0 libgthread-2.0.so.0 libglib-2.0.so.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(b) CentOS 5.11 시스템에서 작동해야 하며, 이 시스템에는 시스템 패키지 관리자가 제공하는 위 라이브러리 버전이 포함되어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003elibcrypt.so.1\u003c/code\u003e은 Fedora 30이 \u003ccode\u003elibcrypt.so.2\u003c/code\u003e와 함께 릴리스된 후 화이트리스트에서 소급적으로 제거되었습니다.\u003c/p\u003e\n\u003cp\u003eCentOS 5는 \u003ccode\u003ex86_64\u003c/code\u003e 및 \u003ccode\u003ei686\u003c/code\u003e 아키텍처에서만 사용할 수 있으므로, 현재 \u003ccode\u003emanylinux1\u003c/code\u003e 정책에서 지원하는 유일한 아키텍처입니다.\u003c/p\u003e\n\u003cp\u003eDebian 기반 시스템에서 이러한 라이브러리는 \u003ccode\u003elibncurses5\u003c/code\u003e, \u003ccode\u003elibgcc1\u003c/code\u003e, \u003ccode\u003elibstdc++6\u003c/code\u003e, \u003ccode\u003elibc6\u003c/code\u003e, \u003ccode\u003elibx11-6\u003c/code\u003e, \u003ccode\u003elibxext6\u003c/code\u003e, \u003ccode\u003elibxrender1\u003c/code\u003e, \u003ccode\u003elibice6\u003c/code\u003e, \u003ccode\u003elibsm6\u003c/code\u003e, \u003ccode\u003elibgl1-mesa-glx\u003c/code\u003e, \u003ccode\u003elibglib2.0-0\u003c/code\u003e 패키지에 의해 제공됩니다.\nRPM 기반 시스템에서 이러한 라이브러리는 \u003ccode\u003encurses\u003c/code\u003e, \u003ccode\u003elibgcc\u003c/code\u003e, \u003ccode\u003elibstdc++\u003c/code\u003e, \u003ccode\u003eglibc\u003c/code\u003e, \u003ccode\u003elibXext\u003c/code\u003e, \u003ccode\u003elibXrender\u003c/code\u003e, \u003ccode\u003elibICE\u003c/code\u003e, \u003ccode\u003elibSM\u003c/code\u003e, \u003ccode\u003emesa-libGL\u003c/code\u003e, \u003ccode\u003eglib2\u003c/code\u003e 패키지에 의해 제공됩니다.\u003c/p\u003e\n\u003cp\u003e이 목록은 Canopy 및 Anaconda 배포판의 외부 공유 라이브러리 종속성을 확인하여 컴파일되었습니다. 이 두 배포판은 가장 인기 있는 다양한 Python 모듈을 포함하며, 실제로 다양한 Linux 시스템에서 작동하는 것으로 확인되었습니다.\u003c/p\u003e\n\u003cp\u003e위에서 허용된 많은 시스템 라이브러리는 하위 호환성을 위해 심볼 버전 관리 체계를 사용합니다. CentOS 5.11 버전의 이러한 라이브러리와 함께 제공되는 최신 심볼 버전은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eGLIBC_2.5\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCXXABI_3.4.8\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGLIBCXX_3.4.9\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGCC_4.2.0\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e따라서 요구 사항 (b)의 결과로, 위 공유 라이브러리의 버전 관리된 심볼에 의존하는 모든 \u003ccode\u003ewheel\u003c/code\u003e은 다음 버전의 심볼에만 의존할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eGLIBC \u0026#x3C;= 2.5\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCXXABI \u0026#x3C;= 3.4.8\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGLIBCXX \u0026#x3C;= 3.4.9\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGCC \u0026#x3C;= 4.2.0\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 권장 사항은 2016년 1월의 관련 논의 결과입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epip\u003c/code\u003e 또는 PyPI가 이 정책의 세부 사항을 확인하고 강제하려고 시도해서는 안 된다는 점에 유의하십시오(기존 플랫폼 태그(\u003ccode\u003ewin32\u003c/code\u003e 등)의 세부 사항을 확인하고 강제하지 않는 것과 마찬가지입니다). 위 텍스트는 (a) 패키지 빌더에게 조언으로, (b) 특정 \u003ccode\u003ewheel\u003c/code\u003e이 일부 시스템에서 작동하지 않을 경우 책임을 할당하는 방법으로 제공됩니다. 만약 \u003ccode\u003ewheel\u003c/code\u003e이 위 정책을 만족하면 이는 사양 또는 설치 도구의 버그입니다. 정책을 만족하지 않으면 \u003ccode\u003ewheel\u003c/code\u003e의 버그입니다. 이 접근 방식의 유용한 결과 중 하나는 더 많은 경험을 쌓으면서 추가 업데이트 및 조정의 가능성을 열어둔다는 것입니다. 예를 들어, 동일한 시스템을 대상으로 하고 동일한 \u003ccode\u003emanylinux1\u003c/code\u003e 플랫폼 태그를 사용하는 \"manylinux 1.1\" 정책(따라서 \u003ccode\u003epip\u003c/code\u003e 또는 PyPI에 추가 변경이 필요 없음)을 가질 수 있지만, 문제가 있는 것으로 판명된 라이브러리를 제거하거나 안전한 것으로 판명된 라이브러리를 추가하도록 위 목록을 조정할 수 있습니다.\u003c/p\u003e\n\u003ch4\u003elibpythonX.Y.so.1\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003elibpythonX.Y.so.1\u003c/code\u003e은 \u003ccode\u003emanylinux1\u003c/code\u003e 확장이 링크할 수 있는 라이브러리 목록에 없습니다. 거의 모든 경우에 \u003ccode\u003elibpythonX.Y.so.1\u003c/code\u003e에 명시적으로 링크할 필요가 없습니다. ELF 링킹 방식에 따르면, 인터프리터에 로드되는 확장 모듈은 확장이 \u003ccode\u003elibpython\u003c/code\u003e에 명시적으로 링크되었는지 여부와 관계없이 인터프리터의 모든 심볼에 자동으로 접근할 수 있습니다. 또한, \u003ccode\u003elibpython\u003c/code\u003e에 명시적으로 링크하면 Python이 \u003ccode\u003e--enable-shared\u003c/code\u003e 없이 빌드된 일반적인 구성에서 문제가 발생합니다. 특히 Debian 및 Ubuntu 시스템에서 \u003ccode\u003eapt install pythonX.Y\u003c/code\u003e는 \u003ccode\u003elibpythonX.Y.so.1\u003c/code\u003e을 설치하지도 않으므로, \u003ccode\u003elibpythonX.Y.so.1\u003c/code\u003e에 의존하는 \u003ccode\u003ewheel\u003c/code\u003e은 가져오기(import)에 실패할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 방식으로 링크된 확장이 작동하지 않을 수 있는 한 가지 상황은, 호스트 프로그램(예: \u003ccode\u003eapache2\u003c/code\u003e)이 \u003ccode\u003edlopen()\u003c/code\u003e을 사용하여 CPython 인터프리터를 내장하는 모듈(예: \u003ccode\u003emod_wsgi\u003c/code\u003e)을 로드하고, 호스트 프로그램이 \u003ccode\u003edlopen()\u003c/code\u003e에 \u003ccode\u003eRTLD_GLOBAL\u003c/code\u003e 플래그를 전달하지 않을 때입니다. 이 경우 내장된 CPython은 \u003ccode\u003elibpythonX.Y.so.1\u003c/code\u003e에 명시적으로 링크되지 않은 확장 모듈을 로드할 수 없습니다. 다행히 \u003ccode\u003eapache2\u003c/code\u003e는 \u003ccode\u003eRTLD_GLOBAL\u003c/code\u003e 플래그를 설정하며, 우리가 찾을 수 있었던 CPython을 \u003ccode\u003edlopen\u003c/code\u003e 플러그인을 통해 내장하는 다른 모든 프로그램도 마찬가지이므로, 실제로 심각한 문제는 아닌 것으로 보입니다. Debian/Ubuntu와의 비호환성은 다소 모호한 예외 상황과의 이론적인 비호환성보다 더 큰 문제입니다.\u003c/p\u003e\n\u003cp\u003e이것은 \u003ccode\u003emanylinux1\u003c/code\u003e의 범위를 넘어서는 다소 복잡하고 미묘한 문제입니다. 더 자세한 논의는를 참조하십시오.\u003c/p\u003e\n\u003ch4\u003eUCS-2 vs UCS-4 빌드 (UCS-2 vs UCS-4 builds)\u003c/h4\u003e\n\u003cp\u003eCPython 2.x의 모든 버전과 CPython 3.0-3.2는 \u003ccode\u003e--enable-unicode=ucs2\u003c/code\u003e 구성 플래그를 사용하는 빌드는 유니코드 데이터를 UCS-2(실제로는 UTF-16) 형식으로 저장하고, \u003ccode\u003e--enable-unicode=ucs4\u003c/code\u003e 구성 플래그를 사용하는 빌드는 UCS-4 형식으로 저장하는 두 가지 ABI 비호환 모드로 빌드할 수 있습니다. (CPython 3.3 이상은 항상 UCS-4를 지원하는 다른 저장 방식을 사용합니다.) UCS-2 \u003ccode\u003ewheels\u003c/code\u003e가 UCS-4 CPython에 설치되지 않도록 하려면 어떤 조치가 필요합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP의 이전 버전에는 이러한 이전 CPython 버전을 대상으로 하는 \u003ccode\u003emanylinux1 wheels\u003c/code\u003e가 항상 UCS-4 ABI를 사용해야 한다는 요구 사항이 포함되어 있었습니다. 그러나 PEP가 처음 수락되고 구현되는 과정에서 \u003ccode\u003epip\u003c/code\u003e와 \u003ccode\u003ewheel\u003c/code\u003e은 관련 CPython 버전에 대한 ABI 호환성의 이 측면을 추적하고 확인하는 일류(first-class) 지원을 얻었으며, 이는 더 나은 해결책입니다. 따라서 이제 \u003ccode\u003emanylinux1\u003c/code\u003e 플랫폼 태그를 모든 ABI 태그와 함께 사용할 수 있도록 허용합니다. 그러나 호환성을 유지하려면 모든 \u003ccode\u003emanylinux1 wheels\u003c/code\u003e에 비 trivial한 ABI 태그가 포함되도록 하는 것이 중요합니다. 예를 들어, UCS-4 CPython에 대해 빌드된 \u003ccode\u003ewheel\u003c/code\u003e은 다음과 같은 이름을 가질 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePKG-VERSION-cp27-cp27mu-manylinux1_x86_64.whl\n^^^^^^ 좋음!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUCS-2 ABI에 대해 빌드된 \u003ccode\u003ewheel\u003c/code\u003e은 다음과 같은 이름을 가질 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePKG-VERSION-cp27-cp27m-manylinux1_x86_64.whl\n^^^^^ 괜찮음!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 다음과 같은 이름의 \u003ccode\u003ewheel\u003c/code\u003e은 절대 안 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePKG-VERSION-cp27-none-manylinux1_x86_64.whl\n^^^^ 나쁨! 이렇게 하지 마세요!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 \u003ccode\u003ewheel\u003c/code\u003e은 UCS-2 및 UCS-4 빌드와 동시에 호환된다고 주장하는데, 이는 잘못된 것입니다.\u003c/p\u003e\n\u003cp\u003e참고로, UCS-4 ABI가 Linux CPython 배포판에서 훨씬 더 널리 퍼져 있는 것으로 보입니다.\u003c/p\u003e\n\u003ch4\u003efpectl 빌드 vs. no fpectl 빌드 (fpectl builds vs. no fpectl builds)\u003c/h4\u003e\n\u003cp\u003eCPython의 모든 기존 버전은 \u003ccode\u003econfigure\u003c/code\u003e 플래그 \u003ccode\u003e--with-fpectl\u003c/code\u003e을 사용하거나 사용하지 않고 빌드할 수 있습니다. 이 플래그는 CPython ABI를 변경하는 것으로 나타났습니다. \u003ccode\u003eno-fpectl\u003c/code\u003e CPython에 대해 빌드된 확장은 \u003ccode\u003eyes-fpectl\u003c/code\u003e CPython과 항상 호환되지만, 역은 반드시 사실이 아닙니다. (증상: 가져오기(import) 시 \u003ccode\u003ePyFPE_jbuf\u003c/code\u003e라는 정의되지 않은 심볼에 대한 오류 발생).\u003c/p\u003e\n\u003cp\u003e따라서 최대 호환성을 위해 \u003ccode\u003emanylinux1 wheels\u003c/code\u003e를 빌드하는 데 사용되는 CPython은 \u003ccode\u003e--with-fpectl\u003c/code\u003e 플래그 없이 컴파일되어야 하며, \u003ccode\u003emanylinux1\u003c/code\u003e 확장 기능은 \u003ccode\u003ePyFPE_jbuf\u003c/code\u003e 심볼을 참조해서는 안 됩니다.\u003c/p\u003e\n\u003ch3\u003e호환되는 \u003ccode\u003eWheels\u003c/code\u003e 컴파일 (Compilation of Compliant Wheels)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eglibc\u003c/code\u003e, \u003ccode\u003elibgcc\u003c/code\u003e, \u003ccode\u003elibstdc++\u003c/code\u003e가 심볼 버전 관리를 관리하는 방식 때문에, 실제로 대부분의 개발자가 일상 작업에 사용하는 컴파일러 툴체인은 \u003ccode\u003emanylinux1\u003c/code\u003e 호환 \u003ccode\u003ewheels\u003c/code\u003e를 빌드할 수 없습니다. 따라서 \u003ccode\u003epip wheel\u003c/code\u003e / \u003ccode\u003ebdist_wheel\u003c/code\u003e의 기본 동작을 변경하지 않습니다. 이들은 계속해서 일반 \u003ccode\u003elinux_*\u003c/code\u003e 플랫폼 태그를 생성할 것이며, \u003ccode\u003emanylinux1\u003c/code\u003e 태그가 붙은 \u003ccode\u003ewheels\u003c/code\u003e를 생성하려는 개발자는 두 번째 후처리 단계에서 태그를 변경해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emanylinux1\u003c/code\u003e 표준을 충족하는 \u003ccode\u003ewheels\u003c/code\u003e 컴파일을 지원하기 위해 두 가지 도구의 초기 초안을 제공합니다.\u003c/p\u003e\n\u003ch4\u003eDocker 이미지 (Docker Image)\u003c/h4\u003e\n\u003cp\u003e첫 번째 도구는 CentOS 5.11 기반의 Docker 이미지입니다. 이 이미지는 \u003ccode\u003emanylinux1 wheels\u003c/code\u003e를 컴파일하기 위한 사용하기 쉬운 자체 포함 빌드 상자로 권장됩니다. 더 최근에 출시된 Linux 배포판에서 컴파일하면 일반적으로 너무 새로운 버전 관리된 심볼에 대한 종속성이 도입됩니다. 이 이미지는 완전한 컴파일러 스위트(\u003ccode\u003egcc\u003c/code\u003e, \u003ccode\u003eg++\u003c/code\u003e, \u003ccode\u003egfortran 4.8.2\u003c/code\u003e)와 최신 Python 및 \u003ccode\u003epip\u003c/code\u003e 릴리스와 함께 제공됩니다.\u003c/p\u003e\n\u003ch4\u003eAuditwheel\u003c/h4\u003e\n\u003cp\u003e두 번째 도구는 \u003ccode\u003eauditwheel\u003c/code\u003e이라는 명령줄 실행 파일로, 패키지 관리자가 타사 외부 종속성을 처리하는 데 도움이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e위 정책을 충족하는 방식으로 타사 외부 라이브러리를 사용하는 \u003ccode\u003ewheels\u003c/code\u003e를 빌드하는 방법은 최소 세 가지가 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e타사 라이브러리를 정적으로 링크할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e타사 공유 라이브러리를 \u003ccode\u003ewheel\u003c/code\u003e이 의존하는 PyPI의 별도 패키지로 배포할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e타사 공유 라이브러리를 \u003ccode\u003ewheel\u003c/code\u003e 라이브러리 내부에 번들로 제공하고 상대 경로로 링크할 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이러한 모든 옵션은 다른 패키지 및 커뮤니티에서 효과적으로 사용될 수 있는 유효한 옵션입니다. 정적 링크는 일반적으로 빌드 시스템에 패키지별 수정이 필요하며, PyPI에 타사 종속성을 배포하려면 패키지 사용자 커뮤니티의 일부 조정이 필요할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 옵션에 대한 종종 자동적인 대안으로 \u003ccode\u003eauditwheel\u003c/code\u003e을 소개합니다. 이 도구는 \u003ccode\u003ewheel\u003c/code\u003e 내부의 모든 ELF 파일을 검사하여 버전 관리된 심볼 또는 외부 공유 라이브러리에 대한 종속성을 확인하고 \u003ccode\u003emanylinux1\u003c/code\u003e 정책과의 일치를 검증합니다. 여기에는 호환되는 \u003ccode\u003ewheels\u003c/code\u003e에 새 플랫폼 태그를 추가하는 기능이 포함됩니다. 더 중요한 것은 \u003ccode\u003eauditwheel\u003c/code\u003e은 외부 공유 라이브러리에 의존하는 \u003ccode\u003ewheels\u003c/code\u003e를 시스템에서 \u003ccode\u003ewheel\u003c/code\u003e 자체로 해당 공유 라이브러리를 복사하고, 런타임에 이러한 라이브러리가 선택되도록 적절한 RPATH 항목을 수정하여 자동으로 \u003ccode\u003ewheels\u003c/code\u003e를 수정하는 기능을 가지고 있다는 것입니다. 이는 빌드 시스템 변경 없이 라이브러리가 정적으로 링크된 것과 유사한 결과를 달성합니다. 패키지 관리자는 번들링이 정적 링크와 마찬가지로 저작권 문제를 야기할 수 있음을 유의해야 합니다.\u003c/p\u003e\n\u003ch3\u003eLinux의 번들 \u003ccode\u003eWheels\u003c/code\u003e (Bundled Wheels on Linux)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003emanylinux1 wheels\u003c/code\u003e 내에서 타사 라이브러리 종속성을 처리하는 여러 가지 접근 방식을 인정하지만, \u003ccode\u003emanylinux1\u003c/code\u003e 정책은 외부 종속성을 번들링하는 것을 권장하며, 이는 많은 Linux 배포판의 시스템 패키지 관리자의 패키지 관리 정책과 상반되는 관행입니다. 이의 주요 목적은 크로스-배포판(cross-distro) 호환성입니다. 또한 PyPI의 \u003ccode\u003emanylinux1 wheels\u003c/code\u003e는 시스템 패키지 관리자를 통해 제공되는 Python 패키지와는 다른 틈새시장을 차지합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP에서 일반적인 Linux 배포판의 번들 해제 정책에서 벗어나도록 권장하는 결정은 다음 우려 사항에 따라 이루어졌습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e자동화된 지속적인 통합(Continuous Integration) 및 배포(Deployment) 파이프라인 시대에는 새로운 버전을 게시하고 종속성을 업데이트하는 것이 이러한 정책이 정의되었을 때보다 쉽습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epip\u003c/code\u003e 사용자는 사전 빌드된 \u003ccode\u003ewheel\u003c/code\u003e 파일을 사용하는 대신 로컬 빌드를 강제하고 싶다면 여전히 \u003ccode\u003e--no-binary\u003c/code\u003e 옵션을 자유롭게 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e현대적인 컨테이너 기반 배포 및 \"불변 인프라(Immutable Infrastructure)\" 모델의 인기는 어차피 애플리케이션 계층에서 상당한 번들링을 포함합니다.\u003c/li\u003e\n\u003cli\u003ePyPI를 통한 번들 \u003ccode\u003ewheels\u003c/code\u003e 배포는 현재 Windows 및 OS X에서는 일반적입니다.\u003c/li\u003e\n\u003cli\u003e이 PEP는 미래에 특정 Linux 배포판에 대해 더 목표 지향적인 바이너리를 제공할 가능성을 배제하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 PEP에 설명된 모델은 크로스 플랫폼 Python 패키지에 가장 이상적으로 적합합니다. 왜냐하면 이미 정적 Windows 및 OS X \u003ccode\u003ewheels\u003c/code\u003e를 만드는 데 수행하는 작업의 대부분을 재사용할 수 있기 때문입니다. 우리는 Linux의 고유한 패키지 관리 기능과 더 긴밀하게 상호 작용하고 특정 배포판의 작은 집합만 대상으로 하려는 Linux 특정 패키지에는 덜 최적화되어 있다는 것을 인정합니다.\u003c/p\u003e\n\u003ch3\u003e보안 영향 (Security Implications)\u003c/h3\u003e\n\u003cp\u003eLinux에서 중앙 집중식 라이브러리에 대한 종속성의 장점 중 하나는 버그 수정 및 보안 업데이트가 시스템 전체에 배포될 수 있으며, 이러한 라이브러리에 의존하는 애플리케이션은 기본 라이브러리가 업데이트될 때 이러한 패치의 영향을 자동으로 받는다는 것입니다. 이는 네트워크를 통한 통신 또는 암호화와 관련된 패키지의 보안 업데이트에 특히 중요할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eOpenSSL과 같은 보안에 중요한 라이브러리를 번들링하여 PyPI를 통해 배포되는 \u003ccode\u003emanylinux1 wheels\u003c/code\u003e는 공개된 취약점 및 패치에 대한 신속한 업데이트의 책임을 지게 됩니다. 이는 플랫폼에 시스템 패키지 관리자가 없기 때문에 일반적으로 종속성을 번들링하는 Windows용 바이너리 \u003ccode\u003ewheels\u003c/code\u003e 배포의 보안 영향과 밀접하게 유사합니다. 특히 안정적인 ABI가 없기 때문에 OpenSSL은 \u003ccode\u003emanylinux1\u003c/code\u003e 프로필에 포함될 수 없습니다.\u003c/p\u003e\n\u003ch3\u003e설치자를 위한 플랫폼 감지 (Platform Detection for Installers)\u003c/h3\u003e\n\u003cp\u003e위에서 \u003ccode\u003ewheel\u003c/code\u003e이 \u003ccode\u003emanylinux1\u003c/code\u003e 호환이라는 것이 무엇을 의미하는지 정의했습니다. 여기서는 Python 설치가 \u003ccode\u003emanylinux1\u003c/code\u003e 호환이라는 것이 무엇을 의미하는지 논의합니다. 특히 이는 \u003ccode\u003epip\u003c/code\u003e와 같은 도구가 \u003ccode\u003emanylinux1\u003c/code\u003e 태그가 붙은 \u003ccode\u003ewheels\u003c/code\u003e를 설치 대상으로 고려해야 할지 결정할 때 중요합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emanylinux1\u003c/code\u003e 프로필은 이미 널리 사용되는 상업용 Python 배포판의 수천 명의 사용자에게 작동하는 것으로 알려져 있으므로, 설치 도구는 특별한 이유가 없는 한 시스템이 호환된다고 가정하는 쪽으로 기울어져야 한다고 제안합니다.\u003c/p\u003e\n\u003cp\u003e실제로 발생할 수 있는 잠재적인 비호환성의 네 가지 주요 원인을 알고 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e결국 미래에는 이 프로필과 호환되지 않는 배포판이 존재할 수 있습니다(예: 프로필의 라이브러리 중 하나가 하위 호환되지 않는 방식으로 ABI를 변경하는 경우).\u003c/li\u003e\n\u003cli\u003e너무 오래된 Linux 배포판(예: RHEL 4)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eglibc\u003c/code\u003e를 사용하지 않는 Linux 배포판(예: \u003ccode\u003emusl libc\u003c/code\u003e 기반의 Alpine Linux 또는 Android)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 문제에 대처하기 위해 두 가지 접근 방식을 제안합니다. 잠재적인 미래 비호환성을 처리하기 위해, Python 배포자가 특정 Python 설치가 \u003ccode\u003emanylinux1\u003c/code\u003e와 확실히 호환되는지 또는 호환되지 않는지 알리는 메커니즘을 표준화합니다. 이는 \u003ccode\u003e_manylinux\u003c/code\u003e라는 모듈을 설치하고 \u003ccode\u003emanylinux1_compatible\u003c/code\u003e 속성을 설정하여 수행됩니다. 이러한 모듈을 표준 라이브러리에 추가하는 것은 제안하지 않습니다. 이는 배포자와 설치 도구가 만나기 위한 잘 알려진 이름일 뿐입니다. 그러나 배포자가 이 모듈을 추가하는 경우, \u003ccode\u003esite-packages/\u003c/code\u003e 디렉터리보다는 표준 라이브러리에 추가해야 합니다. 왜냐하면 표준 라이브러리는 \u003ccode\u003evirtualenvs\u003c/code\u003e에 의해 상속되고(\u003ccode\u003evirtualenvs\u003c/code\u003e에 상속되기를 원함), \u003ccode\u003esite-packages/\u003c/code\u003e는 일반적으로 그렇지 않기 때문입니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 기존 Python 배포판에 대한 마지막 두 가지 경우를 처리하기 위해 \u003ccode\u003eglibc\u003c/code\u003e의 존재 및 버전을 확인하는 간단하고 신뢰할 수 있는 방법을 제안합니다(기본적으로 전체 배포판의 \"연령\"에 대한 \"시계\"로 사용).\u003c/p\u003e\n\u003cp\u003e구체적으로 제안하는 알고리즘은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef is_manylinux1_compatible():\n    # Only Linux, and only x86-64 / i686\n    from distutils.util import get_platform\n    if get_platform() not in [\"linux-x86_64\", \"linux-i686\"]:\n        return False\n\n    # Check for presence of _manylinux module\n    try:\n        import _manylinux\n        return bool(_manylinux.manylinux1_compatible)\n    except (ImportError, AttributeError):\n        # Fall through to heuristic check below\n        pass\n\n    # Check glibc version. CentOS 5 uses glibc 2.5.\n    return have_compatible_glibc(2, 5)\n\ndef have_compatible_glibc(major, minimum_minor):\n    import ctypes\n    process_namespace = ctypes.CDLL(None)\n    try:\n        gnu_get_libc_version = process_namespace.gnu_get_libc_version\n    except AttributeError:\n        # Symbol doesn't exist -\u003e therefore, we are not linked to\n        # glibc.\n        return False\n\n    # Call gnu_get_libc_version, which returns a string like \"2.5\".\n    gnu_get_libc_version.restype = ctypes.c_char_p\n    version_str = gnu_get_libc_version()\n\n    # py2 / py3 compatibility: if not isinstance(version_str, str):\n    if not isinstance(version_str, str):\n        version_str = version_str.decode(\"ascii\")\n\n    # Parse string and check against requested version.\n    version = [int(piece) for piece in version_str.split(\".\")]\n    assert len(version) == 2\n    if major != version[0]:\n        return False\n    if minimum_minor \u003e version[1]:\n        return False\n    return True\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e거부된 대안:\u003c/strong\u003e 우리는 또한 \u003ccode\u003e(/etc/python/compatibility.cfg)\u003c/code\u003e와 같은 구성 파일을 사용하는 것을 고려했습니다. 이 방법의 문제점은 단일 파일 시스템에 각기 고유한 ABI 프로필을 가진 여러 다른 인터프리터 환경이 포함될 수 있다는 것입니다. 시스템에 설치된 \u003ccode\u003ex86_64 CPython\u003c/code\u003e의 \u003ccode\u003emanylinux1\u003c/code\u003e 호환성이 사용자 설치 \u003ccode\u003ei686 PyPy\u003c/code\u003e의 \u003ccode\u003emanylinux1\u003c/code\u003e 호환성에 대해 많은 것을 알려주지 않을 수 있습니다. 이 구성 정보를 Python 환경 자체 내에 배치하면 올바른 바이너리에 계속 연결되어 있고 조회 코드가 크게 단순화됩니다.\u003c/p\u003e\n\u003cp\u003e우리는 또한 호환 가능한 것으로 간주되어야 하는 모든 플랫폼 태그 목록과 그 선호도 순서를 포함하는 더 정교한 구조를 사용하는 것도 고려했습니다. 예를 들어 \u003ccode\u003e_binary_compat.compatible = [\"manylinux1_x86_64\", \"centos5_x86_64\", \"linux_x86_64\"]\u003c/code\u003e와 같습니다. 그러나 이것은 몇 가지 복잡성을 야기합니다. 예를 들어, \"manylinux1을 지원하지 않음\"(또는 결국 \u003ccode\u003emanylinux2\u003c/code\u003e 등) 상태와 \"manylinux1 지원 여부를 명시적으로 지정하지 않음\" 상태를 구별할 수 있어야 하는데, 이는 위 표현에서 완전히 명확하지 않습니다. 또한 현재 유일하게 가능한 플랫폼 태그가 \u003ccode\u003emanylinux1\u003c/code\u003e과 \u003ccode\u003elinux\u003c/code\u003e라는 점을 감안할 때 선호도 순서와 관련하여 실제로 필요한 기능이 무엇인지 전혀 명확하지 않습니다. 따라서 Linux가 더 많은 플랫폼 태그를 얻게 될 때 별도의 PEP에서 더 완전한 해결책을 보류하고 있습니다.\u003c/p\u003e\n\u003cp\u003e라이브러리 호환성 검사를 위해 훨씬 더 정교한 검사(예: 커널 버전 확인, \u003ccode\u003emanylinux1\u003c/code\u003e 프로필에 나열된 모든 개별 라이브러리 검색 및 버전 확인 등)도 고려했지만, 궁극적으로 이는 사용자에게 실제로 도움이 되기보다는 혼란스러운 버그를 유발할 가능성이 더 높다고 판단했습니다. (예: 다른 배포판은 이러한 라이브러리를 실제로 어디에 두는지 다르며, 검사 코드가 올바른 경로 검색을 사용하지 못하면 쉽게 잘못된 답변을 반환할 수 있습니다.)\u003c/p\u003e\n\u003ch3\u003ePyPI 지원 (PyPI Support)\u003c/h3\u003e\n\u003cp\u003ePyPI는 \u003ccode\u003emanylinux1\u003c/code\u003e 플랫폼 태그를 포함하는 \u003ccode\u003ewheels\u003c/code\u003e의 업로드를 허용해야 합니다. PyPI는 \u003ccode\u003emanylinux1\u003c/code\u003e 플랫폼 태그를 포함하는 \u003ccode\u003ewheels\u003c/code\u003e가 이 문서에 설명된 \u003ccode\u003emanylinux1\u003c/code\u003e 정책을 준수하는지 공식적으로 확인하려고 시도해서는 안 됩니다. 이러한 검증 작업은 \u003ccode\u003eauditwheel\u003c/code\u003e과 같이 별도로 개발된 다른 도구에 맡겨야 합니다.\u003c/p\u003e\n\u003ch3\u003e거부된 대안 (Rejected Alternatives)\u003c/h3\u003e\n\u003cp\u003e한 가지 대안은 각 Linux 배포판(및 각 버전)에 대해 별도의 플랫폼 태그를 제공하는 것이었습니다. 예를 들어 \u003ccode\u003eRHEL6\u003c/code\u003e, \u003ccode\u003eubuntu14_10\u003c/code\u003e, \u003ccode\u003edebian_jessie\u003c/code\u003e 등입니다. 이 제안의 어떤 내용도 미래에 이러한 플랫폼 태그를 추가할 가능성이나, \u003ccode\u003ewheels\u003c/code\u003e가 외부 시스템 설치 패키지에 대한 종속성을 선언할 수 있도록 하는 \u003ccode\u003ewheel\u003c/code\u003e 메타데이터에 대한 추가 확장을 배제하지 않습니다. 그러나 이러한 확장은 이 제안보다 훨씬 더 많은 작업을 필요로 하며, 모든 일반적인 Linux 배포판을 포괄하기 위해 여러 빌드 환경을 유지하고 여러 \u003ccode\u003ewheels\u003c/code\u003e를 빌드해야 하는 것을 선호하지 않는 패키지 개발자에게 여전히 좋게 평가되지 않을 수 있습니다. 따라서 우리는 그러한 제안들을 이 PEP의 범위를 벗어나는 것으로 간주합니다.\u003c/p\u003e\n\u003ch3\u003e향후 업데이트 (Future updates)\u003c/h3\u003e\n\u003cp\u003e미래의 어느 시점에는 더 현대적인 기준 환경(아마도 CentOS 6 기반)을 지정하는 \u003ccode\u003emanylinux2\u003c/code\u003e가 있을 것이고, 언젠가는 \u003ccode\u003emanylinux3\u003c/code\u003e 등이 있을 것으로 예상하지만, 초기 \u003ccode\u003emanylinux1\u003c/code\u003e 제안에 대한 더 많은 경험을 얻을 때까지는 이러한 사양을 연기합니다.\u003c/p\u003e\n\u003ch3\u003e참조 (References)\u003c/h3\u003e\n\u003cp\u003ePEP 513은 다음 자료들을 참조합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEnthought Canopy Python Distribution (https://store.enthought.com/downloads/)\u003c/li\u003e\n\u003cli\u003eContinuum Analytics Anaconda Python Distribution (https://www.continuum.io/downloads)\u003c/li\u003e\n\u003cli\u003eCentOS 5.11 Release Notes (https://wiki.centos.org/Manuals/ReleaseNotes/CentOS5.11)\u003c/li\u003e\n\u003cli\u003emanylinux-discuss mailing list discussion (https://groups.google.com/forum/#!topic/manylinux-discuss/-4l3rrjfr9U)\u003c/li\u003e\n\u003cli\u003edistutils-sig discussion (https://mail.python.org/pipermail/distutils-sig/2016-January/027997.html)\u003c/li\u003e\n\u003cli\u003edistutils-sig discussion (https://mail.python.org/pipermail/distutils-sig/2016-February/028275.html)\u003c/li\u003e\n\u003cli\u003egithub issue discussion (https://github.com/pypa/manylinux/issues/30)\u003c/li\u003e\n\u003cli\u003epython bug tracker discussion (https://bugs.python.org/issue21536)\u003c/li\u003e\n\u003cli\u003emanylinux1 docker images (Source: https://github.com/pypa/manylinux; x86-64: https://quay.io/repository/pypa/manylinux1_x86_64; x86-32: https://quay.io/repository/pypa/manylinux1_i686)\u003c/li\u003e\n\u003cli\u003eauditwheel tool (https://pypi.python.org/pypi/auditwheel)\u003c/li\u003e\n\u003cli\u003eFedora Bundled Software Policy (https://fedoraproject.org/wiki/Bundled_Software_policy)\u003c/li\u003e\n\u003cli\u003eDebian Policy Manual – 4.13: Convenience copies of code (https://www.debian.org/doc/debian-policy/ch-source.html#s-embeddedfiles)\u003c/li\u003e\n\u003cli\u003enumpy bug report: https://github.com/numpy/numpy/issues/8415#issuecomment-269095235\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\nSource: https://github.com/python/peps/blob/main/peps/pep-0513.rst\n최종 수정: 2025-02-01 08:59:27 GMT\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e거부된 대안:\u003c/strong\u003e 우리는 또한 \u003ccode\u003e(/etc/python/compatibility.cfg)\u003c/code\u003e와 같은 구성 파일을 사용하는 것을 고려했습니다. 이 방법의 문제점은 단일 파일 시스템에 각기 고유한 ABI 프로필을 가진 여러 다른 인터프리터 환경이 포함될 수 있다는 것입니다. 시스템에 설치된 \u003ccode\u003ex86_64 CPython\u003c/code\u003e의 \u003ccode\u003emanylinux1\u003c/code\u003e 호환성이 사용자 설치 \u003ccode\u003ei686 PyPy\u003c/code\u003e의 \u003ccode\u003emanylinux1\u003c/code\u003e 호환성에 대해 많은 것을 알려주지 않을 수 있습니다. 이 구성 정보를 Python 환경 자체 내에 배치하면 올바른 바이너리에 계속 연결되어 있고 조회 코드가 크게 단순화됩니다.\u003c/p\u003e\n\u003cp\u003e우리는 또한 호환 가능한 것으로 간주되어야 하는 모든 플랫폼 태그 목록과 그 선호도 순서를 포함하는 더 정교한 구조를 사용하는 것도 고려했습니다. 예를 들어 \u003ccode\u003e_binary_compat.compatible = [\"manylinux1_x86_64\", \"centos5_x86_64\", \"linux_x86_64\"]\u003c/code\u003e와 같습니다. 그러나 이것은 몇 가지 복잡성을 야기합니다. 예를 들어, \"manylinux1을 지원하지 않음\"(또는 결국 \u003ccode\u003emanylinux2\u003c/code\u003e 등) 상태와 \"manylinux1 지원 여부를 명시적으로 지정하지 않음\" 상태를 구별할 수 있어야 하는데, 이는 위 표현에서 완전히 명확하지 않습니다. 또한 현재 유일하게 가능한 플랫폼 태그가 \u003ccode\u003emanylinux1\u003c/code\u003e과 \u003ccode\u003elinux\u003c/code\u003e라는 점을 감안할 때 선호도 순서와 관련하여 실제로 필요한 기능이 무엇인지 전혀 명확하지 않습니다. 따라서 Linux가 더 많은 플랫폼 태그를 얻게 될 때 별도의 PEP에서 더 완전한 해결책을 보류하고 있습니다.\u003c/p\u003e\n\u003cp\u003e라이브러리 호환성 검사를 위해 훨씬 더 정교한 검사(예: 커널 버전 확인, \u003ccode\u003emanylinux1\u003c/code\u003e 프로필에 나열된 모든 개별 라이브러리 검색 및 버전 확인 등)도 고려했지만, 궁극적으로 이는 사용자에게 실제로 도움이 되기보다는 혼란스러운 버그를 유발할 가능성이 더 높다고 판단했습니다. (예: 다른 배포판은 이러한 라이브러리를 실제로 어디에 두는지 다르며, 검사 코드가 올바른 경로 검색을 사용하지 못하면 쉽게 잘못된 답변을 반환할 수 있습니다.)\u003c/p\u003e\n\u003ch3\u003ePyPI 지원 (PyPI Support)\u003c/h3\u003e\n\u003cp\u003ePyPI는 \u003ccode\u003emanylinux1\u003c/code\u003e 플랫폼 태그를 포함하는 \u003ccode\u003ewheels\u003c/code\u003e의 업로드를 허용해야 합니다. PyPI는 \u003ccode\u003emanylinux1\u003c/code\u003e 플랫폼 태그를 포함하는 \u003ccode\u003ewheels\u003c/code\u003e가 이 문서에 설명된 \u003ccode\u003emanylinux1\u003c/code\u003e 정책을 준수하는지 공식적으로 확인하려고 시도해서는 안 됩니다. 이러한 검증 작업은 \u003ccode\u003eauditwheel\u003c/code\u003e과 같이 별도로 개발된 다른 도구에 맡겨야 합니다.\u003c/p\u003e\n\u003ch3\u003e거부된 대안 (Rejected Alternatives)\u003c/h3\u003e\n\u003cp\u003e한 가지 대안은 각 Linux 배포판(및 각 버전)에 대해 별도의 플랫폼 태그를 제공하는 것이었습니다. 예를 들어 \u003ccode\u003eRHEL6\u003c/code\u003e, \u003ccode\u003eubuntu14_10\u003c/code\u003e, \u003ccode\u003edebian_jessie\u003c/code\u003e 등입니다. 이 제안의 어떤 내용도 미래에 이러한 플랫폼 태그를 추가할 가능성이나, \u003ccode\u003ewheels\u003c/code\u003e가 외부 시스템 설치 패키지에 대한 종속성을 선언할 수 있도록 하는 \u003ccode\u003ewheel\u003c/code\u003e 메타데이터에 대한 추가 확장을 배제하지 않습니다. 그러나 이러한 확장은 이 제안보다 훨씬 더 많은 작업을 필요로 하며, 모든 일반적인 Linux 배포판을 포괄하기 위해 여러 빌드 환경을 유지하고 여러 \u003ccode\u003ewheels\u003c/code\u003e를 빌드해야 하는 것을 선호하지 않는 패키지 개발자에게 여전히 좋게 평가되지 않을 수 있습니다. 따라서 우리는 그러한 제안들을 이 PEP의 범위를 벗어나는 것으로 간주합니다.\u003c/p\u003e\n\u003ch3\u003e향후 업데이트 (Future updates)\u003c/h3\u003e\n\u003cp\u003e미래의 어느 시점에는 더 현대적인 기준 환경(아마도 CentOS 6 기반)을 지정하는 \u003ccode\u003emanylinux2\u003c/code\u003e가 있을 것이고, 언젠가는 \u003ccode\u003emanylinux3\u003c/code\u003e 등이 있을 것으로 예상하지만, 초기 \u003ccode\u003emanylinux1\u003c/code\u003e 제안에 대한 더 많은 경험을 얻을 때까지는 이러한 사양을 연기합니다.\u003c/p\u003e\n\u003ch3\u003e참조 (References)\u003c/h3\u003e\n\u003cp\u003ePEP 513은 다음 자료들을 참조합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEnthought Canopy Python Distribution (https://store.enthought.com/downloads/)\u003c/li\u003e\n\u003cli\u003eContinuum Analytics Anaconda Python Distribution (https://www.continuum.io/downloads)\u003c/li\u003e\n\u003cli\u003eCentOS 5.11 Release Notes (https://wiki.centos.org/Manuals/ReleaseNotes/CentOS5.11)\u003c/li\u003e\n\u003cli\u003emanylinux-discuss mailing list discussion (https://groups.google.com/forum/#!topic/manylinux-discuss/-4l3rrjfr9U)\u003c/li\u003e\n\u003cli\u003edistutils-sig discussion (https://mail.python.org/pipermail/distutils-sig/2016-January/027997.html)\u003c/li\u003e\n\u003cli\u003edistutils-sig discussion (https://mail.python.org/pipermail/distutils-sig/2016-February/028275.html)\u003c/li\u003e\n\u003cli\u003egithub issue discussion (https://github.com/pypa/manylinux/issues/30)\u003c/li\u003e\n\u003cli\u003epython bug tracker discussion (https://bugs.python.org/issue21536)\u003c/li\u003e\n\u003cli\u003emanylinux1 docker images (Source: https://github.com/pypa/manylinux; x86-64: https://quay.io/repository/pypa/manylinux1_x86_64; x86-32: https://quay.io/repository/pypa/manylinux1_i686)\u003c/li\u003e\n\u003cli\u003eauditwheel tool (https://pypi.python.org/pypi/auditwheel)\u003c/li\u003e\n\u003cli\u003eFedora Bundled Software Policy (https://fedoraproject.org/wiki/Bundled_Software_policy)\u003c/li\u003e\n\u003cli\u003eDebian Policy Manual – 4.13: Convenience copies of code (https://www.debian.org/doc/debian-policy/ch-source.html#s-embeddedfiles)\u003c/li\u003e\n\u003cli\u003enumpy bug report: https://github.com/numpy/numpy/issues/8415#issuecomment-269095235\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\nSource: https://github.com/python/peps/blob/main/peps/pep-0513.rst\n최종 수정: 2025-02-01 08:59:27 GMT\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Superseded] PEP 513 - A Platform Tag for Portable Linux Built Distributions\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:03:09+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>