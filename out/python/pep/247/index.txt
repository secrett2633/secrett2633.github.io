3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-d79d6340e7770dba.js","185","static/chunks/app/layout-b06e577e11976c7d.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js"],""]
4:["slug","python/pep/247","c"]
0:["qNOrJYeuqip9qCFPpDVpu",[[["",{"children":[["slug","python/pep/247","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"247\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/247","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e975486d410ad4e9.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T1db5,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0247/">PEP 247 - API for Cryptographic Hash Functions</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Informational | <strong>작성일:</strong> 23-Mar-2001</p>
</blockquote>
<h1>PEP 247 – 암호화 해시 함수용 API</h1>
<h2>개요</h2>
<p>이 문서는 MD5 또는 SHA와 같은 암호화 해싱 알고리즘을 구현하는 다양한 모듈들을 위해 표준화된 API를 정의합니다. 이를 통해 여러 구현체 간의 전환을 용이하게 하는 것을 목표로 합니다.</p>
<h2>사양 (Specification)</h2>
<p>모든 해싱 모듈은 동일한 인터페이스를 제공해야 합니다. 추가적인 메서드나 변수를 포함할 수 있지만, 이 문서에 명시된 항목들은 항상 존재해야 합니다.</p>
<h3>해시 함수 모듈이 정의하는 함수</h3>
<ul>
<li><code>new([string])</code> (키가 없는(unkeyed) 해시)</li>
<li><code>new([key], [string])</code> (키가 있는(keyed) 해시)</li>
</ul>
<p>새로운 해싱 객체를 생성하고 반환합니다. 첫 번째 형식은 MD5나 SHA처럼 키가 없는 해시에 사용됩니다. HMAC와 같은 키가 있는 해시의 경우, <code>key</code>는 사용할 키를 담은 문자열을 필수로 받습니다. 두 경우 모두, 선택적 <code>string</code> 파라미터가 제공되면, 마치 <code>obj.update(string)</code>이 호출된 것처럼 객체의 초기 상태에 즉시 해시됩니다.</p>
<p>해싱 객체 생성 후, <code>update()</code> 메서드를 사용하여 임의의 문자열을 객체에 공급할 수 있으며, <code>digest()</code> 메서드를 호출하여 언제든지 해시 값을 얻을 수 있습니다.</p>
<p>이 함수에 임의의 추가 키워드 인수를 추가할 수 있지만, 제공되지 않은 경우 합리적인 기본값이 사용되어야 합니다. 예를 들어, 가변 라운드 수와 여러 출력 크기를 지원하는 해시 함수에는 <code>rounds</code> 및 <code>digest_size</code> 키워드를 추가할 수 있으며, 이들은 안전하다고 여겨지는 값으로 기본 설정되어야 합니다.</p>
<h3>해시 함수 모듈이 정의하는 변수</h3>
<ul>
<li><code>digest_size</code></li>
</ul>
<p>정수 값으로, 이 모듈이 생성하는 해싱 객체에 의해 생성되는 다이제스트(digest)의 크기를 바이트 단위로 나타냅니다. 샘플 객체를 생성하고 해당 <code>digest_size</code> 속성에 접근하여 이 값을 얻을 수도 있지만, 모듈에서 바로 이 값을 사용할 수 있도록 하는 것이 편리합니다. 출력 크기가 가변적인 해시는 이 변수를 <code>None</code>으로 설정합니다.</p>
<h3>해싱 객체가 요구하는 속성</h3>
<ul>
<li><code>digest_size</code></li>
</ul>
<p>이 속성은 모듈 수준의 <code>digest_size</code> 변수와 동일하며, 해싱 객체에 의해 생성되는 다이제스트의 크기를 바이트 단위로 측정합니다. 해시가 가변 출력 크기를 갖는 경우, 이 출력 크기는 해싱 객체가 생성될 때 선택되어야 하며, 이 속성에는 선택된 크기가 포함되어야 합니다. 따라서 <code>None</code>은 이 속성의 유효한 값이 아닙니다.</p>
<h3>해싱 객체가 요구하는 메서드</h3>
<ul>
<li>
<p><code>copy()</code>
이 해싱 객체의 별도 사본을 반환합니다. 이 사본에 대한 업데이트는 원본 객체에 영향을 주지 않습니다.</p>
</li>
<li>
<p><code>digest()</code>
이 해싱 객체의 해시 값을 8비트 데이터를 포함하는 문자열로 반환합니다. 이 함수에 의해 객체는 어떤 식으로든 변경되지 않습니다. 이 함수를 호출한 후에도 객체를 계속 업데이트할 수 있습니다.</p>
</li>
<li>
<p><code>hexdigest()</code>
이 해싱 객체의 해시 값을 16진수 숫자를 포함하는 문자열로 반환합니다. <code>a</code>부터 <code>f</code>까지의 숫자에 대해 소문자가 사용되어야 합니다. <code>.digest()</code> 메서드와 마찬가지로, 이 메서드는 객체를 변경해서는 안 됩니다.</p>
</li>
<li>
<p><code>update(string)</code>
<code>string</code>을 해싱 객체의 현재 상태로 해시합니다. <code>update()</code>는 해싱 객체의 수명 동안 여러 번 호출될 수 있습니다.</p>
</li>
</ul>
<p>해싱 모듈은 추가적인 모듈 수준 함수나 객체 메서드를 정의할 수 있으며, 여전히 이 사양을 준수합니다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-python">>>> from Crypto.Hash import MD5
>>> m = MD5.new()
>>> m.digest_size
16
>>> m.update('abc')
>>> m.digest()
'\x90\x01P\x98&#x3C;\xd2O\xb0\xd6\x96?}(\xe1\x7fr'
>>> m.hexdigest()
'900150983cd24fb0d6963f7d28e17f72'
>>> MD5.new('abc').digest()
'\x90\x01P\x98&#x3C;\xd2O\xb0\xd6\x96?}(\xe1\x7fr'
</code></pre>
<h2>근거 (Rationale)</h2>
<p>다이제스트(digest) 크기는 해시 알고리즘의 크기가 일반적으로 비트 단위로 인용됨에도 불구하고 바이트 단위로 측정됩니다. 예를 들어, MD5는 128비트 알고리즘이지 16바이트 알고리즘이 아닙니다. 이는 검토된 샘플 코드에서 바이트 길이가 종종 필요하고(파일에서 앞뒤로 탐색, 출력 문자열 길이 계산 등), 비트 길이는 거의 사용되지 않기 때문입니다. 따라서, 비트 단위 크기가 실제로 필요한 소수의 사람들에게 <code>digest_size</code>에 8을 곱하는 부담이 주어질 것입니다.</p>
<p><code>update()</code> 메서드가 <code>append()</code>로 이름이 바뀌는 것이 더 낫다는 제안이 있었습니다. 그러나 이 메서드는 실제로 해싱 객체의 현재 상태를 업데이트하는 것이며, <code>update()</code>는 이미 Python에 포함된 <code>md5</code> 및 <code>sha</code> 모듈에서 사용되고 있으므로, <code>update()</code> 이름을 그대로 두는 것이 가장 간단하다고 판단되었습니다.</p>
<p>키가 있는 해시(keyed hashes)의 생성자 인자 순서는 까다로운 문제였습니다. <code>key</code>가 먼저 와야 할지 두 번째로 와야 할지 명확하지 않았습니다. <code>key</code>는 필수 매개변수이며, 일반적인 관례는 필수 매개변수를 먼저 배치하는 것이지만, 이는 <code>string</code> 매개변수가 첫 번째 위치에서 두 번째 위치로 이동하는 것을 의미하기도 합니다. 혼동하여 단일 인자를 키가 있는 해시에 전달하면서, 키가 없는 해시에 초기 문자열을 전달한다고 생각할 수도 있지만, 이러한 잠재적 오류를 피하기 위해 키가 있는 해시의 인터페이스를 더 모호하게 만들 가치는 없는 것으로 보입니다.</p>
<h2>변경사항 (Changes)</h2>
<ul>
<li><strong>2001-09-17:</strong> <code>clear()</code>가 <code>reset()</code>으로 이름이 변경되었고, 객체에 <code>digest_size</code> 속성이 추가되었으며, <code>.hexdigest()</code> 메서드가 추가되었습니다.</li>
<li><strong>2001-09-20:</strong> <code>reset()</code> 메서드가 완전히 제거되었습니다.</li>
<li><strong>2001-09-28:</strong> 가변 크기 해시의 경우 <code>digest_size</code>가 <code>None</code>으로 설정되었습니다.</li>
</ul>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1025,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 247 - API for Cryptographic Hash Functions"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 17:22:10+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","22",{"name":"next-size-adjust"}]]
1:null
