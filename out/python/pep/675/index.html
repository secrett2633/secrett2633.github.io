<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/edf391eeca43d999.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0ec5cf06f346236d.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-e3ea38185bb36cd2.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2082<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 675 - Arbitrary Literal String Type</h1><div class="page__meta"><time dateTime="2025-09-27 10:08:22+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0675/">PEP 675 - Arbitrary Literal String Type</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 30-Nov-2021</p>
</blockquote>
<p>PEP 675: 임의의 리터럴 문자열 타입 (Arbitrary Literal String Type)</p>
<h2>개요 (Abstract)</h2>
<p>현재 Python에서는 특정 리터럴 문자열(예: <code>Literal["foo"]</code>)이 아닌, "어떤" 리터럴 문자열 타입이든 허용하는 함수 매개변수를 타입 어노테이션으로 지정할 방법이 없습니다. 이 PEP는 리터럴 문자열 타입들의 슈퍼타입인 <code>LiteralString</code>을 도입합니다. 이를 통해 함수가 <code>Literal["foo"]</code> 또는 <code>Literal["bar"]</code>와 같은 임의의 리터럴 문자열 타입을 받아들일 수 있게 됩니다.</p>
<h2>동기 (Motivation)</h2>
<p>SQL 또는 셸 명령어를 실행하는 강력한 API는 종종 임의의 사용자 제어 문자열이 아닌, <em>리터럴 문자열</em>로 호출될 것을 권장합니다. 그러나 현재 타입 시스템에는 이러한 권장 사항을 표현할 방법이 없어, 개발자가 이를 따르지 않을 경우 보안 취약점이 발생하곤 합니다.</p>
<p><strong>문제 사례: SQL Injection</strong></p>
<p>예를 들어, 사용자 ID를 받아 데이터베이스에서 레코드를 조회하는 일반적인 방법은 다음과 같습니다:</p>
<pre><code class="language-python">def query_user(conn: Connection, user_id: str) -> User:
    query = f"SELECT * FROM data WHERE user_id = {user_id}"
    conn.execute(query)
    # ...
</code></pre>
<p><code>user_id</code>가 사용자 제어 데이터이므로, 악의적인 사용자는 SQL 인젝션 공격을 시도할 수 있습니다. 예를 들어, <code>user_id</code>에 <code>"user123; DROP TABLE data;"</code>를 전달하면 테이블이 삭제될 수 있습니다.</p>
<p>SQL API는 이러한 공격을 방지하기 위해 매개변수화된 쿼리(parameterized queries)를 제공하여 쿼리 실행과 사용자 제어 데이터를 분리합니다.</p>
<pre><code class="language-python">def query_user(conn: Connection, user_id: str) -> User:
    query = "SELECT * FROM data WHERE user_id = ?"
    conn.execute(query, (user_id,))
    # ...
</code></pre>
<p>문제는 이러한 원칙을 강제할 방법이 없다는 것입니다. <code>sqlite3</code>의 문서조차 외부 입력으로 <code>sql</code> 인수를 동적으로 구성하지 말라고 권고할 뿐, 타입 시스템을 통해 이를 표현할 수 없습니다. 결과적으로 사용자들은 여전히 편리한 f-string을 사용하여 코드를 SQL 인젝션에 취약하게 만들 수 있습니다.</p>
<p>기존 보안 린터(예: Bandit)는 SQL API에서 안전하지 않은 외부 데이터를 탐지하려고 시도하지만, 여러 줄 쿼리를 변수에 저장하거나 조건에 따라 리터럴 문자열을 추가하는 등 일반적인 코딩 관용구를 방해할 수 있습니다.</p>
<p><strong><code>LiteralString</code>의 해결책:</strong></p>
<p><code>LiteralString</code> 타입은 리터럴로 구성된 것으로 알려진 문자열 값만 허용합니다. 이는 PEP 586의 <code>Literal["foo"]</code> 타입의 일반화된 형태입니다. <code>LiteralString</code> 타입의 문자열은 사용자 제어 데이터를 포함할 수 없으므로, <code>LiteralString</code>만 허용하는 API는 인젝션 취약점으로부터 안전합니다 (실용적인 한계 내에서).</p>
<p><code>sqlite3</code>의 <code>execute</code> 메서드가 사용자 입력으로 만들어진 문자열을 허용하지 않도록, <code>typeshed</code> 스텁에서 SQL 쿼리가 <code>LiteralString</code> 타입임을 명시할 수 있습니다.</p>
<pre><code class="language-python">from typing import LiteralString
def execute(self, sql: LiteralString, parameters: Iterable[str] = ...) -> Cursor: ...
</code></pre>
<p>이렇게 하면 <code>user_id</code>를 사용하는 f-string으로 구성된 <code>query</code> 변수는 <code>str</code> 타입으로 추론되어 <code>execute</code>에 전달할 수 없게 되며 타입 에러가 발생합니다.</p>
<pre><code class="language-python">def query_user(conn: Connection, user_id: str) -> User:
    query = f"SELECT * FROM data WHERE user_id = {user_id}"
    conn.execute(query) # 에러: Expected LiteralString, got str.
    # ...
</code></pre>
<p>반면, 리터럴 문자열끼리 결합하는 안전한 패턴은 여전히 허용됩니다.</p>
<pre><code class="language-python">def query_data(conn: Connection, user_id: str, limit: bool) -> None:
    query = """ SELECT user.name, user.age FROM data WHERE user_id = ? """
    if limit:
        query += " LIMIT 1" # LiteralString을 추가했으므로 여전히 LiteralString 타입.
    conn.execute(query, (user_id,)) # OK
</code></pre>
<p>사용자는 SQL 코드를 변경할 필요 없이 타입 체커가 리터럴 문자열 타입을 추론하고 위반 시에만 경고하게 됩니다.</p>
<p><code>LiteralString</code>은 셸 명령어 구축, HTML 응답 렌더링 시 이스케이프 없이 문자열 사용 등 엄격한 명령-데이터 분리가 필요한 다른 경우에도 유용합니다 (부록 A 참조).</p>
<h3>사용 통계 (Usage statistics)</h3>
<p><code>sqlite3</code>를 사용하는 오픈 소스 프로젝트 샘플에서 <code>conn.execute</code> 호출 중 약 67%는 안전한 문자열 리터럴로, 약 33%는 잠재적으로 안전하지 않은 로컬 문자열 변수로 이루어졌습니다. 이 PEP의 <code>LiteralString</code> 타입을 타입 체커와 함께 사용하면 33% 중 사용자 제어 데이터가 쿼리에 통합된 부분을 방지할 수 있습니다.</p>
<h2>근거 (Rationale)</h2>
<p><strong>왜 보안 취약점 방지에 타입을 사용해야 하는가?</strong></p>
<ul>
<li><strong>문서 경고는 불충분</strong> : 대부분의 사용자는 경고를 보지 않거나 무시합니다.</li>
<li><strong>기존 동적/정적 분석은 너무 제한적</strong> : 자연스러운 코딩 관용구를 막습니다.</li>
<li><strong>타이핑 기반 접근 방식</strong> : 엄격함과 유연성 사이의 균형을 맞춥니다.</li>
</ul>
<p><strong>런타임(Runtime) 접근 방식의 한계</strong> : 런타임에는 쿼리 문자열이 일반 <code>str</code>이므로, 휴리스틱(heuristics)으로 일부 악용을 막을 수 있지만, 항상 우회할 방법이 있습니다.</p>
<p><strong>정적(Static) 접근 방식의 한계</strong> : AST를 확인하는 정적 분석은 문자열이 중간 변수에 할당되거나 안전한 함수에 의해 변환될 때를 구별할 수 없어 지나치게 제한적입니다.</p>
<p><strong>타입 체커(Type Checker)의 장점</strong> : 타입 체커는 런타임 또는 정적 분석에서 사용할 수 없는 정보(예: 표현식이 <code>Literal["foo"]</code>와 같은 리터럴 문자열 타입인지 여부)에 접근할 수 있으며, 변수 할당이나 함수 호출 전반에 걸쳐 타입을 전파합니다.</p>
<p><strong><code>LiteralString</code>의 개념</strong> : <code>LiteralString</code>은 모든 리터럴 문자열 타입의 "슈퍼타입"입니다. 이는 <code>Literal["foo"]</code>와 <code>str</code> 사이에 타입 계층 구조를 도입합니다.</p>
<ul>
<li><code>Literal["foo"]</code> 또는 <code>Literal["bar"]</code>와 같은 특정 리터럴 문자열은 <code>LiteralString</code>과 호환되지만, 그 반대는 아닙니다.</li>
<li><code>LiteralString</code>의 슈퍼타입은 <code>str</code>입니다. 따라서 <code>LiteralString</code>은 <code>str</code>과 호환되지만, 그 반대는 아닙니다.</li>
<li>리터럴 타입들의 <code>Union</code> 또한 <code>LiteralString</code>과 호환됩니다 (예: <code>Literal["foo", "bar"]</code>).</li>
</ul>
<p><strong>리터럴 문자열의 조합</strong> : <code>x</code>와 <code>y</code>가 <code>LiteralString</code> 타입인 경우, <code>x + y</code>도 <code>LiteralString</code>과 호환되는 타입이 됩니다. 이는 <code>Literal["foo"]</code>와 <code>Literal["bar"]</code>를 더하면 <code>Literal["foobar"]</code>가 되므로 <code>LiteralString</code>과 호환된다는 식으로 추론할 수 있습니다. 이 원리는 리터럴 타입의 <code>Union</code>에도 적용됩니다.</p>
<p>이러한 방식으로, API가 리터럴로만 구성된 것으로 알려진 문자열만 허용하도록 지정할 수 있습니다.</p>
<h2>명세 (Specification)</h2>
<h3>런타임 동작 (Runtime Behavior)</h3>
<p><code>LiteralString</code>은 <code>typing.py</code>에 추가되며, <code>typing.NoReturn</code>과 유사하게 구현됩니다. <code>LiteralString</code>은 타입 검사를 위해서만 사용되는 특별한 형태입니다. 런타임에 <code>type(&#x3C;expr>)</code>이 <code>LiteralString</code>을 생성하는 표현식은 없습니다. 따라서 <code>str</code>의 서브클래스로 지정되지 않습니다.</p>
<h3><code>LiteralString</code>의 유효한 위치 (Valid Locations for LiteralString)</h3>
<p><code>LiteralString</code>은 다른 타입이 사용될 수 있는 모든 곳에 사용될 수 있습니다.</p>
<ul>
<li>변수 어노테이션: <code>variable_annotation: LiteralString</code></li>
<li>함수 매개변수 및 반환 타입: <code>def my_function(literal_string: LiteralString) -> LiteralString: ...</code></li>
<li>클래스 속성: <code>class Foo: my_attribute: LiteralString</code></li>
<li>제네릭 타입 인수: <code>type_argument: List[LiteralString]</code></li>
<li><code>TypeVar</code> 바운드: <code>T = TypeVar("T", bound=LiteralString)</code></li>
</ul>
<p>단, <code>Literal</code> 타입의 <code>Union</code> 내부에 중첩될 수 없습니다 (예: <code>Literal["hello", LiteralString]</code> 또는 <code>Literal[LiteralString]</code>은 허용되지 않습니다).</p>
<h3>타입 추론 (Type Inference)</h3>
<p><strong><code>LiteralString</code> 추론 규칙:</strong></p>
<ul>
<li>모든 리터럴 문자열 타입은 <code>LiteralString</code>과 호환됩니다 (예: <code>x: LiteralString = "foo"</code>는 유효합니다).</li>
<li><strong>덧셈</strong> : <code>x</code>와 <code>y</code>가 모두 <code>LiteralString</code>과 호환되면 <code>x + y</code>는 <code>LiteralString</code> 타입입니다.</li>
<li><strong>조인</strong> : <code>sep.join(xs)</code>는 <code>sep</code>이 <code>LiteralString</code>과 호환되고 <code>xs</code>가 <code>Iterable[LiteralString]</code>과 호환되면 <code>LiteralString</code> 타입입니다.</li>
<li><strong>복합 할당 (in-place addition)</strong> : <code>s</code>가 <code>LiteralString</code> 타입이고 <code>x</code>가 <code>LiteralString</code>과 호환되면, <code>s += x</code>는 <code>s</code>의 타입을 <code>LiteralString</code>으로 유지합니다.</li>
<li><strong>문자열 포매팅</strong> : f-string은 구성 요소 표현식들이 리터럴 문자열인 경우에만 <code>LiteralString</code> 타입입니다. <code>s.format(...)</code>도 <code>s</code>와 인자들이 <code>LiteralString</code>과 호환되는 경우에만 <code>LiteralString</code> 타입입니다.</li>
<li><strong>리터럴 유지 메서드</strong> : 부록 C에 <code>LiteralString</code> 타입을 유지하는 <code>str</code> 메서드 목록이 있습니다.</li>
</ul>
<p>그 외의 경우에는, 하나 이상의 구성 값이 <code>str</code>과 같은 비-리터럴 타입인 경우, 전체 타입은 <code>str</code>이 됩니다. (예: <code>s</code>가 <code>str</code> 타입이면 <code>"hello" + s</code>는 <code>str</code> 타입입니다.)</p>
<p><code>LiteralString</code>은 <code>str</code> 타입과 호환되며 <code>str</code>의 모든 메서드를 상속합니다.</p>
<p><strong>예시 (Examples)</strong></p>
<pre><code class="language-python">literal_string: LiteralString
s: str = literal_string # OK
literal_string: LiteralString = s # Error: Expected LiteralString, got str.
literal_string: LiteralString = "hello" # OK

# 리터럴 문자열의 덧셈:
def expect_literal_string(s: LiteralString) -> None: ...
expect_literal_string("foo" + "bar") # OK
literal_string2: LiteralString
expect_literal_string(literal_string + literal_string2) # OK
plain_string: str
expect_literal_string(literal_string + plain_string) # NOT OK.

# 리터럴 문자열을 사용한 Join:
expect_literal_string(",".join(["foo", "bar"])) # OK
xs: List[LiteralString]
expect_literal_string(literal_string.join(xs)) # OK
expect_literal_string(plain_string.join([literal_string, literal_string2])) # Not OK (구분자가 'str' 타입이기 때문)

# 복합 할당 (In-place addition):
literal_string += "foo" # OK
literal_string += plain_string # Not OK

# 리터럴 문자열을 사용한 포맷 문자열:
literal_name: LiteralString
expect_literal_string(f"hello {literal_name}") # OK
username: str
expect_literal_string(f"hello {username}") # NOT OK.

# 리터럴 정수 등 다른 리터럴 타입은 LiteralString과 호환되지 않습니다.
literal_one: Literal[1] = 1
expect_literal_string(literal_one) # Error: Expected LiteralString, got Literal[1].

# 조건문과 표현식
def return_literal_string() -> LiteralString:
    return "foo" if condition1() else "bar" # OK
</code></pre>
<h3>TypeVar 및 제네릭과의 상호작용 (Interaction with TypeVars and Generics)</h3>
<p><code>TypeVar</code>는 <code>LiteralString</code>에 바인딩될 수 있습니다.</p>
<pre><code class="language-python">from typing import Literal, LiteralString, TypeVar
TLiteral = TypeVar("TLiteral", bound=LiteralString)
def literal_identity(s: TLiteral) -> TLiteral: return s

hello: Literal["hello"] = "hello"
y = literal_identity(hello) # y는 Literal["hello"]로 추론됨
s: LiteralString
y2 = literal_identity(s) # y2는 LiteralString으로 추론됨
s_error: str
literal_identity(s_error) # Error
</code></pre>
<p><code>LiteralString</code>은 제네릭 클래스의 타입 인수로 사용될 수 있습니다.</p>
<pre><code class="language-python">class Container(Generic[T]): ...
literal_string: LiteralString = "hello"
x: Container[LiteralString] = Container(literal_string) # OK
s: str
x_error: Container[LiteralString] = Container(s) # Not OK
</code></pre>
<p><code>List</code>와 같은 표준 컨테이너도 예상대로 작동합니다.</p>
<h3>오버로드(Overloads)와의 상호작용 (Interactions with Overloads)</h3>
<p><code>LiteralString</code>은 특정 <code>Literal["foo"]</code> 타입이 일치하지 않을 때 폴백(fallback) 오버로드로 사용될 수 있습니다.</p>
<pre><code class="language-python">@overload
def foo(x: Literal["foo"]) -> int: ...
@overload
def foo(x: LiteralString) -> bool: ...
@overload
def foo(x: str) -> str: ...

x1: int = foo("foo") # 첫 번째 오버로드
x2: bool = foo("bar") # 두 번째 오버로드
s: str
x3: str = foo(s) # 세 번째 오버로드
</code></pre>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p>이전 Python 버전에서 사용하기 위해 <code>typing_extensions.LiteralString</code>이 추가될 예정입니다.</p>
<p>PEP 586과 마찬가지로, 이 PEP는 타입 체커가 리터럴 문자열로 초기화된 어노테이션 없는 변수에 대해 리터럴 문자열 타입을 추론하도록 강제하지는 않습니다. 그러나 대부분의 타입 체커는 이러한 추론을 수행하며, 그렇지 않은 경우 사용자는 <code>x: LiteralString = "hello"</code>와 같이 명시적으로 어노테이션을 추가하여 타입 체커를 도울 수 있습니다.</p>
<h2>거부된 대안 (Rejected Alternatives)</h2>
<h3>특정 도구 X를 사용하지 않는 이유 (Why not use tool X?)</h3>
<p>SQL 인젝션과 같은 문제를 잡는 도구는 AST 기반, 함수 레벨 분석, 오염 흐름 분석(taint flow analysis)의 세 가지 유형이 있습니다.</p>
<ul>
<li><strong>AST 기반 도구 (예: Bandit)</strong> : 리터럴 문자열이 아닌 SQL 쿼리에 대해 경고하지만, 안전한 SQL 쿼리도 문자열 리터럴로 동적으로 구축되는 경우가 많습니다. 이러한 도구는 개발자의 SQL 쿼리 구축 능력을 크게 제한합니다. <code>LiteralString</code>은 더 적은 제약으로 유사한 안전 보장을 제공할 수 있습니다.</li>
<li><strong>Semgrep 및 pyanalyze</strong> : 함수 내에서 상수 전파를 포함한 정교한 함수 레벨 분석을 지원하여 일부 형태의 안전한 동적 SQL 쿼리를 허용합니다. 그러나 안전한 SQL 쿼리를 구성하고 반환하는 함수 호출은 처리하지 못합니다. <code>LiteralString</code>은 이러한 자연스러운 사용을 프로그래머에게 부담 없이 처리합니다.</li>
<li><strong>오염 흐름 분석 (예: Pysa, CodeQL)</strong> : 사용자 제어 입력에서 SQL 쿼리로 흐르는 데이터를 추적할 수 있는 강력한 도구입니다. 하지만 CI 설정, '오염' 싱크 및 소스 정의, 개발자 교육에 상당한 오버헤드가 있습니다. 또한 실행 시간이 타입 체커보다 길어 피드백이 즉각적이지 않습니다. 마지막으로, 취약점 방지의 부담을 라이브러리 사용자에게 전가하는 반면 <code>LiteralString</code>은 라이브러리 자체가 API 호출 방식을 정확하게 지정할 수 있도록 합니다.</li>
</ul>
<p>전용 도구 대신 새 타입을 선호하는 한 가지 이유는 타입 체커가 전용 보안 도구보다 훨씬 널리 사용된다는 점입니다. 타입 체커에 보안 기능이 내장되면 더 많은 개발자가 혜택을 받을 수 있습니다.</p>
<h3><code>str</code>에 <code>NewType</code>을 사용하지 않는 이유 (Why not use a NewType for str?)</h3>
<p><code>LiteralString</code>이 적합한 모든 API는 <code>NewType("SafeSQL", str)</code>와 같이 Python 타입 시스템 내에서 생성된 다른 타입을 받아들이도록 업데이트될 수 있습니다.</p>
<pre><code class="language-python">SafeSQL = NewType("SafeSQL", str)
def execute(self, sql: SafeSQL, parameters: Iterable[str] = ...) -> Cursor: ...
execute(SafeSQL("SELECT * FROM data WHERE user_id = ?"), user_id) # OK
</code></pre>
<p>그러나 사용자가 사용자 제어 문자열을 새로운 타입으로 강제 변환하여 전달하는 것을 막을 수 없습니다.</p>
<pre><code class="language-python">query = f"SELECT * FROM data WHERE user_id = f{user_id}"
execute(SafeSQL(query)) # 오류 없음!
</code></pre>
<p>이는 Django의 <code>SafeString</code>과 <code>mark_safe</code>가 CVE-2020-13596과 같은 문제를 발생시킨 사례에서도 볼 수 있습니다. 또한, <code>NewType</code>은 소스 코드에 침투적인 변경(쿼리를 <code>SafeSQL</code>로 래핑)을 요구하지만, <code>LiteralString</code>은 그러한 변경을 요구하지 않습니다.</p>
<h3>Trusted Types 에뮬레이션을 시도하지 않는 이유 (Why not try to emulate Trusted Types?)</h3>
<p>Trusted Types는 DOM 기반 XSS를 방지하기 위한 W3C 명세입니다. Python에 Trusted Types 개념을 도입하는 것을 고려할 수 있지만, 근본적인 차이점은 Trusted Types 새니타이저(sanitizer)의 출력은 일반적으로 실행 가능한 코드가 아니라는 점입니다. SQL 쿼리나 셸 명령어는 최종 결과가 여전히 실행 가능한 코드여야 하므로, 입력 문자열의 어느 부분이 안전하고 어느 부분이 악의적인지 안정적으로 파악하는 새니타이저를 작성할 방법이 없습니다.</p>
<h3>런타임 체크 가능한 <code>LiteralString</code> (Runtime Checkable LiteralString)</h3>
<p><code>LiteralString</code> 개념을 정적 타입 검사 이상으로 확장하여 <code>str</code> 객체의 런타임 체크 가능한 속성으로 만들 수도 있습니다. 이는 프레임워크가 동적 문자열에 대해 오류를 발생시키도록 허용하는 등의 이점을 제공할 수 있습니다. 그러나 이 확장은 Python의 가장 근본적인 타입 중 하나에 대한 변경을 요구하므로 제안의 범위를 극적으로 증가시킵니다.</p>
<h3>거부된 이름 (Rejected Names)</h3>
<p><code>LiteralString</code> 외에 <code>Literal[str]</code>, <code>LiteralStr</code>, <code>LiteralDerivedString</code>, <code>StringLiteral</code>, <code>SafeString</code>, <code>ConstantStr</code>, <code>StaticStr</code>, <code>LiteralOnly[str]</code> 등 다양한 이름이 고려되었지만, 각각의 문제점(혼동 가능성, 장황함, 오해의 소지 등)으로 인해 <code>LiteralString</code>이 선택되었습니다.</p>
<h3>LiteralBytes</h3>
<p><code>LiteralBytes</code>와 같이 리터럴 바이트 타입을 일반화하는 것도 가능하지만, <code>LiteralString</code>만큼 사용 빈도가 높지 않고 사용자 요구가 많지 않아 이 PEP에는 포함되지 않았습니다.</p>
<h2>참조 구현 (Reference Implementation)</h2>
<p>Pyre v0.9.8에 구현되어 활발하게 사용 중입니다. 구현은 단순히 타입 체커를 확장하여 <code>LiteralString</code>을 리터럴 문자열 타입의 슈퍼타입으로 추가합니다. 덧셈, 조인 등을 통한 조합을 지원하기 위해 <code>typeshed</code>의 <code>str</code> 스텁을 오버로드하는 것으로 충분했습니다.</p>
<h2>부록 A: 다른 용례 (Other Uses)</h2>
<p><code>LiteralString</code>은 SQL 인젝션 외에도 다양한 종류의 인젝션 취약점을 방지하는 데 사용될 수 있습니다.</p>
<ul>
<li><strong>명령어 인젝션 (Command Injection)</strong> : <code>subprocess.run</code>과 같은 API가 사용자 제어 데이터를 포함하는 셸 명령어를 실행할 때 발생할 수 있는 취약점을 방지합니다.
<pre><code class="language-python"># 수정된 stub (예시)
def run(command: LiteralString, *args: str, shell: bool=...): ...
</code></pre>
</li>
<li><strong>크로스 사이트 스크립팅 (XSS)</strong> : Django의 <code>mark_safe</code>나 Jinja2의 <code>do_mark_safe</code>와 같이 자동 이스케이핑을 우회하는 함수가 사용자 입력으로 XSS 취약점을 유발할 수 있는 것을 방지합니다.
<pre><code class="language-python"># 수정된 stub (예시)
def mark_safe(s: LiteralString) -> str: ...
</code></pre>
</li>
<li><strong>서버 사이드 템플릿 인젝션 (SSTI)</strong> : Jinja와 같은 템플릿 프레임워크에서 공격자가 템플릿 문자열을 제어하여 임의 코드를 실행할 수 있는 취약점을 방지합니다.
<pre><code class="language-python"># 수정된 stub (예시)
class Template:
    def __init__(self, source: LiteralString): ...
</code></pre>
</li>
<li><strong>로깅 포맷 문자열 인젝션 (Logging Format String Injection)</strong> : 로깅 프레임워크가 입력 문자열에 포매팅 지시어를 허용할 때, 외부에서 제어되는 로깅 문자열로 인해 서비스 거부(DoS) 공격이 발생할 수 있는 것을 방지합니다.
<pre><code class="language-python"># 수정된 stub (예시)
def info(msg: LiteralString, *args: object) -> None: ...
</code></pre>
</li>
</ul>
<h2>부록 B: 한계 (Limitations)</h2>
<p><code>LiteralString</code>이 사용자가 리터럴이 아닌 데이터로 구성된 문자열을 API에 전달하는 것을 막지 못할 수 있는 몇 가지 방법이 있습니다.</p>
<ol>
<li>개발자가 타입 체커를 사용하지 않거나 타입 어노테이션을 추가하지 않는 경우, 위반 사항이 감지되지 않습니다.</li>
<li><code>cast(LiteralString, non_literal_string)</code>를 사용하여 타입 체커를 속이고 동적 문자열 값을 <code>LiteralString</code>인 것처럼 위장할 수 있습니다. <code>Any</code> 타입의 변수도 마찬가지입니다.</li>
<li><code># type: ignore</code>와 같은 주석을 사용하여 비-리터럴 문자열에 대한 경고를 무시할 수 있습니다.</li>
<li><code>str</code>을 <code>LiteralString</code>으로 변환하는 사소한 함수를 구성할 수 있습니다.</li>
</ol>
<p>이러한 한계는 린팅, 코드 리뷰 등을 통해 완화될 수 있지만, 궁극적으로 <code>LiteralString</code>이 제공하는 보호 기능을 우회하려는 악의적인 개발자는 항상 성공할 것입니다. <code>LiteralString</code>은 악의적인 개발자로부터 보호하기 위한 것이 아니라, 선량한 개발자가 민감한 API를 우발적으로 위험하게 사용하는 것을 방지하기 위한 것입니다.</p>
<p><code>LiteralString</code>이 없으면 API 작성자가 가질 수 있는 최선의 강제 도구는 문서뿐이며, 이는 쉽게 무시되고 종종 보이지 않습니다. <code>LiteralString</code>을 사용하면 API 오용은 의식적인 사고와 코드 내에서 검토자와 미래 개발자가 알아챌 수 있는 아티팩트를 요구합니다.</p>
<h2>부록 C: <code>LiteralString</code>을 보존하는 <code>str</code> 메서드 (<code>str</code> methods that preserve LiteralString)</h2>
<p><code>str</code> 클래스에는 <code>LiteralString</code> 타입이 이점을 얻을 수 있는 여러 메서드가 있습니다. 예를 들어, <code>"hello".capitalize()</code>는 <code>LiteralString</code>과 호환되는 <code>Literal["Hello"]</code> 타입으로 추론되어야 합니다. 즉, <code>capitalize</code> 메서드는 <code>LiteralString</code> 타입을 보존합니다.</p>
<p><code>typeshed</code>의 <code>str</code> 스텁을 업데이트하여 <code>LiteralString</code>을 보존하는 버전으로 메서드를 오버로드할 것을 제안합니다. 이렇게 하면 타입 체커가 각 메서드에 대해 <code>LiteralString</code> 동작을 하드코딩할 필요가 없으며, 향후 새로운 메서드도 쉽게 지원할 수 있습니다.</p>
<p>예를 들어, <code>capitalize</code> 메서드에 대한 스텁은 다음과 같이 변경됩니다.</p>
<pre><code class="language-python"># 변경 전
def capitalize(self) -> str: ...
# 변경 후
@overload
def capitalize(self: LiteralString) -> LiteralString: ...
@overload
def capitalize(self) -> str: ...
</code></pre>
<p>단점은 스텁이 더 복잡해지고 에러 메시지가 이해하기 어려워질 수 있다는 점입니다.</p>
<p><code>LiteralString</code>을 반환하는 것으로 처리되어야 하는 <code>str</code> 메서드의 목록 (모든 인수가 <code>LiteralString</code> 타입일 때)은 PEP 원문에 상세히 나열되어 있습니다. (예: <code>casefold</code>, <code>center</code>, <code>join</code>, <code>lower</code>, <code>replace</code>, <code>split</code>, <code>upper</code>, <code>__add__</code>, <code>__mul__</code> 등).</p>
<h2>부록 D: 스텁에서 <code>LiteralString</code> 사용 지침 (Guidelines for using LiteralString in Stubs)</h2>
<p>Typeshed의 타입 스텁 작성자는 <code>LiteralString</code>을 사용할 때 주의해야 합니다.</p>
<ul>
<li><strong>순수 함수 (pure function)</strong> 의 스텁인 경우, 모든 해당 매개변수가 리터럴 타입(<code>LiteralString</code> 또는 <code>Literal["a", "b"]</code>)을 가질 때만 함수의 반환 타입 또는 오버로드에 <code>LiteralString</code>을 사용하는 것을 권장합니다.
<pre><code class="language-python"># OK
@overload
def my_transform(x: LiteralString, y: Literal["a", "b"]) -> LiteralString: ...
@overload
def my_transform(x: str, y: str) -> str: ...

# Not OK (x는 LiteralString이지만 y는 str이므로 반환 타입을 LiteralString으로 하면 안 됨)
@overload
def my_transform(x: LiteralString, y: str) -> LiteralString: ...
</code></pre>
</li>
<li><strong><code>staticmethod</code></strong> 의 스텁인 경우 위와 동일한 지침을 권장합니다.</li>
<li><strong>다른 종류의 메서드</strong> 의 스텁인 경우, 메서드 또는 오버로드의 반환 타입에 <code>LiteralString</code>을 사용하지 않는 것을 권장합니다. 모든 명시적 매개변수가 <code>LiteralString</code> 타입이더라도 객체 자체가 사용자 데이터로 생성될 수 있기 때문입니다.</li>
<li><strong>클래스 속성 또는 전역 변수</strong> 의 스텁인 경우에도 <code>LiteralString</code> 사용을 권장하지 않습니다.</li>
</ul>
<p>그러나 최종 결정은 라이브러리 작성자에게 달려 있습니다. 메서드나 함수가 반환하는 문자열 또는 속성에 저장된 문자열이 리터럴 타입임을 확신할 수 있는 경우(즉, 문자열 리터럴에 리터럴을 보존하는 <code>str</code> 연산만 적용하여 생성된 경우) <code>LiteralString</code>을 사용할 수 있습니다. 이 지침은 타입 체커가 타입을 확인할 수 있는 인라인 타입 어노테이션에는 적용되지 않습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/674/">[Deferred] PEP 674 - Disallow using macros as l-values</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 675 - Arbitrary Literal String Type</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/676/">[Active] PEP 676 - PEP Infrastructure Process</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/edf391eeca43d999.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0ec5cf06f346236d.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-e3ea38185bb36cd2.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/675\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/edf391eeca43d999.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"J5cbkfStV-uQJU0kFEPzo\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/675/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/675\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"675\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/675\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T7263,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0675/\"\u003ePEP 675 - Arbitrary Literal String Type\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 30-Nov-2021\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 675: 임의의 리터럴 문자열 타입 (Arbitrary Literal String Type)\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e현재 Python에서는 특정 리터럴 문자열(예: \u003ccode\u003eLiteral[\"foo\"]\u003c/code\u003e)이 아닌, \"어떤\" 리터럴 문자열 타입이든 허용하는 함수 매개변수를 타입 어노테이션으로 지정할 방법이 없습니다. 이 PEP는 리터럴 문자열 타입들의 슈퍼타입인 \u003ccode\u003eLiteralString\u003c/code\u003e을 도입합니다. 이를 통해 함수가 \u003ccode\u003eLiteral[\"foo\"]\u003c/code\u003e 또는 \u003ccode\u003eLiteral[\"bar\"]\u003c/code\u003e와 같은 임의의 리터럴 문자열 타입을 받아들일 수 있게 됩니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003eSQL 또는 셸 명령어를 실행하는 강력한 API는 종종 임의의 사용자 제어 문자열이 아닌, \u003cem\u003e리터럴 문자열\u003c/em\u003e로 호출될 것을 권장합니다. 그러나 현재 타입 시스템에는 이러한 권장 사항을 표현할 방법이 없어, 개발자가 이를 따르지 않을 경우 보안 취약점이 발생하곤 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e문제 사례: SQL Injection\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e예를 들어, 사용자 ID를 받아 데이터베이스에서 레코드를 조회하는 일반적인 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef query_user(conn: Connection, user_id: str) -\u003e User:\r\n    query = f\"SELECT * FROM data WHERE user_id = {user_id}\"\r\n    conn.execute(query)\r\n    # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003euser_id\u003c/code\u003e가 사용자 제어 데이터이므로, 악의적인 사용자는 SQL 인젝션 공격을 시도할 수 있습니다. 예를 들어, \u003ccode\u003euser_id\u003c/code\u003e에 \u003ccode\u003e\"user123; DROP TABLE data;\"\u003c/code\u003e를 전달하면 테이블이 삭제될 수 있습니다.\u003c/p\u003e\n\u003cp\u003eSQL API는 이러한 공격을 방지하기 위해 매개변수화된 쿼리(parameterized queries)를 제공하여 쿼리 실행과 사용자 제어 데이터를 분리합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef query_user(conn: Connection, user_id: str) -\u003e User:\r\n    query = \"SELECT * FROM data WHERE user_id = ?\"\r\n    conn.execute(query, (user_id,))\r\n    # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e문제는 이러한 원칙을 강제할 방법이 없다는 것입니다. \u003ccode\u003esqlite3\u003c/code\u003e의 문서조차 외부 입력으로 \u003ccode\u003esql\u003c/code\u003e 인수를 동적으로 구성하지 말라고 권고할 뿐, 타입 시스템을 통해 이를 표현할 수 없습니다. 결과적으로 사용자들은 여전히 편리한 f-string을 사용하여 코드를 SQL 인젝션에 취약하게 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e기존 보안 린터(예: Bandit)는 SQL API에서 안전하지 않은 외부 데이터를 탐지하려고 시도하지만, 여러 줄 쿼리를 변수에 저장하거나 조건에 따라 리터럴 문자열을 추가하는 등 일반적인 코딩 관용구를 방해할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eLiteralString\u003c/code\u003e의 해결책:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e 타입은 리터럴로 구성된 것으로 알려진 문자열 값만 허용합니다. 이는 PEP 586의 \u003ccode\u003eLiteral[\"foo\"]\u003c/code\u003e 타입의 일반화된 형태입니다. \u003ccode\u003eLiteralString\u003c/code\u003e 타입의 문자열은 사용자 제어 데이터를 포함할 수 없으므로, \u003ccode\u003eLiteralString\u003c/code\u003e만 허용하는 API는 인젝션 취약점으로부터 안전합니다 (실용적인 한계 내에서).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esqlite3\u003c/code\u003e의 \u003ccode\u003eexecute\u003c/code\u003e 메서드가 사용자 입력으로 만들어진 문자열을 허용하지 않도록, \u003ccode\u003etypeshed\u003c/code\u003e 스텁에서 SQL 쿼리가 \u003ccode\u003eLiteralString\u003c/code\u003e 타입임을 명시할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import LiteralString\r\ndef execute(self, sql: LiteralString, parameters: Iterable[str] = ...) -\u003e Cursor: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 \u003ccode\u003euser_id\u003c/code\u003e를 사용하는 f-string으로 구성된 \u003ccode\u003equery\u003c/code\u003e 변수는 \u003ccode\u003estr\u003c/code\u003e 타입으로 추론되어 \u003ccode\u003eexecute\u003c/code\u003e에 전달할 수 없게 되며 타입 에러가 발생합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef query_user(conn: Connection, user_id: str) -\u003e User:\r\n    query = f\"SELECT * FROM data WHERE user_id = {user_id}\"\r\n    conn.execute(query) # 에러: Expected LiteralString, got str.\r\n    # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e반면, 리터럴 문자열끼리 결합하는 안전한 패턴은 여전히 허용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef query_data(conn: Connection, user_id: str, limit: bool) -\u003e None:\r\n    query = \"\"\" SELECT user.name, user.age FROM data WHERE user_id = ? \"\"\"\r\n    if limit:\r\n        query += \" LIMIT 1\" # LiteralString을 추가했으므로 여전히 LiteralString 타입.\r\n    conn.execute(query, (user_id,)) # OK\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사용자는 SQL 코드를 변경할 필요 없이 타입 체커가 리터럴 문자열 타입을 추론하고 위반 시에만 경고하게 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e은 셸 명령어 구축, HTML 응답 렌더링 시 이스케이프 없이 문자열 사용 등 엄격한 명령-데이터 분리가 필요한 다른 경우에도 유용합니다 (부록 A 참조).\u003c/p\u003e\n\u003ch3\u003e사용 통계 (Usage statistics)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esqlite3\u003c/code\u003e를 사용하는 오픈 소스 프로젝트 샘플에서 \u003ccode\u003econn.execute\u003c/code\u003e 호출 중 약 67%는 안전한 문자열 리터럴로, 약 33%는 잠재적으로 안전하지 않은 로컬 문자열 변수로 이루어졌습니다. 이 PEP의 \u003ccode\u003eLiteralString\u003c/code\u003e 타입을 타입 체커와 함께 사용하면 33% 중 사용자 제어 데이터가 쿼리에 통합된 부분을 방지할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e왜 보안 취약점 방지에 타입을 사용해야 하는가?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e문서 경고는 불충분\u003c/strong\u003e : 대부분의 사용자는 경고를 보지 않거나 무시합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e기존 동적/정적 분석은 너무 제한적\u003c/strong\u003e : 자연스러운 코딩 관용구를 막습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e타이핑 기반 접근 방식\u003c/strong\u003e : 엄격함과 유연성 사이의 균형을 맞춥니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e런타임(Runtime) 접근 방식의 한계\u003c/strong\u003e : 런타임에는 쿼리 문자열이 일반 \u003ccode\u003estr\u003c/code\u003e이므로, 휴리스틱(heuristics)으로 일부 악용을 막을 수 있지만, 항상 우회할 방법이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e정적(Static) 접근 방식의 한계\u003c/strong\u003e : AST를 확인하는 정적 분석은 문자열이 중간 변수에 할당되거나 안전한 함수에 의해 변환될 때를 구별할 수 없어 지나치게 제한적입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e타입 체커(Type Checker)의 장점\u003c/strong\u003e : 타입 체커는 런타임 또는 정적 분석에서 사용할 수 없는 정보(예: 표현식이 \u003ccode\u003eLiteral[\"foo\"]\u003c/code\u003e와 같은 리터럴 문자열 타입인지 여부)에 접근할 수 있으며, 변수 할당이나 함수 호출 전반에 걸쳐 타입을 전파합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eLiteralString\u003c/code\u003e의 개념\u003c/strong\u003e : \u003ccode\u003eLiteralString\u003c/code\u003e은 모든 리터럴 문자열 타입의 \"슈퍼타입\"입니다. 이는 \u003ccode\u003eLiteral[\"foo\"]\u003c/code\u003e와 \u003ccode\u003estr\u003c/code\u003e 사이에 타입 계층 구조를 도입합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLiteral[\"foo\"]\u003c/code\u003e 또는 \u003ccode\u003eLiteral[\"bar\"]\u003c/code\u003e와 같은 특정 리터럴 문자열은 \u003ccode\u003eLiteralString\u003c/code\u003e과 호환되지만, 그 반대는 아닙니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLiteralString\u003c/code\u003e의 슈퍼타입은 \u003ccode\u003estr\u003c/code\u003e입니다. 따라서 \u003ccode\u003eLiteralString\u003c/code\u003e은 \u003ccode\u003estr\u003c/code\u003e과 호환되지만, 그 반대는 아닙니다.\u003c/li\u003e\n\u003cli\u003e리터럴 타입들의 \u003ccode\u003eUnion\u003c/code\u003e 또한 \u003ccode\u003eLiteralString\u003c/code\u003e과 호환됩니다 (예: \u003ccode\u003eLiteral[\"foo\", \"bar\"]\u003c/code\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e리터럴 문자열의 조합\u003c/strong\u003e : \u003ccode\u003ex\u003c/code\u003e와 \u003ccode\u003ey\u003c/code\u003e가 \u003ccode\u003eLiteralString\u003c/code\u003e 타입인 경우, \u003ccode\u003ex + y\u003c/code\u003e도 \u003ccode\u003eLiteralString\u003c/code\u003e과 호환되는 타입이 됩니다. 이는 \u003ccode\u003eLiteral[\"foo\"]\u003c/code\u003e와 \u003ccode\u003eLiteral[\"bar\"]\u003c/code\u003e를 더하면 \u003ccode\u003eLiteral[\"foobar\"]\u003c/code\u003e가 되므로 \u003ccode\u003eLiteralString\u003c/code\u003e과 호환된다는 식으로 추론할 수 있습니다. 이 원리는 리터럴 타입의 \u003ccode\u003eUnion\u003c/code\u003e에도 적용됩니다.\u003c/p\u003e\n\u003cp\u003e이러한 방식으로, API가 리터럴로만 구성된 것으로 알려진 문자열만 허용하도록 지정할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003ch3\u003e런타임 동작 (Runtime Behavior)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e은 \u003ccode\u003etyping.py\u003c/code\u003e에 추가되며, \u003ccode\u003etyping.NoReturn\u003c/code\u003e과 유사하게 구현됩니다. \u003ccode\u003eLiteralString\u003c/code\u003e은 타입 검사를 위해서만 사용되는 특별한 형태입니다. 런타임에 \u003ccode\u003etype(\u0026#x3C;expr\u003e)\u003c/code\u003e이 \u003ccode\u003eLiteralString\u003c/code\u003e을 생성하는 표현식은 없습니다. 따라서 \u003ccode\u003estr\u003c/code\u003e의 서브클래스로 지정되지 않습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eLiteralString\u003c/code\u003e의 유효한 위치 (Valid Locations for LiteralString)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e은 다른 타입이 사용될 수 있는 모든 곳에 사용될 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e변수 어노테이션: \u003ccode\u003evariable_annotation: LiteralString\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e함수 매개변수 및 반환 타입: \u003ccode\u003edef my_function(literal_string: LiteralString) -\u003e LiteralString: ...\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e클래스 속성: \u003ccode\u003eclass Foo: my_attribute: LiteralString\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e제네릭 타입 인수: \u003ccode\u003etype_argument: List[LiteralString]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTypeVar\u003c/code\u003e 바운드: \u003ccode\u003eT = TypeVar(\"T\", bound=LiteralString)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단, \u003ccode\u003eLiteral\u003c/code\u003e 타입의 \u003ccode\u003eUnion\u003c/code\u003e 내부에 중첩될 수 없습니다 (예: \u003ccode\u003eLiteral[\"hello\", LiteralString]\u003c/code\u003e 또는 \u003ccode\u003eLiteral[LiteralString]\u003c/code\u003e은 허용되지 않습니다).\u003c/p\u003e\n\u003ch3\u003e타입 추론 (Type Inference)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eLiteralString\u003c/code\u003e 추론 규칙:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모든 리터럴 문자열 타입은 \u003ccode\u003eLiteralString\u003c/code\u003e과 호환됩니다 (예: \u003ccode\u003ex: LiteralString = \"foo\"\u003c/code\u003e는 유효합니다).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e덧셈\u003c/strong\u003e : \u003ccode\u003ex\u003c/code\u003e와 \u003ccode\u003ey\u003c/code\u003e가 모두 \u003ccode\u003eLiteralString\u003c/code\u003e과 호환되면 \u003ccode\u003ex + y\u003c/code\u003e는 \u003ccode\u003eLiteralString\u003c/code\u003e 타입입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e조인\u003c/strong\u003e : \u003ccode\u003esep.join(xs)\u003c/code\u003e는 \u003ccode\u003esep\u003c/code\u003e이 \u003ccode\u003eLiteralString\u003c/code\u003e과 호환되고 \u003ccode\u003exs\u003c/code\u003e가 \u003ccode\u003eIterable[LiteralString]\u003c/code\u003e과 호환되면 \u003ccode\u003eLiteralString\u003c/code\u003e 타입입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e복합 할당 (in-place addition)\u003c/strong\u003e : \u003ccode\u003es\u003c/code\u003e가 \u003ccode\u003eLiteralString\u003c/code\u003e 타입이고 \u003ccode\u003ex\u003c/code\u003e가 \u003ccode\u003eLiteralString\u003c/code\u003e과 호환되면, \u003ccode\u003es += x\u003c/code\u003e는 \u003ccode\u003es\u003c/code\u003e의 타입을 \u003ccode\u003eLiteralString\u003c/code\u003e으로 유지합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e문자열 포매팅\u003c/strong\u003e : f-string은 구성 요소 표현식들이 리터럴 문자열인 경우에만 \u003ccode\u003eLiteralString\u003c/code\u003e 타입입니다. \u003ccode\u003es.format(...)\u003c/code\u003e도 \u003ccode\u003es\u003c/code\u003e와 인자들이 \u003ccode\u003eLiteralString\u003c/code\u003e과 호환되는 경우에만 \u003ccode\u003eLiteralString\u003c/code\u003e 타입입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e리터럴 유지 메서드\u003c/strong\u003e : 부록 C에 \u003ccode\u003eLiteralString\u003c/code\u003e 타입을 유지하는 \u003ccode\u003estr\u003c/code\u003e 메서드 목록이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그 외의 경우에는, 하나 이상의 구성 값이 \u003ccode\u003estr\u003c/code\u003e과 같은 비-리터럴 타입인 경우, 전체 타입은 \u003ccode\u003estr\u003c/code\u003e이 됩니다. (예: \u003ccode\u003es\u003c/code\u003e가 \u003ccode\u003estr\u003c/code\u003e 타입이면 \u003ccode\u003e\"hello\" + s\u003c/code\u003e는 \u003ccode\u003estr\u003c/code\u003e 타입입니다.)\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e은 \u003ccode\u003estr\u003c/code\u003e 타입과 호환되며 \u003ccode\u003estr\u003c/code\u003e의 모든 메서드를 상속합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e예시 (Examples)\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eliteral_string: LiteralString\r\ns: str = literal_string # OK\r\nliteral_string: LiteralString = s # Error: Expected LiteralString, got str.\r\nliteral_string: LiteralString = \"hello\" # OK\r\n\r\n# 리터럴 문자열의 덧셈:\r\ndef expect_literal_string(s: LiteralString) -\u003e None: ...\r\nexpect_literal_string(\"foo\" + \"bar\") # OK\r\nliteral_string2: LiteralString\r\nexpect_literal_string(literal_string + literal_string2) # OK\r\nplain_string: str\r\nexpect_literal_string(literal_string + plain_string) # NOT OK.\r\n\r\n# 리터럴 문자열을 사용한 Join:\r\nexpect_literal_string(\",\".join([\"foo\", \"bar\"])) # OK\r\nxs: List[LiteralString]\r\nexpect_literal_string(literal_string.join(xs)) # OK\r\nexpect_literal_string(plain_string.join([literal_string, literal_string2])) # Not OK (구분자가 'str' 타입이기 때문)\r\n\r\n# 복합 할당 (In-place addition):\r\nliteral_string += \"foo\" # OK\r\nliteral_string += plain_string # Not OK\r\n\r\n# 리터럴 문자열을 사용한 포맷 문자열:\r\nliteral_name: LiteralString\r\nexpect_literal_string(f\"hello {literal_name}\") # OK\r\nusername: str\r\nexpect_literal_string(f\"hello {username}\") # NOT OK.\r\n\r\n# 리터럴 정수 등 다른 리터럴 타입은 LiteralString과 호환되지 않습니다.\r\nliteral_one: Literal[1] = 1\r\nexpect_literal_string(literal_one) # Error: Expected LiteralString, got Literal[1].\r\n\r\n# 조건문과 표현식\r\ndef return_literal_string() -\u003e LiteralString:\r\n    return \"foo\" if condition1() else \"bar\" # OK\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eTypeVar 및 제네릭과의 상호작용 (Interaction with TypeVars and Generics)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eTypeVar\u003c/code\u003e는 \u003ccode\u003eLiteralString\u003c/code\u003e에 바인딩될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Literal, LiteralString, TypeVar\r\nTLiteral = TypeVar(\"TLiteral\", bound=LiteralString)\r\ndef literal_identity(s: TLiteral) -\u003e TLiteral: return s\r\n\r\nhello: Literal[\"hello\"] = \"hello\"\r\ny = literal_identity(hello) # y는 Literal[\"hello\"]로 추론됨\r\ns: LiteralString\r\ny2 = literal_identity(s) # y2는 LiteralString으로 추론됨\r\ns_error: str\r\nliteral_identity(s_error) # Error\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e은 제네릭 클래스의 타입 인수로 사용될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Container(Generic[T]): ...\r\nliteral_string: LiteralString = \"hello\"\r\nx: Container[LiteralString] = Container(literal_string) # OK\r\ns: str\r\nx_error: Container[LiteralString] = Container(s) # Not OK\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eList\u003c/code\u003e와 같은 표준 컨테이너도 예상대로 작동합니다.\u003c/p\u003e\n\u003ch3\u003e오버로드(Overloads)와의 상호작용 (Interactions with Overloads)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e은 특정 \u003ccode\u003eLiteral[\"foo\"]\u003c/code\u003e 타입이 일치하지 않을 때 폴백(fallback) 오버로드로 사용될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@overload\r\ndef foo(x: Literal[\"foo\"]) -\u003e int: ...\r\n@overload\r\ndef foo(x: LiteralString) -\u003e bool: ...\r\n@overload\r\ndef foo(x: str) -\u003e str: ...\r\n\r\nx1: int = foo(\"foo\") # 첫 번째 오버로드\r\nx2: bool = foo(\"bar\") # 두 번째 오버로드\r\ns: str\r\nx3: str = foo(s) # 세 번째 오버로드\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e이전 Python 버전에서 사용하기 위해 \u003ccode\u003etyping_extensions.LiteralString\u003c/code\u003e이 추가될 예정입니다.\u003c/p\u003e\n\u003cp\u003ePEP 586과 마찬가지로, 이 PEP는 타입 체커가 리터럴 문자열로 초기화된 어노테이션 없는 변수에 대해 리터럴 문자열 타입을 추론하도록 강제하지는 않습니다. 그러나 대부분의 타입 체커는 이러한 추론을 수행하며, 그렇지 않은 경우 사용자는 \u003ccode\u003ex: LiteralString = \"hello\"\u003c/code\u003e와 같이 명시적으로 어노테이션을 추가하여 타입 체커를 도울 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e거부된 대안 (Rejected Alternatives)\u003c/h2\u003e\n\u003ch3\u003e특정 도구 X를 사용하지 않는 이유 (Why not use tool X?)\u003c/h3\u003e\n\u003cp\u003eSQL 인젝션과 같은 문제를 잡는 도구는 AST 기반, 함수 레벨 분석, 오염 흐름 분석(taint flow analysis)의 세 가지 유형이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAST 기반 도구 (예: Bandit)\u003c/strong\u003e : 리터럴 문자열이 아닌 SQL 쿼리에 대해 경고하지만, 안전한 SQL 쿼리도 문자열 리터럴로 동적으로 구축되는 경우가 많습니다. 이러한 도구는 개발자의 SQL 쿼리 구축 능력을 크게 제한합니다. \u003ccode\u003eLiteralString\u003c/code\u003e은 더 적은 제약으로 유사한 안전 보장을 제공할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSemgrep 및 pyanalyze\u003c/strong\u003e : 함수 내에서 상수 전파를 포함한 정교한 함수 레벨 분석을 지원하여 일부 형태의 안전한 동적 SQL 쿼리를 허용합니다. 그러나 안전한 SQL 쿼리를 구성하고 반환하는 함수 호출은 처리하지 못합니다. \u003ccode\u003eLiteralString\u003c/code\u003e은 이러한 자연스러운 사용을 프로그래머에게 부담 없이 처리합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e오염 흐름 분석 (예: Pysa, CodeQL)\u003c/strong\u003e : 사용자 제어 입력에서 SQL 쿼리로 흐르는 데이터를 추적할 수 있는 강력한 도구입니다. 하지만 CI 설정, '오염' 싱크 및 소스 정의, 개발자 교육에 상당한 오버헤드가 있습니다. 또한 실행 시간이 타입 체커보다 길어 피드백이 즉각적이지 않습니다. 마지막으로, 취약점 방지의 부담을 라이브러리 사용자에게 전가하는 반면 \u003ccode\u003eLiteralString\u003c/code\u003e은 라이브러리 자체가 API 호출 방식을 정확하게 지정할 수 있도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e전용 도구 대신 새 타입을 선호하는 한 가지 이유는 타입 체커가 전용 보안 도구보다 훨씬 널리 사용된다는 점입니다. 타입 체커에 보안 기능이 내장되면 더 많은 개발자가 혜택을 받을 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003estr\u003c/code\u003e에 \u003ccode\u003eNewType\u003c/code\u003e을 사용하지 않는 이유 (Why not use a NewType for str?)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e이 적합한 모든 API는 \u003ccode\u003eNewType(\"SafeSQL\", str)\u003c/code\u003e와 같이 Python 타입 시스템 내에서 생성된 다른 타입을 받아들이도록 업데이트될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eSafeSQL = NewType(\"SafeSQL\", str)\r\ndef execute(self, sql: SafeSQL, parameters: Iterable[str] = ...) -\u003e Cursor: ...\r\nexecute(SafeSQL(\"SELECT * FROM data WHERE user_id = ?\"), user_id) # OK\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 사용자가 사용자 제어 문자열을 새로운 타입으로 강제 변환하여 전달하는 것을 막을 수 없습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003equery = f\"SELECT * FROM data WHERE user_id = f{user_id}\"\r\nexecute(SafeSQL(query)) # 오류 없음!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 Django의 \u003ccode\u003eSafeString\u003c/code\u003e과 \u003ccode\u003emark_safe\u003c/code\u003e가 CVE-2020-13596과 같은 문제를 발생시킨 사례에서도 볼 수 있습니다. 또한, \u003ccode\u003eNewType\u003c/code\u003e은 소스 코드에 침투적인 변경(쿼리를 \u003ccode\u003eSafeSQL\u003c/code\u003e로 래핑)을 요구하지만, \u003ccode\u003eLiteralString\u003c/code\u003e은 그러한 변경을 요구하지 않습니다.\u003c/p\u003e\n\u003ch3\u003eTrusted Types 에뮬레이션을 시도하지 않는 이유 (Why not try to emulate Trusted Types?)\u003c/h3\u003e\n\u003cp\u003eTrusted Types는 DOM 기반 XSS를 방지하기 위한 W3C 명세입니다. Python에 Trusted Types 개념을 도입하는 것을 고려할 수 있지만, 근본적인 차이점은 Trusted Types 새니타이저(sanitizer)의 출력은 일반적으로 실행 가능한 코드가 아니라는 점입니다. SQL 쿼리나 셸 명령어는 최종 결과가 여전히 실행 가능한 코드여야 하므로, 입력 문자열의 어느 부분이 안전하고 어느 부분이 악의적인지 안정적으로 파악하는 새니타이저를 작성할 방법이 없습니다.\u003c/p\u003e\n\u003ch3\u003e런타임 체크 가능한 \u003ccode\u003eLiteralString\u003c/code\u003e (Runtime Checkable LiteralString)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e 개념을 정적 타입 검사 이상으로 확장하여 \u003ccode\u003estr\u003c/code\u003e 객체의 런타임 체크 가능한 속성으로 만들 수도 있습니다. 이는 프레임워크가 동적 문자열에 대해 오류를 발생시키도록 허용하는 등의 이점을 제공할 수 있습니다. 그러나 이 확장은 Python의 가장 근본적인 타입 중 하나에 대한 변경을 요구하므로 제안의 범위를 극적으로 증가시킵니다.\u003c/p\u003e\n\u003ch3\u003e거부된 이름 (Rejected Names)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e 외에 \u003ccode\u003eLiteral[str]\u003c/code\u003e, \u003ccode\u003eLiteralStr\u003c/code\u003e, \u003ccode\u003eLiteralDerivedString\u003c/code\u003e, \u003ccode\u003eStringLiteral\u003c/code\u003e, \u003ccode\u003eSafeString\u003c/code\u003e, \u003ccode\u003eConstantStr\u003c/code\u003e, \u003ccode\u003eStaticStr\u003c/code\u003e, \u003ccode\u003eLiteralOnly[str]\u003c/code\u003e 등 다양한 이름이 고려되었지만, 각각의 문제점(혼동 가능성, 장황함, 오해의 소지 등)으로 인해 \u003ccode\u003eLiteralString\u003c/code\u003e이 선택되었습니다.\u003c/p\u003e\n\u003ch3\u003eLiteralBytes\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eLiteralBytes\u003c/code\u003e와 같이 리터럴 바이트 타입을 일반화하는 것도 가능하지만, \u003ccode\u003eLiteralString\u003c/code\u003e만큼 사용 빈도가 높지 않고 사용자 요구가 많지 않아 이 PEP에는 포함되지 않았습니다.\u003c/p\u003e\n\u003ch2\u003e참조 구현 (Reference Implementation)\u003c/h2\u003e\n\u003cp\u003ePyre v0.9.8에 구현되어 활발하게 사용 중입니다. 구현은 단순히 타입 체커를 확장하여 \u003ccode\u003eLiteralString\u003c/code\u003e을 리터럴 문자열 타입의 슈퍼타입으로 추가합니다. 덧셈, 조인 등을 통한 조합을 지원하기 위해 \u003ccode\u003etypeshed\u003c/code\u003e의 \u003ccode\u003estr\u003c/code\u003e 스텁을 오버로드하는 것으로 충분했습니다.\u003c/p\u003e\n\u003ch2\u003e부록 A: 다른 용례 (Other Uses)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e은 SQL 인젝션 외에도 다양한 종류의 인젝션 취약점을 방지하는 데 사용될 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e명령어 인젝션 (Command Injection)\u003c/strong\u003e : \u003ccode\u003esubprocess.run\u003c/code\u003e과 같은 API가 사용자 제어 데이터를 포함하는 셸 명령어를 실행할 때 발생할 수 있는 취약점을 방지합니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 수정된 stub (예시)\r\ndef run(command: LiteralString, *args: str, shell: bool=...): ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e크로스 사이트 스크립팅 (XSS)\u003c/strong\u003e : Django의 \u003ccode\u003emark_safe\u003c/code\u003e나 Jinja2의 \u003ccode\u003edo_mark_safe\u003c/code\u003e와 같이 자동 이스케이핑을 우회하는 함수가 사용자 입력으로 XSS 취약점을 유발할 수 있는 것을 방지합니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 수정된 stub (예시)\r\ndef mark_safe(s: LiteralString) -\u003e str: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e서버 사이드 템플릿 인젝션 (SSTI)\u003c/strong\u003e : Jinja와 같은 템플릿 프레임워크에서 공격자가 템플릿 문자열을 제어하여 임의 코드를 실행할 수 있는 취약점을 방지합니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 수정된 stub (예시)\r\nclass Template:\r\n    def __init__(self, source: LiteralString): ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e로깅 포맷 문자열 인젝션 (Logging Format String Injection)\u003c/strong\u003e : 로깅 프레임워크가 입력 문자열에 포매팅 지시어를 허용할 때, 외부에서 제어되는 로깅 문자열로 인해 서비스 거부(DoS) 공격이 발생할 수 있는 것을 방지합니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 수정된 stub (예시)\r\ndef info(msg: LiteralString, *args: object) -\u003e None: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e부록 B: 한계 (Limitations)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e이 사용자가 리터럴이 아닌 데이터로 구성된 문자열을 API에 전달하는 것을 막지 못할 수 있는 몇 가지 방법이 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e개발자가 타입 체커를 사용하지 않거나 타입 어노테이션을 추가하지 않는 경우, 위반 사항이 감지되지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecast(LiteralString, non_literal_string)\u003c/code\u003e를 사용하여 타입 체커를 속이고 동적 문자열 값을 \u003ccode\u003eLiteralString\u003c/code\u003e인 것처럼 위장할 수 있습니다. \u003ccode\u003eAny\u003c/code\u003e 타입의 변수도 마찬가지입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e# type: ignore\u003c/code\u003e와 같은 주석을 사용하여 비-리터럴 문자열에 대한 경고를 무시할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estr\u003c/code\u003e을 \u003ccode\u003eLiteralString\u003c/code\u003e으로 변환하는 사소한 함수를 구성할 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이러한 한계는 린팅, 코드 리뷰 등을 통해 완화될 수 있지만, 궁극적으로 \u003ccode\u003eLiteralString\u003c/code\u003e이 제공하는 보호 기능을 우회하려는 악의적인 개발자는 항상 성공할 것입니다. \u003ccode\u003eLiteralString\u003c/code\u003e은 악의적인 개발자로부터 보호하기 위한 것이 아니라, 선량한 개발자가 민감한 API를 우발적으로 위험하게 사용하는 것을 방지하기 위한 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e이 없으면 API 작성자가 가질 수 있는 최선의 강제 도구는 문서뿐이며, 이는 쉽게 무시되고 종종 보이지 않습니다. \u003ccode\u003eLiteralString\u003c/code\u003e을 사용하면 API 오용은 의식적인 사고와 코드 내에서 검토자와 미래 개발자가 알아챌 수 있는 아티팩트를 요구합니다.\u003c/p\u003e\n\u003ch2\u003e부록 C: \u003ccode\u003eLiteralString\u003c/code\u003e을 보존하는 \u003ccode\u003estr\u003c/code\u003e 메서드 (\u003ccode\u003estr\u003c/code\u003e methods that preserve LiteralString)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estr\u003c/code\u003e 클래스에는 \u003ccode\u003eLiteralString\u003c/code\u003e 타입이 이점을 얻을 수 있는 여러 메서드가 있습니다. 예를 들어, \u003ccode\u003e\"hello\".capitalize()\u003c/code\u003e는 \u003ccode\u003eLiteralString\u003c/code\u003e과 호환되는 \u003ccode\u003eLiteral[\"Hello\"]\u003c/code\u003e 타입으로 추론되어야 합니다. 즉, \u003ccode\u003ecapitalize\u003c/code\u003e 메서드는 \u003ccode\u003eLiteralString\u003c/code\u003e 타입을 보존합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etypeshed\u003c/code\u003e의 \u003ccode\u003estr\u003c/code\u003e 스텁을 업데이트하여 \u003ccode\u003eLiteralString\u003c/code\u003e을 보존하는 버전으로 메서드를 오버로드할 것을 제안합니다. 이렇게 하면 타입 체커가 각 메서드에 대해 \u003ccode\u003eLiteralString\u003c/code\u003e 동작을 하드코딩할 필요가 없으며, 향후 새로운 메서드도 쉽게 지원할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003ecapitalize\u003c/code\u003e 메서드에 대한 스텁은 다음과 같이 변경됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 변경 전\r\ndef capitalize(self) -\u003e str: ...\r\n# 변경 후\r\n@overload\r\ndef capitalize(self: LiteralString) -\u003e LiteralString: ...\r\n@overload\r\ndef capitalize(self) -\u003e str: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e단점은 스텁이 더 복잡해지고 에러 메시지가 이해하기 어려워질 수 있다는 점입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eLiteralString\u003c/code\u003e을 반환하는 것으로 처리되어야 하는 \u003ccode\u003estr\u003c/code\u003e 메서드의 목록 (모든 인수가 \u003ccode\u003eLiteralString\u003c/code\u003e 타입일 때)은 PEP 원문에 상세히 나열되어 있습니다. (예: \u003ccode\u003ecasefold\u003c/code\u003e, \u003ccode\u003ecenter\u003c/code\u003e, \u003ccode\u003ejoin\u003c/code\u003e, \u003ccode\u003elower\u003c/code\u003e, \u003ccode\u003ereplace\u003c/code\u003e, \u003ccode\u003esplit\u003c/code\u003e, \u003ccode\u003eupper\u003c/code\u003e, \u003ccode\u003e__add__\u003c/code\u003e, \u003ccode\u003e__mul__\u003c/code\u003e 등).\u003c/p\u003e\n\u003ch2\u003e부록 D: 스텁에서 \u003ccode\u003eLiteralString\u003c/code\u003e 사용 지침 (Guidelines for using LiteralString in Stubs)\u003c/h2\u003e\n\u003cp\u003eTypeshed의 타입 스텁 작성자는 \u003ccode\u003eLiteralString\u003c/code\u003e을 사용할 때 주의해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e순수 함수 (pure function)\u003c/strong\u003e 의 스텁인 경우, 모든 해당 매개변수가 리터럴 타입(\u003ccode\u003eLiteralString\u003c/code\u003e 또는 \u003ccode\u003eLiteral[\"a\", \"b\"]\u003c/code\u003e)을 가질 때만 함수의 반환 타입 또는 오버로드에 \u003ccode\u003eLiteralString\u003c/code\u003e을 사용하는 것을 권장합니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# OK\r\n@overload\r\ndef my_transform(x: LiteralString, y: Literal[\"a\", \"b\"]) -\u003e LiteralString: ...\r\n@overload\r\ndef my_transform(x: str, y: str) -\u003e str: ...\r\n\r\n# Not OK (x는 LiteralString이지만 y는 str이므로 반환 타입을 LiteralString으로 하면 안 됨)\r\n@overload\r\ndef my_transform(x: LiteralString, y: str) -\u003e LiteralString: ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003estaticmethod\u003c/code\u003e\u003c/strong\u003e 의 스텁인 경우 위와 동일한 지침을 권장합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e다른 종류의 메서드\u003c/strong\u003e 의 스텁인 경우, 메서드 또는 오버로드의 반환 타입에 \u003ccode\u003eLiteralString\u003c/code\u003e을 사용하지 않는 것을 권장합니다. 모든 명시적 매개변수가 \u003ccode\u003eLiteralString\u003c/code\u003e 타입이더라도 객체 자체가 사용자 데이터로 생성될 수 있기 때문입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e클래스 속성 또는 전역 변수\u003c/strong\u003e 의 스텁인 경우에도 \u003ccode\u003eLiteralString\u003c/code\u003e 사용을 권장하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그러나 최종 결정은 라이브러리 작성자에게 달려 있습니다. 메서드나 함수가 반환하는 문자열 또는 속성에 저장된 문자열이 리터럴 타입임을 확신할 수 있는 경우(즉, 문자열 리터럴에 리터럴을 보존하는 \u003ccode\u003estr\u003c/code\u003e 연산만 적용하여 생성된 경우) \u003ccode\u003eLiteralString\u003c/code\u003e을 사용할 수 있습니다. 이 지침은 타입 체커가 타입을 확인할 수 있는 인라인 타입 어노테이션에는 적용되지 않습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2082,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 675 - Arbitrary Literal String Type\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 10:08:22+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/674/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Deferred] PEP 674 - Disallow using macros as l-values\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 675 - Arbitrary Literal String Type\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/676/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Active] PEP 676 - PEP Infrastructure Process\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>