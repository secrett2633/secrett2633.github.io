<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/773b243a13a00265.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-61c2b369a48bb953.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/app/layout-c3297246cbd80ae3.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-7dac10d45f5cfdfc.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2224<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Active] PEP 287 - reStructuredText Docstring Format</h1><div class="page__meta"><time dateTime="2025-09-26 17:59:15+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0287/">PEP 287 - reStructuredText Docstring Format</a></p>
<p><strong>상태:</strong> Active | <strong>유형:</strong> Informational | <strong>작성일:</strong> 25-Mar-2002</p>
</blockquote>
<h1>PEP 287 – reStructuredText Docstring Format</h1>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 Python docstring, PEPs 및 관련 문서에서 구조화된 일반 텍스트 문서를 위한 표준 마크업 형식으로 <code>reStructuredText</code> 마크업을 채택할 것을 제안합니다. <code>reStructuredText</code>는 풍부하고 확장 가능하면서도 읽기 쉬운 WYSIWYG(What-You-See-Is-What-You-Get) 일반 텍스트 마크업 문법입니다.</p>
<p>이 PEP는 docstring의 저수준(low-level) 문법만을 다루며, docstring의 의미론(semantics)이나 처리에 대해서는 다루지 않습니다 (관련 내용은 PEP 256을 참조하십시오). 순수 일반 텍스트(plaintext) docstring의 사용을 비난하려는 시도가 아니며, 이는 항상 유효합니다. <code>reStructuredText</code> 마크업은 더 표현력 있는 docstring을 원하는 개발자들을 위한 대안입니다.</p>
<h2>장점 (Benefits)</h2>
<p>개발자는 본질적으로 게으른 종족입니다. 우리는 함수, 클래스, 모듈 및 서브시스템을 통해 코드를 재사용합니다. Python은 docstring 문법을 통해 코드 내부에서 문서를 작성할 수 있도록 합니다. Python Documentation Special Interest Group (Doc-SIG)의 "성배(holy grail)"는 Python 시스템의 docstring이 컨텍스트 내에서 추출되어 여러 목적에 유용한 고품질 문서로 처리될 수 있도록 하는 마크업 문법 및 도구 세트였습니다.</p>
<p>문서 마크업 언어에는 세 가지 고객 그룹이 있습니다: 문서를 작성하는 저자, 데이터를 처리하는 소프트웨어 시스템, 그리고 최종 소비자이자 가장 중요한 그룹인 독자입니다. 대부분의 마크업은 저자와 소프트웨어 시스템을 위해 설계되었으며, 독자는 처리된 형태(종이나 브라우저를 통해)만을 보게 됩니다. <code>reStructuredText</code>는 다릅니다: 마크업에 대한 사전 지식 없이도 소스 형태로 쉽게 읽을 수 있도록 의도되었습니다. <code>reStructuredText</code>는 일반 텍스트 형식으로 완전히 읽을 수 있으며, 많은 마크업 형태가 일반적인 사용법과 일치하므로(*예: <em>강조</em>), 매우 자연스럽게 읽힙니다. 그러면서도 복잡한 문서를 생성하기에 충분히 풍부하고, 확장 가능하여 거의 제한이 없습니다. 물론 <code>reStructuredText</code> 문서를 작성하려면 약간의 사전 지식이 필요합니다.</p>
<p>이 마크업은 소스 텍스트에서 쉬운 가독성을 유지하면서 기능성과 표현력을 제공합니다. 처리된 형태(HTML 등)는 독자들에게 모든 것을 접근 가능하게 만듭니다: 인라인 라이브 하이퍼링크, 각주로의 라이브 링크 및 각주로부터의 링크, 자동 목차(라이브 링크 포함!), 테이블, 다이어그램 등을 위한 이미지, 쾌적하고 읽기 쉬운 스타일이 적용된 텍스트.</p>
<p><code>reStructuredText</code> 파서는 현재 Docutils 프로젝트의 일부로 사용할 수 있습니다. 독립 실행형 <code>reStructuredText</code> 문서와 PEP는 HTML로 변환할 수 있으며, 다른 출력 형식 라이터(writer)는 개발 중이며 시간이 지남에 따라 제공될 것입니다. docstring에서 자동 문서를 구현할 Python 소스 "Reader"에 대한 작업이 진행 중입니다. 기존 자동 문서화 도구의 저자들은 <code>reStructuredText</code> 파서를 프로젝트에 통합하거나, 더 나아가 Python 표준 라이브러리를 위한 세계적 수준의 도구 세트를 만들기 위해 협력할 것을 권장합니다.</p>
<p>가까운 미래에 개발자들이 기존 docstring에서 온라인 도움말을 위한 HTML, 여러 목적을 위한 XML, 그리고 궁극적으로 인쇄 문서를 위한 PDF, DocBook, LaTeX를 "거의 무료로" 생성할 수 있도록 하는 도구들이 제공될 것입니다. 표준의 채택은 적어도 docstring 처리 도구들이 더 이상의 "바퀴의 재발명(reinventing the wheel)"을 막음으로써 이점을 얻게 할 것입니다.</p>
<p>궁극적으로 유일한 기존 표준 자동 문서화 도구인 PyDoc은 <code>reStructuredText</code> 지원을 추가할 수 있을 것입니다. 그동안은 모든 docstring을 미리 포맷된 일반 텍스트로 처리하기 때문에 <code>reStructuredText</code> 마크업에 문제가 없을 것입니다.</p>
<h2>목표 (Goals)</h2>
<p>Doc-SIG에서 논의된 바와 같이, docstring 형식에 대한 일반적으로 받아들여지는 목표는 다음과 같습니다:</p>
<ul>
<li>일반 사용자가 소스 형태로 읽을 수 있어야 합니다.</li>
<li>어떤 표준 텍스트 편집기로도 쉽게 입력할 수 있어야 합니다.</li>
<li>모듈 파싱을 통해 추론할 수 있는 정보를 포함할 필요가 없어야 합니다.</li>
<li>합리적인 마크업 형식으로 변환될 수 있도록 충분한 정보(구조)를 포함해야 합니다.</li>
<li>마크업 언어에 방해받는다는 느낌 없이 모듈의 전체 문서를 docstring에 작성할 수 있어야 합니다.</li>
</ul>
<p><code>reStructuredText</code>는 이 모든 목표를 충족하고 능가하며, 더욱 엄격한 자체 목표를 설정합니다. 자세한 내용은 아래 "Docstring-Significant Features"를 참조하십시오.</p>
<p>이 PEP의 목표는 다음과 같습니다:</p>
<ul>
<li>docstring (Python 모듈 및 패키지의 인라인 문서), PEPs, README-유형 파일 및 기타 독립 실행형 문서를 위한 표준 구조화된 일반 텍스트 형식으로 <code>reStructuredText</code>를 확립하는 것입니다. "승인됨(Accepted)" 상태는 Python 커뮤니티의 합의와 궁극적인 BDFL(Benevolent Dictator For Life) 선언을 통해 추구될 것입니다.
<ul>
<li><code>reStructuredText</code>는 표준으로 제안되지만, 유일한 표준은 아닙니다. 그 사용은 전적으로 선택 사항입니다. 사용하고 싶지 않은 사람은 사용할 필요가 없습니다.</li>
</ul>
</li>
<li>Python 커뮤니티에서 제기된 관련 우려 사항을 요청하고 해결하는 것입니다.</li>
<li>커뮤니티 지원을 장려하는 것입니다. 여러 경쟁 마크업이 존재하는 한 개발 커뮤니티는 분열되어 있습니다. 일단 표준이 존재하면 사람들은 그것을 사용하기 시작할 것이고, 추진력은 필연적으로 모일 것입니다.</li>
<li>관련 자동 문서화 프로젝트의 노력을 통합하는 것입니다. 관심 있는 개발자들이 힘을 합쳐 공동/병합/공통 구현을 작업하기를 희망합니다.</li>
</ul>
<p><code>reStructuredText</code>가 Python 표준이 되면, 표준에 대해 논쟁하는 대신 도구에 노력을 집중할 수 있습니다. Python은 표준화된 문서 도구 세트가 필요합니다.</p>
<p>PEPs와 관련하여 다음 전략 중 하나 또는 둘 다 적용될 수 있습니다:</p>
<ul>
<li>기존 PEP 섹션 구조 구성(한 줄 섹션 헤더, 들여쓰기된 본문 텍스트)을 유지합니다. 하위 섹션은 금지되거나, 들여쓰기된 본문 텍스트에 <code>reStructuredText</code> 스타일의 밑줄 헤더로 지원될 수 있습니다.</li>
<li>PEP 섹션 구조 구성을 <code>reStructuredText</code> 문법으로 대체합니다. 섹션 헤더는 밑줄을 필요로 하며, 하위 섹션은 즉시 지원되고, 본문 텍스트는 들여쓰기할 필요가 없습니다 (블록 인용문 제외).</li>
</ul>
<p>전략 (b)가 권장되며, 그 구현은 완료되었습니다.</p>
<p>RFC 2822 헤더 지원은 PEPs를 위한 <code>reStructuredText</code> 파서에 추가되었습니다 (특정 컨텍스트, 즉 문서의 첫 번째 연속 블록이 주어졌을 때 명확함). 균일성을 위해 PEP 섹션 헤더에 허용되는 오버라인/밑줄 스타일을 구체적으로 지정하는 것이 바람직할 수 있습니다.</p>
<h2>배경 (Rationale)</h2>
<p>docstring에 대한 표준 문법의 부재는 docstring을 표준 형식(예: HTML, DocBook, TeX)의 문서로 추출하고 변환하는 표준 도구의 개발을 방해했습니다. 여러 제안된 마크업 형식과 변형, 그리고 이러한 제안에 묶인 많은 도구들이 있었지만, 표준 docstring 형식이 없으면 강력한 지지를 얻지 못했거나 미완성으로 좌초되었습니다.</p>
<p>Doc-SIG의 존재 내내 단일 표준 docstring 형식에 대한 합의는 결코 이루어지지 않았습니다. 다음을 포함한 여러 이유로 경량의 암묵적 마크업이 추구되었습니다:</p>
<ul>
<li>Python 코드 내에 작성된 docstring은 대화형 인터프리터 내에서 사용할 수 있으며 "print"할 수 있습니다. 따라서 쉬운 가독성을 위해 일반 텍스트를 사용합니다.</li>
<li>개발자들은 원본 docstring의 가독성을 희생하지 않고 docstring에 구조를 추가하기를 원합니다.</li>
<li>꾸밈 없는 일반 텍스트는 유용한 구조화된 형식으로 변환("up-translated")될 수 없습니다.</li>
<li>명시적 마크업(XML 또는 TeX와 같은)은 익숙하지 않은 사람들에게는 일반적으로 읽기 어렵다고 간주됩니다.</li>
<li>암묵적 마크업은 깔끔하고 미니멀리스트적인 Python 문법과 미학적으로 호환됩니다.</li>
</ul>
<p>수년 동안 Doc-SIG에서 docstring을 위한 많은 대체 마크업이 제안되었습니다. 대표적인 예시가 아래에 나열되어 있습니다. 각 마크업은 위에 언급된 목표의 관점에서 간략하게 분석됩니다. 이것이 모든 기존 마크업 시스템의 배타적인 목록이 아니라는 점에 유의하십시오. (Texinfo, Doxygen, TIM, YODL, AFT 등) 언급되지 않은 많은 다른 마크업이 있습니다.</p>
<ul>
<li><strong>XML, SGML, DocBook, HTML, XHTML</strong> : XML 및 SGML은 모든 종류의 문서에 적합한 명시적이고 잘 정돈된 메타 언어입니다. XML은 SGML의 변형입니다. 이들은 훈련받지 않은 눈에는 장황하고, 입력하기 어려우며, 소스로서 편안하게 읽기에는 너무 복잡하기 때문에 주로 배후에서 사용됩니다. DocBook, HTML, XHTML은 모두 SGML 및/또는 XML의 응용 프로그램이며, 동일한 기본 문법과 동일한 단점을 공유합니다.</li>
<li><strong>TeX</strong> : TeX는 XML/SGML과 유사하게 명시적이지만, 작성하기 쉽지 않고, 익숙하지 않은 사람들에게는 읽기 어렵습니다.</li>
<li><strong>Perl POD</strong> : 대부분의 Perl 모듈은 POD(Plain Old Documentation)라는 형식으로 문서화됩니다. 이는 Perl 파서와 강력하게 통합된, 입력하기 쉽고 매우 낮은 수준의 형식입니다. POD 문서를 info, HTML, man 페이지 등 다른 형식으로 변환하는 많은 도구들이 존재합니다. 그러나 POD 문법은 가독성 면에서 Perl 자체를 따릅니다.</li>
<li><strong>JavaDoc</strong> : Java 클래스 및 함수 앞의 특별한 주석이 코드 문서를 작성하는 데 사용됩니다. 이를 추출하여 HTML 문서로 변환하는 프로그램은 javadoc이라고 불리며, 표준 Java 배포판의 일부입니다. 그러나 JavaDoc은 대부분의 마크업에 HTML 태그를 사용하여 HTML과 매우 밀접한 관계를 가지고 있습니다. 따라서 HTML의 가독성 문제를 공유합니다.</li>
<li><strong>Setext, StructuredText</strong> : 초기에 Setext(Structure Enhanced Text)의 변형들, Zope Corp의 StructuredText를 포함하여, Python docstring 형식 지정을 위해 제안되었습니다. 이후 이러한 변형들을 통칭하여 "STexts"라고 부를 것입니다. STexts는 특별한 지식 없이도 읽기 쉽고, 비교적 작성하기 쉽다는 장점이 있습니다.</li>
</ul>
<p>일부 사용자(대부분의 기존 Python 자동 문서화 도구 포함)에 의해 사용되었음에도 불구하고, 지금까지 STexts는 다음과 같은 이유로 표준이 되지 못했습니다:</p>
<ul>
<li>STexts는 불완전했습니다. 사람들이 docstring에서 사용하고 싶어하는 "필수적인" 구성이 부족하여 STexts는 이상적이지 못했습니다. 이러한 "필수적인" 구성은 보편적이지 않으며, 모든 사람이 자신의 요구 사항을 가지고 있다는 점에 유의하십시오.</li>
<li>STexts는 때때로 예상치 못했습니다. 텍스트 조각이 예상치 못하게 마크업된 것으로 해석되어 사용자에게 불만을 초래했습니다.</li>
<li>SText 구현은 버그가 많았습니다. 대부분의 STexts는 구현 자체를 제외하고는 공식적인 사양이 없었습니다. 버그 있는 구현은 버그 있는 사양을 의미했으며, 그 반대도 마찬가지였습니다.</li>
<li>마크업 문자가 비-마크업 컨텍스트에서 사용될 때 SText 마크업 규칙을 우회할 메커니즘이 없었습니다. 다시 말해, 마크업을 이스케이프할 방법이 없었습니다.</li>
</ul>
<p>암묵적 STexts의 지지자들은 명시적 마크업(XML, HTML, TeX, POD 등)에 대한 제안에 강력하게 반대했으며, 이 논쟁은 1996년 또는 그 이전부터 계속되었습니다.</p>
<p><code>reStructuredText</code>는 위에 나열된 모든 문제를 해결하면서 SText 아이디어를 완전히 수정하고 재해석한 것입니다.</p>
<h2>명세 (Specification)</h2>
<p><code>reStructuredText</code>의 명세와 사용자 문서는 매우 광범위합니다. 여기에서 모든 것을 반복하거나 요약하는 대신, 원본 문서에 대한 링크가 제공됩니다.</p>
<p>먼저 짧고 쉬운 입문서인 <a href="https://docutils.sourceforge.io/docs/user/rst/quickstart.html">A ReStructuredText Primer</a>를 살펴보십시오. <a href="https://docutils.sourceforge.io/docs/user/rst/quickref.html">Quick reStructuredText user reference</a>는 모든 마크업 구성을 빠르게 요약합니다. 완전하고 광범위한 세부 정보는 다음 문서를 참조하십시오:</p>
<ul>
<li><a href="https://docutils.sourceforge.io/docs/ref/rst/introduction.html">An Introduction to reStructuredText</a></li>
<li><a href="https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html">reStructuredText Markup Specification</a></li>
<li><a href="https://docutils.sourceforge.io/docs/ref/rst/directives.html">reStructuredText Directives</a></li>
</ul>
<p>또한, <a href="https://docutils.sourceforge.io/docs/ref/rst/structuredtext_problems.html">Problems With StructuredText</a>는 StructuredText와 관련하여 이루어진 많은 마크업 결정 사항을 설명하고, <a href="https://docutils.sourceforge.io/docs/ref/rst/alternatives.html">A Record of reStructuredText Syntax Alternatives</a>는 독립적으로 이루어진 마크업 결정 사항을 기록합니다.</p>
<h2>Docstring 관련 주요 기능 (Docstring-Significant Features)</h2>
<h3>마크업 이스케이프 메커니즘 (Markup escaping mechanism)</h3>
<p>백슬래시(<code>\</code>)는 마크업 문자가 비-마크업 목적으로 필요할 때 이스케이프하는 데 사용됩니다. 그러나 인라인 마크업 인식 규칙은 백슬래시 이스케이프가 필요한 경우를 최소화하도록 구성되었습니다. 예를 들어, 별표는 강조를 위해 사용되지만, <code>"*"</code> 또는 <code>"(*)"</code> 또는 <code>"x * y"</code>와 같은 비-마크업 컨텍스트에서는 별표가 마크업으로 해석되지 않고 그대로 유지됩니다. 백슬래시의 많은 비-마크업 사용(예: 정규 표현식 설명)의 경우, 인라인 리터럴 또는 리터럴 블록이 적용됩니다; 다음 항목을 참조하십시오.</p>
<h3>Python 소스 코드 및 Python 대화형 세션 포함 마크업: 인라인 리터럴, 리터럴 블록, doctest 블록 (Markup to include Python source code and Python interactive sessions: inline literals, literal blocks, and doctest blocks)</h3>
<ul>
<li>
<p><strong>인라인 리터럴(Inline literals)</strong> : 프로그램 I/O 또는 코드 스니펫을 나타내기 위해 이중 백쿼트(<code> </code>)를 사용합니다. 인라인 리터럴 내에서는 마크업 해석(백슬래시 이스케이프[ <code>\</code> ] 해석 포함)이 수행되지 않습니다.</p>
</li>
<li>
<p><strong>리터럴 블록(Literal blocks)</strong> : 코드 발췌문 또는 ASCII 그래픽과 같은 블록 수준의 리터럴 텍스트는 들여쓰기되며, 이전 단락 끝에 이중 콜론(<code>::</code>)으로 표시됩니다.</p>
<pre><code class="language-python">if literal_block:
    text = 'is left as-is'
    spaces_and_linebreaks = 'are preserved'
    markup_processing = None
</code></pre>
</li>
<li>
<p><strong>doctest 블록(Doctest blocks)</strong> : <code>>>> </code>로 시작하고 빈 줄로 끝납니다. 들여쓰기나 리터럴 블록의 이중 콜론은 필요하지 않습니다. 예를 들면 다음과 같습니다:</p>
<pre><code>Here's a doctest block:
>>> print 'Python-specific usage examples; begun with ">>>"'
Python-specific usage examples; begun with ">>>"
>>> print '(cut and pasted from interactive sessions)'
(cut and pasted from interactive sessions)
</code></pre>
</li>
</ul>
<h3>Python 식별자를 분리하는 마크업: 해석된 텍스트 (Markup that isolates a Python identifier: interpreted text)</h3>
<p>단일 백쿼트(<code>`</code>)로 묶인 텍스트는 "해석된 텍스트(interpreted text)"로 인식되며, 그 해석은 애플리케이션에 따라 다릅니다. Python docstring의 컨텍스트에서 해석된 텍스트의 기본 해석은 Python 식별자입니다. 텍스트는 주어진 식별자에 대한 문서에 연결된 하이퍼링크로 마크업됩니다. 조회 규칙은 Python 자체와 동일합니다: LGB 네임스페이스 조회(local, global, builtin). 해석된 텍스트의 "역할(role)"(클래스, 모듈, 함수 등을 식별하는)은 네임스페이스 조회를 통해 암묵적으로 결정됩니다. 예를 들면 다음과 같습니다:</p>
<pre><code class="language-python">class Keeper(Storer):
    """
    Keep data fresher longer. Extend `Storer`.
    Class attribute `instances` keeps track of the number of `Keeper` objects instantiated.
    """
    instances = 0
    """How many `Keeper` objects are there?"""
    def __init__(self):
        """
        Extend `Storer.__init__()` to keep track of instances.
        Keep count in `self.instances` and data in `self.data`.
        """
        Storer.__init__(self)
        self.instances += 1
        self.data = []
        """Store data in a list, most recent last."""
    def storedata(self, data):
        """
        Extend `Storer.storedata()`; append new `data` to a list (in `self.data`).
        """
        self.data = data
</code></pre>
<p>각 해석된 텍스트 조각은 해당 docstring을 포함하는 블록의 로컬 네임스페이스에 따라 조회됩니다.</p>
<h3>Python 식별자를 분리하고 그 유형을 지정하는 마크업: 역할이 있는 해석된 텍스트 (Markup that isolates a Python identifier and specifies its type: interpreted text with roles)</h3>
<p>Python 소스 컨텍스트 리더는 명시적 역할이 필요하지 않도록 설계되었지만, 역할을 사용할 수 있습니다. 식별자를 명시적으로 분류하기 위해 역할은 접두사 또는 접미사 형식으로 식별자와 함께 제공됩니다.</p>
<p><code>Use :method:</code>Keeper.storedata<code>to store the object's data in</code>Keeper.data<code>:instance_attribute:.</code></p>
<p>역할에 대해 선택된 문법은 장황하지만, 필연적으로 그렇습니다 (더 나은 대안이 있다면 Doc-SIG에 게시해 주십시오). 마크업의 의도는 명시적 역할을 사용할 필요가 거의 없어야 한다는 것입니다. 그 사용은 절대적인 최소한으로 유지되어야 합니다.</p>
<h3>"태그 목록" 또는 "레이블 목록"을 위한 마크업: 필드 목록 (Markup for “tagged lists” or “label lists”: field lists)</h3>
<p>필드 목록(Field lists)은 필드 이름에서 필드 본문으로의 매핑을 나타냅니다. 이는 주로 "서지 필드 목록"(저자, 날짜, 버전과 같은 문서 메타데이터를 나타냄) 및 지시문(directives)의 확장 속성(아래 참조)과 같은 확장 문법에 사용됩니다. 매개변수 식별, 발생 예외 등과 같은 방법론(docstring 의미론)을 구현하는 데 사용될 수 있습니다. 이러한 사용은 이 PEP의 범위를 벗어납니다.</p>
<p>수정된 RFC 2822 문법이 사용되며, 필드 이름 앞뒤에 콜론이 있습니다. 필드 본문도 더 다양합니다; 여러 필드 본문(심지어 중첩된 필드 목록)을 포함할 수 있습니다. 예를 들면 다음과 같습니다:</p>
<pre><code>:Date: 2002-03-22
:Version: 1
:Authors: - Me
          - Myself
          - I
</code></pre>
<p>표준 RFC 2822 헤더 문법은 모호하기 때문에 이 구성을 위해 사용될 수 없습니다. 한 줄 시작 부분에 콜론이 뒤따르는 단어는 일반적인 서면 텍스트에서 흔합니다.</p>
<h3>마크업 확장성: 지시문 및 대체 (Markup extensibility: directives and substitutions)</h3>
<p><strong>지시문(Directives)</strong> 은 <code>reStructuredText</code>의 확장 메커니즘으로 사용되며, 새로운 문법을 추가하지 않고 새로운 블록 수준 구성을 지원하는 방법입니다. 이미지, 경고(note, caution 등), 목차 생성(다른 것들 중)을 위한 지시문이 구현되었습니다. 예를 들어, 이미지를 배치하는 방법은 다음과 같습니다:</p>
<pre><code>.. image:: mylogo.png
</code></pre>
<p><strong>대체 정의(Substitution definitions)</strong> 는 인라인 텍스트로 블록 수준 지시문의 힘과 유연성을 공유할 수 있도록 합니다. 예를 들면 다음과 같습니다:</p>
<pre><code>The |biohazard| symbol must be used on containers used to dispose of medical waste.
.. |biohazard| image:: biohazard.png
</code></pre>
<h3>섹션 구조 마크업 (Section structure markup)</h3>
<p><code>reStructuredText</code>의 섹션 헤더는 들여쓰기가 아닌 밑줄(및 선택적으로 오버라인)을 통한 장식(adornment)을 사용합니다. 예를 들면 다음과 같습니다:</p>
<pre><code>This is a Section Title
=======================

This is a Subsection Title
--------------------------
This paragraph is in the subsection.

This is Another Section Title
=============================
This paragraph is in the second section.
</code></pre>
<h2>질문 및 답변 (Questions &#x26; Answers)</h2>
<h3><code>reStructuredText</code>는 충분히 풍부한가요? (Is reStructuredText rich enough?)</h3>
<p>네, 대부분의 사람들에게는 그렇습니다. 특정 애플리케이션에 필요한 구성이 부족하다면 지시문 메커니즘을 통해 추가할 수 있습니다. 유용하고 일반적인 구성이 간과되었고 적절하게 읽을 수 있는 문법을 찾을 수 있다면, 명세와 파서에 추가될 수 있습니다.</p>
<h3><code>reStructuredText</code>는 너무 풍부한가요? (Is reStructuredText too rich?)</h3>
<p>특정 애플리케이션이나 개인에게는 그럴 수도 있습니다. 일반적으로는 그렇지 않습니다.</p>
<p>docstring 마크업 문법이 Doc-SIG에 제안될 때마다, 누군가는 어떤 구성에 대한 지원 부족에 대해 불평했습니다. 답변은 종종 "우리가 말하는 것은 docstring이고, docstring은 복잡한 마크업을 가질 필요가 없습니다"와 같았습니다. 문제는 한 사람에게는 불필요해 보이는 구성이 다른 사람에게는 절대적으로 필수적일 수 있다는 것입니다.</p>
<p><code>reStructuredText</code>는 정반대의 접근 방식을 취합니다: 풍부한 암묵적 마크업 구성 세트(및 명시적 마크업을 위한 일반 확장 메커니즘)를 제공하여 모든 종류의 문서를 허용합니다. 구성 세트가 특정 애플리케이션에 너무 풍부하다면, 사용되지 않는 구성은 파서에서 제거(애플리케이션별 재정의를 통해)하거나 단순히 관례상 생략할 수 있습니다.</p>
<h3>StructuredText처럼 섹션 구조에 들여쓰기를 사용하지 않는 이유는 무엇인가요? 더 "Pythonic"하지 않나요? (Why not use indentation for section structure, like StructuredText does? Isn't it more “Pythonic”?)</h3>
<p>Guido van Rossum은 2001년 6월 13일 Doc-SIG 게시물에 다음과 같이 썼습니다:</p>
<blockquote>
<p>저는 여전히 섹션을 나타내기 위해 들여쓰기를 사용하는 것이 잘못되었다고 생각합니다. 실제 서적 및 기타 인쇄 출판물이 어떻게 배치되는지 살펴보면, 들여쓰기는 자주 사용되지만 주로 섹션 내 수준에서 사용된다는 것을 알 수 있습니다. 들여쓰기는 목록, 표, 인용문, 예제 등을 구분하는 데 사용될 수 있습니다. (docstring이 텍스트 포맷터의 입력이기 때문에 다르다는 주장은 잘못되었습니다: 핵심은 처리 없이도 읽을 수 있어야 한다는 것입니다).</p>
<p>저는 들여쓰기를 사용하는 것이 Pythonic하다는 주장을 거부합니다. 텍스트는 코드가 아니며, 다른 전통과 관습이 적용됩니다. 사람들은 30세기 이상 동안 가독성을 위해 텍스트를 제시해왔습니다. 불필요하게 혁신하지 맙시다.</p>
</blockquote>
<p>자세한 내용은 <a href="https://docutils.sourceforge.io/docs/ref/rst/structuredtext_problems.html">Problems With StructuredText</a>의 "Section Structure via Indentation"을 참조하십시오.</p>
<h3>PEPs에 <code>reStructuredText</code>를 사용하는 이유는 무엇인가요? 기존 표준의 문제점은 무엇인가요? (Why use reStructuredText for PEPs? What's wrong with the existing standard?)</h3>
<p>PEPs에 대한 기존 표준은 일반적인 표현력 측면에서 매우 제한적이며, 특히 참조가 풍부한 문서 유형에 대한 참조 기능이 부족합니다. PEPs는 현재 HTML로 변환되지만, 결과물(대부분 모노스페이스 텍스트)은 매력적이지 않으며, HTML의 부가가치 잠재력(특히 인라인 하이퍼링크)은 대부분 활용되지 않습니다.</p>
<p><code>reStructuredText</code>를 PEPs의 표준 마크업으로 만들면 섹션 구조, 인라인 마크업, 그래픽 및 테이블 지원을 포함하여 훨씬 더 풍부한 표현이 가능해집니다. 여러 PEPs에는 일반 텍스트 문서가 지원할 수 있는 모든 ASCII 그래픽 다이어그램이 있습니다. PEPs가 HTML 형태로 제공되므로, 적절한 다이어그램을 포함하는 기능은 즉시 유용할 것입니다.</p>
<p>현재 PEP 관행은 텍스트에 "[1]" 형식의 참조 마커를 허용하며, 각주/참조 자체는 문서 끝 부분의 섹션에 나열됩니다. 현재 참조 마커와 각주/참조 자체 사이에 하이퍼링크가 없습니다 (pep2html.py에 추가할 수 있지만, "마크업" 자체가 모호하여 실수가 불가피합니다). 많은 참조를 포함하는 PEP(이 PEP와 같은 ;-)는 앞뒤로 많이 넘겨봐야 합니다. PEP를 수정할 때 종종 새로운 참조가 추가되거나 사용되지 않는 참조가 삭제됩니다. 참조 번호를 다시 매기는 것은 두 곳에서 해야 하고 연쇄 효과를 가질 수 있으므로 고통스럽습니다 (새로운 참조 1을 하나 삽입하면 다른 모든 참조의 번호를 다시 매겨야 합니다; 항상 새로운 참조를 끝에 추가하는 것은 최적이 아닙니다). 참조가 동기화되지 않을 수 있습니다.</p>
<p>PEPs는 두 가지 목적으로 참조를 사용합니다: 간단한 URL 참조와 각주. <code>reStructuredText</code>는 이 둘을 구분합니다. PEP는 다음과 같은 참조를 포함할 수 있습니다:</p>
<pre><code>Abstract
This PEP proposes adding frungible doodads to the core. It extends PEP 9876 via the BCA mechanism.
...
References and Footnotes
 http://www.example.org/
 PEP 9876, Let's Hope We Never Get Here
    http://peps.python.org/pep-9876/
 "Bogus Complexity Addition"
</code></pre>
<p>참조 1은 간단한 URL 참조입니다. 참조 2는 텍스트와 URL을 포함하는 각주입니다. 참조 3은 텍스트만 포함하는 각주입니다. <code>reStructuredText</code>를 사용하여 다시 작성하면 이 PEP는 다음과 같이 보일 수 있습니다:</p>
<pre><code>Abstract
========
This PEP proposes adding `frungible doodads`_ to the core. It extends PEP 9876 [#pep9876]_ via the BCA [#]_ mechanism.
...
References &#x26; Footnotes
======================
.. _frungible doodads: http://www.example.org/
.. [#pep9876] PEP 9876, Let's Hope We Never Get Here
.. [#] "Bogus Complexity Addition"
</code></pre>
<p>URL과 각주는 원하는 경우 참조 가까이에 정의할 수 있어 소스 텍스트에서 읽기 쉬워지고 PEP를 수정하기 쉬워집니다. "References and Footnotes" 섹션은 문서 트리 변환(document tree transform)으로 자동 생성될 수 있습니다. PEP 전체의 각주는 표준 헤더 아래에 수집되어 표시됩니다. URL 참조도 명시적으로 작성되어야 하는 경우(인용 형식으로), 다른 트리 변환을 사용할 수 있습니다.</p>
<p>URL 참조는 이름 지정될 수 있으며("frungible doodads"), 추가 정의 없이 문서의 여러 위치에서 참조될 수 있습니다. HTML로 변환될 때 참조는 인라인 하이퍼링크(HTML <code>&#x3C;a></code> 태그)로 대체됩니다. 두 각주는 자동으로 번호가 매겨지므로 항상 동기화 상태를 유지합니다. 첫 번째 각주에는 내부 참조 이름 "pep9876"도 포함되어 있어 소스 텍스트에서 참조와 각주 사이의 연결을 더 쉽게 볼 수 있습니다. 이름 지정된 각주는 여러 번 참조될 수 있으며, 일관된 번호 매기기를 유지합니다.</p>
<p>"#pep9876" 각주는 인용 형식으로도 작성될 수 있습니다:</p>
<p><code>It extends PEP 9876 [PEP9876]_ ...</code>
<code>.. [PEP9876] PEP 9876, Let's Hope We Never Get Here</code></p>
<p>각주는 번호가 매겨지지만, 인용은 참조에 텍스트를 사용합니다.</p>
<h3>docstring 및 PEP 제안을 분리하는 것이 더 낫지 않을까요? (Wouldn't it be better to keep the docstring and PEP proposals separate?)</h3>
<p>PEP 마크업 제안은 PEP 마크업의 필요성이 없다고 판단되면 제거될 수 있거나, 별도의 PEP로 만들어질 수 있습니다. 승인된다면, PEP 1, PEP Purpose and Guidelines, 및 PEP 9, Sample PEP Template가 업데이트될 것입니다.</p>
<p>Python에서 구조화된 일반 텍스트의 모든 용도에 대해 단일의 일관된 마크업 표준을 채택하고, 이를 한곳에서 제안하는 것이 자연스러워 보입니다.</p>
<h3>기존 pep2html.py 스크립트는 기존 PEP 형식을 HTML로 변환합니다. 새 형식의 PEP는 어떻게 HTML로 변환될까요? (The existing pep2html.py script converts the existing PEP format to HTML. How will the new-format PEPs be converted to HTML?)</h3>
<p><code>reStructuredText</code> 파싱이 통합된 새 버전의 pep2html.py가 완성되었습니다. Docutils 프로젝트는 "PEP Reader" 구성 요소를 통해 PEPs를 지원하며, 현재 pep2html.py의 모든 기능(PEP 및 RFC 참조의 자동 인식, 이메일 마스킹 등)을 포함합니다.</p>
<h3>누가 기존 PEPs를 <code>reStructuredText</code>로 변환할까요? (Who's going to convert the existing PEPs to reStructuredText?)</h3>
<p>PEP 저자 또는 자원봉사자는 원하는 경우 기존 PEPs를 변환할 수 있지만, 그렇게 할 의무는 없습니다. <code>reStructuredText</code> 기반 PEPs는 기존 PEP 표준과 공존할 것입니다. 6번 질문 답변에서 언급된 pep2html.py는 기존 및 새 표준을 모두 처리합니다.</p>
<h3>README 및 기타 보조 파일에 <code>reStructuredText</code>를 사용하는 이유는 무엇인가요? (Why use reStructuredText for README and other ancillary files?)</h3>
<p>위 4번 질문 답변에서 PEPs에 대해 제시된 이유는 README 및 기타 보조 파일에도 적용됩니다. 표준 마크업을 채택함으로써 이러한 파일은 매력적인 상호 참조 HTML로 변환되어 python.org에 게시될 수 있습니다. 다른 프로젝트 개발자들도 이 기능을 자신의 문서에 활용할 수 있습니다.</p>
<h3>기존 마크업 규칙과의 피상적인 유사성이 문제를 일으키고, 사람들이 유효하지 않은 마크업을 작성(그리고 일반 텍스트가 자연스러워 보여서 눈치채지 못함)하게 만들지 않을까요? <code>reStructuredText</code>는 "완벽하지 않은" 마크업에 얼마나 관대한가요? (Won't the superficial similarity to existing markup conventions cause problems, and result in people writing invalid markup (and not noticing, because the plaintext looks natural)? How forgiving is reStructuredText of “not quite right” markup?)</h3>
<p>한 프로그래밍 언어에서 다른 프로그래밍 언어로 전환할 때와 마찬가지로 일부 실수가 있을 것입니다. 다른 언어와 마찬가지로 경험을 통해 숙련도가 향상됩니다. 다행히 <code>reStructuredText</code>는 매우 작은 언어입니다.</p>
<p>어떤 문법이든 문법 오류의 가능성은 있습니다. 사용자는 입력에 대해 처리 시스템을 실행하고 출력이 정확한지 확인할 것으로 예상됩니다.</p>
<p>엄격한 의미에서 <code>reStructuredText</code> 파서는 매우 관대하지 않습니다 (그래야 합니다; "모호함에 직면했을 때, 추측하려는 유혹을 거부하라"는 마크업 파싱뿐만 아니라 컴퓨터 언어에도 적용됩니다). <a href="https://docutils.sourceforge.io/docs/ref/rst/introduction.html">An Introduction to reStructuredText</a>의 설계 목표 3은 다음과 같습니다:</p>
<blockquote>
<p>명확해야 합니다. 마크업 규칙은 해석의 여지를 두어서는 안 됩니다. 어떤 주어진 입력에 대해 단 하나의 가능한 출력(오류 출력 포함)만 있어야 합니다.</p>
</blockquote>
<p>관대하지 않지만, 동시에 파서는 유용한 진단 출력("시스템 메시지")을 생성하여 도움을 주려고 노력합니다. 파서는 문제의 심각도 수준(가장 낮은 것부터 높은 것까지: debug, info, warning, error, severe)을 나타내어 보고합니다. 사용자 또는 클라이언트 소프트웨어는 보고 임계값을 결정할 수 있습니다; 저수준 문제는 무시하거나 고수준 문제가 즉시 처리를 중단시키도록 할 수 있습니다. 문제는 파싱 중에도 보고되며 출력에도 포함되는데, 종종 문제의 원본과 이를 설명하는 시스템 메시지 사이에 양방향 링크가 있습니다.</p>
<h3>Python 표준 라이브러리 모듈의 docstring은 <code>reStructuredText</code>로 변환될까요? (Will the docstrings in the Python standard library modules be converted to reStructuredText?)</h3>
<p>아니요. Python의 라이브러리 참조 문서는 소스와 별도로 관리됩니다. Python 표준 라이브러리의 docstring은 라이브러리 참조 문서를 복제하려고 시도해서는 안 됩니다. Python 표준 라이브러리의 docstring에 대한 현재 정책은 간결한 힌트, 간단하고 마크업이 없는 것이어야 한다는 것입니다 (비록 많은 경우 임시적인 암묵적 마크업을 포함하고 있지만).</p>
<h3>모든 문자열을 유니코드로 작성하고 싶습니다. 문제가 생길까요? (I want to write all my strings in Unicode. Will anything break?)</h3>
<p>파서는 유니코드를 완전히 지원합니다. Docutils는 임의의 입력 및 출력 인코딩을 지원합니다.</p>
<h3>커뮤니티에 새로운 구조화된 텍스트 디자인이 필요한 이유는 무엇인가요? (Why does the community need a new structured text design?)</h3>
<p>기존의 구조화된 텍스트 디자인은 위 "배경"에서 제시된 이유들로 인해 결함이 있습니다. <code>reStructuredText</code>는 "읽을 수 있는 일반 텍스트" 매체의 한계 내에서 완전한 마크업 문법이 되는 것을 목표로 합니다.</p>
<h3>기존 문서화 방법론에 문제가 있나요? (What is wrong with existing documentation methodologies?)</h3>
<p>어떤 기존 방법론을 말씀하시나요? Python docstring의 경우, JavaDoc과 같은 문서화 방법론은 고사하고 공식적인 표준 마크업 형식도 없습니다. 방법론 문제는 문법(이 PEP가 다루는)보다 훨씬 높은 수준의 문제입니다. 이는 잠재적으로 훨씬 더 논란의 여지가 있고 해결하기 어려우므로, 이 논의에서 의도적으로 제외되었습니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<h2>감사의 말 (Acknowledgements)</h2>
<p>일부 텍스트는 Moshe Zadka의 PEP 216, Docstring Format에서 차용되었습니다.</p>
<p>Python Doc-SIG의 모든 과거 및 현재 회원들에게 특별히 감사드립니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/286/">[Deferred] PEP 286 - Enhanced Argument Tuples</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Active] PEP 287 - reStructuredText Docstring Format</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/288/">[Withdrawn] PEP 288 - Generators Attributes and Exceptions</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-61c2b369a48bb953.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/773b243a13a00265.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"185\",\"static/chunks/app/layout-c3297246cbd80ae3.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-7dac10d45f5cfdfc.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/287\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/773b243a13a00265.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"QRk123GkENE0bgAxJMWB7\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/287/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/287\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"287\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/287\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"e:I[646,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-7dac10d45f5cfdfc.js\"],\"default\"]\nd:T9485,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0287/\"\u003ePEP 287 - reStructuredText Docstring Format\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Active | \u003cstrong\u003e유형:\u003c/strong\u003e Informational | \u003cstrong\u003e작성일:\u003c/strong\u003e 25-Mar-2002\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 287 – reStructuredText Docstring Format\u003c/h1\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 Python docstring, PEPs 및 관련 문서에서 구조화된 일반 텍스트 문서를 위한 표준 마크업 형식으로 \u003ccode\u003ereStructuredText\u003c/code\u003e 마크업을 채택할 것을 제안합니다. \u003ccode\u003ereStructuredText\u003c/code\u003e는 풍부하고 확장 가능하면서도 읽기 쉬운 WYSIWYG(What-You-See-Is-What-You-Get) 일반 텍스트 마크업 문법입니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 docstring의 저수준(low-level) 문법만을 다루며, docstring의 의미론(semantics)이나 처리에 대해서는 다루지 않습니다 (관련 내용은 PEP 256을 참조하십시오). 순수 일반 텍스트(plaintext) docstring의 사용을 비난하려는 시도가 아니며, 이는 항상 유효합니다. \u003ccode\u003ereStructuredText\u003c/code\u003e 마크업은 더 표현력 있는 docstring을 원하는 개발자들을 위한 대안입니다.\u003c/p\u003e\n\u003ch2\u003e장점 (Benefits)\u003c/h2\u003e\n\u003cp\u003e개발자는 본질적으로 게으른 종족입니다. 우리는 함수, 클래스, 모듈 및 서브시스템을 통해 코드를 재사용합니다. Python은 docstring 문법을 통해 코드 내부에서 문서를 작성할 수 있도록 합니다. Python Documentation Special Interest Group (Doc-SIG)의 \"성배(holy grail)\"는 Python 시스템의 docstring이 컨텍스트 내에서 추출되어 여러 목적에 유용한 고품질 문서로 처리될 수 있도록 하는 마크업 문법 및 도구 세트였습니다.\u003c/p\u003e\n\u003cp\u003e문서 마크업 언어에는 세 가지 고객 그룹이 있습니다: 문서를 작성하는 저자, 데이터를 처리하는 소프트웨어 시스템, 그리고 최종 소비자이자 가장 중요한 그룹인 독자입니다. 대부분의 마크업은 저자와 소프트웨어 시스템을 위해 설계되었으며, 독자는 처리된 형태(종이나 브라우저를 통해)만을 보게 됩니다. \u003ccode\u003ereStructuredText\u003c/code\u003e는 다릅니다: 마크업에 대한 사전 지식 없이도 소스 형태로 쉽게 읽을 수 있도록 의도되었습니다. \u003ccode\u003ereStructuredText\u003c/code\u003e는 일반 텍스트 형식으로 완전히 읽을 수 있으며, 많은 마크업 형태가 일반적인 사용법과 일치하므로(*예: \u003cem\u003e강조\u003c/em\u003e), 매우 자연스럽게 읽힙니다. 그러면서도 복잡한 문서를 생성하기에 충분히 풍부하고, 확장 가능하여 거의 제한이 없습니다. 물론 \u003ccode\u003ereStructuredText\u003c/code\u003e 문서를 작성하려면 약간의 사전 지식이 필요합니다.\u003c/p\u003e\n\u003cp\u003e이 마크업은 소스 텍스트에서 쉬운 가독성을 유지하면서 기능성과 표현력을 제공합니다. 처리된 형태(HTML 등)는 독자들에게 모든 것을 접근 가능하게 만듭니다: 인라인 라이브 하이퍼링크, 각주로의 라이브 링크 및 각주로부터의 링크, 자동 목차(라이브 링크 포함!), 테이블, 다이어그램 등을 위한 이미지, 쾌적하고 읽기 쉬운 스타일이 적용된 텍스트.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e 파서는 현재 Docutils 프로젝트의 일부로 사용할 수 있습니다. 독립 실행형 \u003ccode\u003ereStructuredText\u003c/code\u003e 문서와 PEP는 HTML로 변환할 수 있으며, 다른 출력 형식 라이터(writer)는 개발 중이며 시간이 지남에 따라 제공될 것입니다. docstring에서 자동 문서를 구현할 Python 소스 \"Reader\"에 대한 작업이 진행 중입니다. 기존 자동 문서화 도구의 저자들은 \u003ccode\u003ereStructuredText\u003c/code\u003e 파서를 프로젝트에 통합하거나, 더 나아가 Python 표준 라이브러리를 위한 세계적 수준의 도구 세트를 만들기 위해 협력할 것을 권장합니다.\u003c/p\u003e\n\u003cp\u003e가까운 미래에 개발자들이 기존 docstring에서 온라인 도움말을 위한 HTML, 여러 목적을 위한 XML, 그리고 궁극적으로 인쇄 문서를 위한 PDF, DocBook, LaTeX를 \"거의 무료로\" 생성할 수 있도록 하는 도구들이 제공될 것입니다. 표준의 채택은 적어도 docstring 처리 도구들이 더 이상의 \"바퀴의 재발명(reinventing the wheel)\"을 막음으로써 이점을 얻게 할 것입니다.\u003c/p\u003e\n\u003cp\u003e궁극적으로 유일한 기존 표준 자동 문서화 도구인 PyDoc은 \u003ccode\u003ereStructuredText\u003c/code\u003e 지원을 추가할 수 있을 것입니다. 그동안은 모든 docstring을 미리 포맷된 일반 텍스트로 처리하기 때문에 \u003ccode\u003ereStructuredText\u003c/code\u003e 마크업에 문제가 없을 것입니다.\u003c/p\u003e\n\u003ch2\u003e목표 (Goals)\u003c/h2\u003e\n\u003cp\u003eDoc-SIG에서 논의된 바와 같이, docstring 형식에 대한 일반적으로 받아들여지는 목표는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일반 사용자가 소스 형태로 읽을 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e어떤 표준 텍스트 편집기로도 쉽게 입력할 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e모듈 파싱을 통해 추론할 수 있는 정보를 포함할 필요가 없어야 합니다.\u003c/li\u003e\n\u003cli\u003e합리적인 마크업 형식으로 변환될 수 있도록 충분한 정보(구조)를 포함해야 합니다.\u003c/li\u003e\n\u003cli\u003e마크업 언어에 방해받는다는 느낌 없이 모듈의 전체 문서를 docstring에 작성할 수 있어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e는 이 모든 목표를 충족하고 능가하며, 더욱 엄격한 자체 목표를 설정합니다. 자세한 내용은 아래 \"Docstring-Significant Features\"를 참조하십시오.\u003c/p\u003e\n\u003cp\u003e이 PEP의 목표는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edocstring (Python 모듈 및 패키지의 인라인 문서), PEPs, README-유형 파일 및 기타 독립 실행형 문서를 위한 표준 구조화된 일반 텍스트 형식으로 \u003ccode\u003ereStructuredText\u003c/code\u003e를 확립하는 것입니다. \"승인됨(Accepted)\" 상태는 Python 커뮤니티의 합의와 궁극적인 BDFL(Benevolent Dictator For Life) 선언을 통해 추구될 것입니다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e는 표준으로 제안되지만, 유일한 표준은 아닙니다. 그 사용은 전적으로 선택 사항입니다. 사용하고 싶지 않은 사람은 사용할 필요가 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ePython 커뮤니티에서 제기된 관련 우려 사항을 요청하고 해결하는 것입니다.\u003c/li\u003e\n\u003cli\u003e커뮤니티 지원을 장려하는 것입니다. 여러 경쟁 마크업이 존재하는 한 개발 커뮤니티는 분열되어 있습니다. 일단 표준이 존재하면 사람들은 그것을 사용하기 시작할 것이고, 추진력은 필연적으로 모일 것입니다.\u003c/li\u003e\n\u003cli\u003e관련 자동 문서화 프로젝트의 노력을 통합하는 것입니다. 관심 있는 개발자들이 힘을 합쳐 공동/병합/공통 구현을 작업하기를 희망합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e가 Python 표준이 되면, 표준에 대해 논쟁하는 대신 도구에 노력을 집중할 수 있습니다. Python은 표준화된 문서 도구 세트가 필요합니다.\u003c/p\u003e\n\u003cp\u003ePEPs와 관련하여 다음 전략 중 하나 또는 둘 다 적용될 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기존 PEP 섹션 구조 구성(한 줄 섹션 헤더, 들여쓰기된 본문 텍스트)을 유지합니다. 하위 섹션은 금지되거나, 들여쓰기된 본문 텍스트에 \u003ccode\u003ereStructuredText\u003c/code\u003e 스타일의 밑줄 헤더로 지원될 수 있습니다.\u003c/li\u003e\n\u003cli\u003ePEP 섹션 구조 구성을 \u003ccode\u003ereStructuredText\u003c/code\u003e 문법으로 대체합니다. 섹션 헤더는 밑줄을 필요로 하며, 하위 섹션은 즉시 지원되고, 본문 텍스트는 들여쓰기할 필요가 없습니다 (블록 인용문 제외).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e전략 (b)가 권장되며, 그 구현은 완료되었습니다.\u003c/p\u003e\n\u003cp\u003eRFC 2822 헤더 지원은 PEPs를 위한 \u003ccode\u003ereStructuredText\u003c/code\u003e 파서에 추가되었습니다 (특정 컨텍스트, 즉 문서의 첫 번째 연속 블록이 주어졌을 때 명확함). 균일성을 위해 PEP 섹션 헤더에 허용되는 오버라인/밑줄 스타일을 구체적으로 지정하는 것이 바람직할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003edocstring에 대한 표준 문법의 부재는 docstring을 표준 형식(예: HTML, DocBook, TeX)의 문서로 추출하고 변환하는 표준 도구의 개발을 방해했습니다. 여러 제안된 마크업 형식과 변형, 그리고 이러한 제안에 묶인 많은 도구들이 있었지만, 표준 docstring 형식이 없으면 강력한 지지를 얻지 못했거나 미완성으로 좌초되었습니다.\u003c/p\u003e\n\u003cp\u003eDoc-SIG의 존재 내내 단일 표준 docstring 형식에 대한 합의는 결코 이루어지지 않았습니다. 다음을 포함한 여러 이유로 경량의 암묵적 마크업이 추구되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePython 코드 내에 작성된 docstring은 대화형 인터프리터 내에서 사용할 수 있으며 \"print\"할 수 있습니다. 따라서 쉬운 가독성을 위해 일반 텍스트를 사용합니다.\u003c/li\u003e\n\u003cli\u003e개발자들은 원본 docstring의 가독성을 희생하지 않고 docstring에 구조를 추가하기를 원합니다.\u003c/li\u003e\n\u003cli\u003e꾸밈 없는 일반 텍스트는 유용한 구조화된 형식으로 변환(\"up-translated\")될 수 없습니다.\u003c/li\u003e\n\u003cli\u003e명시적 마크업(XML 또는 TeX와 같은)은 익숙하지 않은 사람들에게는 일반적으로 읽기 어렵다고 간주됩니다.\u003c/li\u003e\n\u003cli\u003e암묵적 마크업은 깔끔하고 미니멀리스트적인 Python 문법과 미학적으로 호환됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e수년 동안 Doc-SIG에서 docstring을 위한 많은 대체 마크업이 제안되었습니다. 대표적인 예시가 아래에 나열되어 있습니다. 각 마크업은 위에 언급된 목표의 관점에서 간략하게 분석됩니다. 이것이 모든 기존 마크업 시스템의 배타적인 목록이 아니라는 점에 유의하십시오. (Texinfo, Doxygen, TIM, YODL, AFT 등) 언급되지 않은 많은 다른 마크업이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eXML, SGML, DocBook, HTML, XHTML\u003c/strong\u003e : XML 및 SGML은 모든 종류의 문서에 적합한 명시적이고 잘 정돈된 메타 언어입니다. XML은 SGML의 변형입니다. 이들은 훈련받지 않은 눈에는 장황하고, 입력하기 어려우며, 소스로서 편안하게 읽기에는 너무 복잡하기 때문에 주로 배후에서 사용됩니다. DocBook, HTML, XHTML은 모두 SGML 및/또는 XML의 응용 프로그램이며, 동일한 기본 문법과 동일한 단점을 공유합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTeX\u003c/strong\u003e : TeX는 XML/SGML과 유사하게 명시적이지만, 작성하기 쉽지 않고, 익숙하지 않은 사람들에게는 읽기 어렵습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePerl POD\u003c/strong\u003e : 대부분의 Perl 모듈은 POD(Plain Old Documentation)라는 형식으로 문서화됩니다. 이는 Perl 파서와 강력하게 통합된, 입력하기 쉽고 매우 낮은 수준의 형식입니다. POD 문서를 info, HTML, man 페이지 등 다른 형식으로 변환하는 많은 도구들이 존재합니다. 그러나 POD 문법은 가독성 면에서 Perl 자체를 따릅니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eJavaDoc\u003c/strong\u003e : Java 클래스 및 함수 앞의 특별한 주석이 코드 문서를 작성하는 데 사용됩니다. 이를 추출하여 HTML 문서로 변환하는 프로그램은 javadoc이라고 불리며, 표준 Java 배포판의 일부입니다. 그러나 JavaDoc은 대부분의 마크업에 HTML 태그를 사용하여 HTML과 매우 밀접한 관계를 가지고 있습니다. 따라서 HTML의 가독성 문제를 공유합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSetext, StructuredText\u003c/strong\u003e : 초기에 Setext(Structure Enhanced Text)의 변형들, Zope Corp의 StructuredText를 포함하여, Python docstring 형식 지정을 위해 제안되었습니다. 이후 이러한 변형들을 통칭하여 \"STexts\"라고 부를 것입니다. STexts는 특별한 지식 없이도 읽기 쉽고, 비교적 작성하기 쉽다는 장점이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e일부 사용자(대부분의 기존 Python 자동 문서화 도구 포함)에 의해 사용되었음에도 불구하고, 지금까지 STexts는 다음과 같은 이유로 표준이 되지 못했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSTexts는 불완전했습니다. 사람들이 docstring에서 사용하고 싶어하는 \"필수적인\" 구성이 부족하여 STexts는 이상적이지 못했습니다. 이러한 \"필수적인\" 구성은 보편적이지 않으며, 모든 사람이 자신의 요구 사항을 가지고 있다는 점에 유의하십시오.\u003c/li\u003e\n\u003cli\u003eSTexts는 때때로 예상치 못했습니다. 텍스트 조각이 예상치 못하게 마크업된 것으로 해석되어 사용자에게 불만을 초래했습니다.\u003c/li\u003e\n\u003cli\u003eSText 구현은 버그가 많았습니다. 대부분의 STexts는 구현 자체를 제외하고는 공식적인 사양이 없었습니다. 버그 있는 구현은 버그 있는 사양을 의미했으며, 그 반대도 마찬가지였습니다.\u003c/li\u003e\n\u003cli\u003e마크업 문자가 비-마크업 컨텍스트에서 사용될 때 SText 마크업 규칙을 우회할 메커니즘이 없었습니다. 다시 말해, 마크업을 이스케이프할 방법이 없었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e암묵적 STexts의 지지자들은 명시적 마크업(XML, HTML, TeX, POD 등)에 대한 제안에 강력하게 반대했으며, 이 논쟁은 1996년 또는 그 이전부터 계속되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e는 위에 나열된 모든 문제를 해결하면서 SText 아이디어를 완전히 수정하고 재해석한 것입니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e의 명세와 사용자 문서는 매우 광범위합니다. 여기에서 모든 것을 반복하거나 요약하는 대신, 원본 문서에 대한 링크가 제공됩니다.\u003c/p\u003e\n\u003cp\u003e먼저 짧고 쉬운 입문서인 \u003ca href=\"https://docutils.sourceforge.io/docs/user/rst/quickstart.html\"\u003eA ReStructuredText Primer\u003c/a\u003e를 살펴보십시오. \u003ca href=\"https://docutils.sourceforge.io/docs/user/rst/quickref.html\"\u003eQuick reStructuredText user reference\u003c/a\u003e는 모든 마크업 구성을 빠르게 요약합니다. 완전하고 광범위한 세부 정보는 다음 문서를 참조하십시오:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://docutils.sourceforge.io/docs/ref/rst/introduction.html\"\u003eAn Introduction to reStructuredText\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html\"\u003ereStructuredText Markup Specification\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docutils.sourceforge.io/docs/ref/rst/directives.html\"\u003ereStructuredText Directives\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한, \u003ca href=\"https://docutils.sourceforge.io/docs/ref/rst/structuredtext_problems.html\"\u003eProblems With StructuredText\u003c/a\u003e는 StructuredText와 관련하여 이루어진 많은 마크업 결정 사항을 설명하고, \u003ca href=\"https://docutils.sourceforge.io/docs/ref/rst/alternatives.html\"\u003eA Record of reStructuredText Syntax Alternatives\u003c/a\u003e는 독립적으로 이루어진 마크업 결정 사항을 기록합니다.\u003c/p\u003e\n\u003ch2\u003eDocstring 관련 주요 기능 (Docstring-Significant Features)\u003c/h2\u003e\n\u003ch3\u003e마크업 이스케이프 메커니즘 (Markup escaping mechanism)\u003c/h3\u003e\n\u003cp\u003e백슬래시(\u003ccode\u003e\\\u003c/code\u003e)는 마크업 문자가 비-마크업 목적으로 필요할 때 이스케이프하는 데 사용됩니다. 그러나 인라인 마크업 인식 규칙은 백슬래시 이스케이프가 필요한 경우를 최소화하도록 구성되었습니다. 예를 들어, 별표는 강조를 위해 사용되지만, \u003ccode\u003e\"*\"\u003c/code\u003e 또는 \u003ccode\u003e\"(*)\"\u003c/code\u003e 또는 \u003ccode\u003e\"x * y\"\u003c/code\u003e와 같은 비-마크업 컨텍스트에서는 별표가 마크업으로 해석되지 않고 그대로 유지됩니다. 백슬래시의 많은 비-마크업 사용(예: 정규 표현식 설명)의 경우, 인라인 리터럴 또는 리터럴 블록이 적용됩니다; 다음 항목을 참조하십시오.\u003c/p\u003e\n\u003ch3\u003ePython 소스 코드 및 Python 대화형 세션 포함 마크업: 인라인 리터럴, 리터럴 블록, doctest 블록 (Markup to include Python source code and Python interactive sessions: inline literals, literal blocks, and doctest blocks)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e인라인 리터럴(Inline literals)\u003c/strong\u003e : 프로그램 I/O 또는 코드 스니펫을 나타내기 위해 이중 백쿼트(\u003ccode\u003e \u003c/code\u003e)를 사용합니다. 인라인 리터럴 내에서는 마크업 해석(백슬래시 이스케이프[ \u003ccode\u003e\\\u003c/code\u003e ] 해석 포함)이 수행되지 않습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e리터럴 블록(Literal blocks)\u003c/strong\u003e : 코드 발췌문 또는 ASCII 그래픽과 같은 블록 수준의 리터럴 텍스트는 들여쓰기되며, 이전 단락 끝에 이중 콜론(\u003ccode\u003e::\u003c/code\u003e)으로 표시됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif literal_block:\r\n    text = 'is left as-is'\r\n    spaces_and_linebreaks = 'are preserved'\r\n    markup_processing = None\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003edoctest 블록(Doctest blocks)\u003c/strong\u003e : \u003ccode\u003e\u003e\u003e\u003e \u003c/code\u003e로 시작하고 빈 줄로 끝납니다. 들여쓰기나 리터럴 블록의 이중 콜론은 필요하지 않습니다. 예를 들면 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eHere's a doctest block:\r\n\u003e\u003e\u003e print 'Python-specific usage examples; begun with \"\u003e\u003e\u003e\"'\r\nPython-specific usage examples; begun with \"\u003e\u003e\u003e\"\r\n\u003e\u003e\u003e print '(cut and pasted from interactive sessions)'\r\n(cut and pasted from interactive sessions)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ePython 식별자를 분리하는 마크업: 해석된 텍스트 (Markup that isolates a Python identifier: interpreted text)\u003c/h3\u003e\n\u003cp\u003e단일 백쿼트(\u003ccode\u003e`\u003c/code\u003e)로 묶인 텍스트는 \"해석된 텍스트(interpreted text)\"로 인식되며, 그 해석은 애플리케이션에 따라 다릅니다. Python docstring의 컨텍스트에서 해석된 텍스트의 기본 해석은 Python 식별자입니다. 텍스트는 주어진 식별자에 대한 문서에 연결된 하이퍼링크로 마크업됩니다. 조회 규칙은 Python 자체와 동일합니다: LGB 네임스페이스 조회(local, global, builtin). 해석된 텍스트의 \"역할(role)\"(클래스, 모듈, 함수 등을 식별하는)은 네임스페이스 조회를 통해 암묵적으로 결정됩니다. 예를 들면 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Keeper(Storer):\r\n    \"\"\"\r\n    Keep data fresher longer. Extend `Storer`.\r\n    Class attribute `instances` keeps track of the number of `Keeper` objects instantiated.\r\n    \"\"\"\r\n    instances = 0\r\n    \"\"\"How many `Keeper` objects are there?\"\"\"\r\n    def __init__(self):\r\n        \"\"\"\r\n        Extend `Storer.__init__()` to keep track of instances.\r\n        Keep count in `self.instances` and data in `self.data`.\r\n        \"\"\"\r\n        Storer.__init__(self)\r\n        self.instances += 1\r\n        self.data = []\r\n        \"\"\"Store data in a list, most recent last.\"\"\"\r\n    def storedata(self, data):\r\n        \"\"\"\r\n        Extend `Storer.storedata()`; append new `data` to a list (in `self.data`).\r\n        \"\"\"\r\n        self.data = data\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e각 해석된 텍스트 조각은 해당 docstring을 포함하는 블록의 로컬 네임스페이스에 따라 조회됩니다.\u003c/p\u003e\n\u003ch3\u003ePython 식별자를 분리하고 그 유형을 지정하는 마크업: 역할이 있는 해석된 텍스트 (Markup that isolates a Python identifier and specifies its type: interpreted text with roles)\u003c/h3\u003e\n\u003cp\u003ePython 소스 컨텍스트 리더는 명시적 역할이 필요하지 않도록 설계되었지만, 역할을 사용할 수 있습니다. 식별자를 명시적으로 분류하기 위해 역할은 접두사 또는 접미사 형식으로 식별자와 함께 제공됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eUse :method:\u003c/code\u003eKeeper.storedata\u003ccode\u003eto store the object's data in\u003c/code\u003eKeeper.data\u003ccode\u003e:instance_attribute:.\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e역할에 대해 선택된 문법은 장황하지만, 필연적으로 그렇습니다 (더 나은 대안이 있다면 Doc-SIG에 게시해 주십시오). 마크업의 의도는 명시적 역할을 사용할 필요가 거의 없어야 한다는 것입니다. 그 사용은 절대적인 최소한으로 유지되어야 합니다.\u003c/p\u003e\n\u003ch3\u003e\"태그 목록\" 또는 \"레이블 목록\"을 위한 마크업: 필드 목록 (Markup for “tagged lists” or “label lists”: field lists)\u003c/h3\u003e\n\u003cp\u003e필드 목록(Field lists)은 필드 이름에서 필드 본문으로의 매핑을 나타냅니다. 이는 주로 \"서지 필드 목록\"(저자, 날짜, 버전과 같은 문서 메타데이터를 나타냄) 및 지시문(directives)의 확장 속성(아래 참조)과 같은 확장 문법에 사용됩니다. 매개변수 식별, 발생 예외 등과 같은 방법론(docstring 의미론)을 구현하는 데 사용될 수 있습니다. 이러한 사용은 이 PEP의 범위를 벗어납니다.\u003c/p\u003e\n\u003cp\u003e수정된 RFC 2822 문법이 사용되며, 필드 이름 앞뒤에 콜론이 있습니다. 필드 본문도 더 다양합니다; 여러 필드 본문(심지어 중첩된 필드 목록)을 포함할 수 있습니다. 예를 들면 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e:Date: 2002-03-22\r\n:Version: 1\r\n:Authors: - Me\r\n          - Myself\r\n          - I\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e표준 RFC 2822 헤더 문법은 모호하기 때문에 이 구성을 위해 사용될 수 없습니다. 한 줄 시작 부분에 콜론이 뒤따르는 단어는 일반적인 서면 텍스트에서 흔합니다.\u003c/p\u003e\n\u003ch3\u003e마크업 확장성: 지시문 및 대체 (Markup extensibility: directives and substitutions)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e지시문(Directives)\u003c/strong\u003e 은 \u003ccode\u003ereStructuredText\u003c/code\u003e의 확장 메커니즘으로 사용되며, 새로운 문법을 추가하지 않고 새로운 블록 수준 구성을 지원하는 방법입니다. 이미지, 경고(note, caution 등), 목차 생성(다른 것들 중)을 위한 지시문이 구현되었습니다. 예를 들어, 이미지를 배치하는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.. image:: mylogo.png\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e대체 정의(Substitution definitions)\u003c/strong\u003e 는 인라인 텍스트로 블록 수준 지시문의 힘과 유연성을 공유할 수 있도록 합니다. 예를 들면 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eThe |biohazard| symbol must be used on containers used to dispose of medical waste.\r\n.. |biohazard| image:: biohazard.png\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e섹션 구조 마크업 (Section structure markup)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e의 섹션 헤더는 들여쓰기가 아닌 밑줄(및 선택적으로 오버라인)을 통한 장식(adornment)을 사용합니다. 예를 들면 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eThis is a Section Title\r\n=======================\r\n\r\nThis is a Subsection Title\r\n--------------------------\r\nThis paragraph is in the subsection.\r\n\r\nThis is Another Section Title\r\n=============================\r\nThis paragraph is in the second section.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e질문 및 답변 (Questions \u0026#x26; Answers)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e는 충분히 풍부한가요? (Is reStructuredText rich enough?)\u003c/h3\u003e\n\u003cp\u003e네, 대부분의 사람들에게는 그렇습니다. 특정 애플리케이션에 필요한 구성이 부족하다면 지시문 메커니즘을 통해 추가할 수 있습니다. 유용하고 일반적인 구성이 간과되었고 적절하게 읽을 수 있는 문법을 찾을 수 있다면, 명세와 파서에 추가될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e는 너무 풍부한가요? (Is reStructuredText too rich?)\u003c/h3\u003e\n\u003cp\u003e특정 애플리케이션이나 개인에게는 그럴 수도 있습니다. 일반적으로는 그렇지 않습니다.\u003c/p\u003e\n\u003cp\u003edocstring 마크업 문법이 Doc-SIG에 제안될 때마다, 누군가는 어떤 구성에 대한 지원 부족에 대해 불평했습니다. 답변은 종종 \"우리가 말하는 것은 docstring이고, docstring은 복잡한 마크업을 가질 필요가 없습니다\"와 같았습니다. 문제는 한 사람에게는 불필요해 보이는 구성이 다른 사람에게는 절대적으로 필수적일 수 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e는 정반대의 접근 방식을 취합니다: 풍부한 암묵적 마크업 구성 세트(및 명시적 마크업을 위한 일반 확장 메커니즘)를 제공하여 모든 종류의 문서를 허용합니다. 구성 세트가 특정 애플리케이션에 너무 풍부하다면, 사용되지 않는 구성은 파서에서 제거(애플리케이션별 재정의를 통해)하거나 단순히 관례상 생략할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003eStructuredText처럼 섹션 구조에 들여쓰기를 사용하지 않는 이유는 무엇인가요? 더 \"Pythonic\"하지 않나요? (Why not use indentation for section structure, like StructuredText does? Isn't it more “Pythonic”?)\u003c/h3\u003e\n\u003cp\u003eGuido van Rossum은 2001년 6월 13일 Doc-SIG 게시물에 다음과 같이 썼습니다:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e저는 여전히 섹션을 나타내기 위해 들여쓰기를 사용하는 것이 잘못되었다고 생각합니다. 실제 서적 및 기타 인쇄 출판물이 어떻게 배치되는지 살펴보면, 들여쓰기는 자주 사용되지만 주로 섹션 내 수준에서 사용된다는 것을 알 수 있습니다. 들여쓰기는 목록, 표, 인용문, 예제 등을 구분하는 데 사용될 수 있습니다. (docstring이 텍스트 포맷터의 입력이기 때문에 다르다는 주장은 잘못되었습니다: 핵심은 처리 없이도 읽을 수 있어야 한다는 것입니다).\u003c/p\u003e\n\u003cp\u003e저는 들여쓰기를 사용하는 것이 Pythonic하다는 주장을 거부합니다. 텍스트는 코드가 아니며, 다른 전통과 관습이 적용됩니다. 사람들은 30세기 이상 동안 가독성을 위해 텍스트를 제시해왔습니다. 불필요하게 혁신하지 맙시다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e자세한 내용은 \u003ca href=\"https://docutils.sourceforge.io/docs/ref/rst/structuredtext_problems.html\"\u003eProblems With StructuredText\u003c/a\u003e의 \"Section Structure via Indentation\"을 참조하십시오.\u003c/p\u003e\n\u003ch3\u003ePEPs에 \u003ccode\u003ereStructuredText\u003c/code\u003e를 사용하는 이유는 무엇인가요? 기존 표준의 문제점은 무엇인가요? (Why use reStructuredText for PEPs? What's wrong with the existing standard?)\u003c/h3\u003e\n\u003cp\u003ePEPs에 대한 기존 표준은 일반적인 표현력 측면에서 매우 제한적이며, 특히 참조가 풍부한 문서 유형에 대한 참조 기능이 부족합니다. PEPs는 현재 HTML로 변환되지만, 결과물(대부분 모노스페이스 텍스트)은 매력적이지 않으며, HTML의 부가가치 잠재력(특히 인라인 하이퍼링크)은 대부분 활용되지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e를 PEPs의 표준 마크업으로 만들면 섹션 구조, 인라인 마크업, 그래픽 및 테이블 지원을 포함하여 훨씬 더 풍부한 표현이 가능해집니다. 여러 PEPs에는 일반 텍스트 문서가 지원할 수 있는 모든 ASCII 그래픽 다이어그램이 있습니다. PEPs가 HTML 형태로 제공되므로, 적절한 다이어그램을 포함하는 기능은 즉시 유용할 것입니다.\u003c/p\u003e\n\u003cp\u003e현재 PEP 관행은 텍스트에 \"[1]\" 형식의 참조 마커를 허용하며, 각주/참조 자체는 문서 끝 부분의 섹션에 나열됩니다. 현재 참조 마커와 각주/참조 자체 사이에 하이퍼링크가 없습니다 (pep2html.py에 추가할 수 있지만, \"마크업\" 자체가 모호하여 실수가 불가피합니다). 많은 참조를 포함하는 PEP(이 PEP와 같은 ;-)는 앞뒤로 많이 넘겨봐야 합니다. PEP를 수정할 때 종종 새로운 참조가 추가되거나 사용되지 않는 참조가 삭제됩니다. 참조 번호를 다시 매기는 것은 두 곳에서 해야 하고 연쇄 효과를 가질 수 있으므로 고통스럽습니다 (새로운 참조 1을 하나 삽입하면 다른 모든 참조의 번호를 다시 매겨야 합니다; 항상 새로운 참조를 끝에 추가하는 것은 최적이 아닙니다). 참조가 동기화되지 않을 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePEPs는 두 가지 목적으로 참조를 사용합니다: 간단한 URL 참조와 각주. \u003ccode\u003ereStructuredText\u003c/code\u003e는 이 둘을 구분합니다. PEP는 다음과 같은 참조를 포함할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAbstract\r\nThis PEP proposes adding frungible doodads to the core. It extends PEP 9876 via the BCA mechanism.\r\n...\r\nReferences and Footnotes\r\n http://www.example.org/\r\n PEP 9876, Let's Hope We Never Get Here\r\n    http://peps.python.org/pep-9876/\r\n \"Bogus Complexity Addition\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참조 1은 간단한 URL 참조입니다. 참조 2는 텍스트와 URL을 포함하는 각주입니다. 참조 3은 텍스트만 포함하는 각주입니다. \u003ccode\u003ereStructuredText\u003c/code\u003e를 사용하여 다시 작성하면 이 PEP는 다음과 같이 보일 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAbstract\r\n========\r\nThis PEP proposes adding `frungible doodads`_ to the core. It extends PEP 9876 [#pep9876]_ via the BCA [#]_ mechanism.\r\n...\r\nReferences \u0026#x26; Footnotes\r\n======================\r\n.. _frungible doodads: http://www.example.org/\r\n.. [#pep9876] PEP 9876, Let's Hope We Never Get Here\r\n.. [#] \"Bogus Complexity Addition\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eURL과 각주는 원하는 경우 참조 가까이에 정의할 수 있어 소스 텍스트에서 읽기 쉬워지고 PEP를 수정하기 쉬워집니다. \"References and Footnotes\" 섹션은 문서 트리 변환(document tree transform)으로 자동 생성될 수 있습니다. PEP 전체의 각주는 표준 헤더 아래에 수집되어 표시됩니다. URL 참조도 명시적으로 작성되어야 하는 경우(인용 형식으로), 다른 트리 변환을 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eURL 참조는 이름 지정될 수 있으며(\"frungible doodads\"), 추가 정의 없이 문서의 여러 위치에서 참조될 수 있습니다. HTML로 변환될 때 참조는 인라인 하이퍼링크(HTML \u003ccode\u003e\u0026#x3C;a\u003e\u003c/code\u003e 태그)로 대체됩니다. 두 각주는 자동으로 번호가 매겨지므로 항상 동기화 상태를 유지합니다. 첫 번째 각주에는 내부 참조 이름 \"pep9876\"도 포함되어 있어 소스 텍스트에서 참조와 각주 사이의 연결을 더 쉽게 볼 수 있습니다. 이름 지정된 각주는 여러 번 참조될 수 있으며, 일관된 번호 매기기를 유지합니다.\u003c/p\u003e\n\u003cp\u003e\"#pep9876\" 각주는 인용 형식으로도 작성될 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eIt extends PEP 9876 [PEP9876]_ ...\u003c/code\u003e\r\n\u003ccode\u003e.. [PEP9876] PEP 9876, Let's Hope We Never Get Here\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e각주는 번호가 매겨지지만, 인용은 참조에 텍스트를 사용합니다.\u003c/p\u003e\n\u003ch3\u003edocstring 및 PEP 제안을 분리하는 것이 더 낫지 않을까요? (Wouldn't it be better to keep the docstring and PEP proposals separate?)\u003c/h3\u003e\n\u003cp\u003ePEP 마크업 제안은 PEP 마크업의 필요성이 없다고 판단되면 제거될 수 있거나, 별도의 PEP로 만들어질 수 있습니다. 승인된다면, PEP 1, PEP Purpose and Guidelines, 및 PEP 9, Sample PEP Template가 업데이트될 것입니다.\u003c/p\u003e\n\u003cp\u003ePython에서 구조화된 일반 텍스트의 모든 용도에 대해 단일의 일관된 마크업 표준을 채택하고, 이를 한곳에서 제안하는 것이 자연스러워 보입니다.\u003c/p\u003e\n\u003ch3\u003e기존 pep2html.py 스크립트는 기존 PEP 형식을 HTML로 변환합니다. 새 형식의 PEP는 어떻게 HTML로 변환될까요? (The existing pep2html.py script converts the existing PEP format to HTML. How will the new-format PEPs be converted to HTML?)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e 파싱이 통합된 새 버전의 pep2html.py가 완성되었습니다. Docutils 프로젝트는 \"PEP Reader\" 구성 요소를 통해 PEPs를 지원하며, 현재 pep2html.py의 모든 기능(PEP 및 RFC 참조의 자동 인식, 이메일 마스킹 등)을 포함합니다.\u003c/p\u003e\n\u003ch3\u003e누가 기존 PEPs를 \u003ccode\u003ereStructuredText\u003c/code\u003e로 변환할까요? (Who's going to convert the existing PEPs to reStructuredText?)\u003c/h3\u003e\n\u003cp\u003ePEP 저자 또는 자원봉사자는 원하는 경우 기존 PEPs를 변환할 수 있지만, 그렇게 할 의무는 없습니다. \u003ccode\u003ereStructuredText\u003c/code\u003e 기반 PEPs는 기존 PEP 표준과 공존할 것입니다. 6번 질문 답변에서 언급된 pep2html.py는 기존 및 새 표준을 모두 처리합니다.\u003c/p\u003e\n\u003ch3\u003eREADME 및 기타 보조 파일에 \u003ccode\u003ereStructuredText\u003c/code\u003e를 사용하는 이유는 무엇인가요? (Why use reStructuredText for README and other ancillary files?)\u003c/h3\u003e\n\u003cp\u003e위 4번 질문 답변에서 PEPs에 대해 제시된 이유는 README 및 기타 보조 파일에도 적용됩니다. 표준 마크업을 채택함으로써 이러한 파일은 매력적인 상호 참조 HTML로 변환되어 python.org에 게시될 수 있습니다. 다른 프로젝트 개발자들도 이 기능을 자신의 문서에 활용할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e기존 마크업 규칙과의 피상적인 유사성이 문제를 일으키고, 사람들이 유효하지 않은 마크업을 작성(그리고 일반 텍스트가 자연스러워 보여서 눈치채지 못함)하게 만들지 않을까요? \u003ccode\u003ereStructuredText\u003c/code\u003e는 \"완벽하지 않은\" 마크업에 얼마나 관대한가요? (Won't the superficial similarity to existing markup conventions cause problems, and result in people writing invalid markup (and not noticing, because the plaintext looks natural)? How forgiving is reStructuredText of “not quite right” markup?)\u003c/h3\u003e\n\u003cp\u003e한 프로그래밍 언어에서 다른 프로그래밍 언어로 전환할 때와 마찬가지로 일부 실수가 있을 것입니다. 다른 언어와 마찬가지로 경험을 통해 숙련도가 향상됩니다. 다행히 \u003ccode\u003ereStructuredText\u003c/code\u003e는 매우 작은 언어입니다.\u003c/p\u003e\n\u003cp\u003e어떤 문법이든 문법 오류의 가능성은 있습니다. 사용자는 입력에 대해 처리 시스템을 실행하고 출력이 정확한지 확인할 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e엄격한 의미에서 \u003ccode\u003ereStructuredText\u003c/code\u003e 파서는 매우 관대하지 않습니다 (그래야 합니다; \"모호함에 직면했을 때, 추측하려는 유혹을 거부하라\"는 마크업 파싱뿐만 아니라 컴퓨터 언어에도 적용됩니다). \u003ca href=\"https://docutils.sourceforge.io/docs/ref/rst/introduction.html\"\u003eAn Introduction to reStructuredText\u003c/a\u003e의 설계 목표 3은 다음과 같습니다:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e명확해야 합니다. 마크업 규칙은 해석의 여지를 두어서는 안 됩니다. 어떤 주어진 입력에 대해 단 하나의 가능한 출력(오류 출력 포함)만 있어야 합니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e관대하지 않지만, 동시에 파서는 유용한 진단 출력(\"시스템 메시지\")을 생성하여 도움을 주려고 노력합니다. 파서는 문제의 심각도 수준(가장 낮은 것부터 높은 것까지: debug, info, warning, error, severe)을 나타내어 보고합니다. 사용자 또는 클라이언트 소프트웨어는 보고 임계값을 결정할 수 있습니다; 저수준 문제는 무시하거나 고수준 문제가 즉시 처리를 중단시키도록 할 수 있습니다. 문제는 파싱 중에도 보고되며 출력에도 포함되는데, 종종 문제의 원본과 이를 설명하는 시스템 메시지 사이에 양방향 링크가 있습니다.\u003c/p\u003e\n\u003ch3\u003ePython 표준 라이브러리 모듈의 docstring은 \u003ccode\u003ereStructuredText\u003c/code\u003e로 변환될까요? (Will the docstrings in the Python standard library modules be converted to reStructuredText?)\u003c/h3\u003e\n\u003cp\u003e아니요. Python의 라이브러리 참조 문서는 소스와 별도로 관리됩니다. Python 표준 라이브러리의 docstring은 라이브러리 참조 문서를 복제하려고 시도해서는 안 됩니다. Python 표준 라이브러리의 docstring에 대한 현재 정책은 간결한 힌트, 간단하고 마크업이 없는 것이어야 한다는 것입니다 (비록 많은 경우 임시적인 암묵적 마크업을 포함하고 있지만).\u003c/p\u003e\n\u003ch3\u003e모든 문자열을 유니코드로 작성하고 싶습니다. 문제가 생길까요? (I want to write all my strings in Unicode. Will anything break?)\u003c/h3\u003e\n\u003cp\u003e파서는 유니코드를 완전히 지원합니다. Docutils는 임의의 입력 및 출력 인코딩을 지원합니다.\u003c/p\u003e\n\u003ch3\u003e커뮤니티에 새로운 구조화된 텍스트 디자인이 필요한 이유는 무엇인가요? (Why does the community need a new structured text design?)\u003c/h3\u003e\n\u003cp\u003e기존의 구조화된 텍스트 디자인은 위 \"배경\"에서 제시된 이유들로 인해 결함이 있습니다. \u003ccode\u003ereStructuredText\u003c/code\u003e는 \"읽을 수 있는 일반 텍스트\" 매체의 한계 내에서 완전한 마크업 문법이 되는 것을 목표로 합니다.\u003c/p\u003e\n\u003ch3\u003e기존 문서화 방법론에 문제가 있나요? (What is wrong with existing documentation methodologies?)\u003c/h3\u003e\n\u003cp\u003e어떤 기존 방법론을 말씀하시나요? Python docstring의 경우, JavaDoc과 같은 문서화 방법론은 고사하고 공식적인 표준 마크업 형식도 없습니다. 방법론 문제는 문법(이 PEP가 다루는)보다 훨씬 높은 수준의 문제입니다. 이는 잠재적으로 훨씬 더 논란의 여지가 있고 해결하기 어려우므로, 이 논의에서 의도적으로 제외되었습니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003ch2\u003e감사의 말 (Acknowledgements)\u003c/h2\u003e\n\u003cp\u003e일부 텍스트는 Moshe Zadka의 PEP 216, Docstring Format에서 차용되었습니다.\u003c/p\u003e\n\u003cp\u003ePython Doc-SIG의 모든 과거 및 현재 회원들에게 특별히 감사드립니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2224,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Active] PEP 287 - reStructuredText Docstring Format\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 17:59:15+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Le\",null,{\"postPermalink\":\"/python/pep/287/\",\"postId\":\"2025-09-26-pep-0287-restructuredtext-docstring-format\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/286/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Deferred] PEP 286 - Enhanced Argument Tuples\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Active] PEP 287 - reStructuredText Docstring Format\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$L9\",null,{\"href\":\"/python/pep/288/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Withdrawn] PEP 288 - Generators Attributes and Exceptions\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>