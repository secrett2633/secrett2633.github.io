<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/da5e1dc2b9a7c5bb.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-aecaf5ac7a84facf.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-e3ea38185bb36cd2.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 3118 - Revising the buffer protocol</h1><div class="page__meta"><time dateTime="2025-09-27 14:26:38+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-3118/">PEP 3118 - Revising the buffer protocol</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 28-Aug-2006</p>
</blockquote>
<h1>PEP 3118 – 버퍼 프로토콜 재설계 (Revising the buffer protocol)</h1>
<ul>
<li><strong>작성자:</strong> Travis Oliphant, Carl Banks</li>
<li><strong>상태:</strong> Final</li>
<li><strong>유형:</strong> Standards Track</li>
<li><strong>생성일:</strong> 2006년 8월 28일</li>
<li><strong>Python 버전:</strong> 3.0</li>
<li><strong>최종 수정일:</strong> 2025년 2월 14일</li>
</ul>
<hr>
<p><strong>중요:</strong> 이 PEP는 역사적인 문서입니다. 최신 공식 문서는 <a href="https://docs.python.org/3/c-api/buffer.html">Buffer Protocol</a>, <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyBufferProcs">PyBufferProcs</a>, <a href="https://docs.python.org/3/c-api/memory.html#c.PyMemoryView_FromObject">PyMemoryView_FromObject</a>에서 찾을 수 있습니다.</p>
<p>이 PEP에서 제안된 모든 기능이 구현된 것은 아닙니다. 특히:</p>
<ul>
<li><code>PyObject_CopyToObject</code>는 추가되지 않았습니다.</li>
<li><code>struct</code> 문자열 구문 추가 사항 중 <code>?</code> (<code>_Bool</code>)를 제외한 나머지는 추가되지 않았습니다.</li>
<li><code>PyObject_GetMemoryView</code>는 <code>PyMemoryView_FromObject</code>로 이름이 변경되었습니다.</li>
</ul>
<p>이 PEP는 10년도 더 전에 출시된 Python 3.0을 대상으로 합니다. 누락된 기능을 추가하려는 모든 제안은 이 PEP의 구현을 완료하는 것이 아니라 새로운 기능으로 논의되어야 합니다.</p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 Python 3.0에서 메모리 공유 방식을 개선하기 위해 버퍼 인터페이스(PyBufferProcs 함수 포인터)를 재설계할 것을 제안합니다.</p>
<p>특히, API의 문자 버퍼(character buffer) 부분을 없애고, 여러 세그먼트(multiple-segment) 부분을 스트라이드(strided) 메모리 공유와 연계하여 재설계하는 것이 제안됩니다. 또한, 새로운 버퍼 인터페이스는 메모리의 다차원적 특성과 메모리가 포함하는 데이터 형식(data-format)을 공유할 수 있도록 할 것입니다.</p>
<p>이 인터페이스는 모든 확장 모듈(extension module)이 메모리를 공유하는 객체를 생성하거나, 인터페이스를 내보내는 임의의 객체에서 원시 메모리(raw memory)를 사용하고 조작하는 알고리즘을 생성할 수 있도록 합니다.</p>
<h2>도입 배경 (Rationale)</h2>
<p>Python 2.X 버퍼 프로토콜은 다른 Python 타입들이 내부 버퍼 시퀀스에 대한 포인터를 교환할 수 있도록 합니다. 이 기능은 서로 다른 고수준 객체들 간에 큰 메모리 세그먼트를 공유하는 데 매우 유용하지만, 너무 제한적이며 다음과 같은 문제가 있습니다.</p>
<ul>
<li>잘 사용되지 않는 "세그먼트 시퀀스" 옵션(<code>bf_getsegcount</code>)이 있으며, 그 동기가 명확하지 않습니다.</li>
<li>겉보기에 중복되는 문자 버퍼 옵션(<code>bf_getcharbuffer</code>)이 있습니다.</li>
<li>소비자(consumer)가 버퍼 API를 내보내는 객체에 메모리 보기를 "다 사용했다"고 알릴 방법이 없으므로, 내보내는 객체가 자신이 소유한 메모리에 대한 포인터를 재할당하는 것이 안전하다고 확신할 방법이 없습니다. (예: <code>array</code> 객체가 원본 포인터를 가지고 있던 버퍼 객체와 메모리를 공유한 후 메모리를 재할당하여 악명 높은 버퍼 객체 문제를 일으켰습니다.)</li>
<li>메모리는 단순히 길이(length)를 가진 포인터일 뿐입니다. 메모리 "안에 무엇이 있는지"(float, int, C-구조체 등)를 설명할 방법이 없습니다.</li>
<li>메모리에 대한 형상(shape) 정보가 제공되지 않습니다. 하지만 여러 배열과 유사한 Python 타입(wxPython, GTK, pyQT, CVXOPT, PyVox, Audio and Video Libraries, ctypes, NumPy, 데이터베이스 인터페이스 등)은 메모리의 형상 해석(shape-interpretation)을 설명하는 표준적인 방법을 활용할 수 있습니다.</li>
<li>비연속적인 메모리(discontiguous memory)를 공유할 방법이 없습니다 (세그먼트 시퀀스 개념을 통하는 경우 제외).</li>
</ul>
<p>비연속적인 메모리 개념을 사용하는 두 가지 널리 사용되는 라이브러리는 PIL과 NumPy입니다. 하지만 이들의 비연속 배열에 대한 관점은 다릅니다. 제안된 버퍼 인터페이스는 두 가지 메모리 모델 모두의 공유를 허용합니다. 내보내는 객체(Exporter)는 일반적으로 한 가지 접근 방식만 사용할 것이며, 소비자는 각 유형의 비연속 배열을 지원할지 여부를 선택할 수 있습니다.</p>
<p>NumPy는 각 차원에서 상수 스트라이딩(constant striding) 개념을 배열의 기본 개념으로 사용합니다. 이 개념을 통해 더 큰 배열의 간단한 하위 영역을 데이터를 복사하지 않고도 설명할 수 있습니다. 따라서 스트라이드 정보는 공유되어야 하는 추가 정보입니다.</p>
<p>PIL은 더 불투명한 메모리 표현을 사용합니다. 때로는 이미지가 연속적인 메모리 세그먼트에 포함되지만, 때로는 이미지의 연속적인 세그먼트(일반적으로 라인)에 대한 포인터 배열에 포함됩니다. PIL은 원래 버퍼 인터페이스에서 여러 버퍼 세그먼트 개념이 유래한 곳입니다.</p>
<p>NumPy의 스트라이드 메모리 모델은 계산 라이브러리에서 더 자주 사용되며, 그 단순성 때문에 이 모델을 사용한 메모리 공유를 지원하는 것이 합리적입니다. PIL 메모리 모델은 C-코드에서 2차원 배열을 이중 포인터 간접 참조(e.g. <code>image[i][j]</code>)를 사용하여 접근할 수 있을 때 사용되기도 합니다.</p>
<p>버퍼 인터페이스는 객체가 이 두 가지 메모리 모델 중 하나를 내보낼 수 있도록 허용해야 합니다. 소비자는 연속적인 메모리를 요구하거나, 이 두 가지 메모리 모델 중 하나 또는 둘 다를 처리하는 코드를 자유롭게 작성할 수 있습니다.</p>
<h2>제안 개요 (Proposal Overview)</h2>
<ul>
<li>버퍼 프로토콜의 문자 버퍼(char-buffer) 및 다중 세그먼트(multiple-segment) 섹션을 제거합니다.</li>
<li>버퍼를 가져오는 읽기/쓰기 버전을 통합합니다.</li>
<li>소비자 객체가 메모리 영역을 "다 사용했을" 때 호출되어야 하는 새로운 함수를 인터페이스에 추가합니다.</li>
<li>메모리에 무엇이 있는지 설명할 수 있도록 새로운 변수를 추가합니다 (현재 <code>struct</code> 및 <code>array</code> 모듈에서 수행되는 작업을 통합).</li>
<li>프로토콜이 형상(shape) 정보를 공유할 수 있도록 새로운 변수를 추가합니다.</li>
<li>스트라이드(stride) 정보를 공유하기 위한 새로운 변수를 추가합니다.</li>
<li>포인터 간접 참조(pointer indirection)를 사용하여 접근해야 하는 배열을 공유하기 위한 새로운 메커니즘을 추가합니다.</li>
<li>핵심(core) 및 표준 라이브러리(standard library)의 모든 객체가 새 인터페이스를 따르도록 수정합니다.</li>
<li><code>struct</code> 모듈을 확장하여 더 많은 형식 지정자(format specifiers)를 처리할 수 있도록 합니다.</li>
<li>버퍼 객체(buffer object)를 버퍼 인터페이스 위에 Python  veneer를 씌운 새로운 메모리 객체(memory object)로 확장합니다.</li>
<li>버퍼 인터페이스를 지원하는 객체에서 연속적인 데이터(contiguous data)를 쉽게 복사하고 가져올 수 있도록 몇 가지 함수를 추가합니다.</li>
</ul>
<h2>사양 (Specification)</h2>
<p>새로운 사양은 복잡한 메모리 공유를 허용하지만, 객체로부터 간단한 연속 바이트 버퍼를 여전히 얻을 수 있습니다. 사실, 새로운 프로토콜은 원본 객체가 연속적인 메모리 청크로 표현되지 않더라도 이를 수행하는 표준 메커니즘을 허용합니다.</p>
<p>가장 쉬운 방법은 제공된 C-API를 사용하여 메모리 청크를 얻는 것입니다.</p>
<p><code>PyBufferProcs</code> 구조체를 다음과 같이 변경합니다.</p>
<pre><code class="language-c">typedef struct {
    getbufferproc bf_getbuffer;
    releasebufferproc bf_releasebuffer;
} PyBufferProcs;
</code></pre>
<p>이 두 루틴은 타입 객체(type object)에 대해 선택 사항입니다.</p>
<pre><code class="language-c">typedef int (*getbufferproc)(PyObject *obj, PyBuffer *view, int flags)
</code></pre>
<p>이 함수는 성공 시 0을 반환하고 실패 시 -1을 반환합니다 (그리고 오류를 발생시킵니다). 첫 번째 변수는 "내보내는(exporting)" 객체입니다. 두 번째 인수는 <code>bufferinfo</code> 구조체의 주소입니다. 두 인수 모두 <code>NULL</code>이어서는 안 됩니다.</p>
<p>세 번째 인수는 소비자가 처리할 준비가 된 버퍼의 종류와 따라서 내보내는 객체가 반환할 수 있는 버퍼의 종류를 나타냅니다. 새로운 버퍼 인터페이스는 훨씬 더 복잡한 메모리 공유 가능성을 허용합니다. 일부 소비자는 모든 복잡성을 처리하지 못할 수 있지만, 내보내는 객체가 메모리에 대한 더 간단한 보기를 허용하는지 확인하고 싶을 수 있습니다.</p>
<p>또한, 일부 내보내는 객체는 모든 가능한 방식으로 메모리를 공유할 수 없으며, 일부 소비자에게 특정 작업이 불가능하다고 알리기 위해 오류를 발생시켜야 할 수도 있습니다. 이러한 오류는 실제로 문제를 일으키는 다른 오류가 없는 한 <code>PyErr_BufferError</code>여야 합니다. 내보내는 객체는 <code>flags</code> 정보를 사용하여 <code>PyBuffer</code> 구조체의 얼마나 많은 요소가 기본값 이외의 값으로 채워지는지 단순화하거나, 객체가 메모리에 대한 더 간단한 보기를 지원할 수 없는 경우 오류를 발생시킬 수 있습니다.</p>
<p>내보내는 객체는 항상 버퍼 구조체의 모든 요소를 채워야 합니다 (요청된 것이 없으면 기본값 또는 <code>NULL</code>로). <code>PyBuffer_FillInfo</code> 함수는 간단한 경우에 사용될 수 있습니다.</p>
<h3>접근 플래그 (Access flags)</h3>
<p>일부 플래그는 특정 종류의 메모리 세그먼트를 요청하는 데 유용하며, 다른 플래그는 소비자가 어떤 종류의 정보를 처리할 수 있는지 내보내는 객체에 알려줍니다. 만약 특정 정보가 소비자에 의해 요청되지 않았지만, 내보내는 객체가 그 정보 없이는 메모리를 공유할 수 없다면, <code>PyErr_BufferError</code>가 발생해야 합니다.</p>
<ul>
<li><code>PyBUF_SIMPLE</code>
<ul>
<li>이것이 기본 플래그 상태(0)입니다. 반환된 버퍼는 쓰기 가능한 메모리를 가질 수도 있고 가지지 않을 수도 있습니다. 형식은 부호 없는 바이트(unsigned bytes)로 가정됩니다. 이것은 "독립적인(stand-alone)" 플래그 상수입니다. 다른 플래그와 <code>|</code>로 연결할 필요가 없습니다. 내보내는 객체는 이러한 연속적인 바이트 버퍼를 제공할 수 없으면 오류를 발생시킵니다.</li>
</ul>
</li>
<li><code>PyBUF_WRITABLE</code>
<ul>
<li>반환된 버퍼는 쓰기 가능해야 합니다. 쓰기 가능하지 않으면 오류를 발생시킵니다.</li>
</ul>
</li>
<li><code>PyBUF_FORMAT</code>
<ul>
<li>이 플래그가 제공되면 반환된 버퍼는 진정한 형식 정보를 가져야 합니다. 이것은 소비자가 실제로 저장된 데이터의 '종류'를 확인할 때 사용됩니다. 내보내는 객체는 요청 시 항상 이 정보를 제공할 수 있어야 합니다. 형식이 명시적으로 요청되지 않으면 형식은 <code>NULL</code>로 반환되어야 합니다 (이는 "B", 즉 부호 없는 바이트를 의미합니다).</li>
</ul>
</li>
<li><code>PyBUF_ND</code>
<ul>
<li>반환된 버퍼는 형상(shape) 정보를 제공해야 합니다. 메모리는 C-스타일 연속(C-style contiguous)으로 가정됩니다 (마지막 차원이 가장 빠르게 변함). 내보내는 객체는 이러한 종류의 연속 버퍼를 제공할 수 없으면 오류를 발생시킬 수 있습니다. 이것이 주어지지 않으면 <code>shape</code>는 <code>NULL</code>이 됩니다.</li>
</ul>
</li>
<li><code>PyBUF_STRIDES</code> ( <code>PyBUF_ND</code>를 암시)
<ul>
<li>반환된 버퍼는 스트라이드(strides) 정보를 제공해야 합니다 (즉, <code>strides</code>는 <code>NULL</code>이 아니어야 합니다). 이것은 소비자가 스트라이드된(strided), 비연속적인 배열을 처리할 수 있을 때 사용됩니다. 스트라이드를 처리하는 것은 자동으로 형상(shape)을 처리할 수 있다고 가정합니다. 내보내는 객체는 (하위 오프셋(suboffsets) 없이) 데이터의 스트라이드된 표현만 제공할 수 없으면 오류를 발생시킬 수 있습니다.</li>
</ul>
</li>
<li><code>PyBUF_C_CONTIGUOUS</code></li>
<li><code>PyBUF_F_CONTIGUOUS</code></li>
<li><code>PyBUF_ANY_CONTIGUOUS</code>
<ul>
<li>이 플래그들은 반환된 버퍼가 각각 C-연속(C-contiguous, 마지막 차원이 가장 빠르게 변함), Fortran-연속(Fortran contiguous, 첫 번째 차원이 가장 빠르게 변함) 또는 둘 중 하나여야 함을 나타냅니다. 이 모든 플래그는 <code>PyBUF_STRIDES</code>를 암시하며, <code>strides</code> 버퍼 정보 구조체가 올바르게 채워질 것을 보장합니다.</li>
</ul>
</li>
<li><code>PyBUF_INDIRECT</code> ( <code>PyBUF_STRIDES</code>를 암시)
<ul>
<li>반환된 버퍼는 하위 오프셋(suboffsets) 정보를 가져야 합니다 (하위 오프셋이 필요하지 않은 경우 <code>NULL</code>일 수 있습니다). 이것은 소비자가 이러한 하위 오프셋이 암시하는 간접 배열 참조를 처리할 수 있을 때 사용됩니다.</li>
</ul>
</li>
</ul>
<p>특정 종류의 메모리 공유를 위한 플래그의 특수 조합.</p>
<ul>
<li><strong>다차원 (하지만 연속적)</strong>
<ul>
<li><code>PyBUF_CONTIG</code> (<code>PyBUF_ND</code> | <code>PyBUF_WRITABLE</code>)</li>
<li><code>PyBUF_CONTIG_RO</code> (<code>PyBUF_ND</code>)</li>
</ul>
</li>
<li><strong>스트라이드를 사용하지만 정렬된 다차원</strong>
<ul>
<li><code>PyBUF_STRIDED</code> (<code>PyBUF_STRIDES</code> | <code>PyBUF_WRITABLE</code>)</li>
<li><code>PyBUF_STRIDED_RO</code> (<code>PyBUF_STRIDES</code>)</li>
</ul>
</li>
<li><strong>스트라이드를 사용하고 반드시 정렬될 필요는 없는 다차원</strong>
<ul>
<li><code>PyBUF_RECORDS</code> (<code>PyBUF_STRIDES</code> | <code>PyBUF_WRITABLE</code> | <code>PyBUF_FORMAT</code>)</li>
<li><code>PyBUF_RECORDS_RO</code> (<code>PyBUF_STRIDES</code> | <code>PyBUF_FORMAT</code>)</li>
</ul>
</li>
<li><strong>하위 오프셋을 사용하는 다차원</strong>
<ul>
<li><code>PyBUF_FULL</code> (<code>PyBUF_INDIRECT</code> | <code>PyBUF_WRITABLE</code> | <code>PyBUF_FORMAT</code>)</li>
<li><code>PyBUF_FULL_RO</code> (<code>PyBUF_INDIRECT</code> | <code>PyBUF_FORMAT</code>)</li>
</ul>
</li>
</ul>
<p>따라서, 객체로부터 간단한 연속 바이트 청크를 원하는 소비자는 <code>PyBUF_SIMPLE</code>을 사용할 수 있으며, 가장 복잡한 경우를 활용할 줄 아는 소비자는 <code>PyBUF_FULL</code>을 사용할 수 있습니다.</p>
<p><code>PyBUF_FORMAT</code>이 <code>flag</code> 인수에 있는 경우에만 형식 정보가 <code>NULL</code>이 아님을 보장하며, 그렇지 않은 경우 소비자는 부호 없는 바이트(unsigned bytes)로 가정할 것으로 예상됩니다.</p>
<p>연속적인 "부호 없는 바이트" 메모리 청크만 내보낼 수 있는 내보내는 객체를 위해 제공된 플래그에 따라 버퍼 정보 구조체를 올바르게 채우는 데 사용할 수 있는 C-API가 있습니다.</p>
<h3><code>Py_buffer</code> 구조체 (The Py_buffer struct)</h3>
<p><code>bufferinfo</code> 구조체는 다음과 같습니다.</p>
<pre><code class="language-c">struct bufferinfo {
    void *buf;
    Py_ssize_t len;
    int readonly;
    const char *format;
    int ndim;
    Py_ssize_t *shape;
    Py_ssize_t *strides;
    Py_ssize_t *suboffsets;
    Py_ssize_t itemsize;
    void *internal;
} Py_buffer;
</code></pre>
<p><code>bf_getbuffer</code> 함수를 호출하기 전에 <code>bufferinfo</code> 구조체는 무엇이든 채워질 수 있지만, 새로운 버퍼를 요청할 때는 <code>buf</code> 필드가 <code>NULL</code>이어야 합니다. <code>bf_getbuffer</code>에서 반환되면 <code>bufferinfo</code> 구조체는 버퍼에 대한 관련 정보로 채워집니다. 이 동일한 <code>bufferinfo</code> 구조체는 소비자가 메모리 사용을 마쳤을 때 <code>bf_releasebuffer</code>(사용 가능한 경우)에 전달되어야 합니다. 호출자는 <code>releasebuffer</code>가 호출될 때까지 <code>obj</code>에 대한 참조를 유지할 책임이 있습니다 (즉, <code>bf_getbuffer</code> 호출은 <code>obj</code>의 참조 횟수를 변경하지 않습니다).</p>
<p><code>bufferinfo</code> 구조체의 멤버들은 다음과 같습니다.</p>
<ul>
<li><code>buf</code>
<ul>
<li>객체의 메모리 시작 부분에 대한 포인터입니다.</li>
</ul>
</li>
<li><code>len</code>
<ul>
<li>객체가 사용하는 총 메모리 바이트 수입니다. 이는 <code>shape</code> 배열과 항목당 바이트 수를 곱한 것과 같아야 합니다.</li>
</ul>
</li>
<li><code>readonly</code>
<ul>
<li>메모리가 읽기 전용인지 여부를 나타내는 정수 변수입니다. 1은 메모리가 읽기 전용임을 의미하고, 0은 메모리가 쓰기 가능함을 의미합니다.</li>
</ul>
</li>
<li><code>format</code>
<ul>
<li>메모리의 각 요소에 무엇이 들어있는지를 나타내는 <code>NULL</code>로 종료되는 형식 문자열(확장 기능을 포함한 <code>struct</code> 스타일 구문 따름)입니다. 요소의 수는 <code>len / itemsize</code>이며, <code>itemsize</code>는 형식에 의해 암시되는 바이트 수입니다. 이것은 <code>NULL</code>일 수 있으며, 이 경우 표준 부호 없는 바이트("B")를 의미합니다.</li>
</ul>
</li>
<li><code>ndim</code>
<ul>
<li>메모리가 나타내는 차원의 수를 저장하는 변수입니다. 0 이상이어야 합니다. 0 값은 <code>shape</code>, <code>strides</code>, <code>suboffsets</code>가 <code>NULL</code>이어야 함을 의미합니다 (즉, 메모리가 스칼라를 나타냅니다).</li>
</ul>
</li>
<li><code>shape</code>
<ul>
<li>메모리의 형상(shape)을 N차원 배열로 나타내는 <code>ndim</code> 길이의 <code>Py_ssize_t</code> 배열입니다. <code>((*shape)[0] * ... * (*shape)[ndims-1])*itemsize = len</code>에 유의하십시오. <code>ndim</code>이 0인 경우(스칼라를 나타냄) 이것은 <code>NULL</code>이어야 합니다.</li>
</ul>
</li>
<li><code>strides</code>
<ul>
<li><code>Py_ssize_t</code> 길이의 <code>ndim</code> 배열에 대한 포인터(또는 <code>ndim</code>이 0인 경우 <code>NULL</code>)로 채워질 <code>Py_ssize_t*</code> 변수의 주소입니다. 각 차원에서 다음 요소로 이동하기 위해 건너뛸 바이트 수를 나타냅니다. 호출자가 이를 요청하지 않으면 (<code>PyBUF_STRIDES</code>가 설정되지 않으면) <code>NULL</code>로 설정되어 C-스타일 연속 배열을 나타내거나, 불가능한 경우 <code>PyExc_BufferError</code>가 발생해야 합니다.</li>
</ul>
</li>
<li><code>suboffsets</code>
<ul>
<li><code>Py_ssize_t</code> 길이의 <code>*ndims</code> 배열에 대한 포인터로 채워질 <code>Py_ssize_t*</code> 변수의 주소입니다. 이 <code>suboffset</code> 숫자가 0 이상인 경우, 지정된 차원을 따라 저장된 값은 포인터이며 <code>suboffset</code> 값은 역참조(de-referencing) 후 포인터에 추가할 바이트 수를 지시합니다. 음수 <code>suboffset</code> 값은 역참조가 발생하지 않아야 함을 나타냅니다 (연속 메모리 블록 내에서 스트라이딩). 모든 <code>suboffset</code>이 음수인 경우 (즉, 역참조가 필요 없음) 이것은 <code>NULL</code>이어야 합니다 (기본값). 호출자가 이를 요청하지 않으면 (<code>PyBUF_INDIRECT</code>가 설정되지 않으면) <code>NULL</code>로 설정되거나, 불가능한 경우 <code>PyExc_BufferError</code>가 발생해야 합니다.</li>
</ul>
</li>
</ul>
<p>명확성을 위해, <code>strides</code>와 <code>suboffsets</code>가 모두 <code>NULL</code>이 아닐 때 N차원 인덱스가 가리키는 N차원 배열의 요소에 대한 포인터를 반환하는 함수는 다음과 같습니다.</p>
<pre><code class="language-c">void *get_item_pointer(int ndim, void *buf, Py_ssize_t *strides, Py_ssize_t *suboffsets, Py_ssize_t *indices) {
    char *pointer = (char*)buf;
    int i;
    for (i = 0; i &#x3C; ndim; i++) {
        pointer += strides[i] * indices[i];
        if (suboffsets[i] >=0 ) {
            pointer = *((char**)pointer) + suboffsets[i];
        }
    }
    return (void*)pointer;
}
</code></pre>
<p><code>suboffset</code>이 역참조 후에 추가된다는 점에 유의하십시오. 따라서 <code>i</code>번째 차원에서 슬라이싱(slicing)하면 <code>(i-1)</code>번째 차원의 <code>suboffsets</code>에 추가됩니다. 첫 번째 차원에서 슬라이싱하면 시작 포인터의 위치가 직접 변경됩니다 (즉, <code>buf</code>가 수정됩니다).</p>
<ul>
<li><code>itemsize</code>
<ul>
<li>공유 메모리의 각 요소의 <code>itemsize</code>(바이트 단위)를 저장하는 공간입니다. <code>PyBuffer_SizeFromFormat</code>을 사용하여 얻을 수 있으므로 기술적으로는 불필요하지만, 내보내는 객체는 형식 문자열을 파싱하지 않고도 이 정보를 알 수 있으며, 스트라이딩을 올바르게 해석하려면 <code>itemsize</code>를 알아야 합니다. 따라서 저장하는 것이 더 편리하고 빠릅니다.</li>
</ul>
</li>
<li><code>internal</code>
<ul>
<li>내보내는 객체가 내부적으로 사용하기 위한 것입니다. 예를 들어, 내보내는 객체가 이를 정수로 재캐스팅하여 버퍼가 해제될 때 <code>shape</code>, <code>strides</code>, <code>suboffsets</code> 배열을 해제해야 하는지에 대한 플래그를 저장하는 데 사용할 수 있습니다. 소비자는 이 값을 절대 변경해서는 안 됩니다.</li>
</ul>
</li>
</ul>
<p>내보내는 객체는 <code>buf</code>, <code>format</code>, <code>shape</code>, <code>strides</code>, <code>suboffsets</code>가 가리키는 모든 메모리가 <code>releasebuffer</code>가 호출될 때까지 유효한지 확인할 책임이 있습니다. 내보내는 객체가 <code>releasebuffer</code>가 호출되기 전에 객체의 <code>shape</code>, <code>strides</code>, 및/또는 <code>suboffsets</code>를 변경할 수 있기를 원한다면, <code>getbuffer</code>가 호출될 때 해당 배열을 할당하고 (제공된 버퍼 정보 구조체에서 이들을 가리키도록) <code>releasebuffer</code>가 호출될 때 해제해야 합니다.</p>
<h3>버퍼 해제 (Releasing the buffer)</h3>
<p>동일한 <code>bufferinfo</code> 구조체가 <code>release-buffer</code> 인터페이스 호출에 사용되어야 합니다. 호출자는 <code>Py_buffer</code> 구조체 자체의 메모리에 대한 책임이 있습니다.</p>
<pre><code class="language-c">typedef void (*releasebufferproc)(PyObject *obj, Py_buffer *view)
</code></pre>
<p><code>getbufferproc</code>의 호출자는 객체에서 이전에 획득한 메모리가 더 이상 필요하지 않을 때 이 함수가 호출되도록 해야 합니다. 인터페이스의 내보내는 객체는 <code>bufferinfo</code> 구조체에 포인터로 지정된 모든 메모리가 <code>releasebuffer</code>가 호출될 때까지 유효하게 유지되도록 해야 합니다.</p>
<p>만약 <code>bf_releasebuffer</code> 함수가 제공되지 않으면 (즉, <code>NULL</code>인 경우), 호출할 필요가 전혀 없습니다.</p>
<p>내보내는 객체는 <code>struct bufferinfo</code>를 통해 공유할 수 있는 메모리, <code>strides</code>, <code>shape</code>, <code>suboffsets</code> 또는 <code>format</code> 변수를 재할당할 수 있는 경우 <code>bf_releasebuffer</code> 함수를 정의해야 합니다. 얼마나 많은 <code>getbuffer</code> 호출이 이루어졌고 공유되었는지 추적하기 위해 여러 메커니즘을 사용할 수 있습니다. 단일 변수를 사용하여 내보내진 "뷰"의 수를 추적하거나, 각 객체에 채워진 <code>bufferinfo</code> 구조체의 연결 리스트를 유지할 수 있습니다.</p>
<p>하지만 내보내는 객체에 의해 특별히 요구되는 것은 <code>bufferinfo</code> 구조체를 통해 공유되는 모든 메모리가 해당 메모리를 내보내는 <code>bufferinfo</code> 구조체에 대해 <code>releasebuffer</code>가 호출될 때까지 유효하게 유지되도록 하는 것입니다.</p>
<h3>새로운 C-API 호출 제안 (New C-API calls are proposed)</h3>
<ul>
<li><code>int PyObject_CheckBuffer(PyObject *obj)</code>
<ul>
<li><code>getbuffer</code> 함수를 사용할 수 있으면 1을 반환하고, 그렇지 않으면 0을 반환합니다.</li>
</ul>
</li>
<li><code>int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)</code>
<ul>
<li><code>getbuffer</code> 함수 호출의 C-API 버전입니다. 객체가 필요한 함수 포인터를 가지고 있는지 확인하고 호출을 실행합니다. 실패 시 -1을 반환하고 오류를 발생시키며, 성공 시 0을 반환합니다.</li>
</ul>
</li>
<li><code>void PyBuffer_Release(PyObject *obj, Py_buffer *view)</code>
<ul>
<li><code>releasebuffer</code> 함수 호출의 C-API 버전입니다. 객체가 필요한 함수 포인터를 가지고 있는지 확인하고 호출을 실행합니다. 이 함수는 객체에 <code>releasebuffer</code> 함수가 없더라도 항상 성공합니다.</li>
</ul>
</li>
<li><code>PyObject *PyObject_GetMemoryView(PyObject *obj)</code>
<ul>
<li>버퍼 인터페이스를 정의하는 객체로부터 <code>memory-view</code> 객체를 반환합니다.</li>
</ul>
</li>
</ul>
<p><code>memory-view</code> 객체는 버퍼 객체를 대체할 수 있는 확장된 버퍼 객체입니다 (하지만 단순한 1차원 <code>memory-view</code> 객체로 유지될 수 있으므로 반드시 대체할 필요는 없습니다). 그 C-구조체는 다음과 같습니다.</p>
<pre><code class="language-c">typedef struct {
    PyObject_HEAD
    PyObject *base;
    Py_buffer view;
} PyMemoryViewObject;
</code></pre>
<p>이것은 <code>base</code>에 대한 참조가 유지되고 메모리 뷰가 다시 가져와지지 않는다는 점을 제외하면 현재 버퍼 객체와 기능적으로 유사합니다. 따라서 이 <code>memory-view</code> 객체는 삭제될 때까지 <code>base</code>의 메모리를 유지합니다.</p>
<p>이 <code>memory-view</code> 객체는 다차원 슬라이싱(multi-dimensional slicing)을 지원하며, Python에서 이를 수행하는 최초의 객체가 될 것입니다. <code>memory-view</code> 객체의 슬라이스는 동일한 <code>base</code>를 가지지만 <code>base</code> 객체에 대한 다른 뷰(view)를 가지는 다른 <code>memory-view</code> 객체입니다.</p>
<p><code>memory-view</code>에서 "요소"가 반환될 때마다 항상 <code>bytes</code> 객체이며, 그 형식은 <code>memoryview</code> 객체의 <code>format</code> 속성에 의해 해석되어야 합니다. 원한다면 <code>struct</code> 모듈을 사용하여 Python에서 바이트를 "디코딩"할 수 있습니다. 또는 내용을 NumPy 배열이나 버퍼 프로토콜을 사용하는 다른 객체에 전달할 수 있습니다.</p>
<p>Python 이름은 <code>__builtin__.memoryview</code>가 될 것입니다.</p>
<p>메서드:</p>
<ul>
<li><code>__getitem__</code> (다차원 슬라이싱 지원)</li>
<li><code>__setitem__</code> (다차원 슬라이싱 지원)</li>
<li><code>tobytes</code> (메모리 복사본의 새 <code>bytes</code> 객체를 얻음).</li>
<li><code>tolist</code> (메모리의 "중첩된" 리스트를 얻음. <code>struct</code> 모듈의 <code>unpack</code>이 하는 것처럼 모든 것이 표준 Python 객체로 해석됩니다. 실제로 이를 위해 <code>struct.unpack</code>을 사용합니다).</li>
</ul>
<p>속성 (<code>base</code> 객체의 메모리에서 가져옴):</p>
<ul>
<li>
<p><code>format</code></p>
</li>
<li>
<p><code>itemsize</code></p>
</li>
<li>
<p><code>shape</code></p>
</li>
<li>
<p><code>strides</code></p>
</li>
<li>
<p><code>suboffsets</code></p>
</li>
<li>
<p><code>readonly</code></p>
</li>
<li>
<p><code>ndim</code></p>
</li>
<li>
<p><code>Py_ssize_t PyBuffer_SizeFromFormat(const char *)</code></p>
<ul>
<li><code>struct</code> 스타일 설명에서 데이터 형식 영역의 암시된 <code>itemsize</code>를 반환합니다.</li>
</ul>
</li>
<li>
<p><code>PyObject * PyMemoryView_GetContiguous(PyObject *obj, int buffertype, char fortran)</code></p>
<ul>
<li><code>obj</code>로 표현되는 연속적인 메모리 청크에 대한 <code>memoryview</code> 객체를 반환합니다. 복사가 이루어져야 하는 경우 (<code>obj</code>가 가리키는 메모리가 연속적이지 않기 때문), 새로운 <code>bytes</code> 객체가 생성되어 반환된 <code>memory view</code> 객체의 <code>base</code> 객체가 됩니다.</li>
</ul>
</li>
</ul>
<p><code>buffertype</code> 인수는 반환된 버퍼가 읽기 가능, 쓰기 가능, 또는 복사가 이루어져야 하는 경우 원본 버퍼를 업데이트하도록 설정할지 여부를 결정하기 위해 <code>PyBUF_READ</code>, <code>PyBUF_WRITE</code>, <code>PyBUF_UPDATEIFCOPY</code>가 될 수 있습니다. <code>buffertype</code>이 <code>PyBUF_WRITE</code>이고 버퍼가 연속적이지 않으면 오류가 발생합니다. 이 경우 사용자는 <code>PyBUF_UPDATEIFCOPY</code>를 사용하여 쓰기 가능한 임시 연속 버퍼가 반환되도록 할 수 있습니다. 이 연속 버퍼의 내용은 <code>memoryview</code> 객체가 삭제된 후 원본 객체가 쓰기 가능한 한 원본 객체로 다시 복사됩니다. 이것이 원본 객체에 의해 허용되지 않으면 <code>BufferError</code>가 발생합니다.</p>
<p>객체가 다차원인 경우, <code>fortran</code>이 'F'이면 기본 배열의 첫 번째 차원이 버퍼에서 가장 빠르게 변합니다. <code>fortran</code>이 'C'이면 마지막 차원이 가장 빠르게 변합니다 (C-스타일 연속). <code>fortran</code>이 'A'이면 중요하지 않으며 객체가 더 효율적이라고 결정하는 것을 얻게 됩니다. 복사가 이루어지면 <code>PyMem_Free</code>를 호출하여 메모리를 해제해야 합니다.</p>
<p><code>memoryview</code> 객체에 대한 새로운 참조를 받습니다.</p>
<ul>
<li><code>int PyObject_CopyToObject(PyObject *obj, void *buf, Py_ssize_t len, char fortran)</code>
<ul>
<li><code>buf</code>가 가리키는 연속적인 메모리 청크가 가리키는 <code>len</code> 바이트의 데이터를 <code>obj</code>가 내보내는 버퍼로 복사합니다. 성공 시 0을 반환하고, 실패 시 -1을 반환하며 오류를 발생시킵니다. 객체가 쓰기 가능한 버퍼를 가지고 있지 않으면 오류가 발생합니다. <code>fortran</code>이 'F'이면, 객체가 다차원인 경우 데이터는 Fortran-스타일(첫 번째 차원이 가장 빠르게 변함)로 배열에 복사됩니다. <code>fortran</code>이 'C'이면 데이터는 C-스타일(마지막 차원이 가장 빠르게 변함)로 배열에 복사됩니다. <code>fortran</code>이 'A'이면 중요하지 않으며 가장 효율적인 방식으로 복사가 이루어집니다.</li>
</ul>
</li>
<li><code>int PyObject_CopyData(PyObject *dest, PyObject *src)</code>
<ul>
<li>이 마지막 세 가지 C-API 호출은 데이터가 실제로 어떻게 저장되어 있든 상관없이 Python 객체에서 연속적인 메모리 영역으로 데이터를 가져오고 내보내는 표준적인 방법을 허용합니다. 이 호출들은 확장된 버퍼 인터페이스를 사용하여 작업을 수행합니다.</li>
</ul>
</li>
<li><code>int PyBuffer_IsContiguous(Py_buffer *view, char fortran)</code>
<ul>
<li><code>view</code> 객체에 의해 정의된 메모리가 C-스타일 (<code>fortran</code> = 'C') 또는 Fortran-스타일 (<code>fortran</code> = 'F') 연속적이거나 둘 중 하나 (<code>fortran</code> = 'A')이면 1을 반환합니다. 그렇지 않으면 0을 반환합니다.</li>
</ul>
</li>
<li><code>void PyBuffer_FillContiguousStrides(int ndim, Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t itemsize, char fortran)</code>
<ul>
<li>주어진 형상(shape)과 요소당 바이트 수(itemsize)를 가진 연속적인 배열(C-스타일, <code>fortran</code>이 'C'이면, 또는 Fortran-스타일, <code>fortran</code>이 'F'이면)의 바이트-스트라이드로 <code>strides</code> 배열을 채웁니다.</li>
</ul>
</li>
<li><code>int PyBuffer_FillInfo(Py_buffer *view, void *buf, Py_ssize_t len, int readonly, int infoflags)</code>
<ul>
<li>주어진 길이의 "부호 없는 바이트" 연속 메모리 청크만 공유할 수 있는 내보내는 객체를 위해 <code>buffer-info</code> 구조체를 올바르게 채웁니다. 성공 시 0을 반환하고, 오류 시 -1을 반환합니다 (오류 발생 포함).</li>
</ul>
</li>
<li><code>PyExc_BufferError</code>
<ul>
<li>내보내는 객체가 소비자가 기대하는 종류의 버퍼를 제공할 수 없기 때문에 발생하는 버퍼 오류를 반환하기 위한 새로운 오류 객체입니다. 이 오류는 소비자가 프로토콜을 제공하지 않는 객체로부터 버퍼를 요청할 때도 발생합니다.</li>
</ul>
</li>
</ul>
<h3><code>struct</code> 문자열 구문 추가 사항 (<code>Additions to the struct string-syntax</code>)</h3>
<p><code>struct</code> 문자열 구문에는 이미 다른 곳(예: <code>ctypes</code> 및 NumPy)에서 사용할 수 있는 데이터 형식 설명(data-format descriptions)을 완전히 구현하기 위한 일부 문자가 누락되어 있습니다. Python 2.5 사양은 <a href="http://docs.python.org/library/struct.html">http://docs.python.org/library/struct.html</a>에 있습니다.</p>
<p>다음은 제안된 추가 사항입니다.</p>
<p>| 문자 | 설명                                                    |
| :--- | :------------------------------------------------------ |
| <code>'t'</code>  | 비트 (앞에 붙는 숫자가 몇 비트인지 나타냄)                  |
| <code>'?'</code>  | 플랫폼 <code>_Bool</code> 타입                                     |
| <code>'g'</code>  | <code>long double</code>                                          |
| <code>'c'</code>  | <code>ucs-1</code> (latin-1) 인코딩                                |
| <code>'u'</code>  | <code>ucs-2</code>                                                |
| <code>'w'</code>  | <code>ucs-4</code>                                                |
| <code>'O'</code>  | Python 객체에 대한 포인터                               |
| <code>'Z'</code>  | 복소수 (다음 지정자가 무엇이든)                          |
| <code>'&#x26;'</code>  | 특정 포인터 (다른 문자 앞에 붙는 접두사)                  |
| <code>'T{}'</code>| 구조체 (내부에 상세 레이아웃 포함 {})                     |
| <code>'(k1,k2,…,kn)'</code>| 다음에 오는 무엇이든의 다차원 배열                  |
| <code>':name:'</code>| 이전 요소의 선택적 이름                               |
| <code>'X{}'</code>| 함수에 대한 포인터 (선택적 함수 시그니처 내부에 {} 포함, 반환 값은 <code>-></code> 뒤에 붙고 끝에 위치) |</p>
<p><code>struct</code> 모듈도 이러한 것들을 이해하고 언팩(unpacking) 시 적절한 Python 객체를 반환하도록 변경될 것입니다. <code>long-double</code>을 언팩하면 <code>decimal</code> 객체 또는 <code>ctypes</code> <code>long-double</code>이 반환됩니다. <code>'u'</code> 또는 <code>'w'</code>를 언팩하면 Python <code>unicode</code>가 반환됩니다. 다차원 배열을 언팩하면 리스트(1차원 이상인 경우 리스트의 리스트)가 반환됩니다. 포인터를 언팩하면 <code>ctypes</code> 포인터 객체가 반환됩니다. 함수 포인터를 언팩하면 <code>ctypes</code> <code>call-object</code>가 반환될 것입니다. 비트(bit)를 언팩하면 Python <code>Bool</code>이 반환됩니다. <code>struct</code> 문자열 구문 내의 공백은 이미 무시되지 않는다면 무시될 것입니다. 명명된 객체(named-object)를 언팩하면 튜플처럼 작동하지만 항목에 이름으로도 접근할 수 있는 <code>named-tuple</code>과 유사한 객체가 반환됩니다. 중첩된 구조체를 언팩하면 중첩된 튜플이 반환됩니다.</p>
<p>바이트 순서(Endian-specification) (<code>!</code>, <code>@</code>, <code>=</code>, <code>></code>, <code>&#x3C;</code>, <code>^</code>)도 문자열 내에서 허용되므로 필요에 따라 변경될 수 있습니다. 이전에 지정된 바이트 순서 문자열은 변경될 때까지 유효합니다. 기본 바이트 순서는 '@'이며, 이는 네이티브 데이터 타입과 정렬을 의미합니다. 정렬되지 않은 네이티브 데이터 타입이 요청되면 바이트 순서 지정은 '^'입니다.</p>
<p><code>struct</code> 모듈에 따르면, 숫자 코드 앞에 숫자가 붙어 해당 타입의 개수를 지정할 수 있습니다. <code>(k1,k2,...,kn)</code> 확장 기능은 데이터가 특정 형식의 (C-스타일 연속, 마지막 차원이 가장 빠르게 변함) 다차원 배열로 보여져야 하는지 여부도 지정할 수 있도록 합니다.</p>
<p><code>ctypes</code>에 <code>struct</code> 설명으로부터 <code>ctypes</code> 객체를 생성하고, <code>long-double</code> 및 <code>ucs-2</code>를 <code>ctypes</code>에 추가하는 함수가 추가되어야 합니다.</p>
<h3>데이터 형식 설명 예시 (Examples of Data-Format Descriptions)</h3>
<p>다음은 C-구조체의 예시와 <code>struct</code> 스타일 구문을 사용하여 어떻게 표현될 수 있는지 보여줍니다.</p>
<p><code>&#x3C;named></code>는 명명된 튜플(아직 지정되지 않음)의 생성자입니다.</p>
<ul>
<li>
<p><code>float</code> <code>'d'</code> &#x3C;–> Python <code>float</code></p>
</li>
<li>
<p><code>complex double</code> <code>'Zd'</code> &#x3C;–> Python <code>complex</code></p>
</li>
<li>
<p><code>RGB Pixel data</code> <code>'BBB'</code> &#x3C;–> <code>(int, int, int)</code></p>
<ul>
<li><code>'B:r: B:g: B:b:'</code> &#x3C;–> <code>&#x3C;named>((int, int, int), ('r','g','b'))</code></li>
</ul>
</li>
<li>
<p><code>Mixed endian</code> (이상하지만 가능) <code>'>i:big: &#x3C;i:little:'</code> &#x3C;–> <code>&#x3C;named>((int, int), ('big', 'little'))</code></p>
</li>
<li>
<p><strong>중첩된 구조체</strong></p>
<pre><code class="language-c">struct {
    int ival;
    struct {
        unsigned short sval;
        unsigned char bval;
        unsigned char cval;
    } sub;
}
"""i:ival: T{ H:sval: B:bval: B:cval: }:sub: """
</code></pre>
</li>
<li>
<p><strong>중첩된 배열</strong></p>
<pre><code class="language-c">struct {
    int ival;
    double data[16*4];
}
"""i:ival: (16,4)d:data: """
</code></pre>
</li>
</ul>
<p>마지막 예시에서 비교되는 C-구조체는 의도적으로 2차원 배열 <code>data[16][4]</code>가 아닌 1차원 배열입니다. 이는 C의 정적 다차원 배열(연속적으로 배치됨)과 <code>data[0][1]</code>와 동일한 구문을 사용하여 요소에 접근하지만 메모리가 반드시 연속적이지는 않은 동적 다차원 배열 간의 혼동을 피하기 위함입니다. <code>struct</code> 구문은 항상 연속적인 메모리를 사용하며, 다차원 문자는 내보내는 객체가 소비자에게 전달할 메모리에 대한 정보입니다.</p>
<p>다시 말해, <code>struct</code> 구문 설명은 동일한 메모리 레이아웃을 설명하는 한 C-구문과 정확히 일치할 필요는 없습니다. C-컴파일러가 메모리를 <code>double</code>형 1차원 배열로 생각할 것이라는 사실은 내보내는 객체가 소비자에게 이 메모리 필드를 4개 요소마다 새로운 차원이 고려되는 2차원 배열로 생각해야 한다고 전달하려는 사실과 무관합니다.</p>
<h3>영향을 받는 코드 (Code to be affected)</h3>
<p>이전 버퍼 인터페이스를 내보내거나 사용하는 Python의 모든 객체와 모듈이 수정될 것입니다. 다음은 부분적인 목록입니다.</p>
<ul>
<li><code>buffer</code> 객체</li>
<li><code>bytes</code> 객체</li>
<li><code>string</code> 객체</li>
<li><code>unicode</code> 객체</li>
<li><code>array</code> 모듈</li>
<li><code>struct</code> 모듈</li>
<li><code>mmap</code> 모듈</li>
<li><code>ctypes</code> 모듈</li>
</ul>
<p>버퍼 API를 사용하는 다른 모든 것.</p>
<h3>문제 및 세부 사항 (Issues and Details)</h3>
<p>이 PEP는 기존 버퍼 프로토콜에 C-API와 두 가지 함수를 추가하여 Python 2.6으로 백포팅(back-ported)될 예정입니다.</p>
<p>이 PEP의 이전 버전에서는 읽기/쓰기 잠금(read/write locking) 체계를 제안했지만, 나중에 다음과 같이 인식되었습니다.
a) 잠금이 필요 없는 일반적인 간단한 사용 사례에는 너무 복잡하고,
b) 변경되고 짧게 유지되는 잠금을 사용하여 버퍼에 대한 동시 읽기/쓰기 접근이 필요한 사용 사례에는 너무 간단하다고 판단되었습니다.
따라서 동시 읽기/쓰기 접근에서 일관된 뷰(consistent views)가 필요한 경우 사용자가 버퍼 객체 주변에 자체적인 특정 잠금 체계를 구현하도록 맡겨져 있습니다. 이러한 사용자 체계에 대한 경험이 축적된 후에는 별도의 잠금 API를 포함하는 미래의 PEP가 제안될 수 있습니다.</p>
<p>스트라이드 메모리(strided memory)와 하위 오프셋(suboffsets)의 공유는 새로운 기능이며, 다중 세그먼트 인터페이스의 수정으로 볼 수 있습니다. 이는 NumPy와 PIL에서 영감을 받았습니다. NumPy 객체는 스트라이드 메모리를 관리하는 방법을 이해하는 코드와 스트라이드 메모리를 공유할 수 있어야 합니다. 왜냐하면 스트라이드 메모리는 계산 라이브러리와 인터페이스할 때 매우 흔하기 때문입니다.</p>
<p>또한, 이 접근 방식을 사용하면 복사 없이 두 가지 종류의 메모리 모두에서 작동하는 일반적인 코드를 작성할 수 있어야 합니다.</p>
<p><code>bufferinfo</code> 구조체의 <code>format</code> 문자열, <code>shape</code> 배열, <code>strides</code> 배열, <code>suboffsets</code> 배열의 메모리 관리는 항상 내보내는 객체의 책임입니다. 소비자는 이러한 포인터를 다른 메모리로 설정하거나 해제하려고 시도해서는 안 됩니다.</p>
<p>몇 가지 아이디어가 논의되었고 거부되었습니다.</p>
<ul>
<li><code>release-buffer</code>가 호출되는 "releaser" 객체를 두는 것. 이것은 프로토콜을 비대칭적으로 만들었기 때문에 (버퍼를 "얻은" 것과 다른 것에 대해 해제를 호출했음) 받아들일 수 없다고 판단되었습니다. 또한 실제 이점 없이 프로토콜을 복잡하게 만들었습니다.</li>
<li>모든 <code>struct</code> 변수를 함수에 별도로 전달하는 것. 이것은 관심 없는 변수에 <code>NULL</code>을 설정할 수 있다는 장점이 있었지만, 함수 호출을 더 어렵게 만들었습니다. <code>flags</code> 변수는 소비자가 프로토콜을 호출하는 방식에서 "간단"할 수 있는 동일한 기능을 허용합니다.</li>
</ul>
<h3>코드 (Code)</h3>
<p>PEP 작성자들은 이 제안에 대한 코드를 기여하고 유지 관리할 것을 약속하지만, 어떠한 도움도 환영할 것입니다.</p>
<h3>코드 예시 (Code Examples)</h3>
<h4>예시 1 (Ex. 1)</h4>
<p>이 예시는 연속적인 라인을 사용하는 이미지 객체가 버퍼를 어떻게 노출할 수 있는지를 보여줍니다.</p>
<pre><code class="language-c">struct rgba {
    unsigned char r, g, b, a;
};
struct ImageObject {
    PyObject_HEAD;
    ...
    struct rgba** lines;
    Py_ssize_t height;
    Py_ssize_t width;
    Py_ssize_t shape_array[2];
    Py_ssize_t stride_array[2];
    Py_ssize_t view_count;
};
</code></pre>
<p><code>"lines"</code>는 <code>malloc</code>으로 할당된 <code>struct rgba*</code>의 1차원 배열을 가리킵니다. 해당 블록의 각 포인터는 별도로 <code>malloc</code>으로 할당된 <code>struct rgba</code> 배열을 가리킵니다.</p>
<p>예를 들어, <code>x=30, y=50</code>에 있는 픽셀의 빨간색 값에 접근하려면 <code>"lines[50][30].r"</code>을 사용합니다.</p>
<p>그렇다면 <code>ImageObject</code>의 <code>getbuffer</code>는 무엇을 할까요? 오류 검사를 제외하면 다음과 같습니다.</p>
<pre><code class="language-c">int Image_getbuffer(PyObject *self, Py_buffer *view, int flags) {
    static Py_ssize_t suboffsets[2] = { 0, -1};
    view->buf = self->lines;
    view->len = self->height*self->width;
    view->readonly = 0;
    view->ndims = 2;
    self->shape_array[0] = height;
    self->shape_array[1] = width;
    view->shape = &#x26;self->shape_array;
    self->stride_array[0] = sizeof(struct rgba*);
    self->stride_array[1] = sizeof(struct rgba);
    view->strides = &#x26;self->stride_array;
    view->suboffsets = suboffsets;
    self->view_count ++;
    return 0;
}
int Image_releasebuffer(PyObject *self, Py_buffer *view) {
    self->view_count--;
    return 0;
}
</code></pre>
<h4>예시 2 (Ex. 2)</h4>
<p>이 예시는 (객체가 살아있는 동안에는 재할당되지 않는) 연속적인 메모리 청크를 노출하려는 객체가 이를 어떻게 수행하는지 보여줍니다.</p>
<pre><code class="language-c">int myobject_getbuffer(PyObject *self, Py_buffer *view, int flags) {
    void *buf;
    Py_ssize_t len;
    int readonly=0;
    buf = /* Point to buffer */
    len = /* Set to size of buffer */
    readonly = /* Set to 1 if readonly */
    return PyObject_FillBufferInfo(view, buf, len, readonly, flags);
}
/* No releasebuffer is necessary because the memory will never be re-allocated */
</code></pre>
<h4>예시 3 (Ex. 3)</h4>
<p>Python 객체 <code>obj</code>에서 간단한 연속 바이트 청크만 얻고 싶은 소비자는 다음을 수행합니다.</p>
<pre><code class="language-c">Py_buffer view;
int ret;
if (PyObject_GetBuffer(obj, &#x26;view, Py_BUF_SIMPLE) &#x3C; 0) {
    /* error return */
}
/* Now, view.buf is the pointer to memory
   view.len is the length
   view.readonly is whether or not the memory is read-only. */
/* After using the information and you don't need it anymore */
if (PyBuffer_Release(obj, &#x26;view) &#x3C; 0) {
    /* error return */
}
</code></pre>
<h4>예시 4 (Ex. 4)</h4>
<p>어떤 객체의 메모리도 사용할 수 있지만 연속적인 메모리만 처리하는 알고리즘을 작성하는 소비자는 다음을 수행할 수 있습니다.</p>
<pre><code class="language-c">void *buf;
Py_ssize_t len;
char *format;
int copy;
copy = PyObject_GetContiguous(obj, &#x26;buf, &#x26;len, &#x26;format, 0, 'A');
if (copy &#x3C; 0) {
    /* error return */
}
/* process memory pointed to by buffer if format is correct */
/* Optional: if, after processing, we want to copy data from buffer back into the object we could do */
if (PyObject_CopyToObject(obj, buf, len, 'A') &#x3C; 0) {
    /* error return */
}
/* Make sure that if a copy was made, the memory is freed */
if (copy == 1) PyMem_Free(buf);
</code></pre>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-aecaf5ac7a84facf.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-e3ea38185bb36cd2.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/3118\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"x02Anhkwgp1He7ftuyAhh\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/3118/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/3118\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"3118\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/3118\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:Tbfc9,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-3118/\"\u003ePEP 3118 - Revising the buffer protocol\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 28-Aug-2006\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 3118 – 버퍼 프로토콜 재설계 (Revising the buffer protocol)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Travis Oliphant, Carl Banks\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2006년 8월 28일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.0\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e최종 수정일:\u003c/strong\u003e 2025년 2월 14일\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e중요:\u003c/strong\u003e 이 PEP는 역사적인 문서입니다. 최신 공식 문서는 \u003ca href=\"https://docs.python.org/3/c-api/buffer.html\"\u003eBuffer Protocol\u003c/a\u003e, \u003ca href=\"https://docs.python.org/3/c-api/typeobj.html#c.PyBufferProcs\"\u003ePyBufferProcs\u003c/a\u003e, \u003ca href=\"https://docs.python.org/3/c-api/memory.html#c.PyMemoryView_FromObject\"\u003ePyMemoryView_FromObject\u003c/a\u003e에서 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP에서 제안된 모든 기능이 구현된 것은 아닙니다. 특히:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyObject_CopyToObject\u003c/code\u003e는 추가되지 않았습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estruct\u003c/code\u003e 문자열 구문 추가 사항 중 \u003ccode\u003e?\u003c/code\u003e (\u003ccode\u003e_Bool\u003c/code\u003e)를 제외한 나머지는 추가되지 않았습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject_GetMemoryView\u003c/code\u003e는 \u003ccode\u003ePyMemoryView_FromObject\u003c/code\u003e로 이름이 변경되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 PEP는 10년도 더 전에 출시된 Python 3.0을 대상으로 합니다. 누락된 기능을 추가하려는 모든 제안은 이 PEP의 구현을 완료하는 것이 아니라 새로운 기능으로 논의되어야 합니다.\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 Python 3.0에서 메모리 공유 방식을 개선하기 위해 버퍼 인터페이스(PyBufferProcs 함수 포인터)를 재설계할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e특히, API의 문자 버퍼(character buffer) 부분을 없애고, 여러 세그먼트(multiple-segment) 부분을 스트라이드(strided) 메모리 공유와 연계하여 재설계하는 것이 제안됩니다. 또한, 새로운 버퍼 인터페이스는 메모리의 다차원적 특성과 메모리가 포함하는 데이터 형식(data-format)을 공유할 수 있도록 할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 인터페이스는 모든 확장 모듈(extension module)이 메모리를 공유하는 객체를 생성하거나, 인터페이스를 내보내는 임의의 객체에서 원시 메모리(raw memory)를 사용하고 조작하는 알고리즘을 생성할 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003e도입 배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003ePython 2.X 버퍼 프로토콜은 다른 Python 타입들이 내부 버퍼 시퀀스에 대한 포인터를 교환할 수 있도록 합니다. 이 기능은 서로 다른 고수준 객체들 간에 큰 메모리 세그먼트를 공유하는 데 매우 유용하지만, 너무 제한적이며 다음과 같은 문제가 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e잘 사용되지 않는 \"세그먼트 시퀀스\" 옵션(\u003ccode\u003ebf_getsegcount\u003c/code\u003e)이 있으며, 그 동기가 명확하지 않습니다.\u003c/li\u003e\n\u003cli\u003e겉보기에 중복되는 문자 버퍼 옵션(\u003ccode\u003ebf_getcharbuffer\u003c/code\u003e)이 있습니다.\u003c/li\u003e\n\u003cli\u003e소비자(consumer)가 버퍼 API를 내보내는 객체에 메모리 보기를 \"다 사용했다\"고 알릴 방법이 없으므로, 내보내는 객체가 자신이 소유한 메모리에 대한 포인터를 재할당하는 것이 안전하다고 확신할 방법이 없습니다. (예: \u003ccode\u003earray\u003c/code\u003e 객체가 원본 포인터를 가지고 있던 버퍼 객체와 메모리를 공유한 후 메모리를 재할당하여 악명 높은 버퍼 객체 문제를 일으켰습니다.)\u003c/li\u003e\n\u003cli\u003e메모리는 단순히 길이(length)를 가진 포인터일 뿐입니다. 메모리 \"안에 무엇이 있는지\"(float, int, C-구조체 등)를 설명할 방법이 없습니다.\u003c/li\u003e\n\u003cli\u003e메모리에 대한 형상(shape) 정보가 제공되지 않습니다. 하지만 여러 배열과 유사한 Python 타입(wxPython, GTK, pyQT, CVXOPT, PyVox, Audio and Video Libraries, ctypes, NumPy, 데이터베이스 인터페이스 등)은 메모리의 형상 해석(shape-interpretation)을 설명하는 표준적인 방법을 활용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e비연속적인 메모리(discontiguous memory)를 공유할 방법이 없습니다 (세그먼트 시퀀스 개념을 통하는 경우 제외).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e비연속적인 메모리 개념을 사용하는 두 가지 널리 사용되는 라이브러리는 PIL과 NumPy입니다. 하지만 이들의 비연속 배열에 대한 관점은 다릅니다. 제안된 버퍼 인터페이스는 두 가지 메모리 모델 모두의 공유를 허용합니다. 내보내는 객체(Exporter)는 일반적으로 한 가지 접근 방식만 사용할 것이며, 소비자는 각 유형의 비연속 배열을 지원할지 여부를 선택할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eNumPy는 각 차원에서 상수 스트라이딩(constant striding) 개념을 배열의 기본 개념으로 사용합니다. 이 개념을 통해 더 큰 배열의 간단한 하위 영역을 데이터를 복사하지 않고도 설명할 수 있습니다. 따라서 스트라이드 정보는 공유되어야 하는 추가 정보입니다.\u003c/p\u003e\n\u003cp\u003ePIL은 더 불투명한 메모리 표현을 사용합니다. 때로는 이미지가 연속적인 메모리 세그먼트에 포함되지만, 때로는 이미지의 연속적인 세그먼트(일반적으로 라인)에 대한 포인터 배열에 포함됩니다. PIL은 원래 버퍼 인터페이스에서 여러 버퍼 세그먼트 개념이 유래한 곳입니다.\u003c/p\u003e\n\u003cp\u003eNumPy의 스트라이드 메모리 모델은 계산 라이브러리에서 더 자주 사용되며, 그 단순성 때문에 이 모델을 사용한 메모리 공유를 지원하는 것이 합리적입니다. PIL 메모리 모델은 C-코드에서 2차원 배열을 이중 포인터 간접 참조(e.g. \u003ccode\u003eimage[i][j]\u003c/code\u003e)를 사용하여 접근할 수 있을 때 사용되기도 합니다.\u003c/p\u003e\n\u003cp\u003e버퍼 인터페이스는 객체가 이 두 가지 메모리 모델 중 하나를 내보낼 수 있도록 허용해야 합니다. 소비자는 연속적인 메모리를 요구하거나, 이 두 가지 메모리 모델 중 하나 또는 둘 다를 처리하는 코드를 자유롭게 작성할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e제안 개요 (Proposal Overview)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e버퍼 프로토콜의 문자 버퍼(char-buffer) 및 다중 세그먼트(multiple-segment) 섹션을 제거합니다.\u003c/li\u003e\n\u003cli\u003e버퍼를 가져오는 읽기/쓰기 버전을 통합합니다.\u003c/li\u003e\n\u003cli\u003e소비자 객체가 메모리 영역을 \"다 사용했을\" 때 호출되어야 하는 새로운 함수를 인터페이스에 추가합니다.\u003c/li\u003e\n\u003cli\u003e메모리에 무엇이 있는지 설명할 수 있도록 새로운 변수를 추가합니다 (현재 \u003ccode\u003estruct\u003c/code\u003e 및 \u003ccode\u003earray\u003c/code\u003e 모듈에서 수행되는 작업을 통합).\u003c/li\u003e\n\u003cli\u003e프로토콜이 형상(shape) 정보를 공유할 수 있도록 새로운 변수를 추가합니다.\u003c/li\u003e\n\u003cli\u003e스트라이드(stride) 정보를 공유하기 위한 새로운 변수를 추가합니다.\u003c/li\u003e\n\u003cli\u003e포인터 간접 참조(pointer indirection)를 사용하여 접근해야 하는 배열을 공유하기 위한 새로운 메커니즘을 추가합니다.\u003c/li\u003e\n\u003cli\u003e핵심(core) 및 표준 라이브러리(standard library)의 모든 객체가 새 인터페이스를 따르도록 수정합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estruct\u003c/code\u003e 모듈을 확장하여 더 많은 형식 지정자(format specifiers)를 처리할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003e버퍼 객체(buffer object)를 버퍼 인터페이스 위에 Python  veneer를 씌운 새로운 메모리 객체(memory object)로 확장합니다.\u003c/li\u003e\n\u003cli\u003e버퍼 인터페이스를 지원하는 객체에서 연속적인 데이터(contiguous data)를 쉽게 복사하고 가져올 수 있도록 몇 가지 함수를 추가합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003cp\u003e새로운 사양은 복잡한 메모리 공유를 허용하지만, 객체로부터 간단한 연속 바이트 버퍼를 여전히 얻을 수 있습니다. 사실, 새로운 프로토콜은 원본 객체가 연속적인 메모리 청크로 표현되지 않더라도 이를 수행하는 표준 메커니즘을 허용합니다.\u003c/p\u003e\n\u003cp\u003e가장 쉬운 방법은 제공된 C-API를 사용하여 메모리 청크를 얻는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyBufferProcs\u003c/code\u003e 구조체를 다음과 같이 변경합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct {\r\n    getbufferproc bf_getbuffer;\r\n    releasebufferproc bf_releasebuffer;\r\n} PyBufferProcs;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 두 루틴은 타입 객체(type object)에 대해 선택 사항입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef int (*getbufferproc)(PyObject *obj, PyBuffer *view, int flags)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 성공 시 0을 반환하고 실패 시 -1을 반환합니다 (그리고 오류를 발생시킵니다). 첫 번째 변수는 \"내보내는(exporting)\" 객체입니다. 두 번째 인수는 \u003ccode\u003ebufferinfo\u003c/code\u003e 구조체의 주소입니다. 두 인수 모두 \u003ccode\u003eNULL\u003c/code\u003e이어서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e세 번째 인수는 소비자가 처리할 준비가 된 버퍼의 종류와 따라서 내보내는 객체가 반환할 수 있는 버퍼의 종류를 나타냅니다. 새로운 버퍼 인터페이스는 훨씬 더 복잡한 메모리 공유 가능성을 허용합니다. 일부 소비자는 모든 복잡성을 처리하지 못할 수 있지만, 내보내는 객체가 메모리에 대한 더 간단한 보기를 허용하는지 확인하고 싶을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, 일부 내보내는 객체는 모든 가능한 방식으로 메모리를 공유할 수 없으며, 일부 소비자에게 특정 작업이 불가능하다고 알리기 위해 오류를 발생시켜야 할 수도 있습니다. 이러한 오류는 실제로 문제를 일으키는 다른 오류가 없는 한 \u003ccode\u003ePyErr_BufferError\u003c/code\u003e여야 합니다. 내보내는 객체는 \u003ccode\u003eflags\u003c/code\u003e 정보를 사용하여 \u003ccode\u003ePyBuffer\u003c/code\u003e 구조체의 얼마나 많은 요소가 기본값 이외의 값으로 채워지는지 단순화하거나, 객체가 메모리에 대한 더 간단한 보기를 지원할 수 없는 경우 오류를 발생시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e내보내는 객체는 항상 버퍼 구조체의 모든 요소를 채워야 합니다 (요청된 것이 없으면 기본값 또는 \u003ccode\u003eNULL\u003c/code\u003e로). \u003ccode\u003ePyBuffer_FillInfo\u003c/code\u003e 함수는 간단한 경우에 사용될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e접근 플래그 (Access flags)\u003c/h3\u003e\n\u003cp\u003e일부 플래그는 특정 종류의 메모리 세그먼트를 요청하는 데 유용하며, 다른 플래그는 소비자가 어떤 종류의 정보를 처리할 수 있는지 내보내는 객체에 알려줍니다. 만약 특정 정보가 소비자에 의해 요청되지 않았지만, 내보내는 객체가 그 정보 없이는 메모리를 공유할 수 없다면, \u003ccode\u003ePyErr_BufferError\u003c/code\u003e가 발생해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_SIMPLE\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e이것이 기본 플래그 상태(0)입니다. 반환된 버퍼는 쓰기 가능한 메모리를 가질 수도 있고 가지지 않을 수도 있습니다. 형식은 부호 없는 바이트(unsigned bytes)로 가정됩니다. 이것은 \"독립적인(stand-alone)\" 플래그 상수입니다. 다른 플래그와 \u003ccode\u003e|\u003c/code\u003e로 연결할 필요가 없습니다. 내보내는 객체는 이러한 연속적인 바이트 버퍼를 제공할 수 없으면 오류를 발생시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_WRITABLE\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e반환된 버퍼는 쓰기 가능해야 합니다. 쓰기 가능하지 않으면 오류를 발생시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_FORMAT\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e이 플래그가 제공되면 반환된 버퍼는 진정한 형식 정보를 가져야 합니다. 이것은 소비자가 실제로 저장된 데이터의 '종류'를 확인할 때 사용됩니다. 내보내는 객체는 요청 시 항상 이 정보를 제공할 수 있어야 합니다. 형식이 명시적으로 요청되지 않으면 형식은 \u003ccode\u003eNULL\u003c/code\u003e로 반환되어야 합니다 (이는 \"B\", 즉 부호 없는 바이트를 의미합니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_ND\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e반환된 버퍼는 형상(shape) 정보를 제공해야 합니다. 메모리는 C-스타일 연속(C-style contiguous)으로 가정됩니다 (마지막 차원이 가장 빠르게 변함). 내보내는 객체는 이러한 종류의 연속 버퍼를 제공할 수 없으면 오류를 발생시킬 수 있습니다. 이것이 주어지지 않으면 \u003ccode\u003eshape\u003c/code\u003e는 \u003ccode\u003eNULL\u003c/code\u003e이 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_STRIDES\u003c/code\u003e ( \u003ccode\u003ePyBUF_ND\u003c/code\u003e를 암시)\n\u003cul\u003e\n\u003cli\u003e반환된 버퍼는 스트라이드(strides) 정보를 제공해야 합니다 (즉, \u003ccode\u003estrides\u003c/code\u003e는 \u003ccode\u003eNULL\u003c/code\u003e이 아니어야 합니다). 이것은 소비자가 스트라이드된(strided), 비연속적인 배열을 처리할 수 있을 때 사용됩니다. 스트라이드를 처리하는 것은 자동으로 형상(shape)을 처리할 수 있다고 가정합니다. 내보내는 객체는 (하위 오프셋(suboffsets) 없이) 데이터의 스트라이드된 표현만 제공할 수 없으면 오류를 발생시킬 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_C_CONTIGUOUS\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_F_CONTIGUOUS\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_ANY_CONTIGUOUS\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e이 플래그들은 반환된 버퍼가 각각 C-연속(C-contiguous, 마지막 차원이 가장 빠르게 변함), Fortran-연속(Fortran contiguous, 첫 번째 차원이 가장 빠르게 변함) 또는 둘 중 하나여야 함을 나타냅니다. 이 모든 플래그는 \u003ccode\u003ePyBUF_STRIDES\u003c/code\u003e를 암시하며, \u003ccode\u003estrides\u003c/code\u003e 버퍼 정보 구조체가 올바르게 채워질 것을 보장합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_INDIRECT\u003c/code\u003e ( \u003ccode\u003ePyBUF_STRIDES\u003c/code\u003e를 암시)\n\u003cul\u003e\n\u003cli\u003e반환된 버퍼는 하위 오프셋(suboffsets) 정보를 가져야 합니다 (하위 오프셋이 필요하지 않은 경우 \u003ccode\u003eNULL\u003c/code\u003e일 수 있습니다). 이것은 소비자가 이러한 하위 오프셋이 암시하는 간접 배열 참조를 처리할 수 있을 때 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e특정 종류의 메모리 공유를 위한 플래그의 특수 조합.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e다차원 (하지만 연속적)\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_CONTIG\u003c/code\u003e (\u003ccode\u003ePyBUF_ND\u003c/code\u003e | \u003ccode\u003ePyBUF_WRITABLE\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_CONTIG_RO\u003c/code\u003e (\u003ccode\u003ePyBUF_ND\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e스트라이드를 사용하지만 정렬된 다차원\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_STRIDED\u003c/code\u003e (\u003ccode\u003ePyBUF_STRIDES\u003c/code\u003e | \u003ccode\u003ePyBUF_WRITABLE\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_STRIDED_RO\u003c/code\u003e (\u003ccode\u003ePyBUF_STRIDES\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e스트라이드를 사용하고 반드시 정렬될 필요는 없는 다차원\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_RECORDS\u003c/code\u003e (\u003ccode\u003ePyBUF_STRIDES\u003c/code\u003e | \u003ccode\u003ePyBUF_WRITABLE\u003c/code\u003e | \u003ccode\u003ePyBUF_FORMAT\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_RECORDS_RO\u003c/code\u003e (\u003ccode\u003ePyBUF_STRIDES\u003c/code\u003e | \u003ccode\u003ePyBUF_FORMAT\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e하위 오프셋을 사용하는 다차원\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_FULL\u003c/code\u003e (\u003ccode\u003ePyBUF_INDIRECT\u003c/code\u003e | \u003ccode\u003ePyBUF_WRITABLE\u003c/code\u003e | \u003ccode\u003ePyBUF_FORMAT\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBUF_FULL_RO\u003c/code\u003e (\u003ccode\u003ePyBUF_INDIRECT\u003c/code\u003e | \u003ccode\u003ePyBUF_FORMAT\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e따라서, 객체로부터 간단한 연속 바이트 청크를 원하는 소비자는 \u003ccode\u003ePyBUF_SIMPLE\u003c/code\u003e을 사용할 수 있으며, 가장 복잡한 경우를 활용할 줄 아는 소비자는 \u003ccode\u003ePyBUF_FULL\u003c/code\u003e을 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyBUF_FORMAT\u003c/code\u003e이 \u003ccode\u003eflag\u003c/code\u003e 인수에 있는 경우에만 형식 정보가 \u003ccode\u003eNULL\u003c/code\u003e이 아님을 보장하며, 그렇지 않은 경우 소비자는 부호 없는 바이트(unsigned bytes)로 가정할 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e연속적인 \"부호 없는 바이트\" 메모리 청크만 내보낼 수 있는 내보내는 객체를 위해 제공된 플래그에 따라 버퍼 정보 구조체를 올바르게 채우는 데 사용할 수 있는 C-API가 있습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ePy_buffer\u003c/code\u003e 구조체 (The Py_buffer struct)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ebufferinfo\u003c/code\u003e 구조체는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct bufferinfo {\r\n    void *buf;\r\n    Py_ssize_t len;\r\n    int readonly;\r\n    const char *format;\r\n    int ndim;\r\n    Py_ssize_t *shape;\r\n    Py_ssize_t *strides;\r\n    Py_ssize_t *suboffsets;\r\n    Py_ssize_t itemsize;\r\n    void *internal;\r\n} Py_buffer;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ebf_getbuffer\u003c/code\u003e 함수를 호출하기 전에 \u003ccode\u003ebufferinfo\u003c/code\u003e 구조체는 무엇이든 채워질 수 있지만, 새로운 버퍼를 요청할 때는 \u003ccode\u003ebuf\u003c/code\u003e 필드가 \u003ccode\u003eNULL\u003c/code\u003e이어야 합니다. \u003ccode\u003ebf_getbuffer\u003c/code\u003e에서 반환되면 \u003ccode\u003ebufferinfo\u003c/code\u003e 구조체는 버퍼에 대한 관련 정보로 채워집니다. 이 동일한 \u003ccode\u003ebufferinfo\u003c/code\u003e 구조체는 소비자가 메모리 사용을 마쳤을 때 \u003ccode\u003ebf_releasebuffer\u003c/code\u003e(사용 가능한 경우)에 전달되어야 합니다. 호출자는 \u003ccode\u003ereleasebuffer\u003c/code\u003e가 호출될 때까지 \u003ccode\u003eobj\u003c/code\u003e에 대한 참조를 유지할 책임이 있습니다 (즉, \u003ccode\u003ebf_getbuffer\u003c/code\u003e 호출은 \u003ccode\u003eobj\u003c/code\u003e의 참조 횟수를 변경하지 않습니다).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebufferinfo\u003c/code\u003e 구조체의 멤버들은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebuf\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e객체의 메모리 시작 부분에 대한 포인터입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elen\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e객체가 사용하는 총 메모리 바이트 수입니다. 이는 \u003ccode\u003eshape\u003c/code\u003e 배열과 항목당 바이트 수를 곱한 것과 같아야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereadonly\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e메모리가 읽기 전용인지 여부를 나타내는 정수 변수입니다. 1은 메모리가 읽기 전용임을 의미하고, 0은 메모리가 쓰기 가능함을 의미합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eformat\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e메모리의 각 요소에 무엇이 들어있는지를 나타내는 \u003ccode\u003eNULL\u003c/code\u003e로 종료되는 형식 문자열(확장 기능을 포함한 \u003ccode\u003estruct\u003c/code\u003e 스타일 구문 따름)입니다. 요소의 수는 \u003ccode\u003elen / itemsize\u003c/code\u003e이며, \u003ccode\u003eitemsize\u003c/code\u003e는 형식에 의해 암시되는 바이트 수입니다. 이것은 \u003ccode\u003eNULL\u003c/code\u003e일 수 있으며, 이 경우 표준 부호 없는 바이트(\"B\")를 의미합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003endim\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e메모리가 나타내는 차원의 수를 저장하는 변수입니다. 0 이상이어야 합니다. 0 값은 \u003ccode\u003eshape\u003c/code\u003e, \u003ccode\u003estrides\u003c/code\u003e, \u003ccode\u003esuboffsets\u003c/code\u003e가 \u003ccode\u003eNULL\u003c/code\u003e이어야 함을 의미합니다 (즉, 메모리가 스칼라를 나타냅니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eshape\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e메모리의 형상(shape)을 N차원 배열로 나타내는 \u003ccode\u003endim\u003c/code\u003e 길이의 \u003ccode\u003ePy_ssize_t\u003c/code\u003e 배열입니다. \u003ccode\u003e((*shape)[0] * ... * (*shape)[ndims-1])*itemsize = len\u003c/code\u003e에 유의하십시오. \u003ccode\u003endim\u003c/code\u003e이 0인 경우(스칼라를 나타냄) 이것은 \u003ccode\u003eNULL\u003c/code\u003e이어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estrides\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePy_ssize_t\u003c/code\u003e 길이의 \u003ccode\u003endim\u003c/code\u003e 배열에 대한 포인터(또는 \u003ccode\u003endim\u003c/code\u003e이 0인 경우 \u003ccode\u003eNULL\u003c/code\u003e)로 채워질 \u003ccode\u003ePy_ssize_t*\u003c/code\u003e 변수의 주소입니다. 각 차원에서 다음 요소로 이동하기 위해 건너뛸 바이트 수를 나타냅니다. 호출자가 이를 요청하지 않으면 (\u003ccode\u003ePyBUF_STRIDES\u003c/code\u003e가 설정되지 않으면) \u003ccode\u003eNULL\u003c/code\u003e로 설정되어 C-스타일 연속 배열을 나타내거나, 불가능한 경우 \u003ccode\u003ePyExc_BufferError\u003c/code\u003e가 발생해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esuboffsets\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePy_ssize_t\u003c/code\u003e 길이의 \u003ccode\u003e*ndims\u003c/code\u003e 배열에 대한 포인터로 채워질 \u003ccode\u003ePy_ssize_t*\u003c/code\u003e 변수의 주소입니다. 이 \u003ccode\u003esuboffset\u003c/code\u003e 숫자가 0 이상인 경우, 지정된 차원을 따라 저장된 값은 포인터이며 \u003ccode\u003esuboffset\u003c/code\u003e 값은 역참조(de-referencing) 후 포인터에 추가할 바이트 수를 지시합니다. 음수 \u003ccode\u003esuboffset\u003c/code\u003e 값은 역참조가 발생하지 않아야 함을 나타냅니다 (연속 메모리 블록 내에서 스트라이딩). 모든 \u003ccode\u003esuboffset\u003c/code\u003e이 음수인 경우 (즉, 역참조가 필요 없음) 이것은 \u003ccode\u003eNULL\u003c/code\u003e이어야 합니다 (기본값). 호출자가 이를 요청하지 않으면 (\u003ccode\u003ePyBUF_INDIRECT\u003c/code\u003e가 설정되지 않으면) \u003ccode\u003eNULL\u003c/code\u003e로 설정되거나, 불가능한 경우 \u003ccode\u003ePyExc_BufferError\u003c/code\u003e가 발생해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e명확성을 위해, \u003ccode\u003estrides\u003c/code\u003e와 \u003ccode\u003esuboffsets\u003c/code\u003e가 모두 \u003ccode\u003eNULL\u003c/code\u003e이 아닐 때 N차원 인덱스가 가리키는 N차원 배열의 요소에 대한 포인터를 반환하는 함수는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid *get_item_pointer(int ndim, void *buf, Py_ssize_t *strides, Py_ssize_t *suboffsets, Py_ssize_t *indices) {\r\n    char *pointer = (char*)buf;\r\n    int i;\r\n    for (i = 0; i \u0026#x3C; ndim; i++) {\r\n        pointer += strides[i] * indices[i];\r\n        if (suboffsets[i] \u003e=0 ) {\r\n            pointer = *((char**)pointer) + suboffsets[i];\r\n        }\r\n    }\r\n    return (void*)pointer;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esuboffset\u003c/code\u003e이 역참조 후에 추가된다는 점에 유의하십시오. 따라서 \u003ccode\u003ei\u003c/code\u003e번째 차원에서 슬라이싱(slicing)하면 \u003ccode\u003e(i-1)\u003c/code\u003e번째 차원의 \u003ccode\u003esuboffsets\u003c/code\u003e에 추가됩니다. 첫 번째 차원에서 슬라이싱하면 시작 포인터의 위치가 직접 변경됩니다 (즉, \u003ccode\u003ebuf\u003c/code\u003e가 수정됩니다).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eitemsize\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e공유 메모리의 각 요소의 \u003ccode\u003eitemsize\u003c/code\u003e(바이트 단위)를 저장하는 공간입니다. \u003ccode\u003ePyBuffer_SizeFromFormat\u003c/code\u003e을 사용하여 얻을 수 있으므로 기술적으로는 불필요하지만, 내보내는 객체는 형식 문자열을 파싱하지 않고도 이 정보를 알 수 있으며, 스트라이딩을 올바르게 해석하려면 \u003ccode\u003eitemsize\u003c/code\u003e를 알아야 합니다. 따라서 저장하는 것이 더 편리하고 빠릅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einternal\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e내보내는 객체가 내부적으로 사용하기 위한 것입니다. 예를 들어, 내보내는 객체가 이를 정수로 재캐스팅하여 버퍼가 해제될 때 \u003ccode\u003eshape\u003c/code\u003e, \u003ccode\u003estrides\u003c/code\u003e, \u003ccode\u003esuboffsets\u003c/code\u003e 배열을 해제해야 하는지에 대한 플래그를 저장하는 데 사용할 수 있습니다. 소비자는 이 값을 절대 변경해서는 안 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e내보내는 객체는 \u003ccode\u003ebuf\u003c/code\u003e, \u003ccode\u003eformat\u003c/code\u003e, \u003ccode\u003eshape\u003c/code\u003e, \u003ccode\u003estrides\u003c/code\u003e, \u003ccode\u003esuboffsets\u003c/code\u003e가 가리키는 모든 메모리가 \u003ccode\u003ereleasebuffer\u003c/code\u003e가 호출될 때까지 유효한지 확인할 책임이 있습니다. 내보내는 객체가 \u003ccode\u003ereleasebuffer\u003c/code\u003e가 호출되기 전에 객체의 \u003ccode\u003eshape\u003c/code\u003e, \u003ccode\u003estrides\u003c/code\u003e, 및/또는 \u003ccode\u003esuboffsets\u003c/code\u003e를 변경할 수 있기를 원한다면, \u003ccode\u003egetbuffer\u003c/code\u003e가 호출될 때 해당 배열을 할당하고 (제공된 버퍼 정보 구조체에서 이들을 가리키도록) \u003ccode\u003ereleasebuffer\u003c/code\u003e가 호출될 때 해제해야 합니다.\u003c/p\u003e\n\u003ch3\u003e버퍼 해제 (Releasing the buffer)\u003c/h3\u003e\n\u003cp\u003e동일한 \u003ccode\u003ebufferinfo\u003c/code\u003e 구조체가 \u003ccode\u003erelease-buffer\u003c/code\u003e 인터페이스 호출에 사용되어야 합니다. 호출자는 \u003ccode\u003ePy_buffer\u003c/code\u003e 구조체 자체의 메모리에 대한 책임이 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef void (*releasebufferproc)(PyObject *obj, Py_buffer *view)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003egetbufferproc\u003c/code\u003e의 호출자는 객체에서 이전에 획득한 메모리가 더 이상 필요하지 않을 때 이 함수가 호출되도록 해야 합니다. 인터페이스의 내보내는 객체는 \u003ccode\u003ebufferinfo\u003c/code\u003e 구조체에 포인터로 지정된 모든 메모리가 \u003ccode\u003ereleasebuffer\u003c/code\u003e가 호출될 때까지 유효하게 유지되도록 해야 합니다.\u003c/p\u003e\n\u003cp\u003e만약 \u003ccode\u003ebf_releasebuffer\u003c/code\u003e 함수가 제공되지 않으면 (즉, \u003ccode\u003eNULL\u003c/code\u003e인 경우), 호출할 필요가 전혀 없습니다.\u003c/p\u003e\n\u003cp\u003e내보내는 객체는 \u003ccode\u003estruct bufferinfo\u003c/code\u003e를 통해 공유할 수 있는 메모리, \u003ccode\u003estrides\u003c/code\u003e, \u003ccode\u003eshape\u003c/code\u003e, \u003ccode\u003esuboffsets\u003c/code\u003e 또는 \u003ccode\u003eformat\u003c/code\u003e 변수를 재할당할 수 있는 경우 \u003ccode\u003ebf_releasebuffer\u003c/code\u003e 함수를 정의해야 합니다. 얼마나 많은 \u003ccode\u003egetbuffer\u003c/code\u003e 호출이 이루어졌고 공유되었는지 추적하기 위해 여러 메커니즘을 사용할 수 있습니다. 단일 변수를 사용하여 내보내진 \"뷰\"의 수를 추적하거나, 각 객체에 채워진 \u003ccode\u003ebufferinfo\u003c/code\u003e 구조체의 연결 리스트를 유지할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e하지만 내보내는 객체에 의해 특별히 요구되는 것은 \u003ccode\u003ebufferinfo\u003c/code\u003e 구조체를 통해 공유되는 모든 메모리가 해당 메모리를 내보내는 \u003ccode\u003ebufferinfo\u003c/code\u003e 구조체에 대해 \u003ccode\u003ereleasebuffer\u003c/code\u003e가 호출될 때까지 유효하게 유지되도록 하는 것입니다.\u003c/p\u003e\n\u003ch3\u003e새로운 C-API 호출 제안 (New C-API calls are proposed)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eint PyObject_CheckBuffer(PyObject *obj)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egetbuffer\u003c/code\u003e 함수를 사용할 수 있으면 1을 반환하고, 그렇지 않으면 0을 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egetbuffer\u003c/code\u003e 함수 호출의 C-API 버전입니다. 객체가 필요한 함수 포인터를 가지고 있는지 확인하고 호출을 실행합니다. 실패 시 -1을 반환하고 오류를 발생시키며, 성공 시 0을 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evoid PyBuffer_Release(PyObject *obj, Py_buffer *view)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ereleasebuffer\u003c/code\u003e 함수 호출의 C-API 버전입니다. 객체가 필요한 함수 포인터를 가지고 있는지 확인하고 호출을 실행합니다. 이 함수는 객체에 \u003ccode\u003ereleasebuffer\u003c/code\u003e 함수가 없더라도 항상 성공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyObject *PyObject_GetMemoryView(PyObject *obj)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e버퍼 인터페이스를 정의하는 객체로부터 \u003ccode\u003ememory-view\u003c/code\u003e 객체를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ememory-view\u003c/code\u003e 객체는 버퍼 객체를 대체할 수 있는 확장된 버퍼 객체입니다 (하지만 단순한 1차원 \u003ccode\u003ememory-view\u003c/code\u003e 객체로 유지될 수 있으므로 반드시 대체할 필요는 없습니다). 그 C-구조체는 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct {\r\n    PyObject_HEAD\r\n    PyObject *base;\r\n    Py_buffer view;\r\n} PyMemoryViewObject;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 \u003ccode\u003ebase\u003c/code\u003e에 대한 참조가 유지되고 메모리 뷰가 다시 가져와지지 않는다는 점을 제외하면 현재 버퍼 객체와 기능적으로 유사합니다. 따라서 이 \u003ccode\u003ememory-view\u003c/code\u003e 객체는 삭제될 때까지 \u003ccode\u003ebase\u003c/code\u003e의 메모리를 유지합니다.\u003c/p\u003e\n\u003cp\u003e이 \u003ccode\u003ememory-view\u003c/code\u003e 객체는 다차원 슬라이싱(multi-dimensional slicing)을 지원하며, Python에서 이를 수행하는 최초의 객체가 될 것입니다. \u003ccode\u003ememory-view\u003c/code\u003e 객체의 슬라이스는 동일한 \u003ccode\u003ebase\u003c/code\u003e를 가지지만 \u003ccode\u003ebase\u003c/code\u003e 객체에 대한 다른 뷰(view)를 가지는 다른 \u003ccode\u003ememory-view\u003c/code\u003e 객체입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ememory-view\u003c/code\u003e에서 \"요소\"가 반환될 때마다 항상 \u003ccode\u003ebytes\u003c/code\u003e 객체이며, 그 형식은 \u003ccode\u003ememoryview\u003c/code\u003e 객체의 \u003ccode\u003eformat\u003c/code\u003e 속성에 의해 해석되어야 합니다. 원한다면 \u003ccode\u003estruct\u003c/code\u003e 모듈을 사용하여 Python에서 바이트를 \"디코딩\"할 수 있습니다. 또는 내용을 NumPy 배열이나 버퍼 프로토콜을 사용하는 다른 객체에 전달할 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePython 이름은 \u003ccode\u003e__builtin__.memoryview\u003c/code\u003e가 될 것입니다.\u003c/p\u003e\n\u003cp\u003e메서드:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__getitem__\u003c/code\u003e (다차원 슬라이싱 지원)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__setitem__\u003c/code\u003e (다차원 슬라이싱 지원)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etobytes\u003c/code\u003e (메모리 복사본의 새 \u003ccode\u003ebytes\u003c/code\u003e 객체를 얻음).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etolist\u003c/code\u003e (메모리의 \"중첩된\" 리스트를 얻음. \u003ccode\u003estruct\u003c/code\u003e 모듈의 \u003ccode\u003eunpack\u003c/code\u003e이 하는 것처럼 모든 것이 표준 Python 객체로 해석됩니다. 실제로 이를 위해 \u003ccode\u003estruct.unpack\u003c/code\u003e을 사용합니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e속성 (\u003ccode\u003ebase\u003c/code\u003e 객체의 메모리에서 가져옴):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eformat\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eitemsize\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eshape\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003estrides\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003esuboffsets\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ereadonly\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003endim\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePy_ssize_t PyBuffer_SizeFromFormat(const char *)\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003estruct\u003c/code\u003e 스타일 설명에서 데이터 형식 영역의 암시된 \u003ccode\u003eitemsize\u003c/code\u003e를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePyObject * PyMemoryView_GetContiguous(PyObject *obj, int buffertype, char fortran)\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eobj\u003c/code\u003e로 표현되는 연속적인 메모리 청크에 대한 \u003ccode\u003ememoryview\u003c/code\u003e 객체를 반환합니다. 복사가 이루어져야 하는 경우 (\u003ccode\u003eobj\u003c/code\u003e가 가리키는 메모리가 연속적이지 않기 때문), 새로운 \u003ccode\u003ebytes\u003c/code\u003e 객체가 생성되어 반환된 \u003ccode\u003ememory view\u003c/code\u003e 객체의 \u003ccode\u003ebase\u003c/code\u003e 객체가 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ebuffertype\u003c/code\u003e 인수는 반환된 버퍼가 읽기 가능, 쓰기 가능, 또는 복사가 이루어져야 하는 경우 원본 버퍼를 업데이트하도록 설정할지 여부를 결정하기 위해 \u003ccode\u003ePyBUF_READ\u003c/code\u003e, \u003ccode\u003ePyBUF_WRITE\u003c/code\u003e, \u003ccode\u003ePyBUF_UPDATEIFCOPY\u003c/code\u003e가 될 수 있습니다. \u003ccode\u003ebuffertype\u003c/code\u003e이 \u003ccode\u003ePyBUF_WRITE\u003c/code\u003e이고 버퍼가 연속적이지 않으면 오류가 발생합니다. 이 경우 사용자는 \u003ccode\u003ePyBUF_UPDATEIFCOPY\u003c/code\u003e를 사용하여 쓰기 가능한 임시 연속 버퍼가 반환되도록 할 수 있습니다. 이 연속 버퍼의 내용은 \u003ccode\u003ememoryview\u003c/code\u003e 객체가 삭제된 후 원본 객체가 쓰기 가능한 한 원본 객체로 다시 복사됩니다. 이것이 원본 객체에 의해 허용되지 않으면 \u003ccode\u003eBufferError\u003c/code\u003e가 발생합니다.\u003c/p\u003e\n\u003cp\u003e객체가 다차원인 경우, \u003ccode\u003efortran\u003c/code\u003e이 'F'이면 기본 배열의 첫 번째 차원이 버퍼에서 가장 빠르게 변합니다. \u003ccode\u003efortran\u003c/code\u003e이 'C'이면 마지막 차원이 가장 빠르게 변합니다 (C-스타일 연속). \u003ccode\u003efortran\u003c/code\u003e이 'A'이면 중요하지 않으며 객체가 더 효율적이라고 결정하는 것을 얻게 됩니다. 복사가 이루어지면 \u003ccode\u003ePyMem_Free\u003c/code\u003e를 호출하여 메모리를 해제해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ememoryview\u003c/code\u003e 객체에 대한 새로운 참조를 받습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eint PyObject_CopyToObject(PyObject *obj, void *buf, Py_ssize_t len, char fortran)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebuf\u003c/code\u003e가 가리키는 연속적인 메모리 청크가 가리키는 \u003ccode\u003elen\u003c/code\u003e 바이트의 데이터를 \u003ccode\u003eobj\u003c/code\u003e가 내보내는 버퍼로 복사합니다. 성공 시 0을 반환하고, 실패 시 -1을 반환하며 오류를 발생시킵니다. 객체가 쓰기 가능한 버퍼를 가지고 있지 않으면 오류가 발생합니다. \u003ccode\u003efortran\u003c/code\u003e이 'F'이면, 객체가 다차원인 경우 데이터는 Fortran-스타일(첫 번째 차원이 가장 빠르게 변함)로 배열에 복사됩니다. \u003ccode\u003efortran\u003c/code\u003e이 'C'이면 데이터는 C-스타일(마지막 차원이 가장 빠르게 변함)로 배열에 복사됩니다. \u003ccode\u003efortran\u003c/code\u003e이 'A'이면 중요하지 않으며 가장 효율적인 방식으로 복사가 이루어집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint PyObject_CopyData(PyObject *dest, PyObject *src)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e이 마지막 세 가지 C-API 호출은 데이터가 실제로 어떻게 저장되어 있든 상관없이 Python 객체에서 연속적인 메모리 영역으로 데이터를 가져오고 내보내는 표준적인 방법을 허용합니다. 이 호출들은 확장된 버퍼 인터페이스를 사용하여 작업을 수행합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint PyBuffer_IsContiguous(Py_buffer *view, char fortran)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eview\u003c/code\u003e 객체에 의해 정의된 메모리가 C-스타일 (\u003ccode\u003efortran\u003c/code\u003e = 'C') 또는 Fortran-스타일 (\u003ccode\u003efortran\u003c/code\u003e = 'F') 연속적이거나 둘 중 하나 (\u003ccode\u003efortran\u003c/code\u003e = 'A')이면 1을 반환합니다. 그렇지 않으면 0을 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evoid PyBuffer_FillContiguousStrides(int ndim, Py_ssize_t *shape, Py_ssize_t *strides, Py_ssize_t itemsize, char fortran)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e주어진 형상(shape)과 요소당 바이트 수(itemsize)를 가진 연속적인 배열(C-스타일, \u003ccode\u003efortran\u003c/code\u003e이 'C'이면, 또는 Fortran-스타일, \u003ccode\u003efortran\u003c/code\u003e이 'F'이면)의 바이트-스트라이드로 \u003ccode\u003estrides\u003c/code\u003e 배열을 채웁니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint PyBuffer_FillInfo(Py_buffer *view, void *buf, Py_ssize_t len, int readonly, int infoflags)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e주어진 길이의 \"부호 없는 바이트\" 연속 메모리 청크만 공유할 수 있는 내보내는 객체를 위해 \u003ccode\u003ebuffer-info\u003c/code\u003e 구조체를 올바르게 채웁니다. 성공 시 0을 반환하고, 오류 시 -1을 반환합니다 (오류 발생 포함).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyExc_BufferError\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e내보내는 객체가 소비자가 기대하는 종류의 버퍼를 제공할 수 없기 때문에 발생하는 버퍼 오류를 반환하기 위한 새로운 오류 객체입니다. 이 오류는 소비자가 프로토콜을 제공하지 않는 객체로부터 버퍼를 요청할 때도 발생합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003estruct\u003c/code\u003e 문자열 구문 추가 사항 (\u003ccode\u003eAdditions to the struct string-syntax\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003estruct\u003c/code\u003e 문자열 구문에는 이미 다른 곳(예: \u003ccode\u003ectypes\u003c/code\u003e 및 NumPy)에서 사용할 수 있는 데이터 형식 설명(data-format descriptions)을 완전히 구현하기 위한 일부 문자가 누락되어 있습니다. Python 2.5 사양은 \u003ca href=\"http://docs.python.org/library/struct.html\"\u003ehttp://docs.python.org/library/struct.html\u003c/a\u003e에 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 제안된 추가 사항입니다.\u003c/p\u003e\n\u003cp\u003e| 문자 | 설명                                                    |\r\n| :--- | :------------------------------------------------------ |\r\n| \u003ccode\u003e't'\u003c/code\u003e  | 비트 (앞에 붙는 숫자가 몇 비트인지 나타냄)                  |\r\n| \u003ccode\u003e'?'\u003c/code\u003e  | 플랫폼 \u003ccode\u003e_Bool\u003c/code\u003e 타입                                     |\r\n| \u003ccode\u003e'g'\u003c/code\u003e  | \u003ccode\u003elong double\u003c/code\u003e                                          |\r\n| \u003ccode\u003e'c'\u003c/code\u003e  | \u003ccode\u003eucs-1\u003c/code\u003e (latin-1) 인코딩                                |\r\n| \u003ccode\u003e'u'\u003c/code\u003e  | \u003ccode\u003eucs-2\u003c/code\u003e                                                |\r\n| \u003ccode\u003e'w'\u003c/code\u003e  | \u003ccode\u003eucs-4\u003c/code\u003e                                                |\r\n| \u003ccode\u003e'O'\u003c/code\u003e  | Python 객체에 대한 포인터                               |\r\n| \u003ccode\u003e'Z'\u003c/code\u003e  | 복소수 (다음 지정자가 무엇이든)                          |\r\n| \u003ccode\u003e'\u0026#x26;'\u003c/code\u003e  | 특정 포인터 (다른 문자 앞에 붙는 접두사)                  |\r\n| \u003ccode\u003e'T{}'\u003c/code\u003e| 구조체 (내부에 상세 레이아웃 포함 {})                     |\r\n| \u003ccode\u003e'(k1,k2,…,kn)'\u003c/code\u003e| 다음에 오는 무엇이든의 다차원 배열                  |\r\n| \u003ccode\u003e':name:'\u003c/code\u003e| 이전 요소의 선택적 이름                               |\r\n| \u003ccode\u003e'X{}'\u003c/code\u003e| 함수에 대한 포인터 (선택적 함수 시그니처 내부에 {} 포함, 반환 값은 \u003ccode\u003e-\u003e\u003c/code\u003e 뒤에 붙고 끝에 위치) |\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estruct\u003c/code\u003e 모듈도 이러한 것들을 이해하고 언팩(unpacking) 시 적절한 Python 객체를 반환하도록 변경될 것입니다. \u003ccode\u003elong-double\u003c/code\u003e을 언팩하면 \u003ccode\u003edecimal\u003c/code\u003e 객체 또는 \u003ccode\u003ectypes\u003c/code\u003e \u003ccode\u003elong-double\u003c/code\u003e이 반환됩니다. \u003ccode\u003e'u'\u003c/code\u003e 또는 \u003ccode\u003e'w'\u003c/code\u003e를 언팩하면 Python \u003ccode\u003eunicode\u003c/code\u003e가 반환됩니다. 다차원 배열을 언팩하면 리스트(1차원 이상인 경우 리스트의 리스트)가 반환됩니다. 포인터를 언팩하면 \u003ccode\u003ectypes\u003c/code\u003e 포인터 객체가 반환됩니다. 함수 포인터를 언팩하면 \u003ccode\u003ectypes\u003c/code\u003e \u003ccode\u003ecall-object\u003c/code\u003e가 반환될 것입니다. 비트(bit)를 언팩하면 Python \u003ccode\u003eBool\u003c/code\u003e이 반환됩니다. \u003ccode\u003estruct\u003c/code\u003e 문자열 구문 내의 공백은 이미 무시되지 않는다면 무시될 것입니다. 명명된 객체(named-object)를 언팩하면 튜플처럼 작동하지만 항목에 이름으로도 접근할 수 있는 \u003ccode\u003enamed-tuple\u003c/code\u003e과 유사한 객체가 반환됩니다. 중첩된 구조체를 언팩하면 중첩된 튜플이 반환됩니다.\u003c/p\u003e\n\u003cp\u003e바이트 순서(Endian-specification) (\u003ccode\u003e!\u003c/code\u003e, \u003ccode\u003e@\u003c/code\u003e, \u003ccode\u003e=\u003c/code\u003e, \u003ccode\u003e\u003e\u003c/code\u003e, \u003ccode\u003e\u0026#x3C;\u003c/code\u003e, \u003ccode\u003e^\u003c/code\u003e)도 문자열 내에서 허용되므로 필요에 따라 변경될 수 있습니다. 이전에 지정된 바이트 순서 문자열은 변경될 때까지 유효합니다. 기본 바이트 순서는 '@'이며, 이는 네이티브 데이터 타입과 정렬을 의미합니다. 정렬되지 않은 네이티브 데이터 타입이 요청되면 바이트 순서 지정은 '^'입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estruct\u003c/code\u003e 모듈에 따르면, 숫자 코드 앞에 숫자가 붙어 해당 타입의 개수를 지정할 수 있습니다. \u003ccode\u003e(k1,k2,...,kn)\u003c/code\u003e 확장 기능은 데이터가 특정 형식의 (C-스타일 연속, 마지막 차원이 가장 빠르게 변함) 다차원 배열로 보여져야 하는지 여부도 지정할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ectypes\u003c/code\u003e에 \u003ccode\u003estruct\u003c/code\u003e 설명으로부터 \u003ccode\u003ectypes\u003c/code\u003e 객체를 생성하고, \u003ccode\u003elong-double\u003c/code\u003e 및 \u003ccode\u003eucs-2\u003c/code\u003e를 \u003ccode\u003ectypes\u003c/code\u003e에 추가하는 함수가 추가되어야 합니다.\u003c/p\u003e\n\u003ch3\u003e데이터 형식 설명 예시 (Examples of Data-Format Descriptions)\u003c/h3\u003e\n\u003cp\u003e다음은 C-구조체의 예시와 \u003ccode\u003estruct\u003c/code\u003e 스타일 구문을 사용하여 어떻게 표현될 수 있는지 보여줍니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u0026#x3C;named\u003e\u003c/code\u003e는 명명된 튜플(아직 지정되지 않음)의 생성자입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003efloat\u003c/code\u003e \u003ccode\u003e'd'\u003c/code\u003e \u0026#x3C;–\u003e Python \u003ccode\u003efloat\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ecomplex double\u003c/code\u003e \u003ccode\u003e'Zd'\u003c/code\u003e \u0026#x3C;–\u003e Python \u003ccode\u003ecomplex\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eRGB Pixel data\u003c/code\u003e \u003ccode\u003e'BBB'\u003c/code\u003e \u0026#x3C;–\u003e \u003ccode\u003e(int, int, int)\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e'B:r: B:g: B:b:'\u003c/code\u003e \u0026#x3C;–\u003e \u003ccode\u003e\u0026#x3C;named\u003e((int, int, int), ('r','g','b'))\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eMixed endian\u003c/code\u003e (이상하지만 가능) \u003ccode\u003e'\u003ei:big: \u0026#x3C;i:little:'\u003c/code\u003e \u0026#x3C;–\u003e \u003ccode\u003e\u0026#x3C;named\u003e((int, int), ('big', 'little'))\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e중첩된 구조체\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct {\r\n    int ival;\r\n    struct {\r\n        unsigned short sval;\r\n        unsigned char bval;\r\n        unsigned char cval;\r\n    } sub;\r\n}\r\n\"\"\"i:ival: T{ H:sval: B:bval: B:cval: }:sub: \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e중첩된 배열\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct {\r\n    int ival;\r\n    double data[16*4];\r\n}\r\n\"\"\"i:ival: (16,4)d:data: \"\"\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e마지막 예시에서 비교되는 C-구조체는 의도적으로 2차원 배열 \u003ccode\u003edata[16][4]\u003c/code\u003e가 아닌 1차원 배열입니다. 이는 C의 정적 다차원 배열(연속적으로 배치됨)과 \u003ccode\u003edata[0][1]\u003c/code\u003e와 동일한 구문을 사용하여 요소에 접근하지만 메모리가 반드시 연속적이지는 않은 동적 다차원 배열 간의 혼동을 피하기 위함입니다. \u003ccode\u003estruct\u003c/code\u003e 구문은 항상 연속적인 메모리를 사용하며, 다차원 문자는 내보내는 객체가 소비자에게 전달할 메모리에 대한 정보입니다.\u003c/p\u003e\n\u003cp\u003e다시 말해, \u003ccode\u003estruct\u003c/code\u003e 구문 설명은 동일한 메모리 레이아웃을 설명하는 한 C-구문과 정확히 일치할 필요는 없습니다. C-컴파일러가 메모리를 \u003ccode\u003edouble\u003c/code\u003e형 1차원 배열로 생각할 것이라는 사실은 내보내는 객체가 소비자에게 이 메모리 필드를 4개 요소마다 새로운 차원이 고려되는 2차원 배열로 생각해야 한다고 전달하려는 사실과 무관합니다.\u003c/p\u003e\n\u003ch3\u003e영향을 받는 코드 (Code to be affected)\u003c/h3\u003e\n\u003cp\u003e이전 버퍼 인터페이스를 내보내거나 사용하는 Python의 모든 객체와 모듈이 수정될 것입니다. 다음은 부분적인 목록입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebuffer\u003c/code\u003e 객체\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebytes\u003c/code\u003e 객체\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estring\u003c/code\u003e 객체\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunicode\u003c/code\u003e 객체\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003earray\u003c/code\u003e 모듈\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estruct\u003c/code\u003e 모듈\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emmap\u003c/code\u003e 모듈\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ectypes\u003c/code\u003e 모듈\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e버퍼 API를 사용하는 다른 모든 것.\u003c/p\u003e\n\u003ch3\u003e문제 및 세부 사항 (Issues and Details)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 기존 버퍼 프로토콜에 C-API와 두 가지 함수를 추가하여 Python 2.6으로 백포팅(back-ported)될 예정입니다.\u003c/p\u003e\n\u003cp\u003e이 PEP의 이전 버전에서는 읽기/쓰기 잠금(read/write locking) 체계를 제안했지만, 나중에 다음과 같이 인식되었습니다.\r\na) 잠금이 필요 없는 일반적인 간단한 사용 사례에는 너무 복잡하고,\r\nb) 변경되고 짧게 유지되는 잠금을 사용하여 버퍼에 대한 동시 읽기/쓰기 접근이 필요한 사용 사례에는 너무 간단하다고 판단되었습니다.\r\n따라서 동시 읽기/쓰기 접근에서 일관된 뷰(consistent views)가 필요한 경우 사용자가 버퍼 객체 주변에 자체적인 특정 잠금 체계를 구현하도록 맡겨져 있습니다. 이러한 사용자 체계에 대한 경험이 축적된 후에는 별도의 잠금 API를 포함하는 미래의 PEP가 제안될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e스트라이드 메모리(strided memory)와 하위 오프셋(suboffsets)의 공유는 새로운 기능이며, 다중 세그먼트 인터페이스의 수정으로 볼 수 있습니다. 이는 NumPy와 PIL에서 영감을 받았습니다. NumPy 객체는 스트라이드 메모리를 관리하는 방법을 이해하는 코드와 스트라이드 메모리를 공유할 수 있어야 합니다. 왜냐하면 스트라이드 메모리는 계산 라이브러리와 인터페이스할 때 매우 흔하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e또한, 이 접근 방식을 사용하면 복사 없이 두 가지 종류의 메모리 모두에서 작동하는 일반적인 코드를 작성할 수 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebufferinfo\u003c/code\u003e 구조체의 \u003ccode\u003eformat\u003c/code\u003e 문자열, \u003ccode\u003eshape\u003c/code\u003e 배열, \u003ccode\u003estrides\u003c/code\u003e 배열, \u003ccode\u003esuboffsets\u003c/code\u003e 배열의 메모리 관리는 항상 내보내는 객체의 책임입니다. 소비자는 이러한 포인터를 다른 메모리로 설정하거나 해제하려고 시도해서는 안 됩니다.\u003c/p\u003e\n\u003cp\u003e몇 가지 아이디어가 논의되었고 거부되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erelease-buffer\u003c/code\u003e가 호출되는 \"releaser\" 객체를 두는 것. 이것은 프로토콜을 비대칭적으로 만들었기 때문에 (버퍼를 \"얻은\" 것과 다른 것에 대해 해제를 호출했음) 받아들일 수 없다고 판단되었습니다. 또한 실제 이점 없이 프로토콜을 복잡하게 만들었습니다.\u003c/li\u003e\n\u003cli\u003e모든 \u003ccode\u003estruct\u003c/code\u003e 변수를 함수에 별도로 전달하는 것. 이것은 관심 없는 변수에 \u003ccode\u003eNULL\u003c/code\u003e을 설정할 수 있다는 장점이 있었지만, 함수 호출을 더 어렵게 만들었습니다. \u003ccode\u003eflags\u003c/code\u003e 변수는 소비자가 프로토콜을 호출하는 방식에서 \"간단\"할 수 있는 동일한 기능을 허용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e코드 (Code)\u003c/h3\u003e\n\u003cp\u003ePEP 작성자들은 이 제안에 대한 코드를 기여하고 유지 관리할 것을 약속하지만, 어떠한 도움도 환영할 것입니다.\u003c/p\u003e\n\u003ch3\u003e코드 예시 (Code Examples)\u003c/h3\u003e\n\u003ch4\u003e예시 1 (Ex. 1)\u003c/h4\u003e\n\u003cp\u003e이 예시는 연속적인 라인을 사용하는 이미지 객체가 버퍼를 어떻게 노출할 수 있는지를 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003estruct rgba {\r\n    unsigned char r, g, b, a;\r\n};\r\nstruct ImageObject {\r\n    PyObject_HEAD;\r\n    ...\r\n    struct rgba** lines;\r\n    Py_ssize_t height;\r\n    Py_ssize_t width;\r\n    Py_ssize_t shape_array[2];\r\n    Py_ssize_t stride_array[2];\r\n    Py_ssize_t view_count;\r\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e\"lines\"\u003c/code\u003e는 \u003ccode\u003emalloc\u003c/code\u003e으로 할당된 \u003ccode\u003estruct rgba*\u003c/code\u003e의 1차원 배열을 가리킵니다. 해당 블록의 각 포인터는 별도로 \u003ccode\u003emalloc\u003c/code\u003e으로 할당된 \u003ccode\u003estruct rgba\u003c/code\u003e 배열을 가리킵니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003ex=30, y=50\u003c/code\u003e에 있는 픽셀의 빨간색 값에 접근하려면 \u003ccode\u003e\"lines[50][30].r\"\u003c/code\u003e을 사용합니다.\u003c/p\u003e\n\u003cp\u003e그렇다면 \u003ccode\u003eImageObject\u003c/code\u003e의 \u003ccode\u003egetbuffer\u003c/code\u003e는 무엇을 할까요? 오류 검사를 제외하면 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint Image_getbuffer(PyObject *self, Py_buffer *view, int flags) {\r\n    static Py_ssize_t suboffsets[2] = { 0, -1};\r\n    view-\u003ebuf = self-\u003elines;\r\n    view-\u003elen = self-\u003eheight*self-\u003ewidth;\r\n    view-\u003ereadonly = 0;\r\n    view-\u003endims = 2;\r\n    self-\u003eshape_array[0] = height;\r\n    self-\u003eshape_array[1] = width;\r\n    view-\u003eshape = \u0026#x26;self-\u003eshape_array;\r\n    self-\u003estride_array[0] = sizeof(struct rgba*);\r\n    self-\u003estride_array[1] = sizeof(struct rgba);\r\n    view-\u003estrides = \u0026#x26;self-\u003estride_array;\r\n    view-\u003esuboffsets = suboffsets;\r\n    self-\u003eview_count ++;\r\n    return 0;\r\n}\r\nint Image_releasebuffer(PyObject *self, Py_buffer *view) {\r\n    self-\u003eview_count--;\r\n    return 0;\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e예시 2 (Ex. 2)\u003c/h4\u003e\n\u003cp\u003e이 예시는 (객체가 살아있는 동안에는 재할당되지 않는) 연속적인 메모리 청크를 노출하려는 객체가 이를 어떻게 수행하는지 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003eint myobject_getbuffer(PyObject *self, Py_buffer *view, int flags) {\r\n    void *buf;\r\n    Py_ssize_t len;\r\n    int readonly=0;\r\n    buf = /* Point to buffer */\r\n    len = /* Set to size of buffer */\r\n    readonly = /* Set to 1 if readonly */\r\n    return PyObject_FillBufferInfo(view, buf, len, readonly, flags);\r\n}\r\n/* No releasebuffer is necessary because the memory will never be re-allocated */\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e예시 3 (Ex. 3)\u003c/h4\u003e\n\u003cp\u003ePython 객체 \u003ccode\u003eobj\u003c/code\u003e에서 간단한 연속 바이트 청크만 얻고 싶은 소비자는 다음을 수행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003ePy_buffer view;\r\nint ret;\r\nif (PyObject_GetBuffer(obj, \u0026#x26;view, Py_BUF_SIMPLE) \u0026#x3C; 0) {\r\n    /* error return */\r\n}\r\n/* Now, view.buf is the pointer to memory\r\n   view.len is the length\r\n   view.readonly is whether or not the memory is read-only. */\r\n/* After using the information and you don't need it anymore */\r\nif (PyBuffer_Release(obj, \u0026#x26;view) \u0026#x3C; 0) {\r\n    /* error return */\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e예시 4 (Ex. 4)\u003c/h4\u003e\n\u003cp\u003e어떤 객체의 메모리도 사용할 수 있지만 연속적인 메모리만 처리하는 알고리즘을 작성하는 소비자는 다음을 수행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid *buf;\r\nPy_ssize_t len;\r\nchar *format;\r\nint copy;\r\ncopy = PyObject_GetContiguous(obj, \u0026#x26;buf, \u0026#x26;len, \u0026#x26;format, 0, 'A');\r\nif (copy \u0026#x3C; 0) {\r\n    /* error return */\r\n}\r\n/* process memory pointed to by buffer if format is correct */\r\n/* Optional: if, after processing, we want to copy data from buffer back into the object we could do */\r\nif (PyObject_CopyToObject(obj, buf, len, 'A') \u0026#x3C; 0) {\r\n    /* error return */\r\n}\r\n/* Make sure that if a copy was made, the memory is freed */\r\nif (copy == 1) PyMem_Free(buf);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 3118 - Revising the buffer protocol\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 14:26:38+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>