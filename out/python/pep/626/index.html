<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 626 - Precise line numbers for debugging and other tools.</h1><div class="page__meta"><time dateTime="2025-09-27 00:29:42+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0626/">PEP 626 - Precise line numbers for debugging and other tools.</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 15-Jul-2020</p>
</blockquote>
<h1>PEP 626 – 디버깅 및 기타 도구를 위한 정밀한 줄 번호 (Precise line numbers for debugging and other tools)</h1>
<p><strong>저자:</strong> Mark Shannon
<strong>BDFL-Delegate:</strong> Pablo Galindo
<strong>상태:</strong> Final
<strong>타입:</strong> Standards Track
<strong>생성일:</strong> 2020년 7월 15일
<strong>Python 버전:</strong> 3.10</p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 Python이 트레이싱(tracing)이 활성화되었을 때, 실행된 모든 코드 라인에 대해 "line" 트레이싱 이벤트를 생성하고, 실행된 코드 라인에 대해서만 이벤트를 생성하도록 보장해야 한다고 명시합니다.</p>
<p>프레임 객체의 <code>f_lineno</code> 속성은 항상 예상된 줄 번호를 포함해야 합니다. 프레임 실행 중에는 현재 실행 중인 소스 코드의 줄 번호가 되어야 하며, 프레임이 완료된 후에는 마지막으로 실행된 소스 코드의 줄 번호가 되어야 합니다.</p>
<p>정확한 줄 번호를 보장하기 위한 부수적인 효과로, 일부 바이트코드는 의미 있는 줄 번호가 없는 "인공적인(artificial)" 것으로 표시되어야 합니다. 도구를 돕기 위해, 바이트코드와 소스 간의 매핑을 설명하는 새로운 <code>co_lines</code> 속성이 추가될 것입니다.</p>
<h2>동기 (Motivation)</h2>
<p><code>sys.settrace</code> 및 관련 도구 사용자들은 모든 코드 라인에 대해 트레이싱 이벤트가 생성되며, 실제 코드에 대해서만 이벤트가 생성된다는 점을 신뢰할 수 있어야 합니다. 또한, <code>f_lineno</code>의 줄 번호가 정확하다고 가정할 수 있어야 합니다.</p>
<p>현재 구현은 대부분 이러한 역할을 수행하지만, 몇몇 경우에 실패합니다. 이는 도구에서 해결 방법을 필요로 하며, 다른 Python 구현체(alternative Python implementations)에 불편함을 줍니다. 이러한 보장은 CPython 구현자들에게도 장기적으로 이점을 제공하는데, 현재 동작은 명확하지 않고 몇몇 특이한 코너 케이스가 있기 때문입니다.</p>
<h2>근거 (Rationale)</h2>
<p>예상대로 줄 이벤트가 생성되도록 보장하기 위해, 현재 형태의 <code>co_lnotab</code> 속성은 더 이상 줄 번호 정보의 "진실의 원천(source of truth)"이 될 수 없습니다.</p>
<p><code>co_lnotab</code> 속성을 수정하려고 시도하기보다는, 바이트코드 오프셋과 소스 코드 줄에 대한 이터레이터를 반환하는 새로운 <code>co_lines()</code> 메서드가 추가될 것입니다.</p>
<p>정확한 줄 번호 정보를 활성화하기 위해 바이트코드가 올바르게 주석(annotated) 처리되도록 보장하는 것은 일부 바이트코드가 인공적인 것으로 표시되어야 하며 줄 번호가 없어야 함을 의미합니다.</p>
<p>기존 도구를 손상시키지 않도록 주의해야 합니다. 최소한의 손상을 위해 <code>co_lnotab</code> 속성은 유지되지만, 필요할 때 지연 생성(lazily generated)됩니다.</p>
<h2>명세 (Specification)</h2>
<p>줄 이벤트와 <code>f_lineno</code> 속성은 숙련된 Python 사용자가 모든 경우에 기대하는 대로 작동해야 합니다.</p>
<h3>트레이싱 (Tracing)</h3>
<p>트레이싱은 호출(calls), 반환(returns), 예외(exceptions), 실행된 소스 코드 줄, 그리고 특정 상황에서는 실행된 명령어(instructions)에 대한 이벤트를 생성합니다. 이 PEP는 줄 이벤트에 대해서만 다룹니다.</p>
<p>트레이싱이 활성화되면 다음 경우에 줄 이벤트가 생성됩니다.</p>
<ul>
<li>새로운 소스 코드 줄에 도달했을 때.</li>
<li>백워드 점프(backwards jump)가 발생했을 때 (예: List Comprehension에서와 같이 동일한 줄로 점프하더라도).</li>
</ul>
<p>또한, 실행되지 않은 소스 코드 줄에 대해서는 줄 이벤트가 절대 생성되지 않습니다.</p>
<h3>트레이싱 목적상 코드로 간주되는 것 (What is considered to be code for the purposes of tracing)</h3>
<p>모든 표현식(expressions)과 표현식의 부분은 실행 가능한 코드(executable code)로 간주됩니다.
일반적으로 모든 구문(statements)도 실행 가능한 코드로 간주됩니다. 그러나 구문이 여러 줄에 걸쳐 있을 때, 구문의 어떤 부분이 실행 가능한 코드로 간주되는지 고려해야 합니다.</p>
<p>구문은 키워드와 표현식으로 구성됩니다. 모든 키워드가 직접적인 런타임 효과를 가지지는 않으므로, 모든 키워드가 실행 가능한 코드로 간주되지는 않습니다. 예를 들어, <code>else</code>는 <code>if</code> 문의 필수적인 부분이지만, <code>else</code>와 관련된 런타임 효과는 없습니다.</p>
<p>트레이싱 목적상 다음 키워드는 실행 가능한 코드로 간주되지 않습니다.</p>
<ul>
<li><code>del</code> – 삭제될 표현식은 실행 가능한 코드로 처리됩니다.</li>
<li><code>else</code> – 런타임 효과 없음</li>
<li><code>finally</code> – 런타임 효과 없음</li>
<li><code>global</code> – 순수하게 선언적(declarative)</li>
<li><code>nonlocal</code> – 순수하게 선언적</li>
</ul>
<p>다른 모든 키워드는 실행 가능한 코드로 간주됩니다.</p>
<h3>이벤트 시퀀스 예시 (Example event sequences)</h3>
<p>다음 예시에서 이벤트는 "(이름)", <code>f_lineno</code> 쌍으로 표시됩니다.</p>
<p><strong>코드:</strong></p>
<pre><code class="language-python">1. global x
2. x = a
</code></pre>
<p>생성되는 이벤트:
<code>"line" 2</code></p>
<p><strong>코드:</strong></p>
<pre><code class="language-python">1. try:
2.     pass
3. finally:
4.     pass
</code></pre>
<p>생성되는 이벤트:
<code>"line" 1</code>
<code>"line" 2</code>
<code>"line" 4</code></p>
<p><strong>코드:</strong></p>
<pre><code class="language-python">1. for (
2.     x) in [1]:
3.     pass
4. return
</code></pre>
<p>생성되는 이벤트:
<code>"line" 2</code> # evaluate
<code>"line" 1</code> # for
<code>"line" 2</code> # store to x
<code>"line" 3</code> # pass
<code>"line" 1</code> # for
<code>"line" 4</code> # return
<code>"return" 1</code></p>
<h3><code>f_lineno</code> 속성 (The f_lineno attribute)</h3>
<p>프레임 객체가 생성될 때, <code>f_lineno</code> 속성은 함수나 클래스가 정의된 줄, 즉 <code>def</code> 또는 <code>class</code> 키워드가 나타나는 줄로 설정됩니다. 모듈의 경우 0으로 설정됩니다. <code>f_lineno</code> 속성은 트레이싱이 꺼져 있고 이벤트가 생성되지 않더라도, 실행될 줄 번호와 일치하도록 업데이트됩니다.</p>
<h3>코드 객체의 새로운 <code>co_lines()</code> 메서드 (The new co_lines() method of code objects)</h3>
<p><code>co_lines()</code> 메서드는 바이트코드 범위의 줄 번호를 나타내는 값들의 튜플을 반환하는 이터레이터를 제공합니다. 각 튜플은 세 가지 값으로 구성됩니다.</p>
<ul>
<li><code>start</code> – 바이트코드 범위의 시작 오프셋 (포함)</li>
<li><code>end</code> – 바이트코드 범위의 끝 오프셋 (제외)</li>
<li><code>line</code> – 줄 번호, 또는 주어진 범위의 바이트코드에 줄 번호가 없는 경우 <code>None</code></li>
</ul>
<p>생성된 시퀀스는 다음 속성을 가집니다.</p>
<ul>
<li>시퀀스의 첫 번째 범위는 <code>start</code>가 0입니다.</li>
<li><code>(start, end)</code> 범위는 감소하지 않고 연속적입니다. 즉, 어떤 두 튜플 쌍에 대해 두 번째 튜플의 <code>start</code>는 첫 번째 튜플의 <code>end</code>와 같습니다.</li>
<li>어떤 범위도 역방향이 아닙니다. 즉, 모든 세 값 튜플에 대해 <code>end >= start</code>입니다.</li>
<li>시퀀스의 마지막 범위는 <code>end</code>가 바이트코드의 크기와 같습니다.</li>
<li><code>line</code>은 양의 정수이거나 <code>None</code>입니다.</li>
</ul>
<h4>0 너비 범위 (Zero width ranges)</h4>
<p><code>start == end</code>인 0 너비 범위가 허용됩니다. 0 너비 범위는 소스 코드에 존재하지만 바이트코드 컴파일러에 의해 제거된 줄에 사용됩니다.</p>
<h3><code>co_linetable</code> 속성 (The co_linetable attribute)</h3>
<p><code>co_linetable</code> 속성은 줄 번호 정보를 저장합니다. 이 형식은 불투명하고(opaque) 명시되지 않으며 예고 없이 변경될 수 있습니다. 이 속성은 새로운 코드 객체 생성을 지원하기 위해서만 공개됩니다.</p>
<h3><code>co_lnotab</code> 속성 (The co_lnotab attribute)</h3>
<p>역사적으로 <code>co_lnotab</code> 속성은 바이트코드 오프셋에서 줄 번호로의 매핑을 담고 있었지만, 줄 번호가 없는 바이트코드를 지원하지 않습니다. 하위 호환성을 위해 <code>co_lnotab</code> 바이트 객체는 필요할 때 지연 생성됩니다. 줄 번호가 없는 바이트코드 범위의 경우, 이전 바이트코드 범위의 줄 번호가 사용됩니다.</p>
<p><code>co_lnotab</code> 테이블을 파싱하는 도구는 가능한 한 빨리 새로운 <code>co_lines()</code> 메서드를 사용하도록 전환해야 합니다.</p>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p><code>co_lnotab</code> 속성은 Python 3.10에서 Deprecated(더 이상 사용되지 않음)되고 Python 3.12에서 제거될 것입니다.</p>
<p>코드 객체의 <code>co_lnotab</code> 속성을 파싱하는 모든 도구는 3.12가 출시되기 전에 <code>co_lines()</code>를 사용하도록 전환해야 합니다. <code>sys.settrace</code>를 사용하는 도구는 수신하는 "line" 이벤트가 더 정확해지는 경우를 제외하고는 영향을 받지 않습니다.</p>
<h3>트레이스 이벤트 시퀀스가 변경될 코드 예시 (Examples of code for which the sequence of trace events will change)</h3>
<p>다음 예시에서 이벤트는 "(이름)", <code>f_lineno</code> 쌍으로 표시됩니다.</p>
<h4><code>if</code> 문 내의 <code>pass</code> 문 (pass statement in an if statement)</h4>
<pre><code class="language-python">0. def spam(a):
1.     if a:
2.         eggs()
3.     else:
4.         pass
</code></pre>
<p><code>a</code>가 <code>True</code>인 경우 Python 3.9에서 생성되는 이벤트 시퀀스:
<code>"line" 1</code>
<code>"line" 2</code>
<code>"line" 4</code>
<code>"return" 4</code></p>
<p>Python 3.10부터의 시퀀스는 다음과 같습니다:
<code>"line" 1</code>
<code>"line" 2</code>
<code>"return" 2</code></p>
<h4>여러 개의 <code>pass</code> 문 (Multiple pass statements)</h4>
<pre><code class="language-python">0. def bar():
1.     pass
2.     pass
3.     pass
</code></pre>
<p>Python 3.9에서 생성되는 이벤트 시퀀스:
<code>"line" 3</code>
<code>"return" 3</code></p>
<p>Python 3.10부터의 시퀀스는 다음과 같습니다:
<code>"line" 1</code>
<code>"line" 2</code>
<code>"line" 3</code>
<code>"return" 3</code></p>
<h2>C API</h2>
<p>C API 함수를 통한 프레임 객체의 <code>f_lineno</code> 속성 접근은 변경되지 않습니다. <code>f_lineno</code>는 <code>PyFrame_GetLineNumber</code>로 읽을 수 있습니다. <code>f_lineno</code>는 <code>PyObject_SetAttr</code> 및 유사 함수를 통해서만 설정할 수 있습니다.</p>
<p>기저 데이터 구조를 통해 <code>f_lineno</code>에 직접 접근하는 것은 금지됩니다.</p>
<h2>프로세스 외부 디버거 및 프로파일러 (Out of process debuggers and profilers)</h2>
<p><code>py-spy</code>와 같은 프로세스 외부 도구는 C-API를 사용할 수 없으므로, 줄 번호 테이블을 직접 파싱해야 합니다. 줄 번호 테이블 형식은 예고 없이 변경될 수 있지만, 버그 수정을 위해 절대적으로 필요한 경우가 아니면 릴리스 중에는 변경되지 않습니다.</p>
<p>이러한 도구 구현에 필요한 작업을 줄이기 위해 다음 C 구조체와 유틸리티 함수가 제공됩니다. 이 함수들은 C-API의 일부가 아니므로, 사용해야 하는 모든 코드에 링크되어야 합니다.</p>
<pre><code class="language-c">typedef struct addressrange {
    int ar_start;
    int ar_end;
    int ar_line;
    struct _opaque opaque;
} PyCodeAddressRange;

void PyLineTable_InitAddressRange(char *linetable, Py_ssize_t length, int firstlineno, PyCodeAddressRange *range);
int PyLineTable_NextAddressRange(PyCodeAddressRange *range);
int PyLineTable_PreviousAddressRange(PyCodeAddressRange *range);
</code></pre>
<p><code>PyLineTable_InitAddressRange</code>는 줄 번호 테이블과 첫 번째 줄 번호에서 <code>PyCodeAddressRange</code> 구조체를 초기화합니다.
<code>PyLineTable_NextAddressRange</code>는 범위를 다음 엔트리로 진행시키고, 유효하면 0이 아닌 값을 반환합니다.
<code>PyLineTable_PreviousAddressRange</code>는 범위를 이전 엔트리로 되돌리고, 유효하면 0이 아닌 값을 반환합니다.</p>
<p><strong>참고:</strong> <code>linetable</code>의 데이터는 변경 불가능하지만, 그 수명은 코드 객체에 따라 달라집니다. 안정적인 작동을 위해 <code>PyLineTable_InitAddressRange</code>를 호출하기 전에 <code>linetable</code>을 로컬 버퍼로 복사해야 합니다.</p>
<p>이 함수들은 C-API의 일부는 아니지만, CPython의 모든 미래 버전에서 제공될 것입니다. <code>PyLineTable_</code> 함수는 C-API를 호출하지 않으므로, 이들을 사용해야 하는 모든 도구에 안전하게 복사될 수 있습니다. <code>PyCodeAddressRange</code> 구조체는 변경되지 않지만, <code>_opaque</code> 구조체는 명세의 일부가 아니며 변경될 수 있습니다.</p>
<p>예를 들어, 다음 코드는 모든 주소 범위를 출력합니다.</p>
<pre><code class="language-c">void print_address_ranges(char *linetable, Py_ssize_t length, int firstlineno) {
    PyCodeAddressRange range;
    PyLineTable_InitAddressRange(linetable, length, firstlineno, &#x26;range);
    while (PyLineTable_NextAddressRange(&#x26;range)) {
        printf("Bytecodes from %d (inclusive) to %d (exclusive) ", range.start, range.end);
        if (range.line &#x3C; 0) { /* line &#x3C; 0 means no line number */
            printf("have no line number\n");
        } else {
            printf("have line number %d\n", range.line);
        }
    }
}
</code></pre>
<h2>성능 영향 (Performance Implications)</h2>
<p>일반적으로 성능 변화는 없을 것입니다. 트레이싱 시에는 새로운 테이블 형식이 줄 번호 계산 속도를 고려하여 설계될 수 있으므로 프로그램이 약간 더 빠르게 실행될 수 있습니다. <code>pass</code> 문이 길게 연속되는 코드는 약간 느려질 수 있습니다.</p>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/626\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"qNOrJYeuqip9qCFPpDVpu\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/626/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/626\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"626\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/626\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T3c82,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0626/\"\u003ePEP 626 - Precise line numbers for debugging and other tools.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 15-Jul-2020\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 626 – 디버깅 및 기타 도구를 위한 정밀한 줄 번호 (Precise line numbers for debugging and other tools)\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e저자:\u003c/strong\u003e Mark Shannon\n\u003cstrong\u003eBDFL-Delegate:\u003c/strong\u003e Pablo Galindo\n\u003cstrong\u003e상태:\u003c/strong\u003e Final\n\u003cstrong\u003e타입:\u003c/strong\u003e Standards Track\n\u003cstrong\u003e생성일:\u003c/strong\u003e 2020년 7월 15일\n\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.10\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 Python이 트레이싱(tracing)이 활성화되었을 때, 실행된 모든 코드 라인에 대해 \"line\" 트레이싱 이벤트를 생성하고, 실행된 코드 라인에 대해서만 이벤트를 생성하도록 보장해야 한다고 명시합니다.\u003c/p\u003e\n\u003cp\u003e프레임 객체의 \u003ccode\u003ef_lineno\u003c/code\u003e 속성은 항상 예상된 줄 번호를 포함해야 합니다. 프레임 실행 중에는 현재 실행 중인 소스 코드의 줄 번호가 되어야 하며, 프레임이 완료된 후에는 마지막으로 실행된 소스 코드의 줄 번호가 되어야 합니다.\u003c/p\u003e\n\u003cp\u003e정확한 줄 번호를 보장하기 위한 부수적인 효과로, 일부 바이트코드는 의미 있는 줄 번호가 없는 \"인공적인(artificial)\" 것으로 표시되어야 합니다. 도구를 돕기 위해, 바이트코드와 소스 간의 매핑을 설명하는 새로운 \u003ccode\u003eco_lines\u003c/code\u003e 속성이 추가될 것입니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esys.settrace\u003c/code\u003e 및 관련 도구 사용자들은 모든 코드 라인에 대해 트레이싱 이벤트가 생성되며, 실제 코드에 대해서만 이벤트가 생성된다는 점을 신뢰할 수 있어야 합니다. 또한, \u003ccode\u003ef_lineno\u003c/code\u003e의 줄 번호가 정확하다고 가정할 수 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e현재 구현은 대부분 이러한 역할을 수행하지만, 몇몇 경우에 실패합니다. 이는 도구에서 해결 방법을 필요로 하며, 다른 Python 구현체(alternative Python implementations)에 불편함을 줍니다. 이러한 보장은 CPython 구현자들에게도 장기적으로 이점을 제공하는데, 현재 동작은 명확하지 않고 몇몇 특이한 코너 케이스가 있기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e예상대로 줄 이벤트가 생성되도록 보장하기 위해, 현재 형태의 \u003ccode\u003eco_lnotab\u003c/code\u003e 속성은 더 이상 줄 번호 정보의 \"진실의 원천(source of truth)\"이 될 수 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eco_lnotab\u003c/code\u003e 속성을 수정하려고 시도하기보다는, 바이트코드 오프셋과 소스 코드 줄에 대한 이터레이터를 반환하는 새로운 \u003ccode\u003eco_lines()\u003c/code\u003e 메서드가 추가될 것입니다.\u003c/p\u003e\n\u003cp\u003e정확한 줄 번호 정보를 활성화하기 위해 바이트코드가 올바르게 주석(annotated) 처리되도록 보장하는 것은 일부 바이트코드가 인공적인 것으로 표시되어야 하며 줄 번호가 없어야 함을 의미합니다.\u003c/p\u003e\n\u003cp\u003e기존 도구를 손상시키지 않도록 주의해야 합니다. 최소한의 손상을 위해 \u003ccode\u003eco_lnotab\u003c/code\u003e 속성은 유지되지만, 필요할 때 지연 생성(lazily generated)됩니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003cp\u003e줄 이벤트와 \u003ccode\u003ef_lineno\u003c/code\u003e 속성은 숙련된 Python 사용자가 모든 경우에 기대하는 대로 작동해야 합니다.\u003c/p\u003e\n\u003ch3\u003e트레이싱 (Tracing)\u003c/h3\u003e\n\u003cp\u003e트레이싱은 호출(calls), 반환(returns), 예외(exceptions), 실행된 소스 코드 줄, 그리고 특정 상황에서는 실행된 명령어(instructions)에 대한 이벤트를 생성합니다. 이 PEP는 줄 이벤트에 대해서만 다룹니다.\u003c/p\u003e\n\u003cp\u003e트레이싱이 활성화되면 다음 경우에 줄 이벤트가 생성됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e새로운 소스 코드 줄에 도달했을 때.\u003c/li\u003e\n\u003cli\u003e백워드 점프(backwards jump)가 발생했을 때 (예: List Comprehension에서와 같이 동일한 줄로 점프하더라도).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한, 실행되지 않은 소스 코드 줄에 대해서는 줄 이벤트가 절대 생성되지 않습니다.\u003c/p\u003e\n\u003ch3\u003e트레이싱 목적상 코드로 간주되는 것 (What is considered to be code for the purposes of tracing)\u003c/h3\u003e\n\u003cp\u003e모든 표현식(expressions)과 표현식의 부분은 실행 가능한 코드(executable code)로 간주됩니다.\n일반적으로 모든 구문(statements)도 실행 가능한 코드로 간주됩니다. 그러나 구문이 여러 줄에 걸쳐 있을 때, 구문의 어떤 부분이 실행 가능한 코드로 간주되는지 고려해야 합니다.\u003c/p\u003e\n\u003cp\u003e구문은 키워드와 표현식으로 구성됩니다. 모든 키워드가 직접적인 런타임 효과를 가지지는 않으므로, 모든 키워드가 실행 가능한 코드로 간주되지는 않습니다. 예를 들어, \u003ccode\u003eelse\u003c/code\u003e는 \u003ccode\u003eif\u003c/code\u003e 문의 필수적인 부분이지만, \u003ccode\u003eelse\u003c/code\u003e와 관련된 런타임 효과는 없습니다.\u003c/p\u003e\n\u003cp\u003e트레이싱 목적상 다음 키워드는 실행 가능한 코드로 간주되지 않습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edel\u003c/code\u003e – 삭제될 표현식은 실행 가능한 코드로 처리됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eelse\u003c/code\u003e – 런타임 효과 없음\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efinally\u003c/code\u003e – 런타임 효과 없음\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eglobal\u003c/code\u003e – 순수하게 선언적(declarative)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enonlocal\u003c/code\u003e – 순수하게 선언적\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다른 모든 키워드는 실행 가능한 코드로 간주됩니다.\u003c/p\u003e\n\u003ch3\u003e이벤트 시퀀스 예시 (Example event sequences)\u003c/h3\u003e\n\u003cp\u003e다음 예시에서 이벤트는 \"(이름)\", \u003ccode\u003ef_lineno\u003c/code\u003e 쌍으로 표시됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e코드:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e1. global x\n2. x = a\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e생성되는 이벤트:\n\u003ccode\u003e\"line\" 2\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e코드:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e1. try:\n2.     pass\n3. finally:\n4.     pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e생성되는 이벤트:\n\u003ccode\u003e\"line\" 1\u003c/code\u003e\n\u003ccode\u003e\"line\" 2\u003c/code\u003e\n\u003ccode\u003e\"line\" 4\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e코드:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e1. for (\n2.     x) in [1]:\n3.     pass\n4. return\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e생성되는 이벤트:\n\u003ccode\u003e\"line\" 2\u003c/code\u003e # evaluate\n\u003ccode\u003e\"line\" 1\u003c/code\u003e # for\n\u003ccode\u003e\"line\" 2\u003c/code\u003e # store to x\n\u003ccode\u003e\"line\" 3\u003c/code\u003e # pass\n\u003ccode\u003e\"line\" 1\u003c/code\u003e # for\n\u003ccode\u003e\"line\" 4\u003c/code\u003e # return\n\u003ccode\u003e\"return\" 1\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ef_lineno\u003c/code\u003e 속성 (The f_lineno attribute)\u003c/h3\u003e\n\u003cp\u003e프레임 객체가 생성될 때, \u003ccode\u003ef_lineno\u003c/code\u003e 속성은 함수나 클래스가 정의된 줄, 즉 \u003ccode\u003edef\u003c/code\u003e 또는 \u003ccode\u003eclass\u003c/code\u003e 키워드가 나타나는 줄로 설정됩니다. 모듈의 경우 0으로 설정됩니다. \u003ccode\u003ef_lineno\u003c/code\u003e 속성은 트레이싱이 꺼져 있고 이벤트가 생성되지 않더라도, 실행될 줄 번호와 일치하도록 업데이트됩니다.\u003c/p\u003e\n\u003ch3\u003e코드 객체의 새로운 \u003ccode\u003eco_lines()\u003c/code\u003e 메서드 (The new co_lines() method of code objects)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eco_lines()\u003c/code\u003e 메서드는 바이트코드 범위의 줄 번호를 나타내는 값들의 튜플을 반환하는 이터레이터를 제공합니다. 각 튜플은 세 가지 값으로 구성됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003estart\u003c/code\u003e – 바이트코드 범위의 시작 오프셋 (포함)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eend\u003c/code\u003e – 바이트코드 범위의 끝 오프셋 (제외)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eline\u003c/code\u003e – 줄 번호, 또는 주어진 범위의 바이트코드에 줄 번호가 없는 경우 \u003ccode\u003eNone\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e생성된 시퀀스는 다음 속성을 가집니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e시퀀스의 첫 번째 범위는 \u003ccode\u003estart\u003c/code\u003e가 0입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e(start, end)\u003c/code\u003e 범위는 감소하지 않고 연속적입니다. 즉, 어떤 두 튜플 쌍에 대해 두 번째 튜플의 \u003ccode\u003estart\u003c/code\u003e는 첫 번째 튜플의 \u003ccode\u003eend\u003c/code\u003e와 같습니다.\u003c/li\u003e\n\u003cli\u003e어떤 범위도 역방향이 아닙니다. 즉, 모든 세 값 튜플에 대해 \u003ccode\u003eend \u003e= start\u003c/code\u003e입니다.\u003c/li\u003e\n\u003cli\u003e시퀀스의 마지막 범위는 \u003ccode\u003eend\u003c/code\u003e가 바이트코드의 크기와 같습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eline\u003c/code\u003e은 양의 정수이거나 \u003ccode\u003eNone\u003c/code\u003e입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e0 너비 범위 (Zero width ranges)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003estart == end\u003c/code\u003e인 0 너비 범위가 허용됩니다. 0 너비 범위는 소스 코드에 존재하지만 바이트코드 컴파일러에 의해 제거된 줄에 사용됩니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eco_linetable\u003c/code\u003e 속성 (The co_linetable attribute)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eco_linetable\u003c/code\u003e 속성은 줄 번호 정보를 저장합니다. 이 형식은 불투명하고(opaque) 명시되지 않으며 예고 없이 변경될 수 있습니다. 이 속성은 새로운 코드 객체 생성을 지원하기 위해서만 공개됩니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eco_lnotab\u003c/code\u003e 속성 (The co_lnotab attribute)\u003c/h3\u003e\n\u003cp\u003e역사적으로 \u003ccode\u003eco_lnotab\u003c/code\u003e 속성은 바이트코드 오프셋에서 줄 번호로의 매핑을 담고 있었지만, 줄 번호가 없는 바이트코드를 지원하지 않습니다. 하위 호환성을 위해 \u003ccode\u003eco_lnotab\u003c/code\u003e 바이트 객체는 필요할 때 지연 생성됩니다. 줄 번호가 없는 바이트코드 범위의 경우, 이전 바이트코드 범위의 줄 번호가 사용됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eco_lnotab\u003c/code\u003e 테이블을 파싱하는 도구는 가능한 한 빨리 새로운 \u003ccode\u003eco_lines()\u003c/code\u003e 메서드를 사용하도록 전환해야 합니다.\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eco_lnotab\u003c/code\u003e 속성은 Python 3.10에서 Deprecated(더 이상 사용되지 않음)되고 Python 3.12에서 제거될 것입니다.\u003c/p\u003e\n\u003cp\u003e코드 객체의 \u003ccode\u003eco_lnotab\u003c/code\u003e 속성을 파싱하는 모든 도구는 3.12가 출시되기 전에 \u003ccode\u003eco_lines()\u003c/code\u003e를 사용하도록 전환해야 합니다. \u003ccode\u003esys.settrace\u003c/code\u003e를 사용하는 도구는 수신하는 \"line\" 이벤트가 더 정확해지는 경우를 제외하고는 영향을 받지 않습니다.\u003c/p\u003e\n\u003ch3\u003e트레이스 이벤트 시퀀스가 변경될 코드 예시 (Examples of code for which the sequence of trace events will change)\u003c/h3\u003e\n\u003cp\u003e다음 예시에서 이벤트는 \"(이름)\", \u003ccode\u003ef_lineno\u003c/code\u003e 쌍으로 표시됩니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eif\u003c/code\u003e 문 내의 \u003ccode\u003epass\u003c/code\u003e 문 (pass statement in an if statement)\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e0. def spam(a):\n1.     if a:\n2.         eggs()\n3.     else:\n4.         pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ea\u003c/code\u003e가 \u003ccode\u003eTrue\u003c/code\u003e인 경우 Python 3.9에서 생성되는 이벤트 시퀀스:\n\u003ccode\u003e\"line\" 1\u003c/code\u003e\n\u003ccode\u003e\"line\" 2\u003c/code\u003e\n\u003ccode\u003e\"line\" 4\u003c/code\u003e\n\u003ccode\u003e\"return\" 4\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003ePython 3.10부터의 시퀀스는 다음과 같습니다:\n\u003ccode\u003e\"line\" 1\u003c/code\u003e\n\u003ccode\u003e\"line\" 2\u003c/code\u003e\n\u003ccode\u003e\"return\" 2\u003c/code\u003e\u003c/p\u003e\n\u003ch4\u003e여러 개의 \u003ccode\u003epass\u003c/code\u003e 문 (Multiple pass statements)\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e0. def bar():\n1.     pass\n2.     pass\n3.     pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 3.9에서 생성되는 이벤트 시퀀스:\n\u003ccode\u003e\"line\" 3\u003c/code\u003e\n\u003ccode\u003e\"return\" 3\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003ePython 3.10부터의 시퀀스는 다음과 같습니다:\n\u003ccode\u003e\"line\" 1\u003c/code\u003e\n\u003ccode\u003e\"line\" 2\u003c/code\u003e\n\u003ccode\u003e\"line\" 3\u003c/code\u003e\n\u003ccode\u003e\"return\" 3\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003eC API\u003c/h2\u003e\n\u003cp\u003eC API 함수를 통한 프레임 객체의 \u003ccode\u003ef_lineno\u003c/code\u003e 속성 접근은 변경되지 않습니다. \u003ccode\u003ef_lineno\u003c/code\u003e는 \u003ccode\u003ePyFrame_GetLineNumber\u003c/code\u003e로 읽을 수 있습니다. \u003ccode\u003ef_lineno\u003c/code\u003e는 \u003ccode\u003ePyObject_SetAttr\u003c/code\u003e 및 유사 함수를 통해서만 설정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e기저 데이터 구조를 통해 \u003ccode\u003ef_lineno\u003c/code\u003e에 직접 접근하는 것은 금지됩니다.\u003c/p\u003e\n\u003ch2\u003e프로세스 외부 디버거 및 프로파일러 (Out of process debuggers and profilers)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003epy-spy\u003c/code\u003e와 같은 프로세스 외부 도구는 C-API를 사용할 수 없으므로, 줄 번호 테이블을 직접 파싱해야 합니다. 줄 번호 테이블 형식은 예고 없이 변경될 수 있지만, 버그 수정을 위해 절대적으로 필요한 경우가 아니면 릴리스 중에는 변경되지 않습니다.\u003c/p\u003e\n\u003cp\u003e이러한 도구 구현에 필요한 작업을 줄이기 위해 다음 C 구조체와 유틸리티 함수가 제공됩니다. 이 함수들은 C-API의 일부가 아니므로, 사용해야 하는 모든 코드에 링크되어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct addressrange {\n    int ar_start;\n    int ar_end;\n    int ar_line;\n    struct _opaque opaque;\n} PyCodeAddressRange;\n\nvoid PyLineTable_InitAddressRange(char *linetable, Py_ssize_t length, int firstlineno, PyCodeAddressRange *range);\nint PyLineTable_NextAddressRange(PyCodeAddressRange *range);\nint PyLineTable_PreviousAddressRange(PyCodeAddressRange *range);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ePyLineTable_InitAddressRange\u003c/code\u003e는 줄 번호 테이블과 첫 번째 줄 번호에서 \u003ccode\u003ePyCodeAddressRange\u003c/code\u003e 구조체를 초기화합니다.\n\u003ccode\u003ePyLineTable_NextAddressRange\u003c/code\u003e는 범위를 다음 엔트리로 진행시키고, 유효하면 0이 아닌 값을 반환합니다.\n\u003ccode\u003ePyLineTable_PreviousAddressRange\u003c/code\u003e는 범위를 이전 엔트리로 되돌리고, 유효하면 0이 아닌 값을 반환합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e \u003ccode\u003elinetable\u003c/code\u003e의 데이터는 변경 불가능하지만, 그 수명은 코드 객체에 따라 달라집니다. 안정적인 작동을 위해 \u003ccode\u003ePyLineTable_InitAddressRange\u003c/code\u003e를 호출하기 전에 \u003ccode\u003elinetable\u003c/code\u003e을 로컬 버퍼로 복사해야 합니다.\u003c/p\u003e\n\u003cp\u003e이 함수들은 C-API의 일부는 아니지만, CPython의 모든 미래 버전에서 제공될 것입니다. \u003ccode\u003ePyLineTable_\u003c/code\u003e 함수는 C-API를 호출하지 않으므로, 이들을 사용해야 하는 모든 도구에 안전하게 복사될 수 있습니다. \u003ccode\u003ePyCodeAddressRange\u003c/code\u003e 구조체는 변경되지 않지만, \u003ccode\u003e_opaque\u003c/code\u003e 구조체는 명세의 일부가 아니며 변경될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 다음 코드는 모든 주소 범위를 출력합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003evoid print_address_ranges(char *linetable, Py_ssize_t length, int firstlineno) {\n    PyCodeAddressRange range;\n    PyLineTable_InitAddressRange(linetable, length, firstlineno, \u0026#x26;range);\n    while (PyLineTable_NextAddressRange(\u0026#x26;range)) {\n        printf(\"Bytecodes from %d (inclusive) to %d (exclusive) \", range.start, range.end);\n        if (range.line \u0026#x3C; 0) { /* line \u0026#x3C; 0 means no line number */\n            printf(\"have no line number\\n\");\n        } else {\n            printf(\"have line number %d\\n\", range.line);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e성능 영향 (Performance Implications)\u003c/h2\u003e\n\u003cp\u003e일반적으로 성능 변화는 없을 것입니다. 트레이싱 시에는 새로운 테이블 형식이 줄 번호 계산 속도를 고려하여 설계될 수 있으므로 프로그램이 약간 더 빠르게 실행될 수 있습니다. \u003ccode\u003epass\u003c/code\u003e 문이 길게 연속되는 코드는 약간 느려질 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 626 - Precise line numbers for debugging and other tools.\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 00:29:42+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>