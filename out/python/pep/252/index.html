<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-19cfc001fdac3337.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1098<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 252 - Making Types Look More Like Classes</h1><div class="page__meta"><time dateTime="2025-09-26 17:30:03+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0252/">PEP 252 - Making Types Look More Like Classes</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 19-Apr-2001</p>
</blockquote>
<h1>PEP 252 – 타입을 클래스처럼 보이게 만들기</h1>
<p><strong>작성자:</strong> Guido van Rossum 
<strong>상태:</strong> 최종 (Final)
<strong>유형:</strong> 표준 트랙 (Standards Track)
<strong>생성일:</strong> 2001년 4월 19일
<strong>Python 버전:</strong> 2.2
<strong>이전 이력:</strong></p>
<h2>요약 (Abstract)</h2>
<p>이 PEP는 타입(types)의 인트로스펙션(introspection) API를 변경하여, 타입이 클래스(classes)처럼 보이고 타입의 인스턴스가 클래스 인스턴스처럼 보이게 할 것을 제안합니다. 예를 들어, 대부분의 내장 타입(built-in types)의 경우 <code>type(x)</code>는 <code>x.__class__</code>와 동일해집니다. <code>C</code>가 <code>x.__class__</code>일 때, <code>x.meth(a)</code>는 일반적으로 <code>C.meth(x, a)</code>와 동일하며, <code>C.__dict__</code>는 <code>x</code>의 메서드와 다른 속성들을 포함하게 됩니다.</p>
<p>이 PEP는 또한 "속성 디스크립터(attribute descriptors)", 줄여서 "디스크립터(descriptors)"를 사용하여 속성을 지정하는 새로운 접근 방식을 소개합니다. 디스크립터는 속성을 설명하는 데 사용되는 여러 가지 일반적인 메커니즘을 통합하고 일반화합니다. 디스크립터는 메서드(method), 객체 구조의 타입 필드(typed field), 또는 getter 및 setter 함수로 표현되는 일반화된 속성을 설명할 수 있습니다.</p>
<p>일반화된 디스크립터 API를 기반으로, 이 PEP는 또한 클래스 메서드(class methods)와 스태틱 메서드(static methods)를 선언하는 방법을 소개합니다.</p>
<p><strong>[편집자 주: 이 PEP에 설명된 아이디어는 Python에 통합되었습니다. 이 PEP는 더 이상 구현을 정확하게 설명하지 않습니다.]</strong></p>
<h2>서론 (Introduction)</h2>
<p>Python의 가장 오래된 언어적 결함(language warts) 중 하나는 클래스와 타입 간의 차이입니다. 예를 들어, 딕셔너리(dictionary) 타입을 직접 서브클래싱(subclass)할 수 없으며, 객체가 어떤 메서드와 인스턴스 변수(instance variables)를 가지고 있는지 알아내는 인트로스펙션 인터페이스가 타입과 클래스에 대해 서로 다릅니다.</p>
<p>클래스/타입 분할을 해결하는 것은 Python이 구현되는 방식의 여러 측면에 영향을 미치기 때문에 큰 노력입니다. 이 PEP는 타입의 인트로스펙션 API를 클래스의 인트로스펙션 API와 동일하게 만드는 데 중점을 둡니다. 다른 PEP들은 클래스를 타입처럼 보이게 하고 내장 타입을 서브클래싱하는 것을 제안할 것이며, 이 주제들은 이 PEP의 의제가 아닙니다.</p>
<h2>인트로스펙션 API (Introspection APIs)</h2>
<p>인트로스펙션은 객체가 어떤 속성을 가지고 있는지 알아내는 것에 관한 것입니다. Python의 매우 일반적인 <code>getattr</code>/<code>setattr</code> API는 특정 객체가 지원하는 모든 속성 목록을 얻을 수 있는 방법이 항상 존재한다고 보장하는 것을 불가능하게 만들지만, 실제로는 거의 모든 객체에 대해 함께 작동하는 두 가지 규칙이 나타났습니다. 저는 이것들을 클래스 기반 인트로스펙션 API (class-based introspection API)와 타입 기반 인트로스펙션 API (type-based introspection API)라고 부르겠습니다. 줄여서 클래스 API와 타입 API입니다.</p>
<p><strong>클래스 기반 인트로스펙션 API</strong>는 주로 클래스 인스턴스에 사용되며, Jim Fulton의 ExtensionClasses에서도 사용됩니다. 이 API는 객체 <code>x</code>의 모든 데이터 속성이 딕셔너리 <code>x.__dict__</code>에 저장되고, 모든 메서드와 클래스 변수는 <code>x</code>의 클래스인 <code>x.__class__</code>를 검사하여 찾을 수 있다고 가정합니다. 클래스에는 메서드와 클래스 자체에 의해 정의된 클래스 변수를 포함하는 딕셔너리를 제공하는 <code>__dict__</code> 속성과, 재귀적으로 검사되어야 하는 기본 클래스(base classes)의 튜플인 <code>__bases__</code> 속성이 있습니다. 여기에는 몇 가지 가정이 있습니다:</p>
<ul>
<li>인스턴스 딕셔너리(instance dict)에 정의된 속성은 객체의 클래스에 의해 정의된 속성을 재정의합니다.</li>
<li>파생 클래스(derived class)에 정의된 속성은 기본 클래스에 정의된 속성을 재정의합니다.</li>
<li><code>__bases__</code>에서 먼저 나타나는 이전 기본 클래스에 정의된 속성은 나중에 나타나는 기본 클래스에 정의된 속성을 재정의합니다.</li>
</ul>
<p>(마지막 두 규칙은 종종 속성 검색에 대한 왼쪽에서 오른쪽, 깊이 우선(left-to-right, depth-first) 규칙으로 요약됩니다. 이것은 고전적인 Python 속성 검색 규칙입니다. PEP 253은 속성 검색 순서를 변경할 것을 제안할 것이며, 만약 수락된다면 이 PEP도 따를 것입니다.)</p>
<p><strong>타입 기반 인트로스펙션 API</strong>는 대부분의 내장 객체에서 어떤 형태로든 지원됩니다. 이 API는 두 개의 특수 속성인 <code>__members__</code>와 <code>__methods__</code>를 사용합니다. <code>__methods__</code> 속성은 존재할 경우 객체가 지원하는 메서드 이름 목록입니다. <code>__members__</code> 속성은 존재할 경우 객체가 지원하는 데이터 속성 이름 목록입니다.</p>
<p>타입 API는 때때로 인스턴스와 동일하게 작동하는 <code>__dict__</code>와 결합됩니다 (예: Python 2.1의 함수 객체의 경우, <code>f.__dict__</code>는 <code>f</code>의 동적 속성을 포함하고, <code>f.__members__</code>는 <code>f</code>의 정적으로 정의된 속성 이름을 나열합니다).</p>
<p>일부 주의가 필요합니다: 어떤 객체는 <code>__dict__</code>나 <code>__doc__</code>와 같은 "내재적(intrinsic)" 속성을 <code>__members__</code>에 나열하지 않는 반면, 다른 객체는 나열합니다. 때때로 속성 이름이 <code>__members__</code> 또는 <code>__methods__</code>와 <code>__dict__</code>의 키(key) 모두에 나타나는 경우도 있는데, 이 경우 <code>__dict__</code>에서 찾은 값이 사용되는지 여부는 알 수 없습니다.</p>
<p>타입 API는 한 번도 신중하게 명시된 적이 없습니다. 이는 Python의 통설(folklore)의 일부이며, 대부분의 서드파티 확장(third party extensions)은 이를 지원하는 예시를 따르기 때문에 지원합니다. 또한, <code>tp_getattr</code> 핸들러에서 <code>Py_FindMethod()</code> 및/또는 <code>PyMember_Get()</code>을 사용하는 모든 타입은 각각 <code>__methods__</code> 및 <code>__members__</code> 속성 이름을 특별히 처리하기 때문에 이를 지원합니다.</p>
<p>Jim Fulton의 ExtensionClasses는 타입 API를 무시하고, 더 강력한 클래스 API를 에뮬레이트합니다. 이 PEP에서는 모든 타입에 클래스 API를 지원하기 위해 타입 API를 단계적으로 폐지할 것을 제안합니다.</p>
<p>클래스 API를 선호하는 한 가지 주장은 타입이 지원하는 속성을 알아내기 위해 인스턴스를 생성할 필요가 없다는 것입니다. 이는 문서 프로세서(documentation processors)에 유용합니다. 예를 들어, <code>socket</code> 모듈은 <code>SocketType</code> 객체를 내보내지만, 현재 <code>socket</code> 객체에 어떤 메서드가 정의되어 있는지 알려주지 않습니다. 클래스 API를 사용하면 <code>SocketType</code>이 <code>socket</code> 객체의 메서드를 정확히 보여주며, 소켓을 생성하지 않고도 해당 독스트링(docstrings)을 추출할 수 있습니다. (이것은 C 확장 모듈이므로, 이 경우 소스 스캐닝 방식의 독스트링 추출은 실현 가능하지 않습니다.)</p>
<h2>클래스 기반 인트로스펙션 API의 명세 (Specification of the class-based introspection API)</h2>
<p>객체는 정적(static) 속성과 동적(dynamic) 속성의 두 가지 종류의 속성을 가질 수 있습니다. 정적 속성의 이름과 때로는 다른 속성들은 <code>obj.__class__</code> 또는 <code>type(obj)</code>를 통해 접근할 수 있는 객체의 타입 또는 클래스(메타-객체)를 검사하여 알 수 있습니다. (저는 여기에서 <code>type</code>과 <code>class</code>를 상호 교환적으로 사용합니다. 둘 다에 해당하는 서투르지만 설명적인 용어는 "메타-객체"입니다.)</p>
<p>(XXX "static" 및 "dynamic"은 여기서 사용하기 좋은 용어가 아닙니다. 왜냐하면 "static" 속성도 실제로는 매우 동적으로 동작할 수 있고, C++ 또는 Java의 static 클래스 멤버와는 아무 관련이 없기 때문입니다. Barry는 대신 "immutable" 및 "mutable"을 사용할 것을 제안했지만, 이 단어들은 이미 약간 다른 맥락에서 정확하고 다른 의미를 가지고 있으므로 여전히 혼란스러울 것이라고 생각합니다.)</p>
<p>동적 속성의 예시로는 클래스 인스턴스의 인스턴스 변수, 모듈 속성 등이 있습니다. 정적 속성의 예시로는 리스트(lists) 및 딕셔너리(dictionaries)와 같은 내장 객체의 메서드, 그리고 프레임(frame) 및 코드(code) 객체의 속성 (<code>f.f_code</code>, <code>c.co_filename</code> 등)이 있습니다. 동적 속성을 가진 객체가 <code>__dict__</code> 속성을 통해 이들을 노출할 때, <code>__dict__</code>는 정적 속성입니다.</p>
<p>동적 속성의 이름과 값은 일반적으로 딕셔너리에 저장되며, 이 딕셔너리는 일반적으로 <code>obj.__dict__</code>로 접근할 수 있습니다. 이 명세의 나머지 부분은 동적 속성보다는 정적 속성의 이름과 속성을 찾는 데 더 중점을 둡니다. 동적 속성은 <code>obj.__dict__</code>를 검사하여 쉽게 찾을 수 있습니다.</p>
<p>아래 논의에서 저는 두 가지 종류의 객체를 구분합니다: 일반 객체(regular objects) (예: 리스트, 정수, 함수)와 메타-객체(meta-objects). 타입과 클래스는 메타-객체입니다. 메타-객체도 일반 객체이지만, 주로 일반 객체의 <code>__class__</code> 속성(또는 다른 메타-객체의 <code>__bases__</code> 속성)에 의해 참조되기 때문에 중요하게 다룹니다.</p>
<p>클래스 인트로스펙션 API는 다음 요소들로 구성됩니다:</p>
<ul>
<li>일반 객체의 <code>__class__</code> 및 <code>__dict__</code> 속성</li>
<li>메타-객체의 <code>__bases__</code> 및 <code>__dict__</code> 속성</li>
<li>우선순위 규칙 (precedence rules)</li>
<li>속성 디스크립터 (attribute descriptors)</li>
</ul>
<p>이들은 함께 메타-객체에 의해 정의된 모든 속성에 대해 알려줄 뿐만 아니라, 주어진 객체의 특정 속성 값을 계산하는 데도 도움을 줍니다.</p>
<h3>일반 객체의 <code>__dict__</code> 속성 (The <code>__dict__</code> attribute on regular objects)</h3>
<p>일반 객체는 <code>__dict__</code> 속성을 가질 수 있습니다. 만약 그렇다면, 이는 최소한 <code>__getitem__()</code>, <code>keys()</code>, <code>has_key()</code>를 지원하는 매핑(mapping)이어야 합니다 (반드시 딕셔너리일 필요는 없습니다). 이것은 객체의 동적 속성을 제공합니다. 매핑의 키는 속성 이름을 제공하고, 해당 값은 그 값을 제공합니다.</p>
<p>일반적으로, 주어진 이름의 속성 값은 <code>__dict__</code>에서 해당 이름을 키로 하는 값과 동일한 객체입니다. 즉, <code>obj.__dict__['spam']</code>은 <code>obj.spam</code>입니다. (그러나 아래의 우선순위 규칙을 참조하십시오. 동일한 이름을 가진 정적 속성이 딕셔너리 항목을 재정의할 수 있습니다.)</p>
<h3>일반 객체의 <code>__class__</code> 속성 (The <code>__class__</code> attribute on regular objects)</h3>
<p>일반 객체는 일반적으로 <code>__class__</code> 속성을 가집니다. 만약 그렇다면, 이것은 메타-객체를 참조합니다. 메타-객체는 <code>__class__</code>가 참조하는 일반 객체에 대한 정적 속성을 정의할 수 있습니다. 이것은 일반적으로 다음 메커니즘을 통해 이루어집니다:</p>
<h3>메타-객체의 <code>__dict__</code> 속성 (The <code>__dict__</code> attribute on meta-objects)</h3>
<p>메타-객체는 일반 객체의 <code>__dict__</code> 속성과 동일한 형태의 <code>__dict__</code> 속성을 가질 수 있습니다 (매핑이지만 반드시 딕셔너리일 필요는 없습니다). 만약 그렇다면, 메타-객체의 <code>__dict__</code>의 키는 해당 일반 객체에 대한 정적 속성의 이름입니다. 값은 속성 디스크립터(attribute descriptors)입니다. 이것은 나중에 설명할 것입니다. 언바운드 메서드(unbound method)는 속성 디스크립터의 특수 케이스입니다.</p>
<p>메타-객체도 일반 객체이기 때문에, 메타-객체의 <code>__dict__</code>에 있는 항목은 메타-객체의 속성과 일치합니다. 그러나 일부 변환이 적용될 수 있으며, 베이스(bases, 아래 참조)가 추가적인 동적 속성을 정의할 수 있습니다. 즉, <code>mobj.spam</code>이 항상 <code>mobj.__dict__['spam']</code>인 것은 아닙니다. (이 규칙에는 클래스의 경우 <code>C.__dict__['spam']</code>이 함수인 경우 <code>C.spam</code>은 언바운드 메서드 객체라는 허점이 있습니다.)</p>
<h3>메타-객체의 <code>__bases__</code> 속성 (The <code>__bases__</code> attribute on meta-objects)</h3>
<p>메타-객체는 <code>__bases__</code> 속성을 가질 수 있습니다. 만약 그렇다면, 이것은 다른 메타-객체들(베이스)의 시퀀스(sequence)여야 합니다 (반드시 튜플일 필요는 없습니다). <code>__bases__</code>가 없는 것은 빈 베이스 시퀀스와 동일합니다. <code>__bases__</code> 속성에 의해 정의된 메타-객체들 사이의 관계에는 순환(cycle)이 없어야 합니다. 즉, <code>__bases__</code> 속성은 파생된 메타-객체에서 그들의 기본 메타-객체로 향하는 아크(arcs)를 가진 방향성 비순환 그래프(directed acyclic graph)를 정의합니다. (여러 클래스가 동일한 기본 클래스를 가질 수 있으므로 반드시 트리(tree)일 필요는 없습니다.) 상속 그래프(inheritance graph) 내의 메타-객체의 <code>__dict__</code> 속성은 <code>__class__</code> 속성이 상속 트리의 루트(root)를 가리키는 일반 객체에 대한 속성 디스크립터를 제공합니다 (이는 상속 계층 구조의 루트와 동일하지 않습니다. 오히려 상속 트리가 일반적으로 그려지는 방식에 따라 맨 아래에 가깝습니다). 디스크립터는 먼저 루트 메타-객체의 딕셔너리에서 검색된 다음, 우선순위 규칙(아래 다음 단락 참조)에 따라 해당 베이스에서 검색됩니다.</p>
<h3>우선순위 규칙 (Precedence rules)</h3>
<p>주어진 일반 객체에 대한 상속 그래프 내의 두 메타-객체가 동일한 이름의 속성 디스크립터를 모두 정의할 때, 검색 순서는 메타-객체에 달려 있습니다. 이를 통해 다른 메타-객체가 다른 검색 순서를 정의할 수 있습니다. 특히, 고전적인 클래스는 오래된 왼쪽에서 오른쪽, 깊이 우선 규칙을 사용하는 반면, 새 스타일 클래스(new-style classes)는 더 고급 규칙을 사용합니다 (PEP 253의 메서드 결정 순서(method resolution order) 섹션 참조).</p>
<p>동적 속성(일반 객체의 <code>__dict__</code>에 정의된 속성)이 정적 속성(일반 객체의 <code>__class__</code>를 루트로 하는 상속 그래프 내의 메타-객체에 의해 정의된 속성)과 동일한 이름을 가질 때, 정적 속성이 <code>__set__</code> 메서드를 정의하는 디스크립터인 경우 우선순위를 가집니다 (아래 참조). 그렇지 않은 경우 (<code>__set__</code> 메서드가 없는 경우) 동적 속성이 우선순위를 가집니다. 즉, 데이터 속성( <code>__set__</code> 메서드를 가진 속성)의 경우 정적 정의가 동적 정의를 재정의하지만, 다른 속성의 경우 동적 정의가 정적 정의를 재정의합니다.</p>
<p><strong>이론적 근거 (Rationale):</strong> "정적이 동적을 재정의한다" 또는 "동적이 정적을 재정의한다"와 같은 간단한 규칙을 가질 수는 없습니다. 왜냐하면 일부 정적 속성은 실제로 동적 속성을 재정의하기 때문입니다. 예를 들어, 인스턴스의 <code>__dict__</code>에 있는 키 <code>'__class__'</code>는 정적으로 정의된 <code>__class__</code> 포인터에 의해 무시되지만, 반면에 <code>inst.__dict__</code>의 대부분의 키는 <code>inst.__class__</code>에 정의된 속성을 재정의합니다. 디스크립터에 <code>__set__</code> 메서드가 존재한다는 것은 이것이 데이터 디스크립터(data descriptor)임을 나타냅니다. (읽기 전용(read-only) 데이터 디스크립터도 <code>__set__</code> 메서드를 가집니다. 항상 예외를 발생시킵니다.) 디스크립터에 <code>__set__</code> 메서드가 없다는 것은 디스크립터가 할당을 가로채는 데 관심이 없음을 나타내며, 이때는 고전적인 규칙이 적용됩니다: 메서드와 동일한 이름을 가진 인스턴스 변수는 해당 특정 인스턴스에 대해 메서드를 삭제될 때까지 숨깁니다.</p>
<h2>속성 디스크립터 (Attribute descriptors)</h2>
<p>여기서부터 흥미롭고 복잡해집니다. 속성 디스크립터(줄여서 디스크립터)는 메타-객체의 <code>__dict__</code> (또는 그 조상 중 하나의 <code>__dict__</code>)에 저장되며, 두 가지 용도로 사용됩니다. 디스크립터는 (일반, 비-메타) 객체의 해당 속성 값을 가져오거나 설정하는 데 사용될 수 있으며, 문서화 및 인트로스펙션 목적으로 속성을 설명하는 추가 인터페이스를 가집니다.</p>
<p>Python에서는 디스크립터 인터페이스를 설계하는 데 있어 이전의 선행 작업이 거의 없습니다. 값을 가져오거나 설정하는 것, 또는 다른 방식으로 속성을 설명하는 것에 대한 선행 작업이 없었으며, 몇 가지 사소한 속성( <code>__name__</code>과 <code>__doc__</code>이 속성의 이름과 독스트링이어야 한다고 가정하는 것이 합리적)을 제외하면 그렇습니다. 저는 아래에서 그러한 API를 제안할 것입니다.</p>
<p>메타-객체의 <code>__dict__</code>에서 발견된 객체가 속성 디스크립터가 아닌 경우, 하위 호환성(backward compatibility)은 특정 최소한의 의미론을 요구합니다. 이는 기본적으로 Python 함수 또는 언바운드 메서드(unbound method)인 경우 해당 속성이 메서드이고, 그렇지 않은 경우 동적 데이터 속성의 기본값이라는 의미입니다. 하위 호환성은 또한 (<code>__setattr__</code> 메서드가 없는 경우) 메서드에 해당하는 속성에 할당하는 것이 합법적이며, 이것이 해당 특정 인스턴스에 대해 메서드를 가리는 데이터 속성을 생성한다는 것을 요구합니다. 그러나 이러한 의미론은 일반 클래스와의 하위 호환성을 위해서만 필요합니다.</p>
<p>인트로스펙션 API는 읽기 전용(read-only) API입니다. 우리는 특수 속성(<code>__dict__</code>, <code>__class__</code>, <code>__bases__</code>)에 대한 할당의 효과나 <code>__dict__</code> 항목에 대한 할당의 효과를 정의하지 않습니다. 일반적으로 이러한 할당은 금지된 것으로 간주되어야 합니다. 향후 PEP에서 이러한 할당 중 일부에 대한 의미론을 정의할 수 있습니다. (특히 현재 인스턴스는 <code>__class__</code> 및 <code>__dict__</code>에 대한 할당을 지원하고, 클래스는 <code>__bases__</code> 및 <code>__dict__</code>에 대한 할당을 지원하기 때문입니다.)</p>
<h3>속성 디스크립터 API의 명세 (Specification of the attribute descriptor API)</h3>
<p>속성 디스크립터는 다음 속성들을 가질 수 있습니다. 예시에서 <code>x</code>는 객체이고, <code>C</code>는 <code>x.__class__</code>이며, <code>x.meth()</code>는 메서드이고, <code>x.ivar</code>는 데이터 속성 또는 인스턴스 변수입니다. 모든 속성은 선택 사항입니다. 즉, 특정 속성은 주어진 디스크립터에 존재할 수도 있고 아닐 수도 있습니다. 속성이 없다는 것은 해당 정보를 사용할 수 없거나 해당 기능이 구현되지 않았음을 의미합니다.</p>
<ul>
<li><code>__name__</code>: 속성 이름. 별칭(aliasing) 및 이름 변경으로 인해 속성은 다른 이름으로 알려질 수 있지만 (추가적으로 또는 독점적으로), 이것은 속성이 생성된 이름입니다. 예시: <code>C.meth.__name__ == 'meth'</code>.</li>
<li><code>__doc__</code>: 속성의 문서화 문자열(docstring). <code>None</code>일 수 있습니다.</li>
<li><code>__objclass__</code>: 이 속성을 선언한 클래스. 디스크립터는 이 클래스의 인스턴스인 객체(서브클래스의 인스턴스 포함)에만 적용됩니다. 예시: <code>C.meth.__objclass__</code>는 <code>C</code>입니다.</li>
<li><code>__get__()</code>: 객체에서 속성 값을 검색하는 한두 개의 인수로 호출 가능한 함수. 이는 메서드 디스크립터의 경우 "바운드 메서드(bound method)" 객체를 반환할 수 있으므로 "바인딩(binding)" 작업이라고도 합니다. 첫 번째 인수 <code>X</code>는 속성을 검색하거나 바인딩해야 하는 객체입니다. <code>X</code>가 <code>None</code>인 경우, 선택적 두 번째 인수 <code>T</code>는 메타-객체여야 하며 바인딩 작업은 <code>T</code>의 인스턴스로 제한되는 언바운드 메서드(unbound method)를 반환할 수 있습니다. <code>X</code>와 <code>T</code>가 모두 지정된 경우 <code>X</code>는 <code>T</code>의 인스턴스여야 합니다. 바인딩 작업이 정확히 무엇을 반환하는지는 디스크립터의 의미론에 따라 달라집니다. 예를 들어, 스태틱 메서드와 클래스 메서드(아래 참조)는 인스턴스를 무시하고 대신 타입에 바인딩합니다.</li>
<li><code>__set__()</code>: 객체에 속성 값을 설정하는 두 개의 인수를 받는 함수. 속성이 읽기 전용인 경우, 이 메서드는 <code>TypeError</code> 또는 <code>AttributeError</code> 예외를 발생시킬 수 있습니다 (둘 다 허용됩니다. 둘 다 정의되지 않거나 설정할 수 없는 속성에 대해 역사적으로 발견되었기 때문입니다). 예시: <code>C.ivar.set(x, y)</code>는 <code>x.ivar = y</code>와 동일합니다.</li>
</ul>
<h2>스태틱 메서드 및 클래스 메서드 (Static methods and class methods)</h2>
<p>디스크립터 API를 통해 스태틱 메서드(static methods)와 클래스 메서드(class methods)를 추가할 수 있습니다. 스태틱 메서드는 설명하기 쉽습니다. 이들은 C++ 또는 Java의 static 메서드와 거의 동일하게 작동합니다. 다음은 예시입니다:</p>
<pre><code class="language-python">class C:
    def foo(x, y):
        print("staticmethod", x, y)
    foo = staticmethod(foo)

C.foo(1, 2)
c = C()
c.foo(1, 2)
</code></pre>
<p><code>C.foo(1, 2)</code> 호출과 <code>c.foo(1, 2)</code> 호출 모두 <code>foo()</code>를 두 개의 인수로 호출하고 "staticmethod 1 2"를 출력합니다. <code>foo()</code>의 정의에 "self"는 선언되지 않았으며, 호출에 인스턴스가 필요하지 않습니다.</p>
<p>클래스 문(class statement)의 "foo = staticmethod(foo)" 줄이 결정적인 요소입니다. 이것이 <code>foo()</code>를 스태틱 메서드로 만듭니다. 내장 <code>staticmethod()</code>는 함수 인수를 <code>__get__()</code> 메서드가 원래 함수를 변경하지 않고 반환하는 특수한 종류의 디스크립터로 래핑(wraps)합니다. 이것이 없으면, 표준 함수 객체의 <code>__get__()</code> 메서드는 <code>c.foo</code>에 대한 바운드 메서드 객체와 <code>C.foo</code>에 대한 언바운드 메서드 객체를 생성했을 것입니다.</p>
<p>(XXX Barry는 "static"이라는 단어가 이미 여러 방식으로 오버로드(overloaded)되어 있기 때문에 "staticmethod" 대신 "sharedmethod"를 사용할 것을 제안했습니다. 하지만 shared가 올바른 의미를 전달하는지 확실하지 않습니다.)</p>
<p>클래스 메서드(Class methods)는 호출되는 클래스인 암묵적인 첫 번째 인수를 받는 메서드를 선언하기 위해 유사한 패턴을 사용합니다. 이것은 C++나 Java에 상응하는 것이 없으며, Smalltalk의 클래스 메서드와 완전히 같지는 않지만 유사한 목적을 수행할 수 있습니다. Armin Rigo에 따르면, 이들은 Borland Pascal 방언 Delphi의 "가상 클래스 메서드(virtual class methods)"와 유사합니다. (Python은 또한 실제 메타클래스(metaclasses)를 가지고 있으며, 아마도 메타클래스에 정의된 메서드가 "클래스 메서드"라는 이름에 더 적합할 것입니다. 하지만 대부분의 프로그래머는 메타클래스를 사용하지 않을 것이라고 예상합니다.) 다음은 예시입니다:</p>
<pre><code class="language-python">class C:
    def foo(cls, y):
        print("classmethod", cls, y)
    foo = classmethod(foo)

C.foo(1)
c = C()
c.foo(1)
</code></pre>
<p><code>C.foo(1)</code> 호출과 <code>c.foo(1)</code> 호출 모두 <code>foo()</code>를 두 개의 인수로 호출하고 "classmethod <code>__main__.C</code> 1"을 출력합니다. <code>foo()</code>의 첫 번째 인수는 암묵적이며, 메서드가 인스턴스를 통해 호출되었더라도 클래스입니다. 이제 예시를 계속해 봅시다:</p>
<pre><code class="language-python">class D(C):
    pass

D.foo(1)
d = D()
d.foo(1)
</code></pre>
<p>이것은 두 번 모두 "classmethod <code>__main__.D</code> 1"을 출력합니다. 즉, <code>foo()</code>의 첫 번째 인수로 전달된 클래스는 호출에 관련된 클래스이며, <code>foo()</code>의 정의에 관련된 클래스가 아닙니다.</p>
<p>하지만 이것을 주목하십시오:</p>
<pre><code class="language-python">class E(C):
    def foo(cls, y): # C.foo 재정의
        print("E.foo() called")
        C.foo(y)
    foo = classmethod(foo)

E.foo(1)
e = E()
e.foo(1)
</code></pre>
<p>이 예시에서 <code>E.foo()</code>에서 <code>C.foo()</code>를 호출하면 첫 번째 인수로 클래스 <code>C</code>를 보게 될 것이고, 클래스 <code>E</code>를 보지 않을 것입니다. 이것은 호출이 클래스 <code>C</code>를 지정하므로 예상되는 결과입니다. 그러나 이것은 이러한 클래스 메서드와 메타클래스에 정의된 메서드 간의 차이를 강조합니다. 메타메서드에 대한 업콜(upcall)은 대상 클래스를 명시적인 첫 번째 인수로 전달할 것입니다. (이것을 이해하지 못해도 걱정하지 마십시오. 혼자가 아닙니다.) <code>cls.foo(y)</code>를 호출하는 것은 실수일 수 있습니다. 무한 재귀(infinite recursion)를 일으킬 것입니다. 또한 클래스 메서드에 명시적인 <code>cls</code> 인수를 지정할 수 없다는 점도 유의하십시오. (예: PEP 253의 <code>__new__</code> 메서드에 필요한 경우) 대신 클래스를 명시적인 첫 번째 인수로 사용하는 스태틱 메서드를 사용하십시오.</p>
<h2>C API</h2>
<p>XXX 다음은 다른 독자를 염두에 두고 작성한 매우 거친 텍스트입니다. 더 편집해야 합니다. XXX 또한 C API에 대해 충분히 자세히 다루지 않습니다.</p>
<p>내장 타입은 두 가지 방식으로 특수 데이터 속성을 선언할 수 있습니다: <code>struct memberlist</code> (structmember.h에 정의됨) 또는 <code>struct getsetlist</code> (descrobject.h에 정의됨)를 사용합니다. <code>struct memberlist</code>는 새로운 용도로 사용되는 오래된 메커니즘입니다. 각 속성은 이름, 타입(다양한 C 타입과 <code>PyObject *</code> 지원), 인스턴스의 시작으로부터의 오프셋(offset), 읽기 전용 플래그(read-only flag)를 포함하는 디스크립터 레코드(descriptor record)를 가집니다.</p>
<p><code>struct getsetlist</code> 메커니즘은 새롭고, 추가적인 검사가 필요하거나 단순히 계산된 속성(calculated attributes)인 경우와 같이 해당 틀에 맞지 않는 경우를 위해 고안되었습니다. 여기에서 각 속성은 이름, getter C 함수 포인터, setter C 함수 포인터, 그리고 컨텍스트 포인터(context pointer)를 가집니다. 함수 포인터는 선택 사항이므로, 예를 들어 setter 함수 포인터를 <code>NULL</code>로 설정하면 읽기 전용 속성이 됩니다. 컨텍스트 포인터는 일반 getter/setter 함수에 보조 정보(auxiliary information)를 전달하기 위한 것이지만, 아직 이에 대한 필요성을 찾지 못했습니다.</p>
<p>내장 메서드를 선언하는 유사한 메커니즘도 있습니다: 이들은 <code>PyMethodDef</code> 구조체이며, 이름과 C 함수 포인터(및 호출 규칙에 대한 일부 플래그)를 포함합니다.</p>
<p>전통적으로 내장 타입은 이러한 속성 정의가 작동하도록 자체 <code>tp_getattro</code> 및 <code>tp_setattro</code> 슬롯 함수를 정의해야 했습니다 (<code>PyMethodDef</code>와 <code>struct memberlist</code>는 꽤 오래되었습니다). <code>PyMethodDef</code> 또는 <code>memberlist</code> 구조체 배열, 객체, 속성 이름을 받아 목록에서 찾으면 속성을 반환하거나 설정하고, 찾지 못하면 예외를 발생시키는 편의 함수가 있습니다. 그러나 이러한 편의 함수는 특정 타입의 <code>tp_getattro</code> 또는 <code>tp_setattro</code> 메서드에 의해 명시적으로 호출되어야 했고, 요청된 속성을 설명하는 배열 요소를 찾기 위해 <code>strcmp()</code>를 사용하여 배열을 선형 검색했습니다.</p>
<p>이제 저는 이 상황을 상당히 개선하는 아주 새로운 일반 메커니즘을 가지고 있습니다.</p>
<p><code>PyMethodDef</code>, <code>memberlist</code>, <code>getsetlist</code> 구조체 배열에 대한 포인터는 새로운 타입 객체(<code>tp_methods</code>, <code>tp_members</code>, <code>tp_getset</code>)의 일부입니다. 타입 초기화 시점(<code>PyType_InitDict()</code>)에, 이 세 배열의 각 항목에 대해 디스크립터 객체가 생성되어 타입에 속하는 딕셔너리(<code>tp_dict</code>)에 배치됩니다. 디스크립터는 주로 해당 구조체를 가리키는 매우 간결한 객체입니다. 구현 세부 사항으로는 모든 디스크립터가 동일한 객체 타입을 공유하며, 식별자 필드(discriminator field)가 어떤 종류의 디스크립터인지(메서드, 멤버 또는 getset) 알려줍니다. PEP 252에 설명된 대로, 디스크립터는 객체 인수를 받아 해당 객체의 속성을 반환하는 <code>get()</code> 메서드를 가집니다. 쓰기 가능한(writable) 속성에 대한 디스크립터는 객체와 값을 받아 해당 객체의 속성을 설정하는 <code>set()</code> 메서드도 가집니다. <code>get()</code> 객체는 메서드에 대한 바인딩(<code>bind()</code>) 작업으로도 작동하여 언바운드 메서드 구현을 객체에 바인딩합니다. 거의 모든 내장 객체는 이제 자체 <code>tp_getattro</code> 및 <code>tp_setattro</code> 구현을 제공하는 대신, <code>PyObject_GenericGetAttr</code> 및 (쓰기 가능한 속성이 있는 경우) <code>PyObject_GenericSetAttr</code>을 <code>tp_getattro</code> 및 <code>tp_setattro</code> 슬롯에 배치합니다. (또는 이들을 <code>NULL</code>로 남겨두고, 첫 번째 인스턴스가 생성되기 전에 타입에 대한 <code>PyType_InitDict()</code>에 대한 명시적 호출을 준비하는 경우 기본 기본 객체로부터 상속받을 수 있습니다.) 가장 간단한 경우, <code>PyObject_GenericGetAttr()</code>은 정확히 하나의 딕셔너리 조회(lookup)를 수행합니다: 타입의 딕셔너리(<code>obj->ob_type->tp_dict</code>)에서 속성 이름을 찾습니다. 성공하면 두 가지 가능성이 있습니다: 디스크립터에 <code>get</code> 메서드가 있거나 없습니다. 속도를 위해 <code>get</code> 및 <code>set</code> 메서드는 타입 슬롯(<code>tp_descr_get</code> 및 <code>tp_descr_set</code>)입니다. <code>tp_descr_get</code> 슬롯이 <code>NULL</code>이 아니면, 객체를 유일한 인수로 전달하여 호출되며, 이 호출의 반환 값이 <code>getattr</code> 작업의 결과가 됩니다. <code>tp_descr_get</code> 슬롯이 <code>NULL</code>이면, 대체로 디스크립터 자체가 반환됩니다 (메서드가 아닌 단순 값인 클래스 속성과 비교). <code>PyObject_GenericSetAttr()</code>은 매우 유사하게 작동하지만 <code>tp_descr_set</code> 슬롯을 사용하고 객체와 새 속성 값으로 호출합니다. <code>tp_descr_set</code> 슬롯이 <code>NULL</code>이면 <code>AttributeError</code>가 발생합니다. 이제 더 복잡한 경우를 살펴봅시다. 위에서 설명한 접근 방식은 리스트, 문자열, 숫자와 같은 대부분의 내장 객체에 적합합니다. 그러나 일부 객체 타입은 각 인스턴스에 임의의 속성을 저장할 수 있는 딕셔너리를 가집니다. 사실, 클래스 문을 사용하여 기존 내장 타입을 서브타입화(subtype)할 때, 이러한 딕셔너리를 자동으로 얻습니다 (다른 고급 기능인 <code>__slots__</code>를 사용하여 명시적으로 끄지 않는 한). 이것을 타입 딕셔너리(type dict)와 구별하기 위해 인스턴스 딕셔너리(instance dict)라고 부르겠습니다. 더 복잡한 경우, 인스턴스 딕셔너리에 저장된 이름과 타입 딕셔너리에 저장된 이름 사이에 충돌이 발생합니다. 두 딕셔너리가 동일한 키를 가진 항목을 가지고 있다면, 어떤 것을 반환해야 할까요? 고전적인 Python에서 지침을 찾아보면 상충되는 규칙을 발견합니다: 클래스 인스턴스의 경우, 인스턴스 딕셔너리가 클래스 딕셔너리를 재정의하지만, 인스턴스 딕셔너리보다 우선순위를 가지는 특수 속성(<code>__dict__</code> 및 <code>__class__</code> 등)은 예외입니다. 저는 <code>PyObject_GenericGetAttr()</code>에 구현된 다음 규칙 집합으로 이 문제를 해결했습니다:</p>
<ol>
<li>타입 딕셔너리에서 찾습니다. 데이터 디스크립터를 찾으면 <code>get()</code> 메서드를 사용하여 결과를 생성합니다. 이것은 <code>__dict__</code> 및 <code>__class__</code>와 같은 특수 속성을 처리합니다.</li>
<li>인스턴스 딕셔너리에서 찾습니다. 아무것도 찾으면 그것이 결과입니다. (이것은 일반적으로 인스턴스 딕셔너리가 클래스 딕셔너리를 재정의해야 한다는 요구 사항을 처리합니다.)</li>
<li>타입 딕셔너리에서 다시 찾습니다 (실제로는 물론 1단계에서 저장된 결과를 사용합니다). 디스크립터를 찾으면 <code>get()</code> 메서드를 사용하고, 다른 것을 찾으면 그것이 결과이며, 거기에 없으면 <code>AttributeError</code>를 발생시킵니다.</li>
</ol>
<p>이것은 디스크립터를 데이터 디스크립터(data descriptor)와 비-데이터 디스크립터(nondata descriptor)로 분류하는 것을 요구합니다. 현재 구현은 멤버(member) 및 getset 디스크립터를 데이터로 (읽기 전용이더라도!), 메서드 디스크립터를 비-데이터로 합리적으로 분류합니다. 비-디스크립터(함수 포인터 또는 일반 값과 같은)도 비-데이터로 분류됩니다 (!).</p>
<p>이 체계에는 한 가지 단점이 있습니다: 제가 가장 일반적인 경우라고 가정하는, 인스턴스 딕셔너리에 저장된 인스턴스 변수를 참조하는 경우, 두 번의 딕셔너리 조회를 수행합니다. 반면 고전적인 체계는 두 개의 밑줄로 시작하는 속성에 대한 빠른 테스트와 단일 딕셔너리 조회를 수행했습니다. (구현은 슬프게도 <code>instance_getattr()</code>가 <code>instance_getattr1()</code>을 호출하고 <code>instance_getattr1()</code>이 <code>instance_getattr2()</code>를 호출하며, <code>instance_getattr2()</code>가 최종적으로 <code>PyDict_GetItem()</code>을 호출하는 방식으로 구성되어 있고, 밑줄 테스트는 <code>PyString_AsString()</code>을 호출하는 대신 인라인(inlining)되지 않습니다. 이 부분을 최적화하는 것이 Python 2.2의 속도를 높이는 좋은 아이디어가 아닐까 궁금합니다. 모두 제거할 계획이 아니었다면 말이죠. :-) 벤치마크 결과 실제로 이것이 고전적인 인스턴스 변수 조회만큼 빠르다는 것을 확인했으므로 더 이상 걱정하지 않습니다. 동적 타입(dynamic types)에 대한 수정: 1단계와 3단계는 타입과 모든 기본 클래스의 딕셔너리에서 찾습니다 (물론 MRO 순서로).</p>
<h2>논의 (Discussion)</h2>
<p>XXX</p>
<h2>예시 (Examples)</h2>
<p>리스트를 살펴봅시다. 고전적인 Python에서는 리스트의 메서드 이름이 리스트 객체의 <code>__methods__</code> 속성으로 제공되었습니다:</p>
<pre><code class="language-python">>>> [].__methods__
['append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
>>>
</code></pre>
<p>새로운 제안에 따라, <code>__methods__</code> 속성은 더 이상 존재하지 않습니다:</p>
<pre><code class="language-python">>>> [].__methods__
Traceback (most recent call last):
  File "&#x3C;stdin>", line 1, in ?
AttributeError: 'list' object has no attribute '__methods__'
>>>
</code></pre>
<p>대신, 리스트 타입에서 동일한 정보를 얻을 수 있습니다:</p>
<pre><code class="language-python">>>> T = [].__class__
>>> T
&#x3C;class 'list'>
>>> dir(T) # T.__dict__.keys()와 같지만 정렬됨
['__add__', '__class__', '__contains__', '__eq__', '__ge__', '__getattr__', '__getitem__', '__getslice__', '__gt__', '__iadd__', '__imul__', '__init__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__radd__', '__repr__', '__rmul__', '__setitem__', '__setslice__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
>>>
</code></pre>
<p>새로운 인트로스펙션 API는 이전 API보다 더 많은 정보를 제공합니다. 일반 메서드 외에도, 일반적으로 특수 표기법(예: <code>__iadd__</code> ( <code>+=</code> ), <code>__len__</code> ( <code>len</code> ), <code>__ne__</code> ( <code>!=</code> ))을 통해 호출되는 메서드도 보여줍니다. 이 목록의 모든 메서드를 직접 호출할 수 있습니다:</p>
<pre><code class="language-python">>>> a = ['tic', 'tac']
>>> T.__len__(a) # len(a)와 동일
2
>>> T.append(a, 'toe') # a.append('toe')와 동일
>>> a
['tic', 'tac', 'toe']
>>>
</code></pre>
<p>이것은 사용자 정의 클래스와 동일합니다.</p>
<p>목록에서 친숙하지만 놀라운 이름인 <code>__init__</code>을 주목하십시오. 이것은 PEP 253의 영역입니다.</p>
<h2>하위 호환성 (Backwards compatibility)</h2>
<p>XXX</p>
<h2>경고 및 오류 (Warnings and Errors)</h2>
<p>XXX</p>
<h2>구현 (Implementation)</h2>
<p>이 PEP의 부분적인 구현은 CVS에서 "descr-branch"라는 이름의 브랜치로 사용할 수 있습니다. 이 구현을 실험하려면 http://sourceforge.net/cvs/?group_id=5470의 지침에 따라 CVS에서 Python을 체크아웃(check out)하되, <code>cvs checkout</code> 명령에 인수 "-r descr-branch"를 추가하십시오. (기존 체크아웃에서 시작하여 "cvs update -r descr-branch"를 수행할 수도 있습니다.) 여기에 설명된 기능의 몇 가지 예시는 파일 <code>Lib/test/test_descr.py</code>를 참조하십시오.</p>
<p><strong>참고:</strong> 이 브랜치의 코드는 이 PEP의 범위를 훨씬 넘어섭니다. 또한 PEP 253 (내장 타입 서브타이핑, Subtyping Built-in Types)에 대한 실험 영역이기도 합니다.</p>
<h2>참조 (References)</h2>
<p>XXX</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.</p>
<hr>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-19cfc001fdac3337.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/252\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"FeyCvJug7In7AgUZlfHUx\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/252/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/252\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"252\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/252\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:Ta2e7,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0252/\"\u003ePEP 252 - Making Types Look More Like Classes\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 19-Apr-2001\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 252 – 타입을 클래스처럼 보이게 만들기\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Guido van Rossum \r\n\u003cstrong\u003e상태:\u003c/strong\u003e 최종 (Final)\r\n\u003cstrong\u003e유형:\u003c/strong\u003e 표준 트랙 (Standards Track)\r\n\u003cstrong\u003e생성일:\u003c/strong\u003e 2001년 4월 19일\r\n\u003cstrong\u003ePython 버전:\u003c/strong\u003e 2.2\r\n\u003cstrong\u003e이전 이력:\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 타입(types)의 인트로스펙션(introspection) API를 변경하여, 타입이 클래스(classes)처럼 보이고 타입의 인스턴스가 클래스 인스턴스처럼 보이게 할 것을 제안합니다. 예를 들어, 대부분의 내장 타입(built-in types)의 경우 \u003ccode\u003etype(x)\u003c/code\u003e는 \u003ccode\u003ex.__class__\u003c/code\u003e와 동일해집니다. \u003ccode\u003eC\u003c/code\u003e가 \u003ccode\u003ex.__class__\u003c/code\u003e일 때, \u003ccode\u003ex.meth(a)\u003c/code\u003e는 일반적으로 \u003ccode\u003eC.meth(x, a)\u003c/code\u003e와 동일하며, \u003ccode\u003eC.__dict__\u003c/code\u003e는 \u003ccode\u003ex\u003c/code\u003e의 메서드와 다른 속성들을 포함하게 됩니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 또한 \"속성 디스크립터(attribute descriptors)\", 줄여서 \"디스크립터(descriptors)\"를 사용하여 속성을 지정하는 새로운 접근 방식을 소개합니다. 디스크립터는 속성을 설명하는 데 사용되는 여러 가지 일반적인 메커니즘을 통합하고 일반화합니다. 디스크립터는 메서드(method), 객체 구조의 타입 필드(typed field), 또는 getter 및 setter 함수로 표현되는 일반화된 속성을 설명할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e일반화된 디스크립터 API를 기반으로, 이 PEP는 또한 클래스 메서드(class methods)와 스태틱 메서드(static methods)를 선언하는 방법을 소개합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e[편집자 주: 이 PEP에 설명된 아이디어는 Python에 통합되었습니다. 이 PEP는 더 이상 구현을 정확하게 설명하지 않습니다.]\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003e서론 (Introduction)\u003c/h2\u003e\n\u003cp\u003ePython의 가장 오래된 언어적 결함(language warts) 중 하나는 클래스와 타입 간의 차이입니다. 예를 들어, 딕셔너리(dictionary) 타입을 직접 서브클래싱(subclass)할 수 없으며, 객체가 어떤 메서드와 인스턴스 변수(instance variables)를 가지고 있는지 알아내는 인트로스펙션 인터페이스가 타입과 클래스에 대해 서로 다릅니다.\u003c/p\u003e\n\u003cp\u003e클래스/타입 분할을 해결하는 것은 Python이 구현되는 방식의 여러 측면에 영향을 미치기 때문에 큰 노력입니다. 이 PEP는 타입의 인트로스펙션 API를 클래스의 인트로스펙션 API와 동일하게 만드는 데 중점을 둡니다. 다른 PEP들은 클래스를 타입처럼 보이게 하고 내장 타입을 서브클래싱하는 것을 제안할 것이며, 이 주제들은 이 PEP의 의제가 아닙니다.\u003c/p\u003e\n\u003ch2\u003e인트로스펙션 API (Introspection APIs)\u003c/h2\u003e\n\u003cp\u003e인트로스펙션은 객체가 어떤 속성을 가지고 있는지 알아내는 것에 관한 것입니다. Python의 매우 일반적인 \u003ccode\u003egetattr\u003c/code\u003e/\u003ccode\u003esetattr\u003c/code\u003e API는 특정 객체가 지원하는 모든 속성 목록을 얻을 수 있는 방법이 항상 존재한다고 보장하는 것을 불가능하게 만들지만, 실제로는 거의 모든 객체에 대해 함께 작동하는 두 가지 규칙이 나타났습니다. 저는 이것들을 클래스 기반 인트로스펙션 API (class-based introspection API)와 타입 기반 인트로스펙션 API (type-based introspection API)라고 부르겠습니다. 줄여서 클래스 API와 타입 API입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e클래스 기반 인트로스펙션 API\u003c/strong\u003e는 주로 클래스 인스턴스에 사용되며, Jim Fulton의 ExtensionClasses에서도 사용됩니다. 이 API는 객체 \u003ccode\u003ex\u003c/code\u003e의 모든 데이터 속성이 딕셔너리 \u003ccode\u003ex.__dict__\u003c/code\u003e에 저장되고, 모든 메서드와 클래스 변수는 \u003ccode\u003ex\u003c/code\u003e의 클래스인 \u003ccode\u003ex.__class__\u003c/code\u003e를 검사하여 찾을 수 있다고 가정합니다. 클래스에는 메서드와 클래스 자체에 의해 정의된 클래스 변수를 포함하는 딕셔너리를 제공하는 \u003ccode\u003e__dict__\u003c/code\u003e 속성과, 재귀적으로 검사되어야 하는 기본 클래스(base classes)의 튜플인 \u003ccode\u003e__bases__\u003c/code\u003e 속성이 있습니다. 여기에는 몇 가지 가정이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e인스턴스 딕셔너리(instance dict)에 정의된 속성은 객체의 클래스에 의해 정의된 속성을 재정의합니다.\u003c/li\u003e\n\u003cli\u003e파생 클래스(derived class)에 정의된 속성은 기본 클래스에 정의된 속성을 재정의합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__bases__\u003c/code\u003e에서 먼저 나타나는 이전 기본 클래스에 정의된 속성은 나중에 나타나는 기본 클래스에 정의된 속성을 재정의합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e(마지막 두 규칙은 종종 속성 검색에 대한 왼쪽에서 오른쪽, 깊이 우선(left-to-right, depth-first) 규칙으로 요약됩니다. 이것은 고전적인 Python 속성 검색 규칙입니다. PEP 253은 속성 검색 순서를 변경할 것을 제안할 것이며, 만약 수락된다면 이 PEP도 따를 것입니다.)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e타입 기반 인트로스펙션 API\u003c/strong\u003e는 대부분의 내장 객체에서 어떤 형태로든 지원됩니다. 이 API는 두 개의 특수 속성인 \u003ccode\u003e__members__\u003c/code\u003e와 \u003ccode\u003e__methods__\u003c/code\u003e를 사용합니다. \u003ccode\u003e__methods__\u003c/code\u003e 속성은 존재할 경우 객체가 지원하는 메서드 이름 목록입니다. \u003ccode\u003e__members__\u003c/code\u003e 속성은 존재할 경우 객체가 지원하는 데이터 속성 이름 목록입니다.\u003c/p\u003e\n\u003cp\u003e타입 API는 때때로 인스턴스와 동일하게 작동하는 \u003ccode\u003e__dict__\u003c/code\u003e와 결합됩니다 (예: Python 2.1의 함수 객체의 경우, \u003ccode\u003ef.__dict__\u003c/code\u003e는 \u003ccode\u003ef\u003c/code\u003e의 동적 속성을 포함하고, \u003ccode\u003ef.__members__\u003c/code\u003e는 \u003ccode\u003ef\u003c/code\u003e의 정적으로 정의된 속성 이름을 나열합니다).\u003c/p\u003e\n\u003cp\u003e일부 주의가 필요합니다: 어떤 객체는 \u003ccode\u003e__dict__\u003c/code\u003e나 \u003ccode\u003e__doc__\u003c/code\u003e와 같은 \"내재적(intrinsic)\" 속성을 \u003ccode\u003e__members__\u003c/code\u003e에 나열하지 않는 반면, 다른 객체는 나열합니다. 때때로 속성 이름이 \u003ccode\u003e__members__\u003c/code\u003e 또는 \u003ccode\u003e__methods__\u003c/code\u003e와 \u003ccode\u003e__dict__\u003c/code\u003e의 키(key) 모두에 나타나는 경우도 있는데, 이 경우 \u003ccode\u003e__dict__\u003c/code\u003e에서 찾은 값이 사용되는지 여부는 알 수 없습니다.\u003c/p\u003e\n\u003cp\u003e타입 API는 한 번도 신중하게 명시된 적이 없습니다. 이는 Python의 통설(folklore)의 일부이며, 대부분의 서드파티 확장(third party extensions)은 이를 지원하는 예시를 따르기 때문에 지원합니다. 또한, \u003ccode\u003etp_getattr\u003c/code\u003e 핸들러에서 \u003ccode\u003ePy_FindMethod()\u003c/code\u003e 및/또는 \u003ccode\u003ePyMember_Get()\u003c/code\u003e을 사용하는 모든 타입은 각각 \u003ccode\u003e__methods__\u003c/code\u003e 및 \u003ccode\u003e__members__\u003c/code\u003e 속성 이름을 특별히 처리하기 때문에 이를 지원합니다.\u003c/p\u003e\n\u003cp\u003eJim Fulton의 ExtensionClasses는 타입 API를 무시하고, 더 강력한 클래스 API를 에뮬레이트합니다. 이 PEP에서는 모든 타입에 클래스 API를 지원하기 위해 타입 API를 단계적으로 폐지할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e클래스 API를 선호하는 한 가지 주장은 타입이 지원하는 속성을 알아내기 위해 인스턴스를 생성할 필요가 없다는 것입니다. 이는 문서 프로세서(documentation processors)에 유용합니다. 예를 들어, \u003ccode\u003esocket\u003c/code\u003e 모듈은 \u003ccode\u003eSocketType\u003c/code\u003e 객체를 내보내지만, 현재 \u003ccode\u003esocket\u003c/code\u003e 객체에 어떤 메서드가 정의되어 있는지 알려주지 않습니다. 클래스 API를 사용하면 \u003ccode\u003eSocketType\u003c/code\u003e이 \u003ccode\u003esocket\u003c/code\u003e 객체의 메서드를 정확히 보여주며, 소켓을 생성하지 않고도 해당 독스트링(docstrings)을 추출할 수 있습니다. (이것은 C 확장 모듈이므로, 이 경우 소스 스캐닝 방식의 독스트링 추출은 실현 가능하지 않습니다.)\u003c/p\u003e\n\u003ch2\u003e클래스 기반 인트로스펙션 API의 명세 (Specification of the class-based introspection API)\u003c/h2\u003e\n\u003cp\u003e객체는 정적(static) 속성과 동적(dynamic) 속성의 두 가지 종류의 속성을 가질 수 있습니다. 정적 속성의 이름과 때로는 다른 속성들은 \u003ccode\u003eobj.__class__\u003c/code\u003e 또는 \u003ccode\u003etype(obj)\u003c/code\u003e를 통해 접근할 수 있는 객체의 타입 또는 클래스(메타-객체)를 검사하여 알 수 있습니다. (저는 여기에서 \u003ccode\u003etype\u003c/code\u003e과 \u003ccode\u003eclass\u003c/code\u003e를 상호 교환적으로 사용합니다. 둘 다에 해당하는 서투르지만 설명적인 용어는 \"메타-객체\"입니다.)\u003c/p\u003e\n\u003cp\u003e(XXX \"static\" 및 \"dynamic\"은 여기서 사용하기 좋은 용어가 아닙니다. 왜냐하면 \"static\" 속성도 실제로는 매우 동적으로 동작할 수 있고, C++ 또는 Java의 static 클래스 멤버와는 아무 관련이 없기 때문입니다. Barry는 대신 \"immutable\" 및 \"mutable\"을 사용할 것을 제안했지만, 이 단어들은 이미 약간 다른 맥락에서 정확하고 다른 의미를 가지고 있으므로 여전히 혼란스러울 것이라고 생각합니다.)\u003c/p\u003e\n\u003cp\u003e동적 속성의 예시로는 클래스 인스턴스의 인스턴스 변수, 모듈 속성 등이 있습니다. 정적 속성의 예시로는 리스트(lists) 및 딕셔너리(dictionaries)와 같은 내장 객체의 메서드, 그리고 프레임(frame) 및 코드(code) 객체의 속성 (\u003ccode\u003ef.f_code\u003c/code\u003e, \u003ccode\u003ec.co_filename\u003c/code\u003e 등)이 있습니다. 동적 속성을 가진 객체가 \u003ccode\u003e__dict__\u003c/code\u003e 속성을 통해 이들을 노출할 때, \u003ccode\u003e__dict__\u003c/code\u003e는 정적 속성입니다.\u003c/p\u003e\n\u003cp\u003e동적 속성의 이름과 값은 일반적으로 딕셔너리에 저장되며, 이 딕셔너리는 일반적으로 \u003ccode\u003eobj.__dict__\u003c/code\u003e로 접근할 수 있습니다. 이 명세의 나머지 부분은 동적 속성보다는 정적 속성의 이름과 속성을 찾는 데 더 중점을 둡니다. 동적 속성은 \u003ccode\u003eobj.__dict__\u003c/code\u003e를 검사하여 쉽게 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아래 논의에서 저는 두 가지 종류의 객체를 구분합니다: 일반 객체(regular objects) (예: 리스트, 정수, 함수)와 메타-객체(meta-objects). 타입과 클래스는 메타-객체입니다. 메타-객체도 일반 객체이지만, 주로 일반 객체의 \u003ccode\u003e__class__\u003c/code\u003e 속성(또는 다른 메타-객체의 \u003ccode\u003e__bases__\u003c/code\u003e 속성)에 의해 참조되기 때문에 중요하게 다룹니다.\u003c/p\u003e\n\u003cp\u003e클래스 인트로스펙션 API는 다음 요소들로 구성됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일반 객체의 \u003ccode\u003e__class__\u003c/code\u003e 및 \u003ccode\u003e__dict__\u003c/code\u003e 속성\u003c/li\u003e\n\u003cli\u003e메타-객체의 \u003ccode\u003e__bases__\u003c/code\u003e 및 \u003ccode\u003e__dict__\u003c/code\u003e 속성\u003c/li\u003e\n\u003cli\u003e우선순위 규칙 (precedence rules)\u003c/li\u003e\n\u003cli\u003e속성 디스크립터 (attribute descriptors)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이들은 함께 메타-객체에 의해 정의된 모든 속성에 대해 알려줄 뿐만 아니라, 주어진 객체의 특정 속성 값을 계산하는 데도 도움을 줍니다.\u003c/p\u003e\n\u003ch3\u003e일반 객체의 \u003ccode\u003e__dict__\u003c/code\u003e 속성 (The \u003ccode\u003e__dict__\u003c/code\u003e attribute on regular objects)\u003c/h3\u003e\n\u003cp\u003e일반 객체는 \u003ccode\u003e__dict__\u003c/code\u003e 속성을 가질 수 있습니다. 만약 그렇다면, 이는 최소한 \u003ccode\u003e__getitem__()\u003c/code\u003e, \u003ccode\u003ekeys()\u003c/code\u003e, \u003ccode\u003ehas_key()\u003c/code\u003e를 지원하는 매핑(mapping)이어야 합니다 (반드시 딕셔너리일 필요는 없습니다). 이것은 객체의 동적 속성을 제공합니다. 매핑의 키는 속성 이름을 제공하고, 해당 값은 그 값을 제공합니다.\u003c/p\u003e\n\u003cp\u003e일반적으로, 주어진 이름의 속성 값은 \u003ccode\u003e__dict__\u003c/code\u003e에서 해당 이름을 키로 하는 값과 동일한 객체입니다. 즉, \u003ccode\u003eobj.__dict__['spam']\u003c/code\u003e은 \u003ccode\u003eobj.spam\u003c/code\u003e입니다. (그러나 아래의 우선순위 규칙을 참조하십시오. 동일한 이름을 가진 정적 속성이 딕셔너리 항목을 재정의할 수 있습니다.)\u003c/p\u003e\n\u003ch3\u003e일반 객체의 \u003ccode\u003e__class__\u003c/code\u003e 속성 (The \u003ccode\u003e__class__\u003c/code\u003e attribute on regular objects)\u003c/h3\u003e\n\u003cp\u003e일반 객체는 일반적으로 \u003ccode\u003e__class__\u003c/code\u003e 속성을 가집니다. 만약 그렇다면, 이것은 메타-객체를 참조합니다. 메타-객체는 \u003ccode\u003e__class__\u003c/code\u003e가 참조하는 일반 객체에 대한 정적 속성을 정의할 수 있습니다. 이것은 일반적으로 다음 메커니즘을 통해 이루어집니다:\u003c/p\u003e\n\u003ch3\u003e메타-객체의 \u003ccode\u003e__dict__\u003c/code\u003e 속성 (The \u003ccode\u003e__dict__\u003c/code\u003e attribute on meta-objects)\u003c/h3\u003e\n\u003cp\u003e메타-객체는 일반 객체의 \u003ccode\u003e__dict__\u003c/code\u003e 속성과 동일한 형태의 \u003ccode\u003e__dict__\u003c/code\u003e 속성을 가질 수 있습니다 (매핑이지만 반드시 딕셔너리일 필요는 없습니다). 만약 그렇다면, 메타-객체의 \u003ccode\u003e__dict__\u003c/code\u003e의 키는 해당 일반 객체에 대한 정적 속성의 이름입니다. 값은 속성 디스크립터(attribute descriptors)입니다. 이것은 나중에 설명할 것입니다. 언바운드 메서드(unbound method)는 속성 디스크립터의 특수 케이스입니다.\u003c/p\u003e\n\u003cp\u003e메타-객체도 일반 객체이기 때문에, 메타-객체의 \u003ccode\u003e__dict__\u003c/code\u003e에 있는 항목은 메타-객체의 속성과 일치합니다. 그러나 일부 변환이 적용될 수 있으며, 베이스(bases, 아래 참조)가 추가적인 동적 속성을 정의할 수 있습니다. 즉, \u003ccode\u003emobj.spam\u003c/code\u003e이 항상 \u003ccode\u003emobj.__dict__['spam']\u003c/code\u003e인 것은 아닙니다. (이 규칙에는 클래스의 경우 \u003ccode\u003eC.__dict__['spam']\u003c/code\u003e이 함수인 경우 \u003ccode\u003eC.spam\u003c/code\u003e은 언바운드 메서드 객체라는 허점이 있습니다.)\u003c/p\u003e\n\u003ch3\u003e메타-객체의 \u003ccode\u003e__bases__\u003c/code\u003e 속성 (The \u003ccode\u003e__bases__\u003c/code\u003e attribute on meta-objects)\u003c/h3\u003e\n\u003cp\u003e메타-객체는 \u003ccode\u003e__bases__\u003c/code\u003e 속성을 가질 수 있습니다. 만약 그렇다면, 이것은 다른 메타-객체들(베이스)의 시퀀스(sequence)여야 합니다 (반드시 튜플일 필요는 없습니다). \u003ccode\u003e__bases__\u003c/code\u003e가 없는 것은 빈 베이스 시퀀스와 동일합니다. \u003ccode\u003e__bases__\u003c/code\u003e 속성에 의해 정의된 메타-객체들 사이의 관계에는 순환(cycle)이 없어야 합니다. 즉, \u003ccode\u003e__bases__\u003c/code\u003e 속성은 파생된 메타-객체에서 그들의 기본 메타-객체로 향하는 아크(arcs)를 가진 방향성 비순환 그래프(directed acyclic graph)를 정의합니다. (여러 클래스가 동일한 기본 클래스를 가질 수 있으므로 반드시 트리(tree)일 필요는 없습니다.) 상속 그래프(inheritance graph) 내의 메타-객체의 \u003ccode\u003e__dict__\u003c/code\u003e 속성은 \u003ccode\u003e__class__\u003c/code\u003e 속성이 상속 트리의 루트(root)를 가리키는 일반 객체에 대한 속성 디스크립터를 제공합니다 (이는 상속 계층 구조의 루트와 동일하지 않습니다. 오히려 상속 트리가 일반적으로 그려지는 방식에 따라 맨 아래에 가깝습니다). 디스크립터는 먼저 루트 메타-객체의 딕셔너리에서 검색된 다음, 우선순위 규칙(아래 다음 단락 참조)에 따라 해당 베이스에서 검색됩니다.\u003c/p\u003e\n\u003ch3\u003e우선순위 규칙 (Precedence rules)\u003c/h3\u003e\n\u003cp\u003e주어진 일반 객체에 대한 상속 그래프 내의 두 메타-객체가 동일한 이름의 속성 디스크립터를 모두 정의할 때, 검색 순서는 메타-객체에 달려 있습니다. 이를 통해 다른 메타-객체가 다른 검색 순서를 정의할 수 있습니다. 특히, 고전적인 클래스는 오래된 왼쪽에서 오른쪽, 깊이 우선 규칙을 사용하는 반면, 새 스타일 클래스(new-style classes)는 더 고급 규칙을 사용합니다 (PEP 253의 메서드 결정 순서(method resolution order) 섹션 참조).\u003c/p\u003e\n\u003cp\u003e동적 속성(일반 객체의 \u003ccode\u003e__dict__\u003c/code\u003e에 정의된 속성)이 정적 속성(일반 객체의 \u003ccode\u003e__class__\u003c/code\u003e를 루트로 하는 상속 그래프 내의 메타-객체에 의해 정의된 속성)과 동일한 이름을 가질 때, 정적 속성이 \u003ccode\u003e__set__\u003c/code\u003e 메서드를 정의하는 디스크립터인 경우 우선순위를 가집니다 (아래 참조). 그렇지 않은 경우 (\u003ccode\u003e__set__\u003c/code\u003e 메서드가 없는 경우) 동적 속성이 우선순위를 가집니다. 즉, 데이터 속성( \u003ccode\u003e__set__\u003c/code\u003e 메서드를 가진 속성)의 경우 정적 정의가 동적 정의를 재정의하지만, 다른 속성의 경우 동적 정의가 정적 정의를 재정의합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e이론적 근거 (Rationale):\u003c/strong\u003e \"정적이 동적을 재정의한다\" 또는 \"동적이 정적을 재정의한다\"와 같은 간단한 규칙을 가질 수는 없습니다. 왜냐하면 일부 정적 속성은 실제로 동적 속성을 재정의하기 때문입니다. 예를 들어, 인스턴스의 \u003ccode\u003e__dict__\u003c/code\u003e에 있는 키 \u003ccode\u003e'__class__'\u003c/code\u003e는 정적으로 정의된 \u003ccode\u003e__class__\u003c/code\u003e 포인터에 의해 무시되지만, 반면에 \u003ccode\u003einst.__dict__\u003c/code\u003e의 대부분의 키는 \u003ccode\u003einst.__class__\u003c/code\u003e에 정의된 속성을 재정의합니다. 디스크립터에 \u003ccode\u003e__set__\u003c/code\u003e 메서드가 존재한다는 것은 이것이 데이터 디스크립터(data descriptor)임을 나타냅니다. (읽기 전용(read-only) 데이터 디스크립터도 \u003ccode\u003e__set__\u003c/code\u003e 메서드를 가집니다. 항상 예외를 발생시킵니다.) 디스크립터에 \u003ccode\u003e__set__\u003c/code\u003e 메서드가 없다는 것은 디스크립터가 할당을 가로채는 데 관심이 없음을 나타내며, 이때는 고전적인 규칙이 적용됩니다: 메서드와 동일한 이름을 가진 인스턴스 변수는 해당 특정 인스턴스에 대해 메서드를 삭제될 때까지 숨깁니다.\u003c/p\u003e\n\u003ch2\u003e속성 디스크립터 (Attribute descriptors)\u003c/h2\u003e\n\u003cp\u003e여기서부터 흥미롭고 복잡해집니다. 속성 디스크립터(줄여서 디스크립터)는 메타-객체의 \u003ccode\u003e__dict__\u003c/code\u003e (또는 그 조상 중 하나의 \u003ccode\u003e__dict__\u003c/code\u003e)에 저장되며, 두 가지 용도로 사용됩니다. 디스크립터는 (일반, 비-메타) 객체의 해당 속성 값을 가져오거나 설정하는 데 사용될 수 있으며, 문서화 및 인트로스펙션 목적으로 속성을 설명하는 추가 인터페이스를 가집니다.\u003c/p\u003e\n\u003cp\u003ePython에서는 디스크립터 인터페이스를 설계하는 데 있어 이전의 선행 작업이 거의 없습니다. 값을 가져오거나 설정하는 것, 또는 다른 방식으로 속성을 설명하는 것에 대한 선행 작업이 없었으며, 몇 가지 사소한 속성( \u003ccode\u003e__name__\u003c/code\u003e과 \u003ccode\u003e__doc__\u003c/code\u003e이 속성의 이름과 독스트링이어야 한다고 가정하는 것이 합리적)을 제외하면 그렇습니다. 저는 아래에서 그러한 API를 제안할 것입니다.\u003c/p\u003e\n\u003cp\u003e메타-객체의 \u003ccode\u003e__dict__\u003c/code\u003e에서 발견된 객체가 속성 디스크립터가 아닌 경우, 하위 호환성(backward compatibility)은 특정 최소한의 의미론을 요구합니다. 이는 기본적으로 Python 함수 또는 언바운드 메서드(unbound method)인 경우 해당 속성이 메서드이고, 그렇지 않은 경우 동적 데이터 속성의 기본값이라는 의미입니다. 하위 호환성은 또한 (\u003ccode\u003e__setattr__\u003c/code\u003e 메서드가 없는 경우) 메서드에 해당하는 속성에 할당하는 것이 합법적이며, 이것이 해당 특정 인스턴스에 대해 메서드를 가리는 데이터 속성을 생성한다는 것을 요구합니다. 그러나 이러한 의미론은 일반 클래스와의 하위 호환성을 위해서만 필요합니다.\u003c/p\u003e\n\u003cp\u003e인트로스펙션 API는 읽기 전용(read-only) API입니다. 우리는 특수 속성(\u003ccode\u003e__dict__\u003c/code\u003e, \u003ccode\u003e__class__\u003c/code\u003e, \u003ccode\u003e__bases__\u003c/code\u003e)에 대한 할당의 효과나 \u003ccode\u003e__dict__\u003c/code\u003e 항목에 대한 할당의 효과를 정의하지 않습니다. 일반적으로 이러한 할당은 금지된 것으로 간주되어야 합니다. 향후 PEP에서 이러한 할당 중 일부에 대한 의미론을 정의할 수 있습니다. (특히 현재 인스턴스는 \u003ccode\u003e__class__\u003c/code\u003e 및 \u003ccode\u003e__dict__\u003c/code\u003e에 대한 할당을 지원하고, 클래스는 \u003ccode\u003e__bases__\u003c/code\u003e 및 \u003ccode\u003e__dict__\u003c/code\u003e에 대한 할당을 지원하기 때문입니다.)\u003c/p\u003e\n\u003ch3\u003e속성 디스크립터 API의 명세 (Specification of the attribute descriptor API)\u003c/h3\u003e\n\u003cp\u003e속성 디스크립터는 다음 속성들을 가질 수 있습니다. 예시에서 \u003ccode\u003ex\u003c/code\u003e는 객체이고, \u003ccode\u003eC\u003c/code\u003e는 \u003ccode\u003ex.__class__\u003c/code\u003e이며, \u003ccode\u003ex.meth()\u003c/code\u003e는 메서드이고, \u003ccode\u003ex.ivar\u003c/code\u003e는 데이터 속성 또는 인스턴스 변수입니다. 모든 속성은 선택 사항입니다. 즉, 특정 속성은 주어진 디스크립터에 존재할 수도 있고 아닐 수도 있습니다. 속성이 없다는 것은 해당 정보를 사용할 수 없거나 해당 기능이 구현되지 않았음을 의미합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__name__\u003c/code\u003e: 속성 이름. 별칭(aliasing) 및 이름 변경으로 인해 속성은 다른 이름으로 알려질 수 있지만 (추가적으로 또는 독점적으로), 이것은 속성이 생성된 이름입니다. 예시: \u003ccode\u003eC.meth.__name__ == 'meth'\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__doc__\u003c/code\u003e: 속성의 문서화 문자열(docstring). \u003ccode\u003eNone\u003c/code\u003e일 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__objclass__\u003c/code\u003e: 이 속성을 선언한 클래스. 디스크립터는 이 클래스의 인스턴스인 객체(서브클래스의 인스턴스 포함)에만 적용됩니다. 예시: \u003ccode\u003eC.meth.__objclass__\u003c/code\u003e는 \u003ccode\u003eC\u003c/code\u003e입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__get__()\u003c/code\u003e: 객체에서 속성 값을 검색하는 한두 개의 인수로 호출 가능한 함수. 이는 메서드 디스크립터의 경우 \"바운드 메서드(bound method)\" 객체를 반환할 수 있으므로 \"바인딩(binding)\" 작업이라고도 합니다. 첫 번째 인수 \u003ccode\u003eX\u003c/code\u003e는 속성을 검색하거나 바인딩해야 하는 객체입니다. \u003ccode\u003eX\u003c/code\u003e가 \u003ccode\u003eNone\u003c/code\u003e인 경우, 선택적 두 번째 인수 \u003ccode\u003eT\u003c/code\u003e는 메타-객체여야 하며 바인딩 작업은 \u003ccode\u003eT\u003c/code\u003e의 인스턴스로 제한되는 언바운드 메서드(unbound method)를 반환할 수 있습니다. \u003ccode\u003eX\u003c/code\u003e와 \u003ccode\u003eT\u003c/code\u003e가 모두 지정된 경우 \u003ccode\u003eX\u003c/code\u003e는 \u003ccode\u003eT\u003c/code\u003e의 인스턴스여야 합니다. 바인딩 작업이 정확히 무엇을 반환하는지는 디스크립터의 의미론에 따라 달라집니다. 예를 들어, 스태틱 메서드와 클래스 메서드(아래 참조)는 인스턴스를 무시하고 대신 타입에 바인딩합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__set__()\u003c/code\u003e: 객체에 속성 값을 설정하는 두 개의 인수를 받는 함수. 속성이 읽기 전용인 경우, 이 메서드는 \u003ccode\u003eTypeError\u003c/code\u003e 또는 \u003ccode\u003eAttributeError\u003c/code\u003e 예외를 발생시킬 수 있습니다 (둘 다 허용됩니다. 둘 다 정의되지 않거나 설정할 수 없는 속성에 대해 역사적으로 발견되었기 때문입니다). 예시: \u003ccode\u003eC.ivar.set(x, y)\u003c/code\u003e는 \u003ccode\u003ex.ivar = y\u003c/code\u003e와 동일합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e스태틱 메서드 및 클래스 메서드 (Static methods and class methods)\u003c/h2\u003e\n\u003cp\u003e디스크립터 API를 통해 스태틱 메서드(static methods)와 클래스 메서드(class methods)를 추가할 수 있습니다. 스태틱 메서드는 설명하기 쉽습니다. 이들은 C++ 또는 Java의 static 메서드와 거의 동일하게 작동합니다. 다음은 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass C:\r\n    def foo(x, y):\r\n        print(\"staticmethod\", x, y)\r\n    foo = staticmethod(foo)\r\n\r\nC.foo(1, 2)\r\nc = C()\r\nc.foo(1, 2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eC.foo(1, 2)\u003c/code\u003e 호출과 \u003ccode\u003ec.foo(1, 2)\u003c/code\u003e 호출 모두 \u003ccode\u003efoo()\u003c/code\u003e를 두 개의 인수로 호출하고 \"staticmethod 1 2\"를 출력합니다. \u003ccode\u003efoo()\u003c/code\u003e의 정의에 \"self\"는 선언되지 않았으며, 호출에 인스턴스가 필요하지 않습니다.\u003c/p\u003e\n\u003cp\u003e클래스 문(class statement)의 \"foo = staticmethod(foo)\" 줄이 결정적인 요소입니다. 이것이 \u003ccode\u003efoo()\u003c/code\u003e를 스태틱 메서드로 만듭니다. 내장 \u003ccode\u003estaticmethod()\u003c/code\u003e는 함수 인수를 \u003ccode\u003e__get__()\u003c/code\u003e 메서드가 원래 함수를 변경하지 않고 반환하는 특수한 종류의 디스크립터로 래핑(wraps)합니다. 이것이 없으면, 표준 함수 객체의 \u003ccode\u003e__get__()\u003c/code\u003e 메서드는 \u003ccode\u003ec.foo\u003c/code\u003e에 대한 바운드 메서드 객체와 \u003ccode\u003eC.foo\u003c/code\u003e에 대한 언바운드 메서드 객체를 생성했을 것입니다.\u003c/p\u003e\n\u003cp\u003e(XXX Barry는 \"static\"이라는 단어가 이미 여러 방식으로 오버로드(overloaded)되어 있기 때문에 \"staticmethod\" 대신 \"sharedmethod\"를 사용할 것을 제안했습니다. 하지만 shared가 올바른 의미를 전달하는지 확실하지 않습니다.)\u003c/p\u003e\n\u003cp\u003e클래스 메서드(Class methods)는 호출되는 클래스인 암묵적인 첫 번째 인수를 받는 메서드를 선언하기 위해 유사한 패턴을 사용합니다. 이것은 C++나 Java에 상응하는 것이 없으며, Smalltalk의 클래스 메서드와 완전히 같지는 않지만 유사한 목적을 수행할 수 있습니다. Armin Rigo에 따르면, 이들은 Borland Pascal 방언 Delphi의 \"가상 클래스 메서드(virtual class methods)\"와 유사합니다. (Python은 또한 실제 메타클래스(metaclasses)를 가지고 있으며, 아마도 메타클래스에 정의된 메서드가 \"클래스 메서드\"라는 이름에 더 적합할 것입니다. 하지만 대부분의 프로그래머는 메타클래스를 사용하지 않을 것이라고 예상합니다.) 다음은 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass C:\r\n    def foo(cls, y):\r\n        print(\"classmethod\", cls, y)\r\n    foo = classmethod(foo)\r\n\r\nC.foo(1)\r\nc = C()\r\nc.foo(1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eC.foo(1)\u003c/code\u003e 호출과 \u003ccode\u003ec.foo(1)\u003c/code\u003e 호출 모두 \u003ccode\u003efoo()\u003c/code\u003e를 두 개의 인수로 호출하고 \"classmethod \u003ccode\u003e__main__.C\u003c/code\u003e 1\"을 출력합니다. \u003ccode\u003efoo()\u003c/code\u003e의 첫 번째 인수는 암묵적이며, 메서드가 인스턴스를 통해 호출되었더라도 클래스입니다. 이제 예시를 계속해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass D(C):\r\n    pass\r\n\r\nD.foo(1)\r\nd = D()\r\nd.foo(1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 두 번 모두 \"classmethod \u003ccode\u003e__main__.D\u003c/code\u003e 1\"을 출력합니다. 즉, \u003ccode\u003efoo()\u003c/code\u003e의 첫 번째 인수로 전달된 클래스는 호출에 관련된 클래스이며, \u003ccode\u003efoo()\u003c/code\u003e의 정의에 관련된 클래스가 아닙니다.\u003c/p\u003e\n\u003cp\u003e하지만 이것을 주목하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass E(C):\r\n    def foo(cls, y): # C.foo 재정의\r\n        print(\"E.foo() called\")\r\n        C.foo(y)\r\n    foo = classmethod(foo)\r\n\r\nE.foo(1)\r\ne = E()\r\ne.foo(1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서 \u003ccode\u003eE.foo()\u003c/code\u003e에서 \u003ccode\u003eC.foo()\u003c/code\u003e를 호출하면 첫 번째 인수로 클래스 \u003ccode\u003eC\u003c/code\u003e를 보게 될 것이고, 클래스 \u003ccode\u003eE\u003c/code\u003e를 보지 않을 것입니다. 이것은 호출이 클래스 \u003ccode\u003eC\u003c/code\u003e를 지정하므로 예상되는 결과입니다. 그러나 이것은 이러한 클래스 메서드와 메타클래스에 정의된 메서드 간의 차이를 강조합니다. 메타메서드에 대한 업콜(upcall)은 대상 클래스를 명시적인 첫 번째 인수로 전달할 것입니다. (이것을 이해하지 못해도 걱정하지 마십시오. 혼자가 아닙니다.) \u003ccode\u003ecls.foo(y)\u003c/code\u003e를 호출하는 것은 실수일 수 있습니다. 무한 재귀(infinite recursion)를 일으킬 것입니다. 또한 클래스 메서드에 명시적인 \u003ccode\u003ecls\u003c/code\u003e 인수를 지정할 수 없다는 점도 유의하십시오. (예: PEP 253의 \u003ccode\u003e__new__\u003c/code\u003e 메서드에 필요한 경우) 대신 클래스를 명시적인 첫 번째 인수로 사용하는 스태틱 메서드를 사용하십시오.\u003c/p\u003e\n\u003ch2\u003eC API\u003c/h2\u003e\n\u003cp\u003eXXX 다음은 다른 독자를 염두에 두고 작성한 매우 거친 텍스트입니다. 더 편집해야 합니다. XXX 또한 C API에 대해 충분히 자세히 다루지 않습니다.\u003c/p\u003e\n\u003cp\u003e내장 타입은 두 가지 방식으로 특수 데이터 속성을 선언할 수 있습니다: \u003ccode\u003estruct memberlist\u003c/code\u003e (structmember.h에 정의됨) 또는 \u003ccode\u003estruct getsetlist\u003c/code\u003e (descrobject.h에 정의됨)를 사용합니다. \u003ccode\u003estruct memberlist\u003c/code\u003e는 새로운 용도로 사용되는 오래된 메커니즘입니다. 각 속성은 이름, 타입(다양한 C 타입과 \u003ccode\u003ePyObject *\u003c/code\u003e 지원), 인스턴스의 시작으로부터의 오프셋(offset), 읽기 전용 플래그(read-only flag)를 포함하는 디스크립터 레코드(descriptor record)를 가집니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estruct getsetlist\u003c/code\u003e 메커니즘은 새롭고, 추가적인 검사가 필요하거나 단순히 계산된 속성(calculated attributes)인 경우와 같이 해당 틀에 맞지 않는 경우를 위해 고안되었습니다. 여기에서 각 속성은 이름, getter C 함수 포인터, setter C 함수 포인터, 그리고 컨텍스트 포인터(context pointer)를 가집니다. 함수 포인터는 선택 사항이므로, 예를 들어 setter 함수 포인터를 \u003ccode\u003eNULL\u003c/code\u003e로 설정하면 읽기 전용 속성이 됩니다. 컨텍스트 포인터는 일반 getter/setter 함수에 보조 정보(auxiliary information)를 전달하기 위한 것이지만, 아직 이에 대한 필요성을 찾지 못했습니다.\u003c/p\u003e\n\u003cp\u003e내장 메서드를 선언하는 유사한 메커니즘도 있습니다: 이들은 \u003ccode\u003ePyMethodDef\u003c/code\u003e 구조체이며, 이름과 C 함수 포인터(및 호출 규칙에 대한 일부 플래그)를 포함합니다.\u003c/p\u003e\n\u003cp\u003e전통적으로 내장 타입은 이러한 속성 정의가 작동하도록 자체 \u003ccode\u003etp_getattro\u003c/code\u003e 및 \u003ccode\u003etp_setattro\u003c/code\u003e 슬롯 함수를 정의해야 했습니다 (\u003ccode\u003ePyMethodDef\u003c/code\u003e와 \u003ccode\u003estruct memberlist\u003c/code\u003e는 꽤 오래되었습니다). \u003ccode\u003ePyMethodDef\u003c/code\u003e 또는 \u003ccode\u003ememberlist\u003c/code\u003e 구조체 배열, 객체, 속성 이름을 받아 목록에서 찾으면 속성을 반환하거나 설정하고, 찾지 못하면 예외를 발생시키는 편의 함수가 있습니다. 그러나 이러한 편의 함수는 특정 타입의 \u003ccode\u003etp_getattro\u003c/code\u003e 또는 \u003ccode\u003etp_setattro\u003c/code\u003e 메서드에 의해 명시적으로 호출되어야 했고, 요청된 속성을 설명하는 배열 요소를 찾기 위해 \u003ccode\u003estrcmp()\u003c/code\u003e를 사용하여 배열을 선형 검색했습니다.\u003c/p\u003e\n\u003cp\u003e이제 저는 이 상황을 상당히 개선하는 아주 새로운 일반 메커니즘을 가지고 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePyMethodDef\u003c/code\u003e, \u003ccode\u003ememberlist\u003c/code\u003e, \u003ccode\u003egetsetlist\u003c/code\u003e 구조체 배열에 대한 포인터는 새로운 타입 객체(\u003ccode\u003etp_methods\u003c/code\u003e, \u003ccode\u003etp_members\u003c/code\u003e, \u003ccode\u003etp_getset\u003c/code\u003e)의 일부입니다. 타입 초기화 시점(\u003ccode\u003ePyType_InitDict()\u003c/code\u003e)에, 이 세 배열의 각 항목에 대해 디스크립터 객체가 생성되어 타입에 속하는 딕셔너리(\u003ccode\u003etp_dict\u003c/code\u003e)에 배치됩니다. 디스크립터는 주로 해당 구조체를 가리키는 매우 간결한 객체입니다. 구현 세부 사항으로는 모든 디스크립터가 동일한 객체 타입을 공유하며, 식별자 필드(discriminator field)가 어떤 종류의 디스크립터인지(메서드, 멤버 또는 getset) 알려줍니다. PEP 252에 설명된 대로, 디스크립터는 객체 인수를 받아 해당 객체의 속성을 반환하는 \u003ccode\u003eget()\u003c/code\u003e 메서드를 가집니다. 쓰기 가능한(writable) 속성에 대한 디스크립터는 객체와 값을 받아 해당 객체의 속성을 설정하는 \u003ccode\u003eset()\u003c/code\u003e 메서드도 가집니다. \u003ccode\u003eget()\u003c/code\u003e 객체는 메서드에 대한 바인딩(\u003ccode\u003ebind()\u003c/code\u003e) 작업으로도 작동하여 언바운드 메서드 구현을 객체에 바인딩합니다. 거의 모든 내장 객체는 이제 자체 \u003ccode\u003etp_getattro\u003c/code\u003e 및 \u003ccode\u003etp_setattro\u003c/code\u003e 구현을 제공하는 대신, \u003ccode\u003ePyObject_GenericGetAttr\u003c/code\u003e 및 (쓰기 가능한 속성이 있는 경우) \u003ccode\u003ePyObject_GenericSetAttr\u003c/code\u003e을 \u003ccode\u003etp_getattro\u003c/code\u003e 및 \u003ccode\u003etp_setattro\u003c/code\u003e 슬롯에 배치합니다. (또는 이들을 \u003ccode\u003eNULL\u003c/code\u003e로 남겨두고, 첫 번째 인스턴스가 생성되기 전에 타입에 대한 \u003ccode\u003ePyType_InitDict()\u003c/code\u003e에 대한 명시적 호출을 준비하는 경우 기본 기본 객체로부터 상속받을 수 있습니다.) 가장 간단한 경우, \u003ccode\u003ePyObject_GenericGetAttr()\u003c/code\u003e은 정확히 하나의 딕셔너리 조회(lookup)를 수행합니다: 타입의 딕셔너리(\u003ccode\u003eobj-\u003eob_type-\u003etp_dict\u003c/code\u003e)에서 속성 이름을 찾습니다. 성공하면 두 가지 가능성이 있습니다: 디스크립터에 \u003ccode\u003eget\u003c/code\u003e 메서드가 있거나 없습니다. 속도를 위해 \u003ccode\u003eget\u003c/code\u003e 및 \u003ccode\u003eset\u003c/code\u003e 메서드는 타입 슬롯(\u003ccode\u003etp_descr_get\u003c/code\u003e 및 \u003ccode\u003etp_descr_set\u003c/code\u003e)입니다. \u003ccode\u003etp_descr_get\u003c/code\u003e 슬롯이 \u003ccode\u003eNULL\u003c/code\u003e이 아니면, 객체를 유일한 인수로 전달하여 호출되며, 이 호출의 반환 값이 \u003ccode\u003egetattr\u003c/code\u003e 작업의 결과가 됩니다. \u003ccode\u003etp_descr_get\u003c/code\u003e 슬롯이 \u003ccode\u003eNULL\u003c/code\u003e이면, 대체로 디스크립터 자체가 반환됩니다 (메서드가 아닌 단순 값인 클래스 속성과 비교). \u003ccode\u003ePyObject_GenericSetAttr()\u003c/code\u003e은 매우 유사하게 작동하지만 \u003ccode\u003etp_descr_set\u003c/code\u003e 슬롯을 사용하고 객체와 새 속성 값으로 호출합니다. \u003ccode\u003etp_descr_set\u003c/code\u003e 슬롯이 \u003ccode\u003eNULL\u003c/code\u003e이면 \u003ccode\u003eAttributeError\u003c/code\u003e가 발생합니다. 이제 더 복잡한 경우를 살펴봅시다. 위에서 설명한 접근 방식은 리스트, 문자열, 숫자와 같은 대부분의 내장 객체에 적합합니다. 그러나 일부 객체 타입은 각 인스턴스에 임의의 속성을 저장할 수 있는 딕셔너리를 가집니다. 사실, 클래스 문을 사용하여 기존 내장 타입을 서브타입화(subtype)할 때, 이러한 딕셔너리를 자동으로 얻습니다 (다른 고급 기능인 \u003ccode\u003e__slots__\u003c/code\u003e를 사용하여 명시적으로 끄지 않는 한). 이것을 타입 딕셔너리(type dict)와 구별하기 위해 인스턴스 딕셔너리(instance dict)라고 부르겠습니다. 더 복잡한 경우, 인스턴스 딕셔너리에 저장된 이름과 타입 딕셔너리에 저장된 이름 사이에 충돌이 발생합니다. 두 딕셔너리가 동일한 키를 가진 항목을 가지고 있다면, 어떤 것을 반환해야 할까요? 고전적인 Python에서 지침을 찾아보면 상충되는 규칙을 발견합니다: 클래스 인스턴스의 경우, 인스턴스 딕셔너리가 클래스 딕셔너리를 재정의하지만, 인스턴스 딕셔너리보다 우선순위를 가지는 특수 속성(\u003ccode\u003e__dict__\u003c/code\u003e 및 \u003ccode\u003e__class__\u003c/code\u003e 등)은 예외입니다. 저는 \u003ccode\u003ePyObject_GenericGetAttr()\u003c/code\u003e에 구현된 다음 규칙 집합으로 이 문제를 해결했습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e타입 딕셔너리에서 찾습니다. 데이터 디스크립터를 찾으면 \u003ccode\u003eget()\u003c/code\u003e 메서드를 사용하여 결과를 생성합니다. 이것은 \u003ccode\u003e__dict__\u003c/code\u003e 및 \u003ccode\u003e__class__\u003c/code\u003e와 같은 특수 속성을 처리합니다.\u003c/li\u003e\n\u003cli\u003e인스턴스 딕셔너리에서 찾습니다. 아무것도 찾으면 그것이 결과입니다. (이것은 일반적으로 인스턴스 딕셔너리가 클래스 딕셔너리를 재정의해야 한다는 요구 사항을 처리합니다.)\u003c/li\u003e\n\u003cli\u003e타입 딕셔너리에서 다시 찾습니다 (실제로는 물론 1단계에서 저장된 결과를 사용합니다). 디스크립터를 찾으면 \u003ccode\u003eget()\u003c/code\u003e 메서드를 사용하고, 다른 것을 찾으면 그것이 결과이며, 거기에 없으면 \u003ccode\u003eAttributeError\u003c/code\u003e를 발생시킵니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이것은 디스크립터를 데이터 디스크립터(data descriptor)와 비-데이터 디스크립터(nondata descriptor)로 분류하는 것을 요구합니다. 현재 구현은 멤버(member) 및 getset 디스크립터를 데이터로 (읽기 전용이더라도!), 메서드 디스크립터를 비-데이터로 합리적으로 분류합니다. 비-디스크립터(함수 포인터 또는 일반 값과 같은)도 비-데이터로 분류됩니다 (!).\u003c/p\u003e\n\u003cp\u003e이 체계에는 한 가지 단점이 있습니다: 제가 가장 일반적인 경우라고 가정하는, 인스턴스 딕셔너리에 저장된 인스턴스 변수를 참조하는 경우, 두 번의 딕셔너리 조회를 수행합니다. 반면 고전적인 체계는 두 개의 밑줄로 시작하는 속성에 대한 빠른 테스트와 단일 딕셔너리 조회를 수행했습니다. (구현은 슬프게도 \u003ccode\u003einstance_getattr()\u003c/code\u003e가 \u003ccode\u003einstance_getattr1()\u003c/code\u003e을 호출하고 \u003ccode\u003einstance_getattr1()\u003c/code\u003e이 \u003ccode\u003einstance_getattr2()\u003c/code\u003e를 호출하며, \u003ccode\u003einstance_getattr2()\u003c/code\u003e가 최종적으로 \u003ccode\u003ePyDict_GetItem()\u003c/code\u003e을 호출하는 방식으로 구성되어 있고, 밑줄 테스트는 \u003ccode\u003ePyString_AsString()\u003c/code\u003e을 호출하는 대신 인라인(inlining)되지 않습니다. 이 부분을 최적화하는 것이 Python 2.2의 속도를 높이는 좋은 아이디어가 아닐까 궁금합니다. 모두 제거할 계획이 아니었다면 말이죠. :-) 벤치마크 결과 실제로 이것이 고전적인 인스턴스 변수 조회만큼 빠르다는 것을 확인했으므로 더 이상 걱정하지 않습니다. 동적 타입(dynamic types)에 대한 수정: 1단계와 3단계는 타입과 모든 기본 클래스의 딕셔너리에서 찾습니다 (물론 MRO 순서로).\u003c/p\u003e\n\u003ch2\u003e논의 (Discussion)\u003c/h2\u003e\n\u003cp\u003eXXX\u003c/p\u003e\n\u003ch2\u003e예시 (Examples)\u003c/h2\u003e\n\u003cp\u003e리스트를 살펴봅시다. 고전적인 Python에서는 리스트의 메서드 이름이 리스트 객체의 \u003ccode\u003e__methods__\u003c/code\u003e 속성으로 제공되었습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e [].__methods__\r\n['append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\r\n\u003e\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 제안에 따라, \u003ccode\u003e__methods__\u003c/code\u003e 속성은 더 이상 존재하지 않습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e [].__methods__\r\nTraceback (most recent call last):\r\n  File \"\u0026#x3C;stdin\u003e\", line 1, in ?\r\nAttributeError: 'list' object has no attribute '__methods__'\r\n\u003e\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e대신, 리스트 타입에서 동일한 정보를 얻을 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e T = [].__class__\r\n\u003e\u003e\u003e T\r\n\u0026#x3C;class 'list'\u003e\r\n\u003e\u003e\u003e dir(T) # T.__dict__.keys()와 같지만 정렬됨\r\n['__add__', '__class__', '__contains__', '__eq__', '__ge__', '__getattr__', '__getitem__', '__getslice__', '__gt__', '__iadd__', '__imul__', '__init__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__radd__', '__repr__', '__rmul__', '__setitem__', '__setslice__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\r\n\u003e\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 인트로스펙션 API는 이전 API보다 더 많은 정보를 제공합니다. 일반 메서드 외에도, 일반적으로 특수 표기법(예: \u003ccode\u003e__iadd__\u003c/code\u003e ( \u003ccode\u003e+=\u003c/code\u003e ), \u003ccode\u003e__len__\u003c/code\u003e ( \u003ccode\u003elen\u003c/code\u003e ), \u003ccode\u003e__ne__\u003c/code\u003e ( \u003ccode\u003e!=\u003c/code\u003e ))을 통해 호출되는 메서드도 보여줍니다. 이 목록의 모든 메서드를 직접 호출할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e a = ['tic', 'tac']\r\n\u003e\u003e\u003e T.__len__(a) # len(a)와 동일\r\n2\r\n\u003e\u003e\u003e T.append(a, 'toe') # a.append('toe')와 동일\r\n\u003e\u003e\u003e a\r\n['tic', 'tac', 'toe']\r\n\u003e\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 사용자 정의 클래스와 동일합니다.\u003c/p\u003e\n\u003cp\u003e목록에서 친숙하지만 놀라운 이름인 \u003ccode\u003e__init__\u003c/code\u003e을 주목하십시오. 이것은 PEP 253의 영역입니다.\u003c/p\u003e\n\u003ch2\u003e하위 호환성 (Backwards compatibility)\u003c/h2\u003e\n\u003cp\u003eXXX\u003c/p\u003e\n\u003ch2\u003e경고 및 오류 (Warnings and Errors)\u003c/h2\u003e\n\u003cp\u003eXXX\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e이 PEP의 부분적인 구현은 CVS에서 \"descr-branch\"라는 이름의 브랜치로 사용할 수 있습니다. 이 구현을 실험하려면 http://sourceforge.net/cvs/?group_id=5470의 지침에 따라 CVS에서 Python을 체크아웃(check out)하되, \u003ccode\u003ecvs checkout\u003c/code\u003e 명령에 인수 \"-r descr-branch\"를 추가하십시오. (기존 체크아웃에서 시작하여 \"cvs update -r descr-branch\"를 수행할 수도 있습니다.) 여기에 설명된 기능의 몇 가지 예시는 파일 \u003ccode\u003eLib/test/test_descr.py\u003c/code\u003e를 참조하십시오.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 이 브랜치의 코드는 이 PEP의 범위를 훨씬 넘어섭니다. 또한 PEP 253 (내장 타입 서브타이핑, Subtyping Built-in Types)에 대한 실험 영역이기도 합니다.\u003c/p\u003e\n\u003ch2\u003e참조 (References)\u003c/h2\u003e\n\u003cp\u003eXXX\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1098,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 252 - Making Types Look More Like Classes\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 17:30:03+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>