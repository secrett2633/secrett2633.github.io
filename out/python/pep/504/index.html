<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-19cfc001fdac3337.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1098<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Withdrawn] PEP 504 - Using the System RNG by default</h1><div class="page__meta"><time dateTime="2025-09-26 22:47:22+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0504/">PEP 504 - Using the System RNG by default</a></p>
<p><strong>상태:</strong> Withdrawn | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 15-Sep-2015</p>
</blockquote>
<h2>PEP 504 – 기본적으로 시스템 RNG 사용 (Using the System RNG by default)</h2>
<p><strong>저자:</strong> Alyssa Coghlan 
<strong>상태:</strong> 철회됨 (Withdrawn)
<strong>유형:</strong> Standards Track
<strong>생성일:</strong> 2015년 9월 15일
<strong>Python 버전:</strong> 3.6
<strong>이력:</strong> 2015년 9월 15일</p>
<hr>
<h3>초록 (Abstract)</h3>
<p>현재 Python의 <code>random</code> 모듈에 있는 모듈 레벨 API는 기본적으로 결정론적(deterministic)인 Mersenne Twister 의사 난수 생성기(PRNG)를 사용합니다. 이로 인해 사용자가 "보안에 민감한(security sensitive)" 작업을 수행할 때는 <code>os.urandom</code> 또는 <code>random.SystemRandom</code> 인터페이스와 같은 암호학적으로 안전한 난수 생성기(CSPRNG)를 사용하거나 <code>cryptography</code>와 같은 서드파티 라이브러리를 사용해야 한다는 것을 인지하고 있어야 합니다.</p>
<p>하지만 이러한 접근 방식은 자신이 보안에 민감한 작업을 하고 있다는 것을 인지하지 못하는 개발자들이 기본 모듈 레벨 API를 사용하게 되어, 사용자들을 불필요한 위험에 노출시키는 결과를 초래했습니다.</p>
<p>이 문제는 당장 심각한(acute) 문제는 아니지만 만성적인(chronic) 문제입니다. 보안 취약점이 도입된 시점과 실제 악용되는 시점 사이에 긴 지연이 발생하는 경우가 많아, 개발자들이 경험을 통해 자연스럽게 학습하기 어렵게 만듭니다.</p>
<p>이 문제에 대한 궁극적이고 보편적인 해결책을 제공하기 위해, 이 PEP는 Python 3.6부터 Python이 기본적으로 시스템 난수 생성기(System Random Number Generator, RNG)를 사용하도록 전환하고, 개발자들이 <code>random.ensure_repeatable()</code>이라는 새로운 API를 사용하거나 자신만의 <code>random.Random()</code> 인스턴스를 명시적으로 생성하여 프로세스 전반에 걸쳐 결정론적 난수 생성기를 사용하도록 옵트인(opt-in)해야 한다고 제안합니다.</p>
<p>기존 코드에 미치는 영향을 최소화하기 위해 결정성을 요구하는 모듈 레벨 API는 암시적으로 결정론적 PRNG로 전환될 것입니다.</p>
<h3>PEP 철회 (PEP Withdrawal)</h3>
<p>이 PEP에 대한 논의 과정에서 Steven D'Aprano는 기본 비밀번호 및 기타 토큰 생성과 같은 보안에 민감한 작업을 처리하기 위한 "한 가지 명확한 방법(one obvious way)"을 제공하는 표준화된 <code>secrets</code> 모듈을 제안했습니다.</p>
<p>Steven의 제안은 기존 <code>random</code> 모듈 API에 대한 호환성 위험을 도입하지 않으면서, 이러한 토큰을 쉽게 생성하는 방법과 올바르게 생성하는 방법을 일치시키는 원하는 효과를 가져옵니다. 따라서 이 PEP는 Steven의 제안을 PEP 506으로 발전시키는 추가 작업을 위해 철회되었습니다.</p>
<h3>제안 (Proposal)</h3>
<p>현재 <code>random</code> 모듈의 모듈 레벨 함수를 보안에 민감한 애플리케이션에 사용하는 것은 결코 올바르지 않습니다. 이 PEP는 Python 3.6+에서 이 경고를 "해당 프로세스에서 <code>random.ensure_repeatable()</code>이 (직접적으로든 간접적으로든) 호출되는 경우 <code>random</code> 모듈의 모듈 레벨 함수를 보안에 민감한 애플리케이션에 사용하는 것은 올바르지 않다"는 식으로 변경할 것을 제안합니다.</p>
<p>이를 달성하기 위해, 현재 <code>random.Random</code> 인스턴스의 바운드 메서드인 것과는 달리, <code>random</code>의 모듈 레벨 호출 가능(callable) 항목들은 기존 <code>random._inst</code> 모듈 속성의 해당 메서드에 위임하는 함수로 변경될 것입니다.</p>
<p>기본적으로 이 속성은 <code>random.SystemRandom</code> 인스턴스에 바인딩됩니다.</p>
<p>새로운 <code>random.ensure_repeatable()</code> API는 <code>random._inst</code> 속성을 <code>system.Random</code> 인스턴스에 다시 바인딩하여, 이전 Python 버전과 동일한 모듈 레벨 API 동작을 복원합니다 (추가적인 간접 참조(indirection) 수준을 제외하고).</p>
<pre><code class="language-python">def ensure_repeatable():
    """Switch to using random.Random() for the module level APIs
    This switches the default RNG instance from the cryptographically secure
    random.SystemRandom() to the deterministic random.Random(), enabling the
    seed(), getstate() and setstate() operations. This means a particular
    random scenario can be replayed later by providing the same seed value
    or restoring a previously saved state.
    NOTE: Libraries implementing security sensitive operations should always
    explicitly use random.SystemRandom() or os.urandom in order to correctly
    handle applications that call this function.
    """
    if not isinstance(_inst, Random):
        _inst = random.Random()
</code></pre>
<p>기존 코드에 미치는 영향을 최소화하기 위해 다음 모듈 레벨 함수 중 하나를 호출하면 암시적으로 <code>random.ensure_repeatable()</code>이 호출됩니다.</p>
<ul>
<li><code>random.seed</code></li>
<li><code>random.getstate</code></li>
<li><code>random.setstate</code></li>
</ul>
<p><code>random.Random</code> 또는 <code>random.SystemRandom</code> 클래스 API에는 변경 사항이 제안되지 않았습니다. 명시적으로 자신만의 난수 생성기를 인스턴스화하는 애플리케이션은 이 제안의 영향을 전혀 받지 않습니다.</p>
<h3>암시적 옵트인에 대한 경고 (Warning on implicit opt-in)</h3>
<p>Python 3.6에서는 결정론적 PRNG 사용에 대한 암시적 옵트인은 다음 확인을 사용하여 DeprecationWarning을 발생시킬 것입니다.</p>
<pre><code class="language-python">if not isinstance(_inst, Random):
    warnings.warn(DeprecationWarning, "Implicitly ensuring repeatability. "
                                      "See help(random.ensure_repeatable) for details")
    ensure_repeatable()
</code></pre>
<p>경고의 특정 문구는 <code>print</code> 호출에서 괄호 누락에 추가된 사용자 지정 오류 메시지와 같이 Stack Overflow에 적절한 답변이 추가되어야 합니다.</p>
<p>Python 2.7이 보안 수정 전용 모드로 전환된 후 첫 번째 Python 3 릴리스에서는 이 DeprecationWarning이 기본적으로 표시되는 <code>RuntimeWarning</code>으로 상향 조정될 것입니다.</p>
<p>이 PEP는 특정 시드(seed) 값이 주어졌을 때 동일한 일련의 출력을 생성하는 결정론적 PRNG를 기본 RNG로 사용하도록 보장하는 기능을 제거할 것을 제안하지 않습니다. 이 기능은 모델링 및 시뮬레이션 시나리오에서 널리 사용되며, <code>ensure_repeatable()</code>이 직접 또는 간접적으로 호출되어야 한다고 요구하는 것은 웹 애플리케이션에서 결정론적 PRNG 사용의 잠재적 보안 영향을 충분히 고려하지 않고 보안에 민감한 작업에 모듈 레벨 <code>random</code> API를 사용하는 경우를 다루기 위한 충분한 개선책입니다.</p>
<h3>성능 영향 (Performance impact)</h3>
<p><code>random.Random</code>과 <code>random.SystemRandom</code> 사이의 큰 성능 차이 때문에, Python 3.6으로 포팅된 애플리케이션은 다음과 같은 경우에 상당한 성능 저하를 겪을 수 있습니다.</p>
<ul>
<li>애플리케이션이 모듈 레벨 <code>random</code> API를 사용하는 경우</li>
<li>암호학적 품질의 무작위성(randomness)이 필요하지 않은 경우</li>
<li>애플리케이션이 <code>random.seed</code>, <code>random.getstate</code> 또는 <code>random.setstate</code>를 호출하여 이미 암시적으로 결정론적 PRNG로 다시 옵트인(opt-in)하지 않는 경우</li>
<li>애플리케이션이 <code>random.ensure_repeatable</code>을 명시적으로 호출하도록 업데이트되지 않은 경우</li>
</ul>
<p>이는 Python 3.6 What's New 가이드의 Porting 섹션에 언급될 것이며, 영향을 받는 애플리케이션의 <code>__main__</code> 모듈에 다음 코드를 포함하도록 권장됩니다.</p>
<pre><code class="language-python">if hasattr(random, "ensure_repeatable"):
    random.ensure_repeatable()
</code></pre>
<p>암호학적 품질의 무작위성이 필요한 애플리케이션은 속도 고려 사항과 관계없이 시스템 난수 생성기를 사용해야 하므로, 그러한 경우에는 이 PEP에서 제안된 변경 사항이 이전에 잠재되어 있던 보안 결함을 수정할 것입니다.</p>
<h3>문서 변경 사항 (Documentation changes)</h3>
<p><code>random</code> 모듈 문서는 <code>seed</code>, <code>getstate</code>, <code>setstate</code> 인터페이스의 문서가 모듈의 뒷부분으로 이동하도록 업데이트될 것이며, 새로운 <code>ensure_repeatable</code> 함수와 관련 보안 경고에 대한 문서도 포함될 것입니다.</p>
<p>모듈 문서의 해당 섹션에는 <code>ensure_repeatable</code>에 의해 활성화되는 결정론적 PRNG(게임, 모델링 및 시뮬레이션, 소프트웨어 테스트)와 기본적으로 사용되는 시스템 RNG(암호학, 보안 토큰 생성)의 각각의 사용 사례에 대한 논의도 추가될 것입니다. 이 논의는 후자의 작업을 위해 서드파티 보안 라이브러리를 사용할 것을 권장할 것입니다.</p>
<h3>이론적 근거 (Rationale)</h3>
<p>마감 및 예산 압박 속에서 보안 소프트웨어를 작성하는 것은 어려운 문제입니다. 이는 개인 식별 정보(personally identifiable information)와 관련된 데이터 유출에 대한 정기적인 알림, 그리고 자동차와 같은 새로운 시스템이 인터넷에 연결될 때 보안 고려 사항을 충분히 반영하지 못하는 사례에서도 드러납니다. 또한, 인터넷에서 쉽게 찾을 수 있는 많은 프로그래밍 조언은 컴퓨터 보안의 수학적 난해함을 고려하지 않습니다. 이러한 문제들을 더욱 복잡하게 만드는 것은 방어자들이 모든 잠재적 취약점을 커버해야 한다는 사실입니다. 단 한 번의 실수로 다른 방어 체계가 전복될 수 있기 때문입니다.</p>
<p>이러한 마지막 측면을 특히 어렵게 만드는 요인 중 하나는 부적절하게 사용될 경우 소리 없는 보안 실패(silent security failure)를 초래하는 API입니다. 즉, 자신이 하고 있는 일이 잘못되었음을 알아낼 수 있는 유일한 방법은 코드를 검토하는 사람이 "이것은 잠재적인 보안 문제이다"라고 말하거나, 자신이 책임지는 시스템이 그러한 실수로 인해 침해되는 경우입니다 (그리고 시스템이 침해되었을 때 여전히 책임이 있을 뿐만 아니라, 침입 탐지 및 감사 메커니즘이 침해 후 어떻게 침해가 발생했는지 파악할 수 있을 만큼 충분히 양호해야 합니다).</p>
<p>이러한 상황은 "보안 피로(security fatigue)"의 중요한 원인입니다. 개발자들(종종 정당하게)은 보안 엔지니어들이 "쉬운 방법으로 하지 마세요, 보안 취약점을 만듭니다"라고 말하는 데 모든 시간을 보낸다고 느낍니다.</p>
<p>세계에서 가장 인기 있는 언어 중 하나의 설계자로서, 우리는 더 많은 상황에서 쉬운 방법을 올바른 방법(또는 적어도 "틀리지 않은" 방법)으로 만듦으로써 이 문제를 줄이는 데 도움을 줄 수 있습니다. 그렇게 함으로써 개발자와 보안 엔지니어는 실제로 흥미로운 위협을 완화하는 데 더 많은 시간을 할애하고, 기본 언어 동작과 씨름하는 시간을 줄일 수 있습니다.</p>
<h3>논의 (Discussion)</h3>
<h4>"ensure_deterministic" 대신 "ensure_repeatable"을 사용하는 이유</h4>
<p>이것은 전문 용어로서 단어의 의미가 일반적인 단어의 의미와 충돌하는 경우이지만, 기술적으로는 동일합니다.</p>
<p>기술적인 관점에서 "결정론적 RNG(deterministic RNG)"는 알고리즘과 현재 상태를 알면 임의의 미래 상태를 안정적으로 계산할 수 있다는 것을 의미합니다.</p>
<p>문제는 "결정론적"이라는 단어 자체는 이러한 수식어를 전달하지 않으므로, 일반적인 의미에 익숙하지만 기술적인 의미에 추가된 수식어에는 익숙하지 않은 사람들에게는 "예측 가능한(predictable)" 또는 "무작위적이지 않은(not random)" 것으로 해석될 가능성이 높다는 것입니다.</p>
<p>전통적인 RNG에 대한 설명으로 "결정론적"이라는 단어의 두 번째 문제는, 그것이 시스템 RNG로는 할 수 없는 전통적인 RNG로 무엇을 할 수 있는지 제대로 알려주지 않는다는 것입니다.</p>
<p>"ensure_repeatable"은 이 두 가지 문제를 모두 해결하는 것을 목표로 합니다. 그 일반적인 의미가 결정론적 PRNG를 시스템 RNG보다 선호하는 주요 이유를 정확하게 설명하기 때문입니다. 즉, 동일한 시드 값을 제공하거나 이전에 저장된 PRNG 상태를 복원함으로써 동일한 일련의 출력을 반복할 수 있도록 보장하는 것입니다.</p>
<h4>Python 3.6+에 대해서만 기본값 변경 (Only changing the default for Python 3.6+)</h4>
<p><code>ssl</code> 모듈의 기능을 업그레이드하고 기본적으로 HTTPS 인증서를 올바르게 확인하도록 전환하는 것과 같은 다른 최근 보안 변경 사항은 Python의 모든 현재 지원 버전으로 변경 사항을 백포팅(backporting)할 만큼 충분히 중요하게 간주되었습니다.</p>
<p>이 경우의 차이점은 정도의 문제입니다. 이 특정 변경 사항을 다른 경우보다 몇 년 일찍 출시함으로써 얻는 추가적인 이점은 유지 보수 릴리스에서 이러한 침습적인 변경을 수행하는 데 드는 추가 노력이나 안정성 위험을 정당화하기에 충분하지 않습니다.</p>
<h4>모듈 레벨 함수 유지 (Keeping the module level functions)</h4>
<p>일반적인 하위 호환성 고려 사항 외에도 Python은 교육 목적으로 널리 사용되며, 우리는 현재 <code>random</code> 모듈 API의 가용성을 전제로 하는 광범위한 교육 자료를 무효화하는 것을 특히 원하지 않습니다. 따라서 이 제안은 대부분의 공개 API가 수정 없이 계속 사용될 수 있을 뿐만 아니라 새로운 경고를 생성하지 않고도 사용될 수 있도록 보장합니다.</p>
<h4>결정론적 RNG로 암시적 옵트인 시 경고 (Warning when implicitly opting in to the deterministic RNG)</h4>
<p>Python은 결정론적 PRNG가 올바른 방법인 모델링 및 시뮬레이션 목적으로 널리 사용되며, 많은 경우 이러한 소프트웨어 모델에는 최신 버전의 Python에서 계속 작동하도록 보장하는 전담 유지 보수 팀이 없을 것입니다. 따라서 결정론적 PRNG로 암시적으로 옵트인하는 것이 필요합니다.</p>
<p>안타깝게도 <code>os.urandom</code>에서 가져온 데이터로 <code>random.seed</code>를 명시적으로 호출하는 것도 온라인에서 쉽게 찾을 수 있는 많은 결함 있는 "Python에서 보안 토큰을 생성하는 방법" 가이드에 나타나는 실수입니다.</p>
<p><code>DeprecationWarning</code>을 사용한 다음 궁극적으로 <code>RuntimeWarning</code>을 사용하여 결정론적 PRNG로의 암시적 전환에 대해 경고하는 것은 암호학적으로 안전한 RNG가 필요한 미래 사용자들이 <code>random.seed()</code> 호출을 피하고, 진정으로 결정론적 생성기가 필요한 사람들은 <code>random.ensure_repeatable()</code>을 명시적으로 호출하도록 유도하는 것을 목표로 합니다.</p>
<h4>사용자 공간 CSPRNG 도입 회피 (Avoiding the introduction of a userspace CSPRNG)</h4>
<p><code>python-ideas</code>에 대한 이 제안의 원래 논의에서는 상대적으로 느린 시스템 난수 생성기 대신 암호학적으로 안전한 의사 난수 생성기(CSPRNG)를 도입하고 이를 기본적으로 사용하도록 제안했습니다.</p>
<p>이 접근 방식의 문제는 난수 생성이 중요한 성능 경로에 있지 않을 수도 있는 애플리케이션을 위해 보안에 민감한 상황에서 추가적인 실패 지점을 도입한다는 것입니다.</p>
<p>암호학적 품질의 무작위성이 필요한 애플리케이션은 속도 고려 사항과 관계없이 시스템 난수 생성기를 사용해야 합니다.</p>
<h4>결정론적 PRNG는 "충분히 안전하지 않은가"? (Isn't the deterministic PRNG “secure enough”?)</h4>
<p>한마디로 "아니오(No)"입니다. 이것이 모듈 문서에 보안에 민감한 목적으로 사용하지 말라는 경고가 있는 이유입니다. 현재 Python의 난수 생성기에 대한 특정 연구는 알려진 바 없지만, PHP의 난수 생성기에 대한 연구는 해당 서브시스템의 약점을 사용하여 인기 있는 PHP 웹 애플리케이션의 비밀번호 복구 토큰에 대한 실제 공격을 용이하게 할 수 있음을 입증했습니다.</p>
<p>그러나 보안 소프트웨어 개발 규칙 중 하나는 "공격은 더 나아질 뿐, 결코 나빠지지 않는다"는 것입니다. 따라서 Python 3.6이 출시될 때쯤에는 Python의 결정론적 PRNG에 대한 실제 공격이 공개적으로 문서화될 수도 있습니다.</p>
<h4>Python 생태계의 보안 피로 (Security fatigue in the Python ecosystem)</h4>
<p>지난 몇 년 동안 컴퓨팅 산업 전반은 우리가 모두 의존하는 공유 네트워크 인프라를 "기본적으로 보안(secure by default)" 상태로 업그레이드하기 위해 concerted 노력을 기울여 왔습니다. 네트워크 서비스 개발(OpenStack Infrastructure-as-a-Service 플랫폼 포함) 및 일반적인 Linux 시스템 관리 분야에서 가장 널리 사용되는 프로그래밍 언어 중 하나로서, 그 부담의 상당 부분이 Python 생태계에 떨어졌습니다. 이는 이러한 문제가 큰 관심사가 아닌 다른 맥락에서 Python을 사용하는 Python 개발자들에게는 당연히 불만스러운 일입니다.</p>
<p>이러한 고려 사항은 <code>python-ideas</code>에 게시된 초기 초안 개념에 비해 이 제안의 상당한 하위 호환성 개선을 이끄는 주요 요인 중 하나입니다.</p>
<h3>감사 (Acknowledgements)</h3>
<ul>
<li><strong>Theo de Raadt</strong>: 암호학적으로 안전한 난수 생성기를 기본으로 사용하는 것을 진지하게 고려하라는 제안을 Guido van Rossum에게 해준 것에 대해.</li>
<li><strong>Serhiy Storchaka, Terry Reedy, Petr Viktorin</strong>: 결정론적 RNG에만 의미 있는 함수가 호출될 때 <code>random.Random</code> 구현으로 투명하게 전환하는 접근 방식을 제안한 <code>python-ideas</code> 스레드의 모든 사람.</li>
<li><strong>Nathaniel Smith</strong>: 비밀번호 재설정 토큰을 생성하는 데 사용될 때 PHP의 난수 생성기에 대한 실제 공격에 대한 참조를 제공해준 것에 대해.</li>
<li><strong>Donald Stufft</strong>: 사용자 공간 CSPRNG 도입이 시스템 RNG를 직접 사용하는 것에 비해 불충분한 이득을 위해 추가적인 복잡성을 의미할 것이라고 제안한 네트워크 보안 전문가들과의 추가 논의를 추진해준 것에 대해.</li>
<li><strong>Paul Moore</strong>: Python 생태계의 현재 보안 피로 수준에 대해 설득력 있게 설명해준 것에 대해.</li>
</ul>
<h3>참고 문헌 (References)</h3>
<p>3만 개 이상의 기록(각각)을 포함하는 데이터 유출 시각화 (http://www.informationisbeautiful.net/visualizations/worlds-biggest-data-breaches-hacks/)
Jeep Cherokee에 대한 원격 UConnect 해킹 (http://www.wired.com/2015/07/hackers-remotely-kill-jeep-highway/)
PHP 애플리케이션의 비밀번호 재설정 토큰에 대한 PRNG 기반 공격 (https://media.blackhat.com/bh-us-12/Briefings/Argyros/BH_US_12_Argyros_PRNG_WP.pdf)
"python password generator" 검색 링크 (https://www.google.com.au/search?q=python+password+generator)
사용자 공간 CSPRNG 사용에 대한 <code>python-ideas</code> 스레드 논의 (https://mail.python.org/pipermail/python-ideas/2015-September/035886.html)
이 PEP가 된 초기 초안 개념 (https://mail.python.org/pipermail/python-ideas/2015-September/036095.html)
안전하게 난수 생성하기 (http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/)
IEEE Spectrum 2015년 상위 10개 프로그래밍 언어 (http://spectrum.ieee.org/computing/software/the-2015-top-ten-programming-languages)
2013년 OWASP 웹 보안 10대 문제 (https://www.owasp.org/index.php/OWASP_Top_Ten_Project#tab=OWASP_Top_10_for_2013)
<code>print</code> 호출에서 괄호 누락에 대한 Stack Overflow 답변 (http://stackoverflow.com/questions/25445439/what-does-syntaxerror-missing-parentheses-in-call-to-print-mean-in-python/25445440#25445440)
안전하지 않은 데이터 캐시를 통한 bcrypt 우회 (http://arstechnica.com/security/2015/09/once-seen-as-bulletproof-11-million-ashley-madison-passwords-already-cracked/)</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 공개 도메인(public domain)에 있습니다.</p>
<hr>
<p><strong>역자 요약 및 해설:</strong></p>
<p>PEP 504는 Python 3.6부터 <code>random</code> 모듈의 기본 난수 생성기를 암호학적으로 안전한 시스템 난수 생성기(SystemRandom)로 변경하자는 제안이었습니다. 기존에는 결정론적(deterministic)인 Mersenne Twister가 기본으로 사용되었는데, 이는 보안에 민감한 애플리케이션에서 사용될 경우 예측 가능한 난수를 생성하여 보안 취약점으로 이어질 수 있었습니다.</p>
<p><strong>주요 제안 내용:</strong></p>
<ul>
<li><strong>기본 RNG 변경:</strong> <code>random</code> 모듈의 모듈 레벨 API가 기본적으로 <code>random.SystemRandom</code> 인스턴스를 사용하도록 합니다.</li>
<li><strong>결정론적 RNG 사용을 위한 옵트인:</strong> 결정론적 PRNG가 필요한 경우, 새로운 <code>random.ensure_repeatable()</code> API를 명시적으로 호출하거나 <code>random.Random()</code> 인스턴스를 직접 생성해야 합니다.</li>
<li><strong>암시적 옵트인:</strong> <code>random.seed()</code>, <code>random.getstate()</code>, <code>random.setstate()</code>와 같은 결정성을 요구하는 함수를 호출하면 암시적으로 <code>random.ensure_repeatable()</code>이 호출됩니다.</li>
<li><strong>경고:</strong> 암시적으로 결정론적 PRNG로 전환될 경우 <code>DeprecationWarning</code> (이후 <code>RuntimeWarning</code>)을 발생시켜 개발자에게 명시적 옵트인을 권장합니다.</li>
<li><strong>성능 고려 사항:</strong> <code>SystemRandom</code>은 <code>Random</code>보다 느릴 수 있으므로, 암호학적 품질의 난수가 필요 없는 기존 애플리케이션은 성능 저하를 겪을 수 있으며, 이를 피하려면 <code>ensure_repeatable()</code>을 명시적으로 호출해야 합니다.</li>
</ul>
<p><strong>도입 배경:</strong></p>
<p>개발자들이 보안에 대한 충분한 인지 없이 <code>random</code> 모듈의 기본 API를 사용하여 잠재적인 보안 위험에 노출되는 경우가 많았습니다. 이는 "보안 피로"로 이어지며, 언어 설계 차원에서 "쉬운 방법이 올바른 방법(the easy way the right way)"이 되도록 돕기 위한 노력의 일환으로 제안되었습니다.</p>
<p><strong>철회 이유 및 실제 영향:</strong></p>
<p>PEP 504는 결국 <strong>철회되었습니다.</strong> 논의 과정에서 Steven D'Aprano가 "보안에 민감한 작업"을 처리하기 위한 "한 가지 명확한 방법"을 제공하는 <strong><code>secrets</code> 모듈</strong>을 제안했고, 이 제안이 기존 <code>random</code> 모듈 API의 호환성 위험 없이 더 나은 해결책으로 인정받았기 때문입니다. <code>secrets</code> 모듈은 Python 3.6에 PEP 506으로 채택되어 도입되었으며, 비밀번호, 보안 토큰 등 암호학적으로 강력한 난수가 필요한 경우 <code>secrets</code> 모듈을 사용하는 것이 권장됩니다.</p>
<p>따라서 PEP 504의 제안 내용은 직접적으로 Python에 반영되지는 않았지만, 그 논의를 통해 더 안전하고 명확한 API인 <code>secrets</code> 모듈이 탄생하는 계기가 되었습니다. <code>random</code> 모듈은 여전히 시뮬레이션, 게임 등 결정론적이고 반복 가능한 난수가 필요한 비보안 용도로 사용되며, 보안 관련 난수 생성은 <code>secrets</code> 모듈을 통해 이루어집니다.## PEP 504 – 기본적으로 시스템 RNG 사용 (Using the System RNG by default)</p>
<p><strong>저자:</strong> Alyssa Coghlan 
<strong>상태:</strong> 철회됨 (Withdrawn)
<strong>유형:</strong> Standards Track
<strong>생성일:</strong> 2015년 9월 15일
<strong>Python 버전:</strong> 3.6
<strong>이력:</strong> 2015년 9월 15일</p>
<hr>
<h3>초록 (Abstract)</h3>
<p>현재 Python의 <code>random</code> 모듈에 있는 모듈 레벨 API는 기본적으로 결정론적(deterministic)인 Mersenne Twister 의사 난수 생성기(PRNG)를 사용합니다. 이로 인해 사용자가 "보안에 민감한(security sensitive)" 작업을 수행할 때는 <code>os.urandom</code> 또는 <code>random.SystemRandom</code> 인터페이스와 같은 암호학적으로 안전한 난수 생성기(CSPRNG)를 사용하거나 <code>cryptography</code>와 같은 서드파티 라이브러리를 사용해야 한다는 것을 인지하고 있어야 합니다.</p>
<p>안타깝게도 이러한 접근 방식은 자신이 보안에 민감한 작업을 하고 있다는 것을 인지하지 못하는 개발자들이 기본 모듈 레벨 API를 사용하게 되어, 사용자들을 불필요한 위험에 노출시키는 결과를 초래했습니다.</p>
<p>이 문제는 당장 심각한(acute) 문제는 아니지만 만성적인(chronic) 문제입니다. 보안 취약점이 도입된 시점과 실제 악용되는 시점 사이에 긴 지연이 발생하는 경우가 많아, 개발자들이 경험을 통해 자연스럽게 학습하기 어렵게 만듭니다.</p>
<p>이 문제에 대한 궁극적이고 보편적인 해결책을 제공하기 위해, 이 PEP는 Python 3.6부터 Python이 기본적으로 시스템 난수 생성기(System Random Number Generator, RNG)를 사용하도록 전환하고, 개발자들이 <code>random.ensure_repeatable()</code>이라는 새로운 API를 사용하거나 자신만의 <code>random.Random()</code> 인스턴스를 명시적으로 생성하여 프로세스 전반에 걸쳐 결정론적 난수 생성기를 사용하도록 옵트인(opt-in)해야 한다고 제안했습니다.</p>
<p>기존 코드에 미치는 영향을 최소화하기 위해 결정성을 요구하는 모듈 레벨 API는 암시적으로 결정론적 PRNG로 전환될 것이었습니다.</p>
<h3>PEP 철회 (PEP Withdrawal)</h3>
<p>이 PEP에 대한 논의 과정에서 Steven D'Aprano는 기본 비밀번호 및 기타 토큰 생성과 같은 보안에 민감한 작업을 처리하기 위한 "한 가지 명확한 방법(one obvious way)"을 제공하는 표준화된 <code>secrets</code> 모듈을 제안했습니다.</p>
<p>Steven의 제안은 기존 <code>random</code> 모듈 API에 대한 호환성 위험을 도입하지 않으면서, 이러한 토큰을 쉽게 생성하는 방법과 올바르게 생성하는 방법을 일치시키는 원하는 효과를 가져왔습니다. 따라서 이 PEP는 Steven의 제안을 PEP 506으로 발전시키는 추가 작업을 위해 철회되었습니다.</p>
<h3>제안 (Proposal)</h3>
<p><em>이 섹션은 PEP가 철회되기 전의 제안 내용을 설명합니다.</em></p>
<p>현재 <code>random</code> 모듈의 모듈 레벨 함수를 보안에 민감한 애플리케이션에 사용하는 것은 결코 올바르지 않습니다. 이 PEP는 Python 3.6+에서 이 경고를 "해당 프로세스에서 <code>random.ensure_repeatable()</code>이 (직접적으로든 간접적으로든) 호출되는 경우 <code>random</code> 모듈의 모듈 레벨 함수를 보안에 민감한 애플리케이션에 사용하는 것은 올바르지 않다"는 식으로 변경할 것을 제안했습니다.</p>
<p>이를 달성하기 위해, 현재 <code>random.Random</code> 인스턴스의 바운드 메서드인 것과는 달리, <code>random</code>의 모듈 레벨 호출 가능(callable) 항목들은 기존 <code>random._inst</code> 모듈 속성의 해당 메서드에 위임하는 함수로 변경될 것이었습니다.</p>
<p>기본적으로 이 속성은 <code>random.SystemRandom</code> 인스턴스에 바인딩됩니다.</p>
<p>새로운 <code>random.ensure_repeatable()</code> API는 <code>random._inst</code> 속성을 <code>system.Random</code> 인스턴스에 다시 바인딩하여, 이전 Python 버전과 동일한 모듈 레벨 API 동작을 복원합니다 (추가적인 간접 참조(indirection) 수준을 제외하고).</p>
<pre><code class="language-python">def ensure_repeatable():
    """Switch to using random.Random() for the module level APIs
    This switches the default RNG instance from the cryptographically secure
    random.SystemRandom() to the deterministic random.Random(), enabling the
    seed(), getstate() and setstate() operations. This means a particular
    random scenario can be replayed later by providing the same seed value
    or restoring a previously saved state.
    NOTE: Libraries implementing security sensitive operations should always
    explicitly use random.SystemRandom() or os.urandom in order to correctly
    handle applications that call this function.
    """
    if not isinstance(_inst, Random):
        _inst = random.Random()
</code></pre>
<p>기존 코드에 미치는 영향을 최소화하기 위해 다음 모듈 레벨 함수 중 하나를 호출하면 암시적으로 <code>random.ensure_repeatable()</code>이 호출될 것이었습니다.</p>
<ul>
<li><code>random.seed</code></li>
<li><code>random.getstate</code></li>
<li><code>random.setstate</code></li>
</ul>
<p><code>random.Random</code> 또는 <code>random.SystemRandom</code> 클래스 API에는 변경 사항이 제안되지 않았습니다. 명시적으로 자신만의 난수 생성기를 인스턴스화하는 애플리케이션은 이 제안의 영향을 전혀 받지 않을 것이었습니다.</p>
<h3>암시적 옵트인에 대한 경고 (Warning on implicit opt-in)</h3>
<p>Python 3.6에서는 결정론적 PRNG 사용에 대한 암시적 옵트인은 <code>DeprecationWarning</code>을 발생시킬 것이었습니다.</p>
<pre><code class="language-python">if not isinstance(_inst, Random):
    warnings.warn(DeprecationWarning, "Implicitly ensuring repeatability. "
                                      "See help(random.ensure_repeatable) for details")
    ensure_repeatable()
</code></pre>
<p>경고의 특정 문구는 <code>print</code> 호출에서 괄호 누락에 추가된 사용자 지정 오류 메시지와 같이 Stack Overflow에 적절한 답변이 추가되어야 한다고 제안되었습니다.</p>
<p>Python 2.7이 보안 수정 전용 모드로 전환된 후 첫 번째 Python 3 릴리스에서는 이 <code>DeprecationWarning</code>이 기본적으로 표시되는 <code>RuntimeWarning</code>으로 상향 조정될 것이었습니다.</p>
<p>이 PEP는 특정 시드(seed) 값이 주어졌을 때 동일한 일련의 출력을 생성하는 결정론적 PRNG를 기본 RNG로 사용하도록 보장하는 기능을 제거할 것을 제안하지 않았습니다. 이 기능은 모델링 및 시뮬레이션 시나리오에서 널리 사용되며, <code>ensure_repeatable()</code>이 직접 또는 간접적으로 호출되어야 한다고 요구하는 것은 웹 애플리케이션에서 결정론적 PRNG 사용의 잠재적 보안 영향을 충분히 고려하지 않고 보안에 민감한 작업에 모듈 레벨 <code>random</code> API를 사용하는 경우를 다루기 위한 충분한 개선책이었습니다.</p>
<h3>성능 영향 (Performance impact)</h3>
<p><code>random.Random</code>과 <code>random.SystemRandom</code> 사이의 큰 성능 차이 때문에, Python 3.6으로 포팅된 애플리케이션은 다음과 같은 경우에 상당한 성능 저하를 겪을 수 있을 것이었습니다.</p>
<ul>
<li>애플리케이션이 모듈 레벨 <code>random</code> API를 사용하는 경우</li>
<li>암호학적 품질의 무작위성(randomness)이 필요 없는 경우</li>
<li>애플리케이션이 <code>random.seed</code>, <code>random.getstate</code>, <code>random.setstate</code>를 호출하여 이미 암시적으로 결정론적 PRNG로 다시 옵트인(opt-in)하지 않는 경우</li>
<li>애플리케이션이 <code>random.ensure_repeatable</code>을 명시적으로 호출하도록 업데이트되지 않은 경우</li>
</ul>
<p>이는 Python 3.6 What's New 가이드의 Porting 섹션에 언급될 것이며, 영향을 받는 애플리케이션의 <code>__main__</code> 모듈에 다음 코드를 포함하도록 권장될 것이었습니다.</p>
<pre><code class="language-python">if hasattr(random, "ensure_repeatable"):
    random.ensure_repeatable()
</code></pre>
<p>암호학적 품질의 무작위성이 필요한 애플리케이션은 속도 고려 사항과 관계없이 시스템 난수 생성기를 사용해야 하므로, 그러한 경우에는 이 PEP에서 제안된 변경 사항이 이전에 잠재되어 있던 보안 결함을 수정할 것이었습니다.</p>
<h3>문서 변경 사항 (Documentation changes)</h3>
<p><code>random</code> 모듈 문서는 <code>seed</code>, <code>getstate</code>, <code>setstate</code> 인터페이스의 문서가 모듈의 뒷부분으로 이동하도록 업데이트될 것이며, 새로운 <code>ensure_repeatable</code> 함수와 관련 보안 경고에 대한 문서도 포함될 것이었습니다.</p>
<p>모듈 문서의 해당 섹션에는 <code>ensure_repeatable</code>에 의해 활성화되는 결정론적 PRNG(게임, 모델링 및 시뮬레이션, 소프트웨어 테스트)와 기본적으로 사용되는 시스템 RNG(암호학, 보안 토큰 생성)의 각각의 사용 사례에 대한 논의도 추가될 것이었습니다. 이 논의는 후자의 작업을 위해 서드파티 보안 라이브러리를 사용할 것을 권장할 것이었습니다.</p>
<h3>이론적 근거 (Rationale)</h3>
<p>마감 및 예산 압박 속에서 보안 소프트웨어를 작성하는 것은 어려운 문제입니다. 이는 개인 식별 정보(personally identifiable information)와 관련된 데이터 유출에 대한 정기적인 알림, 그리고 자동차와 같은 새로운 시스템이 인터넷에 연결될 때 보안 고려 사항을 충분히 반영하지 못하는 사례에서도 드러납니다. 또한, 인터넷에서 쉽게 찾을 수 있는 많은 프로그래밍 조언은 컴퓨터 보안의 수학적 난해함을 고려하지 않습니다. 이러한 문제들을 더욱 복잡하게 만드는 것은 방어자들이 모든 잠재적 취약점을 커버해야 한다는 사실입니다. 단 한 번의 실수로 다른 방어 체계가 전복될 수 있기 때문입니다.</p>
<p>이러한 마지막 측면을 특히 어렵게 만드는 요인 중 하나는 부적절하게 사용될 경우 소리 없는 보안 실패(silent security failure)를 초래하는 API입니다. 즉, 자신이 하고 있는 일이 잘못되었음을 알아낼 수 있는 유일한 방법은 코드를 검토하는 사람이 "이것은 잠재적인 보안 문제이다"라고 말하거나, 자신이 책임지는 시스템이 그러한 실수로 인해 침해되는 경우입니다 (그리고 시스템이 침해되었을 때 여전히 책임이 있을 뿐만 아니라, 침입 탐지 및 감사 메커니즘이 침해 후 어떻게 침해가 발생했는지 파악할 수 있을 만큼 충분히 양호해야 합니다).</p>
<p>이러한 상황은 "보안 피로(security fatigue)"의 중요한 원인입니다. 개발자들(종종 정당하게)은 보안 엔지니어들이 "쉬운 방법으로 하지 마세요, 보안 취약점을 만듭니다"라고 말하는 데 모든 시간을 보낸다고 느낍니다.</p>
<p>세계에서 가장 인기 있는 언어 중 하나의 설계자로서, 우리는 더 많은 상황에서 쉬운 방법을 올바른 방법(또는 적어도 "틀리지 않은" 방법)으로 만듦으로써 이 문제를 줄이는 데 도움을 줄 수 있습니다. 그렇게 함으로써 개발자와 보안 엔지니어는 실제로 흥미로운 위협을 완화하는 데 더 많은 시간을 할애하고, 기본 언어 동작과 씨름하는 시간을 줄일 수 있습니다.</p>
<h3>논의 (Discussion)</h3>
<h4>"ensure_deterministic" 대신 "ensure_repeatable"을 사용하는 이유</h4>
<p>"결정론적(deterministic)"이라는 단어는 기술적인 의미와 일반적인 의미 사이의 혼동을 야기할 수 있습니다. 기술적으로는 "알고리즘과 현재 상태를 알면 미래 상태를 계산할 수 있다"는 의미지만, 일반인에게는 "예측 가능한" 또는 "무작위적이지 않은" 것으로 오해될 수 있습니다.</p>
<p>또한 "결정론적"은 시스템 RNG로는 할 수 없는 전통적인 RNG의 주요 장점을 명확히 전달하지 못합니다.</p>
<p>이에 반해 "<code>ensure_repeatable</code>"은 "동일한 시드 값 또는 저장된 PRNG 상태를 통해 동일한 일련의 출력을 반복할 수 있도록 보장한다"는 결정론적 PRNG의 핵심적인 장점을 일반적인 의미로 정확하게 설명하므로, 오해를 줄이고 기능을 명확히 전달하는 데 더 적합합니다.</p>
<h4>Python 3.6+에 대해서만 기본값 변경 (Only changing the default for Python 3.6+)</h4>
<p><code>ssl</code> 모듈 기능 업그레이드나 HTTPS 인증서 기본 확인 전환과 같은 다른 보안 변경 사항은 모든 지원 Python 버전에 백포팅될 만큼 중요하게 간주되었습니다.</p>
<p>하지만 이 PEP의 변경 사항은 그 중요도가 달랐습니다. 몇 년 일찍 변경 사항을 적용함으로써 얻는 추가적인 이점이 유지 보수 릴리스에서 침습적인 변경을 수행하는 데 드는 추가 노력이나 안정성 위험을 정당화하기에 충분하지 않다고 판단되었습니다.</p>
<h4>모듈 레벨 함수 유지 (Keeping the module level functions)</h4>
<p>일반적인 하위 호환성 외에도 Python은 교육 목적으로 널리 사용됩니다. 따라서 현재 <code>random</code> 모듈 API의 가용성을 전제로 하는 광범위한 교육 자료를 무효화하는 것을 피하고자 했습니다. 이에 따라 이 제안은 대부분의 공개 API가 수정 없이 계속 사용될 수 있을 뿐만 아니라 새로운 경고를 생성하지 않고도 사용될 수 있도록 보장했습니다.</p>
<h4>결정론적 RNG로 암시적 옵트인 시 경고 (Warning when implicitly opting in to the deterministic RNG)</h4>
<p>Python은 결정론적 PRNG가 적절한 모델링 및 시뮬레이션 목적으로 널리 사용됩니다. 이러한 소프트웨어 모델 중 상당수는 최신 Python 버전에서 계속 작동하도록 보장하는 전담 유지 보수 팀이 없을 수 있으므로, 결정론적 PRNG로 암시적으로 옵트인하는 것이 필요했습니다.</p>
<p>하지만 <code>os.urandom</code>에서 가져온 데이터로 <code>random.seed</code>를 명시적으로 호출하는 것은 온라인에서 쉽게 찾을 수 있는 많은 결함 있는 "Python에서 보안 토큰을 생성하는 방법" 가이드에 나타나는 실수이기도 합니다.</p>
<p><code>DeprecationWarning</code>을 사용한 다음 궁극적으로 <code>RuntimeWarning</code>을 사용하여 결정론적 PRNG로의 암시적 전환에 대해 경고하는 것은 암호학적으로 안전한 RNG가 필요한 미래 사용자들이 <code>random.seed()</code> 호출을 피하고, 진정으로 결정론적 생성기가 필요한 사람들은 <code>random.ensure_repeatable()</code>을 명시적으로 호출하도록 유도하는 것을 목표로 했습니다.</p>
<h4>사용자 공간 CSPRNG 도입 회피 (Avoiding the introduction of a userspace CSPRNG)</h4>
<p>이 제안의 초기 논의에서는 상대적으로 느린 시스템 난수 생성기 대신 암호학적으로 안전한 의사 난수 생성기(CSPRNG)를 도입하고 이를 기본적으로 사용하도록 제안되었으나, 이 접근 방식의 문제는 난수 생성이 중요한 성능 경로에 있지 않을 수도 있는 애플리케이션을 위해 보안에 민감한 상황에서 추가적인 실패 지점을 도입한다는 것이었습니다.</p>
<p>암호학적 품질의 무작위성이 필요한 애플리케이션은 속도 고려 사항과 관계없이 시스템 난수 생성기를 사용해야 했습니다.</p>
<h4>결정론적 PRNG는 "충분히 안전하지 않은가"? (Isn't the deterministic PRNG “secure enough”?)</h4>
<p>한마디로 "아니오(No)"입니다. 이것이 모듈 문서에 보안에 민감한 목적으로 사용하지 말라는 경고가 있는 이유입니다. 현재 Python의 난수 생성기에 대한 특정 연구는 알려진 바 없지만, PHP의 난수 생성기에 대한 연구는 해당 서브시스템의 약점을 사용하여 인기 있는 PHP 웹 애플리케이션의 비밀번호 복구 토큰에 대한 실제 공격을 용이하게 할 수 있음을 입증했습니다.</p>
<p>보안 소프트웨어 개발 규칙 중 하나는 "공격은 더 나아질 뿐, 결코 나빠지지 않는다"는 것입니다. 따라서 Python 3.6이 출시될 때쯤에는 Python의 결정론적 PRNG에 대한 실제 공격이 공개적으로 문서화될 수도 있을 것이었습니다.</p>
<h4>Python 생태계의 보안 피로 (Security fatigue in the Python ecosystem)</h4>
<p>지난 몇 년 동안 컴퓨팅 산업 전반은 우리가 모두 의존하는 공유 네트워크 인프라를 "기본적으로 보안(secure by default)" 상태로 업그레이드하기 위해 노력해왔습니다. 네트워크 서비스 개발(OpenStack Infrastructure-as-a-Service 플랫폼 포함) 및 일반적인 Linux 시스템 관리 분야에서 가장 널리 사용되는 프로그래밍 언어 중 하나로서, 그 부담의 상당 부분이 Python 생태계에 떨어졌습니다. 이는 이러한 문제가 큰 관심사가 아닌 다른 맥락에서 Python을 사용하는 개발자들에게는 불만스러운 일입니다.</p>
<p>이러한 고려 사항은 <code>python-ideas</code>에 게시된 초기 초안 개념에 비해 이 제안의 상당한 하위 호환성 개선을 이끄는 주요 요인 중 하나였습니다.</p>
<h3>감사 (Acknowledgements)</h3>
<ul>
<li><strong>Theo de Raadt</strong>: 암호학적으로 안전한 난수 생성기를 기본으로 사용하는 것을 진지하게 고려하라는 제안을 Guido van Rossum에게 해준 것에 대해.</li>
<li><strong>Serhiy Storchaka, Terry Reedy, Petr Viktorin</strong>: 결정론적 RNG에만 의미 있는 함수가 호출될 때 <code>random.Random</code> 구현으로 투명하게 전환하는 접근 방식을 제안한 <code>python-ideas</code> 스레드의 모든 사람.</li>
<li><strong>Nathaniel Smith</strong>: 비밀번호 재설정 토큰을 생성하는 데 사용될 때 PHP의 난수 생성기에 대한 실제 공격에 대한 참조를 제공해준 것에 대해.</li>
<li><strong>Donald Stufft</strong>: 사용자 공간 CSPRNG 도입이 시스템 RNG를 직접 사용하는 것에 비해 불충분한 이득을 위해 추가적인 복잡성을 의미할 것이라고 제안한 네트워크 보안 전문가들과의 추가 논의를 추진해준 것에 대해.</li>
<li><strong>Paul Moore</strong>: Python 생태계의 현재 보안 피로 수준에 대해 설득력 있게 설명해준 것에 대해.</li>
</ul>
<h3>참고 문헌 (References)</h3>
<p>3만 개 이상의 기록(각각)을 포함하는 데이터 유출 시각화 (http://www.informationisbeautiful.net/visualizations/worlds-biggest-data-breaches-hacks/)
Jeep Cherokee에 대한 원격 UConnect 해킹 (http://www.wired.com/2015/07/hackers-remotely-kill-jeep-highway/)
PHP 애플리케이션의 비밀번호 재설정 토큰에 대한 PRNG 기반 공격 (https://media.blackhat.com/bh-us-12/Briefings/Argyros/BH_US_12_Argyros_PRNG_WP.pdf)
"python password generator" 검색 링크 (https://www.google.com.au/search?q=python+password+generator)
사용자 공간 CSPRNG 사용에 대한 <code>python-ideas</code> 스레드 논의 (https://mail.python.org/pipermail/python-ideas/2015-September/035886.html)
이 PEP가 된 초기 초안 개념 (https://mail.python.org/pipermail/python-ideas/2015-September/036095.html)
안전하게 난수 생성하기 (http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/)
IEEE Spectrum 2015년 상위 10개 프로그래밍 언어 (http://spectrum.ieee.org/computing/software/the-2015-top-ten-programming-languages)
2013년 OWASP 웹 보안 10대 문제 (https://www.owasp.org/index.php/OWASP_Top_Ten_Project#tab=OWASP_Top_10_for_2013)
<code>print</code> 호출에서 괄호 누락에 대한 Stack Overflow 답변 (http://stackoverflow.com/questions/25445439/what-does-syntaxerror-missing-parentheses-in-call-to-print-mean-in-python/25445440#25445440)
안전하지 않은 데이터 캐시를 통한 bcrypt 우회 (http://arstechnica.com/security/2015/09/once-seen-as-bulletproof-11-million-ashley-madison-passwords-already-cracked/)</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 공개 도메인(public domain)에 있습니다.</p>
<hr>
<h3>역자 요약 및 해설: Python 개발자를 위한 PEP 504 이해</h3>
<p>PEP 504는 Python의 <code>random</code> 모듈이 기본적으로 사용하는 난수 생성기를 암호학적으로 안전한 시스템 난수 생성기(System RNG)로 변경하자는 제안이었습니다. 이는 Python 개발자들이 보안에 민감한 작업에서 의도치 않게 안전하지 않은 난수를 사용하는 문제를 해결하고자 했습니다.</p>
<h4>핵심 제안 내용 (당시의 제안):</h4>
<ol>
<li><strong>기본 난수 생성기(RNG) 변경:</strong> Python 3.6부터 <code>random</code> 모듈의 모듈 레벨 함수들이 기본적으로 <code>random.SystemRandom</code> 인스턴스(시스템 RNG)를 사용하도록 변경합니다.</li>
<li><strong>결정론적 RNG 사용을 위한 옵트인(Opt-in):</strong> 시뮬레이션, 게임 등 반복 가능한(repeatable) 난수가 필요한 경우, 개발자는 새로운 <code>random.ensure_repeatable()</code> API를 명시적으로 호출하거나 직접 <code>random.Random()</code> 인스턴스를 생성하여 결정론적 PRNG를 사용하도록 해야 합니다.</li>
<li><strong>암시적 옵트인:</strong> <code>random.seed()</code>, <code>random.getstate()</code>, <code>random.setstate()</code>와 같이 결정성에 의존하는 기존 함수를 호출하면, 암시적으로 <code>random.ensure_repeatable()</code>이 호출되어 결정론적 PRNG로 전환됩니다.</li>
<li><strong>경고 도입:</strong> 암시적으로 결정론적 PRNG로 전환될 경우 <code>DeprecationWarning</code> (이후 <code>RuntimeWarning</code>으로 격상)이 발생하여, 개발자들이 명시적으로 원하는 RNG를 선택하도록 유도합니다.</li>
<li><strong>성능 영향:</strong> <code>random.SystemRandom</code>은 <code>random.Random</code>보다 일반적으로 느리므로, 암호학적 품질의 난수가 필요 없는 기존 애플리케이션에서는 성능 저하가 발생할 수 있습니다. 이를 피하려면 <code>random.ensure_repeatable()</code>을 명시적으로 호출하도록 코드를 업데이트해야 합니다.</li>
</ol>
<h4>도입 배경 및 문제 의식:</h4>
<ul>
<li><strong>보안 취약점 노출:</strong> 많은 개발자가 <code>random</code> 모듈의 기본 API가 보안에 민감한 용도로 적합하지 않다는 사실을 인지하지 못하고 사용하여, 예측 가능한 난수를 생성함으로써 애플리케이션의 보안을 위협할 수 있었습니다.</li>
<li><strong>"보안 피로(Security Fatigue)":</strong> 개발자들이 보안 엔지니어로부터 "쉬운 방법이 안전하지 않다"는 말을 자주 듣게 되어 보안에 대한 피로감을 느끼는 경향이 있었습니다. PEP 504는 "쉬운 방법이 올바른 방법"이 되도록 언어 차원에서 개선하고자 했습니다.</li>
<li><strong>PHP 사례:</strong> PHP의 난수 생성기 취약점을 이용한 비밀번호 복구 토큰 공격 사례를 통해 결정론적 PRNG의 보안 위험성이 강조되었습니다.</li>
</ul>
<h4>PEP 철회 이유 및 실제 Python에 미친 영향:</h4>
<p>PEP 504는 최종적으로 **철회(Withdrawn)**되었습니다. 그 이유는 이 PEP의 논의 과정에서 Steven D'Aprano가 <strong><code>secrets</code> 모듈</strong>을 제안했기 때문입니다. <code>secrets</code> 모듈은 비밀번호, 보안 토큰, 임시 URL 등 암호학적으로 강력한 난수가 필요한 보안에 민감한 작업을 처리하는 "한 가지 명확한 방법"을 제공하며, 기존 <code>random</code> 모듈 API와의 호환성 문제를 일으키지 않는다는 장점이 있었습니다.</p>
<p>결과적으로 PEP 504의 제안 내용은 Python 3.6에 직접 반영되지 않았습니다. 대신, <strong>PEP 506으로 발전된 <code>secrets</code> 모듈</strong>이 Python 3.6에 도입되어 보안 관련 난수 생성의 표준으로 자리 잡았습니다.</p>
<p><strong>현재 Python 사용에 미치는 영향:</strong></p>
<ul>
<li><strong><code>random</code> 모듈:</strong> <code>random</code> 모듈은 여전히 시뮬레이션, 게임, 통계 분석 등 결정론적이고 재현 가능한(repeatable) 난수가 필요한 <strong>비보안 용도</strong>로 사용됩니다. 기본 동작은 이 PEP의 제안대로 변경되지 않았으며, 여전히 <code>random.Random</code> 인스턴스를 기반으로 합니다.</li>
<li><strong><code>secrets</code> 모듈:</strong> 비밀번호, 토큰 등 <strong>암호학적으로 안전한 난수</strong>가 필요한 모든 보안 관련 작업에는 <code>secrets</code> 모듈을 사용하는 것이 강력히 권장됩니다. 이는 PEP 504의 본래 의도인 "쉬운 방법이 올바른 방법"이 보안 컨텍스트에서 <code>secrets</code> 모듈을 통해 실현된 것으로 볼 수 있습니다. 예를 들어, <code>secrets.token_hex()</code>, <code>secrets.randbelow()</code> 등의 함수를 사용합니다.</li>
<li><strong><code>os.urandom</code>:</strong> 저수준(low-level)에서 직접 시스템 RNG에 접근해야 할 경우 <code>os.urandom</code>을 사용할 수 있습니다. <code>secrets</code> 모듈은 내부적으로 <code>os.urandom</code>을 활용합니다.</li>
</ul>
<p>PEP 504는 비록 철회되었지만, Python 커뮤니티가 보안에 대한 인식을 높이고 더 안전한 기본값을 향해 나아가려는 중요한 논의의 전환점이었으며, 궁극적으로 더 나은 <code>secrets</code> 모듈의 탄생으로 이어졌습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-19cfc001fdac3337.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/504\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"FeyCvJug7In7AgUZlfHUx\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/504/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/504\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"504\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/504\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:Tcc72,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0504/\"\u003ePEP 504 - Using the System RNG by default\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Withdrawn | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 15-Sep-2015\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 504 – 기본적으로 시스템 RNG 사용 (Using the System RNG by default)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e저자:\u003c/strong\u003e Alyssa Coghlan \r\n\u003cstrong\u003e상태:\u003c/strong\u003e 철회됨 (Withdrawn)\r\n\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track\r\n\u003cstrong\u003e생성일:\u003c/strong\u003e 2015년 9월 15일\r\n\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.6\r\n\u003cstrong\u003e이력:\u003c/strong\u003e 2015년 9월 15일\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e현재 Python의 \u003ccode\u003erandom\u003c/code\u003e 모듈에 있는 모듈 레벨 API는 기본적으로 결정론적(deterministic)인 Mersenne Twister 의사 난수 생성기(PRNG)를 사용합니다. 이로 인해 사용자가 \"보안에 민감한(security sensitive)\" 작업을 수행할 때는 \u003ccode\u003eos.urandom\u003c/code\u003e 또는 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e 인터페이스와 같은 암호학적으로 안전한 난수 생성기(CSPRNG)를 사용하거나 \u003ccode\u003ecryptography\u003c/code\u003e와 같은 서드파티 라이브러리를 사용해야 한다는 것을 인지하고 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e하지만 이러한 접근 방식은 자신이 보안에 민감한 작업을 하고 있다는 것을 인지하지 못하는 개발자들이 기본 모듈 레벨 API를 사용하게 되어, 사용자들을 불필요한 위험에 노출시키는 결과를 초래했습니다.\u003c/p\u003e\n\u003cp\u003e이 문제는 당장 심각한(acute) 문제는 아니지만 만성적인(chronic) 문제입니다. 보안 취약점이 도입된 시점과 실제 악용되는 시점 사이에 긴 지연이 발생하는 경우가 많아, 개발자들이 경험을 통해 자연스럽게 학습하기 어렵게 만듭니다.\u003c/p\u003e\n\u003cp\u003e이 문제에 대한 궁극적이고 보편적인 해결책을 제공하기 위해, 이 PEP는 Python 3.6부터 Python이 기본적으로 시스템 난수 생성기(System Random Number Generator, RNG)를 사용하도록 전환하고, 개발자들이 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e이라는 새로운 API를 사용하거나 자신만의 \u003ccode\u003erandom.Random()\u003c/code\u003e 인스턴스를 명시적으로 생성하여 프로세스 전반에 걸쳐 결정론적 난수 생성기를 사용하도록 옵트인(opt-in)해야 한다고 제안합니다.\u003c/p\u003e\n\u003cp\u003e기존 코드에 미치는 영향을 최소화하기 위해 결정성을 요구하는 모듈 레벨 API는 암시적으로 결정론적 PRNG로 전환될 것입니다.\u003c/p\u003e\n\u003ch3\u003ePEP 철회 (PEP Withdrawal)\u003c/h3\u003e\n\u003cp\u003e이 PEP에 대한 논의 과정에서 Steven D'Aprano는 기본 비밀번호 및 기타 토큰 생성과 같은 보안에 민감한 작업을 처리하기 위한 \"한 가지 명확한 방법(one obvious way)\"을 제공하는 표준화된 \u003ccode\u003esecrets\u003c/code\u003e 모듈을 제안했습니다.\u003c/p\u003e\n\u003cp\u003eSteven의 제안은 기존 \u003ccode\u003erandom\u003c/code\u003e 모듈 API에 대한 호환성 위험을 도입하지 않으면서, 이러한 토큰을 쉽게 생성하는 방법과 올바르게 생성하는 방법을 일치시키는 원하는 효과를 가져옵니다. 따라서 이 PEP는 Steven의 제안을 PEP 506으로 발전시키는 추가 작업을 위해 철회되었습니다.\u003c/p\u003e\n\u003ch3\u003e제안 (Proposal)\u003c/h3\u003e\n\u003cp\u003e현재 \u003ccode\u003erandom\u003c/code\u003e 모듈의 모듈 레벨 함수를 보안에 민감한 애플리케이션에 사용하는 것은 결코 올바르지 않습니다. 이 PEP는 Python 3.6+에서 이 경고를 \"해당 프로세스에서 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e이 (직접적으로든 간접적으로든) 호출되는 경우 \u003ccode\u003erandom\u003c/code\u003e 모듈의 모듈 레벨 함수를 보안에 민감한 애플리케이션에 사용하는 것은 올바르지 않다\"는 식으로 변경할 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e이를 달성하기 위해, 현재 \u003ccode\u003erandom.Random\u003c/code\u003e 인스턴스의 바운드 메서드인 것과는 달리, \u003ccode\u003erandom\u003c/code\u003e의 모듈 레벨 호출 가능(callable) 항목들은 기존 \u003ccode\u003erandom._inst\u003c/code\u003e 모듈 속성의 해당 메서드에 위임하는 함수로 변경될 것입니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 이 속성은 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e 인스턴스에 바인딩됩니다.\u003c/p\u003e\n\u003cp\u003e새로운 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e API는 \u003ccode\u003erandom._inst\u003c/code\u003e 속성을 \u003ccode\u003esystem.Random\u003c/code\u003e 인스턴스에 다시 바인딩하여, 이전 Python 버전과 동일한 모듈 레벨 API 동작을 복원합니다 (추가적인 간접 참조(indirection) 수준을 제외하고).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef ensure_repeatable():\r\n    \"\"\"Switch to using random.Random() for the module level APIs\r\n    This switches the default RNG instance from the cryptographically secure\r\n    random.SystemRandom() to the deterministic random.Random(), enabling the\r\n    seed(), getstate() and setstate() operations. This means a particular\r\n    random scenario can be replayed later by providing the same seed value\r\n    or restoring a previously saved state.\r\n    NOTE: Libraries implementing security sensitive operations should always\r\n    explicitly use random.SystemRandom() or os.urandom in order to correctly\r\n    handle applications that call this function.\r\n    \"\"\"\r\n    if not isinstance(_inst, Random):\r\n        _inst = random.Random()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기존 코드에 미치는 영향을 최소화하기 위해 다음 모듈 레벨 함수 중 하나를 호출하면 암시적으로 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e이 호출됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erandom.seed\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erandom.getstate\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erandom.setstate\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003erandom.Random\u003c/code\u003e 또는 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e 클래스 API에는 변경 사항이 제안되지 않았습니다. 명시적으로 자신만의 난수 생성기를 인스턴스화하는 애플리케이션은 이 제안의 영향을 전혀 받지 않습니다.\u003c/p\u003e\n\u003ch3\u003e암시적 옵트인에 대한 경고 (Warning on implicit opt-in)\u003c/h3\u003e\n\u003cp\u003ePython 3.6에서는 결정론적 PRNG 사용에 대한 암시적 옵트인은 다음 확인을 사용하여 DeprecationWarning을 발생시킬 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif not isinstance(_inst, Random):\r\n    warnings.warn(DeprecationWarning, \"Implicitly ensuring repeatability. \"\r\n                                      \"See help(random.ensure_repeatable) for details\")\r\n    ensure_repeatable()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e경고의 특정 문구는 \u003ccode\u003eprint\u003c/code\u003e 호출에서 괄호 누락에 추가된 사용자 지정 오류 메시지와 같이 Stack Overflow에 적절한 답변이 추가되어야 합니다.\u003c/p\u003e\n\u003cp\u003ePython 2.7이 보안 수정 전용 모드로 전환된 후 첫 번째 Python 3 릴리스에서는 이 DeprecationWarning이 기본적으로 표시되는 \u003ccode\u003eRuntimeWarning\u003c/code\u003e으로 상향 조정될 것입니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 특정 시드(seed) 값이 주어졌을 때 동일한 일련의 출력을 생성하는 결정론적 PRNG를 기본 RNG로 사용하도록 보장하는 기능을 제거할 것을 제안하지 않습니다. 이 기능은 모델링 및 시뮬레이션 시나리오에서 널리 사용되며, \u003ccode\u003eensure_repeatable()\u003c/code\u003e이 직접 또는 간접적으로 호출되어야 한다고 요구하는 것은 웹 애플리케이션에서 결정론적 PRNG 사용의 잠재적 보안 영향을 충분히 고려하지 않고 보안에 민감한 작업에 모듈 레벨 \u003ccode\u003erandom\u003c/code\u003e API를 사용하는 경우를 다루기 위한 충분한 개선책입니다.\u003c/p\u003e\n\u003ch3\u003e성능 영향 (Performance impact)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003erandom.Random\u003c/code\u003e과 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e 사이의 큰 성능 차이 때문에, Python 3.6으로 포팅된 애플리케이션은 다음과 같은 경우에 상당한 성능 저하를 겪을 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e애플리케이션이 모듈 레벨 \u003ccode\u003erandom\u003c/code\u003e API를 사용하는 경우\u003c/li\u003e\n\u003cli\u003e암호학적 품질의 무작위성(randomness)이 필요하지 않은 경우\u003c/li\u003e\n\u003cli\u003e애플리케이션이 \u003ccode\u003erandom.seed\u003c/code\u003e, \u003ccode\u003erandom.getstate\u003c/code\u003e 또는 \u003ccode\u003erandom.setstate\u003c/code\u003e를 호출하여 이미 암시적으로 결정론적 PRNG로 다시 옵트인(opt-in)하지 않는 경우\u003c/li\u003e\n\u003cli\u003e애플리케이션이 \u003ccode\u003erandom.ensure_repeatable\u003c/code\u003e을 명시적으로 호출하도록 업데이트되지 않은 경우\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 Python 3.6 What's New 가이드의 Porting 섹션에 언급될 것이며, 영향을 받는 애플리케이션의 \u003ccode\u003e__main__\u003c/code\u003e 모듈에 다음 코드를 포함하도록 권장됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif hasattr(random, \"ensure_repeatable\"):\r\n    random.ensure_repeatable()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e암호학적 품질의 무작위성이 필요한 애플리케이션은 속도 고려 사항과 관계없이 시스템 난수 생성기를 사용해야 하므로, 그러한 경우에는 이 PEP에서 제안된 변경 사항이 이전에 잠재되어 있던 보안 결함을 수정할 것입니다.\u003c/p\u003e\n\u003ch3\u003e문서 변경 사항 (Documentation changes)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003erandom\u003c/code\u003e 모듈 문서는 \u003ccode\u003eseed\u003c/code\u003e, \u003ccode\u003egetstate\u003c/code\u003e, \u003ccode\u003esetstate\u003c/code\u003e 인터페이스의 문서가 모듈의 뒷부분으로 이동하도록 업데이트될 것이며, 새로운 \u003ccode\u003eensure_repeatable\u003c/code\u003e 함수와 관련 보안 경고에 대한 문서도 포함될 것입니다.\u003c/p\u003e\n\u003cp\u003e모듈 문서의 해당 섹션에는 \u003ccode\u003eensure_repeatable\u003c/code\u003e에 의해 활성화되는 결정론적 PRNG(게임, 모델링 및 시뮬레이션, 소프트웨어 테스트)와 기본적으로 사용되는 시스템 RNG(암호학, 보안 토큰 생성)의 각각의 사용 사례에 대한 논의도 추가될 것입니다. 이 논의는 후자의 작업을 위해 서드파티 보안 라이브러리를 사용할 것을 권장할 것입니다.\u003c/p\u003e\n\u003ch3\u003e이론적 근거 (Rationale)\u003c/h3\u003e\n\u003cp\u003e마감 및 예산 압박 속에서 보안 소프트웨어를 작성하는 것은 어려운 문제입니다. 이는 개인 식별 정보(personally identifiable information)와 관련된 데이터 유출에 대한 정기적인 알림, 그리고 자동차와 같은 새로운 시스템이 인터넷에 연결될 때 보안 고려 사항을 충분히 반영하지 못하는 사례에서도 드러납니다. 또한, 인터넷에서 쉽게 찾을 수 있는 많은 프로그래밍 조언은 컴퓨터 보안의 수학적 난해함을 고려하지 않습니다. 이러한 문제들을 더욱 복잡하게 만드는 것은 방어자들이 모든 잠재적 취약점을 커버해야 한다는 사실입니다. 단 한 번의 실수로 다른 방어 체계가 전복될 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이러한 마지막 측면을 특히 어렵게 만드는 요인 중 하나는 부적절하게 사용될 경우 소리 없는 보안 실패(silent security failure)를 초래하는 API입니다. 즉, 자신이 하고 있는 일이 잘못되었음을 알아낼 수 있는 유일한 방법은 코드를 검토하는 사람이 \"이것은 잠재적인 보안 문제이다\"라고 말하거나, 자신이 책임지는 시스템이 그러한 실수로 인해 침해되는 경우입니다 (그리고 시스템이 침해되었을 때 여전히 책임이 있을 뿐만 아니라, 침입 탐지 및 감사 메커니즘이 침해 후 어떻게 침해가 발생했는지 파악할 수 있을 만큼 충분히 양호해야 합니다).\u003c/p\u003e\n\u003cp\u003e이러한 상황은 \"보안 피로(security fatigue)\"의 중요한 원인입니다. 개발자들(종종 정당하게)은 보안 엔지니어들이 \"쉬운 방법으로 하지 마세요, 보안 취약점을 만듭니다\"라고 말하는 데 모든 시간을 보낸다고 느낍니다.\u003c/p\u003e\n\u003cp\u003e세계에서 가장 인기 있는 언어 중 하나의 설계자로서, 우리는 더 많은 상황에서 쉬운 방법을 올바른 방법(또는 적어도 \"틀리지 않은\" 방법)으로 만듦으로써 이 문제를 줄이는 데 도움을 줄 수 있습니다. 그렇게 함으로써 개발자와 보안 엔지니어는 실제로 흥미로운 위협을 완화하는 데 더 많은 시간을 할애하고, 기본 언어 동작과 씨름하는 시간을 줄일 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e논의 (Discussion)\u003c/h3\u003e\n\u003ch4\u003e\"ensure_deterministic\" 대신 \"ensure_repeatable\"을 사용하는 이유\u003c/h4\u003e\n\u003cp\u003e이것은 전문 용어로서 단어의 의미가 일반적인 단어의 의미와 충돌하는 경우이지만, 기술적으로는 동일합니다.\u003c/p\u003e\n\u003cp\u003e기술적인 관점에서 \"결정론적 RNG(deterministic RNG)\"는 알고리즘과 현재 상태를 알면 임의의 미래 상태를 안정적으로 계산할 수 있다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e문제는 \"결정론적\"이라는 단어 자체는 이러한 수식어를 전달하지 않으므로, 일반적인 의미에 익숙하지만 기술적인 의미에 추가된 수식어에는 익숙하지 않은 사람들에게는 \"예측 가능한(predictable)\" 또는 \"무작위적이지 않은(not random)\" 것으로 해석될 가능성이 높다는 것입니다.\u003c/p\u003e\n\u003cp\u003e전통적인 RNG에 대한 설명으로 \"결정론적\"이라는 단어의 두 번째 문제는, 그것이 시스템 RNG로는 할 수 없는 전통적인 RNG로 무엇을 할 수 있는지 제대로 알려주지 않는다는 것입니다.\u003c/p\u003e\n\u003cp\u003e\"ensure_repeatable\"은 이 두 가지 문제를 모두 해결하는 것을 목표로 합니다. 그 일반적인 의미가 결정론적 PRNG를 시스템 RNG보다 선호하는 주요 이유를 정확하게 설명하기 때문입니다. 즉, 동일한 시드 값을 제공하거나 이전에 저장된 PRNG 상태를 복원함으로써 동일한 일련의 출력을 반복할 수 있도록 보장하는 것입니다.\u003c/p\u003e\n\u003ch4\u003ePython 3.6+에 대해서만 기본값 변경 (Only changing the default for Python 3.6+)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003essl\u003c/code\u003e 모듈의 기능을 업그레이드하고 기본적으로 HTTPS 인증서를 올바르게 확인하도록 전환하는 것과 같은 다른 최근 보안 변경 사항은 Python의 모든 현재 지원 버전으로 변경 사항을 백포팅(backporting)할 만큼 충분히 중요하게 간주되었습니다.\u003c/p\u003e\n\u003cp\u003e이 경우의 차이점은 정도의 문제입니다. 이 특정 변경 사항을 다른 경우보다 몇 년 일찍 출시함으로써 얻는 추가적인 이점은 유지 보수 릴리스에서 이러한 침습적인 변경을 수행하는 데 드는 추가 노력이나 안정성 위험을 정당화하기에 충분하지 않습니다.\u003c/p\u003e\n\u003ch4\u003e모듈 레벨 함수 유지 (Keeping the module level functions)\u003c/h4\u003e\n\u003cp\u003e일반적인 하위 호환성 고려 사항 외에도 Python은 교육 목적으로 널리 사용되며, 우리는 현재 \u003ccode\u003erandom\u003c/code\u003e 모듈 API의 가용성을 전제로 하는 광범위한 교육 자료를 무효화하는 것을 특히 원하지 않습니다. 따라서 이 제안은 대부분의 공개 API가 수정 없이 계속 사용될 수 있을 뿐만 아니라 새로운 경고를 생성하지 않고도 사용될 수 있도록 보장합니다.\u003c/p\u003e\n\u003ch4\u003e결정론적 RNG로 암시적 옵트인 시 경고 (Warning when implicitly opting in to the deterministic RNG)\u003c/h4\u003e\n\u003cp\u003ePython은 결정론적 PRNG가 올바른 방법인 모델링 및 시뮬레이션 목적으로 널리 사용되며, 많은 경우 이러한 소프트웨어 모델에는 최신 버전의 Python에서 계속 작동하도록 보장하는 전담 유지 보수 팀이 없을 것입니다. 따라서 결정론적 PRNG로 암시적으로 옵트인하는 것이 필요합니다.\u003c/p\u003e\n\u003cp\u003e안타깝게도 \u003ccode\u003eos.urandom\u003c/code\u003e에서 가져온 데이터로 \u003ccode\u003erandom.seed\u003c/code\u003e를 명시적으로 호출하는 것도 온라인에서 쉽게 찾을 수 있는 많은 결함 있는 \"Python에서 보안 토큰을 생성하는 방법\" 가이드에 나타나는 실수입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eDeprecationWarning\u003c/code\u003e을 사용한 다음 궁극적으로 \u003ccode\u003eRuntimeWarning\u003c/code\u003e을 사용하여 결정론적 PRNG로의 암시적 전환에 대해 경고하는 것은 암호학적으로 안전한 RNG가 필요한 미래 사용자들이 \u003ccode\u003erandom.seed()\u003c/code\u003e 호출을 피하고, 진정으로 결정론적 생성기가 필요한 사람들은 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e을 명시적으로 호출하도록 유도하는 것을 목표로 합니다.\u003c/p\u003e\n\u003ch4\u003e사용자 공간 CSPRNG 도입 회피 (Avoiding the introduction of a userspace CSPRNG)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003epython-ideas\u003c/code\u003e에 대한 이 제안의 원래 논의에서는 상대적으로 느린 시스템 난수 생성기 대신 암호학적으로 안전한 의사 난수 생성기(CSPRNG)를 도입하고 이를 기본적으로 사용하도록 제안했습니다.\u003c/p\u003e\n\u003cp\u003e이 접근 방식의 문제는 난수 생성이 중요한 성능 경로에 있지 않을 수도 있는 애플리케이션을 위해 보안에 민감한 상황에서 추가적인 실패 지점을 도입한다는 것입니다.\u003c/p\u003e\n\u003cp\u003e암호학적 품질의 무작위성이 필요한 애플리케이션은 속도 고려 사항과 관계없이 시스템 난수 생성기를 사용해야 합니다.\u003c/p\u003e\n\u003ch4\u003e결정론적 PRNG는 \"충분히 안전하지 않은가\"? (Isn't the deterministic PRNG “secure enough”?)\u003c/h4\u003e\n\u003cp\u003e한마디로 \"아니오(No)\"입니다. 이것이 모듈 문서에 보안에 민감한 목적으로 사용하지 말라는 경고가 있는 이유입니다. 현재 Python의 난수 생성기에 대한 특정 연구는 알려진 바 없지만, PHP의 난수 생성기에 대한 연구는 해당 서브시스템의 약점을 사용하여 인기 있는 PHP 웹 애플리케이션의 비밀번호 복구 토큰에 대한 실제 공격을 용이하게 할 수 있음을 입증했습니다.\u003c/p\u003e\n\u003cp\u003e그러나 보안 소프트웨어 개발 규칙 중 하나는 \"공격은 더 나아질 뿐, 결코 나빠지지 않는다\"는 것입니다. 따라서 Python 3.6이 출시될 때쯤에는 Python의 결정론적 PRNG에 대한 실제 공격이 공개적으로 문서화될 수도 있습니다.\u003c/p\u003e\n\u003ch4\u003ePython 생태계의 보안 피로 (Security fatigue in the Python ecosystem)\u003c/h4\u003e\n\u003cp\u003e지난 몇 년 동안 컴퓨팅 산업 전반은 우리가 모두 의존하는 공유 네트워크 인프라를 \"기본적으로 보안(secure by default)\" 상태로 업그레이드하기 위해 concerted 노력을 기울여 왔습니다. 네트워크 서비스 개발(OpenStack Infrastructure-as-a-Service 플랫폼 포함) 및 일반적인 Linux 시스템 관리 분야에서 가장 널리 사용되는 프로그래밍 언어 중 하나로서, 그 부담의 상당 부분이 Python 생태계에 떨어졌습니다. 이는 이러한 문제가 큰 관심사가 아닌 다른 맥락에서 Python을 사용하는 Python 개발자들에게는 당연히 불만스러운 일입니다.\u003c/p\u003e\n\u003cp\u003e이러한 고려 사항은 \u003ccode\u003epython-ideas\u003c/code\u003e에 게시된 초기 초안 개념에 비해 이 제안의 상당한 하위 호환성 개선을 이끄는 주요 요인 중 하나입니다.\u003c/p\u003e\n\u003ch3\u003e감사 (Acknowledgements)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTheo de Raadt\u003c/strong\u003e: 암호학적으로 안전한 난수 생성기를 기본으로 사용하는 것을 진지하게 고려하라는 제안을 Guido van Rossum에게 해준 것에 대해.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSerhiy Storchaka, Terry Reedy, Petr Viktorin\u003c/strong\u003e: 결정론적 RNG에만 의미 있는 함수가 호출될 때 \u003ccode\u003erandom.Random\u003c/code\u003e 구현으로 투명하게 전환하는 접근 방식을 제안한 \u003ccode\u003epython-ideas\u003c/code\u003e 스레드의 모든 사람.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNathaniel Smith\u003c/strong\u003e: 비밀번호 재설정 토큰을 생성하는 데 사용될 때 PHP의 난수 생성기에 대한 실제 공격에 대한 참조를 제공해준 것에 대해.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDonald Stufft\u003c/strong\u003e: 사용자 공간 CSPRNG 도입이 시스템 RNG를 직접 사용하는 것에 비해 불충분한 이득을 위해 추가적인 복잡성을 의미할 것이라고 제안한 네트워크 보안 전문가들과의 추가 논의를 추진해준 것에 대해.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePaul Moore\u003c/strong\u003e: Python 생태계의 현재 보안 피로 수준에 대해 설득력 있게 설명해준 것에 대해.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e참고 문헌 (References)\u003c/h3\u003e\n\u003cp\u003e3만 개 이상의 기록(각각)을 포함하는 데이터 유출 시각화 (http://www.informationisbeautiful.net/visualizations/worlds-biggest-data-breaches-hacks/)\r\nJeep Cherokee에 대한 원격 UConnect 해킹 (http://www.wired.com/2015/07/hackers-remotely-kill-jeep-highway/)\r\nPHP 애플리케이션의 비밀번호 재설정 토큰에 대한 PRNG 기반 공격 (https://media.blackhat.com/bh-us-12/Briefings/Argyros/BH_US_12_Argyros_PRNG_WP.pdf)\r\n\"python password generator\" 검색 링크 (https://www.google.com.au/search?q=python+password+generator)\r\n사용자 공간 CSPRNG 사용에 대한 \u003ccode\u003epython-ideas\u003c/code\u003e 스레드 논의 (https://mail.python.org/pipermail/python-ideas/2015-September/035886.html)\r\n이 PEP가 된 초기 초안 개념 (https://mail.python.org/pipermail/python-ideas/2015-September/036095.html)\r\n안전하게 난수 생성하기 (http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/)\r\nIEEE Spectrum 2015년 상위 10개 프로그래밍 언어 (http://spectrum.ieee.org/computing/software/the-2015-top-ten-programming-languages)\r\n2013년 OWASP 웹 보안 10대 문제 (https://www.owasp.org/index.php/OWASP_Top_Ten_Project#tab=OWASP_Top_10_for_2013)\r\n\u003ccode\u003eprint\u003c/code\u003e 호출에서 괄호 누락에 대한 Stack Overflow 답변 (http://stackoverflow.com/questions/25445439/what-does-syntaxerror-missing-parentheses-in-call-to-print-mean-in-python/25445440#25445440)\r\n안전하지 않은 데이터 캐시를 통한 bcrypt 우회 (http://arstechnica.com/security/2015/09/once-seen-as-bulletproof-11-million-ashley-madison-passwords-already-cracked/)\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 공개 도메인(public domain)에 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e역자 요약 및 해설:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ePEP 504는 Python 3.6부터 \u003ccode\u003erandom\u003c/code\u003e 모듈의 기본 난수 생성기를 암호학적으로 안전한 시스템 난수 생성기(SystemRandom)로 변경하자는 제안이었습니다. 기존에는 결정론적(deterministic)인 Mersenne Twister가 기본으로 사용되었는데, 이는 보안에 민감한 애플리케이션에서 사용될 경우 예측 가능한 난수를 생성하여 보안 취약점으로 이어질 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e주요 제안 내용:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e기본 RNG 변경:\u003c/strong\u003e \u003ccode\u003erandom\u003c/code\u003e 모듈의 모듈 레벨 API가 기본적으로 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e 인스턴스를 사용하도록 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e결정론적 RNG 사용을 위한 옵트인:\u003c/strong\u003e 결정론적 PRNG가 필요한 경우, 새로운 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e API를 명시적으로 호출하거나 \u003ccode\u003erandom.Random()\u003c/code\u003e 인스턴스를 직접 생성해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e암시적 옵트인:\u003c/strong\u003e \u003ccode\u003erandom.seed()\u003c/code\u003e, \u003ccode\u003erandom.getstate()\u003c/code\u003e, \u003ccode\u003erandom.setstate()\u003c/code\u003e와 같은 결정성을 요구하는 함수를 호출하면 암시적으로 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e이 호출됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e경고:\u003c/strong\u003e 암시적으로 결정론적 PRNG로 전환될 경우 \u003ccode\u003eDeprecationWarning\u003c/code\u003e (이후 \u003ccode\u003eRuntimeWarning\u003c/code\u003e)을 발생시켜 개발자에게 명시적 옵트인을 권장합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e성능 고려 사항:\u003c/strong\u003e \u003ccode\u003eSystemRandom\u003c/code\u003e은 \u003ccode\u003eRandom\u003c/code\u003e보다 느릴 수 있으므로, 암호학적 품질의 난수가 필요 없는 기존 애플리케이션은 성능 저하를 겪을 수 있으며, 이를 피하려면 \u003ccode\u003eensure_repeatable()\u003c/code\u003e을 명시적으로 호출해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e도입 배경:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e개발자들이 보안에 대한 충분한 인지 없이 \u003ccode\u003erandom\u003c/code\u003e 모듈의 기본 API를 사용하여 잠재적인 보안 위험에 노출되는 경우가 많았습니다. 이는 \"보안 피로\"로 이어지며, 언어 설계 차원에서 \"쉬운 방법이 올바른 방법(the easy way the right way)\"이 되도록 돕기 위한 노력의 일환으로 제안되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e철회 이유 및 실제 영향:\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ePEP 504는 결국 \u003cstrong\u003e철회되었습니다.\u003c/strong\u003e 논의 과정에서 Steven D'Aprano가 \"보안에 민감한 작업\"을 처리하기 위한 \"한 가지 명확한 방법\"을 제공하는 \u003cstrong\u003e\u003ccode\u003esecrets\u003c/code\u003e 모듈\u003c/strong\u003e을 제안했고, 이 제안이 기존 \u003ccode\u003erandom\u003c/code\u003e 모듈 API의 호환성 위험 없이 더 나은 해결책으로 인정받았기 때문입니다. \u003ccode\u003esecrets\u003c/code\u003e 모듈은 Python 3.6에 PEP 506으로 채택되어 도입되었으며, 비밀번호, 보안 토큰 등 암호학적으로 강력한 난수가 필요한 경우 \u003ccode\u003esecrets\u003c/code\u003e 모듈을 사용하는 것이 권장됩니다.\u003c/p\u003e\n\u003cp\u003e따라서 PEP 504의 제안 내용은 직접적으로 Python에 반영되지는 않았지만, 그 논의를 통해 더 안전하고 명확한 API인 \u003ccode\u003esecrets\u003c/code\u003e 모듈이 탄생하는 계기가 되었습니다. \u003ccode\u003erandom\u003c/code\u003e 모듈은 여전히 시뮬레이션, 게임 등 결정론적이고 반복 가능한 난수가 필요한 비보안 용도로 사용되며, 보안 관련 난수 생성은 \u003ccode\u003esecrets\u003c/code\u003e 모듈을 통해 이루어집니다.## PEP 504 – 기본적으로 시스템 RNG 사용 (Using the System RNG by default)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e저자:\u003c/strong\u003e Alyssa Coghlan \r\n\u003cstrong\u003e상태:\u003c/strong\u003e 철회됨 (Withdrawn)\r\n\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track\r\n\u003cstrong\u003e생성일:\u003c/strong\u003e 2015년 9월 15일\r\n\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.6\r\n\u003cstrong\u003e이력:\u003c/strong\u003e 2015년 9월 15일\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e현재 Python의 \u003ccode\u003erandom\u003c/code\u003e 모듈에 있는 모듈 레벨 API는 기본적으로 결정론적(deterministic)인 Mersenne Twister 의사 난수 생성기(PRNG)를 사용합니다. 이로 인해 사용자가 \"보안에 민감한(security sensitive)\" 작업을 수행할 때는 \u003ccode\u003eos.urandom\u003c/code\u003e 또는 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e 인터페이스와 같은 암호학적으로 안전한 난수 생성기(CSPRNG)를 사용하거나 \u003ccode\u003ecryptography\u003c/code\u003e와 같은 서드파티 라이브러리를 사용해야 한다는 것을 인지하고 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e안타깝게도 이러한 접근 방식은 자신이 보안에 민감한 작업을 하고 있다는 것을 인지하지 못하는 개발자들이 기본 모듈 레벨 API를 사용하게 되어, 사용자들을 불필요한 위험에 노출시키는 결과를 초래했습니다.\u003c/p\u003e\n\u003cp\u003e이 문제는 당장 심각한(acute) 문제는 아니지만 만성적인(chronic) 문제입니다. 보안 취약점이 도입된 시점과 실제 악용되는 시점 사이에 긴 지연이 발생하는 경우가 많아, 개발자들이 경험을 통해 자연스럽게 학습하기 어렵게 만듭니다.\u003c/p\u003e\n\u003cp\u003e이 문제에 대한 궁극적이고 보편적인 해결책을 제공하기 위해, 이 PEP는 Python 3.6부터 Python이 기본적으로 시스템 난수 생성기(System Random Number Generator, RNG)를 사용하도록 전환하고, 개발자들이 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e이라는 새로운 API를 사용하거나 자신만의 \u003ccode\u003erandom.Random()\u003c/code\u003e 인스턴스를 명시적으로 생성하여 프로세스 전반에 걸쳐 결정론적 난수 생성기를 사용하도록 옵트인(opt-in)해야 한다고 제안했습니다.\u003c/p\u003e\n\u003cp\u003e기존 코드에 미치는 영향을 최소화하기 위해 결정성을 요구하는 모듈 레벨 API는 암시적으로 결정론적 PRNG로 전환될 것이었습니다.\u003c/p\u003e\n\u003ch3\u003ePEP 철회 (PEP Withdrawal)\u003c/h3\u003e\n\u003cp\u003e이 PEP에 대한 논의 과정에서 Steven D'Aprano는 기본 비밀번호 및 기타 토큰 생성과 같은 보안에 민감한 작업을 처리하기 위한 \"한 가지 명확한 방법(one obvious way)\"을 제공하는 표준화된 \u003ccode\u003esecrets\u003c/code\u003e 모듈을 제안했습니다.\u003c/p\u003e\n\u003cp\u003eSteven의 제안은 기존 \u003ccode\u003erandom\u003c/code\u003e 모듈 API에 대한 호환성 위험을 도입하지 않으면서, 이러한 토큰을 쉽게 생성하는 방법과 올바르게 생성하는 방법을 일치시키는 원하는 효과를 가져왔습니다. 따라서 이 PEP는 Steven의 제안을 PEP 506으로 발전시키는 추가 작업을 위해 철회되었습니다.\u003c/p\u003e\n\u003ch3\u003e제안 (Proposal)\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003e이 섹션은 PEP가 철회되기 전의 제안 내용을 설명합니다.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e현재 \u003ccode\u003erandom\u003c/code\u003e 모듈의 모듈 레벨 함수를 보안에 민감한 애플리케이션에 사용하는 것은 결코 올바르지 않습니다. 이 PEP는 Python 3.6+에서 이 경고를 \"해당 프로세스에서 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e이 (직접적으로든 간접적으로든) 호출되는 경우 \u003ccode\u003erandom\u003c/code\u003e 모듈의 모듈 레벨 함수를 보안에 민감한 애플리케이션에 사용하는 것은 올바르지 않다\"는 식으로 변경할 것을 제안했습니다.\u003c/p\u003e\n\u003cp\u003e이를 달성하기 위해, 현재 \u003ccode\u003erandom.Random\u003c/code\u003e 인스턴스의 바운드 메서드인 것과는 달리, \u003ccode\u003erandom\u003c/code\u003e의 모듈 레벨 호출 가능(callable) 항목들은 기존 \u003ccode\u003erandom._inst\u003c/code\u003e 모듈 속성의 해당 메서드에 위임하는 함수로 변경될 것이었습니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 이 속성은 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e 인스턴스에 바인딩됩니다.\u003c/p\u003e\n\u003cp\u003e새로운 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e API는 \u003ccode\u003erandom._inst\u003c/code\u003e 속성을 \u003ccode\u003esystem.Random\u003c/code\u003e 인스턴스에 다시 바인딩하여, 이전 Python 버전과 동일한 모듈 레벨 API 동작을 복원합니다 (추가적인 간접 참조(indirection) 수준을 제외하고).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef ensure_repeatable():\r\n    \"\"\"Switch to using random.Random() for the module level APIs\r\n    This switches the default RNG instance from the cryptographically secure\r\n    random.SystemRandom() to the deterministic random.Random(), enabling the\r\n    seed(), getstate() and setstate() operations. This means a particular\r\n    random scenario can be replayed later by providing the same seed value\r\n    or restoring a previously saved state.\r\n    NOTE: Libraries implementing security sensitive operations should always\r\n    explicitly use random.SystemRandom() or os.urandom in order to correctly\r\n    handle applications that call this function.\r\n    \"\"\"\r\n    if not isinstance(_inst, Random):\r\n        _inst = random.Random()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기존 코드에 미치는 영향을 최소화하기 위해 다음 모듈 레벨 함수 중 하나를 호출하면 암시적으로 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e이 호출될 것이었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erandom.seed\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erandom.getstate\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erandom.setstate\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003erandom.Random\u003c/code\u003e 또는 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e 클래스 API에는 변경 사항이 제안되지 않았습니다. 명시적으로 자신만의 난수 생성기를 인스턴스화하는 애플리케이션은 이 제안의 영향을 전혀 받지 않을 것이었습니다.\u003c/p\u003e\n\u003ch3\u003e암시적 옵트인에 대한 경고 (Warning on implicit opt-in)\u003c/h3\u003e\n\u003cp\u003ePython 3.6에서는 결정론적 PRNG 사용에 대한 암시적 옵트인은 \u003ccode\u003eDeprecationWarning\u003c/code\u003e을 발생시킬 것이었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif not isinstance(_inst, Random):\r\n    warnings.warn(DeprecationWarning, \"Implicitly ensuring repeatability. \"\r\n                                      \"See help(random.ensure_repeatable) for details\")\r\n    ensure_repeatable()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e경고의 특정 문구는 \u003ccode\u003eprint\u003c/code\u003e 호출에서 괄호 누락에 추가된 사용자 지정 오류 메시지와 같이 Stack Overflow에 적절한 답변이 추가되어야 한다고 제안되었습니다.\u003c/p\u003e\n\u003cp\u003ePython 2.7이 보안 수정 전용 모드로 전환된 후 첫 번째 Python 3 릴리스에서는 이 \u003ccode\u003eDeprecationWarning\u003c/code\u003e이 기본적으로 표시되는 \u003ccode\u003eRuntimeWarning\u003c/code\u003e으로 상향 조정될 것이었습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 특정 시드(seed) 값이 주어졌을 때 동일한 일련의 출력을 생성하는 결정론적 PRNG를 기본 RNG로 사용하도록 보장하는 기능을 제거할 것을 제안하지 않았습니다. 이 기능은 모델링 및 시뮬레이션 시나리오에서 널리 사용되며, \u003ccode\u003eensure_repeatable()\u003c/code\u003e이 직접 또는 간접적으로 호출되어야 한다고 요구하는 것은 웹 애플리케이션에서 결정론적 PRNG 사용의 잠재적 보안 영향을 충분히 고려하지 않고 보안에 민감한 작업에 모듈 레벨 \u003ccode\u003erandom\u003c/code\u003e API를 사용하는 경우를 다루기 위한 충분한 개선책이었습니다.\u003c/p\u003e\n\u003ch3\u003e성능 영향 (Performance impact)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003erandom.Random\u003c/code\u003e과 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e 사이의 큰 성능 차이 때문에, Python 3.6으로 포팅된 애플리케이션은 다음과 같은 경우에 상당한 성능 저하를 겪을 수 있을 것이었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e애플리케이션이 모듈 레벨 \u003ccode\u003erandom\u003c/code\u003e API를 사용하는 경우\u003c/li\u003e\n\u003cli\u003e암호학적 품질의 무작위성(randomness)이 필요 없는 경우\u003c/li\u003e\n\u003cli\u003e애플리케이션이 \u003ccode\u003erandom.seed\u003c/code\u003e, \u003ccode\u003erandom.getstate\u003c/code\u003e, \u003ccode\u003erandom.setstate\u003c/code\u003e를 호출하여 이미 암시적으로 결정론적 PRNG로 다시 옵트인(opt-in)하지 않는 경우\u003c/li\u003e\n\u003cli\u003e애플리케이션이 \u003ccode\u003erandom.ensure_repeatable\u003c/code\u003e을 명시적으로 호출하도록 업데이트되지 않은 경우\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이는 Python 3.6 What's New 가이드의 Porting 섹션에 언급될 것이며, 영향을 받는 애플리케이션의 \u003ccode\u003e__main__\u003c/code\u003e 모듈에 다음 코드를 포함하도록 권장될 것이었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eif hasattr(random, \"ensure_repeatable\"):\r\n    random.ensure_repeatable()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e암호학적 품질의 무작위성이 필요한 애플리케이션은 속도 고려 사항과 관계없이 시스템 난수 생성기를 사용해야 하므로, 그러한 경우에는 이 PEP에서 제안된 변경 사항이 이전에 잠재되어 있던 보안 결함을 수정할 것이었습니다.\u003c/p\u003e\n\u003ch3\u003e문서 변경 사항 (Documentation changes)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003erandom\u003c/code\u003e 모듈 문서는 \u003ccode\u003eseed\u003c/code\u003e, \u003ccode\u003egetstate\u003c/code\u003e, \u003ccode\u003esetstate\u003c/code\u003e 인터페이스의 문서가 모듈의 뒷부분으로 이동하도록 업데이트될 것이며, 새로운 \u003ccode\u003eensure_repeatable\u003c/code\u003e 함수와 관련 보안 경고에 대한 문서도 포함될 것이었습니다.\u003c/p\u003e\n\u003cp\u003e모듈 문서의 해당 섹션에는 \u003ccode\u003eensure_repeatable\u003c/code\u003e에 의해 활성화되는 결정론적 PRNG(게임, 모델링 및 시뮬레이션, 소프트웨어 테스트)와 기본적으로 사용되는 시스템 RNG(암호학, 보안 토큰 생성)의 각각의 사용 사례에 대한 논의도 추가될 것이었습니다. 이 논의는 후자의 작업을 위해 서드파티 보안 라이브러리를 사용할 것을 권장할 것이었습니다.\u003c/p\u003e\n\u003ch3\u003e이론적 근거 (Rationale)\u003c/h3\u003e\n\u003cp\u003e마감 및 예산 압박 속에서 보안 소프트웨어를 작성하는 것은 어려운 문제입니다. 이는 개인 식별 정보(personally identifiable information)와 관련된 데이터 유출에 대한 정기적인 알림, 그리고 자동차와 같은 새로운 시스템이 인터넷에 연결될 때 보안 고려 사항을 충분히 반영하지 못하는 사례에서도 드러납니다. 또한, 인터넷에서 쉽게 찾을 수 있는 많은 프로그래밍 조언은 컴퓨터 보안의 수학적 난해함을 고려하지 않습니다. 이러한 문제들을 더욱 복잡하게 만드는 것은 방어자들이 모든 잠재적 취약점을 커버해야 한다는 사실입니다. 단 한 번의 실수로 다른 방어 체계가 전복될 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이러한 마지막 측면을 특히 어렵게 만드는 요인 중 하나는 부적절하게 사용될 경우 소리 없는 보안 실패(silent security failure)를 초래하는 API입니다. 즉, 자신이 하고 있는 일이 잘못되었음을 알아낼 수 있는 유일한 방법은 코드를 검토하는 사람이 \"이것은 잠재적인 보안 문제이다\"라고 말하거나, 자신이 책임지는 시스템이 그러한 실수로 인해 침해되는 경우입니다 (그리고 시스템이 침해되었을 때 여전히 책임이 있을 뿐만 아니라, 침입 탐지 및 감사 메커니즘이 침해 후 어떻게 침해가 발생했는지 파악할 수 있을 만큼 충분히 양호해야 합니다).\u003c/p\u003e\n\u003cp\u003e이러한 상황은 \"보안 피로(security fatigue)\"의 중요한 원인입니다. 개발자들(종종 정당하게)은 보안 엔지니어들이 \"쉬운 방법으로 하지 마세요, 보안 취약점을 만듭니다\"라고 말하는 데 모든 시간을 보낸다고 느낍니다.\u003c/p\u003e\n\u003cp\u003e세계에서 가장 인기 있는 언어 중 하나의 설계자로서, 우리는 더 많은 상황에서 쉬운 방법을 올바른 방법(또는 적어도 \"틀리지 않은\" 방법)으로 만듦으로써 이 문제를 줄이는 데 도움을 줄 수 있습니다. 그렇게 함으로써 개발자와 보안 엔지니어는 실제로 흥미로운 위협을 완화하는 데 더 많은 시간을 할애하고, 기본 언어 동작과 씨름하는 시간을 줄일 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e논의 (Discussion)\u003c/h3\u003e\n\u003ch4\u003e\"ensure_deterministic\" 대신 \"ensure_repeatable\"을 사용하는 이유\u003c/h4\u003e\n\u003cp\u003e\"결정론적(deterministic)\"이라는 단어는 기술적인 의미와 일반적인 의미 사이의 혼동을 야기할 수 있습니다. 기술적으로는 \"알고리즘과 현재 상태를 알면 미래 상태를 계산할 수 있다\"는 의미지만, 일반인에게는 \"예측 가능한\" 또는 \"무작위적이지 않은\" 것으로 오해될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한 \"결정론적\"은 시스템 RNG로는 할 수 없는 전통적인 RNG의 주요 장점을 명확히 전달하지 못합니다.\u003c/p\u003e\n\u003cp\u003e이에 반해 \"\u003ccode\u003eensure_repeatable\u003c/code\u003e\"은 \"동일한 시드 값 또는 저장된 PRNG 상태를 통해 동일한 일련의 출력을 반복할 수 있도록 보장한다\"는 결정론적 PRNG의 핵심적인 장점을 일반적인 의미로 정확하게 설명하므로, 오해를 줄이고 기능을 명확히 전달하는 데 더 적합합니다.\u003c/p\u003e\n\u003ch4\u003ePython 3.6+에 대해서만 기본값 변경 (Only changing the default for Python 3.6+)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003essl\u003c/code\u003e 모듈 기능 업그레이드나 HTTPS 인증서 기본 확인 전환과 같은 다른 보안 변경 사항은 모든 지원 Python 버전에 백포팅될 만큼 중요하게 간주되었습니다.\u003c/p\u003e\n\u003cp\u003e하지만 이 PEP의 변경 사항은 그 중요도가 달랐습니다. 몇 년 일찍 변경 사항을 적용함으로써 얻는 추가적인 이점이 유지 보수 릴리스에서 침습적인 변경을 수행하는 데 드는 추가 노력이나 안정성 위험을 정당화하기에 충분하지 않다고 판단되었습니다.\u003c/p\u003e\n\u003ch4\u003e모듈 레벨 함수 유지 (Keeping the module level functions)\u003c/h4\u003e\n\u003cp\u003e일반적인 하위 호환성 외에도 Python은 교육 목적으로 널리 사용됩니다. 따라서 현재 \u003ccode\u003erandom\u003c/code\u003e 모듈 API의 가용성을 전제로 하는 광범위한 교육 자료를 무효화하는 것을 피하고자 했습니다. 이에 따라 이 제안은 대부분의 공개 API가 수정 없이 계속 사용될 수 있을 뿐만 아니라 새로운 경고를 생성하지 않고도 사용될 수 있도록 보장했습니다.\u003c/p\u003e\n\u003ch4\u003e결정론적 RNG로 암시적 옵트인 시 경고 (Warning when implicitly opting in to the deterministic RNG)\u003c/h4\u003e\n\u003cp\u003ePython은 결정론적 PRNG가 적절한 모델링 및 시뮬레이션 목적으로 널리 사용됩니다. 이러한 소프트웨어 모델 중 상당수는 최신 Python 버전에서 계속 작동하도록 보장하는 전담 유지 보수 팀이 없을 수 있으므로, 결정론적 PRNG로 암시적으로 옵트인하는 것이 필요했습니다.\u003c/p\u003e\n\u003cp\u003e하지만 \u003ccode\u003eos.urandom\u003c/code\u003e에서 가져온 데이터로 \u003ccode\u003erandom.seed\u003c/code\u003e를 명시적으로 호출하는 것은 온라인에서 쉽게 찾을 수 있는 많은 결함 있는 \"Python에서 보안 토큰을 생성하는 방법\" 가이드에 나타나는 실수이기도 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eDeprecationWarning\u003c/code\u003e을 사용한 다음 궁극적으로 \u003ccode\u003eRuntimeWarning\u003c/code\u003e을 사용하여 결정론적 PRNG로의 암시적 전환에 대해 경고하는 것은 암호학적으로 안전한 RNG가 필요한 미래 사용자들이 \u003ccode\u003erandom.seed()\u003c/code\u003e 호출을 피하고, 진정으로 결정론적 생성기가 필요한 사람들은 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e을 명시적으로 호출하도록 유도하는 것을 목표로 했습니다.\u003c/p\u003e\n\u003ch4\u003e사용자 공간 CSPRNG 도입 회피 (Avoiding the introduction of a userspace CSPRNG)\u003c/h4\u003e\n\u003cp\u003e이 제안의 초기 논의에서는 상대적으로 느린 시스템 난수 생성기 대신 암호학적으로 안전한 의사 난수 생성기(CSPRNG)를 도입하고 이를 기본적으로 사용하도록 제안되었으나, 이 접근 방식의 문제는 난수 생성이 중요한 성능 경로에 있지 않을 수도 있는 애플리케이션을 위해 보안에 민감한 상황에서 추가적인 실패 지점을 도입한다는 것이었습니다.\u003c/p\u003e\n\u003cp\u003e암호학적 품질의 무작위성이 필요한 애플리케이션은 속도 고려 사항과 관계없이 시스템 난수 생성기를 사용해야 했습니다.\u003c/p\u003e\n\u003ch4\u003e결정론적 PRNG는 \"충분히 안전하지 않은가\"? (Isn't the deterministic PRNG “secure enough”?)\u003c/h4\u003e\n\u003cp\u003e한마디로 \"아니오(No)\"입니다. 이것이 모듈 문서에 보안에 민감한 목적으로 사용하지 말라는 경고가 있는 이유입니다. 현재 Python의 난수 생성기에 대한 특정 연구는 알려진 바 없지만, PHP의 난수 생성기에 대한 연구는 해당 서브시스템의 약점을 사용하여 인기 있는 PHP 웹 애플리케이션의 비밀번호 복구 토큰에 대한 실제 공격을 용이하게 할 수 있음을 입증했습니다.\u003c/p\u003e\n\u003cp\u003e보안 소프트웨어 개발 규칙 중 하나는 \"공격은 더 나아질 뿐, 결코 나빠지지 않는다\"는 것입니다. 따라서 Python 3.6이 출시될 때쯤에는 Python의 결정론적 PRNG에 대한 실제 공격이 공개적으로 문서화될 수도 있을 것이었습니다.\u003c/p\u003e\n\u003ch4\u003ePython 생태계의 보안 피로 (Security fatigue in the Python ecosystem)\u003c/h4\u003e\n\u003cp\u003e지난 몇 년 동안 컴퓨팅 산업 전반은 우리가 모두 의존하는 공유 네트워크 인프라를 \"기본적으로 보안(secure by default)\" 상태로 업그레이드하기 위해 노력해왔습니다. 네트워크 서비스 개발(OpenStack Infrastructure-as-a-Service 플랫폼 포함) 및 일반적인 Linux 시스템 관리 분야에서 가장 널리 사용되는 프로그래밍 언어 중 하나로서, 그 부담의 상당 부분이 Python 생태계에 떨어졌습니다. 이는 이러한 문제가 큰 관심사가 아닌 다른 맥락에서 Python을 사용하는 개발자들에게는 불만스러운 일입니다.\u003c/p\u003e\n\u003cp\u003e이러한 고려 사항은 \u003ccode\u003epython-ideas\u003c/code\u003e에 게시된 초기 초안 개념에 비해 이 제안의 상당한 하위 호환성 개선을 이끄는 주요 요인 중 하나였습니다.\u003c/p\u003e\n\u003ch3\u003e감사 (Acknowledgements)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTheo de Raadt\u003c/strong\u003e: 암호학적으로 안전한 난수 생성기를 기본으로 사용하는 것을 진지하게 고려하라는 제안을 Guido van Rossum에게 해준 것에 대해.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSerhiy Storchaka, Terry Reedy, Petr Viktorin\u003c/strong\u003e: 결정론적 RNG에만 의미 있는 함수가 호출될 때 \u003ccode\u003erandom.Random\u003c/code\u003e 구현으로 투명하게 전환하는 접근 방식을 제안한 \u003ccode\u003epython-ideas\u003c/code\u003e 스레드의 모든 사람.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNathaniel Smith\u003c/strong\u003e: 비밀번호 재설정 토큰을 생성하는 데 사용될 때 PHP의 난수 생성기에 대한 실제 공격에 대한 참조를 제공해준 것에 대해.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDonald Stufft\u003c/strong\u003e: 사용자 공간 CSPRNG 도입이 시스템 RNG를 직접 사용하는 것에 비해 불충분한 이득을 위해 추가적인 복잡성을 의미할 것이라고 제안한 네트워크 보안 전문가들과의 추가 논의를 추진해준 것에 대해.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePaul Moore\u003c/strong\u003e: Python 생태계의 현재 보안 피로 수준에 대해 설득력 있게 설명해준 것에 대해.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e참고 문헌 (References)\u003c/h3\u003e\n\u003cp\u003e3만 개 이상의 기록(각각)을 포함하는 데이터 유출 시각화 (http://www.informationisbeautiful.net/visualizations/worlds-biggest-data-breaches-hacks/)\r\nJeep Cherokee에 대한 원격 UConnect 해킹 (http://www.wired.com/2015/07/hackers-remotely-kill-jeep-highway/)\r\nPHP 애플리케이션의 비밀번호 재설정 토큰에 대한 PRNG 기반 공격 (https://media.blackhat.com/bh-us-12/Briefings/Argyros/BH_US_12_Argyros_PRNG_WP.pdf)\r\n\"python password generator\" 검색 링크 (https://www.google.com.au/search?q=python+password+generator)\r\n사용자 공간 CSPRNG 사용에 대한 \u003ccode\u003epython-ideas\u003c/code\u003e 스레드 논의 (https://mail.python.org/pipermail/python-ideas/2015-September/035886.html)\r\n이 PEP가 된 초기 초안 개념 (https://mail.python.org/pipermail/python-ideas/2015-September/036095.html)\r\n안전하게 난수 생성하기 (http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/)\r\nIEEE Spectrum 2015년 상위 10개 프로그래밍 언어 (http://spectrum.ieee.org/computing/software/the-2015-top-ten-programming-languages)\r\n2013년 OWASP 웹 보안 10대 문제 (https://www.owasp.org/index.php/OWASP_Top_Ten_Project#tab=OWASP_Top_10_for_2013)\r\n\u003ccode\u003eprint\u003c/code\u003e 호출에서 괄호 누락에 대한 Stack Overflow 답변 (http://stackoverflow.com/questions/25445439/what-does-syntaxerror-missing-parentheses-in-call-to-print-mean-in-python/25445440#25445440)\r\n안전하지 않은 데이터 캐시를 통한 bcrypt 우회 (http://arstechnica.com/security/2015/09/once-seen-as-bulletproof-11-million-ashley-madison-passwords-already-cracked/)\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 공개 도메인(public domain)에 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e역자 요약 및 해설: Python 개발자를 위한 PEP 504 이해\u003c/h3\u003e\n\u003cp\u003ePEP 504는 Python의 \u003ccode\u003erandom\u003c/code\u003e 모듈이 기본적으로 사용하는 난수 생성기를 암호학적으로 안전한 시스템 난수 생성기(System RNG)로 변경하자는 제안이었습니다. 이는 Python 개발자들이 보안에 민감한 작업에서 의도치 않게 안전하지 않은 난수를 사용하는 문제를 해결하고자 했습니다.\u003c/p\u003e\n\u003ch4\u003e핵심 제안 내용 (당시의 제안):\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e기본 난수 생성기(RNG) 변경:\u003c/strong\u003e Python 3.6부터 \u003ccode\u003erandom\u003c/code\u003e 모듈의 모듈 레벨 함수들이 기본적으로 \u003ccode\u003erandom.SystemRandom\u003c/code\u003e 인스턴스(시스템 RNG)를 사용하도록 변경합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e결정론적 RNG 사용을 위한 옵트인(Opt-in):\u003c/strong\u003e 시뮬레이션, 게임 등 반복 가능한(repeatable) 난수가 필요한 경우, 개발자는 새로운 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e API를 명시적으로 호출하거나 직접 \u003ccode\u003erandom.Random()\u003c/code\u003e 인스턴스를 생성하여 결정론적 PRNG를 사용하도록 해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e암시적 옵트인:\u003c/strong\u003e \u003ccode\u003erandom.seed()\u003c/code\u003e, \u003ccode\u003erandom.getstate()\u003c/code\u003e, \u003ccode\u003erandom.setstate()\u003c/code\u003e와 같이 결정성에 의존하는 기존 함수를 호출하면, 암시적으로 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e이 호출되어 결정론적 PRNG로 전환됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e경고 도입:\u003c/strong\u003e 암시적으로 결정론적 PRNG로 전환될 경우 \u003ccode\u003eDeprecationWarning\u003c/code\u003e (이후 \u003ccode\u003eRuntimeWarning\u003c/code\u003e으로 격상)이 발생하여, 개발자들이 명시적으로 원하는 RNG를 선택하도록 유도합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e성능 영향:\u003c/strong\u003e \u003ccode\u003erandom.SystemRandom\u003c/code\u003e은 \u003ccode\u003erandom.Random\u003c/code\u003e보다 일반적으로 느리므로, 암호학적 품질의 난수가 필요 없는 기존 애플리케이션에서는 성능 저하가 발생할 수 있습니다. 이를 피하려면 \u003ccode\u003erandom.ensure_repeatable()\u003c/code\u003e을 명시적으로 호출하도록 코드를 업데이트해야 합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e도입 배경 및 문제 의식:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e보안 취약점 노출:\u003c/strong\u003e 많은 개발자가 \u003ccode\u003erandom\u003c/code\u003e 모듈의 기본 API가 보안에 민감한 용도로 적합하지 않다는 사실을 인지하지 못하고 사용하여, 예측 가능한 난수를 생성함으로써 애플리케이션의 보안을 위협할 수 있었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\"보안 피로(Security Fatigue)\":\u003c/strong\u003e 개발자들이 보안 엔지니어로부터 \"쉬운 방법이 안전하지 않다\"는 말을 자주 듣게 되어 보안에 대한 피로감을 느끼는 경향이 있었습니다. PEP 504는 \"쉬운 방법이 올바른 방법\"이 되도록 언어 차원에서 개선하고자 했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePHP 사례:\u003c/strong\u003e PHP의 난수 생성기 취약점을 이용한 비밀번호 복구 토큰 공격 사례를 통해 결정론적 PRNG의 보안 위험성이 강조되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003ePEP 철회 이유 및 실제 Python에 미친 영향:\u003c/h4\u003e\n\u003cp\u003ePEP 504는 최종적으로 **철회(Withdrawn)**되었습니다. 그 이유는 이 PEP의 논의 과정에서 Steven D'Aprano가 \u003cstrong\u003e\u003ccode\u003esecrets\u003c/code\u003e 모듈\u003c/strong\u003e을 제안했기 때문입니다. \u003ccode\u003esecrets\u003c/code\u003e 모듈은 비밀번호, 보안 토큰, 임시 URL 등 암호학적으로 강력한 난수가 필요한 보안에 민감한 작업을 처리하는 \"한 가지 명확한 방법\"을 제공하며, 기존 \u003ccode\u003erandom\u003c/code\u003e 모듈 API와의 호환성 문제를 일으키지 않는다는 장점이 있었습니다.\u003c/p\u003e\n\u003cp\u003e결과적으로 PEP 504의 제안 내용은 Python 3.6에 직접 반영되지 않았습니다. 대신, \u003cstrong\u003ePEP 506으로 발전된 \u003ccode\u003esecrets\u003c/code\u003e 모듈\u003c/strong\u003e이 Python 3.6에 도입되어 보안 관련 난수 생성의 표준으로 자리 잡았습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e현재 Python 사용에 미치는 영향:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003erandom\u003c/code\u003e 모듈:\u003c/strong\u003e \u003ccode\u003erandom\u003c/code\u003e 모듈은 여전히 시뮬레이션, 게임, 통계 분석 등 결정론적이고 재현 가능한(repeatable) 난수가 필요한 \u003cstrong\u003e비보안 용도\u003c/strong\u003e로 사용됩니다. 기본 동작은 이 PEP의 제안대로 변경되지 않았으며, 여전히 \u003ccode\u003erandom.Random\u003c/code\u003e 인스턴스를 기반으로 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003esecrets\u003c/code\u003e 모듈:\u003c/strong\u003e 비밀번호, 토큰 등 \u003cstrong\u003e암호학적으로 안전한 난수\u003c/strong\u003e가 필요한 모든 보안 관련 작업에는 \u003ccode\u003esecrets\u003c/code\u003e 모듈을 사용하는 것이 강력히 권장됩니다. 이는 PEP 504의 본래 의도인 \"쉬운 방법이 올바른 방법\"이 보안 컨텍스트에서 \u003ccode\u003esecrets\u003c/code\u003e 모듈을 통해 실현된 것으로 볼 수 있습니다. 예를 들어, \u003ccode\u003esecrets.token_hex()\u003c/code\u003e, \u003ccode\u003esecrets.randbelow()\u003c/code\u003e 등의 함수를 사용합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eos.urandom\u003c/code\u003e:\u003c/strong\u003e 저수준(low-level)에서 직접 시스템 RNG에 접근해야 할 경우 \u003ccode\u003eos.urandom\u003c/code\u003e을 사용할 수 있습니다. \u003ccode\u003esecrets\u003c/code\u003e 모듈은 내부적으로 \u003ccode\u003eos.urandom\u003c/code\u003e을 활용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePEP 504는 비록 철회되었지만, Python 커뮤니티가 보안에 대한 인식을 높이고 더 안전한 기본값을 향해 나아가려는 중요한 논의의 전환점이었으며, 궁극적으로 더 나은 \u003ccode\u003esecrets\u003c/code\u003e 모듈의 탄생으로 이어졌습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1098,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Withdrawn] PEP 504 - Using the System RNG by default\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 22:47:22+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>