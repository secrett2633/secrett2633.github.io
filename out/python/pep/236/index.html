<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-1a135130af3e1cae.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1318<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 236 - Back to the __future__</h1><div class="page__meta"><time dateTime="2025-09-26 17:05:02+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0236/">PEP 236 - Back to the <strong>future</strong></a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 26-Feb-2001</p>
</blockquote>
<h2>동기 (Motivation)</h2>
<p>때때로 Python은 핵심 언어 구문의 공표된 의미(semantics)에 호환되지 않는 변경을 가하거나, 의도치 않은(구현에 의존하는) 동작을 변경합니다. 이러한 변경은 신중하게 이루어지며 장기적으로 언어를 개선하기 위함이지만, 단기적으로는 논란의 여지가 있고 혼란을 야기할 수 있습니다.</p>
<p>PEP 5, "Guidelines for Language Evolution"은 이러한 어려움을 완화하기 위한 방법을 제시하며, 이 PEP는 이를 지원하는 메커니즘을 소개합니다.</p>
<p>PEP 227, "Statically Nested Scopes"가 첫 번째 적용 사례이며, 이 PEP에서 예시로 사용됩니다.</p>
<h2>목표 (Intent)</h2>
<p>핵심 언어 구문이나 의미론에 호환되지 않는 변경이 있을 때 다음 정책이 적용됩니다.</p>
<ul>
<li>변경을 도입하는 릴리스 C에서는 기본적으로 구문이나 의미론이 변경되지 않습니다.</li>
<li>새로운 구문이나 의미론이 강제될 미래 릴리스 R이 지정됩니다.</li>
<li>가능한 경우, 릴리스 R에서 의미가 변경될 수 있는 구문이나 연산에 대해 PEP 230, "Warning Framework"에 설명된 메커니즘을 사용하여 경고가 생성됩니다.</li>
<li>새로운 <code>future_statement</code> (아래 참조)를 모듈 M에 명시적으로 포함하여, 모듈 M의 코드가 현재 릴리스 C에서 새로운 구문이나 의미론을 사용하도록 요청할 수 있습니다.</li>
</ul>
<p>따라서, 오래된 코드는 최소한 한 릴리스 동안은 기본적으로 계속 작동하지만, 새로운 경고 메시지가 발생할 수 있습니다. 새로운 구문이나 의미론으로의 마이그레이션은 이 기간 동안 진행될 수 있으며, <code>future_statement</code>를 사용하여 해당 모듈이 새로운 구문이나 의미론이 이미 강제되고 있는 것처럼 작동하도록 만듭니다.</p>
<p>기존 코드를 손상시킬 수 있는 경우가 아니라면 새로운 기능에 <code>future_statement</code> 메커니즘을 사용할 필요가 없다는 점에 유의해야 합니다. 완전히 하위 호환되는 추가 기능은 해당 <code>future_statement</code> 없이 도입될 수 있으며, 그렇게 해야 합니다.</p>
<h2>구문 (Syntax)</h2>
<p><code>future_statement</code>는 예약된 모듈 이름 <code>__future__</code>를 사용하는 단순한 <code>from/import</code> 문입니다.</p>
<pre><code>future_statement: "from" "__future__" "import" feature ["as" name] (","feature ["as" name])*
feature: identifier
name: identifier
</code></pre>
<p>또한, 모든 <code>future_statement</code>는 모듈의 거의 맨 위(near the top)에 나타나야 합니다. <code>future_statement</code> 앞에 올 수 있는 유일한 줄은 다음과 같습니다.</p>
<ul>
<li>모듈 docstring (있는 경우)</li>
<li>주석 (Comments)</li>
<li>빈 줄 (Blank lines)</li>
<li>다른 <code>future_statement</code></li>
</ul>
<p><strong>예시:</strong></p>
<pre><code class="language-python">"""This is a module docstring."""
# This is a comment, preceded by a blank line and followed by
# a future_statement.
from __future__ import nested_scopes
from math import sin
from __future__ import alabaster_weenoblobs # compile-time error!
# That was an error because preceded by a non-future-statement.
</code></pre>
<h2>의미론 (Semantics)</h2>
<p><code>future_statement</code>는 컴파일 시간에 특별히 인식되고 처리됩니다. 핵심 구문의 의미론 변경은 종종 다른 코드를 생성함으로써 구현되기 때문입니다. 새로운 기능이 새로운 비호환 구문(예: 새로운 예약어)을 도입하는 경우, 컴파일러가 모듈을 다르게 파싱해야 할 수도 있습니다. 이러한 결정은 런타임으로 미뤄질 수 없습니다.</p>
<p>주어진 릴리스에서 컴파일러는 어떤 기능 이름이 정의되었는지 알고 있으며, <code>future_statement</code>에 알려지지 않은 기능이 포함되어 있으면 컴파일 시간 오류를 발생시킵니다.</p>
<p>직접적인 런타임 의미론은 다른 <code>import</code> 문과 동일합니다. 즉, 나중에 설명할 표준 모듈 <code>__future__.py</code>가 있으며, <code>future_statement</code>가 실행될 때 일반적인 방식으로 임포트됩니다.</p>
<p>흥미로운 런타임 의미론은 모듈에 나타나는 <code>future_statement</code>에 의해 "임포트"된 특정 기능에 따라 달라집니다.</p>
<p><code>import __future__ [as name]</code> 문은 특별한 의미나 구문 제약이 없는 일반적인 <code>import</code> 문이며, <code>future_statement</code>가 아니라는 점에 유의해야 합니다.</p>
<h2>예시 (Example)</h2>
<p><code>scope.py</code> 파일의 다음 코드를 고려해봅시다.</p>
<pre><code class="language-python">x = 42
def f():
    x = 666
    def g():
        print "x is", x
    g()
f()
</code></pre>
<ul>
<li>Python 2.0에서는 <code>"x is 42"</code>를 출력합니다.</li>
<li>중첩 스코프(PEP 227)는 2.1에 도입되었지만, 2.1에서도 <code>"x is 42"</code>를 출력하고 경고를 발생시킵니다.</li>
<li>Python 2.2부터는, 또는 2.1에서 <code>scope.py</code> 맨 위에 <code>from __future__ import nested_scopes</code>가 포함된 경우 <code>"x is 666"</code>을 출력합니다.</li>
</ul>
<h2>표준 모듈 <code>__future__.py</code></h2>
<p><code>Lib/__future__.py</code>는 실제 모듈이며 다음 세 가지 목적을 수행합니다.</p>
<ol>
<li><code>import</code> 문을 분석하고 임포트하는 모듈을 찾으려고 하는 기존 도구를 혼란스럽게 하지 않기 위함입니다.</li>
<li>Python 2.1 이전 릴리스에서 <code>future_statement</code>가 실행될 경우, 최소한 런타임 예외가 발생하도록 보장합니다(<code>__future__</code> 임포트가 실패하기 때문).</li>
<li>호환되지 않는 변경이 언제 도입되었고, 언제 강제될 예정이거나 강제되었는지 문서화합니다. 이는 실행 가능한 문서 형태이며, <code>__future__</code>를 임포트하고 그 내용을 검사함으로써 프로그래밍 방식으로 확인할 수 있습니다.</li>
</ol>
<p><code>__future__.py</code>의 각 문은 다음과 같은 형태를 가집니다.</p>
<pre><code>FeatureName = "_Feature(" OptionalRelease "," MandatoryRelease ")"
</code></pre>
<p>여기서 일반적으로 <code>OptionalRelease &#x3C; MandatoryRelease</code>이며, 둘 다 <code>sys.version_info</code>와 동일한 형태의 5-튜플입니다.</p>
<pre><code class="language-python">(PY_MAJOR_VERSION,    # 2.1.0a3에서 2; 정수
 PY_MINOR_VERSION,    # 1; 정수
 PY_MICRO_VERSION,    # 0; 정수
 PY_RELEASE_LEVEL,    # "alpha", "beta", "candidate" 또는 "final"; 문자열
 PY_RELEASE_SERIAL    # 3; 정수
)
</code></pre>
<ul>
<li><code>OptionalRelease</code>는 <code>from __future__ import FeatureName</code>이 허용된 첫 번째 릴리스를 기록합니다.</li>
<li>아직 발생하지 않은 <code>MandatoryRelease</code>의 경우, 해당 기능이 언어의 일부가 될 릴리스를 예측합니다.</li>
<li>그 외의 경우, <code>MandatoryRelease</code>는 기능이 언어의 일부가 된 시점을 기록합니다. 이 릴리스 이후에는 모듈이 해당 기능을 사용하기 위해 <code>from __future__ import FeatureName</code>를 더 이상 필요로 하지 않지만, 계속 사용할 수는 있습니다.</li>
<li><code>MandatoryRelease</code>는 <code>None</code>일 수도 있으며, 이는 계획된 기능이 중단되었음을 의미합니다.</li>
</ul>
<p><code>_Feature</code> 클래스의 인스턴스에는 <code>.getOptionalRelease()</code> 및 <code>.getMandatoryRelease()</code>라는 두 가지 해당 메서드가 있습니다.</p>
<p><code>__future__.py</code>에서 기능 라인이 삭제되는 일은 없습니다.</p>
<p><strong>예시 라인:</strong></p>
<pre><code class="language-python">nested_scopes = _Feature((2, 1, 0, "beta", 1), (2, 2, 0, "final", 0))
</code></pre>
<p>이는 <code>from __future__ import nested_scopes</code>가 2.1b1 이후의 모든 릴리스에서 작동하며, 중첩 스코프는 2.2 릴리스부터 강제될 예정임을 의미합니다.</p>
<h2>해결된 문제: 런타임 컴파일 (Resolved Problem: Runtime Compilation)</h2>
<p>몇 가지 Python 기능은 모듈의 런타임 동안 코드를 컴파일할 수 있습니다.</p>
<ul>
<li><code>exec</code> 문</li>
<li><code>execfile()</code> 함수</li>
<li><code>compile()</code> 함수</li>
<li><code>eval()</code> 함수</li>
<li><code>input()</code> 함수</li>
</ul>
<p>기능 F를 명시하는 <code>future_statement</code>를 포함하는 모듈 M이 현재 릴리스에서 F와 관련하여 미래 릴리스처럼 작동하도록 요청하므로, M 내에서 이러한 함수 중 하나에 전달된 텍스트로부터 동적으로 컴파일된 코드도 F와 관련된 새로운 구문이나 의미론을 사용해야 합니다. Python 2.1 릴리스는 이런 식으로 동작합니다.</p>
<p>그러나 항상 이런 동작이 바람직한 것은 아닙니다. 예를 들어, <code>doctest.testmod(M)</code>는 M의 문자열에서 가져온 예제를 컴파일하며, 이 예제는 <code>doctest</code> 모듈의 선택이 아니라 M의 선택을 사용해야 합니다. 2.1 릴리스에서는 이것이 불가능하며, 이를 해결할 방법은 아직 제시되지 않았습니다. 참고: PEP 264는 나중에 <code>compile()</code>에 선택적 인수를 추가하여 유연한 방식으로 이 문제를 해결했습니다.</p>
<p>어떤 경우든, <code>exec</code>, <code>execfile()</code>, <code>compile()</code>에 의해 동적으로 컴파일된 텍스트의 "거의 맨 위"(위의 구문 참조)에 나타나는 <code>future_statement</code>는 생성된 코드 블록에 적용되지만, 해당 <code>exec</code>, <code>execfile()</code>, <code>compile()</code>을 실행하는 모듈에는 더 이상 영향을 미치지 않습니다. 그러나 <code>eval()</code>이나 <code>input()</code>에는 영향을 미칠 수 없는데, 이는 이들이 표현식 입력만 허용하고 <code>future_statement</code>는 표현식이 아니기 때문입니다.</p>
<h2>해결된 문제: 네이티브 대화형 셸 (Resolved Problem: Native Interactive Shells)</h2>
<p>대화형 셸을 얻는 방법에는 두 가지가 있습니다.</p>
<ul>
<li>스크립트 인수 없이 명령줄에서 Python을 호출합니다.</li>
<li><code>-i</code> 스위치와 스크립트 인수를 사용하여 명령줄에서 Python을 호출합니다.</li>
</ul>
<p>대화형 셸은 런타임 컴파일의 극단적인 경우로 볼 수 있습니다. 사실상, 대화형 셸 프롬프트에서 입력된 각 문은 <code>exec</code>, <code>compile()</code>, <code>execfile()</code>의 새 인스턴스를 실행합니다. 대화형 셸에서 입력된 <code>future_statement</code>는 마치 <code>future_statement</code>가 모듈의 맨 위에 나타난 것처럼 셸 세션의 나머지 수명 동안 적용됩니다.</p>
<h2>해결된 문제: 시뮬레이션된 대화형 셸 (Resolved Problem: Simulated Interactive Shells)</h2>
<p>IDLE 및 Emacs Python 모드와 같은 도구에 의해 "수동으로 빌드된" 대화형 셸은 네이티브 대화형 셸처럼 동작해야 합니다. 그러나 네이티브 대화형 셸에서 내부적으로 사용되는 메커니즘이 노출되지 않았으므로, 자체 대화형 셸을 구축하는 도구들이 원하는 동작을 달성할 명확한 방법이 없었습니다.</p>
<p>참고: PEP 264는 나중에 표준 <code>codeop.py</code>에 기능을 추가하여 이 문제를 해결했습니다. 표준 라이브러리 셸 헬퍼를 사용하지 않는 시뮬레이션된 셸은 PEP 264에 의해 추가된 <code>compile()</code>의 새로운 선택적 인수를 활용하여 유사한 효과를 얻을 수 있습니다.</p>
<h2>질의응답 (Questions and Answers)</h2>
<p><strong>Q: 이전 동작으로 돌아가기 위한 "<code>from __past__</code>" 버전은 어떻습니까?</strong>
A: 이 PEP의 범위 밖입니다. 저자는 가능성이 낮다고 생각합니다. 이를 추진하려면 PEP를 작성해야 합니다.</p>
<p><strong>Q: Python 가상 머신 변경으로 인한 비호환성은 어떻습니까?</strong>
A: 이 PEP의 범위 밖입니다. PEP 5는 이 경우에도 유예 기간을 제안하며, <code>future_statement</code>도 여기에 역할을 할 수 있습니다.</p>
<p><strong>Q: Python의 C API 변경으로 인한 비호환성은 어떻습니까?</strong>
A: 이 PEP의 범위 밖입니다.</p>
<p><strong>Q: <code>future_statement</code>를 <code>try/except</code> 블록으로 래핑하여 실행 중인 Python 버전에 따라 다른 코드를 사용하고 싶습니다. 왜 할 수 없나요?</strong>
A: 죄송합니다! <code>try/except</code>는 런타임 기능이고, <code>future_statement</code>는 주로 컴파일 시간 메커니즘입니다. <code>try/except</code>는 컴파일러 작업이 완료된 한참 후에 발생합니다. 즉, <code>try/except</code>를 수행할 때쯤이면 모듈에 적용되는 의미론은 이미 확정된 상태입니다. <code>try/except</code>가 의도한 바를 달성하지 못할 것이므로 단순히 허용되지 않습니다. 또한, 이러한 특별한 문들을 매우 쉽게 찾고 인식할 수 있도록 유지하고자 합니다.
<code>__future__</code>를 직접 임포트하고 그 안에 있는 정보와 <code>sys.version_info</code>를 사용하여 실행 중인 릴리스가 특정 기능의 상태와 관련하여 어떤 위치에 있는지 파악할 수 있다는 점에 유의하세요.</p>
<p><strong>Q: <code>nested_scopes</code> 예시로 돌아가서, 릴리스 2.2가 나왔는데도 제 코드를 아직 변경하지 않았다면 어떻게 됩니까? 2.1 동작을 유지하려면 어떻게 해야 합니까?</strong>
A: 코드를 변경하기 전까지는 2.2로 옮겨가지 않고 2.1을 계속 사용하면 됩니다. <code>future_statement</code>의 목적은 최신 릴리스에 제때 맞춰가는 사람들의 삶을 더 쉽게 만드는 것입니다. 그렇지 않더라도 당신을 싫어하지는 않지만, 당신의 문제는 훨씬 더 해결하기 어렵고, 그런 문제를 가진 사람은 해당 문제를 다루는 PEP를 작성해야 할 것입니다. <code>future_statement</code>는 다른 대상을 목표로 합니다.</p>
<p><strong>Q: <code>import</code>를 오버로드하는 것은 좋지 않습니다. 왜 이를 위해 새로운 문을 도입하지 않습니까?</strong>
A: 예를 들어 <code>lambda lambda nested_scopes</code>와 같은 것 말입니까? 즉, 새로운 키워드를 도입하지 않는 한, 완전히 새로운 문을 도입할 수 없습니다. 그러나 새로운 키워드를 도입한다면, 그 자체가 오래된 코드를 손상시킬 것입니다. 그것은 너무 아이러니해서 견딜 수 없을 것입니다. 예, <code>import</code>를 오버로드하는 것은 좋지 않지만, 대안만큼 강력하게 나쁘지는 않습니다. 현재로서는 <code>future_statement</code>는 100% 하위 호환됩니다.</p>
<h2>저작권 및 참고 자료 (Copyright and References)</h2>
<p>이 문서는 공개 도메인으로 지정되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-1a135130af3e1cae.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/236\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"8N6icDw00Cy0kKVlExSq2\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/236/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/236\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"236\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/236\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T3e65,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0236/\"\u003ePEP 236 - Back to the \u003cstrong\u003efuture\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 26-Feb-2001\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e때때로 Python은 핵심 언어 구문의 공표된 의미(semantics)에 호환되지 않는 변경을 가하거나, 의도치 않은(구현에 의존하는) 동작을 변경합니다. 이러한 변경은 신중하게 이루어지며 장기적으로 언어를 개선하기 위함이지만, 단기적으로는 논란의 여지가 있고 혼란을 야기할 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePEP 5, \"Guidelines for Language Evolution\"은 이러한 어려움을 완화하기 위한 방법을 제시하며, 이 PEP는 이를 지원하는 메커니즘을 소개합니다.\u003c/p\u003e\n\u003cp\u003ePEP 227, \"Statically Nested Scopes\"가 첫 번째 적용 사례이며, 이 PEP에서 예시로 사용됩니다.\u003c/p\u003e\n\u003ch2\u003e목표 (Intent)\u003c/h2\u003e\n\u003cp\u003e핵심 언어 구문이나 의미론에 호환되지 않는 변경이 있을 때 다음 정책이 적용됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e변경을 도입하는 릴리스 C에서는 기본적으로 구문이나 의미론이 변경되지 않습니다.\u003c/li\u003e\n\u003cli\u003e새로운 구문이나 의미론이 강제될 미래 릴리스 R이 지정됩니다.\u003c/li\u003e\n\u003cli\u003e가능한 경우, 릴리스 R에서 의미가 변경될 수 있는 구문이나 연산에 대해 PEP 230, \"Warning Framework\"에 설명된 메커니즘을 사용하여 경고가 생성됩니다.\u003c/li\u003e\n\u003cli\u003e새로운 \u003ccode\u003efuture_statement\u003c/code\u003e (아래 참조)를 모듈 M에 명시적으로 포함하여, 모듈 M의 코드가 현재 릴리스 C에서 새로운 구문이나 의미론을 사용하도록 요청할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e따라서, 오래된 코드는 최소한 한 릴리스 동안은 기본적으로 계속 작동하지만, 새로운 경고 메시지가 발생할 수 있습니다. 새로운 구문이나 의미론으로의 마이그레이션은 이 기간 동안 진행될 수 있으며, \u003ccode\u003efuture_statement\u003c/code\u003e를 사용하여 해당 모듈이 새로운 구문이나 의미론이 이미 강제되고 있는 것처럼 작동하도록 만듭니다.\u003c/p\u003e\n\u003cp\u003e기존 코드를 손상시킬 수 있는 경우가 아니라면 새로운 기능에 \u003ccode\u003efuture_statement\u003c/code\u003e 메커니즘을 사용할 필요가 없다는 점에 유의해야 합니다. 완전히 하위 호환되는 추가 기능은 해당 \u003ccode\u003efuture_statement\u003c/code\u003e 없이 도입될 수 있으며, 그렇게 해야 합니다.\u003c/p\u003e\n\u003ch2\u003e구문 (Syntax)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003efuture_statement\u003c/code\u003e는 예약된 모듈 이름 \u003ccode\u003e__future__\u003c/code\u003e를 사용하는 단순한 \u003ccode\u003efrom/import\u003c/code\u003e 문입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efuture_statement: \"from\" \"__future__\" \"import\" feature [\"as\" name] (\",\"feature [\"as\" name])*\r\nfeature: identifier\r\nname: identifier\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한, 모든 \u003ccode\u003efuture_statement\u003c/code\u003e는 모듈의 거의 맨 위(near the top)에 나타나야 합니다. \u003ccode\u003efuture_statement\u003c/code\u003e 앞에 올 수 있는 유일한 줄은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모듈 docstring (있는 경우)\u003c/li\u003e\n\u003cli\u003e주석 (Comments)\u003c/li\u003e\n\u003cli\u003e빈 줄 (Blank lines)\u003c/li\u003e\n\u003cli\u003e다른 \u003ccode\u003efuture_statement\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\"\"\"This is a module docstring.\"\"\"\r\n# This is a comment, preceded by a blank line and followed by\r\n# a future_statement.\r\nfrom __future__ import nested_scopes\r\nfrom math import sin\r\nfrom __future__ import alabaster_weenoblobs # compile-time error!\r\n# That was an error because preceded by a non-future-statement.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e의미론 (Semantics)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003efuture_statement\u003c/code\u003e는 컴파일 시간에 특별히 인식되고 처리됩니다. 핵심 구문의 의미론 변경은 종종 다른 코드를 생성함으로써 구현되기 때문입니다. 새로운 기능이 새로운 비호환 구문(예: 새로운 예약어)을 도입하는 경우, 컴파일러가 모듈을 다르게 파싱해야 할 수도 있습니다. 이러한 결정은 런타임으로 미뤄질 수 없습니다.\u003c/p\u003e\n\u003cp\u003e주어진 릴리스에서 컴파일러는 어떤 기능 이름이 정의되었는지 알고 있으며, \u003ccode\u003efuture_statement\u003c/code\u003e에 알려지지 않은 기능이 포함되어 있으면 컴파일 시간 오류를 발생시킵니다.\u003c/p\u003e\n\u003cp\u003e직접적인 런타임 의미론은 다른 \u003ccode\u003eimport\u003c/code\u003e 문과 동일합니다. 즉, 나중에 설명할 표준 모듈 \u003ccode\u003e__future__.py\u003c/code\u003e가 있으며, \u003ccode\u003efuture_statement\u003c/code\u003e가 실행될 때 일반적인 방식으로 임포트됩니다.\u003c/p\u003e\n\u003cp\u003e흥미로운 런타임 의미론은 모듈에 나타나는 \u003ccode\u003efuture_statement\u003c/code\u003e에 의해 \"임포트\"된 특정 기능에 따라 달라집니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimport __future__ [as name]\u003c/code\u003e 문은 특별한 의미나 구문 제약이 없는 일반적인 \u003ccode\u003eimport\u003c/code\u003e 문이며, \u003ccode\u003efuture_statement\u003c/code\u003e가 아니라는 점에 유의해야 합니다.\u003c/p\u003e\n\u003ch2\u003e예시 (Example)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003escope.py\u003c/code\u003e 파일의 다음 코드를 고려해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ex = 42\r\ndef f():\r\n    x = 666\r\n    def g():\r\n        print \"x is\", x\r\n    g()\r\nf()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ePython 2.0에서는 \u003ccode\u003e\"x is 42\"\u003c/code\u003e를 출력합니다.\u003c/li\u003e\n\u003cli\u003e중첩 스코프(PEP 227)는 2.1에 도입되었지만, 2.1에서도 \u003ccode\u003e\"x is 42\"\u003c/code\u003e를 출력하고 경고를 발생시킵니다.\u003c/li\u003e\n\u003cli\u003ePython 2.2부터는, 또는 2.1에서 \u003ccode\u003escope.py\u003c/code\u003e 맨 위에 \u003ccode\u003efrom __future__ import nested_scopes\u003c/code\u003e가 포함된 경우 \u003ccode\u003e\"x is 666\"\u003c/code\u003e을 출력합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e표준 모듈 \u003ccode\u003e__future__.py\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLib/__future__.py\u003c/code\u003e는 실제 모듈이며 다음 세 가지 목적을 수행합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eimport\u003c/code\u003e 문을 분석하고 임포트하는 모듈을 찾으려고 하는 기존 도구를 혼란스럽게 하지 않기 위함입니다.\u003c/li\u003e\n\u003cli\u003ePython 2.1 이전 릴리스에서 \u003ccode\u003efuture_statement\u003c/code\u003e가 실행될 경우, 최소한 런타임 예외가 발생하도록 보장합니다(\u003ccode\u003e__future__\u003c/code\u003e 임포트가 실패하기 때문).\u003c/li\u003e\n\u003cli\u003e호환되지 않는 변경이 언제 도입되었고, 언제 강제될 예정이거나 강제되었는지 문서화합니다. 이는 실행 가능한 문서 형태이며, \u003ccode\u003e__future__\u003c/code\u003e를 임포트하고 그 내용을 검사함으로써 프로그래밍 방식으로 확인할 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ccode\u003e__future__.py\u003c/code\u003e의 각 문은 다음과 같은 형태를 가집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFeatureName = \"_Feature(\" OptionalRelease \",\" MandatoryRelease \")\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 일반적으로 \u003ccode\u003eOptionalRelease \u0026#x3C; MandatoryRelease\u003c/code\u003e이며, 둘 다 \u003ccode\u003esys.version_info\u003c/code\u003e와 동일한 형태의 5-튜플입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e(PY_MAJOR_VERSION,    # 2.1.0a3에서 2; 정수\r\n PY_MINOR_VERSION,    # 1; 정수\r\n PY_MICRO_VERSION,    # 0; 정수\r\n PY_RELEASE_LEVEL,    # \"alpha\", \"beta\", \"candidate\" 또는 \"final\"; 문자열\r\n PY_RELEASE_SERIAL    # 3; 정수\r\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eOptionalRelease\u003c/code\u003e는 \u003ccode\u003efrom __future__ import FeatureName\u003c/code\u003e이 허용된 첫 번째 릴리스를 기록합니다.\u003c/li\u003e\n\u003cli\u003e아직 발생하지 않은 \u003ccode\u003eMandatoryRelease\u003c/code\u003e의 경우, 해당 기능이 언어의 일부가 될 릴리스를 예측합니다.\u003c/li\u003e\n\u003cli\u003e그 외의 경우, \u003ccode\u003eMandatoryRelease\u003c/code\u003e는 기능이 언어의 일부가 된 시점을 기록합니다. 이 릴리스 이후에는 모듈이 해당 기능을 사용하기 위해 \u003ccode\u003efrom __future__ import FeatureName\u003c/code\u003e를 더 이상 필요로 하지 않지만, 계속 사용할 수는 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMandatoryRelease\u003c/code\u003e는 \u003ccode\u003eNone\u003c/code\u003e일 수도 있으며, 이는 계획된 기능이 중단되었음을 의미합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e_Feature\u003c/code\u003e 클래스의 인스턴스에는 \u003ccode\u003e.getOptionalRelease()\u003c/code\u003e 및 \u003ccode\u003e.getMandatoryRelease()\u003c/code\u003e라는 두 가지 해당 메서드가 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__future__.py\u003c/code\u003e에서 기능 라인이 삭제되는 일은 없습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e예시 라인:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003enested_scopes = _Feature((2, 1, 0, \"beta\", 1), (2, 2, 0, \"final\", 0))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 \u003ccode\u003efrom __future__ import nested_scopes\u003c/code\u003e가 2.1b1 이후의 모든 릴리스에서 작동하며, 중첩 스코프는 2.2 릴리스부터 강제될 예정임을 의미합니다.\u003c/p\u003e\n\u003ch2\u003e해결된 문제: 런타임 컴파일 (Resolved Problem: Runtime Compilation)\u003c/h2\u003e\n\u003cp\u003e몇 가지 Python 기능은 모듈의 런타임 동안 코드를 컴파일할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eexec\u003c/code\u003e 문\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eexecfile()\u003c/code\u003e 함수\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecompile()\u003c/code\u003e 함수\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eeval()\u003c/code\u003e 함수\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einput()\u003c/code\u003e 함수\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e기능 F를 명시하는 \u003ccode\u003efuture_statement\u003c/code\u003e를 포함하는 모듈 M이 현재 릴리스에서 F와 관련하여 미래 릴리스처럼 작동하도록 요청하므로, M 내에서 이러한 함수 중 하나에 전달된 텍스트로부터 동적으로 컴파일된 코드도 F와 관련된 새로운 구문이나 의미론을 사용해야 합니다. Python 2.1 릴리스는 이런 식으로 동작합니다.\u003c/p\u003e\n\u003cp\u003e그러나 항상 이런 동작이 바람직한 것은 아닙니다. 예를 들어, \u003ccode\u003edoctest.testmod(M)\u003c/code\u003e는 M의 문자열에서 가져온 예제를 컴파일하며, 이 예제는 \u003ccode\u003edoctest\u003c/code\u003e 모듈의 선택이 아니라 M의 선택을 사용해야 합니다. 2.1 릴리스에서는 이것이 불가능하며, 이를 해결할 방법은 아직 제시되지 않았습니다. 참고: PEP 264는 나중에 \u003ccode\u003ecompile()\u003c/code\u003e에 선택적 인수를 추가하여 유연한 방식으로 이 문제를 해결했습니다.\u003c/p\u003e\n\u003cp\u003e어떤 경우든, \u003ccode\u003eexec\u003c/code\u003e, \u003ccode\u003eexecfile()\u003c/code\u003e, \u003ccode\u003ecompile()\u003c/code\u003e에 의해 동적으로 컴파일된 텍스트의 \"거의 맨 위\"(위의 구문 참조)에 나타나는 \u003ccode\u003efuture_statement\u003c/code\u003e는 생성된 코드 블록에 적용되지만, 해당 \u003ccode\u003eexec\u003c/code\u003e, \u003ccode\u003eexecfile()\u003c/code\u003e, \u003ccode\u003ecompile()\u003c/code\u003e을 실행하는 모듈에는 더 이상 영향을 미치지 않습니다. 그러나 \u003ccode\u003eeval()\u003c/code\u003e이나 \u003ccode\u003einput()\u003c/code\u003e에는 영향을 미칠 수 없는데, 이는 이들이 표현식 입력만 허용하고 \u003ccode\u003efuture_statement\u003c/code\u003e는 표현식이 아니기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e해결된 문제: 네이티브 대화형 셸 (Resolved Problem: Native Interactive Shells)\u003c/h2\u003e\n\u003cp\u003e대화형 셸을 얻는 방법에는 두 가지가 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e스크립트 인수 없이 명령줄에서 Python을 호출합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-i\u003c/code\u003e 스위치와 스크립트 인수를 사용하여 명령줄에서 Python을 호출합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e대화형 셸은 런타임 컴파일의 극단적인 경우로 볼 수 있습니다. 사실상, 대화형 셸 프롬프트에서 입력된 각 문은 \u003ccode\u003eexec\u003c/code\u003e, \u003ccode\u003ecompile()\u003c/code\u003e, \u003ccode\u003eexecfile()\u003c/code\u003e의 새 인스턴스를 실행합니다. 대화형 셸에서 입력된 \u003ccode\u003efuture_statement\u003c/code\u003e는 마치 \u003ccode\u003efuture_statement\u003c/code\u003e가 모듈의 맨 위에 나타난 것처럼 셸 세션의 나머지 수명 동안 적용됩니다.\u003c/p\u003e\n\u003ch2\u003e해결된 문제: 시뮬레이션된 대화형 셸 (Resolved Problem: Simulated Interactive Shells)\u003c/h2\u003e\n\u003cp\u003eIDLE 및 Emacs Python 모드와 같은 도구에 의해 \"수동으로 빌드된\" 대화형 셸은 네이티브 대화형 셸처럼 동작해야 합니다. 그러나 네이티브 대화형 셸에서 내부적으로 사용되는 메커니즘이 노출되지 않았으므로, 자체 대화형 셸을 구축하는 도구들이 원하는 동작을 달성할 명확한 방법이 없었습니다.\u003c/p\u003e\n\u003cp\u003e참고: PEP 264는 나중에 표준 \u003ccode\u003ecodeop.py\u003c/code\u003e에 기능을 추가하여 이 문제를 해결했습니다. 표준 라이브러리 셸 헬퍼를 사용하지 않는 시뮬레이션된 셸은 PEP 264에 의해 추가된 \u003ccode\u003ecompile()\u003c/code\u003e의 새로운 선택적 인수를 활용하여 유사한 효과를 얻을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e질의응답 (Questions and Answers)\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eQ: 이전 동작으로 돌아가기 위한 \"\u003ccode\u003efrom __past__\u003c/code\u003e\" 버전은 어떻습니까?\u003c/strong\u003e\r\nA: 이 PEP의 범위 밖입니다. 저자는 가능성이 낮다고 생각합니다. 이를 추진하려면 PEP를 작성해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eQ: Python 가상 머신 변경으로 인한 비호환성은 어떻습니까?\u003c/strong\u003e\r\nA: 이 PEP의 범위 밖입니다. PEP 5는 이 경우에도 유예 기간을 제안하며, \u003ccode\u003efuture_statement\u003c/code\u003e도 여기에 역할을 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eQ: Python의 C API 변경으로 인한 비호환성은 어떻습니까?\u003c/strong\u003e\r\nA: 이 PEP의 범위 밖입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eQ: \u003ccode\u003efuture_statement\u003c/code\u003e를 \u003ccode\u003etry/except\u003c/code\u003e 블록으로 래핑하여 실행 중인 Python 버전에 따라 다른 코드를 사용하고 싶습니다. 왜 할 수 없나요?\u003c/strong\u003e\r\nA: 죄송합니다! \u003ccode\u003etry/except\u003c/code\u003e는 런타임 기능이고, \u003ccode\u003efuture_statement\u003c/code\u003e는 주로 컴파일 시간 메커니즘입니다. \u003ccode\u003etry/except\u003c/code\u003e는 컴파일러 작업이 완료된 한참 후에 발생합니다. 즉, \u003ccode\u003etry/except\u003c/code\u003e를 수행할 때쯤이면 모듈에 적용되는 의미론은 이미 확정된 상태입니다. \u003ccode\u003etry/except\u003c/code\u003e가 의도한 바를 달성하지 못할 것이므로 단순히 허용되지 않습니다. 또한, 이러한 특별한 문들을 매우 쉽게 찾고 인식할 수 있도록 유지하고자 합니다.\r\n\u003ccode\u003e__future__\u003c/code\u003e를 직접 임포트하고 그 안에 있는 정보와 \u003ccode\u003esys.version_info\u003c/code\u003e를 사용하여 실행 중인 릴리스가 특정 기능의 상태와 관련하여 어떤 위치에 있는지 파악할 수 있다는 점에 유의하세요.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eQ: \u003ccode\u003enested_scopes\u003c/code\u003e 예시로 돌아가서, 릴리스 2.2가 나왔는데도 제 코드를 아직 변경하지 않았다면 어떻게 됩니까? 2.1 동작을 유지하려면 어떻게 해야 합니까?\u003c/strong\u003e\r\nA: 코드를 변경하기 전까지는 2.2로 옮겨가지 않고 2.1을 계속 사용하면 됩니다. \u003ccode\u003efuture_statement\u003c/code\u003e의 목적은 최신 릴리스에 제때 맞춰가는 사람들의 삶을 더 쉽게 만드는 것입니다. 그렇지 않더라도 당신을 싫어하지는 않지만, 당신의 문제는 훨씬 더 해결하기 어렵고, 그런 문제를 가진 사람은 해당 문제를 다루는 PEP를 작성해야 할 것입니다. \u003ccode\u003efuture_statement\u003c/code\u003e는 다른 대상을 목표로 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eQ: \u003ccode\u003eimport\u003c/code\u003e를 오버로드하는 것은 좋지 않습니다. 왜 이를 위해 새로운 문을 도입하지 않습니까?\u003c/strong\u003e\r\nA: 예를 들어 \u003ccode\u003elambda lambda nested_scopes\u003c/code\u003e와 같은 것 말입니까? 즉, 새로운 키워드를 도입하지 않는 한, 완전히 새로운 문을 도입할 수 없습니다. 그러나 새로운 키워드를 도입한다면, 그 자체가 오래된 코드를 손상시킬 것입니다. 그것은 너무 아이러니해서 견딜 수 없을 것입니다. 예, \u003ccode\u003eimport\u003c/code\u003e를 오버로드하는 것은 좋지 않지만, 대안만큼 강력하게 나쁘지는 않습니다. 현재로서는 \u003ccode\u003efuture_statement\u003c/code\u003e는 100% 하위 호환됩니다.\u003c/p\u003e\n\u003ch2\u003e저작권 및 참고 자료 (Copyright and References)\u003c/h2\u003e\n\u003cp\u003e이 문서는 공개 도메인으로 지정되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1318,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 236 - Back to the __future__\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 17:05:02+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>