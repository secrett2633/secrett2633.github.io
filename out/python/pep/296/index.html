<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d79d6340e7770dba.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Withdrawn] PEP 296 - Adding a bytes Object Type</h1><div class="page__meta"><time dateTime="2025-09-26 18:05:57+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0296/">PEP 296 - Adding a bytes Object Type</a></p>
<p><strong>상태:</strong> Withdrawn | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 12-Jul-2002</p>
</blockquote>
<p>PEP 296은 Python 2.3 버전을 위해 <code>bytes</code> 객체 타입 추가를 제안했던 문서입니다. 이 제안은 나중에 PEP 358로 대체되어 철회(Withdrawn)되었습니다.</p>
<hr>
<h2>PEP 296 – <code>bytes</code> 객체 타입 추가</h2>
<h3>공지 (Notice)</h3>
<p>이 PEP는 작성자에 의해 철회되었습니다 (PEP 358 선호).</p>
<h3>개요 (Abstract)</h3>
<p>이 PEP는 'bytes'라는 새로운 표준 타입과 내장 생성자(builtin constructor) 생성을 제안합니다. <code>bytes</code> 객체는 효율적으로 저장되는 바이트 배열이며, 유사한 다른 구현체들과 차별화되는 몇 가지 추가적인 특성을 가집니다.</p>
<h3>배경 (Rationale)</h3>
<p>현재 Python에는 이 제안의 <code>bytes</code> 객체와 유사한 기능을 구현하는 많은 객체가 있습니다. 예를 들어, 표준 <code>string</code>, <code>buffer</code>, <code>array</code>, 그리고 <code>mmap</code> 객체는 모두 `bytes`` 객체와 여러 면에서 매우 유사합니다. 또한, 여러 중요한 서드파티 확장 기능들이 유사한 요구를 충족하기 위해 비슷한 객체를 만들었습니다. 안타깝게도, 이러한 각 객체는 범위가 너무 좁고 더 넓은 범주의 문제에 적용하기에 중요한 기능들이 부족합니다.</p>
<h3>명세 (Specification)</h3>
<p><code>bytes</code> 객체는 다음과 같은 중요한 특성을 가집니다.</p>
<ul>
<li><strong>효율적인 내부 배열 저장:</strong> 표준 C 타입인 "unsigned char"를 통해 효율적인 내부 배열 저장을 제공합니다. 이를 통해 할당되는 메모리 양을 세밀하게 제어할 수 있습니다. 다음 항목에 명시된 정렬(alignment) 제약 조건과 함께, 저수준(low level) 확장 기능이 필요에 따라 포인터를 다른 타입으로 캐스팅하는 것이 쉽습니다.
<ul>
<li>객체가 바이트 배열로 구현되어 있으므로, 현재 문자열(string)과 함께 작동하는 표준 라이브러리의 광범위한 루틴 라이브러리에 <code>bytes</code> 객체를 전달할 수 있습니다. 예를 들어, <code>struct</code> 모듈과 함께 <code>bytes</code> 객체를 사용하면 순수 Python 스크립트만으로 <code>array</code> 모듈을 완전히 대체할 수 있습니다.</li>
<li>네이티브 8비트 <code>unsigned</code> 타입이 없는 특이한 플랫폼이 발견된다 하더라도, 객체는 Python 스크립트 레벨에서 8비트 <code>unsigned</code> 값의 배열인 것처럼 자신을 표현하기 위해 최선을 다할 것입니다. 많은 확장 기능이 이를 올바르게 처리할지는 의문이지만, 이러한 경우 Python 스크립트는 이식성(portable)을 가질 수 있습니다.</li>
</ul>
</li>
<li><strong>할당된 바이트 배열의 정렬:</strong> <code>malloc</code>의 플랫폼 구현이 약속하는 대로 정렬됩니다. 확장 기능에서 생성된 <code>bytes</code> 객체는 확장 기능 작성자가 적절하다고 판단하는 임의의 정렬을 제공할 수 있습니다.
<ul>
<li>이러한 정렬 제약 조건은 <code>bytes</code> 객체가 모든 표준 C 타입, 예를 들어 <code>PyComplex</code> 객체나 표준 C 타입으로 구성된 다른 <code>struct</code>들의 저장소로 사용될 수 있도록 허용해야 합니다. 추가적인 정렬 제약 조건은 필요에 따라 확장 기능에서 제공될 수 있습니다.</li>
</ul>
</li>
<li><strong>시퀀스 연산(Sequence Operations) 지원:</strong> <code>bytes</code> 객체는 <code>string</code>/<code>array</code> 객체에서 제공하는 시퀀스 연산의 부분 집합을 구현하지만, 일부 경우에 약간 다른 의미(semantics)를 가집니다.
<ul>
<li>특히, 슬라이스(slice)는 항상 새로운 <code>bytes</code> 객체를 반환하지만, 내부 메모리는 두 객체 간에 공유됩니다. 이러한 종류의 슬라이스 동작은 "뷰(view)"를 생성한다고 불립니다.</li>
<li>또한, <code>bytes</code> 객체에 대한 반복(repetition) 및 연결(concatenation)은 정의되지 않으며 예외(exception)를 발생시킵니다.</li>
<li>이러한 객체는 고성능 애플리케이션에서 사용될 가능성이 높기 때문에, 뷰 슬라이싱(view slicing) 사용 결정의 동기 중 하나는 <code>bytes</code> 객체 간의 복사(copying)가 매우 효율적이어야 하며 임시 객체 생성을 필요로 하지 않아야 한다는 것입니다. 다음 코드는 이를 보여줍니다.
<pre><code class="language-python"># create two 10 Meg bytes objects
b1 = bytes(10000000)
b2 = bytes(10000000)
# copy from part of one to another with out creating a 1 Meg temporary
b1[2000000:3000000] = b2[4000000:5000000]
</code></pre>
</li>
<li>Rvalue의 길이가 Lvalue의 길이와 같지 않은 슬라이스 할당(slice assignment)은 예외를 발생시킵니다. 그러나 슬라이스 할당은 겹치는 슬라이스(memmove로 일반적으로 구현됨)에서도 올바르게 작동합니다.</li>
</ul>
</li>
<li><strong>Pickle 및 cPickle 지원:</strong> <code>bytes</code> 객체는 효율적인 직렬화(serialization)를 위해 <code>pickle</code> 및 <code>cPickle</code> 모듈에 의해 네이티브 타입으로 인식됩니다. (실제로, 이것은 서드파티 확장 기능으로는 구현할 수 없는 유일한 요구 사항입니다.)
<ul>
<li><code>bytes</code>와 유사한 객체에 저장된 데이터를 임시 복사본을 문자열로 만들지 않고 직렬화해야 하는 요구를 해결하기 위한 부분적인 솔루션이 과거에 구현되었습니다. <code>array</code> 객체의 <code>tofile</code> 및 <code>fromfile</code> 메서드가 좋은 예시입니다. <code>bytes</code> 객체도 이러한 메서드를 지원할 것입니다.</li>
<li>그러나 pickling은 <code>shelve</code> 모듈이나 Python 객체의 RPC 구현과 같은 다른 상황에서도 유용하며, 효율적인 데이터 전송을 위해 최종 사용자가 두 가지 다른 직렬화 메커니즘을 사용하도록 요구하는 것은 바람직하지 않습니다.</li>
<li><strong>TODO:</strong> 이전 버전의 Python이 <code>bytes</code> 객체를 <code>string</code> 객체로 언피클(unpickle)하도록 새로운 <code>bytes</code> 객체의 pickling을 구현하려고 노력할 것입니다.</li>
<li>언피클링 시, <code>bytes</code> 객체는 Python에서 할당된 메모리(malloc을 통해)로부터 생성됩니다. 따라서 확장 기능이 제공한 포인터가 제공했을 수 있는 추가 속성(특수 정렬 또는 특수 메모리 타입)을 잃게 됩니다.</li>
<li><strong>TODO:</strong> <code>bytes</code> 타입의 C 서브클래스가 언피클될 메모리를 제공할 수 있도록 만들려고 노력할 것입니다. 예를 들어, <code>PageAlignedBytes</code>라는 파생 클래스는 페이지 정렬된 메모리로 언피클될 것입니다.</li>
<li><code>int</code>가 32비트인 모든 플랫폼(대부분의 경우)에서, 현재 31비트로 표현할 수 있는 길이보다 큰 문자열을 생성하는 것은 불가능합니다. 따라서 연산이 불가능할 때 <code>string</code>으로 pickling하는 것은 예외를 발생시킵니다.</li>
<li>적어도 대용량 파일(large file)을 지원하는 플랫폼(대부분)에서는 <code>file.write()</code> 메서드를 반복적으로 호출하여 대용량 <code>bytes</code> 객체를 파일로 pickling하는 것이 가능해야 합니다.</li>
</ul>
</li>
<li><strong>PyBufferProcs 인터페이스 지원:</strong> <code>bytes</code> 타입은 <code>PyBufferProcs</code> 인터페이스를 지원하지만, <code>bytes</code> 객체는 <code>bytes</code> 객체에 대한 참조가 유지되는 한 포인터가 할당 해제(deallocated)되거나 재할당(reallocated)되지 않는다는 추가적인 보장을 제공합니다.
<ul>
<li>이는 <code>bytes</code> 객체가 일단 생성되면 크기 변경이 불가능하다(not resizable)는 것을 의미하지만, <code>PyBytes_Check(...)</code> 테스트가 통과되면 별도의 스레드가 가리키는 메모리를 조작하는 동안 전역 인터프리터 락(GIL)을 해제할 수 있도록 허용합니다.</li>
<li><code>bytes</code> 객체의 이러한 특성은 비동기 파일 I/O 또는 다중 프로세서(multiprocessor) 머신과 같이 <code>PyBufferProcs</code>에 의해 얻은 포인터가 전역 인터프리터 락과 독립적으로 사용되는 상황에서 사용될 수 있도록 합니다.</li>
<li>GIL이 해제된 후 포인터가 재할당되거나 해제될 수 없다는 것을 알면 확장 기능 작성자는 진정한 동시성(concurrency)을 얻고 포인터에 대한 장기 실행 계산을 위해 추가 프로세서를 사용할 수 있습니다.</li>
<li>C/C++ 확장 기능에서, <code>bytes</code> 객체는 제공된 포인터(pointer)와 소멸자(destructor) 함수로부터 생성될 수 있으며, 참조 카운트(reference count)가 0이 되면 메모리를 해제합니다.</li>
<li><code>bytes</code> 객체의 슬라이싱에 대한 특별한 구현은 여러 <code>bytes</code> 객체가 동일한 포인터/소멸자를 참조할 수 있도록 합니다. 따라서 실제 포인터/소멸자에 대한 참조 카운트가 유지됩니다. 이 참조 카운트는 일반적으로 Python 객체와 관련된 참조 카운트와는 별개입니다.</li>
<li><strong>TODO:</strong> 내부 참조 카운트 객체를 실제 Python 객체로 노출하는 것이 바람직할 수 있습니다. 좋은 사용 사례가 발생하면, 나중에 하위 호환성 손실 없이 구현하는 것이 가능해야 합니다.</li>
</ul>
</li>
<li><strong>읽기 전용(<code>readonly</code>) <code>bytes</code> 객체:</strong> <code>bytes</code> 객체를 읽기 전용으로 표시하는 것도 가능하며, 이 경우 실제로는 변경 불가능(immutable)하지만 <code>bytes</code> 객체의 다른 기능들을 제공합니다.</li>
<li><strong>LONG_LONG 타입 길이 추적:</strong> <code>bytes</code> 객체는 Python <code>LONG_LONG</code> 타입으로 데이터의 길이를 추적합니다. <code>PyBufferProcs</code>의 현재 정의가 길이를 <code>int</code> 크기로 제한하더라도, 이 PEP는 그 부분에 변경을 제안하지 않습니다. 대신, 확장 기능은 명시적인 <code>PyBytes_Check(...)</code> 호출을 통해 이 제한을 우회할 수 있으며, 성공하면 <code>PyBytes_GetReadBuffer(...)</code> 또는 <code>PyBytes_GetWriteBuffer</code> 호출을 통해 객체의 포인터와 전체 길이를 <code>LONG_LONG</code>으로 얻을 수 있습니다.</li>
<li><strong>예외 발생:</strong> 표준 <code>PyBufferProcs</code> 메커니즘이 사용되고 <code>bytes</code> 객체의 크기가 <code>int</code>로 표현할 수 있는 크기보다 큰 경우 <code>bytes</code> 객체는 예외를 발생시킬 것입니다.</li>
<li><strong>Python 스크립팅에서:</strong> <code>bytes</code> 객체는 <code>long</code>으로 인덱싱(subscriptable)될 수 있어 32비트 <code>int</code> 제한을 피할 수 있습니다.
<ul>
<li><code>len()</code> 함수는 <code>PyObject_Size()</code>이며 <code>int</code>를 반환하므로 여전히 문제가 있습니다. 해결책으로 <code>bytes</code> 객체는 <code>long</code>을 반환하는 <code>.length()</code> 메서드를 제공할 것입니다.</li>
</ul>
</li>
<li><strong>생성자:</strong> <code>bytes</code> 객체는 Python 스크립팅 레벨에서 할당할 바이트 수를 <code>int</code>/<code>long</code>으로 <code>bytes</code> 생성자에 전달하여 생성할 수 있습니다. 예를 들면:
<pre><code class="language-python">b = bytes(100000) # alloc 100K bytes
</code></pre>
<ul>
<li>생성자는 다른 <code>bytes</code> 객체를 인자로 받을 수도 있습니다. 이것은 언피클링 구현 및 읽기/쓰기 <code>bytes</code> 객체를 읽기 전용으로 변환하는 데 유용할 것입니다. 선택적 두 번째 인수는 읽기 전용 <code>bytes</code> 객체 생성을 지정하는 데 사용됩니다.</li>
</ul>
</li>
<li><strong>C API:</strong> C API에서 <code>bytes</code> 객체는 다음 시그니처 중 하나를 사용하여 할당할 수 있습니다.
<pre><code class="language-c">PyObject* PyBytes_FromLength(LONG_LONG len, int readonly);
PyObject* PyBytes_FromPointer(void* ptr, LONG_LONG len, int readonly void (*dest)(void *ptr, void *user), void* user);
</code></pre>
<ul>
<li><code>PyBytes_FromPointer(...)</code> 함수에서 <code>dest</code> 함수 포인터가 <code>NULL</code>로 전달되면 호출되지 않습니다. 이는 정적으로 할당된 공간에서 <code>bytes</code> 객체를 생성하는 데만 사용해야 합니다.</li>
<li><code>user</code> 포인터는 다른 곳에서 클로저(closure)라고 불렸습니다. 이는 사용자가 어떤 목적으로든 사용할 수 있는 포인터입니다. 정리 시 소멸자 함수로 전달되며 여러 가지 유용하게 사용될 수 있습니다. <code>user</code> 포인터가 필요 없으면 <code>NULL</code>을 전달해야 합니다.</li>
</ul>
</li>
<li><strong>새로운 스타일 클래스:</strong> <code>bytes</code> 타입은 모든 표준 Python 타입이 향하는 방향인 새로운 스타일 클래스(new style class)가 될 것입니다.</li>
</ul>
<h3>기존 타입과의 대조 (Contrast to existing types)</h3>
<ul>
<li><strong><code>string</code> 객체:</strong> <code>bytes</code> 객체가 없었던 문제를 해결하는 가장 일반적인 방법은 <code>string</code> 객체를 대신 사용하는 것이었습니다. 바이너리 파일, <code>struct</code>/<code>array</code> 모듈 및 기타 여러 예시가 있습니다. 이러한 사용이 일반적으로 텍스트 문자열과 관련이 없다는 스타일 문제를 제쳐두고, <code>string</code>이 변경 불가능(immutable)하여 이러한 경우 반환된 데이터를 직접 조작할 수 없다는 실제 문제가 있습니다. 또한 <code>string</code> 모듈의 수많은 최적화(예: 해시 값 캐싱 또는 포인터 인턴화)는 확장 기능 작성자가 <code>string</code> 객체의 규칙을 어기려고 하면 매우 위험한 상황에 처하게 된다는 것을 의미합니다.</li>
<li><strong><code>buffer</code> 객체:</strong> <code>buffer</code> 객체는 <code>bytes</code> 객체가 충족하려는 목적을 다루기 위해 의도된 것처럼 보이지만, 구현의 몇 가지 단점 [1]으로 인해 많은 일반적인 경우에서 덜 유용했습니다. <code>buffer</code> 객체는 슬라이싱 동작에 대해 다른 선택을 했습니다(슬라이싱 및 다른 연산에 대해 <code>buffer</code> 대신 새 문자열을 반환함). 또한 <code>bytes</code> 객체가 하는 정렬(alignment) 또는 GIL 해제에 대한 많은 약속을 하지 않습니다.
<ul>
<li>또한 <code>buffer</code> 객체와 관련하여, <code>buffer</code> 객체를 <code>bytes</code> 객체로 단순히 교체하고 하위 호환성(backward compatibility)을 유지하는 것은 불가능합니다. <code>buffer</code> 객체는 다른 객체의 <code>PyBufferProcs</code>가 제공하는 포인터를 가져와 자신의 것으로 제공하는 메커니즘을 제공합니다. 다른 객체의 동작이 <code>bytes</code> 객체가 따르는 것과 동일한 엄격한 규칙을 따르도록 보장할 수 없으므로, <code>bytes</code> 객체가 사용될 수 있는 곳에서는 사용할 수 없습니다.</li>
</ul>
</li>
<li><strong><code>array</code> 모듈:</strong> <code>array</code> 모듈은 바이트 배열 생성을 지원하지만, 확장 기능이 제공하는 메모리에 포인터와 소멸자를 제공하는 C API를 제공하지 않습니다. 이로 인해 공유 메모리(shared memory) 또는 DMA 전송과 같은 특수한 정렬 또는 잠금을 가진 메모리에서 객체를 구성하는 데 사용할 수 없습니다. 또한 <code>array</code> 객체는 현재 pickling을 지원하지 않습니다. 마지막으로 <code>array</code> 객체는 <code>extend</code> 메서드를 통해 내용이 커질 수 있으므로, GIL이 유지되지 않은 채 사용되는 경우 포인터가 변경될 수 있습니다.
<ul>
<li><code>array</code> 객체에서 <code>buffer</code> 객체를 생성하는 것은 <code>array</code> 객체의 크기가 조정될 때 유효하지 않은 포인터를 남기는 동일한 문제를 가지고 있습니다.</li>
</ul>
</li>
<li><strong><code>mmap</code> 객체:</strong> <code>mmap</code> 객체는 특정 틈새 시장(niche)을 만족시키지만, 더 넓은 범주의 문제를 해결하려고 시도하지 않습니다.</li>
<li><strong>서드파티 확장:</strong> 표준 Python 타입의 임시 객체를 생성하지 않고는 어떤 서드파티 확장도 pickling을 구현할 수 없습니다. 예를 들어, Numeric 커뮤니티에서는 대규모 <code>array</code>가 <code>array</code> 데이터를 복제하기 위해 대규모 바이너리 문자열을 생성하지 않고는 pickling할 수 없다는 것이 불쾌한 일입니다.</li>
</ul>
<h3>하위 호환성 (Backward Compatibility)</h3>
<p>작성자가 인지하고 있는 하위 호환성 문제의 유일한 가능성은 새로운 <code>bytes</code> 타입을 포함하는 데이터를 언피클(unpickle)하려는 이전 버전의 Python에 있습니다.</p>
<h3>참조 구현 (Reference Implementation)</h3>
<p><strong>TODO:</strong> 실제 구현이 진행 중이지만, 이 PEP가 추가 검토를 받음에 따라 변경될 가능성이 있습니다.</p>
<p>다음 새 파일이 Python baseline에 추가될 것입니다.</p>
<ul>
<li><code>Include/bytesobject.h</code> (C 인터페이스)</li>
<li><code>Objects/bytesobject.c</code> (C 구현)</li>
<li><code>Lib/test/test_bytes.py</code> (단위 테스트)</li>
<li><code>Doc/lib/libbytes.tex</code> (문서화)</li>
</ul>
<p>다음 파일도 수정될 것입니다.</p>
<ul>
<li><code>Include/Python.h</code> (bytesmodule.h 포함 파일 추가)</li>
<li><code>Python/bltinmodule.c</code> (bytes 타입 객체 추가)</li>
<li><code>Modules/cPickle.c</code> (표준 타입에 bytes 추가)</li>
<li><code>Lib/pickle.py</code> (표준 타입에 bytes 추가)</li>
</ul>
<p>여러 다른 모듈이 <code>bytes</code> 객체를 기반으로 정리되고 구현될 수 있습니다. <code>mmap</code> 모듈이 먼저 떠오르지만, 위에서 언급했듯이 <code>array</code> 모듈을 순수 Python 모듈로 재구현하는 것도 가능할 것입니다. 이 PEP가 실제로 소스 코드의 양을 어느 정도 줄일 수 있다는 점은 매력적이지만, 작성자는 이것이 기존 애플리케이션을 손상시키는 불필요한 위험을 초래할 수 있으므로 현재로서는 피해야 한다고 생각합니다.</p>
<h3>추가 노트/코멘트 (Additional Notes/Comments)</h3>
<ul>
<li><strong>Guido van Rossum</strong>은 <code>mmap</code> 객체로부터 <code>bytes</code> 객체를 생성할 수 있는 것이 합리적인지 궁금해했습니다. <code>mmap</code> 객체는 <code>bytes</code> 객체에 메모리를 제공하는 데 필요한 요구 사항을 지원하는 것으로 보입니다. (크기가 조정되지 않고 포인터는 객체의 수명 동안 유효합니다.) 따라서 <code>mmap</code> 모듈에 <code>bytes</code> 객체를 <code>mmap</code> 객체로부터 직접 생성할 수 있는 메서드를 추가할 수 있습니다. 이것이 어떻게 구현될지에 대한 초기 시도는 위에 설명된 <code>PyBytes_FromPointer()</code> 함수를 사용하고 <code>mmap_object</code>를 <code>user</code> 포인터로 전달하는 것입니다. 소멸자 함수는 정리 시 <code>mmap_object</code>의 참조 카운트를 감소(decref)시킬 것입니다.</li>
<li><strong>Todd Miller</strong>는 <code>PyObject_AsLargeReadBuffer()</code> 및 <code>PyObject_AsLargeWriteBuffer</code>라는 두 개의 새로운 함수가 유용할 수 있다고 언급합니다. 이 함수들은 <code>PyObject_AsReadBuffer()</code> 및 <code>PyObject_AsWriteBuffer()</code>와 유사하지만, <code>void*</code> 포인터 외에 <code>LONG_LONG</code> 길이를 얻는 것을 지원합니다. 이 함수들은 확장 기능 작성자가 <code>bytes</code> 객체(LONG_LONG 길이를 지원) 및 대부분의 다른 버퍼 유사 객체(int 길이만 지원)와 투명하게 작업할 수 있도록 허용할 것입니다. 이 함수들은 특정 <code>PyByte_GetReadBuffer()</code> 및 <code>PyBytes_GetWriteBuffer()</code> 함수를 생성하는 대신 또는 추가로 사용될 수 있습니다.
<ul>
<li><strong>TODO:</strong> 작성자는 이것이 다른 객체들이 결국 대용량(64비트) 포인터를 지원할 수 있는 길을 열어주며 <code>abstract.c</code>와 <code>abstract.h</code>에만 영향을 미칠 것이므로 매우 좋은 아이디어라고 생각합니다. 이것을 위에 추가해야 할까요?</li>
</ul>
</li>
<li><code>PyBufferProcs</code> 인터페이스의 세그먼트 카운트(segment count)를 남용하여 길이의 31비트 제한을 우회하는 것은 좋은 해킹(hack)이 아니라는 점에 일반적으로 동의했습니다. 이것이 무엇을 의미하는지 모른다면, 당신은 좋은 동료들과 함께 있는 것입니다. Python baseline의 대부분 코드와 아마도 많은 서드파티 확장 기능에서 세그먼트 카운트가 1이 아닐 경우 포기합니다.</li>
</ul>
<h3>참조 (References)</h3>
<ul>
<li>[1] The buffer interface <code>https://mail.python.org/pipermail/python-dev/2000-October/009974.html</code></li>
</ul>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d79d6340e7770dba.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/296\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"jf5MDuRUbMNVvRN9tv5rq\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/296/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/296\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"296\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/296\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T576f,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0296/\"\u003ePEP 296 - Adding a bytes Object Type\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Withdrawn | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 12-Jul-2002\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 296은 Python 2.3 버전을 위해 \u003ccode\u003ebytes\u003c/code\u003e 객체 타입 추가를 제안했던 문서입니다. 이 제안은 나중에 PEP 358로 대체되어 철회(Withdrawn)되었습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003ePEP 296 – \u003ccode\u003ebytes\u003c/code\u003e 객체 타입 추가\u003c/h2\u003e\n\u003ch3\u003e공지 (Notice)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 작성자에 의해 철회되었습니다 (PEP 358 선호).\u003c/p\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 'bytes'라는 새로운 표준 타입과 내장 생성자(builtin constructor) 생성을 제안합니다. \u003ccode\u003ebytes\u003c/code\u003e 객체는 효율적으로 저장되는 바이트 배열이며, 유사한 다른 구현체들과 차별화되는 몇 가지 추가적인 특성을 가집니다.\u003c/p\u003e\n\u003ch3\u003e배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003e현재 Python에는 이 제안의 \u003ccode\u003ebytes\u003c/code\u003e 객체와 유사한 기능을 구현하는 많은 객체가 있습니다. 예를 들어, 표준 \u003ccode\u003estring\u003c/code\u003e, \u003ccode\u003ebuffer\u003c/code\u003e, \u003ccode\u003earray\u003c/code\u003e, 그리고 \u003ccode\u003emmap\u003c/code\u003e 객체는 모두 `bytes`` 객체와 여러 면에서 매우 유사합니다. 또한, 여러 중요한 서드파티 확장 기능들이 유사한 요구를 충족하기 위해 비슷한 객체를 만들었습니다. 안타깝게도, 이러한 각 객체는 범위가 너무 좁고 더 넓은 범주의 문제에 적용하기에 중요한 기능들이 부족합니다.\u003c/p\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ebytes\u003c/code\u003e 객체는 다음과 같은 중요한 특성을 가집니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e효율적인 내부 배열 저장:\u003c/strong\u003e 표준 C 타입인 \"unsigned char\"를 통해 효율적인 내부 배열 저장을 제공합니다. 이를 통해 할당되는 메모리 양을 세밀하게 제어할 수 있습니다. 다음 항목에 명시된 정렬(alignment) 제약 조건과 함께, 저수준(low level) 확장 기능이 필요에 따라 포인터를 다른 타입으로 캐스팅하는 것이 쉽습니다.\n\u003cul\u003e\n\u003cli\u003e객체가 바이트 배열로 구현되어 있으므로, 현재 문자열(string)과 함께 작동하는 표준 라이브러리의 광범위한 루틴 라이브러리에 \u003ccode\u003ebytes\u003c/code\u003e 객체를 전달할 수 있습니다. 예를 들어, \u003ccode\u003estruct\u003c/code\u003e 모듈과 함께 \u003ccode\u003ebytes\u003c/code\u003e 객체를 사용하면 순수 Python 스크립트만으로 \u003ccode\u003earray\u003c/code\u003e 모듈을 완전히 대체할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e네이티브 8비트 \u003ccode\u003eunsigned\u003c/code\u003e 타입이 없는 특이한 플랫폼이 발견된다 하더라도, 객체는 Python 스크립트 레벨에서 8비트 \u003ccode\u003eunsigned\u003c/code\u003e 값의 배열인 것처럼 자신을 표현하기 위해 최선을 다할 것입니다. 많은 확장 기능이 이를 올바르게 처리할지는 의문이지만, 이러한 경우 Python 스크립트는 이식성(portable)을 가질 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e할당된 바이트 배열의 정렬:\u003c/strong\u003e \u003ccode\u003emalloc\u003c/code\u003e의 플랫폼 구현이 약속하는 대로 정렬됩니다. 확장 기능에서 생성된 \u003ccode\u003ebytes\u003c/code\u003e 객체는 확장 기능 작성자가 적절하다고 판단하는 임의의 정렬을 제공할 수 있습니다.\n\u003cul\u003e\n\u003cli\u003e이러한 정렬 제약 조건은 \u003ccode\u003ebytes\u003c/code\u003e 객체가 모든 표준 C 타입, 예를 들어 \u003ccode\u003ePyComplex\u003c/code\u003e 객체나 표준 C 타입으로 구성된 다른 \u003ccode\u003estruct\u003c/code\u003e들의 저장소로 사용될 수 있도록 허용해야 합니다. 추가적인 정렬 제약 조건은 필요에 따라 확장 기능에서 제공될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e시퀀스 연산(Sequence Operations) 지원:\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e 객체는 \u003ccode\u003estring\u003c/code\u003e/\u003ccode\u003earray\u003c/code\u003e 객체에서 제공하는 시퀀스 연산의 부분 집합을 구현하지만, 일부 경우에 약간 다른 의미(semantics)를 가집니다.\n\u003cul\u003e\n\u003cli\u003e특히, 슬라이스(slice)는 항상 새로운 \u003ccode\u003ebytes\u003c/code\u003e 객체를 반환하지만, 내부 메모리는 두 객체 간에 공유됩니다. 이러한 종류의 슬라이스 동작은 \"뷰(view)\"를 생성한다고 불립니다.\u003c/li\u003e\n\u003cli\u003e또한, \u003ccode\u003ebytes\u003c/code\u003e 객체에 대한 반복(repetition) 및 연결(concatenation)은 정의되지 않으며 예외(exception)를 발생시킵니다.\u003c/li\u003e\n\u003cli\u003e이러한 객체는 고성능 애플리케이션에서 사용될 가능성이 높기 때문에, 뷰 슬라이싱(view slicing) 사용 결정의 동기 중 하나는 \u003ccode\u003ebytes\u003c/code\u003e 객체 간의 복사(copying)가 매우 효율적이어야 하며 임시 객체 생성을 필요로 하지 않아야 한다는 것입니다. 다음 코드는 이를 보여줍니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# create two 10 Meg bytes objects\nb1 = bytes(10000000)\nb2 = bytes(10000000)\n# copy from part of one to another with out creating a 1 Meg temporary\nb1[2000000:3000000] = b2[4000000:5000000]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003eRvalue의 길이가 Lvalue의 길이와 같지 않은 슬라이스 할당(slice assignment)은 예외를 발생시킵니다. 그러나 슬라이스 할당은 겹치는 슬라이스(memmove로 일반적으로 구현됨)에서도 올바르게 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePickle 및 cPickle 지원:\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e 객체는 효율적인 직렬화(serialization)를 위해 \u003ccode\u003epickle\u003c/code\u003e 및 \u003ccode\u003ecPickle\u003c/code\u003e 모듈에 의해 네이티브 타입으로 인식됩니다. (실제로, 이것은 서드파티 확장 기능으로는 구현할 수 없는 유일한 요구 사항입니다.)\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebytes\u003c/code\u003e와 유사한 객체에 저장된 데이터를 임시 복사본을 문자열로 만들지 않고 직렬화해야 하는 요구를 해결하기 위한 부분적인 솔루션이 과거에 구현되었습니다. \u003ccode\u003earray\u003c/code\u003e 객체의 \u003ccode\u003etofile\u003c/code\u003e 및 \u003ccode\u003efromfile\u003c/code\u003e 메서드가 좋은 예시입니다. \u003ccode\u003ebytes\u003c/code\u003e 객체도 이러한 메서드를 지원할 것입니다.\u003c/li\u003e\n\u003cli\u003e그러나 pickling은 \u003ccode\u003eshelve\u003c/code\u003e 모듈이나 Python 객체의 RPC 구현과 같은 다른 상황에서도 유용하며, 효율적인 데이터 전송을 위해 최종 사용자가 두 가지 다른 직렬화 메커니즘을 사용하도록 요구하는 것은 바람직하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTODO:\u003c/strong\u003e 이전 버전의 Python이 \u003ccode\u003ebytes\u003c/code\u003e 객체를 \u003ccode\u003estring\u003c/code\u003e 객체로 언피클(unpickle)하도록 새로운 \u003ccode\u003ebytes\u003c/code\u003e 객체의 pickling을 구현하려고 노력할 것입니다.\u003c/li\u003e\n\u003cli\u003e언피클링 시, \u003ccode\u003ebytes\u003c/code\u003e 객체는 Python에서 할당된 메모리(malloc을 통해)로부터 생성됩니다. 따라서 확장 기능이 제공한 포인터가 제공했을 수 있는 추가 속성(특수 정렬 또는 특수 메모리 타입)을 잃게 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTODO:\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e 타입의 C 서브클래스가 언피클될 메모리를 제공할 수 있도록 만들려고 노력할 것입니다. 예를 들어, \u003ccode\u003ePageAlignedBytes\u003c/code\u003e라는 파생 클래스는 페이지 정렬된 메모리로 언피클될 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint\u003c/code\u003e가 32비트인 모든 플랫폼(대부분의 경우)에서, 현재 31비트로 표현할 수 있는 길이보다 큰 문자열을 생성하는 것은 불가능합니다. 따라서 연산이 불가능할 때 \u003ccode\u003estring\u003c/code\u003e으로 pickling하는 것은 예외를 발생시킵니다.\u003c/li\u003e\n\u003cli\u003e적어도 대용량 파일(large file)을 지원하는 플랫폼(대부분)에서는 \u003ccode\u003efile.write()\u003c/code\u003e 메서드를 반복적으로 호출하여 대용량 \u003ccode\u003ebytes\u003c/code\u003e 객체를 파일로 pickling하는 것이 가능해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePyBufferProcs 인터페이스 지원:\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e 타입은 \u003ccode\u003ePyBufferProcs\u003c/code\u003e 인터페이스를 지원하지만, \u003ccode\u003ebytes\u003c/code\u003e 객체는 \u003ccode\u003ebytes\u003c/code\u003e 객체에 대한 참조가 유지되는 한 포인터가 할당 해제(deallocated)되거나 재할당(reallocated)되지 않는다는 추가적인 보장을 제공합니다.\n\u003cul\u003e\n\u003cli\u003e이는 \u003ccode\u003ebytes\u003c/code\u003e 객체가 일단 생성되면 크기 변경이 불가능하다(not resizable)는 것을 의미하지만, \u003ccode\u003ePyBytes_Check(...)\u003c/code\u003e 테스트가 통과되면 별도의 스레드가 가리키는 메모리를 조작하는 동안 전역 인터프리터 락(GIL)을 해제할 수 있도록 허용합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebytes\u003c/code\u003e 객체의 이러한 특성은 비동기 파일 I/O 또는 다중 프로세서(multiprocessor) 머신과 같이 \u003ccode\u003ePyBufferProcs\u003c/code\u003e에 의해 얻은 포인터가 전역 인터프리터 락과 독립적으로 사용되는 상황에서 사용될 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003eGIL이 해제된 후 포인터가 재할당되거나 해제될 수 없다는 것을 알면 확장 기능 작성자는 진정한 동시성(concurrency)을 얻고 포인터에 대한 장기 실행 계산을 위해 추가 프로세서를 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eC/C++ 확장 기능에서, \u003ccode\u003ebytes\u003c/code\u003e 객체는 제공된 포인터(pointer)와 소멸자(destructor) 함수로부터 생성될 수 있으며, 참조 카운트(reference count)가 0이 되면 메모리를 해제합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebytes\u003c/code\u003e 객체의 슬라이싱에 대한 특별한 구현은 여러 \u003ccode\u003ebytes\u003c/code\u003e 객체가 동일한 포인터/소멸자를 참조할 수 있도록 합니다. 따라서 실제 포인터/소멸자에 대한 참조 카운트가 유지됩니다. 이 참조 카운트는 일반적으로 Python 객체와 관련된 참조 카운트와는 별개입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTODO:\u003c/strong\u003e 내부 참조 카운트 객체를 실제 Python 객체로 노출하는 것이 바람직할 수 있습니다. 좋은 사용 사례가 발생하면, 나중에 하위 호환성 손실 없이 구현하는 것이 가능해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e읽기 전용(\u003ccode\u003ereadonly\u003c/code\u003e) \u003ccode\u003ebytes\u003c/code\u003e 객체:\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e 객체를 읽기 전용으로 표시하는 것도 가능하며, 이 경우 실제로는 변경 불가능(immutable)하지만 \u003ccode\u003ebytes\u003c/code\u003e 객체의 다른 기능들을 제공합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLONG_LONG 타입 길이 추적:\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e 객체는 Python \u003ccode\u003eLONG_LONG\u003c/code\u003e 타입으로 데이터의 길이를 추적합니다. \u003ccode\u003ePyBufferProcs\u003c/code\u003e의 현재 정의가 길이를 \u003ccode\u003eint\u003c/code\u003e 크기로 제한하더라도, 이 PEP는 그 부분에 변경을 제안하지 않습니다. 대신, 확장 기능은 명시적인 \u003ccode\u003ePyBytes_Check(...)\u003c/code\u003e 호출을 통해 이 제한을 우회할 수 있으며, 성공하면 \u003ccode\u003ePyBytes_GetReadBuffer(...)\u003c/code\u003e 또는 \u003ccode\u003ePyBytes_GetWriteBuffer\u003c/code\u003e 호출을 통해 객체의 포인터와 전체 길이를 \u003ccode\u003eLONG_LONG\u003c/code\u003e으로 얻을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e예외 발생:\u003c/strong\u003e 표준 \u003ccode\u003ePyBufferProcs\u003c/code\u003e 메커니즘이 사용되고 \u003ccode\u003ebytes\u003c/code\u003e 객체의 크기가 \u003ccode\u003eint\u003c/code\u003e로 표현할 수 있는 크기보다 큰 경우 \u003ccode\u003ebytes\u003c/code\u003e 객체는 예외를 발생시킬 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 스크립팅에서:\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e 객체는 \u003ccode\u003elong\u003c/code\u003e으로 인덱싱(subscriptable)될 수 있어 32비트 \u003ccode\u003eint\u003c/code\u003e 제한을 피할 수 있습니다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elen()\u003c/code\u003e 함수는 \u003ccode\u003ePyObject_Size()\u003c/code\u003e이며 \u003ccode\u003eint\u003c/code\u003e를 반환하므로 여전히 문제가 있습니다. 해결책으로 \u003ccode\u003ebytes\u003c/code\u003e 객체는 \u003ccode\u003elong\u003c/code\u003e을 반환하는 \u003ccode\u003e.length()\u003c/code\u003e 메서드를 제공할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성자:\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e 객체는 Python 스크립팅 레벨에서 할당할 바이트 수를 \u003ccode\u003eint\u003c/code\u003e/\u003ccode\u003elong\u003c/code\u003e으로 \u003ccode\u003ebytes\u003c/code\u003e 생성자에 전달하여 생성할 수 있습니다. 예를 들면:\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eb = bytes(100000) # alloc 100K bytes\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e생성자는 다른 \u003ccode\u003ebytes\u003c/code\u003e 객체를 인자로 받을 수도 있습니다. 이것은 언피클링 구현 및 읽기/쓰기 \u003ccode\u003ebytes\u003c/code\u003e 객체를 읽기 전용으로 변환하는 데 유용할 것입니다. 선택적 두 번째 인수는 읽기 전용 \u003ccode\u003ebytes\u003c/code\u003e 객체 생성을 지정하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eC API:\u003c/strong\u003e C API에서 \u003ccode\u003ebytes\u003c/code\u003e 객체는 다음 시그니처 중 하나를 사용하여 할당할 수 있습니다.\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003ePyObject* PyBytes_FromLength(LONG_LONG len, int readonly);\nPyObject* PyBytes_FromPointer(void* ptr, LONG_LONG len, int readonly void (*dest)(void *ptr, void *user), void* user);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyBytes_FromPointer(...)\u003c/code\u003e 함수에서 \u003ccode\u003edest\u003c/code\u003e 함수 포인터가 \u003ccode\u003eNULL\u003c/code\u003e로 전달되면 호출되지 않습니다. 이는 정적으로 할당된 공간에서 \u003ccode\u003ebytes\u003c/code\u003e 객체를 생성하는 데만 사용해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euser\u003c/code\u003e 포인터는 다른 곳에서 클로저(closure)라고 불렸습니다. 이는 사용자가 어떤 목적으로든 사용할 수 있는 포인터입니다. 정리 시 소멸자 함수로 전달되며 여러 가지 유용하게 사용될 수 있습니다. \u003ccode\u003euser\u003c/code\u003e 포인터가 필요 없으면 \u003ccode\u003eNULL\u003c/code\u003e을 전달해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e새로운 스타일 클래스:\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e 타입은 모든 표준 Python 타입이 향하는 방향인 새로운 스타일 클래스(new style class)가 될 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e기존 타입과의 대조 (Contrast to existing types)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003estring\u003c/code\u003e 객체:\u003c/strong\u003e \u003ccode\u003ebytes\u003c/code\u003e 객체가 없었던 문제를 해결하는 가장 일반적인 방법은 \u003ccode\u003estring\u003c/code\u003e 객체를 대신 사용하는 것이었습니다. 바이너리 파일, \u003ccode\u003estruct\u003c/code\u003e/\u003ccode\u003earray\u003c/code\u003e 모듈 및 기타 여러 예시가 있습니다. 이러한 사용이 일반적으로 텍스트 문자열과 관련이 없다는 스타일 문제를 제쳐두고, \u003ccode\u003estring\u003c/code\u003e이 변경 불가능(immutable)하여 이러한 경우 반환된 데이터를 직접 조작할 수 없다는 실제 문제가 있습니다. 또한 \u003ccode\u003estring\u003c/code\u003e 모듈의 수많은 최적화(예: 해시 값 캐싱 또는 포인터 인턴화)는 확장 기능 작성자가 \u003ccode\u003estring\u003c/code\u003e 객체의 규칙을 어기려고 하면 매우 위험한 상황에 처하게 된다는 것을 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ebuffer\u003c/code\u003e 객체:\u003c/strong\u003e \u003ccode\u003ebuffer\u003c/code\u003e 객체는 \u003ccode\u003ebytes\u003c/code\u003e 객체가 충족하려는 목적을 다루기 위해 의도된 것처럼 보이지만, 구현의 몇 가지 단점 [1]으로 인해 많은 일반적인 경우에서 덜 유용했습니다. \u003ccode\u003ebuffer\u003c/code\u003e 객체는 슬라이싱 동작에 대해 다른 선택을 했습니다(슬라이싱 및 다른 연산에 대해 \u003ccode\u003ebuffer\u003c/code\u003e 대신 새 문자열을 반환함). 또한 \u003ccode\u003ebytes\u003c/code\u003e 객체가 하는 정렬(alignment) 또는 GIL 해제에 대한 많은 약속을 하지 않습니다.\n\u003cul\u003e\n\u003cli\u003e또한 \u003ccode\u003ebuffer\u003c/code\u003e 객체와 관련하여, \u003ccode\u003ebuffer\u003c/code\u003e 객체를 \u003ccode\u003ebytes\u003c/code\u003e 객체로 단순히 교체하고 하위 호환성(backward compatibility)을 유지하는 것은 불가능합니다. \u003ccode\u003ebuffer\u003c/code\u003e 객체는 다른 객체의 \u003ccode\u003ePyBufferProcs\u003c/code\u003e가 제공하는 포인터를 가져와 자신의 것으로 제공하는 메커니즘을 제공합니다. 다른 객체의 동작이 \u003ccode\u003ebytes\u003c/code\u003e 객체가 따르는 것과 동일한 엄격한 규칙을 따르도록 보장할 수 없으므로, \u003ccode\u003ebytes\u003c/code\u003e 객체가 사용될 수 있는 곳에서는 사용할 수 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003earray\u003c/code\u003e 모듈:\u003c/strong\u003e \u003ccode\u003earray\u003c/code\u003e 모듈은 바이트 배열 생성을 지원하지만, 확장 기능이 제공하는 메모리에 포인터와 소멸자를 제공하는 C API를 제공하지 않습니다. 이로 인해 공유 메모리(shared memory) 또는 DMA 전송과 같은 특수한 정렬 또는 잠금을 가진 메모리에서 객체를 구성하는 데 사용할 수 없습니다. 또한 \u003ccode\u003earray\u003c/code\u003e 객체는 현재 pickling을 지원하지 않습니다. 마지막으로 \u003ccode\u003earray\u003c/code\u003e 객체는 \u003ccode\u003eextend\u003c/code\u003e 메서드를 통해 내용이 커질 수 있으므로, GIL이 유지되지 않은 채 사용되는 경우 포인터가 변경될 수 있습니다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003earray\u003c/code\u003e 객체에서 \u003ccode\u003ebuffer\u003c/code\u003e 객체를 생성하는 것은 \u003ccode\u003earray\u003c/code\u003e 객체의 크기가 조정될 때 유효하지 않은 포인터를 남기는 동일한 문제를 가지고 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003emmap\u003c/code\u003e 객체:\u003c/strong\u003e \u003ccode\u003emmap\u003c/code\u003e 객체는 특정 틈새 시장(niche)을 만족시키지만, 더 넓은 범주의 문제를 해결하려고 시도하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e서드파티 확장:\u003c/strong\u003e 표준 Python 타입의 임시 객체를 생성하지 않고는 어떤 서드파티 확장도 pickling을 구현할 수 없습니다. 예를 들어, Numeric 커뮤니티에서는 대규모 \u003ccode\u003earray\u003c/code\u003e가 \u003ccode\u003earray\u003c/code\u003e 데이터를 복제하기 위해 대규모 바이너리 문자열을 생성하지 않고는 pickling할 수 없다는 것이 불쾌한 일입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e하위 호환성 (Backward Compatibility)\u003c/h3\u003e\n\u003cp\u003e작성자가 인지하고 있는 하위 호환성 문제의 유일한 가능성은 새로운 \u003ccode\u003ebytes\u003c/code\u003e 타입을 포함하는 데이터를 언피클(unpickle)하려는 이전 버전의 Python에 있습니다.\u003c/p\u003e\n\u003ch3\u003e참조 구현 (Reference Implementation)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eTODO:\u003c/strong\u003e 실제 구현이 진행 중이지만, 이 PEP가 추가 검토를 받음에 따라 변경될 가능성이 있습니다.\u003c/p\u003e\n\u003cp\u003e다음 새 파일이 Python baseline에 추가될 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eInclude/bytesobject.h\u003c/code\u003e (C 인터페이스)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eObjects/bytesobject.c\u003c/code\u003e (C 구현)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLib/test/test_bytes.py\u003c/code\u003e (단위 테스트)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDoc/lib/libbytes.tex\u003c/code\u003e (문서화)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 파일도 수정될 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eInclude/Python.h\u003c/code\u003e (bytesmodule.h 포함 파일 추가)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePython/bltinmodule.c\u003c/code\u003e (bytes 타입 객체 추가)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eModules/cPickle.c\u003c/code\u003e (표준 타입에 bytes 추가)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLib/pickle.py\u003c/code\u003e (표준 타입에 bytes 추가)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e여러 다른 모듈이 \u003ccode\u003ebytes\u003c/code\u003e 객체를 기반으로 정리되고 구현될 수 있습니다. \u003ccode\u003emmap\u003c/code\u003e 모듈이 먼저 떠오르지만, 위에서 언급했듯이 \u003ccode\u003earray\u003c/code\u003e 모듈을 순수 Python 모듈로 재구현하는 것도 가능할 것입니다. 이 PEP가 실제로 소스 코드의 양을 어느 정도 줄일 수 있다는 점은 매력적이지만, 작성자는 이것이 기존 애플리케이션을 손상시키는 불필요한 위험을 초래할 수 있으므로 현재로서는 피해야 한다고 생각합니다.\u003c/p\u003e\n\u003ch3\u003e추가 노트/코멘트 (Additional Notes/Comments)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGuido van Rossum\u003c/strong\u003e은 \u003ccode\u003emmap\u003c/code\u003e 객체로부터 \u003ccode\u003ebytes\u003c/code\u003e 객체를 생성할 수 있는 것이 합리적인지 궁금해했습니다. \u003ccode\u003emmap\u003c/code\u003e 객체는 \u003ccode\u003ebytes\u003c/code\u003e 객체에 메모리를 제공하는 데 필요한 요구 사항을 지원하는 것으로 보입니다. (크기가 조정되지 않고 포인터는 객체의 수명 동안 유효합니다.) 따라서 \u003ccode\u003emmap\u003c/code\u003e 모듈에 \u003ccode\u003ebytes\u003c/code\u003e 객체를 \u003ccode\u003emmap\u003c/code\u003e 객체로부터 직접 생성할 수 있는 메서드를 추가할 수 있습니다. 이것이 어떻게 구현될지에 대한 초기 시도는 위에 설명된 \u003ccode\u003ePyBytes_FromPointer()\u003c/code\u003e 함수를 사용하고 \u003ccode\u003emmap_object\u003c/code\u003e를 \u003ccode\u003euser\u003c/code\u003e 포인터로 전달하는 것입니다. 소멸자 함수는 정리 시 \u003ccode\u003emmap_object\u003c/code\u003e의 참조 카운트를 감소(decref)시킬 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTodd Miller\u003c/strong\u003e는 \u003ccode\u003ePyObject_AsLargeReadBuffer()\u003c/code\u003e 및 \u003ccode\u003ePyObject_AsLargeWriteBuffer\u003c/code\u003e라는 두 개의 새로운 함수가 유용할 수 있다고 언급합니다. 이 함수들은 \u003ccode\u003ePyObject_AsReadBuffer()\u003c/code\u003e 및 \u003ccode\u003ePyObject_AsWriteBuffer()\u003c/code\u003e와 유사하지만, \u003ccode\u003evoid*\u003c/code\u003e 포인터 외에 \u003ccode\u003eLONG_LONG\u003c/code\u003e 길이를 얻는 것을 지원합니다. 이 함수들은 확장 기능 작성자가 \u003ccode\u003ebytes\u003c/code\u003e 객체(LONG_LONG 길이를 지원) 및 대부분의 다른 버퍼 유사 객체(int 길이만 지원)와 투명하게 작업할 수 있도록 허용할 것입니다. 이 함수들은 특정 \u003ccode\u003ePyByte_GetReadBuffer()\u003c/code\u003e 및 \u003ccode\u003ePyBytes_GetWriteBuffer()\u003c/code\u003e 함수를 생성하는 대신 또는 추가로 사용될 수 있습니다.\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTODO:\u003c/strong\u003e 작성자는 이것이 다른 객체들이 결국 대용량(64비트) 포인터를 지원할 수 있는 길을 열어주며 \u003ccode\u003eabstract.c\u003c/code\u003e와 \u003ccode\u003eabstract.h\u003c/code\u003e에만 영향을 미칠 것이므로 매우 좋은 아이디어라고 생각합니다. 이것을 위에 추가해야 할까요?\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyBufferProcs\u003c/code\u003e 인터페이스의 세그먼트 카운트(segment count)를 남용하여 길이의 31비트 제한을 우회하는 것은 좋은 해킹(hack)이 아니라는 점에 일반적으로 동의했습니다. 이것이 무엇을 의미하는지 모른다면, 당신은 좋은 동료들과 함께 있는 것입니다. Python baseline의 대부분 코드와 아마도 많은 서드파티 확장 기능에서 세그먼트 카운트가 1이 아닐 경우 포기합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e참조 (References)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e[1] The buffer interface \u003ccode\u003ehttps://mail.python.org/pipermail/python-dev/2000-October/009974.html\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Withdrawn] PEP 296 - Adding a bytes Object Type\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 18:05:57+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>