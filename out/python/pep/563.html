<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/edb8d4ad4fe2f3b0.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-4b0d66bdf1ba1813.js" async=""></script><script src="/_next/static/chunks/23-41c976638cd1a58c.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-ee5764c1002761f9.js" async=""></script><script src="/_next/static/chunks/132-273e49420772df1e.js" async=""></script><script src="/_next/static/chunks/app/layout-d443cbc354279241.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-ef33f0f4c1a350bd.js" async=""></script><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY" as="script"/><title>[Superseded] PEP 563 - Postponed Evaluation of Annotations - secrett2633&#x27;s blog</title><meta name="description" content="Python Enhancement Proposal 563: &#x27;Postponed Evaluation of Annotations&#x27;에 대한 한국어 번역입니다."/><meta name="author" content="secrett2633"/><link rel="manifest" href="/manifest.json" crossorigin="use-credentials"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/python/pep/563"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="[Superseded] PEP 563 - Postponed Evaluation of Annotations"/><meta property="og:description" content="Python Enhancement Proposal 563: &#x27;Postponed Evaluation of Annotations&#x27;에 대한 한국어 번역입니다."/><meta property="og:url" content="https://blog.secrett2633.cloud/python/pep/563"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2025-09-26T14:48:31.000Z"/><meta property="article:modified_time" content="2025-09-26T14:48:31.000Z"/><meta property="article:author" content="secrett2633"/><meta property="article:section" content="Python"/><meta property="article:tag" content="Python"/><meta property="article:tag" content="PEP"/><meta property="article:tag" content="Translation"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:creator" content="@secrett2633"/><meta name="twitter:title" content="[Superseded] PEP 563 - Postponed Evaluation of Annotations"/><meta name="twitter:description" content="Python Enhancement Proposal 563: &#x27;Postponed Evaluation of Annotations&#x27;에 대한 한국어 번역입니다."/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><link rel="dns-prefetch" href="https://www.googletagmanager.com"/><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"/><link rel="dns-prefetch" href="https://giscus.app"/><link rel="preconnect" href="https://giscus.app" crossorigin="anonymous"/><meta http-equiv="X-Content-Type-Options" content="nosniff"/><meta name="referrer" content="strict-origin-when-cross-origin"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"WebSite","name":"secrett2633's blog","url":"https://blog.secrett2633.cloud","description":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트","inLanguage":"ko","publisher":{"@type":"Person","name":"secrett2633","url":"https://blog.secrett2633.cloud"}}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"Person","name":"secrett2633","url":"https://blog.secrett2633.cloud","sameAs":["https://github.com/secrett2633"]}</script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><a href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:z-50 focus:p-4 focus:bg-white focus:text-blue-600">본문으로 건너뛰기</a><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav" aria-label="메인 네비게이션"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button" aria-label="검색"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main id="main-content" class="initial-content"><!--$--><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Superseded] PEP 563 - Postponed Evaluation of Annotations","description":"Python Enhancement Proposal 563: 'Postponed Evaluation of Annotations'에 대한 한국어 번역입니다.","url":"https://blog.secrett2633.cloud/python/pep/563","datePublished":"2025-09-26T14:48:31.000Z","dateModified":"2025-09-26T14:48:31.000Z","author":{"@type":"Person","name":"secrett2633","url":"https://blog.secrett2633.cloud"},"publisher":{"@type":"Person","name":"secrett2633","url":"https://blog.secrett2633.cloud"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.secrett2633.cloud/python/pep/563"},"image":"https://blog.secrett2633.cloud/og-default.png","isAccessibleForFree":true,"inLanguage":"ko","wordCount":2942,"articleSection":"Python","keywords":"Python, PEP, Translation"}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"홈","item":"https://blog.secrett2633.cloud/"},{"@type":"ListItem","position":2,"name":"[Superseded] PEP 563 - Postponed Evaluation of Annotations","item":"https://blog.secrett2633.cloud/python/pep/563"}]}</script><div class="space-y-6"><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4" aria-label="카테고리 네비게이션"><div><p class="font-medium text-gray-900 mb-2">Backend</p><ul class="space-y-1 ml-4"><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/backend/django">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/backend/logging">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><p class="font-medium text-gray-900 mb-2">Python</p><ul class="space-y-1 ml-4"><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/python/pep">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><p class="font-medium text-gray-900 mb-2">AI/ML</p><ul class="space-y-1 ml-4"><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/ai/llm">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/ai/review">Review<!-- --> (<!-- -->2741<!-- -->)</a></li></ul></div><div><p class="font-medium text-gray-900 mb-2">DevOps</p><ul class="space-y-1 ml-4"><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/nginx">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/docker">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/safeline">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/jenkins">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/github-actions">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/devops/aws">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><p class="font-medium text-gray-900 mb-2">etc</p><ul class="space-y-1 ml-4"><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/etc/me">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a class="text-sm text-gray-600 hover:text-primary-600 block py-1" href="/etc/chrome-extension">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><div class="flex-1"><nav aria-label="breadcrumb" class="text-sm text-gray-500 mb-4"><ol class="flex flex-wrap items-center gap-1"><li><a class="hover:text-gray-700" href="/">홈</a></li><li class="flex items-center gap-1"><span aria-hidden="true">/</span><span class="text-gray-900" aria-current="page">[Superseded] PEP 563 - Postponed Evaluation of Annotations</span></li></ol></nav><article class="page"><header class="mb-8"><h1 class="page__title">[Superseded] PEP 563 - Postponed Evaluation of Annotations</h1><div class="page__meta"><time dateTime="2025-09-26 23:48:31+0900">2025년 9월 26일</time><time class="ml-4" dateTime="2025-09-26T14:48:31.000Z">수정: <!-- -->2025년 9월 26일</time></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0563/" target="_blank" rel="noopener noreferrer">PEP 563 - Postponed Evaluation of Annotations</a></p>
<p><strong>상태:</strong> Superseded | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 08-Sep-2017</p>
</blockquote>
<h2 id="pep-563-어노테이션-지연-평가-postponed-evaluation-of-annotations"><a href="#pep-563-어노테이션-지연-평가-postponed-evaluation-of-annotations">PEP 563 – 어노테이션 지연 평가 (Postponed Evaluation of Annotations)</a></h2>
<p><strong>상태:</strong> 이 PEP에서 제안된 기능은 기본 동작이 되지 못했으며, PEP 649 및 PEP 749에서 제안된 어노테이션의 지연된 평가로 대체되었습니다.</p>
<h3 id="개요-abstract"><a href="#개요-abstract">개요 (Abstract)</a></h3>
<p>PEP 3107은 함수 어노테이션을 위한 구문을 도입했지만, 그 의미는 의도적으로 정의되지 않은 채로 남겨두었습니다. PEP 484는 어노테이션에 표준적인 의미인 "타입 힌트 (type hints)"를 부여했습니다. PEP 526은 변수 어노테이션을 정의하며, 이를 타입 힌트 사용 사례와 명시적으로 연결했습니다.</p>
<p>PEP 563은 함수 및 변수 어노테이션이 더 이상 함수 정의 시점에 평가되지 않도록 변경할 것을 제안합니다. 대신, 어노테이션은 <code>__annotations__</code>에 문자열 형태로 보존됩니다. 이 변경 사항은 Python 3.7부터 <code>__future__</code> import를 통해 점진적으로 도입되었습니다.</p>
<h3 id="배경-및-목표-rationale-and-goals"><a href="#배경-및-목표-rationale-and-goals">배경 및 목표 (Rationale and Goals)</a></h3>
<p>PEP 3107은 함수 정의의 일부에 임의의 어노테이션을 추가하는 기능을 지원했습니다. 기본값(default values)과 마찬가지로 어노테이션은 함수 정의 시점에 평가됩니다. 이는 타입 힌트 사용 사례에서 여러 문제를 야기했습니다:</p>
<ul>
<li><strong>전방 참조 (forward references):</strong> 타입 힌트에 아직 정의되지 않은 이름이 포함될 경우, 해당 정의는 문자열 리터럴로 표현되어야 합니다.</li>
<li><strong>런타임 비용:</strong> 타입 힌트는 모듈 임포트(module import) 시점에 실행되므로, 계산 비용이 발생합니다.</li>
</ul>
<p>어노테이션 평가를 지연하면 이 두 가지 문제가 모두 해결됩니다.</p>
<p><strong>참고:</strong> PEP 649는 위 문제에 대한 대체 솔루션을 제안하여, 이 PEP가 대체될 위험에 처하게 되었습니다.</p>
<h4 id="비목표-non-goals"><a href="#비목표-non-goals">비목표 (Non-goals)</a></h4>
<p>PEP 484 및 PEP 526과 마찬가지로, Python은 동적 타입 언어로 유지될 것이며, 타입 힌트를 관례로든 강제로든 필수화할 의도는 없음을 강조합니다. 이 PEP는 타입 어노테이션의 전방 참조 문제를 해결하기 위한 것입니다. 어노테이션 외부에 전방 참조가 여전히 문자열 리터럴 사용을 요구하는 경우가 존재하며, 이는 이 문서의 뒷부분에 나열되어 있습니다.</p>
<p>강제 평가가 없는 어노테이션은 타입 힌트의 구문을 개선할 기회를 제공합니다. 이 아이디어는 별도의 PEP가 필요하며 이 문서에서는 더 이상 논의되지 않습니다.</p>
<h4 id="비-타이핑-목적의-어노테이션-사용-non-typing-usage-of-annotations"><a href="#비-타이핑-목적의-어노테이션-사용-non-typing-usage-of-annotations">비-타이핑 목적의 어노테이션 사용 (Non-typing usage of annotations)</a></h4>
<p>어노테이션은 타입 검사 외에도 임의의 용도로 계속 사용 가능하지만, 이 PEP의 설계와 그 선구자들(PEP 484 및 PEP 526)은 주로 타입 힌트 사용 사례에 의해 동기 부여되었다는 점을 언급할 가치가 있습니다. Python 3.8에서 PEP 484는 임시(provisional) 상태에서 벗어나게 됩니다. PEP 544, PEP 557, PEP 560과 같은 다른 Python 언어 개선 사항들은 이미 PEP 484에 정의된 타입 어노테이션 및 <code>typing</code> 모듈에 의존하고 있습니다.</p>
<p>이를 염두에 두고, 위 PEP들과 호환되지 않는 어노테이션 사용은 폐기(deprecated)될 것으로 간주해야 합니다.</p>
<h3 id="구현-implementation"><a href="#구현-implementation">구현 (Implementation)</a></h3>
<p>이 PEP를 통해 함수 및 변수 어노테이션은 더 이상 정의 시점에 평가되지 않습니다. 대신, 문자열 형태가 해당 <code>__annotations__</code> 딕셔너리에 보존됩니다. 정적 타입 검사기(static type checkers)는 동작에 차이를 느끼지 않겠지만, 런타임에 어노테이션을 사용하는 도구는 지연 평가를 수행해야 합니다.</p>
<p>문자열 형태는 컴파일 단계에서 AST(Abstract Syntax Tree)로부터 얻어지며, 이는 문자열 형태가 원본 소스 코드의 정확한 포맷팅을 보존하지 않을 수 있음을 의미합니다. 어노테이션이 이미 문자열 리터럴이었더라도 여전히 문자열로 래핑됩니다.</p>
<p>어노테이션은 구문적으로 유효한 Python 표현식이어야 하며, 리터럴 문자열로 전달될 때도 마찬가지입니다 (예: <code>compile(literal, '', 'eval')</code>). 어노테이션은 모듈 스코프(module scope)에 있는 이름만 사용할 수 있습니다. 이는 로컬 이름을 사용한 지연 평가가 신뢰할 수 없기 때문입니다 (클래스 수준 이름은 <code>typing.get_type_hints()</code>에 의해 해결되는 유일한 예외). PEP 526에 따라 로컬 변수 어노테이션은 함수의 클로저(closure) 외부에서 접근할 수 없으므로 전혀 평가되지 않습니다.</p>
<h4 id="python-37에서-미래-동작-활성화-enabling-the-future-behavior-in-python-37"><a href="#python-37에서-미래-동작-활성화-enabling-the-future-behavior-in-python-37">Python 3.7에서 미래 동작 활성화 (Enabling the future behavior in Python 3.7)</a></h4>
<p>위에 설명된 기능은 Python 3.7부터 다음 특별 import를 사용하여 활성화할 수 있습니다:</p>
<pre><code class="language-python">from __future__ import annotations
</code></pre>
<p>이 기능의 참조 구현은 GitHub에서 사용할 수 있습니다.</p>
<h4 id="런타임에-타입-힌트-해결-resolving-type-hints-at-runtime"><a href="#런타임에-타입-힌트-해결-resolving-type-hints-at-runtime">런타임에 타입 힌트 해결 (Resolving Type Hints at Runtime)</a></h4>
<p>런타임에 어노테이션을 문자열 형태에서 포함된 표현식의 결과로 해결하려면, 사용자 코드가 해당 문자열을 평가해야 합니다.</p>
<p>타입 힌트를 사용하는 코드의 경우, <code>typing.get_type_hints(obj, globalns=None, localns=None)</code> 함수는 문자열 형태에서 표현식을 올바르게 평가합니다. 현재 <code>__annotations__</code>를 사용하는 모든 유효한 코드는 타입 어노테이션이 문자열 리터럴로 표현될 수 있으므로 이미 이렇게 해야 합니다.</p>
<p>다른 목적으로 어노테이션을 사용하는 코드의 경우, 일반적인 <code>eval(ann, globals, locals)</code> 호출만으로 어노테이션을 해결하기에 충분합니다.</p>
<p>두 경우 모두 <code>globals</code> 및 <code>locals</code>가 지연 평가에 어떻게 영향을 미치는지 고려하는 것이 중요합니다. 어노테이션은 더 이상 정의 시점에, 그리고 더 중요하게는 정의된 것과 동일한 스코프에서 평가되지 않습니다. 결과적으로, 어노테이션에 로컬 상태를 사용하는 것은 일반적으로 더 이상 불가능합니다. <code>globals</code>의 경우, 어노테이션이 정의된 모듈이 지연 평가를 위한 올바른 컨텍스트입니다.</p>
<p><code>get_type_hints()</code> 함수는 함수 및 클래스에 대한 <code>globalns</code>의 올바른 값을 자동으로 해결합니다. 또한 클래스에 대한 올바른 <code>localns</code>를 자동으로 제공합니다.</p>
<p><code>eval()</code>을 실행할 때, <code>globals</code>의 값은 다음 방식으로 수집될 수 있습니다:</p>
<ul>
<li>함수 객체는 <code>__globals__</code>라는 속성에 해당 <code>globals</code>에 대한 참조를 가지고 있습니다.</li>
<li>클래스는 정의된 모듈의 이름을 가지고 있으며, 이를 사용하여 해당 <code>globals</code>를 검색할 수 있습니다.
<pre><code class="language-python">cls_globals = vars(sys.modules[SomeClass.__module__])
</code></pre>
이것은 모든 <code>__annotations__</code>를 평가하기 위해 기본 클래스(base classes)에 대해서도 반복되어야 합니다.</li>
<li>모듈은 자신의 <code>__dict__</code>를 사용해야 합니다.</li>
</ul>
<p><code>localns</code>의 값은 함수에 대해 신뢰할 수 있게 검색할 수 없습니다. 이는 호출 시점의 스택 프레임이 더 이상 존재하지 않을 가능성이 높기 때문입니다.</p>
<p>클래스의 경우, <code>localns</code>는 주어진 클래스와 그 기본 클래스(메서드 결정 순서로)의 <code>vars</code>를 연결하여 구성될 수 있습니다. 슬롯(slots)은 클래스가 정의된 후에만 채워질 수 있으므로, 이 목적으로 슬롯을 고려할 필요는 없습니다.</p>
<h4 id="런타임-어노테이션-해결과-클래스-데코레이터-runtime-annotation-resolution-and-class-decorators"><a href="#런타임-어노테이션-해결과-클래스-데코레이터-runtime-annotation-resolution-and-class-decorators">런타임 어노테이션 해결과 클래스 데코레이터 (Runtime annotation resolution and class decorators)</a></h4>
<p>현재 클래스에 대한 어노테이션을 해결해야 하는 메타클래스(metaclasses) 및 클래스 데코레이터(class decorators)는 현재 클래스의 이름을 사용하는 어노테이션에 대해 실패합니다. 예시:</p>
<pre><code class="language-python">def class_decorator(cls):
    annotations = get_type_hints(cls) # 'C'에서 NameError 발생
    print(f'Annotations for {cls}: {annotations}')
    return cls

@class_decorator
class C:
    singleton: 'C' = None
</code></pre>
<p>이는 이 PEP 이전에도 마찬가지였습니다. 클래스 데코레이터는 현재 정의 스코프에서 클래스에 이름이 할당되기 전에 클래스에 작용합니다.</p>
<h4 id="런타임-어노테이션-해결과-type_checking-runtime-annotation-resolution-and-type_checking"><a href="#런타임-어노테이션-해결과-type_checking-runtime-annotation-resolution-and-type_checking">런타임 어노테이션 해결과 <code>TYPE_CHECKING</code> (Runtime annotation resolution and TYPE_CHECKING)</a></h4>
<p>때로는 타입 검사기가 봐야 하지만 실행되어서는 안 되는 코드가 있습니다. 이러한 상황을 위해 <code>typing</code> 모듈은 타입 검사 중에는 <code>True</code>로 간주되지만 런타임에는 <code>False</code>인 상수 <code>TYPE_CHECKING</code>을 정의합니다. 예시:</p>
<pre><code class="language-python">import typing

if typing.TYPE_CHECKING:
    import expensive_mod

def a_func(arg: expensive_mod.SomeClass) -> None:
    a_var: expensive_mod.SomeClass = arg
    ...
</code></pre>
<p>이 접근 방식은 임포트 순환(import cycles)을 처리할 때도 유용합니다.</p>
<p><code>typing.get_type_hints()</code>를 사용하여 <code>a_func</code>의 어노테이션을 런타임에 해결하려고 하면 <code>expensive_mod</code> 이름이 정의되지 않았기 때문에 실패합니다 (런타임에 <code>TYPE_CHECKING</code> 변수가 <code>False</code>이기 때문입니다). 이는 이 PEP 이전에도 마찬가지였습니다.</p>
<h3 id="하위-호환성-backwards-compatibility"><a href="#하위-호환성-backwards-compatibility">하위 호환성 (Backwards Compatibility)</a></h3>
<p>이것은 하위 호환성을 깨는 변경 사항입니다. <code>typing.get_type_hints()</code> 또는 <code>eval()</code>을 사용하지 않고 어노테이션에 임의의 객체가 직접 존재한다고 가정하는 애플리케이션은 깨지게 됩니다.</p>
<p>함수 정의 시점의 <code>locals</code>에 의존하는 어노테이션은 나중에 해결할 수 없게 됩니다. 예시:</p>
<pre><code class="language-python">def generate():
    A = Optional[int]
    class C:
        field: A = 1
        def method(self, arg: A) -> None: ...
    return C

X = generate()
</code></pre>
<p>나중에 <code>get_type_hints(X)</code>를 사용하여 <code>X</code>의 어노테이션을 해결하려고 하면 <code>A</code>와 그를 둘러싼 스코프가 더 이상 존재하지 않기 때문에 실패합니다. Python은 이러한 어노테이션을 금지하려는 시도를 하지 않습니다. 이는 어노테이션의 주된 사용 사례인 정적 분석에서 여전히 성공적으로 분석될 수 있기 때문입니다.</p>
<p>중첩된 클래스(nested classes) 및 해당 상태를 사용하는 어노테이션은 여전히 유효합니다. 이들은 로컬 이름 또는 정규화된 이름(fully qualified name)을 사용할 수 있습니다. 예시:</p>
<pre><code class="language-python">class C:
    field = 'c_field'
    def method(self) -> C.field: # OK
        ...
    def method(self) -> field: # OK
        ...
    def method(self) -> C.D: # OK
        ...
    def method(self) -> D: # OK
        ...
    class D:
        field2 = 'd_field'
        def method(self) -> C.D.field2: # OK
            ...
        def method(self) -> D.field2: # 실패, 클래스 D는 C의 로컬이므로
                                   # C.D로만 접근 가능. PEP 이전에도 마찬가지.
            ...
        def method(self) -> field2: # OK
            ...
        def method(self) -> field: # 실패, field는 C의 로컬이므로
                                   # C.field로 접근하지 않으면 D에서 보이지 않음.
                                   # PEP 이전에도 마찬가지.
            ...
</code></pre>
<p>구문적으로 유효하지 않은 표현식인 어노테이션이 있는 경우, 컴파일 시점에 <code>SyntaxError</code>가 발생합니다. 그러나 이름이 해당 시점에 해결되지 않으므로, 사용된 이름이 올바른지 여부를 검증하려는 시도는 이루어지지 않습니다.</p>
<h4 id="폐기-정책-deprecation-policy"><a href="#폐기-정책-deprecation-policy">폐기 정책 (Deprecation policy)</a></h4>
<p>Python 3.7부터는 설명된 기능을 사용하려면 <code>__future__</code> import가 필요합니다. 경고는 발생하지 않습니다.</p>
<p><strong>참고:</strong> 이 기능이 결국 기본 동작이 될지 여부는 PEP 649에 대한 결정이 보류 중이므로 현재 불분명합니다. 어떠한 경우든, 즉시 평가(eager evaluation)에 의존하는 어노테이션의 사용은 두 제안 모두와 호환되지 않으며 더 이상 지원되지 않습니다.</p>
<h4 id="전방-참조-forward-references"><a href="#전방-참조-forward-references">전방 참조 (Forward References)</a></h4>
<p>모듈에서 이름이 정의되기 전에 의도적으로 이름을 사용하는 것을 전방 참조라고 합니다. 이 섹션의 목적을 위해 <code>if TYPE_CHECKING:</code> 블록 내에서 임포트되거나 정의된 모든 이름도 전방 참조라고 부를 것입니다.</p>
<p>이 PEP는 타입 어노테이션의 전방 참조 문제를 해결합니다. 이 경우 문자열 리터럴의 사용은 더 이상 필수가 아닙니다. 그러나 <code>typing</code> 모듈에는 언어의 다른 구문 구조를 사용하는 API가 있으며, 이들은 여전히 문자열 리터럴로 전방 참조를 우회해야 합니다. 목록은 다음과 같습니다:</p>
<ul>
<li>타입 정의:
<pre><code class="language-python">T = TypeVar('T', bound='&#x3C;type>')
UserId = NewType('UserId', '&#x3C;type>')
Employee = NamedTuple('Employee', [('name', '&#x3C;type>'), ('id', '&#x3C;type>')])
</code></pre>
</li>
<li>별칭 (aliases):
<pre><code class="language-python">Alias = Optional['&#x3C;type>']
AnotherAlias = Union['&#x3C;type>', '&#x3C;type>']
YetAnotherAlias = '&#x3C;type>'
</code></pre>
</li>
<li>캐스팅 (casting):
<pre><code class="language-python">cast('&#x3C;type>', value)
</code></pre>
</li>
<li>기본 클래스 (base classes):
<pre><code class="language-python">class C(Tuple['&#x3C;type>', '&#x3C;type>']): ...
</code></pre>
</li>
</ul>
<p>특정 경우에 따라 위 목록의 일부 사례는 <code>if TYPE_CHECKING:</code> 블록에 사용을 배치하여 해결할 수 있습니다. 이는 런타임에 사용할 수 있어야 하는 코드, 특히 기본 클래스 및 캐스팅에는 작동하지 않습니다. <code>NamedTuple</code>의 경우, Python 3.6에서 도입된 새 클래스 정의 구문을 사용하면 문제가 해결됩니다.</p>
<p>일반적으로 모든 전방 참조에 대한 문제를 해결하려면 현재의 단일 패스 하향식(single-pass top-down) 모델에서 Python의 모듈 인스턴스화 방식 변경이 필요합니다. 이는 언어에 대한 주요 변경 사항이므로 이 PEP의 범위 밖입니다.</p>
<h3 id="기각된-아이디어-rejected-ideas"><a href="#기각된-아이디어-rejected-ideas">기각된 아이디어 (Rejected Ideas)</a></h3>
<h4 id="어노테이션-정의-시-함수-로컬-상태-사용-기능-유지-keeping-the-ability-to-use-function-local-state-when-defining-annotations"><a href="#어노테이션-정의-시-함수-로컬-상태-사용-기능-유지-keeping-the-ability-to-use-function-local-state-when-defining-annotations">어노테이션 정의 시 함수 로컬 상태 사용 기능 유지 (Keeping the ability to use function local state when defining annotations)</a></h4>
<p>지연 평가를 통해, 이는 어노테이션이 생성된 프레임에 대한 참조를 유지해야 합니다. 예를 들어, 모든 어노테이션을 문자열 대신 람다(lambdas)로 저장함으로써 달성할 수 있습니다. 이는 고도로 어노테이션된 코드의 경우 프레임이 모든 객체를 활성 상태로 유지하므로 엄청나게 비쌀 것입니다.</p>
<p>클래스 수준 스코프를 처리하려면 람다 접근 방식은 인터프리터에 새로운 종류의 셀(cell)을 요구할 것입니다. 이는 <code>__annotations__</code>에 나타날 수 있는 타입의 수를 증식시킬 뿐만 아니라, 문자열만큼 내부를 들여다볼 수 없을 것입니다.</p>
<p>중첩 클래스의 경우, 정의 시점에 효과적인 "globals" 및 "locals"를 가져오는 기능은 <code>typing.get_type_hints()</code>에 의해 제공됩니다.</p>
<p>어노테이션이 로컬 변수를 사용해야 하는 클래스 또는 함수를 생성하는 함수는 컴파일러에 의존하지 않고 생성된 객체의 <code>__annotations__</code> 딕셔너리를 직접 채울 수 있습니다.</p>
<h4 id="클래스에도-로컬-상태-사용-금지-disallowing-local-state-usage-for-classes-too"><a href="#클래스에도-로컬-상태-사용-금지-disallowing-local-state-usage-for-classes-too">클래스에도 로컬 상태 사용 금지 (Disallowing local state usage for classes, too)</a></h4>
<p>이 PEP는 원래 어노테이션 내의 이름을 모듈 수준 스코프의 이름으로만 제한할 것을 제안했으며, 클래스의 경우에도 마찬가지였습니다. 저자는 이것이 로컬 이름과 모듈 수준 이름 간의 충돌을 포함하여 이름 해결을 모호하지 않게 만든다고 주장했습니다.</p>
<p>이 아이디어는 결국 클래스의 경우 기각되었습니다. 대신 <code>typing.get_type_hints()</code>가 클래스 수준 어노테이션이 필요한 경우 로컬 네임스페이스를 올바르게 채우도록 수정되었습니다.</p>
<p>이 아이디어를 기각한 이유는 Python에서 스코프(scoping)가 작동하는 방식의 직관에 어긋나고, 기존 타입 어노테이션을 충분히 깨뜨려 전환을 번거롭게 만들 것이기 때문입니다. 마지막으로, 클래스 데코레이터가 타입 어노테이션을 평가할 수 있으려면 로컬 스코프 접근이 필요합니다. 이는 클래스 데코레이터가 외부 스코프에서 클래스가 이름을 받기 전에 적용되기 때문입니다.</p>
<h4 id="문자열-리터럴-형태를-위한-새-딕셔너리-도입-introducing-a-new-dictionary-for-the-string-literal-form-instead"><a href="#문자열-리터럴-형태를-위한-새-딕셔너리-도입-introducing-a-new-dictionary-for-the-string-literal-form-instead">문자열 리터럴 형태를 위한 새 딕셔너리 도입 (Introducing a new dictionary for the string literal form instead)</a></h4>
<p>Yury Selivanov는 다음 아이디어를 공유했습니다: 함수에 <code>__annotations_text__</code>라는 새로운 특별 속성을 추가합니다. <code>__annotations__</code>를 지연 동적 매핑으로 만들어, <code>__annotations_text__</code>의 해당 키에서 표현식을 Just-In-Time으로 평가합니다.</p>
<p>이 아이디어는 하위 호환성 문제를 해결하고 새 <code>__future__</code> import의 필요성을 제거하기 위한 것이었습니다. 그러나 지연 평가는 어노테이션이 접근할 수 있는 상태를 변경합니다. 지연 평가가 전방 참조 문제를 해결하지만, 함수 수준의 <code>locals</code>에 더 이상 접근할 수 없게 만듭니다. 이것만으로도 하위 호환성 위반의 원인이 되며, 이는 폐기 기간을 정당화합니다.</p>
<p><code>__future__</code> import는 새로운 기능을 선택한다는 명확하고 명시적인 지표입니다. 또한 외부 도구가 이전 방식 또는 새 방식을 사용하는 Python 파일 간의 차이를 쉽게 인식하게 합니다.</p>
<p>마지막으로, <code>get_type_hints()</code>가 나중에 사용되는 경우 <code>__annotations__</code>에서의 Just-In-Time 평가는 불필요한 단계입니다.</p>
<h4 id="-o-옵션으로-어노테이션-제거-dropping-annotations-with--o"><a href="#-o-옵션으로-어노테이션-제거-dropping-annotations-with--o"><code>-O</code> 옵션으로 어노테이션 제거 (Dropping annotations with -O)</a></h4>
<p>이 PEP의 목적을 위해 이것이 만족스럽지 않은 두 가지 이유가 있습니다.</p>
<ol>
<li>이것은 런타임 비용만 다루며, 전방 참조는 다루지 않습니다. 라이브러리 관리자는 전방 참조를 사용할 수 없을 것입니다. 이는 라이브러리 사용자가 새로운 가상의 <code>-O</code> 스위치를 사용하도록 강요하기 때문입니다.</li>
<li>이것은 "목욕물과 함께 아기를 버리는" 격입니다. 이제 런타임 어노테이션 사용은 전혀 수행할 수 없게 됩니다. PEP 557은 런타임에 타입 어노테이션을 평가하는 것이 유용한 최근 개발의 한 예입니다.</li>
</ol>
<p>그럼에도 불구하고, 어노테이션을 제거하는 세분화된 <code>-O</code> 옵션은 기존 <code>-O</code> 동작(docstring 및 assert 문 제거)과 개념적으로 호환되므로 미래에 가능할 수 있습니다. 이 PEP는 이 아이디어를 무효화하지 않습니다.</p>
<h4 id="어노테이션의-문자열-리터럴을-__annotations__에-그대로-전달-passing-string-literals-in-annotations-verbatim-to-annotations"><a href="#어노테이션의-문자열-리터럴을-__annotations__에-그대로-전달-passing-string-literals-in-annotations-verbatim-to-annotations">어노테이션의 문자열 리터럴을 <code>__annotations__</code>에 그대로 전달 (Passing string literals in annotations verbatim to <strong>annotations</strong>)</a></h4>
<p>이 PEP는 원래 문자열 리터럴의 내용을 <code>__annotations__</code>의 해당 키 아래에 직접 저장할 것을 제안했습니다. 이는 런타임 타입 검사기(runtime type checkers)를 위한 지원을 단순화하기 위한 것이었습니다. Mark Shannon은 이 아이디어가 문자열이 타입 어노테이션의 일부일 때의 상황을 처리하지 못하므로 결함이 있다고 지적했습니다. 이 아이디어의 불일치성은 항상 명백했지만, 어쨌든 문자열의 이중 래핑(double-wrapping) 사례를 완전히 방지하지 못했기 때문에 가치가 없었습니다.</p>
<h4 id="__future__-import의-이름을-더-길게-만들기-making-the-name-of-the-future-import-more-verbose"><a href="#__future__-import의-이름을-더-길게-만들기-making-the-name-of-the-future-import-more-verbose"><code>__future__</code> import의 이름을 더 길게 만들기 (Making the name of the future import more verbose)</a></h4>
<p>다음 import를 요구하는 대신:</p>
<pre><code class="language-python">from __future__ import annotations
</code></pre>
<p>이 PEP는 기능을 더 명시적으로 호출할 수 있습니다. 예를 들어, <code>string_annotations</code>, <code>stringify_annotations</code>, <code>annotation_strings</code>, <code>annotations_as_strings</code>, <code>lazy_annotations</code>, <code>static_annotations</code> 등이 있습니다.</p>
<p>이러한 이름의 문제는 매우 장황하다는 것입니다. <code>lazy_annotations</code>를 제외한 각 이름은 Python에서 가장 긴 미래 기능 이름이 될 것입니다. 타이핑하기 길고 단어 하나로 된 형태보다 기억하기 어렵습니다.</p>
<p>지나치게 일반적으로 들리지만 실제로는 사용자에게 무엇을 하는지 명백했던 <code>__future__</code> import 이름의 선례가 있습니다:</p>
<pre><code class="language-python">from __future__ import division
</code></pre>
<h3 id="이전-논의-prior-discussion"><a href="#이전-논의-prior-discussion">이전 논의 (Prior discussion)</a></h3>
<h4 id="pep-484에서-in-pep-484"><a href="#pep-484에서-in-pep-484">PEP 484에서 (In PEP 484)</a></h4>
<p>전방 참조 문제는 PEP 484가 처음 초안될 때 논의되었으며, 문서에 다음과 같은 진술을 이끌어냈습니다:</p>
<blockquote>
<p><code>__future__</code> import를 통해 주어진 모듈의 모든 어노테이션을 문자열 리터럴로 바꿀 수 있는 절충안이 가능하며, 다음과 같습니다:</p>
<pre><code class="language-python">from __future__ import annotations
class ImSet:
    def add(self, a: ImSet) -> List[ImSet]: ...
assert ImSet.add.__annotations__ == {
    'a': 'ImSet',
    'return': 'List[ImSet]'
}
</code></pre>
<p>이러한 <code>__future__</code> import 문은 별도의 PEP에서 제안될 수 있습니다.</p>
</blockquote>
<h4 id="pythontyping400"><a href="#pythontyping400">python/typing#400</a></h4>
<p>이 문제는 <code>typing</code> 모듈의 GitHub 프로젝트, Issue 400에서 심층적으로 논의되었습니다. 거기서의 문제 설명은 <code>typing</code>에서 제네릭 타입(generic types)을 임포트해야 하는 것에 대한 비판을 포함합니다. 이는 초보자에게 혼란을 주는 경향이 있습니다:</p>
<pre><code class="language-python"># 왜 이렇게 해야 하는가:
from typing import List, Set
def dir(o: object = ...) -> List[str]: ...
def add_friends(friends: Set[Friend]) -> None: ...

# 이렇게는 안 되는가:
def dir(o: object = ...) -> list[str]: ...
def add_friends(friends: set[Friend]) -> None ...

# 왜 이렇게 해야 하는가:
up_to_ten = list(range(10))
friends = set()

# 이렇게는 안 되는가:
from typing import List, Set
up_to_ten = List[int](range(10))
friends = Set[Friend]()
</code></pre>
<p><code>typing</code>의 유용성은 흥미로운 문제이지만, 이 PEP의 범위 밖입니다. 특히 PEP 484에서 표준화된 <code>typing</code> 구문의 확장은 각각의 PEP와 승인을 요구할 것입니다.</p>
<p>Issue 400은 궁극적으로 어노테이션의 평가를 지연하고 <code>__annotations__</code>에 문자열로 유지할 것을 제안하며, 이는 이 PEP가 명시하는 바와 같습니다. 이 아이디어는 잘 받아들여졌습니다. Ivan Levkivskyi는 <code>__future__</code> import 사용을 지지했고, <code>compile.c</code>에서 AST를 역파싱(unparsing)할 것을 제안했습니다. Jukka Lehtosalo는 타입이 어노테이션 외부에서 사용되는 전방 참조의 일부 경우가 있으며, 지연 평가는 도움이 되지 않을 것이라고 지적했습니다. 이러한 경우에는 문자열 리터럴 표기법을 계속 사용해야 할 것입니다. 이러한 사례들은 이 PEP의 "Forward References" 섹션에서 간략하게 논의됩니다.</p>
<p>이 문제에 대한 가장 큰 논란은 Guido van Rossum의 우려였습니다. 그는 어노테이션 표현식을 다시 문자열 형태로 토큰화하지 않는 것은 Python 프로그래밍 언어에 전례가 없으며 해킹적인 우회책처럼 느껴진다고 말했습니다. 그는 다음과 같이 말했습니다:</p>
<blockquote>
<p>"하나 생각나는 것은 언어에 대한 매우 무작위적인 변경이라는 것입니다. 표현식의 지연 실행을 나타내는 더 간결한 방법이 있으면 유용할 수 있습니다 ( <code>lambda:</code>보다 적은 구문을 사용하여). 그러나 이 특정 사용 사례에 대한 해결책이 이미 존재하고 매우 최소한의 구문을 요구하는데, 타입 어노테이션의 사용 사례가 언어를 먼저 변경해야 할 만큼 그렇게 중요한 이유는 무엇일까요 (더 일반적인 해결책을 제안하기보다는)?"</p>
</blockquote>
<p>결국 Ethan Smith와 schollii는 PyCon US에서 수집된 피드백이 전방 참조 상태를 수정해야 함을 시사한다고 말했습니다. Guido van Rossum은 <code>__future__</code> 아이디어로 돌아갈 것을 제안하며, 남용을 방지하기 위해 어노테이션이 구문적으로 유효하고 런타임에 올바르게 평가되는 것이 중요하다고 지적했습니다.</p>
<h4 id="python-ideas에서의-첫-번째-초안-논의-first-draft-discussion-on-python-ideas"><a href="#python-ideas에서의-첫-번째-초안-논의-first-draft-discussion-on-python-ideas">python-ideas에서의 첫 번째 초안 논의 (First draft discussion on python-ideas)</a></h4>
<p>논의는 주로 두 스레드, 즉 원래 발표와 <code>PEP 563 and expensive backwards compatibility</code>라는 후속 스레드에서 이루어졌습니다.</p>
<p>PEP는 상당히 긍정적인 피드백을 받았습니다 (4명이 강력하게 찬성, 2명이 우려와 함께 찬성, 2명이 반대). 이전 스레드에서 가장 큰 우려의 목소리는 Steven D'Aprano의 검토였습니다. 그는 PEP의 문제 정의가 하위 호환성을 깨뜨리는 것을 정당화하지 못한다고 주장했습니다. 이 답변에서 Steven은 주로 Python이 더 이상 로컬 함수/클래스 상태에 의존하는 어노테이션의 평가를 지원하지 않는 것에 대해 우려하는 것처럼 보였습니다.</p>
<p>몇몇 사람들은 어노테이션을 비-타이핑 목적으로 사용하는 라이브러리가 있다는 우려를 표명했습니다. 그러나 언급된 라이브러리 중 어느 것도 이 PEP에 의해 무효화되지 않을 것입니다. 그들은 어노테이션에 대해 올바른 <code>globals</code>와 <code>locals</code>를 설정하여 <code>eval()</code>을 호출하는 새로운 요구 사항에 적응해야 합니다.</p>
<p><code>globals</code>와 <code>locals</code>가 올바르게 설정되어야 한다는 이 세부 사항은 많은 논평자들에 의해 언급되었습니다. Alyssa (Nick) Coghlan은 어노테이션을 문자열 대신 람다로 바꾸는 벤치마크를 수행했지만, 안타깝게도 이는 현재 상황보다 런타임에 훨씬 느리다는 것이 입증되었습니다.</p>
<p>후자의 스레드는 Jim J. Jewett에 의해 시작되었는데, 그는 어노테이션을 제대로 평가하는 능력이 중요한 요구 사항이며, 이와 관련하여 하위 호환성이 가치 있다고 강조했습니다. 그는 논의 후 어노테이션의 부작용(side effects)이 코드 스멜(code smell)이며, 평가를 수행할지 말지를 선택하는 모달 지원은 지저분한 해결책이라고 인정했습니다. 그의 가장 큰 우려는 전역 및 로컬 스코프의 평가 제한으로 인해 발생하는 기능 손실이었습니다.</p>
<p>Alyssa Coghlan은 PEP의 일부 평가 제한이 영리한 평가 도우미(evaluation helper) 구현으로 해제될 수 있으며, 이는 클래스 데코레이터 형태에서도 자기 참조 클래스(self-referencing classes)를 해결할 수 있다고 지적했습니다. 그녀는 PEP가 표준 라이브러리에 이 도우미 함수를 제공해야 한다고 제안했습니다.</p>
<h4 id="python-dev에서의-두-번째-초안-논의-second-draft-discussion-on-python-dev"><a href="#python-dev에서의-두-번째-초안-논의-second-draft-discussion-on-python-dev">python-dev에서의 두 번째 초안 논의 (Second draft discussion on python-dev)</a></h4>
<p>논의는 주로 발표 스레드에서 이루어졌으며, Mark Shannon의 게시물 아래에서 간략한 논의가 이어졌습니다.</p>
<p>Steven D'Aprano는 PEP가 제안한 변경 후 어노테이션에 오타가 허용되는 것이 허용되는지 우려했습니다. Brett Cannon은 타입 검사기 및 다른 정적 분석기(린터나 프로그래밍 텍스트 편집기 등)가 이러한 유형의 오류를 잡아낼 것이라고 응답했습니다. Jukka Lehtosalo는 이 상황이 함수 본문의 이름이 함수가 호출될 때까지 해결되지 않는 방식과 유사하다고 덧붙였습니다.</p>
<p>논의의 주요 주제는 Alyssa Coghlan의 어노테이션을 "thunk form"으로 저장하자는 제안이었습니다. 즉, 클래스 수준 스코프에 접근할 수 있고 (호출 시 스코프 사용자 정의를 허용하는) 특수화된 람다 형태였습니다. 그는 이에 대한 가능한 설계를 제시했습니다 (간접 속성 셀). 이는 나중에 Lisp의 "특수 형태"와 동등한 것으로 간주되었습니다. Guido van Rossum은 이러한 종류의 기능이 12주 안에 (즉, Python 3.7 베타 동결 전에) 안전하게 구현될 수 있을지 우려를 표했습니다.</p>
<p>얼마 후, 문자열 형태 지지자와 thunk 형태 지지자 간의 분열점은 실제로 어노테이션이 일반적인 구문 요소로 인식되어야 하는지 아니면 타입 검사 사용 사례에 묶인 것으로 인식되어야 하는지에 관한 것임이 분명해졌습니다.</p>
<p>마침내 Guido van Rossum은 thunk 아이디어가 인터프리터에 새로운 빌딩 블록을 요구할 것이라는 사실에 근거하여 이를 거부한다고 선언했습니다. 이 블록은 어노테이션에 노출되어 <code>__annotations__</code>에 저장될 수 있는 값의 유형(임의 객체, 문자열, 이제는 thunk)을 증식시킬 것입니다. 또한 thunk는 문자열만큼 내부를 들여다볼 수 없습니다. 가장 중요하게, Guido van Rossum은 어노테이션의 사용을 점진적으로 정적 타이핑(선택적 런타임 구성 요소 포함)으로 제한하는 데 명시적인 관심을 표명했습니다.</p>
<p>Alyssa Coghlan도 PEP 563에 설득되었고, 즉시 <code>__future__</code> import 이름에 대한 의무적인 "bike shedding" 세션을 시작했습니다. 많은 토론자들은 <code>annotations</code>가 기능 이름으로는 지나치게 광범위한 이름처럼 보인다는 데 동의했습니다. Guido van Rossum은 잠시 <code>string_annotations</code>라고 부르기로 결정했지만, <code>division</code>이 명확한 의미를 가진 광범위한 이름의 선례라고 주장하며 마음을 바꿨습니다.</p>
<p>Mark Shannon이 논의에서 제안한 PEP에 대한 최종 개선 사항은 문자열 리터럴을 <code>__annotations__</code>에 그대로 전달하려는 유혹을 거부하는 것이었습니다.</p>
<p>정적 타이핑의 런타임 패널티에 대한 부차적인 논의 스레드가 시작되었으며, <code>typing</code> 모듈의 임포트 시간(종속성 없이 <code>re</code>와 비슷하고, 종속성을 포함하면 <code>re</code>보다 세 배 무겁다)과 같은 주제가 다루어졌습니다.</p>
<h3 id="감사-acknowledgements"><a href="#감사-acknowledgements">감사 (Acknowledgements)</a></h3>
<p>이 문서는 Guido van Rossum, Jukka Lehtosalo, Ivan Levkivskyi의 귀중한 의견, 격려 및 조언 없이는 완성될 수 없었습니다. 구현은 Serhiy Storchaka가 철저히 검토하여 버그, 낮은 가독성, 성능 문제 등 모든 종류의 문제를 발견했습니다.</p>
<h3 id="저작권-copyright"><a href="#저작권-copyright">저작권 (Copyright)</a></h3>
<p>이 문서는 공개 도메인에 배포되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><span class="text-sm font-medium text-gray-900 mb-2 block">태그</span><a class="page__taxonomy-item" href="/tags/Python">#<!-- -->Python</a><a class="page__taxonomy-item" href="/tags/PEP">#<!-- -->PEP</a><a class="page__taxonomy-item" href="/tags/Translation">#<!-- -->Translation</a></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/562">[Final] PEP 562 - Module __getattr__ and __dir__</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Superseded] PEP 563 - Postponed Evaluation of Annotations</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/564">[Final] PEP 564 - Add new time functions with nanosecond resolution</a></li></ul></section></article></div></div></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© <!-- -->2026<!-- --> secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/edb8d4ad4fe2f3b0.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-ee5764c1002761f9.js\",\"132\",\"static/chunks/132-273e49420772df1e.js\",\"185\",\"static/chunks/app/layout-d443cbc354279241.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-ee5764c1002761f9.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-ef33f0f4c1a350bd.js\"],\"\"]\nb:I[4080,[\"231\",\"static/chunks/231-ee5764c1002761f9.js\",\"132\",\"static/chunks/132-273e49420772df1e.js\",\"185\",\"static/chunks/app/layout-d443cbc354279241.js\"],\"\"]\nd:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/563\",\"c\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/edb8d4ad4fe2f3b0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"mJI0q5Z-SQWBtT83kG_N7\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/563\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/563\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"563\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/563\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"link\",null,{\"rel\":\"dns-prefetch\",\"href\":\"https://www.googletagmanager.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://www.googletagmanager.com\",\"crossOrigin\":\"anonymous\"}],[\"$\",\"link\",null,{\"rel\":\"dns-prefetch\",\"href\":\"https://giscus.app\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://giscus.app\",\"crossOrigin\":\"anonymous\"}],[\"$\",\"meta\",null,{\"httpEquiv\":\"X-Content-Type-Options\",\"content\":\"nosniff\"}],[\"$\",\"meta\",null,{\"name\":\"referrer\",\"content\":\"strict-origin-when-cross-origin\"}],[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"WebSite\\\",\\\"name\\\":\\\"secrett2633's blog\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud\\\",\\\"description\\\":\\\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\\\",\\\"inLanguage\\\":\\\"ko\\\",\\\"publisher\\\":{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"secrett2633\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud\\\"}}\"}}],[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"secrett2633\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud\\\",\\\"sameAs\\\":[\\\"https://github.com/secrett2633\\\"]}\"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[[\"$\",\"a\",null,{\"href\":\"#main-content\",\"className\":\"sr-only focus:not-sr-only focus:absolute focus:z-50 focus:p-4 focus:bg-white focus:text-blue-600\",\"children\":\"본문으로 건너뛰기\"}],[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"id\":\"main-content\",\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":[\"© \",2026,\" secrett2633. All rights reserved.\"]}]}]}]}]]}],[\"$\",\"$Lb\",null,{\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\",\"strategy\":\"afterInteractive\"}],[\"$\",\"$Lb\",null,{\"id\":\"gtag-init\",\"strategy\":\"afterInteractive\",\"children\":\"window.dataLayer = window.dataLayer || [];\\n            function gtag(){dataLayer.push(arguments);}\\n            gtag('js', new Date());\\n            gtag('config', 'G-NE2W3CFPNY');\"}]]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"role\":\"status\",\"aria-label\":\"로딩 중\",\"children\":[[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}],[\"$\",\"span\",null,{\"className\":\"sr-only\",\"children\":\"로딩 중...\"}]]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]]\n"])</script><script>self.__next_f.push([1,"10:I[646,[\"231\",\"static/chunks/231-ee5764c1002761f9.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-ef33f0f4c1a350bd.js\"],\"default\"]\nf:T922d,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0563/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ePEP 563 - Postponed Evaluation of Annotations\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Superseded | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 08-Sep-2017\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"pep-563-어노테이션-지연-평가-postponed-evaluation-of-annotations\"\u003e\u003ca href=\"#pep-563-어노테이션-지연-평가-postponed-evaluation-of-annotations\"\u003ePEP 563 – 어노테이션 지연 평가 (Postponed Evaluation of Annotations)\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 이 PEP에서 제안된 기능은 기본 동작이 되지 못했으며, PEP 649 및 PEP 749에서 제안된 어노테이션의 지연된 평가로 대체되었습니다.\u003c/p\u003e\n\u003ch3 id=\"개요-abstract\"\u003e\u003ca href=\"#개요-abstract\"\u003e개요 (Abstract)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003ePEP 3107은 함수 어노테이션을 위한 구문을 도입했지만, 그 의미는 의도적으로 정의되지 않은 채로 남겨두었습니다. PEP 484는 어노테이션에 표준적인 의미인 \"타입 힌트 (type hints)\"를 부여했습니다. PEP 526은 변수 어노테이션을 정의하며, 이를 타입 힌트 사용 사례와 명시적으로 연결했습니다.\u003c/p\u003e\n\u003cp\u003ePEP 563은 함수 및 변수 어노테이션이 더 이상 함수 정의 시점에 평가되지 않도록 변경할 것을 제안합니다. 대신, 어노테이션은 \u003ccode\u003e__annotations__\u003c/code\u003e에 문자열 형태로 보존됩니다. 이 변경 사항은 Python 3.7부터 \u003ccode\u003e__future__\u003c/code\u003e import를 통해 점진적으로 도입되었습니다.\u003c/p\u003e\n\u003ch3 id=\"배경-및-목표-rationale-and-goals\"\u003e\u003ca href=\"#배경-및-목표-rationale-and-goals\"\u003e배경 및 목표 (Rationale and Goals)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003ePEP 3107은 함수 정의의 일부에 임의의 어노테이션을 추가하는 기능을 지원했습니다. 기본값(default values)과 마찬가지로 어노테이션은 함수 정의 시점에 평가됩니다. 이는 타입 힌트 사용 사례에서 여러 문제를 야기했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e전방 참조 (forward references):\u003c/strong\u003e 타입 힌트에 아직 정의되지 않은 이름이 포함될 경우, 해당 정의는 문자열 리터럴로 표현되어야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e런타임 비용:\u003c/strong\u003e 타입 힌트는 모듈 임포트(module import) 시점에 실행되므로, 계산 비용이 발생합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e어노테이션 평가를 지연하면 이 두 가지 문제가 모두 해결됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e PEP 649는 위 문제에 대한 대체 솔루션을 제안하여, 이 PEP가 대체될 위험에 처하게 되었습니다.\u003c/p\u003e\n\u003ch4 id=\"비목표-non-goals\"\u003e\u003ca href=\"#비목표-non-goals\"\u003e비목표 (Non-goals)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003ePEP 484 및 PEP 526과 마찬가지로, Python은 동적 타입 언어로 유지될 것이며, 타입 힌트를 관례로든 강제로든 필수화할 의도는 없음을 강조합니다. 이 PEP는 타입 어노테이션의 전방 참조 문제를 해결하기 위한 것입니다. 어노테이션 외부에 전방 참조가 여전히 문자열 리터럴 사용을 요구하는 경우가 존재하며, 이는 이 문서의 뒷부분에 나열되어 있습니다.\u003c/p\u003e\n\u003cp\u003e강제 평가가 없는 어노테이션은 타입 힌트의 구문을 개선할 기회를 제공합니다. 이 아이디어는 별도의 PEP가 필요하며 이 문서에서는 더 이상 논의되지 않습니다.\u003c/p\u003e\n\u003ch4 id=\"비-타이핑-목적의-어노테이션-사용-non-typing-usage-of-annotations\"\u003e\u003ca href=\"#비-타이핑-목적의-어노테이션-사용-non-typing-usage-of-annotations\"\u003e비-타이핑 목적의 어노테이션 사용 (Non-typing usage of annotations)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e어노테이션은 타입 검사 외에도 임의의 용도로 계속 사용 가능하지만, 이 PEP의 설계와 그 선구자들(PEP 484 및 PEP 526)은 주로 타입 힌트 사용 사례에 의해 동기 부여되었다는 점을 언급할 가치가 있습니다. Python 3.8에서 PEP 484는 임시(provisional) 상태에서 벗어나게 됩니다. PEP 544, PEP 557, PEP 560과 같은 다른 Python 언어 개선 사항들은 이미 PEP 484에 정의된 타입 어노테이션 및 \u003ccode\u003etyping\u003c/code\u003e 모듈에 의존하고 있습니다.\u003c/p\u003e\n\u003cp\u003e이를 염두에 두고, 위 PEP들과 호환되지 않는 어노테이션 사용은 폐기(deprecated)될 것으로 간주해야 합니다.\u003c/p\u003e\n\u003ch3 id=\"구현-implementation\"\u003e\u003ca href=\"#구현-implementation\"\u003e구현 (Implementation)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e이 PEP를 통해 함수 및 변수 어노테이션은 더 이상 정의 시점에 평가되지 않습니다. 대신, 문자열 형태가 해당 \u003ccode\u003e__annotations__\u003c/code\u003e 딕셔너리에 보존됩니다. 정적 타입 검사기(static type checkers)는 동작에 차이를 느끼지 않겠지만, 런타임에 어노테이션을 사용하는 도구는 지연 평가를 수행해야 합니다.\u003c/p\u003e\n\u003cp\u003e문자열 형태는 컴파일 단계에서 AST(Abstract Syntax Tree)로부터 얻어지며, 이는 문자열 형태가 원본 소스 코드의 정확한 포맷팅을 보존하지 않을 수 있음을 의미합니다. 어노테이션이 이미 문자열 리터럴이었더라도 여전히 문자열로 래핑됩니다.\u003c/p\u003e\n\u003cp\u003e어노테이션은 구문적으로 유효한 Python 표현식이어야 하며, 리터럴 문자열로 전달될 때도 마찬가지입니다 (예: \u003ccode\u003ecompile(literal, '', 'eval')\u003c/code\u003e). 어노테이션은 모듈 스코프(module scope)에 있는 이름만 사용할 수 있습니다. 이는 로컬 이름을 사용한 지연 평가가 신뢰할 수 없기 때문입니다 (클래스 수준 이름은 \u003ccode\u003etyping.get_type_hints()\u003c/code\u003e에 의해 해결되는 유일한 예외). PEP 526에 따라 로컬 변수 어노테이션은 함수의 클로저(closure) 외부에서 접근할 수 없으므로 전혀 평가되지 않습니다.\u003c/p\u003e\n\u003ch4 id=\"python-37에서-미래-동작-활성화-enabling-the-future-behavior-in-python-37\"\u003e\u003ca href=\"#python-37에서-미래-동작-활성화-enabling-the-future-behavior-in-python-37\"\u003ePython 3.7에서 미래 동작 활성화 (Enabling the future behavior in Python 3.7)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e위에 설명된 기능은 Python 3.7부터 다음 특별 import를 사용하여 활성화할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom __future__ import annotations\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 기능의 참조 구현은 GitHub에서 사용할 수 있습니다.\u003c/p\u003e\n\u003ch4 id=\"런타임에-타입-힌트-해결-resolving-type-hints-at-runtime\"\u003e\u003ca href=\"#런타임에-타입-힌트-해결-resolving-type-hints-at-runtime\"\u003e런타임에 타입 힌트 해결 (Resolving Type Hints at Runtime)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e런타임에 어노테이션을 문자열 형태에서 포함된 표현식의 결과로 해결하려면, 사용자 코드가 해당 문자열을 평가해야 합니다.\u003c/p\u003e\n\u003cp\u003e타입 힌트를 사용하는 코드의 경우, \u003ccode\u003etyping.get_type_hints(obj, globalns=None, localns=None)\u003c/code\u003e 함수는 문자열 형태에서 표현식을 올바르게 평가합니다. 현재 \u003ccode\u003e__annotations__\u003c/code\u003e를 사용하는 모든 유효한 코드는 타입 어노테이션이 문자열 리터럴로 표현될 수 있으므로 이미 이렇게 해야 합니다.\u003c/p\u003e\n\u003cp\u003e다른 목적으로 어노테이션을 사용하는 코드의 경우, 일반적인 \u003ccode\u003eeval(ann, globals, locals)\u003c/code\u003e 호출만으로 어노테이션을 해결하기에 충분합니다.\u003c/p\u003e\n\u003cp\u003e두 경우 모두 \u003ccode\u003eglobals\u003c/code\u003e 및 \u003ccode\u003elocals\u003c/code\u003e가 지연 평가에 어떻게 영향을 미치는지 고려하는 것이 중요합니다. 어노테이션은 더 이상 정의 시점에, 그리고 더 중요하게는 정의된 것과 동일한 스코프에서 평가되지 않습니다. 결과적으로, 어노테이션에 로컬 상태를 사용하는 것은 일반적으로 더 이상 불가능합니다. \u003ccode\u003eglobals\u003c/code\u003e의 경우, 어노테이션이 정의된 모듈이 지연 평가를 위한 올바른 컨텍스트입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eget_type_hints()\u003c/code\u003e 함수는 함수 및 클래스에 대한 \u003ccode\u003eglobalns\u003c/code\u003e의 올바른 값을 자동으로 해결합니다. 또한 클래스에 대한 올바른 \u003ccode\u003elocalns\u003c/code\u003e를 자동으로 제공합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eeval()\u003c/code\u003e을 실행할 때, \u003ccode\u003eglobals\u003c/code\u003e의 값은 다음 방식으로 수집될 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e함수 객체는 \u003ccode\u003e__globals__\u003c/code\u003e라는 속성에 해당 \u003ccode\u003eglobals\u003c/code\u003e에 대한 참조를 가지고 있습니다.\u003c/li\u003e\n\u003cli\u003e클래스는 정의된 모듈의 이름을 가지고 있으며, 이를 사용하여 해당 \u003ccode\u003eglobals\u003c/code\u003e를 검색할 수 있습니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecls_globals = vars(sys.modules[SomeClass.__module__])\n\u003c/code\u003e\u003c/pre\u003e\n이것은 모든 \u003ccode\u003e__annotations__\u003c/code\u003e를 평가하기 위해 기본 클래스(base classes)에 대해서도 반복되어야 합니다.\u003c/li\u003e\n\u003cli\u003e모듈은 자신의 \u003ccode\u003e__dict__\u003c/code\u003e를 사용해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003elocalns\u003c/code\u003e의 값은 함수에 대해 신뢰할 수 있게 검색할 수 없습니다. 이는 호출 시점의 스택 프레임이 더 이상 존재하지 않을 가능성이 높기 때문입니다.\u003c/p\u003e\n\u003cp\u003e클래스의 경우, \u003ccode\u003elocalns\u003c/code\u003e는 주어진 클래스와 그 기본 클래스(메서드 결정 순서로)의 \u003ccode\u003evars\u003c/code\u003e를 연결하여 구성될 수 있습니다. 슬롯(slots)은 클래스가 정의된 후에만 채워질 수 있으므로, 이 목적으로 슬롯을 고려할 필요는 없습니다.\u003c/p\u003e\n\u003ch4 id=\"런타임-어노테이션-해결과-클래스-데코레이터-runtime-annotation-resolution-and-class-decorators\"\u003e\u003ca href=\"#런타임-어노테이션-해결과-클래스-데코레이터-runtime-annotation-resolution-and-class-decorators\"\u003e런타임 어노테이션 해결과 클래스 데코레이터 (Runtime annotation resolution and class decorators)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e현재 클래스에 대한 어노테이션을 해결해야 하는 메타클래스(metaclasses) 및 클래스 데코레이터(class decorators)는 현재 클래스의 이름을 사용하는 어노테이션에 대해 실패합니다. 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef class_decorator(cls):\n    annotations = get_type_hints(cls) # 'C'에서 NameError 발생\n    print(f'Annotations for {cls}: {annotations}')\n    return cls\n\n@class_decorator\nclass C:\n    singleton: 'C' = None\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 이 PEP 이전에도 마찬가지였습니다. 클래스 데코레이터는 현재 정의 스코프에서 클래스에 이름이 할당되기 전에 클래스에 작용합니다.\u003c/p\u003e\n\u003ch4 id=\"런타임-어노테이션-해결과-type_checking-runtime-annotation-resolution-and-type_checking\"\u003e\u003ca href=\"#런타임-어노테이션-해결과-type_checking-runtime-annotation-resolution-and-type_checking\"\u003e런타임 어노테이션 해결과 \u003ccode\u003eTYPE_CHECKING\u003c/code\u003e (Runtime annotation resolution and TYPE_CHECKING)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e때로는 타입 검사기가 봐야 하지만 실행되어서는 안 되는 코드가 있습니다. 이러한 상황을 위해 \u003ccode\u003etyping\u003c/code\u003e 모듈은 타입 검사 중에는 \u003ccode\u003eTrue\u003c/code\u003e로 간주되지만 런타임에는 \u003ccode\u003eFalse\u003c/code\u003e인 상수 \u003ccode\u003eTYPE_CHECKING\u003c/code\u003e을 정의합니다. 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport typing\n\nif typing.TYPE_CHECKING:\n    import expensive_mod\n\ndef a_func(arg: expensive_mod.SomeClass) -\u003e None:\n    a_var: expensive_mod.SomeClass = arg\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 접근 방식은 임포트 순환(import cycles)을 처리할 때도 유용합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etyping.get_type_hints()\u003c/code\u003e를 사용하여 \u003ccode\u003ea_func\u003c/code\u003e의 어노테이션을 런타임에 해결하려고 하면 \u003ccode\u003eexpensive_mod\u003c/code\u003e 이름이 정의되지 않았기 때문에 실패합니다 (런타임에 \u003ccode\u003eTYPE_CHECKING\u003c/code\u003e 변수가 \u003ccode\u003eFalse\u003c/code\u003e이기 때문입니다). 이는 이 PEP 이전에도 마찬가지였습니다.\u003c/p\u003e\n\u003ch3 id=\"하위-호환성-backwards-compatibility\"\u003e\u003ca href=\"#하위-호환성-backwards-compatibility\"\u003e하위 호환성 (Backwards Compatibility)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e이것은 하위 호환성을 깨는 변경 사항입니다. \u003ccode\u003etyping.get_type_hints()\u003c/code\u003e 또는 \u003ccode\u003eeval()\u003c/code\u003e을 사용하지 않고 어노테이션에 임의의 객체가 직접 존재한다고 가정하는 애플리케이션은 깨지게 됩니다.\u003c/p\u003e\n\u003cp\u003e함수 정의 시점의 \u003ccode\u003elocals\u003c/code\u003e에 의존하는 어노테이션은 나중에 해결할 수 없게 됩니다. 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef generate():\n    A = Optional[int]\n    class C:\n        field: A = 1\n        def method(self, arg: A) -\u003e None: ...\n    return C\n\nX = generate()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e나중에 \u003ccode\u003eget_type_hints(X)\u003c/code\u003e를 사용하여 \u003ccode\u003eX\u003c/code\u003e의 어노테이션을 해결하려고 하면 \u003ccode\u003eA\u003c/code\u003e와 그를 둘러싼 스코프가 더 이상 존재하지 않기 때문에 실패합니다. Python은 이러한 어노테이션을 금지하려는 시도를 하지 않습니다. 이는 어노테이션의 주된 사용 사례인 정적 분석에서 여전히 성공적으로 분석될 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e중첩된 클래스(nested classes) 및 해당 상태를 사용하는 어노테이션은 여전히 유효합니다. 이들은 로컬 이름 또는 정규화된 이름(fully qualified name)을 사용할 수 있습니다. 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass C:\n    field = 'c_field'\n    def method(self) -\u003e C.field: # OK\n        ...\n    def method(self) -\u003e field: # OK\n        ...\n    def method(self) -\u003e C.D: # OK\n        ...\n    def method(self) -\u003e D: # OK\n        ...\n    class D:\n        field2 = 'd_field'\n        def method(self) -\u003e C.D.field2: # OK\n            ...\n        def method(self) -\u003e D.field2: # 실패, 클래스 D는 C의 로컬이므로\n                                   # C.D로만 접근 가능. PEP 이전에도 마찬가지.\n            ...\n        def method(self) -\u003e field2: # OK\n            ...\n        def method(self) -\u003e field: # 실패, field는 C의 로컬이므로\n                                   # C.field로 접근하지 않으면 D에서 보이지 않음.\n                                   # PEP 이전에도 마찬가지.\n            ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e구문적으로 유효하지 않은 표현식인 어노테이션이 있는 경우, 컴파일 시점에 \u003ccode\u003eSyntaxError\u003c/code\u003e가 발생합니다. 그러나 이름이 해당 시점에 해결되지 않으므로, 사용된 이름이 올바른지 여부를 검증하려는 시도는 이루어지지 않습니다.\u003c/p\u003e\n\u003ch4 id=\"폐기-정책-deprecation-policy\"\u003e\u003ca href=\"#폐기-정책-deprecation-policy\"\u003e폐기 정책 (Deprecation policy)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003ePython 3.7부터는 설명된 기능을 사용하려면 \u003ccode\u003e__future__\u003c/code\u003e import가 필요합니다. 경고는 발생하지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 이 기능이 결국 기본 동작이 될지 여부는 PEP 649에 대한 결정이 보류 중이므로 현재 불분명합니다. 어떠한 경우든, 즉시 평가(eager evaluation)에 의존하는 어노테이션의 사용은 두 제안 모두와 호환되지 않으며 더 이상 지원되지 않습니다.\u003c/p\u003e\n\u003ch4 id=\"전방-참조-forward-references\"\u003e\u003ca href=\"#전방-참조-forward-references\"\u003e전방 참조 (Forward References)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e모듈에서 이름이 정의되기 전에 의도적으로 이름을 사용하는 것을 전방 참조라고 합니다. 이 섹션의 목적을 위해 \u003ccode\u003eif TYPE_CHECKING:\u003c/code\u003e 블록 내에서 임포트되거나 정의된 모든 이름도 전방 참조라고 부를 것입니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 타입 어노테이션의 전방 참조 문제를 해결합니다. 이 경우 문자열 리터럴의 사용은 더 이상 필수가 아닙니다. 그러나 \u003ccode\u003etyping\u003c/code\u003e 모듈에는 언어의 다른 구문 구조를 사용하는 API가 있으며, 이들은 여전히 문자열 리터럴로 전방 참조를 우회해야 합니다. 목록은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e타입 정의:\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eT = TypeVar('T', bound='\u0026#x3C;type\u003e')\nUserId = NewType('UserId', '\u0026#x3C;type\u003e')\nEmployee = NamedTuple('Employee', [('name', '\u0026#x3C;type\u003e'), ('id', '\u0026#x3C;type\u003e')])\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e별칭 (aliases):\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eAlias = Optional['\u0026#x3C;type\u003e']\nAnotherAlias = Union['\u0026#x3C;type\u003e', '\u0026#x3C;type\u003e']\nYetAnotherAlias = '\u0026#x3C;type\u003e'\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e캐스팅 (casting):\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecast('\u0026#x3C;type\u003e', value)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e기본 클래스 (base classes):\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass C(Tuple['\u0026#x3C;type\u003e', '\u0026#x3C;type\u003e']): ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e특정 경우에 따라 위 목록의 일부 사례는 \u003ccode\u003eif TYPE_CHECKING:\u003c/code\u003e 블록에 사용을 배치하여 해결할 수 있습니다. 이는 런타임에 사용할 수 있어야 하는 코드, 특히 기본 클래스 및 캐스팅에는 작동하지 않습니다. \u003ccode\u003eNamedTuple\u003c/code\u003e의 경우, Python 3.6에서 도입된 새 클래스 정의 구문을 사용하면 문제가 해결됩니다.\u003c/p\u003e\n\u003cp\u003e일반적으로 모든 전방 참조에 대한 문제를 해결하려면 현재의 단일 패스 하향식(single-pass top-down) 모델에서 Python의 모듈 인스턴스화 방식 변경이 필요합니다. 이는 언어에 대한 주요 변경 사항이므로 이 PEP의 범위 밖입니다.\u003c/p\u003e\n\u003ch3 id=\"기각된-아이디어-rejected-ideas\"\u003e\u003ca href=\"#기각된-아이디어-rejected-ideas\"\u003e기각된 아이디어 (Rejected Ideas)\u003c/a\u003e\u003c/h3\u003e\n\u003ch4 id=\"어노테이션-정의-시-함수-로컬-상태-사용-기능-유지-keeping-the-ability-to-use-function-local-state-when-defining-annotations\"\u003e\u003ca href=\"#어노테이션-정의-시-함수-로컬-상태-사용-기능-유지-keeping-the-ability-to-use-function-local-state-when-defining-annotations\"\u003e어노테이션 정의 시 함수 로컬 상태 사용 기능 유지 (Keeping the ability to use function local state when defining annotations)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e지연 평가를 통해, 이는 어노테이션이 생성된 프레임에 대한 참조를 유지해야 합니다. 예를 들어, 모든 어노테이션을 문자열 대신 람다(lambdas)로 저장함으로써 달성할 수 있습니다. 이는 고도로 어노테이션된 코드의 경우 프레임이 모든 객체를 활성 상태로 유지하므로 엄청나게 비쌀 것입니다.\u003c/p\u003e\n\u003cp\u003e클래스 수준 스코프를 처리하려면 람다 접근 방식은 인터프리터에 새로운 종류의 셀(cell)을 요구할 것입니다. 이는 \u003ccode\u003e__annotations__\u003c/code\u003e에 나타날 수 있는 타입의 수를 증식시킬 뿐만 아니라, 문자열만큼 내부를 들여다볼 수 없을 것입니다.\u003c/p\u003e\n\u003cp\u003e중첩 클래스의 경우, 정의 시점에 효과적인 \"globals\" 및 \"locals\"를 가져오는 기능은 \u003ccode\u003etyping.get_type_hints()\u003c/code\u003e에 의해 제공됩니다.\u003c/p\u003e\n\u003cp\u003e어노테이션이 로컬 변수를 사용해야 하는 클래스 또는 함수를 생성하는 함수는 컴파일러에 의존하지 않고 생성된 객체의 \u003ccode\u003e__annotations__\u003c/code\u003e 딕셔너리를 직접 채울 수 있습니다.\u003c/p\u003e\n\u003ch4 id=\"클래스에도-로컬-상태-사용-금지-disallowing-local-state-usage-for-classes-too\"\u003e\u003ca href=\"#클래스에도-로컬-상태-사용-금지-disallowing-local-state-usage-for-classes-too\"\u003e클래스에도 로컬 상태 사용 금지 (Disallowing local state usage for classes, too)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e이 PEP는 원래 어노테이션 내의 이름을 모듈 수준 스코프의 이름으로만 제한할 것을 제안했으며, 클래스의 경우에도 마찬가지였습니다. 저자는 이것이 로컬 이름과 모듈 수준 이름 간의 충돌을 포함하여 이름 해결을 모호하지 않게 만든다고 주장했습니다.\u003c/p\u003e\n\u003cp\u003e이 아이디어는 결국 클래스의 경우 기각되었습니다. 대신 \u003ccode\u003etyping.get_type_hints()\u003c/code\u003e가 클래스 수준 어노테이션이 필요한 경우 로컬 네임스페이스를 올바르게 채우도록 수정되었습니다.\u003c/p\u003e\n\u003cp\u003e이 아이디어를 기각한 이유는 Python에서 스코프(scoping)가 작동하는 방식의 직관에 어긋나고, 기존 타입 어노테이션을 충분히 깨뜨려 전환을 번거롭게 만들 것이기 때문입니다. 마지막으로, 클래스 데코레이터가 타입 어노테이션을 평가할 수 있으려면 로컬 스코프 접근이 필요합니다. 이는 클래스 데코레이터가 외부 스코프에서 클래스가 이름을 받기 전에 적용되기 때문입니다.\u003c/p\u003e\n\u003ch4 id=\"문자열-리터럴-형태를-위한-새-딕셔너리-도입-introducing-a-new-dictionary-for-the-string-literal-form-instead\"\u003e\u003ca href=\"#문자열-리터럴-형태를-위한-새-딕셔너리-도입-introducing-a-new-dictionary-for-the-string-literal-form-instead\"\u003e문자열 리터럴 형태를 위한 새 딕셔너리 도입 (Introducing a new dictionary for the string literal form instead)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eYury Selivanov는 다음 아이디어를 공유했습니다: 함수에 \u003ccode\u003e__annotations_text__\u003c/code\u003e라는 새로운 특별 속성을 추가합니다. \u003ccode\u003e__annotations__\u003c/code\u003e를 지연 동적 매핑으로 만들어, \u003ccode\u003e__annotations_text__\u003c/code\u003e의 해당 키에서 표현식을 Just-In-Time으로 평가합니다.\u003c/p\u003e\n\u003cp\u003e이 아이디어는 하위 호환성 문제를 해결하고 새 \u003ccode\u003e__future__\u003c/code\u003e import의 필요성을 제거하기 위한 것이었습니다. 그러나 지연 평가는 어노테이션이 접근할 수 있는 상태를 변경합니다. 지연 평가가 전방 참조 문제를 해결하지만, 함수 수준의 \u003ccode\u003elocals\u003c/code\u003e에 더 이상 접근할 수 없게 만듭니다. 이것만으로도 하위 호환성 위반의 원인이 되며, 이는 폐기 기간을 정당화합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__future__\u003c/code\u003e import는 새로운 기능을 선택한다는 명확하고 명시적인 지표입니다. 또한 외부 도구가 이전 방식 또는 새 방식을 사용하는 Python 파일 간의 차이를 쉽게 인식하게 합니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, \u003ccode\u003eget_type_hints()\u003c/code\u003e가 나중에 사용되는 경우 \u003ccode\u003e__annotations__\u003c/code\u003e에서의 Just-In-Time 평가는 불필요한 단계입니다.\u003c/p\u003e\n\u003ch4 id=\"-o-옵션으로-어노테이션-제거-dropping-annotations-with--o\"\u003e\u003ca href=\"#-o-옵션으로-어노테이션-제거-dropping-annotations-with--o\"\u003e\u003ccode\u003e-O\u003c/code\u003e 옵션으로 어노테이션 제거 (Dropping annotations with -O)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e이 PEP의 목적을 위해 이것이 만족스럽지 않은 두 가지 이유가 있습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e이것은 런타임 비용만 다루며, 전방 참조는 다루지 않습니다. 라이브러리 관리자는 전방 참조를 사용할 수 없을 것입니다. 이는 라이브러리 사용자가 새로운 가상의 \u003ccode\u003e-O\u003c/code\u003e 스위치를 사용하도록 강요하기 때문입니다.\u003c/li\u003e\n\u003cli\u003e이것은 \"목욕물과 함께 아기를 버리는\" 격입니다. 이제 런타임 어노테이션 사용은 전혀 수행할 수 없게 됩니다. PEP 557은 런타임에 타입 어노테이션을 평가하는 것이 유용한 최근 개발의 한 예입니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e그럼에도 불구하고, 어노테이션을 제거하는 세분화된 \u003ccode\u003e-O\u003c/code\u003e 옵션은 기존 \u003ccode\u003e-O\u003c/code\u003e 동작(docstring 및 assert 문 제거)과 개념적으로 호환되므로 미래에 가능할 수 있습니다. 이 PEP는 이 아이디어를 무효화하지 않습니다.\u003c/p\u003e\n\u003ch4 id=\"어노테이션의-문자열-리터럴을-__annotations__에-그대로-전달-passing-string-literals-in-annotations-verbatim-to-annotations\"\u003e\u003ca href=\"#어노테이션의-문자열-리터럴을-__annotations__에-그대로-전달-passing-string-literals-in-annotations-verbatim-to-annotations\"\u003e어노테이션의 문자열 리터럴을 \u003ccode\u003e__annotations__\u003c/code\u003e에 그대로 전달 (Passing string literals in annotations verbatim to \u003cstrong\u003eannotations\u003c/strong\u003e)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e이 PEP는 원래 문자열 리터럴의 내용을 \u003ccode\u003e__annotations__\u003c/code\u003e의 해당 키 아래에 직접 저장할 것을 제안했습니다. 이는 런타임 타입 검사기(runtime type checkers)를 위한 지원을 단순화하기 위한 것이었습니다. Mark Shannon은 이 아이디어가 문자열이 타입 어노테이션의 일부일 때의 상황을 처리하지 못하므로 결함이 있다고 지적했습니다. 이 아이디어의 불일치성은 항상 명백했지만, 어쨌든 문자열의 이중 래핑(double-wrapping) 사례를 완전히 방지하지 못했기 때문에 가치가 없었습니다.\u003c/p\u003e\n\u003ch4 id=\"__future__-import의-이름을-더-길게-만들기-making-the-name-of-the-future-import-more-verbose\"\u003e\u003ca href=\"#__future__-import의-이름을-더-길게-만들기-making-the-name-of-the-future-import-more-verbose\"\u003e\u003ccode\u003e__future__\u003c/code\u003e import의 이름을 더 길게 만들기 (Making the name of the future import more verbose)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e다음 import를 요구하는 대신:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom __future__ import annotations\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 PEP는 기능을 더 명시적으로 호출할 수 있습니다. 예를 들어, \u003ccode\u003estring_annotations\u003c/code\u003e, \u003ccode\u003estringify_annotations\u003c/code\u003e, \u003ccode\u003eannotation_strings\u003c/code\u003e, \u003ccode\u003eannotations_as_strings\u003c/code\u003e, \u003ccode\u003elazy_annotations\u003c/code\u003e, \u003ccode\u003estatic_annotations\u003c/code\u003e 등이 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 이름의 문제는 매우 장황하다는 것입니다. \u003ccode\u003elazy_annotations\u003c/code\u003e를 제외한 각 이름은 Python에서 가장 긴 미래 기능 이름이 될 것입니다. 타이핑하기 길고 단어 하나로 된 형태보다 기억하기 어렵습니다.\u003c/p\u003e\n\u003cp\u003e지나치게 일반적으로 들리지만 실제로는 사용자에게 무엇을 하는지 명백했던 \u003ccode\u003e__future__\u003c/code\u003e import 이름의 선례가 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom __future__ import division\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"이전-논의-prior-discussion\"\u003e\u003ca href=\"#이전-논의-prior-discussion\"\u003e이전 논의 (Prior discussion)\u003c/a\u003e\u003c/h3\u003e\n\u003ch4 id=\"pep-484에서-in-pep-484\"\u003e\u003ca href=\"#pep-484에서-in-pep-484\"\u003ePEP 484에서 (In PEP 484)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e전방 참조 문제는 PEP 484가 처음 초안될 때 논의되었으며, 문서에 다음과 같은 진술을 이끌어냈습니다:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e__future__\u003c/code\u003e import를 통해 주어진 모듈의 모든 어노테이션을 문자열 리터럴로 바꿀 수 있는 절충안이 가능하며, 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom __future__ import annotations\nclass ImSet:\n    def add(self, a: ImSet) -\u003e List[ImSet]: ...\nassert ImSet.add.__annotations__ == {\n    'a': 'ImSet',\n    'return': 'List[ImSet]'\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 \u003ccode\u003e__future__\u003c/code\u003e import 문은 별도의 PEP에서 제안될 수 있습니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"pythontyping400\"\u003e\u003ca href=\"#pythontyping400\"\u003epython/typing#400\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e이 문제는 \u003ccode\u003etyping\u003c/code\u003e 모듈의 GitHub 프로젝트, Issue 400에서 심층적으로 논의되었습니다. 거기서의 문제 설명은 \u003ccode\u003etyping\u003c/code\u003e에서 제네릭 타입(generic types)을 임포트해야 하는 것에 대한 비판을 포함합니다. 이는 초보자에게 혼란을 주는 경향이 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 왜 이렇게 해야 하는가:\nfrom typing import List, Set\ndef dir(o: object = ...) -\u003e List[str]: ...\ndef add_friends(friends: Set[Friend]) -\u003e None: ...\n\n# 이렇게는 안 되는가:\ndef dir(o: object = ...) -\u003e list[str]: ...\ndef add_friends(friends: set[Friend]) -\u003e None ...\n\n# 왜 이렇게 해야 하는가:\nup_to_ten = list(range(10))\nfriends = set()\n\n# 이렇게는 안 되는가:\nfrom typing import List, Set\nup_to_ten = List[int](range(10))\nfriends = Set[Friend]()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003etyping\u003c/code\u003e의 유용성은 흥미로운 문제이지만, 이 PEP의 범위 밖입니다. 특히 PEP 484에서 표준화된 \u003ccode\u003etyping\u003c/code\u003e 구문의 확장은 각각의 PEP와 승인을 요구할 것입니다.\u003c/p\u003e\n\u003cp\u003eIssue 400은 궁극적으로 어노테이션의 평가를 지연하고 \u003ccode\u003e__annotations__\u003c/code\u003e에 문자열로 유지할 것을 제안하며, 이는 이 PEP가 명시하는 바와 같습니다. 이 아이디어는 잘 받아들여졌습니다. Ivan Levkivskyi는 \u003ccode\u003e__future__\u003c/code\u003e import 사용을 지지했고, \u003ccode\u003ecompile.c\u003c/code\u003e에서 AST를 역파싱(unparsing)할 것을 제안했습니다. Jukka Lehtosalo는 타입이 어노테이션 외부에서 사용되는 전방 참조의 일부 경우가 있으며, 지연 평가는 도움이 되지 않을 것이라고 지적했습니다. 이러한 경우에는 문자열 리터럴 표기법을 계속 사용해야 할 것입니다. 이러한 사례들은 이 PEP의 \"Forward References\" 섹션에서 간략하게 논의됩니다.\u003c/p\u003e\n\u003cp\u003e이 문제에 대한 가장 큰 논란은 Guido van Rossum의 우려였습니다. 그는 어노테이션 표현식을 다시 문자열 형태로 토큰화하지 않는 것은 Python 프로그래밍 언어에 전례가 없으며 해킹적인 우회책처럼 느껴진다고 말했습니다. 그는 다음과 같이 말했습니다:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\"하나 생각나는 것은 언어에 대한 매우 무작위적인 변경이라는 것입니다. 표현식의 지연 실행을 나타내는 더 간결한 방법이 있으면 유용할 수 있습니다 ( \u003ccode\u003elambda:\u003c/code\u003e보다 적은 구문을 사용하여). 그러나 이 특정 사용 사례에 대한 해결책이 이미 존재하고 매우 최소한의 구문을 요구하는데, 타입 어노테이션의 사용 사례가 언어를 먼저 변경해야 할 만큼 그렇게 중요한 이유는 무엇일까요 (더 일반적인 해결책을 제안하기보다는)?\"\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e결국 Ethan Smith와 schollii는 PyCon US에서 수집된 피드백이 전방 참조 상태를 수정해야 함을 시사한다고 말했습니다. Guido van Rossum은 \u003ccode\u003e__future__\u003c/code\u003e 아이디어로 돌아갈 것을 제안하며, 남용을 방지하기 위해 어노테이션이 구문적으로 유효하고 런타임에 올바르게 평가되는 것이 중요하다고 지적했습니다.\u003c/p\u003e\n\u003ch4 id=\"python-ideas에서의-첫-번째-초안-논의-first-draft-discussion-on-python-ideas\"\u003e\u003ca href=\"#python-ideas에서의-첫-번째-초안-논의-first-draft-discussion-on-python-ideas\"\u003epython-ideas에서의 첫 번째 초안 논의 (First draft discussion on python-ideas)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e논의는 주로 두 스레드, 즉 원래 발표와 \u003ccode\u003ePEP 563 and expensive backwards compatibility\u003c/code\u003e라는 후속 스레드에서 이루어졌습니다.\u003c/p\u003e\n\u003cp\u003ePEP는 상당히 긍정적인 피드백을 받았습니다 (4명이 강력하게 찬성, 2명이 우려와 함께 찬성, 2명이 반대). 이전 스레드에서 가장 큰 우려의 목소리는 Steven D'Aprano의 검토였습니다. 그는 PEP의 문제 정의가 하위 호환성을 깨뜨리는 것을 정당화하지 못한다고 주장했습니다. 이 답변에서 Steven은 주로 Python이 더 이상 로컬 함수/클래스 상태에 의존하는 어노테이션의 평가를 지원하지 않는 것에 대해 우려하는 것처럼 보였습니다.\u003c/p\u003e\n\u003cp\u003e몇몇 사람들은 어노테이션을 비-타이핑 목적으로 사용하는 라이브러리가 있다는 우려를 표명했습니다. 그러나 언급된 라이브러리 중 어느 것도 이 PEP에 의해 무효화되지 않을 것입니다. 그들은 어노테이션에 대해 올바른 \u003ccode\u003eglobals\u003c/code\u003e와 \u003ccode\u003elocals\u003c/code\u003e를 설정하여 \u003ccode\u003eeval()\u003c/code\u003e을 호출하는 새로운 요구 사항에 적응해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eglobals\u003c/code\u003e와 \u003ccode\u003elocals\u003c/code\u003e가 올바르게 설정되어야 한다는 이 세부 사항은 많은 논평자들에 의해 언급되었습니다. Alyssa (Nick) Coghlan은 어노테이션을 문자열 대신 람다로 바꾸는 벤치마크를 수행했지만, 안타깝게도 이는 현재 상황보다 런타임에 훨씬 느리다는 것이 입증되었습니다.\u003c/p\u003e\n\u003cp\u003e후자의 스레드는 Jim J. Jewett에 의해 시작되었는데, 그는 어노테이션을 제대로 평가하는 능력이 중요한 요구 사항이며, 이와 관련하여 하위 호환성이 가치 있다고 강조했습니다. 그는 논의 후 어노테이션의 부작용(side effects)이 코드 스멜(code smell)이며, 평가를 수행할지 말지를 선택하는 모달 지원은 지저분한 해결책이라고 인정했습니다. 그의 가장 큰 우려는 전역 및 로컬 스코프의 평가 제한으로 인해 발생하는 기능 손실이었습니다.\u003c/p\u003e\n\u003cp\u003eAlyssa Coghlan은 PEP의 일부 평가 제한이 영리한 평가 도우미(evaluation helper) 구현으로 해제될 수 있으며, 이는 클래스 데코레이터 형태에서도 자기 참조 클래스(self-referencing classes)를 해결할 수 있다고 지적했습니다. 그녀는 PEP가 표준 라이브러리에 이 도우미 함수를 제공해야 한다고 제안했습니다.\u003c/p\u003e\n\u003ch4 id=\"python-dev에서의-두-번째-초안-논의-second-draft-discussion-on-python-dev\"\u003e\u003ca href=\"#python-dev에서의-두-번째-초안-논의-second-draft-discussion-on-python-dev\"\u003epython-dev에서의 두 번째 초안 논의 (Second draft discussion on python-dev)\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e논의는 주로 발표 스레드에서 이루어졌으며, Mark Shannon의 게시물 아래에서 간략한 논의가 이어졌습니다.\u003c/p\u003e\n\u003cp\u003eSteven D'Aprano는 PEP가 제안한 변경 후 어노테이션에 오타가 허용되는 것이 허용되는지 우려했습니다. Brett Cannon은 타입 검사기 및 다른 정적 분석기(린터나 프로그래밍 텍스트 편집기 등)가 이러한 유형의 오류를 잡아낼 것이라고 응답했습니다. Jukka Lehtosalo는 이 상황이 함수 본문의 이름이 함수가 호출될 때까지 해결되지 않는 방식과 유사하다고 덧붙였습니다.\u003c/p\u003e\n\u003cp\u003e논의의 주요 주제는 Alyssa Coghlan의 어노테이션을 \"thunk form\"으로 저장하자는 제안이었습니다. 즉, 클래스 수준 스코프에 접근할 수 있고 (호출 시 스코프 사용자 정의를 허용하는) 특수화된 람다 형태였습니다. 그는 이에 대한 가능한 설계를 제시했습니다 (간접 속성 셀). 이는 나중에 Lisp의 \"특수 형태\"와 동등한 것으로 간주되었습니다. Guido van Rossum은 이러한 종류의 기능이 12주 안에 (즉, Python 3.7 베타 동결 전에) 안전하게 구현될 수 있을지 우려를 표했습니다.\u003c/p\u003e\n\u003cp\u003e얼마 후, 문자열 형태 지지자와 thunk 형태 지지자 간의 분열점은 실제로 어노테이션이 일반적인 구문 요소로 인식되어야 하는지 아니면 타입 검사 사용 사례에 묶인 것으로 인식되어야 하는지에 관한 것임이 분명해졌습니다.\u003c/p\u003e\n\u003cp\u003e마침내 Guido van Rossum은 thunk 아이디어가 인터프리터에 새로운 빌딩 블록을 요구할 것이라는 사실에 근거하여 이를 거부한다고 선언했습니다. 이 블록은 어노테이션에 노출되어 \u003ccode\u003e__annotations__\u003c/code\u003e에 저장될 수 있는 값의 유형(임의 객체, 문자열, 이제는 thunk)을 증식시킬 것입니다. 또한 thunk는 문자열만큼 내부를 들여다볼 수 없습니다. 가장 중요하게, Guido van Rossum은 어노테이션의 사용을 점진적으로 정적 타이핑(선택적 런타임 구성 요소 포함)으로 제한하는 데 명시적인 관심을 표명했습니다.\u003c/p\u003e\n\u003cp\u003eAlyssa Coghlan도 PEP 563에 설득되었고, 즉시 \u003ccode\u003e__future__\u003c/code\u003e import 이름에 대한 의무적인 \"bike shedding\" 세션을 시작했습니다. 많은 토론자들은 \u003ccode\u003eannotations\u003c/code\u003e가 기능 이름으로는 지나치게 광범위한 이름처럼 보인다는 데 동의했습니다. Guido van Rossum은 잠시 \u003ccode\u003estring_annotations\u003c/code\u003e라고 부르기로 결정했지만, \u003ccode\u003edivision\u003c/code\u003e이 명확한 의미를 가진 광범위한 이름의 선례라고 주장하며 마음을 바꿨습니다.\u003c/p\u003e\n\u003cp\u003eMark Shannon이 논의에서 제안한 PEP에 대한 최종 개선 사항은 문자열 리터럴을 \u003ccode\u003e__annotations__\u003c/code\u003e에 그대로 전달하려는 유혹을 거부하는 것이었습니다.\u003c/p\u003e\n\u003cp\u003e정적 타이핑의 런타임 패널티에 대한 부차적인 논의 스레드가 시작되었으며, \u003ccode\u003etyping\u003c/code\u003e 모듈의 임포트 시간(종속성 없이 \u003ccode\u003ere\u003c/code\u003e와 비슷하고, 종속성을 포함하면 \u003ccode\u003ere\u003c/code\u003e보다 세 배 무겁다)과 같은 주제가 다루어졌습니다.\u003c/p\u003e\n\u003ch3 id=\"감사-acknowledgements\"\u003e\u003ca href=\"#감사-acknowledgements\"\u003e감사 (Acknowledgements)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e이 문서는 Guido van Rossum, Jukka Lehtosalo, Ivan Levkivskyi의 귀중한 의견, 격려 및 조언 없이는 완성될 수 없었습니다. 구현은 Serhiy Storchaka가 철저히 검토하여 버그, 낮은 가독성, 성능 문제 등 모든 종류의 문제를 발견했습니다.\u003c/p\u003e\n\u003ch3 id=\"저작권-copyright\"\u003e\u003ca href=\"#저작권-copyright\"\u003e저작권 (Copyright)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e이 문서는 공개 도메인에 배포되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"BlogPosting\\\",\\\"headline\\\":\\\"[Superseded] PEP 563 - Postponed Evaluation of Annotations\\\",\\\"description\\\":\\\"Python Enhancement Proposal 563: 'Postponed Evaluation of Annotations'에 대한 한국어 번역입니다.\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud/python/pep/563\\\",\\\"datePublished\\\":\\\"2025-09-26T14:48:31.000Z\\\",\\\"dateModified\\\":\\\"2025-09-26T14:48:31.000Z\\\",\\\"author\\\":{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"secrett2633\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud\\\"},\\\"publisher\\\":{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"secrett2633\\\",\\\"url\\\":\\\"https://blog.secrett2633.cloud\\\"},\\\"mainEntityOfPage\\\":{\\\"@type\\\":\\\"WebPage\\\",\\\"@id\\\":\\\"https://blog.secrett2633.cloud/python/pep/563\\\"},\\\"image\\\":\\\"https://blog.secrett2633.cloud/og-default.png\\\",\\\"isAccessibleForFree\\\":true,\\\"inLanguage\\\":\\\"ko\\\",\\\"wordCount\\\":2942,\\\"articleSection\\\":\\\"Python\\\",\\\"keywords\\\":\\\"Python, PEP, Translation\\\"}\"}}],[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"BreadcrumbList\\\",\\\"itemListElement\\\":[{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":1,\\\"name\\\":\\\"홈\\\",\\\"item\\\":\\\"https://blog.secrett2633.cloud/\\\"},{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":2,\\\"name\\\":\\\"[Superseded] PEP 563 - Postponed Evaluation of Annotations\\\",\\\"item\\\":\\\"https://blog.secrett2633.cloud/python/pep/563\\\"}]}\"}}],[\"$\",\"div\",null,{\"className\":\"space-y-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"aria-label\":\"카테고리 네비게이션\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"p\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/backend/django\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/backend/logging\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"p\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/python/pep\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"p\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/ai/llm\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/ai/review\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2741,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"p\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/nginx\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/docker\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/safeline\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/jenkins\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/github-actions\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/devops/aws\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"p\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/etc/me\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"$La\",null,{\"href\":\"/etc/chrome-extension\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"div\",null,{\"className\":\"flex-1\",\"children\":[[\"$\",\"nav\",null,{\"aria-label\":\"breadcrumb\",\"className\":\"text-sm text-gray-500 mb-4\",\"children\":[\"$\",\"ol\",null,{\"className\":\"flex flex-wrap items-center gap-1\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"hover:text-gray-700\",\"children\":\"홈\"}]}],[[\"$\",\"li\",\"/python/pep/563\",{\"className\":\"flex items-center gap-1\",\"children\":[[\"$\",\"span\",null,{\"aria-hidden\":\"true\",\"children\":\"/\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-900\",\"aria-current\":\"page\",\"children\":\"[Superseded] PEP 563 - Postponed Evaluation of Annotations\"}]]}]]]}]}],[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Superseded] PEP 563 - Postponed Evaluation of Annotations\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:48:31+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"time\",null,{\"className\":\"ml-4\",\"dateTime\":\"2025-09-26T14:48:31.000Z\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$f\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2 block\",\"children\":\"태그\"}],[[\"$\",\"$La\",\"Python\",{\"href\":\"/tags/Python\",\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"$La\",\"PEP\",{\"href\":\"/tags/PEP\",\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"$La\",\"Translation\",{\"href\":\"/tags/Translation\",\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$L10\",null,{\"postPermalink\":\"/python/pep/563\",\"postId\":\"2025-09-26-pep-0563-postponed-evaluation-of-annotations\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/562\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 562 - Module __getattr__ and __dir__\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Superseded] PEP 563 - Postponed Evaluation of Annotations\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/564\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 564 - Add new time functions with nanosecond resolution\"}]]}]]}]]}]]}]]}]]}]}]]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"[Superseded] PEP 563 - Postponed Evaluation of Annotations - secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Python Enhancement Proposal 563: 'Postponed Evaluation of Annotations'에 대한 한국어 번역입니다.\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"link\",\"5\",{\"rel\":\"manifest\",\"href\":\"/manifest.json\",\"crossOrigin\":\"use-credentials\"}],[\"$\",\"meta\",\"6\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"7\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"9\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"10\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"11\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/python/pep/563\"}],[\"$\",\"meta\",\"12\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:title\",\"content\":\"[Superseded] PEP 563 - Postponed Evaluation of Annotations\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:description\",\"content\":\"Python Enhancement Proposal 563: 'Postponed Evaluation of Annotations'에 대한 한국어 번역입니다.\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/python/pep/563\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"17\",{\"property\":\"article:published_time\",\"content\":\"2025-09-26T14:48:31.000Z\"}],[\"$\",\"meta\",\"18\",{\"property\":\"article:modified_time\",\"content\":\"2025-09-26T14:48:31.000Z\"}],[\"$\",\"meta\",\"19\",{\"property\":\"article:author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"20\",{\"property\":\"article:section\",\"content\":\"Python\"}],[\"$\",\"meta\",\"21\",{\"property\":\"article:tag\",\"content\":\"Python\"}],[\"$\",\"meta\",\"22\",{\"property\":\"article:tag\",\"content\":\"PEP\"}],[\"$\",\"meta\",\"23\",{\"property\":\"article:tag\",\"content\":\"Translation\"}],[\"$\",\"meta\",\"24\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"25\",{\"name\":\"twitter:creator\",\"content\":\"@secrett2633\"}],[\"$\",\"meta\",\"26\",{\"name\":\"twitter:title\",\"content\":\"[Superseded] PEP 563 - Postponed Evaluation of Annotations\"}],[\"$\",\"meta\",\"27\",{\"name\":\"twitter:description\",\"content\":\"Python Enhancement Proposal 563: 'Postponed Evaluation of Annotations'에 대한 한국어 번역입니다.\"}],[\"$\",\"link\",\"28\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"29\",{\"name\":\"next-size-adjust\"}]]\n"])</script><script>self.__next_f.push([1,"4:null\n"])</script></body></html>