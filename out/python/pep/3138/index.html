<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-1a135130af3e1cae.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1318<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 3138 - String representation in Python 3000</h1><div class="page__meta"><time dateTime="2025-09-27 14:35:12+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-3138/">PEP 3138 - String representation in Python 3000</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 05-May-2008</p>
</blockquote>
<h1>PEP 3138 – Python 3000에서의 문자열 표현 (String representation in Python 3000)</h1>
<ul>
<li><strong>작성자:</strong> Atsuo Ishimoto </li>
<li><strong>상태:</strong> 최종 (Final)</li>
<li><strong>유형:</strong> 표준 트랙 (Standards Track)</li>
<li><strong>생성일:</strong> 2008년 5월 5일</li>
<li><strong>Python 버전:</strong> 3.0</li>
<li><strong>최근 이력:</strong> 2008년 5월 5일, 2008년 6월 5일</li>
</ul>
<h2>요약 (Abstract)</h2>
<p>이 PEP는 Python 3000(Python 3.x의 초기 명칭)을 위한 새로운 문자열 표현 형식을 제안합니다. Python 3000 이전 버전의 Python에서는 내장 함수 <code>repr()</code>이 디버깅 및 로깅을 위해 임의의 객체를 인쇄 가능한 ASCII 문자열로 변환했습니다. Python 3000에서는 유니코드 표준을 기반으로 더 넓은 범위의 문자를 '인쇄 가능'하다고 간주해야 한다는 제안입니다.</p>
<h2>동기 (Motivation)</h2>
<p>기존 <code>repr()</code> 함수는 다음 알고리즘을 사용하여 8비트 문자열을 ASCII로 변환합니다.</p>
<ol>
<li>CR, LF, TAB 및 <code>\</code>를 각각 <code>\r</code>, <code>\n</code>, <code>\t</code>, <code>\\</code>로 변환합니다.</li>
<li>다른 인쇄 불가능한 문자(0x00-0x1f, 0x7f)와 비-ASCII 문자(>= 0x80)를 <code>\xXX</code> 형식으로 변환합니다.</li>
<li>인용 부호(' 또는 <code>_</code>)를 백슬래시로 이스케이프하고, 문자열의 시작과 끝에 인용 부호를 추가합니다.</li>
</ol>
<p>유니코드 문자열의 경우, 다음 추가 변환이 수행됩니다.</p>
<ol>
<li>후행 문자 없는 선행 서러게이트 쌍 문자(0xd800-0xdbff 범위이나 0xdc00-0xdfff가 뒤따르지 않는 경우)를 <code>\uXXXX</code> 형식으로 변환합니다.</li>
<li>16비트 문자(>= 0x100)를 <code>\uXXXX</code> 형식으로 변환합니다.</li>
<li>21비트 문자(>= 0x10000) 및 서러게이트 쌍 문자를 <code>\U00xxxxxx</code> 형식으로 변환합니다.</li>
</ol>
<p>이 알고리즘은 모든 문자열을 인쇄 가능한 ASCII로 변환하며, <code>repr()</code>은 디버깅이나 로깅을 위해 문자열을 출력하는 편리하고 안전한 방법으로 사용됩니다. 모든 비-ASCII 문자는 이스케이프되지만, 대부분의 문자열 문자가 ASCII인 경우에는 문제가 되지 않습니다. 그러나 일본어와 같이 문자열의 대부분이 비-ASCII 문자인 다른 언어의 경우, 이는 매우 불편합니다.</p>
<p><code>print(aJapaneseString)</code>을 사용하여 읽기 쉬운 문자열을 얻을 수 있지만, 리스트(list)나 튜플(tuple)과 같은 컬렉션(collection)에서 문자열을 출력하는 유사한 해결책은 없습니다. <code>print(listOfJapaneseStrings)</code>는 <code>repr()</code>을 사용하여 출력할 문자열을 구성하므로, 결과 문자열은 항상 헥스(hex) 이스케이프된 상태입니다. 또는 <code>open(japaneseFilename)</code>이 예외를 발생시킬 때, 오류 메시지가 <code>IOError: [Errno 2] No such file or directory: '\u65e5\u672c\u8a9e'</code>와 같이 표시되어 전혀 도움이 되지 않습니다.</p>
<p>Python 3000은 비-ASCII 식별자(identifier)와 같이 비-라틴어 사용자에게 많은 유용한 기능을 제공하므로, 인쇄 가능한 출력(printable output)에서도 유사한 방식으로 발전한다면 도움이 될 것입니다.</p>
<p>일부 사용자는 이미지와 같은 이진 데이터를 출력할 경우 콘솔이 엉망이 될 것을 우려할 수 있습니다. 그러나 Python 3000에서는 바이트(bytes)와 문자열(strings)이 서로 다른 유형이므로, 콘솔에 이미지를 출력하는 것이 콘솔을 엉망으로 만들 가능성은 낮기 때문에 실제로 이런 일은 발생하지 않을 것입니다.</p>
<p>이 문제는 이전에 Hye-Shik Chang에 의해 논의되었지만, 거부되었습니다.</p>
<h2>명세 (Specification)</h2>
<h3><code>Py_UNICODE_ISPRINTABLE</code> 함수 추가</h3>
<p>Python C API에 새로운 함수 <code>int Py_UNICODE_ISPRINTABLE(Py_UNICODE ch)</code>를 추가합니다. 이 함수는 <code>repr()</code>이 유니코드 문자 <code>ch</code>를 이스케이프해야 하는 경우 0을 반환하고, 그렇지 않으면 1을 반환합니다. 이스케이프되어야 할 문자는 유니코드 문자 데이터베이스에서 다음과 같이 정의됩니다.</p>
<ul>
<li><code>Cc</code> (Other, Control): 제어 문자</li>
<li><code>Cf</code> (Other, Format): 형식 문자</li>
<li><code>Cs</code> (Other, Surrogate): 서러게이트 (대리) 문자</li>
<li><code>Co</code> (Other, Private Use): 개인 사용 영역 문자</li>
<li><code>Cn</code> (Other, Not Assigned): 할당되지 않은 문자</li>
<li><code>Zl</code> (Separator, Line): <code>LINE SEPARATOR</code> (<code>\u2028</code>)를 의미합니다.</li>
<li><code>Zp</code> (Separator, Paragraph): <code>PARAGRAPH SEPARATOR</code> (<code>\u2029</code>)를 의미합니다.</li>
<li><code>Zs</code> (Separator, Space): ASCII 공백 (<code>\x20</code>) 이외의 구분 공백 문자. 모호함을 피하기 위해 이 범주의 문자는 이스케이프되어야 합니다.</li>
</ul>
<h3><code>repr()</code> 문자열 생성 알고리즘 변경</h3>
<p><code>repr()</code> 문자열을 생성하는 알고리즘은 다음과 같이 변경되어야 합니다.</p>
<ol>
<li>CR, LF, TAB 및 <code>\</code>를 <code>\r</code>, <code>\n</code>, <code>\t</code>, <code>\\</code>로 변환합니다.</li>
<li>인쇄 불가능한 ASCII 문자(0x00-0x1f, 0x7f)를 <code>\xXX</code> 형식으로 변환합니다.</li>
<li>후행 문자 없는 선행 서러게이트 쌍 문자(0xd800-0xdbff 범위이나 0xdc00-0xdfff가 뒤따르지 않는 경우)를 <code>\uXXXX</code> 형식으로 변환합니다.</li>
<li><code>Py_UNICODE_ISPRINTABLE()</code>이 0을 반환하는 인쇄 불가능한 문자를 <code>\xXX</code>, <code>\uXXXX</code> 또는 <code>\U00xxxxxx</code> 형식으로 변환합니다.</li>
<li>인용 부호(<code>'</code>)를 백슬래시로 이스케이프하고, 문자열의 시작과 끝에 인용 부호를 추가합니다.</li>
</ol>
<h3><code>sys.stderr</code> 기본 에러 핸들러 변경</h3>
<p><code>sys.stderr</code>의 유니코드 에러 핸들러(error-handler)를 기본적으로 <code>'backslashreplace'</code>로 설정합니다.</p>
<h3><code>PyObject_ASCII</code> 함수 추가</h3>
<p>Python C API에 새로운 함수 <code>PyObject *PyObject_ASCII(PyObject *o)</code>를 추가합니다. 이 함수는 <code>PyObject_Repr()</code>을 사용하여 파이썬 객체를 문자열로 변환한 다음, 모든 비-ASCII 문자를 헥스 이스케이프합니다. <code>PyObject_ASCII()</code>는 Python 2의 <code>PyObject_Repr()</code>과 동일한 문자열을 생성합니다.</p>
<h3><code>ascii()</code> 내장 함수 추가</h3>
<p>새로운 내장 함수 <code>ascii()</code>를 추가합니다. 이 함수는 <code>repr()</code>을 사용하여 파이썬 객체를 문자열로 변환한 다음, 모든 비-ASCII 문자를 헥스 이스케이프합니다. <code>ascii()</code>는 Python 2의 <code>repr()</code>과 동일한 문자열을 생성합니다.</p>
<h3><code>%a</code> 문자열 포맷 연산자 및 관련 기능 추가</h3>
<ul>
<li><code>%a</code> 문자열 포맷 연산자를 추가합니다. <code>%a</code>는 <code>repr()</code>을 사용하여 파이썬 객체를 문자열로 변환한 다음, 모든 비-ASCII 문자를 헥스 이스케이프합니다. <code>%a</code> 포맷 연산자는 Python 2의 <code>%r</code>과 동일한 문자열을 생성합니다.</li>
<li><code>str.format()</code> 메서드에 <code>!a</code> 변환 플래그를 추가합니다.</li>
<li><code>PyUnicode_FromFormat()</code>에 <code>%A</code> 연산자를 추가합니다.
이들은 <code>%a</code> 문자열 포맷 연산자와 같이 모든 객체를 ASCII 문자열로 변환합니다.</li>
</ul>
<h3><code>str.isprintable()</code> 메서드 추가</h3>
<p>문자열 유형에 <code>isprintable()</code> 메서드를 추가합니다. <code>str.isprintable()</code>은 문자열의 어떤 문자라도 <code>repr()</code>이 이스케이프할 경우 <code>False</code>를 반환하고, 그렇지 않으면 <code>True</code>를 반환합니다. <code>isprintable()</code> 메서드는 내부적으로 <code>Py_UNICODE_ISPRINTABLE()</code> 함수를 호출합니다.</p>
<h2>근거 (Rationale)</h2>
<p>Python 3000의 <code>repr()</code>은 Python 3000의 문자열과 마찬가지로 ASCII 기반이 아닌 유니코드 기반이어야 합니다. 또한, 로케일(locale) 설정은 출력 장치의 로케일과 반드시 같지 않으므로, 변환이 로케일 설정에 영향을 받아서는 안 됩니다. 예를 들어, 데몬(daemon) 프로세스가 ASCII 설정으로 호출되지만 UTF-8로 로그 파일에 쓰는 것은 일반적인 경우입니다. 또한, 웹 애플리케이션은 HTML 페이지의 인코딩을 기반으로 오류 정보를 더 읽기 쉬운 형태로 보고하고 싶을 수 있습니다.</p>
<p>사용자 콘솔에서 지원하지 않는 문자는 유니코드 인코더의 에러 핸들러에 의해 출력 시 헥스 이스케이프될 수 있습니다. 출력 파일의 에러 핸들러가 <code>'backslashreplace'</code>인 경우, 그러한 문자는 <code>UnicodeEncodeError</code>를 발생시키지 않고 헥스 이스케이프됩니다. 예를 들어, 기본 인코딩이 ASCII인 경우 <code>print('Hello ¢')</code>는 <code>'Hello \xa2'</code>를 출력합니다. 인코딩이 ISO-8859-1인 경우 <code>'Hello ¢'</code>가 출력됩니다.</p>
<p><code>sys.stdout</code>의 기본 에러 핸들러는 <code>'strict'</code>입니다. 출력을 읽는 다른 애플리케이션이 헥스 이스케이프된 문자를 잘못 해석할 수 있으므로, 지원되지 않는 문자는 쓸 때 감지되어야 합니다. 지원되지 않는 문자가 이스케이프되어야 하는 경우, 에러 핸들러를 명시적으로 변경해야 합니다. <code>sys.stdout</code>과 달리 <code>sys.stderr</code>는 기본적으로 <code>UnicodeEncodingError</code>를 발생시키지 않습니다. 이는 기본 에러 핸들러가 <code>'backslashreplace'</code>이기 때문입니다. 따라서 비-ASCII 문자를 포함하는 오류 메시지를 <code>sys.stderr</code>로 출력해도 예외가 발생하지 않습니다. 또한, 처리되지 않은 예외(예외 객체, 트레이스백)에 대한 정보는 인터프리터에 의해 예외를 발생시키지 않고 출력됩니다.</p>
<h2>대안 솔루션 (Alternate Solutions)</h2>
<p><code>repr()</code>을 변경하지 않고 비-라틴어 사용자의 디버깅을 돕기 위해 다른 제안들이 있었습니다.</p>
<ul>
<li><strong>리스트(list)나 딕트(dict)를 출력하는 도구 제공:</strong> 디버깅을 위해 출력되어야 하는 문자열은 리스트나 딕트뿐만 아니라 다른 많은 종류의 객체에도 포함되어 있습니다. 파일 객체는 유니코드 파일 이름을 포함하고, 예외 객체는 유니코드 메시지를 포함하는 등, 이러한 문자열은 <code>repr()</code>될 때 읽기 쉬운 형태로 출력되어야 합니다. 모든 가능한 객체 유형을 출력하는 도구를 구현하는 것은 불가능할 것입니다.</li>
<li><strong><code>sys.displayhook</code> 및 <code>sys.excepthook</code> 사용:</strong> 대화형 세션의 경우, 헥스 이스케이프된 문자를 원래 문자로 복원하는 훅(hook)을 작성할 수 있습니다. 그러나 이러한 훅은 대화형 Python 세션에서 입력된 표현식의 평가 결과를 출력할 때만 호출되며, <code>print()</code> 함수, 비-대화형 세션 또는 <code>logging.debug("%r", ...)</code> 등에는 작동하지 않습니다.</li>
<li><strong><code>sys.stdout</code> 및 <code>sys.stderr</code> 서브클래싱(subclassing):</strong> 헥스 이스케이프된 문자를 복원하는 서브클래스를 구현하는 것은 어렵습니다. 모든 경우에 이스케이프를 올바르게 되돌리기에 충분한 정보가 문자열이 될 때까지 남아 있지 않기 때문입니다. 예를 들어, <code>print("\\"+"u0041")</code>는 'A'가 아니라 <code>'\u0041'</code>로 출력되어야 합니다. 그러나 파일 객체를 구별할 기회가 없습니다.</li>
<li><strong><code>unicode_repr()</code>에서 사용되는 인코딩을 조정 가능하게 하고, 기존 <code>repr()</code>을 기본값으로 설정:</strong> 조정 가능한 <code>repr()</code>을 사용하면 <code>repr()</code>의 결과가 예측 불가능해지고, <code>repr()</code>과 관련된 올바른 코드를 작성하는 것이 불가능해질 수 있습니다. 그리고 현재 <code>repr()</code>이 기본값이라면, 기존 관행이 유지되고 사용자는 <code>repr()</code>의 결과로 ASCII 문자열을 기대할 수 있습니다. 사용자 정의 <code>repr()</code> 함수가 사용될 때 서드파티 애플리케이션이나 라이브러리가 혼란스러워할 수 있습니다.</li>
</ul>
<h2>하위 호환성 (Backwards Compatibility)</h2>
<p><code>repr()</code> 변경은 일부 기존 코드, 특히 테스트 코드를 손상시킬 수 있습니다. Python의 회귀 테스트(regression tests) 중 5개가 이 수정으로 인해 실패합니다. Python 2처럼 비-ASCII 문자가 없는 <code>repr()</code> 문자열이 필요한 경우 다음 함수를 사용할 수 있습니다.</p>
<pre><code class="language-python">def repr_ascii(obj):
    return str(repr(obj).encode("ASCII", "backslashreplace"), "ASCII")
</code></pre>
<p>로깅이나 디버깅을 위해 다음 코드는 <code>UnicodeEncodeError</code>를 발생시킬 수 있습니다.</p>
<pre><code class="language-python">log = open("logfile", "w")
log.write(repr(data)) # data에 지원되지 않는 문자가 포함된 경우 UnicodeEncodeError가 발생합니다.
</code></pre>
<p>예외 발생을 피하려면 에러 핸들러를 명시적으로 지정할 수 있습니다.</p>
<pre><code class="language-python">log = open("logfile", "w", errors="backslashreplace")
log.write(repr(data)) # 지원되지 않는 문자는 이스케이프됩니다.
</code></pre>
<p><code>en_US.utf8</code> 또는 <code>de_DE.utf8</code>과 같이 유니코드 기반 인코딩을 사용하는 콘솔의 경우, 백슬래시 교체(backslashreplace) 트릭이 작동하지 않고 모든 인쇄 가능한 문자가 이스케이프되지 않습니다. 이로 인해 서유럽, 그리스어, 키릴어와 같은 언어에서 비슷한 문자가 그려지는 문제가 발생할 수 있습니다. 이들 언어는 유사하지만 다른 알파벳(공통 조상에서 유래)을 사용하며, 비슷해 보이지만 문자 코드가 다른 글자를 포함합니다. 예를 들어, 라틴어 'a', 'e', 'o'를 키릴어 'а', 'е', 'о'와 구별하기 어렵습니다. (물론 시각적 표현은 사용되는 폰트에 따라 크게 다르지만, 일반적으로 이들 글자는 거의 구별할 수 없습니다.) 이 문제를 피하기 위해 사용자는 자신의 환경에 적합한 결과를 얻기 위해 터미널 인코딩을 조정할 수 있습니다.</p>
<h2>거부된 제안 (Rejected Proposals)</h2>
<ul>
<li><strong>내장 <code>print()</code> 함수에 <code>encoding</code> 및 <code>errors</code> 인수를 추가하며, 기본값은 <code>sys.getfilesystemencoding()</code> 및 <code>'backslashreplace'</code>로 설정:</strong> 구현이 복잡하고, 일반적으로 좋은 아이디어로 간주되지 않습니다.</li>
<li><strong>헥스(hex) 문자 코드 대신 문자 이름을 사용하여 문자 이스케이프:</strong> 예를 들어, <code>repr('\u03b1')</code>를 <code>"\N{GREEK SMALL LETTER ALPHA}"</code>로 변환하는 것입니다. 문자 이름을 사용하는 것은 헥스 이스케이프보다 매우 장황할 수 있습니다. 예: <code>repr("\ufbf9")</code>는 <code>"\N{ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA ISOLATED FORM}"</code>으로 변환됩니다.</li>
<li><strong><code>sys.stdout</code>의 기본 에러 핸들러를 <code>'backslashreplace'</code>로 설정:</strong> <code>stdout</code>에 쓰여진 내용은 <code>\</code> 이스케이프를 잘못 해석할 수 있는 다른 프로그램에 의해 소비될 수 있습니다. 대화형 세션의 경우 <code>'backslashreplace'</code> 에러 핸들러를 기본값으로 만들 수 있지만, 이는 "대화형 모드에서는 작동하지만 파일로 리디렉션할 때는 작동하지 않는다"와 같은 혼란을 야기할 수 있습니다.</li>
</ul>
<h2>구현 (Implementation)</h2>
<p>작성자는 http://bugs.python.org/issue2630에 패치(patch)를 작성했으며, 이는 2008년 11월 6일 리비전 64138로 Python 3.0 브랜치에 커밋되었습니다.</p>
<h2>참조 (References)</h2>
<p>Multibyte string on string::string_print (http://bugs.python.org/issue479898)
[Python-3000] Displaying strings containing unicode escapes (https://mail.python.org/pipermail/python-3000/2008-April/013366.html)</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-1a135130af3e1cae.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/3138\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"8N6icDw00Cy0kKVlExSq2\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/3138/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/3138\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"3138\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/3138\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T45b8,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-3138/\"\u003ePEP 3138 - String representation in Python 3000\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 05-May-2008\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 3138 – Python 3000에서의 문자열 표현 (String representation in Python 3000)\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Atsuo Ishimoto \u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 최종 (Final)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e 표준 트랙 (Standards Track)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2008년 5월 5일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.0\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e최근 이력:\u003c/strong\u003e 2008년 5월 5일, 2008년 6월 5일\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 Python 3000(Python 3.x의 초기 명칭)을 위한 새로운 문자열 표현 형식을 제안합니다. Python 3000 이전 버전의 Python에서는 내장 함수 \u003ccode\u003erepr()\u003c/code\u003e이 디버깅 및 로깅을 위해 임의의 객체를 인쇄 가능한 ASCII 문자열로 변환했습니다. Python 3000에서는 유니코드 표준을 기반으로 더 넓은 범위의 문자를 '인쇄 가능'하다고 간주해야 한다는 제안입니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e기존 \u003ccode\u003erepr()\u003c/code\u003e 함수는 다음 알고리즘을 사용하여 8비트 문자열을 ASCII로 변환합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCR, LF, TAB 및 \u003ccode\u003e\\\u003c/code\u003e를 각각 \u003ccode\u003e\\r\u003c/code\u003e, \u003ccode\u003e\\n\u003c/code\u003e, \u003ccode\u003e\\t\u003c/code\u003e, \u003ccode\u003e\\\\\u003c/code\u003e로 변환합니다.\u003c/li\u003e\n\u003cli\u003e다른 인쇄 불가능한 문자(0x00-0x1f, 0x7f)와 비-ASCII 문자(\u003e= 0x80)를 \u003ccode\u003e\\xXX\u003c/code\u003e 형식으로 변환합니다.\u003c/li\u003e\n\u003cli\u003e인용 부호(' 또는 \u003ccode\u003e_\u003c/code\u003e)를 백슬래시로 이스케이프하고, 문자열의 시작과 끝에 인용 부호를 추가합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e유니코드 문자열의 경우, 다음 추가 변환이 수행됩니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e후행 문자 없는 선행 서러게이트 쌍 문자(0xd800-0xdbff 범위이나 0xdc00-0xdfff가 뒤따르지 않는 경우)를 \u003ccode\u003e\\uXXXX\u003c/code\u003e 형식으로 변환합니다.\u003c/li\u003e\n\u003cli\u003e16비트 문자(\u003e= 0x100)를 \u003ccode\u003e\\uXXXX\u003c/code\u003e 형식으로 변환합니다.\u003c/li\u003e\n\u003cli\u003e21비트 문자(\u003e= 0x10000) 및 서러게이트 쌍 문자를 \u003ccode\u003e\\U00xxxxxx\u003c/code\u003e 형식으로 변환합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 알고리즘은 모든 문자열을 인쇄 가능한 ASCII로 변환하며, \u003ccode\u003erepr()\u003c/code\u003e은 디버깅이나 로깅을 위해 문자열을 출력하는 편리하고 안전한 방법으로 사용됩니다. 모든 비-ASCII 문자는 이스케이프되지만, 대부분의 문자열 문자가 ASCII인 경우에는 문제가 되지 않습니다. 그러나 일본어와 같이 문자열의 대부분이 비-ASCII 문자인 다른 언어의 경우, 이는 매우 불편합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprint(aJapaneseString)\u003c/code\u003e을 사용하여 읽기 쉬운 문자열을 얻을 수 있지만, 리스트(list)나 튜플(tuple)과 같은 컬렉션(collection)에서 문자열을 출력하는 유사한 해결책은 없습니다. \u003ccode\u003eprint(listOfJapaneseStrings)\u003c/code\u003e는 \u003ccode\u003erepr()\u003c/code\u003e을 사용하여 출력할 문자열을 구성하므로, 결과 문자열은 항상 헥스(hex) 이스케이프된 상태입니다. 또는 \u003ccode\u003eopen(japaneseFilename)\u003c/code\u003e이 예외를 발생시킬 때, 오류 메시지가 \u003ccode\u003eIOError: [Errno 2] No such file or directory: '\\u65e5\\u672c\\u8a9e'\u003c/code\u003e와 같이 표시되어 전혀 도움이 되지 않습니다.\u003c/p\u003e\n\u003cp\u003ePython 3000은 비-ASCII 식별자(identifier)와 같이 비-라틴어 사용자에게 많은 유용한 기능을 제공하므로, 인쇄 가능한 출력(printable output)에서도 유사한 방식으로 발전한다면 도움이 될 것입니다.\u003c/p\u003e\n\u003cp\u003e일부 사용자는 이미지와 같은 이진 데이터를 출력할 경우 콘솔이 엉망이 될 것을 우려할 수 있습니다. 그러나 Python 3000에서는 바이트(bytes)와 문자열(strings)이 서로 다른 유형이므로, 콘솔에 이미지를 출력하는 것이 콘솔을 엉망으로 만들 가능성은 낮기 때문에 실제로 이런 일은 발생하지 않을 것입니다.\u003c/p\u003e\n\u003cp\u003e이 문제는 이전에 Hye-Shik Chang에 의해 논의되었지만, 거부되었습니다.\u003c/p\u003e\n\u003ch2\u003e명세 (Specification)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003ePy_UNICODE_ISPRINTABLE\u003c/code\u003e 함수 추가\u003c/h3\u003e\n\u003cp\u003ePython C API에 새로운 함수 \u003ccode\u003eint Py_UNICODE_ISPRINTABLE(Py_UNICODE ch)\u003c/code\u003e를 추가합니다. 이 함수는 \u003ccode\u003erepr()\u003c/code\u003e이 유니코드 문자 \u003ccode\u003ech\u003c/code\u003e를 이스케이프해야 하는 경우 0을 반환하고, 그렇지 않으면 1을 반환합니다. 이스케이프되어야 할 문자는 유니코드 문자 데이터베이스에서 다음과 같이 정의됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCc\u003c/code\u003e (Other, Control): 제어 문자\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCf\u003c/code\u003e (Other, Format): 형식 문자\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCs\u003c/code\u003e (Other, Surrogate): 서러게이트 (대리) 문자\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCo\u003c/code\u003e (Other, Private Use): 개인 사용 영역 문자\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCn\u003c/code\u003e (Other, Not Assigned): 할당되지 않은 문자\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eZl\u003c/code\u003e (Separator, Line): \u003ccode\u003eLINE SEPARATOR\u003c/code\u003e (\u003ccode\u003e\\u2028\u003c/code\u003e)를 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eZp\u003c/code\u003e (Separator, Paragraph): \u003ccode\u003ePARAGRAPH SEPARATOR\u003c/code\u003e (\u003ccode\u003e\\u2029\u003c/code\u003e)를 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eZs\u003c/code\u003e (Separator, Space): ASCII 공백 (\u003ccode\u003e\\x20\u003c/code\u003e) 이외의 구분 공백 문자. 모호함을 피하기 위해 이 범주의 문자는 이스케이프되어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003erepr()\u003c/code\u003e 문자열 생성 알고리즘 변경\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003erepr()\u003c/code\u003e 문자열을 생성하는 알고리즘은 다음과 같이 변경되어야 합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCR, LF, TAB 및 \u003ccode\u003e\\\u003c/code\u003e를 \u003ccode\u003e\\r\u003c/code\u003e, \u003ccode\u003e\\n\u003c/code\u003e, \u003ccode\u003e\\t\u003c/code\u003e, \u003ccode\u003e\\\\\u003c/code\u003e로 변환합니다.\u003c/li\u003e\n\u003cli\u003e인쇄 불가능한 ASCII 문자(0x00-0x1f, 0x7f)를 \u003ccode\u003e\\xXX\u003c/code\u003e 형식으로 변환합니다.\u003c/li\u003e\n\u003cli\u003e후행 문자 없는 선행 서러게이트 쌍 문자(0xd800-0xdbff 범위이나 0xdc00-0xdfff가 뒤따르지 않는 경우)를 \u003ccode\u003e\\uXXXX\u003c/code\u003e 형식으로 변환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePy_UNICODE_ISPRINTABLE()\u003c/code\u003e이 0을 반환하는 인쇄 불가능한 문자를 \u003ccode\u003e\\xXX\u003c/code\u003e, \u003ccode\u003e\\uXXXX\u003c/code\u003e 또는 \u003ccode\u003e\\U00xxxxxx\u003c/code\u003e 형식으로 변환합니다.\u003c/li\u003e\n\u003cli\u003e인용 부호(\u003ccode\u003e'\u003c/code\u003e)를 백슬래시로 이스케이프하고, 문자열의 시작과 끝에 인용 부호를 추가합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003ccode\u003esys.stderr\u003c/code\u003e 기본 에러 핸들러 변경\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esys.stderr\u003c/code\u003e의 유니코드 에러 핸들러(error-handler)를 기본적으로 \u003ccode\u003e'backslashreplace'\u003c/code\u003e로 설정합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ePyObject_ASCII\u003c/code\u003e 함수 추가\u003c/h3\u003e\n\u003cp\u003ePython C API에 새로운 함수 \u003ccode\u003ePyObject *PyObject_ASCII(PyObject *o)\u003c/code\u003e를 추가합니다. 이 함수는 \u003ccode\u003ePyObject_Repr()\u003c/code\u003e을 사용하여 파이썬 객체를 문자열로 변환한 다음, 모든 비-ASCII 문자를 헥스 이스케이프합니다. \u003ccode\u003ePyObject_ASCII()\u003c/code\u003e는 Python 2의 \u003ccode\u003ePyObject_Repr()\u003c/code\u003e과 동일한 문자열을 생성합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eascii()\u003c/code\u003e 내장 함수 추가\u003c/h3\u003e\n\u003cp\u003e새로운 내장 함수 \u003ccode\u003eascii()\u003c/code\u003e를 추가합니다. 이 함수는 \u003ccode\u003erepr()\u003c/code\u003e을 사용하여 파이썬 객체를 문자열로 변환한 다음, 모든 비-ASCII 문자를 헥스 이스케이프합니다. \u003ccode\u003eascii()\u003c/code\u003e는 Python 2의 \u003ccode\u003erepr()\u003c/code\u003e과 동일한 문자열을 생성합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003e%a\u003c/code\u003e 문자열 포맷 연산자 및 관련 기능 추가\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e%a\u003c/code\u003e 문자열 포맷 연산자를 추가합니다. \u003ccode\u003e%a\u003c/code\u003e는 \u003ccode\u003erepr()\u003c/code\u003e을 사용하여 파이썬 객체를 문자열로 변환한 다음, 모든 비-ASCII 문자를 헥스 이스케이프합니다. \u003ccode\u003e%a\u003c/code\u003e 포맷 연산자는 Python 2의 \u003ccode\u003e%r\u003c/code\u003e과 동일한 문자열을 생성합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estr.format()\u003c/code\u003e 메서드에 \u003ccode\u003e!a\u003c/code\u003e 변환 플래그를 추가합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyUnicode_FromFormat()\u003c/code\u003e에 \u003ccode\u003e%A\u003c/code\u003e 연산자를 추가합니다.\r\n이들은 \u003ccode\u003e%a\u003c/code\u003e 문자열 포맷 연산자와 같이 모든 객체를 ASCII 문자열로 변환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e\u003ccode\u003estr.isprintable()\u003c/code\u003e 메서드 추가\u003c/h3\u003e\n\u003cp\u003e문자열 유형에 \u003ccode\u003eisprintable()\u003c/code\u003e 메서드를 추가합니다. \u003ccode\u003estr.isprintable()\u003c/code\u003e은 문자열의 어떤 문자라도 \u003ccode\u003erepr()\u003c/code\u003e이 이스케이프할 경우 \u003ccode\u003eFalse\u003c/code\u003e를 반환하고, 그렇지 않으면 \u003ccode\u003eTrue\u003c/code\u003e를 반환합니다. \u003ccode\u003eisprintable()\u003c/code\u003e 메서드는 내부적으로 \u003ccode\u003ePy_UNICODE_ISPRINTABLE()\u003c/code\u003e 함수를 호출합니다.\u003c/p\u003e\n\u003ch2\u003e근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003ePython 3000의 \u003ccode\u003erepr()\u003c/code\u003e은 Python 3000의 문자열과 마찬가지로 ASCII 기반이 아닌 유니코드 기반이어야 합니다. 또한, 로케일(locale) 설정은 출력 장치의 로케일과 반드시 같지 않으므로, 변환이 로케일 설정에 영향을 받아서는 안 됩니다. 예를 들어, 데몬(daemon) 프로세스가 ASCII 설정으로 호출되지만 UTF-8로 로그 파일에 쓰는 것은 일반적인 경우입니다. 또한, 웹 애플리케이션은 HTML 페이지의 인코딩을 기반으로 오류 정보를 더 읽기 쉬운 형태로 보고하고 싶을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e사용자 콘솔에서 지원하지 않는 문자는 유니코드 인코더의 에러 핸들러에 의해 출력 시 헥스 이스케이프될 수 있습니다. 출력 파일의 에러 핸들러가 \u003ccode\u003e'backslashreplace'\u003c/code\u003e인 경우, 그러한 문자는 \u003ccode\u003eUnicodeEncodeError\u003c/code\u003e를 발생시키지 않고 헥스 이스케이프됩니다. 예를 들어, 기본 인코딩이 ASCII인 경우 \u003ccode\u003eprint('Hello ¢')\u003c/code\u003e는 \u003ccode\u003e'Hello \\xa2'\u003c/code\u003e를 출력합니다. 인코딩이 ISO-8859-1인 경우 \u003ccode\u003e'Hello ¢'\u003c/code\u003e가 출력됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esys.stdout\u003c/code\u003e의 기본 에러 핸들러는 \u003ccode\u003e'strict'\u003c/code\u003e입니다. 출력을 읽는 다른 애플리케이션이 헥스 이스케이프된 문자를 잘못 해석할 수 있으므로, 지원되지 않는 문자는 쓸 때 감지되어야 합니다. 지원되지 않는 문자가 이스케이프되어야 하는 경우, 에러 핸들러를 명시적으로 변경해야 합니다. \u003ccode\u003esys.stdout\u003c/code\u003e과 달리 \u003ccode\u003esys.stderr\u003c/code\u003e는 기본적으로 \u003ccode\u003eUnicodeEncodingError\u003c/code\u003e를 발생시키지 않습니다. 이는 기본 에러 핸들러가 \u003ccode\u003e'backslashreplace'\u003c/code\u003e이기 때문입니다. 따라서 비-ASCII 문자를 포함하는 오류 메시지를 \u003ccode\u003esys.stderr\u003c/code\u003e로 출력해도 예외가 발생하지 않습니다. 또한, 처리되지 않은 예외(예외 객체, 트레이스백)에 대한 정보는 인터프리터에 의해 예외를 발생시키지 않고 출력됩니다.\u003c/p\u003e\n\u003ch2\u003e대안 솔루션 (Alternate Solutions)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003erepr()\u003c/code\u003e을 변경하지 않고 비-라틴어 사용자의 디버깅을 돕기 위해 다른 제안들이 있었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e리스트(list)나 딕트(dict)를 출력하는 도구 제공:\u003c/strong\u003e 디버깅을 위해 출력되어야 하는 문자열은 리스트나 딕트뿐만 아니라 다른 많은 종류의 객체에도 포함되어 있습니다. 파일 객체는 유니코드 파일 이름을 포함하고, 예외 객체는 유니코드 메시지를 포함하는 등, 이러한 문자열은 \u003ccode\u003erepr()\u003c/code\u003e될 때 읽기 쉬운 형태로 출력되어야 합니다. 모든 가능한 객체 유형을 출력하는 도구를 구현하는 것은 불가능할 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003esys.displayhook\u003c/code\u003e 및 \u003ccode\u003esys.excepthook\u003c/code\u003e 사용:\u003c/strong\u003e 대화형 세션의 경우, 헥스 이스케이프된 문자를 원래 문자로 복원하는 훅(hook)을 작성할 수 있습니다. 그러나 이러한 훅은 대화형 Python 세션에서 입력된 표현식의 평가 결과를 출력할 때만 호출되며, \u003ccode\u003eprint()\u003c/code\u003e 함수, 비-대화형 세션 또는 \u003ccode\u003elogging.debug(\"%r\", ...)\u003c/code\u003e 등에는 작동하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003esys.stdout\u003c/code\u003e 및 \u003ccode\u003esys.stderr\u003c/code\u003e 서브클래싱(subclassing):\u003c/strong\u003e 헥스 이스케이프된 문자를 복원하는 서브클래스를 구현하는 것은 어렵습니다. 모든 경우에 이스케이프를 올바르게 되돌리기에 충분한 정보가 문자열이 될 때까지 남아 있지 않기 때문입니다. 예를 들어, \u003ccode\u003eprint(\"\\\\\"+\"u0041\")\u003c/code\u003e는 'A'가 아니라 \u003ccode\u003e'\\u0041'\u003c/code\u003e로 출력되어야 합니다. 그러나 파일 객체를 구별할 기회가 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eunicode_repr()\u003c/code\u003e에서 사용되는 인코딩을 조정 가능하게 하고, 기존 \u003ccode\u003erepr()\u003c/code\u003e을 기본값으로 설정:\u003c/strong\u003e 조정 가능한 \u003ccode\u003erepr()\u003c/code\u003e을 사용하면 \u003ccode\u003erepr()\u003c/code\u003e의 결과가 예측 불가능해지고, \u003ccode\u003erepr()\u003c/code\u003e과 관련된 올바른 코드를 작성하는 것이 불가능해질 수 있습니다. 그리고 현재 \u003ccode\u003erepr()\u003c/code\u003e이 기본값이라면, 기존 관행이 유지되고 사용자는 \u003ccode\u003erepr()\u003c/code\u003e의 결과로 ASCII 문자열을 기대할 수 있습니다. 사용자 정의 \u003ccode\u003erepr()\u003c/code\u003e 함수가 사용될 때 서드파티 애플리케이션이나 라이브러리가 혼란스러워할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e하위 호환성 (Backwards Compatibility)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003erepr()\u003c/code\u003e 변경은 일부 기존 코드, 특히 테스트 코드를 손상시킬 수 있습니다. Python의 회귀 테스트(regression tests) 중 5개가 이 수정으로 인해 실패합니다. Python 2처럼 비-ASCII 문자가 없는 \u003ccode\u003erepr()\u003c/code\u003e 문자열이 필요한 경우 다음 함수를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef repr_ascii(obj):\r\n    return str(repr(obj).encode(\"ASCII\", \"backslashreplace\"), \"ASCII\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e로깅이나 디버깅을 위해 다음 코드는 \u003ccode\u003eUnicodeEncodeError\u003c/code\u003e를 발생시킬 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elog = open(\"logfile\", \"w\")\r\nlog.write(repr(data)) # data에 지원되지 않는 문자가 포함된 경우 UnicodeEncodeError가 발생합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예외 발생을 피하려면 에러 핸들러를 명시적으로 지정할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003elog = open(\"logfile\", \"w\", errors=\"backslashreplace\")\r\nlog.write(repr(data)) # 지원되지 않는 문자는 이스케이프됩니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003een_US.utf8\u003c/code\u003e 또는 \u003ccode\u003ede_DE.utf8\u003c/code\u003e과 같이 유니코드 기반 인코딩을 사용하는 콘솔의 경우, 백슬래시 교체(backslashreplace) 트릭이 작동하지 않고 모든 인쇄 가능한 문자가 이스케이프되지 않습니다. 이로 인해 서유럽, 그리스어, 키릴어와 같은 언어에서 비슷한 문자가 그려지는 문제가 발생할 수 있습니다. 이들 언어는 유사하지만 다른 알파벳(공통 조상에서 유래)을 사용하며, 비슷해 보이지만 문자 코드가 다른 글자를 포함합니다. 예를 들어, 라틴어 'a', 'e', 'o'를 키릴어 'а', 'е', 'о'와 구별하기 어렵습니다. (물론 시각적 표현은 사용되는 폰트에 따라 크게 다르지만, 일반적으로 이들 글자는 거의 구별할 수 없습니다.) 이 문제를 피하기 위해 사용자는 자신의 환경에 적합한 결과를 얻기 위해 터미널 인코딩을 조정할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e거부된 제안 (Rejected Proposals)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e내장 \u003ccode\u003eprint()\u003c/code\u003e 함수에 \u003ccode\u003eencoding\u003c/code\u003e 및 \u003ccode\u003eerrors\u003c/code\u003e 인수를 추가하며, 기본값은 \u003ccode\u003esys.getfilesystemencoding()\u003c/code\u003e 및 \u003ccode\u003e'backslashreplace'\u003c/code\u003e로 설정:\u003c/strong\u003e 구현이 복잡하고, 일반적으로 좋은 아이디어로 간주되지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e헥스(hex) 문자 코드 대신 문자 이름을 사용하여 문자 이스케이프:\u003c/strong\u003e 예를 들어, \u003ccode\u003erepr('\\u03b1')\u003c/code\u003e를 \u003ccode\u003e\"\\N{GREEK SMALL LETTER ALPHA}\"\u003c/code\u003e로 변환하는 것입니다. 문자 이름을 사용하는 것은 헥스 이스케이프보다 매우 장황할 수 있습니다. 예: \u003ccode\u003erepr(\"\\ufbf9\")\u003c/code\u003e는 \u003ccode\u003e\"\\N{ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA ISOLATED FORM}\"\u003c/code\u003e으로 변환됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003esys.stdout\u003c/code\u003e의 기본 에러 핸들러를 \u003ccode\u003e'backslashreplace'\u003c/code\u003e로 설정:\u003c/strong\u003e \u003ccode\u003estdout\u003c/code\u003e에 쓰여진 내용은 \u003ccode\u003e\\\u003c/code\u003e 이스케이프를 잘못 해석할 수 있는 다른 프로그램에 의해 소비될 수 있습니다. 대화형 세션의 경우 \u003ccode\u003e'backslashreplace'\u003c/code\u003e 에러 핸들러를 기본값으로 만들 수 있지만, 이는 \"대화형 모드에서는 작동하지만 파일로 리디렉션할 때는 작동하지 않는다\"와 같은 혼란을 야기할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e작성자는 http://bugs.python.org/issue2630에 패치(patch)를 작성했으며, 이는 2008년 11월 6일 리비전 64138로 Python 3.0 브랜치에 커밋되었습니다.\u003c/p\u003e\n\u003ch2\u003e참조 (References)\u003c/h2\u003e\n\u003cp\u003eMultibyte string on string::string_print (http://bugs.python.org/issue479898)\r\n[Python-3000] Displaying strings containing unicode escapes (https://mail.python.org/pipermail/python-3000/2008-April/013366.html)\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1318,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 3138 - String representation in Python 3000\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 14:35:12+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>