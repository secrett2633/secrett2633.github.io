<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/773b243a13a00265.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/app/layout-29f3b81c3a382114.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.cloud/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.cloud/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2279<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 343 - The “with” Statement</h1><div class="page__meta"><time dateTime="2025-09-27 01:01:20+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0343/">PEP 343 - The “with” Statement</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 13-May-2005</p>
</blockquote>
<h2>PEP 343 – <code>with</code> 문</h2>
<h3>초록 (Abstract)</h3>
<p>이 PEP(Python Enhancement Proposal)는 Python 언어에 새로운 <code>with</code> 문을 추가하여, <code>try/finally</code> 문의 표준적인 사용 패턴을 간결하게 만들 수 있도록 합니다.
<code>with</code> 문 내에서, <strong>컨텍스트 매니저(context manager)</strong> 는 <code>with</code> 문 본문으로 진입하고 종료할 때 호출되는 <code>__enter__()</code> 및 <code>__exit__()</code> 메서드를 제공합니다.</p>
<h3>작성자 주 (Author's Note)</h3>
<p>이 PEP는 원래 Guido van Rossum에 의해 작성되었으며, 이후 python-dev에서 논의된 내용을 반영하여 Alyssa (Nick) Coghlan이 업데이트했습니다. Python 2.5 알파 릴리스 주기 동안 이 PEP의 용어와 관련 문서 및 구현에서 문제점이 발견되었고, 첫 번째 Python 2.5 베타 릴리스 시점에 PEP가 안정화되었습니다.</p>
<h3>서론 (Introduction)</h3>
<p>PEP 340 및 대안에 대한 많은 논의 끝에, Guido는 PEP 340을 철회하고 PEP 310의 약간 수정된 버전을 제안했습니다. 추가 논의 후, 일시 중지된 제너레이터(generator)에서 예외를 발생시키기 위한 <code>throw()</code> 메서드와 새로운 <code>GeneratorExit</code> 예외를 발생시키는 <code>close()</code> 메서드가 다시 추가되었습니다. 이 변경 사항들은 python-dev에서 처음 제안되어 만장일치로 승인되었습니다. 또한, 키워드가 <code>with</code>로 변경되었습니다.</p>
<p>이 PEP가 채택된 후, 다음과 같은 PEP들은 중복으로 인해 기각되었습니다.</p>
<ul>
<li><strong>PEP 310, Reliable Acquisition/Release Pairs:</strong> <code>with</code> 문에 대한 원래 제안이었습니다.</li>
<li><strong>PEP 319, Python Synchronize/Asynchronize Block:</strong> 이 PEP의 사용 사례는 적절한 <code>with</code> 문 컨트롤러를 제공함으로써 처리될 수 있습니다.</li>
</ul>
<p>PEP 340 및 PEP 346도 이 PEP와 중복되었으나, 이 PEP가 제출되면서 자발적으로 철회되었습니다.</p>
<h3>동기 및 요약 (Motivation and Summary)</h3>
<p>PEP 340(<code>Anonymous Block Statements</code>)은 제너레이터를 블록 템플릿으로 사용하고, 예외 처리 및 마무리(finalization) 기능을 제너레이터에 추가하는 등 여러 강력한 아이디어를 결합했습니다. 그러나 이는 내부적으로 잠재적인 반복(looping) 구조라는 점 때문에 많은 반대에 부딪혔습니다. 이는 <code>break</code>와 <code>continue</code>가 블록 문 내에서 사용될 경우, 자원 관리 도구로 사용되더라도 블록 문을 깨거나 계속 진행시킬 수 있음을 의미했습니다.</p>
<p>결정적인 계기는 Raymond Chen의 흐름 제어 매크로에 대한 비판을 읽은 후였습니다. Raymond는 매크로에 흐름 제어를 숨기는 것이 코드를 이해하기 어렵게 만든다고 주장했으며, Guido는 이 주장이 C뿐만 아니라 Python에도 적용된다고 생각했습니다. PEP 340 템플릿이 모든 종류의 제어 흐름을 숨길 수 있음을 깨달은 것입니다.</p>
<p>반면, PEP 310의 <code>with</code> 문은 흐름 제어를 숨기지 않습니다. <code>finally</code> 스위트(suite)가 일시적으로 흐름을 중단시키더라도, 결국에는 <code>finally</code> 스위트가 없었던 것처럼 흐름이 재개됩니다.</p>
<p>PEP 310은 대략 다음과 같은 구문을 제안했습니다. ( <code>VAR =</code> 부분은 선택 사항입니다.)</p>
<pre><code class="language-python">with VAR = EXPR:
    BLOCK
</code></pre>
<p>이는 대략 다음과 같이 번역됩니다.</p>
<pre><code class="language-python">VAR = EXPR
VAR.__enter__()
try:
    BLOCK
finally:
    VAR.__exit__()
</code></pre>
<p>이러한 접근 방식은 <code>BLOCK</code> 내에서 예외가 발생하거나 <code>break</code>, <code>continue</code>, <code>return</code>과 같은 비지역적 <code>goto</code>가 실행될 경우, <code>finally</code> 절이 여전히 실행되도록 보장합니다.</p>
<p>이 아이디어는 Guido가 PEP 310을 지지하도록 이끌었지만, PEP 340의 제너레이터를 '템플릿'으로 사용하여 잠금 획득 및 해제 또는 파일 열기 및 닫기와 같은 추상화를 구현하는 강력한 아이디어를 포기할 수 없었습니다.</p>
<p>Phillip Eby의 PEP 340에 대한 반대 제안에 영감을 받아, 적절한 제너레이터를 필요한 <code>__enter__()</code> 및 <code>__exit__()</code> 메서드를 가진 객체로 변환하는 데코레이터를 만들려고 시도했습니다. 여기서 문제에 부딪혔는데, 잠금(locking) 예시에서는 어렵지 않았지만, 파일 열기 예시에서는 불가능했습니다.</p>
<p>해결책은 <code>VAR</code>가 <code>__enter__()</code> 메서드 호출의 결과를 받도록 하고, <code>EXPR</code>의 값을 저장하여 나중에 <code>__exit__()</code> 메서드를 호출하는 방식으로 번역을 약간 변경하는 것이었습니다. 이렇게 하면 제너레이터를 컨텍스트 매니저로 변환하는 데코레이터를 쉽게 작성할 수 있게 됩니다.</p>
<p>이후 <code>with VAR = EXPR:</code> 구문이 <code>VAR</code>가 <code>EXPR</code>의 값을 직접 받지 않는다는 점에서 오해의 소지가 있다는 논의가 있었습니다. PEP 340에서 아이디어를 빌려와 <code>with EXPR as VAR:</code> 구문이 채택되었습니다.</p>
<p>추가 논의를 통해, 제너레이터 내에서 예외를 '볼' 수 있는 기능(<code>throw()</code> 메서드)이 중요하다고 판단되었습니다. 이는 <code>with</code> 문이 루프처럼 사용되는 것을 방지하면서도 예외 로깅 등을 가능하게 합니다. 또한, 제너레이터가 가비지 컬렉션될 때 자동으로 호출되는 <code>close()</code> 메서드도 제안되었으며, 이는 특별한 <code>GeneratorExit</code> 예외를 발생시킵니다.</p>
<p>이러한 변경 사항들을 통해 <code>try-finally</code> 문 내에서 <code>yield</code> 문을 허용할 수 있게 되었고, <code>finally</code> 절이 (결국) 실행될 것을 보장할 수 있게 되었습니다. (제너레이터에 대한 자세한 변경 사항은 PEP 342에서 다룹니다.)</p>
<h3>사용 사례 (Use Cases)</h3>
<p>자세한 내용은 마지막의 "예시" 섹션을 참조하십시오.</p>
<h3>사양: <code>with</code> 문 (Specification: The 'with' Statement)</h3>
<p>다음과 같은 구문의 새로운 문이 제안됩니다.</p>
<pre><code class="language-python">with EXPR as VAR:
    BLOCK
</code></pre>
<p>여기서 <code>with</code>와 <code>as</code>는 새로운 키워드입니다. <code>EXPR</code>은 임의의 표현식이며, <code>VAR</code>는 단일 할당 대상입니다. <code>VAR</code>는 쉼표로 구분된 변수 시퀀스가 될 수 없지만, 괄호로 묶인 쉼표로 구분된 변수 시퀀스는 가능합니다. (<code>as VAR</code> 부분은 선택 사항입니다.)</p>
<p>위 문의 번역은 다음과 같습니다.</p>
<pre><code class="language-python">mgr = (EXPR)
exit = type(mgr).__exit__ # 아직 호출하지 않음
value = type(mgr).__enter__(mgr)
exc = True
try:
    try:
        VAR = value # "as VAR"가 있는 경우에만
        BLOCK
    except: # 예외 발생 시 처리
        exc = False
        if not exit(mgr, *sys.exc_info()):
            raise # exit()가 True를 반환하면 예외는 삼켜짐
    finally: # 정상 및 비지역적 goto의 경우 처리
        if exc:
            exit(mgr, None, None, None)
</code></pre>
<p>여기서 소문자 변수(mgr, exit, value, exc)는 내부 변수이며 사용자에게는 접근할 수 없습니다. 이는 주로 특별한 레지스터 또는 스택 위치로 구현될 것입니다.</p>
<p><code>mgr.__exit__()</code>의 호출 규칙은 다음과 같습니다.</p>
<ul>
<li><code>BLOCK</code>의 정상 완료 또는 비지역적 <code>goto</code>(<code>break</code>, <code>continue</code>, <code>return</code>)를 통해 <code>finally</code> 스위트에 도달한 경우, <code>mgr.__exit__()</code>는 세 개의 <code>None</code> 인자와 함께 호출됩니다.</li>
<li><code>BLOCK</code>에서 발생한 예외를 통해 <code>finally</code> 스위트에 도달한 경우, <code>mgr.__exit__()</code>는 예외 유형, 값, 트레이스백을 나타내는 세 개의 인자와 함께 호출됩니다.</li>
</ul>
<p><strong>중요:</strong> <code>mgr.__exit__()</code>가 "참(true)" 값을 반환하면 예외는 "삼켜집니다(swallowed)". 즉, <code>with</code> 문 내에서 예외가 발생했더라도 <code>exit()</code>가 <code>True</code>를 반환하면 <code>with</code> 문 다음 문에서 실행이 계속됩니다. 그러나 <code>with</code> 문이 비지역적 <code>goto</code>(<code>break</code>, <code>continue</code>, <code>return</code>)를 통해 종료된 경우, <code>mgr.__exit__()</code>의 반환 값과 관계없이 이 비지역적 반환이 재개됩니다. 이는 <code>mgr.__exit__()</code>가 예외를 삼킬 수 있도록 하면서도, 기본 반환 값인 <code>None</code>이 거짓(false)이므로 예외가 다시 발생하도록 하여 예외 삼키기를 너무 쉽게 만들지 않기 위함입니다.</p>
<p><code>__exit__()</code>에 예외 세부 정보를 전달하는 동기는 트랜잭션(<code>transactional()</code>) 사용 사례(아래 예시 3)에서 비롯되었습니다. 이 예시의 템플릿은 예외 발생 여부에 따라 트랜잭션을 커밋하거나 롤백해야 합니다.</p>
<p><code>__exit__()</code> 메서드는 전달된 오류를 다시 발생시키지 않아야 합니다. 오류를 다시 발생시키는 것은 항상 <code>__exit__()</code> 메서드를 호출하는 호출자의 책임입니다.</p>
<h3>전환 계획 (Transition Plan)</h3>
<p>Python 2.5에서는 <code>from __future__ import with_statement</code> 미래 문이 있을 경우에만 새로운 구문이 인식됩니다. 이 경우 <code>with</code>와 <code>as</code>가 키워드가 됩니다. 미래 문이 없으면 <code>with</code> 또는 <code>as</code>를 식별자로 사용하면 <code>stderr</code>에 경고가 발행됩니다.
Python 2.6에서는 새로운 구문이 항상 인식되며, <code>with</code>와 <code>as</code>는 항상 키워드입니다.</p>
<h3>제너레이터 데코레이터 (Generator Decorator)</h3>
<p>PEP 342가 채택되면서, 정확히 한 번 <code>yield</code>하는 제너레이터를 사용하여 <code>with</code> 문을 제어하는 데코레이터를 작성할 수 있게 되었습니다. <code>GeneratorContextManager</code> 클래스를 사용하여 제너레이터 함수를 컨텍스트 매니저 팩토리로 변환하는 <code>contextmanager</code> 데코레이터를 구현할 수 있습니다.</p>
<p>강력한 구현은 표준 라이브러리의 일부가 될 것입니다.</p>
<pre><code class="language-python"># GeneratorContextManager 및 contextmanager 데코레이터의 스케치
class GeneratorContextManager(object):
    def __init__(self, gen):
        self.gen = gen
    def __enter__(self):
        try:
            return self.gen.next()
        except StopIteration:
            raise RuntimeError("generator didn't yield")
    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                self.gen.next()
            except StopIteration:
                return
            else:
                raise RuntimeError("generator didn't stop")
        else:
            try:
                self.gen.throw(type, value, traceback)
                raise RuntimeError("generator didn't stop after throw()")
            except StopIteration:
                return True
            except:
                # throw() 프로토콜과 __exit__() 프로토콜 간의 불일치 해결
                # __exit__() 자체에 실패하지 않는 한 예외를 발생시키지 않아야 함
                pass # (원문에는 주석 처리된 raise 조건이 있으나, 스케치이므로 간략화)

def contextmanager(func):
    def helper(*args, **kwds):
        return GeneratorContextManager(func(*args, **kwds))
    return helper
</code></pre>
<p>이 데코레이터는 다음과 같이 사용될 수 있습니다.</p>
<pre><code class="language-python">@contextmanager
def opening(filename):
    f = open(filename)
    try:
        yield f
    finally:
        f.close()
</code></pre>
<h3>표준 라이브러리의 컨텍스트 매니저 (Context Managers in the Standard Library)</h3>
<p>파일, 소켓, 잠금(lock)과 같은 특정 객체에 <code>__enter__()</code> 및 <code>__exit__()</code> 메서드를 부여하여 직접 <code>with</code> 문에서 사용할 수 있도록 할 수 있습니다.
예를 들어, <code>with locking(myLock): BLOCK</code> 대신 <code>with myLock: BLOCK</code>와 같이 작성할 수 있습니다.</p>
<p>그러나 이러한 방식은 <code>f = open(filename); with f: BLOCK1; with f: BLOCK2</code>와 같이 <code>f</code>가 <code>BLOCK2</code>에 진입하기 전에 닫히는 오해를 불러일으킬 수 있으므로 주의해야 합니다. 이러한 실수는 쉽게 진단할 수 있습니다.</p>
<p>Python 2.5에서는 다음 유형들이 컨텍스트 매니저로 식별되었습니다.</p>
<ul>
<li><code>file</code></li>
<li><code>thread.LockType</code></li>
<li><code>threading.Lock</code></li>
<li><code>threading.RLock</code></li>
<li><code>threading.Condition</code></li>
<li><code>threading.Semaphore</code></li>
<li><code>threading.BoundedSemaphore</code></li>
</ul>
<p><code>decimal</code> 모듈에도 <code>with</code> 문 본문 내에서 지역 십진수 산술 컨텍스트를 지원하고, <code>with</code> 문을 종료할 때 원래 컨텍스트를 자동으로 복원하는 컨텍스트 매니저가 추가될 것입니다.</p>
<h3>표준 용어 (Standard Terminology)</h3>
<p>이 PEP는 <code>__enter__()</code> 및 <code>__exit__()</code> 메서드로 구성된 프로토콜을 " <strong>컨텍스트 관리 프로토콜(context management protocol)</strong> "이라고 부르고, 이 프로토콜을 구현하는 객체를 " <strong>컨텍스트 매니저(context manager)</strong> "라고 부를 것을 제안합니다.</p>
<p><code>with</code> 키워드 바로 뒤에 오는 표현식은 "컨텍스트 표현식(context expression)"이며, 이는 <code>with</code> 문 본문 기간 동안 컨텍스트 매니저가 설정하는 런타임 환경에 대한 주요 단서를 제공합니다.</p>
<h3>컨텍스트 매니저 캐싱 (Caching Context Managers)</h3>
<p>많은 컨텍스트 매니저(예: 파일 및 제너레이터 기반 컨텍스트)는 한 번만 사용되는 객체입니다. <code>__exit__()</code> 메서드가 호출되면 컨텍스트 매니저는 더 이상 사용 가능한 상태가 아닙니다.</p>
<p>각 <code>with</code> 문마다 새로운 매니저 객체를 요구하는 것이 멀티스레드 코드 및 중첩된 <code>with</code> 문에서 동일한 컨텍스트 매니저를 사용하려 할 때 발생하는 문제를 피하는 가장 쉬운 방법입니다. 재사용을 지원하는 모든 표준 라이브러리 컨텍스트 매니저가 <code>threading</code> 모듈에서 비롯되었다는 것은 우연이 아닙니다.</p>
<h3>해결된 문제 (Resolved Issues)</h3>
<p>다음 문제들은 BDFL(Benevolent Dictator For Life)의 승인과 python-dev에서의 주요 반대 의견 부족으로 해결되었습니다.</p>
<ul>
<li><strong>제너레이터-이터레이터가 오작동할 때 <code>GeneratorContextManager</code>는 어떤 예외를 발생시켜야 하는가?</strong> Guido는 이 경우와 PEP 342의 제너레이터 <code>close()</code> 메서드 모두에 대해 <code>RuntimeError</code>를 선택했습니다. <code>RuntimeError</code>는 프로그래머가 코드를 수정하도록 유도하는 데 적합하며, 무한 재귀 감지 등 핵심 Python 코드에서 이미 사용되는 선례가 있습니다.</li>
<li><code>with</code> 문에 관련된 클래스에 해당 메서드가 없을 경우 <code>TypeError</code> 대신 <code>AttributeError</code>를 발생시키는 것이 허용됩니다.</li>
<li><code>__enter__/__exit__</code> 메서드를 가진 객체는 "컨텍스트 매니저"라고 불리며, 제너레이터 함수를 컨텍스트 매니저 팩토리로 변환하는 데코레이터는 <code>contextlib.contextmanager</code>입니다.</li>
</ul>
<h3>거부된 옵션 (Rejected Options)</h3>
<ul>
<li><strong>예외 억제 금지:</strong> 초기에는 숨겨진 흐름 제어를 피하기 위해 예외 억제가 금지되었으나, 구현상의 어려움으로 인해 Guido는 예외 억제 기능을 복원했습니다.</li>
<li><strong><code>__context__()</code> 메서드:</strong> 이터러블의 <code>__iter__()</code> 메서드와 유사한 <code>__context__()</code> 메서드를 추가하자는 제안이 있었으나, 설명 및 작동 방식에 대한 지속적인 문제로 인해 Guido는 이 개념을 완전히 제거했습니다.</li>
<li><strong>PEP 342 제너레이터 API 직접 사용:</strong> <code>with</code> 문 정의에 PEP 342의 향상된 제너레이터 API를 직접 사용하자는 아이디어도 잠시 고려되었으나, 제너레이터 기반이 아닌 컨텍스트 매니저 작성을 너무 어렵게 만든다는 이유로 빠르게 기각되었습니다.</li>
</ul>
<h3>예시 (Examples)</h3>
<p>제너레이터 기반 예시는 PEP 342에 의존합니다. 또한, 일부 예시는 <code>threading.RLock</code>와 같은 적절한 객체가 <code>with</code> 문에서 직접 사용될 수 있으므로 실제로는 필요하지 않을 수 있습니다.</p>
<p>예시 컨텍스트의 이름에 사용된 시제는 임의적이지 않습니다. <code>__enter__</code> 메서드에서 수행되고 <code>__exit__</code> 메서드에서 되돌려지는 동작을 나타낼 때는 과거 시제(" -ed ")가 사용됩니다. <code>__exit__</code> 메서드에서 수행될 동작을 나타낼 때는 현재 진행형 시제(" -ing ")가 사용됩니다.</p>
<p><strong>1. 잠금(Lock) 보장:</strong> 블록 시작 시 획득한 잠금이 블록을 벗어날 때 해제되도록 보장하는 템플릿입니다.</p>
<pre><code class="language-python">@contextmanager
def locked(lock):
    lock.acquire()
    try:
        yield
    finally:
        lock.release()

# 사용 예시:
with locked(myLock):
    # 이 코드 블록은 myLock이 획득된 상태에서 실행됩니다.
    # 블록을 벗어날 때 (return 또는 잡히지 않은 예외를 통해서도)
    # 잠금은 해제되는 것이 보장됩니다.
</code></pre>
<p><strong>2. 파일 열기 및 닫기 보장:</strong> 블록을 벗어날 때 파일이 닫히도록 보장하는 템플릿입니다.</p>
<pre><code class="language-python">@contextmanager
def opened(filename, mode="r"):
    f = open(filename, mode)
    try:
        yield f
    finally:
        f.close()

# 사용 예시:
with opened("/etc/passwd") as f:
    for line in f:
        print(line.rstrip())
</code></pre>
<p><strong>3. 데이터베이스 트랜잭션 커밋 또는 롤백:</strong> 데이터베이스 트랜잭션을 커밋하거나 롤백하는 템플릿입니다.</p>
<pre><code class="language-python">@contextmanager
def transaction(db):
    db.begin()
    try:
        yield None
    except:
        db.rollback()
        raise
    else:
        db.commit()
</code></pre>
<p><strong>4. <code>locked</code> 예시를 제너레이터 없이 재작성:</strong></p>
<pre><code class="language-python">class locked:
    def __init__(self, lock):
        self.lock = lock
    def __enter__(self):
        self.lock.acquire()
    def __exit__(self, type, value, tb):
        self.lock.release()
</code></pre>
<p><strong>5. 표준 출력(stdout) 일시적으로 리디렉션:</strong></p>
<pre><code class="language-python">@contextmanager
def stdout_redirected(new_stdout):
    save_stdout = sys.stdout
    sys.stdout = new_stdout
    try:
        yield None
    finally:
        sys.stdout = save_stdout

# 사용 예시:
with opened(filename, "w") as f:
    with stdout_redirected(f):
        print("Hello world")
</code></pre>
<p><strong>6. 오류 조건도 반환하는 <code>opened()</code> 변형:</strong></p>
<pre><code class="language-python">@contextmanager
def opened_w_error(filename, mode="r"):
    try:
        f = open(filename, mode)
    except IOError as err:
        yield None, err
    else:
        try:
            yield f, None
        finally:
            f.close()

# 사용 예시:
with opened_w_error("/etc/passwd", "a") as (f, err):
    if err:
        print("IOError:", err)
    else:
        f.write("guido::0:0::/:/bin/sh\n")
</code></pre>
<p><strong>7. <code>decimal</code> 모듈의 추가 정밀도 컨텍스트:</strong></p>
<pre><code class="language-python">import decimal
@contextmanager
def extra_precision(places=2):
    c = decimal.getcontext()
    saved_prec = c.prec
    c.prec += places
    try:
        yield None
    finally:
        c.prec = saved_prec

# 사용 예시:
def sin(x):
    with extra_precision():
        # ... 사인 계산 로직 ...
        return +s
</code></pre>
<p><strong>8. <code>decimal</code> 모듈의 지역 컨텍스트 매니저:</strong></p>
<pre><code class="language-python">from decimal import localcontext, ExtendedContext
@contextmanager
def localcontext(ctx=None):
    """Set a new local decimal context for the block"""
    # ... 구현 ...

# 사용 예시:
def sin(x):
    with localcontext() as ctx:
        ctx.prec += 2
        # ... 사인 계산 로직 ...
        return +s
</code></pre>
<p><strong>9. 제네릭 "객체 닫기" 컨텍스트 매니저 (<code>closing</code>):</strong> <code>close</code> 메서드를 가진 모든 객체를 확정적으로 닫는 데 사용됩니다. (Python 2.5의 <code>contextlib</code> 모듈에 이 컨텍스트 매니저 버전이 포함되어 있습니다.)</p>
<pre><code class="language-python">class closing(object):
    def __init__(self, obj):
        self.obj = obj
    def __enter__(self):
        return self.obj
    def __exit__(self, *exc_info):
        try:
            close_it = self.obj.close
        except AttributeError:
            pass
        else:
            close_it()

# 사용 예시:
with closing(open("argument.txt")) as contradiction:
    for line in contradiction:
        print(line)
</code></pre>
<p><strong>10. 잠금을 일시적으로 해제하는 <code>released()</code> 컨텍스트:</strong></p>
<pre><code class="language-python">class released:
    def __init__(self, lock):
        self.lock = lock
    def __enter__(self):
        self.lock.release()
    def __exit__(self, type, value, tb):
        self.lock.acquire()

# 사용 예시:
with my_lock:
    # 잠금이 획득된 상태에서의 작업
    with released(my_lock):
        # 잠금 없이 작업
        # 예: 블로킹 I/O
    # 잠금이 다시 획득된 상태
</code></pre>
<p><strong>11. 여러 컨텍스트를 자동으로 중첩하는 <code>nested</code> 컨텍스트 매니저:</strong> 과도한 들여쓰기를 피하기 위해 제공된 컨텍스트를 왼쪽에서 오른쪽으로 자동 중첩합니다. (Python 2.5의 <code>contextlib</code> 모듈에 이 컨텍스트 매니저 버전이 포함되어 있습니다.)</p>
<pre><code class="language-python">@contextmanager
def nested(*contexts):
    # ... 구현 ...

# 사용 예시:
with nested(a, b, c) as (x, y, z):
    # 작업 수행

# 위 코드는 다음 코드와 동일합니다.
with a as x:
    with b as y:
        with c as z:
            # 작업 수행
</code></pre>
<h3>참조 구현 (Reference Implementation)</h3>
<p>이 PEP는 2005년 6월 27일 EuroPython 기조연설에서 Guido에 의해 처음 수락되었습니다. <code>__context__</code> 메서드가 추가된 후 다시 수락되었습니다. 이 PEP는 Python 2.5a1을 위해 Subversion에 구현되었고, <code>__context__()</code> 메서드는 Python 2.5b1에서 제거되었습니다.</p>
<h3>감사의 글 (Acknowledgements)</h3>
<p>PEP 340 및 PEP 346의 감사의 글에 언급된 모든 사람들을 포함하여, 이 PEP의 아이디어와 개념에 많은 사람들이 기여했습니다. 추가적으로 Paul Moore, Phillip J. Eby, Greg Ewing, Jason Orendorff, Michael Hudson, Raymond Hettinger, Walter Dörwald, Aahz, Georg Brandl, Terry Reedy, A.M. Kuchling, Brett Cannon, 그리고 python-dev 토론에 참여한 모든 사람들에게 감사드립니다.</p>
<h3>참조 (References)</h3>
<p>Raymond Chen의 숨겨진 흐름 제어에 대한 글 (https://devblogs.microsoft.com/oldnewthing/20050106-00/?p=36783)
Guido가 PEP 342에 포함된 제너레이터 변경 사항을 제안 (https://mail.python.org/pipermail/python-dev/2005-May/053885.html)
PEP 343에 대한 위키 토론 (http://wiki.python.org/moin/WithStatement)
... (이하 생략)</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/335/">[Rejected] PEP 335 - Overloadable Boolean Operators</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 343 - The “with” Statement</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/355/">[Rejected] PEP 355 - Path - Object oriented filesystem paths</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/773b243a13a00265.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"185\",\"static/chunks/app/layout-29f3b81c3a382114.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/343\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/773b243a13a00265.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"vurCQsCzY_vgt4Jj6xcPJ\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/343/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/343\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"343\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/343\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"default\"]\ne:T6459,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0343/\"\u003ePEP 343 - The “with” Statement\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 13-May-2005\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 343 – \u003ccode\u003ewith\u003c/code\u003e 문\u003c/h2\u003e\n\u003ch3\u003e초록 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP(Python Enhancement Proposal)는 Python 언어에 새로운 \u003ccode\u003ewith\u003c/code\u003e 문을 추가하여, \u003ccode\u003etry/finally\u003c/code\u003e 문의 표준적인 사용 패턴을 간결하게 만들 수 있도록 합니다.\n\u003ccode\u003ewith\u003c/code\u003e 문 내에서, \u003cstrong\u003e컨텍스트 매니저(context manager)\u003c/strong\u003e 는 \u003ccode\u003ewith\u003c/code\u003e 문 본문으로 진입하고 종료할 때 호출되는 \u003ccode\u003e__enter__()\u003c/code\u003e 및 \u003ccode\u003e__exit__()\u003c/code\u003e 메서드를 제공합니다.\u003c/p\u003e\n\u003ch3\u003e작성자 주 (Author's Note)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 원래 Guido van Rossum에 의해 작성되었으며, 이후 python-dev에서 논의된 내용을 반영하여 Alyssa (Nick) Coghlan이 업데이트했습니다. Python 2.5 알파 릴리스 주기 동안 이 PEP의 용어와 관련 문서 및 구현에서 문제점이 발견되었고, 첫 번째 Python 2.5 베타 릴리스 시점에 PEP가 안정화되었습니다.\u003c/p\u003e\n\u003ch3\u003e서론 (Introduction)\u003c/h3\u003e\n\u003cp\u003ePEP 340 및 대안에 대한 많은 논의 끝에, Guido는 PEP 340을 철회하고 PEP 310의 약간 수정된 버전을 제안했습니다. 추가 논의 후, 일시 중지된 제너레이터(generator)에서 예외를 발생시키기 위한 \u003ccode\u003ethrow()\u003c/code\u003e 메서드와 새로운 \u003ccode\u003eGeneratorExit\u003c/code\u003e 예외를 발생시키는 \u003ccode\u003eclose()\u003c/code\u003e 메서드가 다시 추가되었습니다. 이 변경 사항들은 python-dev에서 처음 제안되어 만장일치로 승인되었습니다. 또한, 키워드가 \u003ccode\u003ewith\u003c/code\u003e로 변경되었습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP가 채택된 후, 다음과 같은 PEP들은 중복으로 인해 기각되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePEP 310, Reliable Acquisition/Release Pairs:\u003c/strong\u003e \u003ccode\u003ewith\u003c/code\u003e 문에 대한 원래 제안이었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePEP 319, Python Synchronize/Asynchronize Block:\u003c/strong\u003e 이 PEP의 사용 사례는 적절한 \u003ccode\u003ewith\u003c/code\u003e 문 컨트롤러를 제공함으로써 처리될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePEP 340 및 PEP 346도 이 PEP와 중복되었으나, 이 PEP가 제출되면서 자발적으로 철회되었습니다.\u003c/p\u003e\n\u003ch3\u003e동기 및 요약 (Motivation and Summary)\u003c/h3\u003e\n\u003cp\u003ePEP 340(\u003ccode\u003eAnonymous Block Statements\u003c/code\u003e)은 제너레이터를 블록 템플릿으로 사용하고, 예외 처리 및 마무리(finalization) 기능을 제너레이터에 추가하는 등 여러 강력한 아이디어를 결합했습니다. 그러나 이는 내부적으로 잠재적인 반복(looping) 구조라는 점 때문에 많은 반대에 부딪혔습니다. 이는 \u003ccode\u003ebreak\u003c/code\u003e와 \u003ccode\u003econtinue\u003c/code\u003e가 블록 문 내에서 사용될 경우, 자원 관리 도구로 사용되더라도 블록 문을 깨거나 계속 진행시킬 수 있음을 의미했습니다.\u003c/p\u003e\n\u003cp\u003e결정적인 계기는 Raymond Chen의 흐름 제어 매크로에 대한 비판을 읽은 후였습니다. Raymond는 매크로에 흐름 제어를 숨기는 것이 코드를 이해하기 어렵게 만든다고 주장했으며, Guido는 이 주장이 C뿐만 아니라 Python에도 적용된다고 생각했습니다. PEP 340 템플릿이 모든 종류의 제어 흐름을 숨길 수 있음을 깨달은 것입니다.\u003c/p\u003e\n\u003cp\u003e반면, PEP 310의 \u003ccode\u003ewith\u003c/code\u003e 문은 흐름 제어를 숨기지 않습니다. \u003ccode\u003efinally\u003c/code\u003e 스위트(suite)가 일시적으로 흐름을 중단시키더라도, 결국에는 \u003ccode\u003efinally\u003c/code\u003e 스위트가 없었던 것처럼 흐름이 재개됩니다.\u003c/p\u003e\n\u003cp\u003ePEP 310은 대략 다음과 같은 구문을 제안했습니다. ( \u003ccode\u003eVAR =\u003c/code\u003e 부분은 선택 사항입니다.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ewith VAR = EXPR:\n    BLOCK\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 대략 다음과 같이 번역됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eVAR = EXPR\nVAR.__enter__()\ntry:\n    BLOCK\nfinally:\n    VAR.__exit__()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 접근 방식은 \u003ccode\u003eBLOCK\u003c/code\u003e 내에서 예외가 발생하거나 \u003ccode\u003ebreak\u003c/code\u003e, \u003ccode\u003econtinue\u003c/code\u003e, \u003ccode\u003ereturn\u003c/code\u003e과 같은 비지역적 \u003ccode\u003egoto\u003c/code\u003e가 실행될 경우, \u003ccode\u003efinally\u003c/code\u003e 절이 여전히 실행되도록 보장합니다.\u003c/p\u003e\n\u003cp\u003e이 아이디어는 Guido가 PEP 310을 지지하도록 이끌었지만, PEP 340의 제너레이터를 '템플릿'으로 사용하여 잠금 획득 및 해제 또는 파일 열기 및 닫기와 같은 추상화를 구현하는 강력한 아이디어를 포기할 수 없었습니다.\u003c/p\u003e\n\u003cp\u003ePhillip Eby의 PEP 340에 대한 반대 제안에 영감을 받아, 적절한 제너레이터를 필요한 \u003ccode\u003e__enter__()\u003c/code\u003e 및 \u003ccode\u003e__exit__()\u003c/code\u003e 메서드를 가진 객체로 변환하는 데코레이터를 만들려고 시도했습니다. 여기서 문제에 부딪혔는데, 잠금(locking) 예시에서는 어렵지 않았지만, 파일 열기 예시에서는 불가능했습니다.\u003c/p\u003e\n\u003cp\u003e해결책은 \u003ccode\u003eVAR\u003c/code\u003e가 \u003ccode\u003e__enter__()\u003c/code\u003e 메서드 호출의 결과를 받도록 하고, \u003ccode\u003eEXPR\u003c/code\u003e의 값을 저장하여 나중에 \u003ccode\u003e__exit__()\u003c/code\u003e 메서드를 호출하는 방식으로 번역을 약간 변경하는 것이었습니다. 이렇게 하면 제너레이터를 컨텍스트 매니저로 변환하는 데코레이터를 쉽게 작성할 수 있게 됩니다.\u003c/p\u003e\n\u003cp\u003e이후 \u003ccode\u003ewith VAR = EXPR:\u003c/code\u003e 구문이 \u003ccode\u003eVAR\u003c/code\u003e가 \u003ccode\u003eEXPR\u003c/code\u003e의 값을 직접 받지 않는다는 점에서 오해의 소지가 있다는 논의가 있었습니다. PEP 340에서 아이디어를 빌려와 \u003ccode\u003ewith EXPR as VAR:\u003c/code\u003e 구문이 채택되었습니다.\u003c/p\u003e\n\u003cp\u003e추가 논의를 통해, 제너레이터 내에서 예외를 '볼' 수 있는 기능(\u003ccode\u003ethrow()\u003c/code\u003e 메서드)이 중요하다고 판단되었습니다. 이는 \u003ccode\u003ewith\u003c/code\u003e 문이 루프처럼 사용되는 것을 방지하면서도 예외 로깅 등을 가능하게 합니다. 또한, 제너레이터가 가비지 컬렉션될 때 자동으로 호출되는 \u003ccode\u003eclose()\u003c/code\u003e 메서드도 제안되었으며, 이는 특별한 \u003ccode\u003eGeneratorExit\u003c/code\u003e 예외를 발생시킵니다.\u003c/p\u003e\n\u003cp\u003e이러한 변경 사항들을 통해 \u003ccode\u003etry-finally\u003c/code\u003e 문 내에서 \u003ccode\u003eyield\u003c/code\u003e 문을 허용할 수 있게 되었고, \u003ccode\u003efinally\u003c/code\u003e 절이 (결국) 실행될 것을 보장할 수 있게 되었습니다. (제너레이터에 대한 자세한 변경 사항은 PEP 342에서 다룹니다.)\u003c/p\u003e\n\u003ch3\u003e사용 사례 (Use Cases)\u003c/h3\u003e\n\u003cp\u003e자세한 내용은 마지막의 \"예시\" 섹션을 참조하십시오.\u003c/p\u003e\n\u003ch3\u003e사양: \u003ccode\u003ewith\u003c/code\u003e 문 (Specification: The 'with' Statement)\u003c/h3\u003e\n\u003cp\u003e다음과 같은 구문의 새로운 문이 제안됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ewith EXPR as VAR:\n    BLOCK\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003ewith\u003c/code\u003e와 \u003ccode\u003eas\u003c/code\u003e는 새로운 키워드입니다. \u003ccode\u003eEXPR\u003c/code\u003e은 임의의 표현식이며, \u003ccode\u003eVAR\u003c/code\u003e는 단일 할당 대상입니다. \u003ccode\u003eVAR\u003c/code\u003e는 쉼표로 구분된 변수 시퀀스가 될 수 없지만, 괄호로 묶인 쉼표로 구분된 변수 시퀀스는 가능합니다. (\u003ccode\u003eas VAR\u003c/code\u003e 부분은 선택 사항입니다.)\u003c/p\u003e\n\u003cp\u003e위 문의 번역은 다음과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003emgr = (EXPR)\nexit = type(mgr).__exit__ # 아직 호출하지 않음\nvalue = type(mgr).__enter__(mgr)\nexc = True\ntry:\n    try:\n        VAR = value # \"as VAR\"가 있는 경우에만\n        BLOCK\n    except: # 예외 발생 시 처리\n        exc = False\n        if not exit(mgr, *sys.exc_info()):\n            raise # exit()가 True를 반환하면 예외는 삼켜짐\n    finally: # 정상 및 비지역적 goto의 경우 처리\n        if exc:\n            exit(mgr, None, None, None)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 소문자 변수(mgr, exit, value, exc)는 내부 변수이며 사용자에게는 접근할 수 없습니다. 이는 주로 특별한 레지스터 또는 스택 위치로 구현될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emgr.__exit__()\u003c/code\u003e의 호출 규칙은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eBLOCK\u003c/code\u003e의 정상 완료 또는 비지역적 \u003ccode\u003egoto\u003c/code\u003e(\u003ccode\u003ebreak\u003c/code\u003e, \u003ccode\u003econtinue\u003c/code\u003e, \u003ccode\u003ereturn\u003c/code\u003e)를 통해 \u003ccode\u003efinally\u003c/code\u003e 스위트에 도달한 경우, \u003ccode\u003emgr.__exit__()\u003c/code\u003e는 세 개의 \u003ccode\u003eNone\u003c/code\u003e 인자와 함께 호출됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBLOCK\u003c/code\u003e에서 발생한 예외를 통해 \u003ccode\u003efinally\u003c/code\u003e 스위트에 도달한 경우, \u003ccode\u003emgr.__exit__()\u003c/code\u003e는 예외 유형, 값, 트레이스백을 나타내는 세 개의 인자와 함께 호출됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e중요:\u003c/strong\u003e \u003ccode\u003emgr.__exit__()\u003c/code\u003e가 \"참(true)\" 값을 반환하면 예외는 \"삼켜집니다(swallowed)\". 즉, \u003ccode\u003ewith\u003c/code\u003e 문 내에서 예외가 발생했더라도 \u003ccode\u003eexit()\u003c/code\u003e가 \u003ccode\u003eTrue\u003c/code\u003e를 반환하면 \u003ccode\u003ewith\u003c/code\u003e 문 다음 문에서 실행이 계속됩니다. 그러나 \u003ccode\u003ewith\u003c/code\u003e 문이 비지역적 \u003ccode\u003egoto\u003c/code\u003e(\u003ccode\u003ebreak\u003c/code\u003e, \u003ccode\u003econtinue\u003c/code\u003e, \u003ccode\u003ereturn\u003c/code\u003e)를 통해 종료된 경우, \u003ccode\u003emgr.__exit__()\u003c/code\u003e의 반환 값과 관계없이 이 비지역적 반환이 재개됩니다. 이는 \u003ccode\u003emgr.__exit__()\u003c/code\u003e가 예외를 삼킬 수 있도록 하면서도, 기본 반환 값인 \u003ccode\u003eNone\u003c/code\u003e이 거짓(false)이므로 예외가 다시 발생하도록 하여 예외 삼키기를 너무 쉽게 만들지 않기 위함입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__exit__()\u003c/code\u003e에 예외 세부 정보를 전달하는 동기는 트랜잭션(\u003ccode\u003etransactional()\u003c/code\u003e) 사용 사례(아래 예시 3)에서 비롯되었습니다. 이 예시의 템플릿은 예외 발생 여부에 따라 트랜잭션을 커밋하거나 롤백해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e__exit__()\u003c/code\u003e 메서드는 전달된 오류를 다시 발생시키지 않아야 합니다. 오류를 다시 발생시키는 것은 항상 \u003ccode\u003e__exit__()\u003c/code\u003e 메서드를 호출하는 호출자의 책임입니다.\u003c/p\u003e\n\u003ch3\u003e전환 계획 (Transition Plan)\u003c/h3\u003e\n\u003cp\u003ePython 2.5에서는 \u003ccode\u003efrom __future__ import with_statement\u003c/code\u003e 미래 문이 있을 경우에만 새로운 구문이 인식됩니다. 이 경우 \u003ccode\u003ewith\u003c/code\u003e와 \u003ccode\u003eas\u003c/code\u003e가 키워드가 됩니다. 미래 문이 없으면 \u003ccode\u003ewith\u003c/code\u003e 또는 \u003ccode\u003eas\u003c/code\u003e를 식별자로 사용하면 \u003ccode\u003estderr\u003c/code\u003e에 경고가 발행됩니다.\nPython 2.6에서는 새로운 구문이 항상 인식되며, \u003ccode\u003ewith\u003c/code\u003e와 \u003ccode\u003eas\u003c/code\u003e는 항상 키워드입니다.\u003c/p\u003e\n\u003ch3\u003e제너레이터 데코레이터 (Generator Decorator)\u003c/h3\u003e\n\u003cp\u003ePEP 342가 채택되면서, 정확히 한 번 \u003ccode\u003eyield\u003c/code\u003e하는 제너레이터를 사용하여 \u003ccode\u003ewith\u003c/code\u003e 문을 제어하는 데코레이터를 작성할 수 있게 되었습니다. \u003ccode\u003eGeneratorContextManager\u003c/code\u003e 클래스를 사용하여 제너레이터 함수를 컨텍스트 매니저 팩토리로 변환하는 \u003ccode\u003econtextmanager\u003c/code\u003e 데코레이터를 구현할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e강력한 구현은 표준 라이브러리의 일부가 될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# GeneratorContextManager 및 contextmanager 데코레이터의 스케치\nclass GeneratorContextManager(object):\n    def __init__(self, gen):\n        self.gen = gen\n    def __enter__(self):\n        try:\n            return self.gen.next()\n        except StopIteration:\n            raise RuntimeError(\"generator didn't yield\")\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            try:\n                self.gen.next()\n            except StopIteration:\n                return\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            try:\n                self.gen.throw(type, value, traceback)\n                raise RuntimeError(\"generator didn't stop after throw()\")\n            except StopIteration:\n                return True\n            except:\n                # throw() 프로토콜과 __exit__() 프로토콜 간의 불일치 해결\n                # __exit__() 자체에 실패하지 않는 한 예외를 발생시키지 않아야 함\n                pass # (원문에는 주석 처리된 raise 조건이 있으나, 스케치이므로 간략화)\n\ndef contextmanager(func):\n    def helper(*args, **kwds):\n        return GeneratorContextManager(func(*args, **kwds))\n    return helper\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 데코레이터는 다음과 같이 사용될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@contextmanager\ndef opening(filename):\n    f = open(filename)\n    try:\n        yield f\n    finally:\n        f.close()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e표준 라이브러리의 컨텍스트 매니저 (Context Managers in the Standard Library)\u003c/h3\u003e\n\u003cp\u003e파일, 소켓, 잠금(lock)과 같은 특정 객체에 \u003ccode\u003e__enter__()\u003c/code\u003e 및 \u003ccode\u003e__exit__()\u003c/code\u003e 메서드를 부여하여 직접 \u003ccode\u003ewith\u003c/code\u003e 문에서 사용할 수 있도록 할 수 있습니다.\n예를 들어, \u003ccode\u003ewith locking(myLock): BLOCK\u003c/code\u003e 대신 \u003ccode\u003ewith myLock: BLOCK\u003c/code\u003e와 같이 작성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 이러한 방식은 \u003ccode\u003ef = open(filename); with f: BLOCK1; with f: BLOCK2\u003c/code\u003e와 같이 \u003ccode\u003ef\u003c/code\u003e가 \u003ccode\u003eBLOCK2\u003c/code\u003e에 진입하기 전에 닫히는 오해를 불러일으킬 수 있으므로 주의해야 합니다. 이러한 실수는 쉽게 진단할 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePython 2.5에서는 다음 유형들이 컨텍스트 매니저로 식별되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efile\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ethread.LockType\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ethreading.Lock\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ethreading.RLock\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ethreading.Condition\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ethreading.Semaphore\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ethreading.BoundedSemaphore\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003edecimal\u003c/code\u003e 모듈에도 \u003ccode\u003ewith\u003c/code\u003e 문 본문 내에서 지역 십진수 산술 컨텍스트를 지원하고, \u003ccode\u003ewith\u003c/code\u003e 문을 종료할 때 원래 컨텍스트를 자동으로 복원하는 컨텍스트 매니저가 추가될 것입니다.\u003c/p\u003e\n\u003ch3\u003e표준 용어 (Standard Terminology)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003e__enter__()\u003c/code\u003e 및 \u003ccode\u003e__exit__()\u003c/code\u003e 메서드로 구성된 프로토콜을 \" \u003cstrong\u003e컨텍스트 관리 프로토콜(context management protocol)\u003c/strong\u003e \"이라고 부르고, 이 프로토콜을 구현하는 객체를 \" \u003cstrong\u003e컨텍스트 매니저(context manager)\u003c/strong\u003e \"라고 부를 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewith\u003c/code\u003e 키워드 바로 뒤에 오는 표현식은 \"컨텍스트 표현식(context expression)\"이며, 이는 \u003ccode\u003ewith\u003c/code\u003e 문 본문 기간 동안 컨텍스트 매니저가 설정하는 런타임 환경에 대한 주요 단서를 제공합니다.\u003c/p\u003e\n\u003ch3\u003e컨텍스트 매니저 캐싱 (Caching Context Managers)\u003c/h3\u003e\n\u003cp\u003e많은 컨텍스트 매니저(예: 파일 및 제너레이터 기반 컨텍스트)는 한 번만 사용되는 객체입니다. \u003ccode\u003e__exit__()\u003c/code\u003e 메서드가 호출되면 컨텍스트 매니저는 더 이상 사용 가능한 상태가 아닙니다.\u003c/p\u003e\n\u003cp\u003e각 \u003ccode\u003ewith\u003c/code\u003e 문마다 새로운 매니저 객체를 요구하는 것이 멀티스레드 코드 및 중첩된 \u003ccode\u003ewith\u003c/code\u003e 문에서 동일한 컨텍스트 매니저를 사용하려 할 때 발생하는 문제를 피하는 가장 쉬운 방법입니다. 재사용을 지원하는 모든 표준 라이브러리 컨텍스트 매니저가 \u003ccode\u003ethreading\u003c/code\u003e 모듈에서 비롯되었다는 것은 우연이 아닙니다.\u003c/p\u003e\n\u003ch3\u003e해결된 문제 (Resolved Issues)\u003c/h3\u003e\n\u003cp\u003e다음 문제들은 BDFL(Benevolent Dictator For Life)의 승인과 python-dev에서의 주요 반대 의견 부족으로 해결되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e제너레이터-이터레이터가 오작동할 때 \u003ccode\u003eGeneratorContextManager\u003c/code\u003e는 어떤 예외를 발생시켜야 하는가?\u003c/strong\u003e Guido는 이 경우와 PEP 342의 제너레이터 \u003ccode\u003eclose()\u003c/code\u003e 메서드 모두에 대해 \u003ccode\u003eRuntimeError\u003c/code\u003e를 선택했습니다. \u003ccode\u003eRuntimeError\u003c/code\u003e는 프로그래머가 코드를 수정하도록 유도하는 데 적합하며, 무한 재귀 감지 등 핵심 Python 코드에서 이미 사용되는 선례가 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewith\u003c/code\u003e 문에 관련된 클래스에 해당 메서드가 없을 경우 \u003ccode\u003eTypeError\u003c/code\u003e 대신 \u003ccode\u003eAttributeError\u003c/code\u003e를 발생시키는 것이 허용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__enter__/__exit__\u003c/code\u003e 메서드를 가진 객체는 \"컨텍스트 매니저\"라고 불리며, 제너레이터 함수를 컨텍스트 매니저 팩토리로 변환하는 데코레이터는 \u003ccode\u003econtextlib.contextmanager\u003c/code\u003e입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e거부된 옵션 (Rejected Options)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e예외 억제 금지:\u003c/strong\u003e 초기에는 숨겨진 흐름 제어를 피하기 위해 예외 억제가 금지되었으나, 구현상의 어려움으로 인해 Guido는 예외 억제 기능을 복원했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e__context__()\u003c/code\u003e 메서드:\u003c/strong\u003e 이터러블의 \u003ccode\u003e__iter__()\u003c/code\u003e 메서드와 유사한 \u003ccode\u003e__context__()\u003c/code\u003e 메서드를 추가하자는 제안이 있었으나, 설명 및 작동 방식에 대한 지속적인 문제로 인해 Guido는 이 개념을 완전히 제거했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePEP 342 제너레이터 API 직접 사용:\u003c/strong\u003e \u003ccode\u003ewith\u003c/code\u003e 문 정의에 PEP 342의 향상된 제너레이터 API를 직접 사용하자는 아이디어도 잠시 고려되었으나, 제너레이터 기반이 아닌 컨텍스트 매니저 작성을 너무 어렵게 만든다는 이유로 빠르게 기각되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e예시 (Examples)\u003c/h3\u003e\n\u003cp\u003e제너레이터 기반 예시는 PEP 342에 의존합니다. 또한, 일부 예시는 \u003ccode\u003ethreading.RLock\u003c/code\u003e와 같은 적절한 객체가 \u003ccode\u003ewith\u003c/code\u003e 문에서 직접 사용될 수 있으므로 실제로는 필요하지 않을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예시 컨텍스트의 이름에 사용된 시제는 임의적이지 않습니다. \u003ccode\u003e__enter__\u003c/code\u003e 메서드에서 수행되고 \u003ccode\u003e__exit__\u003c/code\u003e 메서드에서 되돌려지는 동작을 나타낼 때는 과거 시제(\" -ed \")가 사용됩니다. \u003ccode\u003e__exit__\u003c/code\u003e 메서드에서 수행될 동작을 나타낼 때는 현재 진행형 시제(\" -ing \")가 사용됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. 잠금(Lock) 보장:\u003c/strong\u003e 블록 시작 시 획득한 잠금이 블록을 벗어날 때 해제되도록 보장하는 템플릿입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@contextmanager\ndef locked(lock):\n    lock.acquire()\n    try:\n        yield\n    finally:\n        lock.release()\n\n# 사용 예시:\nwith locked(myLock):\n    # 이 코드 블록은 myLock이 획득된 상태에서 실행됩니다.\n    # 블록을 벗어날 때 (return 또는 잡히지 않은 예외를 통해서도)\n    # 잠금은 해제되는 것이 보장됩니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e2. 파일 열기 및 닫기 보장:\u003c/strong\u003e 블록을 벗어날 때 파일이 닫히도록 보장하는 템플릿입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@contextmanager\ndef opened(filename, mode=\"r\"):\n    f = open(filename, mode)\n    try:\n        yield f\n    finally:\n        f.close()\n\n# 사용 예시:\nwith opened(\"/etc/passwd\") as f:\n    for line in f:\n        print(line.rstrip())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e3. 데이터베이스 트랜잭션 커밋 또는 롤백:\u003c/strong\u003e 데이터베이스 트랜잭션을 커밋하거나 롤백하는 템플릿입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@contextmanager\ndef transaction(db):\n    db.begin()\n    try:\n        yield None\n    except:\n        db.rollback()\n        raise\n    else:\n        db.commit()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e4. \u003ccode\u003elocked\u003c/code\u003e 예시를 제너레이터 없이 재작성:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass locked:\n    def __init__(self, lock):\n        self.lock = lock\n    def __enter__(self):\n        self.lock.acquire()\n    def __exit__(self, type, value, tb):\n        self.lock.release()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e5. 표준 출력(stdout) 일시적으로 리디렉션:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@contextmanager\ndef stdout_redirected(new_stdout):\n    save_stdout = sys.stdout\n    sys.stdout = new_stdout\n    try:\n        yield None\n    finally:\n        sys.stdout = save_stdout\n\n# 사용 예시:\nwith opened(filename, \"w\") as f:\n    with stdout_redirected(f):\n        print(\"Hello world\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e6. 오류 조건도 반환하는 \u003ccode\u003eopened()\u003c/code\u003e 변형:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@contextmanager\ndef opened_w_error(filename, mode=\"r\"):\n    try:\n        f = open(filename, mode)\n    except IOError as err:\n        yield None, err\n    else:\n        try:\n            yield f, None\n        finally:\n            f.close()\n\n# 사용 예시:\nwith opened_w_error(\"/etc/passwd\", \"a\") as (f, err):\n    if err:\n        print(\"IOError:\", err)\n    else:\n        f.write(\"guido::0:0::/:/bin/sh\\n\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e7. \u003ccode\u003edecimal\u003c/code\u003e 모듈의 추가 정밀도 컨텍스트:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport decimal\n@contextmanager\ndef extra_precision(places=2):\n    c = decimal.getcontext()\n    saved_prec = c.prec\n    c.prec += places\n    try:\n        yield None\n    finally:\n        c.prec = saved_prec\n\n# 사용 예시:\ndef sin(x):\n    with extra_precision():\n        # ... 사인 계산 로직 ...\n        return +s\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e8. \u003ccode\u003edecimal\u003c/code\u003e 모듈의 지역 컨텍스트 매니저:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom decimal import localcontext, ExtendedContext\n@contextmanager\ndef localcontext(ctx=None):\n    \"\"\"Set a new local decimal context for the block\"\"\"\n    # ... 구현 ...\n\n# 사용 예시:\ndef sin(x):\n    with localcontext() as ctx:\n        ctx.prec += 2\n        # ... 사인 계산 로직 ...\n        return +s\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e9. 제네릭 \"객체 닫기\" 컨텍스트 매니저 (\u003ccode\u003eclosing\u003c/code\u003e):\u003c/strong\u003e \u003ccode\u003eclose\u003c/code\u003e 메서드를 가진 모든 객체를 확정적으로 닫는 데 사용됩니다. (Python 2.5의 \u003ccode\u003econtextlib\u003c/code\u003e 모듈에 이 컨텍스트 매니저 버전이 포함되어 있습니다.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass closing(object):\n    def __init__(self, obj):\n        self.obj = obj\n    def __enter__(self):\n        return self.obj\n    def __exit__(self, *exc_info):\n        try:\n            close_it = self.obj.close\n        except AttributeError:\n            pass\n        else:\n            close_it()\n\n# 사용 예시:\nwith closing(open(\"argument.txt\")) as contradiction:\n    for line in contradiction:\n        print(line)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e10. 잠금을 일시적으로 해제하는 \u003ccode\u003ereleased()\u003c/code\u003e 컨텍스트:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass released:\n    def __init__(self, lock):\n        self.lock = lock\n    def __enter__(self):\n        self.lock.release()\n    def __exit__(self, type, value, tb):\n        self.lock.acquire()\n\n# 사용 예시:\nwith my_lock:\n    # 잠금이 획득된 상태에서의 작업\n    with released(my_lock):\n        # 잠금 없이 작업\n        # 예: 블로킹 I/O\n    # 잠금이 다시 획득된 상태\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e11. 여러 컨텍스트를 자동으로 중첩하는 \u003ccode\u003enested\u003c/code\u003e 컨텍스트 매니저:\u003c/strong\u003e 과도한 들여쓰기를 피하기 위해 제공된 컨텍스트를 왼쪽에서 오른쪽으로 자동 중첩합니다. (Python 2.5의 \u003ccode\u003econtextlib\u003c/code\u003e 모듈에 이 컨텍스트 매니저 버전이 포함되어 있습니다.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@contextmanager\ndef nested(*contexts):\n    # ... 구현 ...\n\n# 사용 예시:\nwith nested(a, b, c) as (x, y, z):\n    # 작업 수행\n\n# 위 코드는 다음 코드와 동일합니다.\nwith a as x:\n    with b as y:\n        with c as z:\n            # 작업 수행\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e참조 구현 (Reference Implementation)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 2005년 6월 27일 EuroPython 기조연설에서 Guido에 의해 처음 수락되었습니다. \u003ccode\u003e__context__\u003c/code\u003e 메서드가 추가된 후 다시 수락되었습니다. 이 PEP는 Python 2.5a1을 위해 Subversion에 구현되었고, \u003ccode\u003e__context__()\u003c/code\u003e 메서드는 Python 2.5b1에서 제거되었습니다.\u003c/p\u003e\n\u003ch3\u003e감사의 글 (Acknowledgements)\u003c/h3\u003e\n\u003cp\u003ePEP 340 및 PEP 346의 감사의 글에 언급된 모든 사람들을 포함하여, 이 PEP의 아이디어와 개념에 많은 사람들이 기여했습니다. 추가적으로 Paul Moore, Phillip J. Eby, Greg Ewing, Jason Orendorff, Michael Hudson, Raymond Hettinger, Walter Dörwald, Aahz, Georg Brandl, Terry Reedy, A.M. Kuchling, Brett Cannon, 그리고 python-dev 토론에 참여한 모든 사람들에게 감사드립니다.\u003c/p\u003e\n\u003ch3\u003e참조 (References)\u003c/h3\u003e\n\u003cp\u003eRaymond Chen의 숨겨진 흐름 제어에 대한 글 (https://devblogs.microsoft.com/oldnewthing/20050106-00/?p=36783)\nGuido가 PEP 342에 포함된 제너레이터 변경 사항을 제안 (https://mail.python.org/pipermail/python-dev/2005-May/053885.html)\nPEP 343에 대한 위키 토론 (http://wiki.python.org/moin/WithStatement)\n... (이하 생략)\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2279,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 343 - The “with” Statement\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 01:01:20+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/343/\",\"postId\":\"2025-09-27-pep-0343-the-with-statement\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/335/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 335 - Overloadable Boolean Operators\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 343 - The “with” Statement\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/355/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 355 - Path - Object oriented filesystem paths\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.cloud/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>