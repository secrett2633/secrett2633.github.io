3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-ee5764c1002761f9.js","132","static/chunks/132-273e49420772df1e.js","185","static/chunks/app/layout-d443cbc354279241.js"],"default"]
7:I[231,["231","static/chunks/231-ee5764c1002761f9.js","877","static/chunks/app/%5B...slug%5D/page-ef33f0f4c1a350bd.js"],""]
8:I[4080,["231","static/chunks/231-ee5764c1002761f9.js","132","static/chunks/132-273e49420772df1e.js","185","static/chunks/app/layout-d443cbc354279241.js"],""]
4:["slug","python/pep/567","c"]
0:["mJI0q5Z-SQWBtT83kG_N7",[[["",{"children":[["slug","python/pep/567","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"567\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/567","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","link",null,{"rel":"dns-prefetch","href":"https://www.googletagmanager.com"}],["$","link",null,{"rel":"preconnect","href":"https://www.googletagmanager.com","crossOrigin":"anonymous"}],["$","link",null,{"rel":"dns-prefetch","href":"https://giscus.app"}],["$","link",null,{"rel":"preconnect","href":"https://giscus.app","crossOrigin":"anonymous"}],["$","meta",null,{"httpEquiv":"X-Content-Type-Options","content":"nosniff"}],["$","meta",null,{"name":"referrer","content":"strict-origin-when-cross-origin"}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"WebSite\",\"name\":\"secrett2633's blog\",\"url\":\"https://blog.secrett2633.cloud\",\"description\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\",\"inLanguage\":\"ko\",\"publisher\":{\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\"}}"}}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\",\"sameAs\":[\"https://github.com/secrett2633\"]}"}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":[["$","a",null,{"href":"#main-content","className":"sr-only focus:not-sr-only focus:absolute focus:z-50 focus:p-4 focus:bg-white focus:text-blue-600","children":"본문으로 건너뛰기"}],["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"id":"main-content","className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":["© ",2026," secrett2633. All rights reserved."]}]}]}]}]]}],["$","$L8",null,{"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY","strategy":"afterInteractive"}],["$","$L8",null,{"id":"gtag-init","strategy":"afterInteractive","children":"window.dataLayer = window.dataLayer || [];\n            function gtag(){dataLayer.push(arguments);}\n            gtag('js', new Date());\n            gtag('config', 'G-NE2W3CFPNY');"}]]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","role":"status","aria-label":"로딩 중","children":[["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}],["$","span",null,{"className":"sr-only","children":"로딩 중..."}]]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/edb8d4ad4fe2f3b0.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L9"]]]]]
b:I[646,["231","static/chunks/231-ee5764c1002761f9.js","877","static/chunks/app/%5B...slug%5D/page-ef33f0f4c1a350bd.js"],"default"]
a:T57d9,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0567/" target="_blank" rel="noopener noreferrer">PEP 567 - Context Variables</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 12-Dec-2017</p>
</blockquote>
<h2 id="pep-567-context-variables-한국어-번역-및-요약"><a href="#pep-567-context-variables-한국어-번역-및-요약">PEP 567 – Context Variables 한국어 번역 및 요약</a></h2>
<h3 id="초록-abstract"><a href="#초록-abstract">초록 (Abstract)</a></h3>
<p>이 PEP(Python Enhancement Proposal)는 <strong>컨텍스트 변수(context variables)</strong> 를 지원하기 위한 새로운 <code>contextvars</code> 모듈과 CPython C API 집합을 제안합니다. 이 개념은 스레드 로컬 저장소(thread-local storage, TLS)와 유사하지만, TLS와 달리 <code>asyncio.Task</code>와 같은 비동기 태스크별로 값들을 올바르게 추적할 수 있도록 합니다.</p>
<p>이 제안은 PEP 550의 간소화된 버전입니다. 핵심 차이점은 PEP 567이 제너레이터(generators)가 아닌 비동기 태스크를 위한 경우에만 초점을 맞춘다는 것입니다. 내장 타입이나 인터프리터에 대한 수정은 제안되지 않았습니다. 이 제안은 Python의 컨텍스트 매니저(Context Managers)와 엄격하게 관련되어 있지는 않지만, 컨텍스트 매니저가 상태를 저장하는 데 사용할 수 있는 메커니즘을 제공합니다.</p>
<h3 id="배경-rationale"><a href="#배경-rationale">배경 (Rationale)</a></h3>
<p>스레드 로컬 변수(thread-local variables)는 동일한 OS 스레드 내에서 동시에 실행되는 비동기 태스크(asynchronous tasks)에는 불충분합니다. <code>threading.local()</code>을 사용하여 컨텍스트 값을 저장하고 복원하는 모든 컨텍스트 매니저는 <code>async/await</code> 코드에서 사용될 때 컨텍스트 값이 예기치 않게 다른 코드로 누출될 수 있습니다.</p>
<p>비동기 코드에서 컨텍스트 로컬 저장소(context local storage)가 필요한 몇 가지 예시는 다음과 같습니다:</p>
<ul>
<li><code>decimal</code> 컨텍스트 및 <code>numpy.errstate</code>와 같은 컨텍스트 매니저.</li>
<li>웹 애플리케이션의 보안 토큰 및 요청 데이터, <code>gettext</code>의 언어 컨텍스트 등 요청 관련 데이터.</li>
<li>대규모 코드베이스에서의 프로파일링(profiling), 트레이싱(tracing) 및 로깅(logging).</li>
</ul>
<h3 id="도입-introduction"><a href="#도입-introduction">도입 (Introduction)</a></h3>
<p>이 PEP는 컨텍스트 변수를 관리하기 위한 새로운 메커니즘을 제안합니다. 이 메커니즘에 관련된 핵심 클래스는 <code>contextvars.Context</code>와 <code>contextvars.ContextVar</code>입니다. 또한, 비동기 태스크 주변에서 이 메커니즘을 사용하는 정책도 제안합니다.</p>
<p>컨텍스트 변수에 접근하기 위한 제안된 메커니즘은 <code>ContextVar</code> 클래스를 사용합니다. 새로운 메커니즘을 사용하려는 모듈(예: <code>decimal</code>)은 다음을 수행해야 합니다:</p>
<ul>
<li><code>ContextVar</code>를 키(key)로 사용하는 모듈-전역 변수를 선언합니다.</li>
<li>키 변수의 <code>get()</code> 메서드를 통해 현재 값에 접근합니다.</li>
<li>키 변수의 <code>set()</code> 메서드를 통해 현재 값을 수정합니다.</li>
</ul>
<p>"현재 값(current value)"의 개념은 특별한 고려가 필요합니다. 동시에 존재하고 실행되는 다른 비동기 태스크는 동일한 키에 대해 다른 값을 가질 수 있습니다. 이 아이디어는 스레드 로컬 저장소에서 잘 알려져 있지만, 이 경우에는 값의 지역성(locality)이 반드시 스레드에 묶여 있지 않습니다. 대신, 스레드 로컬 저장소에 저장되는 "현재 <code>Context</code>"라는 개념이 있습니다. 현재 컨텍스트의 조작은 <code>asyncio</code>와 같은 태스크 프레임워크의 책임입니다.</p>
<p><code>Context</code>는 <code>ContextVar</code> 객체와 해당 값들의 매핑(mapping)입니다. <code>Context</code> 자체는 <code>abc.Mapping</code> 인터페이스를 노출하며 (<code>abc.MutableMapping</code>이 아님!), 따라서 직접 수정할 수 없습니다. <code>Context</code> 객체에서 컨텍스트 변수의 새 값을 설정하려면 사용자는 다음을 수행해야 합니다:</p>
<ol>
<li><code>Context.run()</code> 메서드를 사용하여 <code>Context</code> 객체를 "현재(current)"로 만듭니다.</li>
<li><code>ContextVar.set()</code>을 사용하여 컨텍스트 변수의 새 값을 설정합니다.</li>
</ol>
<p><code>ContextVar.get()</code> 메서드는 <code>self</code>를 키로 사용하여 현재 <code>Context</code> 객체에서 변수를 찾습니다. 현재 <code>Context</code> 객체에 대한 직접 참조를 얻는 것은 불가능하지만, <code>contextvars.copy_context()</code> 함수를 사용하여 얕은 복사본을 얻을 수 있습니다. 이를 통해 <code>Context.run()</code> 호출자가 해당 <code>Context</code> 객체의 유일한 소유자임을 보장합니다.</p>
<h3 id="명세-specification"><a href="#명세-specification">명세 (Specification)</a></h3>
<p>새로운 표준 라이브러리 모듈 <code>contextvars</code>가 다음 API와 함께 추가됩니다:</p>
<ul>
<li><code>copy_context() -> Context</code> 함수: 현재 OS 스레드의 현재 <code>Context</code> 객체의 복사본을 가져오는 데 사용됩니다.</li>
<li><code>ContextVar</code> 클래스: 컨텍스트 변수를 선언하고 접근하는 데 사용됩니다.</li>
<li><code>Context</code> 클래스: 컨텍스트 상태를 캡슐화합니다. 모든 OS 스레드는 현재 <code>Context</code> 인스턴스에 대한 참조를 저장합니다. 이 참조를 직접 제어하는 것은 불가능합니다. 대신 <code>Context.run(callable, *args, **kwargs)</code> 메서드를 사용하여 다른 컨텍스트에서 Python 코드를 실행합니다.</li>
</ul>
<h4 id="contextvarscontextvar"><a href="#contextvarscontextvar"><code>contextvars.ContextVar</code></a></h4>
<p><code>ContextVar</code> 클래스는 다음 생성자 시그니처를 가집니다: <code>ContextVar(name, *, default=_NO_DEFAULT)</code>.
<code>name</code> 매개변수는 인트로스펙션(introspection) 및 디버그 목적으로 사용되며, 읽기 전용 <code>ContextVar.name</code> 속성으로 노출됩니다. <code>default</code> 매개변수는 선택 사항입니다.</p>
<p>예시:</p>
<pre><code class="language-python"># 'var'이라는 컨텍스트 변수를 기본값 42로 선언합니다.
var = ContextVar('var', default=42)
</code></pre>
<p><code>ContextVar.get(default=_NO_DEFAULT)</code>는 현재 <code>Context</code>에 대한 컨텍스트 변수의 값을 반환합니다:</p>
<pre><code class="language-python"># `var`의 값을 가져옵니다.
var.get()
</code></pre>
<p>현재 컨텍스트에 변수 값이 없으면 <code>ContextVar.get()</code>은 다음을 수행합니다:</p>
<ul>
<li>제공된 경우 <code>get()</code> 메서드의 <code>default</code> 인자 값을 반환합니다.</li>
<li>제공된 경우 컨텍스트 변수의 기본값을 반환합니다.</li>
<li>그렇지 않으면 <code>LookupError</code>를 발생시킵니다.</li>
</ul>
<p><code>ContextVar.set(value) -> Token</code>은 현재 <code>Context</code>에 컨텍스트 변수의 새 값을 설정하는 데 사용됩니다:</p>
<pre><code class="language-python"># 현재 컨텍스트에서 변수 'var'를 1로 설정합니다.
var.set(1)
</code></pre>
<p><code>ContextVar.reset(token)</code>은 현재 컨텍스트에서 변수를 토큰을 생성한 <code>set()</code> 작업 이전의 값으로 재설정하거나 (또는 설정되지 않은 경우 변수를 제거) 하는 데 사용됩니다:</p>
<pre><code class="language-python"># 가정: var.get(None) is None
# 'var'를 1로 설정합니다:
token = var.set(1)
try:
    # var.get() == 1
    pass
finally:
    var.reset(token)
    # 재설정 후: var.get(None) is None,
    # 즉 'var'는 현재 컨텍스트에서 제거되었습니다.
</code></pre>
<p><code>ContextVar.reset()</code> 메서드는 다음 경우에 <code>ValueError</code>를 발생시킵니다:</p>
<ul>
<li>다른 변수가 생성한 토큰 객체로 호출될 때.</li>
<li>현재 <code>Context</code> 객체가 토큰 객체가 생성된 컨텍스트와 일치하지 않을 때.</li>
<li>토큰 객체가 변수를 재설정하기 위해 이미 한 번 사용되었을 때 <code>RuntimeError</code>를 발생시킵니다.</li>
</ul>
<h4 id="contextvarstoken"><a href="#contextvarstoken"><code>contextvars.Token</code></a></h4>
<p><code>contextvars.Token</code>은 <code>ContextVar</code>를 이전 값으로 복원하거나, 변수가 이전에 설정되지 않은 경우 컨텍스트에서 제거하는 데 사용되어야 하는 불투명(opaque) 객체입니다. 이는 <code>ContextVar.set()</code>을 호출함으로써만 생성될 수 있습니다.</p>
<p>디버그 및 인트로스펙션 목적으로 다음 속성을 가집니다:</p>
<ul>
<li>읽기 전용 속성 <code>Token.var</code>: 토큰을 생성한 변수를 가리킵니다.</li>
<li>읽기 전용 속성 <code>Token.old_value</code>: <code>set()</code> 호출 이전 변수가 가졌던 값으로 설정되거나, 변수가 이전에 설정되지 않은 경우 <code>Token.MISSING</code>으로 설정됩니다.</li>
</ul>
<h4 id="contextvarscontext"><a href="#contextvarscontext"><code>contextvars.Context</code></a></h4>
<p><code>Context</code> 객체는 컨텍스트 변수와 값의 매핑입니다.
<code>Context()</code>는 빈 컨텍스트를 생성합니다. 현재 OS 스레드의 현재 <code>Context</code>의 복사본을 얻으려면 <code>contextvars.copy_context()</code> 메서드를 사용합니다:</p>
<pre><code class="language-python">ctx = contextvars.copy_context()
</code></pre>
<p>특정 <code>Context</code>에서 Python 코드를 실행하려면 <code>Context.run()</code> 메서드를 사용합니다:</p>
<pre><code class="language-python">ctx.run(function)
</code></pre>
<p><code>function</code>이 유발하는 모든 컨텍스트 변수 변경 사항은 <code>ctx</code> 컨텍스트에 포함됩니다:</p>
<pre><code class="language-python">var = ContextVar('var')
var.set('spam')

def main():
    # 'copy_context()' 및 'ctx.run(main)' 호출 전에 'var'는 'spam'으로 설정되었습니다.
    # 따라서: var.get() == ctx[var] == 'spam'
    var.set('ham')
    # 이제 'var'를 'ham'으로 설정한 후:
    # var.get() == ctx[var] == 'ham'

ctx = copy_context()
# 'main' 함수가 'var'에 대해 수행하는 모든 변경 사항은 'ctx'에 포함됩니다.
ctx.run(main)

# 'main()' 함수는 'ctx' 컨텍스트에서 실행되었으므로,
# 'var'에 대한 변경 사항은 그 안에 포함됩니다:
# ctx[var] == 'ham'
# 그러나 'ctx' 외부에서는 'var'가 여전히 'spam'으로 설정되어 있습니다:
# var.get() == 'spam'
</code></pre>
<p><code>Context.run()</code>은 두 개 이상의 OS 스레드에서 동일한 컨텍스트 객체에 대해 호출되거나, 재귀적으로 호출될 때 <code>RuntimeError</code>를 발생시킵니다.
<code>Context.copy()</code>는 컨텍스트 객체의 얕은 복사본을 반환합니다.</p>
<p><code>Context</code> 객체는 <code>collections.abc.Mapping</code> ABC를 구현합니다. 이는 컨텍스트를 인트로스펙션하는 데 사용될 수 있습니다:</p>
<pre><code class="language-python">ctx = contextvars.copy_context()
# 'ctx'에 있는 모든 컨텍스트 변수와 해당 값을 출력합니다:
print(ctx.items())
# 컨텍스트 'ctx'에서 'some_variable'의 값을 출력합니다:
print(ctx[some_variable])
</code></pre>
<p><code>Context.__getitem__</code> 및 <code>Context.get</code>을 포함한 모든 <code>Mapping</code> 메서드는 컨텍스트 변수의 기본값(<code>ContextVar.default</code>)을 무시합니다. 즉, 기본값으로 생성되었지만 컨텍스트에서 설정되지 않은 변수 <code>var</code>의 경우:</p>
<ul>
<li><code>context[var]</code>는 <code>KeyError</code>를 발생시킵니다.</li>
<li><code>var in context</code>는 <code>False</code>를 반환합니다.</li>
<li>변수는 <code>context.items()</code>에 포함되지 않습니다.</li>
</ul>
<h4 id="asyncio"><a href="#asyncio"><code>asyncio</code></a></h4>
<p><code>asyncio</code>는 <code>Loop.call_soon()</code>, <code>Loop.call_later()</code>, <code>Loop.call_at()</code>을 사용하여 함수의 비동기 실행을 스케줄링합니다. <code>asyncio.Task</code>는 <code>call_soon()</code>을 사용하여 래핑된 코루틴(coroutine)을 실행합니다.</p>
<p><code>Loop.call_{at,later,soon}</code> 및 <code>Future.add_done_callback()</code>은 새로운 선택적 키워드 전용 인자 <code>context</code>를 받도록 수정되며, 기본값은 현재 컨텍스트입니다.</p>
<pre><code class="language-python">def call_soon(self, callback, *args, context=None):
    if context is None:
        context = contextvars.copy_context()
    # ... 얼마 후
    context.run(callback, *args)
</code></pre>
<p><code>asyncio</code>의 태스크는 생성된 시점부터 상속받는 자신만의 컨텍스트를 유지해야 합니다. <code>asyncio.Task</code>는 다음과 같이 수정됩니다:</p>
<pre><code class="language-python">class Task:
    def __init__(self, coro):
        ...
        # 현재 컨텍스트 스냅샷을 가져옵니다.
        self._context = contextvars.copy_context()
        self._loop.call_soon(self._step, context=self._context)

    def _step(self, exc=None):
        ...
        # 래핑된 코루틴의 모든 진행은
        # 태스크의 컨텍스트 내에서 이루어집니다.
        self._loop.call_soon(self._step, context=self._context)
        ...
</code></pre>
<h3 id="새로운-api-요약-summary-of-the-new-apis"><a href="#새로운-api-요약-summary-of-the-new-apis">새로운 API 요약 (Summary of the New APIs)</a></h3>
<h4 id="python-api"><a href="#python-api">Python API</a></h4>
<ul>
<li><code>ContextVar</code>, <code>Context</code>, <code>Token</code> 클래스 및 <code>copy_context()</code> 함수를 포함하는 새로운 <code>contextvars</code> 모듈.</li>
<li><code>asyncio.Loop.call_at()</code>, <code>asyncio.Loop.call_later()</code>, <code>asyncio.Loop.call_soon()</code>, <code>asyncio.Future.add_done_callback()</code>은 호출된 컨텍스트에서 콜백 함수를 실행합니다.</li>
<li>새로운 <code>context</code> 키워드 전용 매개변수를 사용하여 사용자 정의 컨텍스트를 지정할 수 있습니다.</li>
<li><code>asyncio.Task</code>는 내부적으로 자신만의 컨텍스트를 유지하도록 수정됩니다.</li>
</ul>
<h4 id="c-api"><a href="#c-api">C API</a></h4>
<ul>
<li><code>PyObject * PyContextVar_New(char *name, PyObject *default)</code>: <code>ContextVar</code> 객체를 생성합니다. <code>default</code> 인수는 <code>NULL</code>일 수 있으며, 이는 변수에 기본값이 없음을 의미합니다.</li>
<li><code>int PyContextVar_Get(PyObject *, PyObject *default_value, PyObject **value)</code>: 조회 중 오류가 발생하면 -1을 반환하고, 그렇지 않으면 0을 반환합니다. 컨텍스트 변수의 값이 발견되면 <code>value</code> 포인터에 설정됩니다. 그렇지 않으면 <code>default_value</code>가 <code>NULL</code>이 아닐 때 <code>value</code>는 <code>default_value</code>로 설정됩니다. <code>default_value</code>가 <code>NULL</code>이면 <code>value</code>는 변수의 기본값으로 설정되며, 이 또한 <code>NULL</code>일 수 있습니다. <code>value</code>는 항상 새로운 참조입니다.</li>
<li><code>PyObject * PyContextVar_Set(PyObject *, PyObject *)</code>: 현재 컨텍스트에서 변수의 값을 설정합니다.</li>
<li><code>PyContextVar_Reset(PyObject *, PyObject *)</code>: 컨텍스트 변수의 값을 재설정합니다.</li>
<li><code>PyObject * PyContext_New()</code>: 새로운 빈 컨텍스트를 생성합니다.</li>
<li><code>PyObject * PyContext_Copy(PyObject *)</code>: 전달된 컨텍스트 객체의 얕은 복사본을 반환합니다.</li>
<li><code>PyObject * PyContext_CopyCurrent()</code>: 현재 컨텍스트의 복사본을 가져옵니다.</li>
<li><code>int PyContext_Enter(PyObject *)</code> 및 <code>int PyContext_Exit(PyObject *)</code>: 현재 OS 스레드의 컨텍스트를 설정하고 복원할 수 있습니다. 이전 컨텍스트를 항상 복원해야 합니다.</li>
</ul>
<pre><code class="language-c">PyObject *old_ctx = PyContext_Copy();
if (old_ctx == NULL) goto error;
if (PyContext_Enter(new_ctx)) goto error;
// 일부 코드 실행
if (PyContext_Exit(old_ctx)) goto error;
</code></pre>
<h3 id="거부된-아이디어-rejected-ideas"><a href="#거부된-아이디어-rejected-ideas">거부된 아이디어 (Rejected Ideas)</a></h3>
<p>몇 가지 아이디어가 제안되었지만 여러 이유로 거부되거나 연기되었습니다.</p>
<ul>
<li><strong><code>threading.local()</code> 인터페이스 복제</strong> : PEP 550에서 자세히 다뤄졌습니다.</li>
<li><strong><code>Token</code>을 <code>ContextVar.unset()</code>으로 대체</strong> : <code>Token</code> API는 <code>ContextVar.unset()</code> 메서드를 피하게 해주며, 이는 PEP 550의 체인형 컨텍스트(chained contexts) 설계와 호환되지 않습니다. 또한 <code>Token</code> API는 값의 부재를 특별하게 처리할 필요가 없어 더 나은 사용성을 제공합니다.</li>
<li><strong><code>ContextVar.reset()</code> 대신 <code>Token.reset()</code> 사용</strong> : <code>Token</code> 클래스에 직접 <code>reset()</code> 메서드를 구현하는 아이디어였으나, 코드를 읽는 사람에게 어떤 변수가 재설정되는지 <code>ContextVar.reset()</code>이 더 명확하기 때문에 거부되었습니다.</li>
<li><strong><code>Context</code> 객체를 피클 가능(picklable)하게 만들기</strong> : <code>ProcessPoolExecutor</code>와 같은 경우에 <code>Context</code> 객체의 투명한 교차 프로세스 사용을 가능하게 할 수 있었으나, <code>ContextVar</code> 객체가 <code>__module__</code> 및 <code>__qualname__</code> 속성을 가지지 않아 간단한 피클링이 불가능하고, 모든 컨텍스트 변수가 피클 가능한 객체를 참조하는 것은 아니라는 점 등의 문제로 Python 3.8로 연기되었습니다.</li>
<li><strong><code>Context</code>를 <code>MutableMapping</code>으로 만들기</strong> : <code>Context</code> 클래스가 <code>abc.MutableMapping</code> 인터페이스를 구현하게 되면 <code>Context[var] = value</code> 및 <code>del Context[var]</code>와 같은 작업으로 변수를 설정 및 해제할 수 있습니다. 그러나 이는 컨텍스트 변수 변경 방식에 혼란을 초래할 수 있고, 컨텍스트가 개념적으로 복잡해질 수 있어 Python 3.8 이상으로 연기되었습니다.</li>
<li><strong><code>ContextVar</code>에 초기 값(initial values) 갖기</strong> : <code>ContextVar</code> 생성자에 <code>initial_value</code> 키워드 전용 인수를 필수로 두자는 제안이었으나, 일부 타입의 경우 <code>None</code> 외에 합리적인 "초기 값"이 없다는 점과, <code>threading.local()</code>과 같은 기존 방식과의 일관성을 위해 거부되었습니다.</li>
</ul>
<h3 id="하위-호환성-backwards-compatibility"><a href="#하위-호환성-backwards-compatibility">하위 호환성 (Backwards Compatibility)</a></h3>
<p>이 제안은 100% 하위 호환성을 유지합니다. <code>threading.local()</code>을 사용하여 컨텍스트 관련 값을 저장하는 라이브러리는 현재 동기 코드에서만 올바르게 작동합니다. 제안된 API를 사용하도록 전환하면 동기 코드의 동작은 변경되지 않지만, 비동기 코드에 대한 지원이 자동으로 활성화됩니다.</p>
<h3 id="예시-examples"><a href="#예시-examples">예시 (Examples)</a></h3>
<h4 id="threadinglocal을-사용하는-코드-변환"><a href="#threadinglocal을-사용하는-코드-변환"><code>threading.local()</code>을 사용하는 코드 변환</a></h4>
<p><code>threading.local()</code>을 사용하는 일반적인 코드 조각은 다음과 같습니다:</p>
<pre><code class="language-python">import threading

class PrecisionStorage(threading.local):
    # 기본값을 지정하기 위해 threading.local을 서브클래싱합니다.
    value = 0.0

precision = PrecisionStorage()

# 새 정밀도(precision)를 설정하려면:
precision.value = 0.5

# 현재 정밀도를 읽으려면:
print(precision.value)
</code></pre>
<p>이 코드는 <code>contextvars</code> 모듈을 사용하도록 변환할 수 있습니다:</p>
<pre><code class="language-python">import contextvars

precision = contextvars.ContextVar('precision', default=0.0)

# 새 정밀도(precision)를 설정하려면:
precision.set(0.5)

# 현재 정밀도를 읽으려면:
print(precision.get())
</code></pre>
<h4 id="다른-스레드로-실행-오프로드-offloading-execution-to-other-threads"><a href="#다른-스레드로-실행-오프로드-offloading-execution-to-other-threads">다른 스레드로 실행 오프로드 (Offloading execution to other threads)</a></h4>
<p>현재 스레드 컨텍스트의 복사본을 사용하여 별도의 OS 스레드에서 코드를 실행할 수 있습니다:</p>
<pre><code class="language-python">from concurrent.futures import ThreadPoolExecutor
import contextvars

executor = ThreadPoolExecutor()
current_context = contextvars.copy_context()
executor.submit(current_context.run, some_function)
</code></pre>
<h3 id="수락-acceptance"><a href="#수락-acceptance">수락 (Acceptance)</a></h3>
<p>PEP 567은 2018년 1월 22일 월요일 Guido van Rossum에 의해 수락되었습니다. 참조 구현은 같은 날 병합되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BlogPosting\",\"headline\":\"[Final] PEP 567 - Context Variables\",\"description\":\"Python Enhancement Proposal 567: 'Context Variables'에 대한 한국어 번역입니다.\",\"url\":\"https://blog.secrett2633.cloud/python/pep/567\",\"datePublished\":\"2025-09-26T14:50:36.000Z\",\"dateModified\":\"2025-09-26T14:50:36.000Z\",\"author\":{\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\"},\"publisher\":{\"@type\":\"Person\",\"name\":\"secrett2633\",\"url\":\"https://blog.secrett2633.cloud\"},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://blog.secrett2633.cloud/python/pep/567\"},\"image\":\"https://blog.secrett2633.cloud/og-default.png\",\"isAccessibleForFree\":true,\"inLanguage\":\"ko\",\"wordCount\":1568,\"articleSection\":\"Python\",\"keywords\":\"Python, PEP, Translation\"}"}}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BreadcrumbList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"홈\",\"item\":\"https://blog.secrett2633.cloud/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"[Final] PEP 567 - Context Variables\",\"item\":\"https://blog.secrett2633.cloud/python/pep/567\"}]}"}}],["$","div",null,{"className":"space-y-6","children":["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","aria-label":"카테고리 네비게이션","children":[["$","div","Backend",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","$L7",null,{"href":"/backend/django","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","$L7",null,{"href":"/backend/logging","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","$L7",null,{"href":"/python/pep","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","$L7",null,{"href":"/ai/llm","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","$L7",null,{"href":"/ai/review","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",2741,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","$L7",null,{"href":"/devops/nginx","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","$L7",null,{"href":"/devops/docker","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","$L7",null,{"href":"/devops/safeline","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","$L7",null,{"href":"/devops/jenkins","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","$L7",null,{"href":"/devops/github-actions","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","$L7",null,{"href":"/devops/aws","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","p",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","$L7",null,{"href":"/etc/me","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","$L7",null,{"href":"/etc/chrome-extension","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","div",null,{"className":"flex-1","children":[["$","nav",null,{"aria-label":"breadcrumb","className":"text-sm text-gray-500 mb-4","children":["$","ol",null,{"className":"flex flex-wrap items-center gap-1","children":[["$","li",null,{"children":["$","$L7",null,{"href":"/","className":"hover:text-gray-700","children":"홈"}]}],[["$","li","/python/pep/567",{"className":"flex items-center gap-1","children":[["$","span",null,{"aria-hidden":"true","children":"/"}],["$","span",null,{"className":"text-gray-900","aria-current":"page","children":"[Final] PEP 567 - Context Variables"}]]}]]]}]}],["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Final] PEP 567 - Context Variables"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 23:50:36+0900","children":"2025년 9월 26일"}],["$","time",null,{"className":"ml-4","dateTime":"2025-09-26T14:50:36.000Z","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$a"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","span",null,{"className":"text-sm font-medium text-gray-900 mb-2 block","children":"태그"}],[["$","$L7","Python",{"href":"/tags/Python","className":"page__taxonomy-item","children":["#","Python"]}],["$","$L7","PEP",{"href":"/tags/PEP","className":"page__taxonomy-item","children":["#","PEP"]}],["$","$L7","Translation",{"href":"/tags/Translation","className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}],["$","$Lb",null,{"postPermalink":"/python/pep/567","postId":"2025-09-26-pep-0567-context-variables"}],["$","section",null,{"className":"mt-12 border-t border-gray-200 pt-8","children":[["$","h3",null,{"className":"text-base font-semibold text-gray-900 mb-4","children":["Python"," 의 다른글"]}],["$","ul",null,{"className":"space-y-2 text-sm","children":[["$","li",null,{"className":"text-gray-500","children":["이전글"," ",["$","$L7",null,{"href":"/python/pep/566","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Final] PEP 566 - Metadata for Python Software Packages 2.1"}]]}],["$","li",null,{"className":"text-gray-900 font-semibold","children":["현재글 : ","[Final] PEP 567 - Context Variables"]}],["$","li",null,{"className":"text-gray-500","children":["다음글"," ",["$","$L7",null,{"href":"/python/pep/568","className":"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4","children":"[Deferred] PEP 568 - Generator-sensitivity for Context Variables"}]]}]]}]]}]]}]]}]]}]}]]
9:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"[Final] PEP 567 - Context Variables - secrett2633's blog"}],["$","meta","3",{"name":"description","content":"Python Enhancement Proposal 567: 'Context Variables'에 대한 한국어 번역입니다."}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","link","5",{"rel":"manifest","href":"/manifest.json","crossOrigin":"use-credentials"}],["$","meta","6",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","7",{"name":"creator","content":"secrett2633"}],["$","meta","8",{"name":"publisher","content":"secrett2633"}],["$","meta","9",{"name":"robots","content":"index, follow"}],["$","meta","10",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","11",{"rel":"canonical","href":"https://blog.secrett2633.cloud/python/pep/567"}],["$","meta","12",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","13",{"property":"og:title","content":"[Final] PEP 567 - Context Variables"}],["$","meta","14",{"property":"og:description","content":"Python Enhancement Proposal 567: 'Context Variables'에 대한 한국어 번역입니다."}],["$","meta","15",{"property":"og:url","content":"https://blog.secrett2633.cloud/python/pep/567"}],["$","meta","16",{"property":"og:type","content":"article"}],["$","meta","17",{"property":"article:published_time","content":"2025-09-26T14:50:36.000Z"}],["$","meta","18",{"property":"article:modified_time","content":"2025-09-26T14:50:36.000Z"}],["$","meta","19",{"property":"article:author","content":"secrett2633"}],["$","meta","20",{"property":"article:section","content":"Python"}],["$","meta","21",{"property":"article:tag","content":"Python"}],["$","meta","22",{"property":"article:tag","content":"PEP"}],["$","meta","23",{"property":"article:tag","content":"Translation"}],["$","meta","24",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","25",{"name":"twitter:creator","content":"@secrett2633"}],["$","meta","26",{"name":"twitter:title","content":"[Final] PEP 567 - Context Variables"}],["$","meta","27",{"name":"twitter:description","content":"Python Enhancement Proposal 567: 'Context Variables'에 대한 한국어 번역입니다."}],["$","link","28",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","29",{"name":"next-size-adjust"}]]
1:null
