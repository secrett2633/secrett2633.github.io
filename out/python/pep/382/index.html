<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/773b243a13a00265.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-90b03762f46d1ba4.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/app/layout-fa159ef0265a0843.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->2215<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 382 - Namespace Packages</h1><div class="page__meta"><time dateTime="2025-09-26 21:03:27+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0382/">PEP 382 - Namespace Packages</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 02-Apr-2009</p>
</blockquote>
<h2>PEP 382 – 네임스페이스 패키지 (Namespace Packages)</h2>
<ul>
<li><strong>작성자:</strong> Martin von Löwis</li>
<li><strong>상태:</strong> Rejected (거부됨)</li>
<li><strong>유형:</strong> Standards Track (표준 트랙)</li>
<li><strong>생성일:</strong> 2009년 4월 2일</li>
<li><strong>Python 버전:</strong> 3.2</li>
<li><strong>사후 이력:</strong> 논의 후 PEP 402의 정신을 이어받는 새로운 PEP가 작성될 예정입니다.</li>
</ul>
<hr>
<h3>거부 알림 (Rejection Notice)</h3>
<p>2012년 US PyCon 스프린트 첫째 날, PEP 382와 PEP 402에 대한 길고 유익한 논의가 진행되었습니다. 그 결과, 두 PEP 모두 거부되었으나, PEP 402의 정신을 이어받아 새로운 PEP가 작성될 예정입니다. Martin von Löwis가 요약을 작성했습니다.</p>
<h3>개요 (Abstract)</h3>
<p>네임스페이스 패키지 (Namespace packages)는 단일 Python 패키지를 디스크상의 여러 디렉터리에 분할하는 메커니즘입니다. 현재 Python 버전에서는 패키지의 <code>__path__</code>를 계산하는 알고리즘을 직접 구성해야 합니다. 본 제안에서 제안하는 개선 사항을 통해, 임포트 메커니즘 (import machinery) 자체가 패키지를 구성하는 디렉터리 목록을 구축하게 됩니다. 이 PEP의 구현은에서 확인할 수 있습니다.</p>
<h3>용어 (Terminology)</h3>
<p>이 PEP 내에서 다음 용어들은 다음과 같이 정의됩니다:</p>
<ul>
<li><strong><code>package</code> (패키지):</strong> Python의 <code>import</code> 문에 의해 정의되는 Python 패키지를 의미합니다.</li>
<li><strong><code>distribution</code> (배포):</strong> Python Package Index에 저장되고 <code>distutils</code> 또는 <code>setuptools</code>에 의해 설치되는, 개별적으로 설치 가능한 Python 모듈 집합을 의미합니다.</li>
<li><strong><code>vendor package</code> (벤더 패키지):</strong> 운영 체제의 패키징 메커니즘 (예: Debian 또는 Redhat 패키지)에 의해 설치되는 파일 그룹을 의미합니다.</li>
<li><strong><code>portion</code> (부분):</strong> 네임스페이스 패키지에 기여하는 단일 디렉터리 (또는 zip 파일에 저장될 수 있는) 내의 파일 집합을 의미합니다.</li>
</ul>
<h3>현재의 네임스페이스 패키지 (Namespace packages today)</h3>
<p>Python은 현재 <code>pkgutil.extend_path</code>를 통해 패키지를 네임스페이스 패키지로 지정할 수 있는 기능을 제공합니다. 권장되는 사용법은 패키지의 <code>__init__.py</code> 파일에 다음 코드를 추가하는 것입니다:</p>
<pre><code class="language-python">from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)
</code></pre>
<p>모든 배포판은 <code>__init__.py</code>에 동일한 내용을 제공해야 하므로, 패키지의 어떤 부분이 먼저 임포트되든지 상관없이 <code>extend_path</code>가 호출됩니다. 결과적으로, <code>__init__.py</code>는 <code>sys.path</code>에서 패키지 조각의 순서에 따라 어떤 부분이 먼저 임포트되는지에 따라 달라지므로, 실제로 어떤 이름도 정의할 수 없습니다. 특별 기능으로 <code>extend_path</code>는 <code>&#x3C;packagename>.pkg</code>라는 파일을 읽어 추가적인 부분을 선언할 수 있습니다.</p>
<p><code>setuptools</code>는 유사한 함수인 <code>pkg_resources.declare_namespace</code>를 다음과 같은 형태로 제공합니다:</p>
<pre><code class="language-python">import pkg_resources
pkg_resources.declare_namespace(__name__)
</code></pre>
<p>이 방식에서는 <code>__init__.py</code>에서 <code>__path__</code>에 대한 할당이 필요하지 않습니다. <code>declare_namespace</code>가 <code>sys.modules</code>를 통해 패키지 <code>__path__</code>를 수정하기 때문입니다. 특별 기능으로 <code>declare_namespace</code>는 zip 파일도 지원하며, 내부적으로 패키지 이름을 등록하여 <code>setuptools</code>에 의한 <code>sys.path</code>에 대한 향후 추가 사항들이 각 패키지에 올바르게 추가적인 부분을 더할 수 있도록 합니다.</p>
<p><code>setuptools</code>는 배포판의 <code>setup.py</code>에서 네임스페이스 패키지를 선언할 수 있도록 하여, 배포판 개발자들이 직접 <code>__init__.py</code>에 마법적인 <code>__path__</code> 수정 코드를 넣을 필요가 없게 합니다.</p>
<h3>근거 (Rationale)</h3>
<p>네임스페이스 패키지에 대한 현재의 명령형 (imperative) 접근 방식은 여러 약간씩 호환되지 않는 메커니즘을 초래했습니다. 예를 들어, <code>pkgutil</code>은 <code>*.pkg</code> 파일을 지원하지만 <code>setuptools</code>는 그렇지 않습니다. 마찬가지로, <code>setuptools</code>는 zip 파일을 검사하고 <code>_namespace_packages</code> 변수에 부분을 추가하는 것을 지원하지만 <code>pkgutil</code>은 그렇지 않습니다.</p>
<p>또한, 현재의 접근 방식은 시스템 벤더들에게 문제를 야기합니다. 벤더 패키지는 일반적으로 파일이 겹치지 않아야 하며, 이미 디스크에 있는 파일을 가진 벤더 패키지를 설치하려고 하면 실패하거나 예측할 수 없는 동작을 유발할 수 있습니다. 벤더가 네임스페이스 패키지를 위해 모든 배포판을 단일 디렉터리에 넣도록 선택할 수 있으므로, 모든 부분은 충돌하는 <code>__init__.py</code> 파일을 기여하게 될 것입니다.</p>
<h3>명세 (Specification)</h3>
<p>패키지를 임포트하는 명령형 메커니즘 대신, 선언형 접근 방식이 제안됩니다:</p>
<p>이 제안에서는 이름이 <code>.pyp</code> (Python package의 약자)로 끝나는 디렉터리가 패키지의 한 부분을 포함한다고 명시합니다.</p>
<p><code>import</code> 문은 패키지 <code>P</code>의 <code>__path__</code> 속성을 계산하도록 확장됩니다. 이는 선택적으로 <code>__init__.py</code> 파일을 포함하는 단일 디렉터리 <code>P</code>와, 부모 패키지의 <code>__path__</code> (또는 <code>sys.path</code>)에서 발견되는 순서대로 모든 <code>P.pyp</code>라는 이름의 디렉터리로 구성됩니다. 이 중 어느 하나라도 발견되면, 패키지의 추가 부분을 계속 검색합니다.</p>
<p>하나의 디렉터리가 <code>P/__init__.py</code> 형식의 패키지와 <code>P.pyp</code> 형식의 패키지 부분을 모두 포함할 수 있습니다.</p>
<p>임포트 메커니즘에는 다른 변경 사항이 없습니다. 모듈 ( <code>__init__.py</code> 포함) 검색은 계속해서 처음 발견된 모듈에서 중단됩니다. 요약하자면, <code>import foo</code> 패키지 프로세스는 다음과 같이 작동합니다:</p>
<ol>
<li><code>sys.path</code>에서 <code>foo</code> 디렉터리, <code>foo.pyp</code> 디렉터리 또는 <code>foo.&#x3C;ext></code> 파일을 검색합니다.</li>
<li>파일이 발견되고 디렉터리가 없으면 모듈로 처리되어 임포트됩니다.</li>
<li><code>foo</code> 디렉터리가 발견되면 <code>__init__.py</code> 파일이 포함되어 있는지 확인합니다. 있으면 <code>__init__.py</code>의 위치를 기억합니다. 그렇지 않으면 디렉터리는 건너뜁니다.</li>
<li><code>__init__.py</code>가 발견되면 <code>foo</code>라는 다른 디렉터리는 건너뜁니다.</li>
<li><code>foo</code> 디렉터리와 <code>foo.pyp</code> 디렉터리 모두 패키지의 <code>__path__</code>에 추가됩니다.</li>
<li><code>__init__</code> 모듈이 발견되면, 계산된 모든 <code>.pyp</code> 디렉터리의 경로로 <code>__path__</code>가 초기화된 상태로 임포트됩니다.</li>
</ol>
<h4>임포트 훅에 미치는 영향 (Impact on Import Hooks)</h4>
<p>PEP 302에 정의된 로더 (loaders)와 파인더 (finds) 모두 네임스페이스 패키지를 지원하도록 변경해야 합니다. 아래 프로토콜을 따르지 않으면 패키지가 네임스페이스 패키지로 인식되지 않을 수 있습니다. 이 프로토콜을 지원하지 않는 로더와 파인더는 아래 함수에 접근할 때 <code>AttributeError</code>를 발생시켜야 합니다.</p>
<p>파인더는 위 알고리즘의 1단계에서 <code>*.pth</code> 파일을 찾는 것을 지원해야 합니다. 이를 위해 경로 훅으로 사용되는 파인더는 다음 메서드를 지원해야 합니다:</p>
<pre><code class="language-python">finder.find_package_portion(fullname)
</code></pre>
<p>이 메서드는 <code>find_module</code>과 동일한 방식으로 호출되며, 패키지의 <code>__path__</code>에 추가될 문자열을 반환해야 합니다. 파인더가 패키지의 부분을 찾지 못하면 <code>None</code>을 반환해야 합니다. 위 호출에서 <code>AttributeError</code>를 발생시키는 것은 이 PEP와의 비준수로 처리되며, 예외는 무시됩니다. 다른 모든 예외는 보고됩니다.</p>
<p>파인더는 <code>find_module</code>과 <code>find_package_portion</code> 모두에서 성공을 보고할 수 있으며, 이는 <code>__init__.py</code>를 포함하는 패키지와 동일한 패키지의 부분을 모두 허용합니다.</p>
<p><code>find_package_portion</code>에서 반환된 모든 문자열과 <code>.pyp</code> 디렉터리의 모든 경로 이름은 새 패키지의 <code>__path__</code>에 추가됩니다.</p>
<h3>논의 (Discussion)</h3>
<p>이 명세의 초기 버전은 <code>sys.path</code>에서 사용되는 방식과 유사하게 <code>*.pth</code> 파일 추가를 제안했습니다. 와일드카드 마커 (<code>*</code>)를 사용하여 패키지는 전체 경로가 부모 경로를 보고 제대로 이름 붙여진 하위 디렉터리를 검색함으로써 파생된다는 것을 나타낼 수 있었습니다.</p>
<p>이후 사람들은 전체 <code>.pth</code> 구문 지원이 부적절하다고 지적했으며, <code>.pth</code> 파일은 디렉터리가 패키지임을 나타내는 단순한 마커 파일로 변경되었습니다. Peter Tröger는 <code>.pth</code>가 부적합한 파일 확장자이며, Python과 관련된 모든 파일 확장자는 <code>.py</code>로 시작해야 한다고 제안했습니다. 따라서 마커 파일은 <code>.pyp</code>로 이름이 변경되었습니다.</p>
<p>Dinu Gherman은 마커 파일이 필요하지 않으며, 디렉터리 확장자가 마커 역할을 할 수 있다고 지적했습니다. 이것이 이 PEP가 현재 제안하는 내용입니다.</p>
<p>Phillip Eby는 다른 언어에서 발견되는 Python의 패키지 구문과 비교한 후 이 PEP에 대한 대안적인 접근 방식인 PEP 402를 설계했습니다. PEP 402는 마커 파일을 전혀 사용하지 않을 것을 제안합니다. PyCon DE 2011 토론에서 사람들은 디렉터리가 패키지에 기여한다는 명시적인 선언을 하는 것이 장애물이 아니라 바람직한 속성이라고 언급했습니다. 특히 Jython 개발자들은 Python 패키지를 선언할 필요가 없다면 Jython이 Java 패키지인 디렉터리를 Python 패키지로 쉽게 오인할 수 있다는 점을 지적했습니다.</p>
<p>패키지는 네임스페이스 패키지의 <code>__init__.py</code>를 채우는 작업을 중단할 수 있습니다. 결과적으로 <code>extend_path</code>와 <code>declare_namespace</code>는 구식 (obsolete)이 됩니다.</p>
<p>네임스페이스 패키지는 비trivial한 (non-trivial) <code>__init__.py</code> 구현을 제공하기 시작할 수 있습니다. 이를 위해 단일 배포판이 네임스페이스 패키지의 <code>__init__.py</code> (및 네임스페이스 패키지 자체에 속하는 다른 모듈)만 포함하는 부분을 제공하는 것이 권장됩니다.</p>
<p>이 메커니즘은 기존 네임스페이스 메커니즘과 대부분 호환됩니다. <code>extend_path</code>는 이 명세에 따라 조정될 것이며, 다른 메커니즘은 <code>__path__</code>에 부분이 두 번 추가될 수 있습니다.</p>
<h3>참고 자료 (References)</h3>
<ul>
<li>PEP 382 branch</li>
<li>Namespace Packages resolution</li>
</ul>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="comments-section mt-12 pt-8 border-t border-gray-200"></section><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/381/">[Withdrawn] PEP 381 - Mirroring infrastructure for PyPI</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Rejected] PEP 382 - Namespace Packages</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/383/">[Final] PEP 383 - Non-decodable Bytes in System Character Interfaces</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-90b03762f46d1ba4.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/773b243a13a00265.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"185\",\"static/chunks/app/layout-fa159ef0265a0843.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/382\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/773b243a13a00265.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"q5uHuVDyt3FPCtp0uxl7W\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/382/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/382\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"382\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/382\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"f:I[646,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-d9dbb0d3ac265797.js\"],\"default\"]\ne:T326f,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0382/\"\u003ePEP 382 - Namespace Packages\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 02-Apr-2009\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 382 – 네임스페이스 패키지 (Namespace Packages)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Martin von Löwis\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected (거부됨)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e Standards Track (표준 트랙)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2009년 4월 2일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 3.2\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e사후 이력:\u003c/strong\u003e 논의 후 PEP 402의 정신을 이어받는 새로운 PEP가 작성될 예정입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e거부 알림 (Rejection Notice)\u003c/h3\u003e\n\u003cp\u003e2012년 US PyCon 스프린트 첫째 날, PEP 382와 PEP 402에 대한 길고 유익한 논의가 진행되었습니다. 그 결과, 두 PEP 모두 거부되었으나, PEP 402의 정신을 이어받아 새로운 PEP가 작성될 예정입니다. Martin von Löwis가 요약을 작성했습니다.\u003c/p\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003e네임스페이스 패키지 (Namespace packages)는 단일 Python 패키지를 디스크상의 여러 디렉터리에 분할하는 메커니즘입니다. 현재 Python 버전에서는 패키지의 \u003ccode\u003e__path__\u003c/code\u003e를 계산하는 알고리즘을 직접 구성해야 합니다. 본 제안에서 제안하는 개선 사항을 통해, 임포트 메커니즘 (import machinery) 자체가 패키지를 구성하는 디렉터리 목록을 구축하게 됩니다. 이 PEP의 구현은에서 확인할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e용어 (Terminology)\u003c/h3\u003e\n\u003cp\u003e이 PEP 내에서 다음 용어들은 다음과 같이 정의됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003epackage\u003c/code\u003e (패키지):\u003c/strong\u003e Python의 \u003ccode\u003eimport\u003c/code\u003e 문에 의해 정의되는 Python 패키지를 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003edistribution\u003c/code\u003e (배포):\u003c/strong\u003e Python Package Index에 저장되고 \u003ccode\u003edistutils\u003c/code\u003e 또는 \u003ccode\u003esetuptools\u003c/code\u003e에 의해 설치되는, 개별적으로 설치 가능한 Python 모듈 집합을 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003evendor package\u003c/code\u003e (벤더 패키지):\u003c/strong\u003e 운영 체제의 패키징 메커니즘 (예: Debian 또는 Redhat 패키지)에 의해 설치되는 파일 그룹을 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eportion\u003c/code\u003e (부분):\u003c/strong\u003e 네임스페이스 패키지에 기여하는 단일 디렉터리 (또는 zip 파일에 저장될 수 있는) 내의 파일 집합을 의미합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e현재의 네임스페이스 패키지 (Namespace packages today)\u003c/h3\u003e\n\u003cp\u003ePython은 현재 \u003ccode\u003epkgutil.extend_path\u003c/code\u003e를 통해 패키지를 네임스페이스 패키지로 지정할 수 있는 기능을 제공합니다. 권장되는 사용법은 패키지의 \u003ccode\u003e__init__.py\u003c/code\u003e 파일에 다음 코드를 추가하는 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom pkgutil import extend_path\n__path__ = extend_path(__path__, __name__)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 배포판은 \u003ccode\u003e__init__.py\u003c/code\u003e에 동일한 내용을 제공해야 하므로, 패키지의 어떤 부분이 먼저 임포트되든지 상관없이 \u003ccode\u003eextend_path\u003c/code\u003e가 호출됩니다. 결과적으로, \u003ccode\u003e__init__.py\u003c/code\u003e는 \u003ccode\u003esys.path\u003c/code\u003e에서 패키지 조각의 순서에 따라 어떤 부분이 먼저 임포트되는지에 따라 달라지므로, 실제로 어떤 이름도 정의할 수 없습니다. 특별 기능으로 \u003ccode\u003eextend_path\u003c/code\u003e는 \u003ccode\u003e\u0026#x3C;packagename\u003e.pkg\u003c/code\u003e라는 파일을 읽어 추가적인 부분을 선언할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esetuptools\u003c/code\u003e는 유사한 함수인 \u003ccode\u003epkg_resources.declare_namespace\u003c/code\u003e를 다음과 같은 형태로 제공합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport pkg_resources\npkg_resources.declare_namespace(__name__)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 방식에서는 \u003ccode\u003e__init__.py\u003c/code\u003e에서 \u003ccode\u003e__path__\u003c/code\u003e에 대한 할당이 필요하지 않습니다. \u003ccode\u003edeclare_namespace\u003c/code\u003e가 \u003ccode\u003esys.modules\u003c/code\u003e를 통해 패키지 \u003ccode\u003e__path__\u003c/code\u003e를 수정하기 때문입니다. 특별 기능으로 \u003ccode\u003edeclare_namespace\u003c/code\u003e는 zip 파일도 지원하며, 내부적으로 패키지 이름을 등록하여 \u003ccode\u003esetuptools\u003c/code\u003e에 의한 \u003ccode\u003esys.path\u003c/code\u003e에 대한 향후 추가 사항들이 각 패키지에 올바르게 추가적인 부분을 더할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esetuptools\u003c/code\u003e는 배포판의 \u003ccode\u003esetup.py\u003c/code\u003e에서 네임스페이스 패키지를 선언할 수 있도록 하여, 배포판 개발자들이 직접 \u003ccode\u003e__init__.py\u003c/code\u003e에 마법적인 \u003ccode\u003e__path__\u003c/code\u003e 수정 코드를 넣을 필요가 없게 합니다.\u003c/p\u003e\n\u003ch3\u003e근거 (Rationale)\u003c/h3\u003e\n\u003cp\u003e네임스페이스 패키지에 대한 현재의 명령형 (imperative) 접근 방식은 여러 약간씩 호환되지 않는 메커니즘을 초래했습니다. 예를 들어, \u003ccode\u003epkgutil\u003c/code\u003e은 \u003ccode\u003e*.pkg\u003c/code\u003e 파일을 지원하지만 \u003ccode\u003esetuptools\u003c/code\u003e는 그렇지 않습니다. 마찬가지로, \u003ccode\u003esetuptools\u003c/code\u003e는 zip 파일을 검사하고 \u003ccode\u003e_namespace_packages\u003c/code\u003e 변수에 부분을 추가하는 것을 지원하지만 \u003ccode\u003epkgutil\u003c/code\u003e은 그렇지 않습니다.\u003c/p\u003e\n\u003cp\u003e또한, 현재의 접근 방식은 시스템 벤더들에게 문제를 야기합니다. 벤더 패키지는 일반적으로 파일이 겹치지 않아야 하며, 이미 디스크에 있는 파일을 가진 벤더 패키지를 설치하려고 하면 실패하거나 예측할 수 없는 동작을 유발할 수 있습니다. 벤더가 네임스페이스 패키지를 위해 모든 배포판을 단일 디렉터리에 넣도록 선택할 수 있으므로, 모든 부분은 충돌하는 \u003ccode\u003e__init__.py\u003c/code\u003e 파일을 기여하게 될 것입니다.\u003c/p\u003e\n\u003ch3\u003e명세 (Specification)\u003c/h3\u003e\n\u003cp\u003e패키지를 임포트하는 명령형 메커니즘 대신, 선언형 접근 방식이 제안됩니다:\u003c/p\u003e\n\u003cp\u003e이 제안에서는 이름이 \u003ccode\u003e.pyp\u003c/code\u003e (Python package의 약자)로 끝나는 디렉터리가 패키지의 한 부분을 포함한다고 명시합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eimport\u003c/code\u003e 문은 패키지 \u003ccode\u003eP\u003c/code\u003e의 \u003ccode\u003e__path__\u003c/code\u003e 속성을 계산하도록 확장됩니다. 이는 선택적으로 \u003ccode\u003e__init__.py\u003c/code\u003e 파일을 포함하는 단일 디렉터리 \u003ccode\u003eP\u003c/code\u003e와, 부모 패키지의 \u003ccode\u003e__path__\u003c/code\u003e (또는 \u003ccode\u003esys.path\u003c/code\u003e)에서 발견되는 순서대로 모든 \u003ccode\u003eP.pyp\u003c/code\u003e라는 이름의 디렉터리로 구성됩니다. 이 중 어느 하나라도 발견되면, 패키지의 추가 부분을 계속 검색합니다.\u003c/p\u003e\n\u003cp\u003e하나의 디렉터리가 \u003ccode\u003eP/__init__.py\u003c/code\u003e 형식의 패키지와 \u003ccode\u003eP.pyp\u003c/code\u003e 형식의 패키지 부분을 모두 포함할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e임포트 메커니즘에는 다른 변경 사항이 없습니다. 모듈 ( \u003ccode\u003e__init__.py\u003c/code\u003e 포함) 검색은 계속해서 처음 발견된 모듈에서 중단됩니다. 요약하자면, \u003ccode\u003eimport foo\u003c/code\u003e 패키지 프로세스는 다음과 같이 작동합니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003esys.path\u003c/code\u003e에서 \u003ccode\u003efoo\u003c/code\u003e 디렉터리, \u003ccode\u003efoo.pyp\u003c/code\u003e 디렉터리 또는 \u003ccode\u003efoo.\u0026#x3C;ext\u003e\u003c/code\u003e 파일을 검색합니다.\u003c/li\u003e\n\u003cli\u003e파일이 발견되고 디렉터리가 없으면 모듈로 처리되어 임포트됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efoo\u003c/code\u003e 디렉터리가 발견되면 \u003ccode\u003e__init__.py\u003c/code\u003e 파일이 포함되어 있는지 확인합니다. 있으면 \u003ccode\u003e__init__.py\u003c/code\u003e의 위치를 기억합니다. 그렇지 않으면 디렉터리는 건너뜁니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__init__.py\u003c/code\u003e가 발견되면 \u003ccode\u003efoo\u003c/code\u003e라는 다른 디렉터리는 건너뜁니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efoo\u003c/code\u003e 디렉터리와 \u003ccode\u003efoo.pyp\u003c/code\u003e 디렉터리 모두 패키지의 \u003ccode\u003e__path__\u003c/code\u003e에 추가됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__init__\u003c/code\u003e 모듈이 발견되면, 계산된 모든 \u003ccode\u003e.pyp\u003c/code\u003e 디렉터리의 경로로 \u003ccode\u003e__path__\u003c/code\u003e가 초기화된 상태로 임포트됩니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4\u003e임포트 훅에 미치는 영향 (Impact on Import Hooks)\u003c/h4\u003e\n\u003cp\u003ePEP 302에 정의된 로더 (loaders)와 파인더 (finds) 모두 네임스페이스 패키지를 지원하도록 변경해야 합니다. 아래 프로토콜을 따르지 않으면 패키지가 네임스페이스 패키지로 인식되지 않을 수 있습니다. 이 프로토콜을 지원하지 않는 로더와 파인더는 아래 함수에 접근할 때 \u003ccode\u003eAttributeError\u003c/code\u003e를 발생시켜야 합니다.\u003c/p\u003e\n\u003cp\u003e파인더는 위 알고리즘의 1단계에서 \u003ccode\u003e*.pth\u003c/code\u003e 파일을 찾는 것을 지원해야 합니다. 이를 위해 경로 훅으로 사용되는 파인더는 다음 메서드를 지원해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efinder.find_package_portion(fullname)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 메서드는 \u003ccode\u003efind_module\u003c/code\u003e과 동일한 방식으로 호출되며, 패키지의 \u003ccode\u003e__path__\u003c/code\u003e에 추가될 문자열을 반환해야 합니다. 파인더가 패키지의 부분을 찾지 못하면 \u003ccode\u003eNone\u003c/code\u003e을 반환해야 합니다. 위 호출에서 \u003ccode\u003eAttributeError\u003c/code\u003e를 발생시키는 것은 이 PEP와의 비준수로 처리되며, 예외는 무시됩니다. 다른 모든 예외는 보고됩니다.\u003c/p\u003e\n\u003cp\u003e파인더는 \u003ccode\u003efind_module\u003c/code\u003e과 \u003ccode\u003efind_package_portion\u003c/code\u003e 모두에서 성공을 보고할 수 있으며, 이는 \u003ccode\u003e__init__.py\u003c/code\u003e를 포함하는 패키지와 동일한 패키지의 부분을 모두 허용합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efind_package_portion\u003c/code\u003e에서 반환된 모든 문자열과 \u003ccode\u003e.pyp\u003c/code\u003e 디렉터리의 모든 경로 이름은 새 패키지의 \u003ccode\u003e__path__\u003c/code\u003e에 추가됩니다.\u003c/p\u003e\n\u003ch3\u003e논의 (Discussion)\u003c/h3\u003e\n\u003cp\u003e이 명세의 초기 버전은 \u003ccode\u003esys.path\u003c/code\u003e에서 사용되는 방식과 유사하게 \u003ccode\u003e*.pth\u003c/code\u003e 파일 추가를 제안했습니다. 와일드카드 마커 (\u003ccode\u003e*\u003c/code\u003e)를 사용하여 패키지는 전체 경로가 부모 경로를 보고 제대로 이름 붙여진 하위 디렉터리를 검색함으로써 파생된다는 것을 나타낼 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e이후 사람들은 전체 \u003ccode\u003e.pth\u003c/code\u003e 구문 지원이 부적절하다고 지적했으며, \u003ccode\u003e.pth\u003c/code\u003e 파일은 디렉터리가 패키지임을 나타내는 단순한 마커 파일로 변경되었습니다. Peter Tröger는 \u003ccode\u003e.pth\u003c/code\u003e가 부적합한 파일 확장자이며, Python과 관련된 모든 파일 확장자는 \u003ccode\u003e.py\u003c/code\u003e로 시작해야 한다고 제안했습니다. 따라서 마커 파일은 \u003ccode\u003e.pyp\u003c/code\u003e로 이름이 변경되었습니다.\u003c/p\u003e\n\u003cp\u003eDinu Gherman은 마커 파일이 필요하지 않으며, 디렉터리 확장자가 마커 역할을 할 수 있다고 지적했습니다. 이것이 이 PEP가 현재 제안하는 내용입니다.\u003c/p\u003e\n\u003cp\u003ePhillip Eby는 다른 언어에서 발견되는 Python의 패키지 구문과 비교한 후 이 PEP에 대한 대안적인 접근 방식인 PEP 402를 설계했습니다. PEP 402는 마커 파일을 전혀 사용하지 않을 것을 제안합니다. PyCon DE 2011 토론에서 사람들은 디렉터리가 패키지에 기여한다는 명시적인 선언을 하는 것이 장애물이 아니라 바람직한 속성이라고 언급했습니다. 특히 Jython 개발자들은 Python 패키지를 선언할 필요가 없다면 Jython이 Java 패키지인 디렉터리를 Python 패키지로 쉽게 오인할 수 있다는 점을 지적했습니다.\u003c/p\u003e\n\u003cp\u003e패키지는 네임스페이스 패키지의 \u003ccode\u003e__init__.py\u003c/code\u003e를 채우는 작업을 중단할 수 있습니다. 결과적으로 \u003ccode\u003eextend_path\u003c/code\u003e와 \u003ccode\u003edeclare_namespace\u003c/code\u003e는 구식 (obsolete)이 됩니다.\u003c/p\u003e\n\u003cp\u003e네임스페이스 패키지는 비trivial한 (non-trivial) \u003ccode\u003e__init__.py\u003c/code\u003e 구현을 제공하기 시작할 수 있습니다. 이를 위해 단일 배포판이 네임스페이스 패키지의 \u003ccode\u003e__init__.py\u003c/code\u003e (및 네임스페이스 패키지 자체에 속하는 다른 모듈)만 포함하는 부분을 제공하는 것이 권장됩니다.\u003c/p\u003e\n\u003cp\u003e이 메커니즘은 기존 네임스페이스 메커니즘과 대부분 호환됩니다. \u003ccode\u003eextend_path\u003c/code\u003e는 이 명세에 따라 조정될 것이며, 다른 메커니즘은 \u003ccode\u003e__path__\u003c/code\u003e에 부분이 두 번 추가될 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e참고 자료 (References)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePEP 382 branch\u003c/li\u003e\n\u003cli\u003eNamespace Packages resolution\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",2215,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 382 - Namespace Packages\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 21:03:27+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"$Lf\",null,{\"postPermalink\":\"/python/pep/382/\",\"postId\":\"2025-09-26-pep-0382-namespace-packages\"}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/381/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Withdrawn] PEP 381 - Mirroring infrastructure for PyPI\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Rejected] PEP 382 - Namespace Packages\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/383/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 383 - Non-decodable Bytes in System Character Interfaces\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>