<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 238 - Changing the Division Operator</h1><div class="page__meta"><time dateTime="2025-09-26 17:08:05+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0238/">PEP 238 - Changing the Division Operator</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 11-Mar-2001</p>
</blockquote>
<p>PEP 238 – 나눗셈 연산자 변경 (Changing the Division Operator)</p>
<h2>개요 (Abstract)</h2>
<p>현재 Python의 나눗셈 연산자 (<code>/</code>)는 숫자 인수에 대해 모호한 의미를 가지고 있습니다. 정수(int)나 long 정수가 인수로 주어질 경우 수학적 나눗셈 결과의 내림(floor) 값을 반환하지만, 부동 소수점(float)이나 복소수(complex)가 주어지면 나눗셈 결과의 합리적인 근사치를 반환합니다. 이로 인해 float 또는 complex 결과가 예상되는 표현식에서 예기치 않게 정수가 입력으로 들어올 경우 오류가 발생하기 쉽습니다.</p>
<p>이 PEP는 이러한 문제를 해결하기 위해 다음과 같이 다른 연산자들을 도입할 것을 제안합니다:</p>
<ul>
<li><code>x / y</code>: 나눗셈의 수학적 결과에 대한 합리적인 근사치를 반환하는 "참 나눗셈 (true division)".</li>
<li><code>x // y</code>: 내림(floor) 값을 반환하는 "바닥 나눗셈 (floor division)".</li>
</ul>
<p>기존의 <code>x / y</code>의 혼합된 의미를 "고전적 나눗셈 (classic division)"이라고 부릅니다.</p>
<p>심각한 하위 호환성 문제 때문에, Python 2.2부터 다음과 같은 전환 조치들이 제안되었습니다:</p>
<ul>
<li>Python 2.x 시리즈에서는 고전적 나눗셈이 기본으로 유지됩니다. Python 3.0에서는 참 나눗셈이 표준이 됩니다.</li>
<li><code>//</code> 연산자는 명확하게 바닥 나눗셈을 요청하는 데 사용될 수 있습니다.</li>
<li><code>from __future__ import division</code> 문은 해당 모듈 전체에서 <code>/</code> 연산자가 참 나눗셈을 의미하도록 변경합니다.</li>
<li>명령줄 옵션을 통해 <code>int</code> 또는 <code>long</code> 인수에 고전적 나눗셈이 적용될 경우 실행 시 경고를 발생시킬 수 있습니다. 다른 명령줄 옵션은 참 나눗셈을 기본으로 설정할 수 있습니다.</li>
<li>표준 라이브러리는 고전적 나눗셈을 완전히 피하기 위해 적절한 경우 future division statement와 <code>//</code> 연산자를 사용하게 됩니다.</li>
</ul>
<h2>동기 (Motivation)</h2>
<p>고전적 나눗셈 연산자는 임의의 숫자 입력을 받아 올바른 결과를 내야 하는 수치 표현식을 작성하기 어렵게 만듭니다. 다른 모든 연산자 (<code>x * y**2 + z</code> 등)의 경우, 어떤 숫자 입력 타입(int, long, float, complex)에 대해서도 계산 결과가 수학적 결과에 가깝게 나옵니다 (물론 수치 정확도의 한계 내에서). 하지만 나눗셈은 문제가 됩니다. 양쪽 인수의 표현식이 우연히 정수 타입일 경우, 참 나눗셈이 아닌 바닥 나눗셈을 수행하기 때문입니다.</p>
<p>이 문제는 동적 타입 언어에 고유합니다. C와 같은 정적 타입 언어에서는 입력 (일반적으로 함수 인수)이 <code>double</code> 또는 <code>float</code>로 선언되고, 정수 인수가 전달될 때 호출 시 <code>double</code> 또는 <code>float</code>로 변환됩니다. Python은 인수 타입 선언이 없으므로, 정수 인수가 쉽게 표현식에 포함될 수 있습니다.</p>
<p>이 문제는 <code>int</code>가 다른 모든 상황에서 <code>float</code>의 완벽한 대체재가 되기 때문에 특히 해롭습니다. 예를 들어, <code>math.sqrt(2)</code>는 <code>math.sqrt(2.0)</code>와 동일한 값을 반환하고, <code>3.14 * 100</code>과 <code>3.14 * 100.0</code>도 동일한 값을 반환합니다. 따라서 수치 루틴의 작성자는 부동 소수점 숫자로만 코드를 테스트하고 올바르게 작동한다고 믿을 수 있지만, 사용자가 실수로 정수 입력 값을 전달하여 잘못된 결과를 얻을 수 있습니다.</p>
<p>고전적 나눗셈은 <code>float</code> 또는 <code>int</code> 인수 모두에서 잘 작동하는 다형성(polymorphic) 함수를 작성하기 어렵게 만듭니다. 다른 모든 연산자들은 이미 올바르게 작동합니다. 정수와 부동 소수점 숫자 모두에 적용되는 어떤 알고리즘도 한 경우에는 절단 나눗셈(truncating division)을, 다른 경우에는 참 나눗셈을 필요로 하지 않습니다.</p>
<p>올바른 해결책은 미묘합니다. 인수를 <code>float()</code>으로 캐스팅하는 것은 복소수일 경우 잘못될 수 있습니다. 인수에 <code>0.0</code>을 더하는 것은 인수가 음수 0일 경우 부호를 유지하지 못합니다. 이 두 가지 단점 없이 사용할 수 있는 유일한 해결책은 인수에 <code>1.0</code>을 곱하는 것입니다. 이것은 <code>float</code> 및 <code>complex</code>의 값과 부호를 변경하지 않고, <code>int</code> 및 <code>long</code>을 해당 값을 가진 <code>float</code>으로 변환합니다.</p>
<p>저자들은 이것이 Python의 진정한 설계 버그이며, 가급적 빨리 수정해야 한다고 판단했습니다. Python 사용이 계속 증가할 것이라고 가정할 때, 이 버그를 언어에 남겨두는 비용은 결국 오래된 코드를 수정하는 비용을 넘어설 것입니다. 수정해야 할 코드의 양에는 상한선이 있지만, 미래에 이 버그의 영향을 받을 수 있는 코드의 양은 무한합니다.</p>
<p>이러한 변경의 또 다른 이유는 궁극적으로 Python의 숫자 모델을 통합하려는 바람 때문입니다. 이는 PEP 228 (현재 미완성)의 주제입니다. 통합된 숫자 모델은 사용자가 다른 숫자 타입을 인지해야 할 필요성을 대부분 제거합니다. 이는 초보자에게도 좋지만, 숙련된 프로그래머에게도 다른 숫자 동작에 대한 우려를 덜어줍니다. (물론, 수치 안정성과 정확성에 대한 우려를 제거하지는 않습니다.)</p>
<p>통합된 숫자 모델에서, 다른 타입들(int, long, float, complex 및 잠재적으로 새로운 유리수(rational) 타입 등)은 주로 저장 최적화 역할을 하며, 부정확성(inexactness)이나 복소수(complexity)와 같은 직교적인 속성을 나타냅니다. 통합 모델에서는 정수 1이 부동 소수점 숫자 1.0과 구별할 수 없어야 하며 (부정확성을 제외하고), 둘 다 모든 숫자 문맥에서 동일하게 동작해야 합니다. 분명히, 통합된 숫자 모델에서 <code>a==b</code>이고 <code>c==d</code>라면, <code>a/c</code>는 <code>b/d</code>와 같아야 합니다 (부정확한 숫자의 반올림으로 인한 약간의 자유는 허용). 그리고 모두가 <code>1.0/2.0</code>이 <code>0.5</code>와 같다는 데 동의하므로, <code>1/2</code>도 <code>0.5</code>와 같아야 합니다. 마찬가지로, <code>1//2</code>가 0과 같으므로, <code>1.0//2.0</code>도 0과 같아야 합니다.</p>
<h2>변경안 (Variations)</h2>
<p>미적으로 <code>x // y</code>는 모두에게 만족스러운 것은 아니며, 따라서 여러 변형이 제안되었습니다.</p>
<ul>
<li><strong><code>x div y</code></strong>: 새로운 키워드를 도입하게 됩니다. <code>div</code>는 인기 있는 식별자이므로, 새로운 키워드가 future division statement 하에서만 인식되지 않는 한, 상당수의 기존 코드를 손상시킬 것입니다. 변환해야 할 코드의 대부분이 정수를 나누는 코드일 것으로 예상되므로, 이는 future division statement의 필요성을 크게 증가시킬 것입니다. future statement가 있더라도, 절대적으로 필요한 경우가 아니면 새로운 키워드를 추가하는 것에 대한 일반적인 정서는 이에 반대합니다.</li>
<li><strong><code>div(x, y)</code></strong>: 이것은 오래된 코드의 변환을 훨씬 어렵게 만듭니다. <code>x/y</code>를 <code>x//y</code> 또는 <code>x div y</code>로 교체하는 것은 간단한 쿼리-대체(query replace)로 가능합니다. 대부분의 경우 프로그래머는 특정 모듈이 정수와만 작동하므로 <code>x/y</code>의 모든 발생을 대체할 수 있음을 쉽게 확인할 수 있습니다. (<code>query replace</code>는 주석이나 문자열 리터럴에 나타나는 슬래시를 걸러내기 위해 여전히 필요합니다.) <code>x/y</code>를 <code>div(x, y)</code>로 교체하려면 <code>/</code>의 왼쪽과 오른쪽에 있는 표현식의 범위를 분석하여 <code>div(</code>와 <code>)</code> 부분을 어디에 배치할지 결정해야 하므로 훨씬 더 지능적인 도구가 필요할 것입니다.</li>
<li><strong><code>x \ y</code></strong>: 백슬래시는 이미 줄 연속(line continuation)을 의미하는 토큰이며, 일반적으로 Unix 사용자에게는 이스케이프를 제안합니다. 또한 (Terry Reedy에 따르면) <code>eval("x\y")</code>와 같은 것을 올바르게 구현하기 어렵게 만들 것입니다.</li>
</ul>
<h2>대안 (Alternatives)</h2>
<p>변환해야 할 오래된 코드의 양을 줄이기 위해 여러 대안 제안이 제시되었습니다. 각 제안(또는 제안 범주)에 대한 간략한 논의는 다음과 같습니다.</p>
<ul>
<li><strong><code>/</code>가 고전적 의미를 유지하고, <code>//</code>를 참 나눗셈에 도입</strong>: 이는 언어에 여전히 깨진 연산자를 남기고, 깨진 동작을 사용하도록 유도합니다. 또한 PEP 228과 같은 통합 숫자 모델로 가는 길을 막습니다.</li>
<li><strong><code>int</code> 나눗셈이 정수 문맥에서는 정수처럼, float 문맥에서는 float처럼 동작하는 특별한 "합성(portmanteau)" 타입을 반환하게 함</strong>: 몇 번의 연산 후에 <code>int</code>와 <code>float</code> 값이 크게 달라질 수 있고, 비교에서 어떤 값을 사용해야 할지 불분명하며, 물론 많은 문맥(예: 문자열 변환)에서는 명확한 <code>int</code> 또는 <code>float</code> 선호도가 없다는 문제가 있습니다.</li>
<li><strong>future statement 대신 모듈에서 특정 나눗셈 의미를 사용하도록 지시어(directive) 사용</strong>: 이는 고전적 나눗셈을 언어의 영구적인 문제점으로 남겨두어, 미래 세대의 Python 프로그래머가 문제와 해결책을 인지하도록 요구하게 됩니다.</li>
<li><strong><code>from __past__ import division</code>를 사용하여 모듈에서 고전적 나눗셈 의미를 사용</strong>: 이는 또한 고전적 나눗셈을 영구적인 문제점으로 남기거나 (결국 <code>past division statement</code>가 <code>ImportError</code>를 발생시킬 수 있습니다), 적어도 오랫동안 유지합니다.</li>
<li><strong>지시어(또는 다른 방법)를 사용하여 특정 코드 조각이 개발된 Python 버전을 지정</strong>: 이는 미래 Python 인터프리터가 여러 이전 Python 버전을 정확하게 에뮬레이션할 수 있어야 하며, 동일한 인터프리터 내에서 여러 버전을 에뮬레이션해야 합니다. 이는 너무 많은 작업입니다. 훨씬 간단한 해결책은 여러 인터프리터를 설치하는 것입니다. 이 제안에 대한 또 다른 반론은 버전 지시어가 거의 항상 과도하게 지정된다는 것입니다. 대부분의 Python X.Y용 코드는 Python X.(Y-1) 및 X.(Y+1)에서도 작동하므로, X.Y를 버전으로 지정하는 것은 필요 이상으로 제약적입니다. 동시에, 코드가 미래 또는 과거의 어떤 버전에서 깨질지 알 방법이 없습니다.</li>
</ul>
<h2>API 변경 (API Changes)</h2>
<p>전환 단계 동안, 우리는 동일한 프로그램 내에서 세 가지 나눗셈 연산자를 지원해야 합니다: 고전적 나눗셈 (future division statement가 없는 모듈의 <code>/</code>), 참 나눗셈 (future division statement가 있는 모듈의 <code>/</code>), 바닥 나눗셈 (<code>//</code>). 각 연산자는 일반적인 형태와 복합 할당 연산자 (<code>/=</code> 또는 <code>//=</code>)의 두 가지 형태로 제공됩니다.</p>
<p>이러한 변형과 관련된 이름은 다음과 같습니다:</p>
<ul>
<li><strong>오버로드된 연산자 메서드</strong>:
<ul>
<li><code>__div__()</code>, <code>__floordiv__()</code>, <code>__truediv__()</code></li>
<li><code>__idiv__()</code>, <code>__ifloordiv__()</code>, <code>__itruediv__()</code></li>
</ul>
</li>
<li><strong>추상 API C 함수</strong>:
<ul>
<li><code>PyNumber_Divide()</code>, <code>PyNumber_FloorDivide()</code>, <code>PyNumber_TrueDivide()</code></li>
<li><code>PyNumber_InPlaceDivide()</code>, <code>PyNumber_InPlaceFloorDivide()</code>, <code>PyNumber_InPlaceTrueDivide()</code></li>
</ul>
</li>
<li><strong>바이트 코드 opcode</strong>:
<ul>
<li><code>BINARY_DIVIDE</code>, <code>BINARY_FLOOR_DIVIDE</code>, <code>BINARY_TRUE_DIVIDE</code></li>
<li><code>INPLACE_DIVIDE</code>, <code>INPLACE_FLOOR_DIVIDE</code>, <code>INPLACE_TRUE_DIVIDE</code></li>
</ul>
</li>
<li><strong><code>PyNumberMethod</code> 슬롯</strong>:
<ul>
<li><code>nb_divide</code>, <code>nb_floor_divide</code>, <code>nb_true_divide</code>, <code>nb_inplace_divide</code>, <code>nb_inplace_floor_divide</code>, <code>nb_inplace_true_divide</code></li>
</ul>
</li>
</ul>
<p>추가된 <code>PyNumberMethod</code> 슬롯은 <code>tp_flags</code>에 추가 플래그를 요구합니다. 이 플래그는 <code>Py_TPFLAGS_HAVE_NEWDIVIDE</code>로 명명되며 <code>Py_TPFLAGS_DEFAULT</code>에 포함될 것입니다.</p>
<p>참 나눗셈 및 바닥 나눗셈 API는 해당 슬롯을 찾아 호출하며, 해당 슬롯이 <code>NULL</code>이면 예외를 발생시킵니다. 고전적 나눗셈 슬롯으로의 폴백(fallback)은 없습니다.</p>
<p>Python 3.0에서는 고전적 나눗셈 의미가 제거될 것입니다. 고전적 나눗셈 API는 참 나눗셈과 동의어가 될 것입니다.</p>
<h2>명령줄 옵션 (Command Line Option)</h2>
<p><code>-Q</code> 명령줄 옵션은 <code>old</code>, <code>warn</code>, <code>warnall</code>, <code>new</code> 네 가지 값을 가질 수 있는 문자열 인수를 받습니다. Python 2.2에서는 기본값이 <code>old</code>이지만, 이후 2.x 버전에서는 <code>warn</code>으로 변경될 것입니다.</p>
<ul>
<li><code>old</code>: 고전적 나눗셈 연산자가 설명된 대로 작동합니다.</li>
<li><code>warn</code>: <code>int</code> 또는 <code>long</code> 인수에 고전적 나눗셈 연산자가 적용될 때 경고 (표준 경고 프레임워크를 사용하는 <code>DeprecationWarning</code>)를 발생시킵니다.</li>
<li><code>warnall</code>: <code>float</code> 또는 <code>complex</code> 인수에 고전적 나눗셈이 적용될 때도 경고를 발생시킵니다. 이는 아래에서 언급된 <code>fixdiv.py</code> 변환 스크립트에서 사용됩니다.</li>
<li><code>new</code>: 기본값을 전역적으로 변경하여 <code>/</code> 연산자가 항상 참 나눗셈으로 해석되도록 합니다. 이 <code>new</code> 옵션은 참 나눗셈이 필요하지만, 학생들이 모든 코드에 future division statement를 포함하도록 요구하는 것이 문제가 되는 특정 교육 환경에서만 사용하도록 의도되었습니다.</li>
</ul>
<p>이 옵션은 Python 3.0에서는 지원되지 않습니다. Python 3.0은 항상 <code>/</code>를 참 나눗셈으로 해석할 것입니다.</p>
<h2>바닥 나눗셈의 의미 (Semantics of Floor Division)</h2>
<p>바닥 나눗셈은 모든 Python 숫자 타입에서 구현될 것이며, 다음과 같은 의미를 가집니다:</p>
<p><code>a // b == floor(a / b)</code></p>
<p>단, 결과 타입은 연산 전에 <code>a</code>와 <code>b</code>가 강제 변환되는 공통 타입이 됩니다.</p>
<p>특히, <code>a</code>와 <code>b</code>가 같은 타입이면 <code>a // b</code>도 해당 타입이 됩니다. 입력이 다른 타입이면, 다른 모든 산술 연산자에 사용되는 동일한 규칙을 사용하여 먼저 공통 타입으로 강제 변환됩니다.</p>
<p>특히, <code>a</code>와 <code>b</code>가 모두 <code>int</code> 또는 <code>long</code>이면, 결과는 이 타입들에 대한 고전적 나눗셈과 동일한 타입과 값을 가집니다 (혼합 입력 타입의 경우 포함; <code>int // long</code> 및 <code>long // int</code>는 모두 <code>long</code>을 반환합니다).</p>
<p>부동 소수점 입력의 경우 결과는 <code>float</code>입니다. 예를 들어:</p>
<p><code>3.5 // 2.0 == 1.0</code></p>
<p>복소수의 경우, 복소수에 대한 <code>floor()</code>가 허용되지 않으므로 <code>//</code>는 예외를 발생시킵니다.</p>
<p>사용자 정의 클래스 및 확장 타입의 경우, 모든 의미는 클래스 또는 타입의 구현에 달려 있습니다.</p>
<h2>참 나눗셈의 의미 (Semantics of True Division)</h2>
<p><code>int</code>와 <code>long</code>에 대한 참 나눗셈은 인수를 <code>float</code>로 변환한 다음 <code>float</code> 나눗셈을 적용합니다. 즉, <code>2/1</code>도 <code>int</code>가 아닌 <code>float</code>(<code>2.0</code>)를 반환합니다. <code>float</code>와 <code>complex</code>의 경우 고전적 나눗셈과 동일합니다.</p>
<p>Python 2.2에서 참 나눗셈 구현은 <code>float</code> 타입이 무한한 범위를 가진 것처럼 작동하여, 수학적 결과의 크기가 <code>float</code>로 표현하기에 너무 크지 않는 한 오버플로우가 발생하지 않습니다. 예를 들어, <code>x = 1L &#x3C;&#x3C; 40000</code> 이후 <code>float(x)</code>는 <code>OverflowError</code>를 발생시킵니다 (이는 2.2의 새로운 사항입니다. 이전에는 결과가 플랫폼 종속적이었고, 대부분 <code>float infinity</code>였습니다). 그러나 <code>x/x</code>는 예외 없이 <code>1.0</code>을 반환하는 반면, <code>x/1</code>은 <code>OverflowError</code>를 발생시킵니다.</p>
<p><code>int</code> 및 <code>long</code> 인수의 경우, 참 나눗셈은 정보 손실을 초래할 수 있습니다. 이는 참 나눗셈의 본질적인 특성입니다 (유리수가 언어에 포함되지 않는 한). <code>long</code> 정수를 의식적으로 사용하는 알고리즘은 <code>//</code>를 사용하는 것을 고려해야 합니다. <code>long</code> 정수의 참 나눗셈은 (대부분의 플랫폼에서) 53비트 이상의 정밀도를 유지하지 않기 때문입니다.</p>
<p>유리수 타입이 Python에 추가될 경우 (PEP 239 참조), <code>int</code> 및 <code>long</code>에 대한 참 나눗셈은 아마도 유리수를 반환해야 할 것입니다. 이는 <code>int</code> 및 <code>long</code>의 참 나눗셈에서 정보 손실 문제를 피할 수 있습니다. 그러나 그때까지는 일관성을 위해 <code>float</code>가 참 나눗셈에 대한 유일한 선택입니다.</p>
<h2>Future Division Statement (미래 나눗셈 문)</h2>
<p>모듈에 <code>from __future__ import division</code>이 있거나 <code>-Qnew</code>가 사용되면, <code>/</code> 및 <code>/=</code> 연산자는 참 나눗셈 opcode로 변환됩니다. 그렇지 않으면 (Python 3.0이 나오기 전까지는) 고전적 나눗셈으로 변환됩니다. Python 3.0에서는 항상 참 나눗셈으로 변환됩니다.</p>
<p>future division statement는 <code>//</code> 및 <code>//=</code>의 인식 또는 변환에 영향을 미치지 않습니다.</p>
<p>future statement에 대한 일반적인 규칙은 PEP 236을 참조하십시오.</p>
<h2>FAQ (자주 묻는 질문)</h2>
<ul>
<li>
<p><strong>Python 3.0은 언제 출시되나요?</strong></p>
<ul>
<li>장기적인 계획은 없으므로 확실히 말할 수 없습니다. 전환 기간으로 최소 2년이 필요하다고 생각합니다. Python 3.0이 더 빨리 나온다면, Python 2.2 출시 후 최소 2년 동안 하위 호환성을 위해 2.x 라인을 유지할 것입니다. 실제로 Python 3.0 출시 후에도 몇 년 동안 Python 2.x 라인을 계속 사용할 수 있으므로 전환에 시간을 할애할 수 있습니다. 사이트에서는 Python 2.x와 Python 3.x를 동시에 설치할 수 있을 것으로 예상됩니다.</li>
</ul>
</li>
<li>
<p><strong>참 나눗셈을 왜 <code>float division</code>이라고 부르지 않나요?</strong></p>
<ul>
<li>유리수를 도입하고 <code>1/2</code>이 <code>float</code>가 아닌 유리수를 반환할 가능성을 열어두고 싶기 때문입니다. PEP 239를 참조하십시오.</li>
</ul>
</li>
<li>
<p><strong><code>__truediv__</code>와 <code>__itruediv__</code>가 필요한 이유는 무엇인가요?</strong></p>
<ul>
<li>사용자 정의 클래스를 2류 시민으로 만들고 싶지 않습니다. 특히 타입/클래스 통합이 진행 중인 상황에서는 더욱 그렇습니다.</li>
</ul>
</li>
<li>
<p><strong><code>//</code> 또는 future division statement를 사용하지 않고 고전적 규칙과 새로운 규칙 모두에서 작동하는 코드를 어떻게 작성하나요?</strong></p>
<ul>
<li>참 나눗셈에는 <code>x * 1.0 / y</code>를, 정수 나눗셈에는 <code>divmod(x, y)</code> (PEP 228)를 사용하세요. 특히 후자는 함수 내부에 숨겨두는 것이 가장 좋습니다. 복소수를 예상하지 않는다면 <code>float(x) / y</code>를 사용하여 참 나눗셈을 할 수도 있습니다. 정수가 음수가 아니라는 것을 안다면 <code>int(x / y)</code>를 사용할 수 있습니다. <code>int()</code>의 문서는 <code>int()</code>가 C 구현에 따라 반올림(round) 또는 절단(truncate)할 수 있다고 말하지만, 절단하지 않는 C 구현은 알지 못하며, <code>int()</code>의 사양을 절단을 약속하도록 변경할 것입니다. 고전적 나눗셈(및 바닥 나눗셈)은 음의 무한대 방향으로 반올림하는 반면, <code>int()</code>는 0 방향으로 반올림하여 음수에 대해 다른 결과를 제공한다는 점에 유의하십시오.</li>
</ul>
</li>
<li>
<p><strong><code>input()</code>, <code>compile()</code>, <code>execfile()</code>, <code>eval()</code>, <code>exec</code>에 대한 나눗셈 의미를 어떻게 지정하나요?</strong></p>
<ul>
<li>호출하는 모듈에서 선택을 상속합니다. PEP 236은 이제 이를 PEP 264를 참조하는 해결된 문제로 나열합니다.</li>
</ul>
</li>
<li>
<p><strong><code>codeop</code> 모듈에 의해 컴파일된 코드는 어떻게 되나요?</strong></p>
<ul>
<li>적절하게 처리됩니다. PEP 264를 참조하십시오.</li>
</ul>
</li>
<li>
<p><strong>변환 도구나 지원 기능이 있나요?</strong></p>
<ul>
<li>물론입니다. 이들은 PEP의 범위를 벗어나지만, Python 2.2a3와 함께 출시될 두 가지 간단한 도구를 지적해야 합니다: <code>Tools/scripts/finddiv.py</code>는 나눗셈 연산자를 찾고 (<code>grep /</code>보다 약간 더 스마트함), <code>Tools/scripts/fixdiv.py</code>는 런타임 분석을 기반으로 패치를 생성할 수 있습니다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/238\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"SAPzS3zi9tsG5MkeKvxIA\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/238/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/238\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"238\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/238\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T5bf5,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0238/\"\u003ePEP 238 - Changing the Division Operator\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 11-Mar-2001\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 238 – 나눗셈 연산자 변경 (Changing the Division Operator)\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e현재 Python의 나눗셈 연산자 (\u003ccode\u003e/\u003c/code\u003e)는 숫자 인수에 대해 모호한 의미를 가지고 있습니다. 정수(int)나 long 정수가 인수로 주어질 경우 수학적 나눗셈 결과의 내림(floor) 값을 반환하지만, 부동 소수점(float)이나 복소수(complex)가 주어지면 나눗셈 결과의 합리적인 근사치를 반환합니다. 이로 인해 float 또는 complex 결과가 예상되는 표현식에서 예기치 않게 정수가 입력으로 들어올 경우 오류가 발생하기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 이러한 문제를 해결하기 위해 다음과 같이 다른 연산자들을 도입할 것을 제안합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ex / y\u003c/code\u003e: 나눗셈의 수학적 결과에 대한 합리적인 근사치를 반환하는 \"참 나눗셈 (true division)\".\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex // y\u003c/code\u003e: 내림(floor) 값을 반환하는 \"바닥 나눗셈 (floor division)\".\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e기존의 \u003ccode\u003ex / y\u003c/code\u003e의 혼합된 의미를 \"고전적 나눗셈 (classic division)\"이라고 부릅니다.\u003c/p\u003e\n\u003cp\u003e심각한 하위 호환성 문제 때문에, Python 2.2부터 다음과 같은 전환 조치들이 제안되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePython 2.x 시리즈에서는 고전적 나눗셈이 기본으로 유지됩니다. Python 3.0에서는 참 나눗셈이 표준이 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e//\u003c/code\u003e 연산자는 명확하게 바닥 나눗셈을 요청하는 데 사용될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efrom __future__ import division\u003c/code\u003e 문은 해당 모듈 전체에서 \u003ccode\u003e/\u003c/code\u003e 연산자가 참 나눗셈을 의미하도록 변경합니다.\u003c/li\u003e\n\u003cli\u003e명령줄 옵션을 통해 \u003ccode\u003eint\u003c/code\u003e 또는 \u003ccode\u003elong\u003c/code\u003e 인수에 고전적 나눗셈이 적용될 경우 실행 시 경고를 발생시킬 수 있습니다. 다른 명령줄 옵션은 참 나눗셈을 기본으로 설정할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e표준 라이브러리는 고전적 나눗셈을 완전히 피하기 위해 적절한 경우 future division statement와 \u003ccode\u003e//\u003c/code\u003e 연산자를 사용하게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e고전적 나눗셈 연산자는 임의의 숫자 입력을 받아 올바른 결과를 내야 하는 수치 표현식을 작성하기 어렵게 만듭니다. 다른 모든 연산자 (\u003ccode\u003ex * y**2 + z\u003c/code\u003e 등)의 경우, 어떤 숫자 입력 타입(int, long, float, complex)에 대해서도 계산 결과가 수학적 결과에 가깝게 나옵니다 (물론 수치 정확도의 한계 내에서). 하지만 나눗셈은 문제가 됩니다. 양쪽 인수의 표현식이 우연히 정수 타입일 경우, 참 나눗셈이 아닌 바닥 나눗셈을 수행하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이 문제는 동적 타입 언어에 고유합니다. C와 같은 정적 타입 언어에서는 입력 (일반적으로 함수 인수)이 \u003ccode\u003edouble\u003c/code\u003e 또는 \u003ccode\u003efloat\u003c/code\u003e로 선언되고, 정수 인수가 전달될 때 호출 시 \u003ccode\u003edouble\u003c/code\u003e 또는 \u003ccode\u003efloat\u003c/code\u003e로 변환됩니다. Python은 인수 타입 선언이 없으므로, 정수 인수가 쉽게 표현식에 포함될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 문제는 \u003ccode\u003eint\u003c/code\u003e가 다른 모든 상황에서 \u003ccode\u003efloat\u003c/code\u003e의 완벽한 대체재가 되기 때문에 특히 해롭습니다. 예를 들어, \u003ccode\u003emath.sqrt(2)\u003c/code\u003e는 \u003ccode\u003emath.sqrt(2.0)\u003c/code\u003e와 동일한 값을 반환하고, \u003ccode\u003e3.14 * 100\u003c/code\u003e과 \u003ccode\u003e3.14 * 100.0\u003c/code\u003e도 동일한 값을 반환합니다. 따라서 수치 루틴의 작성자는 부동 소수점 숫자로만 코드를 테스트하고 올바르게 작동한다고 믿을 수 있지만, 사용자가 실수로 정수 입력 값을 전달하여 잘못된 결과를 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e고전적 나눗셈은 \u003ccode\u003efloat\u003c/code\u003e 또는 \u003ccode\u003eint\u003c/code\u003e 인수 모두에서 잘 작동하는 다형성(polymorphic) 함수를 작성하기 어렵게 만듭니다. 다른 모든 연산자들은 이미 올바르게 작동합니다. 정수와 부동 소수점 숫자 모두에 적용되는 어떤 알고리즘도 한 경우에는 절단 나눗셈(truncating division)을, 다른 경우에는 참 나눗셈을 필요로 하지 않습니다.\u003c/p\u003e\n\u003cp\u003e올바른 해결책은 미묘합니다. 인수를 \u003ccode\u003efloat()\u003c/code\u003e으로 캐스팅하는 것은 복소수일 경우 잘못될 수 있습니다. 인수에 \u003ccode\u003e0.0\u003c/code\u003e을 더하는 것은 인수가 음수 0일 경우 부호를 유지하지 못합니다. 이 두 가지 단점 없이 사용할 수 있는 유일한 해결책은 인수에 \u003ccode\u003e1.0\u003c/code\u003e을 곱하는 것입니다. 이것은 \u003ccode\u003efloat\u003c/code\u003e 및 \u003ccode\u003ecomplex\u003c/code\u003e의 값과 부호를 변경하지 않고, \u003ccode\u003eint\u003c/code\u003e 및 \u003ccode\u003elong\u003c/code\u003e을 해당 값을 가진 \u003ccode\u003efloat\u003c/code\u003e으로 변환합니다.\u003c/p\u003e\n\u003cp\u003e저자들은 이것이 Python의 진정한 설계 버그이며, 가급적 빨리 수정해야 한다고 판단했습니다. Python 사용이 계속 증가할 것이라고 가정할 때, 이 버그를 언어에 남겨두는 비용은 결국 오래된 코드를 수정하는 비용을 넘어설 것입니다. 수정해야 할 코드의 양에는 상한선이 있지만, 미래에 이 버그의 영향을 받을 수 있는 코드의 양은 무한합니다.\u003c/p\u003e\n\u003cp\u003e이러한 변경의 또 다른 이유는 궁극적으로 Python의 숫자 모델을 통합하려는 바람 때문입니다. 이는 PEP 228 (현재 미완성)의 주제입니다. 통합된 숫자 모델은 사용자가 다른 숫자 타입을 인지해야 할 필요성을 대부분 제거합니다. 이는 초보자에게도 좋지만, 숙련된 프로그래머에게도 다른 숫자 동작에 대한 우려를 덜어줍니다. (물론, 수치 안정성과 정확성에 대한 우려를 제거하지는 않습니다.)\u003c/p\u003e\n\u003cp\u003e통합된 숫자 모델에서, 다른 타입들(int, long, float, complex 및 잠재적으로 새로운 유리수(rational) 타입 등)은 주로 저장 최적화 역할을 하며, 부정확성(inexactness)이나 복소수(complexity)와 같은 직교적인 속성을 나타냅니다. 통합 모델에서는 정수 1이 부동 소수점 숫자 1.0과 구별할 수 없어야 하며 (부정확성을 제외하고), 둘 다 모든 숫자 문맥에서 동일하게 동작해야 합니다. 분명히, 통합된 숫자 모델에서 \u003ccode\u003ea==b\u003c/code\u003e이고 \u003ccode\u003ec==d\u003c/code\u003e라면, \u003ccode\u003ea/c\u003c/code\u003e는 \u003ccode\u003eb/d\u003c/code\u003e와 같아야 합니다 (부정확한 숫자의 반올림으로 인한 약간의 자유는 허용). 그리고 모두가 \u003ccode\u003e1.0/2.0\u003c/code\u003e이 \u003ccode\u003e0.5\u003c/code\u003e와 같다는 데 동의하므로, \u003ccode\u003e1/2\u003c/code\u003e도 \u003ccode\u003e0.5\u003c/code\u003e와 같아야 합니다. 마찬가지로, \u003ccode\u003e1//2\u003c/code\u003e가 0과 같으므로, \u003ccode\u003e1.0//2.0\u003c/code\u003e도 0과 같아야 합니다.\u003c/p\u003e\n\u003ch2\u003e변경안 (Variations)\u003c/h2\u003e\n\u003cp\u003e미적으로 \u003ccode\u003ex // y\u003c/code\u003e는 모두에게 만족스러운 것은 아니며, 따라서 여러 변형이 제안되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ex div y\u003c/code\u003e\u003c/strong\u003e: 새로운 키워드를 도입하게 됩니다. \u003ccode\u003ediv\u003c/code\u003e는 인기 있는 식별자이므로, 새로운 키워드가 future division statement 하에서만 인식되지 않는 한, 상당수의 기존 코드를 손상시킬 것입니다. 변환해야 할 코드의 대부분이 정수를 나누는 코드일 것으로 예상되므로, 이는 future division statement의 필요성을 크게 증가시킬 것입니다. future statement가 있더라도, 절대적으로 필요한 경우가 아니면 새로운 키워드를 추가하는 것에 대한 일반적인 정서는 이에 반대합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ediv(x, y)\u003c/code\u003e\u003c/strong\u003e: 이것은 오래된 코드의 변환을 훨씬 어렵게 만듭니다. \u003ccode\u003ex/y\u003c/code\u003e를 \u003ccode\u003ex//y\u003c/code\u003e 또는 \u003ccode\u003ex div y\u003c/code\u003e로 교체하는 것은 간단한 쿼리-대체(query replace)로 가능합니다. 대부분의 경우 프로그래머는 특정 모듈이 정수와만 작동하므로 \u003ccode\u003ex/y\u003c/code\u003e의 모든 발생을 대체할 수 있음을 쉽게 확인할 수 있습니다. (\u003ccode\u003equery replace\u003c/code\u003e는 주석이나 문자열 리터럴에 나타나는 슬래시를 걸러내기 위해 여전히 필요합니다.) \u003ccode\u003ex/y\u003c/code\u003e를 \u003ccode\u003ediv(x, y)\u003c/code\u003e로 교체하려면 \u003ccode\u003e/\u003c/code\u003e의 왼쪽과 오른쪽에 있는 표현식의 범위를 분석하여 \u003ccode\u003ediv(\u003c/code\u003e와 \u003ccode\u003e)\u003c/code\u003e 부분을 어디에 배치할지 결정해야 하므로 훨씬 더 지능적인 도구가 필요할 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ex \\ y\u003c/code\u003e\u003c/strong\u003e: 백슬래시는 이미 줄 연속(line continuation)을 의미하는 토큰이며, 일반적으로 Unix 사용자에게는 이스케이프를 제안합니다. 또한 (Terry Reedy에 따르면) \u003ccode\u003eeval(\"x\\y\")\u003c/code\u003e와 같은 것을 올바르게 구현하기 어렵게 만들 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e대안 (Alternatives)\u003c/h2\u003e\n\u003cp\u003e변환해야 할 오래된 코드의 양을 줄이기 위해 여러 대안 제안이 제시되었습니다. 각 제안(또는 제안 범주)에 대한 간략한 논의는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e/\u003c/code\u003e가 고전적 의미를 유지하고, \u003ccode\u003e//\u003c/code\u003e를 참 나눗셈에 도입\u003c/strong\u003e: 이는 언어에 여전히 깨진 연산자를 남기고, 깨진 동작을 사용하도록 유도합니다. 또한 PEP 228과 같은 통합 숫자 모델로 가는 길을 막습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eint\u003c/code\u003e 나눗셈이 정수 문맥에서는 정수처럼, float 문맥에서는 float처럼 동작하는 특별한 \"합성(portmanteau)\" 타입을 반환하게 함\u003c/strong\u003e: 몇 번의 연산 후에 \u003ccode\u003eint\u003c/code\u003e와 \u003ccode\u003efloat\u003c/code\u003e 값이 크게 달라질 수 있고, 비교에서 어떤 값을 사용해야 할지 불분명하며, 물론 많은 문맥(예: 문자열 변환)에서는 명확한 \u003ccode\u003eint\u003c/code\u003e 또는 \u003ccode\u003efloat\u003c/code\u003e 선호도가 없다는 문제가 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003efuture statement 대신 모듈에서 특정 나눗셈 의미를 사용하도록 지시어(directive) 사용\u003c/strong\u003e: 이는 고전적 나눗셈을 언어의 영구적인 문제점으로 남겨두어, 미래 세대의 Python 프로그래머가 문제와 해결책을 인지하도록 요구하게 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003efrom __past__ import division\u003c/code\u003e를 사용하여 모듈에서 고전적 나눗셈 의미를 사용\u003c/strong\u003e: 이는 또한 고전적 나눗셈을 영구적인 문제점으로 남기거나 (결국 \u003ccode\u003epast division statement\u003c/code\u003e가 \u003ccode\u003eImportError\u003c/code\u003e를 발생시킬 수 있습니다), 적어도 오랫동안 유지합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e지시어(또는 다른 방법)를 사용하여 특정 코드 조각이 개발된 Python 버전을 지정\u003c/strong\u003e: 이는 미래 Python 인터프리터가 여러 이전 Python 버전을 정확하게 에뮬레이션할 수 있어야 하며, 동일한 인터프리터 내에서 여러 버전을 에뮬레이션해야 합니다. 이는 너무 많은 작업입니다. 훨씬 간단한 해결책은 여러 인터프리터를 설치하는 것입니다. 이 제안에 대한 또 다른 반론은 버전 지시어가 거의 항상 과도하게 지정된다는 것입니다. 대부분의 Python X.Y용 코드는 Python X.(Y-1) 및 X.(Y+1)에서도 작동하므로, X.Y를 버전으로 지정하는 것은 필요 이상으로 제약적입니다. 동시에, 코드가 미래 또는 과거의 어떤 버전에서 깨질지 알 방법이 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eAPI 변경 (API Changes)\u003c/h2\u003e\n\u003cp\u003e전환 단계 동안, 우리는 동일한 프로그램 내에서 세 가지 나눗셈 연산자를 지원해야 합니다: 고전적 나눗셈 (future division statement가 없는 모듈의 \u003ccode\u003e/\u003c/code\u003e), 참 나눗셈 (future division statement가 있는 모듈의 \u003ccode\u003e/\u003c/code\u003e), 바닥 나눗셈 (\u003ccode\u003e//\u003c/code\u003e). 각 연산자는 일반적인 형태와 복합 할당 연산자 (\u003ccode\u003e/=\u003c/code\u003e 또는 \u003ccode\u003e//=\u003c/code\u003e)의 두 가지 형태로 제공됩니다.\u003c/p\u003e\n\u003cp\u003e이러한 변형과 관련된 이름은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e오버로드된 연산자 메서드\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e__div__()\u003c/code\u003e, \u003ccode\u003e__floordiv__()\u003c/code\u003e, \u003ccode\u003e__truediv__()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e__idiv__()\u003c/code\u003e, \u003ccode\u003e__ifloordiv__()\u003c/code\u003e, \u003ccode\u003e__itruediv__()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e추상 API C 함수\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyNumber_Divide()\u003c/code\u003e, \u003ccode\u003ePyNumber_FloorDivide()\u003c/code\u003e, \u003ccode\u003ePyNumber_TrueDivide()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePyNumber_InPlaceDivide()\u003c/code\u003e, \u003ccode\u003ePyNumber_InPlaceFloorDivide()\u003c/code\u003e, \u003ccode\u003ePyNumber_InPlaceTrueDivide()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e바이트 코드 opcode\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eBINARY_DIVIDE\u003c/code\u003e, \u003ccode\u003eBINARY_FLOOR_DIVIDE\u003c/code\u003e, \u003ccode\u003eBINARY_TRUE_DIVIDE\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eINPLACE_DIVIDE\u003c/code\u003e, \u003ccode\u003eINPLACE_FLOOR_DIVIDE\u003c/code\u003e, \u003ccode\u003eINPLACE_TRUE_DIVIDE\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ePyNumberMethod\u003c/code\u003e 슬롯\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003enb_divide\u003c/code\u003e, \u003ccode\u003enb_floor_divide\u003c/code\u003e, \u003ccode\u003enb_true_divide\u003c/code\u003e, \u003ccode\u003enb_inplace_divide\u003c/code\u003e, \u003ccode\u003enb_inplace_floor_divide\u003c/code\u003e, \u003ccode\u003enb_inplace_true_divide\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e추가된 \u003ccode\u003ePyNumberMethod\u003c/code\u003e 슬롯은 \u003ccode\u003etp_flags\u003c/code\u003e에 추가 플래그를 요구합니다. 이 플래그는 \u003ccode\u003ePy_TPFLAGS_HAVE_NEWDIVIDE\u003c/code\u003e로 명명되며 \u003ccode\u003ePy_TPFLAGS_DEFAULT\u003c/code\u003e에 포함될 것입니다.\u003c/p\u003e\n\u003cp\u003e참 나눗셈 및 바닥 나눗셈 API는 해당 슬롯을 찾아 호출하며, 해당 슬롯이 \u003ccode\u003eNULL\u003c/code\u003e이면 예외를 발생시킵니다. 고전적 나눗셈 슬롯으로의 폴백(fallback)은 없습니다.\u003c/p\u003e\n\u003cp\u003ePython 3.0에서는 고전적 나눗셈 의미가 제거될 것입니다. 고전적 나눗셈 API는 참 나눗셈과 동의어가 될 것입니다.\u003c/p\u003e\n\u003ch2\u003e명령줄 옵션 (Command Line Option)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e-Q\u003c/code\u003e 명령줄 옵션은 \u003ccode\u003eold\u003c/code\u003e, \u003ccode\u003ewarn\u003c/code\u003e, \u003ccode\u003ewarnall\u003c/code\u003e, \u003ccode\u003enew\u003c/code\u003e 네 가지 값을 가질 수 있는 문자열 인수를 받습니다. Python 2.2에서는 기본값이 \u003ccode\u003eold\u003c/code\u003e이지만, 이후 2.x 버전에서는 \u003ccode\u003ewarn\u003c/code\u003e으로 변경될 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eold\u003c/code\u003e: 고전적 나눗셈 연산자가 설명된 대로 작동합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewarn\u003c/code\u003e: \u003ccode\u003eint\u003c/code\u003e 또는 \u003ccode\u003elong\u003c/code\u003e 인수에 고전적 나눗셈 연산자가 적용될 때 경고 (표준 경고 프레임워크를 사용하는 \u003ccode\u003eDeprecationWarning\u003c/code\u003e)를 발생시킵니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ewarnall\u003c/code\u003e: \u003ccode\u003efloat\u003c/code\u003e 또는 \u003ccode\u003ecomplex\u003c/code\u003e 인수에 고전적 나눗셈이 적용될 때도 경고를 발생시킵니다. 이는 아래에서 언급된 \u003ccode\u003efixdiv.py\u003c/code\u003e 변환 스크립트에서 사용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enew\u003c/code\u003e: 기본값을 전역적으로 변경하여 \u003ccode\u003e/\u003c/code\u003e 연산자가 항상 참 나눗셈으로 해석되도록 합니다. 이 \u003ccode\u003enew\u003c/code\u003e 옵션은 참 나눗셈이 필요하지만, 학생들이 모든 코드에 future division statement를 포함하도록 요구하는 것이 문제가 되는 특정 교육 환경에서만 사용하도록 의도되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 옵션은 Python 3.0에서는 지원되지 않습니다. Python 3.0은 항상 \u003ccode\u003e/\u003c/code\u003e를 참 나눗셈으로 해석할 것입니다.\u003c/p\u003e\n\u003ch2\u003e바닥 나눗셈의 의미 (Semantics of Floor Division)\u003c/h2\u003e\n\u003cp\u003e바닥 나눗셈은 모든 Python 숫자 타입에서 구현될 것이며, 다음과 같은 의미를 가집니다:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ea // b == floor(a / b)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e단, 결과 타입은 연산 전에 \u003ccode\u003ea\u003c/code\u003e와 \u003ccode\u003eb\u003c/code\u003e가 강제 변환되는 공통 타입이 됩니다.\u003c/p\u003e\n\u003cp\u003e특히, \u003ccode\u003ea\u003c/code\u003e와 \u003ccode\u003eb\u003c/code\u003e가 같은 타입이면 \u003ccode\u003ea // b\u003c/code\u003e도 해당 타입이 됩니다. 입력이 다른 타입이면, 다른 모든 산술 연산자에 사용되는 동일한 규칙을 사용하여 먼저 공통 타입으로 강제 변환됩니다.\u003c/p\u003e\n\u003cp\u003e특히, \u003ccode\u003ea\u003c/code\u003e와 \u003ccode\u003eb\u003c/code\u003e가 모두 \u003ccode\u003eint\u003c/code\u003e 또는 \u003ccode\u003elong\u003c/code\u003e이면, 결과는 이 타입들에 대한 고전적 나눗셈과 동일한 타입과 값을 가집니다 (혼합 입력 타입의 경우 포함; \u003ccode\u003eint // long\u003c/code\u003e 및 \u003ccode\u003elong // int\u003c/code\u003e는 모두 \u003ccode\u003elong\u003c/code\u003e을 반환합니다).\u003c/p\u003e\n\u003cp\u003e부동 소수점 입력의 경우 결과는 \u003ccode\u003efloat\u003c/code\u003e입니다. 예를 들어:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e3.5 // 2.0 == 1.0\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e복소수의 경우, 복소수에 대한 \u003ccode\u003efloor()\u003c/code\u003e가 허용되지 않으므로 \u003ccode\u003e//\u003c/code\u003e는 예외를 발생시킵니다.\u003c/p\u003e\n\u003cp\u003e사용자 정의 클래스 및 확장 타입의 경우, 모든 의미는 클래스 또는 타입의 구현에 달려 있습니다.\u003c/p\u003e\n\u003ch2\u003e참 나눗셈의 의미 (Semantics of True Division)\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eint\u003c/code\u003e와 \u003ccode\u003elong\u003c/code\u003e에 대한 참 나눗셈은 인수를 \u003ccode\u003efloat\u003c/code\u003e로 변환한 다음 \u003ccode\u003efloat\u003c/code\u003e 나눗셈을 적용합니다. 즉, \u003ccode\u003e2/1\u003c/code\u003e도 \u003ccode\u003eint\u003c/code\u003e가 아닌 \u003ccode\u003efloat\u003c/code\u003e(\u003ccode\u003e2.0\u003c/code\u003e)를 반환합니다. \u003ccode\u003efloat\u003c/code\u003e와 \u003ccode\u003ecomplex\u003c/code\u003e의 경우 고전적 나눗셈과 동일합니다.\u003c/p\u003e\n\u003cp\u003ePython 2.2에서 참 나눗셈 구현은 \u003ccode\u003efloat\u003c/code\u003e 타입이 무한한 범위를 가진 것처럼 작동하여, 수학적 결과의 크기가 \u003ccode\u003efloat\u003c/code\u003e로 표현하기에 너무 크지 않는 한 오버플로우가 발생하지 않습니다. 예를 들어, \u003ccode\u003ex = 1L \u0026#x3C;\u0026#x3C; 40000\u003c/code\u003e 이후 \u003ccode\u003efloat(x)\u003c/code\u003e는 \u003ccode\u003eOverflowError\u003c/code\u003e를 발생시킵니다 (이는 2.2의 새로운 사항입니다. 이전에는 결과가 플랫폼 종속적이었고, 대부분 \u003ccode\u003efloat infinity\u003c/code\u003e였습니다). 그러나 \u003ccode\u003ex/x\u003c/code\u003e는 예외 없이 \u003ccode\u003e1.0\u003c/code\u003e을 반환하는 반면, \u003ccode\u003ex/1\u003c/code\u003e은 \u003ccode\u003eOverflowError\u003c/code\u003e를 발생시킵니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eint\u003c/code\u003e 및 \u003ccode\u003elong\u003c/code\u003e 인수의 경우, 참 나눗셈은 정보 손실을 초래할 수 있습니다. 이는 참 나눗셈의 본질적인 특성입니다 (유리수가 언어에 포함되지 않는 한). \u003ccode\u003elong\u003c/code\u003e 정수를 의식적으로 사용하는 알고리즘은 \u003ccode\u003e//\u003c/code\u003e를 사용하는 것을 고려해야 합니다. \u003ccode\u003elong\u003c/code\u003e 정수의 참 나눗셈은 (대부분의 플랫폼에서) 53비트 이상의 정밀도를 유지하지 않기 때문입니다.\u003c/p\u003e\n\u003cp\u003e유리수 타입이 Python에 추가될 경우 (PEP 239 참조), \u003ccode\u003eint\u003c/code\u003e 및 \u003ccode\u003elong\u003c/code\u003e에 대한 참 나눗셈은 아마도 유리수를 반환해야 할 것입니다. 이는 \u003ccode\u003eint\u003c/code\u003e 및 \u003ccode\u003elong\u003c/code\u003e의 참 나눗셈에서 정보 손실 문제를 피할 수 있습니다. 그러나 그때까지는 일관성을 위해 \u003ccode\u003efloat\u003c/code\u003e가 참 나눗셈에 대한 유일한 선택입니다.\u003c/p\u003e\n\u003ch2\u003eFuture Division Statement (미래 나눗셈 문)\u003c/h2\u003e\n\u003cp\u003e모듈에 \u003ccode\u003efrom __future__ import division\u003c/code\u003e이 있거나 \u003ccode\u003e-Qnew\u003c/code\u003e가 사용되면, \u003ccode\u003e/\u003c/code\u003e 및 \u003ccode\u003e/=\u003c/code\u003e 연산자는 참 나눗셈 opcode로 변환됩니다. 그렇지 않으면 (Python 3.0이 나오기 전까지는) 고전적 나눗셈으로 변환됩니다. Python 3.0에서는 항상 참 나눗셈으로 변환됩니다.\u003c/p\u003e\n\u003cp\u003efuture division statement는 \u003ccode\u003e//\u003c/code\u003e 및 \u003ccode\u003e//=\u003c/code\u003e의 인식 또는 변환에 영향을 미치지 않습니다.\u003c/p\u003e\n\u003cp\u003efuture statement에 대한 일반적인 규칙은 PEP 236을 참조하십시오.\u003c/p\u003e\n\u003ch2\u003eFAQ (자주 묻는 질문)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePython 3.0은 언제 출시되나요?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e장기적인 계획은 없으므로 확실히 말할 수 없습니다. 전환 기간으로 최소 2년이 필요하다고 생각합니다. Python 3.0이 더 빨리 나온다면, Python 2.2 출시 후 최소 2년 동안 하위 호환성을 위해 2.x 라인을 유지할 것입니다. 실제로 Python 3.0 출시 후에도 몇 년 동안 Python 2.x 라인을 계속 사용할 수 있으므로 전환에 시간을 할애할 수 있습니다. 사이트에서는 Python 2.x와 Python 3.x를 동시에 설치할 수 있을 것으로 예상됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e참 나눗셈을 왜 \u003ccode\u003efloat division\u003c/code\u003e이라고 부르지 않나요?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e유리수를 도입하고 \u003ccode\u003e1/2\u003c/code\u003e이 \u003ccode\u003efloat\u003c/code\u003e가 아닌 유리수를 반환할 가능성을 열어두고 싶기 때문입니다. PEP 239를 참조하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e__truediv__\u003c/code\u003e와 \u003ccode\u003e__itruediv__\u003c/code\u003e가 필요한 이유는 무엇인가요?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자 정의 클래스를 2류 시민으로 만들고 싶지 않습니다. 특히 타입/클래스 통합이 진행 중인 상황에서는 더욱 그렇습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e//\u003c/code\u003e 또는 future division statement를 사용하지 않고 고전적 규칙과 새로운 규칙 모두에서 작동하는 코드를 어떻게 작성하나요?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e참 나눗셈에는 \u003ccode\u003ex * 1.0 / y\u003c/code\u003e를, 정수 나눗셈에는 \u003ccode\u003edivmod(x, y)\u003c/code\u003e (PEP 228)를 사용하세요. 특히 후자는 함수 내부에 숨겨두는 것이 가장 좋습니다. 복소수를 예상하지 않는다면 \u003ccode\u003efloat(x) / y\u003c/code\u003e를 사용하여 참 나눗셈을 할 수도 있습니다. 정수가 음수가 아니라는 것을 안다면 \u003ccode\u003eint(x / y)\u003c/code\u003e를 사용할 수 있습니다. \u003ccode\u003eint()\u003c/code\u003e의 문서는 \u003ccode\u003eint()\u003c/code\u003e가 C 구현에 따라 반올림(round) 또는 절단(truncate)할 수 있다고 말하지만, 절단하지 않는 C 구현은 알지 못하며, \u003ccode\u003eint()\u003c/code\u003e의 사양을 절단을 약속하도록 변경할 것입니다. 고전적 나눗셈(및 바닥 나눗셈)은 음의 무한대 방향으로 반올림하는 반면, \u003ccode\u003eint()\u003c/code\u003e는 0 방향으로 반올림하여 음수에 대해 다른 결과를 제공한다는 점에 유의하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003einput()\u003c/code\u003e, \u003ccode\u003ecompile()\u003c/code\u003e, \u003ccode\u003eexecfile()\u003c/code\u003e, \u003ccode\u003eeval()\u003c/code\u003e, \u003ccode\u003eexec\u003c/code\u003e에 대한 나눗셈 의미를 어떻게 지정하나요?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e호출하는 모듈에서 선택을 상속합니다. PEP 236은 이제 이를 PEP 264를 참조하는 해결된 문제로 나열합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ecodeop\u003c/code\u003e 모듈에 의해 컴파일된 코드는 어떻게 되나요?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e적절하게 처리됩니다. PEP 264를 참조하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e변환 도구나 지원 기능이 있나요?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e물론입니다. 이들은 PEP의 범위를 벗어나지만, Python 2.2a3와 함께 출시될 두 가지 간단한 도구를 지적해야 합니다: \u003ccode\u003eTools/scripts/finddiv.py\u003c/code\u003e는 나눗셈 연산자를 찾고 (\u003ccode\u003egrep /\u003c/code\u003e보다 약간 더 스마트함), \u003ccode\u003eTools/scripts/fixdiv.py\u003c/code\u003e는 런타임 분석을 기반으로 패치를 생성할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 238 - Changing the Division Operator\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 17:08:05+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>