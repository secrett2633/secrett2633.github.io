<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/edf391eeca43d999.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-167bfed393319721.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-eb985a9c6ac1f073.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1734<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 561 - Distributing and Packaging Type Information</h1><div class="page__meta"><time dateTime="2025-09-26 23:46:31+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0561/">PEP 561 - Distributing and Packaging Type Information</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 09-Sep-2017</p>
</blockquote>
<p>PEP 561 – 타입 정보 배포 및 패키징</p>
<h2>개요 (Abstract)</h2>
<p>PEP 484는 점진적이고 쉽게 채택할 수 있는 목표를 가지고 Python에 타입 힌팅(Type Hinting)을 도입했습니다. 현재 타입 정보는 수동으로 배포되어야 합니다. 이 PEP는 기존 툴링(tooling)을 활용하여 최소한의 작업으로 타입 정보를 패키징하고 배포할 수 있는 표준화된 방법을 제공하며, 타입 체커(Type Checker)가 모듈을 해석하고 타입 검사를 위해 이 정보를 수집하는 순서를 정의합니다.</p>
<h2>배경 (Rationale)</h2>
<p>현재 패키지 작성자는 인라인(inline) 타입 정보가 포함된 코드를 배포하고자 합니다. 또한, 관리자는 최신 주석 구문(annotation syntax)을 사용하면서 Python 2 호환성을 유지하기 위해 스텁(stub) 파일을 배포하기를 원합니다. 그러나 타입 정보가 포함된 패키지를 배포하는 표준화된 방법이 없습니다. 또한, 개인적으로 스텁 파일을 제공하고자 한다면 MYPYPATH 또는 그에 상응하는 것을 설정하여 스텁 파일을 수동으로 지정하는 방법밖에 없었습니다. 만약 패키지를 공개적으로 배포할 수 있다면 typeshed에 추가할 수 있지만, 이는 확장성이 떨어지고 typeshed 관리자에게 부담이 됩니다. 또한, 스텁 파일의 버그 수정이 typeshed를 사용하는 도구의 릴리스에 종속됩니다.</p>
<p>PEP 484는 타입 정보 배포에 대한 간략한 섹션을 가지고 있습니다. 이 섹션에서는 스텁 파일을 배포하기 위해 <code>shared/typehints/pythonX.Y/</code> 사용을 권장합니다. 그러나 각 서드파티 라이브러리(third party library)에 스텁 파일 경로를 수동으로 추가하는 것은 확장성이 떨어집니다. 가장 간단한 접근 방식은 <code>site-packages</code>를 <code>MYPYPATH</code>에 추가하는 것이었지만, 이는 동적(dynamic)인 패키지(예: SQLAlchemy, Django)에서 타입 체커가 실패하는 원인이 됩니다.</p>
<h2>용어 정의 (Definition of Terms)</h2>
<p>"MAY", "MUST", "SHOULD", "SHOULD NOT"의 정의는 RFC 2119에 기술된 대로 해석됩니다.</p>
<ul>
<li><strong>"inline"</strong> : 타입이 PEP 526 및 PEP 3107 구문(<code>*.py</code> 파일)을 사용하여 런타임 코드의 일부로 포함된 경우를 의미합니다.</li>
<li><strong>"stubs"</strong> : 런타임 코드는 없고 타입 정보만 포함하는 파일(<code>*.pyi</code> 파일)을 의미합니다.</li>
<li><strong>"Distributions"</strong> : 릴리스를 발행하고 배포하는 데 사용되는 패키지화된 파일입니다 (PEP 426).</li>
<li><strong>"Module"</strong> : Python 런타임 코드 또는 스텁 타입 정보가 포함된 파일입니다.</li>
<li><strong>"Package"</strong> : Python 모듈의 네임스페이스를 제공하는 디렉터리 또는 디렉터리들입니다. (패키지와 배포(distribution)의 차이에 유의해야 합니다. 대부분의 배포는 하나의 패키지 이름을 따르지만, 일부 배포는 여러 패키지를 설치합니다.)</li>
</ul>
<h2>사양 (Specification)</h2>
<p>패키지에서 타입 지원을 위한 여러 동기 및 방법이 있습니다. 이 PEP는 타입 사용자가 생성하고자 하는 세 가지 유형의 패키지를 인식합니다.</p>
<ol>
<li>패키지 관리자가 타입 정보를 인라인으로 추가하고자 하는 경우.</li>
<li>패키지 관리자가 스텁 파일을 통해 타입 정보를 추가하고자 하는 경우.</li>
<li>서드파티 또는 패키지 관리자가 특정 패키지에 대한 스텁 파일을 공유하고자 하지만, 해당 관리자가 스텁 파일을 패키지 소스에 포함하고 싶지 않은 경우.</li>
</ol>
<p>이 PEP는 위 세 가지 시나리오를 모두 지원하며, 패키징 및 배포에 간단하게 추가할 수 있도록 하는 것을 목표로 합니다.</p>
<p>이 사양의 두 가지 주요 부분은 패키징 사양과 모듈 타입 정보 해석을 위한 해석 순서입니다. 타입 체킹 사양은 PEP 484의 <code>shared/typehints/pythonX.Y/</code> 사양을 대체하기 위한 것입니다.</p>
<p>새로운 서드파티 스텁 라이브러리는 typeshed에 추가되는 대신, 이 PEP에서 제안하는 서드파티 패키징 방법을 통해 스텁을 배포해야 합니다 (<code>SHOULD</code>). Typeshed는 계속 사용되지만, 관리자가 있는 경우 typeshed의 서드파티 스텁은 자체 패키지로 분리될 수 있습니다 (<code>MAY</code>).</p>
<h3>타입 정보 패키징 (Packaging Type Information)</h3>
<p>타입 정보 패키징 및 배포를 최대한 간단하고 쉽게 만들기 위해, 패키징 및 배포는 기존 프레임워크를 통해 이루어집니다.</p>
<p>코드의 타입 검사를 지원하려는 패키지 관리자는 패키지에 <code>py.typed</code>라는 마커 파일(marker file)을 추가해야 합니다 (<code>MUST</code>). 이 마커는 재귀적으로 적용됩니다. 즉, 최상위 패키지가 이 파일을 포함하면 모든 하위 패키지(sub-packages)도 타입 검사를 지원해야 합니다 (<code>MUST</code>). 이 파일을 패키지와 함께 설치하기 위해 관리자는 아래 예시와 같이 <code>distutils</code>의 <code>package_data</code>와 같은 기존 패키징 옵션을 사용할 수 있습니다.</p>
<p>Distutils 옵션 예시:</p>
<pre><code class="language-python">setup(
    ...,
    package_data = {
        'foopkg': ['py.typed'],
    },
    ...,
)
</code></pre>
<p>네임스페이스 패키지(namespace packages, PEP 420 참조)의 경우, <code>py.typed</code> 파일은 충돌을 피하고 명확성을 위해 네임스페이스의 서브모듈(submodules)에 있어야 합니다.</p>
<p>이 PEP는 모듈 전용 배포(module-only distributions) 또는 네임스페이스 패키지 내의 단일 파일 모듈(single-file modules)의 일부로 타입 정보를 배포하는 것을 지원하지 않습니다. 단일 파일 모듈은 패키지로 리팩터링되고, 위에서 설명한 대로 해당 패키지가 타입 지정을 지원함을 나타내야 합니다.</p>
<h3>스텁 전용 패키지 (Stub-only Packages)</h3>
<p>모든 타입 정보가 포함된 스텁 파일을 배포하려는 패키지 관리자의 경우, <code>*.pyi</code> 스텁 파일이 해당 <code>*.py</code> 파일과 함께 있는 것이 선호됩니다. 그러나 스텁은 별도의 패키지에 넣어 개별적으로 배포될 수도 있습니다. 서드파티 또한 스텁 파일을 배포하고자 할 때 이 방법을 유용하게 사용할 수 있습니다. 스텁 패키지의 이름은 <code>foopkg</code>라는 패키지에 대한 타입 스텁의 경우 <code>foopkg-stubs</code> 스키마를 따라야 합니다 (<code>MUST</code>). 스텁 전용 패키지의 경우 <code>-stubs</code>라는 이름 자체가 타입 정보의 소스임을 나타내기에 <code>py.typed</code> 마커를 추가할 필요가 없습니다.</p>
<p>스텁 파일을 배포하려는 서드파티는 패키지 관리자에게 패키지와 함께 배포하는 것에 대해 문의하는 것이 좋습니다. 관리자가 스텁 파일이나 인라인 타입 정보의 유지 보수 또는 패키징을 원하지 않는다면, 서드파티 스텁 전용 패키지를 생성할 수 있습니다.</p>
<p>또한, 스텁 전용 배포는 일반적인 의존성 데이터(dependency data)를 통해 런타임 패키지의 버전(들)을 명시함으로써 어떤 버전의 런타임 패키지를 지원하는지 나타내야 합니다 (<code>SHOULD</code>). 예를 들어, 스텁 패키지 <code>flyingcircus-stubs</code>는 <code>distutils</code> 기반 도구의 <code>install_requires</code> 또는 다른 패키징 도구의 동등한 기능을 통해 지원하는 런타임 <code>flyingcircus</code> 배포의 버전을 명시할 수 있습니다. pip 9.0에서는 <code>flyingcircus-stubs</code>를 업데이트하면 <code>flyingcircus</code>도 업데이트됩니다. pip 9.0에서는 <code>--upgrade-strategy=only-if-needed</code> 플래그를 사용할 수 있으며, pip 10.0에서는 이것이 기본 동작입니다.</p>
<p>네임스페이스 패키지(PEP 420 참조)의 경우, 스텁 전용 패키지는 루트 네임스페이스 패키지에만 <code>-stubs</code> 접미사를 사용해야 합니다. 모든 스텁 전용 네임스페이스 패키지는 <code>__init__.pyi</code> 파일을 생략해야 합니다. <code>py.typed</code> 마커 파일은 스텁 전용 패키지에는 필요하지 않지만, 인라인 타입이 있는 패키지와 유사하게 사용되는 경우 충돌을 피하고 명확성을 위해 네임스페이스의 서브모듈에 있어야 합니다.</p>
<p>예를 들어, <code>pentagon</code>과 <code>hexagon</code>이 <code>shapes.polygons</code> 네임스페이스 패키지 내에 설치되는 별도의 배포라면, 해당 타입 전용 배포는 다음과 같이 패키지를 구성해야 합니다.</p>
<pre><code>shapes-stubs/
└── polygons/
    └── pentagon/
        └── __init__.pyi
shapes-stubs/
└── polygons/
    └── hexagon/
        └── __init__.pyi
</code></pre>
<h3>타입 체커 모듈 해석 순서 (Type Checker Module Resolution Order)</h3>
<p>이 PEP를 지원하는 타입 체커가 타입 정보가 포함된 모듈을 해석하는 순서는 다음과 같아야 합니다 (<code>SHOULD</code>).</p>
<ol>
<li><strong>경로의 시작 부분에 수동으로 배치된 스텁 또는 Python 소스</strong> : 타입 체커는 사용자가 사용할 스텁을 완전히 제어하고, 패키지의 손상된 스텁/인라인 타입을 패치할 수 있도록 이를 제공해야 합니다 (<code>SHOULD</code>). mypy에서는 <code>$MYPYPATH</code> 환경 변수를 사용하여 이를 수행할 수 있습니다.</li>
<li><strong>사용자 코드</strong> : 타입 체커가 실행하는 파일입니다.</li>
<li><strong>스텁 패키지</strong> : 이 패키지는 설치된 인라인 패키지를 대체해야 합니다 (<code>SHOULD</code>). <code>foopkg</code> 패키지의 경우 <code>foopkg-stubs</code>에서 찾을 수 있습니다.</li>
<li><strong><code>py.typed</code> 마커 파일이 있는 패키지</strong> : 설치된 패키지를 재정의하는 것이 없고, 해당 패키지가 타입 검사를 선택(opt into)하는 경우, 패키지와 함께 번들된 타입(<code>.pyi</code> 타입 스텁 파일이든 <code>.py</code> 파일 내에 인라인으로 있든)이 사용되어야 합니다 (<code>SHOULD</code>).</li>
<li><strong>Typeshed (사용하는 경우)</strong> : 표준 라이브러리(stdlib) 타입과 여러 서드파티 라이브러리를 제공합니다.</li>
</ol>
<p>타입 체커가 3단계에서 원하는 모듈이 없는 스텁 전용 네임스페이스 패키지를 식별하면, 4단계/5단계로 계속 진행해야 합니다. 타입 체커는 <code>__init__.pyi</code> 파일의 부재를 통해 네임스페이스 패키지를 식별해야 합니다. 이는 다른 서브패키지가 인라인 방식과 스텁 전용 방식 중 독립적으로 선택할 수 있도록 합니다.</p>
<p>실행되는 Python 버전과 다른 Python 버전을 검사하는 타입 체커는 해당 Python 버전의 <code>site-packages</code> / <code>dist-packages</code>에서 타입 정보를 찾아야 합니다 (<code>MUST</code>). 이는 예를 들어 <code>pythonX.Y -c 'import site; print(site.getsitepackages())'</code> 와 같이 쿼리할 수 있습니다. 또한, 경로에 없는 경우 사용자가 특정 Python 바이너리를 지정할 수 있도록 타입 체커가 허용하는 것이 권장됩니다.</p>
<h3>부분적인 스텁 패키지 (Partial Stub Packages)</h3>
<p>많은 스텁 패키지는 특히 초기에 라이브러리의 타입 인터페이스 중 일부만 완성되어 있을 것입니다. 타입 검사 및 코드 편집기의 이점을 위해 패키지는 "부분적(partial)"일 수 있습니다. 이는 스텁 패키지에서 찾을 수 없는 모듈은 위 모듈 해석 순서의 4단계와 5단계, 즉 인라인 패키지 및 typeshed에서 찾아야 함을 의미합니다 (<code>SHOULD</code>).</p>
<p>타입 체커는 스텁 패키지와 런타임 패키지 또는 typeshed 디렉터리를 병합해야 합니다. 이는 스텁 패키지를 해당 런타임 패키지 또는 typeshed 폴더와 동일한 디렉터리에 복사하고 병합된 디렉터리 구조를 타입 검사하는 것과 기능적으로 동일하다고 생각할 수 있습니다. 따라서 타입 체커는 <code>*.pyi</code> 파일을 <code>*.py</code> 파일보다 먼저 확인하는 일반적인 해석 순서를 유지해야 합니다 (<code>MUST</code>).</p>
<p>스텁 패키지 배포가 부분적이라면 <code>py.typed</code> 파일에 <code>partial\n</code>을 포함해야 합니다 (<code>MUST</code>). 네임스페이스 패키지 내에서 배포되는 스텁 패키지의 경우(PEP 420 참조), <code>py.typed</code> 파일은 네임스페이스의 서브모듈에 있어야 합니다.</p>
<p>타입 체커는 여러 배포가 네임스페이스 패키지를 채울 수 있으므로 스텁 패키지 내의 네임스페이스 패키지를 불완전한 것으로 처리해야 합니다. 스텁 패키지 배포 내의 네임스페이스 패키지 내의 일반 패키지는 <code>partial\n</code>이 포함된 <code>py.typed</code> 파일이 포함되지 않는 한 완전한 것으로 간주됩니다.</p>
<h2>구현 (Implementation)</h2>
<p>타입 지원을 나타내는 제안된 방식은 완전히 하위 호환되며, 패키지 툴링을 수정할 필요가 없습니다. 인라인 타입이 있는 샘플 패키지 [typed_package]와 [stub_package]가 제공됩니다. 설치된 패키지의 메타데이터를 읽고 타입이 지정되지 않았는지(not typed), 인라인 타입이 지정되었는지(inline typed), 또는 스텁 패키지인지 보고하는 샘플 패키지 체커 [pkg_checker]도 있습니다.</p>
<p>mypy 타입 체커는 mypy 문서에서 확인할 수 있는 PEP 561 검색을 구현했습니다.</p>
<p>[numpy-stubs]는 <code>numpy</code> 배포를 위한 실제 스텁 전용 패키지의 예시입니다.</p>
<h2>감사 (Acknowledgements)</h2>
<p>이 PEP는 Ivan Levkivskyi, Jelle Zijlstra, Alyssa Coghlan, Daniel F Moisset, Andrey Vlasovskikh, Nathaniel Smith, 그리고 Guido van Rossum의 아이디어, 피드백, 지원 없이는 불가능했을 것입니다.</p>
<h2>버전 기록 (Version History)</h2>
<ul>
<li><strong>2023-01-13</strong> : 모듈 해석 순서의 4단계가 <code>py.typed</code> 마커 파일이 있는 모든 패키지(인라인 패키지뿐만 아니라)에 적용됨을 명확히 했습니다.</li>
<li><strong>2021-09-20</strong> : 스텁 전용 네임스페이스 패키지에 대한 기대치와 타입 체커 동작을 명확히 했습니다. 네임스페이스 패키지 내의 단일 파일 모듈 처리 방식을 명확히 했습니다.</li>
<li><strong>2018-07-09</strong> : 샘플 스텁 전용 패키지에 대한 링크를 추가했습니다.</li>
<li><strong>2018-06-19</strong> : 부분적 스텁 패키지가 런타임 패키지뿐만 아니라 typeshed도 확인할 수 있도록 했습니다.</li>
<li><strong>2018-05-15</strong> : 부분적 스텁 패키지 사양을 추가했습니다.</li>
<li><strong>2018-04-09</strong> : mypy 구현에 대한 참조를 추가했습니다. 스텁 패키지 우선순위를 명확히 했습니다.</li>
<li><strong>2018-02-02</strong> : 스텁 전용 패키지 접미사를 <code>_stubs</code>에서 <code>-stubs</code>로 변경했습니다. 스텁 전용 패키지에는 <code>py.typed</code>가 필요 없음을 명시했습니다. pip 및 스텁 패키지 업그레이드에 대한 참고 사항을 추가했습니다.</li>
<li><strong>2017-11-12</strong> : 기존 툴링만 사용하도록 다시 작성했습니다. 메타데이터에 타입 정보 종류를 명시할 필요가 없습니다. 마커 파일 이름이 <code>.typeinfo</code>에서 <code>py.typed</code>로 변경되었습니다.</li>
<li><strong>2017-11-10</strong> : 배포 메타데이터 대신 패키지 메타데이터를 사용하도록 사양을 다시 작성했습니다. 스텁 전용 패키지를 제거하고 서드파티 패키지 사양에 병합했습니다. 타입 체커가 런타임 버전을 검사하는 것에 대한 제안을 제거했습니다. PEP 변경 사항을 반영하여 구현을 업데이트했습니다.</li>
<li><strong>2017-10-26</strong> : 구현 참조를 추가했습니다. 감사 및 버전 기록을 추가했습니다.</li>
<li><strong>2017-10-06</strong> : <code>distutils</code> 특정 명령 대신 <code>.distinfo/METADATA</code>를 사용하도록 다시 작성했습니다. 서드파티 스텁 패키지의 버전 관리를 명확히 했습니다.</li>
<li><strong>2017-09-11</strong> : 현재 해결책 및 typeshed에 대한 정보를 추가했습니다. 배경(rationale)을 명확히 했습니다.</li>
</ul>
<h2>참조 (References)</h2>
<ul>
<li>Typeshed</li>
<li>타입 체커의 예시 구현 (mypy docs)</li>
<li>[stub_package] 스텁 전용 패키지</li>
<li>[typed_package] 샘플 타입 지정 패키지</li>
<li>[numpy-stubs] numpy용 스텁</li>
<li>[pkg_checker] 샘플 패키지 체커</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/560/">[Final] PEP 560 - Core support for typing module and generic types</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 561 - Distributing and Packaging Type Information</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/562/">[Final] PEP 562 - Module __getattr__ and __dir__</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/edf391eeca43d999.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-167bfed393319721.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-eb985a9c6ac1f073.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/561\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/edf391eeca43d999.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"q8gP0CJE_7T-dGWg_B3Wl\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/561/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/561\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"561\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/561\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T46a0,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0561/\"\u003ePEP 561 - Distributing and Packaging Type Information\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 09-Sep-2017\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 561 – 타입 정보 배포 및 패키징\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003ePEP 484는 점진적이고 쉽게 채택할 수 있는 목표를 가지고 Python에 타입 힌팅(Type Hinting)을 도입했습니다. 현재 타입 정보는 수동으로 배포되어야 합니다. 이 PEP는 기존 툴링(tooling)을 활용하여 최소한의 작업으로 타입 정보를 패키징하고 배포할 수 있는 표준화된 방법을 제공하며, 타입 체커(Type Checker)가 모듈을 해석하고 타입 검사를 위해 이 정보를 수집하는 순서를 정의합니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003e현재 패키지 작성자는 인라인(inline) 타입 정보가 포함된 코드를 배포하고자 합니다. 또한, 관리자는 최신 주석 구문(annotation syntax)을 사용하면서 Python 2 호환성을 유지하기 위해 스텁(stub) 파일을 배포하기를 원합니다. 그러나 타입 정보가 포함된 패키지를 배포하는 표준화된 방법이 없습니다. 또한, 개인적으로 스텁 파일을 제공하고자 한다면 MYPYPATH 또는 그에 상응하는 것을 설정하여 스텁 파일을 수동으로 지정하는 방법밖에 없었습니다. 만약 패키지를 공개적으로 배포할 수 있다면 typeshed에 추가할 수 있지만, 이는 확장성이 떨어지고 typeshed 관리자에게 부담이 됩니다. 또한, 스텁 파일의 버그 수정이 typeshed를 사용하는 도구의 릴리스에 종속됩니다.\u003c/p\u003e\n\u003cp\u003ePEP 484는 타입 정보 배포에 대한 간략한 섹션을 가지고 있습니다. 이 섹션에서는 스텁 파일을 배포하기 위해 \u003ccode\u003eshared/typehints/pythonX.Y/\u003c/code\u003e 사용을 권장합니다. 그러나 각 서드파티 라이브러리(third party library)에 스텁 파일 경로를 수동으로 추가하는 것은 확장성이 떨어집니다. 가장 간단한 접근 방식은 \u003ccode\u003esite-packages\u003c/code\u003e를 \u003ccode\u003eMYPYPATH\u003c/code\u003e에 추가하는 것이었지만, 이는 동적(dynamic)인 패키지(예: SQLAlchemy, Django)에서 타입 체커가 실패하는 원인이 됩니다.\u003c/p\u003e\n\u003ch2\u003e용어 정의 (Definition of Terms)\u003c/h2\u003e\n\u003cp\u003e\"MAY\", \"MUST\", \"SHOULD\", \"SHOULD NOT\"의 정의는 RFC 2119에 기술된 대로 해석됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\"inline\"\u003c/strong\u003e : 타입이 PEP 526 및 PEP 3107 구문(\u003ccode\u003e*.py\u003c/code\u003e 파일)을 사용하여 런타임 코드의 일부로 포함된 경우를 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\"stubs\"\u003c/strong\u003e : 런타임 코드는 없고 타입 정보만 포함하는 파일(\u003ccode\u003e*.pyi\u003c/code\u003e 파일)을 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\"Distributions\"\u003c/strong\u003e : 릴리스를 발행하고 배포하는 데 사용되는 패키지화된 파일입니다 (PEP 426).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\"Module\"\u003c/strong\u003e : Python 런타임 코드 또는 스텁 타입 정보가 포함된 파일입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\"Package\"\u003c/strong\u003e : Python 모듈의 네임스페이스를 제공하는 디렉터리 또는 디렉터리들입니다. (패키지와 배포(distribution)의 차이에 유의해야 합니다. 대부분의 배포는 하나의 패키지 이름을 따르지만, 일부 배포는 여러 패키지를 설치합니다.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003cp\u003e패키지에서 타입 지원을 위한 여러 동기 및 방법이 있습니다. 이 PEP는 타입 사용자가 생성하고자 하는 세 가지 유형의 패키지를 인식합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e패키지 관리자가 타입 정보를 인라인으로 추가하고자 하는 경우.\u003c/li\u003e\n\u003cli\u003e패키지 관리자가 스텁 파일을 통해 타입 정보를 추가하고자 하는 경우.\u003c/li\u003e\n\u003cli\u003e서드파티 또는 패키지 관리자가 특정 패키지에 대한 스텁 파일을 공유하고자 하지만, 해당 관리자가 스텁 파일을 패키지 소스에 포함하고 싶지 않은 경우.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 PEP는 위 세 가지 시나리오를 모두 지원하며, 패키징 및 배포에 간단하게 추가할 수 있도록 하는 것을 목표로 합니다.\u003c/p\u003e\n\u003cp\u003e이 사양의 두 가지 주요 부분은 패키징 사양과 모듈 타입 정보 해석을 위한 해석 순서입니다. 타입 체킹 사양은 PEP 484의 \u003ccode\u003eshared/typehints/pythonX.Y/\u003c/code\u003e 사양을 대체하기 위한 것입니다.\u003c/p\u003e\n\u003cp\u003e새로운 서드파티 스텁 라이브러리는 typeshed에 추가되는 대신, 이 PEP에서 제안하는 서드파티 패키징 방법을 통해 스텁을 배포해야 합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e). Typeshed는 계속 사용되지만, 관리자가 있는 경우 typeshed의 서드파티 스텁은 자체 패키지로 분리될 수 있습니다 (\u003ccode\u003eMAY\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003e타입 정보 패키징 (Packaging Type Information)\u003c/h3\u003e\n\u003cp\u003e타입 정보 패키징 및 배포를 최대한 간단하고 쉽게 만들기 위해, 패키징 및 배포는 기존 프레임워크를 통해 이루어집니다.\u003c/p\u003e\n\u003cp\u003e코드의 타입 검사를 지원하려는 패키지 관리자는 패키지에 \u003ccode\u003epy.typed\u003c/code\u003e라는 마커 파일(marker file)을 추가해야 합니다 (\u003ccode\u003eMUST\u003c/code\u003e). 이 마커는 재귀적으로 적용됩니다. 즉, 최상위 패키지가 이 파일을 포함하면 모든 하위 패키지(sub-packages)도 타입 검사를 지원해야 합니다 (\u003ccode\u003eMUST\u003c/code\u003e). 이 파일을 패키지와 함께 설치하기 위해 관리자는 아래 예시와 같이 \u003ccode\u003edistutils\u003c/code\u003e의 \u003ccode\u003epackage_data\u003c/code\u003e와 같은 기존 패키징 옵션을 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eDistutils 옵션 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003esetup(\n    ...,\n    package_data = {\n        'foopkg': ['py.typed'],\n    },\n    ...,\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e네임스페이스 패키지(namespace packages, PEP 420 참조)의 경우, \u003ccode\u003epy.typed\u003c/code\u003e 파일은 충돌을 피하고 명확성을 위해 네임스페이스의 서브모듈(submodules)에 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 모듈 전용 배포(module-only distributions) 또는 네임스페이스 패키지 내의 단일 파일 모듈(single-file modules)의 일부로 타입 정보를 배포하는 것을 지원하지 않습니다. 단일 파일 모듈은 패키지로 리팩터링되고, 위에서 설명한 대로 해당 패키지가 타입 지정을 지원함을 나타내야 합니다.\u003c/p\u003e\n\u003ch3\u003e스텁 전용 패키지 (Stub-only Packages)\u003c/h3\u003e\n\u003cp\u003e모든 타입 정보가 포함된 스텁 파일을 배포하려는 패키지 관리자의 경우, \u003ccode\u003e*.pyi\u003c/code\u003e 스텁 파일이 해당 \u003ccode\u003e*.py\u003c/code\u003e 파일과 함께 있는 것이 선호됩니다. 그러나 스텁은 별도의 패키지에 넣어 개별적으로 배포될 수도 있습니다. 서드파티 또한 스텁 파일을 배포하고자 할 때 이 방법을 유용하게 사용할 수 있습니다. 스텁 패키지의 이름은 \u003ccode\u003efoopkg\u003c/code\u003e라는 패키지에 대한 타입 스텁의 경우 \u003ccode\u003efoopkg-stubs\u003c/code\u003e 스키마를 따라야 합니다 (\u003ccode\u003eMUST\u003c/code\u003e). 스텁 전용 패키지의 경우 \u003ccode\u003e-stubs\u003c/code\u003e라는 이름 자체가 타입 정보의 소스임을 나타내기에 \u003ccode\u003epy.typed\u003c/code\u003e 마커를 추가할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e스텁 파일을 배포하려는 서드파티는 패키지 관리자에게 패키지와 함께 배포하는 것에 대해 문의하는 것이 좋습니다. 관리자가 스텁 파일이나 인라인 타입 정보의 유지 보수 또는 패키징을 원하지 않는다면, 서드파티 스텁 전용 패키지를 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, 스텁 전용 배포는 일반적인 의존성 데이터(dependency data)를 통해 런타임 패키지의 버전(들)을 명시함으로써 어떤 버전의 런타임 패키지를 지원하는지 나타내야 합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e). 예를 들어, 스텁 패키지 \u003ccode\u003eflyingcircus-stubs\u003c/code\u003e는 \u003ccode\u003edistutils\u003c/code\u003e 기반 도구의 \u003ccode\u003einstall_requires\u003c/code\u003e 또는 다른 패키징 도구의 동등한 기능을 통해 지원하는 런타임 \u003ccode\u003eflyingcircus\u003c/code\u003e 배포의 버전을 명시할 수 있습니다. pip 9.0에서는 \u003ccode\u003eflyingcircus-stubs\u003c/code\u003e를 업데이트하면 \u003ccode\u003eflyingcircus\u003c/code\u003e도 업데이트됩니다. pip 9.0에서는 \u003ccode\u003e--upgrade-strategy=only-if-needed\u003c/code\u003e 플래그를 사용할 수 있으며, pip 10.0에서는 이것이 기본 동작입니다.\u003c/p\u003e\n\u003cp\u003e네임스페이스 패키지(PEP 420 참조)의 경우, 스텁 전용 패키지는 루트 네임스페이스 패키지에만 \u003ccode\u003e-stubs\u003c/code\u003e 접미사를 사용해야 합니다. 모든 스텁 전용 네임스페이스 패키지는 \u003ccode\u003e__init__.pyi\u003c/code\u003e 파일을 생략해야 합니다. \u003ccode\u003epy.typed\u003c/code\u003e 마커 파일은 스텁 전용 패키지에는 필요하지 않지만, 인라인 타입이 있는 패키지와 유사하게 사용되는 경우 충돌을 피하고 명확성을 위해 네임스페이스의 서브모듈에 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003epentagon\u003c/code\u003e과 \u003ccode\u003ehexagon\u003c/code\u003e이 \u003ccode\u003eshapes.polygons\u003c/code\u003e 네임스페이스 패키지 내에 설치되는 별도의 배포라면, 해당 타입 전용 배포는 다음과 같이 패키지를 구성해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eshapes-stubs/\n└── polygons/\n    └── pentagon/\n        └── __init__.pyi\nshapes-stubs/\n└── polygons/\n    └── hexagon/\n        └── __init__.pyi\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e타입 체커 모듈 해석 순서 (Type Checker Module Resolution Order)\u003c/h3\u003e\n\u003cp\u003e이 PEP를 지원하는 타입 체커가 타입 정보가 포함된 모듈을 해석하는 순서는 다음과 같아야 합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e).\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e경로의 시작 부분에 수동으로 배치된 스텁 또는 Python 소스\u003c/strong\u003e : 타입 체커는 사용자가 사용할 스텁을 완전히 제어하고, 패키지의 손상된 스텁/인라인 타입을 패치할 수 있도록 이를 제공해야 합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e). mypy에서는 \u003ccode\u003e$MYPYPATH\u003c/code\u003e 환경 변수를 사용하여 이를 수행할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e사용자 코드\u003c/strong\u003e : 타입 체커가 실행하는 파일입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e스텁 패키지\u003c/strong\u003e : 이 패키지는 설치된 인라인 패키지를 대체해야 합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e). \u003ccode\u003efoopkg\u003c/code\u003e 패키지의 경우 \u003ccode\u003efoopkg-stubs\u003c/code\u003e에서 찾을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003epy.typed\u003c/code\u003e 마커 파일이 있는 패키지\u003c/strong\u003e : 설치된 패키지를 재정의하는 것이 없고, 해당 패키지가 타입 검사를 선택(opt into)하는 경우, 패키지와 함께 번들된 타입(\u003ccode\u003e.pyi\u003c/code\u003e 타입 스텁 파일이든 \u003ccode\u003e.py\u003c/code\u003e 파일 내에 인라인으로 있든)이 사용되어야 합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTypeshed (사용하는 경우)\u003c/strong\u003e : 표준 라이브러리(stdlib) 타입과 여러 서드파티 라이브러리를 제공합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e타입 체커가 3단계에서 원하는 모듈이 없는 스텁 전용 네임스페이스 패키지를 식별하면, 4단계/5단계로 계속 진행해야 합니다. 타입 체커는 \u003ccode\u003e__init__.pyi\u003c/code\u003e 파일의 부재를 통해 네임스페이스 패키지를 식별해야 합니다. 이는 다른 서브패키지가 인라인 방식과 스텁 전용 방식 중 독립적으로 선택할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e실행되는 Python 버전과 다른 Python 버전을 검사하는 타입 체커는 해당 Python 버전의 \u003ccode\u003esite-packages\u003c/code\u003e / \u003ccode\u003edist-packages\u003c/code\u003e에서 타입 정보를 찾아야 합니다 (\u003ccode\u003eMUST\u003c/code\u003e). 이는 예를 들어 \u003ccode\u003epythonX.Y -c 'import site; print(site.getsitepackages())'\u003c/code\u003e 와 같이 쿼리할 수 있습니다. 또한, 경로에 없는 경우 사용자가 특정 Python 바이너리를 지정할 수 있도록 타입 체커가 허용하는 것이 권장됩니다.\u003c/p\u003e\n\u003ch3\u003e부분적인 스텁 패키지 (Partial Stub Packages)\u003c/h3\u003e\n\u003cp\u003e많은 스텁 패키지는 특히 초기에 라이브러리의 타입 인터페이스 중 일부만 완성되어 있을 것입니다. 타입 검사 및 코드 편집기의 이점을 위해 패키지는 \"부분적(partial)\"일 수 있습니다. 이는 스텁 패키지에서 찾을 수 없는 모듈은 위 모듈 해석 순서의 4단계와 5단계, 즉 인라인 패키지 및 typeshed에서 찾아야 함을 의미합니다 (\u003ccode\u003eSHOULD\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003e타입 체커는 스텁 패키지와 런타임 패키지 또는 typeshed 디렉터리를 병합해야 합니다. 이는 스텁 패키지를 해당 런타임 패키지 또는 typeshed 폴더와 동일한 디렉터리에 복사하고 병합된 디렉터리 구조를 타입 검사하는 것과 기능적으로 동일하다고 생각할 수 있습니다. 따라서 타입 체커는 \u003ccode\u003e*.pyi\u003c/code\u003e 파일을 \u003ccode\u003e*.py\u003c/code\u003e 파일보다 먼저 확인하는 일반적인 해석 순서를 유지해야 합니다 (\u003ccode\u003eMUST\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003e스텁 패키지 배포가 부분적이라면 \u003ccode\u003epy.typed\u003c/code\u003e 파일에 \u003ccode\u003epartial\\n\u003c/code\u003e을 포함해야 합니다 (\u003ccode\u003eMUST\u003c/code\u003e). 네임스페이스 패키지 내에서 배포되는 스텁 패키지의 경우(PEP 420 참조), \u003ccode\u003epy.typed\u003c/code\u003e 파일은 네임스페이스의 서브모듈에 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e타입 체커는 여러 배포가 네임스페이스 패키지를 채울 수 있으므로 스텁 패키지 내의 네임스페이스 패키지를 불완전한 것으로 처리해야 합니다. 스텁 패키지 배포 내의 네임스페이스 패키지 내의 일반 패키지는 \u003ccode\u003epartial\\n\u003c/code\u003e이 포함된 \u003ccode\u003epy.typed\u003c/code\u003e 파일이 포함되지 않는 한 완전한 것으로 간주됩니다.\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e타입 지원을 나타내는 제안된 방식은 완전히 하위 호환되며, 패키지 툴링을 수정할 필요가 없습니다. 인라인 타입이 있는 샘플 패키지 [typed_package]와 [stub_package]가 제공됩니다. 설치된 패키지의 메타데이터를 읽고 타입이 지정되지 않았는지(not typed), 인라인 타입이 지정되었는지(inline typed), 또는 스텁 패키지인지 보고하는 샘플 패키지 체커 [pkg_checker]도 있습니다.\u003c/p\u003e\n\u003cp\u003emypy 타입 체커는 mypy 문서에서 확인할 수 있는 PEP 561 검색을 구현했습니다.\u003c/p\u003e\n\u003cp\u003e[numpy-stubs]는 \u003ccode\u003enumpy\u003c/code\u003e 배포를 위한 실제 스텁 전용 패키지의 예시입니다.\u003c/p\u003e\n\u003ch2\u003e감사 (Acknowledgements)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 Ivan Levkivskyi, Jelle Zijlstra, Alyssa Coghlan, Daniel F Moisset, Andrey Vlasovskikh, Nathaniel Smith, 그리고 Guido van Rossum의 아이디어, 피드백, 지원 없이는 불가능했을 것입니다.\u003c/p\u003e\n\u003ch2\u003e버전 기록 (Version History)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e2023-01-13\u003c/strong\u003e : 모듈 해석 순서의 4단계가 \u003ccode\u003epy.typed\u003c/code\u003e 마커 파일이 있는 모든 패키지(인라인 패키지뿐만 아니라)에 적용됨을 명확히 했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2021-09-20\u003c/strong\u003e : 스텁 전용 네임스페이스 패키지에 대한 기대치와 타입 체커 동작을 명확히 했습니다. 네임스페이스 패키지 내의 단일 파일 모듈 처리 방식을 명확히 했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2018-07-09\u003c/strong\u003e : 샘플 스텁 전용 패키지에 대한 링크를 추가했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2018-06-19\u003c/strong\u003e : 부분적 스텁 패키지가 런타임 패키지뿐만 아니라 typeshed도 확인할 수 있도록 했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2018-05-15\u003c/strong\u003e : 부분적 스텁 패키지 사양을 추가했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2018-04-09\u003c/strong\u003e : mypy 구현에 대한 참조를 추가했습니다. 스텁 패키지 우선순위를 명확히 했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2018-02-02\u003c/strong\u003e : 스텁 전용 패키지 접미사를 \u003ccode\u003e_stubs\u003c/code\u003e에서 \u003ccode\u003e-stubs\u003c/code\u003e로 변경했습니다. 스텁 전용 패키지에는 \u003ccode\u003epy.typed\u003c/code\u003e가 필요 없음을 명시했습니다. pip 및 스텁 패키지 업그레이드에 대한 참고 사항을 추가했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2017-11-12\u003c/strong\u003e : 기존 툴링만 사용하도록 다시 작성했습니다. 메타데이터에 타입 정보 종류를 명시할 필요가 없습니다. 마커 파일 이름이 \u003ccode\u003e.typeinfo\u003c/code\u003e에서 \u003ccode\u003epy.typed\u003c/code\u003e로 변경되었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2017-11-10\u003c/strong\u003e : 배포 메타데이터 대신 패키지 메타데이터를 사용하도록 사양을 다시 작성했습니다. 스텁 전용 패키지를 제거하고 서드파티 패키지 사양에 병합했습니다. 타입 체커가 런타임 버전을 검사하는 것에 대한 제안을 제거했습니다. PEP 변경 사항을 반영하여 구현을 업데이트했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2017-10-26\u003c/strong\u003e : 구현 참조를 추가했습니다. 감사 및 버전 기록을 추가했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2017-10-06\u003c/strong\u003e : \u003ccode\u003edistutils\u003c/code\u003e 특정 명령 대신 \u003ccode\u003e.distinfo/METADATA\u003c/code\u003e를 사용하도록 다시 작성했습니다. 서드파티 스텁 패키지의 버전 관리를 명확히 했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2017-09-11\u003c/strong\u003e : 현재 해결책 및 typeshed에 대한 정보를 추가했습니다. 배경(rationale)을 명확히 했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e참조 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTypeshed\u003c/li\u003e\n\u003cli\u003e타입 체커의 예시 구현 (mypy docs)\u003c/li\u003e\n\u003cli\u003e[stub_package] 스텁 전용 패키지\u003c/li\u003e\n\u003cli\u003e[typed_package] 샘플 타입 지정 패키지\u003c/li\u003e\n\u003cli\u003e[numpy-stubs] numpy용 스텁\u003c/li\u003e\n\u003cli\u003e[pkg_checker] 샘플 패키지 체커\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1734,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 561 - Distributing and Packaging Type Information\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:46:31+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/560/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 560 - Core support for typing module and generic types\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 561 - Distributing and Packaging Type Information\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/562/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 562 - Module __getattr__ and __dir__\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>