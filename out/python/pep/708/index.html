<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Provisional] PEP 708 - Extending the Repository API to Mitigate Dependency Confusion Attacks</h1><div class="page__meta"><time dateTime="2025-09-27 13:10:38+0900">2025년 9월 27일</time><span class="ml-4">수정: <!-- -->2025년 9월 27일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0708/">PEP 708 - Extending the Repository API to Mitigate Dependency Confusion Attacks</a></p>
<p><strong>상태:</strong> Provisional | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 20-Feb-2023</p>
</blockquote>
<p>PEP 708: 의존성 혼란 공격 완화를 위한 저장소 API 확장 번역 및 요약</p>
<h2>요약 (Abstract)</h2>
<p>의존성 혼란 공격(Dependency confusion attacks)은 사용자가 예상한 패키지 대신 악성 패키지가 설치되는 형태로, 점점 더 흔해지는 공급망 위협입니다. Python 의존성에 대한 대부분의 공격(최근 PyTorch 사건 포함)은 여러 패키지 저장소에서 발생하는데, 특정 저장소(예: 사용자 정의 인덱스)에서 올 것으로 예상되는 의존성이 다른 저장소(예: PyPI)에서 설치되는 경우입니다.</p>
<p>이 문제를 해결하기 위해 PEP 708은 Simple Repository API를 확장하여 저장소 운영자가 자신의 저장소에 있는 프로젝트가 다른 저장소의 프로젝트를 "추적(tracks)"하거나, 프로젝트가 여러 저장소에 걸쳐 네임스페이스를 확장할 수 있도록 제안합니다. 이러한 기능은 설치 프로그램이 특정 저장소 조합에서 제공되는 프로젝트가 예상된 것이고 허용되어야 하는 경우와 그렇지 않은 경우를 판단하여, 후자의 경우 사용자 보호를 위해 설치를 오류로 중단시킬 수 있게 합니다.</p>
<h2>동기 (Motivation)</h2>
<p>오랫동안 "의존성 혼란(dependency confusion)" 공격이라는 종류의 공격이 존재해왔는데, 이는 사용자가 패키지 A를 기대했지만 대신 패키지 B를 받게 되는 상황으로 요약할 수 있습니다. Python에서는 거의 항상 여러 저장소(PyPI 기본값 포함) 설정 때문에 발생합니다. 사용자가 저장소 X에서 패키지 A를 기대했지만, 누군가 저장소 Y에 동일한 이름으로 악성 패키지 B를 게시할 수 있기 때문입니다.</p>
<p>의존성 혼란 공격은 오래전부터 가능했지만, 최근 성공적으로 실행된 사례들이 공개되면서 주목받고 있습니다. 대표적인 예는 PyTorch 프로젝트의 내부 패키지인 <code>torchtriton</code> 사례입니다. 이 패키지는 <code>https://download.pytorch.org/</code>에 있는 PyTorch 저장소에서만 설치되도록 의도되었지만, PyPI에 해당 이름이 등록되지 않아 공격자가 같은 이름을 사용하여 악성 버전을 게시할 수 있었습니다.</p>
<p>현재 이러한 공격을 완화하는 여러 방법이 있지만, 모두 최종 사용자가 스스로 보호하기 위해 추가적인 노력을 기울여야 하며, 기본적으로 보호되지 않습니다. 이는 대부분의 사용자가 이러한 공격 유형을 인지하더라도 여전히 취약한 상태로 남아있을 가능성이 높다는 것을 의미합니다.</p>
<p>궁극적으로 이러한 공격의 근본 원인은 모든 Python 패키지 이름이 나오는 전역적으로 고유한(globally unique) 네임스페이스가 없다는 사실에서 기인합니다. 대신 각 저장소는 자체적인 고유한 네임스페이스이며, <code>spam</code>과 같은 "추상적인" 이름을 설치하도록 주어지면, 설치 프로그램은 암묵적으로 이를 <code>pypi.org:spam</code> 또는 <code>example.com:spam</code>과 같은 "구체적인" 이름으로 변환해야 합니다. 현재 Python 설치 도구의 표준 동작은 이러한 여러 네임스페이스를 모든 네임스페이스의 파일을 포함하는 하나의 네임스페이스로 암묵적으로 통합하는 것입니다.</p>
<p>네임스페이스를 통합하는 것이 예상된 동작이라는 가정은, 다른 저장소에 있는 동일한 이름의 패키지가 서로 다른 당사자에 의해 작성될 때(예: <code>torchtriton</code> 사례), 의존성 혼란 공격이 가능해진다는 것을 의미합니다. 또한, 두 저장소를 하나의 네임스페이스로 병합하려는 유효한 사용 사례와 두 저장소를 별개의 네임스페이스로 처리하려는 유효한 사용 사례가 모두 존재하므로 "정답"이 없습니다. 따라서 설치 프로그램은 항상 병합하거나 절대 병합하지 않는 규칙 대신, 여러 저장소의 네임스페이스를 언제 병합하고 언제 병합하지 않아야 할지 결정할 수 있는 메커니즘이 필요합니다.</p>
<p>이 기능은 최종 사용자에게 직접 전달될 수도 있지만, 저장소 사양을 확장하여 저장소가 안전한 경우를 표시할 수 있게 함으로써, 개별 프로젝트와 저장소가 여러 별개의 네임스페이스에 걸쳐 자연스럽게 존재하더라도 "기본적으로 작동"할 수 있도록 하고, 설치 프로그램이 기본적으로 안전할 수 있는 능력을 유지할 수 있습니다.</p>
<p>이 PEP는 의존성 혼란 공격을 단독으로 해결하지는 않지만, 설치 프로그램이 유효하고 안전한 사용 사례에 과도한 피해를 주지 않으면서 공격을 방지할 수 있는 충분한 정보를 제공합니다.</p>
<h2>이론적 근거 (Rationale)</h2>
<p>이 PEP는 저장소 간 이름 병합에 대한 두 가지 광범위한 사용 사례를 가능하게 합니다.</p>
<ol>
<li>
<p><strong>다른 저장소에 정의된 이름을 확장하는 경우:</strong> 한 저장소가 자체 이름을 정의하지 않고, 다른 저장소에 정의된 이름을 확장하는 경우입니다. 이는 프로젝트가 한 저장소에서 다른 저장소로 미러링되거나(Bandersnatch 참조), 저장소가 특정 플랫폼에 대한 보조 아티팩트를 제공하는 경우(Piwheels 참조)에 흔히 발생합니다.
이 경우 확장되는 저장소나 프로젝트는 자신이 확장되고 있는지, 누구에 의해 확장되는지 알지 못할 수 있으므로, "확장하는" 저장소 자체에 존재하지 않는 정보에 의존할 수 없습니다.</p>
</li>
<li>
<p><strong>프로젝트가 여러 저장소에 게시하는 경우:</strong> 프로젝트가 하나의 "주요" 저장소에 게시하지만, 추가 플랫폼, GPU, CPU 등을 위한 바이너리를 제공하는 추가 저장소를 갖는 경우입니다. 현재 Wheel 태그는 이러한 유형의 바이너리 호환성을 충분히 표현할 수 없으므로, 이를 사용하려는 프로젝트는 여러 저장소를 설정하고 사용자가 자신의 플랫폼, GPU, CPU 등에 맞는 올바른 바이너리를 얻기 위해 수동으로 구성하도록 해야 합니다.
이 사용 사례는 첫 번째와 유사하지만, 누가 정보를 제공하고 그들의 신뢰 수준이 어떤지에 대한 중요한 차이점이 있어 별개의 사용 사례가 됩니다.</p>
</li>
</ol>
<p>사용자가 특정 저장소를 구성할 때(또는 기본값에 의존할 때) 어떤 저장소를 의미하는지에 대한 모호성은 없습니다. 저장소는 URL로 식별되며, 도메인 시스템을 통해 URL은 전역적으로 고유한 식별자입니다. 이러한 모호성 부족은 설치 프로그램이 저장소 운영자를 신뢰할 수 있고, 제공하는 메타데이터를 유효성 검사 없이 신뢰할 수 있다고 가정할 수 있음을 의미합니다.</p>
<p>반대로, 설치 프로그램이 여러 저장소에서 동일한 이름을 발견하면 어떤 저장소를 신뢰해야 하는지에 대한 모호성이 발생합니다. 이러한 모호성 때문에 설치 프로그램은 어느 저장소의 프로젝트 소유자도 신뢰할 수 있다고 가정할 수 없으며, 실제로 동일한 프로젝트인지, 또는 의존성 혼란 공격이 아닌지 유효성 검사를 해야 합니다.</p>
<p>설치 프로그램이 여러 저장소 간의 메타데이터를 검증할 방법이 없다면, 프로젝트는 이 사용 사례를 안전하게 지원하기 위해 저장소 운영자가 되어야 할 것입니다. 이는 나쁜 선택은 아니지만, 저장소가 프로젝트 소유자가 이 관계를 안전하게 표현할 수 있는 방법을 제공하지 않으면, 저장소 운영자의 메타데이터를 사용하도록 유도되어 원래의 불안정성이 재도입될 위험이 있습니다.</p>
<h2>사양 (Specification)</h2>
<p>이 사양은 Simple Repository API 버전 1.2의 변경 사항을 정의하며, 두 가지 새로운 메타데이터 항목인 "Repository 'Tracks'" 및 "'Alternate Locations'"를 추가합니다.</p>
<h3>Repository "Tracks" Metadata (저장소 "추적" 메타데이터)</h3>
<p>하나의 저장소가 다른 저장소에서 호스팅되는 프로젝트를 "확장"하기 위해, 확장하는 저장소는 특정 프로젝트가 다른 저장소 또는 여러 저장소의 프로젝트를 "추적"한다고 선언할 수 있습니다. 이는 확장하는 프로젝트 및 저장소의 URL을 추가함으로써 이루어집니다.</p>
<p>이는 JSON에서는 <code>meta.tracks</code> 키로, HTML에서는 프로젝트별 URL(<code>$root/$project/</code>)에 <code>pypi:tracks</code>라는 <code>meta</code> 요소로 노출됩니다.</p>
<p>이 메타데이터를 사용할 때 반드시 유지되어야 할 몇 가지 중요한 속성이 있습니다:</p>
<ul>
<li>이것은 저장소를 사용하는 개별 게시자가 아닌, <strong>저장소 운영자 자신</strong>의 통제하에 있어야 합니다.
<ul>
<li>"저장소 운영자"는 특정 저장소의 전체 네임스페이스를 관리하는 사람도 포함할 수 있습니다. 예를 들어, 한 엔티티가 소프트웨어를 운영하지만 다른 엔티티가 저장소의 전체 네임스페이스를 소유/관리하는 호스팅된 저장소 서비스와 같은 상황이 해당됩니다.</li>
</ul>
</li>
<li>모든 URL은 확장하는 저장소의 프로젝트와 **동일한 "프로젝트"**를 나타내야 합니다.
<ul>
<li>이는 동일한 파일을 제공해야 한다는 의미는 아닙니다. 다른 플랫폼용으로 빌드된 바이너리, 로컬 패치가 적용된 복사본 등을 포함하는 것이 유효합니다. 이는 궁극적으로 사용자와 저장소 운영자가 "동일한" 프로젝트가 무엇을 구성하는지에 대한 기대에 달려 있으므로 의도적으로 모호하게 남겨두었습니다.</li>
</ul>
</li>
<li>네임스페이스를 "소유"하는 저장소를 가리켜야 하며, 해당 네임스페이스를 추적하는 다른 저장소를 가리켜서는 안 됩니다.</li>
<li><strong>정확히 동일한 이름</strong>(정규화 후)을 가진 프로젝트를 가리켜야 합니다.</li>
<li>확장된 저장소의 기본 URL이 아닌, <strong>해당 프로젝트의 실제 URL</strong>을 가리켜야 합니다.</li>
<li>저장소의 모든 이름이 동일한 저장소를 추적하거나, 아예 어떤 저장소도 추적해야 하는 것은 아닙니다. 일부 이름은 저장소를 추적하고 일부 이름은 추적하지 않는 혼합 사용 저장소도 명시적으로 허용됩니다.</li>
</ul>
<p><strong>JSON 예시:</strong></p>
<pre><code class="language-json">{
  "meta": {
    "api-version": "1.2",
    "tracks": ["https://pypi.org/simple/holygrail/", "https://test.pypi.org/simple/holygrail/"]
  },
  "name": "holygrail",
  "files": [
    {
      "filename": "holygrail-1.0.tar.gz",
      "url": "https://example.com/files/holygrail-1.0.tar.gz",
      "hashes": {"sha256": "...", "blake2b": "..."},
      "requires-python": ">=3.7",
      "yanked": "Had a vulnerability"
    },
    {
      "filename": "holygrail-1.0-py3-none-any.whl",
      "url": "https://example.com/files/holygrail-1.0-py3-none-any.whl",
      "hashes": {"sha256": "...", "blake2b": "..."},
      "requires-python": ">=3.7",
      "dist-info-metadata": true
    }
  ]
}
</code></pre>
<p><strong>HTML 예시:</strong></p>
<pre><code class="language-html">&#x3C;!DOCTYPE html>
&#x3C;html>
&#x3C;head>
&#x3C;meta name="pypi:repository-version" content="1.2">
&#x3C;meta name="pypi:tracks" content="https://pypi.org/simple/holygrail/">
&#x3C;meta name="pypi:tracks" content="https://test.pypi.org/simple/holygrail/">
&#x3C;/head>
&#x3C;body>
&#x3C;a href="https://example.com/files/holygrail-1.0.tar.gz#sha256=...">
&#x3C;a href="https://example.com/files/holygrail-1.0-py3-none-any.whl#sha256=...">
&#x3C;/body>
&#x3C;/html>
</code></pre>
<h3>"Alternate Locations" Metadata ("대체 위치" 메타데이터)</h3>
<p>프로젝트가 여러 저장소에 걸쳐 네임스페이스를 확장할 수 있도록, 이 PEP는 프로젝트 소유자가 프로젝트의 "대체 위치(alternate locations)" 목록을 선언할 수 있도록 합니다. 이는 JSON에서는 <code>alternate-locations</code> 키로, HTML에서는 여러 번 사용될 수 있는 <code>pypi-alternate-locations</code>라는 <code>meta</code> 요소로 노출됩니다.</p>
<p>이 메타데이터를 사용할 때 반드시 준수해야 할 몇 가지 중요한 속성이 있습니다:</p>
<ul>
<li>이 메타데이터를 신뢰하려면, 해당 프로젝트가 발견되는 모든 위치 간에 <strong>대체 위치가 무엇인지에 대한 합의</strong>가 있어야 합니다.</li>
<li>대체 위치를 사용할 때, 클라이언트는 응답이 가져온 URL이 목록에 포함되어 있다고 <strong>암묵적으로 가정</strong>해야 합니다. 즉, <code>https://pypi.org/simple/foo/</code>에서 가져온 응답에 <code>["https://example.com/simple/foo/"]</code>라는 <code>alternate-locations</code> 메타데이터가 있다면, 이를 <code>["https://example.com/simple/foo/", "https://pypi.org/simple/foo/"]</code>와 같이 처리해야 합니다.</li>
<li>배열 내 요소의 순서는 특별한 의미를 가지지 않습니다.</li>
</ul>
<p>설치 프로그램이 대체 위치 메타데이터를 사용하는 프로젝트를 발견하면, 명명된 모든 저장소가 여러 저장소에 걸쳐 동일한 네임스페이스를 확장한다고 <strong>간주해야 합니다</strong>.</p>
<p><strong>참고:</strong> 이 대체 위치 메타데이터는 아티팩트 레벨 메타데이터가 아니라 프로젝트 레벨 메타데이터입니다. 즉, 핵심 메타데이터 사양의 일부로 포함되지 않으며, 각 저장소가 (지원하기로 선택한 경우) 구성 옵션을 제공해야 하는 사항입니다.</p>
<p><strong>JSON 예시:</strong></p>
<pre><code class="language-json">{
  "meta": {
    "api-version": "1.2"
  },
  "name": "holygrail",
  "alternate-locations": ["https://pypi.org/simple/holygrail/", "https://test.pypi.org/simple/holygrail/"],
  "files": [
    {
      "filename": "holygrail-1.0.tar.gz",
      "url": "https://example.com/files/holygrail-1.0.tar.gz",
      "hashes": {"sha256": "...", "blake2b": "..."},
      "requires-python": ">=3.7",
      "yanked": "Had a vulnerability"
    },
    {
      "filename": "holygrail-1.0-py3-none-any.whl",
      "url": "https://example.com/files/holygrail-1.0-py3-none-any.whl",
      "hashes": {"sha256": "...", "blake2b": "..."},
      "requires-python": ">=3.7",
      "dist-info-metadata": true
    }
  ]
}
</code></pre>
<p><strong>HTML 예시:</strong></p>
<pre><code class="language-html">&#x3C;!DOCTYPE html>
&#x3C;html>
&#x3C;head>
&#x3C;meta name="pypi:repository-version" content="1.2">
&#x3C;meta name="pypi:alternate-locations" content="https://pypi.org/simple/holygrail/">
&#x3C;meta name="pypi:alternate-locations" content="https://test.pypi.org/simple/holygrail/">
&#x3C;/head>
&#x3C;body>
&#x3C;a href="https://example.com/files/holygrail-1.0.tar.gz#sha256=...">
&#x3C;a href="https://example.com/files/holygrail-1.0-py3-none-any.whl#sha256=...">
&#x3C;/body>
&#x3C;/html>
</code></pre>
<h2>권고 사항 (Recommendations)</h2>
<p>이 섹션은 규범적이지 않으며, 이 PEP가 사용자를 기본적으로 보호하고 기존 워크플로우의 중단을 최소화하는 최상의 절충안을 제공한다고 느끼는 메타데이터 해석 방법에 대한 권고를 설치 프로그램에 제공합니다. 이러한 권고는 구속력이 없으며, 설치 프로그램은 이를 무시하거나 특정 상황에 맞게 선택적으로 적용할 수 있습니다.</p>
<h3>파일 발견 알고리즘 (File Discovery Algorithm)</h3>
<p>현재 "표준" 파일 발견 알고리즘은 다음과 같습니다:</p>
<ol>
<li>구성된 모든 저장소에서 모든 파일 목록을 생성합니다.</li>
<li>록파일(lockfile) 또는 요구사항 파일(requirements file)에서 알려진 해시와 일치하지 않는 파일을 필터링합니다.</li>
<li>현재 플랫폼, Python 버전 등과 일치하지 않는 파일을 필터링합니다.</li>
<li>해당 파일 목록을 리졸버(resolver)에 전달하여, 어떤 저장소에서 왔는지에 관계없이 해당 파일 중 "최적"의 일치를 해결하려고 시도합니다.</li>
</ol>
<p>설치 프로그램은 새로운 메타데이터를 고려하도록 파일 발견 알고리즘을 변경하는 것이 권고되며, 대신 다음을 수행합니다:</p>
<ol>
<li>구성된 모든 저장소에서 모든 파일 목록을 생성합니다.</li>
<li>록파일 또는 요구사항 파일에서 알려진 해시와 일치하지 않는 파일을 필터링합니다.</li>
<li>최종 사용자가 설치 프로그램에 특정 저장소에서 프로젝트를 가져오도록 명시적으로 지시했다면, 다른 모든 저장소를 필터링하고 5단계로 건너뜁니다.</li>
<li>발견된 파일이 여러 저장소에 걸쳐 있는지 확인합니다. 만약 그렇다면, "Tracks" 또는 "Alternate Locations" 메타데이터가 발견된 모든 저장소를 안전하게 병합할 수 있는지 확인합니다. 해당 메타데이터가 이를 허용하지 않는다면 오류를 생성하고, 그렇지 않으면 계속 진행합니다.
<ul>
<li><strong>참고:</strong> 이는 원격 저장소에만 적용됩니다. 로컬 파일 시스템에 존재하는 저장소는 항상 모든 원격 저장소와 암묵적으로 병합될 수 있도록 허용되어야 합니다.</li>
</ul>
</li>
<li>현재 플랫폼, Python 버전 등과 일치하지 않는 파일을 필터링합니다.</li>
<li>해당 파일 목록을 리졸버에 전달하여, 어떤 저장소에서 왔는지에 관계없이 해당 파일 중 "최적"의 일치를 해결하려고 시도합니다.</li>
</ol>
<p>이 알고리즘은 설치 프로그램이 두 개의 이질적인 네임스페이스가 하나로 평면화될 수 있다고 가정하지 않도록 보장하며, 이는 실질적으로 모든 종류의 의존성 혼란 공격 가능성을 제거합니다.</p>
<h3>최종 사용자를 위한 명시적 구성 (Explicit Configuration for End Users)</h3>
<p>이 PEP는 설치 프로그램이 최종 사용자가 특정 패키지를 설치하려는 저장소를 정확히 구성할 수 있도록 하는 특정 메커니즘을 지시하거나 권장하지 않습니다. 그러나 설치 프로그램이 최종 사용자에게 해당 구성을 제공할 수 있는 메커니즘을 제공할 것을 권장합니다.</p>
<h2>전달 방법 (How to Communicate This)</h2>
<p>이 섹션은 변경 사항을 전달하기 위한 예시 "게시물"로 읽어야 합니다.</p>
<p>pip 사용자를 보호하고 이러한 유형의 공격으로부터 보호하기 위해, pip이 패키지를 설치하는 방법을 변경할 것입니다.</p>
<h3>무엇이 변경됩니까? (What is Changing?)</h3>
<p>pip이 동일한 프로젝트가 여러 원격 저장소에서 사용 가능하다고 감지하면, 기본적으로 오류를 생성하고 어떤 저장소에서 설치해야 할지 추측하는 대신 진행을 거부합니다.
여러 저장소에 기본적으로 게시하는 프로젝트에는 pip이 해당 저장소들을 함께 사용할 때 오류가 발생하지 않도록 저장소들을 안전하게 "연결"할 수 있는 기능이 제공됩니다.
pip의 최종 사용자에게는 특정 프로젝트에 유효한 하나 이상의 저장소를 명시적으로 정의할 수 있는 기능이 제공되어, pip이 해당 프로젝트에 대해 해당 저장소만 고려하고 오류 생성을 완전히 피할 수 있습니다.</p>
<h3>누가 영향을 받습니까? (Who is Affected?)</h3>
<p>여러 원격(예: 로컬 파일 시스템에 없는) 저장소에서 설치하는 사용자는 다음과 같은 경우 pip이 성공적으로 설치하는 대신 오류를 발생시켜 영향을 받을 수 있습니다:</p>
<ul>
<li>동일한 "이름"이 여러 원격 저장소에서 제공되는 프로젝트를 설치하는 경우.</li>
<li>여러 원격 저장소에서 사용 가능한 프로젝트 이름이 해당 저장소를 함께 연결하기 위해 정의된 메커니즘 중 하나를 사용하지 않은 경우.</li>
<li>pip을 호출하는 사용자가 특정 프로젝트에 유효한 저장소를 명시적으로 제어하기 위해 정의된 메커니즘을 사용하지 않은 경우.</li>
</ul>
<p>단일 원격 저장소만 사용하는 사용자(로컬 파일 시스템 "wheel house"를 사용하는 사용자 포함)는 전혀 영향을 받지 않습니다.</p>
<h3>무엇을 해야 합니까? (What do I need to do?)</h3>
<p><strong>pip 사용자로서:</strong></p>
<ul>
<li>단일 원격 저장소만 사용하는 경우 아무것도 할 필요가 없습니다.</li>
<li>여러 원격 저장소를 사용하는 경우, <code>pip</code> 호출에 <code>--use-feature=TBD</code>를 추가하여 새 동작을 선택하여 의존성 중 여러 원격 저장소에서 제공되는 것이 있는지 확인할 수 있습니다.</li>
<li>이 동작이 기본값이 되면, <code>pip</code> 호출에 <code>--use-deprecated=TBD</code>를 추가하여 일시적으로 선택 해제할 수 있습니다.</li>
<li>공개 저장소에 호스팅되지 않는 프로젝트를 사용하지만 공개 저장소를 대체(fallback)로 사용하는 경우, <code>pip</code>을 저장소 파일로 구성하여 해당 의존성이 어디에서 와야 하는지 명시적으로 지정하는 것을 고려하여 공개 저장소에 해당 이름이 등록되어 <code>pip</code>이 오류를 발생시키는 것을 방지하십시오.</li>
</ul>
<p><strong>프로젝트 소유자로서:</strong></p>
<ul>
<li>프로젝트를 단일 저장소에만 게시하는 경우 아무것도 할 필요가 없습니다.</li>
<li>프로젝트를 여러 저장소에 동시에 사용하도록 의도된 경우, 최종 사용자의 문제 발생을 방지하기 위해 모든 저장소가 대체 저장소 메타데이터를 제공하도록 구성하십시오.</li>
<li>프로젝트를 단일 저장소에 게시하지만 다른 저장소와 함께 흔히 사용되는 경우, 제3자가 사용자 <code>pip install</code> 호출이 실패하는 것을 방지하기 위해 해당 저장소에 이름을 선제적으로 등록하는 것을 고려하십시오.</li>
</ul>
<p><strong>저장소 운영자로서:</strong></p>
<ul>
<li>개인 저장소의 경우, 사용자가 의존하는 공개 프로젝트를 자체 저장소로 미러링하고, 공개 프로젝트가 개인 프로젝트와 병합되지 않도록 주의하며, 사용자에게 <code>--index-url</code> 옵션을 사용하여 자신의 저장소만 사용하도록 지시하는 것을 권장합니다.</li>
<li>공개 저장소의 경우, 프로젝트가 둘 이상의 저장소에서 사용 가능한 경우 프로젝트 소유자가 해당 프로젝트가 사용 가능한 저장소 목록을 구성할 수 있도록 대체 저장소 메커니즘을 구현하고 활성화해야 합니다.</li>
<li>다른 저장소를 "추적"하지만 특정 플랫폼용으로 빌드된 Wheel과 같은 보조 아티팩트를 제공하는 공개 저장소의 경우, 저장소에 대한 "tracks" 메타데이터를 구현해야 합니다. 그러나 이 정보는 저장소에 프로젝트를 게시하는 최종 사용자가 설정할 수 <strong>없어야 합니다</strong>.</li>
</ul>
<h2>기각된 아이디어 (Rejected Ideas)</h2>
<p>이 PEP는 여러 가지 다른 아이디어들을 고려했으나 다음과 같은 이유로 기각되었습니다:</p>
<ul>
<li><strong>파일 목록이 동일한 경우 미러를 암묵적으로 허용:</strong> 정확히 동일한 복사본인 미러만 해결하며, 결국 일관성이 없는 분산 시스템에서 산발적인 실패를 초래할 수 있습니다.</li>
<li><strong>저장소 순서를 지정하는 메커니즘 제공:</strong> 사용자들이 저장소 순서가 의미 없다고 15년 이상 교육받았기 때문에 되돌리기 어렵고, 암묵적 순서는 사용자의 의도와 다를 수 있으며, 잘못된 경우 사용자에게 아무런 피드백 없이 조용히 잘못된 것을 설치할 수 있습니다.</li>
<li><strong>저장소 프록시에 의존:</strong> 사용자가 인프라를 유지하거나 옵트인해야 하며, 복잡한 요구사항에 대한 좋은 경험을 제공할 수 있지만, 대부분의 사용자가 단순히 안전하게 여러 저장소와 상호작용하기 위해 프록시를 설정하고 싶어하지 않을 것입니다.</li>
<li><strong>해시 검사에만 의존:</strong> 사용자가 옵트인해야 하며 기본적으로 보호되지 않고, 사용자가 해시를 관리하는 데 많은 노력이 필요하며, <code>requirements.txt</code> 파일을 사용하지 않는 경우 보호를 얻기 어렵습니다.</li>
<li><strong>모든 프로젝트가 "기본" 저장소에 존재하도록 요구:</strong> <code>--extra-index-url</code>의 범위를 좁히는 것은 사용자가 이해하기 어렵고, 기본 저장소에 등록되지 않은 프로젝트에 대한 대안을 제공하지 않으며, 이질적인 네임스페이스를 통합하는 근본적인 문제를 해결하지 못합니다.</li>
<li><strong>전역적으로 고유한 이름으로 이동:</strong> 전역적으로 고유하고 인간에게 의미 있는 이름을 생성하는 것은 거의 불가능하며, 수십 년 된 시스템에 이를 소급 적용하는 것은 현실적으로 어렵습니다.</li>
<li><strong>설치 프로그램이 명시적 구성만 제공하도록 권고:</strong> 옵트인 방식이므로 평균 사용자를 보호하지 못하며, 모든 최종 사용자가 PyPI 미러와 같은 경우에도 동일한 문제를 반복적으로 해결해야 합니다.</li>
<li><strong>npm 방식의 스코프(Scopes) 도입:</strong> 스코프는 관련 프로젝트를 그룹화하고 특정 레지스트리에 이름을 할당하는 메커니즘을 제공하지만, npm.org와 같이 중앙화된 레지스트리가 일반적인 환경에서는 유용할 수 있으나, Python에서는 사용자가 자체 레지스트리를 사용하는 것이 장려되므로 이 문제의 근본적인 해결책은 아닙니다.</li>
<li><strong>"명시적 구성" 정의 및 표준화:</strong> 이 메커니즘은 각 설치 프로그램의 UX와 밀접하게 관련되어 있어 표준화를 강제하기 어려우며, 필요하다면 별도의 PEP로 다루는 것이 적절합니다.</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 조건으로 배포됩니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/708\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"SAPzS3zi9tsG5MkeKvxIA\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/708/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/708\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"708\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/708\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T6c56,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0708/\"\u003ePEP 708 - Extending the Repository API to Mitigate Dependency Confusion Attacks\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Provisional | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 20-Feb-2023\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 708: 의존성 혼란 공격 완화를 위한 저장소 API 확장 번역 및 요약\u003c/p\u003e\n\u003ch2\u003e요약 (Abstract)\u003c/h2\u003e\n\u003cp\u003e의존성 혼란 공격(Dependency confusion attacks)은 사용자가 예상한 패키지 대신 악성 패키지가 설치되는 형태로, 점점 더 흔해지는 공급망 위협입니다. Python 의존성에 대한 대부분의 공격(최근 PyTorch 사건 포함)은 여러 패키지 저장소에서 발생하는데, 특정 저장소(예: 사용자 정의 인덱스)에서 올 것으로 예상되는 의존성이 다른 저장소(예: PyPI)에서 설치되는 경우입니다.\u003c/p\u003e\n\u003cp\u003e이 문제를 해결하기 위해 PEP 708은 Simple Repository API를 확장하여 저장소 운영자가 자신의 저장소에 있는 프로젝트가 다른 저장소의 프로젝트를 \"추적(tracks)\"하거나, 프로젝트가 여러 저장소에 걸쳐 네임스페이스를 확장할 수 있도록 제안합니다. 이러한 기능은 설치 프로그램이 특정 저장소 조합에서 제공되는 프로젝트가 예상된 것이고 허용되어야 하는 경우와 그렇지 않은 경우를 판단하여, 후자의 경우 사용자 보호를 위해 설치를 오류로 중단시킬 수 있게 합니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e오랫동안 \"의존성 혼란(dependency confusion)\" 공격이라는 종류의 공격이 존재해왔는데, 이는 사용자가 패키지 A를 기대했지만 대신 패키지 B를 받게 되는 상황으로 요약할 수 있습니다. Python에서는 거의 항상 여러 저장소(PyPI 기본값 포함) 설정 때문에 발생합니다. 사용자가 저장소 X에서 패키지 A를 기대했지만, 누군가 저장소 Y에 동일한 이름으로 악성 패키지 B를 게시할 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e의존성 혼란 공격은 오래전부터 가능했지만, 최근 성공적으로 실행된 사례들이 공개되면서 주목받고 있습니다. 대표적인 예는 PyTorch 프로젝트의 내부 패키지인 \u003ccode\u003etorchtriton\u003c/code\u003e 사례입니다. 이 패키지는 \u003ccode\u003ehttps://download.pytorch.org/\u003c/code\u003e에 있는 PyTorch 저장소에서만 설치되도록 의도되었지만, PyPI에 해당 이름이 등록되지 않아 공격자가 같은 이름을 사용하여 악성 버전을 게시할 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e현재 이러한 공격을 완화하는 여러 방법이 있지만, 모두 최종 사용자가 스스로 보호하기 위해 추가적인 노력을 기울여야 하며, 기본적으로 보호되지 않습니다. 이는 대부분의 사용자가 이러한 공격 유형을 인지하더라도 여전히 취약한 상태로 남아있을 가능성이 높다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e궁극적으로 이러한 공격의 근본 원인은 모든 Python 패키지 이름이 나오는 전역적으로 고유한(globally unique) 네임스페이스가 없다는 사실에서 기인합니다. 대신 각 저장소는 자체적인 고유한 네임스페이스이며, \u003ccode\u003espam\u003c/code\u003e과 같은 \"추상적인\" 이름을 설치하도록 주어지면, 설치 프로그램은 암묵적으로 이를 \u003ccode\u003epypi.org:spam\u003c/code\u003e 또는 \u003ccode\u003eexample.com:spam\u003c/code\u003e과 같은 \"구체적인\" 이름으로 변환해야 합니다. 현재 Python 설치 도구의 표준 동작은 이러한 여러 네임스페이스를 모든 네임스페이스의 파일을 포함하는 하나의 네임스페이스로 암묵적으로 통합하는 것입니다.\u003c/p\u003e\n\u003cp\u003e네임스페이스를 통합하는 것이 예상된 동작이라는 가정은, 다른 저장소에 있는 동일한 이름의 패키지가 서로 다른 당사자에 의해 작성될 때(예: \u003ccode\u003etorchtriton\u003c/code\u003e 사례), 의존성 혼란 공격이 가능해진다는 것을 의미합니다. 또한, 두 저장소를 하나의 네임스페이스로 병합하려는 유효한 사용 사례와 두 저장소를 별개의 네임스페이스로 처리하려는 유효한 사용 사례가 모두 존재하므로 \"정답\"이 없습니다. 따라서 설치 프로그램은 항상 병합하거나 절대 병합하지 않는 규칙 대신, 여러 저장소의 네임스페이스를 언제 병합하고 언제 병합하지 않아야 할지 결정할 수 있는 메커니즘이 필요합니다.\u003c/p\u003e\n\u003cp\u003e이 기능은 최종 사용자에게 직접 전달될 수도 있지만, 저장소 사양을 확장하여 저장소가 안전한 경우를 표시할 수 있게 함으로써, 개별 프로젝트와 저장소가 여러 별개의 네임스페이스에 걸쳐 자연스럽게 존재하더라도 \"기본적으로 작동\"할 수 있도록 하고, 설치 프로그램이 기본적으로 안전할 수 있는 능력을 유지할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 의존성 혼란 공격을 단독으로 해결하지는 않지만, 설치 프로그램이 유효하고 안전한 사용 사례에 과도한 피해를 주지 않으면서 공격을 방지할 수 있는 충분한 정보를 제공합니다.\u003c/p\u003e\n\u003ch2\u003e이론적 근거 (Rationale)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 저장소 간 이름 병합에 대한 두 가지 광범위한 사용 사례를 가능하게 합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e다른 저장소에 정의된 이름을 확장하는 경우:\u003c/strong\u003e 한 저장소가 자체 이름을 정의하지 않고, 다른 저장소에 정의된 이름을 확장하는 경우입니다. 이는 프로젝트가 한 저장소에서 다른 저장소로 미러링되거나(Bandersnatch 참조), 저장소가 특정 플랫폼에 대한 보조 아티팩트를 제공하는 경우(Piwheels 참조)에 흔히 발생합니다.\r\n이 경우 확장되는 저장소나 프로젝트는 자신이 확장되고 있는지, 누구에 의해 확장되는지 알지 못할 수 있으므로, \"확장하는\" 저장소 자체에 존재하지 않는 정보에 의존할 수 없습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e프로젝트가 여러 저장소에 게시하는 경우:\u003c/strong\u003e 프로젝트가 하나의 \"주요\" 저장소에 게시하지만, 추가 플랫폼, GPU, CPU 등을 위한 바이너리를 제공하는 추가 저장소를 갖는 경우입니다. 현재 Wheel 태그는 이러한 유형의 바이너리 호환성을 충분히 표현할 수 없으므로, 이를 사용하려는 프로젝트는 여러 저장소를 설정하고 사용자가 자신의 플랫폼, GPU, CPU 등에 맞는 올바른 바이너리를 얻기 위해 수동으로 구성하도록 해야 합니다.\r\n이 사용 사례는 첫 번째와 유사하지만, 누가 정보를 제공하고 그들의 신뢰 수준이 어떤지에 대한 중요한 차이점이 있어 별개의 사용 사례가 됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e사용자가 특정 저장소를 구성할 때(또는 기본값에 의존할 때) 어떤 저장소를 의미하는지에 대한 모호성은 없습니다. 저장소는 URL로 식별되며, 도메인 시스템을 통해 URL은 전역적으로 고유한 식별자입니다. 이러한 모호성 부족은 설치 프로그램이 저장소 운영자를 신뢰할 수 있고, 제공하는 메타데이터를 유효성 검사 없이 신뢰할 수 있다고 가정할 수 있음을 의미합니다.\u003c/p\u003e\n\u003cp\u003e반대로, 설치 프로그램이 여러 저장소에서 동일한 이름을 발견하면 어떤 저장소를 신뢰해야 하는지에 대한 모호성이 발생합니다. 이러한 모호성 때문에 설치 프로그램은 어느 저장소의 프로젝트 소유자도 신뢰할 수 있다고 가정할 수 없으며, 실제로 동일한 프로젝트인지, 또는 의존성 혼란 공격이 아닌지 유효성 검사를 해야 합니다.\u003c/p\u003e\n\u003cp\u003e설치 프로그램이 여러 저장소 간의 메타데이터를 검증할 방법이 없다면, 프로젝트는 이 사용 사례를 안전하게 지원하기 위해 저장소 운영자가 되어야 할 것입니다. 이는 나쁜 선택은 아니지만, 저장소가 프로젝트 소유자가 이 관계를 안전하게 표현할 수 있는 방법을 제공하지 않으면, 저장소 운영자의 메타데이터를 사용하도록 유도되어 원래의 불안정성이 재도입될 위험이 있습니다.\u003c/p\u003e\n\u003ch2\u003e사양 (Specification)\u003c/h2\u003e\n\u003cp\u003e이 사양은 Simple Repository API 버전 1.2의 변경 사항을 정의하며, 두 가지 새로운 메타데이터 항목인 \"Repository 'Tracks'\" 및 \"'Alternate Locations'\"를 추가합니다.\u003c/p\u003e\n\u003ch3\u003eRepository \"Tracks\" Metadata (저장소 \"추적\" 메타데이터)\u003c/h3\u003e\n\u003cp\u003e하나의 저장소가 다른 저장소에서 호스팅되는 프로젝트를 \"확장\"하기 위해, 확장하는 저장소는 특정 프로젝트가 다른 저장소 또는 여러 저장소의 프로젝트를 \"추적\"한다고 선언할 수 있습니다. 이는 확장하는 프로젝트 및 저장소의 URL을 추가함으로써 이루어집니다.\u003c/p\u003e\n\u003cp\u003e이는 JSON에서는 \u003ccode\u003emeta.tracks\u003c/code\u003e 키로, HTML에서는 프로젝트별 URL(\u003ccode\u003e$root/$project/\u003c/code\u003e)에 \u003ccode\u003epypi:tracks\u003c/code\u003e라는 \u003ccode\u003emeta\u003c/code\u003e 요소로 노출됩니다.\u003c/p\u003e\n\u003cp\u003e이 메타데이터를 사용할 때 반드시 유지되어야 할 몇 가지 중요한 속성이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이것은 저장소를 사용하는 개별 게시자가 아닌, \u003cstrong\u003e저장소 운영자 자신\u003c/strong\u003e의 통제하에 있어야 합니다.\n\u003cul\u003e\n\u003cli\u003e\"저장소 운영자\"는 특정 저장소의 전체 네임스페이스를 관리하는 사람도 포함할 수 있습니다. 예를 들어, 한 엔티티가 소프트웨어를 운영하지만 다른 엔티티가 저장소의 전체 네임스페이스를 소유/관리하는 호스팅된 저장소 서비스와 같은 상황이 해당됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e모든 URL은 확장하는 저장소의 프로젝트와 **동일한 \"프로젝트\"**를 나타내야 합니다.\n\u003cul\u003e\n\u003cli\u003e이는 동일한 파일을 제공해야 한다는 의미는 아닙니다. 다른 플랫폼용으로 빌드된 바이너리, 로컬 패치가 적용된 복사본 등을 포함하는 것이 유효합니다. 이는 궁극적으로 사용자와 저장소 운영자가 \"동일한\" 프로젝트가 무엇을 구성하는지에 대한 기대에 달려 있으므로 의도적으로 모호하게 남겨두었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e네임스페이스를 \"소유\"하는 저장소를 가리켜야 하며, 해당 네임스페이스를 추적하는 다른 저장소를 가리켜서는 안 됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e정확히 동일한 이름\u003c/strong\u003e(정규화 후)을 가진 프로젝트를 가리켜야 합니다.\u003c/li\u003e\n\u003cli\u003e확장된 저장소의 기본 URL이 아닌, \u003cstrong\u003e해당 프로젝트의 실제 URL\u003c/strong\u003e을 가리켜야 합니다.\u003c/li\u003e\n\u003cli\u003e저장소의 모든 이름이 동일한 저장소를 추적하거나, 아예 어떤 저장소도 추적해야 하는 것은 아닙니다. 일부 이름은 저장소를 추적하고 일부 이름은 추적하지 않는 혼합 사용 저장소도 명시적으로 허용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eJSON 예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\r\n  \"meta\": {\r\n    \"api-version\": \"1.2\",\r\n    \"tracks\": [\"https://pypi.org/simple/holygrail/\", \"https://test.pypi.org/simple/holygrail/\"]\r\n  },\r\n  \"name\": \"holygrail\",\r\n  \"files\": [\r\n    {\r\n      \"filename\": \"holygrail-1.0.tar.gz\",\r\n      \"url\": \"https://example.com/files/holygrail-1.0.tar.gz\",\r\n      \"hashes\": {\"sha256\": \"...\", \"blake2b\": \"...\"},\r\n      \"requires-python\": \"\u003e=3.7\",\r\n      \"yanked\": \"Had a vulnerability\"\r\n    },\r\n    {\r\n      \"filename\": \"holygrail-1.0-py3-none-any.whl\",\r\n      \"url\": \"https://example.com/files/holygrail-1.0-py3-none-any.whl\",\r\n      \"hashes\": {\"sha256\": \"...\", \"blake2b\": \"...\"},\r\n      \"requires-python\": \"\u003e=3.7\",\r\n      \"dist-info-metadata\": true\r\n    }\r\n  ]\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eHTML 예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;!DOCTYPE html\u003e\r\n\u0026#x3C;html\u003e\r\n\u0026#x3C;head\u003e\r\n\u0026#x3C;meta name=\"pypi:repository-version\" content=\"1.2\"\u003e\r\n\u0026#x3C;meta name=\"pypi:tracks\" content=\"https://pypi.org/simple/holygrail/\"\u003e\r\n\u0026#x3C;meta name=\"pypi:tracks\" content=\"https://test.pypi.org/simple/holygrail/\"\u003e\r\n\u0026#x3C;/head\u003e\r\n\u0026#x3C;body\u003e\r\n\u0026#x3C;a href=\"https://example.com/files/holygrail-1.0.tar.gz#sha256=...\"\u003e\r\n\u0026#x3C;a href=\"https://example.com/files/holygrail-1.0-py3-none-any.whl#sha256=...\"\u003e\r\n\u0026#x3C;/body\u003e\r\n\u0026#x3C;/html\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\"Alternate Locations\" Metadata (\"대체 위치\" 메타데이터)\u003c/h3\u003e\n\u003cp\u003e프로젝트가 여러 저장소에 걸쳐 네임스페이스를 확장할 수 있도록, 이 PEP는 프로젝트 소유자가 프로젝트의 \"대체 위치(alternate locations)\" 목록을 선언할 수 있도록 합니다. 이는 JSON에서는 \u003ccode\u003ealternate-locations\u003c/code\u003e 키로, HTML에서는 여러 번 사용될 수 있는 \u003ccode\u003epypi-alternate-locations\u003c/code\u003e라는 \u003ccode\u003emeta\u003c/code\u003e 요소로 노출됩니다.\u003c/p\u003e\n\u003cp\u003e이 메타데이터를 사용할 때 반드시 준수해야 할 몇 가지 중요한 속성이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 메타데이터를 신뢰하려면, 해당 프로젝트가 발견되는 모든 위치 간에 \u003cstrong\u003e대체 위치가 무엇인지에 대한 합의\u003c/strong\u003e가 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e대체 위치를 사용할 때, 클라이언트는 응답이 가져온 URL이 목록에 포함되어 있다고 \u003cstrong\u003e암묵적으로 가정\u003c/strong\u003e해야 합니다. 즉, \u003ccode\u003ehttps://pypi.org/simple/foo/\u003c/code\u003e에서 가져온 응답에 \u003ccode\u003e[\"https://example.com/simple/foo/\"]\u003c/code\u003e라는 \u003ccode\u003ealternate-locations\u003c/code\u003e 메타데이터가 있다면, 이를 \u003ccode\u003e[\"https://example.com/simple/foo/\", \"https://pypi.org/simple/foo/\"]\u003c/code\u003e와 같이 처리해야 합니다.\u003c/li\u003e\n\u003cli\u003e배열 내 요소의 순서는 특별한 의미를 가지지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e설치 프로그램이 대체 위치 메타데이터를 사용하는 프로젝트를 발견하면, 명명된 모든 저장소가 여러 저장소에 걸쳐 동일한 네임스페이스를 확장한다고 \u003cstrong\u003e간주해야 합니다\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 이 대체 위치 메타데이터는 아티팩트 레벨 메타데이터가 아니라 프로젝트 레벨 메타데이터입니다. 즉, 핵심 메타데이터 사양의 일부로 포함되지 않으며, 각 저장소가 (지원하기로 선택한 경우) 구성 옵션을 제공해야 하는 사항입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eJSON 예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\r\n  \"meta\": {\r\n    \"api-version\": \"1.2\"\r\n  },\r\n  \"name\": \"holygrail\",\r\n  \"alternate-locations\": [\"https://pypi.org/simple/holygrail/\", \"https://test.pypi.org/simple/holygrail/\"],\r\n  \"files\": [\r\n    {\r\n      \"filename\": \"holygrail-1.0.tar.gz\",\r\n      \"url\": \"https://example.com/files/holygrail-1.0.tar.gz\",\r\n      \"hashes\": {\"sha256\": \"...\", \"blake2b\": \"...\"},\r\n      \"requires-python\": \"\u003e=3.7\",\r\n      \"yanked\": \"Had a vulnerability\"\r\n    },\r\n    {\r\n      \"filename\": \"holygrail-1.0-py3-none-any.whl\",\r\n      \"url\": \"https://example.com/files/holygrail-1.0-py3-none-any.whl\",\r\n      \"hashes\": {\"sha256\": \"...\", \"blake2b\": \"...\"},\r\n      \"requires-python\": \"\u003e=3.7\",\r\n      \"dist-info-metadata\": true\r\n    }\r\n  ]\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eHTML 예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;!DOCTYPE html\u003e\r\n\u0026#x3C;html\u003e\r\n\u0026#x3C;head\u003e\r\n\u0026#x3C;meta name=\"pypi:repository-version\" content=\"1.2\"\u003e\r\n\u0026#x3C;meta name=\"pypi:alternate-locations\" content=\"https://pypi.org/simple/holygrail/\"\u003e\r\n\u0026#x3C;meta name=\"pypi:alternate-locations\" content=\"https://test.pypi.org/simple/holygrail/\"\u003e\r\n\u0026#x3C;/head\u003e\r\n\u0026#x3C;body\u003e\r\n\u0026#x3C;a href=\"https://example.com/files/holygrail-1.0.tar.gz#sha256=...\"\u003e\r\n\u0026#x3C;a href=\"https://example.com/files/holygrail-1.0-py3-none-any.whl#sha256=...\"\u003e\r\n\u0026#x3C;/body\u003e\r\n\u0026#x3C;/html\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e권고 사항 (Recommendations)\u003c/h2\u003e\n\u003cp\u003e이 섹션은 규범적이지 않으며, 이 PEP가 사용자를 기본적으로 보호하고 기존 워크플로우의 중단을 최소화하는 최상의 절충안을 제공한다고 느끼는 메타데이터 해석 방법에 대한 권고를 설치 프로그램에 제공합니다. 이러한 권고는 구속력이 없으며, 설치 프로그램은 이를 무시하거나 특정 상황에 맞게 선택적으로 적용할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e파일 발견 알고리즘 (File Discovery Algorithm)\u003c/h3\u003e\n\u003cp\u003e현재 \"표준\" 파일 발견 알고리즘은 다음과 같습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e구성된 모든 저장소에서 모든 파일 목록을 생성합니다.\u003c/li\u003e\n\u003cli\u003e록파일(lockfile) 또는 요구사항 파일(requirements file)에서 알려진 해시와 일치하지 않는 파일을 필터링합니다.\u003c/li\u003e\n\u003cli\u003e현재 플랫폼, Python 버전 등과 일치하지 않는 파일을 필터링합니다.\u003c/li\u003e\n\u003cli\u003e해당 파일 목록을 리졸버(resolver)에 전달하여, 어떤 저장소에서 왔는지에 관계없이 해당 파일 중 \"최적\"의 일치를 해결하려고 시도합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e설치 프로그램은 새로운 메타데이터를 고려하도록 파일 발견 알고리즘을 변경하는 것이 권고되며, 대신 다음을 수행합니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e구성된 모든 저장소에서 모든 파일 목록을 생성합니다.\u003c/li\u003e\n\u003cli\u003e록파일 또는 요구사항 파일에서 알려진 해시와 일치하지 않는 파일을 필터링합니다.\u003c/li\u003e\n\u003cli\u003e최종 사용자가 설치 프로그램에 특정 저장소에서 프로젝트를 가져오도록 명시적으로 지시했다면, 다른 모든 저장소를 필터링하고 5단계로 건너뜁니다.\u003c/li\u003e\n\u003cli\u003e발견된 파일이 여러 저장소에 걸쳐 있는지 확인합니다. 만약 그렇다면, \"Tracks\" 또는 \"Alternate Locations\" 메타데이터가 발견된 모든 저장소를 안전하게 병합할 수 있는지 확인합니다. 해당 메타데이터가 이를 허용하지 않는다면 오류를 생성하고, 그렇지 않으면 계속 진행합니다.\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 이는 원격 저장소에만 적용됩니다. 로컬 파일 시스템에 존재하는 저장소는 항상 모든 원격 저장소와 암묵적으로 병합될 수 있도록 허용되어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e현재 플랫폼, Python 버전 등과 일치하지 않는 파일을 필터링합니다.\u003c/li\u003e\n\u003cli\u003e해당 파일 목록을 리졸버에 전달하여, 어떤 저장소에서 왔는지에 관계없이 해당 파일 중 \"최적\"의 일치를 해결하려고 시도합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이 알고리즘은 설치 프로그램이 두 개의 이질적인 네임스페이스가 하나로 평면화될 수 있다고 가정하지 않도록 보장하며, 이는 실질적으로 모든 종류의 의존성 혼란 공격 가능성을 제거합니다.\u003c/p\u003e\n\u003ch3\u003e최종 사용자를 위한 명시적 구성 (Explicit Configuration for End Users)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 설치 프로그램이 최종 사용자가 특정 패키지를 설치하려는 저장소를 정확히 구성할 수 있도록 하는 특정 메커니즘을 지시하거나 권장하지 않습니다. 그러나 설치 프로그램이 최종 사용자에게 해당 구성을 제공할 수 있는 메커니즘을 제공할 것을 권장합니다.\u003c/p\u003e\n\u003ch2\u003e전달 방법 (How to Communicate This)\u003c/h2\u003e\n\u003cp\u003e이 섹션은 변경 사항을 전달하기 위한 예시 \"게시물\"로 읽어야 합니다.\u003c/p\u003e\n\u003cp\u003epip 사용자를 보호하고 이러한 유형의 공격으로부터 보호하기 위해, pip이 패키지를 설치하는 방법을 변경할 것입니다.\u003c/p\u003e\n\u003ch3\u003e무엇이 변경됩니까? (What is Changing?)\u003c/h3\u003e\n\u003cp\u003epip이 동일한 프로젝트가 여러 원격 저장소에서 사용 가능하다고 감지하면, 기본적으로 오류를 생성하고 어떤 저장소에서 설치해야 할지 추측하는 대신 진행을 거부합니다.\r\n여러 저장소에 기본적으로 게시하는 프로젝트에는 pip이 해당 저장소들을 함께 사용할 때 오류가 발생하지 않도록 저장소들을 안전하게 \"연결\"할 수 있는 기능이 제공됩니다.\r\npip의 최종 사용자에게는 특정 프로젝트에 유효한 하나 이상의 저장소를 명시적으로 정의할 수 있는 기능이 제공되어, pip이 해당 프로젝트에 대해 해당 저장소만 고려하고 오류 생성을 완전히 피할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e누가 영향을 받습니까? (Who is Affected?)\u003c/h3\u003e\n\u003cp\u003e여러 원격(예: 로컬 파일 시스템에 없는) 저장소에서 설치하는 사용자는 다음과 같은 경우 pip이 성공적으로 설치하는 대신 오류를 발생시켜 영향을 받을 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e동일한 \"이름\"이 여러 원격 저장소에서 제공되는 프로젝트를 설치하는 경우.\u003c/li\u003e\n\u003cli\u003e여러 원격 저장소에서 사용 가능한 프로젝트 이름이 해당 저장소를 함께 연결하기 위해 정의된 메커니즘 중 하나를 사용하지 않은 경우.\u003c/li\u003e\n\u003cli\u003epip을 호출하는 사용자가 특정 프로젝트에 유효한 저장소를 명시적으로 제어하기 위해 정의된 메커니즘을 사용하지 않은 경우.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단일 원격 저장소만 사용하는 사용자(로컬 파일 시스템 \"wheel house\"를 사용하는 사용자 포함)는 전혀 영향을 받지 않습니다.\u003c/p\u003e\n\u003ch3\u003e무엇을 해야 합니까? (What do I need to do?)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003epip 사용자로서:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e단일 원격 저장소만 사용하는 경우 아무것도 할 필요가 없습니다.\u003c/li\u003e\n\u003cli\u003e여러 원격 저장소를 사용하는 경우, \u003ccode\u003epip\u003c/code\u003e 호출에 \u003ccode\u003e--use-feature=TBD\u003c/code\u003e를 추가하여 새 동작을 선택하여 의존성 중 여러 원격 저장소에서 제공되는 것이 있는지 확인할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e이 동작이 기본값이 되면, \u003ccode\u003epip\u003c/code\u003e 호출에 \u003ccode\u003e--use-deprecated=TBD\u003c/code\u003e를 추가하여 일시적으로 선택 해제할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e공개 저장소에 호스팅되지 않는 프로젝트를 사용하지만 공개 저장소를 대체(fallback)로 사용하는 경우, \u003ccode\u003epip\u003c/code\u003e을 저장소 파일로 구성하여 해당 의존성이 어디에서 와야 하는지 명시적으로 지정하는 것을 고려하여 공개 저장소에 해당 이름이 등록되어 \u003ccode\u003epip\u003c/code\u003e이 오류를 발생시키는 것을 방지하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e프로젝트 소유자로서:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프로젝트를 단일 저장소에만 게시하는 경우 아무것도 할 필요가 없습니다.\u003c/li\u003e\n\u003cli\u003e프로젝트를 여러 저장소에 동시에 사용하도록 의도된 경우, 최종 사용자의 문제 발생을 방지하기 위해 모든 저장소가 대체 저장소 메타데이터를 제공하도록 구성하십시오.\u003c/li\u003e\n\u003cli\u003e프로젝트를 단일 저장소에 게시하지만 다른 저장소와 함께 흔히 사용되는 경우, 제3자가 사용자 \u003ccode\u003epip install\u003c/code\u003e 호출이 실패하는 것을 방지하기 위해 해당 저장소에 이름을 선제적으로 등록하는 것을 고려하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e저장소 운영자로서:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e개인 저장소의 경우, 사용자가 의존하는 공개 프로젝트를 자체 저장소로 미러링하고, 공개 프로젝트가 개인 프로젝트와 병합되지 않도록 주의하며, 사용자에게 \u003ccode\u003e--index-url\u003c/code\u003e 옵션을 사용하여 자신의 저장소만 사용하도록 지시하는 것을 권장합니다.\u003c/li\u003e\n\u003cli\u003e공개 저장소의 경우, 프로젝트가 둘 이상의 저장소에서 사용 가능한 경우 프로젝트 소유자가 해당 프로젝트가 사용 가능한 저장소 목록을 구성할 수 있도록 대체 저장소 메커니즘을 구현하고 활성화해야 합니다.\u003c/li\u003e\n\u003cli\u003e다른 저장소를 \"추적\"하지만 특정 플랫폼용으로 빌드된 Wheel과 같은 보조 아티팩트를 제공하는 공개 저장소의 경우, 저장소에 대한 \"tracks\" 메타데이터를 구현해야 합니다. 그러나 이 정보는 저장소에 프로젝트를 게시하는 최종 사용자가 설정할 수 \u003cstrong\u003e없어야 합니다\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e기각된 아이디어 (Rejected Ideas)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 여러 가지 다른 아이디어들을 고려했으나 다음과 같은 이유로 기각되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e파일 목록이 동일한 경우 미러를 암묵적으로 허용:\u003c/strong\u003e 정확히 동일한 복사본인 미러만 해결하며, 결국 일관성이 없는 분산 시스템에서 산발적인 실패를 초래할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e저장소 순서를 지정하는 메커니즘 제공:\u003c/strong\u003e 사용자들이 저장소 순서가 의미 없다고 15년 이상 교육받았기 때문에 되돌리기 어렵고, 암묵적 순서는 사용자의 의도와 다를 수 있으며, 잘못된 경우 사용자에게 아무런 피드백 없이 조용히 잘못된 것을 설치할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e저장소 프록시에 의존:\u003c/strong\u003e 사용자가 인프라를 유지하거나 옵트인해야 하며, 복잡한 요구사항에 대한 좋은 경험을 제공할 수 있지만, 대부분의 사용자가 단순히 안전하게 여러 저장소와 상호작용하기 위해 프록시를 설정하고 싶어하지 않을 것입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e해시 검사에만 의존:\u003c/strong\u003e 사용자가 옵트인해야 하며 기본적으로 보호되지 않고, 사용자가 해시를 관리하는 데 많은 노력이 필요하며, \u003ccode\u003erequirements.txt\u003c/code\u003e 파일을 사용하지 않는 경우 보호를 얻기 어렵습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e모든 프로젝트가 \"기본\" 저장소에 존재하도록 요구:\u003c/strong\u003e \u003ccode\u003e--extra-index-url\u003c/code\u003e의 범위를 좁히는 것은 사용자가 이해하기 어렵고, 기본 저장소에 등록되지 않은 프로젝트에 대한 대안을 제공하지 않으며, 이질적인 네임스페이스를 통합하는 근본적인 문제를 해결하지 못합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e전역적으로 고유한 이름으로 이동:\u003c/strong\u003e 전역적으로 고유하고 인간에게 의미 있는 이름을 생성하는 것은 거의 불가능하며, 수십 년 된 시스템에 이를 소급 적용하는 것은 현실적으로 어렵습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e설치 프로그램이 명시적 구성만 제공하도록 권고:\u003c/strong\u003e 옵트인 방식이므로 평균 사용자를 보호하지 못하며, 모든 최종 사용자가 PyPI 미러와 같은 경우에도 동일한 문제를 반복적으로 해결해야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enpm 방식의 스코프(Scopes) 도입:\u003c/strong\u003e 스코프는 관련 프로젝트를 그룹화하고 특정 레지스트리에 이름을 할당하는 메커니즘을 제공하지만, npm.org와 같이 중앙화된 레지스트리가 일반적인 환경에서는 유용할 수 있으나, Python에서는 사용자가 자체 레지스트리를 사용하는 것이 장려되므로 이 문제의 근본적인 해결책은 아닙니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\"명시적 구성\" 정의 및 표준화:\u003c/strong\u003e 이 메커니즘은 각 설치 프로그램의 UX와 밀접하게 관련되어 있어 표준화를 강제하기 어려우며, 필요하다면 별도의 PEP로 다루는 것이 적절합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 관대한 조건으로 배포됩니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Provisional] PEP 708 - Extending the Repository API to Mitigate Dependency Confusion Attacks\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-27 13:10:38+0900\",\"children\":\"2025년 9월 27일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 27일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>