3:I[9275,[],""]
5:I[1343,[],""]
6:I[9157,["231","static/chunks/231-c27e618569e042bc.js","157","static/chunks/157-d79d6340e7770dba.js","185","static/chunks/app/layout-b06e577e11976c7d.js"],"default"]
7:I[231,["231","static/chunks/231-c27e618569e042bc.js","877","static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js"],""]
4:["slug","python/pep/225","c"]
0:["jf5MDuRUbMNVvRN9tv5rq",[[["",{"children":[["slug","python/pep/225","c"],{"children":["__PAGE__?{\"slug\":[\"python\",\"pep\",\"225\"]}",{}]}]},"$undefined","$undefined",true],["",{"children":[["slug","python/pep/225","c"],{"children":["__PAGE__",{},[["$L1","$L2"],null],null]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}],null]},[["$","html",null,{"lang":"ko","className":"no-js","children":[["$","head",null,{"children":[["$","meta",null,{"name":"msapplication-TileColor","content":"#ffc40d"}],["$","meta",null,{"name":"theme-color","content":"#ffffff"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n              window.dataLayer = window.dataLayer || [];\n              function gtag(){dataLayer.push(arguments);}\n              gtag('js', new Date());\n              gtag('config', 'G-NE2W3CFPNY');\n            "}}]]}],["$","body",null,{"className":"__className_f367f3 layout--default","children":["$","div",null,{"className":"min-h-screen bg-gray-50","children":[["$","$L6",null,{}],["$","main",null,{"className":"initial-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","div",null,{"className":"min-h-screen flex items-center justify-center bg-gray-50","children":["$","div",null,{"className":"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center","children":[["$","h1",null,{"className":"text-6xl font-bold text-primary-600 mb-4","children":"404"}],["$","h2",null,{"className":"text-2xl font-semibold text-gray-900 mb-4","children":"페이지를 찾을 수 없습니다"}],["$","p",null,{"className":"text-gray-600 mb-8","children":"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다."}],["$","$L7",null,{"href":"/","className":"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors","children":"홈으로 돌아가기"}]]}]}],"notFoundStyles":[],"styles":null}]}],["$","div",null,{"id":"footer","className":"page__footer","children":["$","footer",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"text-center text-gray-500 text-sm","children":["$","p",null,{"children":"© 2025 secrett2633. All rights reserved."}]}]}]}]]}]}]]}],null],[["$","div",null,{"className":"flex items-center justify-center min-h-screen","children":["$","div",null,{"className":"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"}]}],[],[]]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e975486d410ad4e9.css","precedence":"next","crossOrigin":"$undefined"}]],[null,"$L8"]]]]]
9:T973c,<blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0225/">PEP 225 - Elementwise/Objectwise Operators</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 19-Sep-2000</p>
</blockquote>
<p><strong>경고:</strong> 이 PEP는 <strong>거부</strong>되었습니다.
이 PEP 대신 PEP 465에서 제시된 접근 방식이 최종적으로 채택되었습니다. PEP 465의 '거부된 아이디어(Rejected Ideas)' 섹션에서 이 결정의 배경에 대한 더 자세한 설명을 확인할 수 있습니다.</p>
<h3>1. 개요 (Introduction)</h3>
<p>이 PEP는 파이썬(Python)에 <strong>요소별 (elementwise)</strong> 및 <strong>객체별 (objectwise)</strong> 연산을 구분하는 데 유용한 새로운 연산자를 추가하자는 제안을 설명합니다. 또한, <code>comp.lang.python</code> 뉴스 그룹에서 이 주제에 대해 논의된 내용을 요약합니다.</p>
<p>주요 논의 내용은 다음과 같습니다.</p>
<ul>
<li>배경 (Background)</li>
<li>제안된 연산자 및 구현 문제 설명</li>
<li>새로운 연산자에 대한 대안 분석</li>
<li>대안적 형태 분석</li>
<li>호환성 문제</li>
<li>더 넓은 확장 및 기타 관련 아이디어 설명</li>
</ul>
<p>이 PEP의 상당 부분은 제안된 확장에는 포함되지 않는 아이디어를 설명하고 있습니다. 이는 이 확장이 본질적으로 <strong>문법적 설탕 (syntactic sugar)</strong> 이므로, 다양한 대안들과 비교하여 채택 여부를 저울질해야 했기 때문입니다.</p>
<p>요소별-객체별 연산에 대한 문제는 수치 계산 (numerical computation)을 넘어 더 넓은 영역으로 확장될 수 있습니다. 이 문서에서는 현재 제안이 더 일반적인 미래 확장과 어떻게 통합될 수 있는지도 설명합니다.</p>
<h3>2. 배경 (Background)</h3>
<p>파이썬은 여섯 가지 이항 중위 수학 연산자 <code>+ - * / % **</code>를 제공하며, 이를 <code>op</code>로 통칭합니다. 이러한 연산자들은 사용자 정의 클래스 (user-defined classes)에서 새로운 의미로 <strong>오버로드 (overload)</strong> 될 수 있습니다.</p>
<p>그러나 배열 (arrays), 벡터 (vectors), 행렬 (matrices)과 같은 동질적인 요소들로 구성된 객체의 경우, 본질적으로 두 가지 다른 의미론이 존재합니다.</p>
<ul>
<li><strong>객체별 연산 (Objectwise operations):</strong> 이러한 객체들을 다차원 공간의 점으로 취급합니다. (예: 행렬 곱셈)</li>
<li><strong>요소별 연산 (Elementwise operations):</strong> 이러한 객체들을 개별 요소들의 컬렉션으로 취급합니다. (예: 요소별 곱셈)</li>
</ul>
<p>이 두 가지 연산은 같은 수식에 자주 혼합되어 사용되기 때문에, 문법적인 구분이 필요합니다.</p>
<p>많은 수치 계산 언어는 두 가지 수학 연산자 집합을 제공합니다. 예를 들어, MatLab에서는 일반적인 <code>op</code>가 객체별 연산에 사용되는 반면, <code>.op</code>는 요소별 연산에 사용됩니다. R에서는 <code>op</code>가 요소별 연산을 의미하는 반면, <code>%op%</code>는 객체별 연산을 의미합니다.</p>
<p>파이썬에서는 이러한 연산을 표현하는 다른 방법들이 있으며, 일부는 이미 기존 수치 패키지에서 사용되고 있습니다.</p>
<ul>
<li>함수 (function): <code>mul(a, b)</code></li>
<li>메서드 (method): <code>a.mul(b)</code></li>
<li>캐스팅 (casting): <code>a.E * b</code></li>
</ul>
<p>하지만 이러한 방법들은 중위 연산자 (infix operators)만큼 적절하지 않습니다. 주요 단점은 다음과 같습니다.</p>
<ul>
<li><strong>가독성 (Readability):</strong> 적당히 복잡한 수식에서도 중위 연산자가 대안보다 훨씬 깔끔합니다.</li>
<li><strong>익숙함 (Familiarity):</strong> 사용자들은 일반적인 수학 연산자에 익숙합니다.</li>
<li><strong>구현 (Implementation):</strong> 새로운 중위 연산자는 파이썬 문법을 과도하게 복잡하게 만들지 않을 것이며, 수치 패키지의 구현을 크게 용이하게 할 것입니다.</li>
</ul>
<p>현재 수학 연산자들을 하나의 의미론에 할당하는 것은 가능하지만, 다른 의미론을 위한 중위 연산자가 충분하지 않습니다. 또한, 한쪽이 일반적인 수학 연산자 기호를 포함하지 않는다면, 두 의미론 간의 시각적 대칭 (visual symmetry)을 유지하는 것도 불가능합니다.</p>
<h3>3. 제안된 확장 (Proposed extension)</h3>
<p>핵심 파이썬(core Python)에 여섯 가지 새로운 이항 중위 연산자 <code>~+ ~- ~* ~/ ~% ~**</code>가 추가됩니다. 이들은 기존 연산자 <code>+ - * / % **</code>와 유사합니다.</p>
<p>파이썬 2.0에서 사용 가능한 증강 할당 연산자 <code>+= -= *= /= %= **=</code>와 유사하게 <code>~+= ~-= ~*= ~/= ~%= ~**=</code> 여섯 가지 증강 할당 연산자도 핵심 파이썬에 추가됩니다.</p>
<ul>
<li>연산자 <code>~op</code>는 연산자 <code>op</code>의 문법적 속성 (구분 선호도 포함)을 유지합니다.</li>
<li>연산자 <code>~op</code>는 내장 숫자 타입 (built-in number types)에 대해 연산자 <code>op</code>의 의미론적 속성을 유지합니다.</li>
<li>연산자 <code>~op</code>는 비숫자 내장 타입 (non-number built-in types)에 대해 <strong>SyntaxError</strong>를 발생시킵니다. 이는 적절한 동작이 합의될 때까지의 임시 조치입니다.</li>
</ul>
<p>이러한 연산자들은 일반 수학 연산자의 이름 앞에 <code>t</code> (틸드(tilde)의 약어)를 붙인 이름으로 클래스에서 오버로드 (overload)할 수 있습니다. 예를 들어, <code>__add__</code>와 <code>__radd__</code>가 <code>+</code>에 대해 작동하는 것처럼 <code>__tadd__</code>와 <code>__rtadd__</code>는 <code>~+</code>에 대해 작동합니다. 기존 연산자와 마찬가지로, 왼쪽 피연산자가 적절한 메서드를 제공하지 않을 경우 <code>__r*__()</code> 메서드가 호출됩니다.</p>
<p><code>op</code> 또는 <code>~op</code> 중 한 세트가 요소별 연산에 사용되고, 다른 한 세트가 객체별 연산에 사용되도록 의도되었지만, 어떤 버전의 연산자가 요소별 또는 객체별 연산을 나타내는지는 명시적으로 지정되지 않으며, 결정은 애플리케이션에 맡겨집니다.</p>
<p>제안된 구현은 토크나이저 (tokenizer), 파서 (parser), 문법 (grammar), 컴파일러 (compiler) 관련 여러 파일을 패치하여 해당 기존 연산자의 기능을 필요에 따라 복제하는 것입니다. 모든 새로운 의미론은 이를 오버로드하는 클래스에서 구현됩니다.</p>
<p><code>~</code> 기호는 이미 파이썬에서 단항 비트wise not (bitwise not) 연산자로 사용됩니다. 현재 이항 연산자에는 허용되지 않습니다. 새로운 연산자들은 완전히 하위 호환됩니다.</p>
<h3>4. 프로토타입 구현 (Prototype Implementation)</h3>
<p>Greg Lielens는 파이썬 2.0b1 소스에 대한 패치로 중위 <code>~op</code>를 구현했습니다.</p>
<p><code>~</code>가 이항 연산자의 일부가 되도록 허용하기 위해, 토크나이저 (tokenizer)는 <code>~+</code>를 하나의 토큰으로 처리합니다. 이는 현재 유효한 표현식인 <code>~+1</code>이 <code>~ + 1</code> 대신 <code>~+ 1</code>로 토큰화된다는 것을 의미합니다. 파서 (parser)는 <code>~+</code>를 <code>~ +</code>의 합성으로 처리합니다. 이 효과는 애플리케이션에 보이지 않습니다.</p>
<p>현재 패치에 대한 참고사항:</p>
<ul>
<li>아직 <code>~op=</code> 연산자는 포함하지 않습니다.</li>
<li><code>~op</code>는 예외를 발생시키는 대신 리스트 (lists)에서 <code>op</code>와 동일하게 동작합니다.</li>
</ul>
<p>이러한 문제들은 이 제안의 최종 버전이 준비될 때 수정되어야 합니다.</p>
<p>이 패치는 <code>xor</code>를 다음과 같은 의미론을 갖는 중위 연산자로 예약합니다.</p>
<pre><code class="language-python">def __xor__(a, b):
    if not b: return a
    elif not a: return b
    else: 0
</code></pre>
<p>이는 가능한 한 참 값 (true value)을 보존하고, 그렇지 않다면 가능한 한 왼쪽 값 (left hand side value)을 보존합니다. 이는 향후 비트wise 연산자 (bitwise operators)가 요소별 논리 연산자 (elementwise logical operators)로 간주될 수 있도록 하기 위함입니다.</p>
<h3>5. 새로운 연산자 추가에 대한 대안 (Alternatives to adding new operators)</h3>
<p><code>comp.lang.python</code> 및 <code>python-dev</code> 메일링 리스트에서 많은 대안이 논의되었습니다. 곱셈 연산자를 예시로 들어 몇 가지 주요 대안은 다음과 같습니다.</p>
<h4>5.1. 함수 <code>mul(a, b)</code> 사용 (Use function <code>mul(a, b)</code>)</h4>
<ul>
<li><strong>장점:</strong> 새로운 연산자가 필요 없습니다.</li>
<li><strong>단점:</strong>
<ul>
<li>복합 수식에 대해 접두사 (prefix) 형태가 번거롭습니다.</li>
<li>대상 사용자에게 익숙하지 않습니다.</li>
<li>대상 사용자에게 너무 장황합니다.</li>
<li>자연스러운 연산자 우선순위 규칙을 사용할 수 없습니다.</li>
</ul>
</li>
</ul>
<h4>5.2. 메서드 호출 <code>a.mul(b)</code> 사용 (Use method call <code>a.mul(b)</code>)</h4>
<ul>
<li><strong>장점:</strong> 새로운 연산자가 필요 없습니다.</li>
<li><strong>단점:</strong>
<ul>
<li>양쪽 피연산자에 대해 비대칭적입니다.</li>
<li>대상 사용자에게 익숙하지 않습니다.</li>
<li>대상 사용자에게 너무 장황합니다.</li>
<li>자연스러운 연산자 우선순위 규칙을 사용할 수 없습니다.</li>
</ul>
</li>
</ul>
<h4>5.3. 쉐도우 클래스 (Shadow classes) 사용</h4>
<p>행렬 클래스에 대해 <code>.E</code> 메서드를 통해 접근 가능한 쉐도우 배열 클래스를 정의하여, 행렬 <code>a</code>와 <code>b</code>에 대해 <code>a.E * b</code>가 <code>elementwise_mul(a, b)</code>인 행렬 객체가 되도록 합니다. 마찬가지로, 배열에 대한 쉐도우 행렬 클래스를 <code>.M</code> 메서드를 통해 접근 가능하도록 정의하여, 배열 <code>a</code>와 <code>b</code>에 대해 <code>a.M * b</code>가 <code>matrixwise_mul(a, b)</code>인 배열이 되도록 합니다.</p>
<ul>
<li><strong>장점:</strong>
<ul>
<li>새로운 연산자가 필요 없습니다.</li>
<li>올바른 연산자 우선순위 규칙을 가진 중위 연산자의 이점을 얻습니다.</li>
<li>애플리케이션에서 깔끔한 수식이 가능합니다.</li>
</ul>
</li>
<li><strong>단점:</strong>
<ul>
<li>현재 파이썬에서는 일반 숫자가 사용자 정의 클래스 메서드를 가질 수 없기 때문에 유지 관리가 어렵습니다. 즉, <code>a</code>가 순수 숫자이면 <code>a.E * b</code>가 실패합니다.</li>
<li><code>T</code> (전치)와 같은 기존 메서드 호출과 충돌하기 때문에 구현이 어렵습니다.</li>
<li>객체 생성 및 메서드 검색에 따른 런타임 오버헤드 (runtime overhead)가 발생합니다.</li>
<li>쉐도잉 클래스는 진정한 클래스를 대체할 수 없습니다. 자체 타입을 반환하지 않기 때문입니다. 따라서 쉐도우 <code>E</code> 클래스를 가진 <code>M</code> 클래스와 쉐도우 <code>M</code> 클래스를 가진 <code>E</code> 클래스가 필요합니다.</li>
<li>수학자들에게는 부자연스럽습니다.</li>
</ul>
</li>
</ul>
<h4>5.4. 쉬운 캐스팅을 통한 행렬별/요소별 클래스 구현 (Implement matrixwise and elementwise classes with easy casting)</h4>
<p>배열에 대한 행렬별 연산은 <code>a.M * b.M</code>과 같고, 행렬에 대한 요소별 연산은 <code>a.E * b.E</code>와 같도록 합니다. 오류 감지를 위해 <code>a.E * b.M</code>은 예외를 발생시킵니다.</p>
<ul>
<li><strong>장점:</strong>
<ul>
<li>새로운 연산자가 필요 없습니다.</li>
<li>올바른 연산자 우선순위 규칙을 가진 중위 표기법과 유사합니다.</li>
</ul>
</li>
<li><strong>단점:</strong>
<ul>
<li>순수 숫자에 대한 사용자 메서드 부족으로 인한 유사한 어려움이 있습니다.</li>
<li>객체 생성 및 메서드 검색에 따른 런타임 오버헤드가 발생합니다.</li>
<li>더 복잡한 수식이 됩니다.</li>
<li>연산자를 용이하게 하기 위해 객체의 속성을 전환하는 것이 지속됩니다. 이는 애플리케이션 코드에 유지 관리가 극도로 어려운 장거리 컨텍스트 종속성 (context dependencies)을 도입합니다.</li>
</ul>
</li>
</ul>
<h4>5.5. 따옴표로 묶인 문자열에 임의의 확장으로 작성된 수식을 파싱하기 위한 미니 파서 (mini parser) 사용 (Using mini parser to parse formulas written in arbitrary extension placed in quoted strings)</h4>
<ul>
<li><strong>장점:</strong> 새로운 연산자 없이 순수 파이썬입니다.</li>
<li><strong>단점:</strong>
<ul>
<li>실제 문법은 따옴표로 묶인 문자열 내부에 있어 문제 자체를 해결하지 못합니다.</li>
<li>특수 문법 영역을 도입합니다.</li>
<li>미니 파서에 대한 요구가 많습니다.</li>
</ul>
</li>
</ul>
<h4>5.6. 행렬 곱셈을 위한 <code>@</code>와 같은 단일 연산자 도입 (Introducing a single operator, such as <code>@</code>, for matrix multiplication)</h4>
<ul>
<li><strong>장점:</strong> 더 적은 수의 연산자를 도입합니다.</li>
<li><strong>단점:</strong>
<ul>
<li><code>+ - **</code>와 같은 연산자들의 구분도 중요합니다.</li>
<li>행렬 또는 배열 지향 패키지에서의 의미가 역전될 수 있습니다. (아래 참조)</li>
<li>새로운 연산자가 특수 문자를 차지합니다.</li>
<li>더 일반적인 객체-요소 문제에는 잘 작동하지 않습니다.</li>
</ul>
</li>
</ul>
<p>이러한 대안들 중에서 첫 번째와 두 번째는 현재 애플리케이션에서 어느 정도 사용되지만, 부적절하다고 판단되었습니다. 세 번째는 애플리케이션에서 가장 선호되지만, 엄청난 구현 복잡성을 초래할 것입니다. 네 번째는 애플리케이션 코드를 매우 컨텍스트에 민감하게 만들고 유지 관리가 어렵게 만들 것입니다. 이 두 대안은 또한 현재의 타입/클래스 분할로 인해 상당한 구현 어려움을 겪습니다. 다섯 번째는 해결하는 문제보다 더 많은 문제를 야기하는 것으로 보입니다. 여섯 번째는 동일한 범위의 애플리케이션을 포괄하지 않습니다.</p>
<h3>6. 중위 연산자의 대안적 형태 (Alternative forms of infix operators)</h3>
<p>새로운 중위 연산자의 두 가지 주요 형태와 여러 사소한 변형이 논의되었습니다.</p>
<h4>6.1. 괄호형 (Bracketed form)</h4>
<p><code>(op)</code>, <code>[op]</code>, <code>{op}</code>, <code>&#x3C;op></code>, <code>:op:</code>, <code>~op~</code>, <code>%op%</code></p>
<h4>6.2. 메타 문자형 (Meta character form)</h4>
<p><code>.op</code>, <code>@op</code>, <code>~op</code>
또는 메타 문자가 연산자 뒤에 오는 형태도 논의되었습니다.</p>
<p>이러한 테마의 덜 일관된 변형들도 있었으나, 선호되지 않았습니다. 예를 들어,</p>
<ul>
<li>좌우 나눗셈을 위해 <code>@/</code> 및 <code>/</code> 사용</li>
<li>외적 (outer product) 및 내적 (inner product)을 위해 <code>[*]</code> 및 <code>(*)</code> 사용</li>
<li>곱셈을 위해 단일 연산자 <code>@</code> 사용</li>
</ul>
<p>표현 형태를 선택하는 기준은 다음과 같습니다.</p>
<ul>
<li>기존 연산자와의 문법적 모호성이 없어야 합니다.</li>
<li>실제 수식에서 더 높은 가독성을 가져야 합니다. (이로 인해 괄호형이 불리해집니다.)</li>
<li>기존 수학 연산자와 시각적으로 유사해야 합니다.</li>
<li>미래 확장을 막지 않으면서 문법적으로 단순해야 합니다.</li>
</ul>
<p>이러한 기준을 고려할 때, 괄호형 중에서는 <code>{op}</code>가 가장 유력한 것으로 나타났습니다. 메타 문자형 중에서는 <code>~op</code>가 명확한 우승자였습니다. 이들을 비교해 보면 <code>~op</code>가 모든 형태 중에서 가장 선호되었습니다.</p>
<p>몇 가지 분석은 다음과 같습니다.</p>
<ul>
<li><code>.op</code> 형태는 <code>1.+a</code>가 <code>1 .+a</code>와 다르게 해석될 수 있어 모호합니다.</li>
<li>괄호형 연산자는 단독으로 있을 때는 가장 좋지만, 수식에서는 괄호의 시각적 파싱과 함수 인자 (function argument)와 간섭하여 가독성을 해칩니다. <code>(op)</code>와 <code>[op]</code>가 특히 그렇고, <code>{op}</code>와 <code>&#x3C;op></code>는 다소 덜합니다.</li>
<li><code>&#x3C;op></code> 형태는 <code>&#x3C; ></code> 및 <code>=</code>와 혼동될 가능성이 있습니다.</li>
<li><code>@op</code>는 <code>@</code>가 시각적으로 무겁기 때문에 (<code>a@+b</code>가 <code>a@ + b</code>보다 <code>a @+ b</code>로 더 쉽게 읽힘) 선호되지 않았습니다.</li>
<li>메타 문자 선택에 있어서: 기존 ASCII 기호 대부분은 이미 사용되었습니다. 사용되지 않은 세 가지는 <code>@ $ ?</code>입니다.</li>
</ul>
<h3>7. 새로운 연산자의 의미론 (Semantics of new operators)</h3>
<p>두 가지 연산자 세트 (기존 <code>op</code>와 제안된 <code>~op</code>) 중 어느 것을 객체별 또는 요소별 연산에 사용할지에 대한 설득력 있는 주장이 모두 있었습니다.</p>
<h4>7.1. <code>op</code>는 요소별, <code>~op</code>는 객체별</h4>
<ul>
<li><code>Numeric</code> 패키지의 현재 <code>multiarray</code> 인터페이스와 일관적입니다.</li>
<li>일부 다른 언어와 일관적입니다.</li>
<li>요소별 연산이 더 자연스럽다는 인식.</li>
<li>요소별 연산이 더 자주 사용된다는 인식.</li>
</ul>
<h4>7.2. <code>op</code>는 객체별, <code>~op</code>는 요소별</h4>
<ul>
<li><code>MatPy</code> 패키지의 현재 선형 대수 인터페이스와 일관적입니다.</li>
<li>일부 다른 언어와 일관적입니다.</li>
<li>객체별 연산이 더 자연스럽다는 인식.</li>
<li>객체별 연산이 더 자주 사용된다는 인식.</li>
<li>리스트 (lists)에 대한 연산자의 현재 동작과 일관적입니다.</li>
<li><code>~</code>가 미래 확장에서 일반적인 요소별 메타 문자 (elementwise meta-character)가 될 수 있도록 허용합니다.</li>
</ul>
<p>일반적으로 다음과 같은 점들이 동의되었습니다.</p>
<ul>
<li>어느 한쪽을 선호할 절대적인 이유는 없습니다.</li>
<li>상당한 크기의 코드 덩어리에서 한 표현 방식에서 다른 표현 방식으로 쉽게 캐스팅할 수 있으므로, 다른 연산자 형태는 항상 소수일 것입니다.</li>
<li>연산자가 통일되더라도 배열 지향 (array-oriented) 및 행렬 지향 (matrix-oriented) 패키지의 존재를 선호하는 다른 의미론적 차이점이 있습니다.</li>
<li>어떤 결정이 내려지든, 기존 인터페이스를 사용하는 코드가 오랫동안 깨져서는 안 됩니다.</li>
</ul>
<p>따라서, 이 두 연산자 세트의 의미론적 특성이 핵심 언어에 의해 강제되지 않는다면, 잃는 것은 많지 않고 많은 유연성이 유지됩니다. 애플리케이션 패키지가 가장 적합한 선택을 할 책임이 있습니다. NumPy와 MatPy는 이미 반대 의미론을 사용하고 있으며, 이는 현재도 마찬가지입니다. 새로운 연산자를 추가해도 이를 깨뜨리지 않을 것입니다.</p>
<p>수치 정밀도 (numerical precision) 문제가 제기되었지만, 의미론이 애플리케이션에 맡겨진다면 실제 정밀도도 애플리케이션에 속해야 합니다.</p>
<h3>8. 예시 (Examples)</h3>
<p>다음은 위에 설명된 다양한 연산자 또는 다른 표현 방식을 사용하여 나타날 실제 수식의 예시입니다.</p>
<h4>8.1. 행렬 역산 (Matrix inversion formula)</h4>
<ul>
<li>
<p><code>op</code>를 객체별, <code>~op</code>를 요소별로 사용하는 경우:</p>
<pre><code>b = a.I - a.I * u / (c.I + v/a*u) * v / a
b = a.I - a.I * u * (c.I + v*a.I*u).I * v * a.I
</code></pre>
</li>
<li>
<p><code>op</code>를 요소별, <code>~op</code>를 객체별로 사용하는 경우:</p>
<pre><code>b = a.I @- a.I @* u @/ (c.I @+ v@/a@*u) @* v @/ a
b = a.I ~- a.I ~* u ~/ (c.I ~+ v~/a~*u) ~* v ~/ a
b = a.I (-) a.I (*) u (/) (c.I (+) v(/)a(*)u) (*) v (/) a
b = a.I [-] a.I [*] u [/] (c.I [+] v[/]a[*]u) [*] v [/] a
b = a.I &#x3C;-> a.I &#x3C;*> u &#x3C;/> (c.I &#x3C;+> v&#x3C;/>a&#x3C;*>u) &#x3C;*> v &#x3C;/> a
b = a.I {-} a.I {*} u {/} (c.I {+} v{/}a{*}u) {*} v {/} a
</code></pre>
</li>
<li>
<p><strong>관찰:</strong> 선형 대수 (linear algebra)에서 <code>op</code>를 객체별로 사용하는 것이 더 좋습니다.</p>
</li>
<li>
<p><strong>관찰:</strong> 복잡한 수식에서 <code>~op</code> 유형 연산자가 <code>(op)</code> 유형보다 더 보기 좋습니다.</p>
</li>
<li>
<p>명명된 연산자 (named operators)를 사용하는 경우:</p>
<pre><code>b = a.I @sub a.I @mul u @div (c.I @add v @div a @mul u) @mul v @div a
b = a.I ~sub a.I ~mul u ~div (c.I ~add v ~div a ~mul u) ~mul v ~div a
</code></pre>
</li>
<li>
<p><strong>관찰:</strong> 명명된 연산자는 수학 수식에 적합하지 않습니다.</p>
</li>
</ul>
<h4>8.2. 3D 그래프 플로팅 (Plotting a 3d graph)</h4>
<ul>
<li>
<p><code>op</code>를 객체별, <code>~op</code>를 요소별로 사용하는 경우:</p>
<pre><code class="language-python">z = sin(x~**2 ~+ y~**2); plot(x,y,z)
</code></pre>
</li>
<li>
<p><code>op</code>를 요소별, <code>~op</code>를 객체별로 사용하는 경우:</p>
<pre><code class="language-python">z = sin(x**2 + y**2); plot(x,y,z)
</code></pre>
</li>
<li>
<p><strong>관찰:</strong> 브로드캐스팅 (broadcasting)이 적용된 요소별 연산은 MatLab보다 훨씬 효율적인 구현을 가능하게 합니다.</p>
</li>
<li>
<p><strong>관찰:</strong> <code>op</code>와 <code>~op</code>의 의미론이 서로 바뀐 두 개의 관련 클래스를 갖는 것이 유용합니다. 이를 사용하면 <code>~op</code> 연산자는 다른 형태가 지배적인 코드 덩어리에서만 나타나면 되고, 코드의 일관된 의미론을 유지할 수 있습니다.</p>
</li>
<li>
<p>자동 브로드캐스팅이 적용된 <code>+</code> 및 <code>-</code> 사용:</p>
<pre><code class="language-python">a = b - c; d = a.T*a
</code></pre>
</li>
<li>
<p><strong>관찰:</strong> <code>b</code>나 <code>c</code> 중 하나가 행 벡터 (row vector)이고 다른 하나가 열 벡터 (column vector)인 경우, 이는 추적하기 어려운 버그를 소리 없이 생성할 수 있습니다.</p>
</li>
</ul>
<h3>9. 기타 문제 (Miscellaneous issues)</h3>
<h4>9.1. <code>~+ ~-</code> 연산자의 필요성</h4>
<p>객체별 <code>+ -</code>는 선형 대수 (linear algebra)에 따른 중요한 건전성 검사 (sanity checks)를 제공하므로 중요합니다. 요소별 <code>+ -</code>는 애플리케이션에서 매우 효율적인 브로드캐스팅 (broadcasting)을 허용하므로 중요합니다.</p>
<h4>9.2. 좌측 나눗셈 (Left division / solve)</h4>
<p>행렬의 경우, <code>a*x</code>는 <code>x*a</code>와 반드시 같지는 않습니다. <code>a*x==b</code>의 해 (Solution), 즉 <code>x=solve(a,b)</code>는 <code>x*a==b</code>의 해, 즉 <code>x=div(b,a)</code>와 다릅니다. <code>solve</code>에 대한 새로운 기호를 찾는 것에 대한 논의가 있었습니다. (배경: MatLab은 <code>div(b,a)</code>에 <code>b/a</code>를, <code>solve(a,b)</code>에 <code>a\b</code>를 사용합니다.)</p>
<p>파이썬은 새로운 기호 없이 더 나은 해결책을 제공한다는 점이 인식되었습니다. 즉, 역 메서드 <code>.I</code>를 지연시켜 <code>a.I*b</code>와 <code>b*a.I</code>가 MatLab의 <code>a\b</code>와 <code>b/a</code>와 동등하도록 만들 수 있습니다. 구현은 매우 간단하며 결과적인 애플리케이션 코드는 깔끔합니다.</p>
<h4>9.3. 거듭제곱 연산자 (Power operator)</h4>
<p>파이썬이 <code>a**b</code>를 <code>pow(a,b)</code>로 사용하는 데에는 두 가지 단점이 인식되었습니다.</p>
<ul>
<li>대부분의 수학자는 이 목적으로 <code>a^b</code>에 더 익숙합니다.</li>
<li><code>~**=</code>와 같은 긴 증강 할당 연산자가 발생합니다.
그러나 이 문제는 여기의 주요 문제와는 별개입니다.</li>
</ul>
<h4>9.4. 추가 곱셈 연산자 (Additional multiplication operators)</h4>
<p>(다중) 선형 대수학에서는 여러 형태의 곱셈이 사용됩니다. 대부분은 선형 대수학적 의미의 곱셈의 변형 (예: 크로네커 곱(Kronecker product))으로 볼 수 있습니다. 그러나 외적 (outer product)과 내적 (inner product)이라는 두 가지 형태가 더 근본적인 것으로 보입니다. 그러나 이들의 사양에는 다음 중 하나일 수 있는 인덱스 (indices)가 포함됩니다.</p>
<ul>
<li>연산자와 연관되거나,</li>
<li>객체와 연관됩니다.</li>
</ul>
<p>후자 (아인슈타인 표기법 (Einstein notation))는 종이에서 광범위하게 사용되며, 구현하기도 더 쉽습니다. 인덱스가 있는 텐서 클래스 (tensor-with-indices class)를 구현함으로써, 곱셈의 일반적인 형태는 외적과 내적을 모두 포함하고, 선형 대수 곱셈으로도 특수화될 것입니다. 인덱스 규칙은 다음과 같은 클래스 메서드로 정의될 수 있습니다.</p>
<pre><code class="language-python">a = b.i(1,2,-1,-2) * c.i(4,-2,3,-1) # a_ijkl = b_ijmn c_lnkm
</code></pre>
<p>따라서 하나의 객체별 곱셈으로 충분합니다.</p>
<h4>9.5. 비트wise 연산자 (Bitwise operators)</h4>
<p>제안된 새로운 수학 연산자들은 비트wise not 연산자인 <code>~</code> 기호를 사용합니다. 이는 호환성 문제를 일으키지 않지만 구현을 다소 복잡하게 만듭니다. <code>^</code> 기호는 비트wise <code>xor</code>보다 <code>pow</code>에 더 잘 사용될 수 있습니다. 그러나 이는 비트wise 연산자의 미래에 달려 있습니다. 제안된 수학 연산자에는 즉각적인 영향을 미치지 않습니다. <code>|</code> 기호는 행렬 해결 (matrix solve)에 사용될 것을 제안 받았지만, 지연된 <code>.I</code>를 사용하는 새로운 해결책이 여러 면에서 더 낫습니다. 현재 제안은 특수 비트wise 연산자의 필요성을 없앨 더 크고 일반적인 확장에 적합합니다. (아래 "일반적인 요소화에 미치는 영향" 참조)</p>
<h4>9.6. 정의에 사용된 특수 연산자 이름에 대한 대안</h4>
<p><code>def __add__(a, b)</code> 대신 <code>def "+"(a, b)</code></p>
<p>이는 더 큰 문법적 변경을 요구하는 것으로 보이며, 임의의 추가 연산자가 허용될 때만 유용할 것입니다.</p>
<h3>10. 일반적인 요소화에 미치는 영향 (Impact on general elementization)</h3>
<p>객체별 연산과 요소별 연산의 구분은 객체가 개념적으로 요소들의 컬렉션으로 간주될 수 있는 다른 컨텍스트에서도 의미가 있습니다. 현재 제안이 가능한 미래 확장을 배제하지 않는 것이 중요합니다.</p>
<p>하나의 일반적인 미래 확장은 <code>~</code>를 주어진 연산자를 요소화하는 메타 연산자로 사용하는 것입니다. 몇 가지 예는 다음과 같습니다.</p>
<h4>10.1. 비트wise 연산자 (Bitwise operators)</h4>
<p>현재 파이썬은 비트wise 연산에 여섯 가지 연산자 (<code>and</code> (<code>&#x26;</code>), <code>or</code> (<code>|</code>), <code>xor</code> (<code>^</code>), <code>complement</code> (<code>~</code>), <code>left shift</code> (<code>&#x3C;&#x3C;</code>), <code>right shift</code> (<code>>></code>))를 할당하며, 각각의 우선순위 수준이 있습니다. 이 중에서 <code>&#x26; | ^ ~</code> 연산자는 정수를 비트 문자열로 간주하여 적용되는 격자 연산자 (lattice operators)의 요소별 버전으로 간주될 수 있습니다.</p>
<pre><code class="language-python">5 &#x26; 6 # 4  (Binary: 101 &#x26; 110 = 100)
5 | 6 # 7  (Binary: 101 | 110 = 111)
5 ^ 6 # 3  (Binary: 101 ^ 110 = 011)
~5    # -6 (Binary: ~000...101 = 111...010)
</code></pre>
<p>제안된 <code>~</code> 연산자를 사용한다면 (예시들은 제안된 의미론을 나타내기 위함이며 실제 Python 코드 아님):</p>
<pre><code class="language-python"># 5 and 6 # 6 (이것은 논리 and, 비트wise &#x26; 5 &#x26; 6 은 4)
# 5 or 6 # 5  (이것은 논리 or, 비트wise | 5 | 6 은 7)
5 ~&#x26; 6 # 4  (제안된 요소별 비트wise and)
5 ~| 6 # 7  (제안된 요소별 비트wise or)
</code></pre>
<p>이들은 정수 내 비트에 국한되지 않고 일반적인 요소별 격자 연산자로 간주될 수 있습니다. <code>xor</code>에 대한 명명된 연산자 <code>~xor</code>를 가지려면 <code>xor</code>를 예약어 (reserved word)로 만들어야 합니다.</p>
<h4>10.2. 리스트 산술 (List arithmetics)</h4>
<pre><code class="language-python">[1, 2] + [3, 4]   # [1, 2, 3, 4] (리스트 연결)
[1, 2] ~+ [3, 4]  # [4, 6] (요소별 덧셈)
['a', 'b'] * 2   # ['a', 'b', 'a', 'b']
'ab' * 2         # 'abab'
['a', 'b'] ~* 2  # ['aa', 'bb'] (요소별 반복)
[1, 2] ~* 2      # [2, 4] (요소별 곱셈)
</code></pre>
<p>또한 카르테시안 곱 (Cartesian product)에도 일관적입니다.</p>
<pre><code class="language-python"># [1,2]*[3,4] # [(1,3),(1,4),(2,3),(2,4)]
</code></pre>
<h4>10.3. 리스트 컴프리헨션 (List comprehension)</h4>
<pre><code class="language-python">a = [1, 2]; b = [3, 4]
~f(a,b) # [f(x,y) for x, y in zip(a,b)]
~f(a*b) # [f(x,y) for x in a for y in b]
a ~+ b  # [x + y for x, y in zip(a,b)]
</code></pre>
<h4>10.4. 튜플 생성 (Tuple generation - Python 2.0의 <code>zip</code> 함수)</h4>
<pre><code class="language-python">[1, 2, 3], [4, 5, 6] # ([1, 2, 3], [4, 5, 6])
[1, 2, 3]~,[4, 5, 6] # [(1,4), (2, 5), (3,6)]
</code></pre>
<h4>10.5. <code>map</code>을 대체하는 일반 요소별 메타 문자 <code>~</code> 사용 (Using <code>~</code> as generic elementwise meta-character to replace <code>map</code>)</h4>
<pre><code class="language-python">~f(a, b)  # map(f, a, b)
~~f(a, b) # map(lambda *x:map(f, *x), a, b)
</code></pre>
<p>더 일반적으로:</p>
<pre><code class="language-python">def ~f(*x): return map(f, *x)
def ~~f(*x): return map(~f, *x)
</code></pre>
<h4>10.6. 요소별 포맷 연산자 (Elementwise format operator - 브로드캐스팅 포함)</h4>
<pre><code class="language-python">a = [1,2,3,4,5]
print ["%5d "] ~% a
a = [[1,2],[3,4]]
print ["%5d "] ~~% a
</code></pre>
<h4>10.7. 풍부한 비교 (Rich comparison)</h4>
<pre><code class="language-python">[1, 2, 3] ~&#x3C; [3, 2, 1]   # [1, 0, 0]
[1, 2, 3] ~== [3, 2, 1]  # [0, 1, 0]
</code></pre>
<h4>10.8. 풍부한 인덱싱 (Rich indexing)</h4>
<pre><code class="language-python">[a, b, c, d] ~[2, 3, 1] # [c, d, b]
</code></pre>
<h4>10.9. 튜플 평탄화 (Tuple flattening)</h4>
<pre><code class="language-python">a = (1,2); b = (3,4)
f(~a, ~b) # f(1,2,3,4)
</code></pre>
<h4>10.10. 복사 연산자 (Copy operator)</h4>
<pre><code class="language-python">a ~= b # a = b.copy()
</code></pre>
<p>특정 수준의 딥 카피 (deep copy)도 가능합니다.</p>
<pre><code class="language-python">a ~~= b # a = b.copy(2)
</code></pre>
<p><strong>참고:</strong> 이와 유사한 상황이 더 많을 수 있습니다. 이 일반적인 접근 방식은 각각에 대한 여러 분리된 확장 (병렬 및 교차 이터레이션 (parallel and cross iteration), 리스트 컴프리헨션 (list comprehension), 풍부한 비교 (rich comparison) 등) 대신 대부분의 상황에 잘 맞을 것으로 보입니다. 요소별 연산의 의미론은 애플리케이션에 따라 달라집니다. 예를 들어, 행렬의 요소는 리스트의 리스트 관점에서 두 단계 아래에 있습니다. 이는 현재 제안보다 더 근본적인 변화를 요구합니다. 어떤 경우든, 현재 제안은 이러한 성격의 미래 가능성에 부정적인 영향을 미 미치지 않을 것입니다.</p>
<p>이 섹션은 현재 제안과 일관성이 있지만 추가적인 호환성 또는 기타 문제를 제시할 수 있는 미래 확장 유형을 설명합니다. 이들은 현재 제안과 직접적으로 연결되어 있지 않습니다.</p>
<h3>11. 명명된 연산자에 미치는 영향 (Impact on named operators)</h3>
<p>논의를 통해 중위 연산자가 수치 계산뿐만 아니라 다른 분야에서도 파이썬에서 희소한 자원임이 일반적으로 분명해졌습니다. 명명된 함수 (named functions)와 유사한 방식으로 중위 연산자를 도입할 수 있는 여러 제안과 아이디어가 제시되었습니다. 현재 확장이 이와 관련하여 미래 확장에 부정적인 영향을 미치지 않음을 보여줍니다.</p>
<h4>11.1. 명명된 중위 연산자 (Named infix operators)</h4>
<p><code>@</code>와 같은 메타 문자를 선택하여, 모든 식별자 <code>opname</code>에 대해 <code>@opname</code> 조합이 이항 중위 연산자가 되고 <code>a @opname b == opname(a,b)</code>가 되도록 합니다.</p>
<p>언급된 다른 표현 방식은 다음과 같습니다.
<code>.name</code>, <code>~name~</code>, <code>:name:</code>, <code>(.name)</code>, <code>%name%</code> 및 유사한 변형들. 순수 괄호 기반 연산자는 이런 방식으로 사용될 수 없습니다.</p>
<p>이는 <code>@opname</code>를 인식하고 함수 호출과 동일한 구조로 파싱하기 위해 파서 (parser)에 대한 변경을 요구합니다. 이 모든 연산자의 우선순위는 한 수준으로 고정되어야 하므로, 기존 수학 연산자의 우선순위를 유지하는 추가 수학 연산자와는 구현이 다를 것입니다.</p>
<p>현재 제안된 확장은 이러한 형태의 가능한 미래 확장을 어떤 식으로든 제한하지 않습니다.</p>
<h4>11.2. 더 일반적인 기호 연산자 (More general symbolic operators)</h4>
<p>미래 확장의 추가적인 형태는 메타 문자와 연산자 기호 (연산자 외의 문법 구조에는 사용될 수 없는 기호)를 사용하는 것입니다. <code>@</code>가 메타 문자라고 가정하면:</p>
<p><code>a + b</code>, <code>a @+ b</code>, <code>a @@+ b</code>, <code>a @+- b</code></p>
<p>모두 우선순위 계층을 가진 연산자가 될 것이며, 다음과 같이 정의됩니다.</p>
<pre><code class="language-python">def "+"(a, b)
def "@+"(a, b)
def "@@+"(a, b)
def "@+-"(a, b)
</code></pre>
<p>명명된 연산자에 비해 메타 문자 또는 일반 연산자 기호를 기반으로 하는 우선순위에 대한 유연성이 더 크다는 장점이 있습니다. 이는 또한 연산자 구성 (operator composition)도 허용합니다. 단점은 "라인 노이즈" (line noise)와 더 비슷하다는 것입니다. 어떤 경우든 현재 제안은 미래 가능성에 영향을 미치지 않습니다.</p>
<p>이러한 종류의 미래 확장은 유니코드 (Unicode)가 일반적으로 사용 가능해지면 필요하지 않을 수도 있습니다.</p>
<p>이 섹션은 제안된 확장이 가능한 미래 확장과의 호환성을 논의합니다. 이러한 다른 확장 자체의 바람직성 또는 호환성은 여기에서 특별히 고려되지 않습니다.</p>
<h3>12. 감사의 말 및 아카이브 (Credits and archives)</h3>
<p>논의는 주로 2000년 7월부터 8월까지 <code>comp.lang.python</code> 뉴스 그룹과 <code>python-dev</code> 메일링 리스트에서 이루어졌습니다. 총 수백 개의 게시물이 있었으며, 대부분 다음 두 페이지에서 검색어 "operator"를 통해 검색할 수 있습니다.</p>
<ul>
<li><a href="http://www.python.org/pipermail/python-list/2000-July/">http://www.python.org/pipermail/python-list/2000-July/</a></li>
<li><a href="http://www.python.org/pipermail/python-list/2000-August/">http://www.python.org/pipermail/python-list/2000-August/</a></li>
</ul>
<p>이곳에 언급하기에는 너무 많은 기여자들의 이름이 있으며, 여기서 논의된 아이디어의 상당 부분이 우리의 것이 아님을 밝힙니다.</p>
<p>논의를 탐색하는 데 도움이 될 수 있는 몇 가지 주요 게시물 (작성자들의 관점)이 나열되어 있습니다.</p>
<ul>
<li><a href="http://www.python.org/pipermail/python-list/2000-July/108893.html">http://www.python.org/pipermail/python-list/2000-July/108893.html</a></li>
<li>... (생략) ...</li>
<li><a href="http://www.python.org/pipermail/python-dev/2000-August/014940.html">http://www.python.org/pipermail/python-dev/2000-August/014940.html</a></li>
</ul>
<p>이 PEP의 초기 초안은 다음 링크에서 확인할 수 있습니다.</p>
<ul>
<li><a href="http://www.python.org/pipermail/python-list/2000-August/111785.html">http://www.python.org/pipermail/python-list/2000-August/111785.html</a></li>
<li>... (생략) ...</li>
<li><a href="http://www.python.org/pipermail/python-dev/2000-August/014906.html">http://www.python.org/pipermail/python-dev/2000-August/014906.html</a></li>
</ul>
<p>Greg Wilson의 "Adding New Linear Algebra Operators to Python"이라는 제목의 대안 PEP (공식적으로 PEP 211)도 있습니다.
첫 번째 (그리고 현재) 버전은 다음 링크에서 확인할 수 있습니다.</p>
<ul>
<li><a href="http://www.python.org/pipermail/python-dev/2000-August/014876.html">http://www.python.org/pipermail/python-dev/2000-August/014876.html</a></li>
</ul>
<h3>13. 추가 참고 자료 (Additional References)</h3>
<p><a href="http://MatPy.sourceforge.net/Misc/index.html">http://MatPy.sourceforge.net/Misc/index.html</a></p>
<hr>
<p>최종 수정일: 2024-04-14 20:08:31 GMT</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
2:["$","div",null,{"className":"flex flex-col lg:flex-row gap-8","children":[["$","aside",null,{"className":"lg:w-64 xl:w-72 order-1 lg:order-none","children":["$","div",null,{"className":"sidebar sticky","children":["$","nav",null,{"className":"space-y-4","children":[["$","div","Backend",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Backend"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Django",{"children":["$","a",null,{"href":"/backend/django/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Django"," (",6,")"]}]}],["$","li","Logging",{"children":["$","a",null,{"href":"/backend/logging/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Logging"," (",1,")"]}]}]]}]]}],["$","div","Python",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"Python"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","PEP",{"children":["$","a",null,{"href":"/python/pep/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["PEP"," (",650,")"]}]}]]}]]}],["$","div","AI/ML",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"AI/ML"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","LLM",{"children":["$","a",null,{"href":"/ai/llm/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["LLM"," (",1,")"]}]}],["$","li","Review",{"children":["$","a",null,{"href":"/ai/review/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Review"," (",1025,")"]}]}]]}]]}],["$","div","DevOps",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"DevOps"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Nginx",{"children":["$","a",null,{"href":"/devops/nginx/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Nginx"," (",1,")"]}]}],["$","li","Docker",{"children":["$","a",null,{"href":"/devops/docker/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Docker"," (",1,")"]}]}],["$","li","SafeLine",{"children":["$","a",null,{"href":"/devops/safeline/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["SafeLine"," (",1,")"]}]}],["$","li","Jenkins",{"children":["$","a",null,{"href":"/devops/jenkins/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Jenkins"," (",3,")"]}]}],["$","li","GitHub Actions",{"children":["$","a",null,{"href":"/devops/github-actions/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["GitHub Actions"," (",1,")"]}]}],["$","li","AWS",{"children":["$","a",null,{"href":"/devops/aws/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["AWS"," (",1,")"]}]}]]}]]}],["$","div","etc",{"children":[["$","h4",null,{"className":"font-medium text-gray-900 mb-2","children":"etc"}],["$","ul",null,{"className":"space-y-1 ml-4","children":[["$","li","Me",{"children":["$","a",null,{"href":"/etc/me/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Me"," (",3,")"]}]}],["$","li","Chrome Extension",{"children":["$","a",null,{"href":"/etc/chrome-extension/","className":"text-sm text-gray-600 hover:text-primary-600 block py-1","children":["Chrome Extension"," (",1,")"]}]}]]}]]}]]}]}]}],["$","main",null,{"className":"flex-1","children":["$","article",null,{"className":"page","children":[["$","header",null,{"className":"mb-8","children":[["$","h1",null,{"className":"page__title","children":"[Rejected] PEP 225 - Elementwise/Objectwise Operators"}],["$","div",null,{"className":"page__meta","children":[["$","time",null,{"dateTime":"2025-09-26 16:45:47+0900","children":"2025년 9월 26일"}],["$","span",null,{"className":"ml-4","children":["수정: ","2025년 9월 26일"]}]]}]]}],["$","div",null,{"className":"page__content","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]}],["$","footer",null,{"className":"page__meta mt-8","children":["$","div",null,{"className":"page__taxonomy","children":[["$","h4",null,{"className":"text-sm font-medium text-gray-900 mb-2","children":"태그"}],[["$","span","Python",{"className":"page__taxonomy-item","children":["#","Python"]}],["$","span","PEP",{"className":"page__taxonomy-item","children":["#","PEP"]}],["$","span","Translation",{"className":"page__taxonomy-item","children":["#","Translation"]}]]]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"secrett2633's blog"}],["$","meta","3",{"name":"description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","4",{"name":"author","content":"secrett2633"}],["$","meta","5",{"name":"keywords","content":"Django, Python, DevOps, AI, ML, 블로그, 기술"}],["$","meta","6",{"name":"creator","content":"secrett2633"}],["$","meta","7",{"name":"publisher","content":"secrett2633"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","link","10",{"rel":"canonical","href":"https://secrett2633.github.io/"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"secrett2633's blog"}],["$","meta","13",{"property":"og:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","meta","14",{"property":"og:url","content":"https://secrett2633.github.io/"}],["$","meta","15",{"property":"og:site_name","content":"secrett2633's blog"}],["$","meta","16",{"property":"og:locale","content":"ko_KR"}],["$","meta","17",{"property":"og:type","content":"website"}],["$","meta","18",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","19",{"name":"twitter:title","content":"secrett2633's blog"}],["$","meta","20",{"name":"twitter:description","content":"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"}],["$","link","21",{"rel":"icon","href":"/icon.ico?6d9f34d4948640b8","type":"image/x-icon","sizes":"16x16"}],["$","meta","22",{"name":"next-size-adjust"}]]
1:null
