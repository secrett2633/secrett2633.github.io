<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-0249a4ed84fdbe73.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1214<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Active] PEP 12 - Sample reStructuredText PEP Template</h1><div class="page__meta"><time dateTime="2025-09-26 15:52:34+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0012/">PEP 12 - Sample reStructuredText PEP Template</a></p>
<p><strong>상태:</strong> Active | <strong>유형:</strong> Process | <strong>작성일:</strong> 05-Aug-2002</p>
</blockquote>
<p>PEP 12는 <code>reStructuredText</code> 형식으로 Python Enhancement Proposal (PEP)을 작성하기 위한 샘플 템플릿 문서입니다. 이 PEP의 목표는 새로운 PEP를 제출하려는 저자들이 표준화된 형식을 쉽게 따를 수 있도록 돕는 것입니다.</p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 <code>reStructuredText</code> 기반의 PEP를 생성하기 위한 기본적인 틀 또는 샘플 템플릿을 제공합니다. PEP 1의 내용 가이드라인과 함께 이 템플릿을 사용하면, PEP 저자는 자신의 PEP를 아래에 명시된 형식에 맞추어 쉽게 작성할 수 있습니다.</p>
<p><strong>참고:</strong> 웹에서 이 PEP를 읽고 있다면, 아래 단계를 완료하기 위해 먼저 이 PEP의 텍스트(<code>reStructuredText</code>) 소스 파일을 확보해야 합니다. HTML 파일을 템플릿으로 사용하지 마십시오!</p>
<p>이 PEP (및 모든 PEP)의 소스 파일은 PEPs 저장소 및 각 PEP 하단 링크를 통해 찾을 수 있습니다.</p>
<h2>도입 배경 (Rationale)</h2>
<p>PEP를 제출할 의향이 있다면, 형식이 맞지 않아 자동으로 거부되는 것을 방지하기 위해 이 템플릿을 아래의 형식 가이드라인과 함께 사용해야 합니다.</p>
<p><code>reStructuredText</code>는 PEP 저자에게 유용한 기능과 표현력을 제공하면서도, 소스 텍스트의 가독성을 유지합니다. 처리된 HTML 형식은 독자들에게 라이브 하이퍼링크, 스타일이 적용된 텍스트, 테이블, 이미지, 자동 목차 등 다양한 기능을 제공합니다.</p>
<h2>템플릿 사용 방법 (How to Use This Template)</h2>
<p>이 템플릿을 사용하려면 먼저 자신의 PEP가 Informational (정보성) 또는 Standards Track (표준 트랙) PEP 중 어떤 유형이 될지 결정해야 합니다. 대부분의 PEP는 Python 언어 또는 표준 라이브러리에 새로운 기능을 제안하기 때문에 Standards Track 유형에 속합니다. 확실하지 않다면 PEP 1을 참조하거나 PEPs 저장소에 이슈를 제기하여 도움을 요청하십시오.</p>
<p>PEP 유형을 결정한 후에는 다음 지침을 따릅니다.</p>
<ol>
<li>이 파일 (<code>.rst</code> 파일, HTML 아님!)을 복사합니다.</li>
<li>새 파일 이름을 <code>pep-NNNN.rst</code>로 지정합니다. 여기서 <code>NNNN</code>은 다음으로 사용 가능한 번호 (게시되었거나 PR에 있는 PEP에 사용되지 않은 번호)입니다. 파일 이름은 <code>pep-0012.rst</code>처럼 0으로 채워져야 하지만, 헤더(<code>PEP: 12</code>)는 0으로 채워지지 않습니다.</li>
<li>"PEP: 12" 헤더를 "PEP: NNNN"으로 변경하고 파일 이름과 일치시킵니다.</li>
<li>Title 헤더를 PEP의 제목으로 변경합니다.</li>
<li>Author 헤더에 이름과 선택적으로 이메일 주소를 포함하도록 변경합니다. 이름이 먼저 오고 괄호 안에 없어야 하며, 이메일 주소는 꺾쇠 괄호(<code>&#x3C; ></code>) 안에 있어야 합니다.</li>
<li>저자 중 Python 코어 개발자가 없는 경우, PEP를 후원하는 코어 개발자의 이름을 Sponsor 헤더에 추가합니다.</li>
<li>Discussions-To 헤더 아래에 PEP의 공식 토론 스레드(예: Python-Dev, Discourse 등)의 직접 URL을 추가합니다. (스레드가 공식 초안 제출 후 생성될 예정이라면 "Pending"으로 두었다가, PEP가 PEPs 저장소에 성공적으로 병합되고 해당 토론 스레드를 생성한 즉시 URL로 업데이트해야 합니다.) 자세한 내용은 PEP 1을 참조하십시오.</li>
<li>Status 헤더를 "Draft"로 변경합니다.</li>
<li>Standards Track PEP의 경우 Type 헤더를 "Standards Track"으로 변경합니다. Informational PEP의 경우 Type 헤더를 "Informational"으로 변경합니다.</li>
<li>Standards Track PEP의 경우, 제안하는 기능이 다른 개발 중인 PEP의 승인에 의존한다면 Type 헤더 바로 뒤에 Requires 헤더를 추가합니다. 값은 의존하는 PEP의 번호여야 합니다. (종속 기능이 Final PEP에 설명되어 있다면 이 헤더를 추가하지 마십시오.)</li>
<li>Created 헤더를 오늘 날짜로 변경합니다. <code>dd-mmm-yyyy</code> 형식 (예: <code>05-Aug-2002</code>)을 따릅니다.</li>
<li>Standards Track PEP의 경우, Created 헤더 뒤에 Python-Version 헤더를 추가하고 다음 계획된 Python 버전을 값으로 설정합니다. (알파 또는 베타 릴리스 지정을 사용하지 마십시오.)</li>
<li>PEP가 Topic Index에 표시된 토픽 중 하나에 속한다면 Topic 헤더를 추가합니다. 대부분의 PEP에는 해당하지 않습니다.</li>
<li>Post-History는 지금은 그대로 둡니다. PEP를 지정된 토론 포럼에 게시할 때마다 날짜와 해당 링크를 이 헤더에 추가합니다.</li>
<li>PEP가 이전 PEP를 대체하는 경우 Replaces 헤더를 추가합니다. 이 헤더의 값은 새 PEP가 대체하는 PEP의 번호입니다. (이전 PEP가 "final" 형식, 즉 Accepted, Final 또는 Rejected 상태인 경우에만 이 헤더를 추가합니다.)</li>
<li>이제 Abstract, Rationale 및 PEP의 다른 내용을 작성하여 이 템플릿의 내용을 자신의 텍스트로 대체합니다. (특히 탭 문자 금지 및 들여쓰기 요구 사항과 같은 형식 가이드라인을 준수하십시오.) "Suggested Sections"를 참조하여 포함할 섹션 템플릿을 확인하십시오.</li>
<li>Footnotes 섹션을 업데이트하고, 텍스트에서 참조된 모든 각주 및 비인라인 링크 대상을 나열합니다.</li>
<li><code>./build.py</code>를 실행하여 PEP가 오류 없이 렌더링되는지 확인하고, <code>build/pep-NNNN.html</code>의 출력이 의도한 대로 보이는지 확인합니다.</li>
<li>PEPs 저장소에 Pull Request를 생성합니다.</li>
</ol>
<h3>가능한 헤더 필드 (Possible Header Fields)</h3>
<p>다음은 가능한 모든 헤더 필드입니다 (대괄호 안의 내용은 대체하거나, 선행 <code>*</code>로 표시된 선택 사항이 해당하지 않으면 필드를 제거해야 합니다).</p>
<pre><code>PEP: [NNN]
Title: [...]
Author: [Full Name &#x3C;email at example.com>]
Sponsor: *[Full Name &#x3C;email at example.com>]
PEP-Delegate:
Discussions-To: [URL]
Status: Draft
Type: [Standards Track | Informational | Process]
Topic: *[Governance | Packaging | Release | Typing]
Requires: *[NNN]
Created: [DD-MMM-YYYY]
Python-Version: *[M.N]
Post-History: [`DD-MMM-YYYY &#x3C;URL>`__]
Replaces: *[NNN]
Superseded-By: *[NNN]
Resolution:
</code></pre>
<h2>reStructuredText PEP 형식 요구 사항 (ReStructuredText PEP Formatting Requirements)</h2>
<p>다음은 <code>reStructuredText</code> 문법에 대한 PEP별 요약입니다. 단순성과 간결성을 위해 많은 세부 사항은 생략됩니다. 자세한 내용은 아래 Resources 섹션을 참조하십시오. 예시에는 리터럴 블록(마크업 처리가 수행되지 않는 블록)이 사용되어 일반 텍스트 마크업을 보여줍니다.</p>
<h3>일반 (General)</h3>
<ul>
<li>줄은 일반적으로 79열을 넘지 않아야 합니다 (URL 등은 예외).</li>
<li>문서에는 탭 문자를 사용해서는 안 됩니다.</li>
</ul>
<h3>섹션 제목 (Section Headings)</h3>
<ul>
<li>
<p>PEP 제목은 0열에서 시작해야 하며, 책 제목처럼 각 단어의 첫 글자는 대문자로 표기해야 합니다. 약어는 모두 대문자여야 합니다.</p>
</li>
<li>
<p>섹션 제목은 밑줄로 장식되어야 하며, 밑줄은 0열에서 시작하여 제목 텍스트의 오른쪽 끝까지 (최소 4자) 확장되어야 합니다.</p>
<ul>
<li>1단계 섹션 제목은 <code>=</code> (등호)로 밑줄을 긋습니다.</li>
<li>2단계 섹션 제목은 <code>-</code> (하이픈)으로 밑줄을 긋습니다.</li>
<li>3단계 섹션 제목은 <code>''</code> (작은따옴표 또는 아포스트로피)로 밑줄을 긋습니다.</li>
<li>예시:
<pre><code>First-Level Title
=================
Second-Level Title
------------------
Third-Level Title
'''''''''''''''''
</code></pre>
</li>
</ul>
</li>
<li>
<p>PEP에 3단계 이상의 섹션이 있는 경우, 1단계 및 2단계에 대해 오버라인/밑줄로 장식된 제목을 다음과 같이 삽입할 수 있습니다.</p>
<pre><code>============================
First-Level Title (optional)
============================
-----------------------------
Second-Level Title (optional)
-----------------------------
Third-Level Title
=================
Fourth-Level Title
------------------
Fifth-Level Title
'''''''''''''''''
</code></pre>
</li>
<li>
<p>PEP에 5단계 이상의 섹션을 사용하지 않아야 합니다.</p>
</li>
<li>
<p>섹션 본문의 마지막 줄과 다음 섹션 제목 사이에는 두 개의 빈 줄을 사용해야 합니다. 하위 섹션 제목이 섹션 제목 바로 뒤에 오는 경우, 한 줄의 빈 줄로 충분합니다.</p>
</li>
<li>
<p>각 섹션의 본문은 일반적으로 들여쓰기되지 않습니다.</p>
</li>
</ul>
<h3>단락 (Paragraphs)</h3>
<ul>
<li>단락은 빈 줄로 구분된 왼쪽 정렬 텍스트 블록입니다.</li>
<li>블록 인용구나 목록 항목과 같은 들여쓰기된 구성의 일부가 아닌 한, 단락은 들여쓰기되지 않습니다.</li>
</ul>
<h3>인라인 마크업 (Inline Markup)</h3>
<ul>
<li>단락 및 기타 텍스트 블록 내의 일부 텍스트는 스타일을 지정할 수 있습니다.
<ul>
<li><code>*강조*</code> (단일 별표, 일반적으로 이탤릭체) 또는 <code>**강력 강조**</code> (이중 별표, 일반적으로 볼드체)로 텍스트를 표시할 수 있습니다.</li>
<li><code>인라인 리터럴</code> (이중 백틱 사용)은 일반적으로 모노스페이스 글꼴로 렌더링됩니다. 이중 백틱 내에서는 추가 마크업 인식이 수행되지 않으므로, 모든 종류의 코드 스니펫에 안전합니다.</li>
</ul>
</li>
</ul>
<h3>블록 인용 (Block Quotes)</h3>
<ul>
<li>
<p>블록 인용은 들여쓰기된 본문 요소로 구성됩니다.</p>
<pre><code>This is a paragraph.
    This is a block quote.
    A block quote may contain many paragraphs.
</code></pre>
</li>
<li>
<p>블록 인용은 다른 소스에서 가져온 긴 구절을 인용하는 데 사용됩니다.</p>
</li>
<li>
<p>각 들여쓰기 수준에 4칸 공백을 사용합니다.</p>
</li>
</ul>
<h3>리터럴 블록 (Literal Blocks)</h3>
<ul>
<li>
<p>리터럴 블록은 코드 샘플 및 기타 미리 서식화된 텍스트에 사용됩니다.</p>
</li>
<li>
<p>리터럴 블록을 나타내려면 들여쓰기된 텍스트 블록 앞에 <code>::</code> (두 개의 콜론)을 붙이거나 <code>.. code-block::</code> 지시문을 사용합니다.</p>
</li>
<li>
<p>텍스트 블록을 4칸 들여쓰기합니다. 리터럴 블록은 들여쓰기가 끝날 때까지 계속됩니다.</p>
<pre><code>This is a typical paragraph. A literal block follows.
::

    for a in [5, 4, 3, 2, 1]:    # this is program code, shown as-is
        print(a)
    print("it's...")
</code></pre>
</li>
<li>
<p><code>::</code>는 모든 단락 끝에서도 인식됩니다. 바로 앞에 공백이 없으면 최종 출력에는 하나의 콜론이 남습니다.</p>
</li>
<li>
<p>기본적으로 리터럴 블록은 Python 코드로 구문 강조 표시됩니다. 다른 언어/형식의 코드 또는 데이터를 포함하는 특정 블록의 경우, <code>.. code-block:: language</code> 지시문을 사용하고 <code>language</code> 대신 적절한 Pygments 렉서의 "짧은 이름"을 사용합니다 (또는 강조 표시를 비활성화하려면 <code>text</code>).</p>
</li>
<li>
<p>주로 특정 언어의 리터럴 블록을 포함하는 PEP의 경우, PEP 본문 상단 (헤더 아래, Abstract 위에)에 <code>.. highlight:: language</code> 지시문을 사용합니다. 이렇게 하면 <code>.. code-block</code>에서 달리 지정되지 않는 한 모든 리터럴 블록이 해당 언어로 처리됩니다.</p>
</li>
</ul>
<h3>목록 (Lists)</h3>
<ul>
<li>
<p>불릿 목록 항목은 <code>-</code>, <code>*</code>, 또는 <code>+</code> (하이픈, 별표 또는 더하기 기호) 중 하나로 시작하며, 그 뒤에 공백과 목록 항목 본문이 옵니다.</p>
</li>
<li>
<p>목록 항목 본문은 불릿에 상대적으로 왼쪽 정렬 및 들여쓰기되어야 합니다.</p>
<pre><code>This paragraph is followed by a list.
*   This is the first bullet list item.

*   This is the first paragraph in the second item in the list.
    This is the second paragraph in the second item in the list.

    - This is a sublist.
*   This is the third item of the main list.
This paragraph is not part of the list.
</code></pre>
</li>
<li>
<p>열거형(번호 매기기) 목록 항목은 불릿 대신 열거자를 사용한다는 점을 제외하고 유사합니다.</p>
<ul>
<li>열거자는 숫자(1, 2, 3, …), 문자(A, B, C, …; 대문자 또는 소문자), 또는 로마 숫자(i, ii, iii, iv, …; 대문자 또는 소문자)이며, 마침표 접미사("1.", "2."), 괄호("(1)", "(2)"), 또는 오른쪽 괄호 접미사("1)", "2)")로 형식이 지정됩니다.</li>
</ul>
<pre><code>1.  As with bullet list items, the left edge of paragraphs must align.
2.  Each list item may contain multiple paragraphs, sublists, etc.
    This is the second paragraph of the second list item.
    a) Enumerated lists may be nested.
    b) Blank lines may be omitted between list items.
</code></pre>
</li>
<li>
<p>정의 목록은 다음과 같이 작성됩니다.</p>
<pre><code>what
    Definition lists associate a term with a definition.
how
    The term is a one-line phrase, and the definition is one or more
    paragraphs or body elements, indented relative to the term.
</code></pre>
</li>
</ul>
<h3>표 (Tables)</h3>
<ul>
<li>
<p>단순한 표는 쉽고 간결합니다.</p>
<pre><code>===== ===== =======
A      B    A and B
===== ===== =======
False False False
True False False
False True False
True True True
===== ===== =======
</code></pre>
</li>
<li>
<p>표에는 최소 두 개의 열이 있어야 합니다 (섹션 제목과 구별하기 위해). 열 병합은 하이픈으로 밑줄을 사용합니다.</p>
</li>
<li>
<p>첫 번째 열 셀의 텍스트는 새 행을 시작합니다. 첫 번째 열에 텍스트가 없으면 계속되는 줄을 나타냅니다.</p>
</li>
</ul>
<h3>하이퍼링크 (Hyperlinks)</h3>
<ul>
<li>PEP 본문에서 외부 웹 페이지를 참조할 때, 페이지 제목이나 적절한 설명을 텍스트에 포함하고, 인라인 하이퍼링크 또는 URL이 있는 별도의 명시적 대상(explicit target)을 사용해야 합니다.</li>
<li>PEP 본문 텍스트에 순수 URL을 포함하지 말고, 가능한 경우 HTTPS 링크를 사용해야 합니다.</li>
<li>하이퍼링크 참조는 백틱과 뒤따르는 밑줄을 사용하여 참조 텍스트를 마크업합니다. 참조 텍스트가 단일 단어인 경우 백틱은 선택 사항입니다.
<ul>
<li>예시: <code>Python website</code>_</li>
</ul>
</li>
<li>링크를 한 번만 참조하고 텍스트와 함께 인라인으로 정의하려면, 연결하려는 텍스트 뒤에, 닫는 백틱 앞에, 그리고 텍스트와 여는 백틱 사이에 공백을 두고 꺾쇠 괄호(<code>&#x3C; ></code>) 안에 링크를 삽입합니다.
<ul>
<li>예시: <code>website &#x3C;https://www.python.org/></code>__ (이중 밑줄은 익명 참조를 만듭니다).</li>
</ul>
</li>
<li>하나의 링크를 여러 곳에서 다른 연결 텍스트와 함께 사용하거나, 연결 텍스트 변경 시 링크 대상 이름을 업데이트할 필요가 없도록 하려면, 연결할 텍스트 뒤에 꺾쇠 괄호 안에 대상 이름을 포함하고, 대상 이름 뒤에 닫는 꺾쇠 괄호 앞에 밑줄을 붙입니다.
<ul>
<li>예시: <code>documentation &#x3C;pydocs_></code>_</li>
</ul>
</li>
<li>명시적 대상은 URL을 제공합니다. 대상을 PEP 끝의 Footnotes 섹션이나 참조가 있는 단락 바로 뒤에 배치합니다. 하이퍼링크 대상은 두 개의 마침표와 공백으로 시작하고, 그 뒤에 선행 밑줄, 참조 텍스트, 콜론, 그리고 URL이 옵니다.
<pre><code>.. _Python web site: https://www.python.org/
.. _pydocs: https://docs.python.org/
</code></pre>
</li>
</ul>
<h3>내부 및 PEP/RFC 링크 (Internal and PEP/RFC Links)</h3>
<ul>
<li>하이퍼링크와 동일한 메커니즘을 내부 참조에도 사용할 수 있습니다. 모든 고유한 섹션 제목은 암시적으로 내부 하이퍼링크 대상을 정의합니다.
<ul>
<li>예시: <code>Abstract</code>_ 섹션 참조.</li>
</ul>
</li>
<li>PEPs 또는 RFCs를 참조하려면 항상 <code>:pep:</code> 및 <code>:rfc:</code> 역할을 사용하고, 하드코딩된 URL을 사용하지 마십시오.
<ul>
<li>예시: <code>See :pep:</code>1<code> for more information on how to write a PEP, and :pep:</code>the Hyperlink section of PEP 12 &#x3C;12#hyperlinks><code> for how to link.</code></li>
</ul>
</li>
</ul>
<h3>각주 (Footnotes)</h3>
<ul>
<li>
<p>각주 참조는 왼쪽 대괄호, 레이블, 오른쪽 대괄호, 그리고 뒤따르는 밑줄로 구성됩니다. 숫자 대신 <code>#word</code> 형식의 레이블을 사용합니다.</p>
<ul>
<li>예시: <code>The TeXbook [#TeXbook]_</code></li>
</ul>
</li>
<li>
<p>각주 참조 앞에는 공백이 있어야 합니다.</p>
</li>
<li>
<p>각주는 추가적인 노트, 설명, 경고, 그리고 온라인에서 쉽게 이용할 수 없는 책이나 다른 출처를 참조하는 데 사용됩니다.</p>
</li>
<li>
<p>각주는 <code>..</code>로 시작하고, 그 뒤에 각주 마커 (밑줄 없음), 그리고 각주 본문이 옵니다.</p>
<pre><code>.. [#TeXbook] Donald Knuth's *The TeXbook*, pages 195 and 196.
</code></pre>
</li>
<li>
<p>각주와 각주 참조는 자동으로 번호가 매겨집니다.</p>
</li>
</ul>
<h3>이미지 (Images)</h3>
<ul>
<li>
<p>PEP에 다이어그램이나 다른 그래픽이 포함된 경우, <code>image</code> 지시문을 사용하여 처리된 출력에 포함할 수 있습니다.</p>
<pre><code>.. image:: diagram.png
</code></pre>
</li>
<li>
<p>모든 브라우저 친화적인 그래픽 형식이 가능하지만, 그래픽에는 PNG, 사진에는 JPEG, 애니메이션에는 GIF를 선호해야 합니다. 현재 PEP 빌드 시스템과의 호환성 문제로 SVG는 피해야 합니다.</p>
</li>
<li>
<p>접근성과 소스 텍스트 독자를 위해, <code>image</code> 지시문의 <code>:alt:</code> 옵션을 사용하여 이미지에 대한 설명과 포함된 주요 정보를 포함해야 합니다.</p>
</li>
</ul>
<h3>주석 (Comments)</h3>
<ul>
<li>주석은 명시적 마크업 시작 (<code>.. </code>) 바로 뒤에 오는 들여쓰기된 임의의 텍스트 블록입니다.</li>
<li><code>..</code>를 자체 줄에 두어 주석이 다른 명시적 마크업 구성으로 오해되지 않도록 합니다.</li>
<li>주석은 처리된 문서에서 보이지 않습니다.
<pre><code>.. This section should be updated in the final PEP. Ensure the date is accurate.
</code></pre>
</li>
</ul>
<h3>이스케이프 메커니즘 (Escaping Mechanism)</h3>
<ul>
<li><code>reStructuredText</code>는 백슬래시(<code>\</code>)를 사용하여 마크업 문자에 부여된 특수 의미를 무시하고 리터럴 문자를 얻습니다. 리터럴 백슬래시를 얻으려면 이스케이프된 백슬래시(<code>\\</code>)를 사용합니다.</li>
<li>백슬래시에 특별한 의미가 없는 두 가지 컨텍스트가 있습니다: 리터럴 블록과 인라인 리터럴. 이러한 컨텍스트에서는 마크업 인식이 수행되지 않으며, 단일 백슬래시는 이중화할 필요 없이 리터럴 백슬래시를 나타냅니다.</li>
</ul>
<h3>Intersphinx</h3>
<ul>
<li>Intersphinx 참조를 사용하여 Python 문서 <code>packaging.python.org</code>, <code>typing.python.org</code>와 같은 다른 Sphinx 사이트로 쉽게 상호 참조하여 페이지, 섹션 및 Python/C 객체를 링크할 수 있습니다.
<ul>
<li>예시: <code>:ref:</code>type expression <a>typing:type-expression</a>``</li>
</ul>
</li>
</ul>
<h3>정식 문서 (Canonical Documentation)</h3>
<ul>
<li>PEP 1에 설명된 대로, PEP는 Final로 표시되면 역사적인 문서로 간주되며, 그 정식 문서/사양은 다른 곳으로 이동되어야 합니다.</li>
<li>이를 나타내기 위해 <code>canonical-doc</code> 지시문 또는 적절한 하위 클래스를 사용합니다.
<ul>
<li><code>packaging</code> 표준용: <code>canonical-pypa-spec</code></li>
<li><code>typing</code> 표준용: <code>canonical-typing-spec</code></li>
</ul>
</li>
<li>지시문을 헤더와 PEP의 첫 번째 섹션 (일반적으로 Abstract) 사이에 추가하고, 정식 문서/사양의 Intersphinx 참조를 인수로 전달합니다.
<ul>
<li>예시: <code>.. canonical-doc:: :mod:</code>python:sqlite3```</li>
</ul>
</li>
<li>이렇게 하면 다음과 같은 배너가 생성됩니다.
<pre><code>Important
This PEP is a historical document. The up-to-date, canonical documentation can now be found at sqlite3 .
</code></pre>
</li>
</ul>
<h2>피해야 할 습관 (Habits to Avoid)</h2>
<ul>
<li>TeX에 익숙한 많은 프로그래머는 따옴표를 <code>‘single-quoted’</code> 또는 <code>‘‘double-quoted’’</code>와 같이 작성합니다. <code>reStructuredText</code>에서는 백틱이 의미가 있으므로 이러한 관행은 피해야 합니다.</li>
<li>일반 텍스트의 경우 <code>'single-quotes'</code> 또는 <code>“double-quotes”</code>와 같은 일반 따옴표를 사용합니다.</li>
<li>인라인 리터럴 텍스트 (위의 Inline Markup 참조)의 경우 이중 백틱을 사용합니다.
<ul>
<li>예시: <code>literal text: in here, anything goes!</code></li>
</ul>
</li>
</ul>
<h2>제안 섹션 (Suggested Sections)</h2>
<p>다양한 섹션이 PEP 전반에 걸쳐 공통적으로 발견되며 PEP 1에 설명되어 있습니다. 이러한 섹션은 편의를 위해 여기에 제공됩니다.</p>
<pre><code>PEP: &#x3C;필수: pep 번호>
Title: &#x3C;필수: pep 제목>
Author: &#x3C;필수: 저자 이름 목록 및 선택적으로 이메일 주소>
Sponsor: &#x3C;후원자 이름>
PEP-Delegate: &#x3C;PEP 대리인 이름>
Discussions-To: Pending
Status: &#x3C;필수: Draft | Active | Accepted | Provisional | Deferred | Rejected | Withdrawn | Final | Superseded>
Type: &#x3C;필수: Standards Track | Informational | Process>
Topic: &#x3C;Governance | Packaging | Release | Typing>
Requires: &#x3C;pep 번호>
Created: &#x3C;생성 날짜, dd-mmm-yyyy 형식>
Python-Version: &#x3C;버전 번호>
Post-History: &#x3C;필수: 날짜, dd-mmm-yyyy 형식, 및 PEP 토론 스레드에 대한 해당 링크>
Replaces: &#x3C;pep 번호>
Superseded-By: &#x3C;pep 번호>
Resolution: &#x3C;url>

Abstract
========
[해결하고자 하는 기술적 문제에 대한 짧은(~200단어) 설명.]

Motivation
==========
[PEP가 해결하는 문제에 대해 기존 언어 사양이 왜 부적절한지 명확하게 설명.]

Rationale
=========
[특정 설계 결정이 왜 이루어졌는지 설명.]

Specification
=============
[새로운 언어 기능의 구문 및 의미 설명.]

Backwards Compatibility
=======================
[기존 코드에 미치는 잠재적 영향 및 심각도 설명.]

Security Implications
=====================
[악의적인 사용자가 이 새로운 기능을 어떻게 악용할 수 있는지.]

How to Teach This
=================
[사용자(초보 및 숙련자)에게 PEP를 작업에 적용하는 방법을 가르치는 방법.]

Reference Implementation
========================
[기존 구현에 대한 링크 및 해당 상태(예: 개념 증명)에 대한 세부 정보.]

Rejected Ideas
==============
[이 PEP를 논의하는 동안 제기된 특정 아이디어가 궁극적으로 채택되지 않은 이유.]

Open Issues
===========
[아직 결정/논의 중인 모든 사항.]

Acknowledgements
================
[PEP에 도움을 준 모든 사람들에게 감사.]

Footnotes
=========
[PEP에 인용된 각주 모음 및 비인라인 하이퍼링크 대상을 나열하는 곳.]

Copyright
=========
이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 조건으로 제공됩니다.
</code></pre>
<h2>자료 (Resources)</h2>
<p>기본 Docutils와 Sphinx에서 추가된 확장을 포함하여 많은 다른 구성과 변형이 가능합니다. 이에 대해 더 자세히 알아볼 수 있는 몇 가지 자료는 다음과 같습니다.</p>
<ul>
<li><a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html">Sphinx ReStructuredText Primer</a>: 부드럽지만 상당히 자세한 소개.</li>
<li><a href="https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html">reStructuredText Markup Specification</a>: 기본적인 reST 구문, 지시문, 역할 등에 대한 권위 있고 포괄적인 문서.</li>
<li><a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html">Sphinx Roles</a> 및 <a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html">Sphinx Directives</a>: PEP를 HTML로 렌더링하는 데 사용되는 Sphinx 문서 시스템에 의해 추가된 확장 구성.</li>
</ul>
<p>위 자료에서 다루지 않는 PEP 작성에 대한 질문이나 도움이 필요한 경우, GitHub의 <code>@python/pep-editors</code>를 태그하거나, PEPs 저장소에 이슈를 생성하거나, PEP 편집자에게 직접 문의하십시오.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 조건으로 제공됩니다.</p>
<hr>
<p><strong>최종 수정일:</strong> 2025-04-10 16:17:29 GMT
<strong>소스:</strong> <code>https://github.com/python/peps/blob/main/peps/pep-0012.rst</code></p>
<pre><code>Please let me know if you need any further assistance!
</code></pre>
<p>I have browsed the content of PEP 12.
Now I need to translate it into Korean, following all the guidelines:</p>
<ul>
<li>Professionalism in Python terminology.</li>
<li>Terminology handling (Korean if common, English original or 병기 if ambiguous/familiar, no translation for keywords/variable names).</li>
<li>Readability with Markdown.</li>
<li>Accuracy and completeness.</li>
<li>Structure: proposal content, background, impact on Python usage.</li>
</ul>
<p>Let's break down the translation process section by section.PEP 12는 <code>reStructuredText</code> 형식으로 Python Enhancement Proposal (PEP)을 작성하기 위한 샘플 템플릿 문서입니다. 이 PEP의 목표는 새로운 PEP를 제출하려는 저자들이 표준화된 형식을 쉽게 따를 수 있도록 돕는 것입니다.</p>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 <code>reStructuredText</code> 기반의 PEP를 생성하기 위한 기본적인 틀 또는 샘플 템플릿을 제공합니다. PEP 1의 내용 가이드라인과 함께 이 템플릿을 사용하면, PEP 저자는 자신의 PEP를 아래에 명시된 형식에 맞추어 쉽게 작성할 수 있습니다.</p>
<p><strong>참고:</strong> 웹에서 이 PEP를 읽고 있다면, 아래 단계를 완료하기 위해 먼저 이 PEP의 텍스트(<code>reStructuredText</code>) 소스 파일을 확보해야 합니다. HTML 파일을 템플릿으로 사용하지 마십시오!</p>
<p>이 PEP (및 모든 PEP)의 소스 파일은 PEPs 저장소 및 각 PEP 하단 링크를 통해 찾을 수 있습니다.</p>
<h2>도입 배경 (Rationale)</h2>
<p>PEP를 제출할 의향이 있다면, 형식이 맞지 않아 자동으로 거부되는 것을 방지하기 위해 이 템플릿을 아래의 형식 가이드라인과 함께 사용해야 합니다.</p>
<p><code>reStructuredText</code>는 PEP 저자에게 유용한 기능과 표현력을 제공하면서도, 소스 텍스트의 가독성을 유지합니다. 처리된 HTML 형식은 독자들에게 라이브 하이퍼링크, 스타일이 적용된 텍스트, 테이블, 이미지, 자동 목차 등 다양한 기능을 제공합니다.</p>
<h2>템플릿 사용 방법 (How to Use This Template)</h2>
<p>이 템플릿을 사용하려면 먼저 자신의 PEP가 Informational (정보성) 또는 Standards Track (표준 트랙) PEP 중 어떤 유형이 될지 결정해야 합니다. 대부분의 PEP는 Python 언어 또는 표준 라이브러리에 새로운 기능을 제안하기 때문에 Standards Track 유형에 속합니다. 확실하지 않다면 PEP 1을 참조하거나 PEPs 저장소에 이슈를 제기하여 도움을 요청하십시오.</p>
<p>PEP 유형을 결정한 후에는 다음 지침을 따릅니다.</p>
<ol>
<li>이 파일 (<code>.rst</code> 파일, HTML 아님!)을 복사합니다.</li>
<li>새 파일 이름을 <code>pep-NNNN.rst</code>로 지정합니다. 여기서 <code>NNNN</code>은 다음으로 사용 가능한 번호 (게시되었거나 PR에 있는 PEP에 사용되지 않은 번호)입니다. 파일 이름은 <code>pep-0012.rst</code>처럼 0으로 채워져야 하지만, 헤더(<code>PEP: 12</code>)는 0으로 채워지지 않습니다.</li>
<li>"PEP: 12" 헤더를 "PEP: NNNN"으로 변경하고 파일 이름과 일치시킵니다.</li>
<li>Title 헤더를 PEP의 제목으로 변경합니다.</li>
<li>Author 헤더에 이름과 선택적으로 이메일 주소를 포함하도록 변경합니다. 이름이 먼저 오고 괄호 안에 없어야 하며, 이메일 주소는 꺾쇠 괄호(<code>&#x3C; ></code>) 안에 있어야 합니다.</li>
<li>저자 중 Python 코어 개발자가 없는 경우, PEP를 후원하는 코어 개발자의 이름을 Sponsor 헤더에 추가합니다.</li>
<li>Discussions-To 헤더 아래에 PEP의 공식 토론 스레드(예: Python-Dev, Discourse 등)의 직접 URL을 추가합니다. (스레드가 공식 초안 제출 후 생성될 예정이라면 "Pending"으로 두었다가, PEP가 PEPs 저장소에 성공적으로 병합되고 해당 토론 스레드를 생성한 즉시 URL로 업데이트해야 합니다.) 자세한 내용은 PEP 1을 참조하십시오.</li>
<li>Status 헤더를 "Draft"로 변경합니다.</li>
<li>Standards Track PEP의 경우 Type 헤더를 "Standards Track"으로 변경합니다. Informational PEP의 경우 Type 헤더를 "Informational"으로 변경합니다.</li>
<li>Standards Track PEP의 경우, 제안하는 기능이 다른 개발 중인 PEP의 승인에 의존한다면 Type 헤더 바로 뒤에 Requires 헤더를 추가합니다. 값은 의존하는 PEP의 번호여야 합니다. (종속 기능이 Final PEP에 설명되어 있다면 이 헤더를 추가하지 마십시오.)</li>
<li>Created 헤더를 오늘 날짜로 변경합니다. <code>dd-mmm-yyyy</code> 형식 (예: <code>05-Aug-2002</code>)을 따릅니다.</li>
<li>Standards Track PEP의 경우, Created 헤더 뒤에 Python-Version 헤더를 추가하고 다음 계획된 Python 버전을 값으로 설정합니다. (알파 또는 베타 릴리스 지정을 사용하지 마십시오.)</li>
<li>PEP가 Topic Index에 표시된 토픽 중 하나에 속한다면 Topic 헤더를 추가합니다. 대부분의 PEP에는 해당하지 않습니다.</li>
<li>Post-History는 지금은 그대로 둡니다. PEP를 지정된 토론 포럼에 게시할 때마다 날짜와 해당 링크를 이 헤더에 추가합니다.</li>
<li>PEP가 이전 PEP를 대체하는 경우 Replaces 헤더를 추가합니다. 이 헤더의 값은 새 PEP가 대체하는 PEP의 번호입니다. (이전 PEP가 "final" 형식, 즉 Accepted, Final 또는 Rejected 상태인 경우에만 이 헤더를 추가합니다.)</li>
<li>이제 Abstract, Rationale 및 PEP의 다른 내용을 작성하여 이 템플릿의 내용을 자신의 텍스트로 대체합니다. (특히 탭 문자 금지 및 들여쓰기 요구 사항과 같은 형식 가이드라인을 준수하십시오.) "Suggested Sections"를 참조하여 포함할 섹션 템플릿을 확인하십시오.</li>
<li>Footnotes 섹션을 업데이트하고, 텍스트에서 참조된 모든 각주 및 비인라인 링크 대상을 나열합니다.</li>
<li><code>./build.py</code>를 실행하여 PEP가 오류 없이 렌더링되는지 확인하고, <code>build/pep-NNNN.html</code>의 출력이 의도한 대로 보이는지 확인합니다.</li>
<li>PEPs 저장소에 Pull Request를 생성합니다.</li>
</ol>
<h3>가능한 헤더 필드 (Possible Header Fields)</h3>
<p>다음은 가능한 모든 헤더 필드입니다 (대괄호 안의 내용은 대체하거나, 선행 <code>*</code>로 표시된 선택 사항이 해당하지 않으면 필드를 제거해야 합니다).</p>
<pre><code>PEP: [NNN]
Title: [...]
Author: [Full Name &#x3C;email at example.com>]
Sponsor: *[Full Name &#x3C;email at example.com>]
PEP-Delegate:
Discussions-To: [URL]
Status: Draft
Type: [Standards Track | Informational | Process]
Topic: *[Governance | Packaging | Release | Typing]
Requires: *[NNN]
Created: [DD-MMM-YYYY]
Python-Version: *[M.N]
Post-History: [`DD-MMM-YYYY &#x3C;URL>`__]
Replaces: *[NNN]
Superseded-By: *[NNN]
Resolution:
</code></pre>
<h2>reStructuredText PEP 형식 요구 사항 (ReStructuredText PEP Formatting Requirements)</h2>
<p>다음은 <code>reStructuredText</code> 문법에 대한 PEP별 요약입니다. 단순성과 간결성을 위해 많은 세부 사항은 생략됩니다. 자세한 내용은 아래 Resources 섹션을 참조하십시오. 예시에는 리터럴 블록(마크업 처리가 수행되지 않는 블록)이 사용되어 일반 텍스트 마크업을 보여줍니다.</p>
<h3>일반 (General)</h3>
<ul>
<li>줄은 일반적으로 79열을 넘지 않아야 합니다 (URL 등은 예외).</li>
<li>문서에는 탭 문자를 사용해서는 안 됩니다.</li>
</ul>
<h3>섹션 제목 (Section Headings)</h3>
<ul>
<li>
<p>PEP 제목은 0열에서 시작해야 하며, 책 제목처럼 각 단어의 첫 글자는 대문자로 표기해야 합니다. 약어는 모두 대문자여야 합니다.</p>
</li>
<li>
<p>섹션 제목은 밑줄로 장식되어야 하며, 밑줄은 0열에서 시작하여 제목 텍스트의 오른쪽 끝까지 (최소 4자) 확장되어야 합니다.</p>
<ul>
<li>1단계 섹션 제목은 <code>=</code> (등호)로 밑줄을 긋습니다.</li>
<li>2단계 섹션 제목은 <code>-</code> (하이픈)으로 밑줄을 긋습니다.</li>
<li>3단계 섹션 제목은 <code>''</code> (작은따옴표 또는 아포스트로피)로 밑줄을 긋습니다.</li>
<li>예시:
<pre><code>First-Level Title
=================
Second-Level Title
------------------
Third-Level Title
'''''''''''''''''
</code></pre>
</li>
</ul>
</li>
<li>
<p>PEP에 3단계 이상의 섹션이 있는 경우, 1단계 및 2단계에 대해 오버라인/밑줄로 장식된 제목을 다음과 같이 삽입할 수 있습니다.</p>
<pre><code>============================
First-Level Title (optional)
============================
-----------------------------
Second-Level Title (optional)
-----------------------------
Third-Level Title
=================
Fourth-Level Title
------------------
Fifth-Level Title
'''''''''''''''''
</code></pre>
</li>
<li>
<p>PEP에 5단계 이상의 섹션을 사용하지 않아야 합니다.</p>
</li>
<li>
<p>섹션 본문의 마지막 줄과 다음 섹션 제목 사이에는 두 개의 빈 줄을 사용해야 합니다. 하위 섹션 제목이 섹션 제목 바로 뒤에 오는 경우, 한 줄의 빈 줄로 충분합니다.</p>
</li>
<li>
<p>각 섹션의 본문은 일반적으로 들여쓰기되지 않습니다.</p>
</li>
</ul>
<h3>단락 (Paragraphs)</h3>
<ul>
<li>단락은 빈 줄로 구분된 왼쪽 정렬 텍스트 블록입니다.</li>
<li>블록 인용구나 목록 항목과 같은 들여쓰기된 구성의 일부가 아닌 한, 단락은 들여쓰기되지 않습니다.</li>
</ul>
<h3>인라인 마크업 (Inline Markup)</h3>
<ul>
<li>단락 및 기타 텍스트 블록 내의 일부 텍스트는 스타일을 지정할 수 있습니다.
<ul>
<li><code>*강조*</code> (단일 별표, 일반적으로 이탤릭체) 또는 <code>**강력 강조**</code> (이중 별표, 일반적으로 볼드체)로 텍스트를 표시할 수 있습니다.</li>
<li><code>인라인 리터럴</code> (이중 백틱 사용)은 일반적으로 모노스페이스 글꼴로 렌더링됩니다. 이중 백틱 내에서는 추가 마크업 인식이 수행되지 않으므로, 모든 종류의 코드 스니펫에 안전합니다.</li>
</ul>
</li>
</ul>
<h3>블록 인용 (Block Quotes)</h3>
<ul>
<li>
<p>블록 인용은 들여쓰기된 본문 요소로 구성됩니다.</p>
<pre><code>This is a paragraph.
    This is a block quote.
    A block quote may contain many paragraphs.
</code></pre>
</li>
<li>
<p>블록 인용은 다른 소스에서 가져온 긴 구절을 인용하는 데 사용됩니다.</p>
</li>
<li>
<p>각 들여쓰기 수준에 4칸 공백을 사용합니다.</p>
</li>
</ul>
<h3>리터럴 블록 (Literal Blocks)</h3>
<ul>
<li>
<p>리터럴 블록은 코드 샘플 및 기타 미리 서식화된 텍스트에 사용됩니다.</p>
</li>
<li>
<p>리터럴 블록을 나타내려면 들여쓰기된 텍스트 블록 앞에 <code>::</code> (두 개의 콜론)을 붙이거나 <code>.. code-block::</code> 지시문을 사용합니다.</p>
</li>
<li>
<p>텍스트 블록을 4칸 들여쓰기합니다. 리터럴 블록은 들여쓰기가 끝날 때까지 계속됩니다.</p>
<pre><code class="language-python">This is a typical paragraph. A literal block follows.
::

    for a in:    # this is program code, shown as-is
        print(a)
    print("it's...")
</code></pre>
</li>
<li>
<p><code>::</code>는 모든 단락 끝에서도 인식됩니다. 바로 앞에 공백이 없으면 최종 출력에는 하나의 콜론이 남습니다.</p>
</li>
<li>
<p>기본적으로 리터럴 블록은 Python 코드로 구문 강조 표시됩니다. 다른 언어/형식의 코드 또는 데이터를 포함하는 특정 블록의 경우, <code>.. code-block:: language</code> 지시문을 사용하고 <code>language</code> 대신 적절한 Pygments 렉서의 "짧은 이름"을 사용합니다 (또는 강조 표시를 비활성화하려면 <code>text</code>).</p>
</li>
<li>
<p>주로 특정 언어의 리터럴 블록을 포함하는 PEP의 경우, PEP 본문 상단 (헤더 아래, Abstract 위에)에 <code>.. highlight:: language</code> 지시문을 사용합니다. 이렇게 하면 <code>.. code-block</code>에서 달리 지정되지 않는 한 모든 리터럴 블록이 해당 언어로 처리됩니다.</p>
</li>
</ul>
<h3>목록 (Lists)</h3>
<ul>
<li>
<p>불릿 목록 항목은 <code>-</code>, <code>*</code>, 또는 <code>+</code> (하이픈, 별표 또는 더하기 기호) 중 하나로 시작하며, 그 뒤에 공백과 목록 항목 본문이 옵니다.</p>
</li>
<li>
<p>목록 항목 본문은 불릿에 상대적으로 왼쪽 정렬 및 들여쓰기되어야 합니다.</p>
<pre><code>This paragraph is followed by a list.
*   This is the first bullet list item.

*   This is the first paragraph in the second item in the list.
    This is the second paragraph in the second item in the list.

    - This is a sublist.
*   This is the third item of the main list.
This paragraph is not part of the list.
</code></pre>
</li>
<li>
<p>열거형(번호 매기기) 목록 항목은 불릿 대신 열거자를 사용한다는 점을 제외하고 유사합니다.</p>
<ul>
<li>열거자는 숫자(1, 2, 3, …), 문자(A, B, C, …; 대문자 또는 소문자), 또는 로마 숫자(i, ii, iii, iv, …; 대문자 또는 소문자)이며, 마침표 접미사("1.", "2."), 괄호("(1)", "(2)"), 또는 오른쪽 괄호 접미사("1)", "2)")로 형식이 지정됩니다.</li>
</ul>
<pre><code>1.  As with bullet list items, the left edge of paragraphs must align.
2.  Each list item may contain multiple paragraphs, sublists, etc.
    This is the second paragraph of the second list item.
    a) Enumerated lists may be nested.
    b) Blank lines may be omitted between list items.
</code></pre>
</li>
<li>
<p>정의 목록은 다음과 같이 작성됩니다.</p>
<pre><code>what
    Definition lists associate a term with a definition.
how
    The term is a one-line phrase, and the definition is one or more
    paragraphs or body elements, indented relative to the term.
</code></pre>
</li>
</ul>
<h3>표 (Tables)</h3>
<ul>
<li>
<p>단순한 표는 쉽고 간결합니다.</p>
<pre><code>===== ===== =======
A      B    A and B
===== ===== =======
False False False
True False False
False True False
True True False
True True True
===== ===== =======
</code></pre>
</li>
<li>
<p>표에는 최소 두 개의 열이 있어야 합니다 (섹션 제목과 구별하기 위해). 열 병합은 하이픈으로 밑줄을 사용합니다.</p>
</li>
<li>
<p>첫 번째 열 셀의 텍스트는 새 행을 시작합니다. 첫 번째 열에 텍스트가 없으면 계속되는 줄을 나타냅니다.</p>
</li>
</ul>
<h3>하이퍼링크 (Hyperlinks)</h3>
<ul>
<li>PEP 본문에서 외부 웹 페이지를 참조할 때, 페이지 제목이나 적절한 설명을 텍스트에 포함하고, 인라인 하이퍼링크 또는 URL이 있는 별도의 명시적 대상(explicit target)을 사용해야 합니다.</li>
<li>PEP 본문 텍스트에 순수 URL을 포함하지 말고, 가능한 경우 HTTPS 링크를 사용해야 합니다.</li>
<li>하이퍼링크 참조는 백틱과 뒤따르는 밑줄을 사용하여 참조 텍스트를 마크업합니다. 참조 텍스트가 단일 단어인 경우 백틱은 선택 사항입니다.
<ul>
<li>예시: <code>Python website</code>_</li>
</ul>
</li>
<li>링크를 한 번만 참조하고 텍스트와 함께 인라인으로 정의하려면, 연결하려는 텍스트 뒤에, 닫는 백틱 앞에, 그리고 텍스트와 여는 백틱 사이에 공백을 두고 꺾쇠 괄호(<code>&#x3C; ></code>) 안에 링크를 삽입합니다.
<ul>
<li>예시: <code>website &#x3C;https://www.python.org/></code>__ (이중 밑줄은 익명 참조를 만듭니다).</li>
</ul>
</li>
<li>하나의 링크를 여러 곳에서 다른 연결 텍스트와 함께 사용하거나, 연결 텍스트 변경 시 링크 대상 이름을 업데이트할 필요가 없도록 하려면, 연결할 텍스트 뒤에 꺾쇠 괄호 안에 대상 이름을 포함하고, 대상 이름 뒤에 닫는 꺾쇠 괄호 앞에 밑줄을 붙입니다.
<ul>
<li>예시: <code>documentation &#x3C;pydocs_></code>_</li>
</ul>
</li>
<li>명시적 대상은 URL을 제공합니다. 대상을 PEP 끝의 Footnotes 섹션이나 참조가 있는 단락 바로 뒤에 배치합니다. 하이퍼링크 대상은 두 개의 마침표와 공백으로 시작하고, 그 뒤에 선행 밑줄, 참조 텍스트, 콜론, 그리고 URL이 옵니다.
<pre><code>.. _Python web site: https://www.python.org/
.. _pydocs: https://docs.python.org/
</code></pre>
</li>
</ul>
<h3>내부 및 PEP/RFC 링크 (Internal and PEP/RFC Links)</h3>
<ul>
<li>하이퍼링크와 동일한 메커니즘을 내부 참조에도 사용할 수 있습니다. 모든 고유한 섹션 제목은 암시적으로 내부 하이퍼링크 대상을 정의합니다.
<ul>
<li>예시: <code>Abstract</code>_ 섹션 참조.</li>
</ul>
</li>
<li>PEPs 또는 RFCs를 참조하려면 항상 <code>:pep:</code> 및 <code>:rfc:</code> 역할을 사용하고, 하드코딩된 URL을 사용하지 마십시오.
<ul>
<li>예시: <code>See :pep:</code>1<code> for more information on how to write a PEP, and :pep:</code>the Hyperlink section of PEP 12 &#x3C;12#hyperlinks><code> for how to link.</code></li>
</ul>
</li>
</ul>
<h3>각주 (Footnotes)</h3>
<ul>
<li>
<p>각주 참조는 왼쪽 대괄호, 레이블, 오른쪽 대괄호, 그리고 뒤따르는 밑줄로 구성됩니다. 숫자 대신 <code>#word</code> 형식의 레이블을 사용합니다.</p>
<ul>
<li>예시: <code>The TeXbook [#TeXbook]_</code></li>
</ul>
</li>
<li>
<p>각주 참조 앞에는 공백이 있어야 합니다.</p>
</li>
<li>
<p>각주는 추가적인 노트, 설명, 경고, 그리고 온라인에서 쉽게 이용할 수 없는 책이나 다른 출처를 참조하는 데 사용됩니다.</p>
</li>
<li>
<p>각주는 <code>..</code>로 시작하고, 그 뒤에 각주 마커 (밑줄 없음), 그리고 각주 본문이 옵니다.</p>
<pre><code>.. [#TeXbook] Donald Knuth's *The TeXbook*, pages 195 and 196.
</code></pre>
</li>
<li>
<p>각주와 각주 참조는 자동으로 번호가 매겨집니다.</p>
</li>
</ul>
<h3>이미지 (Images)</h3>
<ul>
<li>
<p>PEP에 다이어그램이나 다른 그래픽이 포함된 경우, <code>image</code> 지시문을 사용하여 처리된 출력에 포함할 수 있습니다.</p>
<pre><code>.. image:: diagram.png
</code></pre>
</li>
<li>
<p>모든 브라우저 친화적인 그래픽 형식이 가능하지만, 그래픽에는 PNG, 사진에는 JPEG, 애니메이션에는 GIF를 선호해야 합니다. 현재 PEP 빌드 시스템과의 호환성 문제로 SVG는 피해야 합니다.</p>
</li>
<li>
<p>접근성과 소스 텍스트 독자를 위해, <code>image</code> 지시문의 <code>:alt:</code> 옵션을 사용하여 이미지에 대한 설명과 포함된 주요 정보를 포함해야 합니다.</p>
</li>
</ul>
<h3>주석 (Comments)</h3>
<ul>
<li>주석은 명시적 마크업 시작 (<code>.. </code>) 바로 뒤에 오는 들여쓰기된 임의의 텍스트 블록입니다.</li>
<li><code>..</code>를 자체 줄에 두어 주석이 다른 명시적 마크업 구성으로 오해되지 않도록 합니다.</li>
<li>주석은 처리된 문서에서 보이지 않습니다.
<pre><code>.. This section should be updated in the final PEP. Ensure the date is accurate.
</code></pre>
</li>
</ul>
<h3>이스케이프 메커니즘 (Escaping Mechanism)</h3>
<ul>
<li><code>reStructuredText</code>는 백슬래시(<code>\</code>)를 사용하여 마크업 문자에 부여된 특수 의미를 무시하고 리터럴 문자를 얻습니다. 리터럴 백슬래시를 얻으려면 이스케이프된 백슬래시(<code>\\</code>)를 사용합니다.</li>
<li>백슬래시에 특별한 의미가 없는 두 가지 컨텍스트가 있습니다: 리터럴 블록과 인라인 리터럴. 이러한 컨텍스트에서는 마크업 인식이 수행되지 않으며, 단일 백슬래시는 이중화할 필요 없이 리터럴 백슬래시를 나타냅니다.</li>
</ul>
<h3>Intersphinx</h3>
<ul>
<li>Intersphinx 참조를 사용하여 Python 문서 <code>packaging.python.org</code>, <code>typing.python.org</code>와 같은 다른 Sphinx 사이트로 쉽게 상호 참조하여 페이지, 섹션 및 Python/C 객체를 링크할 수 있습니다.
<ul>
<li>예시: <code>:ref:</code>type expression <a>typing:type-expression</a>``</li>
</ul>
</li>
</ul>
<h3>정식 문서 (Canonical Documentation)</h3>
<ul>
<li>PEP 1에 설명된 대로, PEP는 Final로 표시되면 역사적인 문서로 간주되며, 그 정식 문서/사양은 다른 곳으로 이동되어야 합니다.</li>
<li>이를 나타내기 위해 <code>canonical-doc</code> 지시문 또는 적절한 하위 클래스를 사용합니다.
<ul>
<li><code>packaging</code> 표준용: <code>canonical-pypa-spec</code></li>
<li><code>typing</code> 표준용: <code>canonical-typing-spec</code></li>
</ul>
</li>
<li>지시문을 헤더와 PEP의 첫 번째 섹션 (일반적으로 Abstract) 사이에 추가하고, 정식 문서/사양의 Intersphinx 참조를 인수로 전달합니다.
<ul>
<li>예시: <code>.. canonical-doc:: :mod:</code>python:sqlite3```</li>
</ul>
</li>
<li>이렇게 하면 다음과 같은 배너가 생성됩니다.
<pre><code>Important
This PEP is a historical document. The up-to-date, canonical documentation can now be found at sqlite3 .
</code></pre>
</li>
</ul>
<h2>피해야 할 습관 (Habits to Avoid)</h2>
<ul>
<li>TeX에 익숙한 많은 프로그래머는 따옴표를 <code>‘single-quoted’</code> 또는 <code>‘‘double-quoted’’</code>와 같이 작성합니다. <code>reStructuredText</code>에서는 백틱이 의미가 있으므로 이러한 관행은 피해야 합니다.</li>
<li>일반 텍스트의 경우 <code>'single-quotes'</code> 또는 <code>“double-quotes”</code>와 같은 일반 따옴표를 사용합니다.</li>
<li>인라인 리터럴 텍스트 (위의 Inline Markup 참조)의 경우 이중 백틱을 사용합니다.
<ul>
<li>예시: <code>literal text: in here, anything goes!</code></li>
</ul>
</li>
</ul>
<h2>제안 섹션 (Suggested Sections)</h2>
<p>다양한 섹션이 PEP 전반에 걸쳐 공통적으로 발견되며 PEP 1에 설명되어 있습니다. 이러한 섹션은 편의를 위해 여기에 제공됩니다.</p>
<pre><code>PEP: &#x3C;필수: pep 번호>
Title: &#x3C;필수: pep 제목>
Author: &#x3C;필수: 저자 이름 목록 및 선택적으로 이메일 주소>
Sponsor: &#x3C;후원자 이름>
PEP-Delegate: &#x3C;PEP 대리인 이름>
Discussions-To: Pending
Status: &#x3C;필수: Draft | Active | Accepted | Provisional | Deferred | Rejected | Withdrawn | Final | Superseded>
Type: &#x3C;필수: Standards Track | Informational | Process>
Topic: &#x3C;Governance | Packaging | Release | Typing>
Requires: &#x3C;pep 번호>
Created: &#x3C;생성 날짜, dd-mmm-yyyy 형식>
Python-Version: &#x3C;버전 번호>
Post-History: &#x3C;필수: 날짜, dd-mmm-yyyy 형식, 및 PEP 토론 스레드에 대한 해당 링크>
Replaces: &#x3C;pep 번호>
Superseded-By: &#x3C;pep 번호>
Resolution: &#x3C;url>

Abstract
========
[해결하고자 하는 기술적 문제에 대한 짧은(~200단어) 설명.]

Motivation
==========
[PEP가 해결하는 문제에 대해 기존 언어 사양이 왜 부적절한지 명확하게 설명.]

Rationale
=========
[특정 설계 결정이 왜 이루어졌는지 설명.]

Specification
=============
[새로운 언어 기능의 구문 및 의미 설명.]

Backwards Compatibility
=======================
[기존 코드에 미치는 잠재적 영향 및 심각도 설명.]

Security Implications
=====================
[악의적인 사용자가 이 새로운 기능을 어떻게 악용할 수 있는지.]

How to Teach This
=================
[사용자(초보 및 숙련자)에게 PEP를 작업에 적용하는 방법을 가르치는 방법.]

Reference Implementation
========================
[기존 구현에 대한 링크 및 해당 상태(예: 개념 증명)에 대한 세부 정보.]

Rejected Ideas
==============
[이 PEP를 논의하는 동안 제기된 특정 아이디어가 궁극적으로 채택되지 않은 이유.]

Open Issues
===========
[아직 결정/논의 중인 모든 사항.]

Acknowledgements
================
[PEP에 도움을 준 모든 사람들에게 감사.]

Footnotes
=========
[PEP에 인용된 각주 모음 및 비인라인 하이퍼링크 대상을 나열하는 곳.]

Copyright
=========
이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 조건으로 제공됩니다.
</code></pre>
<h2>자료 (Resources)</h2>
<p>기본 Docutils와 Sphinx에서 추가된 확장을 포함하여 많은 다른 구성과 변형이 가능합니다. 이에 대해 더 자세히 알아볼 수 있는 몇 가지 자료는 다음과 같습니다.</p>
<ul>
<li><a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html">Sphinx ReStructuredText Primer</a>: 부드럽지만 상당히 자세한 소개.</li>
<li><a href="https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html">reStructuredText Markup Specification</a>: 기본적인 reST 구문, 지시문, 역할 등에 대한 권위 있고 포괄적인 문서.</li>
<li><a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html">Sphinx Roles</a> 및 <a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html">Sphinx Directives</a>: PEP를 HTML로 렌더링하는 데 사용되는 Sphinx 문서 시스템에 의해 추가된 확장 구성.</li>
</ul>
<p>위 자료에서 다루지 않는 PEP 작성에 대한 질문이나 도움이 필요한 경우, GitHub의 <code>@python/pep-editors</code>를 태그하거나, PEPs 저장소에 이슈를 생성하거나, PEP 편집자에게 직접 문의하십시오.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 조건으로 제공됩니다.</p>
<hr>
<p><strong>최종 수정일:</strong> 2025-04-10 16:17:29 GMT
<strong>소스:</strong> <code>https://github.com/python/peps/blob/main/peps/pep-0012.rst</code></p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-0249a4ed84fdbe73.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-90448483657abf9e.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/12\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"SAPzS3zi9tsG5MkeKvxIA\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/12/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/12\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"12\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/12\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:Td0f7,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0012/\"\u003ePEP 12 - Sample reStructuredText PEP Template\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Active | \u003cstrong\u003e유형:\u003c/strong\u003e Process | \u003cstrong\u003e작성일:\u003c/strong\u003e 05-Aug-2002\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePEP 12는 \u003ccode\u003ereStructuredText\u003c/code\u003e 형식으로 Python Enhancement Proposal (PEP)을 작성하기 위한 샘플 템플릿 문서입니다. 이 PEP의 목표는 새로운 PEP를 제출하려는 저자들이 표준화된 형식을 쉽게 따를 수 있도록 돕는 것입니다.\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003ereStructuredText\u003c/code\u003e 기반의 PEP를 생성하기 위한 기본적인 틀 또는 샘플 템플릿을 제공합니다. PEP 1의 내용 가이드라인과 함께 이 템플릿을 사용하면, PEP 저자는 자신의 PEP를 아래에 명시된 형식에 맞추어 쉽게 작성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 웹에서 이 PEP를 읽고 있다면, 아래 단계를 완료하기 위해 먼저 이 PEP의 텍스트(\u003ccode\u003ereStructuredText\u003c/code\u003e) 소스 파일을 확보해야 합니다. HTML 파일을 템플릿으로 사용하지 마십시오!\u003c/p\u003e\n\u003cp\u003e이 PEP (및 모든 PEP)의 소스 파일은 PEPs 저장소 및 각 PEP 하단 링크를 통해 찾을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e도입 배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003ePEP를 제출할 의향이 있다면, 형식이 맞지 않아 자동으로 거부되는 것을 방지하기 위해 이 템플릿을 아래의 형식 가이드라인과 함께 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e는 PEP 저자에게 유용한 기능과 표현력을 제공하면서도, 소스 텍스트의 가독성을 유지합니다. 처리된 HTML 형식은 독자들에게 라이브 하이퍼링크, 스타일이 적용된 텍스트, 테이블, 이미지, 자동 목차 등 다양한 기능을 제공합니다.\u003c/p\u003e\n\u003ch2\u003e템플릿 사용 방법 (How to Use This Template)\u003c/h2\u003e\n\u003cp\u003e이 템플릿을 사용하려면 먼저 자신의 PEP가 Informational (정보성) 또는 Standards Track (표준 트랙) PEP 중 어떤 유형이 될지 결정해야 합니다. 대부분의 PEP는 Python 언어 또는 표준 라이브러리에 새로운 기능을 제안하기 때문에 Standards Track 유형에 속합니다. 확실하지 않다면 PEP 1을 참조하거나 PEPs 저장소에 이슈를 제기하여 도움을 요청하십시오.\u003c/p\u003e\n\u003cp\u003ePEP 유형을 결정한 후에는 다음 지침을 따릅니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e이 파일 (\u003ccode\u003e.rst\u003c/code\u003e 파일, HTML 아님!)을 복사합니다.\u003c/li\u003e\n\u003cli\u003e새 파일 이름을 \u003ccode\u003epep-NNNN.rst\u003c/code\u003e로 지정합니다. 여기서 \u003ccode\u003eNNNN\u003c/code\u003e은 다음으로 사용 가능한 번호 (게시되었거나 PR에 있는 PEP에 사용되지 않은 번호)입니다. 파일 이름은 \u003ccode\u003epep-0012.rst\u003c/code\u003e처럼 0으로 채워져야 하지만, 헤더(\u003ccode\u003ePEP: 12\u003c/code\u003e)는 0으로 채워지지 않습니다.\u003c/li\u003e\n\u003cli\u003e\"PEP: 12\" 헤더를 \"PEP: NNNN\"으로 변경하고 파일 이름과 일치시킵니다.\u003c/li\u003e\n\u003cli\u003eTitle 헤더를 PEP의 제목으로 변경합니다.\u003c/li\u003e\n\u003cli\u003eAuthor 헤더에 이름과 선택적으로 이메일 주소를 포함하도록 변경합니다. 이름이 먼저 오고 괄호 안에 없어야 하며, 이메일 주소는 꺾쇠 괄호(\u003ccode\u003e\u0026#x3C; \u003e\u003c/code\u003e) 안에 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e저자 중 Python 코어 개발자가 없는 경우, PEP를 후원하는 코어 개발자의 이름을 Sponsor 헤더에 추가합니다.\u003c/li\u003e\n\u003cli\u003eDiscussions-To 헤더 아래에 PEP의 공식 토론 스레드(예: Python-Dev, Discourse 등)의 직접 URL을 추가합니다. (스레드가 공식 초안 제출 후 생성될 예정이라면 \"Pending\"으로 두었다가, PEP가 PEPs 저장소에 성공적으로 병합되고 해당 토론 스레드를 생성한 즉시 URL로 업데이트해야 합니다.) 자세한 내용은 PEP 1을 참조하십시오.\u003c/li\u003e\n\u003cli\u003eStatus 헤더를 \"Draft\"로 변경합니다.\u003c/li\u003e\n\u003cli\u003eStandards Track PEP의 경우 Type 헤더를 \"Standards Track\"으로 변경합니다. Informational PEP의 경우 Type 헤더를 \"Informational\"으로 변경합니다.\u003c/li\u003e\n\u003cli\u003eStandards Track PEP의 경우, 제안하는 기능이 다른 개발 중인 PEP의 승인에 의존한다면 Type 헤더 바로 뒤에 Requires 헤더를 추가합니다. 값은 의존하는 PEP의 번호여야 합니다. (종속 기능이 Final PEP에 설명되어 있다면 이 헤더를 추가하지 마십시오.)\u003c/li\u003e\n\u003cli\u003eCreated 헤더를 오늘 날짜로 변경합니다. \u003ccode\u003edd-mmm-yyyy\u003c/code\u003e 형식 (예: \u003ccode\u003e05-Aug-2002\u003c/code\u003e)을 따릅니다.\u003c/li\u003e\n\u003cli\u003eStandards Track PEP의 경우, Created 헤더 뒤에 Python-Version 헤더를 추가하고 다음 계획된 Python 버전을 값으로 설정합니다. (알파 또는 베타 릴리스 지정을 사용하지 마십시오.)\u003c/li\u003e\n\u003cli\u003ePEP가 Topic Index에 표시된 토픽 중 하나에 속한다면 Topic 헤더를 추가합니다. 대부분의 PEP에는 해당하지 않습니다.\u003c/li\u003e\n\u003cli\u003ePost-History는 지금은 그대로 둡니다. PEP를 지정된 토론 포럼에 게시할 때마다 날짜와 해당 링크를 이 헤더에 추가합니다.\u003c/li\u003e\n\u003cli\u003ePEP가 이전 PEP를 대체하는 경우 Replaces 헤더를 추가합니다. 이 헤더의 값은 새 PEP가 대체하는 PEP의 번호입니다. (이전 PEP가 \"final\" 형식, 즉 Accepted, Final 또는 Rejected 상태인 경우에만 이 헤더를 추가합니다.)\u003c/li\u003e\n\u003cli\u003e이제 Abstract, Rationale 및 PEP의 다른 내용을 작성하여 이 템플릿의 내용을 자신의 텍스트로 대체합니다. (특히 탭 문자 금지 및 들여쓰기 요구 사항과 같은 형식 가이드라인을 준수하십시오.) \"Suggested Sections\"를 참조하여 포함할 섹션 템플릿을 확인하십시오.\u003c/li\u003e\n\u003cli\u003eFootnotes 섹션을 업데이트하고, 텍스트에서 참조된 모든 각주 및 비인라인 링크 대상을 나열합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e./build.py\u003c/code\u003e를 실행하여 PEP가 오류 없이 렌더링되는지 확인하고, \u003ccode\u003ebuild/pep-NNNN.html\u003c/code\u003e의 출력이 의도한 대로 보이는지 확인합니다.\u003c/li\u003e\n\u003cli\u003ePEPs 저장소에 Pull Request를 생성합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e가능한 헤더 필드 (Possible Header Fields)\u003c/h3\u003e\n\u003cp\u003e다음은 가능한 모든 헤더 필드입니다 (대괄호 안의 내용은 대체하거나, 선행 \u003ccode\u003e*\u003c/code\u003e로 표시된 선택 사항이 해당하지 않으면 필드를 제거해야 합니다).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePEP: [NNN]\r\nTitle: [...]\r\nAuthor: [Full Name \u0026#x3C;email at example.com\u003e]\r\nSponsor: *[Full Name \u0026#x3C;email at example.com\u003e]\r\nPEP-Delegate:\r\nDiscussions-To: [URL]\r\nStatus: Draft\r\nType: [Standards Track | Informational | Process]\r\nTopic: *[Governance | Packaging | Release | Typing]\r\nRequires: *[NNN]\r\nCreated: [DD-MMM-YYYY]\r\nPython-Version: *[M.N]\r\nPost-History: [`DD-MMM-YYYY \u0026#x3C;URL\u003e`__]\r\nReplaces: *[NNN]\r\nSuperseded-By: *[NNN]\r\nResolution:\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ereStructuredText PEP 형식 요구 사항 (ReStructuredText PEP Formatting Requirements)\u003c/h2\u003e\n\u003cp\u003e다음은 \u003ccode\u003ereStructuredText\u003c/code\u003e 문법에 대한 PEP별 요약입니다. 단순성과 간결성을 위해 많은 세부 사항은 생략됩니다. 자세한 내용은 아래 Resources 섹션을 참조하십시오. 예시에는 리터럴 블록(마크업 처리가 수행되지 않는 블록)이 사용되어 일반 텍스트 마크업을 보여줍니다.\u003c/p\u003e\n\u003ch3\u003e일반 (General)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e줄은 일반적으로 79열을 넘지 않아야 합니다 (URL 등은 예외).\u003c/li\u003e\n\u003cli\u003e문서에는 탭 문자를 사용해서는 안 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e섹션 제목 (Section Headings)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ePEP 제목은 0열에서 시작해야 하며, 책 제목처럼 각 단어의 첫 글자는 대문자로 표기해야 합니다. 약어는 모두 대문자여야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e섹션 제목은 밑줄로 장식되어야 하며, 밑줄은 0열에서 시작하여 제목 텍스트의 오른쪽 끝까지 (최소 4자) 확장되어야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1단계 섹션 제목은 \u003ccode\u003e=\u003c/code\u003e (등호)로 밑줄을 긋습니다.\u003c/li\u003e\n\u003cli\u003e2단계 섹션 제목은 \u003ccode\u003e-\u003c/code\u003e (하이픈)으로 밑줄을 긋습니다.\u003c/li\u003e\n\u003cli\u003e3단계 섹션 제목은 \u003ccode\u003e''\u003c/code\u003e (작은따옴표 또는 아포스트로피)로 밑줄을 긋습니다.\u003c/li\u003e\n\u003cli\u003e예시:\n\u003cpre\u003e\u003ccode\u003eFirst-Level Title\r\n=================\r\nSecond-Level Title\r\n------------------\r\nThird-Level Title\r\n'''''''''''''''''\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePEP에 3단계 이상의 섹션이 있는 경우, 1단계 및 2단계에 대해 오버라인/밑줄로 장식된 제목을 다음과 같이 삽입할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e============================\r\nFirst-Level Title (optional)\r\n============================\r\n-----------------------------\r\nSecond-Level Title (optional)\r\n-----------------------------\r\nThird-Level Title\r\n=================\r\nFourth-Level Title\r\n------------------\r\nFifth-Level Title\r\n'''''''''''''''''\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePEP에 5단계 이상의 섹션을 사용하지 않아야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e섹션 본문의 마지막 줄과 다음 섹션 제목 사이에는 두 개의 빈 줄을 사용해야 합니다. 하위 섹션 제목이 섹션 제목 바로 뒤에 오는 경우, 한 줄의 빈 줄로 충분합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각 섹션의 본문은 일반적으로 들여쓰기되지 않습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e단락 (Paragraphs)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e단락은 빈 줄로 구분된 왼쪽 정렬 텍스트 블록입니다.\u003c/li\u003e\n\u003cli\u003e블록 인용구나 목록 항목과 같은 들여쓰기된 구성의 일부가 아닌 한, 단락은 들여쓰기되지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e인라인 마크업 (Inline Markup)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e단락 및 기타 텍스트 블록 내의 일부 텍스트는 스타일을 지정할 수 있습니다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e*강조*\u003c/code\u003e (단일 별표, 일반적으로 이탤릭체) 또는 \u003ccode\u003e**강력 강조**\u003c/code\u003e (이중 별표, 일반적으로 볼드체)로 텍스트를 표시할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e인라인 리터럴\u003c/code\u003e (이중 백틱 사용)은 일반적으로 모노스페이스 글꼴로 렌더링됩니다. 이중 백틱 내에서는 추가 마크업 인식이 수행되지 않으므로, 모든 종류의 코드 스니펫에 안전합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e블록 인용 (Block Quotes)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e블록 인용은 들여쓰기된 본문 요소로 구성됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eThis is a paragraph.\r\n    This is a block quote.\r\n    A block quote may contain many paragraphs.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e블록 인용은 다른 소스에서 가져온 긴 구절을 인용하는 데 사용됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각 들여쓰기 수준에 4칸 공백을 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e리터럴 블록 (Literal Blocks)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e리터럴 블록은 코드 샘플 및 기타 미리 서식화된 텍스트에 사용됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e리터럴 블록을 나타내려면 들여쓰기된 텍스트 블록 앞에 \u003ccode\u003e::\u003c/code\u003e (두 개의 콜론)을 붙이거나 \u003ccode\u003e.. code-block::\u003c/code\u003e 지시문을 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e텍스트 블록을 4칸 들여쓰기합니다. 리터럴 블록은 들여쓰기가 끝날 때까지 계속됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eThis is a typical paragraph. A literal block follows.\r\n::\r\n\r\n    for a in [5, 4, 3, 2, 1]:    # this is program code, shown as-is\r\n        print(a)\r\n    print(\"it's...\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e::\u003c/code\u003e는 모든 단락 끝에서도 인식됩니다. 바로 앞에 공백이 없으면 최종 출력에는 하나의 콜론이 남습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e기본적으로 리터럴 블록은 Python 코드로 구문 강조 표시됩니다. 다른 언어/형식의 코드 또는 데이터를 포함하는 특정 블록의 경우, \u003ccode\u003e.. code-block:: language\u003c/code\u003e 지시문을 사용하고 \u003ccode\u003elanguage\u003c/code\u003e 대신 적절한 Pygments 렉서의 \"짧은 이름\"을 사용합니다 (또는 강조 표시를 비활성화하려면 \u003ccode\u003etext\u003c/code\u003e).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e주로 특정 언어의 리터럴 블록을 포함하는 PEP의 경우, PEP 본문 상단 (헤더 아래, Abstract 위에)에 \u003ccode\u003e.. highlight:: language\u003c/code\u003e 지시문을 사용합니다. 이렇게 하면 \u003ccode\u003e.. code-block\u003c/code\u003e에서 달리 지정되지 않는 한 모든 리터럴 블록이 해당 언어로 처리됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e목록 (Lists)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e불릿 목록 항목은 \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e*\u003c/code\u003e, 또는 \u003ccode\u003e+\u003c/code\u003e (하이픈, 별표 또는 더하기 기호) 중 하나로 시작하며, 그 뒤에 공백과 목록 항목 본문이 옵니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e목록 항목 본문은 불릿에 상대적으로 왼쪽 정렬 및 들여쓰기되어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eThis paragraph is followed by a list.\r\n*   This is the first bullet list item.\r\n\r\n*   This is the first paragraph in the second item in the list.\r\n    This is the second paragraph in the second item in the list.\r\n\r\n    - This is a sublist.\r\n*   This is the third item of the main list.\r\nThis paragraph is not part of the list.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e열거형(번호 매기기) 목록 항목은 불릿 대신 열거자를 사용한다는 점을 제외하고 유사합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e열거자는 숫자(1, 2, 3, …), 문자(A, B, C, …; 대문자 또는 소문자), 또는 로마 숫자(i, ii, iii, iv, …; 대문자 또는 소문자)이며, 마침표 접미사(\"1.\", \"2.\"), 괄호(\"(1)\", \"(2)\"), 또는 오른쪽 괄호 접미사(\"1)\", \"2)\")로 형식이 지정됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003e1.  As with bullet list items, the left edge of paragraphs must align.\r\n2.  Each list item may contain multiple paragraphs, sublists, etc.\r\n    This is the second paragraph of the second list item.\r\n    a) Enumerated lists may be nested.\r\n    b) Blank lines may be omitted between list items.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e정의 목록은 다음과 같이 작성됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewhat\r\n    Definition lists associate a term with a definition.\r\nhow\r\n    The term is a one-line phrase, and the definition is one or more\r\n    paragraphs or body elements, indented relative to the term.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e표 (Tables)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e단순한 표는 쉽고 간결합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e===== ===== =======\r\nA      B    A and B\r\n===== ===== =======\r\nFalse False False\r\nTrue False False\r\nFalse True False\r\nTrue True True\r\n===== ===== =======\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e표에는 최소 두 개의 열이 있어야 합니다 (섹션 제목과 구별하기 위해). 열 병합은 하이픈으로 밑줄을 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e첫 번째 열 셀의 텍스트는 새 행을 시작합니다. 첫 번째 열에 텍스트가 없으면 계속되는 줄을 나타냅니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e하이퍼링크 (Hyperlinks)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePEP 본문에서 외부 웹 페이지를 참조할 때, 페이지 제목이나 적절한 설명을 텍스트에 포함하고, 인라인 하이퍼링크 또는 URL이 있는 별도의 명시적 대상(explicit target)을 사용해야 합니다.\u003c/li\u003e\n\u003cli\u003ePEP 본문 텍스트에 순수 URL을 포함하지 말고, 가능한 경우 HTTPS 링크를 사용해야 합니다.\u003c/li\u003e\n\u003cli\u003e하이퍼링크 참조는 백틱과 뒤따르는 밑줄을 사용하여 참조 텍스트를 마크업합니다. 참조 텍스트가 단일 단어인 경우 백틱은 선택 사항입니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003ePython website\u003c/code\u003e_\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e링크를 한 번만 참조하고 텍스트와 함께 인라인으로 정의하려면, 연결하려는 텍스트 뒤에, 닫는 백틱 앞에, 그리고 텍스트와 여는 백틱 사이에 공백을 두고 꺾쇠 괄호(\u003ccode\u003e\u0026#x3C; \u003e\u003c/code\u003e) 안에 링크를 삽입합니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003ewebsite \u0026#x3C;https://www.python.org/\u003e\u003c/code\u003e__ (이중 밑줄은 익명 참조를 만듭니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e하나의 링크를 여러 곳에서 다른 연결 텍스트와 함께 사용하거나, 연결 텍스트 변경 시 링크 대상 이름을 업데이트할 필요가 없도록 하려면, 연결할 텍스트 뒤에 꺾쇠 괄호 안에 대상 이름을 포함하고, 대상 이름 뒤에 닫는 꺾쇠 괄호 앞에 밑줄을 붙입니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003edocumentation \u0026#x3C;pydocs_\u003e\u003c/code\u003e_\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e명시적 대상은 URL을 제공합니다. 대상을 PEP 끝의 Footnotes 섹션이나 참조가 있는 단락 바로 뒤에 배치합니다. 하이퍼링크 대상은 두 개의 마침표와 공백으로 시작하고, 그 뒤에 선행 밑줄, 참조 텍스트, 콜론, 그리고 URL이 옵니다.\n\u003cpre\u003e\u003ccode\u003e.. _Python web site: https://www.python.org/\r\n.. _pydocs: https://docs.python.org/\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e내부 및 PEP/RFC 링크 (Internal and PEP/RFC Links)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e하이퍼링크와 동일한 메커니즘을 내부 참조에도 사용할 수 있습니다. 모든 고유한 섹션 제목은 암시적으로 내부 하이퍼링크 대상을 정의합니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003eAbstract\u003c/code\u003e_ 섹션 참조.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ePEPs 또는 RFCs를 참조하려면 항상 \u003ccode\u003e:pep:\u003c/code\u003e 및 \u003ccode\u003e:rfc:\u003c/code\u003e 역할을 사용하고, 하드코딩된 URL을 사용하지 마십시오.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003eSee :pep:\u003c/code\u003e1\u003ccode\u003e for more information on how to write a PEP, and :pep:\u003c/code\u003ethe Hyperlink section of PEP 12 \u0026#x3C;12#hyperlinks\u003e\u003ccode\u003e for how to link.\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e각주 (Footnotes)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e각주 참조는 왼쪽 대괄호, 레이블, 오른쪽 대괄호, 그리고 뒤따르는 밑줄로 구성됩니다. 숫자 대신 \u003ccode\u003e#word\u003c/code\u003e 형식의 레이블을 사용합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003eThe TeXbook [#TeXbook]_\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각주 참조 앞에는 공백이 있어야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각주는 추가적인 노트, 설명, 경고, 그리고 온라인에서 쉽게 이용할 수 없는 책이나 다른 출처를 참조하는 데 사용됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각주는 \u003ccode\u003e..\u003c/code\u003e로 시작하고, 그 뒤에 각주 마커 (밑줄 없음), 그리고 각주 본문이 옵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.. [#TeXbook] Donald Knuth's *The TeXbook*, pages 195 and 196.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각주와 각주 참조는 자동으로 번호가 매겨집니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e이미지 (Images)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ePEP에 다이어그램이나 다른 그래픽이 포함된 경우, \u003ccode\u003eimage\u003c/code\u003e 지시문을 사용하여 처리된 출력에 포함할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.. image:: diagram.png\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e모든 브라우저 친화적인 그래픽 형식이 가능하지만, 그래픽에는 PNG, 사진에는 JPEG, 애니메이션에는 GIF를 선호해야 합니다. 현재 PEP 빌드 시스템과의 호환성 문제로 SVG는 피해야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e접근성과 소스 텍스트 독자를 위해, \u003ccode\u003eimage\u003c/code\u003e 지시문의 \u003ccode\u003e:alt:\u003c/code\u003e 옵션을 사용하여 이미지에 대한 설명과 포함된 주요 정보를 포함해야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e주석 (Comments)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e주석은 명시적 마크업 시작 (\u003ccode\u003e.. \u003c/code\u003e) 바로 뒤에 오는 들여쓰기된 임의의 텍스트 블록입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e..\u003c/code\u003e를 자체 줄에 두어 주석이 다른 명시적 마크업 구성으로 오해되지 않도록 합니다.\u003c/li\u003e\n\u003cli\u003e주석은 처리된 문서에서 보이지 않습니다.\n\u003cpre\u003e\u003ccode\u003e.. This section should be updated in the final PEP. Ensure the date is accurate.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e이스케이프 메커니즘 (Escaping Mechanism)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e는 백슬래시(\u003ccode\u003e\\\u003c/code\u003e)를 사용하여 마크업 문자에 부여된 특수 의미를 무시하고 리터럴 문자를 얻습니다. 리터럴 백슬래시를 얻으려면 이스케이프된 백슬래시(\u003ccode\u003e\\\\\u003c/code\u003e)를 사용합니다.\u003c/li\u003e\n\u003cli\u003e백슬래시에 특별한 의미가 없는 두 가지 컨텍스트가 있습니다: 리터럴 블록과 인라인 리터럴. 이러한 컨텍스트에서는 마크업 인식이 수행되지 않으며, 단일 백슬래시는 이중화할 필요 없이 리터럴 백슬래시를 나타냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eIntersphinx\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eIntersphinx 참조를 사용하여 Python 문서 \u003ccode\u003epackaging.python.org\u003c/code\u003e, \u003ccode\u003etyping.python.org\u003c/code\u003e와 같은 다른 Sphinx 사이트로 쉽게 상호 참조하여 페이지, 섹션 및 Python/C 객체를 링크할 수 있습니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003e:ref:\u003c/code\u003etype expression \u003ca\u003etyping:type-expression\u003c/a\u003e``\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e정식 문서 (Canonical Documentation)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePEP 1에 설명된 대로, PEP는 Final로 표시되면 역사적인 문서로 간주되며, 그 정식 문서/사양은 다른 곳으로 이동되어야 합니다.\u003c/li\u003e\n\u003cli\u003e이를 나타내기 위해 \u003ccode\u003ecanonical-doc\u003c/code\u003e 지시문 또는 적절한 하위 클래스를 사용합니다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epackaging\u003c/code\u003e 표준용: \u003ccode\u003ecanonical-pypa-spec\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etyping\u003c/code\u003e 표준용: \u003ccode\u003ecanonical-typing-spec\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e지시문을 헤더와 PEP의 첫 번째 섹션 (일반적으로 Abstract) 사이에 추가하고, 정식 문서/사양의 Intersphinx 참조를 인수로 전달합니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003e.. canonical-doc:: :mod:\u003c/code\u003epython:sqlite3```\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e이렇게 하면 다음과 같은 배너가 생성됩니다.\n\u003cpre\u003e\u003ccode\u003eImportant\r\nThis PEP is a historical document. The up-to-date, canonical documentation can now be found at sqlite3 .\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e피해야 할 습관 (Habits to Avoid)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTeX에 익숙한 많은 프로그래머는 따옴표를 \u003ccode\u003e‘single-quoted’\u003c/code\u003e 또는 \u003ccode\u003e‘‘double-quoted’’\u003c/code\u003e와 같이 작성합니다. \u003ccode\u003ereStructuredText\u003c/code\u003e에서는 백틱이 의미가 있으므로 이러한 관행은 피해야 합니다.\u003c/li\u003e\n\u003cli\u003e일반 텍스트의 경우 \u003ccode\u003e'single-quotes'\u003c/code\u003e 또는 \u003ccode\u003e“double-quotes”\u003c/code\u003e와 같은 일반 따옴표를 사용합니다.\u003c/li\u003e\n\u003cli\u003e인라인 리터럴 텍스트 (위의 Inline Markup 참조)의 경우 이중 백틱을 사용합니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003eliteral text: in here, anything goes!\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e제안 섹션 (Suggested Sections)\u003c/h2\u003e\n\u003cp\u003e다양한 섹션이 PEP 전반에 걸쳐 공통적으로 발견되며 PEP 1에 설명되어 있습니다. 이러한 섹션은 편의를 위해 여기에 제공됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePEP: \u0026#x3C;필수: pep 번호\u003e\r\nTitle: \u0026#x3C;필수: pep 제목\u003e\r\nAuthor: \u0026#x3C;필수: 저자 이름 목록 및 선택적으로 이메일 주소\u003e\r\nSponsor: \u0026#x3C;후원자 이름\u003e\r\nPEP-Delegate: \u0026#x3C;PEP 대리인 이름\u003e\r\nDiscussions-To: Pending\r\nStatus: \u0026#x3C;필수: Draft | Active | Accepted | Provisional | Deferred | Rejected | Withdrawn | Final | Superseded\u003e\r\nType: \u0026#x3C;필수: Standards Track | Informational | Process\u003e\r\nTopic: \u0026#x3C;Governance | Packaging | Release | Typing\u003e\r\nRequires: \u0026#x3C;pep 번호\u003e\r\nCreated: \u0026#x3C;생성 날짜, dd-mmm-yyyy 형식\u003e\r\nPython-Version: \u0026#x3C;버전 번호\u003e\r\nPost-History: \u0026#x3C;필수: 날짜, dd-mmm-yyyy 형식, 및 PEP 토론 스레드에 대한 해당 링크\u003e\r\nReplaces: \u0026#x3C;pep 번호\u003e\r\nSuperseded-By: \u0026#x3C;pep 번호\u003e\r\nResolution: \u0026#x3C;url\u003e\r\n\r\nAbstract\r\n========\r\n[해결하고자 하는 기술적 문제에 대한 짧은(~200단어) 설명.]\r\n\r\nMotivation\r\n==========\r\n[PEP가 해결하는 문제에 대해 기존 언어 사양이 왜 부적절한지 명확하게 설명.]\r\n\r\nRationale\r\n=========\r\n[특정 설계 결정이 왜 이루어졌는지 설명.]\r\n\r\nSpecification\r\n=============\r\n[새로운 언어 기능의 구문 및 의미 설명.]\r\n\r\nBackwards Compatibility\r\n=======================\r\n[기존 코드에 미치는 잠재적 영향 및 심각도 설명.]\r\n\r\nSecurity Implications\r\n=====================\r\n[악의적인 사용자가 이 새로운 기능을 어떻게 악용할 수 있는지.]\r\n\r\nHow to Teach This\r\n=================\r\n[사용자(초보 및 숙련자)에게 PEP를 작업에 적용하는 방법을 가르치는 방법.]\r\n\r\nReference Implementation\r\n========================\r\n[기존 구현에 대한 링크 및 해당 상태(예: 개념 증명)에 대한 세부 정보.]\r\n\r\nRejected Ideas\r\n==============\r\n[이 PEP를 논의하는 동안 제기된 특정 아이디어가 궁극적으로 채택되지 않은 이유.]\r\n\r\nOpen Issues\r\n===========\r\n[아직 결정/논의 중인 모든 사항.]\r\n\r\nAcknowledgements\r\n================\r\n[PEP에 도움을 준 모든 사람들에게 감사.]\r\n\r\nFootnotes\r\n=========\r\n[PEP에 인용된 각주 모음 및 비인라인 하이퍼링크 대상을 나열하는 곳.]\r\n\r\nCopyright\r\n=========\r\n이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 조건으로 제공됩니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e자료 (Resources)\u003c/h2\u003e\n\u003cp\u003e기본 Docutils와 Sphinx에서 추가된 확장을 포함하여 많은 다른 구성과 변형이 가능합니다. 이에 대해 더 자세히 알아볼 수 있는 몇 가지 자료는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html\"\u003eSphinx ReStructuredText Primer\u003c/a\u003e: 부드럽지만 상당히 자세한 소개.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html\"\u003ereStructuredText Markup Specification\u003c/a\u003e: 기본적인 reST 구문, 지시문, 역할 등에 대한 권위 있고 포괄적인 문서.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html\"\u003eSphinx Roles\u003c/a\u003e 및 \u003ca href=\"https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html\"\u003eSphinx Directives\u003c/a\u003e: PEP를 HTML로 렌더링하는 데 사용되는 Sphinx 문서 시스템에 의해 추가된 확장 구성.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 자료에서 다루지 않는 PEP 작성에 대한 질문이나 도움이 필요한 경우, GitHub의 \u003ccode\u003e@python/pep-editors\u003c/code\u003e를 태그하거나, PEPs 저장소에 이슈를 생성하거나, PEP 편집자에게 직접 문의하십시오.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 조건으로 제공됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e최종 수정일:\u003c/strong\u003e 2025-04-10 16:17:29 GMT\r\n\u003cstrong\u003e소스:\u003c/strong\u003e \u003ccode\u003ehttps://github.com/python/peps/blob/main/peps/pep-0012.rst\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePlease let me know if you need any further assistance!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI have browsed the content of PEP 12.\r\nNow I need to translate it into Korean, following all the guidelines:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProfessionalism in Python terminology.\u003c/li\u003e\n\u003cli\u003eTerminology handling (Korean if common, English original or 병기 if ambiguous/familiar, no translation for keywords/variable names).\u003c/li\u003e\n\u003cli\u003eReadability with Markdown.\u003c/li\u003e\n\u003cli\u003eAccuracy and completeness.\u003c/li\u003e\n\u003cli\u003eStructure: proposal content, background, impact on Python usage.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet's break down the translation process section by section.PEP 12는 \u003ccode\u003ereStructuredText\u003c/code\u003e 형식으로 Python Enhancement Proposal (PEP)을 작성하기 위한 샘플 템플릿 문서입니다. 이 PEP의 목표는 새로운 PEP를 제출하려는 저자들이 표준화된 형식을 쉽게 따를 수 있도록 돕는 것입니다.\u003c/p\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003ereStructuredText\u003c/code\u003e 기반의 PEP를 생성하기 위한 기본적인 틀 또는 샘플 템플릿을 제공합니다. PEP 1의 내용 가이드라인과 함께 이 템플릿을 사용하면, PEP 저자는 자신의 PEP를 아래에 명시된 형식에 맞추어 쉽게 작성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고:\u003c/strong\u003e 웹에서 이 PEP를 읽고 있다면, 아래 단계를 완료하기 위해 먼저 이 PEP의 텍스트(\u003ccode\u003ereStructuredText\u003c/code\u003e) 소스 파일을 확보해야 합니다. HTML 파일을 템플릿으로 사용하지 마십시오!\u003c/p\u003e\n\u003cp\u003e이 PEP (및 모든 PEP)의 소스 파일은 PEPs 저장소 및 각 PEP 하단 링크를 통해 찾을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e도입 배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003ePEP를 제출할 의향이 있다면, 형식이 맞지 않아 자동으로 거부되는 것을 방지하기 위해 이 템플릿을 아래의 형식 가이드라인과 함께 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e는 PEP 저자에게 유용한 기능과 표현력을 제공하면서도, 소스 텍스트의 가독성을 유지합니다. 처리된 HTML 형식은 독자들에게 라이브 하이퍼링크, 스타일이 적용된 텍스트, 테이블, 이미지, 자동 목차 등 다양한 기능을 제공합니다.\u003c/p\u003e\n\u003ch2\u003e템플릿 사용 방법 (How to Use This Template)\u003c/h2\u003e\n\u003cp\u003e이 템플릿을 사용하려면 먼저 자신의 PEP가 Informational (정보성) 또는 Standards Track (표준 트랙) PEP 중 어떤 유형이 될지 결정해야 합니다. 대부분의 PEP는 Python 언어 또는 표준 라이브러리에 새로운 기능을 제안하기 때문에 Standards Track 유형에 속합니다. 확실하지 않다면 PEP 1을 참조하거나 PEPs 저장소에 이슈를 제기하여 도움을 요청하십시오.\u003c/p\u003e\n\u003cp\u003ePEP 유형을 결정한 후에는 다음 지침을 따릅니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e이 파일 (\u003ccode\u003e.rst\u003c/code\u003e 파일, HTML 아님!)을 복사합니다.\u003c/li\u003e\n\u003cli\u003e새 파일 이름을 \u003ccode\u003epep-NNNN.rst\u003c/code\u003e로 지정합니다. 여기서 \u003ccode\u003eNNNN\u003c/code\u003e은 다음으로 사용 가능한 번호 (게시되었거나 PR에 있는 PEP에 사용되지 않은 번호)입니다. 파일 이름은 \u003ccode\u003epep-0012.rst\u003c/code\u003e처럼 0으로 채워져야 하지만, 헤더(\u003ccode\u003ePEP: 12\u003c/code\u003e)는 0으로 채워지지 않습니다.\u003c/li\u003e\n\u003cli\u003e\"PEP: 12\" 헤더를 \"PEP: NNNN\"으로 변경하고 파일 이름과 일치시킵니다.\u003c/li\u003e\n\u003cli\u003eTitle 헤더를 PEP의 제목으로 변경합니다.\u003c/li\u003e\n\u003cli\u003eAuthor 헤더에 이름과 선택적으로 이메일 주소를 포함하도록 변경합니다. 이름이 먼저 오고 괄호 안에 없어야 하며, 이메일 주소는 꺾쇠 괄호(\u003ccode\u003e\u0026#x3C; \u003e\u003c/code\u003e) 안에 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e저자 중 Python 코어 개발자가 없는 경우, PEP를 후원하는 코어 개발자의 이름을 Sponsor 헤더에 추가합니다.\u003c/li\u003e\n\u003cli\u003eDiscussions-To 헤더 아래에 PEP의 공식 토론 스레드(예: Python-Dev, Discourse 등)의 직접 URL을 추가합니다. (스레드가 공식 초안 제출 후 생성될 예정이라면 \"Pending\"으로 두었다가, PEP가 PEPs 저장소에 성공적으로 병합되고 해당 토론 스레드를 생성한 즉시 URL로 업데이트해야 합니다.) 자세한 내용은 PEP 1을 참조하십시오.\u003c/li\u003e\n\u003cli\u003eStatus 헤더를 \"Draft\"로 변경합니다.\u003c/li\u003e\n\u003cli\u003eStandards Track PEP의 경우 Type 헤더를 \"Standards Track\"으로 변경합니다. Informational PEP의 경우 Type 헤더를 \"Informational\"으로 변경합니다.\u003c/li\u003e\n\u003cli\u003eStandards Track PEP의 경우, 제안하는 기능이 다른 개발 중인 PEP의 승인에 의존한다면 Type 헤더 바로 뒤에 Requires 헤더를 추가합니다. 값은 의존하는 PEP의 번호여야 합니다. (종속 기능이 Final PEP에 설명되어 있다면 이 헤더를 추가하지 마십시오.)\u003c/li\u003e\n\u003cli\u003eCreated 헤더를 오늘 날짜로 변경합니다. \u003ccode\u003edd-mmm-yyyy\u003c/code\u003e 형식 (예: \u003ccode\u003e05-Aug-2002\u003c/code\u003e)을 따릅니다.\u003c/li\u003e\n\u003cli\u003eStandards Track PEP의 경우, Created 헤더 뒤에 Python-Version 헤더를 추가하고 다음 계획된 Python 버전을 값으로 설정합니다. (알파 또는 베타 릴리스 지정을 사용하지 마십시오.)\u003c/li\u003e\n\u003cli\u003ePEP가 Topic Index에 표시된 토픽 중 하나에 속한다면 Topic 헤더를 추가합니다. 대부분의 PEP에는 해당하지 않습니다.\u003c/li\u003e\n\u003cli\u003ePost-History는 지금은 그대로 둡니다. PEP를 지정된 토론 포럼에 게시할 때마다 날짜와 해당 링크를 이 헤더에 추가합니다.\u003c/li\u003e\n\u003cli\u003ePEP가 이전 PEP를 대체하는 경우 Replaces 헤더를 추가합니다. 이 헤더의 값은 새 PEP가 대체하는 PEP의 번호입니다. (이전 PEP가 \"final\" 형식, 즉 Accepted, Final 또는 Rejected 상태인 경우에만 이 헤더를 추가합니다.)\u003c/li\u003e\n\u003cli\u003e이제 Abstract, Rationale 및 PEP의 다른 내용을 작성하여 이 템플릿의 내용을 자신의 텍스트로 대체합니다. (특히 탭 문자 금지 및 들여쓰기 요구 사항과 같은 형식 가이드라인을 준수하십시오.) \"Suggested Sections\"를 참조하여 포함할 섹션 템플릿을 확인하십시오.\u003c/li\u003e\n\u003cli\u003eFootnotes 섹션을 업데이트하고, 텍스트에서 참조된 모든 각주 및 비인라인 링크 대상을 나열합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e./build.py\u003c/code\u003e를 실행하여 PEP가 오류 없이 렌더링되는지 확인하고, \u003ccode\u003ebuild/pep-NNNN.html\u003c/code\u003e의 출력이 의도한 대로 보이는지 확인합니다.\u003c/li\u003e\n\u003cli\u003ePEPs 저장소에 Pull Request를 생성합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e가능한 헤더 필드 (Possible Header Fields)\u003c/h3\u003e\n\u003cp\u003e다음은 가능한 모든 헤더 필드입니다 (대괄호 안의 내용은 대체하거나, 선행 \u003ccode\u003e*\u003c/code\u003e로 표시된 선택 사항이 해당하지 않으면 필드를 제거해야 합니다).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePEP: [NNN]\r\nTitle: [...]\r\nAuthor: [Full Name \u0026#x3C;email at example.com\u003e]\r\nSponsor: *[Full Name \u0026#x3C;email at example.com\u003e]\r\nPEP-Delegate:\r\nDiscussions-To: [URL]\r\nStatus: Draft\r\nType: [Standards Track | Informational | Process]\r\nTopic: *[Governance | Packaging | Release | Typing]\r\nRequires: *[NNN]\r\nCreated: [DD-MMM-YYYY]\r\nPython-Version: *[M.N]\r\nPost-History: [`DD-MMM-YYYY \u0026#x3C;URL\u003e`__]\r\nReplaces: *[NNN]\r\nSuperseded-By: *[NNN]\r\nResolution:\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ereStructuredText PEP 형식 요구 사항 (ReStructuredText PEP Formatting Requirements)\u003c/h2\u003e\n\u003cp\u003e다음은 \u003ccode\u003ereStructuredText\u003c/code\u003e 문법에 대한 PEP별 요약입니다. 단순성과 간결성을 위해 많은 세부 사항은 생략됩니다. 자세한 내용은 아래 Resources 섹션을 참조하십시오. 예시에는 리터럴 블록(마크업 처리가 수행되지 않는 블록)이 사용되어 일반 텍스트 마크업을 보여줍니다.\u003c/p\u003e\n\u003ch3\u003e일반 (General)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e줄은 일반적으로 79열을 넘지 않아야 합니다 (URL 등은 예외).\u003c/li\u003e\n\u003cli\u003e문서에는 탭 문자를 사용해서는 안 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e섹션 제목 (Section Headings)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ePEP 제목은 0열에서 시작해야 하며, 책 제목처럼 각 단어의 첫 글자는 대문자로 표기해야 합니다. 약어는 모두 대문자여야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e섹션 제목은 밑줄로 장식되어야 하며, 밑줄은 0열에서 시작하여 제목 텍스트의 오른쪽 끝까지 (최소 4자) 확장되어야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1단계 섹션 제목은 \u003ccode\u003e=\u003c/code\u003e (등호)로 밑줄을 긋습니다.\u003c/li\u003e\n\u003cli\u003e2단계 섹션 제목은 \u003ccode\u003e-\u003c/code\u003e (하이픈)으로 밑줄을 긋습니다.\u003c/li\u003e\n\u003cli\u003e3단계 섹션 제목은 \u003ccode\u003e''\u003c/code\u003e (작은따옴표 또는 아포스트로피)로 밑줄을 긋습니다.\u003c/li\u003e\n\u003cli\u003e예시:\n\u003cpre\u003e\u003ccode\u003eFirst-Level Title\r\n=================\r\nSecond-Level Title\r\n------------------\r\nThird-Level Title\r\n'''''''''''''''''\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePEP에 3단계 이상의 섹션이 있는 경우, 1단계 및 2단계에 대해 오버라인/밑줄로 장식된 제목을 다음과 같이 삽입할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e============================\r\nFirst-Level Title (optional)\r\n============================\r\n-----------------------------\r\nSecond-Level Title (optional)\r\n-----------------------------\r\nThird-Level Title\r\n=================\r\nFourth-Level Title\r\n------------------\r\nFifth-Level Title\r\n'''''''''''''''''\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePEP에 5단계 이상의 섹션을 사용하지 않아야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e섹션 본문의 마지막 줄과 다음 섹션 제목 사이에는 두 개의 빈 줄을 사용해야 합니다. 하위 섹션 제목이 섹션 제목 바로 뒤에 오는 경우, 한 줄의 빈 줄로 충분합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각 섹션의 본문은 일반적으로 들여쓰기되지 않습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e단락 (Paragraphs)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e단락은 빈 줄로 구분된 왼쪽 정렬 텍스트 블록입니다.\u003c/li\u003e\n\u003cli\u003e블록 인용구나 목록 항목과 같은 들여쓰기된 구성의 일부가 아닌 한, 단락은 들여쓰기되지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e인라인 마크업 (Inline Markup)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e단락 및 기타 텍스트 블록 내의 일부 텍스트는 스타일을 지정할 수 있습니다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e*강조*\u003c/code\u003e (단일 별표, 일반적으로 이탤릭체) 또는 \u003ccode\u003e**강력 강조**\u003c/code\u003e (이중 별표, 일반적으로 볼드체)로 텍스트를 표시할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e인라인 리터럴\u003c/code\u003e (이중 백틱 사용)은 일반적으로 모노스페이스 글꼴로 렌더링됩니다. 이중 백틱 내에서는 추가 마크업 인식이 수행되지 않으므로, 모든 종류의 코드 스니펫에 안전합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e블록 인용 (Block Quotes)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e블록 인용은 들여쓰기된 본문 요소로 구성됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eThis is a paragraph.\r\n    This is a block quote.\r\n    A block quote may contain many paragraphs.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e블록 인용은 다른 소스에서 가져온 긴 구절을 인용하는 데 사용됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각 들여쓰기 수준에 4칸 공백을 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e리터럴 블록 (Literal Blocks)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e리터럴 블록은 코드 샘플 및 기타 미리 서식화된 텍스트에 사용됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e리터럴 블록을 나타내려면 들여쓰기된 텍스트 블록 앞에 \u003ccode\u003e::\u003c/code\u003e (두 개의 콜론)을 붙이거나 \u003ccode\u003e.. code-block::\u003c/code\u003e 지시문을 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e텍스트 블록을 4칸 들여쓰기합니다. 리터럴 블록은 들여쓰기가 끝날 때까지 계속됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eThis is a typical paragraph. A literal block follows.\r\n::\r\n\r\n    for a in:    # this is program code, shown as-is\r\n        print(a)\r\n    print(\"it's...\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e::\u003c/code\u003e는 모든 단락 끝에서도 인식됩니다. 바로 앞에 공백이 없으면 최종 출력에는 하나의 콜론이 남습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e기본적으로 리터럴 블록은 Python 코드로 구문 강조 표시됩니다. 다른 언어/형식의 코드 또는 데이터를 포함하는 특정 블록의 경우, \u003ccode\u003e.. code-block:: language\u003c/code\u003e 지시문을 사용하고 \u003ccode\u003elanguage\u003c/code\u003e 대신 적절한 Pygments 렉서의 \"짧은 이름\"을 사용합니다 (또는 강조 표시를 비활성화하려면 \u003ccode\u003etext\u003c/code\u003e).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e주로 특정 언어의 리터럴 블록을 포함하는 PEP의 경우, PEP 본문 상단 (헤더 아래, Abstract 위에)에 \u003ccode\u003e.. highlight:: language\u003c/code\u003e 지시문을 사용합니다. 이렇게 하면 \u003ccode\u003e.. code-block\u003c/code\u003e에서 달리 지정되지 않는 한 모든 리터럴 블록이 해당 언어로 처리됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e목록 (Lists)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e불릿 목록 항목은 \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e*\u003c/code\u003e, 또는 \u003ccode\u003e+\u003c/code\u003e (하이픈, 별표 또는 더하기 기호) 중 하나로 시작하며, 그 뒤에 공백과 목록 항목 본문이 옵니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e목록 항목 본문은 불릿에 상대적으로 왼쪽 정렬 및 들여쓰기되어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eThis paragraph is followed by a list.\r\n*   This is the first bullet list item.\r\n\r\n*   This is the first paragraph in the second item in the list.\r\n    This is the second paragraph in the second item in the list.\r\n\r\n    - This is a sublist.\r\n*   This is the third item of the main list.\r\nThis paragraph is not part of the list.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e열거형(번호 매기기) 목록 항목은 불릿 대신 열거자를 사용한다는 점을 제외하고 유사합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e열거자는 숫자(1, 2, 3, …), 문자(A, B, C, …; 대문자 또는 소문자), 또는 로마 숫자(i, ii, iii, iv, …; 대문자 또는 소문자)이며, 마침표 접미사(\"1.\", \"2.\"), 괄호(\"(1)\", \"(2)\"), 또는 오른쪽 괄호 접미사(\"1)\", \"2)\")로 형식이 지정됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003e1.  As with bullet list items, the left edge of paragraphs must align.\r\n2.  Each list item may contain multiple paragraphs, sublists, etc.\r\n    This is the second paragraph of the second list item.\r\n    a) Enumerated lists may be nested.\r\n    b) Blank lines may be omitted between list items.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e정의 목록은 다음과 같이 작성됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewhat\r\n    Definition lists associate a term with a definition.\r\nhow\r\n    The term is a one-line phrase, and the definition is one or more\r\n    paragraphs or body elements, indented relative to the term.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e표 (Tables)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e단순한 표는 쉽고 간결합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e===== ===== =======\r\nA      B    A and B\r\n===== ===== =======\r\nFalse False False\r\nTrue False False\r\nFalse True False\r\nTrue True False\r\nTrue True True\r\n===== ===== =======\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e표에는 최소 두 개의 열이 있어야 합니다 (섹션 제목과 구별하기 위해). 열 병합은 하이픈으로 밑줄을 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e첫 번째 열 셀의 텍스트는 새 행을 시작합니다. 첫 번째 열에 텍스트가 없으면 계속되는 줄을 나타냅니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e하이퍼링크 (Hyperlinks)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePEP 본문에서 외부 웹 페이지를 참조할 때, 페이지 제목이나 적절한 설명을 텍스트에 포함하고, 인라인 하이퍼링크 또는 URL이 있는 별도의 명시적 대상(explicit target)을 사용해야 합니다.\u003c/li\u003e\n\u003cli\u003ePEP 본문 텍스트에 순수 URL을 포함하지 말고, 가능한 경우 HTTPS 링크를 사용해야 합니다.\u003c/li\u003e\n\u003cli\u003e하이퍼링크 참조는 백틱과 뒤따르는 밑줄을 사용하여 참조 텍스트를 마크업합니다. 참조 텍스트가 단일 단어인 경우 백틱은 선택 사항입니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003ePython website\u003c/code\u003e_\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e링크를 한 번만 참조하고 텍스트와 함께 인라인으로 정의하려면, 연결하려는 텍스트 뒤에, 닫는 백틱 앞에, 그리고 텍스트와 여는 백틱 사이에 공백을 두고 꺾쇠 괄호(\u003ccode\u003e\u0026#x3C; \u003e\u003c/code\u003e) 안에 링크를 삽입합니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003ewebsite \u0026#x3C;https://www.python.org/\u003e\u003c/code\u003e__ (이중 밑줄은 익명 참조를 만듭니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e하나의 링크를 여러 곳에서 다른 연결 텍스트와 함께 사용하거나, 연결 텍스트 변경 시 링크 대상 이름을 업데이트할 필요가 없도록 하려면, 연결할 텍스트 뒤에 꺾쇠 괄호 안에 대상 이름을 포함하고, 대상 이름 뒤에 닫는 꺾쇠 괄호 앞에 밑줄을 붙입니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003edocumentation \u0026#x3C;pydocs_\u003e\u003c/code\u003e_\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e명시적 대상은 URL을 제공합니다. 대상을 PEP 끝의 Footnotes 섹션이나 참조가 있는 단락 바로 뒤에 배치합니다. 하이퍼링크 대상은 두 개의 마침표와 공백으로 시작하고, 그 뒤에 선행 밑줄, 참조 텍스트, 콜론, 그리고 URL이 옵니다.\n\u003cpre\u003e\u003ccode\u003e.. _Python web site: https://www.python.org/\r\n.. _pydocs: https://docs.python.org/\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e내부 및 PEP/RFC 링크 (Internal and PEP/RFC Links)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e하이퍼링크와 동일한 메커니즘을 내부 참조에도 사용할 수 있습니다. 모든 고유한 섹션 제목은 암시적으로 내부 하이퍼링크 대상을 정의합니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003eAbstract\u003c/code\u003e_ 섹션 참조.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ePEPs 또는 RFCs를 참조하려면 항상 \u003ccode\u003e:pep:\u003c/code\u003e 및 \u003ccode\u003e:rfc:\u003c/code\u003e 역할을 사용하고, 하드코딩된 URL을 사용하지 마십시오.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003eSee :pep:\u003c/code\u003e1\u003ccode\u003e for more information on how to write a PEP, and :pep:\u003c/code\u003ethe Hyperlink section of PEP 12 \u0026#x3C;12#hyperlinks\u003e\u003ccode\u003e for how to link.\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e각주 (Footnotes)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e각주 참조는 왼쪽 대괄호, 레이블, 오른쪽 대괄호, 그리고 뒤따르는 밑줄로 구성됩니다. 숫자 대신 \u003ccode\u003e#word\u003c/code\u003e 형식의 레이블을 사용합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003eThe TeXbook [#TeXbook]_\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각주 참조 앞에는 공백이 있어야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각주는 추가적인 노트, 설명, 경고, 그리고 온라인에서 쉽게 이용할 수 없는 책이나 다른 출처를 참조하는 데 사용됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각주는 \u003ccode\u003e..\u003c/code\u003e로 시작하고, 그 뒤에 각주 마커 (밑줄 없음), 그리고 각주 본문이 옵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.. [#TeXbook] Donald Knuth's *The TeXbook*, pages 195 and 196.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e각주와 각주 참조는 자동으로 번호가 매겨집니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e이미지 (Images)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ePEP에 다이어그램이나 다른 그래픽이 포함된 경우, \u003ccode\u003eimage\u003c/code\u003e 지시문을 사용하여 처리된 출력에 포함할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.. image:: diagram.png\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e모든 브라우저 친화적인 그래픽 형식이 가능하지만, 그래픽에는 PNG, 사진에는 JPEG, 애니메이션에는 GIF를 선호해야 합니다. 현재 PEP 빌드 시스템과의 호환성 문제로 SVG는 피해야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e접근성과 소스 텍스트 독자를 위해, \u003ccode\u003eimage\u003c/code\u003e 지시문의 \u003ccode\u003e:alt:\u003c/code\u003e 옵션을 사용하여 이미지에 대한 설명과 포함된 주요 정보를 포함해야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e주석 (Comments)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e주석은 명시적 마크업 시작 (\u003ccode\u003e.. \u003c/code\u003e) 바로 뒤에 오는 들여쓰기된 임의의 텍스트 블록입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e..\u003c/code\u003e를 자체 줄에 두어 주석이 다른 명시적 마크업 구성으로 오해되지 않도록 합니다.\u003c/li\u003e\n\u003cli\u003e주석은 처리된 문서에서 보이지 않습니다.\n\u003cpre\u003e\u003ccode\u003e.. This section should be updated in the final PEP. Ensure the date is accurate.\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e이스케이프 메커니즘 (Escaping Mechanism)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ereStructuredText\u003c/code\u003e는 백슬래시(\u003ccode\u003e\\\u003c/code\u003e)를 사용하여 마크업 문자에 부여된 특수 의미를 무시하고 리터럴 문자를 얻습니다. 리터럴 백슬래시를 얻으려면 이스케이프된 백슬래시(\u003ccode\u003e\\\\\u003c/code\u003e)를 사용합니다.\u003c/li\u003e\n\u003cli\u003e백슬래시에 특별한 의미가 없는 두 가지 컨텍스트가 있습니다: 리터럴 블록과 인라인 리터럴. 이러한 컨텍스트에서는 마크업 인식이 수행되지 않으며, 단일 백슬래시는 이중화할 필요 없이 리터럴 백슬래시를 나타냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eIntersphinx\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eIntersphinx 참조를 사용하여 Python 문서 \u003ccode\u003epackaging.python.org\u003c/code\u003e, \u003ccode\u003etyping.python.org\u003c/code\u003e와 같은 다른 Sphinx 사이트로 쉽게 상호 참조하여 페이지, 섹션 및 Python/C 객체를 링크할 수 있습니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003e:ref:\u003c/code\u003etype expression \u003ca\u003etyping:type-expression\u003c/a\u003e``\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e정식 문서 (Canonical Documentation)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ePEP 1에 설명된 대로, PEP는 Final로 표시되면 역사적인 문서로 간주되며, 그 정식 문서/사양은 다른 곳으로 이동되어야 합니다.\u003c/li\u003e\n\u003cli\u003e이를 나타내기 위해 \u003ccode\u003ecanonical-doc\u003c/code\u003e 지시문 또는 적절한 하위 클래스를 사용합니다.\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epackaging\u003c/code\u003e 표준용: \u003ccode\u003ecanonical-pypa-spec\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etyping\u003c/code\u003e 표준용: \u003ccode\u003ecanonical-typing-spec\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e지시문을 헤더와 PEP의 첫 번째 섹션 (일반적으로 Abstract) 사이에 추가하고, 정식 문서/사양의 Intersphinx 참조를 인수로 전달합니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003e.. canonical-doc:: :mod:\u003c/code\u003epython:sqlite3```\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e이렇게 하면 다음과 같은 배너가 생성됩니다.\n\u003cpre\u003e\u003ccode\u003eImportant\r\nThis PEP is a historical document. The up-to-date, canonical documentation can now be found at sqlite3 .\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e피해야 할 습관 (Habits to Avoid)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTeX에 익숙한 많은 프로그래머는 따옴표를 \u003ccode\u003e‘single-quoted’\u003c/code\u003e 또는 \u003ccode\u003e‘‘double-quoted’’\u003c/code\u003e와 같이 작성합니다. \u003ccode\u003ereStructuredText\u003c/code\u003e에서는 백틱이 의미가 있으므로 이러한 관행은 피해야 합니다.\u003c/li\u003e\n\u003cli\u003e일반 텍스트의 경우 \u003ccode\u003e'single-quotes'\u003c/code\u003e 또는 \u003ccode\u003e“double-quotes”\u003c/code\u003e와 같은 일반 따옴표를 사용합니다.\u003c/li\u003e\n\u003cli\u003e인라인 리터럴 텍스트 (위의 Inline Markup 참조)의 경우 이중 백틱을 사용합니다.\n\u003cul\u003e\n\u003cli\u003e예시: \u003ccode\u003eliteral text: in here, anything goes!\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e제안 섹션 (Suggested Sections)\u003c/h2\u003e\n\u003cp\u003e다양한 섹션이 PEP 전반에 걸쳐 공통적으로 발견되며 PEP 1에 설명되어 있습니다. 이러한 섹션은 편의를 위해 여기에 제공됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePEP: \u0026#x3C;필수: pep 번호\u003e\r\nTitle: \u0026#x3C;필수: pep 제목\u003e\r\nAuthor: \u0026#x3C;필수: 저자 이름 목록 및 선택적으로 이메일 주소\u003e\r\nSponsor: \u0026#x3C;후원자 이름\u003e\r\nPEP-Delegate: \u0026#x3C;PEP 대리인 이름\u003e\r\nDiscussions-To: Pending\r\nStatus: \u0026#x3C;필수: Draft | Active | Accepted | Provisional | Deferred | Rejected | Withdrawn | Final | Superseded\u003e\r\nType: \u0026#x3C;필수: Standards Track | Informational | Process\u003e\r\nTopic: \u0026#x3C;Governance | Packaging | Release | Typing\u003e\r\nRequires: \u0026#x3C;pep 번호\u003e\r\nCreated: \u0026#x3C;생성 날짜, dd-mmm-yyyy 형식\u003e\r\nPython-Version: \u0026#x3C;버전 번호\u003e\r\nPost-History: \u0026#x3C;필수: 날짜, dd-mmm-yyyy 형식, 및 PEP 토론 스레드에 대한 해당 링크\u003e\r\nReplaces: \u0026#x3C;pep 번호\u003e\r\nSuperseded-By: \u0026#x3C;pep 번호\u003e\r\nResolution: \u0026#x3C;url\u003e\r\n\r\nAbstract\r\n========\r\n[해결하고자 하는 기술적 문제에 대한 짧은(~200단어) 설명.]\r\n\r\nMotivation\r\n==========\r\n[PEP가 해결하는 문제에 대해 기존 언어 사양이 왜 부적절한지 명확하게 설명.]\r\n\r\nRationale\r\n=========\r\n[특정 설계 결정이 왜 이루어졌는지 설명.]\r\n\r\nSpecification\r\n=============\r\n[새로운 언어 기능의 구문 및 의미 설명.]\r\n\r\nBackwards Compatibility\r\n=======================\r\n[기존 코드에 미치는 잠재적 영향 및 심각도 설명.]\r\n\r\nSecurity Implications\r\n=====================\r\n[악의적인 사용자가 이 새로운 기능을 어떻게 악용할 수 있는지.]\r\n\r\nHow to Teach This\r\n=================\r\n[사용자(초보 및 숙련자)에게 PEP를 작업에 적용하는 방법을 가르치는 방법.]\r\n\r\nReference Implementation\r\n========================\r\n[기존 구현에 대한 링크 및 해당 상태(예: 개념 증명)에 대한 세부 정보.]\r\n\r\nRejected Ideas\r\n==============\r\n[이 PEP를 논의하는 동안 제기된 특정 아이디어가 궁극적으로 채택되지 않은 이유.]\r\n\r\nOpen Issues\r\n===========\r\n[아직 결정/논의 중인 모든 사항.]\r\n\r\nAcknowledgements\r\n================\r\n[PEP에 도움을 준 모든 사람들에게 감사.]\r\n\r\nFootnotes\r\n=========\r\n[PEP에 인용된 각주 모음 및 비인라인 하이퍼링크 대상을 나열하는 곳.]\r\n\r\nCopyright\r\n=========\r\n이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 조건으로 제공됩니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e자료 (Resources)\u003c/h2\u003e\n\u003cp\u003e기본 Docutils와 Sphinx에서 추가된 확장을 포함하여 많은 다른 구성과 변형이 가능합니다. 이에 대해 더 자세히 알아볼 수 있는 몇 가지 자료는 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html\"\u003eSphinx ReStructuredText Primer\u003c/a\u003e: 부드럽지만 상당히 자세한 소개.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html\"\u003ereStructuredText Markup Specification\u003c/a\u003e: 기본적인 reST 구문, 지시문, 역할 등에 대한 권위 있고 포괄적인 문서.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html\"\u003eSphinx Roles\u003c/a\u003e 및 \u003ca href=\"https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html\"\u003eSphinx Directives\u003c/a\u003e: PEP를 HTML로 렌더링하는 데 사용되는 Sphinx 문서 시스템에 의해 추가된 확장 구성.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 자료에서 다루지 않는 PEP 작성에 대한 질문이나 도움이 필요한 경우, GitHub의 \u003ccode\u003e@python/pep-editors\u003c/code\u003e를 태그하거나, PEPs 저장소에 이슈를 생성하거나, PEP 편집자에게 직접 문의하십시오.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인 또는 CC0-1.0-Universal 라이선스 중 더 허용적인 조건으로 제공됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e최종 수정일:\u003c/strong\u003e 2025-04-10 16:17:29 GMT\r\n\u003cstrong\u003e소스:\u003c/strong\u003e \u003ccode\u003ehttps://github.com/python/peps/blob/main/peps/pep-0012.rst\u003c/code\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1214,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Active] PEP 12 - Sample reStructuredText PEP Template\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 15:52:34+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>