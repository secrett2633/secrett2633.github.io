<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/e975486d410ad4e9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e1766af8e208074e.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-19cfc001fdac3337.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-51594f997fc19690.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1098<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Rejected] PEP 276 - Simple Iterator for ints</h1><div class="page__meta"><time dateTime="2025-09-26 17:54:04+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0276/">PEP 276 - Simple Iterator for ints</a></p>
<p><strong>상태:</strong> Rejected | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 12-Nov-2001</p>
</blockquote>
<h2>PEP 276 – <code>int</code>를 위한 단순 이터레이터</h2>
<ul>
<li><strong>작성자:</strong> Jim Althoff</li>
<li><strong>상태:</strong> 거부됨 (Rejected)</li>
<li><strong>유형:</strong> 표준 트랙 (Standards Track)</li>
<li><strong>생성일:</strong> 2001년 11월 12일</li>
<li><strong>Python 버전:</strong> 2.3</li>
</ul>
<h3>요약 (Abstract)</h3>
<p>Python 2.1부터 이터레이터(Iterator) 기능(PEP 234)이 추가되었으며, 이는 다양한 코딩 상황에서 유용하고 편리하다는 것이 입증되었습니다. Python의 <code>for-loop</code> 제어 구조는 2.1 릴리스부터 이터레이터 프로토콜을 사용하며, <code>list</code>, <code>tuple</code>, <code>dictionary</code>, <code>string</code>, <code>file</code>과 같은 내장 타입에 대한 이터레이터를 제공합니다.</p>
<p>이 PEP는 내장 타입인 <code>int</code> (<code>types.IntType</code>)에 이터레이터를 추가할 것을 제안합니다. 이러한 이터레이터는 Python에서 특정 <code>for-loop</code> 코딩을 단순화할 수 있을 것입니다.</p>
<h3>BDFL (Benevolent Dictator For Life)의 선언 (BDFL Pronouncement)</h3>
<p>이 PEP는 2005년 6월 17일, <code>python-dev</code> 메일링 리스트에 대한 공지와 함께 <strong>거부되었습니다</strong>.</p>
<p>원래의 필요성 대부분은 Python 2.3에 채택된 <code>enumerate()</code> 함수로 충족되었습니다. 또한, 이 제안은 다음과 같은 오용을 허용하고 장려할 수 있다는 문제가 있었습니다.</p>
<pre><code class="language-python">>>> for i in 3: print i
0
1
2
</code></pre>
<p>마찬가지로, 다음과 같은 문장의 구문 오류를 비활성화할 수 있다는 점도 도움이 되지 않았습니다.</p>
<pre><code class="language-python">x, = 1
</code></pre>
<h3>상세 사양 (Specification)</h3>
<p>이 PEP는 <code>types.IntType</code> (즉, 내장 타입 <code>int</code>)의 인스턴스를 인자로 받아 <code>iter()</code> 내장 함수가 호출될 때 반환되는 이터레이터를 정의합니다.</p>
<p>반환된 이터레이터는 다음과 같이 동작합니다.</p>
<ul>
<li>
<p><code>i</code>가 <code>types.IntType</code>의 인스턴스(<code>int</code>)이고 <code>i > 0</code>이라고 가정할 때:</p>
<ul>
<li><code>iter(i)</code>는 이터레이터 객체를 반환합니다.</li>
<li>해당 이터레이터 객체는 <code>0, 1, 2, ..., i-1</code> 순서의 정수를 순회합니다.</li>
</ul>
<p><strong>예시:</strong>
<code>iter(5)</code>는 <code>0, 1, 2, 3, 4</code> 순서의 정수를 순회하는 이터레이터 객체를 반환합니다.</p>
</li>
<li>
<p><code>i &#x3C;= 0</code>인 경우, <code>iter(i)</code>는 "빈(empty)" 이터레이터를 반환합니다. 즉, <code>next()</code> 메서드를 처음 호출할 때 <code>StopIteration</code>을 발생시킵니다.</p>
</li>
</ul>
<p>다른 말로, 이 이터레이터의 조건과 의미는 <code>range()</code> 및 <code>xrange()</code> 함수의 조건 및 의미와 일치합니다.</p>
<p><code>int</code> <code>i</code>와 연관된 <code>0, 1, 2, ..., i-1</code> 시퀀스는 Python 프로그래밍의 맥락에서 "자연스럽다"고 간주됩니다. 이는 Python의 시퀀스에 대한 내장 인덱싱 프로토콜과 일치하기 때문입니다. 예를 들어, Python의 <code>list</code>와 <code>tuple</code>은 0부터 시작하여 <code>len(object)-1</code>로 끝나는 인덱스(양수 인덱스 사용 시)를 가집니다. 즉, 이러한 객체들은 <code>0, 1, 2, ..., len(object)-1</code> 시퀀스로 인덱싱됩니다.</p>
<h3>제안 배경 (Rationale)</h3>
<p>일반적인 프로그래밍 방식은 객체 컬렉션을 가져와서 컬렉션의 각 항목에 대해 정해진 순서로 어떤 작업을 적용하는 것입니다. Python은 이 일반적인 방식을 처리하기 위해 "<code>for in</code>" 루프 제어 구조를 제공합니다.</p>
<p>그러나, "인덱싱된(indexed)" 컬렉션의 각 항목에 접근하기 위해 각 인덱스를 순회하고 해당 인덱스를 사용하여 컬렉션의 각 항목에 접근하는 것이 필요하거나 더 편리한 경우가 발생합니다.</p>
<p><strong>예시:</strong>
2차원 "테이블" 객체가 있다고 가정했을 때, 테이블의 각 행의 첫 번째 열에 어떤 작업을 적용해야 할 수 있습니다. 테이블의 구현에 따라 각 행과 각 열에 개별 객체로 접근하는 것이 불가능할 수 있습니다. 대신, 행 인덱스와 열 인덱스를 사용하여 테이블의 셀에 접근할 수 있습니다. 이런 경우, 원하는 테이블 항목에 접근하기 위해 인덱스 시퀀스를 순회하는 방식이 필요합니다.</p>
<p>또 다른 일반적인 예는 두 개 이상의 컬렉션을 병렬로 처리해야 하는 경우나 컬렉션에서 두 번째 항목마다 접근해야 하는 경우입니다. 컬렉션의 항목에 대한 접근이 인덱스 계산을 통해 용이해지는 다른 많은 예시들이 있으며, 이는 항목 자체에 직접 접근하는 대신 인덱스에 접근해야 함을 의미합니다.</p>
<p>이러한 방식을 "<code>indexed for-loop</code>" 방식이라고 부릅니다. 일부 프로그래밍 언어는 이 방식을 처리하기 위한 내장 구문을 제공합니다. Python에서 <code>indexed for-loop</code> 방식을 구현하기 위한 일반적인 규칙은 내장 <code>range()</code> 또는 <code>xrange()</code> 함수를 사용하여 인덱스 시퀀스를 생성하는 것입니다.</p>
<p><strong>예시:</strong></p>
<pre><code class="language-python">for rowcount in range(table.getRowCount()):
    print table.getValueAt(rowcount, 0)
</code></pre>
<p>또는</p>
<pre><code class="language-python">for rowcount in xrange(table.getRowCount()):
    print table.getValueAt(rowcount, 0)
</code></pre>
<p><code>indexed for-loop</code> 방식에 대한 논의는 Python 커뮤니티에서 종종 이루어졌습니다. 이 디자인 방식에서 <code>range()</code> 또는 <code>xrange()</code> 함수를 사용해야 할 필요성은 다음과 같은 이유로 비판받기도 합니다.</p>
<ul>
<li>새로운 Python 프로그래머에게 <strong>명확하지 않다</strong>.</li>
<li>숙련된 Python 프로그래머에게도 <strong>오류 발생 가능성이 높다</strong> (잊어버리기 쉽다).</li>
<li><code>xrange()</code>와 <code>range()</code>의 차이점과 권장 사용법을 이해해야 하는 사람들에게 <strong>혼란스럽고 산만하다</strong>.</li>
<li>특히 <code>len()</code> 함수와 결합할 때 <strong>다루기 어렵다</strong> (<code>xrange(len(sequence))</code>).</li>
<li>다른 언어의 동등한 메커니즘만큼 <strong>편리하지 않다</strong>.</li>
<li><strong>성가시고</strong>, "흠(wart)"으로 여겨진다.</li>
</ul>
<p>이러한 방식에 대해 Python이 더 나은 메커니즘을 제공할 수 있는 방법에 대한 제안들이 때때로 제시됩니다. 최근 사례로는 PEP 204 "Range Literals" 및 PEP 212 "Loop Counter Iteration"이 있습니다.</p>
<p>대부분의 경우, 이러한 제안에는 Python의 구문 변경 및 기타 "무거운(heavyweight)" 변경 사항이 포함됩니다. 여기서의 어려움 중 일부는 새로운 구문을 주장하는 것이 "일반적인 인덱싱"에 대한 포괄적인 해결책을 의미하며, 이는 다음과 같은 측면을 포함해야 하기 때문입니다.</p>
<ul>
<li>시작 인덱스 값 (starting index value)</li>
<li>끝 인덱스 값 (ending index value)</li>
<li>단계 값 (step value)</li>
<li>열린 구간 (open intervals) 대 닫힌 구간 (closed intervals) 대 반열린 구간 (half opened intervals)</li>
</ul>
<p>포괄적이고, 간단하며, 일반적이고, Python답고, 많은 사람들에게 매력적이며, 구현하기 쉽고, 기존 구조와 충돌하지 않으며, 기존 구조를 과도하게 오버로드하지 않는 새로운 구문을 찾는 것은 예상보다 어렵다는 것이 입증되었습니다.</p>
<p>이 PEP에 제시된 제안은 이미 사용 가능한 입증된 메커니즘(Python 2.1부터)인 <strong>이터레이터</strong>를 사용하여 가장 일반적인 경우를 돕는 간단한 "경량(lightweight)" 솔루션을 제안함으로써 문제를 해결하고자 합니다.</p>
<p><code>for-loop</code>는 Python 2.1부터 이미 "이터레이터" 프로토콜을 사용하므로, 이 PEP에서 제안된 <code>types.IntType</code>에 이터레이터를 추가하면 <code>indexed for-loop</code> 방식에 대해 다음과 같은 단축 기능을 기본적으로 활성화할 수 있습니다.</p>
<pre><code class="language-python">for rowcount in table.getRowCount():
    print table.getValueAt(rowcount, 0)
</code></pre>
<p><code>range()</code> 또는 <code>xrange()</code> 함수를 사용하는 현재 메커니즘과 비교하여 이 접근 방식의 이점은 다음과 같습니다.</p>
<ul>
<li><strong>더 간단하다</strong> (Simpler).</li>
<li><strong>더 깔끔하다</strong> (Less cluttered).</li>
<li><strong>당면한 문제에 집중한다</strong> (Focuses on the problem at hand) (보조적인 구현 지향 함수인 <code>range()</code> 및 <code>xrange()</code>에 의존할 필요 없이).</li>
</ul>
<p>다른 변경 제안과 비교하면:</p>
<ul>
<li><strong>새로운 구문이 필요 없다</strong> (Requires no new syntax).</li>
<li><strong>새로운 키워드가 필요 없다</strong> (Requires no new keywords).</li>
<li><strong>새롭고 잘 확립된 이터레이터 메커니즘을 활용한다</strong> (Takes advantage of the new and well-established iterator mechanism).</li>
</ul>
<p>그리고 일반적으로:</p>
<ul>
<li><code>list</code>, <code>tuple</code>, <code>dictionary</code>, <code>string</code>, <code>file</code>과 같은 다른 내장 타입에 대해 이미 포함된 (Python 2.1부터) 이터레이터 기반 "편의" 변경 사항과 일치합니다.</li>
</ul>
<h3>하위 호환성 (Backwards Compatibility)</h3>
<p>제안된 메커니즘은 새로운 구문이나 키워드를 요구하지 않으므로 일반적으로 하위 호환됩니다. 모든 기존의 유효한 Python 프로그램은 수정 없이 계속 작동해야 합니다.</p>
<p>그러나 이 제안은 현재 유효하지 않은 특정 문장이 현재 제안에 따라 유효하게 된다는 점에서 완벽하게 하위 호환되지 않습니다. Tim Peters는 두 가지 예를 지적했습니다.</p>
<ol>
<li>
<p><strong><code>range()</code> 또는 <code>xrange()</code>를 포함하는 것을 잊어버린 일반적인 경우:</strong></p>
<pre><code class="language-python">for rowcount in table.getRowCount():
    print table.getValueAt(rowcount, 0)
</code></pre>
<p>Python 2.2에서는 <code>TypeError</code> 예외가 발생합니다.
현재 제안에 따르면, 위 문장은 유효하며 (아마도) 의도한 대로 작동할 것입니다. 이것은 좋은 점일 것입니다. Tim이 언급했듯이, 이것은 "<code>range</code>를 잊어버린 실수"의 일반적인 경우입니다.</p>
</li>
<li>
<p><strong>튜플 언패킹(tuple unpacking)을 사용할 때 오타를 내는 (바라건대) 매우 드문 경우:</strong></p>
<pre><code class="language-python">x, = 1
</code></pre>
<p>Python 2.2에서는 <code>TypeError</code> 예외가 발생합니다.
현재 제안에 따르면, 위 문장은 유효하며 <code>x</code>를 <code>0</code>으로 설정할 것입니다. PEP 작성자는 이 오타가 얼마나 흔한지, 또는 현재 제안 하에서 이러한 오류를 잡아내기 얼마나 어려운지에 대한 데이터가 없습니다. 그는 이러한 경우가 자주 발생하지 않으며, 발생하더라도 비교적 쉽게 수정할 수 있을 것이라고 생각합니다.</p>
</li>
</ol>
<h3>쟁점 (Issues)</h3>
<p>Python 관심 메일링 리스트에서 PEP 276에 대한 광범위한 논의는 다양한 의견을 제시했습니다. 일부는 찬성하고, 일부는 중립적이며, 일부는 반대했습니다. 찬성하는 사람들은 정수에 대한 단순한 이터레이터의 유용성, 편리함, 학습 용이성, 단순성에 대한 위의 주장에 동의하는 경향이 있었습니다.</p>
<p>PEP 276에 대한 쟁점은 다음과 같습니다.</p>
<ul>
<li>
<p><strong><code>range</code>/<code>xrange</code> 사용은 현재로서는 괜찮다.</strong></p>
<ul>
<li><strong>응답:</strong> 일부는 그렇게 생각하지만, 다른 사람들은 동의하지 않습니다.</li>
</ul>
</li>
<li>
<p><strong>정수 <code>n</code>에 대해 <code>0, 1, 2, ..., n-1</code> 시퀀스를 순회하는 것은 직관적이지 않다.</strong> "<code>for i in 5:</code>"는 (일부에 의해) "명확하지 않다"고 여겨집니다. 일부는 이러한 사용법이 "올바른 느낌"이 없기 때문에 싫어합니다. 일부는 이러한 유형의 사용법이 정수를 시퀀스로 보도록 강요하며, 이것이 잘못되었다고 믿기 때문에 싫어합니다. 일부는 <code>for-loop</code>이 임의의 이터레이터보다는 명시적인 시퀀스를 다루는 것으로 보는 것을 선호하기 때문에 싫어합니다.</p>
<ul>
<li><strong>응답:</strong> 일부는 제안된 방식을 좋아하고 간단하고 우아하며 배우기 쉽고 사용하기 쉽다고 봅니다. 일부는 이 문제에 대해 중립적입니다. 다른 사람들은 앞서 언급했듯이 싫어합니다.</li>
</ul>
</li>
<li>
<p><strong><code>iter(5)</code>가 <code>0,1,2,3,4</code> 시퀀스로 매핑되는 것이 명확한가?</strong></p>
<ul>
<li><strong>응답:</strong> 위에서 언급했듯이, Python은 0에서 시작하여 시퀀스 길이보다 하나 작은 값의 인덱스에서 끝나는 시퀀스 인덱싱에 대한 강력한 규칙을 가지고 있다는 점을 감안할 때, 제안된 시퀀스는 Python 프로그래머에게 합리적으로 직관적이며 유용하고 실용적이라고 주장됩니다. 더 중요한 것은, 일단 이 규칙을 배우면 기억하기 매우 쉽다고 주장됩니다. <code>range</code> 함수의 독스트링(doc string)은 <code>range(n)</code>과 길이가 <code>n</code>인 리스트의 인덱스 사이의 자연스럽고 유용한 연관성을 언급합니다.</li>
</ul>
</li>
<li>
<p><strong>잠재적 모호성:</strong></p>
<pre><code class="language-python">for i in 10: print i
</code></pre>
<p>가</p>
<pre><code class="language-python">for i in (10,): print i
</code></pre>
<p>로 오해될 수 있다.</p>
<ul>
<li><strong>응답:</strong> 이것은 현재 Python의 문자열과 정확히 동일한 상황입니다 (위 코드에서 <code>10</code>을 <code>'spam'</code>으로 바꾸는 것과 같습니다).</li>
</ul>
</li>
<li>
<p><strong>너무 일반적이다:</strong> 최신 Python 릴리스에서는 <code>for-loop</code>과 같이 이터레이터가 암시적으로 호출되는 컨텍스트가 있습니다. 일부는 <code>for-loop</code>를 제외하고 다른 컨텍스트에서 정수에 대한 이터레이터가 호출되는 것이 예상치 못한 동작과 버그로 이어질 수 있다고 우려합니다. 위에서 언급된 "<code>x, = 1</code>" 예시가 좋은 예입니다.</p>
<ul>
<li><strong>응답:</strong> 작성자의 관점에서 PEP 276 논의에서 식별된 위의 예시들은 미묘하고 감지하기 어려운 오류로 이어질 수 있는 방식으로 우발적으로 오용될 것으로 보이지 않았습니다.</li>
<li>또한, 이 제안의 사양 섹션에 설명된 내용을 변형하여 이 문제를 처리하는 방법이 있는 것으로 보입니다. <code>int</code> 클래스에 <code>__iter__</code> 메서드를 추가하는 대신, <code>for-loop</code> 처리 코드를 변경하여 (본질적으로) 다음과 같이 변환하는 것입니다.
<pre><code class="language-python">for i in n: # when isinstance(n,int) is 1
</code></pre>
를
<pre><code class="language-python">for i in xrange(n):
</code></pre>
이 접근 방식은 <code>for-loop</code>에서 <code>__iter__</code> 메서드와 동일한 결과를 제공하지만 다른 어떤 컨텍스트에서도 정수 값에 대한 순회를 방지할 수 있습니다. 예를 들어, <code>list</code>와 <code>tuple</code>은 <code>__iter__</code>를 가지고 있지 않으며 특별한 코드로 처리됩니다. 정수 값은 또 다른 특별한 경우가 될 것입니다.</li>
</ul>
</li>
<li>
<p><strong>"<code>i in n</code>"은 매우 부자연스러워 보인다.</strong></p>
<ul>
<li><strong>응답:</strong> 일부는 "<code>i in len(mylist)</code>"가 쉽게 이해되고 유용할 것이라고 생각합니다. 일부는 특히 "<code>i in 5</code>"와 같이 리터럴이 사용될 때 이를 싫어합니다. 이전 문제에 대한 응답에서 언급된 변형이 구현된다면 이 문제는 논외입니다. 그렇지 않다면, <code>int</code> 클래스에 항상 <code>TypeError</code>를 발생시키는 <code>__contains__</code> 메서드를 정의하여 이 문제를 해결할 수도 있습니다. 이렇게 하면 "<code>i in n</code>"의 동작이 현재 Python과 동일해집니다.</li>
</ul>
</li>
<li>
<p><strong>표준 "<code>for item in collection:</code>" 방식이 분명히 더 나을 때, 초보자들이 <code>indexed for-loop</code> 방식을 사용하지 않도록 막을 수 있다.</strong></p>
<ul>
<li><strong>응답:</strong> 표준 방식은 적합할 때 너무 좋아서 추가적인 "당근"이나 "채찍"이 필요하지 않습니다. 반면에, <code>indexed for-loop</code> 방식의 어색함 때문에 표준 방식의 과용/오용 사례가 눈에 띄기도 합니다.
<pre><code class="language-python">for item in sequence:
    print sequence.index(item)
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>왜 더 큰 변경을 제안하지 않는가?</strong></p>
<ul>
<li>PEP 276에 대한 반대 의견의 대부분은 시작 값, 끝 값, 단계 값뿐만 아니라 열린, 닫힌, 반열린(반닫힌) 정수 구간의 변형을 처리할 만큼 충분히 일반적인 정수 시퀀스를 지정하는 더 일반적인 문제에 대처하기 위해 Python에 훨씬 더 큰 변경을 선호하는 사람들로부터 나왔습니다. 이러한 많은 제안들이 논의되었습니다.</li>
<li>여기에는 다음이 포함됩니다.
<ul>
<li>리터럴 리스트에서 정수 시퀀스를 지정하기 위한 Haskell과 유사한 표기법 추가</li>
<li>시퀀스를 지정하기 위한 슬라이싱(slicing) 표기법의 다양한 사용</li>
<li>루프 헤더에서 관계형 연산자를 사용할 수 있도록 <code>for-in</code> 루프의 구문 변경</li>
<li>정수-구간(integer-interval) 클래스 생성과 관계형 연산자 또는 나눗셈 연산자를 오버로드하여 정수-구간 객체에 "슬라이싱"을 제공하는 메서드 추가</li>
<li>기타</li>
</ul>
</li>
<li>많은 논쟁이 있었지만, 이러한 대규모 제안에 대한 압도적인 합의는 없었습니다.</li>
<li>분명히 PEP 276은 그러한 대규모 변경을 제안하지 않고 특정 문제 영역에 초점을 맞추고 있습니다. 논의 기간이 끝날 무렵, 몇몇 발표자들은 제시된 더 야심찬 제안들에 비해 PEP 276의 좁은 초점과 단순성에 찬성했습니다. 그러한 대규모의 대안적인 제안에 대한 PEP의 필요성에 대한 합의가 있는 것으로 보였습니다. 이러한 인식을 고려하여 다양한 대안적 제안에 대한 자세한 내용은 여기서 더 이상 논의되지 않습니다.</li>
</ul>
</li>
</ul>
<h3>구현 (Implementation)</h3>
<p>현재 구현은 제공되지 않지만, 간단할 것으로 예상됩니다. 작성자는 이 제안의 아이디어를 테스트하기 위한 수단으로 <code>__iter__</code> 메서드(Python으로 작성됨)가 있는 <code>int</code>의 서브클래스를 구현했습니다.</p>
<h3>저작권 (Copyright)</h3>
<p>이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-e1766af8e208074e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/e975486d410ad4e9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-19cfc001fdac3337.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-51594f997fc19690.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/276\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/e975486d410ad4e9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"FeyCvJug7In7AgUZlfHUx\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/276/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/276\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"276\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/276\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T5090,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0276/\"\u003ePEP 276 - Simple Iterator for ints\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Rejected | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 12-Nov-2001\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003ePEP 276 – \u003ccode\u003eint\u003c/code\u003e를 위한 단순 이터레이터\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e작성자:\u003c/strong\u003e Jim Althoff\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태:\u003c/strong\u003e 거부됨 (Rejected)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e유형:\u003c/strong\u003e 표준 트랙 (Standards Track)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생성일:\u003c/strong\u003e 2001년 11월 12일\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePython 버전:\u003c/strong\u003e 2.3\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e요약 (Abstract)\u003c/h3\u003e\n\u003cp\u003ePython 2.1부터 이터레이터(Iterator) 기능(PEP 234)이 추가되었으며, 이는 다양한 코딩 상황에서 유용하고 편리하다는 것이 입증되었습니다. Python의 \u003ccode\u003efor-loop\u003c/code\u003e 제어 구조는 2.1 릴리스부터 이터레이터 프로토콜을 사용하며, \u003ccode\u003elist\u003c/code\u003e, \u003ccode\u003etuple\u003c/code\u003e, \u003ccode\u003edictionary\u003c/code\u003e, \u003ccode\u003estring\u003c/code\u003e, \u003ccode\u003efile\u003c/code\u003e과 같은 내장 타입에 대한 이터레이터를 제공합니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 내장 타입인 \u003ccode\u003eint\u003c/code\u003e (\u003ccode\u003etypes.IntType\u003c/code\u003e)에 이터레이터를 추가할 것을 제안합니다. 이러한 이터레이터는 Python에서 특정 \u003ccode\u003efor-loop\u003c/code\u003e 코딩을 단순화할 수 있을 것입니다.\u003c/p\u003e\n\u003ch3\u003eBDFL (Benevolent Dictator For Life)의 선언 (BDFL Pronouncement)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 2005년 6월 17일, \u003ccode\u003epython-dev\u003c/code\u003e 메일링 리스트에 대한 공지와 함께 \u003cstrong\u003e거부되었습니다\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e원래의 필요성 대부분은 Python 2.3에 채택된 \u003ccode\u003eenumerate()\u003c/code\u003e 함수로 충족되었습니다. 또한, 이 제안은 다음과 같은 오용을 허용하고 장려할 수 있다는 문제가 있었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e for i in 3: print i\r\n0\r\n1\r\n2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마찬가지로, 다음과 같은 문장의 구문 오류를 비활성화할 수 있다는 점도 도움이 되지 않았습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ex, = 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e상세 사양 (Specification)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 \u003ccode\u003etypes.IntType\u003c/code\u003e (즉, 내장 타입 \u003ccode\u003eint\u003c/code\u003e)의 인스턴스를 인자로 받아 \u003ccode\u003eiter()\u003c/code\u003e 내장 함수가 호출될 때 반환되는 이터레이터를 정의합니다.\u003c/p\u003e\n\u003cp\u003e반환된 이터레이터는 다음과 같이 동작합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ei\u003c/code\u003e가 \u003ccode\u003etypes.IntType\u003c/code\u003e의 인스턴스(\u003ccode\u003eint\u003c/code\u003e)이고 \u003ccode\u003ei \u003e 0\u003c/code\u003e이라고 가정할 때:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eiter(i)\u003c/code\u003e는 이터레이터 객체를 반환합니다.\u003c/li\u003e\n\u003cli\u003e해당 이터레이터 객체는 \u003ccode\u003e0, 1, 2, ..., i-1\u003c/code\u003e 순서의 정수를 순회합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e예시:\u003c/strong\u003e\r\n\u003ccode\u003eiter(5)\u003c/code\u003e는 \u003ccode\u003e0, 1, 2, 3, 4\u003c/code\u003e 순서의 정수를 순회하는 이터레이터 객체를 반환합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ei \u0026#x3C;= 0\u003c/code\u003e인 경우, \u003ccode\u003eiter(i)\u003c/code\u003e는 \"빈(empty)\" 이터레이터를 반환합니다. 즉, \u003ccode\u003enext()\u003c/code\u003e 메서드를 처음 호출할 때 \u003ccode\u003eStopIteration\u003c/code\u003e을 발생시킵니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다른 말로, 이 이터레이터의 조건과 의미는 \u003ccode\u003erange()\u003c/code\u003e 및 \u003ccode\u003exrange()\u003c/code\u003e 함수의 조건 및 의미와 일치합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eint\u003c/code\u003e \u003ccode\u003ei\u003c/code\u003e와 연관된 \u003ccode\u003e0, 1, 2, ..., i-1\u003c/code\u003e 시퀀스는 Python 프로그래밍의 맥락에서 \"자연스럽다\"고 간주됩니다. 이는 Python의 시퀀스에 대한 내장 인덱싱 프로토콜과 일치하기 때문입니다. 예를 들어, Python의 \u003ccode\u003elist\u003c/code\u003e와 \u003ccode\u003etuple\u003c/code\u003e은 0부터 시작하여 \u003ccode\u003elen(object)-1\u003c/code\u003e로 끝나는 인덱스(양수 인덱스 사용 시)를 가집니다. 즉, 이러한 객체들은 \u003ccode\u003e0, 1, 2, ..., len(object)-1\u003c/code\u003e 시퀀스로 인덱싱됩니다.\u003c/p\u003e\n\u003ch3\u003e제안 배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003e일반적인 프로그래밍 방식은 객체 컬렉션을 가져와서 컬렉션의 각 항목에 대해 정해진 순서로 어떤 작업을 적용하는 것입니다. Python은 이 일반적인 방식을 처리하기 위해 \"\u003ccode\u003efor in\u003c/code\u003e\" 루프 제어 구조를 제공합니다.\u003c/p\u003e\n\u003cp\u003e그러나, \"인덱싱된(indexed)\" 컬렉션의 각 항목에 접근하기 위해 각 인덱스를 순회하고 해당 인덱스를 사용하여 컬렉션의 각 항목에 접근하는 것이 필요하거나 더 편리한 경우가 발생합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e예시:\u003c/strong\u003e\r\n2차원 \"테이블\" 객체가 있다고 가정했을 때, 테이블의 각 행의 첫 번째 열에 어떤 작업을 적용해야 할 수 있습니다. 테이블의 구현에 따라 각 행과 각 열에 개별 객체로 접근하는 것이 불가능할 수 있습니다. 대신, 행 인덱스와 열 인덱스를 사용하여 테이블의 셀에 접근할 수 있습니다. 이런 경우, 원하는 테이블 항목에 접근하기 위해 인덱스 시퀀스를 순회하는 방식이 필요합니다.\u003c/p\u003e\n\u003cp\u003e또 다른 일반적인 예는 두 개 이상의 컬렉션을 병렬로 처리해야 하는 경우나 컬렉션에서 두 번째 항목마다 접근해야 하는 경우입니다. 컬렉션의 항목에 대한 접근이 인덱스 계산을 통해 용이해지는 다른 많은 예시들이 있으며, 이는 항목 자체에 직접 접근하는 대신 인덱스에 접근해야 함을 의미합니다.\u003c/p\u003e\n\u003cp\u003e이러한 방식을 \"\u003ccode\u003eindexed for-loop\u003c/code\u003e\" 방식이라고 부릅니다. 일부 프로그래밍 언어는 이 방식을 처리하기 위한 내장 구문을 제공합니다. Python에서 \u003ccode\u003eindexed for-loop\u003c/code\u003e 방식을 구현하기 위한 일반적인 규칙은 내장 \u003ccode\u003erange()\u003c/code\u003e 또는 \u003ccode\u003exrange()\u003c/code\u003e 함수를 사용하여 인덱스 시퀀스를 생성하는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e예시:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor rowcount in range(table.getRowCount()):\r\n    print table.getValueAt(rowcount, 0)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor rowcount in xrange(table.getRowCount()):\r\n    print table.getValueAt(rowcount, 0)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eindexed for-loop\u003c/code\u003e 방식에 대한 논의는 Python 커뮤니티에서 종종 이루어졌습니다. 이 디자인 방식에서 \u003ccode\u003erange()\u003c/code\u003e 또는 \u003ccode\u003exrange()\u003c/code\u003e 함수를 사용해야 할 필요성은 다음과 같은 이유로 비판받기도 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e새로운 Python 프로그래머에게 \u003cstrong\u003e명확하지 않다\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e숙련된 Python 프로그래머에게도 \u003cstrong\u003e오류 발생 가능성이 높다\u003c/strong\u003e (잊어버리기 쉽다).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exrange()\u003c/code\u003e와 \u003ccode\u003erange()\u003c/code\u003e의 차이점과 권장 사용법을 이해해야 하는 사람들에게 \u003cstrong\u003e혼란스럽고 산만하다\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e특히 \u003ccode\u003elen()\u003c/code\u003e 함수와 결합할 때 \u003cstrong\u003e다루기 어렵다\u003c/strong\u003e (\u003ccode\u003exrange(len(sequence))\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e다른 언어의 동등한 메커니즘만큼 \u003cstrong\u003e편리하지 않다\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e성가시고\u003c/strong\u003e, \"흠(wart)\"으로 여겨진다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 방식에 대해 Python이 더 나은 메커니즘을 제공할 수 있는 방법에 대한 제안들이 때때로 제시됩니다. 최근 사례로는 PEP 204 \"Range Literals\" 및 PEP 212 \"Loop Counter Iteration\"이 있습니다.\u003c/p\u003e\n\u003cp\u003e대부분의 경우, 이러한 제안에는 Python의 구문 변경 및 기타 \"무거운(heavyweight)\" 변경 사항이 포함됩니다. 여기서의 어려움 중 일부는 새로운 구문을 주장하는 것이 \"일반적인 인덱싱\"에 대한 포괄적인 해결책을 의미하며, 이는 다음과 같은 측면을 포함해야 하기 때문입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e시작 인덱스 값 (starting index value)\u003c/li\u003e\n\u003cli\u003e끝 인덱스 값 (ending index value)\u003c/li\u003e\n\u003cli\u003e단계 값 (step value)\u003c/li\u003e\n\u003cli\u003e열린 구간 (open intervals) 대 닫힌 구간 (closed intervals) 대 반열린 구간 (half opened intervals)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e포괄적이고, 간단하며, 일반적이고, Python답고, 많은 사람들에게 매력적이며, 구현하기 쉽고, 기존 구조와 충돌하지 않으며, 기존 구조를 과도하게 오버로드하지 않는 새로운 구문을 찾는 것은 예상보다 어렵다는 것이 입증되었습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP에 제시된 제안은 이미 사용 가능한 입증된 메커니즘(Python 2.1부터)인 \u003cstrong\u003e이터레이터\u003c/strong\u003e를 사용하여 가장 일반적인 경우를 돕는 간단한 \"경량(lightweight)\" 솔루션을 제안함으로써 문제를 해결하고자 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efor-loop\u003c/code\u003e는 Python 2.1부터 이미 \"이터레이터\" 프로토콜을 사용하므로, 이 PEP에서 제안된 \u003ccode\u003etypes.IntType\u003c/code\u003e에 이터레이터를 추가하면 \u003ccode\u003eindexed for-loop\u003c/code\u003e 방식에 대해 다음과 같은 단축 기능을 기본적으로 활성화할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor rowcount in table.getRowCount():\r\n    print table.getValueAt(rowcount, 0)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003erange()\u003c/code\u003e 또는 \u003ccode\u003exrange()\u003c/code\u003e 함수를 사용하는 현재 메커니즘과 비교하여 이 접근 방식의 이점은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e더 간단하다\u003c/strong\u003e (Simpler).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e더 깔끔하다\u003c/strong\u003e (Less cluttered).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e당면한 문제에 집중한다\u003c/strong\u003e (Focuses on the problem at hand) (보조적인 구현 지향 함수인 \u003ccode\u003erange()\u003c/code\u003e 및 \u003ccode\u003exrange()\u003c/code\u003e에 의존할 필요 없이).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다른 변경 제안과 비교하면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e새로운 구문이 필요 없다\u003c/strong\u003e (Requires no new syntax).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e새로운 키워드가 필요 없다\u003c/strong\u003e (Requires no new keywords).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e새롭고 잘 확립된 이터레이터 메커니즘을 활용한다\u003c/strong\u003e (Takes advantage of the new and well-established iterator mechanism).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그리고 일반적으로:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elist\u003c/code\u003e, \u003ccode\u003etuple\u003c/code\u003e, \u003ccode\u003edictionary\u003c/code\u003e, \u003ccode\u003estring\u003c/code\u003e, \u003ccode\u003efile\u003c/code\u003e과 같은 다른 내장 타입에 대해 이미 포함된 (Python 2.1부터) 이터레이터 기반 \"편의\" 변경 사항과 일치합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e하위 호환성 (Backwards Compatibility)\u003c/h3\u003e\n\u003cp\u003e제안된 메커니즘은 새로운 구문이나 키워드를 요구하지 않으므로 일반적으로 하위 호환됩니다. 모든 기존의 유효한 Python 프로그램은 수정 없이 계속 작동해야 합니다.\u003c/p\u003e\n\u003cp\u003e그러나 이 제안은 현재 유효하지 않은 특정 문장이 현재 제안에 따라 유효하게 된다는 점에서 완벽하게 하위 호환되지 않습니다. Tim Peters는 두 가지 예를 지적했습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003erange()\u003c/code\u003e 또는 \u003ccode\u003exrange()\u003c/code\u003e를 포함하는 것을 잊어버린 일반적인 경우:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor rowcount in table.getRowCount():\r\n    print table.getValueAt(rowcount, 0)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 2.2에서는 \u003ccode\u003eTypeError\u003c/code\u003e 예외가 발생합니다.\r\n현재 제안에 따르면, 위 문장은 유효하며 (아마도) 의도한 대로 작동할 것입니다. 이것은 좋은 점일 것입니다. Tim이 언급했듯이, 이것은 \"\u003ccode\u003erange\u003c/code\u003e를 잊어버린 실수\"의 일반적인 경우입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e튜플 언패킹(tuple unpacking)을 사용할 때 오타를 내는 (바라건대) 매우 드문 경우:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ex, = 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePython 2.2에서는 \u003ccode\u003eTypeError\u003c/code\u003e 예외가 발생합니다.\r\n현재 제안에 따르면, 위 문장은 유효하며 \u003ccode\u003ex\u003c/code\u003e를 \u003ccode\u003e0\u003c/code\u003e으로 설정할 것입니다. PEP 작성자는 이 오타가 얼마나 흔한지, 또는 현재 제안 하에서 이러한 오류를 잡아내기 얼마나 어려운지에 대한 데이터가 없습니다. 그는 이러한 경우가 자주 발생하지 않으며, 발생하더라도 비교적 쉽게 수정할 수 있을 것이라고 생각합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e쟁점 (Issues)\u003c/h3\u003e\n\u003cp\u003ePython 관심 메일링 리스트에서 PEP 276에 대한 광범위한 논의는 다양한 의견을 제시했습니다. 일부는 찬성하고, 일부는 중립적이며, 일부는 반대했습니다. 찬성하는 사람들은 정수에 대한 단순한 이터레이터의 유용성, 편리함, 학습 용이성, 단순성에 대한 위의 주장에 동의하는 경향이 있었습니다.\u003c/p\u003e\n\u003cp\u003ePEP 276에 대한 쟁점은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003erange\u003c/code\u003e/\u003ccode\u003exrange\u003c/code\u003e 사용은 현재로서는 괜찮다.\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e응답:\u003c/strong\u003e 일부는 그렇게 생각하지만, 다른 사람들은 동의하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e정수 \u003ccode\u003en\u003c/code\u003e에 대해 \u003ccode\u003e0, 1, 2, ..., n-1\u003c/code\u003e 시퀀스를 순회하는 것은 직관적이지 않다.\u003c/strong\u003e \"\u003ccode\u003efor i in 5:\u003c/code\u003e\"는 (일부에 의해) \"명확하지 않다\"고 여겨집니다. 일부는 이러한 사용법이 \"올바른 느낌\"이 없기 때문에 싫어합니다. 일부는 이러한 유형의 사용법이 정수를 시퀀스로 보도록 강요하며, 이것이 잘못되었다고 믿기 때문에 싫어합니다. 일부는 \u003ccode\u003efor-loop\u003c/code\u003e이 임의의 이터레이터보다는 명시적인 시퀀스를 다루는 것으로 보는 것을 선호하기 때문에 싫어합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e응답:\u003c/strong\u003e 일부는 제안된 방식을 좋아하고 간단하고 우아하며 배우기 쉽고 사용하기 쉽다고 봅니다. 일부는 이 문제에 대해 중립적입니다. 다른 사람들은 앞서 언급했듯이 싫어합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eiter(5)\u003c/code\u003e가 \u003ccode\u003e0,1,2,3,4\u003c/code\u003e 시퀀스로 매핑되는 것이 명확한가?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e응답:\u003c/strong\u003e 위에서 언급했듯이, Python은 0에서 시작하여 시퀀스 길이보다 하나 작은 값의 인덱스에서 끝나는 시퀀스 인덱싱에 대한 강력한 규칙을 가지고 있다는 점을 감안할 때, 제안된 시퀀스는 Python 프로그래머에게 합리적으로 직관적이며 유용하고 실용적이라고 주장됩니다. 더 중요한 것은, 일단 이 규칙을 배우면 기억하기 매우 쉽다고 주장됩니다. \u003ccode\u003erange\u003c/code\u003e 함수의 독스트링(doc string)은 \u003ccode\u003erange(n)\u003c/code\u003e과 길이가 \u003ccode\u003en\u003c/code\u003e인 리스트의 인덱스 사이의 자연스럽고 유용한 연관성을 언급합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e잠재적 모호성:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor i in 10: print i\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e가\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor i in (10,): print i\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e로 오해될 수 있다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e응답:\u003c/strong\u003e 이것은 현재 Python의 문자열과 정확히 동일한 상황입니다 (위 코드에서 \u003ccode\u003e10\u003c/code\u003e을 \u003ccode\u003e'spam'\u003c/code\u003e으로 바꾸는 것과 같습니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e너무 일반적이다:\u003c/strong\u003e 최신 Python 릴리스에서는 \u003ccode\u003efor-loop\u003c/code\u003e과 같이 이터레이터가 암시적으로 호출되는 컨텍스트가 있습니다. 일부는 \u003ccode\u003efor-loop\u003c/code\u003e를 제외하고 다른 컨텍스트에서 정수에 대한 이터레이터가 호출되는 것이 예상치 못한 동작과 버그로 이어질 수 있다고 우려합니다. 위에서 언급된 \"\u003ccode\u003ex, = 1\u003c/code\u003e\" 예시가 좋은 예입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e응답:\u003c/strong\u003e 작성자의 관점에서 PEP 276 논의에서 식별된 위의 예시들은 미묘하고 감지하기 어려운 오류로 이어질 수 있는 방식으로 우발적으로 오용될 것으로 보이지 않았습니다.\u003c/li\u003e\n\u003cli\u003e또한, 이 제안의 사양 섹션에 설명된 내용을 변형하여 이 문제를 처리하는 방법이 있는 것으로 보입니다. \u003ccode\u003eint\u003c/code\u003e 클래스에 \u003ccode\u003e__iter__\u003c/code\u003e 메서드를 추가하는 대신, \u003ccode\u003efor-loop\u003c/code\u003e 처리 코드를 변경하여 (본질적으로) 다음과 같이 변환하는 것입니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor i in n: # when isinstance(n,int) is 1\n\u003c/code\u003e\u003c/pre\u003e\n를\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor i in xrange(n):\n\u003c/code\u003e\u003c/pre\u003e\n이 접근 방식은 \u003ccode\u003efor-loop\u003c/code\u003e에서 \u003ccode\u003e__iter__\u003c/code\u003e 메서드와 동일한 결과를 제공하지만 다른 어떤 컨텍스트에서도 정수 값에 대한 순회를 방지할 수 있습니다. 예를 들어, \u003ccode\u003elist\u003c/code\u003e와 \u003ccode\u003etuple\u003c/code\u003e은 \u003ccode\u003e__iter__\u003c/code\u003e를 가지고 있지 않으며 특별한 코드로 처리됩니다. 정수 값은 또 다른 특별한 경우가 될 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\"\u003ccode\u003ei in n\u003c/code\u003e\"은 매우 부자연스러워 보인다.\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e응답:\u003c/strong\u003e 일부는 \"\u003ccode\u003ei in len(mylist)\u003c/code\u003e\"가 쉽게 이해되고 유용할 것이라고 생각합니다. 일부는 특히 \"\u003ccode\u003ei in 5\u003c/code\u003e\"와 같이 리터럴이 사용될 때 이를 싫어합니다. 이전 문제에 대한 응답에서 언급된 변형이 구현된다면 이 문제는 논외입니다. 그렇지 않다면, \u003ccode\u003eint\u003c/code\u003e 클래스에 항상 \u003ccode\u003eTypeError\u003c/code\u003e를 발생시키는 \u003ccode\u003e__contains__\u003c/code\u003e 메서드를 정의하여 이 문제를 해결할 수도 있습니다. 이렇게 하면 \"\u003ccode\u003ei in n\u003c/code\u003e\"의 동작이 현재 Python과 동일해집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e표준 \"\u003ccode\u003efor item in collection:\u003c/code\u003e\" 방식이 분명히 더 나을 때, 초보자들이 \u003ccode\u003eindexed for-loop\u003c/code\u003e 방식을 사용하지 않도록 막을 수 있다.\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e응답:\u003c/strong\u003e 표준 방식은 적합할 때 너무 좋아서 추가적인 \"당근\"이나 \"채찍\"이 필요하지 않습니다. 반면에, \u003ccode\u003eindexed for-loop\u003c/code\u003e 방식의 어색함 때문에 표준 방식의 과용/오용 사례가 눈에 띄기도 합니다.\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efor item in sequence:\r\n    print sequence.index(item)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e왜 더 큰 변경을 제안하지 않는가?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePEP 276에 대한 반대 의견의 대부분은 시작 값, 끝 값, 단계 값뿐만 아니라 열린, 닫힌, 반열린(반닫힌) 정수 구간의 변형을 처리할 만큼 충분히 일반적인 정수 시퀀스를 지정하는 더 일반적인 문제에 대처하기 위해 Python에 훨씬 더 큰 변경을 선호하는 사람들로부터 나왔습니다. 이러한 많은 제안들이 논의되었습니다.\u003c/li\u003e\n\u003cli\u003e여기에는 다음이 포함됩니다.\n\u003cul\u003e\n\u003cli\u003e리터럴 리스트에서 정수 시퀀스를 지정하기 위한 Haskell과 유사한 표기법 추가\u003c/li\u003e\n\u003cli\u003e시퀀스를 지정하기 위한 슬라이싱(slicing) 표기법의 다양한 사용\u003c/li\u003e\n\u003cli\u003e루프 헤더에서 관계형 연산자를 사용할 수 있도록 \u003ccode\u003efor-in\u003c/code\u003e 루프의 구문 변경\u003c/li\u003e\n\u003cli\u003e정수-구간(integer-interval) 클래스 생성과 관계형 연산자 또는 나눗셈 연산자를 오버로드하여 정수-구간 객체에 \"슬라이싱\"을 제공하는 메서드 추가\u003c/li\u003e\n\u003cli\u003e기타\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e많은 논쟁이 있었지만, 이러한 대규모 제안에 대한 압도적인 합의는 없었습니다.\u003c/li\u003e\n\u003cli\u003e분명히 PEP 276은 그러한 대규모 변경을 제안하지 않고 특정 문제 영역에 초점을 맞추고 있습니다. 논의 기간이 끝날 무렵, 몇몇 발표자들은 제시된 더 야심찬 제안들에 비해 PEP 276의 좁은 초점과 단순성에 찬성했습니다. 그러한 대규모의 대안적인 제안에 대한 PEP의 필요성에 대한 합의가 있는 것으로 보였습니다. 이러한 인식을 고려하여 다양한 대안적 제안에 대한 자세한 내용은 여기서 더 이상 논의되지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e구현 (Implementation)\u003c/h3\u003e\n\u003cp\u003e현재 구현은 제공되지 않지만, 간단할 것으로 예상됩니다. 작성자는 이 제안의 아이디어를 테스트하기 위한 수단으로 \u003ccode\u003e__iter__\u003c/code\u003e 메서드(Python으로 작성됨)가 있는 \u003ccode\u003eint\u003c/code\u003e의 서브클래스를 구현했습니다.\u003c/p\u003e\n\u003ch3\u003e저작권 (Copyright)\u003c/h3\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인(public domain)에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1098,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Rejected] PEP 276 - Simple Iterator for ints\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 17:54:04+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>