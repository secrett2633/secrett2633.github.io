<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/edf391eeca43d999.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-15a70ff5b484f3df.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6087bc228fd56b83.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-d2fcfe6c399a7b4a.js" async=""></script><script src="/_next/static/chunks/app/layout-b06e577e11976c7d.js" async=""></script><script src="/_next/static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://blog.secrett2633.site/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://blog.secrett2633.site/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button></div></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1885<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 523 - Adding a frame evaluation API to CPython</h1><div class="page__meta"><time dateTime="2025-09-26 23:16:26+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0523/">PEP 523 - Adding a frame evaluation API to CPython</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 16-May-2016</p>
</blockquote>
<h1>PEP 523 – CPython에 프레임 평가 API 추가</h1>
<h2>개요 (Abstract)</h2>
<p>이 PEP는 CPython의 C API를 확장하여 인터프리터별 프레임 평가 함수를 지정할 수 있도록 제안합니다. 또한, 이 제안은 프레임 평가 함수에서 사용할 임의의 데이터를 저장하기 위해 코드 객체에 새로운 필드를 추가하는 것을 포함합니다.</p>
<h2>배경 (Rationale)</h2>
<p>Python 코드의 직접적인 실행에는 유연성이 부족한 부분이 있었습니다. CPython의 C API는 프레임 객체에 데이터를 구성하고 <code>PyEval_EvalFrameEx()</code>를 통해 평가할 수 있도록 허용하지만, Python 코드 실행에 대한 제어는 프레임 수준의 전체적인 제어가 아닌 개별 객체에만 국한되었습니다.</p>
<p>프레임 평가에 대한 영향을 원한다는 것이 다소 로우레벨(low-level)하게 들릴 수 있지만, 이는 CPython 자체에서 제공할 필요 없이 메서드 수준의 JIT (Just-In-Time Compiler)를 CPython에 도입할 가능성을 열어줍니다. 외부 C 코드가 프레임 평가를 제어할 수 있도록 함으로써, JIT는 평가가 발생하는 핵심 지점에서 Python 코드 실행에 참여할 수 있습니다. 이를 통해 JIT는 필요에 따라 Python 바이트코드를 머신 코드로 조건부 재컴파일할 수 있으며, JIT 실행이 원치 않을 때는 일반 CPython 바이트코드를 실행할 수 있습니다. 이는 인터프리터가 프레임을 평가하기 위해 호출할 함수를 지정할 수 있도록 함으로써 달성됩니다. 또한, API를 프레임 평가 수준에 배치함으로써 JIT가 코드의 실행 환경에 대한 완전한 시야를 가질 수 있습니다.</p>
<p>프레임 평가 함수를 지정하는 이러한 기능은 CPython을 JIT에 개방하는 것 외에도 다른 사용 사례를 가능하게 합니다. 예를 들어, 이 API를 사용하면 호출 수준에서 트레이싱(tracing) 또는 프로파일링(profiling) 기능을 구현하는 것이 어렵지 않을 것입니다. CPython은 Python 수준에서 트레이싱 또는 프로파일링 함수를 설정하는 기능을 제공하지만, 이 API는 프로파일러의 데이터 수집과 일치할 수 있으며, 라인별 트레이싱 지원을 단순히 건너뛰어 트레이싱에 더 빠를 수 있습니다.</p>
<p>또한, 이는 디버깅(debugging)의 가능성을 열어줍니다. 프레임 평가 함수는 특정 코드 객체를 실행하려고 할 때만 특별한 디버깅 작업을 수행할 수 있습니다. 이 경우, 바이트코드는 이론적으로 인플레이스(in-place)로 재작성되어 적절한 지점에 브레이크포인트(breakpoint) 함수 호출을 삽입하여 디버깅을 돕고, <code>sys.settrace()</code>에서 요구하는 강력한 접근 방식을 사용하지 않을 수 있습니다.</p>
<p>이러한 사용 사례를 용이하게 하기 위해, 새로운 필드를 통해 코드 객체에 "스크래치 공간(scratch space)"을 추가하는 것도 제안됩니다. 이를 통해 코드 객체별 데이터를 코드 객체 자체에 저장하여, 필요에 따라 프레임 평가 함수가 쉽게 검색할 수 있도록 합니다. 필드 자체는 단순히 <code>PyObject *</code> 타입이므로, 필드에 저장된 모든 데이터는 일반 객체 메모리 관리(object memory management)에 참여하게 됩니다.</p>
<h2>제안 (Proposal)</h2>
<p>아래 제안된 모든 C API 변경 사항은 안정적인 ABI (Application Binary Interface)의 일부가 되지 않습니다.</p>
<h3><code>PyCodeObject</code> 확장</h3>
<p><code>PyCodeObject</code> 구조체에 하나의 필드가 추가됩니다.</p>
<pre><code class="language-c">typedef struct {
    /* ... */
    void *co_extra; /* "Scratch space" for the code object. */
} PyCodeObject;
</code></pre>
<p><code>co_extra</code>는 기본적으로 <code>NULL</code>이며 필요에 따라 채워집니다. 필드에 저장된 값은 코드 객체가 작동하는 데 필수는 아니므로, 데이터 손실이 허용됩니다.</p>
<p>이 필드와 함께 작동하기 위해 비공개(private) API가 도입되었습니다.</p>
<pre><code class="language-c">PyAPI_FUNC(Py_ssize_t) _PyEval_RequestCodeExtraIndex(freefunc);
PyAPI_FUNC(int) _PyCode_GetExtra(PyObject *code, Py_ssize_t index, void **extra);
PyAPI_FUNC(int) _PyCode_SetExtra(PyObject *code, Py_ssize_t index, void *extra);
</code></pre>
<p>필드 사용자는 <code>_PyEval_RequestCodeExtraIndex()</code>를 호출하여 <code>co_extra</code>에 데이터를 추가할 불투명한 인덱스(opaque index) 값을 받아야 합니다. 이 인덱스를 사용하여 사용자는 <code>_PyCode_SetExtra()</code>로 데이터를 설정하고 나중에 <code>_PyCode_GetExtra()</code>로 데이터를 검색할 수 있습니다. 이 API는 Python 릴리스 간에 API의 의미론적 보장(semantic guarantees)이 없음을 알리기 위해 의도적으로 비공개로 나열되었습니다.</p>
<p>리스트(list)와 튜플(tuple) 사용이 고려되었지만 성능이 떨어지는 것으로 나타났으며, 주요 사용 사례가 JIT인 점을 고려할 때 Python 객체 대신 사용자 정의 구조체를 사용하는 것이 성능 면에서 우세했습니다. 딕셔너리(dict)도 고려되었지만, 다시 한번 성능이 더 중요했습니다. 딕셔너리는 데이터 조회에 상수 오버헤드(constant overhead)가 있지만, 데이터 구조에 단일 객체가 저장되는 일반적인 경우에 튜플이 더 나은 성능 특성을 가집니다 (예: 길이가 1인 튜플을 반복하는 것이 딕셔너리에서 객체를 해싱하고 조회하는 오버헤드보다 빠릅니다).</p>
<h3><code>PyInterpreterState</code> 확장</h3>
<p>프레임 평가 함수의 진입점은 인터프리터별(per-interpreter)입니다.</p>
<pre><code class="language-c">// PyEval_EvalFrameEx()와 동일한 타입 시그니처(type signature)입니다.
typedef PyObject* (*_PyFrameEvalFunction)(PyFrameObject*, int);

typedef struct {
    /* ... */
    _PyFrameEvalFunction eval_frame;
} PyInterpreterState;
</code></pre>
<p>기본적으로 <code>eval_frame</code> 필드는 현재 <code>PyEval_EvalFrameEx()</code>가 나타내는 함수 포인터(이 PEP에서 나중에 논의되는 <code>_PyEval_EvalFrameDefault()</code>라고 불림)로 초기화됩니다. 타사 코드(third-party code)는 Python 코드의 실행을 제어하기 위해 자체 프레임 평가 함수를 설정할 수 있습니다. 포인터 비교를 사용하여 필드가 <code>_PyEval_EvalFrameDefault()</code>로 설정되었는지, 따라서 아직 변경되지 않았는지 감지할 수 있습니다.</p>
<h3><code>Python/ceval.c</code> 변경 사항</h3>
<p>현재 <code>PyEval_EvalFrameEx()</code>는 <code>_PyEval_EvalFrameDefault()</code>로 이름이 변경됩니다. 새로운 <code>PyEval_EvalFrameEx()</code>는 다음과 같아집니다.</p>
<pre><code class="language-c">PyObject *
PyEval_EvalFrameEx(PyFrameObject *frame, int throwflag)
{
    PyThreadState *tstate = PyThreadState_GET();
    return tstate->interp->eval_frame(frame, throwflag);
}
</code></pre>
<p>이는 타사 코드가 기존 C API를 이미 사용하는 코드와의 하위 호환성(backwards-compatible)을 유지하면서 Python 코드 실행 경로에 직접 자신을 배치할 수 있도록 합니다.</p>
<h3><code>python-gdb.py</code> 업데이트</h3>
<p>GDB에서 Python 지원을 위해 사용되는 생성된 <code>python-gdb.py</code> 파일은 <code>PyEval_EvalFrameEx()</code>에 대해 일부 하드코딩된 가정(예: 지역 변수 이름)을 합니다. 제안된 변경 사항과 함께 작동하도록 업데이트해야 합니다.</p>
<h2>성능 영향 (Performance impact)</h2>
<p>이 PEP는 플러그인 기능(pluggability)을 추가하기 위한 API를 제안하므로, 성능 영향은 타사 코드가 아무런 변경을 하지 않은 경우에만 고려됩니다.</p>
<p><code>pybench</code>의 여러 실행에서 API 변경만으로는 일관되게 성능 저하가 없음을 보여주었습니다.</p>
<p>Python 벤치마크 스위트의 실행에서는 측정 가능한 성능 비용이 없었습니다.</p>
<p>메모리 영향 측면에서, 단일 프로세스에서 실행되는 CPython 인터프리터가 일반적으로 많지 않으므로 <code>PyCodeObject</code>에 <code>co_extra</code>가 추가되는 영향만 우려됩니다.에 따르면, Python 테스트 스위트의 실행 결과 약 72,395개의 코드 객체가 생성됩니다. 64비트 CPU에서 모든 코드 객체가 동시에 활성 상태이고 <code>co_extra</code> 필드에 아무것도 설정되지 않은 경우, 579,160바이트의 추가 메모리가 사용될 것입니다.</p>
<h2>예시 사용 (Example Usage)</h2>
<h3>CPython용 JIT (A JIT for CPython)</h3>
<h4>Pyjion</h4>
<p>Pyjion 프로젝트는 이 제안된 API를 사용하여 CoreCLR의 JIT를 활용하여 CPython용 JIT를 구현했습니다. 각 코드 객체는 <code>co_extra</code> 필드가 <code>PyjionJittedCode</code> 객체로 설정되며, 이 객체는 네 가지 정보를 저장합니다.</p>
<ul>
<li>실행 횟수 (Execution count)</li>
<li>이전 JIT 시도가 실패했는지 여부를 나타내는 부울(boolean) 값</li>
<li>트램폴린(trampoline)에 대한 함수 포인터 (타입 트레이싱 여부와 관계없이)</li>
<li>JIT 컴파일된 머신 코드에 대한 <code>void</code> 포인터</li>
</ul>
<p>프레임 평가 함수는 (대략적으로) 다음과 같은 알고리즘을 가집니다.</p>
<pre><code class="language-python">def eval_frame(frame, throw_flag):
    pyjion_code = frame.code.co_extra
    if not pyjion_code:
        frame.code.co_extra = PyjionJittedCode()
    elif not pyjion_code.jit_failed:
        if not pyjion_code.jit_code:
            return pyjion_code.eval(pyjion_code.jit_code, frame)
        elif pyjion_code.exec_count > 20_000:
            if jit_compile(frame):
                return pyjion_code.eval(pyjion_code.jit_code, frame)
            else:
                pyjion_code.jit_failed = True
    pyjion_code.exec_count += 1
    return _PyEval_EvalFrameDefault(frame, throw_flag)
</code></pre>
<p>핵심은 이 모든 작업과 로직이 CPython과 분리되어 있지만, 제안된 API 변경 사항 덕분에 Python 시맨틱(semantics)을 준수하는 JIT를 제공할 수 있다는 것입니다 (이 글을 쓰는 시점에는 새로운 API가 없는 CPython과 성능이 거의 동일합니다). 이는 제안된 API를 활용하여 다른 사람들이 CPython용 자체 JIT를 구현하는 것을 기술적으로 막는 것이 없음을 의미합니다.</p>
<h4>다른 JIT (Other JITs)</h4>
<p>Pyston 팀은 이 PEP의 초기 버전에 대해 자문을 받았는데, 그 버전은 JIT에 더 특화되어 있었고, 그들은 메모리 레이아웃에 대한 제어를 원했기 때문에 제안된 변경 사항을 활용하는 데 관심이 없었습니다. PyPy 팀의 개발자와의 비공식적인 논의에서도 비슷한 의견이 나왔습니다.</p>
<p>반면 Numba는 1.0 이후의 미래에 제안된 변경 사항에 관심이 있을 것이라고 제안했습니다.</p>
<p>실험적인 Coconut JIT는 이 PEP의 혜택을 받을 수 있었습니다. Coconut의 개발자와의 비공개 대화에서, 우리의 API가 CPython에 JIT 지원을 추가하기 위해 그들이 개발한 API보다 아마도 우수할 것이라는 말을 들었습니다.</p>
<h3>디버깅 (Debugging)</h3>
<p>Python Tools for Visual Studio (PTVS) 팀과의 대화에서, 그들은 이 API 변경 사항이 더 나은 성능의 디버깅을 구현하는 데 유용할 것이라고 생각했습니다. 배경 섹션에서 언급했듯이, 이 API는 디버깅 기능이 필요한 프레임에서만 전환될 수 있도록 합니다. 이는 <code>sys.settrace()</code>가 일반적으로 제공하는 정보를 건너뛰는 것을 허용하고, 심지어 실행 전에 바이트코드를 동적으로 재작성하여 바이트코드에 브레이크포인트를 주입하는 것까지 가능하게 합니다.</p>
<p>Google도 내부적으로 매우 유사한 API를 제공하며, 이는 성능이 뛰어난 디버깅 목적으로 사용되었습니다.</p>
<h2>구현 (Implementation)</h2>
<p>제안된 API를 구현하는 일련의 패치는 Pyjion 프로젝트를 통해 제공됩니다. 현재 형태로 이 제안된 API보다 CPython에 더 많은 변경 사항이 있지만, 이는 엄격한 목표 달성 요구 사항 대신 개발의 용이성을 위한 것입니다.</p>
<h2>미해결 문제 (Open Issues)</h2>
<h3><code>eval_frame</code>을 <code>NULL</code>로 허용할 것인가? (Allow eval_frame to be NULL)</h3>
<p>현재 프레임 평가 함수는 항상 설정되어 있어야 합니다. 단순히 기본적으로 <code>NULL</code>로 설정하여 <code>_PyEval_EvalFrameDefault()</code>를 사용하도록 신호를 보낼 수도 있습니다. 필드를 특별히 처리하지 않는 현재 제안이 가장 간단해 보였지만, 필드가 실수로 지워지지 않도록 해야 하며, 그렇지 않으면 충돌(crash)이 발생할 수 있습니다.</p>
<h2>기각된 아이디어 (Rejected Ideas)</h2>
<h3>JIT-특정 C API (A JIT-specific C API)</h3>
<p>원래 이 PEP는 JIT에 더 특화된 훨씬 더 큰 API 변경을 제안하려고 했습니다. 그러나 Numba 팀으로부터 피드백을 받은 후, API가 불필요하게 크다는 것이 분명해졌습니다. 진정으로 필요한 것은 JIT 컴파일된 Python 코드의 실행을 처리할 트램폴린 함수를 제공할 기회와, 컴파일된 머신 코드를 다른 중요한 데이터와 함께 해당 Python 코드 객체에 연결하는 방법이라는 것을 깨달았습니다. 필요한 API 변경을 최소화하면서 기능이나 성능 손실이 없다는 것이 입증된 후, 제안은 현재 형태로 변경되었습니다.</p>
<h3><code>co_extra</code>가 필요한가? (Is co_extra needed?)</h3>
<p>PyCon US 2016에서 이 PEP를 논의하는 동안, 일부 핵심 개발자들은 <code>co_extra</code> 필드가 코드 객체를 변경 가능하게 만들 수 있다는 우려를 표했습니다. 코드 객체가 생성된 후 변경되는 필드를 갖는 것이 객체를 변경 가능하게 보이게 한다는 생각이었지만, 코드 객체의 다른 측면은 변경되지 않았습니다.</p>
<p>이 PEP의 관점은 <code>co_extra</code> 필드가 코드 객체가 불변(immutable)이라는 사실을 바꾸지 않는다는 것입니다. 이 필드는 코드 객체를 사용할 수 있게 만드는 데 필요한 정보를 포함하지 않도록 이 PEP에서 지정되었으므로, 캐싱 필드에 가깝습니다. 이는 문자열 객체가 내부적으로 가지는 UTF-8 캐시와 유사하게 볼 수 있습니다. 문자열은 조건부로 설정되는 필드를 가지고 있음에도 불구하고 여전히 불변으로 간주됩니다.</p>
<p>JIT 워크로드에서 필드를 사용할 수 없을 때도 성능 측정이 이루어졌습니다. C++의 정렬되지 않은 맵(unordered map) 또는 Python의 딕셔너리를 사용하여 코드 객체를 JIT-특정 데이터 객체와 연결할 때 필드의 손실은 성능에 너무 큰 비용을 초래하는 것으로 간주되었습니다.</p>
<h2>참고 자료 (References)</h2>
<ul>
<li>Pyjion 프로젝트 (https://github.com/microsoft/pyjion)</li>
<li>CPython의 C API (https://docs.python.org/3/c-api/index.html)</li>
<li>PyCodeObject (https://docs.python.org/3/c-api/code.html#c.PyCodeObject)</li>
<li>.NET Core Runtime (CoreCLR) (https://github.com/dotnet/coreclr)</li>
<li>PyEval_EvalFrameEx() (https://docs.python.org/3/c-api/veryhigh.html?highlight=pyframeobject#c.PyEval_EvalFrameEx)</li>
<li>Numba (http://numba.pydata.org/)</li>
<li>numba-users 메일링 리스트: "Would the C API for a JIT entrypoint being proposed by Pyjion help out Numba?" (https://groups.google.com/a/continuum.io/forum/#!topic/numba-users/yRl_0t8-m1g)</li>
<li>[Python-Dev] Opcode cache in ceval loop (https://mail.python.org/pipermail/python-dev/2016-February/143025.html)</li>
<li>Python 벤치마크 스위트 (https://hg.python.org/benchmarks)</li>
<li>Pyston (http://pyston.org)</li>
<li>PyPy (http://pypy.org/)</li>
<li>Python Tools for Visual Studio (http://microsoft.github.io/PTVS/)</li>
<li>Coconut (https://github.com/davidmalcolm/coconut)</li>
<li>pybench (https://hg.python.org/cpython/file/default/Tools/pybench)</li>
</ul>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.
Source: <code>https://github.com/python/peps/blob/main/peps/pep-0523.rst</code>
최종 수정: 2025-02-01 08:55:40 GMTPEP 523은 CPython의 C API를 확장하여 프레임 평가 함수를 지정할 수 있도록 하는 제안입니다. 이 문서는 Python 개발자들이 JIT 컴파일러, 고급 디버깅 도구, 그리고 프로파일링 도구와 같은 외부 도구들이 CPython의 실행 흐름에 더 깊이 개입할 수 있도록 하는 것을 목표로 합니다.</p>
<h2>PEP 523 – CPython에 프레임 평가 API 추가</h2>
<h3>개요 (Abstract)</h3>
<p>이 PEP는 CPython의 C API를 확장하여 인터프리터별 프레임 평가 함수를 지정할 수 있도록 제안합니다. 또한, 이 제안은 프레임 평가 함수에서 사용할 임의의 데이터를 저장하기 위해 코드 객체 (code object)에 새로운 필드를 추가하는 것을 포함합니다.</p>
<h3>배경 (Rationale)</h3>
<p>기존 CPython은 <code>PyEval_EvalFrameEx()</code>를 통해 프레임을 평가하는 기능을 제공했지만, Python 코드 실행에 대한 전체적인 제어보다는 개별 객체 수준에서의 제어에 머물러 있었습니다. 이러한 유연성 부족은 특히 JIT(Just-In-Time) 컴파일러와 같은 외부 도구가 CPython의 실행 흐름에 통합되는 것을 어렵게 했습니다.</p>
<p>이 PEP는 프레임 수준에서 실행 제어를 제공함으로써 다음과 같은 가능성을 열어줍니다:</p>
<ul>
<li><strong>JIT 컴파일러 도입</strong> : CPython 자체에 JIT를 내장하지 않고도, 외부 C 코드가 프레임 평가를 제어하여 Python 바이트코드를 머신 코드로 조건부 재컴파일할 수 있도록 합니다. 이는 JIT가 필요한 경우에만 활성화되고, 그렇지 않은 경우에는 표준 CPython 바이트코드를 실행할 수 있게 합니다.</li>
<li><strong>고급 트레이싱 및 프로파일링</strong> : 호출 수준에서 트레이싱 또는 프로파일링 기능을 더 효율적으로 구현할 수 있게 됩니다. <code>sys.settrace()</code>와 같은 기존 Python 수준의 기능보다 더 빠르고 상세한 데이터 수집이 가능하며, 라인별 트레이싱을 건너뛰는 등의 최적화도 가능합니다.</li>
<li><strong>효율적인 디버깅</strong> : 프레임 평가 함수가 특정 코드 객체를 실행하기 전에 디버깅 작업을 수행할 수 있도록 합니다. 이는 바이트코드를 동적으로 재작성하여 브레이크포인트(breakpoint)를 삽입하는 등의 고급 디버깅 기능을 <code>sys.settrace()</code>보다 가벼운 방식으로 구현할 수 있게 합니다.</li>
</ul>
<p>이러한 사용 사례를 지원하기 위해, 코드 객체에 새로운 "스크래치 공간(scratch space)" 필드인 <code>co_extra</code>를 추가하는 것도 제안됩니다. 이 필드는 프레임 평가 함수가 필요에 따라 코드 객체별 데이터를 저장하고 검색하는 데 사용됩니다.</p>
<h3>제안 (Proposal)</h3>
<p>제안된 C API 변경 사항은 안정적인 ABI (Application Binary Interface)의 일부가 되지 않습니다.</p>
<h4><code>PyCodeObject</code> 확장</h4>
<p><code>PyCodeObject</code> 구조체에 <code>void *co_extra;</code> 필드가 추가됩니다.</p>
<ul>
<li><code>co_extra</code>는 기본적으로 <code>NULL</code>이며, 필요에 따라 임의의 데이터를 저장하는 데 사용됩니다.</li>
<li>이 필드에 저장된 데이터는 코드 객체 기능에 필수는 아니므로, 데이터 손실이 허용됩니다.</li>
<li><code>co_extra</code>와 상호작용하기 위한 비공개 API인 <code>_PyEval_RequestCodeExtraIndex()</code>, <code>_PyCode_GetExtra()</code>, <code>_PyCode_SetExtra()</code>가 제공됩니다. 이 API는 Python 릴리스 간에 의미론적 보장이 없으므로 주의해야 합니다. 성능상의 이유로 리스트, 튜플, 딕셔너리 대신 사용자 정의 구조체와 유사한 방식으로 관리됩니다.</li>
</ul>
<h4><code>PyInterpreterState</code> 확장</h4>
<p>인터프리터별(per-interpreter) 프레임 평가 함수를 위한 진입점이 추가됩니다.</p>
<ul>
<li><code>PyInterpreterState</code> 구조체에 <code>_PyFrameEvalFunction eval_frame;</code> 필드가 추가됩니다.</li>
<li><code>eval_frame</code>은 기본적으로 기존 <code>PyEval_EvalFrameEx()</code>의 동작을 나타내는 <code>_PyEval_EvalFrameDefault()</code> 함수 포인터로 초기화됩니다.</li>
<li>타사 코드는 이 <code>eval_frame</code> 필드를 자신의 커스텀 함수로 설정하여 Python 코드 실행을 제어할 수 있습니다.</li>
</ul>
<h4><code>Python/ceval.c</code> 변경 사항</h4>
<ul>
<li>기존 <code>PyEval_EvalFrameEx()</code>는 <code>_PyEval_EvalFrameDefault()</code>로 이름이 변경됩니다.</li>
<li>새로운 <code>PyEval_EvalFrameEx()</code>는 <code>PyThreadState *tstate = PyThreadState_GET(); return tstate->interp->eval_frame(frame, throwflag);</code>와 같이 현재 스레드의 인터프리터에 설정된 <code>eval_frame</code> 함수를 호출하도록 변경됩니다.</li>
<li>이 변경은 타사 코드가 Python 코드 실행 경로에 직접 개입하면서도 기존 C API를 사용하는 코드와의 하위 호환성(backwards-compatible)을 유지하도록 합니다.</li>
</ul>
<h4><code>python-gdb.py</code> 업데이트</h4>
<p>GDB의 Python 지원을 위한 <code>python-gdb.py</code> 파일은 <code>PyEval_EvalFrameEx()</code>에 대한 가정을 포함하므로, 제안된 변경 사항과 호환되도록 업데이트되어야 합니다.</p>
<h3>성능 영향 (Performance impact)</h3>
<p>이 PEP는 플러그인 기능(pluggability)을 위한 API를 제안하므로, 타사 코드가 변경을 가하지 않은 경우의 성능 영향만 고려됩니다.</p>
<ul>
<li><code>pybench</code> 및 Python 벤치마크 스위트 실행 결과, API 변경만으로는 측정 가능한 성능 저하가 없었습니다.</li>
<li>메모리 측면에서는 <code>co_extra</code> 필드가 <code>PyCodeObject</code>에 추가됨으로써 발생할 수 있는 영향이 우려됩니다. 약 72,395개의 코드 객체가 생성되는 Python 테스트 스위트 실행 기준으로, 64비트 CPU에서 최대 579,160바이트의 추가 메모리 사용이 발생할 수 있습니다.</li>
</ul>
<h3>예시 사용 (Example Usage)</h3>
<h4>CPython용 JIT (A JIT for CPython)</h4>
<ul>
<li><strong>Pyjion</strong> : 이 제안된 API를 사용하여 CoreCLR의 JIT를 활용한 CPython용 JIT를 구현했습니다. <code>co_extra</code> 필드에 JIT 컴파일된 코드와 관련 메타데이터를 저장하고, <code>eval_frame</code> 함수를 오버라이드하여 JIT 컴파일된 코드를 실행합니다. 이는 CPython과 분리된 상태로 Python 시맨틱을 준수하는 JIT를 제공하는 것이 가능함을 보여줍니다.</li>
<li><strong>다른 JITs</strong> : Pyston 및 PyPy 팀은 초기 버전의 PEP에 큰 관심을 보이지 않았으나, Numba는 향후 버전에 관심을 표명했습니다. Coconut JIT 또한 이 PEP의 혜택을 받을 수 있었을 것입니다.</li>
</ul>
<h4>디버깅 (Debugging)</h4>
<ul>
<li><strong>Python Tools for Visual Studio (PTVS)</strong> 팀은 이 API가 더 높은 성능의 디버깅 기능을 구현하는 데 유용할 것이라고 언급했습니다. 필요한 프레임에서만 디버깅 기능을 활성화하고, 바이트코드를 동적으로 재작성하여 브레이크포인트를 주입하는 등의 고급 기능을 구현할 수 있습니다. Google도 내부적으로 유사한 API를 사용하여 성능 좋은 디버깅에 활용하고 있습니다.</li>
</ul>
<h3>구현 (Implementation)</h3>
<p>제안된 API를 구현하는 패치 세트는 Pyjion 프로젝트를 통해 제공됩니다.</p>
<h3>미해결 문제 (Open Issues)</h3>
<ul>
<li><strong><code>eval_frame</code>을 <code>NULL</code>로 허용할 것인가?</strong> : 현재는 <code>eval_frame</code>이 항상 설정되어 있어야 하지만, <code>NULL</code>을 기본값으로 하여 <code>_PyEval_EvalFrameDefault()</code>를 사용하도록 신호를 보낼 수도 있습니다. 필드가 우발적으로 지워져 충돌이 발생하는 것을 방지해야 합니다.</li>
</ul>
<h3>기각된 아이디어 (Rejected Ideas)</h3>
<h4>JIT-특정 C API (A JIT-specific C API)</h4>
<p>초기에는 더 크고 JIT에 특화된 API가 제안되었으나, Numba 팀의 피드백을 통해 불필요하게 크다는 것이 밝혀졌습니다. 결국, JIT 컴파일된 Python 코드 실행을 처리할 트램폴린 함수와 컴파일된 코드를 Python 코드 객체에 연결하는 방법만 있으면 된다는 결론에 도달하여 현재의 간소화된 형태로 변경되었습니다.</p>
<h4><code>co_extra</code>가 필요한가? (Is co_extra needed?)</h4>
<p><code>co_extra</code> 필드가 코드 객체를 변경 가능하게 만들 수 있다는 우려가 제기되었습니다. 그러나 이 PEP는 <code>co_extra</code> 필드가 코드 객체 자체의 불변성(immutability)을 변경하지 않으며, 코드 객체가 작동하는 데 필요한 정보를 포함하지 않고 주로 캐싱(caching) 목적으로 사용된다고 주장합니다. 이는 문자열 객체의 내부 UTF-8 캐시와 유사하게 볼 수 있습니다. 성능 측정 결과, JIT 워크로드에서 이 필드가 없을 경우 성능 저하가 너무 커서 필드를 유지하는 것이 합당하다고 판단되었습니다.</p>
<h3>참고 자료 (References)</h3>
<p>문서 말미에 언급된 다양한 프로젝트, API 문서, 메일링 리스트 및 벤치마크 도구에 대한 참고 자료가 포함되어 있습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer><section class="mt-12 border-t border-gray-200 pt-8"><h3 class="text-base font-semibold text-gray-900 mb-4">Python<!-- --> 의 다른글</h3><ul class="space-y-2 text-sm"><li class="text-gray-500">이전글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/522/">[Rejected] PEP 522 - Allow BlockingIOError in security sensitive APIs</a></li><li class="text-gray-900 font-semibold">현재글 : <!-- -->[Final] PEP 523 - Adding a frame evaluation API to CPython</li><li class="text-gray-500">다음글<!-- --> <a class="text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4" href="/python/pep/524/">[Final] PEP 524 - Make os.urandom() blocking on Linux</a></li></ul></section></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-15a70ff5b484f3df.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/edf391eeca43d999.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[5751,[],\"\"]\n6:I[9275,[],\"\"]\n8:I[1343,[],\"\"]\n9:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-d2fcfe6c399a7b4a.js\",\"185\",\"static/chunks/app/layout-b06e577e11976c7d.js\"],\"default\"]\na:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"877\",\"static/chunks/app/%5B...slug%5D/page-9d772c571b4668c1.js\"],\"\"]\nc:I[6130,[],\"\"]\n7:[\"slug\",\"python/pep/523\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/edf391eeca43d999.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"LkoFRRXGj3o0jVIpHD68u\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/523/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/523\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"523\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/523\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",\"$L5\"],null],null]},[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L9\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]]\n"])</script><script>self.__next_f.push([1,"e:T696c,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0523/\"\u003ePEP 523 - Adding a frame evaluation API to CPython\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 16-May-2016\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 523 – CPython에 프레임 평가 API 추가\u003c/h1\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 CPython의 C API를 확장하여 인터프리터별 프레임 평가 함수를 지정할 수 있도록 제안합니다. 또한, 이 제안은 프레임 평가 함수에서 사용할 임의의 데이터를 저장하기 위해 코드 객체에 새로운 필드를 추가하는 것을 포함합니다.\u003c/p\u003e\n\u003ch2\u003e배경 (Rationale)\u003c/h2\u003e\n\u003cp\u003ePython 코드의 직접적인 실행에는 유연성이 부족한 부분이 있었습니다. CPython의 C API는 프레임 객체에 데이터를 구성하고 \u003ccode\u003ePyEval_EvalFrameEx()\u003c/code\u003e를 통해 평가할 수 있도록 허용하지만, Python 코드 실행에 대한 제어는 프레임 수준의 전체적인 제어가 아닌 개별 객체에만 국한되었습니다.\u003c/p\u003e\n\u003cp\u003e프레임 평가에 대한 영향을 원한다는 것이 다소 로우레벨(low-level)하게 들릴 수 있지만, 이는 CPython 자체에서 제공할 필요 없이 메서드 수준의 JIT (Just-In-Time Compiler)를 CPython에 도입할 가능성을 열어줍니다. 외부 C 코드가 프레임 평가를 제어할 수 있도록 함으로써, JIT는 평가가 발생하는 핵심 지점에서 Python 코드 실행에 참여할 수 있습니다. 이를 통해 JIT는 필요에 따라 Python 바이트코드를 머신 코드로 조건부 재컴파일할 수 있으며, JIT 실행이 원치 않을 때는 일반 CPython 바이트코드를 실행할 수 있습니다. 이는 인터프리터가 프레임을 평가하기 위해 호출할 함수를 지정할 수 있도록 함으로써 달성됩니다. 또한, API를 프레임 평가 수준에 배치함으로써 JIT가 코드의 실행 환경에 대한 완전한 시야를 가질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e프레임 평가 함수를 지정하는 이러한 기능은 CPython을 JIT에 개방하는 것 외에도 다른 사용 사례를 가능하게 합니다. 예를 들어, 이 API를 사용하면 호출 수준에서 트레이싱(tracing) 또는 프로파일링(profiling) 기능을 구현하는 것이 어렵지 않을 것입니다. CPython은 Python 수준에서 트레이싱 또는 프로파일링 함수를 설정하는 기능을 제공하지만, 이 API는 프로파일러의 데이터 수집과 일치할 수 있으며, 라인별 트레이싱 지원을 단순히 건너뛰어 트레이싱에 더 빠를 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, 이는 디버깅(debugging)의 가능성을 열어줍니다. 프레임 평가 함수는 특정 코드 객체를 실행하려고 할 때만 특별한 디버깅 작업을 수행할 수 있습니다. 이 경우, 바이트코드는 이론적으로 인플레이스(in-place)로 재작성되어 적절한 지점에 브레이크포인트(breakpoint) 함수 호출을 삽입하여 디버깅을 돕고, \u003ccode\u003esys.settrace()\u003c/code\u003e에서 요구하는 강력한 접근 방식을 사용하지 않을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 사용 사례를 용이하게 하기 위해, 새로운 필드를 통해 코드 객체에 \"스크래치 공간(scratch space)\"을 추가하는 것도 제안됩니다. 이를 통해 코드 객체별 데이터를 코드 객체 자체에 저장하여, 필요에 따라 프레임 평가 함수가 쉽게 검색할 수 있도록 합니다. 필드 자체는 단순히 \u003ccode\u003ePyObject *\u003c/code\u003e 타입이므로, 필드에 저장된 모든 데이터는 일반 객체 메모리 관리(object memory management)에 참여하게 됩니다.\u003c/p\u003e\n\u003ch2\u003e제안 (Proposal)\u003c/h2\u003e\n\u003cp\u003e아래 제안된 모든 C API 변경 사항은 안정적인 ABI (Application Binary Interface)의 일부가 되지 않습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ePyCodeObject\u003c/code\u003e 확장\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ePyCodeObject\u003c/code\u003e 구조체에 하나의 필드가 추가됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003etypedef struct {\n    /* ... */\n    void *co_extra; /* \"Scratch space\" for the code object. */\n} PyCodeObject;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eco_extra\u003c/code\u003e는 기본적으로 \u003ccode\u003eNULL\u003c/code\u003e이며 필요에 따라 채워집니다. 필드에 저장된 값은 코드 객체가 작동하는 데 필수는 아니므로, 데이터 손실이 허용됩니다.\u003c/p\u003e\n\u003cp\u003e이 필드와 함께 작동하기 위해 비공개(private) API가 도입되었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003ePyAPI_FUNC(Py_ssize_t) _PyEval_RequestCodeExtraIndex(freefunc);\nPyAPI_FUNC(int) _PyCode_GetExtra(PyObject *code, Py_ssize_t index, void **extra);\nPyAPI_FUNC(int) _PyCode_SetExtra(PyObject *code, Py_ssize_t index, void *extra);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e필드 사용자는 \u003ccode\u003e_PyEval_RequestCodeExtraIndex()\u003c/code\u003e를 호출하여 \u003ccode\u003eco_extra\u003c/code\u003e에 데이터를 추가할 불투명한 인덱스(opaque index) 값을 받아야 합니다. 이 인덱스를 사용하여 사용자는 \u003ccode\u003e_PyCode_SetExtra()\u003c/code\u003e로 데이터를 설정하고 나중에 \u003ccode\u003e_PyCode_GetExtra()\u003c/code\u003e로 데이터를 검색할 수 있습니다. 이 API는 Python 릴리스 간에 API의 의미론적 보장(semantic guarantees)이 없음을 알리기 위해 의도적으로 비공개로 나열되었습니다.\u003c/p\u003e\n\u003cp\u003e리스트(list)와 튜플(tuple) 사용이 고려되었지만 성능이 떨어지는 것으로 나타났으며, 주요 사용 사례가 JIT인 점을 고려할 때 Python 객체 대신 사용자 정의 구조체를 사용하는 것이 성능 면에서 우세했습니다. 딕셔너리(dict)도 고려되었지만, 다시 한번 성능이 더 중요했습니다. 딕셔너리는 데이터 조회에 상수 오버헤드(constant overhead)가 있지만, 데이터 구조에 단일 객체가 저장되는 일반적인 경우에 튜플이 더 나은 성능 특성을 가집니다 (예: 길이가 1인 튜플을 반복하는 것이 딕셔너리에서 객체를 해싱하고 조회하는 오버헤드보다 빠릅니다).\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ePyInterpreterState\u003c/code\u003e 확장\u003c/h3\u003e\n\u003cp\u003e프레임 평가 함수의 진입점은 인터프리터별(per-interpreter)입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003e// PyEval_EvalFrameEx()와 동일한 타입 시그니처(type signature)입니다.\ntypedef PyObject* (*_PyFrameEvalFunction)(PyFrameObject*, int);\n\ntypedef struct {\n    /* ... */\n    _PyFrameEvalFunction eval_frame;\n} PyInterpreterState;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기본적으로 \u003ccode\u003eeval_frame\u003c/code\u003e 필드는 현재 \u003ccode\u003ePyEval_EvalFrameEx()\u003c/code\u003e가 나타내는 함수 포인터(이 PEP에서 나중에 논의되는 \u003ccode\u003e_PyEval_EvalFrameDefault()\u003c/code\u003e라고 불림)로 초기화됩니다. 타사 코드(third-party code)는 Python 코드의 실행을 제어하기 위해 자체 프레임 평가 함수를 설정할 수 있습니다. 포인터 비교를 사용하여 필드가 \u003ccode\u003e_PyEval_EvalFrameDefault()\u003c/code\u003e로 설정되었는지, 따라서 아직 변경되지 않았는지 감지할 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ePython/ceval.c\u003c/code\u003e 변경 사항\u003c/h3\u003e\n\u003cp\u003e현재 \u003ccode\u003ePyEval_EvalFrameEx()\u003c/code\u003e는 \u003ccode\u003e_PyEval_EvalFrameDefault()\u003c/code\u003e로 이름이 변경됩니다. 새로운 \u003ccode\u003ePyEval_EvalFrameEx()\u003c/code\u003e는 다음과 같아집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-c\"\u003ePyObject *\nPyEval_EvalFrameEx(PyFrameObject *frame, int throwflag)\n{\n    PyThreadState *tstate = PyThreadState_GET();\n    return tstate-\u003einterp-\u003eeval_frame(frame, throwflag);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 타사 코드가 기존 C API를 이미 사용하는 코드와의 하위 호환성(backwards-compatible)을 유지하면서 Python 코드 실행 경로에 직접 자신을 배치할 수 있도록 합니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003epython-gdb.py\u003c/code\u003e 업데이트\u003c/h3\u003e\n\u003cp\u003eGDB에서 Python 지원을 위해 사용되는 생성된 \u003ccode\u003epython-gdb.py\u003c/code\u003e 파일은 \u003ccode\u003ePyEval_EvalFrameEx()\u003c/code\u003e에 대해 일부 하드코딩된 가정(예: 지역 변수 이름)을 합니다. 제안된 변경 사항과 함께 작동하도록 업데이트해야 합니다.\u003c/p\u003e\n\u003ch2\u003e성능 영향 (Performance impact)\u003c/h2\u003e\n\u003cp\u003e이 PEP는 플러그인 기능(pluggability)을 추가하기 위한 API를 제안하므로, 성능 영향은 타사 코드가 아무런 변경을 하지 않은 경우에만 고려됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epybench\u003c/code\u003e의 여러 실행에서 API 변경만으로는 일관되게 성능 저하가 없음을 보여주었습니다.\u003c/p\u003e\n\u003cp\u003ePython 벤치마크 스위트의 실행에서는 측정 가능한 성능 비용이 없었습니다.\u003c/p\u003e\n\u003cp\u003e메모리 영향 측면에서, 단일 프로세스에서 실행되는 CPython 인터프리터가 일반적으로 많지 않으므로 \u003ccode\u003ePyCodeObject\u003c/code\u003e에 \u003ccode\u003eco_extra\u003c/code\u003e가 추가되는 영향만 우려됩니다.에 따르면, Python 테스트 스위트의 실행 결과 약 72,395개의 코드 객체가 생성됩니다. 64비트 CPU에서 모든 코드 객체가 동시에 활성 상태이고 \u003ccode\u003eco_extra\u003c/code\u003e 필드에 아무것도 설정되지 않은 경우, 579,160바이트의 추가 메모리가 사용될 것입니다.\u003c/p\u003e\n\u003ch2\u003e예시 사용 (Example Usage)\u003c/h2\u003e\n\u003ch3\u003eCPython용 JIT (A JIT for CPython)\u003c/h3\u003e\n\u003ch4\u003ePyjion\u003c/h4\u003e\n\u003cp\u003ePyjion 프로젝트는 이 제안된 API를 사용하여 CoreCLR의 JIT를 활용하여 CPython용 JIT를 구현했습니다. 각 코드 객체는 \u003ccode\u003eco_extra\u003c/code\u003e 필드가 \u003ccode\u003ePyjionJittedCode\u003c/code\u003e 객체로 설정되며, 이 객체는 네 가지 정보를 저장합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e실행 횟수 (Execution count)\u003c/li\u003e\n\u003cli\u003e이전 JIT 시도가 실패했는지 여부를 나타내는 부울(boolean) 값\u003c/li\u003e\n\u003cli\u003e트램폴린(trampoline)에 대한 함수 포인터 (타입 트레이싱 여부와 관계없이)\u003c/li\u003e\n\u003cli\u003eJIT 컴파일된 머신 코드에 대한 \u003ccode\u003evoid\u003c/code\u003e 포인터\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e프레임 평가 함수는 (대략적으로) 다음과 같은 알고리즘을 가집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef eval_frame(frame, throw_flag):\n    pyjion_code = frame.code.co_extra\n    if not pyjion_code:\n        frame.code.co_extra = PyjionJittedCode()\n    elif not pyjion_code.jit_failed:\n        if not pyjion_code.jit_code:\n            return pyjion_code.eval(pyjion_code.jit_code, frame)\n        elif pyjion_code.exec_count \u003e 20_000:\n            if jit_compile(frame):\n                return pyjion_code.eval(pyjion_code.jit_code, frame)\n            else:\n                pyjion_code.jit_failed = True\n    pyjion_code.exec_count += 1\n    return _PyEval_EvalFrameDefault(frame, throw_flag)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e핵심은 이 모든 작업과 로직이 CPython과 분리되어 있지만, 제안된 API 변경 사항 덕분에 Python 시맨틱(semantics)을 준수하는 JIT를 제공할 수 있다는 것입니다 (이 글을 쓰는 시점에는 새로운 API가 없는 CPython과 성능이 거의 동일합니다). 이는 제안된 API를 활용하여 다른 사람들이 CPython용 자체 JIT를 구현하는 것을 기술적으로 막는 것이 없음을 의미합니다.\u003c/p\u003e\n\u003ch4\u003e다른 JIT (Other JITs)\u003c/h4\u003e\n\u003cp\u003ePyston 팀은 이 PEP의 초기 버전에 대해 자문을 받았는데, 그 버전은 JIT에 더 특화되어 있었고, 그들은 메모리 레이아웃에 대한 제어를 원했기 때문에 제안된 변경 사항을 활용하는 데 관심이 없었습니다. PyPy 팀의 개발자와의 비공식적인 논의에서도 비슷한 의견이 나왔습니다.\u003c/p\u003e\n\u003cp\u003e반면 Numba는 1.0 이후의 미래에 제안된 변경 사항에 관심이 있을 것이라고 제안했습니다.\u003c/p\u003e\n\u003cp\u003e실험적인 Coconut JIT는 이 PEP의 혜택을 받을 수 있었습니다. Coconut의 개발자와의 비공개 대화에서, 우리의 API가 CPython에 JIT 지원을 추가하기 위해 그들이 개발한 API보다 아마도 우수할 것이라는 말을 들었습니다.\u003c/p\u003e\n\u003ch3\u003e디버깅 (Debugging)\u003c/h3\u003e\n\u003cp\u003ePython Tools for Visual Studio (PTVS) 팀과의 대화에서, 그들은 이 API 변경 사항이 더 나은 성능의 디버깅을 구현하는 데 유용할 것이라고 생각했습니다. 배경 섹션에서 언급했듯이, 이 API는 디버깅 기능이 필요한 프레임에서만 전환될 수 있도록 합니다. 이는 \u003ccode\u003esys.settrace()\u003c/code\u003e가 일반적으로 제공하는 정보를 건너뛰는 것을 허용하고, 심지어 실행 전에 바이트코드를 동적으로 재작성하여 바이트코드에 브레이크포인트를 주입하는 것까지 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003eGoogle도 내부적으로 매우 유사한 API를 제공하며, 이는 성능이 뛰어난 디버깅 목적으로 사용되었습니다.\u003c/p\u003e\n\u003ch2\u003e구현 (Implementation)\u003c/h2\u003e\n\u003cp\u003e제안된 API를 구현하는 일련의 패치는 Pyjion 프로젝트를 통해 제공됩니다. 현재 형태로 이 제안된 API보다 CPython에 더 많은 변경 사항이 있지만, 이는 엄격한 목표 달성 요구 사항 대신 개발의 용이성을 위한 것입니다.\u003c/p\u003e\n\u003ch2\u003e미해결 문제 (Open Issues)\u003c/h2\u003e\n\u003ch3\u003e\u003ccode\u003eeval_frame\u003c/code\u003e을 \u003ccode\u003eNULL\u003c/code\u003e로 허용할 것인가? (Allow eval_frame to be NULL)\u003c/h3\u003e\n\u003cp\u003e현재 프레임 평가 함수는 항상 설정되어 있어야 합니다. 단순히 기본적으로 \u003ccode\u003eNULL\u003c/code\u003e로 설정하여 \u003ccode\u003e_PyEval_EvalFrameDefault()\u003c/code\u003e를 사용하도록 신호를 보낼 수도 있습니다. 필드를 특별히 처리하지 않는 현재 제안이 가장 간단해 보였지만, 필드가 실수로 지워지지 않도록 해야 하며, 그렇지 않으면 충돌(crash)이 발생할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e기각된 아이디어 (Rejected Ideas)\u003c/h2\u003e\n\u003ch3\u003eJIT-특정 C API (A JIT-specific C API)\u003c/h3\u003e\n\u003cp\u003e원래 이 PEP는 JIT에 더 특화된 훨씬 더 큰 API 변경을 제안하려고 했습니다. 그러나 Numba 팀으로부터 피드백을 받은 후, API가 불필요하게 크다는 것이 분명해졌습니다. 진정으로 필요한 것은 JIT 컴파일된 Python 코드의 실행을 처리할 트램폴린 함수를 제공할 기회와, 컴파일된 머신 코드를 다른 중요한 데이터와 함께 해당 Python 코드 객체에 연결하는 방법이라는 것을 깨달았습니다. 필요한 API 변경을 최소화하면서 기능이나 성능 손실이 없다는 것이 입증된 후, 제안은 현재 형태로 변경되었습니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eco_extra\u003c/code\u003e가 필요한가? (Is co_extra needed?)\u003c/h3\u003e\n\u003cp\u003ePyCon US 2016에서 이 PEP를 논의하는 동안, 일부 핵심 개발자들은 \u003ccode\u003eco_extra\u003c/code\u003e 필드가 코드 객체를 변경 가능하게 만들 수 있다는 우려를 표했습니다. 코드 객체가 생성된 후 변경되는 필드를 갖는 것이 객체를 변경 가능하게 보이게 한다는 생각이었지만, 코드 객체의 다른 측면은 변경되지 않았습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP의 관점은 \u003ccode\u003eco_extra\u003c/code\u003e 필드가 코드 객체가 불변(immutable)이라는 사실을 바꾸지 않는다는 것입니다. 이 필드는 코드 객체를 사용할 수 있게 만드는 데 필요한 정보를 포함하지 않도록 이 PEP에서 지정되었으므로, 캐싱 필드에 가깝습니다. 이는 문자열 객체가 내부적으로 가지는 UTF-8 캐시와 유사하게 볼 수 있습니다. 문자열은 조건부로 설정되는 필드를 가지고 있음에도 불구하고 여전히 불변으로 간주됩니다.\u003c/p\u003e\n\u003cp\u003eJIT 워크로드에서 필드를 사용할 수 없을 때도 성능 측정이 이루어졌습니다. C++의 정렬되지 않은 맵(unordered map) 또는 Python의 딕셔너리를 사용하여 코드 객체를 JIT-특정 데이터 객체와 연결할 때 필드의 손실은 성능에 너무 큰 비용을 초래하는 것으로 간주되었습니다.\u003c/p\u003e\n\u003ch2\u003e참고 자료 (References)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ePyjion 프로젝트 (https://github.com/microsoft/pyjion)\u003c/li\u003e\n\u003cli\u003eCPython의 C API (https://docs.python.org/3/c-api/index.html)\u003c/li\u003e\n\u003cli\u003ePyCodeObject (https://docs.python.org/3/c-api/code.html#c.PyCodeObject)\u003c/li\u003e\n\u003cli\u003e.NET Core Runtime (CoreCLR) (https://github.com/dotnet/coreclr)\u003c/li\u003e\n\u003cli\u003ePyEval_EvalFrameEx() (https://docs.python.org/3/c-api/veryhigh.html?highlight=pyframeobject#c.PyEval_EvalFrameEx)\u003c/li\u003e\n\u003cli\u003eNumba (http://numba.pydata.org/)\u003c/li\u003e\n\u003cli\u003enumba-users 메일링 리스트: \"Would the C API for a JIT entrypoint being proposed by Pyjion help out Numba?\" (https://groups.google.com/a/continuum.io/forum/#!topic/numba-users/yRl_0t8-m1g)\u003c/li\u003e\n\u003cli\u003e[Python-Dev] Opcode cache in ceval loop (https://mail.python.org/pipermail/python-dev/2016-February/143025.html)\u003c/li\u003e\n\u003cli\u003ePython 벤치마크 스위트 (https://hg.python.org/benchmarks)\u003c/li\u003e\n\u003cli\u003ePyston (http://pyston.org)\u003c/li\u003e\n\u003cli\u003ePyPy (http://pypy.org/)\u003c/li\u003e\n\u003cli\u003ePython Tools for Visual Studio (http://microsoft.github.io/PTVS/)\u003c/li\u003e\n\u003cli\u003eCoconut (https://github.com/davidmalcolm/coconut)\u003c/li\u003e\n\u003cli\u003epybench (https://hg.python.org/cpython/file/default/Tools/pybench)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\nSource: \u003ccode\u003ehttps://github.com/python/peps/blob/main/peps/pep-0523.rst\u003c/code\u003e\n최종 수정: 2025-02-01 08:55:40 GMTPEP 523은 CPython의 C API를 확장하여 프레임 평가 함수를 지정할 수 있도록 하는 제안입니다. 이 문서는 Python 개발자들이 JIT 컴파일러, 고급 디버깅 도구, 그리고 프로파일링 도구와 같은 외부 도구들이 CPython의 실행 흐름에 더 깊이 개입할 수 있도록 하는 것을 목표로 합니다.\u003c/p\u003e\n\u003ch2\u003ePEP 523 – CPython에 프레임 평가 API 추가\u003c/h2\u003e\n\u003ch3\u003e개요 (Abstract)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 CPython의 C API를 확장하여 인터프리터별 프레임 평가 함수를 지정할 수 있도록 제안합니다. 또한, 이 제안은 프레임 평가 함수에서 사용할 임의의 데이터를 저장하기 위해 코드 객체 (code object)에 새로운 필드를 추가하는 것을 포함합니다.\u003c/p\u003e\n\u003ch3\u003e배경 (Rationale)\u003c/h3\u003e\n\u003cp\u003e기존 CPython은 \u003ccode\u003ePyEval_EvalFrameEx()\u003c/code\u003e를 통해 프레임을 평가하는 기능을 제공했지만, Python 코드 실행에 대한 전체적인 제어보다는 개별 객체 수준에서의 제어에 머물러 있었습니다. 이러한 유연성 부족은 특히 JIT(Just-In-Time) 컴파일러와 같은 외부 도구가 CPython의 실행 흐름에 통합되는 것을 어렵게 했습니다.\u003c/p\u003e\n\u003cp\u003e이 PEP는 프레임 수준에서 실행 제어를 제공함으로써 다음과 같은 가능성을 열어줍니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eJIT 컴파일러 도입\u003c/strong\u003e : CPython 자체에 JIT를 내장하지 않고도, 외부 C 코드가 프레임 평가를 제어하여 Python 바이트코드를 머신 코드로 조건부 재컴파일할 수 있도록 합니다. 이는 JIT가 필요한 경우에만 활성화되고, 그렇지 않은 경우에는 표준 CPython 바이트코드를 실행할 수 있게 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e고급 트레이싱 및 프로파일링\u003c/strong\u003e : 호출 수준에서 트레이싱 또는 프로파일링 기능을 더 효율적으로 구현할 수 있게 됩니다. \u003ccode\u003esys.settrace()\u003c/code\u003e와 같은 기존 Python 수준의 기능보다 더 빠르고 상세한 데이터 수집이 가능하며, 라인별 트레이싱을 건너뛰는 등의 최적화도 가능합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e효율적인 디버깅\u003c/strong\u003e : 프레임 평가 함수가 특정 코드 객체를 실행하기 전에 디버깅 작업을 수행할 수 있도록 합니다. 이는 바이트코드를 동적으로 재작성하여 브레이크포인트(breakpoint)를 삽입하는 등의 고급 디버깅 기능을 \u003ccode\u003esys.settrace()\u003c/code\u003e보다 가벼운 방식으로 구현할 수 있게 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 사용 사례를 지원하기 위해, 코드 객체에 새로운 \"스크래치 공간(scratch space)\" 필드인 \u003ccode\u003eco_extra\u003c/code\u003e를 추가하는 것도 제안됩니다. 이 필드는 프레임 평가 함수가 필요에 따라 코드 객체별 데이터를 저장하고 검색하는 데 사용됩니다.\u003c/p\u003e\n\u003ch3\u003e제안 (Proposal)\u003c/h3\u003e\n\u003cp\u003e제안된 C API 변경 사항은 안정적인 ABI (Application Binary Interface)의 일부가 되지 않습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003ePyCodeObject\u003c/code\u003e 확장\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ePyCodeObject\u003c/code\u003e 구조체에 \u003ccode\u003evoid *co_extra;\u003c/code\u003e 필드가 추가됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eco_extra\u003c/code\u003e는 기본적으로 \u003ccode\u003eNULL\u003c/code\u003e이며, 필요에 따라 임의의 데이터를 저장하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e이 필드에 저장된 데이터는 코드 객체 기능에 필수는 아니므로, 데이터 손실이 허용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eco_extra\u003c/code\u003e와 상호작용하기 위한 비공개 API인 \u003ccode\u003e_PyEval_RequestCodeExtraIndex()\u003c/code\u003e, \u003ccode\u003e_PyCode_GetExtra()\u003c/code\u003e, \u003ccode\u003e_PyCode_SetExtra()\u003c/code\u003e가 제공됩니다. 이 API는 Python 릴리스 간에 의미론적 보장이 없으므로 주의해야 합니다. 성능상의 이유로 리스트, 튜플, 딕셔너리 대신 사용자 정의 구조체와 유사한 방식으로 관리됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003ccode\u003ePyInterpreterState\u003c/code\u003e 확장\u003c/h4\u003e\n\u003cp\u003e인터프리터별(per-interpreter) 프레임 평가 함수를 위한 진입점이 추가됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePyInterpreterState\u003c/code\u003e 구조체에 \u003ccode\u003e_PyFrameEvalFunction eval_frame;\u003c/code\u003e 필드가 추가됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eeval_frame\u003c/code\u003e은 기본적으로 기존 \u003ccode\u003ePyEval_EvalFrameEx()\u003c/code\u003e의 동작을 나타내는 \u003ccode\u003e_PyEval_EvalFrameDefault()\u003c/code\u003e 함수 포인터로 초기화됩니다.\u003c/li\u003e\n\u003cli\u003e타사 코드는 이 \u003ccode\u003eeval_frame\u003c/code\u003e 필드를 자신의 커스텀 함수로 설정하여 Python 코드 실행을 제어할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003ccode\u003ePython/ceval.c\u003c/code\u003e 변경 사항\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e기존 \u003ccode\u003ePyEval_EvalFrameEx()\u003c/code\u003e는 \u003ccode\u003e_PyEval_EvalFrameDefault()\u003c/code\u003e로 이름이 변경됩니다.\u003c/li\u003e\n\u003cli\u003e새로운 \u003ccode\u003ePyEval_EvalFrameEx()\u003c/code\u003e는 \u003ccode\u003ePyThreadState *tstate = PyThreadState_GET(); return tstate-\u003einterp-\u003eeval_frame(frame, throwflag);\u003c/code\u003e와 같이 현재 스레드의 인터프리터에 설정된 \u003ccode\u003eeval_frame\u003c/code\u003e 함수를 호출하도록 변경됩니다.\u003c/li\u003e\n\u003cli\u003e이 변경은 타사 코드가 Python 코드 실행 경로에 직접 개입하면서도 기존 C API를 사용하는 코드와의 하위 호환성(backwards-compatible)을 유지하도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003ccode\u003epython-gdb.py\u003c/code\u003e 업데이트\u003c/h4\u003e\n\u003cp\u003eGDB의 Python 지원을 위한 \u003ccode\u003epython-gdb.py\u003c/code\u003e 파일은 \u003ccode\u003ePyEval_EvalFrameEx()\u003c/code\u003e에 대한 가정을 포함하므로, 제안된 변경 사항과 호환되도록 업데이트되어야 합니다.\u003c/p\u003e\n\u003ch3\u003e성능 영향 (Performance impact)\u003c/h3\u003e\n\u003cp\u003e이 PEP는 플러그인 기능(pluggability)을 위한 API를 제안하므로, 타사 코드가 변경을 가하지 않은 경우의 성능 영향만 고려됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epybench\u003c/code\u003e 및 Python 벤치마크 스위트 실행 결과, API 변경만으로는 측정 가능한 성능 저하가 없었습니다.\u003c/li\u003e\n\u003cli\u003e메모리 측면에서는 \u003ccode\u003eco_extra\u003c/code\u003e 필드가 \u003ccode\u003ePyCodeObject\u003c/code\u003e에 추가됨으로써 발생할 수 있는 영향이 우려됩니다. 약 72,395개의 코드 객체가 생성되는 Python 테스트 스위트 실행 기준으로, 64비트 CPU에서 최대 579,160바이트의 추가 메모리 사용이 발생할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e예시 사용 (Example Usage)\u003c/h3\u003e\n\u003ch4\u003eCPython용 JIT (A JIT for CPython)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePyjion\u003c/strong\u003e : 이 제안된 API를 사용하여 CoreCLR의 JIT를 활용한 CPython용 JIT를 구현했습니다. \u003ccode\u003eco_extra\u003c/code\u003e 필드에 JIT 컴파일된 코드와 관련 메타데이터를 저장하고, \u003ccode\u003eeval_frame\u003c/code\u003e 함수를 오버라이드하여 JIT 컴파일된 코드를 실행합니다. 이는 CPython과 분리된 상태로 Python 시맨틱을 준수하는 JIT를 제공하는 것이 가능함을 보여줍니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e다른 JITs\u003c/strong\u003e : Pyston 및 PyPy 팀은 초기 버전의 PEP에 큰 관심을 보이지 않았으나, Numba는 향후 버전에 관심을 표명했습니다. Coconut JIT 또한 이 PEP의 혜택을 받을 수 있었을 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e디버깅 (Debugging)\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePython Tools for Visual Studio (PTVS)\u003c/strong\u003e 팀은 이 API가 더 높은 성능의 디버깅 기능을 구현하는 데 유용할 것이라고 언급했습니다. 필요한 프레임에서만 디버깅 기능을 활성화하고, 바이트코드를 동적으로 재작성하여 브레이크포인트를 주입하는 등의 고급 기능을 구현할 수 있습니다. Google도 내부적으로 유사한 API를 사용하여 성능 좋은 디버깅에 활용하고 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e구현 (Implementation)\u003c/h3\u003e\n\u003cp\u003e제안된 API를 구현하는 패치 세트는 Pyjion 프로젝트를 통해 제공됩니다.\u003c/p\u003e\n\u003ch3\u003e미해결 문제 (Open Issues)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eeval_frame\u003c/code\u003e을 \u003ccode\u003eNULL\u003c/code\u003e로 허용할 것인가?\u003c/strong\u003e : 현재는 \u003ccode\u003eeval_frame\u003c/code\u003e이 항상 설정되어 있어야 하지만, \u003ccode\u003eNULL\u003c/code\u003e을 기본값으로 하여 \u003ccode\u003e_PyEval_EvalFrameDefault()\u003c/code\u003e를 사용하도록 신호를 보낼 수도 있습니다. 필드가 우발적으로 지워져 충돌이 발생하는 것을 방지해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e기각된 아이디어 (Rejected Ideas)\u003c/h3\u003e\n\u003ch4\u003eJIT-특정 C API (A JIT-specific C API)\u003c/h4\u003e\n\u003cp\u003e초기에는 더 크고 JIT에 특화된 API가 제안되었으나, Numba 팀의 피드백을 통해 불필요하게 크다는 것이 밝혀졌습니다. 결국, JIT 컴파일된 Python 코드 실행을 처리할 트램폴린 함수와 컴파일된 코드를 Python 코드 객체에 연결하는 방법만 있으면 된다는 결론에 도달하여 현재의 간소화된 형태로 변경되었습니다.\u003c/p\u003e\n\u003ch4\u003e\u003ccode\u003eco_extra\u003c/code\u003e가 필요한가? (Is co_extra needed?)\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eco_extra\u003c/code\u003e 필드가 코드 객체를 변경 가능하게 만들 수 있다는 우려가 제기되었습니다. 그러나 이 PEP는 \u003ccode\u003eco_extra\u003c/code\u003e 필드가 코드 객체 자체의 불변성(immutability)을 변경하지 않으며, 코드 객체가 작동하는 데 필요한 정보를 포함하지 않고 주로 캐싱(caching) 목적으로 사용된다고 주장합니다. 이는 문자열 객체의 내부 UTF-8 캐시와 유사하게 볼 수 있습니다. 성능 측정 결과, JIT 워크로드에서 이 필드가 없을 경우 성능 저하가 너무 커서 필드를 유지하는 것이 합당하다고 판단되었습니다.\u003c/p\u003e\n\u003ch3\u003e참고 자료 (References)\u003c/h3\u003e\n\u003cp\u003e문서 말미에 언급된 다양한 프로젝트, API 문서, 메일링 리스트 및 벤치마크 도구에 대한 참고 자료가 포함되어 있습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1885,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 523 - Adding a frame evaluation API to CPython\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 23:16:26+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}],[\"$\",\"section\",null,{\"className\":\"mt-12 border-t border-gray-200 pt-8\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-base font-semibold text-gray-900 mb-4\",\"children\":[\"Python\",\" 의 다른글\"]}],[\"$\",\"ul\",null,{\"className\":\"space-y-2 text-sm\",\"children\":[[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"이전글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/522/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Rejected] PEP 522 - Allow BlockingIOError in security sensitive APIs\"}]]}],[\"$\",\"li\",null,{\"className\":\"text-gray-900 font-semibold\",\"children\":[\"현재글 : \",\"[Final] PEP 523 - Adding a frame evaluation API to CPython\"]}],[\"$\",\"li\",null,{\"className\":\"text-gray-500\",\"children\":[\"다음글\",\" \",[\"$\",\"$La\",null,{\"href\":\"/python/pep/524/\",\"className\":\"text-gray-500 hover:text-gray-700 underline decoration-dotted underline-offset-4\",\"children\":\"[Final] PEP 524 - Make os.urandom() blocking on Linux\"}]]}]]}]]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://blog.secrett2633.site/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"22\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>