<!DOCTYPE html><html lang="ko" class="no-js"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/da5e1dc2b9a7c5bb.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js"/><script src="/_next/static/chunks/fd9d1056-4e1a26e2d413ba3c.js" async=""></script><script src="/_next/static/chunks/23-e8ded9e1e67d56dc.js" async=""></script><script src="/_next/static/chunks/main-app-6d0231ce06c8f62f.js" async=""></script><script src="/_next/static/chunks/231-c27e618569e042bc.js" async=""></script><script src="/_next/static/chunks/157-aecaf5ac7a84facf.js" async=""></script><script src="/_next/static/chunks/app/layout-c3e2e457f12fb6f6.js" async=""></script><script src="/_next/static/chunks/app/page-e3ea38185bb36cd2.js" async=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY"></script><title>secrett2633&#x27;s blog</title><meta name="description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta name="author" content="secrett2633"/><meta name="keywords" content="Django, Python, DevOps, AI, ML, 블로그, 기술"/><meta name="creator" content="secrett2633"/><meta name="publisher" content="secrett2633"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><link rel="canonical" href="https://secrett2633.github.io/"/><meta name="format-detection" content="telephone=no, address=no, email=no"/><meta property="og:title" content="secrett2633&#x27;s blog"/><meta property="og:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><meta property="og:url" content="https://secrett2633.github.io/"/><meta property="og:site_name" content="secrett2633&#x27;s blog"/><meta property="og:locale" content="ko_KR"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="secrett2633&#x27;s blog"/><meta name="twitter:description" content="기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트"/><link rel="icon" href="/icon.ico?6d9f34d4948640b8" type="image/x-icon" sizes="16x16"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="theme-color" content="#ffffff"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-NE2W3CFPNY');
            </script><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_f367f3 layout--default"><div class="min-h-screen bg-gray-50"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"><a class="site-title" href="/">secrett2633&#x27;s blog</a><div class="flex items-center space-x-4"><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer">GitHub</a></li></ul><button class="search__toggle" type="button"><svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path></svg></button><button class="greedy-nav__toggle" type="button"><div class="navicon"></div></button></div><ul class="hidden-links hidden md:hidden"><li><a href="https://github.com/secrett2633" target="_blank" rel="noopener noreferrer" class="block py-2">GitHub</a></li></ul></nav></div></div></div><main class="initial-content"><!--$--><div class="flex flex-col lg:flex-row gap-8"><aside class="lg:w-64 xl:w-72 order-1 lg:order-none"><div class="sidebar sticky"><nav class="space-y-4"><div><h4 class="font-medium text-gray-900 mb-2">Backend</h4><ul class="space-y-1 ml-4"><li><a href="/backend/django/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Django<!-- --> (<!-- -->6<!-- -->)</a></li><li><a href="/backend/logging/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Logging<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">Python</h4><ul class="space-y-1 ml-4"><li><a href="/python/pep/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">PEP<!-- --> (<!-- -->650<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">AI/ML</h4><ul class="space-y-1 ml-4"><li><a href="/ai/llm/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">LLM<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/ai/review/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Review<!-- --> (<!-- -->1025<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">DevOps</h4><ul class="space-y-1 ml-4"><li><a href="/devops/nginx/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Nginx<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/docker/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Docker<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/safeline/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">SafeLine<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/jenkins/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Jenkins<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/devops/github-actions/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">GitHub Actions<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/devops/aws/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">AWS<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div><div><h4 class="font-medium text-gray-900 mb-2">etc</h4><ul class="space-y-1 ml-4"><li><a href="/etc/me/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Me<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/etc/chrome-extension/" class="text-sm text-gray-600 hover:text-primary-600 block py-1">Chrome Extension<!-- --> (<!-- -->1<!-- -->)</a></li></ul></div></nav></div></aside><main class="flex-1"><article class="page"><header class="mb-8"><h1 class="page__title">[Final] PEP 318 - Decorators for Functions and Methods</h1><div class="page__meta"><time dateTime="2025-09-26 18:28:53+0900">2025년 9월 26일</time><span class="ml-4">수정: <!-- -->2025년 9월 26일</span></div></header><div class="page__content"><div><blockquote>
<p><strong>원문 링크:</strong> <a href="https://peps.python.org/pep-0318/">PEP 318 - Decorators for Functions and Methods</a></p>
<p><strong>상태:</strong> Final | <strong>유형:</strong> Standards Track | <strong>작성일:</strong> 05-Jun-2003</p>
</blockquote>
<h1>PEP 318 – 함수 및 메서드를 위한 데코레이터 (Decorators for Functions and Methods)</h1>
<h2>개요 (Abstract)</h2>
<p>기존에는 함수나 메서드를 변형(예: <code>classmethod</code> 또는 <code>staticmethod</code>로 선언)하는 방식이 복잡하여 코드 이해를 어렵게 만들었습니다. 이상적으로는 이러한 변형이 선언 지점에서 함께 이루어져야 합니다. 이 PEP는 함수 또는 메서드 선언의 변형을 위한 새로운 문법을 제안합니다.</p>
<h2>동기 (Motivation)</h2>
<p>기존에는 함수나 메서드에 변형을 적용할 때 실제 변형 코드가 함수 본문 뒤에 위치했습니다. 예를 들어:</p>
<pre><code class="language-python">def foo(self):
    # 메서드 작업 수행
    pass
foo = classmethod(foo)
</code></pre>
<p>메서드의 길이가 길어질수록 이러한 방식은 가독성을 떨어뜨리며, 개념적으로 하나의 선언임에도 함수 이름을 세 번이나 반복하는 것은 Pythonic하지 않습니다.</p>
<p>이 문제에 대한 해결책은 메서드 변형을 메서드 선언에 더 가깝게 옮기는 것입니다. 새로운 문법은 다음과 같은 형태를 대체하는 것을 목표로 합니다:</p>
<pre><code class="language-python">def foo(cls):
    pass
foo = synchronized(lock)(foo)
foo = classmethod(foo)
</code></pre>
<p>아래와 같이 데코레이션을 함수의 선언부에 직접 배치하여 코드를 개선합니다:</p>
<pre><code class="language-python">@classmethod
@synchronized(lock)
def foo(cls):
    pass
</code></pre>
<p>클래스에 대한 데코레이터(Class Decorators)도 가능하지만, 그 이점은 함수/메서드 데코레이터만큼 명확하지 않습니다. 클래스 데코레이터로 할 수 있는 대부분의 작업은 메타클래스(Metaclasses)를 통해 가능하지만, 메타클래스는 다소 난해하므로 클래스에 간단한 수정을 가하는 더 쉬운 방법의 매력이 있습니다. Python 2.4에서는 함수/메서드 데코레이터만 추가되었습니다. PEP 3129는 Python 2.6부터 클래스 데코레이터를 추가할 것을 제안합니다.</p>
<h3>왜 이렇게 어려웠을까? (Why Is This So Hard?)</h3>
<p><code>classmethod()</code>와 <code>staticmethod()</code> 두 데코레이터는 Python 2.2부터 사용할 수 있었고, 언어에 문법적 지원이 추가될 것이라는 가정이 있었습니다. 하지만 합의에 도달하기 어려웠던 몇 가지 이유가 있습니다:</p>
<ul>
<li><strong>'의도 선언' 위치에 대한 불일치:</strong> 함수 정의 끝에 데코레이터를 적용하는 것이 최적은 아니라는 데는 모두 동의하지만, 어디에 정보를 배치할지에 대한 명확한 합의가 없었습니다.</li>
<li><strong>문법적 제약:</strong> Python은 시각적으로나 파서(parser) 측면에서 '일을 망치지 않고' 할 수 있는 일에 강한 제약을 가진 문법적으로 간단한 언어입니다.</li>
<li><strong>개념에 대한 전반적인 생소함:</strong> 데코레이터 개념은 Python에서 접하기 전에는 많은 프로그래머에게 생소한 개념이었습니다.</li>
</ul>
<h2>배경 (Background)</h2>
<p>현재의 상황에서 문법적 지원이 바람직하다는 것이 일반적인 합의였습니다. Guido van Rossum은 EuroPython 2004에서 여러 제안을 논의한 후, Java 스타일의 <code>@decorator</code> 문법을 선택했으며, 이는 Python 2.4a2에 처음으로 등장했습니다. Barry Warsaw는 이를 <code>@</code> 기호가 파이(pie)처럼 보여 '파이 데코레이터(pie-decorator)' 문법이라고 이름 붙였습니다.</p>
<h3>'Decorator'라는 이름에 대하여 (On the name 'Decorator')</h3>
<p>이 기능에 'decorator'라는 이름을 선택한 것에 대해 여러 불만이 제기되었습니다. 가장 큰 이유는 GoF(Gang of Four) 디자인 패턴 책에서의 사용과 일치하지 않는다는 것입니다. 'decorator'라는 이름은 컴파일러 분야에서 문법 트리를 탐색하고 주석을 다는 방식에서 영향을 받은 것으로 보이며, 더 좋은 이름이 나올 가능성도 있습니다.</p>
<h2>설계 목표 (Design Goals)</h2>
<p>새로운 문법은 다음을 목표로 해야 합니다:</p>
<ul>
<li>사용자 정의 호출 가능 객체(<code>callables</code>) 및 기존의 <code>classmethod()</code>, <code>staticmethod()</code>를 포함한 <strong>임의의 래퍼(wrappers)에 작동</strong>해야 합니다. 이는 데코레이터 문법이 래퍼 생성자(wrapper constructor)에 인자를 전달하는 것을 지원해야 함을 의미합니다.</li>
<li>하나의 정의에 <strong>여러 래퍼와 함께 작동</strong>해야 합니다.</li>
<li>무슨 일이 일어나는지 <strong>명확하게</strong> 보여야 합니다. 적어도 새로운 사용자가 자신의 코드를 작성할 때 안전하게 무시할 수 있어야 합니다.</li>
<li>한 번 설명되면 <strong>기억하기 쉬운 문법</strong>이어야 합니다.</li>
<li>향후 확장을 <strong>어렵게 만들지 않아야</strong> 합니다.</li>
<li><strong>입력하기 쉬워야</strong> 합니다. 이 기능을 사용하는 프로그램은 매우 자주 사용할 것으로 예상됩니다.</li>
<li>코드를 빠르게 스캔하는 것을 <strong>어렵게 만들지 않아야</strong> 합니다.</li>
<li>언어 인식 편집기(language-sensitive editors)와 같은 보조 지원 도구를 <strong>불필요하게 복잡하게 만들지 않아야</strong> 합니다.</li>
<li>미래 컴파일러가 데코레이터를 <strong>최적화할 수 있도록 허용</strong>해야 합니다.</li>
<li>함수 정의의 끝에 숨겨져 있던 것을 <strong>앞으로 옮겨서 더 눈에 띄게</strong> 해야 합니다.</li>
</ul>
<h2>현재 문법 (Current Syntax)</h2>
<p>Python 2.4a2에 구현된 함수 데코레이터의 현재 문법은 다음과 같습니다:</p>
<pre><code class="language-python">@dec2
@dec1
def func(arg1, arg2, ...):
    pass
</code></pre>
<p>이는 중간 변수 <code>func</code>에 대한 할당 없이 다음 코드와 동일합니다:</p>
<pre><code class="language-python">def func(arg1, arg2, ...):
    pass
func = dec2(dec1(func))
</code></pre>
<p>데코레이터는 함수 선언 근처에 있습니다. <code>@</code> 기호는 새로운 일이 진행되고 있음을 명확히 합니다.
적용 순서(아래에서 위로)는 함수 적용의 일반적인 순서와 일치하는 것을 근거로 합니다. 수학에서 함수 합성 <code>(g o f)(x)</code>는 <code>g(f(x))</code>로 번역됩니다. Python에서 <code>@g @f def foo()</code>는 <code>foo=g(f(foo))</code>로 번역됩니다.</p>
<p>현재 문법은 데코레이터 선언이 데코레이터를 반환하는 함수를 호출하는 것도 허용합니다:</p>
<pre><code class="language-python">@decomaker(argA, argB, ...)
def func(arg1, arg2, ...):
    pass
</code></pre>
<p>이는 다음 코드와 동일합니다:</p>
<pre><code class="language-python">func = decomaker(argA, argB, ...)(func)
</code></pre>
<p>데코레이터를 반환하는 함수를 허용하는 근거는 <code>@</code> 기호 뒤의 부분이 표현식으로 간주될 수 있으며(문법적으로는 함수로 제한되지만), 그 표현식이 반환하는 것이 호출되기 때문입니다.</p>
<h2>문법 대안 (Syntax Alternatives)</h2>
<p>많은 다른 문법이 제안되었으며, 이를 개별적으로 논의하기보다는 문법 논의를 여러 영역으로 나누는 것이 가치가 있습니다.</p>
<h3>데코레이터 위치 (Decorator Location)</h3>
<p>데코레이터의 첫 번째 문법적 쟁점은 위치입니다. Python 2.4a2에서 사용된 <code>@</code> 문법을 기준으로 합니다.</p>
<ol>
<li>
<p><strong><code>def</code> 문 앞:</strong> 2.4a2에서 사용된 문법입니다.</p>
<pre><code class="language-python">@classmethod
def foo(arg1,arg2): pass

@accepts(int,int)
@returns(float)
def bar(low,high): pass
</code></pre>
<p>이 위치에 대한 주요 반대는 Python에서 한 줄의 코드가 다음 줄에 영향을 미치는 첫 번째 실제 사례라는 점입니다. 최종적으로 Python 2.4에서는 한 줄에 하나의 데코레이터만 허용하도록 결정되었습니다. 장점으로는 데코레이터가 메서드 본문 밖에 존재하여 함수가 정의될 때 명확히 실행된다는 점과, 함수 정의 전에 코드의 의미론적 변화를 알 수 있다는 점이 있습니다.</p>
</li>
<li>
<p><strong><code>def</code>와 함수 이름 사이 또는 함수 이름과 인자 목록 사이:</strong></p>
<pre><code class="language-python">def @classmethod foo(arg1,arg2): pass
def foo @classmethod (arg1,arg2): pass
</code></pre>
<p>이 형식의 문제점은 소스 코드의 'greppability'를 깨뜨리고, 여러 데코레이터의 경우 문법이 매우 복잡해진다는 점입니다.</p>
</li>
<li>
<p><strong>인자 목록과 <code>:</code> 사이:</strong></p>
<pre><code class="language-python">def foo(arg1,arg2) @classmethod: pass
</code></pre>
<p>Guido는 이 형식이 중요한 정보(예: <code>staticmethod</code> 여부)를 시그니처 뒤에 숨겨 쉽게 놓칠 수 있고, 긴 인자 목록과 긴 데코레이터 목록 사이의 전환을 놓치기 쉬우며, 데코레이터 목록을 재사용하기 위해 잘라내기/붙여넣기(cut and paste)하기 번거롭다는 이유로 반대했습니다.</p>
</li>
<li>
<p><strong>메서드 본문 시작 부분:</strong> <code>docstrings</code>가 위치하는 곳과 동일합니다.</p>
<pre><code class="language-python">def foo(arg1,arg2):
    @classmethod
    pass
</code></pre>
<p>이 형식의 주요 반대는 데코레이터를 결정하기 위해 메서드 본문 "안을 들여다봐야" 한다는 점입니다.</p>
</li>
<li>
<p><strong>메서드 코드를 감싸는 새로운 블록:</strong> <code>decorate</code> 키워드를 사용합니다.</p>
<pre><code class="language-python">decorate: classmethod
def foo(arg1,arg2): pass
</code></pre>
<p>이 형식은 데코레이트된 메서드와 그렇지 않은 메서드에 대해 일관되지 않은 들여쓰기를 초래하며, 데코레이트된 메서드의 본문이 세 단계 들여쓰기로 시작하게 됩니다.</p>
</li>
</ol>
<h3>문법 형식 (Syntax forms)</h3>
<ul>
<li><strong><code>@decorator</code>:</strong> <code>@</code> 기호가 Python에서 이전에 사용되지 않았고, Java 1.5의 어노테이션(annotations)과 유사하다는 점이 장점입니다. 이는 이전 버전의 Python에 의해 파싱될 가능성이 없어 미묘한 의미론적 버그로 이어지지 않는다는 것을 의미합니다.</li>
<li><strong><code>|decorator</code>:</strong> <code>@</code> 데코레이터 문법의 변형으로, IPython 및 Leo와 충돌하지 않는다는 장점이 있지만, <code>|</code> 기호가 대문자 'I'와 소문자 'l'처럼 보인다는 단점이 있습니다.</li>
<li><strong><code>list syntax</code> (<code>[...]</code> 또는 <code>&#x3C;...></code>)</strong>: 대괄호는 현재 의미가 있으며, 데코레이터라는 표시가 부족하다는 반대가 있었습니다. 꺾쇠 괄호는 파싱 문제를 일으킵니다.</li>
<li><strong><code>decorate()</code> 함수:</strong> 새로운 문법을 구현하지 않고, 함수를 조작하는 <code>magic function</code>을 사용하는 제안입니다. Guido는 새로운 문법이 없다면 이러한 함수의 '마법성'이 매우 높기 때문에 단호히 반대했습니다.</li>
<li><strong>새로운 키워드 (및 블록):</strong> <code>using</code> 키워드를 사용하는 블록 형식이 <code>comp.lang.python</code>에서 합의된 대안이었습니다. Guido는 블록의 문법적 형태가 문장 시퀀스를 강하게 제안하지만 실제로는 그렇지 않다는 점과 <code>using</code> 키워드가 <code>if</code>, <code>while</code> 등과 같은 수준의 관심을 받을 자격이 없다는 이유로 이 제안을 거부했습니다.</li>
</ul>
<h3>왜 <code>@</code>인가? (Why @?)</h3>
<p>Java에서 <code>@</code>는 처음에는 Javadoc 주석의 마커로, 나중에는 Java 1.5에서 Python 데코레이터와 유사한 어노테이션에 사용되었습니다. <code>@</code>가 Python에서 이전에 토큰으로 사용되지 않았다는 사실은 이러한 코드가 이전 버전의 Python에 의해 파싱될 가능성이 없어 미묘한 의미론적 버그로 이어지지 않는다는 것을 의미합니다. 또한 무엇이 데코레이터이고 무엇이 아닌지에 대한 모호성을 제거합니다.</p>
<h2>현재 구현 및 역사 (Current Implementation, History)</h2>
<p>Guido는 자신이 선호하는 문법을 구현할 자원자를 요청했고, Mark Russell이 패치를 게시했습니다. 이 새로운 문법은 Python 2.4a2에서 사용할 수 있게 되었습니다.</p>
<pre><code class="language-python">@dec2
@dec1
def func(arg1, arg2, ...):
    pass
</code></pre>
<p>이것은 중간 변수 <code>func</code>의 생성 없이 다음 코드와 동일합니다:</p>
<pre><code class="language-python">def func(arg1, arg2, ...):
    pass
func = dec2(dec1(func))
</code></pre>
<p>2.4a2에 구현된 버전은 한 줄에 여러 <code>@decorator</code> 절을 허용했지만, 2.4a3에서는 한 줄에 하나의 데코레이터만 허용하도록 강화되었습니다. 결국 <code>@</code> 문자는 유지되었습니다.</p>
<h2>예시 (Examples)</h2>
<p>데코레이터는 <code>staticmethod()</code> 및 <code>classmethod()</code>와 같은 내장 함수를 더 깔끔하게 사용하는 것 이상의 강력한 기능을 제공합니다. 다음은 몇 가지 사용 예시입니다:</p>
<ul>
<li>
<p><strong>종료 시 실행될 함수 정의:</strong> <code>atexit</code> 모듈을 사용하여 함수를 등록합니다.</p>
<pre><code class="language-python">def onexit(f):
    import atexit
    atexit.register(f)
    return f

@onexit
def func():
    print("프로그램 종료 시 실행됩니다.")
</code></pre>
</li>
<li>
<p><strong>싱글턴(Singleton) 인스턴스를 가진 클래스 정의:</strong> 클래스의 유일한 인스턴스를 보장합니다.</p>
<pre><code class="language-python">def singleton(cls):
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls()
        return instances[cls]
    return getinstance

@singleton
class MyClass:
    def __init__(self):
        print("MyClass 인스턴스 생성")
</code></pre>
</li>
<li>
<p><strong>함수에 속성 추가:</strong> 함수에 메타데이터를 추가할 수 있습니다.</p>
<pre><code class="language-python">def attrs(**kwds):
    def decorate(f):
        for k in kwds:
            setattr(f, k, kwds[k])
        return f
    return decorate

@attrs(versionadded="2.2", author="Guido van Rossum")
def mymethod():
    pass
</code></pre>
</li>
<li>
<p><strong>함수 인자 및 반환 타입 강제:</strong> 함수의 인자 및 반환 타입을 검사합니다.</p>
<pre><code class="language-python">def accepts(*types):
    def check_accepts(f):
        assert len(types) == f.func_code.co_argcount
        def new_f(*args, **kwds):
            for (a, t) in zip(args, types):
                assert isinstance(a, t), \
                    "arg %r does not match %s" % (a,t)
            return f(*args, **kwds)
        new_f.func_name = f.func_name
        return new_f
    return check_accepts

def returns(rtype):
    def check_returns(f):
        def new_f(*args, **kwds):
            result = f(*args, **kwds)
            assert isinstance(result, rtype), \
                "return value %r does not match %s" % (result,rtype)
            return result
        new_f.func_name = f.func_name
        return new_f
    return check_returns

@accepts(int, (int,float))
@returns((int,float))
def func(arg1, arg2):
    return arg1 * arg2
</code></pre>
</li>
<li>
<p><strong>클래스가 특정 인터페이스를 구현한다고 선언:</strong> PyProtocols 경험을 기반으로 합니다.</p>
<pre><code class="language-python"># 예시를 위해 PyProtocols의 개념을 간략화함
class Interface: pass
def declareImplementation(typ, instancesProvide): pass

def provides(*interfaces):
    def provides_decorator(typ):
        declareImplementation(typ, instancesProvide=interfaces)
        return typ
    return provides_decorator

class IBar(Interface):
    pass

@provides(IBar)
class Foo(object):
    pass
</code></pre>
</li>
</ul>
<p>물론 이 모든 예시는 문법적 지원 없이도 가능했지만, 데코레이터 문법을 통해 더욱 간결하고 명확하게 표현할 수 있게 되었습니다.</p>
<h2>(더 이상) 열린 문제 ((No longer) Open Issues)</h2>
<p>클래스 데코레이터가 미래에 언어에 통합될지는 확실하지 않았지만, PEP 3129는 Python 2.6부터 클래스 데코레이터를 추가할 것을 제안했습니다. Python 2.4b1 이전에 <code>@</code> 문자 선택이 재검토될 예정이었으나, 결국 <code>@</code> 문자는 유지되었습니다.</p>
<h2>저작권 (Copyright)</h2>
<p>이 문서는 퍼블릭 도메인에 공개되었습니다.</p>
<blockquote>
<p>⚠️ <strong>알림:</strong> 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.</p>
</blockquote>
</div></div><footer class="page__meta mt-8"><div class="page__taxonomy"><h4 class="text-sm font-medium text-gray-900 mb-2">태그</h4><span class="page__taxonomy-item">#<!-- -->Python</span><span class="page__taxonomy-item">#<!-- -->PEP</span><span class="page__taxonomy-item">#<!-- -->Translation</span></div></footer></article></main></div><!--/$--></main><div id="footer" class="page__footer"><footer class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><div class="text-center text-gray-500 text-sm"><p>© 2025 secrett2633. All rights reserved.</p></div></footer></div></div><script src="/_next/static/chunks/webpack-4bcb99d26e8ec64d.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[5751,[],\"\"]\n5:I[9275,[],\"\"]\n7:I[1343,[],\"\"]\n8:I[9157,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"157\",\"static/chunks/157-aecaf5ac7a84facf.js\",\"185\",\"static/chunks/app/layout-c3e2e457f12fb6f6.js\"],\"default\"]\n9:I[231,[\"231\",\"static/chunks/231-c27e618569e042bc.js\",\"931\",\"static/chunks/app/page-e3ea38185bb36cd2.js\"],\"\"]\nb:I[6130,[],\"\"]\n6:[\"slug\",\"python/pep/318\",\"c\"]\nc:[]\n"])</script><script>self.__next_f.push([1,"0:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/da5e1dc2b9a7c5bb.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$L2\",null,{\"buildId\":\"x02Anhkwgp1He7ftuyAhh\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/python/pep/318/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"python/pep/318\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"python\\\",\\\"pep\\\",\\\"318\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"python/pep/318\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\"],null],null]},[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}],null]},[[\"$\",\"html\",null,{\"lang\":\"ko\",\"className\":\"no-js\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"name\":\"msapplication-TileColor\",\"content\":\"#ffc40d\"}],[\"$\",\"meta\",null,{\"name\":\"theme-color\",\"content\":\"#ffffff\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-NE2W3CFPNY\"}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n              window.dataLayer = window.dataLayer || [];\\n              function gtag(){dataLayer.push(arguments);}\\n              gtag('js', new Date());\\n              gtag('config', 'G-NE2W3CFPNY');\\n            \"}}]]}],[\"$\",\"body\",null,{\"className\":\"__className_f367f3 layout--default\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen bg-gray-50\",\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"main\",null,{\"className\":\"initial-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex items-center justify-center bg-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-md w-full bg-white rounded-lg shadow-md p-8 text-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-6xl font-bold text-primary-600 mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-semibold text-gray-900 mb-4\",\"children\":\"페이지를 찾을 수 없습니다\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-600 mb-8\",\"children\":\"요청하신 페이지가 존재하지 않거나 이동되었을 수 있습니다.\"}],[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"inline-flex items-center px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 transition-colors\",\"children\":\"홈으로 돌아가기\"}]]}]}],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"div\",null,{\"id\":\"footer\",\"className\":\"page__footer\",\"children\":[\"$\",\"footer\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center text-gray-500 text-sm\",\"children\":[\"$\",\"p\",null,{\"children\":\"© 2025 secrett2633. All rights reserved.\"}]}]}]}]]}]}]]}],null],[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600\"}]}],[],[]]],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]]\n"])</script><script>self.__next_f.push([1,"d:T45f3,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e원문 링크:\u003c/strong\u003e \u003ca href=\"https://peps.python.org/pep-0318/\"\u003ePEP 318 - Decorators for Functions and Methods\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e상태:\u003c/strong\u003e Final | \u003cstrong\u003e유형:\u003c/strong\u003e Standards Track | \u003cstrong\u003e작성일:\u003c/strong\u003e 05-Jun-2003\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1\u003ePEP 318 – 함수 및 메서드를 위한 데코레이터 (Decorators for Functions and Methods)\u003c/h1\u003e\n\u003ch2\u003e개요 (Abstract)\u003c/h2\u003e\n\u003cp\u003e기존에는 함수나 메서드를 변형(예: \u003ccode\u003eclassmethod\u003c/code\u003e 또는 \u003ccode\u003estaticmethod\u003c/code\u003e로 선언)하는 방식이 복잡하여 코드 이해를 어렵게 만들었습니다. 이상적으로는 이러한 변형이 선언 지점에서 함께 이루어져야 합니다. 이 PEP는 함수 또는 메서드 선언의 변형을 위한 새로운 문법을 제안합니다.\u003c/p\u003e\n\u003ch2\u003e동기 (Motivation)\u003c/h2\u003e\n\u003cp\u003e기존에는 함수나 메서드에 변형을 적용할 때 실제 변형 코드가 함수 본문 뒤에 위치했습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef foo(self):\r\n    # 메서드 작업 수행\r\n    pass\r\nfoo = classmethod(foo)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e메서드의 길이가 길어질수록 이러한 방식은 가독성을 떨어뜨리며, 개념적으로 하나의 선언임에도 함수 이름을 세 번이나 반복하는 것은 Pythonic하지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 문제에 대한 해결책은 메서드 변형을 메서드 선언에 더 가깝게 옮기는 것입니다. 새로운 문법은 다음과 같은 형태를 대체하는 것을 목표로 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef foo(cls):\r\n    pass\r\nfoo = synchronized(lock)(foo)\r\nfoo = classmethod(foo)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래와 같이 데코레이션을 함수의 선언부에 직접 배치하여 코드를 개선합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@classmethod\r\n@synchronized(lock)\r\ndef foo(cls):\r\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e클래스에 대한 데코레이터(Class Decorators)도 가능하지만, 그 이점은 함수/메서드 데코레이터만큼 명확하지 않습니다. 클래스 데코레이터로 할 수 있는 대부분의 작업은 메타클래스(Metaclasses)를 통해 가능하지만, 메타클래스는 다소 난해하므로 클래스에 간단한 수정을 가하는 더 쉬운 방법의 매력이 있습니다. Python 2.4에서는 함수/메서드 데코레이터만 추가되었습니다. PEP 3129는 Python 2.6부터 클래스 데코레이터를 추가할 것을 제안합니다.\u003c/p\u003e\n\u003ch3\u003e왜 이렇게 어려웠을까? (Why Is This So Hard?)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eclassmethod()\u003c/code\u003e와 \u003ccode\u003estaticmethod()\u003c/code\u003e 두 데코레이터는 Python 2.2부터 사용할 수 있었고, 언어에 문법적 지원이 추가될 것이라는 가정이 있었습니다. 하지만 합의에 도달하기 어려웠던 몇 가지 이유가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e'의도 선언' 위치에 대한 불일치:\u003c/strong\u003e 함수 정의 끝에 데코레이터를 적용하는 것이 최적은 아니라는 데는 모두 동의하지만, 어디에 정보를 배치할지에 대한 명확한 합의가 없었습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e문법적 제약:\u003c/strong\u003e Python은 시각적으로나 파서(parser) 측면에서 '일을 망치지 않고' 할 수 있는 일에 강한 제약을 가진 문법적으로 간단한 언어입니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e개념에 대한 전반적인 생소함:\u003c/strong\u003e 데코레이터 개념은 Python에서 접하기 전에는 많은 프로그래머에게 생소한 개념이었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e배경 (Background)\u003c/h2\u003e\n\u003cp\u003e현재의 상황에서 문법적 지원이 바람직하다는 것이 일반적인 합의였습니다. Guido van Rossum은 EuroPython 2004에서 여러 제안을 논의한 후, Java 스타일의 \u003ccode\u003e@decorator\u003c/code\u003e 문법을 선택했으며, 이는 Python 2.4a2에 처음으로 등장했습니다. Barry Warsaw는 이를 \u003ccode\u003e@\u003c/code\u003e 기호가 파이(pie)처럼 보여 '파이 데코레이터(pie-decorator)' 문법이라고 이름 붙였습니다.\u003c/p\u003e\n\u003ch3\u003e'Decorator'라는 이름에 대하여 (On the name 'Decorator')\u003c/h3\u003e\n\u003cp\u003e이 기능에 'decorator'라는 이름을 선택한 것에 대해 여러 불만이 제기되었습니다. 가장 큰 이유는 GoF(Gang of Four) 디자인 패턴 책에서의 사용과 일치하지 않는다는 것입니다. 'decorator'라는 이름은 컴파일러 분야에서 문법 트리를 탐색하고 주석을 다는 방식에서 영향을 받은 것으로 보이며, 더 좋은 이름이 나올 가능성도 있습니다.\u003c/p\u003e\n\u003ch2\u003e설계 목표 (Design Goals)\u003c/h2\u003e\n\u003cp\u003e새로운 문법은 다음을 목표로 해야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자 정의 호출 가능 객체(\u003ccode\u003ecallables\u003c/code\u003e) 및 기존의 \u003ccode\u003eclassmethod()\u003c/code\u003e, \u003ccode\u003estaticmethod()\u003c/code\u003e를 포함한 \u003cstrong\u003e임의의 래퍼(wrappers)에 작동\u003c/strong\u003e해야 합니다. 이는 데코레이터 문법이 래퍼 생성자(wrapper constructor)에 인자를 전달하는 것을 지원해야 함을 의미합니다.\u003c/li\u003e\n\u003cli\u003e하나의 정의에 \u003cstrong\u003e여러 래퍼와 함께 작동\u003c/strong\u003e해야 합니다.\u003c/li\u003e\n\u003cli\u003e무슨 일이 일어나는지 \u003cstrong\u003e명확하게\u003c/strong\u003e 보여야 합니다. 적어도 새로운 사용자가 자신의 코드를 작성할 때 안전하게 무시할 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e한 번 설명되면 \u003cstrong\u003e기억하기 쉬운 문법\u003c/strong\u003e이어야 합니다.\u003c/li\u003e\n\u003cli\u003e향후 확장을 \u003cstrong\u003e어렵게 만들지 않아야\u003c/strong\u003e 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e입력하기 쉬워야\u003c/strong\u003e 합니다. 이 기능을 사용하는 프로그램은 매우 자주 사용할 것으로 예상됩니다.\u003c/li\u003e\n\u003cli\u003e코드를 빠르게 스캔하는 것을 \u003cstrong\u003e어렵게 만들지 않아야\u003c/strong\u003e 합니다.\u003c/li\u003e\n\u003cli\u003e언어 인식 편집기(language-sensitive editors)와 같은 보조 지원 도구를 \u003cstrong\u003e불필요하게 복잡하게 만들지 않아야\u003c/strong\u003e 합니다.\u003c/li\u003e\n\u003cli\u003e미래 컴파일러가 데코레이터를 \u003cstrong\u003e최적화할 수 있도록 허용\u003c/strong\u003e해야 합니다.\u003c/li\u003e\n\u003cli\u003e함수 정의의 끝에 숨겨져 있던 것을 \u003cstrong\u003e앞으로 옮겨서 더 눈에 띄게\u003c/strong\u003e 해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e현재 문법 (Current Syntax)\u003c/h2\u003e\n\u003cp\u003ePython 2.4a2에 구현된 함수 데코레이터의 현재 문법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@dec2\r\n@dec1\r\ndef func(arg1, arg2, ...):\r\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 중간 변수 \u003ccode\u003efunc\u003c/code\u003e에 대한 할당 없이 다음 코드와 동일합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef func(arg1, arg2, ...):\r\n    pass\r\nfunc = dec2(dec1(func))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데코레이터는 함수 선언 근처에 있습니다. \u003ccode\u003e@\u003c/code\u003e 기호는 새로운 일이 진행되고 있음을 명확히 합니다.\r\n적용 순서(아래에서 위로)는 함수 적용의 일반적인 순서와 일치하는 것을 근거로 합니다. 수학에서 함수 합성 \u003ccode\u003e(g o f)(x)\u003c/code\u003e는 \u003ccode\u003eg(f(x))\u003c/code\u003e로 번역됩니다. Python에서 \u003ccode\u003e@g @f def foo()\u003c/code\u003e는 \u003ccode\u003efoo=g(f(foo))\u003c/code\u003e로 번역됩니다.\u003c/p\u003e\n\u003cp\u003e현재 문법은 데코레이터 선언이 데코레이터를 반환하는 함수를 호출하는 것도 허용합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@decomaker(argA, argB, ...)\r\ndef func(arg1, arg2, ...):\r\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 다음 코드와 동일합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efunc = decomaker(argA, argB, ...)(func)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데코레이터를 반환하는 함수를 허용하는 근거는 \u003ccode\u003e@\u003c/code\u003e 기호 뒤의 부분이 표현식으로 간주될 수 있으며(문법적으로는 함수로 제한되지만), 그 표현식이 반환하는 것이 호출되기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e문법 대안 (Syntax Alternatives)\u003c/h2\u003e\n\u003cp\u003e많은 다른 문법이 제안되었으며, 이를 개별적으로 논의하기보다는 문법 논의를 여러 영역으로 나누는 것이 가치가 있습니다.\u003c/p\u003e\n\u003ch3\u003e데코레이터 위치 (Decorator Location)\u003c/h3\u003e\n\u003cp\u003e데코레이터의 첫 번째 문법적 쟁점은 위치입니다. Python 2.4a2에서 사용된 \u003ccode\u003e@\u003c/code\u003e 문법을 기준으로 합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003edef\u003c/code\u003e 문 앞:\u003c/strong\u003e 2.4a2에서 사용된 문법입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@classmethod\r\ndef foo(arg1,arg2): pass\r\n\r\n@accepts(int,int)\r\n@returns(float)\r\ndef bar(low,high): pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 위치에 대한 주요 반대는 Python에서 한 줄의 코드가 다음 줄에 영향을 미치는 첫 번째 실제 사례라는 점입니다. 최종적으로 Python 2.4에서는 한 줄에 하나의 데코레이터만 허용하도록 결정되었습니다. 장점으로는 데코레이터가 메서드 본문 밖에 존재하여 함수가 정의될 때 명확히 실행된다는 점과, 함수 정의 전에 코드의 의미론적 변화를 알 수 있다는 점이 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003edef\u003c/code\u003e와 함수 이름 사이 또는 함수 이름과 인자 목록 사이:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef @classmethod foo(arg1,arg2): pass\r\ndef foo @classmethod (arg1,arg2): pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 형식의 문제점은 소스 코드의 'greppability'를 깨뜨리고, 여러 데코레이터의 경우 문법이 매우 복잡해진다는 점입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e인자 목록과 \u003ccode\u003e:\u003c/code\u003e 사이:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef foo(arg1,arg2) @classmethod: pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGuido는 이 형식이 중요한 정보(예: \u003ccode\u003estaticmethod\u003c/code\u003e 여부)를 시그니처 뒤에 숨겨 쉽게 놓칠 수 있고, 긴 인자 목록과 긴 데코레이터 목록 사이의 전환을 놓치기 쉬우며, 데코레이터 목록을 재사용하기 위해 잘라내기/붙여넣기(cut and paste)하기 번거롭다는 이유로 반대했습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e메서드 본문 시작 부분:\u003c/strong\u003e \u003ccode\u003edocstrings\u003c/code\u003e가 위치하는 곳과 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef foo(arg1,arg2):\r\n    @classmethod\r\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 형식의 주요 반대는 데코레이터를 결정하기 위해 메서드 본문 \"안을 들여다봐야\" 한다는 점입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e메서드 코드를 감싸는 새로운 블록:\u003c/strong\u003e \u003ccode\u003edecorate\u003c/code\u003e 키워드를 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edecorate: classmethod\r\ndef foo(arg1,arg2): pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 형식은 데코레이트된 메서드와 그렇지 않은 메서드에 대해 일관되지 않은 들여쓰기를 초래하며, 데코레이트된 메서드의 본문이 세 단계 들여쓰기로 시작하게 됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e문법 형식 (Syntax forms)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e@decorator\u003c/code\u003e:\u003c/strong\u003e \u003ccode\u003e@\u003c/code\u003e 기호가 Python에서 이전에 사용되지 않았고, Java 1.5의 어노테이션(annotations)과 유사하다는 점이 장점입니다. 이는 이전 버전의 Python에 의해 파싱될 가능성이 없어 미묘한 의미론적 버그로 이어지지 않는다는 것을 의미합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e|decorator\u003c/code\u003e:\u003c/strong\u003e \u003ccode\u003e@\u003c/code\u003e 데코레이터 문법의 변형으로, IPython 및 Leo와 충돌하지 않는다는 장점이 있지만, \u003ccode\u003e|\u003c/code\u003e 기호가 대문자 'I'와 소문자 'l'처럼 보인다는 단점이 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003elist syntax\u003c/code\u003e (\u003ccode\u003e[...]\u003c/code\u003e 또는 \u003ccode\u003e\u0026#x3C;...\u003e\u003c/code\u003e)\u003c/strong\u003e: 대괄호는 현재 의미가 있으며, 데코레이터라는 표시가 부족하다는 반대가 있었습니다. 꺾쇠 괄호는 파싱 문제를 일으킵니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003edecorate()\u003c/code\u003e 함수:\u003c/strong\u003e 새로운 문법을 구현하지 않고, 함수를 조작하는 \u003ccode\u003emagic function\u003c/code\u003e을 사용하는 제안입니다. Guido는 새로운 문법이 없다면 이러한 함수의 '마법성'이 매우 높기 때문에 단호히 반대했습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e새로운 키워드 (및 블록):\u003c/strong\u003e \u003ccode\u003eusing\u003c/code\u003e 키워드를 사용하는 블록 형식이 \u003ccode\u003ecomp.lang.python\u003c/code\u003e에서 합의된 대안이었습니다. Guido는 블록의 문법적 형태가 문장 시퀀스를 강하게 제안하지만 실제로는 그렇지 않다는 점과 \u003ccode\u003eusing\u003c/code\u003e 키워드가 \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003ewhile\u003c/code\u003e 등과 같은 수준의 관심을 받을 자격이 없다는 이유로 이 제안을 거부했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e왜 \u003ccode\u003e@\u003c/code\u003e인가? (Why @?)\u003c/h3\u003e\n\u003cp\u003eJava에서 \u003ccode\u003e@\u003c/code\u003e는 처음에는 Javadoc 주석의 마커로, 나중에는 Java 1.5에서 Python 데코레이터와 유사한 어노테이션에 사용되었습니다. \u003ccode\u003e@\u003c/code\u003e가 Python에서 이전에 토큰으로 사용되지 않았다는 사실은 이러한 코드가 이전 버전의 Python에 의해 파싱될 가능성이 없어 미묘한 의미론적 버그로 이어지지 않는다는 것을 의미합니다. 또한 무엇이 데코레이터이고 무엇이 아닌지에 대한 모호성을 제거합니다.\u003c/p\u003e\n\u003ch2\u003e현재 구현 및 역사 (Current Implementation, History)\u003c/h2\u003e\n\u003cp\u003eGuido는 자신이 선호하는 문법을 구현할 자원자를 요청했고, Mark Russell이 패치를 게시했습니다. 이 새로운 문법은 Python 2.4a2에서 사용할 수 있게 되었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e@dec2\r\n@dec1\r\ndef func(arg1, arg2, ...):\r\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 중간 변수 \u003ccode\u003efunc\u003c/code\u003e의 생성 없이 다음 코드와 동일합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef func(arg1, arg2, ...):\r\n    pass\r\nfunc = dec2(dec1(func))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e2.4a2에 구현된 버전은 한 줄에 여러 \u003ccode\u003e@decorator\u003c/code\u003e 절을 허용했지만, 2.4a3에서는 한 줄에 하나의 데코레이터만 허용하도록 강화되었습니다. 결국 \u003ccode\u003e@\u003c/code\u003e 문자는 유지되었습니다.\u003c/p\u003e\n\u003ch2\u003e예시 (Examples)\u003c/h2\u003e\n\u003cp\u003e데코레이터는 \u003ccode\u003estaticmethod()\u003c/code\u003e 및 \u003ccode\u003eclassmethod()\u003c/code\u003e와 같은 내장 함수를 더 깔끔하게 사용하는 것 이상의 강력한 기능을 제공합니다. 다음은 몇 가지 사용 예시입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e종료 시 실행될 함수 정의:\u003c/strong\u003e \u003ccode\u003eatexit\u003c/code\u003e 모듈을 사용하여 함수를 등록합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef onexit(f):\r\n    import atexit\r\n    atexit.register(f)\r\n    return f\r\n\r\n@onexit\r\ndef func():\r\n    print(\"프로그램 종료 시 실행됩니다.\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e싱글턴(Singleton) 인스턴스를 가진 클래스 정의:\u003c/strong\u003e 클래스의 유일한 인스턴스를 보장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef singleton(cls):\r\n    instances = {}\r\n    def getinstance():\r\n        if cls not in instances:\r\n            instances[cls] = cls()\r\n        return instances[cls]\r\n    return getinstance\r\n\r\n@singleton\r\nclass MyClass:\r\n    def __init__(self):\r\n        print(\"MyClass 인스턴스 생성\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e함수에 속성 추가:\u003c/strong\u003e 함수에 메타데이터를 추가할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef attrs(**kwds):\r\n    def decorate(f):\r\n        for k in kwds:\r\n            setattr(f, k, kwds[k])\r\n        return f\r\n    return decorate\r\n\r\n@attrs(versionadded=\"2.2\", author=\"Guido van Rossum\")\r\ndef mymethod():\r\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e함수 인자 및 반환 타입 강제:\u003c/strong\u003e 함수의 인자 및 반환 타입을 검사합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef accepts(*types):\r\n    def check_accepts(f):\r\n        assert len(types) == f.func_code.co_argcount\r\n        def new_f(*args, **kwds):\r\n            for (a, t) in zip(args, types):\r\n                assert isinstance(a, t), \\\r\n                    \"arg %r does not match %s\" % (a,t)\r\n            return f(*args, **kwds)\r\n        new_f.func_name = f.func_name\r\n        return new_f\r\n    return check_accepts\r\n\r\ndef returns(rtype):\r\n    def check_returns(f):\r\n        def new_f(*args, **kwds):\r\n            result = f(*args, **kwds)\r\n            assert isinstance(result, rtype), \\\r\n                \"return value %r does not match %s\" % (result,rtype)\r\n            return result\r\n        new_f.func_name = f.func_name\r\n        return new_f\r\n    return check_returns\r\n\r\n@accepts(int, (int,float))\r\n@returns((int,float))\r\ndef func(arg1, arg2):\r\n    return arg1 * arg2\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e클래스가 특정 인터페이스를 구현한다고 선언:\u003c/strong\u003e PyProtocols 경험을 기반으로 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 예시를 위해 PyProtocols의 개념을 간략화함\r\nclass Interface: pass\r\ndef declareImplementation(typ, instancesProvide): pass\r\n\r\ndef provides(*interfaces):\r\n    def provides_decorator(typ):\r\n        declareImplementation(typ, instancesProvide=interfaces)\r\n        return typ\r\n    return provides_decorator\r\n\r\nclass IBar(Interface):\r\n    pass\r\n\r\n@provides(IBar)\r\nclass Foo(object):\r\n    pass\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e물론 이 모든 예시는 문법적 지원 없이도 가능했지만, 데코레이터 문법을 통해 더욱 간결하고 명확하게 표현할 수 있게 되었습니다.\u003c/p\u003e\n\u003ch2\u003e(더 이상) 열린 문제 ((No longer) Open Issues)\u003c/h2\u003e\n\u003cp\u003e클래스 데코레이터가 미래에 언어에 통합될지는 확실하지 않았지만, PEP 3129는 Python 2.6부터 클래스 데코레이터를 추가할 것을 제안했습니다. Python 2.4b1 이전에 \u003ccode\u003e@\u003c/code\u003e 문자 선택이 재검토될 예정이었으나, 결국 \u003ccode\u003e@\u003c/code\u003e 문자는 유지되었습니다.\u003c/p\u003e\n\u003ch2\u003e저작권 (Copyright)\u003c/h2\u003e\n\u003cp\u003e이 문서는 퍼블릭 도메인에 공개되었습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e알림:\u003c/strong\u003e 이 문서는 AI를 활용하여 번역되었으며, 기술적 정확성을 보장하지 않습니다. 정확한 내용은 반드시 원문을 확인하시기 바랍니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"aside\",null,{\"className\":\"lg:w-64 xl:w-72 order-1 lg:order-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sidebar sticky\",\"children\":[\"$\",\"nav\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"div\",\"Backend\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Backend\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Django\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/django/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Django\",\" (\",6,\")\"]}]}],[\"$\",\"li\",\"Logging\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/backend/logging/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Logging\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"Python\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"Python\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"PEP\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/python/pep/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"PEP\",\" (\",650,\")\"]}]}]]}]]}],[\"$\",\"div\",\"AI/ML\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"AI/ML\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"LLM\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/llm/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"LLM\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Review\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/ai/review/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Review\",\" (\",1025,\")\"]}]}]]}]]}],[\"$\",\"div\",\"DevOps\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"DevOps\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Nginx\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/nginx/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Nginx\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Docker\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/docker/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Docker\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"SafeLine\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/safeline/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"SafeLine\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"Jenkins\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/jenkins/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Jenkins\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"GitHub Actions\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/github-actions/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"GitHub Actions\",\" (\",1,\")\"]}]}],[\"$\",\"li\",\"AWS\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/devops/aws/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"AWS\",\" (\",1,\")\"]}]}]]}]]}],[\"$\",\"div\",\"etc\",{\"children\":[[\"$\",\"h4\",null,{\"className\":\"font-medium text-gray-900 mb-2\",\"children\":\"etc\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-1 ml-4\",\"children\":[[\"$\",\"li\",\"Me\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/me/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Me\",\" (\",3,\")\"]}]}],[\"$\",\"li\",\"Chrome Extension\",{\"children\":[\"$\",\"a\",null,{\"href\":\"/etc/chrome-extension/\",\"className\":\"text-sm text-gray-600 hover:text-primary-600 block py-1\",\"children\":[\"Chrome Extension\",\" (\",1,\")\"]}]}]]}]]}]]}]}]}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"article\",null,{\"className\":\"page\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"page__title\",\"children\":\"[Final] PEP 318 - Decorators for Functions and Methods\"}],[\"$\",\"div\",null,{\"className\":\"page__meta\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-09-26 18:28:53+0900\",\"children\":\"2025년 9월 26일\"}],[\"$\",\"span\",null,{\"className\":\"ml-4\",\"children\":[\"수정: \",\"2025년 9월 26일\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"page__content\",\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}],[\"$\",\"footer\",null,{\"className\":\"page__meta mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"page__taxonomy\",\"children\":[[\"$\",\"h4\",null,{\"className\":\"text-sm font-medium text-gray-900 mb-2\",\"children\":\"태그\"}],[[\"$\",\"span\",\"Python\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Python\"]}],[\"$\",\"span\",\"PEP\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"PEP\"]}],[\"$\",\"span\",\"Translation\",{\"className\":\"page__taxonomy-item\",\"children\":[\"#\",\"Translation\"]}]]]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"Django, Python, DevOps, AI, ML, 블로그, 기술\"}],[\"$\",\"meta\",\"6\",{\"name\":\"creator\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"7\",{\"name\":\"publisher\",\"content\":\"secrett2633\"}],[\"$\",\"meta\",\"8\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"9\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"link\",\"10\",{\"rel\":\"canonical\",\"href\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"11\",{\"name\":\"format-detection\",\"content\":\"telephone=no, address=no, email=no\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:url\",\"content\":\"https://secrett2633.github.io/\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:site_name\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:locale\",\"content\":\"ko_KR\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:title\",\"content\":\"secrett2633's blog\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:description\",\"content\":\"기술 블로그 - Django, Python, DevOps, AI/ML 관련 포스트\"}],[\"$\",\"link\",\"21\",{\"rel\":\"icon\",\"href\":\"/icon.ico?6d9f34d4948640b8\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n3:null\n"])</script></body></html>